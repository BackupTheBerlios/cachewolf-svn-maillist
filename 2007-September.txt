From mik77 at mail.berlios.de  Sat Sep  1 14:31:59 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sat, 1 Sep 2007 14:31:59 +0200
Subject: [Cachewolf-svn] r858 - in trunk: resources src/CacheWolf
Message-ID: <200709011231.l81CVxPX018920@sheep.berlios.de>

Author: mik77
Date: 2007-09-01 14:31:52 +0200 (Sat, 01 Sep 2007)
New Revision: 858

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/resources/rose.png
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MovingMap.java
Log:
first step of GotoPanel redesign


Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-08-30 22:11:44 UTC (rev 857)
+++ trunk/resources/cachewolf.Languages.cfg	2007-09-01 12:31:52 UTC (rev 858)
@@ -299,6 +299,7 @@
 		1406=Koordinaten in beliebigem Format oder GCxxxx
 		1500=Ziel:
 		1501=Aktuell
+		1502=Grad
 		1600=Opencahing.de Download
 		1601=max. Abstand:
 		1602=Bilder downloaden
@@ -844,6 +845,7 @@
 		1406=Enter coordinates in any format or GCxxxx
 		1500=DST:
 		1501=Current
+		1502=deg
 		1600=Opencahing.de Download
 		1601=Distance:
 		1602=Download Images

Modified: trunk/resources/rose.png
===================================================================
(Binary files differ)

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-08-30 22:11:44 UTC (rev 857)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-09-01 12:31:52 UTC (rev 858)
@@ -13,8 +13,6 @@
 import ewe.sys.*;
 import ewe.sys.Double;
 
-
-
 /**
  *	Class to create the panel which handles the connection to the GPS-device<br>
  *	Displays: current position,speed and bearing; relation to destination waypoint<br>
@@ -31,10 +29,9 @@
 	mButton btnGoto, btnMap;
 	int currFormat;
 
-	mLabel lblPosition, lblSats, lblSpeed, lblBearMov, lblBearWayP, lblDist, lblHDOP;
-	mLabel lblSatsText, lblSpeedText, lblDirText, lblDistText, lblSunAzimut;
-	mLabel lblGPS, lblDST, lblCurr, lblWayP, lblLuminary;
+	mLabel lblGPS, lblPosition, lblDST;
 	mLabel lblLog;
+	Color gpsStatus;
 	mCheckBox chkLog;
 	mInput inpLogSeconds;
 
@@ -48,7 +45,6 @@
 	CellPanel ButtonP = new CellPanel();
 	CellPanel CoordsP = new CellPanel();
 	CellPanel roseP = new CellPanel();
-	CellPanel GotoP = new CellPanel();
 	CellPanel LogP = new CellPanel();
 
 	ImageControl icRose;
@@ -61,7 +57,6 @@
 
 	final static Font BOLD = new Font("Arial", Font.BOLD, 14);
 
-	GotoRose rose;
 	int ticker = 0;
 	
 	Menu mnuContextFormt;
@@ -132,37 +127,7 @@
 		icRose.modifyAll(Control.WantHoldDown, 0); // this is necessary in order to make PenHold on a PDA work as right click
 		roseP.addLast(icRose,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTH));
 
-		//Goto
-		//things from GPS
-		GotoP.addLast(lblCurr = new mLabel(MyLocale.getMsg(1501,"Current")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		lblCurr.backGround = RED;
-		lblCurr.font = BOLD;
-
-		//GotoP.addNext(lblSatsText = new mLabel("Sats: "),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		//lblSatsText.font = BOLD;
-		GotoP.addLast(lblSats = new mLabel("Sats:    " + Convert.toString(myNavigation.gpsPos.getSats())),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		lblSats.font = BOLD;
-		GotoP.addLast(lblHDOP = new mLabel("HDOP:    " + Convert.toString(myNavigation.gpsPos.getHDOP())),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		lblHDOP.font = BOLD;
-
-
-		GotoP.addLast(lblSpeed = new mLabel(Convert.toString(myNavigation.gpsPos.getSpeed())),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		lblSpeed.font = BOLD;
-
-		GotoP.addLast(lblBearMov = new mLabel("0"),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		lblBearMov.font = BOLD;
-
-		//things about destination
-		GotoP.addLast(lblWayP = new mLabel("WayPoint"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		lblWayP.backGround = Color.DarkBlue;
-		lblWayP.foreGround = Color.White;
-		lblWayP.font = BOLD;
-		GotoP.addLast(lblBearWayP = new mLabel("0"),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		lblBearWayP.font = BOLD;
-
-		GotoP.addLast(lblDist = new mLabel("0"),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		lblDist.font = BOLD;
-
+		//log
 		LogP.addNext(lblLog = new mLabel("Log "),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		LogP.addNext(chkLog = new mCheckBox(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		LogP.addNext(inpLogSeconds = new mInput("10"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
@@ -172,20 +137,10 @@
 		chkLog.setState(false);
 		inpLogSeconds.columns = 5;
 
-		LogP.addNext(lblLuminary = new mLabel(SkyOrientation.getLuminaryName(myNavigation.luminary)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		lblLuminary.backGround = YELLOW;
-		lblLuminary.setTag(SPAN, new Dimension(2,1));
-
-		LogP.addLast(lblSunAzimut = new mLabel("---"),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.NORTH));
-		lblSunAzimut.setText("---");
-		lblSunAzimut.font = BOLD;
-
-
 		//add Panels
 		this.addLast(ButtonP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
 		this.addLast(CoordsP,CellConstants.HSTRETCH, CellConstants.HFILL|CellConstants.NORTH).setTag(SPAN,new Dimension(2,1));
-		this.addNext(roseP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(1,1));
-		this.addLast(GotoP,CellConstants.HSTRETCH, CellConstants.HFILL|CellConstants.NORTHWEST).setTag(SPAN,new Dimension(1,2));
+		this.addLast(roseP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
 		this.addLast(LogP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.NORTHWEST).setTag(SPAN,new Dimension(1,1));
 
 		// for debuging
@@ -251,24 +206,11 @@
 	
 	public void updateDistance() {
 		//update distance
-		Double tmp = new Double();
+		float distance = -1.0f;
 		if (myNavigation.gpsPos.isValid() && myNavigation.destination.isValid() ) {
-			tmp.set(myNavigation.gpsPos.getDistance(myNavigation.destination)); // TODO distance in navigate.java berechnen
-			if (tmp.value >= 1){
-				lblDist.setText(MyLocale.formatDouble(tmp,"0.000")+ " km");
-			}
-			else {
-				tmp.set(tmp.value * 1000);
-				lblDist.setText(tmp.toString(3,0,0) + " m");
-			}
+			distance = (float)myNavigation.gpsPos.getDistance(myNavigation.destination);
 		}
-		else lblDist.setText("--- km");
-		// update goto-bearing
-		tmp.set(myNavigation.gpsPos.getBearing(myNavigation.destination));
-		if (tmp.value <= 360) 
-			lblBearWayP.setText(tmp.toString(0,0,0) + " Grad");
-		else lblBearWayP.setText("---" + " Grad");
-		compassRose.setWaypointDirection((float)tmp.value);
+		compassRose.setWaypointDirectionDist((float)myNavigation.gpsPos.getBearing(myNavigation.destination), distance);
 	}
 
 	/**
@@ -279,39 +221,32 @@
 		Double speed = new Double();
 		Double sunAzimut = new Double();
 		Vm.debug("ticked: voher");
-		lblSats.setText("Sats: " + Convert.toString(myNavigation.gpsPos.getSats()));
-		lblHDOP.setText("HDOP: " + Convert.toString(myNavigation.gpsPos.getHDOP()));
+		compassRose.setGpsStatus(fix, myNavigation.gpsPos.getSats(), myNavigation.gpsPos.getHDOP());
 		if ((fix > 0) && (myNavigation.gpsPos.getSats()>= 0)) {
 			// display values only, if signal good
 			//Vm.debug("currTrack.add: nachher");
 			lblPosition.setText(myNavigation.gpsPos.toString(currFormat));
-			speed.set(myNavigation.gpsPos.getSpeed());
-			lblSpeed.setText(MyLocale.formatDouble(speed,"0.0") + " km/h");
 			sunAzimut.set(myNavigation.skyOrientationDir.lonDec);
-			if (sunAzimut.value >= -360) lblSunAzimut.setText(MyLocale.formatDouble(sunAzimut,"0.0") + " Grad");
-			else lblSunAzimut.setText("--- Grad");
 			bearMov.set(myNavigation.gpsPos.getBear());
-			lblBearMov.setText(bearMov.toString(0,0,0) + " Grad");
-			compassRose.setSunMoveDirections((float)sunAzimut.value, (float)bearMov.value);
 			updateDistance();
+			compassRose.setSunMoveDirections((float)sunAzimut.value, (float)bearMov.value, (float)speed.value);
 			// Set background to signal quality
-			lblSats.backGround = GREEN;
 		}
 
 		// receiving data, but signal ist not good
 		if ((fix == 0) && (myNavigation.gpsPos.getSats()>= 0)) {
-			lblSats.backGround = YELLOW;
+			gpsStatus = YELLOW;
 		}
 		// receiving no data
 		if (fix == -1) {
-			if (lblSats.backGround != RED) (new MessageBox("Error", "No data from GPS\nConnection to serial port closed",MessageBox.OKB)).exec();
-			lblSats.backGround = RED;
+			if (gpsStatus != RED) (new MessageBox("Error", "No data from GPS\nConnection to serial port closed",MessageBox.OKB)).exec();
+			gpsStatus = RED;
 			myNavigation.stopGps();
 		}
 		// cannot interprete data
 		if (fix == -2) {
-			if (lblSats.backGround != RED) (new MessageBox("Error", "Cannot interpret data from GPS\n possible reasons:\n wrong Port,\n wrong Baudrate,\n not NMEA-Protocol\nConnection to serial port closed\nLast String tried to interprete:\n "+myNavigation.gpsPos.lastStrExamined, MessageBox.OKB)).exec();
-			lblSats.backGround = RED;
+			if (gpsStatus != RED) (new MessageBox("Error", "Cannot interpret data from GPS\n possible reasons:\n wrong Port,\n wrong Baudrate,\n not NMEA-Protocol\nConnection to serial port closed\nLast String tried to interprete:\n "+myNavigation.gpsPos.lastStrExamined, MessageBox.OKB)).exec();
+			gpsStatus = RED;
 			myNavigation.stopGps(); // TODO automatic in myNavigate?
 		}
 	}
@@ -328,7 +263,7 @@
 
 	public void gpsStoped() {
 		btnGPS.setText("Start");
-		lblSats.backGround = this.backGround;
+		gpsStatus = this.backGround;
 		chkLog.modify(0,ControlConstants.Disabled);
 		this.repaintNow(); // without this the change in the background color will not be displayed
 	}
@@ -396,7 +331,7 @@
 						if (action == miLuminary[i]) {
 							myNavigation.setLuminary(i);
 							miLuminary[i].modifiers |= MenuItem.Checked;
-							lblLuminary.setText(SkyOrientation.getLuminaryName(myNavigation.luminary));
+							compassRose.setLuminaryName(SkyOrientation.getLuminaryName(myNavigation.luminary));
 						} else miLuminary[i].modifiers &= ~MenuItem.Checked;
 					}
 				}
@@ -448,7 +383,17 @@
 	float gotoDir = -361;
 	float sunDir = -361;
 	float moveDir = -361;
+	float distance = -1;
 	
+	int m_fix = -1;
+	int m_sats = -1;
+	double m_hdop = -1;
+	float m_speed = -1;
+	
+	String m_Luminary = MyLocale.getMsg(6100, "Sun");
+	
+	FontMetrics fm;
+	
 	final static Color RED = new Color(255,0,0);
 	final static Color YELLOW = new Color(255,255,0);
 	final static Color GREEN = new Color(0,255,0);
@@ -465,16 +410,31 @@
 		super(fn);
 	}
 	
-	public void setWaypointDirection(float wd) {
+	public void setWaypointDirectionDist(float wd, float dist) {
 		gotoDir = wd;
+		distance = dist;
 	}
 	
-	public void setSunMoveDirections(float sd, float md ) {
+	public void setSunMoveDirections(float sd, float md, float speed ) {
 		sunDir = sd;
 		moveDir = md;
+		m_speed = speed;
 		refresh();
 	}
 	
+	public void setGpsStatus(int fix, int sats, double hdop) {
+		m_fix = fix;
+		m_sats = sats;
+		m_hdop = hdop;
+		refresh();
+	}
+	
+	public void setLuminaryName(String Luminary) {
+		m_Luminary = Luminary;
+		refresh();
+	}
+
+	
 	/**
 	 * draw arrows for the directions of movement and destination waypoint
 	 * @param ctrl the control to paint on
@@ -484,9 +444,130 @@
 	
 	public void doDraw(Graphics g,int options) {
 		super.doDraw(g, options);
+		Font font = new Font("Verdana", Font.BOLD, 12);
+		g.setFont(font);
+		fm = g.getFontMetrics(font);
 		drawArrows(g);
+		drawWayPointData(g);
+		drawGpsData(g);
+		drawLuminaryData(g);
+		drawGpsStatus(g);
 	}
+		
+	private void drawWayPointData(Graphics g){
+		String strTemp = "WayPoint";
+		g.setColor(Color.DarkBlue);
+		g.fillRect(0, 0, fm.getTextWidth(strTemp) + 4 ,fm.getHeight());
+		g.setColor(Color.White);		
+		g.drawText(strTemp, 2, 0);
+		
+		g.setColor(Color.Black);		
+		
+		Double tmp = new Double();
+		strTemp = "";
+		if ( distance >= 0.0f ) {
+			tmp.set(distance);
+			if (tmp.value >= 1){
+				strTemp = MyLocale.formatDouble(tmp,"0.000")+ " km";
+			}
+			else {
+				tmp.set(tmp.value * 1000);
+				strTemp = tmp.toString(3,0,0) + " m";
+			}
+		}
+		else strTemp = "--- km";
+		g.drawText(strTemp, 2, 12);
+		
+		tmp.set(gotoDir);
+		if ((tmp.value <= 360) && (tmp.value >= -360))
+			strTemp = tmp.toString(0,0,0) + " " + MyLocale.getMsg(1502,"deg");
+		else strTemp = "---" + " " + MyLocale.getMsg(1502,"deg");
+		g.drawText(strTemp, 2, 24);
+	}
+	
+	private void drawGpsData(Graphics g){
+		g.setColor(RED);
+		
+		String strHeadline = MyLocale.getMsg(1501,"Current");
+		
+		Double tmp = new Double();
 
+		tmp.set(m_speed);
+		String strSpeed = "- km/h";
+		if (m_speed >= 0) {
+			if (m_speed >= 100) {
+				strSpeed = MyLocale.formatDouble(tmp,"0") + " km/h";				
+			}
+			else {
+				strSpeed = MyLocale.formatDouble(tmp,"0.0") + " km/h";
+			}
+		}
+		
+		tmp.set(moveDir);
+		String strMoveDir = "---" + " " + MyLocale.getMsg(1502,"deg");
+		if ((tmp.value <= 360) && (tmp.value >= -360))
+			strMoveDir = tmp.toString(0,0,0) + " " + MyLocale.getMsg(1502,"deg");
+
+		int textWidth = java.lang.Math.max(fm.getTextWidth(strSpeed), fm.getTextWidth(strMoveDir));
+		textWidth = java.lang.Math.max(textWidth, fm.getTextWidth(strHeadline));
+		
+		int startX = location.width - (textWidth + 4);
+		g.fillRect(startX, 0, location.width - startX ,12);
+		
+		g.setColor(Color.Black);		
+		g.drawText(strHeadline, startX + 2, 0);		
+		g.drawText(strSpeed, startX + 2, 12);
+		g.drawText(strMoveDir, startX + 2, 24);
+	}
+	
+	private void drawLuminaryData(Graphics g){
+		g.setColor(YELLOW);
+
+		String strSunDir = "---" + " " + MyLocale.getMsg(1502,"deg");
+		if (sunDir < 360 && sunDir > -360) {
+			Double tmp = new Double();
+			tmp.set(sunDir);
+			strSunDir = tmp.toString(0,0,0) + " " + MyLocale.getMsg(1502,"deg");
+		}
+
+		int textWidth = java.lang.Math.max(fm.getTextWidth(m_Luminary), fm.getTextWidth(strSunDir));
+		int startY = location.height - 24;
+		g.fillRect(0, startY, textWidth + 4, location.height - startY);
+
+		g.setColor(Color.Black);		
+		g.drawText(m_Luminary, 2, startY);
+		g.drawText(strSunDir, 2, startY + 12);
+	}
+	
+	private void drawGpsStatus(Graphics g){
+		if ((m_fix > 0) && (m_sats >= 0)) {
+			// Set background to signal quality
+			g.setColor(GREEN);
+		}
+		else
+		// receiving data, but signal ist not good
+		if ((m_fix == 0) && (m_sats >= 0)) {
+			g.setColor(YELLOW);
+		}
+		else {
+			g.setColor(RED);
+		}
+
+		String strSats = "Sats: -";
+		if (m_sats >= 0) strSats = "Sats: " + Convert.toString(m_sats);
+		String strHdop = "HDOP: -";
+		if (m_hdop >= 0) strHdop = "HDOP: " + Convert.toString(m_hdop);
+
+		int textWidth = java.lang.Math.max(fm.getTextWidth(strSats), fm.getTextWidth(strHdop));
+		int startX = location.width - (textWidth + 4);
+		int startY = location.height - 24;
+		g.fillRect(startX, startY, location.width - startX ,location.height - startY);
+
+		g.setColor(Color.Black);
+		g.drawText(strSats, startX + 2, startY);
+		g.drawText(strHdop, startX + 2, startY + 12);
+	}
+
 	private void drawArrows(Graphics g){
 		if (g != null)
 		{
@@ -535,10 +616,11 @@
 	private void drawArrow(Graphics g, float angle, Color col, float scale) {
 		float angleRad;
 		int x, y, centerX = location.width/2, centerY = location.height/2;
+		int arrowLength = java.lang.Math.min(centerX, centerY); 
 
 		angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		x = centerX + new Float(centerX * java.lang.Math.sin(angleRad) * scale).intValue();
-		y = centerY - new Float(centerY * java.lang.Math.cos(angleRad) * scale).intValue();
+		x = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad) * scale).intValue();
+		y = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad) * scale).intValue();
 		g.setPen(new Pen(col,Pen.SOLID,3));
 		g.drawLine(centerX,centerY,x,y);
 	}

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-08-30 22:11:44 UTC (rev 857)
+++ trunk/src/CacheWolf/MovingMap.java	2007-09-01 12:31:52 UTC (rev 858)
@@ -53,6 +53,7 @@
 	public static final String MARK_CACHE_IMAGE = "mark_cache.png";
 	int posCircleX = 0, posCircleY = 0, lastCompareX = Integer.MAX_VALUE, lastCompareY = Integer.MAX_VALUE;
 	double posCircleLat, posCircleLon;
+	FontMetrics fm;
 
 	boolean dontUpdatePos = false; // this is only internaly used to avoid multi-threading problems
 	boolean ignoreGps = false; // ignores updateGps-calls if true
@@ -101,18 +102,19 @@
 		buttonImageZoom1to1.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(buttonImageZoom1to1);
 		//target distance
-		//Label distLbl = new mLabel("Distance: ----,-- km");
+		Font font = new Font("Helvetica", Font.PLAIN, 13);
+		fm = getFontMetrics(font);
 		DistanceImage = new AniImage();
 		DistanceImage.setImage(new Image(120, 15), Color.White); // consider the size of the font used
 		DistanceImageGraphics = new Graphics(DistanceImage.image);
-		DistanceImageGraphics.setFont(new Font("Helvetica", Font.PLAIN, 13));
+		DistanceImageGraphics.setFont(font);
 		DistanceImage.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(DistanceImage);
 		//scale
 		ScaleImage = new AniImage();
 		ScaleImage.setImage(new Image(120, 15), Color.White); // consider the size of the font used
 		ScaleImageGraphics = new Graphics(ScaleImage.image);
-		ScaleImageGraphics.setFont(new Font("Helvetica", Font.PLAIN, 13));
+		ScaleImageGraphics.setFont(font);
 		ScaleImage.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(ScaleImage);
 		//resizeTo(pref.myAppWidth, pref.myAppWidth); // is necessary to initialize mapImage.screenSize
@@ -193,18 +195,17 @@
 			int lineLengthPixels = (int)java.lang.Math.round( lineLengthMeters / currentMap.scale );
 
 			String lineLengthString;
-			int backgroundStartX = 0;
 			if (lineLengthMeters < 1000)
 			{
 				lineLengthString = Convert.toString((int) lineLengthMeters) + "m";
-				backgroundStartX = ScaleImage.location.width - lineLengthPixels - ( ((int)digits+1) * 6 ) - 14;
 			}
 			else
 			{
 				lineLengthString = Convert.toString((int) lineLengthMeters / 1000) + "km";
-				backgroundStartX = ScaleImage.location.width - lineLengthPixels - ( ((int)digits-2) * 6 ) - 19;
 			}
 			
+			int backgroundStartX = ScaleImage.location.width - (lineLengthPixels + fm.getTextWidth(lineLengthString) + 7);
+			
 			ScaleImageGraphics.setColor(new Color(250,250,250));
 			ScaleImageGraphics.fillRect(backgroundStartX, 0, ScaleImage.location.width - backgroundStartX ,ScaleImage.location.height);
 
@@ -230,22 +231,21 @@
 				ewe.sys.Double dd = new ewe.sys.Double();
 				dd.set(currentDistance);
 				String d;
-				int backgroundWidth = DistanceImage.location.width;
 				if (dd.value < 1) {
 					dd.value = dd.value * 1000; 
 					dd.decimalPlaces = 0;
 					d = "Dist: " + dd.toString() + "m";
 					int digits = (int)java.lang.Math.floor( java.lang.Math.log(dd.value) / java.lang.Math.log(10.0) );
 					digits = java.lang.Math.max(0, digits);
-					backgroundWidth = 6 * (digits + 1) + 36;
 				} 
 				else {
 					dd.decimalPlaces = 2;
 					d = "Dist: " + dd.toString() + "km";
 					int digits = (int)java.lang.Math.floor( java.lang.Math.log(dd.value) / java.lang.Math.log(10.0) );
 					digits = java.lang.Math.max(0, digits);
-					backgroundWidth = 6 * (digits + 3) + 45;
 				}
+				
+				int backgroundWidth = fm.getTextWidth(d) + 4;
 
 				DistanceImageGraphics.setColor(new Color(250,250,250));
 				DistanceImageGraphics.fillRect(0, 0, backgroundWidth ,DistanceImage.location.height);



From salzkammergut at mail.berlios.de  Sat Sep  1 14:40:12 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 1 Sep 2007 14:40:12 +0200
Subject: [Cachewolf-svn] r859 - trunk/resources
Message-ID: <200709011240.l81CeC0l019299@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-01 14:40:07 +0200 (Sat, 01 Sep 2007)
New Revision: 859

Modified:
   trunk/resources/cachewolf.Languages.cfg
Log:
Languages.cfg: Rechtschreibfehler korrigiert

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-09-01 12:31:52 UTC (rev 858)
+++ trunk/resources/cachewolf.Languages.cfg	2007-09-01 12:40:07 UTC (rev 859)
@@ -486,7 +486,7 @@
 		5508=Einloggen ...
 		5509=Zentrumskoordinaten nicht gesetzt
 		5510=Spider Optionen
-		5511=Gefunen
+		5511=Gefunden+
 		5512=+Caches
 		5513=Laden von:+
 		5514=%0aTravelbug:+ 



From mik77 at mail.berlios.de  Sat Sep  1 16:51:17 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sat, 1 Sep 2007 16:51:17 +0200
Subject: [Cachewolf-svn] r860 - trunk/src/CacheWolf
Message-ID: <200709011451.l81EpHeK025543@sheep.berlios.de>

Author: mik77
Date: 2007-09-01 16:51:13 +0200 (Sat, 01 Sep 2007)
New Revision: 860

Modified:
   trunk/src/CacheWolf/GotoPanel.java
Log:
new arrows for GotoPanel


Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-09-01 12:40:07 UTC (rev 859)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-09-01 14:51:13 UTC (rev 860)
@@ -397,7 +397,7 @@
 	final static Color RED = new Color(255,0,0);
 	final static Color YELLOW = new Color(255,255,0);
 	final static Color GREEN = new Color(0,255,0);
-	final static Color BLUE = new Color(0,255,255);
+	final static Color BLUE = new Color(0,0,255);
 	final static Color ORANGE = new Color(255,128,0);
 	final static Color DARKGREEN = new Color(0,192,0);
 
@@ -601,9 +601,10 @@
 			}
 
 			// draw only valid arrows
-			if (gotoDir < 360 && gotoDir > -360) drawArrow(g, gotoDir, Color.DarkBlue, 1.0f);
-			if (moveDir < 360 && moveDir > -360) drawArrow(g, moveDir, moveDirColor, 1.0f);
-			if (sunDir < 360 && sunDir > -360) drawArrow(g, sunDir, YELLOW, 0.75f);
+			if (gotoDir < 360 && gotoDir > -360) drawThickArrow(g, gotoDir, Color.DarkBlue, 1.0f);
+			if (moveDir < 360 && moveDir > -360) drawThinArrow(g, moveDir, moveDirColor, 1.0f);
+			if (sunDir < 360 && sunDir > -360) drawSunArrow(g, sunDir, YELLOW, 0.75f);
+			//drawDoubleArrow(g, 0, BLUE, RED, 1.0f);
 		}
 	}
 
@@ -613,7 +614,7 @@
 	 * @param angle angle of arrow
 	 * @param col color of arrow
 	 */
-	private void drawArrow(Graphics g, float angle, Color col, float scale) {
+	private void drawSimpleArrow(Graphics g, float angle, Color col, float scale) {
 		float angleRad;
 		int x, y, centerX = location.width/2, centerY = location.height/2;
 		int arrowLength = java.lang.Math.min(centerX, centerY); 
@@ -624,4 +625,112 @@
 		g.setPen(new Pen(col,Pen.SOLID,3));
 		g.drawLine(centerX,centerY,x,y);
 	}
+	
+	private void drawSunArrow(Graphics g, float angle, Color col, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = location.width/2, centerY = location.height/2;
+		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
+		float halfArrowWidth = arrowLength * 0.08f;
+		float circlePos = arrowLength * 0.7f;
+		int circleRadius = (int)(arrowLength * 0.1f);
+
+		int pointX = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		int pointY = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		int circleX = centerX + new Float(circlePos * java.lang.Math.sin(angleRad)).intValue();
+		int circleY = centerY - new Float(circlePos * java.lang.Math.cos(angleRad)).intValue();
+
+		int[] pointsX = new int[4];
+		int[] pointsY = new int[4];
+
+		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[1] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsY[1] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
+		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
+		pointsX[3] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		pointsY[3] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		
+//		g.setPen(new Pen(col,Pen.SOLID,3));
+//		g.drawLine(centerX,centerY,pointX,pointY);
+		
+		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setBrush(new Brush(col, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 4);
+		g.fillEllipse(circleX - circleRadius, circleY - circleRadius, 2 * circleRadius, 2 * circleRadius);
+	}
+	
+	private void drawThinArrow(Graphics g, float angle, Color col, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = location.width/2, centerY = location.height/2;
+		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
+		float halfOpeningAngle = (float)(java.lang.Math.PI * 0.03);
+		float sideLineLength = arrowLength * 0.75f;
+		
+		int[] pointsX = new int[4];
+		int[] pointsY = new int[4];
+
+		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[1] = centerX + new Float(sideLineLength * java.lang.Math.sin(angleRad + halfOpeningAngle)).intValue();
+		pointsY[1] = centerY - new Float(sideLineLength * java.lang.Math.cos(angleRad + halfOpeningAngle)).intValue();
+		pointsX[2] = centerX;
+		pointsY[2] = centerY;
+		pointsX[3] = centerX + new Float(sideLineLength * java.lang.Math.sin(angleRad - halfOpeningAngle)).intValue();
+		pointsY[3] = centerY - new Float(sideLineLength * java.lang.Math.cos(angleRad - halfOpeningAngle)).intValue();
+		
+		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setBrush(new Brush(col, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 4);
+	}
+	
+	private void drawDoubleArrow(Graphics g, float angle, Color colFront, Color colRear, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = location.width/2, centerY = location.height/2;
+		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
+		float halfArrowWidth = arrowLength * 0.1f;
+		
+		int[] pointsX = new int[3];
+		int[] pointsY = new int[3];
+
+		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[1] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsY[1] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		
+		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setBrush(new Brush(colFront, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 3);
+		
+		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
+		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
+		
+		g.setBrush(new Brush(colRear, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 3);
+	}
+	
+	private void drawThickArrow(Graphics g, float angle, Color col, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = location.width/2, centerY = location.height/2;
+		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
+		float halfArrowWidth = arrowLength * 0.1f;
+		
+		int[] pointsX = new int[4];
+		int[] pointsY = new int[4];
+
+		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[1] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsY[1] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
+		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
+		pointsX[3] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		pointsY[3] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		
+		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setBrush(new Brush(col, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 4);
+	}
 }



From mik77 at mail.berlios.de  Sat Sep  1 18:56:57 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sat, 1 Sep 2007 18:56:57 +0200
Subject: [Cachewolf-svn] r861 - in trunk: resources src/CacheWolf
Message-ID: <200709011656.l81GuvML014837@sheep.berlios.de>

Author: mik77
Date: 2007-09-01 18:56:50 +0200 (Sat, 01 Sep 2007)
New Revision: 861

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MovingMap.java
Log:
- GotoPanel redesign completed (with moveDir centered view)
- added context menu for luminary selection in moving map

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-09-01 14:51:13 UTC (rev 860)
+++ trunk/resources/cachewolf.Languages.cfg	2007-09-01 16:56:50 UTC (rev 861)
@@ -300,6 +300,7 @@
 		1500=Ziel:
 		1501=Aktuell
 		1502=Grad
+		1503=Nordausrichtung
 		1600=Opencahing.de Download
 		1601=max. Abstand:
 		1602=Bilder downloaden
@@ -846,6 +847,7 @@
 		1500=DST:
 		1501=Current
 		1502=deg
+		1503=North centered
 		1600=Opencahing.de Download
 		1601=Distance:
 		1602=Download Images

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-09-01 14:51:13 UTC (rev 860)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-09-01 16:56:50 UTC (rev 861)
@@ -64,6 +64,8 @@
 	
 	Menu mnuContextRose;
 	MenuItem miLuminary[] = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
+	MenuItem miNorthCentered;
+	
 	/**
 	 * Create GotoPanel 
 	 * @param Preferences 	global preferences
@@ -126,6 +128,11 @@
 		icRose.setMenu(mnuContextRose);
 		icRose.modifyAll(Control.WantHoldDown, 0); // this is necessary in order to make PenHold on a PDA work as right click
 		roseP.addLast(icRose,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTH));
+		
+		mnuContextRose.addItem(new MenuItem("", MenuItem.Separator, null));
+		mnuContextRose.addItem(miNorthCentered = new MenuItem(MyLocale.getMsg(1503,"North Centered")));
+		if (compassRose.isNorthCentered()) miNorthCentered.modifiers |= MenuItem.Checked;
+		else miNorthCentered.modifiers &= MenuItem.Checked;
 
 		//log
 		LogP.addNext(lblLog = new mLabel("Log "),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
@@ -334,6 +341,17 @@
 							compassRose.setLuminaryName(SkyOrientation.getLuminaryName(myNavigation.luminary));
 						} else miLuminary[i].modifiers &= ~MenuItem.Checked;
 					}
+					if (action == miNorthCentered) {
+						if (compassRose.isNorthCentered()) {
+							compassRose.setNorthCentered(false);
+							miNorthCentered.modifiers &= ~MenuItem.Checked;							
+						}
+						else
+						{
+							compassRose.setNorthCentered(true);
+							miNorthCentered.modifiers |= MenuItem.Checked;
+						}
+					}
 				}
 			}
 		}
@@ -394,6 +412,8 @@
 	
 	FontMetrics fm;
 	
+	boolean northCentered = true;
+	
 	final static Color RED = new Color(255,0,0);
 	final static Color YELLOW = new Color(255,255,0);
 	final static Color GREEN = new Color(0,255,0);
@@ -443,7 +463,13 @@
 	 */
 	
 	public void doDraw(Graphics g,int options) {
-		super.doDraw(g, options);
+		if (northCentered) {
+			super.doDraw(g, options);
+		}
+		else {
+			g.setColor(Color.White);
+			g.fillRect(0, 0, location.width, location.height);
+		}
 		Font font = new Font("Verdana", Font.BOLD, 12);
 		g.setFont(font);
 		fm = g.getFontMetrics(font);
@@ -586,11 +612,12 @@
 					diff = 360.0f - diff;
 				}
 				
-				if (diff <= 5.0)
+				/*if (diff <= 5.0)
 				{
 					moveDirColor = DARKGREEN;
 				}
-				else if (diff <= 22.5)
+				else*/
+				if (diff <= 22.5)
 				{
 					moveDirColor = GREEN;
 				}
@@ -601,10 +628,21 @@
 			}
 
 			// draw only valid arrows
-			if (gotoDir < 360 && gotoDir > -360) drawThickArrow(g, gotoDir, Color.DarkBlue, 1.0f);
-			if (moveDir < 360 && moveDir > -360) drawThinArrow(g, moveDir, moveDirColor, 1.0f);
-			if (sunDir < 360 && sunDir > -360) drawSunArrow(g, sunDir, YELLOW, 0.75f);
-			//drawDoubleArrow(g, 0, BLUE, RED, 1.0f);
+			if (northCentered) {
+				if (gotoDir < 360 && gotoDir > -360) drawThickArrow(g, gotoDir, Color.DarkBlue, 1.0f);
+				if (moveDir < 360 && moveDir > -360) drawThinArrow(g, moveDir, moveDirColor, 1.0f);
+				if (sunDir < 360 && sunDir > -360) drawSunArrow(g, sunDir, YELLOW, 0.75f);
+			}
+			else {
+				//moveDir centered
+				g.setPen(new Pen(RED,Pen.SOLID,3));
+				g.drawLine(location.width/2, 0, location.width/2, location.height);
+				if (moveDir < 360 && moveDir > -360) {
+					drawDoubleArrow(g, 360 - moveDir, BLUE, RED, 1.0f);
+					if (gotoDir < 360 && gotoDir > -360) drawThinArrow(g, gotoDir - moveDir, moveDirColor, 1.0f);
+					if (sunDir < 360 && sunDir > -360) drawSunArrow(g, sunDir - moveDir, YELLOW, 0.75f);					
+				}				
+			}
 		}
 	}
 
@@ -733,4 +771,13 @@
 		g.setBrush(new Brush(col, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 4);
 	}
+	
+	public void setNorthCentered(boolean nc) {
+		northCentered = nc;
+		refresh();
+	}
+	
+	public boolean isNorthCentered() {
+		return northCentered;
+	}
 }

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-09-01 14:51:13 UTC (rev 860)
+++ trunk/src/CacheWolf/MovingMap.java	2007-09-01 16:56:50 UTC (rev 861)
@@ -1300,6 +1300,8 @@
 	MenuItem gotoMenuItem = new MenuItem("Goto here$g", 0, null);
 	MenuItem newWayPointMenuItem = new MenuItem("Create new Waypoint here$n", 0, null);;
 	MenuItem openCacheDescMenuItem,addCachetoListMenuItem;
+	
+	MenuItem miLuminary[];
 
 	Menu mapsMenu;
 	MenuItem selectMapMI = new MenuItem("Select a map manually$s", 0, null);
@@ -1555,18 +1557,29 @@
 			//( (ev.type == PenEvent.PEN_DOWN) && ((PenEvent)ev).modifiers == PenEvent.RIGHT_BUTTON)
 			//|| ((ev.type == PenEvent.RIGHT_BUTTON) ) )) ---> these events are not posted --> this overridering is the only solution 
 			kontextMenu = new Menu();
-			kontextMenu.addItem(gotoMenuItem);
-			kontextMenu.addItem(newWayPointMenuItem);
-			AniImage clickedOnImage = images.findHotImage(p);
-			if (clickedOnImage != null && clickedOnImage instanceof MapSymbol) {
-				clickedCache = ((CacheHolder)((MapSymbol)clickedOnImage).mapObject);
-				if (clickedCache != null) openCacheDescMenuItem = new MenuItem("Open '"+(clickedCache.CacheName.length()>0?clickedCache.CacheName:clickedCache.wayPoint)+"'$o"); // clickedCache == null can happen if clicked on the goto-symbol
-				kontextMenu.addItem(openCacheDescMenuItem);
-				if (clickedCache !=null && Global.mainForm.cacheListVisible) { 
-					addCachetoListMenuItem = new MenuItem(MyLocale.getMsg(199,"Add to cachetour"));
-					kontextMenu.addItem(addCachetoListMenuItem);
+			if ( !(mm.directionArrows.onHotArea(p.x, p.y)) ) {
+				kontextMenu.addItem(gotoMenuItem);
+				kontextMenu.addItem(newWayPointMenuItem);
+				AniImage clickedOnImage = images.findHotImage(p);
+				if (clickedOnImage != null && clickedOnImage instanceof MapSymbol) {
+					clickedCache = ((CacheHolder)((MapSymbol)clickedOnImage).mapObject);
+					if (clickedCache != null) openCacheDescMenuItem = new MenuItem("Open '"+(clickedCache.CacheName.length()>0?clickedCache.CacheName:clickedCache.wayPoint)+"'$o"); // clickedCache == null can happen if clicked on the goto-symbol
+					kontextMenu.addItem(openCacheDescMenuItem);
+					if (clickedCache !=null && Global.mainForm.cacheListVisible) { 
+						addCachetoListMenuItem = new MenuItem(MyLocale.getMsg(199,"Add to cachetour"));
+						kontextMenu.addItem(addCachetoListMenuItem);
+					}
 				}
 			}
+			else {			
+				miLuminary = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
+
+				for (int i=0; i<SkyOrientation.LUMINARY_NAMES.length; i++) {
+					kontextMenu.addItem(miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i)));
+					if (i == mm.myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
+					else miLuminary[i].modifiers &= MenuItem.Checked;
+				}
+			}
 			kontextMenu.exec(this, new Point(p.x, p.y), this);
 		}
 	}
@@ -1681,7 +1694,14 @@
 						kontextMenu.close();
 						Global.mainForm.cacheList.addCache(clickedCache.wayPoint);
 					}
-
+					for (int i=0; i<miLuminary.length; i++) {
+						if (action == miLuminary[i]) {
+							kontextMenu.close();
+							mm.myNavigation.setLuminary(i);
+							mm.updateGps(mm.myNavigation.gpsPos.getFix());
+							miLuminary[i].modifiers |= MenuItem.Checked;
+						} else miLuminary[i].modifiers &= ~MenuItem.Checked;
+					}
 				}
 			} // if (ev.target == kontextMenu)
 		} // if (ev instanceof ControlEvent ) 



From mik77 at mail.berlios.de  Sat Sep  1 19:44:13 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sat, 1 Sep 2007 19:44:13 +0200
Subject: [Cachewolf-svn] r862 - trunk/src/CacheWolf
Message-ID: <200709011744.l81HiDXe015667@sheep.berlios.de>

Author: mik77
Date: 2007-09-01 19:44:06 +0200 (Sat, 01 Sep 2007)
New Revision: 862

Modified:
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/Preferences.java
Log:
save north centered status in preferences and restore on next startup

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-09-01 16:56:50 UTC (rev 861)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-09-01 17:44:06 UTC (rev 862)
@@ -412,7 +412,7 @@
 	
 	FontMetrics fm;
 	
-	boolean northCentered = true;
+	boolean northCentered = Global.getPref().northCenteredGoto;
 	
 	final static Color RED = new Color(255,0,0);
 	final static Color YELLOW = new Color(255,255,0);
@@ -774,6 +774,10 @@
 	
 	public void setNorthCentered(boolean nc) {
 		northCentered = nc;
+		if (northCentered != Global.getPref().northCenteredGoto) {
+			Global.getPref().northCenteredGoto = northCentered;
+			Global.getPref().savePreferences();
+		}
 		refresh();
 	}
 	

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-09-01 16:56:50 UTC (rev 861)
+++ trunk/src/CacheWolf/Preferences.java	2007-09-01 17:44:06 UTC (rev 862)
@@ -90,6 +90,8 @@
 	/** If this flag is true, only non-logged travelbug journeys will be shown */
 	public boolean travelbugShowOnlyNonLogged=false;
 	
+	public boolean northCenteredGoto = true;
+	
 	public String mapsPath = "maps/standard";
 	// Helper variables for XML parser 
 	private StringBuffer collectElement=null; 
@@ -399,6 +401,9 @@
 			travelbugColWidth=atts.getValue("colwidths");	
 			travelbugShowOnlyNonLogged=Boolean.valueOf(atts.getValue("shownonlogged")).booleanValue();
 		}
+		if (name.equals("gotopanel")) {
+			northCenteredGoto = Boolean.valueOf(atts.getValue("northcentered")).booleanValue();
+		}
 	}
 
 	public void characters( char ch[], int start, int length ) {
@@ -448,6 +453,7 @@
 			outp.print("    <garmin connection = \""+garminConn+"\" GPSBabelOptions = \""+garminGPSBabelOptions+"\" />\n");
 			outp.print("    <opencaching downloadPicsOC=\""+downloadPicsOC+"\" downloadMaps=\""+downloadMapsOC+"\" downloadMissing=\""+downloadmissingOC+"\"/>\n");
 			outp.print("	<location lat = \""+curCentrePt.getLatDeg(CWPoint.DD)+"\" long = \""+curCentrePt.getLonDeg(CWPoint.DD)+"\"/>\n");
+			outp.print("    <gotopanel northcentered=\""+northCenteredGoto+"\" />\n");
 			if (customMapsPath!=null) outp.print("	<mapspath dir = \""+ customMapsPath +"\"/>\n");
 			if (debug) outp.print("    <debug value=\"true\" />\n"); // Keep the debug switch if it is set
 			// save last path of different exporters



From mik77 at mail.berlios.de  Sat Sep  1 23:55:42 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sat, 1 Sep 2007 23:55:42 +0200
Subject: [Cachewolf-svn] r863 - trunk/src/CacheWolf
Message-ID: <200709012155.l81LtguD028606@sheep.berlios.de>

Author: mik77
Date: 2007-09-01 23:55:37 +0200 (Sat, 01 Sep 2007)
New Revision: 863

Modified:
   trunk/src/CacheWolf/GotoPanel.java
Log:
- circle for moveDir centered view in GotoPanel
- Log commented out in GotoPanel. (Too large with font 12 and will be moved to better place)

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-09-01 17:44:06 UTC (rev 862)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-09-01 21:55:37 UTC (rev 863)
@@ -148,7 +148,7 @@
 		this.addLast(ButtonP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
 		this.addLast(CoordsP,CellConstants.HSTRETCH, CellConstants.HFILL|CellConstants.NORTH).setTag(SPAN,new Dimension(2,1));
 		this.addLast(roseP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
-		this.addLast(LogP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.NORTHWEST).setTag(SPAN,new Dimension(1,1));
+		//this.addLast(LogP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.NORTHWEST).setTag(SPAN,new Dimension(1,1));
 
 		// for debuging
 		/*		CWGPSPoint myGPS;
@@ -635,8 +635,14 @@
 			}
 			else {
 				//moveDir centered
+				int radius = (int)((float)(java.lang.Math.min(location.width, location.height) / 2) * 0.75f);
+				
 				g.setPen(new Pen(RED,Pen.SOLID,3));
-				g.drawLine(location.width/2, 0, location.width/2, location.height);
+				g.drawLine(location.width/2, location.height/2 - radius, location.width/2, location.height/2 + radius);
+				
+				g.setPen(new Pen(new Color(150,150,150),Pen.SOLID,3));
+				g.drawEllipse(location.width/2 - radius, location.height/2 - radius, 2 * radius, 2 * radius );
+				
 				if (moveDir < 360 && moveDir > -360) {
 					drawDoubleArrow(g, 360 - moveDir, BLUE, RED, 1.0f);
 					if (gotoDir < 360 && gotoDir > -360) drawThinArrow(g, gotoDir - moveDir, moveDirColor, 1.0f);



From salzkammergut at mail.berlios.de  Sun Sep  2 00:13:21 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 2 Sep 2007 00:13:21 +0200
Subject: [Cachewolf-svn] r864 - trunk/src/CacheWolf
Message-ID: <200709012213.l81MDLeq029309@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-02 00:13:11 +0200 (Sun, 02 Sep 2007)
New Revision: 864

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/CacheHolderDetail.java
   trunk/src/CacheWolf/CacheList.java
   trunk/src/CacheWolf/GPXImporter.java
   trunk/src/CacheWolf/LOCXMLImporter.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/SpiderGC.java
Log:
Cachetour: Bugfix (http://www.geoclub.de/ftopic18379.html)
Ueberarbeitung von CacheHolder/CacheHolderDetail (mit Auswirkungen auf diverse Importer)
Ueberarbeitung von SpiderGC (Fehlende Tags in spider.def erzeugen Exception)


Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-09-01 21:55:37 UTC (rev 863)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-09-01 22:13:11 UTC (rev 864)
@@ -1,4 +1,5 @@
 package CacheWolf;
+import ewe.sys.Vm;
 import ewe.util.Vector;
 
 /**
@@ -8,53 +9,93 @@
 *	
 */
 public class CacheHolder {
-protected String NODISTANCE = "? km";
-protected String NOBEARING = "?";
-protected String EMPTY = "";
+protected static final String NODISTANCE = "? km";
+protected static final String NOBEARING = "?";
+protected static final String EMPTY = "";
 
+/** Cachestatus is Found, Not found or a date in format yyyy-mm-dd hh:mm for found date */
 public String CacheStatus = EMPTY;
+/** The name of the waypoint typicall GC.... or OC.... or CW...... (can be any characters) */
 public String wayPoint = EMPTY;
+/** The name of the cache (short description) */
 public String CacheName = EMPTY;
+/** The alias of the owner */
 public String CacheOwner = EMPTY;
+/** The coordinates of the cache */
 public CWPoint pos = new CWPoint();
+/** The coordinates of the cache */
 public String LatLon = pos.toString();
+/** The date when the cache was hidden in format yyyy-mm-dd */
 public String DateHidden = EMPTY;
+/** The size of the cache (as per GC cache sizes Micro, Small, ....) */
 public String CacheSize = "None";
+/** The distance from the center in km */
 public double kilom = 0;
+/** The formatted distance such as "x.xx km" */
 public String distance = NODISTANCE;
+/** The bearing N, NNE, NE, ENE ... from the current center to this point */
 public String bearing = NOBEARING;
+/** The angle (0=North, 180=South) from the current center to this point */
 public double degrees = 0;
+/** The difficulty of the cache from 1 to 5 in .5 incements */ 
 public String hard = EMPTY;
+/** The terrain rating of the cache from 1 to 5 in .5 incements */
 public String terrain = EMPTY;
-public String type = "0";
+/** The cache type (@see CacheType for translation table)  */
+public String type = "0"; //TODO Should be an int
+/** True if the cache has been archived */
 public boolean is_archived = false;
+/** True if the cache is available for searching */
 public boolean is_available = true;
+/** True if we own this cache */
 public boolean is_owned = false;
+/** True if we have found this cache */
 public boolean is_found = false;
+/** If this is true, the cache has been filtered (is currently invisible) */
 public boolean is_filtered = false;
+/** True if the number of logs for this cache has changed */
 public boolean is_log_update = false;
+/** True if cache details have changed: longDescription, Hints,  */
 public boolean is_update = false;
-public boolean is_selected = false;
+/** True if the cache data is incomplete (e.g. an error occurred during spidering */
 public boolean is_incomplete = false;
+/** True if the cache is blacklisted */
 public boolean is_black = false;
+/** True if the cache is new */
 public boolean is_new = false;
+/** True if the cache is part of the results of a search */
 public boolean is_flaged = false;
+/** True if the cache has been selected using the tick box in the list view */
 public boolean is_Checked = false;
-public String dirty = EMPTY;
+/** Not used: This attribute is saved with the cache and read back but never set */
+//public String dirty = EMPTY;
+/** The unique OC cache ID */
 public String ocCacheID = EMPTY;
+/** The number of times this cache has not been found (max. 5) */
 public int noFindLogs = 0;
+/** True if this cache has travelbugs */
 public boolean has_bug = false;
+/** True if the cache description is stored in HTML format */
 public boolean is_HTML = true;
+/** List of additional waypoints associated with this waypoint */
 public Vector addiWpts = new Vector();
+/** If this is an additional waypoint, this links back to the main waypoint */
 public CacheHolder mainCache;
+/** The date this cache was last synced with OC in format yyyyMMddHHmmss */
+public String lastSyncOC = EMPTY;
+/** When sorting the cacheDB this field is used. The relevant field is copied here and
+ *  the sort is always done on this field to speed up the sorting process 
+ */
 public String sort;
-public String lastSyncOC = EMPTY;
-
 //static int nObjects=0;
 CacheHolder() {//nObjects++;Vm.debug("CacheHolder() nO="+nObjects);
 }
 
 CacheHolder(CacheHolder ch) {//nObjects++;Vm.debug("CacheHolder(ch) nO="+nObjects);
+	update(ch);
+}
+
+public void update(CacheHolder ch) {
 	this.CacheStatus=ch.CacheStatus;
 	this.wayPoint = ch.wayPoint;
 	this.CacheName = ch.CacheName;
@@ -77,7 +118,6 @@
 	this.is_filtered = ch.is_filtered;
 	this.is_log_update = ch.is_log_update;
 	this.is_update = ch.is_update;
-	this.is_selected = ch.is_selected;
 	this.is_incomplete = ch.is_incomplete;
 	this.is_black=ch.is_black;
 	this.addiWpts = ch.addiWpts;
@@ -85,16 +125,22 @@
 	this.is_new=ch.is_new;
 	this.is_flaged = ch.is_flaged;
 	this.is_Checked = ch.is_Checked;
-    this.dirty = ch.dirty;
+    //this.dirty = ch.dirty;
 	this.ocCacheID = ch.ocCacheID;
 	this.noFindLogs = ch.noFindLogs;
 	this.has_bug = ch.has_bug;
 	this.is_HTML = ch.is_HTML;
 	this.sort=ch.sort;
 	this.lastSyncOC = ch.lastSyncOC;
-	
 }
 
+public void setLatLon(String latLon) {
+	latLon=latLon.trim();
+	if (!latLon.equals(LatLon)) is_update=true;
+	LatLon = latLon;
+	pos.set(latLon);
+}
+
 public boolean isAddiWpt() {
 	   return CacheType.isAddiWpt(this.type);
    }

Modified: trunk/src/CacheWolf/CacheHolderDetail.java
===================================================================
--- trunk/src/CacheWolf/CacheHolderDetail.java	2007-09-01 21:55:37 UTC (rev 863)
+++ trunk/src/CacheWolf/CacheHolderDetail.java	2007-09-01 22:13:11 UTC (rev 864)
@@ -36,7 +36,33 @@
 	 public CacheHolderDetail(CacheHolder ch) {
 		 super(ch);
 	 }
-	  
+
+	 public void setLongDescription(String longDescription) {
+	 	if (!LongDescription.equals(longDescription)) is_update=true;
+	 	LongDescription = longDescription;
+	 }
+	 
+	 public void setHints(String hints) {
+	 	if (!Hints.equals(hints)) is_update=true;
+	 	Hints = hints;
+	 }
+	 
+	 public void setCacheLogs(Vector logs) {
+		  // Number of logs has changed, set the log_update flag
+		 if (logs.size()!=CacheLogs.size()) is_log_update=true;
+		 CacheLogs=logs;
+		 // Count the number of not-found logs
+		int countNoFoundLogs = 0;
+		String loganal = "";
+		while(countNoFoundLogs < CacheLogs.size() && countNoFoundLogs < 5){
+			loganal = (String)CacheLogs.get(countNoFoundLogs);
+			if(loganal.indexOf("icon_sad")>0) {
+				countNoFoundLogs++;
+			}else break;
+		}
+		noFindLogs = countNoFoundLogs;
+	 }
+	 
 	  /**
 	 * Method to update an existing cache with new data. This is
 	 * necessary to avoid missing old logs.
@@ -44,59 +70,22 @@
 	 * @return CacheHolder with updated data
 	 */
 	public CacheHolderDetail update(CacheHolderDetail newCh){
+		  super.update(newCh);
 		  // flags
-		  this.is_available = newCh.is_available;
-		  this.is_archived = newCh.is_archived;
-		  // update is_owned only if not the owner ????
-		  if (this.is_owned == false) this.is_owned = newCh.is_owned;
-		  // update is_found if not already found
-		  if (this.is_found == false) this.is_found = newCh.is_found;
-		  // no else, because status can change.
 		  if (this.is_found == true) this.CacheStatus = MyLocale.getMsg(318,"Found");
-		  
-		  
-		  this.is_new = false;
-		  this.is_update = false;
-		  this.is_log_update = false;
-		  
-		  //name and owner
-		  this.CacheName = newCh.CacheName;
-		  this.CacheOwner = newCh.CacheOwner;
 
-		  //classification
-		  this.hard = newCh.hard;
-		  this.terrain = newCh.terrain;
-		  this.type = newCh.type;
-		  
 		  //travelbugs: overriding is OK, since GPX-File contains all actual travelbugs
-		  this.has_bug = newCh.has_bug;
+		  this.has_bug = newCh.Travelbugs.size()>0;
 		  this.Travelbugs = newCh.Travelbugs;
 		  
 		  // URL
 		  this.URL = newCh.URL;
 		  
-		  //coords
-		  this.LatLon = newCh.LatLon;
-		  this.pos.set(newCh.pos);
-
-		  // check only length of the description to see, if there was an update
-		  if (this.LongDescription.length() != newCh.LongDescription.length()){
-			  this.is_update = true;
-		  }
-		  // same for hints
-		  if (this.Hints.length() != newCh.Hints.length()){
-			  this.is_update = true;
-		  }
+		  setLongDescription(newCh.LongDescription);
+		  setHints(newCh.Hints);
+		  setCacheLogs(newCh.CacheLogs);
 		  
-		  // description & hints
-		  this.is_HTML = newCh.is_HTML;
-		  this.LongDescription = newCh.LongDescription;
-		  this.Hints = newCh.Hints;
-
-		  //Logs
-		  //<img src='icon_smile.gif'>&nbsp;2005-10-30 by Schatzpirat</strong><br>
-		  //get Date of latest log in old cachedata
-		  Extractor extOldDate;
+/*		  Extractor extOldDate;
 		  String oldLogDate = EMPTY;
 		  if(this.CacheLogs.size()>0){
 			extOldDate = new Extractor((String) this.CacheLogs.get(0), ";"," by", 0, true);
@@ -120,20 +109,12 @@
 			  }
 			  else currLog--;
 		  }//while
-	   	 //Check for number sukzessive DNF logs
-		 int z = 0;
-		 String loganal = EMPTY;
-		 //Vm.debug("Checking size: ");
-		 //int sz = newCh.CacheLogs.size();
-		 //Vm.debug("log size: " + sz);
-	 	 while(z < newCh.CacheLogs.size() && z < 5){
-			loganal = (String)newCh.CacheLogs.get(z);
-			if(loganal.indexOf("icon_sad")>0) {
-				z++;
-			}else break;
-		 }
-		 noFindLogs = z;
-		 this.Solver=newCh.Solver;
+		  
+		  //Logs
+		  //<img src='icon_smile.gif'>&nbsp;2005-10-30 by Schatzpirat</strong><br>
+		  //get Date of latest log in old cachedata
+*/
+		  if (newCh.Solver.length()>0) this.Solver=newCh.Solver;
 	 	return this;
 	  }
 	  

Modified: trunk/src/CacheWolf/CacheList.java
===================================================================
--- trunk/src/CacheWolf/CacheList.java	2007-09-01 21:55:37 UTC (rev 863)
+++ trunk/src/CacheWolf/CacheList.java	2007-09-01 22:13:11 UTC (rev 864)
@@ -22,6 +22,7 @@
     /** The extension for cachelists (CL) */ 
     private final String EXTENSION="CL";
 	private final String TITLE=MyLocale.getMsg(188,"CACHETOUR: NEW");
+	private static int applyCount=0; // Counts the number of times we apply the list
     CacheList() {
 		this.setPreferredSize(100,-1); 
 		this.equalWidths=true;
@@ -168,8 +169,11 @@
 				int activeTab=Global.mainTab.cardPanel.selectedItem;
 				if (activeTab==0) 
 					Global.mainTab.tbP.tc.repaint();
-				else
+				else {
+					// We need to change to the list view first to load a new cache
+					Global.mainTab.onEvent(new MultiPanelEvent(0,Global.mainTab,0));
 					Global.mainTab.onEvent(new MultiPanelEvent(0,Global.mainTab,activeTab));
+				}
 			}
 		}
 		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
@@ -227,31 +231,48 @@
 					lstCaches.select(sel+1);
 				}
 			} else if (ev.target==btnFilter) {
-				Vector cacheDB=Global.getProfile().cacheDB;
-				CacheHolder ch;
-				// Start by setting all caches to filtered
-				for(int i = cacheDB.size()-1; i >=0 ; i--){
-					ch = (CacheHolder)cacheDB.get(i);
-					ch.is_filtered=true ; // ignore blacklist attribute
-					ch.sort="\uFFFF";
-				}
-				// Now "unfilter" the caches in our list
-				for (int i = cacheList.size()-1; i>=0; i--) {
-					ch = (CacheHolder)cacheList.get(i);
-					ch.is_filtered=false;
-					ch.sort=MyLocale.formatLong(i,"00000");
-				}
-				// The sort command places all filtered caches at the end
-				cacheDB.sort(new mySort(),false);
-				Filter.filterActive=true;
-				Filter.filterInverted=false;
-				updateScreen();
-			}
+				applyCacheList();			}
 		}
 		changeUpDownButtonStatus();
 	}
 
-
+	/** Apply the cache list */
+	public void applyCacheList() {
+		Vector cacheDB=Global.getProfile().cacheDB;
+		CacheHolder ch;
+		String apply="\uFFFF"+Convert.toString(applyCount++);
+		// Start by setting all caches to filtered
+		for(int i = cacheDB.size()-1; i >=0 ; i--){
+			ch = (CacheHolder)cacheDB.get(i);
+			ch.is_filtered=true ; // ignore blacklist attribute
+			ch.sort=apply;
+		}
+		// Now "unfilter" the caches in our list
+		for (int i = cacheList.size()-1; i>=0; i--) {
+			ch = (CacheHolder)cacheList.get(i);
+			/* If the cache was reloaded from a GPX file since we dragged it into the list,
+			   the pointer ch points to a CacheHolder object that is no longer part of cacheDB.
+			   In this case we need to search the cacheDB for an object with the name of ch.wayPoint
+			   and use that object. To speed up this process and avoid having to search the whole
+			   cacheDB for each entry in cacheList, we simply compare the sort field of ch to apply.
+			*/
+			if (!ch.sort.equals(apply)) {
+				int idx=Global.getProfile().getCacheIndex(ch.wayPoint);
+				if (idx==-1) continue;
+				ch=null;
+				ch=(CacheHolder) cacheDB.get(idx);
+			}
+			ch.is_filtered=false;
+			ch.sort=MyLocale.formatLong(i,"00000");
+		}
+		// The sort command places all filtered caches at the end
+		cacheDB.sort(new mySort(),false);
+		Filter.filterActive=true;
+		Filter.filterInverted=false;
+		updateScreen();
+		
+	}
+	
 	/** Add a cache (and its addis) to the list 
 	 * @return true if the cache is not already in lstCaches */
 	public boolean addCache(String wayPoint) {

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2007-09-01 21:55:37 UTC (rev 863)
+++ trunk/src/CacheWolf/GPXImporter.java	2007-09-01 22:13:11 UTC (rev 864)
@@ -39,7 +39,8 @@
 	public static final int DOIT_WITHSPOILER = 2;
 	boolean getMaps = false;
 	SpiderGC imgSpider;
-		
+	StringBuffer strBuf;
+	
 	public GPXImporter(Preferences p, Profile prof, String f )
 	{
 		profile=prof;
@@ -53,7 +54,6 @@
 		inCache = false;
 		inLogs = false;
 		inBug =false;
-		strData = new String();
 		//index db for faster search
 		CacheHolder ch;
 		for(int i = 0; i<cacheDB.size();i++){
@@ -148,7 +148,7 @@
 			}
 	}
 	public void startElement(String name, AttributeList atts){
-		strData ="";
+		strBuf=new StringBuffer(300);
 		if (name.equals("gpx")){
 			// check for opencaching
 			if (atts.getValue("creator").indexOf("opencaching")> 0) fromOC = true;
@@ -161,8 +161,8 @@
 		}
 		if (name.equals("wpt")) {
 			holder = new CacheHolderDetail();
-			holder.LatLon = latdeg2min(atts.getValue("lat")) + " " +londeg2min(atts.getValue("lon"));
 			holder.pos.set(Common.parseDouble(atts.getValue("lat")),Common.parseDouble(atts.getValue("lon")));
+			holder.LatLon=holder.pos.toString();
 			inWpt = true;
 			inLogs = false;
 			inBug = false;
@@ -234,6 +234,7 @@
 	}
 	
 	public void endElement(String name){
+		strData=strBuf.toString();
 		//Vm.debug("Ende: " + name);
 		
 		// logs
@@ -468,70 +469,11 @@
 
 	}
 	public void characters(char[] ch,int start,int length){
-		String chars = new String(ch,start,length);
-		strData += chars;
-		if (debugGPX) Vm.debug("Char: " + chars);
+		strBuf.append(ch,start,length);
+		if (debugGPX) Vm.debug("Char: " + strBuf.toString());
 	}
 	
-	public static String latdeg2min(String lat){
-		String res = new String();
-		String deg = new String();
-		String min = new String();
-		Double minDouble = new Double();
-		
-		// Get degrees
-		if (lat.indexOf('.') < 0) lat = lat + ".0";
-		deg = lat.substring(0, lat.indexOf('.'));
-		if (deg.substring(0,1).equals("-")){
-			res = "S " + replace(deg, "-","") + "? ";
-		}
-		else  res = "N " + deg + "? ";
 
-		// Get minutes
-		min = lat.substring(lat.indexOf('.')+1);
-		minDouble.set(Common.parseDouble("0." +min)*60);
-		minDouble.decimalPlaces = 3;
-				
-		// and back to string
-		min = minDouble.toString().replace(',','.');
-		// add leading '0'
-		if (min.indexOf('.') == 1) min = "0" + min;
-		// Build return string
-		res += min;
-		return res;
-	}
-	public static String londeg2min(String lon){
-		String res = new String();
-		String deg = new String();
-		String min = new String();
-		Double minDouble = new Double();
-		
-		
-		// Get degrees
-		if (lon.indexOf('.') < 0) lon = lon + ".0";
-		deg = lon.substring(0, lon.indexOf('.'));
-		if (deg.substring(0,1).equals("-")){
-			res = "W ";
-			deg = replace(deg, "-","");
-		} else  res = "E ";
-		// fill up leading '0'
-		for (int i=deg.length();i<3;i++)
-			res += "0";
-		res += deg + "? ";
-		// Get minutes
-		min = lon.substring(lon.indexOf('.')+1);
-		minDouble.set(Common.parseDouble("0."+ min) * 60);
-		minDouble.decimalPlaces = 3;
-				
-		// and back to string
-		min = minDouble.toString().replace(',','.');
-		// add leading '0'
-		if (min.indexOf('.') == 1) min = "0" + min;
-		// Build return string
-		res += min;
-		return res;
-	}
-
 	public static String typeText2Image(String typeText){
 		if (typeText.equals("Found it")||typeText.equals("Found")||typeText.equals("find")) return "<img src='icon_smile.gif'>&nbsp;";
 		if (typeText.equals("Didn't find it")||typeText.equals("Not Found")||typeText.equals("no_find")) return "<img src='icon_sad.gif'>&nbsp;";
@@ -598,7 +540,7 @@
 		if (imgSpider == null) imgSpider = new SpiderGC(pref, profile, false);
 		
 		if (fromTC) {
-			imgSpider.getImages(holder.LongDescription, holder);
+				imgSpider.getImages(holder.LongDescription, holder);
 		}
 		else {
 			addr = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + holder.wayPoint ;

Modified: trunk/src/CacheWolf/LOCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/LOCXMLImporter.java	2007-09-01 21:55:37 UTC (rev 863)
+++ trunk/src/CacheWolf/LOCXMLImporter.java	2007-09-01 22:13:11 UTC (rev 864)
@@ -90,8 +90,8 @@
 			return;
 		}
 		if (name.equals("coord")){
-			holder.LatLon = GPXImporter.latdeg2min(atts.getValue("lat")) + " " + GPXImporter.londeg2min(atts.getValue("lon"));
 			holder.pos.set(Common.parseDouble(atts.getValue("lat")),Common.parseDouble(atts.getValue("lon")));
+			holder.LatLon = holder.pos.toString();
 			return;
 		}
 

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-09-01 21:55:37 UTC (rev 863)
+++ trunk/src/CacheWolf/MainTab.java	2007-09-01 22:13:11 UTC (rev 864)
@@ -95,8 +95,7 @@
 			// Perform clean up actions for the panel we are leaving
 			onLeavingPanel(oldCard);
 			// Prepare actions for the panel we are about to enter
-			onEnteringPanel(getSelectedItem());
-			oldCard=getSelectedItem();
+			onEnteringPanel(oldCard=((MultiPanelEvent)ev).selectedIndex);
 		}
 		super.onEvent(ev); //Make sure you call this.
 		// If we are in Listview update status

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-09-01 21:55:37 UTC (rev 863)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-09-01 22:13:11 UTC (rev 864)
@@ -54,6 +54,7 @@
 	String logData, logIcon, logDate, logFinder;
 	int logtype;
 	String user;
+	double longitude;
 
 
 	public OCXMLImporter(Preferences p,Profile prof)
@@ -440,12 +441,12 @@
 		}
 
 		if(name.equals("longitude")){
-			chD.LatLon = GPXImporter.londeg2min(strData);
+			longitude = Common.parseDouble(strData);
 			return;
 		}
 		if(name.equals("latitude")) {
-			chD.LatLon = GPXImporter.latdeg2min(strData) + " " + chD.LatLon;
-			chD.pos.set(chD.LatLon);
+			chD.pos.set(Common.parseDouble(strData),longitude);
+			chD.LatLon = chD.pos.toString();
 			return;
 		}
 		if(name.equals("difficulty")) {

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-09-01 21:55:37 UTC (rev 863)
+++ trunk/src/CacheWolf/Profile.java	2007-09-01 22:13:11 UTC (rev 864)
@@ -160,7 +160,8 @@
 					detfile.print("    <CACHE name = \""+SafeXML.clean(ch.CacheName)+"\" owner = \""+SafeXML.clean(ch.CacheOwner)+
 							//"\" lat = \""+ SafeXML.clean(ch.LatLon) +
 							"\" lat = \""+ ch.pos.latDec + "\" lon = \""+ch.pos.lonDec+
-							"\" hidden = \""+ch.DateHidden+"\" wayp = \""+SafeXML.clean(ch.wayPoint)+"\" status = \""+ch.CacheStatus+"\" type = \""+ch.type+"\" dif = \""+ch.hard+"\" terrain = \"" + ch.terrain + "\" dirty = \"" + ch.dirty + "\" size = \""+ch.CacheSize+"\" online = \"" + Convert.toString(ch.is_available) + "\" archived = \"" + Convert.toString(ch.is_archived) + "\" has_bug = \"" + Convert.toString(ch.has_bug) + "\" black = \"" + Convert.toString(ch.is_black) + "\" owned = \"" + Convert.toString(ch.is_owned) + "\" found = \"" + Convert.toString(ch.is_found) + "\" is_new = \"" + Convert.toString(ch.is_new) +"\" is_log_update = \"" + Convert.toString(ch.is_log_update) + "\" is_update = \"" + Convert.toString(ch.is_update) + "\" is_HTML = \"" + Convert.toString(ch.is_HTML) + "\" DNFLOGS = \"" + ch.noFindLogs + "\" ocCacheID = \"" + ch.ocCacheID + "\" is_INCOMPLETE = \""+Convert.toString(ch.is_incomplete)+ "\" lastSyncOC = \"" + ch.lastSyncOC + "\" />\n");
+							"\" hidden = \""+ch.DateHidden+"\" wayp = \""+SafeXML.clean(ch.wayPoint)+"\" status = \""+ch.CacheStatus+"\" type = \""+ch.type+"\" dif = \""+ch.hard+"\" terrain = \"" + ch.terrain + "\" dirty = \"false" + // ch.dirty + dirty is not used, so we save it as false 
+							"\" size = \""+ch.CacheSize+"\" online = \"" + Convert.toString(ch.is_available) + "\" archived = \"" + Convert.toString(ch.is_archived) + "\" has_bug = \"" + Convert.toString(ch.has_bug) + "\" black = \"" + Convert.toString(ch.is_black) + "\" owned = \"" + Convert.toString(ch.is_owned) + "\" found = \"" + Convert.toString(ch.is_found) + "\" is_new = \"" + Convert.toString(ch.is_new) +"\" is_log_update = \"" + Convert.toString(ch.is_log_update) + "\" is_update = \"" + Convert.toString(ch.is_update) + "\" is_HTML = \"" + Convert.toString(ch.is_HTML) + "\" DNFLOGS = \"" + ch.noFindLogs + "\" ocCacheID = \"" + ch.ocCacheID + "\" is_INCOMPLETE = \""+Convert.toString(ch.is_incomplete)+ "\" lastSyncOC = \"" + ch.lastSyncOC + "\" />\n");
 				}
 			}
 			detfile.print("</CACHELIST>\n");
@@ -220,7 +221,8 @@
 					ch.type = ex.findNext();
 					ch.hard = ex.findNext();
 					ch.terrain = ex.findNext();
-					ch.dirty = ex.findNext();
+					//ch.dirty =  ch.dirty is not used 
+					ex.findNext(); // Need to skip dirty
 					ch.CacheSize = ex.findNext();
 					ch.is_available = ex.findNext().equals("true") ? true : false;
 					ch.is_archived = ex.findNext().equals("true") ? true : false;

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-09-01 21:55:37 UTC (rev 863)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-09-01 22:13:11 UTC (rev 864)
@@ -41,49 +41,35 @@
 	/**
 	 * The maximum number of logs that will be stored
 	 */
-	public static int MAXLOGS=250;
+	public static int MAXLOGS=250; // Can be pre-set from preferences
+	public static String passwort = ""; // Can be pre-set from preferences
 
 	private static int ERR_LOGIN = -10;
 	private static Preferences pref;
 	private Profile profile;
-	static String viewstate = "";
-	static String passwort = "";
-	static String cookieID = "";
-	static String cookieSession = "";
-	static double distance = 0;
-	Regex inRex = new Regex();
-	Vector cacheDB;
-	Vector cachesToLoad = new Vector();
-	Hashtable indexDB;
-	InfoBox infB;
+	private static String viewstate = "";
+	private static String cookieID = "";
+	private static String cookieSession = "";
+	private static double distance = 0;
+	private Regex inRex = new Regex();
+	private Vector cacheDB;
+	private Vector cachesToLoad = new Vector();
+	private Hashtable indexDB;
+	private InfoBox infB;
 	private boolean loggedIn = false;
-	private static Properties p=null;
+	private static myProperties p=null;
 
 	public SpiderGC(Preferences prf, Profile profile, boolean bypass){
 		this.profile=profile;
 		this.cacheDB = profile.cacheDB;
 		pref = prf;
-		try {
-			if (p==null) {
-				p=new Properties();
-				p.load(new FileInputStream(File.getProgramDirectory()+"/spider.def"));
-			}
-		} catch (Exception ex) {
-			p=null;
-			pref.log("Failed to load spider.def",ex);
-			// We don't display an error message box here, as the call to
-			// spiderSingle or doIt will do this
+		if (p==null) {
+			pref.logInit();
+			p=new myProperties();
 		}
 		MAXLOGS=pref.maxLogsToSpider;
 	}
 
-	private boolean existsSpiderDef() {
-		if (p==null) {
-			(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5504,"Could not load 'spider.def'"), MessageBox.OKB)).execute();
-			return false;
-		}
-		return true;
-	}
 	/**
 	 * Method to login the user to gc.com
 	 * It will request a password and use the alias defined in preferences
@@ -91,10 +77,15 @@
 	 * If the login fails, an appropriate message is displayed.
 	 */
 	public int login(){
-		pref.logInit();
 		loggedIn = false;
-		//Access the page once to get a viewstate
-		String start,doc,loginPage;
+		String start,doc,loginPage,loginSuccess,nextPage;
+		try {
+			loginPage=p.getProp("loginPage");
+			loginSuccess=p.getProp("loginSuccess");
+			nextPage=p.getProp("nextPage");
+		} catch (Exception ex) { // Tag not found in spider.def
+			return ERR_LOGIN;
+		}
 		//Get password
 		InfoBox infB = new InfoBox(MyLocale.getMsg(5506,"Password"), MyLocale.getMsg(5505,"Enter Password"), InfoBox.INPUT);
 		infB.feedback.setText(passwort); // Remember the PWD for next time
@@ -108,12 +99,9 @@
 		infB.exec();
 		try{
 			pref.log("Fetching login page");
-			start = fetch(loginPage=p.getProperty("loginPage"));   //http://www.geocaching.com/login/Default.aspx
-		}catch (NullPointerException ex) {
-			(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5497,"Error missing tag in spider.def") + ": loginPage", MessageBox.OKB)).execute();
-			pref.log("Error missing tag in spider.def: loginPage",ex);
-			return ERR_LOGIN;
-		}catch(Exception ex){
+			//Access the page once to get a viewstate
+			start = fetch(loginPage);   //http://www.geocaching.com/login/Default.aspx
+		} catch(Exception ex){
 			infB.close(0);
 			(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5499,"Error loading login page"), MessageBox.OKB)).execute();
 			pref.log("Could not fetch: gc.com login page",ex);
@@ -138,18 +126,15 @@
 				    + "&" + URL.encodeURL("myPassword",false) +"="+ encodeUTF8(new String(Utils.encodeJavaUtf8String(passwort)))
 				    + "&" + URL.encodeURL("cookie",false) +"="+ URL.encodeURL("on",false)
 				    + "&" + URL.encodeURL("Button1",false) +"="+ URL.encodeURL("Login",false);
-				start = fetch_post(loginPage, doc, p.getProperty("nextPage"));  // /login/default.aspx
-				if(start.indexOf(p.getProperty("loginSuccess")) > 0) pref.log("Login successful");
+				start = fetch_post(loginPage, doc, nextPage);  // /login/default.aspx
+				if(start.indexOf(loginSuccess) > 0) 
+					pref.log("Login successful");
 				else {
 					pref.log("Login failed. Wrong Account or Password?");
 					infB.close(0);
 				    (new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5501,"Login failed! Wrong account or password?"), MessageBox.OKB)).execute();
 					return ERR_LOGIN;
 				}
-			}catch (NullPointerException ex) {
-				(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5497,"Error missing tag in spider.def") + ": loginSuccess", MessageBox.OKB)).execute();
-				pref.log("Error missing tag in spider.def: loginSuccess",ex);
-				return ERR_LOGIN;
 			}catch(Exception ex){
 				pref.log("Login failed.", ex);
 				infB.close(0);
@@ -194,7 +179,6 @@
 	public boolean spiderSingle(int number, InfoBox infB){
 		boolean ret=false;
 		this.infB = infB;
-		if (!existsSpiderDef()) return false;
 		CacheHolder ch = (CacheHolder)cacheDB.get(number);
 		if (ch.isAddiWpt()) return false;  // No point re-spidering an addi waypoint, comes with parent
 
@@ -217,7 +201,7 @@
 			if (ret) {
 				pref.log("Saving to:" + profile.dataDir);
 				chD.saveCacheDetails(profile.dataDir);
-				cacheDB.set(number, new CacheHolder(chD)); // TODO Could copy into existing object
+				((CacheHolder) cacheDB.get(number)).update(chD); 
 			}
 		}catch(Exception ex){
 			pref.log("Error spidering " + chD.wayPoint + " in spiderSingle");
@@ -232,14 +216,15 @@
 	 */
 	public String getCacheCoordinates(String wayPoint) {
 		String completeWebPage;
+		// Check whether spider definitions could be loaded, if not issue appropriate message and terminate
+		// Try to login. If login fails, issue appropriate message and terminate
+		if (login()!=Form.IDOK) {
+			return "";
+		}
 		InfoBox infB = new InfoBox("Info", "Loading", InfoBox.PROGRESS_WITH_WARNINGS);
 		infB.exec();
-		// Check whether spider definitions could be loaded, if not issue appropriate message and terminate
-		if (!existsSpiderDef()) return "";
-		// Try to login. If login fails, issue appropriate message and terminate
-		if (login()!=Form.IDOK) return "";
-		String doc = p.getProperty("waypoint") + wayPoint;
 		try{
+			String doc = p.getProp("waypoint") + wayPoint;
 			pref.log("Fetching: " + wayPoint);
 			completeWebPage = fetch(doc);
 		}catch(Exception ex){
@@ -248,7 +233,11 @@
 			return "";
 		}
 		infB.close(0);
-		return getLatLon(completeWebPage);
+		try {
+			return getLatLon(completeWebPage);
+		} catch (Exception ex) {
+			return "????";
+		}
 	}
 
 	/**
@@ -258,7 +247,6 @@
 		String postStr, dummy, ln, wpt;
 		Regex lineRex;
 		CacheHolderDetail chD;
-		if (!existsSpiderDef()) return;
 		CWPoint origin = pref.curCentrePt; // No need to copy curCentrePt as it is only read and not written
 		if (!origin.isValid()) {
 			(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5509,"Coordinates for center must be set"), MessageBox.OKB)).execute();
@@ -297,7 +285,7 @@
 		infB.exec();
 		//Get first page
 		try{
-			ln = p.getProperty("firstPage") + origin.getLatDeg(CWPoint.DD) + p.getProperty("firstPage2") +origin.getLonDeg(CWPoint.DD);
+			ln = p.getProp("firstPage") + origin.getLatDeg(CWPoint.DD) + p.getProp("firstPage2") +origin.getLonDeg(CWPoint.DD);
 			if(doNotgetFound) ln = ln + "&f=1";
 			pref.log("Getting first page: "+ln);
 			start = fetch(ln);
@@ -312,55 +300,66 @@
 		dummy = "";
 		//String lineBlck = "";
 		int page_number = 4;
-		lineRex = new Regex(p.getProperty("lineRex")); //"<tr bgcolor=((?s).*?)</tr>"
+		try  {
+			lineRex = new Regex(p.getProp("lineRex")); //"<tr bgcolor=((?s).*?)</tr>"
+		} catch (Exception ex) {
+			infB.close(0);
+			Vm.showWait(false);
+			return;
+		}
 		int found_on_page = 0;
-		//Loop till maximum distance has been found or no more caches are in the list
-		while(distance > 0){
-			if (infB.isClosed) break;
-			rex.search(start);
-			viewstate = rex.stringMatched(1);
-			//Vm.debug("In loop");
-			Regex listBlockRex = new Regex(p.getProperty("listBlockRex")); // "<table id=\"dlResults\"((?s).*?)</table>"
-			listBlockRex.search(start);
-			dummy = listBlockRex.stringMatched(1);
-			try{
-				lineRex.search(dummy);
-			}catch(NullPointerException nex){}
-			while(lineRex.didMatch()){
-				//Vm.debug(getDist(lineRex.stringMatched(1)) + " / " +getWP(lineRex.stringMatched(1)));
-				found_on_page++;
-				if(getDist(lineRex.stringMatched(1)) <= distance){
-					if(indexDB.get((String)getWP(lineRex.stringMatched(1))) == null){
-						cachesToLoad.add(getWP(lineRex.stringMatched(1)));
-					} else pref.log(getWP(lineRex.stringMatched(1))+" already in DB");
-				} else distance = 0;
-				lineRex.searchFrom(dummy, lineRex.matchedTo());
-			}
-			infB.setInfo(MyLocale.getMsg(5511,"Found ") + cachesToLoad.size() + MyLocale.getMsg(5512," caches"));
-			if(found_on_page < 20) distance = 0;
-			postStr = p.getProperty("firstLine") + origin.getLatDeg(CWPoint.DD) + "&" + origin.getLonDeg(CWPoint.DD);
-			if(doNotgetFound) postStr = postStr + p.getProperty("showOnlyFound");
-			if(distance > 0){
-				page_number++;
-				if(page_number >= 15) page_number = 5;
-				doc = URL.encodeURL("__VIEWSTATE",false) +"="+ URL.encodeURL(viewstate,false)
-				//if(doNotgetFound) doc += "&f=1";
-				    + "&" + URL.encodeURL("__EVENTTARGET",false) +"="+ URL.encodeURL("ResultsPager:_ctl"+page_number,false)
-				    + "&" + URL.encodeURL("__EVENTARGUMENT",false) +"="+ URL.encodeURL("",false);
+		try {
+			//Loop till maximum distance has been found or no more caches are in the list
+			while(distance > 0){
+				if (infB.isClosed) break;
+				rex.search(start);
+				viewstate = rex.stringMatched(1);
+				//Vm.debug("In loop");
+				Regex listBlockRex = new Regex(p.getProp("listBlockRex")); // "<table id=\"dlResults\"((?s).*?)</table>"
+				listBlockRex.search(start);
+				dummy = listBlockRex.stringMatched(1);
 				try{
-					start = "";
-					pref.log("Fetching next list page:" + doc);
-					start = fetch_post(postStr, doc, p.getProperty("nextListPage"));
-				}catch(Exception ex){
-					//Vm.debug("Couldn't get the next page");
-					pref.log("Error getting next page");
-				}finally{
+					lineRex.search(dummy);
+				}catch(NullPointerException nex){}
+				while(lineRex.didMatch()){
+					//Vm.debug(getDist(lineRex.stringMatched(1)) + " / " +getWP(lineRex.stringMatched(1)));
+					found_on_page++;
+					if(getDist(lineRex.stringMatched(1)) <= distance){
+						if(indexDB.get((String)getWP(lineRex.stringMatched(1))) == null){
+							cachesToLoad.add(getWP(lineRex.stringMatched(1)));
+						} else pref.log(getWP(lineRex.stringMatched(1))+" already in DB");
+					} else distance = 0;
+					lineRex.searchFrom(dummy, lineRex.matchedTo());
 				}
+				infB.setInfo(MyLocale.getMsg(5511,"Found ") + cachesToLoad.size() + MyLocale.getMsg(5512," caches"));
+				if(found_on_page < 20) distance = 0;
+				postStr = p.getProp("firstLine") + origin.getLatDeg(CWPoint.DD) + "&" + origin.getLonDeg(CWPoint.DD);
+				if(doNotgetFound) postStr = postStr + p.getProp("showOnlyFound");
+				if(distance > 0){
+					page_number++;
+					if(page_number >= 15) page_number = 5;
+					doc = URL.encodeURL("__VIEWSTATE",false) +"="+ URL.encodeURL(viewstate,false)
+					//if(doNotgetFound) doc += "&f=1";
+					    + "&" + URL.encodeURL("__EVENTTARGET",false) +"="+ URL.encodeURL("ResultsPager:_ctl"+page_number,false)
+					    + "&" + URL.encodeURL("__EVENTARGUMENT",false) +"="+ URL.encodeURL("",false);
+					try{
+						start = "";
+						pref.log("Fetching next list page:" + doc);
+						start = fetch_post(postStr, doc, p.getProp("nextListPage"));
+					}catch(Exception ex){
+						//Vm.debug("Couldn't get the next page");
+						pref.log("Error getting next page");
+					}finally{
+					}
+				}
+				//Vm.debug("Distance is now: " + distance);
+				found_on_page = 0;
 			}
-			//Vm.debug("Distance is now: " + distance);
-			found_on_page = 0;
+		} catch (Exception ex) { // Some tag missing from spider.def
+			infB.close(0);
+			Vm.showWait(false);
+			return;
 		}
-
 		pref.log("Found " + cachesToLoad.size() + " caches");
 		if (!infB.isClosed) infB.setInfo(MyLocale.getMsg(5511,"Found ") + cachesToLoad.size() + MyLocale.getMsg(5512," caches"));
 
@@ -404,9 +403,9 @@
 	 * @return false if the infoBox was closed
 	 */
 	private boolean getCacheByWaypointName(CacheHolderDetail chD, boolean isUpdate, boolean fetchImages, boolean doNotGetFound, boolean fetchAllLogs) {
-		String completeWebPage,origLongDesc;
-		String doc = p.getProperty("getPageByName") + chD.wayPoint +(fetchAllLogs?p.getProperty("fetchAllLogs"):"");
+		String completeWebPage;
 		try{
+			String doc = p.getProp("getPageByName") + chD.wayPoint +(fetchAllLogs?p.getProp("fetchAllLogs"):"");
 			pref.log("Fetching: " + chD.wayPoint);
 			completeWebPage = fetch(doc);
 		}catch(Exception ex){
@@ -430,19 +429,16 @@
 				chD.Images.clear();
 				chD.ImagesText.clear();
 
-				if(completeWebPage.indexOf(p.getProperty("cacheUnavailable")) >= 0) chD.is_available = false;
-				if(completeWebPage.indexOf(p.getProperty("cacheArchived")) >= 0) chD.is_archived = true;
+				if(completeWebPage.indexOf(p.getProp("cacheUnavailable")) >= 0) chD.is_available = false;
+				if(completeWebPage.indexOf(p.getProp("cacheArchived")) >= 0) chD.is_archived = true;
 				//==========
 				// General Cache Data
 				//==========
-				chD.LatLon = getLatLon(completeWebPage);
-				chD.pos.set(chD.LatLon);
+				chD.setLatLon(getLatLon(completeWebPage));
 				if (pref.debug) pref.log("LatLon: " + chD.LatLon);
 
 				pref.log("Trying description");
-				origLongDesc = chD.LongDescription;
-				chD.LongDescription = getLongDesc(completeWebPage);
-				if(isUpdate && !chD.LongDescription.equals(origLongDesc)) chD.is_update = true;
+				chD.setLongDescription(getLongDesc(completeWebPage));
 				pref.log("Got description");
 
 				pref.log("Getting cache name");
@@ -462,7 +458,7 @@
 				if (pref.debug) pref.log("Hidden: " + chD.DateHidden);
 
 				pref.log("Trying hints");
-				chD.Hints = getHints(completeWebPage);
+				chD.setHints(getHints(completeWebPage));
 				pref.log("Got hints");
 				if (pref.debug) pref.log("Hints: " + chD.Hints);
 
@@ -490,20 +486,9 @@
 				// Logs
 				//==========
 				pref.log("Trying logs");
-				chD.CacheLogs = getLogs(completeWebPage, chD);
-				// Count the number of not-found logs
-				int countNoFoundLogs = 0;
-				String loganal = "";
-				while(countNoFoundLogs < chD.CacheLogs.size() && countNoFoundLogs < 5){
-					loganal = (String)chD.CacheLogs.get(countNoFoundLogs);
-					if(loganal.indexOf("icon_sad")>0) {
-						countNoFoundLogs++;
-					}else break;
-				}
-				chD.noFindLogs = countNoFoundLogs;
-				chD.is_log_update = false;
-				if(isUpdate && chD.CacheLogs.size()>logsz) chD.is_log_update = true;
+				chD.setCacheLogs(getLogs(completeWebPage, chD));
 				pref.log("Found logs");
+				
 				// If the switch is set to not store found caches and we found the cache => return
 				if (chD.is_found && doNotGetFound) return !infB.isClosed;
 
@@ -536,9 +521,7 @@
 				pref.log("Getting attributes");
 				getAttributes(completeWebPage, chD);
 				pref.log("Got attributes");
-
-
-
+				if (chD.is_new) chD.is_update=false;
 			}catch(Exception ex){
 				pref.log("Error reading cache: "+chD.wayPoint);
 				pref.log("Exception in getCacheByWaypointName: ",ex);
@@ -566,8 +549,8 @@
 	 * @param doc A previously fetched cachepage
 	 * @return Distance
 	 */
-	private double getDist(String doc){
-		inRex = new Regex(p.getProperty("distRex"));
+	private double getDist(String doc) throws Exception {
+		inRex = new Regex(p.getProp("distRex"));
 		inRex.search(doc);
 		if(doc.indexOf("Here") >= 0) return(0);
 		if (!inRex.didMatch()) return 0;
@@ -580,8 +563,8 @@
 	 * @param doc A previously fetched cachepage
 	 * @return Name of waypoint to add to list
 	 */
-	private String getWP(String doc){
-		inRex = new Regex(p.getProperty("waypointRex"));
+	private String getWP(String doc) throws Exception {
+		inRex = new Regex(p.getProp("waypointRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) return "???";
 		return inRex.stringMatched(1);
@@ -592,8 +575,8 @@
 	 * @param doc A previously fetched cachepage
 	 * @return Cache coordinates
 	 */
-	private String getLatLon(String doc){
-		inRex = new Regex(p.getProperty("latLonRex"));
+	private String getLatLon(String doc) throws Exception{
+		inRex = new Regex(p.getProp("latLonRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) return "???";
 		return inRex.stringMatched(1);
@@ -604,10 +587,10 @@
 	 * @param doc A previously fetched cachepage
 	 * @return the long description
 	 */
-	private String getLongDesc(String doc){
+	private String getLongDesc(String doc) throws Exception{
 		String res = "";
-		inRex = new Regex(p.getProperty("shortDescRex"));
-		Regex rex2 = new Regex(p.getProperty("longDescRex"));
+		inRex = new Regex(p.getProp("shortDescRex"));
+		Regex rex2 = new Regex(p.getProp("longDescRex"));
 		inRex.search(doc);
 		rex2.search(doc);
 		res = ((inRex.stringMatched(1)==null)?"":inRex.stringMatched(1)) + "<br>";
@@ -620,8 +603,8 @@
 	 * @param doc A previously fetched cachepage
 	 * @return the name of the cache
 	 */
-	private String getName(String doc){
-		inRex = new Regex(p.getProperty("cacheNameRex"));
+	private String getName(String doc) throws Exception{
+		inRex = new Regex(p.getProp("cacheNameRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) return "???";
 		return inRex.stringMatched(1);
@@ -632,8 +615,8 @@
 	 * @param doc A previously fetched cachepage
 	 * @return the cache owner
 	 */
-	private String getOwner(String doc){
-		inRex = new Regex(p.getProperty("cacheOwnerRex"));
+	private String getOwner(String doc) throws Exception{
+		inRex = new Regex(p.getProp("cacheOwnerRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) return "???";
 		return inRex.stringMatched(1);
@@ -644,8 +627,8 @@
 	 * @param doc A previously fetched cachepage
 	 * @return Hidden date
 	 */
-	private String getDateHidden(String doc){
-		inRex = new Regex(p.getProperty("dateHiddenRex"));
+	private String getDateHidden(String doc) throws Exception{
+		inRex = new Regex(p.getProp("dateHiddenRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) return "???";
 		return inRex.stringMatched(1);
@@ -656,8 +639,8 @@
 	 * @param doc A previously fetched cachepage
 	 * @return Cachehints
 	 */
-	private String getHints(String doc){
-		inRex = new Regex(p.getProperty("hintsRex"));
+	private String getHints(String doc) throws Exception{
+		inRex = new Regex(p.getProp("hintsRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) return "";
 		return inRex.stringMatched(1);
@@ -668,8 +651,8 @@
 	 * @param doc A previously fetched cachepage
 	 * @return Cache size
 	 */
-	private String getSize(String doc){
-		inRex = new Regex(p.getProperty("sizeRex"));
+	private String getSize(String doc) throws Exception{
+		inRex = new Regex(p.getProp("sizeRex"));
 		inRex.search(doc);
 		if(inRex.didMatch()) return inRex.stringMatched(1);
 		else return "None";
@@ -680,8 +663,8 @@
 	 * @param doc A previously fetched cachepage
 	 * @return The cache difficulty
 	 */
-	private String getDiff(String doc){
-		inRex = new Regex(p.getProperty("difficultyRex"));
+	private String getDiff(String doc) throws Exception{
+		inRex = new Regex(p.getProp("difficultyRex"));
 		inRex.search(doc);
 		if(inRex.didMatch()) return inRex.stringMatched(1);
 		else return "";
@@ -692,8 +675,8 @@
 	 * @param doc A previously fetched cachepage
 	 * @return Terrain rating
 	 */
-	private String getTerr(String doc){
-		inRex = new Regex(p.getProperty("terrainRex"));
+	private String getTerr(String doc) throws Exception{
+		inRex = new Regex(p.getProp("terrainRex"));
 		inRex.search(doc);
 		if(inRex.didMatch()) return inRex.stringMatched(1);
 		else return "";
@@ -704,8 +687,8 @@
 	 * @param doc A previously fetched cachepage
 	 * @return the waypoint type (Tradi, Multi, etc.)
 	 */
-	private String getType(String doc){
-		inRex = new Regex(p.getProperty("cacheTypeRex"));
+	private String getType(String doc) throws Exception{
+		inRex = new Regex(p.getProp("cacheTypeRex"));
 		inRex.search(doc);
 		if(inRex.didMatch()) return inRex.stringMatched(1);
 		else return "";
@@ -717,11 +700,11 @@
 	 * @param chD Cache Details
 	 * @return A HTML string containing the logs
 	 */
-	private Vector getLogs(String doc, CacheHolderDetail chD){
+	private Vector getLogs(String doc, CacheHolderDetail chD) throws Exception{
 		String icon = "";
 		String name = "";
 		Vector reslts = new Vector();
-		Regex blockRex = new Regex(p.getProperty("blockRex"));
+		Regex blockRex = new Regex(p.getProp("blockRex"));
 		blockRex.search(doc);
 		doc = blockRex.stringMatched(1);
 		//Vm.debug("Log Block: " + doc);
@@ -739,15 +722,15 @@
 		}
 		*/
 		String singleLog = "";
-		Extractor exSingleLog = new Extractor(doc,p.getProperty("singleLogExStart"), p.getProperty("singleLogExEnd"), 0, false); // maybe here is some change neccessary because findnext now gives the whole endstring back???
+		Extractor exSingleLog = new Extractor(doc,p.getProp("singleLogExStart"), p.getProp("singleLogExEnd"), 0, false); // maybe here is some change neccessary because findnext now gives the whole endstring back???
 		singleLog = exSingleLog.findNext();
-		Extractor exIcon = new Extractor(singleLog,p.getProperty("iconExStart"), p.getProperty("iconExEnd"), 0, true);
-		Extractor exNameTemp = new Extractor(singleLog,p.getProperty("nameTempExStart"), p.getProperty("nameTempExEnd"), 0 , true);
+		Extractor exIcon = new Extractor(singleLog,p.getProp("iconExStart"), p.getProp("iconExEnd"), 0, true);
+		Extractor exNameTemp = new Extractor(singleLog,p.getProp("nameTempExStart"), p.getProp("nameTempExEnd"), 0 , true);
 		String nameTemp = "";
 		nameTemp = exNameTemp.findNext();
-		Extractor exName = new Extractor(nameTemp, p.getProperty("nameExStart"), p.getProperty("nameExEnd"), 0 , true);
-		Extractor exDate = new Extractor(singleLog,p.getProperty("dateExStart"), p.getProperty("dateExEnd"), 0 , true);
-		Extractor exLog = new Extractor(singleLog, p.getProperty("logExStart"), p.getProperty("logExEnd"), 0, true);
+		Extractor exName = new Extractor(nameTemp, p.getProp("nameExStart"), p.getProp("nameExEnd"), 0 , true);
+		Extractor exDate = new Extractor(singleLog,p.getProp("dateExStart"), p.getProp("dateExEnd"), 0 , true);
+		Extractor exLog = new Extractor(singleLog, p.getProp("logExStart"), p.getProp("logExEnd"), 0, true);
 		//Vm.debug("Log Block: " + singleLog);
 		int nLogs=0;
 		while(exSingleLog.endOfSearch() == false){
@@ -762,7 +745,7 @@
 			icon = exIcon.findNext();
 			name = exName.findNext();
 			String d=DateFormat.logdate2YMD(exDate.findNext());
-			if((icon.equals(p.getProperty("icon_smile")) || icon.equals(p.getProperty("icon_camera"))) &&
+			if((icon.equals(p.getProp("icon_smile")) || icon.equals(p.getProp("icon_camera"))) &&
 				(name.equals(pref.myAlias) || (pref.myAlias2.length()>0 && name.equals(pref.myAlias2))) )  {
 				chD.is_found = true;
 				chD.CacheStatus = d;
@@ -792,11 +775,11 @@
 	 * @param doc The previously fetched cachepage
 	 * @return A HTML formatted string with bug names and there purpose
 	 */
-	public void getBugs(CacheHolderDetail chD, String doc){
-		Extractor exBlock = new Extractor(doc,p.getProperty("blockExStart"),p.getProperty("blockExEnd") ,0,Extractor.EXCLUDESTARTEND);
+	public void getBugs(CacheHolderDetail chD, String doc) throws Exception{
+		Extractor exBlock = new Extractor(doc,p.getProp("blockExStart"),p.getProp("blockExEnd") ,0,Extractor.EXCLUDESTARTEND);
 		String bugBlock = exBlock.findNext();
 		//Vm.debug("Bugblock: "+bugBlock);
-		Extractor exBug = new Extractor(bugBlock,p.getProperty("bugExStart"),p.getProperty("bugExEnd"),0,Extractor.EXCLUDESTARTEND);
+		Extractor exBug = new Extractor(bugBlock,p.getProp("bugExStart"),p.getProp("bugExEnd"),0,Extractor.EXCLUDESTARTEND);
 		String link,bug,linkPlusBug,bugDetails;
 		String oldInfoBox=infB.getInfo();
 		chD.Travelbugs.clear();
@@ -813,7 +796,7 @@
 					infB.setInfo(oldInfoBox+MyLocale.getMsg(5514,"\nGetting bug: ")+bug);
 					pref.log("Fetching bug details: "+bug);
 					bugDetails = fetch(link);
-					Extractor exDetails = new Extractor(bugDetails,p.getProperty("bugDetailsStart"),p.getProperty("bugDetailsEnd"),0,Extractor.EXCLUDESTARTEND);
+					Extractor exDetails = new Extractor(bugDetails,p.getProp("bugDetailsStart"),p.getProp("bugDetailsEnd"),0,Extractor.EXCLUDESTARTEND);
 					tb.setMission(exDetails.findNext());
 					Extractor exGuid = new Extractor(bugDetails,"details.aspx?guid=","\" id=\"Form1",0,Extractor.EXCLUDESTARTEND); // TODO Replace with spider.def see also further down
 					tb.setGuid(exGuid.findNext());
@@ -839,17 +822,23 @@
 		int imgCounter = 0;
 		String imgName, oldImgName, imgType, imgUrl;
 		Vector spideredUrls=new Vector(15);
+		Extractor exImgBlock;
 		int idxUrl; // Index of already spidered Url in list of spideredUrls
 		//========
 		//In the long description
 		//========
 		String longDesc = "";
-		if (chD.wayPoint.startsWith("TC")) longDesc = doc;
-		else longDesc = getLongDesc(doc);
-		longDesc = STRreplace.replace(longDesc, "<img", "<IMG");
-		longDesc = STRreplace.replace(longDesc, "src=", "SRC=");
-		longDesc = STRreplace.replace(longDesc, "'", "\"");
-		Extractor exImgBlock = new Extractor(longDesc,p.getProperty("imgBlockExStart"),p.getProperty("imgBlockExEnd"), 0, false);
+		try {
+			if (chD.wayPoint.startsWith("TC")) longDesc = doc;
+			else 
+				longDesc = getLongDesc(doc);
+			longDesc = STRreplace.replace(longDesc, "<img", "<IMG");
+			longDesc = STRreplace.replace(longDesc, "src=", "SRC=");
+			longDesc = STRreplace.replace(longDesc, "'", "\"");
+			exImgBlock = new Extractor(longDesc,p.getProp("imgBlockExStart"),p.getProp("imgBlockExEnd"), 0, false);
+		} catch (Exception ex) {//Missing property in spider.def
+			return;
+		}
 		//Vm.debug("In getImages: Have longDesc" + longDesc);
 		String tst;
 		tst = exImgBlock.findNext();
@@ -890,10 +879,15 @@
 		//========
 		//In the image span
 		//========
-		Extractor spanBlock = new Extractor(doc,p.getProperty("imgSpanExStart"),p.getProperty("imgSpanExEnd"), 0 , true);
-		tst = spanBlock.findNext();
-		Extractor exImgName = new Extractor(tst,p.getProperty("imgNameExStart"),p.getProperty("imgNameExEnd"), 0 , true);
-		exImgSrc = new Extractor(tst,p.getProperty("imgSrcExStart"),p.getProperty("imgSrcExEnd"), 0, true);
+		Extractor spanBlock,exImgName;
+		try {
+			spanBlock = new Extractor(doc,p.getProp("imgSpanExStart"),p.getProp("imgSpanExEnd"), 0 , true);
+			tst = spanBlock.findNext();
+			exImgName = new Extractor(tst,p.getProp("imgNameExStart"),p.getProp("imgNameExEnd"), 0 , true);
+			exImgSrc = new Extractor(tst,p.getProp("imgSrcExStart"),p.getProp("imgSrcExEnd"), 0, true);
+		} catch (Exception ex) { // Missing property in spider .def
+			return;
+		}
 		while(exImgSrc.endOfSearch() == false){
 			imgUrl = exImgSrc.findNext();
 			//Vm.debug("Img Url: " +imgUrl);
@@ -971,59 +965,57 @@
 	 * @param wayPoint The name of the cache
 	 * @param is_found Found status of the cached (is inherited by the additional waypoints)
 	 */
-	public void getAddWaypoints(String doc, String wayPoint, boolean is_found){
-		Extractor exWayBlock = new Extractor(doc,p.getProperty("wayBlockExStart"),p.getProperty("wayBlockExEnd"), 0, false);
+	public void getAddWaypoints(String doc, String wayPoint, boolean is_found) throws Exception{
+		Extractor exWayBlock = new Extractor(doc,p.getProp("wayBlockExStart"),p.getProp("wayBlockExEnd"), 0, false);
 		String wayBlock = "";
 		String rowBlock = "";
 		wayBlock = exWayBlock.findNext();
-		Regex nameRex = new Regex(p.getProperty("nameRex"));
-		Regex koordRex = new Regex(p.getProperty("koordRex"));
-		Regex descRex = new Regex(p.getProperty("descRex"));
-		Regex typeRex = new Regex(p.getProperty("typeRex"));
+		Regex nameRex = new Regex(p.getProp("nameRex"));
+		Regex koordRex = new Regex(p.getProp("koordRex"));
+		Regex descRex = new Regex(p.getProp("descRex"));
+		Regex typeRex = new Regex(p.getProp("typeRex"));
 		int counter = 0;
 		if(exWayBlock.endOfSearch() == false && wayBlock.indexOf("No additional waypoints to display.")<0){
-			Extractor exRowBlock = new Extractor(wayBlock,p.getProperty("rowBlockExStart"),p.getProperty("rowBlockExEnd"), 0, false);
+			Extractor exRowBlock = new Extractor(wayBlock,p.getProp("rowBlockExStart"),p.getProp("rowBlockExEnd"), 0, false);
 			rowBlock = exRowBlock.findNext();
 			rowBlock = exRowBlock.findNext();
 			while(exRowBlock.endOfSearch()==false){
-				CacheHolderDetail cx = new CacheHolderDetail();
-				cx.wayPoint = MyLocale.formatLong(counter, "00") + wayPoint.substring(2);
+				CacheHolderDetail cxD = new CacheHolderDetail();
+				cxD.wayPoint = MyLocale.formatLong(counter, "00") + wayPoint.substring(2);
 				counter++;
 				try{ // If addi exists, try to read it to preserve the notes
-					cx.readCache(profile.dataDir);
+					cxD.readCache(profile.dataDir);
 				} catch (Exception ex) {};
 				nameRex.search(rowBlock);
 				koordRex.search(rowBlock);
 				typeRex.search(rowBlock);
-				cx.CacheName = nameRex.stringMatched(1);
-				//Vm.debug("Addi: " + cx.CacheName);
-				if(koordRex.didMatch()) cx.pos.set(koordRex.stringMatched(1));
-				cx.LatLon = cx.pos.toString();
-				//cx.pos.set(cx.LatLon);
-				if(typeRex.didMatch()) cx.type = CacheType.typeText2Number("Waypoint|"+typeRex.stringMatched(1));
+				cxD.CacheName = nameRex.stringMatched(1);
+				if(koordRex.didMatch()) cxD.setLatLon(koordRex.stringMatched(1));
+				if(typeRex.didMatch()) cxD.type = CacheType.typeText2Number("Waypoint|"+typeRex.stringMatched(1));
 				rowBlock = exRowBlock.findNext();
 				descRex.search(rowBlock);
-				cx.LongDescription = descRex.stringMatched(1);
-				//Vm.debug(descRex.stringMatched(1));
-				int idx=profile.getCacheIndex(cx.wayPoint);
-				cx.is_found = is_found;
-				//Vm.debug("IDX: " + idx);
+				cxD.setLongDescription(descRex.stringMatched(1));
+				cxD.is_found = is_found;
+				cxD.saveCacheDetails(profile.dataDir);
+				
+				int idx=profile.getCacheIndex(cxD.wayPoint);
 				if (idx<0){
-					cacheDB.add(new CacheHolder(cx));
-				}else if (((CacheHolder) cacheDB.get(idx)).is_Checked && // Only re-spider existing addi waypoints that are ticked
-						!((CacheHolder) cacheDB.get(idx)).is_filtered) // and are visible (i.e.  not filtered)
-					cacheDB.set(idx,new CacheHolder(
-					    new CacheHolderDetail(((CacheHolder) cacheDB.get(idx))).update(cx)));
-				cx.saveCacheDetails(profile.dataDir);
+					cacheDB.add(new CacheHolder(cxD));
+				}else {
+					CacheHolder cx=(CacheHolder) cacheDB.get(idx);
+					if (cx.is_Checked && // Only re-spider existing addi waypoints that are ticked
+				 	   !cx.is_filtered) // and are visible (i.e.  not filtered)
+					   cx.update(cxD);
+				}
 				rowBlock = exRowBlock.findNext();
 			}
 		}
 	}
 
-	private void getAttributes(String doc, CacheHolderDetail chD) {
-		Extractor attBlock = new Extractor(doc,p.getProperty("attBlockExStart"),p.getProperty("attBlockExEnd"), 0 , true);
+	private void getAttributes(String doc, CacheHolderDetail chD) throws Exception {
+		Extractor attBlock = new Extractor(doc,p.getProp("attBlockExStart"),p.getProp("attBlockExEnd"), 0 , true);
 		String atts = attBlock.findNext();
-		Extractor attEx = new Extractor(atts,p.getProperty("attExStart"),p.getProperty("attExEnd"), 0 , true);
+		Extractor attEx = new Extractor(atts,p.getProp("attExStart"),p.getProp("attExEnd"), 0 , true);
 		String attribute=attEx.findNext();
 		chD.attributes.clear();
 		while (attEx.endOfSearch()==false) {
@@ -1286,27 +1278,30 @@
 	 * @param name The name (or partial name) of a travelbug
 	 * @return the id of the bug
 	 */
-	public String getBugId(String name) {
+	public String getBugId (String name) {
 		String bugList;
-		if (!existsSpiderDef()) return "";
 		try{
 			//infB.setInfo(oldInfoBox+"\nGetting bug: "+bug);
 			pref.log("Fetching bugId: "+name);
-			bugList = fetch(p.getProperty("getBugByName")+STRreplace.replace(SafeXML.clean(name)," ","+"));
+			bugList = fetch(p.getProp("getBugByName")+STRreplace.replace(SafeXML.clean(name)," ","+"));
 		}catch(Exception ex){
 			pref.log("Could not fetch bug list");
 			bugList="";
 		}
-		if (bugList.equals("") || bugList.indexOf(p.getProperty("bugNotFound"))>=0) {
-			(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(6020,"Travelbug not found."), MessageBox.OKB)).execute();
+		try {
+			if (bugList.equals("") || bugList.indexOf(p.getProp("bugNotFound"))>=0) {
+				(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(6020,"Travelbug not found."), MessageBox.OKB)).execute();
+				return "";
+			}
+			if (bugList.indexOf(p.getProp("bugTotalRecords"))<0) {
+				(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(6021,"More than one travelbug found. Specify name more precisely."), MessageBox.OKB)).execute();
+				return "";
+			}
+			Extractor exGuid = new Extractor(bugList,p.getProp("bugGuidExStart"),p.getProp("bugGuidExEnd"),0,Extractor.EXCLUDESTARTEND); // TODO Replace with spider.def
+			return exGuid.findNext();
+		} catch (Exception ex) {
 			return "";
 		}
-		if (bugList.indexOf(p.getProperty("bugTotalRecords"))<0) {
-			(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(6021,"More than one travelbug found. Specify name more precisely."), MessageBox.OKB)).execute();
-			return "";
-		}
-		Extractor exGuid = new Extractor(bugList,p.getProperty("bugGuidExStart"),p.getProperty("bugGuidExEnd"),0,Extractor.EXCLUDESTARTEND); // TODO Replace with spider.def
-		return exGuid.findNext();
 	}
 
 	/**
@@ -1317,23 +1312,47 @@
 	 */
 	public String getBugMissionByGuid(String guid) {
 		String bugDetails;
-		if (!existsSpiderDef()) return "";
 		try{
 			//infB.setInfo(oldInfoBox+"\nGetting bug: "+bug);
 			pref.log("Fetching bug detailsById: "+guid);
 			if (guid.length()>10)
-				bugDetails = fetch(p.getProperty("getBugByGuid")+guid);
+				bugDetails = fetch(p.getProp("getBugByGuid")+guid);
 			else
-				bugDetails = fetch(p.getProperty("getBugById")+guid);
+				bugDetails = fetch(p.getProp("getBugById")+guid);
 		}catch(Exception ex){
 			pref.log("Could not fetch bug details");
 			bugDetails="";
 		}
-		if (bugDetails.indexOf(p.getProperty("bugNotFound"))>=0) {
-			(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(6020,"Travelbug not found."), MessageBox.OKB)).execute();
+		try {
+			if (bugDetails.indexOf(p.getProp("bugNotFound"))>=0) {
+				(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(6020,"Travelbug not found."), MessageBox.OKB)).execute();
+				return "";
+			}
+			Extractor exDetails = new Extractor(bugDetails,p.getProp("bugDetailsStart"),p.getProp("bugDetailsEnd"),0,Extractor.EXCLUDESTARTEND);
+			return exDetails.findNext();
+		} catch (Exception ex) {
 			return "";
 		}
-		Extractor exDetails = new Extractor(bugDetails,p.getProperty("bugDetailsStart"),p.getProperty("bugDetailsEnd"),0,Extractor.EXCLUDESTARTEND);
-		return exDetails.findNext();
 	}
+
+	private class myProperties extends Properties {
+		myProperties() {
+			super();
+			try {
+				load(new FileInputStream(File.getProgramDirectory()+"/spider.def"));
+			} catch (Exception ex) {
+				pref.log("Failed to load spider.def",ex);
+				(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5504,"Could not load 'spider.def'"), MessageBox.OKB)).execute();
+			}
+		}
+		public String getProp(String key) throws Exception {
+			String s=super.getProperty(key);
+			if (s==null) {
+				(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5497,"Error missing tag in spider.def") + ": "+key, MessageBox.OKB)).execute();
+				throw new Exception("Missing tag in spider.def: "+key);
+			}
+			return s;
+		}
+		
+	}
 }



From mik77 at mail.berlios.de  Sun Sep  2 00:21:50 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sun, 2 Sep 2007 00:21:50 +0200
Subject: [Cachewolf-svn] r865 - trunk/src/CacheWolf
Message-ID: <200709012221.l81MLoWU029600@sheep.berlios.de>

Author: mik77
Date: 2007-09-02 00:21:49 +0200 (Sun, 02 Sep 2007)
New Revision: 865

Modified:
   trunk/src/CacheWolf/GotoPanel.java
Log:
small color correction

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-09-01 22:13:11 UTC (rev 864)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-09-01 22:21:49 UTC (rev 865)
@@ -645,6 +645,7 @@
 				
 				if (moveDir < 360 && moveDir > -360) {
 					drawDoubleArrow(g, 360 - moveDir, BLUE, RED, 1.0f);
+					if (moveDirColor == RED) moveDirColor = Color.DarkBlue;
 					if (gotoDir < 360 && gotoDir > -360) drawThinArrow(g, gotoDir - moveDir, moveDirColor, 1.0f);
 					if (sunDir < 360 && sunDir > -360) drawSunArrow(g, sunDir - moveDir, YELLOW, 0.75f);					
 				}				



From salzkammergut at mail.berlios.de  Sun Sep  2 10:55:37 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 2 Sep 2007 10:55:37 +0200
Subject: [Cachewolf-svn] r867 - trunk/src/CacheWolf
Message-ID: <200709020855.l828tbeR021329@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-02 10:55:36 +0200 (Sun, 02 Sep 2007)
New Revision: 867

Modified:
   trunk/src/CacheWolf/CacheList.java
Log:
CacheList: Bugfix (http://www.geoclub.de/ftopic18379.html)

Modified: trunk/src/CacheWolf/CacheList.java
===================================================================
--- trunk/src/CacheWolf/CacheList.java	2007-09-02 06:53:58 UTC (rev 866)
+++ trunk/src/CacheWolf/CacheList.java	2007-09-02 08:55:36 UTC (rev 867)
@@ -162,16 +162,17 @@
 				int lstCacheIdx=lstCaches.getSelectedIndex(0);
 				CacheHolder ch=(CacheHolder)cacheList.get(lstCacheIdx);
 				int idx=Global.getProfile().cacheDB.find(ch);
-				// Select the cache also in the main list view
-				Global.mainTab.tbP.selectRow(idx);
 				// Ensure that the main view is updated with the selected cache, i.e.
 				// DetailsPanel, HintLog, Pictures etc.
 				int activeTab=Global.mainTab.cardPanel.selectedItem;
-				if (activeTab==0) 
+				if (activeTab==0) { 
+					// Select the cache also in the main list view
+					Global.mainTab.tbP.selectRow(idx);
 					Global.mainTab.tbP.tc.repaint();
-				else {
+				} else {
 					// We need to change to the list view first to load a new cache
 					Global.mainTab.onEvent(new MultiPanelEvent(0,Global.mainTab,0));
+					Global.mainTab.tbP.selectRow(idx);
 					Global.mainTab.onEvent(new MultiPanelEvent(0,Global.mainTab,activeTab));
 				}
 			}
@@ -267,7 +268,7 @@
 		}
 		// The sort command places all filtered caches at the end
 		cacheDB.sort(new mySort(),false);
-		Filter.filterActive=true;
+		Filter.filterActive=Filter.FILTER_CACHELIST;
 		Filter.filterInverted=false;
 		updateScreen();
 		



From salzkammergut at mail.berlios.de  Sun Sep  2 08:54:02 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 2 Sep 2007 08:54:02 +0200
Subject: [Cachewolf-svn] r866 - trunk/src/CacheWolf
Message-ID: <200709020654.l826s2ud003787@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-02 08:53:58 +0200 (Sun, 02 Sep 2007)
New Revision: 866

Modified:
   trunk/src/CacheWolf/RadarPanel.java
Log:
RadarPanel: Bugfix. Falsche Icons fuer Parking und Trailhead (http://www.geoclub.de/ftopic18454.html)
Das RadarPanel holt sich seine Images jetzt aus myTableModel. Das fixt den Bug, spart Speicherplatz und Ladezeit.

Modified: trunk/src/CacheWolf/RadarPanel.java
===================================================================
--- trunk/src/CacheWolf/RadarPanel.java	2007-09-01 22:21:49 UTC (rev 865)
+++ trunk/src/CacheWolf/RadarPanel.java	2007-09-02 06:53:58 UTC (rev 866)
@@ -23,7 +23,6 @@
 	int scaleKm = 30;
 	int centerX, centerY;
 	int height, width;
-	Image cacheImages[] = new Image[454];
 	String selectedWaypoint = new String();
 	MainTab mt;
 	boolean penMoving = false;
@@ -35,27 +34,6 @@
 	* "navigation" buttons.
 	*/
 	public RadarPanel(){
-		cacheImages[0] = new Image("0.png");
-		//cacheImages[1] = new Image();
-		cacheImages[2] = new Image("2.png");
-		cacheImages[3] = new Image("3.png");
-		cacheImages[4] = new Image("4.png");
-		cacheImages[5] = new Image("5.png");
-		cacheImages[6] = new Image("6.png");
-		cacheImages[8] = new Image("8.png");
-		//cacheImages[9] = new Image();
-		//cacheImages[10] = new Image();
-		cacheImages[11] = new Image("11.png");
-		cacheImages[12] = new Image("12.png");
-		cacheImages[13] = new Image("13.png");
-		//additional waypoints, begin with 50
-		cacheImages[50] = new Image("pkg.png");
-		cacheImages[51] = new Image("stage.png");
-		cacheImages[52] = new Image("puzzle.png");
-		cacheImages[53] = new Image("flag.png");
-
-		cacheImages[137] = new Image("137.png");
-		cacheImages[453] = new Image("453.png");
 		this.addLast(iActP = new myInteractivePanel(), this.STRETCH, this.FILL);
 		CellPanel cp = new CellPanel();
 		cp.addNext(btMinus,this.DONTSTRETCH, (this.DONTFILL|this.WEST));
@@ -155,9 +133,9 @@
 							iActP.addImage(aImg);
 						}
 					}
-					Image imgCache=cacheImages[Convert.parseInt(holder.type)];
+					Image imgCache=myTableModel.cacheImages[Convert.parseInt(holder.type)];
 					// If we have no image for the cache type use a question mark
-					if (imgCache==null) imgCache=cacheImages[8]; 
+					if (imgCache==null) imgCache=myTableModel.cacheImages[8]; 
 					rpi = new RadarPanelImage(imgCache);
 					rpi.wayPoint = holder.wayPoint;
 					rpi.rownum = i;



From salzkammergut at mail.berlios.de  Sun Sep  2 11:13:38 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 2 Sep 2007 11:13:38 +0200
Subject: [Cachewolf-svn] r868 - trunk/src/CacheWolf
Message-ID: <200709020913.l829DcJo022277@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-02 11:13:36 +0200 (Sun, 02 Sep 2007)
New Revision: 868

Modified:
   trunk/src/CacheWolf/SpiderGC.java
Log:
SpiderGC: Travelbugs mit Umlauten wurden in der Infobox nicht richtig dargestellt.

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-09-02 08:55:36 UTC (rev 867)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-09-02 09:13:36 UTC (rev 868)
@@ -793,7 +793,7 @@
 			if(bug.length()>0) { // Found a bug, get its details
 				Travelbug tb=new Travelbug(bug);
 				try{
-					infB.setInfo(oldInfoBox+MyLocale.getMsg(5514,"\nGetting bug: ")+bug);
+					infB.setInfo(oldInfoBox+MyLocale.getMsg(5514,"\nGetting bug: ")+SafeXML.cleanback(bug));
 					pref.log("Fetching bug details: "+bug);
 					bugDetails = fetch(link);
 					Extractor exDetails = new Extractor(bugDetails,p.getProp("bugDetailsStart"),p.getProp("bugDetailsEnd"),0,Extractor.EXCLUDESTARTEND);



From salzkammergut at mail.berlios.de  Sun Sep  2 19:11:51 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 2 Sep 2007 19:11:51 +0200
Subject: [Cachewolf-svn] r869 - trunk/src/CacheWolf
Message-ID: <200709021711.l82HBpFU028002@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-02 19:11:45 +0200 (Sun, 02 Sep 2007)
New Revision: 869

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/CacheHolderDetail.java
Log:
CacheHolder: Neue Methode toXML() gibt die Daten, die in der index.xml stehen als XML-String zurueck.
Diese Methode wird auch beim Speichern von CacheHolderDetail aufgerufen und speichert diese Daten ganz am Ende
der cache.xml Datei (beim Einlesen werden sie ignoriert). Dadurch wird es in Zukunft m?glich sein, die 
index.xml aus den cache.xml Dateien zu restaurieren.

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-09-02 09:13:36 UTC (rev 868)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-09-02 17:11:45 UTC (rev 869)
@@ -1,4 +1,5 @@
 package CacheWolf;
+import ewe.sys.Convert;
 import ewe.sys.Vm;
 import ewe.util.Vector;
 
@@ -87,6 +88,8 @@
  *  the sort is always done on this field to speed up the sorting process 
  */
 public String sort;
+private static StringBuffer sb=new StringBuffer(530); // Used in toXML()
+
 //static int nObjects=0;
 CacheHolder() {//nObjects++;Vm.debug("CacheHolder() nO="+nObjects);
 }
@@ -134,6 +137,40 @@
 	this.lastSyncOC = ch.lastSyncOC;
 }
 
+/** Return a XML string containing all the cache data for storing in index.xml */
+public String toXML() {
+	sb.delete(0,sb.length());
+	sb.append("    <CACHE name = \"");
+	sb.append(SafeXML.clean(CacheName));
+	sb.append("\" owner = \"");		sb.append(SafeXML.clean(CacheOwner));
+	sb.append("\" lat = \""); 		sb.append(pos.latDec ); 
+	sb.append("\" lon = \"");		sb.append(pos.lonDec);
+	sb.append("\" hidden = \"");	sb.append(DateHidden);
+	sb.append("\" wayp = \"");		sb.append(SafeXML.clean(wayPoint));
+	sb.append("\" status = \"");	sb.append(CacheStatus);
+	sb.append("\" type = \"");		sb.append(type);
+	sb.append("\" dif = \"");		sb.append(hard);
+	sb.append("\" terrain = \"" );	sb.append(terrain ); 
+	sb.append("\" filtered = \"" ); sb.append(is_filtered); // This was 'dirty', but dirty is not used
+	sb.append("\" size = \"");		sb.append(CacheSize);
+	sb.append("\" online = \"" );	sb.append(is_available); 
+	sb.append("\" archived = \"" );	sb.append(is_archived); 
+	sb.append("\" has_bug = \"" ); 	sb.append(has_bug); 
+	sb.append("\" black = \"" ); 	sb.append(is_black); 
+	sb.append("\" owned = \"" ); 	sb.append(is_owned); 
+	sb.append("\" found = \"" ); 	sb.append(is_found); 
+	sb.append("\" is_new = \"" );	sb.append(is_new);
+	sb.append("\" is_log_update = \"" );sb.append(is_log_update); 
+	sb.append("\" is_update = \"" );sb.append(is_update); 
+	sb.append("\" is_HTML = \"" ); 	sb.append(is_HTML); 
+	sb.append("\" DNFLOGS = \"" ); 	sb.append(noFindLogs ); 
+	sb.append("\" ocCacheID = \"" );sb.append(ocCacheID ); 
+	sb.append("\" is_INCOMPLETE = \"");sb.append(is_incomplete); 
+	sb.append("\" lastSyncOC = \"" );sb.append(lastSyncOC ); 
+	sb.append("\" />\n");
+	return sb.toString();
+}
+
 public void setLatLon(String latLon) {
 	latLon=latLon.trim();
 	if (!latLon.equals(LatLon)) is_update=true;

Modified: trunk/src/CacheWolf/CacheHolderDetail.java
===================================================================
--- trunk/src/CacheWolf/CacheHolderDetail.java	2007-09-02 09:13:36 UTC (rev 868)
+++ trunk/src/CacheWolf/CacheHolderDetail.java	2007-09-02 17:11:45 UTC (rev 869)
@@ -367,6 +367,7 @@
 				  detfile.print(Travelbugs.toXML());
 				  detfile.print("<URL><![CDATA["+URL+"]]></URL>\r\n");
 				  detfile.print("<SOLVER><![CDATA["+Solver+"]]></SOLVER>\r\n");
+				  detfile.print(toXML()); // This will allow restoration of index.xml
 				  detfile.print("</CACHEDETAILS>\n");
 				} // if length
 			} catch (Exception e){



From salzkammergut at mail.berlios.de  Sun Sep  2 21:45:07 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 2 Sep 2007 21:45:07 +0200
Subject: [Cachewolf-svn] r870 - in trunk: resources src/CacheWolf
Message-ID: <200709021945.l82Jj7N5024425@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-02 21:44:59 +0200 (Sun, 02 Sep 2007)
New Revision: 870

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/CacheList.java
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/MainForm.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/NewProfileForm.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/ProfilesForm.java
   trunk/src/CacheWolf/SearchCache.java
   trunk/src/CacheWolf/StatusBar.java
Log:
CacheTour: Bessere Integration mit dem Filter. Wenn eine CacheTour angewendet wurde und gespeichert wird, wird sie
beim Start wieder hergestellt. Wenn eine Cachetour aktiv ist, wird das FilterIcon in der Statuszeile 
blau gefaerbt. Warnmeldung wenn bei einer CacheTour blackgelistete und normale Caches gemischt werden.
Anmerkung: Die Aenderung in Rev 822 wurde rueckgaengig gemacht (hinterlaesst bei mir Artefakte am PDA), da auch
bei MainTab einige Aenderungen notwendig waren.

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-09-02 17:11:45 UTC (rev 869)
+++ trunk/resources/cachewolf.Languages.cfg	2007-09-02 19:44:59 UTC (rev 870)
@@ -472,6 +472,7 @@
 		4500=Ges:
 		4501=Gez:
 		4502=Gef:
+		4600=Nicht alle Caches k%f6nnen angezeigt werden. Inkompatibler Blacklist Status.
 		5000=Lade Cacheliste
 		5497=Fehler: Ein Tag in spider.def fehlt
 		5498=Login nicht m%f6glich. Fehler beim Laden der Seite nach Login.
@@ -1017,6 +1018,7 @@
 		4500=Tot:
 		4501=Vis:
 		4502=Fnd:
+		4600=Some cache(s) cannot be shown because of wrong blacklist status
 		5498=Login failed. Error loading page after login. 
 		5499=Error loading login page
 		5000=Load Cachelist

Modified: trunk/src/CacheWolf/CacheList.java
===================================================================
--- trunk/src/CacheWolf/CacheList.java	2007-09-02 17:11:45 UTC (rev 869)
+++ trunk/src/CacheWolf/CacheList.java	2007-09-02 19:44:59 UTC (rev 870)
@@ -241,6 +241,7 @@
 	public void applyCacheList() {
 		Vector cacheDB=Global.getProfile().cacheDB;
 		CacheHolder ch;
+		int wrongBlackStatus=0;
 		String apply="\uFFFF"+Convert.toString(applyCount++);
 		// Start by setting all caches to filtered
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
@@ -263,15 +264,21 @@
 				ch=null;
 				ch=(CacheHolder) cacheDB.get(idx);
 			}
-			ch.is_filtered=false;
-			ch.sort=MyLocale.formatLong(i,"00000");
+			if (ch.is_black!=Filter.showBlacklisted) 
+				wrongBlackStatus++;
+			else {
+				ch.is_filtered=false;
+				ch.sort=MyLocale.formatLong(i,"00000");
+			}
 		}
 		// The sort command places all filtered caches at the end
 		cacheDB.sort(new mySort(),false);
 		Filter.filterActive=Filter.FILTER_CACHELIST;
 		Filter.filterInverted=false;
-		updateScreen();
-		
+		updateScreen(cacheList.size()-wrongBlackStatus);
+		if (wrongBlackStatus>0)
+			(new MessageBox(MyLocale.getMsg(5500,"Error"),MyLocale.getMsg(4600,"Some cache(s) cannot be shown because of wrong blacklist status"), MessageBox.OKB)).execute();
+
 	}
 	
 	/** Add a cache (and its addis) to the list 
@@ -314,8 +321,8 @@
 			return false;
 	}
 	
-	void updateScreen() {
-		Global.mainTab.tbP.myMod.numRows=cacheList.size();
+	void updateScreen(int numRows) {
+		Global.mainTab.tbP.myMod.numRows=numRows;
 		// Check whether the currently selected cache is still visible
 		//selectRow(getSelectedCache());
 		Global.mainTab.tbP.tc.update(true); // Update and repaint

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2007-09-02 17:11:45 UTC (rev 869)
+++ trunk/src/CacheWolf/Filter.java	2007-09-02 19:44:59 UTC (rev 870)
@@ -11,12 +11,16 @@
 *   @author BilboWolf (optimiert von salzkammergut)
 */
 public class Filter{
+	public static final int FILTER_INACTIVE=0;
+	public static final int FILTER_ACTIVE=1;
+	public static final int FILTER_CACHELIST=2;
+	
 	/** Toggle for showing blacklisted caches. Can be toggled through the Filter menu */
 	public static boolean showBlacklisted=false;
 	/** Indicator whether a filter is inverted */
 	public static boolean filterInverted=false;
 	/** Indicator whether a filter is active. Used in status bar to indicate filter status */
-	public static boolean filterActive=false;
+	public static int filterActive=FILTER_INACTIVE;
 	
 	private static final int SMALLER = -1;
 	private static final int EQUAL = 0;
@@ -451,7 +455,7 @@
 			}
 			
 		} // for
-		filterActive=true;
+		filterActive=FILTER_ACTIVE;
 	}
 	
 	/**
@@ -482,7 +486,7 @@
 			ch = (CacheHolder)cacheDB.get(i);
 			ch.is_filtered=(ch.is_black^showBlacklisted) ; // Always filter blacklisted caches
 		}
-		filterActive=false;
+		filterActive=FILTER_INACTIVE;
 		filterInverted=false;
 	}
 

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-09-02 17:11:45 UTC (rev 869)
+++ trunk/src/CacheWolf/MainForm.java	2007-09-02 19:44:59 UTC (rev 870)
@@ -42,11 +42,11 @@
 
 	protected boolean canExit(int exitCode) {
 		mTab.saveUnsavedChanges(true);
-		return true;
+		return pref.hasCloseButton;
 	}
 	
 	public void doIt(){
-	//	CellPanel [] p = addToolbar();
+		//CellPanel [] p = addToolbar();
 		Global.mainForm=this;
 		//this.title = "CacheWolf " + Version.getRelease();
 		this.exitSystemOnClose = true;
@@ -54,6 +54,7 @@
 		this.moveable = true;
 		this.windowFlagsToSet = Window.FLAG_MAXIMIZE_ON_PDA;
 		if(Vm.isMobile() == true) {
+			//this.windowFlagsToSet |=Window.FLAG_FULL_SCREEN;
 			this.resizable = false;
 			this.moveable = false;
 		}
@@ -100,11 +101,7 @@
 		pnlMainTab.addLast(mTab,STRETCH,FILL);
 		
 		mTab.dontAutoScroll=true;
-		//p[0].addLast(mMenu);
-		//p[0].addLast(mMenu,CellConstants.DONTSTRETCH, CellConstants.FILL);
-		//p[1].addLast(split,STRETCH,FILL);
-		this.addLast(split,STRETCH,FILL);
-		/*
+		
 		if (pref.menuAtTop) {
 			this.addLast(mMenu,CellConstants.DONTSTRETCH, CellConstants.FILL);
 			this.addLast(split,STRETCH,FILL);
@@ -112,7 +109,6 @@
 			this.addLast(split,STRETCH,FILL);
 			this.addLast(mMenu,CellConstants.DONTSTRETCH, CellConstants.FILL);
 		}
-		*/
 		mMenu.setTablePanel(mTab.getTablePanel());
 		infB.close(0);
 		mTab.tbP.selectFirstRow();
@@ -152,12 +148,12 @@
 			// Make the splitterbar visible with a width of 6 
 			split.theSplitter.modify(0,Invisible);
 			split.theSplitter.resizeTo(6,split.theSplitter.getRect().height);
-			Global.mainForm.mMenu.orgCacheTour.modifiers|=MenuItem.Checked;
+			Global.mainForm.mMenu.filtCacheTour.modifiers|=MenuItem.Checked;
 		} else {
 			// Hide the splitterbar and set width to 0
 			split.theSplitter.modify(Invisible,0);
 			split.theSplitter.resizeTo(0,split.theSplitter.getRect().height);
-			Global.mainForm.mMenu.orgCacheTour.modifiers&=~MenuItem.Checked;
+			Global.mainForm.mMenu.filtCacheTour.modifiers&=~MenuItem.Checked;
 		}
 		split.theSplitter.doOpenClose(cacheListVisible);
 		Global.mainForm.mMenu.repaint();

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-09-02 17:11:45 UTC (rev 869)
+++ trunk/src/CacheWolf/MainMenu.java	2007-09-02 19:44:59 UTC (rev 870)
@@ -29,7 +29,7 @@
 	private MenuItem filtCreate, filtClear, filtInvert, filtSelected, filtBlack, filtApply;
 	private MenuItem exportGPS, exportCacheMate,mnuSeparator;
 	private MenuItem orgCopy, orgMove, orgDelete;
-	public MenuItem orgCacheTour,orgTravelbugs;
+	public MenuItem filtCacheTour,orgTravelbugs;
 	private MenuItem mnuNewProfile, mnuOpenProfile, mnuEditCenter;
 	private Form father;
 	private TablePanel tbp;
@@ -114,7 +114,7 @@
 		///////////////////////////////////////////////////////////////////////
 		// Create the "Filter" pulldown menu
 		///////////////////////////////////////////////////////////////////////
-		MenuItem[] filterMenuItems=new MenuItem[8];
+		MenuItem[] filterMenuItems=new MenuItem[10];
 		filterMenuItems[0] = filtApply  = new MenuItem(MyLocale.getMsg(709,"Apply")); 
 		filterMenuItems[1] = filtCreate  = new MenuItem(MyLocale.getMsg(114,"Create")); 
 		filterMenuItems[2] = filtInvert  = new MenuItem(MyLocale.getMsg(115,"Invert")); 
@@ -123,11 +123,13 @@
 		filterMenuItems[5] = filtSelected = new MenuItem(MyLocale.getMsg(160,"Selected"));
 		filterMenuItems[6] = mnuSeparator;
 		filterMenuItems[7] = filtBlack   = new MenuItem(MyLocale.getMsg(161,"Show Blacklist"));
+		filterMenuItems[8] = mnuSeparator;
+		filterMenuItems[9] = filtCacheTour = new MenuItem(MyLocale.getMsg(198,"Cachetour"));
 		
 		///////////////////////////////////////////////////////////////////////
 		// Create a combined "Filter and Search" pulldown menu for devices with small screens
 		///////////////////////////////////////////////////////////////////////
-		MenuItem[] filterAndSearchMenuItems=new MenuItem[11];
+		MenuItem[] filterAndSearchMenuItems=new MenuItem[13];
 		filterAndSearchMenuItems[0]=filtApply;
 		filterAndSearchMenuItems[1]=filtCreate;
 		filterAndSearchMenuItems[2]=filtInvert;
@@ -139,6 +141,8 @@
 		filterAndSearchMenuItems[8]=mnuSeparator;
 		filterAndSearchMenuItems[9]=search;
 		filterAndSearchMenuItems[10]=searchClr;
+		filterAndSearchMenuItems[11] = mnuSeparator;
+		filterAndSearchMenuItems[12] = filtCacheTour;
 		
 		// Depending on screen width display either filter and searach menus or the combined menu 
 		if (MyLocale.getScreenWidth()>300) {
@@ -151,14 +155,12 @@
 		///////////////////////////////////////////////////////////////////////
 		// Create the "Organize" pulldown menu
 		///////////////////////////////////////////////////////////////////////
-		MenuItem[] organizeMenuItems=new MenuItem[7];
+		MenuItem[] organizeMenuItems=new MenuItem[5];
 		organizeMenuItems[0] = orgCopy  = new MenuItem(MyLocale.getMsg(141,"Copy")); 
 		organizeMenuItems[1] = orgMove  = new MenuItem(MyLocale.getMsg(142,"Move")); 
 		organizeMenuItems[2] = orgDelete   = new MenuItem(MyLocale.getMsg(143,"Delete"));
 		organizeMenuItems[3] = mnuSeparator;
-		organizeMenuItems[4] = orgCacheTour = new MenuItem(MyLocale.getMsg(198,"Cachetour"));
-		organizeMenuItems[5] = mnuSeparator;
-		organizeMenuItems[6] = orgTravelbugs = new MenuItem(MyLocale.getMsg(139,"Manage travelbugs"));
+		organizeMenuItems[4] = orgTravelbugs = new MenuItem(MyLocale.getMsg(139,"Manage travelbugs"));
 		this.addMenu(new PullDownMenu(MyLocale.getMsg(140,"Organize"),new Menu(organizeMenuItems,null)));
 
 		///////////////////////////////////////////////////////////////////////
@@ -482,8 +484,14 @@
 				Filter.showBlacklisted=!Filter.showBlacklisted;
 				SearchCache ssc = new SearchCache(cacheDB);
 				ssc.clearSearch();// Clear search & restore filter status
+				Filter flt=new Filter();
+				flt.clearFilter();
 				tbp.refreshTable();
 			}
+			if(mev.selectedItem == filtCacheTour){
+				filtCacheTour.modifiers^=MenuItem.Checked;
+				Global.mainForm.toggleCacheListVisible();			
+			}
 			///////////////////////////////////////////////////////////////////////
 			// "Organize" pulldown menu
 			///////////////////////////////////////////////////////////////////////
@@ -507,10 +515,6 @@
 				dm.deleteCaches();
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == orgCacheTour){
-				orgCacheTour.modifiers^=MenuItem.Checked;
-				Global.mainForm.toggleCacheListVisible();			
-			}
 			if(mev.selectedItem == orgTravelbugs){
 				TravelbugJourneyScreen tbs=new TravelbugJourneyScreen();
 				tbs.setPreferredSize(800,600);

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-09-02 17:11:45 UTC (rev 869)
+++ trunk/src/CacheWolf/MainTab.java	2007-09-02 19:44:59 UTC (rev 870)
@@ -48,8 +48,7 @@
 		//Don't expand tabs if the screen is very narrow, i.e. HP IPAQ 65xx, 69xx
 		if (MyLocale.getScreenWidth() <= 240) this.dontExpandTabs=true;
 		calcP = new CalcPanel(); // Init here so that Global.MainT is already set
-		tbP = new TablePanel(pref, profile, statBar);
-		Card c = this.addCard(new TableForm(tbP), MyLocale.getMsg(1200,"List"), null);
+		Card c = this.addCard(tbP=new TablePanel(pref, profile, statBar), MyLocale.getMsg(1200,"List"), null);
 
 		c = this.addCard(detP, MyLocale.getMsg(1201,"Details"), null);
 		c.iconize(new Image("details.gif"),true);
@@ -77,6 +76,7 @@
 		c = this.addCard(radarP, "Radar", null);
 		radarP.setMainTab(this);
 		c.iconize(new Image("radar.gif"),true);
+		mnuMain.allowProfileChange(true);
 	}
 
 	public TablePanel getTablePanel(){
@@ -89,17 +89,19 @@
 	}
 
 
-	public void onEvent(Event ev)
-	{
+	public void onEvent(Event ev) {
 		if(ev instanceof MultiPanelEvent){
+			// Check whether a profile change is allowed, if not disable the relevant options
+			checkProfileChange();
 			// Perform clean up actions for the panel we are leaving
 			onLeavingPanel(oldCard);
 			// Prepare actions for the panel we are about to enter
-			onEnteringPanel(oldCard=((MultiPanelEvent)ev).selectedIndex);
+			onEnteringPanel(((MultiPanelEvent)ev).selectedIndex);
+			oldCard=((MultiPanelEvent)ev).selectedIndex;
 		}
 		super.onEvent(ev); //Make sure you call this.
 		// If we are in Listview update status
-		if (this.getSelectedItem()==0) statBar.updateDisplay();
+		if (this.getSelectedItem()==0 && statBar!=null) statBar.updateDisplay();
 	}
 
 	/**
@@ -161,16 +163,7 @@
 			updatePendingChanges();
 			if (detP.hasBlackStatusChanged()) {
 				// Restore the filter status (this automatically sets the status for blacklisted caches)
-				//TODO This is not very elegant (see also SearchCache)
-				Filter flt=new Filter();
-				if (Filter.filterActive) {
-					flt.setFilter();
-					flt.doFilter();
-				} else {
-					flt.clearFilter();
-				}
-				if (Filter.filterInverted) 
-					flt.invertFilter();
+				Global.getProfile().restoreFilter();
 				tbP.refreshTable();
 			}
 			break;
@@ -237,7 +230,7 @@
 		tbP.pref = pref;
 		profile.updateBearingDistance();
 		tbP.refreshTable();
-		(new MessageBox(MyLocale.getMsg(327,"Information"), MyLocale.getMsg(1024,"Entfernungen in der Listenansicht \nvom aktuellen Standpunkt aus \nneu berechnet").replace('~','\n'), MessageBox.OKB)).execute();
+		//(new MessageBox(MyLocale.getMsg(327,"Information"), MyLocale.getMsg(1024,"Entfernungen in der Listenansicht \nvom aktuellen Standpunkt aus \nneu berechnet").replace('~','\n'), MessageBox.OKB)).execute();
 	}
 
 	public void gotoPoint(String LatLon) { // TODO ?bergabe nicht als String
@@ -358,6 +351,14 @@
 		if (saveIndex) profile.saveIndex(Global.getPref(),false);
 	}
 	
+	private void checkProfileChange() {
+		// A panel is selected. Could be the same panel twice
+		mnuMain.allowProfileChange(false);	  
+		if(this.getSelectedItem() == 0){// List view selected
+			mnuMain.allowProfileChange(true);	  
+			MyLocale.setSIPOff();
+		}
+	}
 }
 // 
 

Modified: trunk/src/CacheWolf/NewProfileForm.java
===================================================================
--- trunk/src/CacheWolf/NewProfileForm.java	2007-09-02 17:11:45 UTC (rev 869)
+++ trunk/src/CacheWolf/NewProfileForm.java	2007-09-02 19:44:59 UTC (rev 870)
@@ -51,7 +51,7 @@
 						profileDir="";
 						this.close(-1);
 					}
-					Filter.filterActive=false;
+					Filter.filterActive=Filter.FILTER_INACTIVE;
 					Filter.filterInverted=false;
 					this.close(0);
 				}

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-09-02 17:11:45 UTC (rev 869)
+++ trunk/src/CacheWolf/Profile.java	2007-09-02 19:44:59 UTC (rev 870)
@@ -57,7 +57,7 @@
 	public String filterDiff=new String("L");
 	public String filterTerr=new String("L");
 	// Saved filterstatus - is only refreshed from class Filter when Profile is saved
-	public boolean filterActive=false;
+	public int filterActive=Filter.FILTER_INACTIVE;
 	public boolean filterInverted=false;
 
 	public boolean selectionChanged = true; // ("H?ckchen") used by movingMap to get to knao if it should update the caches in the map 
@@ -102,7 +102,7 @@
 
 	
 	/** Save index with filter settings given */ 
-	public void saveIndex(Preferences pref, boolean showprogress, boolean saveFilterActive, boolean saveFilterInverted){
+	public void saveIndex(Preferences pref, boolean showprogress, int saveFilterActive, boolean saveFilterInverted){
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
 		if(showprogress){
@@ -143,7 +143,7 @@
 				distOC = "0";
 			}
 
-			detfile.print("    <FILTER status = \""+(saveFilterActive?"T":"F")+(saveFilterInverted?"T":"F")+ 
+			detfile.print("    <FILTER status = \""+saveFilterActive+(saveFilterInverted?"T":"F")+ 
 					"\" rose = \""+filterRose+"\" type = \""+filterType+
 					"\" var = \""+filterVar+"\" dist = \""+filterDist.replace('"',' ')+"\" diff = \""+
 					filterDiff+"\" terr = \""+filterTerr+"\" size = \""+filterSize+"\" />\n");
@@ -157,11 +157,12 @@
 				ch = (CacheHolder)cacheDB.get(i);
 				////Vm.debug("Saving: " + ch.CacheName);
 				if(ch.wayPoint.length()>0) { //TODO && ch.LongDescription.equals("An Error Has Occured") == false){
-					detfile.print("    <CACHE name = \""+SafeXML.clean(ch.CacheName)+"\" owner = \""+SafeXML.clean(ch.CacheOwner)+
+/*					detfile.print("    <CACHE name = \""+SafeXML.clean(ch.CacheName)+"\" owner = \""+SafeXML.clean(ch.CacheOwner)+
 							//"\" lat = \""+ SafeXML.clean(ch.LatLon) +
 							"\" lat = \""+ ch.pos.latDec + "\" lon = \""+ch.pos.lonDec+
 							"\" hidden = \""+ch.DateHidden+"\" wayp = \""+SafeXML.clean(ch.wayPoint)+"\" status = \""+ch.CacheStatus+"\" type = \""+ch.type+"\" dif = \""+ch.hard+"\" terrain = \"" + ch.terrain + "\" dirty = \"false" + // ch.dirty + dirty is not used, so we save it as false 
 							"\" size = \""+ch.CacheSize+"\" online = \"" + Convert.toString(ch.is_available) + "\" archived = \"" + Convert.toString(ch.is_archived) + "\" has_bug = \"" + Convert.toString(ch.has_bug) + "\" black = \"" + Convert.toString(ch.is_black) + "\" owned = \"" + Convert.toString(ch.is_owned) + "\" found = \"" + Convert.toString(ch.is_found) + "\" is_new = \"" + Convert.toString(ch.is_new) +"\" is_log_update = \"" + Convert.toString(ch.is_log_update) + "\" is_update = \"" + Convert.toString(ch.is_update) + "\" is_HTML = \"" + Convert.toString(ch.is_HTML) + "\" DNFLOGS = \"" + ch.noFindLogs + "\" ocCacheID = \"" + ch.ocCacheID + "\" is_INCOMPLETE = \""+Convert.toString(ch.is_incomplete)+ "\" lastSyncOC = \"" + ch.lastSyncOC + "\" />\n");
+*/					detfile.print(ch.toXML());
 				}
 			}
 			detfile.print("</CACHELIST>\n");
@@ -221,8 +222,8 @@
 					ch.type = ex.findNext();
 					ch.hard = ex.findNext();
 					ch.terrain = ex.findNext();
-					//ch.dirty =  ch.dirty is not used 
-					ex.findNext(); // Need to skip dirty
+					// The next item was 'dirty' but this is no longer used.
+					ch.is_filtered = ex.findNext().equals("true") ? true : false; 
 					ch.CacheSize = ex.findNext();
 					ch.is_available = ex.findNext().equals("true") ? true : false;
 					ch.is_archived = ex.findNext().equals("true") ? true : false;
@@ -268,7 +269,11 @@
 					ex.setSource(text);
 					String temp=ex.findNext(); // Filter status is now first, need to deal with old versions which don't have filter status
 					if (temp.length()==2) {
-						filterActive=temp.charAt(0)=='T';
+						// Compatibility with previous versions
+						if (temp.charAt(0)=='T') 
+							filterActive=Filter.FILTER_ACTIVE;
+						else
+							filterActive=Common.parseInt(temp.substring(0,1));
 						filterInverted=temp.charAt(1)=='T';
 						filterRose = ex.findNext();
 					} else 
@@ -311,12 +316,14 @@
 	 **/
 	void restoreFilter() {
 		Filter flt=new Filter();
-		if (filterActive) {
+		if (filterActive==Filter.FILTER_ACTIVE) {
 			flt.setFilter();
 			flt.doFilter();
+			if (filterInverted) 
+				flt.invertFilter();
+		} else if (filterActive==Filter.FILTER_CACHELIST) {
+			flt.filterActive=filterActive;
 		}
-		if (filterInverted) 
-			flt.invertFilter();
 	}
 
 	public int getCacheIndex(String wp){

Modified: trunk/src/CacheWolf/ProfilesForm.java
===================================================================
--- trunk/src/CacheWolf/ProfilesForm.java	2007-09-02 17:11:45 UTC (rev 869)
+++ trunk/src/CacheWolf/ProfilesForm.java	2007-09-02 19:44:59 UTC (rev 870)
@@ -118,7 +118,7 @@
 				close(-1);
 			}
 			if (ev.target == btnOK || ev.target == choice){
-				Filter.filterActive=false;
+				Filter.filterActive=Filter.FILTER_INACTIVE;
 				Filter.filterInverted=false;
 				if (choice.getSelectedItem()!=null) {
 					newSelectedProfile=choice.getSelectedItem().toString();

Modified: trunk/src/CacheWolf/SearchCache.java
===================================================================
--- trunk/src/CacheWolf/SearchCache.java	2007-09-02 17:11:45 UTC (rev 869)
+++ trunk/src/CacheWolf/SearchCache.java	2007-09-02 19:44:59 UTC (rev 870)
@@ -48,15 +48,7 @@
 	* cache database. Restore to the state of the filter
 	*/
 	public void clearSearch(){
-		Filter flt=new Filter();
-		if (Filter.filterActive) {
-			flt.setFilter();
-			flt.doFilter();
-		} else {
-			flt.clearFilter();
-		}
-		if (Filter.filterInverted) 
-			flt.invertFilter();
+		Global.getProfile().restoreFilter();
 		for(int i = cacheDB.size()-1;i >=0;i--){
 			((CacheHolder)cacheDB.get(i)).is_flaged=false;
 		}

Modified: trunk/src/CacheWolf/StatusBar.java
===================================================================
--- trunk/src/CacheWolf/StatusBar.java	2007-09-02 17:11:45 UTC (rev 869)
+++ trunk/src/CacheWolf/StatusBar.java	2007-09-02 19:44:59 UTC (rev 870)
@@ -46,8 +46,10 @@
 					MyLocale.getMsg(4502,"Fnd:") + " " + stats.totalFound() + "  ";
 		disp.setText(strStatus);
 		// Indicate that a filter is active in the status line
-		if (Filter.filterActive)
+		if (Filter.filterActive==Filter.FILTER_ACTIVE)
 			btnFlt.backGround=new Color(0,255,0);
+		else if (Filter.filterActive==Filter.FILTER_CACHELIST)
+			btnFlt.backGround=new Color(0,0,255);
 		else
 			btnFlt.backGround=null;
 		// Current centre can only be displayed if screen is big
@@ -63,11 +65,11 @@
 		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
 			if (ev.target == btnFlt){
 				Filter flt = new Filter();
-				if (Filter.filterActive) {
-					flt.clearFilter();
-				} else {
+				if (Filter.filterActive==Filter.FILTER_INACTIVE) {
 					flt.setFilter();
 					flt.doFilter();
+				} else {
+					flt.clearFilter();
 				}
 				Global.mainTab.tbP.refreshTable();
 			}



From salzkammergut at mail.berlios.de  Sun Sep  2 23:33:32 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 2 Sep 2007 23:33:32 +0200
Subject: [Cachewolf-svn] r871 - trunk/src/CacheWolf
Message-ID: <200709022133.l82LXW7h029171@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-02 23:33:31 +0200 (Sun, 02 Sep 2007)
New Revision: 871

Modified:
   trunk/src/CacheWolf/SpiderGC.java
Log:
SpiderGC: Wenn mehrfach hintereinander eingeloggt wird, wird bei neuerlichen logins keine neue sessionID vergeben.
Also mu? die alte weiterverwendet werden und darf nicht gel?scht werden.

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-09-02 19:44:59 UTC (rev 870)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-09-02 21:33:31 UTC (rev 871)
@@ -155,8 +155,8 @@
 			//Vm.debug(cookieID);
 			rexCookieSession.search(start);
 			if (!rexCookieSession.didMatch()) {
-				pref.log("CookieSession not found");
-				cookieSession="";
+				pref.log("CookieSession not found Using old one.");
+				//cookieSession="";
 			} else
 				cookieSession = rexCookieSession.stringMatched(1);
 			//Vm.debug("cookieSession = " + cookieSession);
@@ -1048,7 +1048,8 @@
 				if(cookieSession.length()>0){
 					conn.setRequestorProperty("Cookie", "ASP.NET_SessionId="+cookieSession +"; userid="+cookieID);
 					pref.log("Cookie Zeug: " + "Cookie: ASP.NET_SessionId="+cookieSession +"; userid="+cookieID);
-				}
+				} else 
+					pref.log("No Cookie found");
 				conn.setRequestorProperty("Connection", "close");
 				conn.documentIsEncoded = true;
 				pref.log("Connecting");



From mik77 at mail.berlios.de  Tue Sep  4 20:43:19 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Tue, 4 Sep 2007 20:43:19 +0200
Subject: [Cachewolf-svn] r872 - trunk/src/CacheWolf
Message-ID: <200709041843.l84IhJKY026567@sheep.berlios.de>

Author: mik77
Date: 2007-09-04 20:43:06 +0200 (Tue, 04 Sep 2007)
New Revision: 872

Modified:
   trunk/src/CacheWolf/MainForm.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/TableForm.java
Log:
Main menu only in tablePanel again. But still configurable on top or on bottom.

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-09-02 21:33:31 UTC (rev 871)
+++ trunk/src/CacheWolf/MainForm.java	2007-09-04 18:43:06 UTC (rev 872)
@@ -102,6 +102,8 @@
 		
 		mTab.dontAutoScroll=true;
 		
+		this.addLast(split,STRETCH,FILL);
+		/*
 		if (pref.menuAtTop) {
 			this.addLast(mMenu,CellConstants.DONTSTRETCH, CellConstants.FILL);
 			this.addLast(split,STRETCH,FILL);
@@ -109,6 +111,7 @@
 			this.addLast(split,STRETCH,FILL);
 			this.addLast(mMenu,CellConstants.DONTSTRETCH, CellConstants.FILL);
 		}
+		*/
 		mMenu.setTablePanel(mTab.getTablePanel());
 		infB.close(0);
 		mTab.tbP.selectFirstRow();

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-09-02 21:33:31 UTC (rev 871)
+++ trunk/src/CacheWolf/MainTab.java	2007-09-04 18:43:06 UTC (rev 872)
@@ -48,7 +48,8 @@
 		//Don't expand tabs if the screen is very narrow, i.e. HP IPAQ 65xx, 69xx
 		if (MyLocale.getScreenWidth() <= 240) this.dontExpandTabs=true;
 		calcP = new CalcPanel(); // Init here so that Global.MainT is already set
-		Card c = this.addCard(tbP=new TablePanel(pref, profile, statBar), MyLocale.getMsg(1200,"List"), null);
+		tbP = new TablePanel(pref, profile, statBar);
+		Card c = this.addCard(new TableForm(tbP), MyLocale.getMsg(1200,"List"), null);
 
 		c = this.addCard(detP, MyLocale.getMsg(1201,"Details"), null);
 		c.iconize(new Image("details.gif"),true);

Modified: trunk/src/CacheWolf/TableForm.java
===================================================================
--- trunk/src/CacheWolf/TableForm.java	2007-09-02 21:33:31 UTC (rev 871)
+++ trunk/src/CacheWolf/TableForm.java	2007-09-04 18:43:06 UTC (rev 872)
@@ -1,12 +1,22 @@
 package CacheWolf;
 
+import ewe.ui.CellConstants;
 import ewe.ui.CellPanel;
 import ewe.ui.Editor;
 
 public class TableForm extends Editor {
 	public TableForm(TablePanel tp) {
+		if (Global.getPref().menuAtTop) {
+			this.addLast(Global.mainForm.mMenu,CellConstants.DONTSTRETCH, CellConstants.FILL);
+			this.addLast(tp,STRETCH,FILL);
+		} else {
+			this.addLast(tp,STRETCH,FILL);
+			this.addLast(Global.mainForm.mMenu,CellConstants.DONTSTRETCH, CellConstants.FILL);
+		}
+		/*
 		CellPanel[] menuList = addToolbar();
 		menuList[0].addLast(Global.mainForm.mMenu);
-		menuList[1].addLast(tp); 
+		menuList[1].addLast(tp);
+		*/
 	}
 }



From mik77 at mail.berlios.de  Tue Sep  4 21:51:32 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Tue, 4 Sep 2007 21:51:32 +0200
Subject: [Cachewolf-svn] r873 - trunk/src/CacheWolf
Message-ID: <200709041951.l84JpWJP030959@sheep.berlios.de>

Author: mik77
Date: 2007-09-04 21:51:28 +0200 (Tue, 04 Sep 2007)
New Revision: 873

Modified:
   trunk/src/CacheWolf/GotoPanel.java
Log:
color finetuning for GotoPanel

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-09-04 18:43:06 UTC (rev 872)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-09-04 19:51:28 UTC (rev 873)
@@ -612,14 +612,14 @@
 					diff = 360.0f - diff;
 				}
 				
-				/*if (diff <= 5.0)
+				if (diff <= 12.25)
 				{
-					moveDirColor = DARKGREEN;
+					moveDirColor = GREEN;
 				}
-				else*/
+				else
 				if (diff <= 22.5)
 				{
-					moveDirColor = GREEN;
+					moveDirColor = DARKGREEN;
 				}
 				else if (diff <= 45.0)
 				{
@@ -630,7 +630,7 @@
 			// draw only valid arrows
 			if (northCentered) {
 				if (gotoDir < 360 && gotoDir > -360) drawThickArrow(g, gotoDir, Color.DarkBlue, 1.0f);
-				if (moveDir < 360 && moveDir > -360) drawThinArrow(g, moveDir, moveDirColor, 1.0f);
+				if (moveDir < 360 && moveDir > -360) drawThinArrow(g, moveDir, RED, moveDirColor, 1.0f);
 				if (sunDir < 360 && sunDir > -360) drawSunArrow(g, sunDir, YELLOW, 0.75f);
 			}
 			else {
@@ -642,11 +642,12 @@
 				
 				g.setPen(new Pen(new Color(150,150,150),Pen.SOLID,3));
 				g.drawEllipse(location.width/2 - radius, location.height/2 - radius, 2 * radius, 2 * radius );
-				
+
 				if (moveDir < 360 && moveDir > -360) {
-					drawDoubleArrow(g, 360 - moveDir, BLUE, RED, 1.0f);
+					//drawDoubleArrow(g, 360 - moveDir, BLUE, new Color(175,0,0), 1.0f);
+					drawRose(g, 360 - moveDir, BLUE, new Color(175,175,175), 1.0f);
 					if (moveDirColor == RED) moveDirColor = Color.DarkBlue;
-					if (gotoDir < 360 && gotoDir > -360) drawThinArrow(g, gotoDir - moveDir, moveDirColor, 1.0f);
+					if (gotoDir < 360 && gotoDir > -360) drawThinArrow(g, gotoDir - moveDir, Color.DarkBlue, moveDirColor, 1.0f);
 					if (sunDir < 360 && sunDir > -360) drawSunArrow(g, sunDir - moveDir, YELLOW, 0.75f);					
 				}				
 			}
@@ -705,7 +706,7 @@
 		g.fillEllipse(circleX - circleRadius, circleY - circleRadius, 2 * circleRadius, 2 * circleRadius);
 	}
 	
-	private void drawThinArrow(Graphics g, float angle, Color col, float scale) {
+	private void drawThinArrow(Graphics g, float angle, Color col, Color colPoint, float scale) {
 		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
 		int centerX = location.width/2, centerY = location.height/2;
 		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
@@ -715,18 +716,22 @@
 		int[] pointsX = new int[4];
 		int[] pointsY = new int[4];
 
-		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
-		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
-		pointsX[1] = centerX + new Float(sideLineLength * java.lang.Math.sin(angleRad + halfOpeningAngle)).intValue();
-		pointsY[1] = centerY - new Float(sideLineLength * java.lang.Math.cos(angleRad + halfOpeningAngle)).intValue();
-		pointsX[2] = centerX;
-		pointsY[2] = centerY;
-		pointsX[3] = centerX + new Float(sideLineLength * java.lang.Math.sin(angleRad - halfOpeningAngle)).intValue();
-		pointsY[3] = centerY - new Float(sideLineLength * java.lang.Math.cos(angleRad - halfOpeningAngle)).intValue();
+		pointsX[0] = centerX + new Float(sideLineLength * java.lang.Math.sin(angleRad - halfOpeningAngle)).intValue();
+		pointsY[0] = centerY - new Float(sideLineLength * java.lang.Math.cos(angleRad - halfOpeningAngle)).intValue();
+		pointsX[1] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[1] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[2] = centerX + new Float(sideLineLength * java.lang.Math.sin(angleRad + halfOpeningAngle)).intValue();
+		pointsY[2] = centerY - new Float(sideLineLength * java.lang.Math.cos(angleRad + halfOpeningAngle)).intValue();
+		pointsX[3] = centerX;
+		pointsY[3] = centerY;
 		
 		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
 		g.setBrush(new Brush(col, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 4);
+		if (colPoint != null) {
+			g.setBrush(new Brush(colPoint, Brush.SOLID));
+			g.fillPolygon(pointsX, pointsY, 3);			
+		}
 	}
 	
 	private void drawDoubleArrow(Graphics g, float angle, Color colFront, Color colRear, float scale) {
@@ -756,6 +761,40 @@
 		g.fillPolygon(pointsX, pointsY, 3);
 	}
 	
+	private void drawRose(Graphics g, float angle, Color colFront, Color colRear, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = location.width/2, centerY = location.height/2;
+		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
+		float halfArrowWidth = arrowLength * 0.12f;
+		
+		int[] pointsX = new int[8];
+		int[] pointsY = new int[8];
+
+		pointsX[0] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 4.0)).intValue();
+		pointsY[0] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 4.0)).intValue();
+		pointsX[1] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[1] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 4.0)).intValue();
+		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 4.0)).intValue();
+		pointsX[3] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsY[3] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsX[4] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + 3.0 * java.lang.Math.PI / 4.0)).intValue();
+		pointsY[4] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + 3.0 * java.lang.Math.PI / 4.0)).intValue();
+		pointsX[5] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
+		pointsY[5] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
+		pointsX[6] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - 3.0 * java.lang.Math.PI / 4.0)).intValue();
+		pointsY[6] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - 3.0 * java.lang.Math.PI / 4.0)).intValue();
+		pointsX[7] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		pointsY[7] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		
+		g.setPen(new Pen(colRear,Pen.SOLID,1));
+		g.setBrush(new Brush(colRear, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 8);
+		
+		g.setBrush(new Brush(colFront, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 3);
+	}
+	
 	private void drawThickArrow(Graphics g, float angle, Color col, float scale) {
 		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
 		int centerX = location.width/2, centerY = location.height/2;



From mik77 at mail.berlios.de  Tue Sep  4 22:05:15 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Tue, 4 Sep 2007 22:05:15 +0200
Subject: [Cachewolf-svn] r874 - trunk/src/CacheWolf
Message-ID: <200709042005.l84K5Foq032007@sheep.berlios.de>

Author: mik77
Date: 2007-09-04 22:05:10 +0200 (Tue, 04 Sep 2007)
New Revision: 874

Modified:
   trunk/src/CacheWolf/GotoPanel.java
Log:
window rose behind moveDir line

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-09-04 19:51:28 UTC (rev 873)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-09-04 20:05:10 UTC (rev 874)
@@ -636,16 +636,17 @@
 			else {
 				//moveDir centered
 				int radius = (int)((float)(java.lang.Math.min(location.width, location.height) / 2) * 0.75f);
-				
-				g.setPen(new Pen(RED,Pen.SOLID,3));
-				g.drawLine(location.width/2, location.height/2 - radius, location.width/2, location.height/2 + radius);
-				
+
 				g.setPen(new Pen(new Color(150,150,150),Pen.SOLID,3));
 				g.drawEllipse(location.width/2 - radius, location.height/2 - radius, 2 * radius, 2 * radius );
 
 				if (moveDir < 360 && moveDir > -360) {
 					//drawDoubleArrow(g, 360 - moveDir, BLUE, new Color(175,0,0), 1.0f);
 					drawRose(g, 360 - moveDir, BLUE, new Color(175,175,175), 1.0f);
+					
+					g.setPen(new Pen(RED,Pen.SOLID,3));
+					g.drawLine(location.width/2, location.height/2 - radius, location.width/2, location.height/2 + radius);
+					
 					if (moveDirColor == RED) moveDirColor = Color.DarkBlue;
 					if (gotoDir < 360 && gotoDir > -360) drawThinArrow(g, gotoDir - moveDir, Color.DarkBlue, moveDirColor, 1.0f);
 					if (sunDir < 360 && sunDir > -360) drawSunArrow(g, sunDir - moveDir, YELLOW, 0.75f);					



From mik77 at mail.berlios.de  Tue Sep  4 23:13:51 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Tue, 4 Sep 2007 23:13:51 +0200
Subject: [Cachewolf-svn] r875 - trunk/src/CacheWolf
Message-ID: <200709042113.l84LDp8d004718@sheep.berlios.de>

Author: mik77
Date: 2007-09-04 23:13:45 +0200 (Tue, 04 Sep 2007)
New Revision: 875

Modified:
   trunk/src/CacheWolf/GotoPanel.java
Log:
some more color improvements for GotoPanel

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-09-04 20:05:10 UTC (rev 874)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-09-04 21:13:45 UTC (rev 875)
@@ -420,6 +420,8 @@
 	final static Color BLUE = new Color(0,0,255);
 	final static Color ORANGE = new Color(255,128,0);
 	final static Color DARKGREEN = new Color(0,192,0);
+	final static Color CYAN = new Color(0,255,255);
+	final static Color MAGENTA = new Color(255,0,255);
 
 	/**
 	 * @param gd goto direction
@@ -607,24 +609,27 @@
 				{
 					diff -= 360.0f;
 				}
-				if (diff > 180)
+				if (diff > 180.0f)
 				{
 					diff = 360.0f - diff;
 				}
 				
-				if (diff <= 12.25)
+				if (diff <= 12.25f)
 				{
 					moveDirColor = GREEN;
 				}
-				else
-				if (diff <= 22.5)
+				else if (diff <= 22.5f)
 				{
-					moveDirColor = DARKGREEN;
+					moveDirColor = CYAN;
 				}
-				else if (diff <= 45.0)
+				else if (diff <= 45.0f)
 				{
 					moveDirColor = ORANGE;
 				}
+				else if (diff <= 90.0f)
+				{
+					moveDirColor = MAGENTA;
+				}
 			}
 
 			// draw only valid arrows
@@ -642,7 +647,7 @@
 
 				if (moveDir < 360 && moveDir > -360) {
 					//drawDoubleArrow(g, 360 - moveDir, BLUE, new Color(175,0,0), 1.0f);
-					drawRose(g, 360 - moveDir, BLUE, new Color(175,175,175), 1.0f);
+					drawRose(g, 360 - moveDir, new Color(100,100,100), new Color(200,200,200), 1.0f);
 					
 					g.setPen(new Pen(RED,Pen.SOLID,3));
 					g.drawLine(location.width/2, location.height/2 - radius, location.width/2, location.height/2 + radius);



From mik77 at mail.berlios.de  Tue Sep  4 23:42:31 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Tue, 4 Sep 2007 23:42:31 +0200
Subject: [Cachewolf-svn] r876 - trunk/src/CacheWolf
Message-ID: <200709042142.l84LgV5e006157@sheep.berlios.de>

Author: mik77
Date: 2007-09-04 23:42:27 +0200 (Tue, 04 Sep 2007)
New Revision: 876

Modified:
   trunk/src/CacheWolf/GotoPanel.java
Log:
special color hack for new view removed because only the point of the arrow is now used for indicating the right direction

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-09-04 21:13:45 UTC (rev 875)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-09-04 21:42:27 UTC (rev 876)
@@ -652,7 +652,6 @@
 					g.setPen(new Pen(RED,Pen.SOLID,3));
 					g.drawLine(location.width/2, location.height/2 - radius, location.width/2, location.height/2 + radius);
 					
-					if (moveDirColor == RED) moveDirColor = Color.DarkBlue;
 					if (gotoDir < 360 && gotoDir > -360) drawThinArrow(g, gotoDir - moveDir, Color.DarkBlue, moveDirColor, 1.0f);
 					if (sunDir < 360 && sunDir > -360) drawSunArrow(g, sunDir - moveDir, YELLOW, 0.75f);					
 				}				



From salzkammergut at mail.berlios.de  Wed Sep  5 00:20:51 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Wed, 5 Sep 2007 00:20:51 +0200
Subject: [Cachewolf-svn] r877 - trunk/src/CacheWolf
Message-ID: <200709042220.l84MKpYq008228@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-05 00:20:47 +0200 (Wed, 05 Sep 2007)
New Revision: 877

Modified:
   trunk/src/CacheWolf/MainTab.java
Log:
mainTab: Bugfix Wenn Suche leere Menge ergibt, wurde in der Detailansicht trotzdem ein Cache (der letzte gewaehlte angezeigt).
 (Das hat vor Rev 822 schon funktioniert, wurde aber durch die Aenderungen in der Cursorsteuerung wieder zu einem Problem.)

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-09-04 21:42:27 UTC (rev 876)
+++ trunk/src/CacheWolf/MainTab.java	2007-09-04 22:20:47 UTC (rev 877)
@@ -116,7 +116,7 @@
 			// If it is Addi get details of main Wpt (chMain)
 			chMain=null;
 			cacheDirty=false;
-			if (tbP.getSelectedCache()>=cacheDB.size() || tbP.getSelectedCache()<0) {
+			if (tbP.getSelectedCache()>=Global.mainTab.tbP.myMod.numRows) {
 				ch=null; chD=null; 
 				lastselected="";
 			} else {



From salzkammergut at mail.berlios.de  Wed Sep  5 01:05:43 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Wed, 5 Sep 2007 01:05:43 +0200
Subject: [Cachewolf-svn] r878 - trunk/src/CacheWolf
Message-ID: <200709042305.l84N5hIm024491@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-05 01:05:39 +0200 (Wed, 05 Sep 2007)
New Revision: 878

Modified:
   trunk/src/CacheWolf/SearchCache.java
   trunk/src/CacheWolf/myTableControl.java
Log:
Bugfix: Nachwehen von Rev 822 gefixt (schon alle?)

Modified: trunk/src/CacheWolf/SearchCache.java
===================================================================
--- trunk/src/CacheWolf/SearchCache.java	2007-09-04 22:20:47 UTC (rev 877)
+++ trunk/src/CacheWolf/SearchCache.java	2007-09-04 23:05:39 UTC (rev 878)
@@ -40,6 +40,7 @@
 				} else
 					ch.is_flaged=true;
 			} // for
+		     Global.mainTab.tbP.selectRow(0);
 		} // if
 	}
 	
@@ -48,9 +49,11 @@
 	* cache database. Restore to the state of the filter
 	*/
 	public void clearSearch(){
-		Global.getProfile().restoreFilter();
 		for(int i = cacheDB.size()-1;i >=0;i--){
 			((CacheHolder)cacheDB.get(i)).is_flaged=false;
 		}
+		Global.getProfile().filterActive=Filter.filterActive; //TODO This is a hack. Need to tidy this up
+		Global.getProfile().filterInverted=Filter.filterInverted;
+		Global.getProfile().restoreFilter();
 	}
 }

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-09-04 22:20:47 UTC (rev 877)
+++ trunk/src/CacheWolf/myTableControl.java	2007-09-04 23:05:39 UTC (rev 878)
@@ -239,12 +239,14 @@
 	
 	IconAndText imgDrag;
 	String wayPoint;
+	int row;
 	
 	public void startDragging(DragContext dc) {//TODO Dragging of header widths
 		 Vector cacheDB=Global.getProfile().cacheDB;
 		 Point p=cellAtPoint(dc.start.x,dc.start.y,null);
 		 wayPoint=null;
 		 if (p.y>=0) { 
+			 row=p.y;
 			 CacheHolder ch=(CacheHolder)cacheDB.get(p.y);
 			 wayPoint=ch.wayPoint;
 			 //Vm.debug("Waypoint : "+ch.wayPoint);
@@ -269,6 +271,7 @@
 		    		 ((mList) c).makeItemVisible(((mList)c).itemsSize()-1);
 		    	 }
 		     }
+		     Global.mainTab.tbP.selectRow(row);
 			 //Vm.debug("Control "+c.toString()+"/"+c.text);
 		 }else super.stopDragging(dc);
 	 }



From arno4401 at uni-trier.de  Wed Sep  5 01:31:31 2007
From: arno4401 at uni-trier.de (Dr. Robert Arnold)
Date: Wed, 05 Sep 2007 01:31:31 +0200
Subject: [Cachewolf-svn] r878 - trunk/src/CacheWolf
In-Reply-To: <200709042305.l84N5hIm024491@sheep.berlios.de>
References: <200709042305.l84N5hIm024491@sheep.berlios.de>
Message-ID: <20070904233135.D8E426D8445@rzmail.uni-trier.de>

Hallo Salzkammergut!

At 01:05 05.09.2007, salzkammergut at mail.berlios.de wrote:
>Author: salzkammergut
>Date: 2007-09-05 01:05:39 +0200 (Wed, 05 Sep 2007)
>New Revision: 878
>
>Modified:
>    trunk/src/CacheWolf/SearchCache.java
>    trunk/src/CacheWolf/myTableControl.java
>Log:
>Bugfix: Nachwehen von Rev 822 gefixt (schon alle?)
vielleicht sollten wir uns wegen der 
Cursor-Steuerung mal unterhalten. Bist Du 
grunds?tzlich mit der L?sung einverstanden, die 
ich f?r die 0.9n schon mal vorgesehen hatte: das 
w?rde bedeuten, dass wir die von ewe daf?r 
vorgesehenen Routinen nutzen und nicht alles neu 
schreiben. Diese Variante hat den Vorteil, dass 
sie beireits kombinierte Maus-/Tastatursteuerung 
vorsieht (und auch ohnehin Routinen f?r den 
Umgang mit einer leeren Liste vorhanden sind)...

vielleicht besprechen wir das mal etwas 
interaktiver (chat oder Telefon: 0228-4098835).

Sch?ne Gr??e,
    Robert. 



From pfeffer at mail.berlios.de  Wed Sep  5 03:58:27 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 5 Sep 2007 03:58:27 +0200
Subject: [Cachewolf-svn] r879 - trunk/src/CacheWolf
Message-ID: <200709050158.l851wRWu005812@sheep.berlios.de>

Author: pfeffer
Date: 2007-09-05 03:58:25 +0200 (Wed, 05 Sep 2007)
New Revision: 879

Modified:
   trunk/src/CacheWolf/SpiderGC.java
Log:
a small fixe from mGisbers for the encoding problem. It fixes not the problem from the enconding problem regarding the sign for degrees in spidering the coordinates

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-09-04 23:05:39 UTC (rev 878)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-09-05 01:58:25 UTC (rev 879)
@@ -110,7 +110,7 @@
 		}
 		if (!infB.isClosed) { // If user has not aborted, we continue
 			Regex rexCookieID = new Regex("Set-Cookie: userid=(.*?);.*");
-			Regex rex = new Regex("name=\"__VIEWSTATE\" value=\"(.*)\" />");
+			Regex rex = new Regex("name=\"__VIEWSTATE\" value=\"(.*?)\" />");
 			Regex rexCookieSession = new Regex("Set-Cookie: ASP.NET_SessionId=(.*?);.*");
 			rex.search(start);
 			if(rex.didMatch()){



From pfeffer at mail.berlios.de  Wed Sep  5 04:07:00 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 5 Sep 2007 04:07:00 +0200
Subject: [Cachewolf-svn] r880 - in trunk/src/CacheWolf: . map
Message-ID: <200709050207.l85270fF006357@sheep.berlios.de>

Author: pfeffer
Date: 2007-09-05 04:06:44 +0200 (Wed, 05 Sep 2007)
New Revision: 880

Added:
   trunk/src/CacheWolf/map/
   trunk/src/CacheWolf/map/Area.java
   trunk/src/CacheWolf/map/AreaList.java
   trunk/src/CacheWolf/map/CWGPSPoint.java
   trunk/src/CacheWolf/map/GotoPanel.java
   trunk/src/CacheWolf/map/Map.java
   trunk/src/CacheWolf/map/MapDetailForm.java
   trunk/src/CacheWolf/map/MapImage.java
   trunk/src/CacheWolf/map/MapInfoObject.java
   trunk/src/CacheWolf/map/MapLoader.java
   trunk/src/CacheWolf/map/MapLoaderGui.java
   trunk/src/CacheWolf/map/MapSymbol.java
   trunk/src/CacheWolf/map/MapsList.java
   trunk/src/CacheWolf/map/MovingMap.java
   trunk/src/CacheWolf/map/Navigate.java
   trunk/src/CacheWolf/map/SelectMap.java
   trunk/src/CacheWolf/map/SkyOrientation.java
   trunk/src/CacheWolf/map/Track.java
   trunk/src/CacheWolf/map/TrackOverlay.java
   trunk/src/CacheWolf/map/TrackPoint.java
Log:
all classes that deal anyhow with navigation (goto, map, gps) moved to package CacheWolf.navi in order to make the source more clearly arranged, .jnf, bat and sh accordingly adjusted, please test

Copied: trunk/src/CacheWolf/map/Area.java (from rev 878, trunk/src/CacheWolf/Area.java)
===================================================================
--- trunk/src/CacheWolf/Area.java	2007-09-04 23:05:39 UTC (rev 878)
+++ trunk/src/CacheWolf/map/Area.java	2007-09-05 02:06:44 UTC (rev 880)
@@ -0,0 +1,74 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+
+public class Area {
+	 public final static int NOT_ON_EDGE = -1;
+	 public final static int AT_TOP_EDGE = 1;
+	 public final static int AT_RIGHT_EDGE = 2;
+	 public final static int AT_BUTTOM_EDGE = 3;
+	 public final static int AT_LEFT_EDGE = 4;
+	 public static double edgeTolerance = 3 * 360/40000000; // approx 3m will be seen as the same
+
+	 CWPoint topleft;
+	 CWPoint buttomright;
+
+	 public Area(CWPoint tl, CWPoint br){
+		 topleft = new CWPoint(tl);
+		 buttomright = new CWPoint(br);
+	 }
+
+	 public boolean isInBound(CWPoint p) {
+		 if (topleft.latDec >= p.latDec && topleft.lonDec <= p.lonDec 
+				 && buttomright.latDec <= p.latDec && buttomright.lonDec >= p.lonDec) return true;
+		 else return false;
+	 }
+	 //if(affine[4] >= lati && lati >= lowlat && affine[5] <= loni && loni <= lowlon) isInBound = true;
+		
+	 public boolean isInBound(double lat, double lon) {
+		 if (topleft.latDec >= lat && topleft.lonDec <= lon
+				 && buttomright.latDec <= lat && buttomright.lonDec >= lon) return true;
+		 else return false;
+	 }
+	 
+	 public boolean isOverlapping(Area a) {
+		 if (       isInBound(a.topleft) || isInBound(a.buttomright) 
+				 || isInBound(a.buttomright.latDec, a.topleft.lonDec) // buttom left
+				 || isInBound(a.topleft.latDec, a.buttomright.lonDec) // top right
+				 // in case this is completly within a, the above tests will give false, so testing the otherway around
+				 || a.isInBound(this.topleft) || a.isInBound(this.buttomright)
+				 || a.isInBound(this.buttomright.latDec, this.topleft.lonDec) // buttom left
+				 || a.isInBound(this.topleft.latDec, this.buttomright.lonDec)) // top right
+			 return true;
+		 else return false;
+	 }
+
+	 public boolean equals(Area a) {
+		 if(java.lang.Math.abs(topleft.latDec - a.topleft.latDec) < edgeTolerance 
+				 && java.lang.Math.abs(topleft.lonDec - a.topleft.lonDec) < edgeTolerance
+				 && java.lang.Math.abs(buttomright.latDec - a.buttomright.latDec) < edgeTolerance
+				 && java.lang.Math.abs(buttomright.lonDec - a.buttomright.lonDec) < edgeTolerance )
+			 return true;
+		 else return false;
+	 }
+	 
+	 public int getEdge(CWPoint tl, CWPoint br) {
+		 if (java.lang.Math.abs(topleft.latDec - br.latDec) < edgeTolerance 
+				 && java.lang.Math.abs(topleft.lonDec - tl.lonDec) < edgeTolerance 
+				 && java.lang.Math.abs(buttomright.lonDec - br.lonDec) < edgeTolerance)
+			 return AT_TOP_EDGE;
+			 if (java.lang.Math.abs(topleft.latDec - tl.latDec) < edgeTolerance 
+					 && java.lang.Math.abs(buttomright.lonDec - tl.lonDec) < edgeTolerance 
+					 && java.lang.Math.abs(buttomright.latDec - br.latDec) < edgeTolerance)
+				 return AT_RIGHT_EDGE;
+			 if (java.lang.Math.abs(topleft.lonDec - tl.lonDec) < edgeTolerance 
+					 && java.lang.Math.abs(buttomright.latDec - tl.latDec) < edgeTolerance 
+					 && java.lang.Math.abs(buttomright.lonDec - br.lonDec) < edgeTolerance)
+				 return AT_BUTTOM_EDGE;
+			 if (java.lang.Math.abs(topleft.latDec - tl.latDec) < edgeTolerance 
+					 && java.lang.Math.abs(topleft.lonDec - br.lonDec) < edgeTolerance 
+					 && java.lang.Math.abs(buttomright.latDec - br.latDec) < edgeTolerance)
+				 return AT_LEFT_EDGE;
+			 return NOT_ON_EDGE;
+	 }
+}
\ No newline at end of file

Copied: trunk/src/CacheWolf/map/AreaList.java (from rev 878, trunk/src/CacheWolf/AreaList.java)
===================================================================
--- trunk/src/CacheWolf/AreaList.java	2007-09-04 23:05:39 UTC (rev 878)
+++ trunk/src/CacheWolf/map/AreaList.java	2007-09-05 02:06:44 UTC (rev 880)
@@ -0,0 +1,73 @@
+package CacheWolf.navi;
+
+
+/**
+ * Class for handling a list of areas covered by a list of maps.
+ * this is needed to determine if a new map should be downloaded or
+ * if a map for the requested area already exists
+ *
+ * @author pfeffer
+ *
+ */
+ public class AreaList extends ewe.util.LinkedListElement { // in java since v1.2 I would use java.util.TreeSet
+/*
+	 public AreaList(int s) {super(s);}
+
+	 public void addArea(CWPoint topleft, CWPoint buttomright) {
+		 Area tp = getArea(topleft);
+		 if (tp != null && tp.isInBound(buttomright)) return; // area already completly in list
+		 int edge = tp.getEdge(topleft, buttomright);
+		 switch (edge) {
+		 case Area.AT_TOP_EDGE: tp.topleft.latDec = topleft.latDec; break;
+		 case Area.AT_RIGHT_EDGE: tp.buttomright.lonDec = buttomright.lonDec; break;
+		 case Area.AT_BUTTOM_EDGE: tp.buttomright.latDec = buttomright.latDec; break;
+		 case Area.AT_LEFT_EDGE: tp.topleft.lonDec = topleft.lonDec; break;
+		 case Area.NOT_ON_EDGE: addAreaUnconditionally(new Area(topleft, buttomright));
+		 }
+	 }
+
+	 public boolean AreaIsCovered(CWPoint topleft, CWPoint buttomright) {
+		 Area tp = getArea(topleft);
+		 if (tp != null && tp.isInBound(buttomright)) return true; // area already completly in list
+		 else return false;
+
+	 }
+
+	 public void addArea(Area a) {
+		 addArea(a.topleft, a.buttomright);
+	 }
+
+	 public static AreaList joinAreas(AreaList al){
+		 AreaList ret = null;
+		 while (!al.equals(ret)) {
+			 ret = new AreaList(al.size());
+			 for (int i=al.size()-1; i >= 0; i--) {
+				 ret.addArea((Area)al.get(i));
+			 }
+		 }
+		 return ret;
+	 }
+
+	 public boolean equals(AreaList al){
+		 if (size() != al.size()) return false;
+		 for (int i = size()-1; i >= 0; i--) {
+			 if (!( ((Area)get(i)).equals((Area)al.get(i)) )) return false;
+		 }
+		 return true;
+	 }
+
+	 private void addAreaUnconditionally(Area a) {
+		 add(a); // TODO insert at the correct / sorted position
+	 }
+
+	 public Area getArea(CWPoint p) {
+		 Area ret;
+		 for (int i=size()-1; i>=0; i--) {
+			 ret = ((Area)get(i));
+			 if(ret.isInBound(p)) return ret;
+		 }
+		 return null;
+	 }
+
+*/
+ }

Copied: trunk/src/CacheWolf/map/CWGPSPoint.java (from rev 878, trunk/src/CacheWolf/CWGPSPoint.java)
===================================================================
--- trunk/src/CacheWolf/CWGPSPoint.java	2007-09-04 23:05:39 UTC (rev 878)
+++ trunk/src/CacheWolf/map/CWGPSPoint.java	2007-09-05 02:06:44 UTC (rev 880)
@@ -0,0 +1,336 @@
+/*
+ * Created on 02.04.2005
+ *
+ * TODO To change the template for this generated file go to
+ * Window - Preferences - Java - Code Style - Code Templates
+ */
+package CacheWolf.navi;
+import CacheWolf.CWPoint;
+import CacheWolf.Common;
+import CacheWolf.Extractor;
+import CacheWolf.Global;
+import ewe.sys.*;
+import ewe.ui.ExecTransfer;
+import ewe.io.*;
+
+
+
+/**
+ * @author Kalle
+ * Class for decoding NMEA sentences
+ */
+
+public class CWGPSPoint extends CWPoint implements TimerProc{
+	public static final int LOGNMEA = 0x01;
+	public static final int LOGRAW  = 0x02;
+	public static final int LOGALL  = LOGNMEA|LOGRAW;
+
+	public double Speed; //Speed
+	public double Bear;	//Bearing
+	public String Time; //Time
+	public String Date;
+	public int Fix; //Fix
+	public int numSat; //Satellites in use, -1 indicates no data, -2 that data could not be interpreted
+	public double HDOP; // Horizontal dilution of precision
+	public double Alt; //Altitude
+
+	//Logging
+	int logTimer = 0;
+	int logFlag = 0;
+	boolean writeLog = false;
+	boolean doLogging = false;
+	FileWriter logFile;
+	String lastStrExamined = new String();
+
+
+	public CWGPSPoint()
+	{
+		super();
+		this.Speed = 0;
+		this.Bear = 0;
+		this.Time = "";
+		this.Date="";
+		this.Fix = 0;
+		this.numSat = 0;
+		this.Alt = 0;
+		this.HDOP = 0;
+	}
+
+
+	public double getSpeed(){
+		return this.Speed;
+	}
+
+	public double getBear (){
+		return this.Bear;
+	}
+	public String getTime(){
+		return this.Time;
+	}
+
+	public int getFix(){
+		return this.Fix;
+	}
+
+	/**
+	 * this method should be called, if COM-Port is closed
+	 */
+	public void noData(){
+		this.Fix = 0;
+		this.numSat = 0;
+	}
+
+	/**
+	 * this method should be called, if not data is coming from COM-Port but is expected to come
+	 */
+	public void noDataError(){
+		this.Fix = -1;
+		this.numSat = -1;
+	}
+
+	/**
+	 * this method should be called, if examine returns for several calls that it couldn't interprete the data
+	 */
+	public void noInterpretableData(){
+		this.Fix = -2;
+		this.numSat = -2;
+	}
+
+	public void ticked(int timerId, int elapsed){
+		if (timerId == logTimer) {
+			writeLog = true;
+		}
+
+	}
+
+	/**
+	 * 
+	 * @param logFileDir directory for logfile
+	 * @param seconds	 intervall for writing to logfile
+	 * @param flag		 level of logging
+	 * @return 0 success, -1 failure
+	 */
+	public int startLog(String logFileDir, int seconds, int flag){
+
+		Time currTime = new Time();
+		currTime.getTime();
+		currTime.setFormat("yyyyMMdd'_'HHmm");
+		String logFileName = new String(logFileDir + currTime.toString()+ ".log");
+		// create Logfile
+		try {
+			logFile = new FileWriter(logFileName);
+		} catch (IOException e) {
+			Vm.debug("Error creating LogFile " + logFileName);
+			return -1;
+		} 
+		// start timer
+		logTimer = Vm.requestTimer(this, 1000 * seconds);
+		logFlag = flag;
+		doLogging = true;
+		return 0;
+	}
+
+	public void stopLog() {
+		writeLog = false;
+
+		if (doLogging){
+			try {
+				logFile.close();
+			} catch (IOException e) {}
+			if (logTimer > 0) {
+				Vm.cancelTimer(logTimer);
+				logTimer = 0;
+			}
+		}
+		doLogging = false;
+	}
+
+
+	public int getSats(){
+		return this.numSat;
+	}
+
+	public double getAlt(){
+		return this.Alt;
+	}
+
+	public double getHDOP(){
+		return this.HDOP;
+	}
+
+	/**
+	 * 
+	 * @param NMEA	string with data to examine
+	 * @return true if some data could be interpreted false otherwise
+	 */
+	public boolean examine(String NMEA){ 
+		boolean interpreted = false;
+		try {
+			int i, start, end;
+			String latDeg="0", latMin="0", latNS="N"; 
+			String lonDeg="0", lonMin="0", lonEW="E";
+			String currToken;
+			end = 0;
+			lastStrExamined = NMEA;
+			//Vm.debug(NMEA);
+			if (writeLog && (logFlag & LOGRAW) > 0){ 
+				try {
+					logFile.write(NMEA);
+					writeLog = false;
+				} catch (IOException e) {}
+			}
+			while(true){
+				start = NMEA.indexOf("$GP", end);  
+				if (start == -1) return interpreted;  
+				end = NMEA.indexOf("*", start);  
+				if ((end == -1)||(end+3 > NMEA.length())) return interpreted;  
+
+
+				//Vm.debug(NMEA.substring(start,end+3));
+				if ((end - start) < 15 || !checkSumOK(NMEA.substring(start,end+3))){
+					//Vm.debug("checksum wrong");
+					continue;
+				}
+				Extractor ex = new Extractor ("," + NMEA.substring(start,end), ",",",",0,true);
+				currToken = ex.findNext();
+				if (currToken.equals("$GPGGA")){
+					//Vm.debug("In $GPGGA");
+					i = 0;
+					while(ex.endOfSearch() != true){
+						currToken = ex.findNext();
+						i++;
+						if (currToken.length()==0) continue; // sometimes there are 2 colons directly one after the other like ",," (e.g. loox)
+						switch (i){
+						case 1: this.Time = currToken; break;
+						case 2: try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+						try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+						break;
+						case 3: latNS = currToken;
+						break;
+
+						case 4: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true; } catch (IndexOutOfBoundsException e) {}
+						break;
+						case 5: lonEW = currToken;
+						break;
+						case 6: this.Fix = Convert.toInt(currToken); interpreted = true; break;
+						case 7: this.numSat = Convert.toInt(currToken); interpreted = true; break;
+						case 8: try {this.HDOP = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} break;
+						case 9: try {this.Alt = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} break;
+						} // switch
+					} // while
+					if (Fix > 0) this.set(latNS, latDeg, latMin, "0", lonEW, lonDeg, lonMin, "0", CWPoint.DMM);
+
+				} // if
+
+				if (currToken.equals("$GPVTG")){
+					i = 0;
+					while(ex.endOfSearch() != true){
+						currToken = ex.findNext();
+						i++;
+						if (currToken.length()==0) continue;
+						switch (i){
+						case 1: try { this.Bear =Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {}
+						if (this.Bear > 360) Vm.debug("Error bear VTG");
+						break;
+						case 7: try { this.Speed = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} 
+						break;
+						} // switch
+					} // while
+				} // if
+
+				if (currToken.equals("$GPRMC")){
+					//Vm.debug("In $GPRMC");
+					i = 0;
+					String status = "V";
+					while(ex.endOfSearch() != true){
+						currToken = ex.findNext();
+						i++;
+						if (currToken.length()==0) continue;
+						//Vm.debug("zz: " + i);
+						//Vm.debug(currToken);
+						switch (i){
+						case 1: this.Time = currToken; interpreted = true; break;
+						case 2: status = currToken; 
+						if (status.equals("A")) this.Fix = 1;
+						else this.Fix = 0;
+						interpreted = true;
+						break;
+						case 3: 	//Vm.debug("Here--->");
+							try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+							//Vm.debug(":" + latDeg);
+							try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+							//Vm.debug(":" + latMin);
+							break;
+						case 4: latNS = currToken; interpreted = true;
+						break;
+						case 5: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+						break;
+						case 6: lonEW = currToken;
+						interpreted = true;
+						break;
+						case 7: if (status.equals("A")){
+							try {this.Speed = Common.parseDouble(currToken)*1.854;
+							interpreted = true; } catch (NumberFormatException e) { }
+						}
+						break;
+						case 8: if (status.equals("A") && currToken.length()> 0){
+							try {this.Bear = Common.parseDouble(currToken);
+							interpreted = true; } catch (NumberFormatException e) { }
+						}
+						break;
+						case 9: if (status.equals("A") && currToken.length()> 0){
+							try {this.Date = currToken;
+							interpreted = true; } catch (NumberFormatException e) { }
+						}
+						break;
+						} // switch
+					} // while
+					if (status.equals("A")){
+						this.set(latNS, latDeg, latMin, "0",
+								lonEW, lonDeg, lonMin, "0", CWPoint.DMM);				
+					}
+				} // if
+				//Vm.debug("End of examine");
+			} //while
+		} catch (Exception e) {
+			Global.getPref().log("Exception in examine in CWGPSPoint", e, true);
+			e.printStackTrace();
+			return interpreted;
+		}
+	}
+
+	private boolean checkSumOK(String nmea){
+		int startPos = 1; // begin after $
+		int endPos = nmea.length() - 3;// without * an two checksum chars
+		byte checkSum = 0;
+
+		for (int i= startPos; i<endPos;i++){
+			checkSum ^= nmea.charAt(i);
+		}
+		//Vm.debug(nmea.substring(3,6)+" Checksum: " + nmea.substring(endPos+1) + " Calculated: " + Convert.intToHexString(checkSum));
+		try { return (checkSum == Byte.parseByte(nmea.substring(endPos+1),16));
+		} catch (IndexOutOfBoundsException e) {
+			return false;
+		} catch (NumberFormatException e) {
+			return false;
+		}
+	}
+
+
+
+	public void printAll(){
+		Vm.debug("Latitude:  " + this.getLatDeg(DD));
+		Vm.debug("Longitude: " + this.getLonDeg(DD));
+		Vm.debug("Speed:     " + this.Speed);
+		Vm.debug("Bearing:   " + this.Bear);
+		Vm.debug("Time:      " + this.Time);
+		Vm.debug("Fix:       " + this.Fix);
+		Vm.debug("Sats:      " + this.numSat);
+		Vm.debug("HDOP:      " + this.HDOP);
+		Vm.debug("Alt:       " + this.Alt);
+		Vm.debug("----------------");
+	}
+}
+

Copied: trunk/src/CacheWolf/map/GotoPanel.java (from rev 878, trunk/src/CacheWolf/GotoPanel.java)
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-09-04 23:05:39 UTC (rev 878)
+++ trunk/src/CacheWolf/map/GotoPanel.java	2007-09-05 02:06:44 UTC (rev 880)
@@ -0,0 +1,847 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.CacheHolder;
+import CacheWolf.CoordsScreen;
+import CacheWolf.DetailsPanel;
+import CacheWolf.Global;
+import CacheWolf.MainTab;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+import CacheWolf.Profile;
+import ewe.ui.*;
+import ewe.util.Vector;
+import ewe.util.mString;
+import ewe.fx.*;
+import ewe.graphics.AniImage;
+import ewe.io.*;
+import ewe.net.Socket;
+//import ewe.io.IOException;
+//import ewe.io.SerialPort;
+//import ewe.io.SerialPortOptions;
+import ewe.sys.*;
+import ewe.sys.Double;
+
+/**
+ *	Class to create the panel which handles the connection to the GPS-device<br>
+ *	Displays: current position,speed and bearing; relation to destination waypoint<br>
+ *	Class ID: 1500
+ */
+
+
+public class GotoPanel extends CellPanel {
+
+	//public CWGPSPoint gpsPosition = new CWGPSPoint();
+	//public CWPoint toPoint = new CWPoint();
+	public Navigate myNavigation;
+	mButton btnGPS, btnCenter,btnSave;
+	mButton btnGoto, btnMap;
+	int currFormat;
+
+	mLabel lblGPS, lblPosition, lblDST;
+	mLabel lblLog;
+	Color gpsStatus;
+	mCheckBox chkLog;
+	mInput inpLogSeconds;
+
+	MainTab mainT;
+	Vector cacheDB;
+	DetailsPanel detP;
+
+	Preferences pref;
+	Profile profile;
+	// different panels to avoid spanning
+	CellPanel ButtonP = new CellPanel();
+	CellPanel CoordsP = new CellPanel();
+	CellPanel roseP = new CellPanel();
+	CellPanel LogP = new CellPanel();
+
+	ImageControl icRose;
+	GotoRose compassRose;
+
+	final static Color RED = new Color(255,0,0);
+	final static Color YELLOW = new Color(255,255,0);
+	final static Color GREEN = new Color(0,255,0);
+	final static Color BLUE = new Color(0,0,255);
+
+	final static Font BOLD = new Font("Arial", Font.BOLD, 14);
+
+	int ticker = 0;
+	
+	Menu mnuContextFormt;
+	MenuItem miDMM, miDMS, miDD, miUTM;
+	
+	Menu mnuContextRose;
+	MenuItem miLuminary[] = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
+	MenuItem miNorthCentered;
+	
+	/**
+	 * Create GotoPanel 
+	 * @param Preferences 	global preferences
+	 * @param MainTab		reference to MainTable
+	 * @param DetailsPanel 	reference to DetailsPanel
+	 * @param Vector		cacheDB
+	 */
+	public GotoPanel(Navigate nav) {
+		myNavigation = nav;
+		pref = Global.getPref();
+		profile=Global.getProfile();
+		mainT = Global.mainTab;
+		detP = mainT.detP;
+		cacheDB = profile.cacheDB;
+
+		// Button
+		ButtonP.addNext(btnGPS = new mButton("Start"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addNext(btnCenter = new mButton(MyLocale.getMsg(309,"Center")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addNext(btnSave = new mButton(MyLocale.getMsg(311,"Create Waypoint")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addLast(btnMap = new mButton("Map"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+
+		//Format selection for coords		
+		//context menu
+		mnuContextFormt = new Menu();
+		mnuContextFormt.addItem(miDD = new MenuItem("d.d?"));
+		miDD.modifiers &= ~MenuItem.Checked;
+		mnuContextFormt.addItem(miDMM = new MenuItem("d?m.m\'"));
+		miDMM.modifiers |= MenuItem.Checked;
+		mnuContextFormt.addItem(miDMS = new MenuItem("d?m\'s\""));
+		miDMS.modifiers &= ~MenuItem.Checked;
+		mnuContextFormt.addItem(miUTM = new MenuItem("UTM"));
+		miUTM.modifiers &= ~MenuItem.Checked;
+		currFormat = CWPoint.DMM;
+
+		// Create context menu for compass rose: select luminary for orientation
+		mnuContextRose = new Menu();
+		for (int i=0; i<SkyOrientation.LUMINARY_NAMES.length; i++) {
+			mnuContextRose.addItem(miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i)));
+			if (i == myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
+			else miLuminary[i].modifiers &= MenuItem.Checked;
+		}
+
+		//Coords
+		CoordsP.addNext(lblGPS = new mLabel("GPS: "),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		lblGPS.backGround = RED;
+		lblGPS.setMenu(mnuContextFormt);
+		lblGPS.modifyAll(Control.WantHoldDown, 0);
+		CoordsP.addLast(lblPosition = new mLabel(myNavigation.gpsPos.toString(currFormat)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		lblPosition.setMenu(mnuContextFormt);
+		lblPosition.modifyAll(Control.WantHoldDown, 0);
+		CoordsP.addNext(lblDST = new mLabel(MyLocale.getMsg(1500,"DST:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		lblDST.backGround = new Color(0,0,255);
+		lblDST.setMenu(mnuContextFormt);
+		lblDST.modifyAll(Control.WantHoldDown, 0);
+		CoordsP.addLast(btnGoto = new mButton(getGotoBtnText()),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+
+		//Rose for bearing
+		compassRose = new GotoRose("rose.png");
+		icRose = new ImageControl(compassRose);
+		icRose.setMenu(mnuContextRose);
+		icRose.modifyAll(Control.WantHoldDown, 0); // this is necessary in order to make PenHold on a PDA work as right click
+		roseP.addLast(icRose,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTH));
+		
+		mnuContextRose.addItem(new MenuItem("", MenuItem.Separator, null));
+		mnuContextRose.addItem(miNorthCentered = new MenuItem(MyLocale.getMsg(1503,"North Centered")));
+		if (compassRose.isNorthCentered()) miNorthCentered.modifiers |= MenuItem.Checked;
+		else miNorthCentered.modifiers &= MenuItem.Checked;
+
+		//log
+		LogP.addNext(lblLog = new mLabel("Log "),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		LogP.addNext(chkLog = new mCheckBox(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		LogP.addNext(inpLogSeconds = new mInput("10"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		LogP.addLast(new mLabel("sec"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+
+		chkLog.useCross = true;
+		chkLog.setState(false);
+		inpLogSeconds.columns = 5;
+
+		//add Panels
+		this.addLast(ButtonP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
+		this.addLast(CoordsP,CellConstants.HSTRETCH, CellConstants.HFILL|CellConstants.NORTH).setTag(SPAN,new Dimension(2,1));
+		this.addLast(roseP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
+		//this.addLast(LogP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.NORTHWEST).setTag(SPAN,new Dimension(1,1));
+
+		// for debuging
+		/*		CWGPSPoint myGPS;
+		myGPS = new CWGPSPoint();
+		String ex = new String();
+		boolean test = false;
+		try { FileReader f = new FileReader("c:\\kw\\20060928_1051.log");
+		ex = f.readAll();
+		test = myGPS.examine(ex);
+		f.close();
+		} catch (IOException e ) {
+			Vm.debug(e.toString());
+		}
+		test = myGPS.examine("$GPGLL,5226.8935,N,01338.5327,E,084635.00,A,D*6E");
+		test = myGPS.examine("$GPGSA,A,3,10,28,26,29,09,,,,,,,,04.1,02.6,03.2*0F");
+		test = myGPS.examine("$GPGSV,4,1,13,08,40,072,28,10,29,201,47,27,15,079,29,28,62,102,44*7E");
+		test = myGPS.examine("$GPGSV,4,2,13,29,72,289,38,26,63,296,41,09,12,259,35,18,14,324,*79");
+		test = myGPS.examine("$GPGSV,4,3,13,19,09,025,,17,06,138,,21,06,300,,37,29,171,40*7A");
+		test = myGPS.examine("$GPGSV,4,4,13,39,29,166,38*40");
+		 */
+
+		//while (true){
+//		int notinterpreted = 0;
+//		if (myGPS.examine("@??H @??H?@??HH???????H")) { notinterpreted = 0;} else notinterpreted++;
+//		if (notinterpreted > 5) myGPS.noInterpretableData();
+//		// myGPS.noInterpretableData();
+
+
+//		}	
+	}
+
+
+	/**
+	 * set the coords of the destination  
+	 * @param dest destination
+	 */ 
+	public void setDestination(CWPoint dest){
+		myNavigation.setDestination(dest);
+		if (!myNavigation.destination.isValid()) (new MessageBox("Error", "Coordinates are out of range: \n"+"latitude: "+myNavigation.destination.latDec+"\n longditue: "+myNavigation.destination.lonDec, MessageBox.OKB)).execute();
+		
+	}
+	
+	public void destChanged(CWPoint d) { // called from myNavigate
+		btnGoto.setText(getGotoBtnText());
+		updateDistance();
+	}
+	
+
+	/**
+	 * set the coords of the destination and switch to gotoPanel  
+	 * @param LatLon destination
+	 */ 
+	public void setDestinationAndSwitch(String LatLon) {
+		myNavigation.setDestination(LatLon);
+		mainT.select(this);
+	}
+	
+	/**
+	 * updates distance and bearing
+	 *
+	 */
+	
+	public void updateDistance() {
+		//update distance
+		float distance = -1.0f;
+		if (myNavigation.gpsPos.isValid() && myNavigation.destination.isValid() ) {
+			distance = (float)myNavigation.gpsPos.getDistance(myNavigation.destination);
+		}
+		compassRose.setWaypointDirectionDist((float)myNavigation.gpsPos.getBearing(myNavigation.destination), distance);
+	}
+
+	/**
+	 * method which is called if a timer is set up  
+	 */ 
+	public void updateGps(int fix) {
+		Double bearMov = new Double();
+		Double speed = new Double();
+		Double sunAzimut = new Double();
+		Vm.debug("ticked: voher");
+		compassRose.setGpsStatus(fix, myNavigation.gpsPos.getSats(), myNavigation.gpsPos.getHDOP());
+		if ((fix > 0) && (myNavigation.gpsPos.getSats()>= 0)) {
+			// display values only, if signal good
+			//Vm.debug("currTrack.add: nachher");
+			lblPosition.setText(myNavigation.gpsPos.toString(currFormat));
+			sunAzimut.set(myNavigation.skyOrientationDir.lonDec);
+			bearMov.set(myNavigation.gpsPos.getBear());
+			updateDistance();
+			compassRose.setSunMoveDirections((float)sunAzimut.value, (float)bearMov.value, (float)speed.value);
+			// Set background to signal quality
+		}
+
+		// receiving data, but signal ist not good
+		if ((fix == 0) && (myNavigation.gpsPos.getSats()>= 0)) {
+			gpsStatus = YELLOW;
+		}
+		// receiving no data
+		if (fix == -1) {
+			if (gpsStatus != RED) (new MessageBox("Error", "No data from GPS\nConnection to serial port closed",MessageBox.OKB)).exec();
+			gpsStatus = RED;
+			myNavigation.stopGps();
+		}
+		// cannot interprete data
+		if (fix == -2) {
+			if (gpsStatus != RED) (new MessageBox("Error", "Cannot interpret data from GPS\n possible reasons:\n wrong Port,\n wrong Baudrate,\n not NMEA-Protocol\nConnection to serial port closed\nLast String tried to interprete:\n "+myNavigation.gpsPos.lastStrExamined, MessageBox.OKB)).exec();
+			gpsStatus = RED;
+			myNavigation.stopGps(); // TODO automatic in myNavigate?
+		}
+	}
+
+	public void gpsStarted() {
+		chkLog.modify(ControlConstants.Disabled,0);
+		btnGPS.setText("Stop");
+	}
+	
+	public void startGps() {
+		myNavigation.setRawLogging(chkLog.getState(), Convert.toInt(inpLogSeconds.getText()));
+		myNavigation.startGps();
+	}
+
+	public void gpsStoped() {
+		btnGPS.setText("Start");
+		gpsStatus = this.backGround;
+		chkLog.modify(0,ControlConstants.Disabled);
+		this.repaintNow(); // without this the change in the background color will not be displayed
+	}
+
+	
+	private String getGotoBtnText() {
+		if (myNavigation.destination == null) return "not set";
+		else return myNavigation.destination.toString(currFormat);
+	}
+	
+	public void switchToMovingMap() {
+		CWPoint centerTo;
+		if (myNavigation.isGpsPosValid()) centerTo = new CWPoint(myNavigation.gpsPos); // set gps-pos if gps is on
+		else {
+			// setze Zielpunkt als Ausgangspunkt, wenn GPS aus ist und lade entsprechende Karte
+			//centerTo = new CWPoint(myNavigation.destination);
+			if (myNavigation.destination.isValid())	centerTo = new CWPoint(myNavigation.destination);
+			else centerTo = new CWPoint(pref.curCentrePt); // if not goto-point defined move map to centere point
+		}  
+		mainT.SwitchToMovingMap(centerTo, false);
+	}
+	
+	/**
+	 * Eventhandler
+	 */
+
+	public void onEvent(Event ev){
+		if (ev instanceof MenuEvent) { 
+			if (ev.type == MenuEvent.SELECTED ) {
+				MenuItem action = (MenuItem) mnuContextFormt.getSelectedItem(); 
+				if (action != null) {
+					if (action == miDD) {
+						mnuContextFormt.close();
+						currFormat = CWPoint.DD;
+					}
+					if (action == miDMM) {
+						mnuContextFormt.close();
+						currFormat = CWPoint.DMM;
+					}
+					if (action == miDMS) {
+						mnuContextFormt.close();
+						currFormat = CWPoint.DMS;
+					}
+					if (action == miUTM) {
+						mnuContextFormt.close();
+						currFormat = CWPoint.UTM;
+					}
+					miDD.modifiers &= ~MenuItem.Checked;
+					miDMM.modifiers &= ~MenuItem.Checked;
+					miDMS.modifiers &= ~MenuItem.Checked;
+					miUTM.modifiers &= ~MenuItem.Checked;
+					switch (currFormat) {
+					case CWPoint.DD: miDD.modifiers |= MenuItem.Checked; break;   
+					case CWPoint.DMM: miDMM.modifiers |= MenuItem.Checked; break;   
+					case CWPoint.DMS: miDMS.modifiers |= MenuItem.Checked; break;   
+					case CWPoint.UTM: miUTM.modifiers |= MenuItem.Checked; break;
+					}
+
+					lblPosition.setText(myNavigation.gpsPos.toString(currFormat));
+					btnGoto.setText(getGotoBtnText());
+				} // end lat-lon-format context menu
+				action = (MenuItem) mnuContextRose.getSelectedItem();
+				if (action != null) {
+					for (int i=0; i<miLuminary.length; i++) {
+						if (action == miLuminary[i]) {
+							myNavigation.setLuminary(i);
+							miLuminary[i].modifiers |= MenuItem.Checked;
+							compassRose.setLuminaryName(SkyOrientation.getLuminaryName(myNavigation.luminary));
+						} else miLuminary[i].modifiers &= ~MenuItem.Checked;
+					}
+					if (action == miNorthCentered) {
+						if (compassRose.isNorthCentered()) {
+							compassRose.setNorthCentered(false);
+							miNorthCentered.modifiers &= ~MenuItem.Checked;							
+						}
+						else
+						{
+							compassRose.setNorthCentered(true);
+							miNorthCentered.modifiers |= MenuItem.Checked;
+						}
+					}
+				}
+			}
+		}
+
+		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+			// start/stop GPS connection
+			if (ev.target == btnGPS){
+				if (btnGPS.getText().equals("Start")) startGps();
+				else myNavigation.stopGps();
+			}
+
+			// set current position as center and recalculate distance of caches in MainTab 
+			if (ev.target == btnCenter){
+				Vm.showWait(true);
+				pref.curCentrePt.set(myNavigation.gpsPos);
+				mainT.updateBearDist();
+				Vm.showWait(false);
+			}
+			//Start moving map
+			if (ev.target == btnMap){
+				switchToMovingMap();
+			} 
+			// create new waypoint with current GPS-position
+			if (ev.target == btnSave){
+				CacheHolder ch = new CacheHolder();
+				ch.LatLon = myNavigation.gpsPos.toString();
+				ch.pos = new CWPoint(myNavigation.gpsPos);
+				mainT.newWaypoint(ch);
+			}
+			// change destination waypoint
+			if (ev.target == btnGoto){
+				CoordsScreen cs = new CoordsScreen();
+				if (myNavigation.destination.isValid())	cs.setFields(myNavigation.destination, currFormat);
+				else cs.setFields(new CWPoint(0,0), currFormat);
+				if (cs.execute(null, Gui.TOP) == CoordsScreen.IDOK)
+					setDestination(cs.getCoords());
+			}
+		}
+		super.onEvent(ev);
+	}
+}
+
+/** class for displaying the compass rose
+ * including goto, sun and moving direction
+ */
+class GotoRose extends AniImage {
+	float gotoDir = -361;
+	float sunDir = -361;
+	float moveDir = -361;
+	float distance = -1;
+	
+	int m_fix = -1;
+	int m_sats = -1;
+	double m_hdop = -1;
+	float m_speed = -1;
+	
+	String m_Luminary = MyLocale.getMsg(6100, "Sun");
+	
+	FontMetrics fm;
+	
+	boolean northCentered = Global.getPref().northCenteredGoto;
+	
+	final static Color RED = new Color(255,0,0);
+	final static Color YELLOW = new Color(255,255,0);
+	final static Color GREEN = new Color(0,255,0);
+	final static Color BLUE = new Color(0,0,255);
+	final static Color ORANGE = new Color(255,128,0);
+	final static Color DARKGREEN = new Color(0,192,0);
+	final static Color CYAN = new Color(0,255,255);
+	final static Color MAGENTA = new Color(255,0,255);
+
+	/**
+	 * @param gd goto direction
+	 * @param sd sun direction
+	 * @param md moving direction
+	 */
+	public GotoRose(String fn){
+		super(fn);
+	}
+	
+	public void setWaypointDirectionDist(float wd, float dist) {
+		gotoDir = wd;
+		distance = dist;
+	}
+	
+	public void setSunMoveDirections(float sd, float md, float speed ) {
+		sunDir = sd;
+		moveDir = md;
+		m_speed = speed;
+		refresh();
+	}
+	
+	public void setGpsStatus(int fix, int sats, double hdop) {
+		m_fix = fix;
+		m_sats = sats;
+		m_hdop = hdop;
+		refresh();
+	}
+	
+	public void setLuminaryName(String Luminary) {
+		m_Luminary = Luminary;
+		refresh();
+	}
+
+	
+	/**
+	 * draw arrows for the directions of movement and destination waypoint
+	 * @param ctrl the control to paint on
+	 * @param moveDir degrees of movement
+	 * @param destDir degrees of destination waypoint
+	 */
+	
+	public void doDraw(Graphics g,int options) {
+		if (northCentered) {
+			super.doDraw(g, options);
+		}
+		else {
+			g.setColor(Color.White);
+			g.fillRect(0, 0, location.width, location.height);
+		}
+		Font font = new Font("Verdana", Font.BOLD, 12);
+		g.setFont(font);
+		fm = g.getFontMetrics(font);
+		drawArrows(g);
+		drawWayPointData(g);
+		drawGpsData(g);
+		drawLuminaryData(g);
+		drawGpsStatus(g);
+	}
+		
+	private void drawWayPointData(Graphics g){
+		String strTemp = "WayPoint";
+		g.setColor(Color.DarkBlue);
+		g.fillRect(0, 0, fm.getTextWidth(strTemp) + 4 ,fm.getHeight());
+		g.setColor(Color.White);		
+		g.drawText(strTemp, 2, 0);
+		
+		g.setColor(Color.Black);		
+		
+		Double tmp = new Double();
+		strTemp = "";
+		if ( distance >= 0.0f ) {
+			tmp.set(distance);
+			if (tmp.value >= 1){
+				strTemp = MyLocale.formatDouble(tmp,"0.000")+ " km";
+			}
+			else {
+				tmp.set(tmp.value * 1000);
+				strTemp = tmp.toString(3,0,0) + " m";
+			}
+		}
+		else strTemp = "--- km";
+		g.drawText(strTemp, 2, 12);
+		
+		tmp.set(gotoDir);
+		if ((tmp.value <= 360) && (tmp.value >= -360))
+			strTemp = tmp.toString(0,0,0) + " " + MyLocale.getMsg(1502,"deg");
+		else strTemp = "---" + " " + MyLocale.getMsg(1502,"deg");
+		g.drawText(strTemp, 2, 24);
+	}
+	
+	private void drawGpsData(Graphics g){
+		g.setColor(RED);
+		
+		String strHeadline = MyLocale.getMsg(1501,"Current");
+		
+		Double tmp = new Double();
+
+		tmp.set(m_speed);
+		String strSpeed = "- km/h";
+		if (m_speed >= 0) {
+			if (m_speed >= 100) {
+				strSpeed = MyLocale.formatDouble(tmp,"0") + " km/h";				
+			}
+			else {
+				strSpeed = MyLocale.formatDouble(tmp,"0.0") + " km/h";
+			}
+		}
+		
+		tmp.set(moveDir);
+		String strMoveDir = "---" + " " + MyLocale.getMsg(1502,"deg");
+		if ((tmp.value <= 360) && (tmp.value >= -360))
+			strMoveDir = tmp.toString(0,0,0) + " " + MyLocale.getMsg(1502,"deg");
+
+		int textWidth = java.lang.Math.max(fm.getTextWidth(strSpeed), fm.getTextWidth(strMoveDir));
+		textWidth = java.lang.Math.max(textWidth, fm.getTextWidth(strHeadline));
+		
+		int startX = location.width - (textWidth + 4);
+		g.fillRect(startX, 0, location.width - startX ,12);
+		
+		g.setColor(Color.Black);		
+		g.drawText(strHeadline, startX + 2, 0);		
+		g.drawText(strSpeed, startX + 2, 12);
+		g.drawText(strMoveDir, startX + 2, 24);
+	}
+	
+	private void drawLuminaryData(Graphics g){
+		g.setColor(YELLOW);
+
+		String strSunDir = "---" + " " + MyLocale.getMsg(1502,"deg");
+		if (sunDir < 360 && sunDir > -360) {
+			Double tmp = new Double();
+			tmp.set(sunDir);
+			strSunDir = tmp.toString(0,0,0) + " " + MyLocale.getMsg(1502,"deg");
+		}
+
+		int textWidth = java.lang.Math.max(fm.getTextWidth(m_Luminary), fm.getTextWidth(strSunDir));
+		int startY = location.height - 24;
+		g.fillRect(0, startY, textWidth + 4, location.height - startY);
+
+		g.setColor(Color.Black);		
+		g.drawText(m_Luminary, 2, startY);
+		g.drawText(strSunDir, 2, startY + 12);
+	}
+	
+	private void drawGpsStatus(Graphics g){
+		if ((m_fix > 0) && (m_sats >= 0)) {
+			// Set background to signal quality
+			g.setColor(GREEN);
+		}
+		else
+		// receiving data, but signal ist not good
+		if ((m_fix == 0) && (m_sats >= 0)) {
+			g.setColor(YELLOW);
+		}
+		else {
+			g.setColor(RED);
+		}
+
+		String strSats = "Sats: -";
+		if (m_sats >= 0) strSats = "Sats: " + Convert.toString(m_sats);
+		String strHdop = "HDOP: -";
+		if (m_hdop >= 0) strHdop = "HDOP: " + Convert.toString(m_hdop);
+
+		int textWidth = java.lang.Math.max(fm.getTextWidth(strSats), fm.getTextWidth(strHdop));
+		int startX = location.width - (textWidth + 4);
+		int startY = location.height - 24;
+		g.fillRect(startX, startY, location.width - startX ,location.height - startY);
+
+		g.setColor(Color.Black);
+		g.drawText(strSats, startX + 2, startY);
+		g.drawText(strHdop, startX + 2, startY + 12);
+	}
+
+	private void drawArrows(Graphics g){
+		if (g != null)
+		{
+			// select moveDirColor according to difference to gotoDir
+			Color moveDirColor = RED;
+			
+			if (gotoDir < 360 && gotoDir > -360 && moveDir < 360 && moveDir > -360)
+			{
+				float diff = java.lang.Math.abs(moveDir - gotoDir);
+				while (diff > 360)
+				{
+					diff -= 360.0f;
+				}
+				if (diff > 180.0f)
+				{
+					diff = 360.0f - diff;
+				}
+				
+				if (diff <= 12.25f)
+				{
+					moveDirColor = GREEN;
+				}
+				else if (diff <= 22.5f)
+				{
+					moveDirColor = CYAN;
+				}
+				else if (diff <= 45.0f)
+				{
+					moveDirColor = ORANGE;
+				}
+				else if (diff <= 90.0f)
+				{
+					moveDirColor = MAGENTA;
+				}
+			}
+
+			// draw only valid arrows
+			if (northCentered) {
+				if (gotoDir < 360 && gotoDir > -360) drawThickArrow(g, gotoDir, Color.DarkBlue, 1.0f);
+				if (moveDir < 360 && moveDir > -360) drawThinArrow(g, moveDir, RED, moveDirColor, 1.0f);
+				if (sunDir < 360 && sunDir > -360) drawSunArrow(g, sunDir, YELLOW, 0.75f);
+			}
+			else {
+				//moveDir centered
+				int radius = (int)((float)(java.lang.Math.min(location.width, location.height) / 2) * 0.75f);
+
+				g.setPen(new Pen(new Color(150,150,150),Pen.SOLID,3));
+				g.drawEllipse(location.width/2 - radius, location.height/2 - radius, 2 * radius, 2 * radius );
+
+				if (moveDir < 360 && moveDir > -360) {
+					//drawDoubleArrow(g, 360 - moveDir, BLUE, new Color(175,0,0), 1.0f);
+					drawRose(g, 360 - moveDir, new Color(100,100,100), new Color(200,200,200), 1.0f);
+					
+					g.setPen(new Pen(RED,Pen.SOLID,3));
+					g.drawLine(location.width/2, location.height/2 - radius, location.width/2, location.height/2 + radius);
+					
+					if (gotoDir < 360 && gotoDir > -360) drawThinArrow(g, gotoDir - moveDir, Color.DarkBlue, moveDirColor, 1.0f);
+					if (sunDir < 360 && sunDir > -360) drawSunArrow(g, sunDir - moveDir, YELLOW, 0.75f);					
+				}				
+			}
+		}
+	}
+
+	/**
+	 * draw single arrow 
+	 * @param g handle for drawing
+	 * @param angle angle of arrow
+	 * @param col color of arrow
+	 */
+	private void drawSimpleArrow(Graphics g, float angle, Color col, float scale) {
+		float angleRad;
+		int x, y, centerX = location.width/2, centerY = location.height/2;
+		int arrowLength = java.lang.Math.min(centerX, centerY); 
+
+		angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		x = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad) * scale).intValue();
+		y = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad) * scale).intValue();
+		g.setPen(new Pen(col,Pen.SOLID,3));
+		g.drawLine(centerX,centerY,x,y);
+	}
+	
+	private void drawSunArrow(Graphics g, float angle, Color col, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = location.width/2, centerY = location.height/2;
+		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
+		float halfArrowWidth = arrowLength * 0.08f;
+		float circlePos = arrowLength * 0.7f;
+		int circleRadius = (int)(arrowLength * 0.1f);
+
+		int pointX = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		int pointY = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		int circleX = centerX + new Float(circlePos * java.lang.Math.sin(angleRad)).intValue();
+		int circleY = centerY - new Float(circlePos * java.lang.Math.cos(angleRad)).intValue();
+
+		int[] pointsX = new int[4];
+		int[] pointsY = new int[4];
+
+		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[1] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsY[1] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
+		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
+		pointsX[3] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		pointsY[3] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		
+//		g.setPen(new Pen(col,Pen.SOLID,3));
+//		g.drawLine(centerX,centerY,pointX,pointY);
+		
+		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setBrush(new Brush(col, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 4);
+		g.fillEllipse(circleX - circleRadius, circleY - circleRadius, 2 * circleRadius, 2 * circleRadius);
+	}
+	
+	private void drawThinArrow(Graphics g, float angle, Color col, Color colPoint, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = location.width/2, centerY = location.height/2;
+		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
+		float halfOpeningAngle = (float)(java.lang.Math.PI * 0.03);
+		float sideLineLength = arrowLength * 0.75f;
+		
+		int[] pointsX = new int[4];
+		int[] pointsY = new int[4];
+
+		pointsX[0] = centerX + new Float(sideLineLength * java.lang.Math.sin(angleRad - halfOpeningAngle)).intValue();
+		pointsY[0] = centerY - new Float(sideLineLength * java.lang.Math.cos(angleRad - halfOpeningAngle)).intValue();
+		pointsX[1] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[1] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[2] = centerX + new Float(sideLineLength * java.lang.Math.sin(angleRad + halfOpeningAngle)).intValue();
+		pointsY[2] = centerY - new Float(sideLineLength * java.lang.Math.cos(angleRad + halfOpeningAngle)).intValue();
+		pointsX[3] = centerX;
+		pointsY[3] = centerY;
+		
+		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setBrush(new Brush(col, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 4);
+		if (colPoint != null) {
+			g.setBrush(new Brush(colPoint, Brush.SOLID));
+			g.fillPolygon(pointsX, pointsY, 3);			
+		}
+	}
+	
+	private void drawDoubleArrow(Graphics g, float angle, Color colFront, Color colRear, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = location.width/2, centerY = location.height/2;
+		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
+		float halfArrowWidth = arrowLength * 0.1f;
+		
+		int[] pointsX = new int[3];
+		int[] pointsY = new int[3];
+
+		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[1] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsY[1] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		
+		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setBrush(new Brush(colFront, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 3);
+		
+		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
+		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
+		
+		g.setBrush(new Brush(colRear, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 3);
+	}
+	
+	private void drawRose(Graphics g, float angle, Color colFront, Color colRear, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = location.width/2, centerY = location.height/2;
+		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
+		float halfArrowWidth = arrowLength * 0.12f;
+		
+		int[] pointsX = new int[8];
+		int[] pointsY = new int[8];
+
+		pointsX[0] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 4.0)).intValue();
+		pointsY[0] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 4.0)).intValue();
+		pointsX[1] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[1] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 4.0)).intValue();
+		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 4.0)).intValue();
+		pointsX[3] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsY[3] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsX[4] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + 3.0 * java.lang.Math.PI / 4.0)).intValue();
+		pointsY[4] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + 3.0 * java.lang.Math.PI / 4.0)).intValue();
+		pointsX[5] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
+		pointsY[5] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
+		pointsX[6] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - 3.0 * java.lang.Math.PI / 4.0)).intValue();
+		pointsY[6] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - 3.0 * java.lang.Math.PI / 4.0)).intValue();
+		pointsX[7] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		pointsY[7] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		
+		g.setPen(new Pen(colRear,Pen.SOLID,1));
+		g.setBrush(new Brush(colRear, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 8);
+		
+		g.setBrush(new Brush(colFront, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 3);
+	}
+	
+	private void drawThickArrow(Graphics g, float angle, Color col, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = location.width/2, centerY = location.height/2;
+		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
+		float halfArrowWidth = arrowLength * 0.1f;
+		
+		int[] pointsX = new int[4];
+		int[] pointsY = new int[4];
+
+		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[1] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsY[1] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
+		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
+		pointsX[3] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		pointsY[3] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		
+		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setBrush(new Brush(col, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 4);
+	}
+	
+	public void setNorthCentered(boolean nc) {
+		northCentered = nc;
+		if (northCentered != Global.getPref().northCenteredGoto) {
+			Global.getPref().northCenteredGoto = northCentered;
+			Global.getPref().savePreferences();
+		}
+		refresh();
+	}
+	
+	public boolean isNorthCentered() {
+		return northCentered;
+	}
+}

Copied: trunk/src/CacheWolf/map/Map.java (from rev 878, trunk/src/CacheWolf/Map.java)
===================================================================
--- trunk/src/CacheWolf/Map.java	2007-09-04 23:05:39 UTC (rev 878)
+++ trunk/src/CacheWolf/map/Map.java	2007-09-05 02:06:44 UTC (rev 880)
@@ -0,0 +1,500 @@
+package CacheWolf.navi;
+
+import ewe.util.*;
+import ewe.io.*;
+import ewe.filechooser.*;
+import ewe.sys.*;
+import ewe.ui.*;
+import ewe.graphics.*;
+import ewe.fx.*;
+
+import CacheWolf.CWPoint;
+import CacheWolf.Common;
+import CacheWolf.CoordsScreen;
+import CacheWolf.Global;
+import CacheWolf.InfoBox;
+import CacheWolf.Matrix;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+
+import com.stevesoft.ewe_pat.*;
+
+/**
+ *	This class is the main class for mapping,
+ *	 (moving map, georeferencing maps, etc)
+ *	in CacheWolf.
+ *	It also provides a class for importing maps
+ *	This class id=4100
+ */
+public class Map extends Form {
+	Preferences pref;
+	String mapsPath = new String();
+	String thisMap = new String();
+	public String selectedMap = new String();
+	CellPanel infPanel;
+	mLabel infLabel = new mLabel("                          ");
+	Vector GCPs = new Vector();
+	MapInfoObject wfl = new MapInfoObject();
+	mButton infButton;
+	ScrollBarPanel scp;
+	AniImage mapImg;
+	int imageWidth, imageHeight = 0;
+
+	/**
+	 *	This constructor should be used when importing maps
+	 */
+	public Map(Preferences pref){
+		this.pref = pref;
+		mapsPath = pref.getMapManuallySavePath(true)+"/"; //File.getProgramDirectory() + "/maps/";
+	}
+
+	/**
+	 *	When a user clicks on the map and more than three ground control points exist
+	 *	then the calculated coordinate based on the affine transformation is displayed in the
+	 *	info panel below the map.
+	 *	It helps to identify how good the georeferencing works based on the set GCPs.
+	 */
+	public void updatePosition(int x, int y){
+		if(GCPs.size()>=3  || (wfl.affine[4] > 0 && wfl.affine[5] > 0)){
+			double x_ = 0;
+			double y_ = 0;
+			x_ = wfl.affine[0]*x + wfl.affine[2]*y + wfl.affine[4];
+			y_ = wfl.affine[1]*x + wfl.affine[3]*y + wfl.affine[5];
+			CWPoint p = new CWPoint(x_ , y_);
+			infLabel.setText("--> " + p.getLatDeg(CWPoint.DMS) + " " +p.getLatMin(CWPoint.DMM) + " / " + p.getLonDeg(CWPoint.DMS) + " " + p.getLonMin(CWPoint.DMM));
+		}
+	}
+
+	/**
+	 *	This is the correct constructor for georeferencing maps.
+	 */
+	public Map(Preferences pref, String mapToLoad, boolean worldfileexists){
+		this.pref = pref;
+		this.title = MyLocale.getMsg(4106,"Calibrate map:") + " " + mapToLoad;
+		this.resizable = true;
+		this.moveable = true;
+		//this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
+		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
+		thisMap = mapToLoad;
+		mapsPath = pref.getMapManuallySavePath(true)+"/"; //File.getProgramDirectory() + "/maps/"; // TDO veraltet
+		try {
+			wfl.loadwfl(mapsPath, thisMap);
+		}catch(FileNotFoundException ex){
+			//	Vm.debug("Cannot load world file!");
+		}catch (IOException ex) { // is thrown if lat/lon out of range
+			MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, "Error"), ex.getMessage(), MessageBox.OKB);
+			tmpMB.execute();
+			Vm.debug("Cannot load world file!");
+		}
+		mapInteractivePanel pane = new mapInteractivePanel(this);
+		scp = new ScrollBarPanel(pane);
+		Image img = new Image(Common.getImageName(mapsPath + thisMap));
+		PixelBuffer pB = new PixelBuffer(img);
+		//pB = pB.scale((int)(pref.myAppWidth*0.98),(int)(pref.myAppHeight*0.98));
+		mapImg = new AniImage(pB.toDrawableImage());
+		pane.addImage(mapImg);
+		scp.setPreferredSize(mapImg.getWidth(),mapImg.getHeight());
+		imageWidth = mapImg.getWidth();
+		imageHeight = mapImg.getHeight();
+		this.addLast(scp.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
+		infPanel = new CellPanel();
+		infPanel.addNext(infLabel,CellConstants.STRETCH, CellConstants.FILL);
+		infButton = new mButton(MyLocale.getMsg(4107,"Done!"));
+		infPanel.addLast(infButton,CellConstants.DONTSTRETCH, CellConstants.FILL);
+		this.addLast(infPanel, CellConstants.DONTSTRETCH, CellConstants.FILL);
+		//scp.repaintNow();
+		//this.repaintNow();
+	}
+
+	/**
+	 *	Add a ground control point to the list
+	 *	If the list is longer than 3 GCPs these will be evaluated
+	 *	to obtain the required parameters for the affine
+	 *	transformation.
+	 */
+	public void addGCP(GCPoint GCP){
+		if (GCP.latDec>90 || GCP.latDec<-90 || GCP.lonDec>360 || GCP.lonDec<-180) throw new IllegalArgumentException("lat/lon out of range: "+GCP.toString());
+		GCPs.add(GCP);
+		if(GCPs.size() >= 3){
+			evalGCP();
+		}
+	}
+
+	/**
+	 *	Returns the number of ground control points in the list. (Vector GCPs)
+	 */
+	public int getGCPCount(){
+		return GCPs.size();
+	}
+
+	/**
+	 *	Actuall method to evaluate the ground control points and identify the parameters
+	 *	for thew affine transformation
+	 */
+	private void evalGCP(){
+		//N 48 16.000 E 11 32.000
+		//N 48 16.000 E 11 50.000
+		//N 48 9.000 E 11 32.000
+		GCPoint gcp = new GCPoint();
+		//Calculate parameters for latitutde affine transformation (affine 0,2,4)
+		Matrix X = new Matrix(GCPs.size(),3);
+		Matrix trg = new Matrix(GCPs.size(),1);
+		for(int i = 0; i < GCPs.size();i++){
+			gcp = (GCPoint)GCPs.get(i);
+			X.matrix[i][0] = 1; X.matrix[i][1] = gcp.bitMapX; X.matrix[i][2] = gcp.bitMapY;
+			trg.matrix[i][0] = gcp.latDec;
+		}
+		Matrix Xtran = new Matrix(X);
+		Xtran.Transpose();
+		Matrix XtranX = new Matrix(Xtran);
+		XtranX.Multiply(X);
+		Matrix XtranXinv = new Matrix(XtranX);
+		XtranXinv.Inverse();
+		Matrix beta = new Matrix(XtranXinv);
+		beta.Multiply(Xtran);
+		beta.Multiply(trg);
+		wfl.affine[0] = beta.matrix[1][0];
+		wfl.affine[2] = beta.matrix[2][0];
+		wfl.affine[4] = beta.matrix[0][0];
+
+		//Calculate parameters for longitude affine transformation (affine 1,3,5)
+		X = new Matrix(GCPs.size(),3);
+		trg = new Matrix(GCPs.size(),1);
+		for(int i = 0; i < GCPs.size();i++){
+			gcp = (GCPoint)GCPs.get(i);
+			X.matrix[i][0] = 1;
+			X.matrix[i][1] = gcp.bitMapX;
+			X.matrix[i][2] = gcp.bitMapY;
+			trg.matrix[i][0] = gcp.lonDec;
+		}
+		Xtran = new Matrix(X);
+		Xtran.Transpose();
+		XtranX = new Matrix(Xtran);
+		XtranX.Multiply(X);
+		XtranXinv = new Matrix(XtranX);
+		XtranXinv.Inverse();
+		beta = new Matrix(XtranXinv);
+		beta.Multiply(Xtran);
+		beta.Multiply(trg);
+		wfl.affine[1] = beta.matrix[1][0];
+		wfl.affine[3] = beta.matrix[2][0];
+		wfl.affine[5] = beta.matrix[0][0];
+		double x_ = 0;
+		double y_ = 0;
+		x_ = wfl.affine[0]*imageWidth+ wfl.affine[2]*imageHeight + wfl.affine[4];
+		y_ = wfl.affine[1]*imageWidth + wfl.affine[3]*imageHeight + wfl.affine[5];
+		CWPoint p = new CWPoint(x_ , y_);
+		wfl.lowlon = p.lonDec;
+		wfl.lowlat = p.latDec;
+		//Vm.debug("A B C" + affine[0] + " " + affine[2] + " " + affine[4]);
+		//Vm.debug("D E F" + affine[1] + " " + affine[3] + " " + affine[5]);
+	}
+
+	/**
+	 *	Method to copy ("import") a png based map
+	 *	into the maps folder in the CacheWolf base directory.
+	 *	
+	 *	If the maps directory does not exist it will create it.
+	 *	If it finds .map files it will assume these are oziexplorer calibration files.
+	 *	It will use these files to automatically georeference the files during import.
+	 */
+	public int importMap(){
+		String rawFileName = new String();
+		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir);
+		fc.addMask("*.png,*.gif,*.bmp,*.jpg");
+		fc.setTitle((String)MyLocale.getMsg(4100,"Select Directory:"));
+		int tmp = fc.execute() ; 
+		if(tmp != FileChooser.IDYES) return Form.IDCANCEL;
+		File inDir = fc.getChosenFile();
+		File mapFile;
+		InfoBox inf = new InfoBox("Info", MyLocale.getMsg(4109,"Loading maps...            \n"), InfoBox.PROGRESS_WITH_WARNINGS, false); 
+		inf.setPreferredSize(220, 300);
+		inf.setInfoHeight(100);
+		inf.relayout(false);
+		Vm.showWait(this, true);
+		inf.exec();
+
+		//User selected a map, but maybe there are more png(s)
+		//copy all of them!
+		//at the same time try to find associated .map files!
+		//These are georeference files targeted for OziExplorer.
+		//So lets check if we have more than 1 png file:
+		String line = new String();
+		InputStream in = null;
+		OutputStream out = null;
+		FileReader inMap;
+		byte[] buf;
+		int len;
+		String[] parts;
+		String [] files = inDir.listMultiple("*.png,*.jpg,*.gif,*.bmp", File.LIST_FILES_ONLY);
+
+		String currfile = null;
+		String curInFullPath;
+		String curOutFullPath;
+		int num = files.length;
+		for(int i =  num -1 ; i >= 0;i--){
+			currfile = (String) files[i];
+			inf.setInfo(MyLocale.getMsg(4110,"Loading: ")+ "\n" + currfile + "\n("+(num-i)+"/"+num+")");
+			//Copy the file
+			//Vm.debug("Copy: " + inDir.getFullPath() + "/" +files[i]);
+			//Vm.debug("to: " + mapsPath + files[i]);
+			curInFullPath = inDir.getFullPath() + "/" +currfile;
+			curOutFullPath = mapsPath + currfile;
+			boolean imageerror = false;
+			try {
+				in = new FileInputStream(curInFullPath);
+				buf = new byte[1024*10];
+				boolean first = true;
+				ByteArray header = new ByteArray(buf);
+				while ((len = in.read(buf)) > 0) {
+					if (first) {
+						first = false;
+						header.copyFrom(buf, 0, len);
+						ImageInfo tmpII = Image.getImageInfo(header,null);
+						imageWidth = tmpII.width;
+						imageHeight = tmpII.height;
+						out = new FileOutputStream(curOutFullPath); // only create outfile if geImageInfo didn't throw an exception so do it only here not directly after opening input stream
+					}
+					out.write(buf, 0, len);
+				}
+			} catch(IOException ex){
+				imageerror = true;
+				inf.addWarning("\nIO-Error while copying image from: " + curInFullPath + " to: " + curOutFullPath + " error: " + ex.getMessage());
+			} catch (IllegalArgumentException e) { // thrown from Image.getImageInfo when it could not interprete the header (e.g. bmp with 32 bits per pixel)
+				imageerror = true;
+				inf.addWarning("\nError: could not decode image: " + curInFullPath + " - image not copied");
+			} finally {
+				try {
+					if (in != null) in.close();
+					if (out  != null) out.close(); 
+				} catch (Throwable e) {}
+			}
+			//Check for a .map file
+			rawFileName = currfile.substring(0, currfile.lastIndexOf("."));
+			mapFile = new File(inDir.getFullPath() + "/" + rawFileName + ".map");
+			if(!imageerror && mapFile.exists()){
+				GCPoint gcp1 = new GCPoint();
+				GCPoint gcp2 = new GCPoint();
+				GCPoint gcp3 = new GCPoint();
+				GCPoint gcp4 = new GCPoint();
+				GCPoint gcpG = new GCPoint();
+				//Vm.debug("Found file: " + inDir.getFullPath() + "/" + rawFileName + ".map");
+				try {
+					inMap = new FileReader(inDir.getFullPath() + "/" + rawFileName + ".map");
+					while((line = inMap.readLine()) != null){
+						if(line.equals("MMPNUM,4")){
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp1.bitMapX = Convert.toInt(parts[2]);
+							gcp1.bitMapY = Convert.toInt(parts[3]);
+							if(gcp1.bitMapX == 0) gcp1.bitMapX = 1;
+							if(gcp1.bitMapY == 0) gcp1.bitMapY = 1;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp2.bitMapX = Convert.toInt(parts[2]);
+							gcp2.bitMapY = Convert.toInt(parts[3]);
+							if(gcp2.bitMapX == 0) gcp2.bitMapX = 1;
+							if(gcp2.bitMapY == 0) gcp2.bitMapY = 1;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp3.bitMapX = Convert.toInt(parts[2]);
+							gcp3.bitMapY = Convert.toInt(parts[3]);
+							if(gcp3.bitMapX == 0) gcp3.bitMapX = 1;
+							if(gcp3.bitMapY == 0) gcp3.bitMapY = 1;
+							//imageWidth = gcp3.bitMapX;
+							//imageHeight = gcp3.bitMapY;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp4.bitMapX = Convert.toInt(parts[2]);
+							gcp4.bitMapY = Convert.toInt(parts[3]);
+							if(gcp4.bitMapX == 0) gcp4.bitMapX = 1;
+							if(gcp4.bitMapY == 0) gcp4.bitMapY = 1;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(pref.digSeparator.equals(",")) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp1.bitMapX;
+							gcpG.bitMapY = gcp1.bitMapY;
+							addGCP(gcpG);
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(pref.digSeparator.equals(",")) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp2.bitMapX;
+							gcpG.bitMapY = gcp2.bitMapY;
+							addGCP(gcpG);
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(pref.digSeparator.equals(",")) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp3.bitMapX;
+							gcpG.bitMapY = gcp3.bitMapY;
+							addGCP(gcpG);
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(pref.digSeparator.equals(",")) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp4.bitMapX;
+							gcpG.bitMapY = gcp4.bitMapY;
+							addGCP(gcpG);
+							/* already read from image file itself
+							// get dimensions of image
+							while ( (line = inMap.readLine()) != null){
+								if (line.startsWith("IWH")){
+									parts = mString.split(line, ',');
+									imageWidth = Convert.toInt(parts[2]);
+									imageHeight = Convert.toInt(parts[3]);
+								}
+							}
+							 */
+							evalGCP();
+							//Vm.debug("Saving .map file to: " + mapsPath + "/" + rawFileName + ".wfl");
+							wfl.saveWFL(mapsPath, rawFileName);
+							GCPs.clear();
+						} // if
+
+					} // while
+					if (inMap != null)	inMap.close();
+				} catch(IllegalArgumentException ex){ // is thrown from Convert.toDouble and saveWFL if affine[0-5]==0 NumberFormatException is a subclass of IllegalArgumentExepction
+					inf.addWarning("\nError while importing .map-file: "+ex.getMessage());
+				} catch(IOException ex){
+					inf.addWarning("\nIO-Error while reading or writing calibration file\n" + ex.getMessage());
+				} 
+			} else { // if map file.exists
+				if (!imageerror) inf.addWarning("\nNo calibration file found for: " + currfile + " - you can calibrate it manually");
+			}
+		} // for file
+		Vm.showWait(this, false);
+		inf.addText("\ndone.");
+		inf.addOkButton();
+		//inf.addOkButton(); doesn't work
+		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
+		return Form.IDOK;
+	}
+
+
+
+	/**
+	 *	Handles button pressed event
+	 *	When the button is pressed a mapname.wfl file is saved in the
+	 *	maps directory.
+	 */
+	public void onEvent(Event ev){
+
+		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+			// display coords in another format
+			if (ev.target == infButton){
+				boolean retry = true;
+				while (retry == true) {
+					try {
+						retry = false;
+						wfl.saveWFL(mapsPath, thisMap);
+						if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
+					} catch (IOException e) {
+						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(321, "Error writing file ") + e.getMessage()+MyLocale.getMsg(324, " - retry?"), MessageBox.YESB | MessageBox.NOB);
+						if (tmpMB.execute() == MessageBox.IDYES) retry = true;
+					}catch (IllegalArgumentException e) {
+						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(325, "Map not calibrated")+MyLocale.getMsg(324, " - retry?"), MessageBox.YESB | MessageBox.NOB);
+						if (tmpMB.execute() == MessageBox.IDYES) { retry = true; break; }
+					}
+				}
+				if (!retry) close(0);
+			}
+		}
+	}
+}
+
+/**
+ *	Class that creates a panel and loads a map.
+ *	It catches click events to display a form where the user may enter the required ccordinates
+ *	The data is stored as a ground control point in the calling class: Map
+ */
+class mapInteractivePanel extends InteractivePanel{
+	Map f;
+	Locale l = Vm.getLocale();
+	LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
+	public mapInteractivePanel(Map f){
+		this.f = f;
+	}
+
+	/**
+	 *	Event handler to catch clicks on the map
+	 */
+	public void imageClicked(AniImage which, Point pos){
+		//Vm.debug("X = " +pos.x + " Y = " + pos.y);
+		Image img = new Image(31, 31);
+		Graphics g = new Graphics(img);
+		g.setColor(new Color(0,0,0));
+		g.fillRect(0,0,31,31);
+		g.setColor(new Color(255,0,0));
+		g.drawLine(0,16,31,16);
+		g.drawLine(16,0,16,31);
+		AniImage aImg = new AniImage(img);
+		aImg.setLocation(pos.x-16,pos.y-16);
+		aImg.transparentColor = new Color(0,0,0);
+		//aImg.properties = mImage.IsNotHot;
+		aImg.properties = mImage.AlwaysOnTop;
+		this.addImage(aImg);
+		g.free();
+		this.repaintNow();
+		f.updatePosition(pos.x, pos.y);
+
+		CoordsScreen cooS = new CoordsScreen(); // (String)lr.get(4108,"Coordinates:"), (String)lr.get(4108,"Coordinates:"), InfoBox.INPUT);
+		if (cooS.execute()==CoordsScreen.IDOK) {
+			GCPoint gcp = new GCPoint(cooS.getCoords());
+			gcp.bitMapX = pos.x;
+			gcp.bitMapY = pos.y;
+			f.addGCP(gcp); // throws IllegalArgumentException in case of lon/lat out of range
+//			} catch (IllegalArgumentException e) { // NumberFormatException is a subclass of IllagalArgumentException
+//			coosInputFormat();
+//			this.removeImage(aImg);
+		} else this.removeImage(aImg); // CANCEL pressed
+	}
+
+	private void coosInputFormat () {
+		MessageBox tmpMB = new MessageBox((String)lr.get(312,"Error"), (String)lr.get(4111,"Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"), MessageBox.OKB);
+		tmpMB.exec();
+
+	}
+}
+/**
+ *	Class based on CWPoint but intended to handle bitmap x and y
+ *	Used for georeferencing bitmaps.
+ */
+class GCPoint extends CWPoint{
+	public int bitMapX = 0;
+	public int bitMapY = 0;
+
+	public GCPoint(){
+	}
+
+	public GCPoint(CWPoint p) {
+		super(p);
+	}
+
+	public GCPoint(double lat, double lon){
+		this.latDec = lat;
+		this.lonDec = lon;
+		this.utmValid = false;
+	}
+}
\ No newline at end of file

Copied: trunk/src/CacheWolf/map/MapDetailForm.java (from rev 878, trunk/src/CacheWolf/MapDetailForm.java)
===================================================================
--- trunk/src/CacheWolf/MapDetailForm.java	2007-09-04 23:05:39 UTC (rev 878)
+++ trunk/src/CacheWolf/map/MapDetailForm.java	2007-09-05 02:06:44 UTC (rev 880)
@@ -0,0 +1,65 @@
+package CacheWolf.navi;
+import CacheWolf.ImageDetailForm;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+import CacheWolf.Profile;
+import ewe.graphics.*;
+import ewe.sys.*;
+import ewe.fx.*;
+import ewe.ui.*;
+import ewe.util.*;
+
+/**
+ *	Class to display map images in different zoom levels.
+ *	Extends ImageDetailForm that handles the resizing to screen
+ *	size. The extension in this class handles the switching between
+ *	different (map) images.
+ */
+public class MapDetailForm extends ImageDetailForm {
+ /* // it's obsolete since we have a well working moving map 
+	mButton btSwitch;
+	String cache;
+	String imgLoc = new String();
+	int status = 0;
+	Profile profile;
+	
+	public MapDetailForm(String cacheName, Preferences p, Profile prof){
+		profile=prof;  // keep ref for later use
+		cache=cacheName;
+		imgLoc = prof.dataDir + cacheName + "_map.gif";
+		scp = new ScrollBarPanel(ipp);
+		setUp(imgLoc, p);
+		this.title = "Maps";
+		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
+		this.addLast(scp.getScrollablePanel(), this.STRETCH, this.FILL);
+		CellPanel butPanel = new CellPanel();
+		btSwitch = new mButton("Zoom");
+		butPanel.addLast(btSwitch);
+		this.addLast(butPanel, this.HSTRETCH, this.FILL);
+	}
+
+	public void onEvent(Event ev){
+		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+			if (ev.target == btSwitch){
+				ipp.removeImage(ai);
+				imgLoc = profile.dataDir + cache;
+				if(status == 0) {
+					imgLoc = imgLoc + "_map_2.gif";
+					status = 1;
+				} else {
+					imgLoc = imgLoc + "_map.gif";
+					status = 0;
+				}
+				try {
+					setUp(imgLoc, pref);
+					this.repaintNow();
+				} catch (IllegalArgumentException e) {
+					MessageBox tmp = new MessageBox(MyLocale.getMsg(321,"Fehler"), MyLocale.getMsg(322,"Kann Bild/Karte nicht finden")+": "+imgLoc, MessageBox.OKB); // @todo: language support
+					tmp.exec();
+				}
+			}
+		}
+	}
+	*/
+}
+

Added: trunk/src/CacheWolf/map/MapImage.java
===================================================================
--- trunk/src/CacheWolf/map/MapImage.java	2007-09-05 01:58:25 UTC (rev 879)
+++ trunk/src/CacheWolf/map/MapImage.java	2007-09-05 02:06:44 UTC (rev 880)
@@ -0,0 +1,78 @@
+package CacheWolf.navi;
+import ewe.fx.*;
+import ewe.graphics.*;
+/** 
+ * class that can be used with any x and any y
+ * it will save taht location and make itself automatically
+ * invisible if it is not on the screen. Call setscreensize to
+ * set the screensize
+ * @author pfeffer
+ *
+ */
+public class MapImage extends AniImage {
+	public Point locAlways = new Point(); // contains the theoretical location even if it the location is out of the screen. If the image is on the screen, it contains the same as location
+	public static Dimension screenDim;
+	boolean hidden = false;
+	public MapImage() {
+		super();
+		if (screenDim == null) screenDim = new Dimension(0,0);
+	}
+
+	public MapImage(String f) {
+		super(f);
+		if (screenDim == null) screenDim = new Dimension(0,0);
+	}
+
+	public MapImage(mImage im) {
+		super(im);
+		if (screenDim == null) screenDim = new Dimension(0,0);
+	}
+
+	public static void setScreenSize(int w, int h) {
+		screenDim = new Dimension(w, h);
+	}
+
+	public void setImage(Image im, Color c) {
+		super.setImage(im, c);
+		if (screenDim == null) screenDim = new Dimension(0,0);
+	}
+
+	public void setLocation (int x, int y) {
+		locAlways.x = x;
+		locAlways.y = y;
+		if (!hidden && isOnScreen()) { 
+			super.setLocation(x, y);
+			properties &= ~AniImage.IsInvisible;
+		} else {
+			properties |= AniImage.IsInvisible;
+			super.move(0, 0);
+		}
+	}
+
+	public void move (int x, int y) {
+		locAlways.x = x;
+		locAlways.y = y;
+		if (!hidden && isOnScreen()) { 
+			super.move(x, y);
+			properties &= ~AniImage.IsInvisible;
+		} else {
+			properties |= AniImage.IsInvisible;
+			super.move(0, 0);
+		}
+	}
+
+	public boolean isOnScreen() { 
+		if ( (locAlways.x + location.width > 0 && locAlways.x < screenDim.width) && 
+				(locAlways.y + location.height > 0 && locAlways.y < screenDim.height) ) return true;
+		else return false;
+	}
+
+	public void hide() {
+		hidden = true;
+		properties |= AniImage.IsInvisible;
+	}
+	public void unhide() {
+		hidden = false;
+		move(locAlways.x, locAlways.y);
+	}
+}

Copied: trunk/src/CacheWolf/map/MapInfoObject.java (from rev 878, trunk/src/CacheWolf/MapInfoObject.java)
===================================================================
--- trunk/src/CacheWolf/MapInfoObject.java	2007-09-04 23:05:39 UTC (rev 878)
+++ trunk/src/CacheWolf/map/MapInfoObject.java	2007-09-05 02:06:44 UTC (rev 880)
@@ -0,0 +1,334 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.Common;
+import CacheWolf.MyLocale;
+import ewe.fx.Point;
+import ewe.io.BufferedWriter;
+import ewe.io.FileReader;
+import ewe.io.FileWriter;
+import ewe.io.FilenameFilter;
+import ewe.io.File;
+import ewe.io.IOException;
+import ewe.io.PrintWriter;
+import ewe.sys.*;
+
+/**
+ * @author r
+ *
+ */
+public class MapInfoObject{
+	//World file:
+	// x scale
+	// y scale
+	// x rotation
+	// y rotation
+	// lon of upper left corner of image
+	// lat of upper left corner of image
+	// lon of lower right corner of image
+	// lat of lower right corner of image
+	public double[] affine = {0,0,0,0,0,0};
+	public double lowlat = 0;
+	public double lowlon = 0;
+	public double transLatX, transLatY, transLonX, transLonY; // this are needed for the inervers calculation from lat/lon to x/y
+	public CWPoint center = new CWPoint();
+	public float sizeKm = 0; // diagonale
+	public float scale; // in meters per pixel, note: it is assumed that this scale identifying the scale of the map, automatically adjusted when zooming
+	public float zoomFactor = 1; // if the image is zoomed, direct after laoding always 1
+	public Point shift = new Point (0,0);
+	public CWPoint OrigUpperLeft; // this is only valid after zooming 
+	public float rotationRad; // contains the rotation of the map == north direction in rad
+	public String fileNameWFL = new String();
+	public String fileName = new String();
+	public String mapName = new String();
+	//private Character digSep = new Character(' ');
+	static private String digSep = MyLocale.getDigSeparator();
+	/*
+	 * loads an .wfl file
+	 * throws FileNotFoundException and IOException (data out of range)
+	 * @maps Path to .wfl file
+	 * @thisMap filename of .wfl file without ".wfl"
+	 * @DigSep "." or ","
+	 */	
+
+	public MapInfoObject() {
+		//double testA = Convert.toDouble("1,50") + Convert.toDouble("3,00");
+		//if(testA == 4.5) digSep = ","; else digSep = ".";
+	}
+	
+	public MapInfoObject(MapInfoObject map) {
+		mapName = map.mapName;
+		affine[0] = map.affine[0];
+		affine[1] = map.affine[1];
+		affine[2] = map.affine[2];
+		affine[3] = map.affine[3];
+		affine[4] = map.affine[4];
+		affine[5] = map.affine[5];
+		lowlat = map.lowlat;
+		lowlon = map.lowlon;
+		OrigUpperLeft = new CWPoint (map.OrigUpperLeft);
+		zoomFactor = map.zoomFactor;
+		shift.set(map.shift);
+		fileName = new String(map.fileName);
+		fileNameWFL = new String(map.fileNameWFL);
+		mapName = new String(mapName);
+		doCalculations();
+	}
+
+	/*
+	 * constructes an MapInfoObject without an associated map
+	 * but with 1 Pixel = scale meters
+	 */
+	public MapInfoObject(double scalei, double lat) {
+		mapName="empty 1 Pixel = "+scalei+"meters";
+		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		double pixel2deg = meters2deg * scalei;
+		affine[0]=0; //x2lat
+		affine[1]=pixel2deg / java.lang.Math.cos(lat); //x2lon
+		affine[2]=-pixel2deg; //y2lat
+		affine[3]=0; //y2lon
+		affine[4]=1; //top
+		affine[5]=0; //left
+		lowlat = 0; //buttom
+		lowlon = 1; //right
+		OrigUpperLeft = new CWPoint(affine[4], affine[5]);
+		doCalculations();
+	}
+
+	/**
+	 * constructs an MapInfoObject with an associated map
+	 * with 1 Pixel = scale meters, center and width, hight in pixels
+	 * @param name path and filename of .wfl file without the extension (it is needed because the image will be searched in the same directory)
+	 */
+	public MapInfoObject(double scalei, CWPoint center, int width, int hight, String name) {
+		mapName = name+".wfl";
+
+		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		double pixel2deg = meters2deg * scalei;
+		double pixel2deghorizontal = pixel2deg / java.lang.Math.cos(center.latDec*java.lang.Math.PI / 180); 
+		affine[0]=0; //x2lat
+		affine[1]=pixel2deghorizontal; //x2lon
+		affine[2]=-pixel2deg; //y2lat
+		affine[3]=0; //y2lon
+		affine[4]=center.latDec + hight / 2 *pixel2deg; //top
+		affine[5]=center.lonDec - width / 2 *pixel2deghorizontal; //left
+		lowlat = center.latDec - hight / 2 *pixel2deg; //buttom
+		lowlon = center.lonDec + width / 2 *pixel2deghorizontal; //right
+		fileNameWFL = name;
+		OrigUpperLeft = new CWPoint(affine[4], affine[5]);
+		doCalculations();
+	}
+	
+
+	/** 
+	 * @return the filename of the associated map image, "" if no file is associated, null if associated file could not be found
+	 */
+	public String getImageFilename() {
+		if (fileName == null || fileName.length() > 0) return fileName;
+		if (fileNameWFL.length() == 0) return "";
+		String n = fileNameWFL.substring(0, fileNameWFL.lastIndexOf("."));
+		return Common.getImageName(n);
+	}
+	
+	/**
+	 * Method to load a .wfl-file
+	 * @throws IOException when there was a problem reading .wfl-file
+	 * @throws IOException when lat/lon were out of range
+	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
+	 */
+	public void loadwfl(String mapsPath, String thisMap) throws IOException, ArithmeticException {
+		FileReader in = new FileReader(mapsPath + thisMap + ".wfl");
+		String line = new String();
+		try {
+			for(int i = 0; i<6;i++){
+				line = in.readLine();
+				if (digSep.equals(",")) {line = line.replace('.',','); } // digSep == ',' musss genau so lauten. digsep.equals(',') wirft eine Exception auf PocketPC, digsep.equals(",") wirft keine Exception, funktioniert aber nicht! 
+				else line = line.replace(',','.');
+				affine[i] = Convert.toDouble(line);
+			}
+			line = in.readLine();
+			if (digSep.equals(",")) {line = line.replace('.',','); }
+			else line = line.replace(',','.');
+			lowlat = Convert.toDouble(line);
+			line = in.readLine();
+			if (digSep.equals(",")) {line = line.replace('.',','); }
+			else line = line.replace(',','.');
+			lowlon = Convert.toDouble(line);
+
+			fileNameWFL = mapsPath + thisMap + ".wfl";
+			fileName = ""; //mapsPath + thisMap + ".png";
+			mapName = thisMap;
+			in.close();
+			if(affine[4] > 90 || affine[4] < -90 || affine[5] < -180 || affine[5] > 360 ||
+					lowlat > 90 || lowlat < -90 || lowlon > 360 || lowlon < -180 ) {
+				affine[0] = 0; affine[1] = 0; affine[2] = 0; affine[3] = 0; affine[4] = 0; affine[5] = 0;
+				lowlat = 0; lowlon = 0;
+				throw (new IOException("Lat/Lon out of range while reading "+mapsPath + thisMap + ".wfl"));
+			}
+		} catch (NullPointerException e) { // in.readline liefert null zur?ck, wenn keine Daten mehr vorhanden sind
+			throw (new IOException("not enough lines in file "+mapsPath + thisMap + ".wfl"));
+		}
+		OrigUpperLeft = new CWPoint(affine[4], affine[5]);
+		doCalculations();
+	}
+
+	/**
+	 * calculates center, diagonal size of the map and inverse to affine transformation
+	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
+	 */
+
+	private void doCalculations() throws ArithmeticException {
+		try {
+			center.set((lowlat + affine[4])/2,(lowlon + affine[5])/2);
+			sizeKm = java.lang.Math.abs((float)center.getDistance(lowlat, lowlon)) *2;
+
+			//calculate reverse affine
+			double nenner=(-affine[1]*affine[2]+affine[0]*affine[3]);
+			transLatX = affine[3]/nenner; // nenner == 0 cannot happen as long als affine is correct
+			transLonX = -affine[2]/nenner;
+			transLatY = -affine[1]/nenner;
+			transLonY = affine[0]/nenner;
+
+			// calculate north direction
+			float scaleXpixels = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLonX,2)+java.lang.Math.pow(transLonY,2));
+			//	float scaleY = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLatX,2)+java.lang.Math.pow(transLatY,2));
+			float rotationX2x=(float)transLonX*scaleXpixels;
+			float rotationX2y=(float)transLonY*scaleXpixels;
+			//rotationY2y=-(float)transLatY*scaleY; // lat -> y = -, y -> y = +
+			//rotationY2x=-(float)transLatX*scaleY; // uncomment an make it a field of MapInfoObject if you need translation from x to x rotated
+			rotationRad = (float)java.lang.Math.atan(rotationX2y);
+			if (rotationX2x < 0) rotationRad = (float)java.lang.Math.PI - rotationRad;
+			// calculate scale in meters per pixel
+			double metersPerLat = 1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0));
+			scale = (float) java.lang.Math.abs((affine[2] * metersPerLat)); 
+		} catch (ArithmeticException ex) { throw new ArithmeticException("Not allowed values in affine\n (matrix cannot be inverted)\n in file \n" + fileNameWFL); }
+	}
+
+
+	/**
+	 *	Method to save a world file (.wfl)
+	 * @param mapsPath without "/" at the end
+	 * @param mapFileName without file extension
+	 * @throws IOException when there was a problem writing .wfl-file
+	 * @throws IllegalArgumentException when affine[x] for all x == 0 ("map not calibrated").
+	 */
+	public void saveWFL(String mapsPath, String mapFileName) throws IOException, IllegalArgumentException {
+		if (affine[0]==0 && affine[1]==0 && affine[2]==0 && affine[3]==0 && 
+				affine[4]==0 && affine[5]==0 ) throw (new IllegalArgumentException("map not calibrated"));
+		PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(mapsPath + "/" + mapFileName + ".wfl")));
+		String towrite=Convert.toString(affine[0])+"\n" +
+		Convert.toString(affine[1])+"\n" +
+		Convert.toString(affine[2])+"\n" + 
+		Convert.toString(affine[3])+"\n" + 
+		Convert.toString(affine[4])+"\n" +
+		Convert.toString(affine[5])+"\n" +
+		Convert.toString(lowlat)+"\n" +
+		Convert.toString(lowlon)+"\n";
+		if (digSep.equals(",")) towrite=towrite.replace(',', '.');
+		outp.print(towrite);
+		outp.close();
+		this.fileName = ""; // this will be set in getImageFilenam //mapsPath + "/" + mapFileName + ".png";
+		this.fileNameWFL = mapsPath + "/" + mapFileName + ".wfl";
+		this.mapName = mapFileName;
+	}
+
+	public boolean inBound(CWPoint pos){
+		boolean isInBound = false;
+		/*
+		Vm.debug(mapName);
+		Vm.debug("Top: " + affine[4]);
+		Vm.debug("Bottom: " + lowlat);
+		Vm.debug("Test: " + pos.latDec);
+		Vm.debug("Left: " + affine[5]);
+		Vm.debug("Right: " + lowlon);
+		Vm.debug("Test: " + pos.lonDec);
+		 */
+		if(affine[4] >= pos.latDec && pos.latDec >= lowlat && affine[5] <= pos.lonDec && pos.lonDec <= lowlon) isInBound = true;
+		return isInBound;
+	}
+
+	/**
+	 * zoom in / out
+	 * @param zf zf > 1 == zoom in, zoom is relative to original unscaled image
+	 * @param diffX shift of map in pixels (if the map was cropped while zooming) in the not zoomed image
+	 * @param diffY
+	 */
+	public void zoom(float zf, int diffX, int diffY) {
+		// restore original values to calculate corret shift (upperleft)
+		affine[4] = OrigUpperLeft.latDec;
+		affine[5] = OrigUpperLeft.lonDec;
+		affine[0] = affine[0] * zoomFactor; 
+		affine[1] = affine[1] * zoomFactor; 
+		affine[2] = affine[2] * zoomFactor;
+		affine[3] = affine[3] * zoomFactor;
+		CWPoint upperleft = calcLatLon(diffX, diffY);
+		affine[4] = upperleft.latDec;
+		affine[5] = upperleft.lonDec;
+		affine[0] = affine[0] / zf ; 
+		affine[1] = affine[1] / zf ; 
+		affine[2] = affine[2] / zf ; 
+		affine[3] = affine[3] / zf ; 
+		zoomFactor = zf ;
+		shift.x = diffX;
+		shift.y = diffY;
+		doCalculations(); // TODO lowlat neu berechnen?
+	}
+
+	public boolean inBound(CWGPSPoint pos){
+		boolean isInBound = false;
+		/*
+		Vm.debug(mapName);
+		Vm.debug("Top: " + affine[4]);
+		Vm.debug("Bottom: " + lowlat);
+		Vm.debug("Test: " + pos.latDec);
+		Vm.debug("Left: " + affine[5]);
+		Vm.debug("Right: " + lowlon); // lowlon should be left?!
+		Vm.debug("Test: " + pos.lonDec);
+		 */
+		if(affine[4] >= pos.latDec && pos.latDec >= lowlat && affine[5] <= pos.lonDec && pos.lonDec <= lowlon) isInBound = true;
+		return isInBound;
+	}
+	public boolean inBound(double lati, double loni){
+		boolean isInBound = false;
+		if(affine[4] >= lati && lati >= lowlat && affine[5] <= loni && loni <= lowlon) isInBound = true;
+		return isInBound;
+	}
+	/**
+	 * Method to calculate bitmap x,y of the current map using
+	 * lat and lon target coordinates. There ist no garanty that
+	 * the returned coordinates are inside of the map. They can be negative.
+	 * @param lat
+	 * @param lon
+	 */
+	public Point calcMapXY(double lat, double lon){
+		Point coords = new Point();
+		double b[] = new double[2];
+		b[0] = lat - affine[4];
+		b[1] = lon - affine[5];
+		double mapx=transLatX* b[0] + transLonX*b[1];
+		double mapy=transLatY* b[0] + transLonY*b[1];
+		coords.x = (int)mapx;
+		coords.y = (int)mapy;
+		//Vm.debug("mapX=mapx2: "+mapx+"="+mapx2+"; mapy=mapy2: "+mapy+"="+mapy2);
+		return coords;
+	}
+
+	/**
+	 * gives back lat/lon from x, y in map
+	 * @param x
+	 * @param y
+	 * @return
+	 */
+	public CWPoint calcLatLon(int x, int y) {
+		CWPoint ll = new CWPoint();
+		ll.latDec = (double)x * affine[0] + (double)y * affine[2] + affine[4];
+		ll.lonDec = (double)x * affine[1] + (double)y * affine[3] + affine[5];
+		return ll;
+	}
+	public CWPoint calcLatLon(Point p) {
+		return calcLatLon(p.x, p.y);
+	}
+	public Area getArea(){
+		return new Area(new CWPoint(affine[4], affine[5]), new CWPoint(lowlat, lowlon));
+	}
+}
\ No newline at end of file

Copied: trunk/src/CacheWolf/map/MapLoader.java (from rev 878, trunk/src/CacheWolf/MapLoader.java)
===================================================================
--- trunk/src/CacheWolf/MapLoader.java	2007-09-04 23:05:39 UTC (rev 878)
+++ trunk/src/CacheWolf/map/MapLoader.java	2007-09-05 02:06:44 UTC (rev 880)
@@ -0,0 +1,240 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.HttpConnection;
+import CacheWolf.InfoBox;
+import ewe.ui.*;
+import ewe.io.*;
+import ewe.fx.*;
+import ewe.util.*;
+import ewe.sys.*;
+import ewe.sys.Double;
+import ewe.net.*;
+
+/**
+*
+*/
+
+// Um Karten zu holen!
+// http://www.expedia.de/pub/agent.dll?qscr=mrdt&ID=3kQaz.&CenP=48.09901667,11.35688333&Lang=EUR0407&Alti=1&Size=600,600&Offs=0.000000,0.000000&Pins=|5748|
+// oder
+// http://www.expedia.de/pub/agent.dll?qscr=mrdt&ID=3kQaz.&CenP=48.15,11.5833&Alti=2&Lang=EUR0407&Size=900,900&Offs=0,0&MapS=0&Pins=|48.15,11.5833|4|48.15,11.5833&Pins=|48.15,11.5833|1|48.15,%2011.5833||
+
+
+public class MapLoader {
+	String proxy = new String();
+	String port = new String();
+	InfoBox progressInfobox;
+	
+	final static float downloadMapScaleFactorExpedia_east = 3950;
+	final static float MAPBLAST_METERS_PER_PIXEL = 1.0f/2817.947378f;
+	final static float EXPEDIA_METERS_PER_PIXEL = downloadMapScaleFactorExpedia_east * MAPBLAST_METERS_PER_PIXEL; 
+
+	int numMapsY;
+	int numMapsX;
+	double latinc;
+	double loninc;
+	CWPoint topleft;
+	CWPoint buttomright;
+	Point tilesSize;
+	int tileScale;
+
+	public MapLoader(String prxy, String prt){
+		port = prt;
+		proxy = prxy;
+		progressInfobox = null;
+	}
+	
+	/**
+	 * download maps from expedia at zoomlevel alti and save the maps and the .wfl 
+	 * in path
+	 * @param center center of all tiles
+	 * @param radius in meters
+	 * @param scale in "alti" value 1 alti =  3950 /2817.947378 = 1,046861280317350198581316446428 meters per pixel
+	 * @param size in pixels
+	 * @param overlapping in pixels
+	 * @param path without "/" at the end
+	 * 
+	 */
+	public void setTiles (CWPoint center, float radius, int scale, Point size, int overlapping) {
+		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		double metersPerLon = metersPerLat * java.lang.Math.cos(center.latDec/180*java.lang.Math.PI);
+		topleft = new CWPoint(center.latDec + (radius / metersPerLat), center.lonDec - (radius / metersPerLon));
+		buttomright = new CWPoint(center.latDec - (radius / metersPerLat), center.lonDec + (radius / metersPerLon));
+		
+		this.setTiles(topleft, buttomright, scale, size, overlapping);
+	}
+	
+	public void setTiles(CWPoint toplefti, CWPoint buttomrighti, int scale, Point size, int overlapping) {
+		//if (toplefti.latDec <= buttomrighti.latDec || toplefti.lonDec >= toplefti.lonDec) throw new IllegalArgumentException("topleft must be left and above buttom right");
+		topleft = new CWPoint(toplefti);
+		buttomright = new CWPoint(buttomrighti);
+		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		double metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + buttomright.latDec)/2/180*java.lang.Math.PI);
+		
+		double pixelsPerLat = metersPerLat / (EXPEDIA_METERS_PER_PIXEL * scale);
+		double pixelsPerLon = metersPerLon / (EXPEDIA_METERS_PER_PIXEL * scale);
+
+		//over all pixelsize without borders
+		double pixelsY = (topleft.latDec - buttomright.latDec) * pixelsPerLat; 
+		double pixelsX = -(topleft.lonDec - buttomright.lonDec) * pixelsPerLon ; 
+		
+		//border sizes around given area and overlapping between tiles
+		//int borderX = (int) java.lang.Math.round((float)size.x * (overlapping - 1.0));
+		//int borderY = (int) java.lang.Math.round((float)size.y * (overlapping - 1.0));
+		int borderX = overlapping;
+		int borderY = overlapping;
+		
+		numMapsY = (int) java.lang.Math.ceil( (pixelsY + (float)borderY) / (float)(size.y - borderY) );
+		numMapsX = (int) java.lang.Math.ceil( (pixelsX + (float)borderX) / (float)(size.x - borderX) );
+		
+		//increments calulated from pixel offset of tiles
+		latinc = (float)-(size.y - borderY) / pixelsPerLat;
+		loninc = (float)(size.x - borderX) / pixelsPerLon;
+		
+		//calculation of center of first tile
+		
+		//additional size for borders and rounding
+		double oversizeX = (float)(numMapsX * (size.x - borderX) + borderX) - pixelsX;
+		double oversizeY = (float)(numMapsY * (size.y - borderY) + borderY) - pixelsY;
+		
+		//offset for upper left corner
+		double offsetLat = -( ((float)size.y - oversizeY) / 2.0 ) / pixelsPerLat;
+		double offsetLon = ( ((float)size.x - oversizeX) / 2.0 ) / pixelsPerLon;
+		
+		topleft.latDec += offsetLat;
+		topleft.lonDec += offsetLon;
+		
+		this.tilesSize = new Point();
+		this.tilesSize.set(size);
+		this.tileScale = scale;
+	}
+
+	public void downlaodTiles(String tilesPath) {
+		double lat = topleft.latDec;
+		double lon = topleft.lonDec;
+		for (int row = 1; row <= numMapsY; row++) {
+			lon = topleft.lonDec;
+			for (int col = 1; col <= numMapsX; col++) {
+				if (progressInfobox != null)
+					progressInfobox.setInfo("Downloading calibrated (georeferenced) \n map image from www.expedia.com \n Downloading tile row: "+row+" / "+numMapsY+" coloumn "+ col + "/"+numMapsX);
+				downloadMap(lat, lon, tileScale, tilesSize.x, tilesSize.y, tilesPath);
+				lon += loninc;
+			}
+			lat += latinc;
+		}
+	}
+	
+	/*
+	public void loadTo(String a, String b) {
+		//loadTo(a, b, "50.74", "7.095");
+	}
+	*/
+
+	public void setProgressInfoBox (InfoBox progrssInfoboxi) {
+		progressInfobox = progrssInfoboxi;
+	}
+	/**
+	 * calculates the Expedia Alti = scale which fits in distance to its edges
+	 * @param center
+	 * @param distance in meters
+	 */
+	public static int getExpediaAlti(CWPoint center, float distance, Point size) {
+		int scaleLatO = (int) java.lang.Math.ceil(( distance * 2 / EXPEDIA_METERS_PER_PIXEL / size.y));
+		int scaleLonO = (int) java.lang.Math.ceil(( distance * 2 / EXPEDIA_METERS_PER_PIXEL / size.x));
+		int scaleO = (scaleLatO < scaleLonO ? scaleLonO : scaleLatO);
+		//loadTo((topleft.latDec + buttomright.latDec)/2, (topleft.lonDec + buttomright.lonDec)/2, scaleO, size.x, size.y, path+"/expedia_alti"+scaleO+"_lat"+latD.toString()+"_lon"+lonD.toString());
+		return scaleO;
+	}
+	
+	public static String createExpediaFilename(double lat, double lon, int alti) {
+		Double latD = new Double(), lonD = new Double();
+		latD.decimalPlaces = 4;
+		lonD.decimalPlaces = 4;
+		latD.set(lat);
+		lonD.set(lon);
+		return "expedia_alti"+alti+"_lat"+latD.toString().replace(',', '.')+"_lon"+lonD.toString().replace(',', '.')+".gif";
+	}
+	
+	public void downloadMap(double lat, double lon, int alti, int PixelWidth, int PixelHeight, String path){
+		loadTo(lat, lon, alti, PixelWidth, PixelHeight, path+"/"+createExpediaFilename(lat, lon, alti));
+	}
+
+	public void loadTo(double lat, double lon, int alti, int PixelWidth, int PixelHeight, String datei){
+		HttpConnection connImg, conn2;
+		Socket sockImg, sock2;
+		InputStream is;
+		FileOutputStream fos;
+		ByteArray daten;
+		String quelle = new String();
+		String zone;
+		if (lon <= -10) zone = "USA0409";
+		else zone = "EUR0809";
+
+		/*
+		 * information from: DownloadMouseMode.properties in project GPSylon ( in directory gpsylon_src-0.5.2\plugins\downloadmousemode\auxiliary\org\dinopolis\gpstool\plugin\downloadmousemode and DownloadMapCalculator.java in Dir gpsylon_src-0.5.2\plugins\downloadmousemode\src\org\dinopolis\gpstool\plugin\downloadmousemode 
+		 * download.map.url.expedia_east=http\://www.expedia.com/pub/agent.dll?qscr=mrdt&ID=3XNsF.&CenP={0,number,#.########},{1,number,#.########}&Lang=EUR0809&Alti={2,number,#}&Size={3,number,#},{4,number,#}&Offs=0.000000,0.000000\&BCheck=1
+		 * download.map.url.expedia_east.title=Url of Expedia Europe
+		 * download.map.scale_factor.expedia_east=3950
+		 */
+		Double latD = new Double();
+		latD.decimalPlaces = 8;
+		latD.set(lat);
+		Double lonD = new Double();
+		lonD.decimalPlaces = 8;
+		lonD.set(lon);
+		quelle = "http://www.expedia.de/pub/agent.dll?qscr=mrdt";
+		quelle = quelle + "&ID=3kQaz.";
+		quelle = quelle + "&CenP=" + latD.toString().replace(',', '.') + "," + lonD.toString().replace(',', '.');
+		quelle = quelle + "&Alti="+Convert.toString(alti)+"&Lang="+zone+"&Size="+Convert.toString(PixelWidth)+","+Convert.toString(PixelHeight)+"&Offs=0,0&MapS=0"; //&Pins=|" + latD.toString().replace(',', '.') + "," + lonD.toString().replace(',', '.') + "|5|";
+		//Vm.debug(lat + "," + lon);
+		if(proxy.length()>0){
+			connImg = new HttpConnection(proxy, Convert.parseInt(port), quelle);
+			//Vm.debug("Loading quelle: " + quelle);
+		}else{
+			connImg = new HttpConnection(quelle);
+		}
+		//datei = "d:\\temp\\test_map.bmp";
+		connImg.setRequestorProperty("USER_AGENT", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0");
+		connImg.setRequestorProperty("Connection", "close");
+		connImg.setRequestorProperty("Cookie", "jscript=1; path=/;");
+		connImg.documentIsEncoded = true;
+		try{
+			File dateiF = new File(datei);
+			if(!dateiF.exists()){
+				sockImg = connImg.connect();
+				//Vm.debug("Redirect: " + connImg.getRedirectTo());
+				quelle = connImg.getRedirectTo();
+				sockImg.close();
+				if(proxy.length()>0){
+					connImg = new HttpConnection(proxy, Convert.parseInt(port), quelle);
+				}else{
+					connImg = new HttpConnection(quelle);
+				}
+				connImg.setRequestorProperty("USER_AGENT", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0");
+				connImg.setRequestorProperty("Connection", "close");
+				connImg.setRequestorProperty("Cookie", "jscript=1; path=/;");
+				connImg.documentIsEncoded = true;
+				sock2 = connImg.connect();
+				daten = connImg.readData(sock2);
+				fos = new FileOutputStream(dateiF);
+				fos.write(daten.toBytes());
+				fos.close();
+				sock2.close();
+			}
+			//Vm.debug("done");
+		}catch(IOException e){
+			(new MessageBox("Error", "Error while downloading or saving map:\n"+e.getMessage(), MessageBox.OKB)).exec();
+		}
+		File dateiF = new File(datei); // change!!!
+		String tmp = dateiF.getName(); // contains the name and the extension
+		String name = tmp.substring(0, tmp.lastIndexOf("."));
+		float metersPerPixel = (float) (alti)*EXPEDIA_METERS_PER_PIXEL;
+		MapInfoObject cal = new MapInfoObject(metersPerPixel, new CWPoint(lat,lon),  PixelWidth, PixelHeight, dateiF.getPath()+"/"+name);
+		try {
+		cal.saveWFL(dateiF.getDrivePath(), name);
+		} catch (IOException e) {
+			(new MessageBox("Error", "Error saving calibration file:\n"+e.getMessage(), MessageBox.OKB)).exec();
+		}
+	}
+}
\ No newline at end of file

Copied: trunk/src/CacheWolf/map/MapLoaderGui.java (from rev 878, trunk/src/CacheWolf/MapLoaderGui.java)
===================================================================
--- trunk/src/CacheWolf/MapLoaderGui.java	2007-09-04 23:05:39 UTC (rev 878)
+++ trunk/src/CacheWolf/map/MapLoaderGui.java	2007-09-05 02:06:44 UTC (rev 880)
@@ -0,0 +1,258 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.CacheHolder;
+import CacheWolf.CoordsScreen;
+import CacheWolf.Global;
+import CacheWolf.InfoBox;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+import ewe.io.File;
+import ewe.sys.Convert;
+import ewe.sys.Vm;
+import ewe.ui.*;
+import ewe.util.Vector;
+
+/**
+ * @author pfeffer
+ * This Class is the Dialog for Download calibrated from expedia.com
+ * is called from 
+ */
+
+public class MapLoaderGui extends Form {
+	mButton cancelB, okBtiles, okBPerCache, cancelBPerCache;
+	Preferences pref;
+	mTabbedPanel mTab = new mTabbedPanel();
+	CellPanel pnlTiles = new CellPanel();
+	CellPanel pnlPerCache = new CellPanel();
+
+	final String descString = "Download georeferenced maps from expedia.com";
+	mCheckBox forCachesChkBox = new mCheckBox("for");
+	mChoice forSelectedChkBox = new mChoice(new String[] {"all", "selected"}, 0);
+	mChoice forSelectedChkBoxPerCache = new mChoice(new String[] {"all", "selected"}, 1);
+	mLabel cachesLbl = new mLabel("caches");
+	mInput distanceInput;
+	mLabel distLbl;
+	mLabel km = new mLabel("km");
+	mLabel coosLbl;
+	mButton coosBtn;
+	mLabel scaleLbl = new mLabel("Approx. m per pixel:");
+	mInput scaleInput = new mInput ("3");
+	mInput scaleInputPerCache = new mInput ("1");
+	mLabel overlappingLbl = new mLabel("overlapping in pixel:");
+	mInput overlappingInput = new mInput("100");
+	mCheckBox overviewChkBox = new mCheckBox("download an overview map");
+	mCheckBox overviewChkBoxPerCache = new mCheckBox("download an overview map");
+
+	CWPoint center;
+	Vector cacheDB;
+	boolean perCache;
+	boolean onlySelected;
+	float radius;
+	float scale;
+	int overlapping;
+	boolean overviewmap;
+	int numCaches;
+
+	public MapLoaderGui(Vector cacheDBi) {
+		super();
+		this.title = MyLocale.getMsg(1800, "Download georeferenced maps"); 
+		pref = Global.getPref(); // myPreferences sollte sp?ter auch diese Einstellungen speichern
+		center = new CWPoint(pref.curCentrePt);
+		cacheDB = cacheDBi;
+		// tiles panel
+		MessageArea desc = new MessageArea(descString);
+		desc.modifyAll(mTextPad.NotEditable | mTextPad.DisplayOnly | mTextPad.NoFocus, mTextPad.TakesKeyFocus);
+		desc.borderStyle = mTextPad.BDR_NOBORDER;
+		pnlTiles.addLast(desc);
+		pnlTiles.addNext(forCachesChkBox);
+		pnlTiles.addNext(forSelectedChkBox);
+		pnlTiles.addLast(cachesLbl);
+		pnlTiles.addNext(distLbl = new mLabel(MyLocale.getMsg(1802,"Within a rectangle of:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		distanceInput = new mInput();
+		int tmp = Convert.toInt((Global.getProfile().distOC));
+		distanceInput.setText(Convert.toString((tmp > 0 ? tmp : 15)));
+		pnlTiles.addNext(distanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlTiles.addLast(km);
+		pnlTiles.addNext(coosLbl = new mLabel(MyLocale.getMsg(1803, "around the center: ")));
+		pnlTiles.addLast(coosBtn = new mButton(center.toString()));
+		pnlTiles.addNext(scaleLbl);
+		scaleInput.setText("5");
+		this.focusFirst();
+		pnlTiles.addLast(scaleInput);
+		//	pnlTiles.addLast(resolutionLbl);
+		pnlTiles.addNext(overlappingLbl);
+		pnlTiles.addLast(overlappingInput);
+		overviewChkBox.setState(true);
+		pnlTiles.addLast(overviewChkBox);
+		cancelB = new mButton(MyLocale.getMsg(1604,"Cancel"));
+		cancelB.setHotKey(0, IKeys.ESCAPE);
+		pnlTiles.addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		okBtiles = new mButton(MyLocale.getMsg(1605,"OK"));
+		okBtiles.setHotKey(0, IKeys.ACTION);
+		okBtiles.setHotKey(0, IKeys.ENTER);
+		pnlTiles.addLast(okBtiles,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		updateForCachesState();
+		mTab.addCard(pnlTiles, MyLocale.getMsg(1804, "Tiles"), MyLocale.getMsg(1804, "Tiles"));
+
+		// per cache panel
+		pnlPerCache.addLast(new MessageArea(descString));
+		pnlPerCache.addNext(new mLabel("Download one map for"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addNext(forSelectedChkBoxPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addLast(new mLabel("caches"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addNext(new mLabel("Approx. m per pixel"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addLast(scaleInputPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+
+		cancelBPerCache = new mButton(MyLocale.getMsg(1604,"Cancel"));
+		cancelBPerCache.setHotKey(0, IKeys.ESCAPE);
+		pnlPerCache.addNext(cancelBPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		okBPerCache = new mButton(MyLocale.getMsg(1605,"OK"));
+		okBPerCache.setHotKey(0, IKeys.ACTION);
+		okBPerCache.setHotKey(0, IKeys.ENTER);
+		pnlPerCache.addLast(okBPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+
+		mTab.addCard(pnlPerCache, MyLocale.getMsg(1805, "Per cache"), MyLocale.getMsg(1805, "Per Cache"));
+		this.addLast(mTab);
+	}
+	public String getMapsDir() {
+		return Global.getPref().getMapExpediaSavePath();
+	}
+	public void downloadTiles() {
+		String mapsDir = getMapsDir();
+		if (mapsDir == null) return;
+		InfoBox progressBox = new InfoBox("Downloading georeferenced maps", "Downloading georeferenced maps\n from www.expedia.com");
+		progressBox.setPreferredSize(230, 150);
+		progressBox.exec();
+		Vm.showWait(true);
+		ewe.fx.Point size = new ewe.fx.Point(1000,1000); // Size of the downloaded maps
+		MapLoader ml = new MapLoader(Global.getPref().myproxy, Global.getPref().myproxyport);
+		if (forCachesChkBox.getState() || perCache) {
+			Area surArea = Global.getProfile().getSourroundingArea(onlySelected); // calculate map boundaries from cacheDB
+			if (surArea == null) {
+				(new MessageBox("Error", "No Caches are seleted", MessageBox.OKB)).execute();
+				Vm.showWait(false);
+				progressBox.close(0);
+				return;
+			}
+			ml.setTiles(surArea.topleft, surArea.buttomright, (int)scale, size, overlapping );
+			// calculate radius and center for overview map
+			center = new CWPoint((surArea.topleft.latDec + surArea.buttomright.latDec)/2, (surArea.topleft.lonDec + surArea.buttomright.lonDec)/2);
+			double radiuslat = (new CWPoint(center.latDec, surArea.buttomright.lonDec)).getDistance(surArea.buttomright);
+			double radiuslon = (new CWPoint(surArea.buttomright.latDec, center.lonDec)).getDistance(surArea.buttomright);
+			radius = (float) (radiuslat < radiuslon ? radiuslon : radiuslat);
+		} else 
+		{ // calculate from center point an radius
+			ml.setTiles(center, radius * 1000, (int)scale, size, overlapping);
+		}
+		if (overviewmap) {
+			progressBox.setInfo("downloading overview map"); 
+			int expediaAlti = MapLoader.getExpediaAlti(center, radius * 1000, size);
+			ml.downloadMap(center.latDec, center.lonDec, expediaAlti, size.x, size.y, mapsDir);
+		}
+		if (!perCache){  // download tiles
+			ml.setProgressInfoBox(progressBox);
+			ml.downlaodTiles(mapsDir);
+		} else { // per cache
+			CacheHolder ch; 
+			CWPoint tmpca = new CWPoint();
+			int numdownloaded = 0;
+			Global.getProfile().getSourroundingArea(onlySelected); // calculate numCachesInArea
+			int numCaches = Global.getProfile().numCachesInArea;
+			for (int i=cacheDB.size()-1; i >= 0; i--) {
+				ch = (CacheHolder) cacheDB.get(i);
+				if (!this.onlySelected || ch.is_Checked) {
+					if (ch.pos == null) { // this can not happen
+						tmpca.set(ch.LatLon);
+						ch.pos = new CWPoint(tmpca);
+					}
+					if (ch.pos.isValid() && ch.pos.latDec != 0 && ch.pos.lonDec != 0) { // TODO != 0 sollte verschwinden, sobald das handling von nicht gesetzten Koos ?berall korrekt ist
+						numdownloaded++;
+						progressBox.setInfo("Downloading map from expedia.de\n"+numdownloaded+" / "+numCaches+"\n for cache:\n"+ch.CacheName);
+						ml.downloadMap(ch.pos.latDec, ch.pos.lonDec, (int)scale, size.x, size.y, mapsDir);
+					}
+				}
+			}
+		}
+		Vm.showWait(false);
+		ml.setProgressInfoBox(null);
+		progressBox.close(0);
+		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
+		(new MessageBox("Expedia maps", "Downloaded and calibrated the maps successfully", MessageBox.OKB)).execute();
+	}
+
+
+	private void updateForCachesState() {
+		int a, b;
+		if (forCachesChkBox.getState()) {
+			// create map rectangle from caches
+			a = 0;
+			b = Control.Disabled;
+		}
+		else { // use center and distance input
+			a = Control.Disabled;
+			b = 0;
+		}
+		forSelectedChkBox.modify(a, b);
+		cachesLbl.modify(a, b);
+		distanceInput.modify(b, a);
+		distLbl.modify(b, a);
+		coosBtn.modify(b, a);
+		coosLbl.modify(b, a);
+		km.modify(b,a);
+		repaintNow();
+
+	}
+
+	public void onEvent(Event ev){
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+			if (ev.target == cancelB || ev.target == cancelBPerCache){
+				this.close(Form.IDCANCEL);
+			}
+			if (ev.target == okBtiles || ev.target == okBPerCache){
+				if (ev.target == okBtiles) { // get tiles
+					perCache = false;
+					if (forSelectedChkBox.getSelectedItem().toString().equalsIgnoreCase("all")) onlySelected = false;
+					else onlySelected = true;
+					overviewmap = overviewChkBox.getState();
+					radius = Convert.toFloat(distanceInput.getText());
+					scale = Convert.toFloat(scaleInput.getText());
+					overlapping = Convert.toInt(overlappingInput.getText());
+					if (!forCachesChkBox.getState()) {
+						if (radius <= 0) { 
+							(new MessageBox("Error", "'radius' must be graeter than null", MessageBox.OKB)).execute();
+							return;
+						}
+						if (overlapping < 0) { 
+							(new MessageBox("Error", "'overlapping' must be greater or equal 0 ", MessageBox.OKB)).execute();
+							return;
+						}
+					}
+				} else { // per cache
+					perCache = true;
+					if (forSelectedChkBoxPerCache.getSelectedItem().toString().equalsIgnoreCase("all")) onlySelected = false;
+					else onlySelected = true;
+					overviewmap = overviewChkBoxPerCache.getState();
+					scale = Convert.toFloat(scaleInputPerCache.getText());
+				}
+				if (scale < 1 || scale != java.lang.Math.floor(scale)) {
+					(new MessageBox("Error", "'Approx. meter pro pixel' must be greater than 0 and must not contain a point", MessageBox.OKB)).execute();
+					return;
+				}
+				this.close(Form.IDOK); 
+				this.downloadTiles();
+			}
+			if (ev.target == coosBtn) {
+				CoordsScreen cs = new CoordsScreen();
+				cs.setFields(center, CWPoint.CW);
+				if (cs.execute() != CoordsScreen.IDCANCEL) {
+					center = cs.getCoords();
+					coosBtn.setText(center.toString());
+				}
+			}
+			if (ev.target == forCachesChkBox) {
+				updateForCachesState();
+			}
+		} // if controllEvent...
+		super.onEvent(ev);
+	}
+}

Added: trunk/src/CacheWolf/map/MapSymbol.java
===================================================================
--- trunk/src/CacheWolf/map/MapSymbol.java	2007-09-05 01:58:25 UTC (rev 879)
+++ trunk/src/CacheWolf/map/MapSymbol.java	2007-09-05 02:06:44 UTC (rev 880)
@@ -0,0 +1,28 @@
+package CacheWolf.navi;
+
+import ewe.fx.*;
+import ewe.graphics.*;
+
+public class MapSymbol extends AniImage { // TODO make this implement MapImage, so that it will be invisible automatically if not on screen. When doing so, test if setgoto-pos -> open map from gotopanel shows the map symbols (directly after starting CW)
+	Object mapObject;
+	String name;
+	String filename;
+	double lat, lon;
+	public MapSymbol(String namei, String filenamei, double lati, double loni) {
+		name = namei;
+		filename = filenamei;
+		lat = lati;
+		lon = loni;
+	}
+	public MapSymbol(String namei, Object mapObjecti, Image fromIm, double lati, double loni) {
+		name = namei;
+		lat = lati;
+		lon = loni;
+		mapObject = mapObjecti;
+		setImage(fromIm);
+	}
+	public void loadImage(){
+		setImage(new Image(filename),0); freeSource();;
+		//properties = AniImage.AlwaysOnTop;
+	}
+}

Copied: trunk/src/CacheWolf/map/MapsList.java (from rev 878, trunk/src/CacheWolf/MapsList.java)
===================================================================
--- trunk/src/CacheWolf/MapsList.java	2007-09-04 23:05:39 UTC (rev 878)
+++ trunk/src/CacheWolf/map/MapsList.java	2007-09-05 02:06:44 UTC (rev 880)
@@ -0,0 +1,326 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import utils.FileBugfix;
+import ewe.io.File;
+import ewe.io.IOException;
+import ewe.sys.Double;
+import ewe.ui.MessageBox;
+import ewe.util.Hashtable;
+import ewe.util.Vector;
+import ewe.fx.*;
+/**
+ * class to handle a list of maps
+ * it loads the list, finds the best map for a given location,
+ * says if a map is available for a given lat lon at a given scale
+ * @author r
+ *
+ */
+public class MapsList extends Vector {
+	public static float scaleTolerance = 1.15f; // absolute deviations from this factor are seen to have the same scale
+	public Hashtable scales2Area;
+
+	/**
+	 * loads alle the maps in mapsPath in all subDirs but not recursive, only one level 
+	 * @param mapsPath
+	 */
+	public MapsList(String mapsPath) {
+		super(); // forget already loaded maps
+		//if (mmp.mapImage != null) 
+		String dateien[];
+		FileBugfix files = new FileBugfix(mapsPath);
+		String rawFileName = new String();
+		String[] dirstmp = files.list(null, File.LIST_DIRECTORIES_ONLY);
+		Vector dirs;
+		if (dirstmp != null) dirs = new Vector(dirstmp);
+		else dirs = new Vector();
+		dirs.add("."); // include the mapsPath itself
+		MapInfoObject tempMIO;
+		MessageBox f = null;
+		for (int j = dirs.size()-1; j >= 0; j--) {
+			files = new FileBugfix(mapsPath+"/"+dirs.get(j));
+			//ewe.sys.Vm.debug("mapd-Dirs:"+files);
+			dateien = files.list("*.wfl", File.LIST_FILES_ONLY); //"*.xyz" doesn't work on some systems -> use FileBugFix
+			for(int i = 0; i < dateien.length;i++){
+				// if (!dateien[i].endsWith(".wfl")) continue;
+				rawFileName = dateien[i].substring(0, dateien[i].lastIndexOf("."));
+				try {
+					tempMIO = new MapInfoObject();
+					if (dirs.get(j).equals(".")) // the notation dir/./filename doesn't work on all platforms anyhow
+						tempMIO.loadwfl(mapsPath+"/", rawFileName);
+					else tempMIO.loadwfl(mapsPath+"/"+dirs.get(j)+"/", rawFileName);
+					add(tempMIO);
+				}catch(IOException ex){ 
+					if (f == null) (f=new MessageBox("Warning", "Ignoring error while \n reading calibration file \n"+ex.toString(), MessageBox.OKB)).exec();
+				}catch(ArithmeticException ex){ // affine contain not allowed values 
+					if (f == null) (f=new MessageBox("Warning", "Ignoring error while \n reading calibration file \n"+ex.toString(), MessageBox.OKB)).exec();
+				} 
+			}
+		}
+	}
+
+	public void addEmptyMaps(double lat) {
+		MapInfoObject tempMIO;
+		tempMIO = new MapInfoObject(1.0, lat);
+		add(tempMIO);
+		tempMIO = new MapInfoObject(5.0, lat);
+		add(tempMIO);
+		tempMIO = new MapInfoObject(50.0, lat);
+		add(tempMIO);
+		tempMIO = new MapInfoObject(250.0, lat);
+		add(tempMIO);
+		tempMIO = new MapInfoObject(1000.0, lat);
+		add(tempMIO);
+	}
+
+	/**
+	 * find the best map for lat/lon in the list of maps
+	 * currently the best map is the one, whose center is nearest to lat/lon
+	 * and in Area with its scale nearest to scale.
+	 * it always returns a map (if the list is not empty) 
+	 * even if the map is not inbound
+	 * lat/lon
+	 * @param lat
+	 * @param lon
+	 * @param forceScale: when true, return null if no map with specified scale could be found
+	 * @return
+	 */
+	public MapInfoObject getBestMap(double lat, double lon, Rect screen, float scale, boolean forceScale) {
+		if (size() == 0) return null;
+		if (scales2Area != null) scales2Area.clear();
+		MapInfoObject mi;
+		MapInfoObject bestMap = null; // = (MapInfoObject)get(0);
+		double minDistLat = 1000000000000000000000000000000000000000000000.0;
+		double minDistLon = 1000000000000000000000000000000000000000000000.0;
+		boolean latNearer, lonNearer;
+		boolean better = false;
+		Area screenArea = null; // getAreaForScreen(screen, lat, lon, bestMap.scale, bestMap);
+		float lastscale = -1;
+		for (int i=size()-1; i >= 0 ;i--) { 
+			better = false;
+			mi = (MapInfoObject)get(i);
+			if (screenArea == null || !scaleEquals(lastscale, mi) ) {
+				screenArea = getAreaForScreen(screen, lat, lon, mi.scale, mi);
+				lastscale = mi.scale;
+			}
+			if (screenArea.isOverlapping(mi.getArea()) ) { // is on screen
+				if (!forceScale || (forceScale && !scaleEquals(scale, mi))) { // different scale?
+					if (!forceScale && (mi.inBound(lat, lon) && (bestMap == null || scaleNearer(mi.scale, bestMap.scale, scale) || !bestMap.inBound(lat, lon)))) 
+						better = true; // inbound and resolution nearer at wanted resolution or old one is on screen but lat/long not inbound-> better
+					else {
+						if ( bestMap == null || scaleNearerOrEuqal(mi.scale, bestMap.scale, scale)) {
+							latNearer = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm < minDistLat ;
+							lonNearer = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm < minDistLon;
+							if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
+							else {
+								if ( (latNearer || lonNearer )) { 
+									if (bestMap == null || mi.center.getDistanceRad(lat, lon) < bestMap.center.getDistanceRad(lat, lon) ) better = true;
+								}
+							}
+						}
+					}
+					if (better) {
+						minDistLat = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm;
+						minDistLon = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm;
+						bestMap = mi;
+						// Vm.debug("better"+ i);
+					}
+				}
+			}
+		}
+		if (bestMap == null) return null;
+		return new MapInfoObject(bestMap); // return a copy of the MapInfoObject so that zooming won't change the MapInfoObject in the list 
+	}
+	/*
+	public MapInfoObject getBestMapNotStrictScale(double lat, double lon, Area screen, float scale) {
+		MapInfoObject ret = getBestMap(lat, lon, screen, scale, true);
+		if (ret == null) ret = getBestMap(lat, lon, screen, scale, false);
+		return ret;
+	}
+	 */
+	/**
+	 * @return a map which includs topleft and bottomright, 
+	 * if no map includes both it returns null
+	 * @param if more than one map includes topleft and bottomright than the one will
+	 * be returned which has its center nearest to topleft. If you have gps-pos and goto-pos
+	 * as topleft and buttomright use gps as topleft.
+	 * if topleft is really topleft or if it is buttomright is not relevant.  
+	 */
+	
+	public MapInfoObject getMapForArea(CWPoint topleft, CWPoint bottomright){
+		MapInfoObject mi;
+		MapInfoObject fittingmap = null;
+		boolean latNearer, lonNearer;
+		boolean better;
+		double minDistLat = 10000000000000000000000.0;
+		double minDistLon = 10000000000000000000000.0;
+		for (int i=size() -1; i>=0 ;i--) {
+			better = false;
+			mi = (MapInfoObject)get(i);
+			if (mi.inBound(topleft) && mi.inBound(bottomright)) { // both points are inside the map
+				if (fittingmap == null || fittingmap.scale > mi.scale * scaleTolerance) {
+					better = true; // mi map has a better (lower) scale than the last knwon good map
+				} else {
+					if (fittingmap != null && scaleEquals(mi, fittingmap)) { // same scale as bestmap till now -> test if its center is nearer to the gps-point = topleft
+						latNearer = java.lang.Math.abs(topleft.latDec- mi.center.latDec)/mi.sizeKm < minDistLat ;
+						lonNearer = java.lang.Math.abs(topleft.lonDec - mi.center.lonDec)/mi.sizeKm < minDistLon;
+						if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
+						else {
+							if ( (latNearer || lonNearer )) { 
+								if (mi.center.getDistanceRad(topleft.latDec, topleft.lonDec) < fittingmap.center.getDistanceRad(topleft.latDec, topleft.lonDec) ) better = true;
+							}
+						}
+
+					}
+				}
+				if (better) {
+					fittingmap = mi;
+					minDistLat = java.lang.Math.abs(topleft.latDec - mi.center.latDec);
+					minDistLon = java.lang.Math.abs(topleft.lonDec - mi.center.lonDec);
+				}
+			}
+		} // for
+		if (fittingmap == null) return null;
+		return new MapInfoObject(fittingmap);
+	}
+
+	/**
+	 * 
+	 * @param lat a point to be inside the map
+	 * @param lon
+	 * @param screen: width, height of the screen. The map must overlap the screen. xy: where is lat/lon on screen
+	 * @param curScale reference scale to be changed
+	 * @param moreDetails true: find map with more details == higher resolustion = lower scale / false find map with less details = better overview
+	 * @return
+	 */
+	public MapInfoObject getMapChangeResolution(double lat, double lon, Rect screen, float curScale, boolean moreDetails){
+		if (size() == 0) return null;
+		if (scales2Area != null) scales2Area.clear();
+		MapInfoObject mi;
+		MapInfoObject bestMap = null; // = (MapInfoObject)get(0);
+		double minDistLat = 1000000000000000000000000000000000000000000000.0;
+		double minDistLon = 1000000000000000000000000000000000000000000000.0;
+		boolean latNearer, lonNearer;
+		boolean better = false;
+		Area screenArea = null; // getAreaForScreen(screen, lat, lon, bestMap.scale, bestMap);
+		float lastscale = -1;
+		for (int i=size()-1; i >= 0 ;i--) { 
+			better = false;
+			mi = (MapInfoObject)get(i);
+			if (mi.fileNameWFL == "") continue; // exclude "maps" without image // TODO make this a boolean in MapInfoObject
+			if (screenArea == null || !scaleEquals(lastscale, mi)) {
+				screenArea = getAreaForScreen(screen, lat, lon, mi.scale, mi);
+				lastscale = mi.scale;
+			}
+			if (screenArea.isOverlapping(mi.getArea())) { // is on screen
+				if (bestMap == null || !scaleEquals(mi, bestMap)) { // different scale than known bestMap?
+					if (mi.inBound(lat, lon) && (      // more details wanted and this map has more details?                                // less details than bestmap
+							(moreDetails && (curScale > mi.scale * scaleTolerance) && (bestMap == null || mi.scale > bestMap.scale * scaleTolerance ) ) // higher resolution wanted and mi has higher res and a lower res than bestmap, because we dont want to overjump one resolution step
+							|| (!moreDetails && (curScale *  scaleTolerance < mi.scale) && (bestMap == null || mi.scale * scaleTolerance < bestMap.scale) ) // lower resolution wanted and mi has lower res and a higher res than bestmap, because we dont want to overjump one resolution step
+					) )	better = true;	// inbound and higher resolution if higher res wanted -> better
+				} else { // same scale as bestmap -> look if naerer 
+					latNearer = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm < minDistLat ;
+					lonNearer = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm < minDistLon;
+					if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
+					else {
+						if ( (latNearer || lonNearer )) { 
+							if (bestMap == null || mi.center.getDistanceRad(lat, lon) < bestMap.center.getDistanceRad(lat, lon) ) better = true;
+						}
+					}
+				} // same scale
+				if (better) {
+					minDistLat = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm;
+					minDistLon = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm;
+					bestMap = mi;
+					// Vm.debug("better"+ i);
+				}
+			}
+		}
+		if (bestMap == null) return null;
+		return new MapInfoObject(bestMap);
+	}
+	/**
+	 * returns an area in lat/lon of the screen
+	 * @param a screen width / height and position of lat/lon on the screen
+	 * @param lat a (reference) point on the screen
+	 * @param lon
+	 * @param scale scale (meters per pixel) of the map for which the screen edges are wanted
+	 * @param map map for which the screen edges are wanted
+	 * @return
+	 */
+	private Area getAreaForScreen(Rect a, double lat, double lon, float scale, MapInfoObject map) {
+		Area ret = null;
+/*		if (scales2Area == null) scales2Area = new Hashtable();
+		else ret = (Area)scales2Area.get(scale);
+		if (ret != null) return ret;
+	*/	// calculate screen Area
+		Point xy = map.calcMapXY(lat, lon);
+		Point topleft = new Point(xy.x - a.x, xy.y - a.y);
+		ret = new Area(map.calcLatLon(topleft), map.calcLatLon(topleft.x+a.width, topleft.y+a.height));
+		//scales2Area.put(new Float(scale), ret);
+		return ret; 
+	}
+	public static boolean scaleEquals(MapInfoObject a, MapInfoObject b) {
+		//return java.lang.Math.abs(a.scale - b.scale) < scaleTolerance;
+		if (a.scale > b.scale) return a.scale / b.scale < scaleTolerance; 
+		else return b.scale / a.scale < scaleTolerance;
+	}
+	public static boolean scaleEquals(float s, MapInfoObject b) {
+		//return java.lang.Math.abs(s - b.scale) < scaleTolerance;
+		if (s > b.scale) return s / b.scale < scaleTolerance;
+		else return b.scale / s < scaleTolerance;
+	}
+	
+	/**
+	 * 
+	 * @param test
+	 * @param old
+	 * @param wanted
+	 * @return true if test is nearer to wanted than old, false if the change in the scale is lower than scaleTolerance
+	 */
+	public static boolean scaleNearer(float test, float old, float wanted) {
+		float testa, wanta, wantb, olda;
+		if (test > wanted) { // ensure that first term is greater than 1
+			testa = test;
+			wanta = wanted;
+		} else {
+			testa = wanted;
+			wanta = test;
+		}
+		if (old > wanted) { // ensure that second term is greater than 1 
+			olda = old;
+			wantb = wanted;
+		} else {
+			olda = wanted;
+			wantb = old;
+		}
+		return testa/wanta * scaleTolerance < olda/wantb; 
+	}
+
+	public static boolean scaleNearerOrEuqal(float test, float old, float wanted) {
+		float testa, wanta, wantb, olda;
+		if (test > wanted) { // ensure that first term is greater than 1
+			testa = test;
+			wanta = wanted;
+		} else {
+			testa = wanted;
+			wanta = test;
+		}
+		if (old > wanted) { // ensure that second term is greater than 1 
+			olda = old;
+			wantb = wanted;
+		} else {
+			olda = wanted;
+			wantb = old;
+		}
+		return testa/wanta < olda/wantb * scaleTolerance ; 
+	}
+
+	/** for determining if a new map should be downloaded
+	public boolean isInAmap(CWPoint topleft, CWPoint buttomright) {
+		if (!latRangeList.isInRange(topleft.latDec) || !latRangeList.isInRange(buttomright.latDec)) ||
+			!lonRangeList.inInRange(topleft.lonDec) || !lonRangeList.isInRange(buttomright.lonDec)
+			return false;
+	}
+	 */
+}

Copied: trunk/src/CacheWolf/map/MovingMap.java (from rev 878, trunk/src/CacheWolf/MovingMap.java)
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-09-04 23:05:39 UTC (rev 878)
+++ trunk/src/CacheWolf/map/MovingMap.java	2007-09-05 02:06:44 UTC (rev 880)
@@ -0,0 +1,2025 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.CacheHolder;
+import CacheWolf.Global;
+import CacheWolf.InfoBox;
+import CacheWolf.MainTab;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+import CacheWolf.myTableModel;
+import ewe.ui.*;
+import ewe.graphics.*;
+import ewe.io.File;
+import ewe.io.IOException;
+import ewe.sys.*;
+import ewe.filechooser.FileChooser;
+import ewe.fx.*;
+import ewe.util.Vector;
+
+/**
+ *	Class to handle a moving map.
+ */
+public class MovingMap extends Form {
+	public final static int gotFix = 4; //green
+	public final static int lostFix = 3; //yellow
+	public final static int noGPSData = 2; // red
+	public final static int noGPS = 1; // no GPS-Position marker, manually disconnected 
+	public final static int ignoreGPS = -1; // ignore even changes in GPS-signal (eg. from lost fix to gotFix) this is wanted when the map is moved manually
+
+	public MapSymbol gotoPos = null;
+	public int GpsStatus;
+	Preferences pref;
+	MovingMapPanel mmp;
+	MapsList maps;
+	Vector symbols;
+	Vector cacheDB;
+	TrackOverlay[] TrackOverlays;
+	CWPoint TrackOverlaySetCenterTopLeft;
+	Vector tracks;
+	MapInfoObject currentMap = null;
+	String mapPath;
+	Navigate myNavigation;
+	boolean running = false;
+
+	MapImage mapImage1to1;
+	ArrowsOnMap directionArrows = new ArrowsOnMap();
+	AniImage statusImageHaveSignal = new AniImage("position_green.png");
+	AniImage statusImageNoSignal = new AniImage("position_yellow.png");
+	AniImage statusImageNoGps = new AniImage("position_red.png");
+	AniImage bottonImageClose;
+	AniImage bottonImageChooseMap = new AniImage("choose_map.gif"); 
+	AniImage buttonImageGpsOn = new AniImage("snap2gps.gif");
+	AniImage buttonImageLens = new AniImage("lupe.png");
+	AniImage buttonImageLensActivated = new AniImage("lupe_activated.png");
+	AniImage buttonImageZoom1to1 = new AniImage("zoom1to1.png");
+	AniImage DistanceImage;
+	Graphics DistanceImageGraphics;
+	AniImage ScaleImage;
+	Graphics ScaleImageGraphics;
+	MapImage posCircle = new MapImage("position_green.png");
+	public static final String MARK_CACHE_IMAGE = "mark_cache.png";
+	int posCircleX = 0, posCircleY = 0, lastCompareX = Integer.MAX_VALUE, lastCompareY = Integer.MAX_VALUE;
+	double posCircleLat, posCircleLon;
+	FontMetrics fm;
+
+	boolean dontUpdatePos = false; // this is only internaly used to avoid multi-threading problems
+	boolean ignoreGps = false; // ignores updateGps-calls if true
+	boolean autoSelectMap = true;
+	boolean forceMapLoad = true; // only needed to force updateposition to try to load the best map again after OutOfMemoryError after an repeated click on snap-to-gps
+	boolean mapHidden = false;
+	boolean noMapsAvailable;
+	boolean zoomingMode = false;
+	boolean mapsloaded = false;
+	
+	Point lastRepaintMapPos = null;
+	double lastDistance = -1;
+
+	public MovingMap(Navigate nav, Vector cacheDB){
+		this.cacheDB = cacheDB;
+		this.myNavigation = nav;
+		this.pref = Global.getPref();
+		if (pref.myAppHeight <= 640 && pref.myAppWidth <= 640)	this.windowFlagsToSet = Window.FLAG_FULL_SCREEN;
+		this.windowFlagsToClear = Window.FLAG_HAS_TITLE | Window.BDR_NOBORDER;
+		this.hasTopBar = false;
+		this.noBorder = true;
+		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
+		this.title = "Moving Map";
+		this.backGround = new Color(254,254,254); // background must not be black because black is interpreted as transparent and transparent images above (eg trackoverlay) want be drawn in windows-VM, so be care, don|t use white either
+		this.mapPath = Global.getPref().getMapLoadPath();
+
+		mmp = new MovingMapPanel(this);
+		this.addLast(mmp);
+		DrawnIcon closeX = new DrawnIcon(DrawnIcon.CROSS,15,15,new Color(0,0,0));
+		bottonImageClose = new AniImage(new Image(closeX.getWidth(), closeX.getHeight()));
+		Graphics tmp = new Graphics(bottonImageClose.image);
+		tmp.setColor(255, 255, 255);
+		tmp.fillRect(0, 0, closeX.getWidth(), closeX.getHeight());
+		closeX.doDraw(tmp, 0);
+		bottonImageClose.properties |= AniImage.AlwaysOnTop;
+		mmp.addImage(bottonImageClose);
+		buttonImageGpsOn.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(buttonImageGpsOn);
+		bottonImageChooseMap.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(bottonImageChooseMap);
+		directionArrows.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(directionArrows);
+		buttonImageLens.properties = AniImage.AlwaysOnTop;
+		buttonImageLensActivated.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(buttonImageLens);
+		buttonImageZoom1to1.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(buttonImageZoom1to1);
+		//target distance
+		Font font = new Font("Helvetica", Font.PLAIN, 13);
+		fm = getFontMetrics(font);
+		DistanceImage = new AniImage();
+		DistanceImage.setImage(new Image(120, 15), Color.White); // consider the size of the font used
+		DistanceImageGraphics = new Graphics(DistanceImage.image);
+		DistanceImageGraphics.setFont(font);
+		DistanceImage.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(DistanceImage);
+		//scale
+		ScaleImage = new AniImage();
+		ScaleImage.setImage(new Image(120, 15), Color.White); // consider the size of the font used
+		ScaleImageGraphics = new Graphics(ScaleImage.image);
+		ScaleImageGraphics.setFont(font);
+		ScaleImage.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(ScaleImage);
+		//resizeTo(pref.myAppWidth, pref.myAppWidth); // is necessary to initialize mapImage.screenSize
+		setGpsStatus(noGPS);
+		posCircle.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(posCircle);
+		mmp.startDragResolution = 5;
+		mapsloaded = false;
+		posCircleLat = -361;
+		posCircleLon = -361; // make them invalid
+		//updateDistance(); // fill Rect with transparent color
+		scaleWanted = 1;
+		mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
+		
+		lastRepaintMapPos = new Point(pref.myAppWidth +1, pref.myAppHeight +1);
+	}
+
+	public void resizeTo(int w,int h) {
+		super.resizeTo(w, h);
+		updateFormSize(w, h);
+	}
+
+	public void updateFormSize(int w, int h) {
+		MapImage.setScreenSize(w, h);
+		bottonImageClose.setLocation(w- bottonImageClose.getWidth()- 5, 5);
+		buttonImageGpsOn.setLocation(w- bottonImageChooseMap.getWidth()-5, bottonImageClose.getHeight() + 20);
+		bottonImageChooseMap.setLocation(10,10);
+		directionArrows.setLocation(w/2-directionArrows.getWidth()/2, 10);
+		buttonImageZoom1to1.setLocation(w - buttonImageZoom1to1.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 - buttonImageZoom1to1.getHeight() -10);
+		buttonImageLens.setLocation(w - buttonImageLens.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 );
+		buttonImageLensActivated.setLocation(w - buttonImageLens.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 );
+		DistanceImage.setLocation(0, h - DistanceImage.getHeight());
+		ScaleImage.setLocation(w - ScaleImage.getWidth(), h - ScaleImage.getHeight());
+		if (mmp.mapImage != null) mmp.mapImage.move(mmp.mapImage.locAlways.x, mmp.mapImage.locAlways.y); // this is necessary to make a new decision if it is still on the screen (and actually mor important because MapImage only now gets to know the screen size) 
+		if (posCircle != null) posCircle.move(posCircle.locAlways.x, posCircle.locAlways.y); // this is necessary to make a new decision if it is still on the screen (and actually mor important because MapImage only now gets to know the screen size) 
+		if (tracks != null) addOverlaySet();
+	}
+
+	boolean loadingMapList = false;
+	/**
+	 * loads the list of maps
+	 * @param mapsPath must not have a trailing end "/"
+	 * @param lat used to create empty maps with correct conversion from lon to meters the latitude must be known
+	 */
+	public void loadMaps(String mapsPath, double lat){
+		if (loadingMapList) return;
+		loadingMapList = true;
+		this.mapPath = mapsPath;
+		Vm.showWait(this, true);
+		resetCenterOfMap();
+		InfoBox inf = new InfoBox("Info", "Loading list of maps...");
+		inf.exec();
+		inf.waitUntilPainted(100);
+		boolean saveGpsIgnoreStatus = dontUpdatePos;
+		dontUpdatePos = true;
+		maps = new MapsList(mapsPath); // this actually loads the maps
+		if (maps.isEmpty()) {
+			(new MessageBox(MyLocale.getMsg(327, "Information"), MyLocale.getMsg(326, "Es steht keine kalibrierte Karte zur Verf?gung \n Bitte w?hlen Sie einen Ma?stab,\n in dem der Track und die markierten Caches angezeigt werden sollen"), MessageBox.OKB)).execute();
+			noMapsAvailable = true;
+		} else noMapsAvailable = false;
+		maps.addEmptyMaps(lat);
+		dontUpdatePos = saveGpsIgnoreStatus;
+		inf.close(0);
+		Vm.showWait(this, false);
+		this.mapsloaded = true;
+		loadingMapList = false;
+	}
+
+	public void updateScale() {
+		ScaleImageGraphics.setColor(ScaleImage.transparentColor);
+		ScaleImageGraphics.fillRect(0, 0, ScaleImage.location.width,ScaleImage.location.height);
+		
+		if (currentMap != null)
+		{
+			float lineLengthMeters = 40 * currentMap.scale;
+			float digits = (float)java.lang.Math.floor( java.lang.Math.log(lineLengthMeters) / java.lang.Math.log(10.0) );
+			lineLengthMeters = (float)java.lang.Math.ceil( lineLengthMeters / (float)java.lang.Math.pow(10, digits) ) * (float)java.lang.Math.pow(10, digits);
+			int lineLengthPixels = (int)java.lang.Math.round( lineLengthMeters / currentMap.scale );
+
+			String lineLengthString;
+			if (lineLengthMeters < 1000)
+			{
+				lineLengthString = Convert.toString((int) lineLengthMeters) + "m";
+			}
+			else
+			{
+				lineLengthString = Convert.toString((int) lineLengthMeters / 1000) + "km";
+			}
+			
+			int backgroundStartX = ScaleImage.location.width - (lineLengthPixels + fm.getTextWidth(lineLengthString) + 7);
+			
+			ScaleImageGraphics.setColor(new Color(250,250,250));
+			ScaleImageGraphics.fillRect(backgroundStartX, 0, ScaleImage.location.width - backgroundStartX ,ScaleImage.location.height);
+
+			ScaleImageGraphics.setPen(new Pen(Color.DarkBlue,Pen.SOLID,3));
+			ScaleImageGraphics.drawLine(backgroundStartX + 2, ScaleImage.location.height / 2, backgroundStartX+2+lineLengthPixels, ScaleImage.location.height / 2);
+			ScaleImageGraphics.setColor(Color.DarkBlue);
+			ScaleImageGraphics.drawText(lineLengthString , backgroundStartX + lineLengthPixels + 5, 0);
+		}
+		
+		ScaleImageGraphics.drawImage(ScaleImage.image,null,Color.LightBlue,0,0,ScaleImage.location.width,ScaleImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+		ScaleImageGraphics.drawImage(ScaleImage.image,null,Color.White,0,0,ScaleImage.location.width,ScaleImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
+	}
+	
+	public void updateDistance(boolean repaint) {
+		DistanceImageGraphics.setColor(DistanceImage.transparentColor);
+		DistanceImageGraphics.fillRect(0, 0, DistanceImage.location.width,DistanceImage.location.height);
+		if (gotoPos != null && posCircleLat >= -360)
+		{
+			double currentDistance = (new CWPoint(gotoPos.lat, gotoPos.lon).getDistance(posCircleLat, posCircleLon));
+			if (currentDistance != lastDistance)
+			{
+				lastDistance = currentDistance;
+				ewe.sys.Double dd = new ewe.sys.Double();
+				dd.set(currentDistance);
+				String d;
+				if (dd.value < 1) {
+					dd.value = dd.value * 1000; 
+					dd.decimalPlaces = 0;
+					d = "Dist: " + dd.toString() + "m";
+					int digits = (int)java.lang.Math.floor( java.lang.Math.log(dd.value) / java.lang.Math.log(10.0) );
+					digits = java.lang.Math.max(0, digits);
+				} 
+				else {
+					dd.decimalPlaces = 2;
+					d = "Dist: " + dd.toString() + "km";
+					int digits = (int)java.lang.Math.floor( java.lang.Math.log(dd.value) / java.lang.Math.log(10.0) );
+					digits = java.lang.Math.max(0, digits);
+				}
+				
+				int backgroundWidth = fm.getTextWidth(d) + 4;
+
+				DistanceImageGraphics.setColor(new Color(250,250,250));
+				DistanceImageGraphics.fillRect(0, 0, backgroundWidth ,DistanceImage.location.height);
+
+				DistanceImageGraphics.setColor(Color.DarkBlue);
+				DistanceImageGraphics.drawText(d, 2, 0);
+				
+				DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.LightBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+				DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.White,0,0,DistanceImage.location.width,DistanceImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
+				if (repaint)
+				{
+					DistanceImage.refreshNow();
+				}
+			}
+		}
+		else
+		{
+			DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.LightBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+			DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.White,0,0,DistanceImage.location.width,DistanceImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
+		}
+	}
+
+	public void forceMapLoad() {
+		forceMapLoad = true;
+		updatePosition(posCircleLat, posCircleLon); // this sets forceMapLoad to false after loading a map
+	}
+
+	public final FormFrame myExec() {
+		// update cache symbols in map
+		running = true;
+		MainTab mainT = Global.mainTab;
+		if (Global.getProfile().selectionChanged) {
+			Global.getProfile().selectionChanged = false;
+			removeAllMapSymbolsButGoto();
+			CacheHolder ch;
+			for (int i=cacheDB.size()-1; i>=0; i--) {
+				ch = (CacheHolder) cacheDB.get(i);
+				if (ch.is_Checked && !ch.is_filtered && ch != mainT.ch) {
+					int ct = Convert.parseInt(ch.type);
+					addSymbol(ch.CacheName, ch, myTableModel.cacheImages[ct], ch.pos.latDec, ch.pos.lonDec);
+				}
+			}
+		}
+		setMarkedCache(mainT.ch);
+		addTrack(myNavigation.curTrack);
+		if (tracks != null && tracks.size() > 0 && ((Track)tracks.get(0)).num > 0) 
+			addOverlaySet(); // show points which where added when MavingMap was not running
+		destChanged(myNavigation.destination);
+		FormFrame ret = exec();
+		return ret;
+	}
+	
+	CacheHolder markedCache = null;
+	public void setMarkedCache(CacheHolder ch) {
+		if (ch == markedCache) return;
+		if (markedCache != null) {
+			removeMapSymbol("selectedCache");
+			if (!markedCache.is_Checked) removeMapSymbol(markedCache);
+		}
+		if (ch != null) {
+			addSymbol("selectedCache", MARK_CACHE_IMAGE, ch.pos.latDec, ch.pos.lonDec);
+			int ct = Convert.parseInt(ch.type);
+			addSymbolIfNecessary(ch.CacheName, ch, myTableModel.cacheImages[ct], ch.pos.latDec, ch.pos.lonDec);
+		}
+		markedCache = ch;
+	}
+	
+	public void addTrack(Track tr) {
+		if (tr == null) return;
+		if (tracks == null) tracks = new Vector();
+		if (tracks.find(tr) >= 0 ) return; // track already in list
+		tracks.add(tr);
+		addOverlaySet();
+	}
+
+	public void addTracks(Track[] trs) {
+		if (trs==null || trs.length == 0) return;
+		for (int i=0; i<trs.length; i++) {
+			addTrack(trs[i]);
+		}
+		addOverlaySet();
+	}
+
+	/**
+	 * adds an 3x3 set of overlays to the map-window which contain the track
+	 * 
+	 * add tracks with addtrack(track) before
+	 */
+
+	public void addOverlaySet() {
+		destroyOverlaySet();
+		if (tracks == null) return; // no tracks
+		try {
+			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
+			addMissingOverlays();
+		} catch (NullPointerException e) {} // hapens if currentmap == null or PosCircle not valid
+		catch (IllegalArgumentException e) {} // happens if screensize is still not known    ---> in both cases creation of Overlayset will be done in updateOverlayPos if tracks != null 
+	}
+
+	public void destroyOverlaySet() {
+		if (TrackOverlays != null) {
+			for (int i=0; i< TrackOverlays.length; i++) {	destroyOverlay(i);	}
+		}
+		Vm.getUsedMemory(true); // call garbage collection
+		Vm.gc();
+	}
+
+
+	public void addMissingOverlays() {
+		if (currentMap == null || posCircleLat < -360 || width == 0 || height == 0) return; // height == 0 happens if this is called before the form ist displayed on the screen
+		if (TrackOverlays == null) {
+			TrackOverlays = new TrackOverlay[9];
+			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
+		}
+		boolean saveGPSIgnoreStatus = dontUpdatePos; // avoid multi-threading problems
+		dontUpdatePos = true;
+		Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft.latDec, TrackOverlaySetCenterTopLeft.lonDec); // TrackOverlay[4] == center of Trackoverlays 
+		//upperleftOf4.x = (upperleftOf4.x + 1* width) % (width * 2) - 1 * width;
+		//upperleftOf4.y = (upperleftOf4.y + 1* height) % (height * 2) - 1 * height;
+		int i;
+		for (int yi=0; yi<3; yi++) {
+			for (int xi=0; xi<3; xi++) {
+				i = yi*3+xi;
+				if (TrackOverlays[i]==null) { 
+					TrackOverlays[i]= new TrackOverlay(ScreenXY2LatLon(upperleftOf4.x+(xi-1)*width, upperleftOf4.y+(yi-1)*height), width, height, currentMap); 
+					TrackOverlays[i].setLocation(width+1, height+1); // outside of the screen will hide it automatically it will get the correct position in upadteOverlayposition 
+					TrackOverlays[i].tracks = this.tracks;
+					TrackOverlays[i].paintTracks();
+					mmp.addImage(TrackOverlays[i]);
+				}
+			}
+		}
+		updateOverlayOnlyPos();
+		if (mmp.mapImage != null) mmp.images.moveToBack(mmp.mapImage);
+		dontUpdatePos = saveGPSIgnoreStatus;
+	}
+
+	private void destroyOverlay(int ov) {
+		if (TrackOverlays[ov] == null) return; 
+		mmp.removeImage(TrackOverlays[ov]);
+		TrackOverlays[ov].free();
+		TrackOverlays[ov]=null;
+	}
+	public void rearangeOverlays() {
+		Point oldp = getXYonScreen(TrackOverlaySetCenterTopLeft.latDec, TrackOverlaySetCenterTopLeft.lonDec);
+		if (TrackOverlays[1].isOnScreen()) { // oben raus
+			TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y - 2* height));
+			destroyOverlay(6);
+			destroyOverlay(7);
+			destroyOverlay(8);
+			mmp.removeImage(TrackOverlays[0]);
+			mmp.removeImage(TrackOverlays[1]);
+			mmp.removeImage(TrackOverlays[2]);
+			TrackOverlays[6]=TrackOverlays[0];
+			TrackOverlays[7]=TrackOverlays[1];
+			TrackOverlays[8]=TrackOverlays[2];
+			mmp.addImage(TrackOverlays[6]);
+			mmp.addImage(TrackOverlays[7]);
+			mmp.addImage(TrackOverlays[8]);
+			TrackOverlays[0] = null;
+			TrackOverlays[1] = null;
+			TrackOverlays[2] = null;
+			destroyOverlay(3);
+			destroyOverlay(4);
+			destroyOverlay(5);
+		} else {
+			if (TrackOverlays[3].isOnScreen()) { // links raus
+				TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y ));
+				destroyOverlay(2);
+				destroyOverlay(5);
+				destroyOverlay(8);
+				mmp.removeImage(TrackOverlays[0]);
+				mmp.removeImage(TrackOverlays[3]);
+				mmp.removeImage(TrackOverlays[6]);
+				TrackOverlays[2]=TrackOverlays[0];
+				TrackOverlays[5]=TrackOverlays[3];
+				TrackOverlays[8]=TrackOverlays[6];
+				mmp.addImage(TrackOverlays[2]);
+				mmp.addImage(TrackOverlays[5]);
+				mmp.addImage(TrackOverlays[8]);
+				TrackOverlays[0] = null;
+				TrackOverlays[3] = null;
+				TrackOverlays[6] = null;
+				destroyOverlay(1);
+				destroyOverlay(4);
+				destroyOverlay(7);
+			} else {
+				if (TrackOverlays[5].isOnScreen()) { // rechts raus
+					TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y ));
+					destroyOverlay(0);
+					destroyOverlay(3);
+					destroyOverlay(6);
+					mmp.removeImage(TrackOverlays[2]);
+					mmp.removeImage(TrackOverlays[5]);
+					mmp.removeImage(TrackOverlays[8]);
+					TrackOverlays[0]=TrackOverlays[2];
+					TrackOverlays[3]=TrackOverlays[5];
+					TrackOverlays[6]=TrackOverlays[8];
+					mmp.addImage(TrackOverlays[0]);
+					mmp.addImage(TrackOverlays[3]);
+					mmp.addImage(TrackOverlays[6]);
+					TrackOverlays[2] = null;
+					TrackOverlays[5] = null;
+					TrackOverlays[8] = null;
+					destroyOverlay(1);
+					destroyOverlay(4);
+					destroyOverlay(7);
+				} else {
+					if (TrackOverlays[7].isOnScreen()) { // unten raus
+						TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y + 2* height));
+						destroyOverlay(0);
+						destroyOverlay(1);
+						destroyOverlay(2);
+						mmp.removeImage(TrackOverlays[6]);
+						mmp.removeImage(TrackOverlays[7]);
+						mmp.removeImage(TrackOverlays[8]);
+						TrackOverlays[0]=TrackOverlays[6];
+						TrackOverlays[1]=TrackOverlays[7];
+						TrackOverlays[2]=TrackOverlays[8];
+						mmp.addImage(TrackOverlays[0]);
+						mmp.addImage(TrackOverlays[1]);
+						mmp.addImage(TrackOverlays[2]);
+						TrackOverlays[6] = null;
+						TrackOverlays[7] = null;
+						TrackOverlays[8] = null;
+						destroyOverlay(3);
+						destroyOverlay(4);
+						destroyOverlay(5);
+					} else { // it is important to test for diagonal only if the other didn't match
+						if (TrackOverlays[0].isOnScreen()) {  // links oben raus
+							TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y - 2* height));
+							destroyOverlay(8);
+							mmp.removeImage(TrackOverlays[0]);
+							TrackOverlays[8]=TrackOverlays[0];
+							mmp.addImage(TrackOverlays[8]);
+							TrackOverlays[0] = null;
+							destroyOverlay(1);
+							destroyOverlay(2);
+							destroyOverlay(3);
+							destroyOverlay(4);
+							destroyOverlay(5);
+							destroyOverlay(6);
+							destroyOverlay(7);
+						} else {
+							if (TrackOverlays[2].isOnScreen()) { // rechts oben raus
+								TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y - 2* height));
+								destroyOverlay(6);
+								mmp.removeImage(TrackOverlays[2]);
+								TrackOverlays[6]=TrackOverlays[2];
+								mmp.addImage(TrackOverlays[6]);
+								TrackOverlays[2] = null;
+								destroyOverlay(0);
+								destroyOverlay(1);
+								destroyOverlay(3);
+								destroyOverlay(4);
+								destroyOverlay(5);
+								destroyOverlay(7);
+								destroyOverlay(8);
+							} else {
+								if (TrackOverlays[6].isOnScreen()) { // links unten raus
+									TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y + 2* height));
+									destroyOverlay(2);
+									mmp.removeImage(TrackOverlays[6]);
+									TrackOverlays[2]=TrackOverlays[6];
+									mmp.addImage(TrackOverlays[2]);
+									TrackOverlays[6] = null;
+									destroyOverlay(0);
+									destroyOverlay(1);
+									destroyOverlay(3);
+									destroyOverlay(4);
+									destroyOverlay(5);
+									destroyOverlay(7);
+									destroyOverlay(8);
+								} else {
+									if (TrackOverlays[8].isOnScreen()) { // rechts unten raus
+										TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y + 2* height));
+										destroyOverlay(0);
+										mmp.removeImage(TrackOverlays[8]);
+										TrackOverlays[0]=TrackOverlays[8];
+										mmp.addImage(TrackOverlays[0]);
+										TrackOverlays[8] = null;
+										destroyOverlay(1);
+										destroyOverlay(2);
+										destroyOverlay(3);
+										destroyOverlay(4);
+										destroyOverlay(5);
+										destroyOverlay(6);
+										destroyOverlay(7);
+									}else
+										for (int i=0; i<TrackOverlays.length; i++) {
+											destroyOverlay(i);
+											TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
+										} // this happens if a position jump occured
+								}}}}}}} // close all IFs
+		Vm.gc(); // call garbage collection
+		Vm.debug("Overlayrearanged"+TrackOverlays.toString());
+	}
+
+	public void ShowLastAddedPoint(Track tr) {
+		if (TrackOverlays == null || tr == null) return;
+		for (int i=0; i<TrackOverlays.length; i++){
+			TrackOverlays[i].paintLastAddedPoint(tr);
+		}
+	}
+
+	public void updateOverlayOnlyPos() {
+		if (TrackOverlays == null || TrackOverlays[4] == null) return;
+		//	Point upperleft = getMapXYPosition();
+		Point posOnScreen;
+		posOnScreen = getXYonScreen(TrackOverlays[4].topLeft.latDec, TrackOverlays[4].topLeft.lonDec);
+		Dimension ws = mmp.getSize(null);
+		int ww = ws.width;
+		int wh = ws.height;
+		//Vm.sleep(100); // this is necessary because the ewe vm ist not multi-threaded and the serial thread also needs time
+		int num, x, y;
+		for (int yi=0; yi<3; yi++) {
+			for (int xi=0; xi<3; xi++) {
+				num = yi*3+xi;
+				x = posOnScreen.x+(xi-1)*ww;
+				y = posOnScreen.y+(yi-1)*wh; 
+				TrackOverlays[num].setLocation(x, y);
+			}
+		}
+	}
+
+	public void updateOverlayPos() {
+		if (tracks == null || tracks.size() == 0) return;
+		if (TrackOverlays == null || TrackOverlays[4] == null) addMissingOverlays();
+		else {
+			updateOverlayOnlyPos();
+			if (TrackOverlays[0].locAlways.x > 0 || TrackOverlays[2].locAlways.x < 0
+					|| TrackOverlays[0].locAlways.y > 0 || TrackOverlays[8].locAlways.y < 0) { // testForNeedToRearange
+				rearangeOverlays();
+				addMissingOverlays();
+				// updateOverlayOnlyPos(); is called from addMissingOverlays 
+			}
+		}
+	}
+
+	/**
+	 * move posCircle to the Center of the Screen
+	 *
+	 */
+	public void resetCenterOfMap() {
+		if (width != 0) {
+			posCircleX = width /2;
+			posCircleY = height /2;
+		} else {
+			posCircleX = pref.myAppWidth/2; // maybe this could /should be repleced to windows size
+			posCircleY = pref.myAppHeight/2;
+		}
+		posCircle.hidden = false;
+		posCircle.move(posCircleX-posCircle.getWidth()/2, posCircleY-posCircle.getHeight()/2); // posCircle.setLocation caused a problem -> hiding the posCircle in some situation
+	}
+
+	public void movePosCircleToLatLon(CWPoint p, boolean repaint) {
+		moveScreenXYtoLatLon(new Point(posCircleX, posCircleY), p, repaint);
+	}
+
+	public void setCenterOfScreen (CWPoint c, boolean repaint) {
+		moveScreenXYtoLatLon(new Point (this.width/2, this.height/2), c, repaint);
+	}
+
+	public void moveScreenXYtoLatLon(Point s, CWPoint c, boolean repaint) {
+		Point mappos = getMapPositionOnScreen();
+		Point onscreenpos = getXYonScreen(c.latDec, c.lonDec);
+		if (mmp != null && mmp.mapImage != null) mmp.mapImage.move(mappos.x - onscreenpos.x + s.x, mappos.y - onscreenpos.y + s.y);
+		mapMoved(s.x - onscreenpos.x, s.y - onscreenpos.y);
+		if (repaint) mmp.repaintNow();
+	}
+
+	/** call this if the map moved on the screen (by dragging)
+	 * this routine will adjust (move accordingly) all other symbols on the screen
+	 * @param diffX
+	 * @param diffY
+	 */
+	public void mapMoved(int diffX, int diffY) {
+		int w = posCircle.getWidth();
+		int h = posCircle.getHeight();
+		int npx = posCircleX-w/2+diffX; 
+		int npy = posCircleY-h/2+diffY;
+		posCircle.move(npx, npy);
+		posCircleX = posCircleX+diffX;
+		posCircleY = posCircleY+diffY;
+		updateSymbolPositions();
+		updateOverlayPos();
+	}
+
+	/**
+	 * get upper left corner of map on window
+	 * this is called when the map needs to be moved / the position of the map is wanted
+	 * the map-position is calculated relativ to posCircle (x,y and lat/lon)
+	 * returns the same as mmp.mapImage.getLocation(mapPos);
+	 * but also works if mmp == null and is used to move the map to the correct point
+	 * @return
+	 */
+	public Point getMapPositionOnScreen() {
+		if (currentMap == null || posCircleLon < -360) return new Point(pref.myAppWidth +1, pref.myAppHeight +1); // in case no calculation is possible return somthing outside of the screen
+		Point mapPos = new Point(); 
+		//if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
+		//else {
+		Point mapposint = currentMap.calcMapXY(posCircleLat, posCircleLon);
+		mapPos.x = posCircleX - mapposint.x;
+		mapPos.y = posCircleY - mapposint.y;
+		//}
+		return mapPos;
+	}
+
+	/**
+	 * 
+	 * @param lat
+	 * @param lon
+	 * @return
+	 */
+	public Point getXYonScreen(double lat, double lon){
+		if (currentMap == null) return null;
+		Point coords = currentMap.calcMapXY(lat, lon);
+		Point mapPos = getMapPositionOnScreen();
+		//		Vm.debug("getXYinMap, posCiLat: "+posCircleLat+"poscLOn: "+ posCircleLon+"gotoLat: "+ lat + "gotoLon: "+ lon+" mapPosX: "+mapPos.x+"mapposY"+mapPos.y);
+		return new Point(coords.x + mapPos.x, coords.y + mapPos.y);
+	}
+
+	public CWPoint ScreenXY2LatLon (int x, int y){
+		Point mapPos = getMapPositionOnScreen();
+		return currentMap.calcLatLon(x - mapPos.x, y - mapPos.y);
+	}
+
+
+	public void updateSymbolPositions() {
+		if (symbols == null) return;
+		Point pOnScreen;
+		MapSymbol symb;
+		int ww = this.width;
+		int wh = this.height;
+		int w, h;
+		for (int i=symbols.size()-1; i>=0; i--) {
+			symb = (MapSymbol)symbols.get(i);
+			pOnScreen = getXYonScreen(symb.lat, symb.lon);
+			w=symb.getWidth();
+			h=symb.getHeight();
+			if (pOnScreen.x+w >= 0 && pOnScreen.x <= ww && pOnScreen.y+h >= 0 &&  pOnScreen.y <= wh) 
+			{
+				symb.properties &= ~mImage.IsInvisible;
+				symb.move(pOnScreen.x-w/2, pOnScreen.y-h/2);
+			}
+			else 
+			{symb.properties |= mImage.IsInvisible;
+			symb.move(30, 30);
+			}
+			//symb.pic.move(ww+1, wh+1);
+		}
+	}
+
+	public MapSymbol addSymbol(String name, String filename, double lat, double lon) {
+		if (symbols==null) symbols=new Vector();
+		MapSymbol ms = new MapSymbol(name, filename, lat, lon);
+		ms.loadImage();
+		ms.properties |= AniImage.AlwaysOnTop;
+		Point pOnScreen = getXYonScreen(lat, lon);
+		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		symbols.add(ms);
+		mmp.addImage(ms);
+		return ms;
+	}
+	
+	public void addSymbolIfNecessary(String name, Object mapObject, Image imSymb, double lat, double lon) {
+		if (findMapSymbol(name) >= 0) return;
+		else addSymbol(name, mapObject, imSymb, lat, lon);
+		
+	}
+		
+	public void addSymbol(String name, Object mapObject, Image imSymb, double lat, double lon) {
+		if (symbols==null) symbols=new Vector();
+		MapSymbol ms = new MapSymbol(name, mapObject, imSymb, lat, lon);
+		ms.properties = AniImage.AlwaysOnTop;
+		Point pOnScreen=getXYonScreen(lat, lon);
+		if (pOnScreen != null) ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		symbols.add(ms);
+		mmp.addImage(ms);
+	}
+
+	public void destChanged(CWPoint d) {
+		if(!running || (d == null && gotoPos == null) || 
+				(d != null && gotoPos != null && d.latDec == gotoPos.lat && d.lonDec == gotoPos.lon)) return;
+		removeGotoPosition();
+		if (d == null || !d.isValid() ) return;
+		gotoPos = addSymbol("goto", "goto_map.png", d.latDec, d.lonDec);
+		//updateDistance(); - this is called from updatePosition
+		forceMapLoad = true;
+		if (this.width != 0) updatePosition(posCircleLat, posCircleLon); // dirty hack: if this.width == 0, then the symbols are not on the screen and get hidden by updateSymbolPositions
+	}
+
+	public void removeGotoPosition() {
+		removeMapSymbol("goto");
+	}
+
+	public CWPoint getGotoPos(){
+		if (gotoPos == null) return null;
+		return new CWPoint(gotoPos.lat, gotoPos.lon);
+	}
+
+	public void removeAllMapSymbolsButGoto(){
+		if (symbols == null) return;
+		for (int i = symbols.size()-1; i >= 0; i--) {
+			mmp.removeImage((MapSymbol)symbols.get(i));
+		}
+		symbols.removeAllElements();
+		if (gotoPos != null) symbols.add(gotoPos);
+	}
+
+	public void removeMapSymbol(String name) {
+		int symbNr = findMapSymbol(name);
+		if (symbNr != -1) removeMapSymbol(symbNr);
+	}
+
+	public void removeMapSymbol(Object obj) {
+		int symbNr = findMapSymbol(obj);
+		if (symbNr != -1) removeMapSymbol(symbNr);
+	}
+
+
+	public void removeMapSymbol(int SymNr) {
+		mmp.removeImage(((MapSymbol)symbols.get(SymNr)));
+		symbols.removeElementAt(SymNr);
+	}
+
+	public int findMapSymbol(String name) {
+		if (symbols == null) return -1;
+		MapSymbol ms;
+		for (int i = symbols.size() -1; i >= 0 ; i--) {
+			ms= (MapSymbol)symbols.get(i);
+			if (ms.name == name) return i;
+		}
+		return -1;
+	}
+	
+	public int findMapSymbol(Object obj) {
+		if (symbols == null) return -1;
+		MapSymbol ms;
+		for (int i = symbols.size() -1; i >= 0 ; i--) {
+			ms= (MapSymbol)symbols.get(i);
+			if (ms.mapObject == obj) return i;
+		}
+		return -1;
+	}
+
+	/**
+	 * Move the map so that the posCircle is at lat/lon
+	 * 
+	 * @param  
+	 */
+	public void updateOnlyPosition(double lat, double lon, boolean updateOverlay){
+		//Point oldMapPos = getMapPositionOnScreen();
+		posCircleLat = lat;
+		posCircleLon = lon;
+		Point mapPos = getMapPositionOnScreen();
+		//Vm.debug("mapx = " + mapx);
+		//Vm.debug("mapy = " + mapy);
+		if (forceMapLoad || (java.lang.Math.abs(lastRepaintMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(lastRepaintMapPos.y - mapPos.y) > 1)) 
+		{
+			lastRepaintMapPos = mapPos;
+			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x, mapPos.y);
+			updateSymbolPositions();
+			updateDistance(false);
+			if (updateOverlay ) updateOverlayPos(); // && TrackOverlays != null
+			mmp.repaintNow(); 
+		}
+		else
+		{
+			updateDistance(true);
+		}
+		//Vm.debug("update only position");			
+	}
+	/**
+	 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
+	 */
+	public void updatePosition(double lat, double lon){
+		if (dontUpdatePos || loadingMapList) return; // avoid multi-threading problems
+		Vm.debug("updatepors, lat: "+lat+" lon: "+lon);
+		if (!mapsloaded) {
+			loadMaps(mapPath, lat);
+			lastCompareX = Integer.MAX_VALUE;
+			lastCompareY = Integer.MAX_VALUE;
+			autoSelectMap = true;
+			setBestMap(lat, lon, true);
+			forceMapLoad = false;
+			return;
+		}
+		updateOnlyPosition(lat, lon, true);
+		if (!autoSelectMap) return;
+		Point mapPos = getMapPositionOnScreen();
+		boolean screenNotCompletlyCovered =  mmp.mapImage == null || (mmp.mapImage != null && ( mapPos.y > 0 || mapPos.x > 0 || mapPos.y+mmp.mapImage.getHeight()<this.height	|| mapPos.x+mmp.mapImage.getWidth()<this.width));
+		if (forceMapLoad || wantMapTest|| screenNotCompletlyCovered) 	{ // if force || want || map doesn't cover the scree completly
+			//Vm.debug("Screen not completly covered by map");
+			if (forceMapLoad || (java.lang.Math.abs(lastCompareX-mapPos.x) > this.width/10 || java.lang.Math.abs(lastCompareY-mapPos.y) > this.height/10)) {
+				// more then 1/10 of screen moved since last time we tried to find a better map
+				lastCompareX = mapPos.x;
+				lastCompareY = mapPos.y;
+				setBestMap(lat, lon, screenNotCompletlyCovered);
+				forceMapLoad = false;
+			}
+		}
+	}
+
+	public void updateGps(int fix) {
+		if (!running || ignoreGps) return;
+		// runMovingMap neccessary in case of multi-threaded Java-VM: ticked could be called during load of mmp 
+		if ((fix > 0) && (myNavigation.gpsPos.getSats()>= 0)) { // TODO is getSats really necessary?
+			directionArrows.setDirections((float)myNavigation.gpsPos.getBearing(myNavigation.destination),
+					(float)myNavigation.skyOrientationDir.lonDec, (float)myNavigation.gpsPos.getBear());
+			setGpsStatus(MovingMap.gotFix);
+			updatePosition(myNavigation.gpsPos.latDec, myNavigation.gpsPos.lonDec);
+			ShowLastAddedPoint(myNavigation.curTrack);
+		}
+		if (fix == 0 && myNavigation.gpsPos.getSats()== 0) 	setGpsStatus(MovingMap.lostFix);
+		if (fix < 0 )	setGpsStatus(MovingMap.noGPSData);
+	}
+	
+	public void gpsStarted() {
+		addTrack(myNavigation.curTrack);
+		ignoreGps = false;
+	}
+	public void gpsStoped() {
+		setGpsStatus(MovingMap.noGPS);
+	}
+
+	int mapChangeModus;
+	float scaleWanted;
+	boolean wantMapTest = true; // if true updateposition calls setBestMap regulary even if the currentmap covers the whole screen
+	public final static int NORMAL_KEEP_RESOLUTION = 1; // keeps the choosen resolution as long as a map is available that overlaps with the screen and with the PosCircle - it changes the resolution if no such map is available. It wil cahnge back to the wanted scale as soon as a map becomes available (through movement of the GPS-receiver)
+	public final static int HIGHEST_RESOLUTION = 2;
+	public final static int HIGHEST_RESOLUTION_GPS_DEST = 3;
+	boolean inBestMap = false; // to avoid multi-threading problems
+
+	/**
+	 * loads the best map for lat/lon according to mapChangeModus
+	 * lat/lon will be at the screen-pos of posCircle
+	 * when posCircle is not on the screen (shifted outside my the user)
+	 * then this routine uses the center of the screen to find the best map
+	 * but anyway the map will be adjusted (moved) relativ to posCircle
+	 * when a better map was found the called method updateposition will set
+	 * posCirleLat/-Lon to lat/lon.
+	 * 
+	 * @param lat
+	 * @param lon
+	 * @param loadIfSameScale false: will not change the map if the better map has the same scale as the current - this is used not to change the map if it covers already the screen completely
+	 * true: willchange the map, regardless of change in scale
+	 */
+	public void setBestMap(double lat, double lon, boolean loadIfSameScale) {
+		if (inBestMap) return;
+		inBestMap = true;
+		Object [] s = getRectForMapChange(lat, lon);
+		CWPoint cll = (CWPoint) s[0]; 
+		Rect screen = (Rect) s[1]; 
+		MapInfoObject newmap = null;
+		//if (mapChangeModus == 0) mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
+		wantMapTest = true;
+		switch (mapChangeModus) {
+		case NORMAL_KEEP_RESOLUTION: 
+			newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, scaleWanted, false);
+			if (newmap == null) newmap = currentMap;
+			if (MapsList.scaleEquals(scaleWanted, newmap)) wantMapTest = false;
+			break;
+		case HIGHEST_RESOLUTION: newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 0.000001f, false); break;
+		case HIGHEST_RESOLUTION_GPS_DEST: 
+			if (gotoPos!= null && GpsStatus != noGPS && posCircleLat>= -90 && posCircleLat <= 90 && posCircleLon >= -360 && posCircleLon <= 360) {
+				newmap = maps.getMapForArea(new CWPoint(posCircleLat, posCircleLon), new CWPoint(gotoPos.lat, gotoPos.lon)); // TODO use home-coos if no gps? - consider start from details panel and from gotopanel
+				if (newmap == null) newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 10000000000000000000000000000000000f, false); // use map with most available overview if no map containing PosCircle and GotoPos is available
+			}
+			//	either Goto-Pos or GPS-Pos not set
+			else newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 0.000001f, false); 
+			break;
+		default: (new MessageBox("Error", "Programmfehler: \nillegal mapChangeModus: " + mapChangeModus, MessageBox.OKB)).execute(); break;
+		}
+		if ( newmap != null && (currentMap == null || !currentMap.mapName.equals(newmap.mapName)) ) {
+			if (loadIfSameScale || !MapsList.scaleEquals(currentMap.scale / currentMap.zoomFactor, newmap) ) {
+				Vm.debug("better map found");
+				setMap(newmap, lat, lon);
+				moveScreenXYtoLatLon(new Point(screen.x, screen.y), cll, true);
+			}
+			inBestMap = false;
+			return;
+		}
+		if (currentMap == null && newmap == null) {
+			(new MessageBox("Information", "F?r die aktuelle Position steht keine Karte zur Verf?ng, bitte w?hlen Sie eine manuell", MessageBox.OKB)).execute();
+			posCircleLat = cll.latDec;
+			posCircleLon = cll.lonDec; // choosemap calls setmap with posCircle-coos
+			while (currentMap == null) {
+				mmp.chooseMap(); // force the user to select a scale // TODO empty maps on top?
+				if (currentMap == null) (new MessageBox("Error", "Moving map cannot run without a map - please select one. \n You can select an empty map", MessageBox.OKB)).execute();
+			}
+		}
+		inBestMap = false;
+	}
+
+	public void setResModus (int modus) {
+		scaleWanted = currentMap.scale;
+		if (mapChangeModus == modus) return;
+		mapChangeModus = modus;
+		if (modus != NORMAL_KEEP_RESOLUTION) setBestMap(posCircleLat, posCircleLon, true);
+	}
+	/**
+	 * method to get a point on the screen which must be included in the map
+	 * the map methods are looking for. If the poscircle is on the screen this will be 
+	 * that point. If it is outside then the center of the screen will be used.
+	 * 
+	 * returns [0] = CWPoint of that point, [1] Rect describing the screen around it 
+	 * @param lat
+	 * @param lon
+	 * @return
+	 */
+	public Object[] getRectForMapChange(double lat, double lon) {
+		int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
+		int h = (height != 0 ? height : pref.myAppHeight);
+		int x, y;
+		CWPoint cll;
+		if (posCircleX >= 0 && posCircleX <= w && posCircleY >= 0 && posCircleY <= h) {
+			x = posCircleX; // posCircle is inside the screen
+			y = posCircleY; // TODO eigentlich interessiert, ob nach dem evtl. Kartenwechsel PosCircle on Screen ist. So wie es jetzt ist, kann 2mal der gleiche Aufruf zum laden unterschiedlicher Karten f?hren, wenn voher PosCircle nicht auf dem SChirm war, nach dem ersten Laden aber schon.
+			cll = new CWPoint(lat, lon);
+		} else { // when posCircle out of screen - use center of screen as point which as to be included in the map
+			cll = ScreenXY2LatLon(w/2, h/2);
+			x = w/2;
+			y = h/2;
+		} 
+		Object[] ret = new Object[2];
+		ret[0] = cll;
+		ret[1] = new Rect(x, y, w, h);
+		return ret; 
+	}
+
+	/**
+	 * 
+	 * @param betterOverview true: getmap with better overview
+	 * @return
+	 */
+	public void loadMoreDetailedMap(boolean betterOverview){
+		Object [] s = getRectForMapChange(posCircleLat, posCircleLon);
+		CWPoint cll = (CWPoint) s[0]; 
+		Rect screen = (Rect) s[1]; 
+		//Rect screen = new Rect(posCircleX, posCircleY, (width != 0 ? width : pref.myAppWidth), (height != 0 ? height : pref.myAppHeight));
+		MapInfoObject m = maps.getMapChangeResolution(cll.latDec, cll.lonDec, screen, currentMap.scale / currentMap.zoomFactor, !betterOverview);
+		if (m != null) {
+			boolean saveGpsIgnStatus = dontUpdatePos;
+			dontUpdatePos = true;
+			setMap(m, posCircleLat, posCircleLon);
+			setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+			dontUpdatePos = saveGpsIgnStatus;
+		}
+		else (new MessageBox("Error", "No "+ (betterOverview ? "less" : "more") + " deteiled map available", MessageBox.OKB)).execute();
+	}
+
+	public void loadMapForAllCaches(){
+		Area sur = Global.getProfile().getSourroundingArea(true);
+		if (sur == null) {
+			(new MessageBox("Error", "Keine  Caches mit H?ckchen ausgew?hlt", MessageBox.OKB)).execute();
+			return;
+		}
+		MapInfoObject newmap = maps.getMapForArea(sur.topleft, sur.buttomright);
+		if (newmap == null ) { // no map that includs all caches is available -> load map with lowest resolution
+			Object [] s = getRectForMapChange(posCircleLat, posCircleLon);
+			CWPoint cll = (CWPoint) s[0]; 
+			Rect screen = (Rect) s[1]; 
+			newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, Float.MAX_VALUE -1, false);
+		}
+		boolean saveGpsIgnStatus = dontUpdatePos;
+		dontUpdatePos = true;
+		setMap(newmap, posCircleLat, posCircleLon);
+		setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+		dontUpdatePos = saveGpsIgnStatus;
+	}
+
+	public void setGpsStatus (int status) {
+		if (status == GpsStatus) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
+		GpsStatus = status;
+		dontUpdatePos = false;
+		ignoreGps = false;
+		switch (status) {
+		case noGPS: 	{ posCircle.change(null); ignoreGps = true; break; }
+		case gotFix:    { posCircle.change(statusImageHaveSignal); break; }
+		case lostFix:   { posCircle.change(statusImageNoSignal); break; }
+		case noGPSData: { posCircle.change(statusImageNoGps); break; }
+		}
+		posCircle.refreshNow();
+	}
+
+	public void SnapToGps() {
+		resetCenterOfMap();
+		dontUpdatePos = false;
+		ignoreGps = false;
+		lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
+		lastCompareY = Integer.MAX_VALUE;
+		autoSelectMap = true;
+		forceMapLoad = true;
+		showMap();
+		if (myNavigation.gpsPos.Fix <=0) updatePosition(posCircleLat, posCircleLon);
+		else updateGps(myNavigation.gpsPos.getFix());
+	}
+
+	/** sets and displays the map
+	 * 
+	 * @param newmap
+	 * @param lat move map so that lat/lon is in the center / -361: don't adust to lat/lon
+	 * @param lon -361: don't adust to lat/lon
+	 */
+	public void setMap(MapInfoObject newmap, double lat, double lon) {
+		if (currentMap != null && newmap.mapName.equals(currentMap.mapName) && !forceMapLoad) { // note: newmap.mapName == currentMap.mapName won't work because they are different String containing the same text 
+			updateOnlyPosition(lat, lon, true); 
+			return;
+		}
+		Vm.showWait(true);
+		boolean saveIgnoreStatus;
+		saveIgnoreStatus = dontUpdatePos;
+		dontUpdatePos = true;  // make updatePosition ignore calls during loading new map
+		InfoBox inf;
+		inf = new InfoBox("Info", "Loading map...");
+		inf.show();
+		inf.waitUntilPainted(100);
+		try {
+			this.currentMap = newmap; 
+			this.title = currentMap.mapName;
+			lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
+			lastCompareY = Integer.MAX_VALUE;
+			if (mmp.mapImage != null ) {
+				//Vm.debug("free: "+Vm.getUsedMemory(false)+"classMemory: "+Vm.getClassMemory()+ "after garbage collection: "+Vm.getUsedMemory(false));
+				mmp.removeImage(mmp.mapImage); mmp.mapImage.free(); mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+
+				//Vm.debug("free: "+Vm.getUsedMemory(false)+"classMemory: "+Vm.getClassMemory()+ "after garbage collection: "+Vm.getUsedMemory(false));
+				Vm.getUsedMemory(true); // calls the garbage collection
+			} // give memory free before loading the new map to avoid out of memory error
+			String ImageFilename = currentMap.getImageFilename(); 
+			if (ImageFilename == null ) {
+				mmp.mapImage = new MapImage();
+				(new MessageBox("Error", "Could not find image associated with: \n"+currentMap.fileNameWFL, MessageBox.OKB)).execute();
+			}
+			else { 
+				if (ImageFilename.length() > 0) mmp.mapImage = new MapImage(ImageFilename); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
+				else mmp.mapImage = new MapImage();
+			}
+			mapImage1to1 = mmp.mapImage;
+			mmp.mapImage.properties = mmp.mapImage.properties | AniImage.IsMoveable;
+			if (mapHidden) mmp.mapImage.hide();
+			mmp.mapImage.move(0,0);
+			mmp.addImage(mmp.mapImage);
+			mmp.images.moveToBack(mmp.mapImage);
+			addOverlaySet();
+			forceMapLoad = true; // forces updateOnlyPosition to redraw
+			updateOnlyPosition(lat, lon, false);
+			forceMapLoad = false;
+			directionArrows.setMap(currentMap);
+			updateScale();
+			inf.close(0);  // this doesn't work in a ticked-thread in the ewe-vm. That's why i made a new mThread in gotoPanel for ticked
+			Vm.showWait(false);
+			dontUpdatePos = saveIgnoreStatus;
+		} catch (IllegalArgumentException e) { // thrown by new AniImage() in ewe-vm if file not found;
+			if (mmp.mapImage != null) {
+				mmp.removeImage(mmp.mapImage); 
+				mmp.mapImage.free();
+				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+			}
+			addOverlaySet();
+			updateOnlyPosition(lat, lon, false);
+			inf.close(0);
+			Vm.showWait(false);
+			(new MessageBox("Error", "Could not load map: "+ newmap.getImageFilename(), MessageBox.OKB)).execute();
+			dontUpdatePos = saveIgnoreStatus;
+		} catch (OutOfMemoryError e) {
+			if (mmp.mapImage != null) {
+				mmp.removeImage(mmp.mapImage); 
+				mmp.mapImage.free();
+				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+			}
+			addOverlaySet();
+			updateOnlyPosition(lat, lon, false);
+			inf.close(0);
+			Vm.showWait(false);
+			(new MessageBox("Error", "Not enough memory to load map: "+ newmap.getImageFilename()+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
+			dontUpdatePos = saveIgnoreStatus;
+		}catch (SystemResourceException e) {
+			if (mmp.mapImage != null) {
+				mmp.removeImage(mmp.mapImage); 
+				mmp.mapImage.free();
+				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+			}
+			addOverlaySet();
+			updateOnlyPosition(lat, lon, false);
+			inf.close(0);
+			Vm.showWait(false);
+			(new MessageBox("Error", "Not enough ressources to load map: "+ newmap.getImageFilename()+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
+			dontUpdatePos = saveIgnoreStatus;
+		}
+	}
+
+	public void hideMap() {
+		if (mmp != null && mmp.mapImage != null)
+			mmp.mapImage.hide();
+		mapHidden = true;
+		repaintNow();
+	}
+
+	public void showMap() {
+		if (mmp != null && mmp.mapImage != null) mmp.mapImage.unhide();
+		mapHidden = false;
+		repaintNow();
+	}
+
+	public void setZoomingMode() {
+		mmp.removeImage(buttonImageLens);
+		mmp.addImage(buttonImageLensActivated);
+		repaintNow();
+		zoomingMode = true;
+	}
+
+	/**
+	 * zommes in if w>0 and out if w<0
+	 * @param firstclickpoint
+	 * @param w
+	 * @param h
+	 */
+	public void zoomScreenRect(Point firstclickpoint, int w, int h) {
+		int newImageWidth = (int) (this.width *  (this.width  < 481 ? 2 : 1.6)); // (maximal) size of the zoomed image 
+		int newImageHeight= (int) (this.height * (this.width < 481 ?  2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors 
+		CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y + h/2);
+		float zoomFactor;
+		if (w > 0)  zoomFactor = (float)this.width / (float)w; // zoom in
+		else {
+			w = java.lang.Math.abs(w);
+			firstclickpoint.x = firstclickpoint.x - w; // make firstclickedpoint the upper left corner
+			zoomFactor = (float)w / (float)this.width;
+		}
+		if (h < 0) {
+			h = java.lang.Math.abs(h);
+			firstclickpoint.y = firstclickpoint.y - h;
+		}
+		// calculate rect in unzoomed image in a way that the center of the new image is the center of selected area but give priority to the prefered image size of the scaled image
+		newImageHeight = (int) (newImageHeight / zoomFactor / currentMap.zoomFactor);
+		newImageWidth = (int) (newImageWidth / zoomFactor / currentMap.zoomFactor);
+		Point mappos = getMapPositionOnScreen();
+		int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w/2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth /2);
+		int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h/2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight /2);
+		Rect newImageRect = new Rect(xinunscaledimage , yinunscaledimage, newImageWidth, newImageHeight);
+		if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
+		{
+			// try to avoid overlapping by shifting
+			if (newImageRect.x < 0) 
+				newImageRect.x = 0; // align left if left overlapping
+			if (newImageRect.y < 0) 
+				newImageRect.y = 0;
+			if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) 
+				newImageRect.x = mapImage1to1.getWidth()- newImageWidth; // align right if right overlaping
+			if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight()) 
+				newImageRect.y = mapImage1to1.getHeight()- newImageHeight;
+			// crop if after shifting still overlapping
+			if (newImageRect.x < 0) 
+				newImageRect.x = 0;
+			if (newImageRect.y < 0) 
+				newImageRect.y = 0;
+			if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) 
+				newImageRect.width = mapImage1to1.getWidth() - newImageRect.x;
+			if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight()) 
+				newImageRect.height= mapImage1to1.getHeight()- newImageRect.y;
+		}
+		zoomFromUnscaled(zoomFactor * currentMap.zoomFactor, newImageRect, center);
+	}
+
+	public void zoom1to1() {
+		CWPoint center = ScreenXY2LatLon(this.width /2 , this.height/2);
+		if (mapImage1to1 != null) zoomFromUnscaled(1, new Rect(0,0,mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
+		else zoomFromUnscaled(1, new Rect(0,0, 1,1), center);
+	}
+
+	/**
+	 * do the actual scaling
+	 * @param zoomFactor relative to original image
+	 * @param newImageRect Rect in the 1:1 image that contains the area to be zoomed into
+	 * @param center
+	 */		
+	public void zoomFromUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
+		Vm.showWait(this, true);
+		boolean savegpsstatus = dontUpdatePos;
+		if (mapImage1to1 != null) {
+			dontUpdatePos = true; // avoid multi-thread problems
+			int saveprop = AniImage.IsMoveable;
+			MapImage tmp = null; // = mmp.mapImage;
+			if (mmp.mapImage != null) {
+				tmp = mmp.mapImage;
+				saveprop = mmp.mapImage.properties;
+				mmp.removeImage(mmp.mapImage);
+				if (mmp.mapImage != mapImage1to1) {
+					mmp.mapImage.free();
+					mmp.mapImage = null;
+				} else tmp = mapImage1to1;
+			}
+			Vm.getUsedMemory(true);
+			try {
+				if (zoomFactor == 1) tmp = mapImage1to1;
+				else tmp = new MapImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor), (int)(newImageRect.height*zoomFactor), newImageRect, 0));
+				currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
+			} catch (OutOfMemoryError e) {
+				(new MessageBox("Error", "Out of memory error", MessageBox.OKB)).execute();
+				//tmp = mapImage1to1;
+			} //if (tmp != null) currentMap.zoom();}
+			Vm.getUsedMemory(true);
+			mmp.mapImage = tmp; // use unscaled or no image in case of OutOfMemoryError
+			mmp.mapImage.properties = saveprop;
+			if (mapHidden) mmp.mapImage.hide();
+			mmp.addImage(mmp.mapImage);
+			mmp.images.moveToBack(mmp.mapImage);
+			if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
+			{
+				Point mappos = getMapPositionOnScreen();
+				mmp.mapImage.move(mappos.x,mappos.y);
+			}
+		} else // no map image loaded 
+		{ currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y); }
+		// scaleWanted = currentMap.scale; use this if you want to change automatically to a map scale that best fits the zooming
+		destroyOverlaySet();
+		Vm.getUsedMemory(true); // call garbage collection
+		setCenterOfScreen(center, false);
+		addOverlaySet();
+		updateScale();
+		this.repaintNow();
+		Vm.showWait(this, false);
+		dontUpdatePos = savegpsstatus;
+	}
+
+	/*	public void gotFocus(int how) {
+		super.gotFocus(how);
+		Dimension ws = getSize(null);
+		onWindowResize(ws.width, ws.height);
+		Vm.debug(ws.width + " h: "+ws.height);
+		this.setPreferredSize(width, height)
+	}
+	 */
+	public void onEvent(Event ev){
+		if(ev instanceof FormEvent && (ev.type == FormEvent.CLOSED )){
+			running = false;
+		}  
+		if(ev instanceof KeyEvent && ev.target == this && ((KeyEvent)ev).key == IKeys.ESCAPE) {
+			this.close(0);
+			ev.consumed = true;
+		}
+		super.onEvent(ev);
+	}
+}
+
+/**
+ *	Class to display the map bitmap and to select another bitmap to display.
+ */
+class MovingMapPanel extends InteractivePanel implements EventListener {
+	Menu kontextMenu;
+	MenuItem gotoMenuItem = new MenuItem("Goto here$g", 0, null);
+	MenuItem newWayPointMenuItem = new MenuItem("Create new Waypoint here$n", 0, null);;
+	MenuItem openCacheDescMenuItem,addCachetoListMenuItem;
+	
+	MenuItem miLuminary[];
+
+	Menu mapsMenu;
+	MenuItem selectMapMI = new MenuItem("Select a map manually$s", 0, null);
+	MenuItem changeMapDirMI = new MenuItem("Change map directory$c", 0, null);
+	MenuItem showMapMI = new MenuItem("Show map", 0, null);
+	MenuItem hideMapMI = new MenuItem("Hide map", 0, null);
+	// automatic
+	MenuItem mapChangeModusMI = new MenuItem("Modus for automatic map change", MenuItem.Separator, null);;
+	MenuItem highestResGpsDestMI = new MenuItem("Highest res. containing dest. & cur. position", 0, null); //immer h?chste Aufl?sung w?hlen, die akt. Pos. und Ziel enthalten 
+	MenuItem highestResolutionMI = new MenuItem("Highest resolution", 0, null); //immer h?chste Aufl?sung w?hlen 
+	MenuItem keepManResolutionMI = new MenuItem("Keep manual resolution", 0, null); // manuell gew?hlte Aufl?sung beibehalten  
+	// manuell
+	MenuItem mapChangeResMI = new MenuItem("Change resolution manually", MenuItem.Separator, null);;
+	MenuItem AllCachesResMI = new MenuItem("Load a map containing all marked caches", 0, null); // Karte w?hlen, die alle markierten Caches enth?lt  
+	MenuItem moreDetailsMI = new MenuItem("Load a map with more details", 0, null); // detailreichere Karte laden 
+	MenuItem moreOverviewMI = new MenuItem("Load a map for a better overview", 0, null); // Karte mit mehr ?bersicht w?hlen  
+	// move map to
+	MenuItem moveToMI = new MenuItem("Move map to an load map", MenuItem.Separator, null);;
+	MenuItem moveToDestMI = new MenuItem("move to goto point", 0, null); //* Karte zum Ziel verschieben (und ggf. entsprechende Karte laden) 
+	MenuItem moveToGpsMI = new MenuItem("move to GPS position", 0, null);   
+	MenuItem moveToCenterMI = new MenuItem("move to Center", 0, null);   
+
+	CacheHolder clickedCache;
+	MovingMap mm;
+	MapImage mapImage;
+	Point saveMapLoc = null;
+	boolean saveGpsIgnoreStatus;
+	boolean paintingZoomArea;
+	ImageList saveImageList = null;
+	int lastZoomWidth , lastZoomHeight;
+	public MovingMapPanel(MovingMap f){
+		this.mm = f;
+		set(Control.WantHoldDown, true); // want to get simulated right-clicks
+	}
+
+	public boolean imageBeginDragged(AniImage which,Point pos) {
+		if (mm.zoomingMode == true) { // zoom
+//			saveMapLoc = pos;
+			//		saveGpsIgnoreStatus = mm.ignoreGps;
+			//	mm.ignoreGps = true;
+			return false;
+		}
+		// move (drag) map
+		//if (!(which == null || which == mapImage || which instanceof TrackOverlay || which == mm.directionArrows) ) return false;
+		saveGpsIgnoreStatus = mm.dontUpdatePos; 
+		mm.dontUpdatePos = true;
+		saveMapLoc = pos;
+		bringMapToTop();
+		if (mapImage.isOnScreen() && !mapImage.hidden ) return super.imageBeginDragged(mapImage, pos);
+		else return super.imageBeginDragged(null, pos);
+	}
+
+	public boolean imageNotDragged(ImageDragContext dc,Point pos){
+		boolean ret = super.imageNotDragged(dc, pos);
+		bringMaptoBack();
+		if (dc.image == null) moveMap(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
+		else mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
+		mm.dontUpdatePos = saveGpsIgnoreStatus;
+		this.repaintNow();
+		return ret;
+	}
+
+	public void onPenEvent(PenEvent ev) {
+		if (!mm.zoomingMode && ev.type == PenEvent.PEN_DOWN) {
+			saveMapLoc = new Point (ev.x, ev.y);
+		}
+		if (mm.zoomingMode && ev.type == PenEvent.PEN_DOWN) {
+			saveGpsIgnoreStatus = mm.dontUpdatePos;
+			mm.dontUpdatePos = true;
+			saveMapLoc = new Point (ev.x, ev.y);
+			paintingZoomArea = true;
+			mm.zoomingMode = true;
+		} 
+		if (!mm.zoomingMode && ev.type == PenEvent.PEN_DOWN && ev.modifiers == PenEvent.RIGHT_BUTTON) {
+			penHeld(new Point (ev.x, ev.y));
+		}
+		if (mm.zoomingMode && ev.type == PenEvent.PEN_UP ) {
+			paintingZoomArea = false;
+			mm.zoomingMode = false;
+			mm.dontUpdatePos = saveGpsIgnoreStatus;
+			removeImage(mm.buttonImageLensActivated);
+			addImage(mm.buttonImageLens);
+			if (java.lang.Math.abs(lastZoomWidth) < 15 || java.lang.Math.abs(lastZoomHeight) < 15)  {
+				repaintNow();
+				return; // dont make to big zoom jumps - it is most probable not an intentional zoom
+			}
+			mm.zoomScreenRect(saveMapLoc, lastZoomWidth, lastZoomHeight);
+		}
+
+		if (mm.zoomingMode && paintingZoomArea && (ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {
+			int left, top;
+			Graphics dr = this.getGraphics();
+			if (lastZoomWidth < 0)left = saveMapLoc.x + lastZoomWidth;
+			else left = saveMapLoc.x;
+			if (lastZoomHeight < 0)top = saveMapLoc.y + lastZoomHeight;
+			else top = saveMapLoc.y;
+			left -= 2;
+			top -= 2;
+			if (top < 0) top = 0;
+			if (left < 0) left = 0;
+			this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth)+4, java.lang.Math.abs(lastZoomHeight)+4));
+			lastZoomWidth = ev.x - saveMapLoc.x;
+			lastZoomHeight =  ev.y - saveMapLoc.y;
+			if (lastZoomWidth < 0) left = saveMapLoc.x + lastZoomWidth;
+			else left = saveMapLoc.x;
+			if (lastZoomHeight < 0)top = saveMapLoc.y + lastZoomHeight;
+			else top = saveMapLoc.y;
+			dr.setPen(new Pen(new Color(255,0,0),Pen.SOLID,3));
+			dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight), 0); // bug in ewe: thickness parameter is ignored
+		}
+		super.onPenEvent(ev);
+	}
+
+	private void bringMapToTop() {
+		if (mapImage == null || mapImage.hidden) {
+			saveImageList = null;
+			return;
+		}
+		saveImageList = new ImageList();
+		saveImageList.copyFrom(images);
+		images.removeAllElements();
+		images.add(mapImage);
+	}
+	private void bringMaptoBack() {
+		if (saveImageList == null) return;
+		images = saveImageList;
+		saveImageList = null;
+	}
+
+	public void moveMap(int diffX, int diffY) {
+		Point p = new Point();
+		if (mapImage!= null) {
+			p = mapImage.locAlways;
+			mapImage.move(p.x+diffX,p.y+diffY);
+			//		if (mm.mapHidden) mapImage.properties |= AniImage.IsInvisible; // this is neccesarry because move will unhide the map if the coos show that the map is on the screen
+		}
+		mapMoved(diffX, diffY);
+	}
+
+	public void mapMoved(int diffX, int diffY){
+		mm.mapMoved(diffX, diffY);
+		this.repaintNow();
+	}
+
+	public void doPaint(Graphics g,Rect area) {
+		super.doPaint(g, area);
+		if (mm.gotoPos != null) {
+			Point dest = mm.getXYonScreen(mm.gotoPos.lat, mm.gotoPos.lon);
+			g.setPen(new Pen(Color.DarkBlue, Pen.SOLID, 3));
+			g.drawLine(mm.posCircleX, mm.posCircleY, dest.x, dest.y);
+		}
+	}
+
+	public void chooseMap() {
+		CWPoint gpspos;
+		if (mm.myNavigation.gpsPos.Fix > 0) gpspos = new CWPoint(mm.myNavigation.gpsPos.latDec, mm.myNavigation.gpsPos.lonDec);
+		else gpspos = null;
+		ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos(), mm.currentMap);
+		if(l.execute() == FormBase.IDOK){
+//			Vm.debug("Trying map: " + l.selectedMap.fileName);
+			mm.autoSelectMap = false;
+			if (l.selectedMap.inBound(mm.posCircleLat, mm.posCircleLon) || l.selectedMap.getImageFilename().length()==0) {
+				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon);
+				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+				mm.ignoreGps = false;
+			} else {
+				mm.setGpsStatus(MovingMap.noGPS);
+				mm.ignoreGps = true;
+				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon); 
+				if (mm.currentMap.fileNameWFL.length() > 0)
+					mm.setCenterOfScreen(l.selectedMap.center, true); // if map has an image
+				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+				//Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
+				//double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4]; 
+				//mm.posCircleX = 0; // place map to the upper left corner of windows
+				//mm.posCircleY = 0;
+				//mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
+			}
+		}
+	}
+
+	/**
+	 *	Method to react to user.
+	 */
+	public void imageClicked(AniImage which, Point pos){
+		if (which == mm.bottonImageChooseMap){
+			mapsMenu = new Menu();
+			mapsMenu.addItem(selectMapMI);
+			mapsMenu.addItem(changeMapDirMI);
+			if (!mm.noMapsAvailable) 
+			{
+				if (mm.mapHidden) mapsMenu.addItem(showMapMI);
+				else mapsMenu.addItem(hideMapMI);
+			}
+
+			// automatic
+			highestResGpsDestMI.modifiers &= ~MenuItem.Checked;
+			highestResolutionMI.modifiers &= ~MenuItem.Checked;
+			keepManResolutionMI.modifiers &= ~MenuItem.Checked;
+			switch (mm.mapChangeModus) {
+			case MovingMap.NORMAL_KEEP_RESOLUTION: keepManResolutionMI.modifiers |= MenuItem.Checked; break;   
+			case MovingMap.HIGHEST_RESOLUTION: highestResolutionMI.modifiers |= MenuItem.Checked; break;   
+			case MovingMap.HIGHEST_RESOLUTION_GPS_DEST: highestResGpsDestMI.modifiers |= MenuItem.Checked; break;   
+			}
+			mapsMenu.addItem(mapChangeModusMI);
+			mapsMenu.addItem(highestResGpsDestMI);
+			mapsMenu.addItem(highestResolutionMI);
+			mapsMenu.addItem(keepManResolutionMI);
+			// manuell
+			mapsMenu.addItem(mapChangeResMI);
+			mapsMenu.addItem(AllCachesResMI);
+			mapsMenu.addItem(moreDetailsMI);
+			mapsMenu.addItem(moreOverviewMI);
+			// move map to
+			mapsMenu.addItem(moveToMI);
+			if (mm.gotoPos != null) moveToDestMI.modifiers &= ~MenuItem.Disabled;
+			else moveToDestMI.modifiers |= MenuItem.Disabled;
+			mapsMenu.addItem(moveToDestMI);
+			if (Global.getPref().curCentrePt.isValid()) moveToCenterMI.modifiers &= ~MenuItem.Disabled;
+			else moveToCenterMI.modifiers |= MenuItem.Disabled;
+			mapsMenu.addItem(moveToCenterMI);
+			mapsMenu.addItem(moveToGpsMI);
+
+			//m.set(Menu., status)
+			mapsMenu.exec(this, new Point(which.location.x, which.location.y), this);
+		}
+		if (which == mm.buttonImageGpsOn) {
+			this.snapToGps();
+		}
+		if (which == mm.buttonImageLens) {
+			mm.setZoomingMode();
+			lastZoomWidth = 0;
+			lastZoomHeight = 0;
+		}
+		if (which == mm.buttonImageZoom1to1) {
+			mm.zoom1to1(); 
+		}
+		if (which == mm.bottonImageClose) {
+			WindowEvent tmp = new WindowEvent();
+			tmp.type = WindowEvent.CLOSE;
+			mm.postEvent(tmp);
+		}
+	}
+
+	public void snapToGps() {
+		mm.myNavigation.startGps();
+		mm.SnapToGps();
+	}
+
+	public void penHeld(Point p){
+		//	if (!menuIsActive()) doMenu(p);
+		if (!mm.zoomingMode) { 
+			//( (ev.type == PenEvent.PEN_DOWN) && ((PenEvent)ev).modifiers == PenEvent.RIGHT_BUTTON)
+			//|| ((ev.type == PenEvent.RIGHT_BUTTON) ) )) ---> these events are not posted --> this overridering is the only solution 
+			kontextMenu = new Menu();
+			if ( !(mm.directionArrows.onHotArea(p.x, p.y)) ) {
+				kontextMenu.addItem(gotoMenuItem);
+				kontextMenu.addItem(newWayPointMenuItem);
+				AniImage clickedOnImage = images.findHotImage(p);
+				if (clickedOnImage != null && clickedOnImage instanceof MapSymbol) {
+					clickedCache = ((CacheHolder)((MapSymbol)clickedOnImage).mapObject);
+					if (clickedCache != null) openCacheDescMenuItem = new MenuItem("Open '"+(clickedCache.CacheName.length()>0?clickedCache.CacheName:clickedCache.wayPoint)+"'$o"); // clickedCache == null can happen if clicked on the goto-symbol
+					kontextMenu.addItem(openCacheDescMenuItem);
+					if (clickedCache !=null && Global.mainForm.cacheListVisible) { 
+						addCachetoListMenuItem = new MenuItem(MyLocale.getMsg(199,"Add to cachetour"));
+						kontextMenu.addItem(addCachetoListMenuItem);
+					}
+				}
+			}
+			else {			
+				miLuminary = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
+
+				for (int i=0; i<SkyOrientation.LUMINARY_NAMES.length; i++) {
+					kontextMenu.addItem(miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i)));
+					if (i == mm.myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
+					else miLuminary[i].modifiers &= MenuItem.Checked;
+				}
+			}
+			kontextMenu.exec(this, new Point(p.x, p.y), this);
+		}
+	}
+
+	public void onEvent(Event ev){
+		if (mapsMenu != null && ev instanceof PenEvent && ev.type == PenEvent.PEN_DOWN && ev.target == this) {mapsMenu.close(); mapsMenu = null;}
+		if (kontextMenu != null && ev instanceof PenEvent && ev.type == PenEvent.PEN_DOWN && ev.target == this) {kontextMenu.close(); kontextMenu = null; }
+
+		if (ev instanceof MenuEvent) { 
+			if (ev.target == mapsMenu) {
+				if (ev.type == MenuEvent.ABORTED || ev.type == MenuEvent.CANCELLED || ev.type == MenuEvent.FOCUS_OUT) mapsMenu.close(); // TODO menuIsActive() benutzen? 
+				if (ev.type == MenuEvent.SELECTED ) {
+					MenuItem action = (MenuItem) mapsMenu.getSelectedItem(); 
+					if (mapsMenu.getSelectedItem() != null) {
+						//maps
+						if (action == selectMapMI)	{ 
+							mapsMenu.close();
+							chooseMap();
+						}
+						if (action == changeMapDirMI)	{
+							mapsMenu.close();
+							FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir+"maps");
+							fc.addMask("*.wfl");
+							fc.setTitle((String)MyLocale.getMsg(4200,"Select map directory:"));
+							if(fc.execute() != FileChooser.IDCANCEL){
+								mm.loadMaps(fc.getChosen().toString(), mm.posCircleLat);
+								mm.forceMapLoad();
+							}
+						}
+						//dont show map
+						if (action == hideMapMI) {
+							mapsMenu.close();
+							mm.hideMap();
+						}
+						// show map
+						if (action == showMapMI) {
+							mapsMenu.close();
+							mm.showMap();
+						}
+						// map change modus
+						if (action == highestResGpsDestMI) {
+							mapsMenu.close();
+							mm.setResModus(MovingMap.HIGHEST_RESOLUTION_GPS_DEST);
+						}
+						if (action == highestResolutionMI) {
+							mapsMenu.close();
+							mm.setResModus(MovingMap.HIGHEST_RESOLUTION);
+						}
+						if (action == keepManResolutionMI) {
+							mapsMenu.close();
+							mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+						}
+						// manually change map resolution
+						if (action == moreDetailsMI) {
+							mapsMenu.close();
+							mm.loadMoreDetailedMap(false);
+						} 
+						if (action == moreOverviewMI) {
+							mapsMenu.close();
+							mm.loadMoreDetailedMap(true);
+						}
+						if (action == AllCachesResMI) {
+							mapsMenu.close();
+							mm.loadMapForAllCaches();
+						}
+						// moveto position
+						if (action == moveToCenterMI) {
+							mapsMenu.close();
+							mm.setCenterOfScreen(Global.getPref().curCentrePt, true);
+						}
+						if (action == moveToDestMI) {
+							mapsMenu.close();
+							mm.setCenterOfScreen(new CWPoint(mm.gotoPos.lat, mm.gotoPos.lon), true);
+						}
+						if (action == moveToGpsMI) {
+							mapsMenu.close();
+							this.snapToGps();						
+						}
+
+					}
+				}
+			} // if (ev.target == mapsMenu)
+			if (ev.target == kontextMenu) {
+				if ((((MenuEvent)ev).type==MenuEvent.SELECTED)) {
+					MenuItem action = (MenuItem) kontextMenu.getSelectedItem(); 
+					if (action == gotoMenuItem) {
+						kontextMenu.close();
+						mm.myNavigation.setDestination(mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y));	
+					}
+					if (action == openCacheDescMenuItem) {
+						//mm.onEvent(new FormEvent(FormEvent.CLOSED, mm));
+						kontextMenu.close();
+						WindowEvent close = new WindowEvent();
+						close.target = mm;
+						close.type = WindowEvent.CLOSE;
+						mm.postEvent(close);
+						MainTab mainT = Global.mainTab;
+						mainT.openDesciptionPanel(clickedCache);
+					}
+					if (action == newWayPointMenuItem) {
+						kontextMenu.close();
+						WindowEvent close = new WindowEvent();
+						close.target = mm; 
+						close.type = WindowEvent.CLOSE;
+						mm.postEvent(close);
+						CacheHolder newWP = new CacheHolder();
+						newWP.pos = mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y);
+						newWP.LatLon=newWP.pos.toString(); 
+						Global.mainTab.newWaypoint(newWP);
+					}
+					if (action == addCachetoListMenuItem) {
+						kontextMenu.close();
+						Global.mainForm.cacheList.addCache(clickedCache.wayPoint);
+					}
+					for (int i=0; i<miLuminary.length; i++) {
+						if (action == miLuminary[i]) {
+							kontextMenu.close();
+							mm.myNavigation.setLuminary(i);
+							mm.updateGps(mm.myNavigation.gpsPos.getFix());
+							miLuminary[i].modifiers |= MenuItem.Checked;
+						} else miLuminary[i].modifiers &= ~MenuItem.Checked;
+					}
+				}
+			} // if (ev.target == kontextMenu)
+		} // if (ev instanceof ControlEvent ) 
+		super.onEvent(ev);
+	}
+}
+
+
+/**
+ *	Class to display maps to choose from
+ */
+class ListBox extends Form{
+	public MapInfoObject selectedMap = new MapInfoObject();
+	mButton cancelButton, okButton;
+	mList list = new mList(4,1,false);
+	public boolean selected = false;
+	Vector maps;
+
+	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos, MapInfoObject curMap){
+		this.title = "Maps";
+		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else 
+		// set width to screenwidth *3/4 but to at least 240 if the screen is big engough for 240px width
+		this.setPreferredSize(java.lang.Math.max(MyLocale.getScreenWidth()*3/4, java.lang.Math.min(240, MyLocale.getScreenWidth()) ), MyLocale.getScreenHeight()*3/4);
+		this.maps = maps;
+		MapInfoObject map;
+		ScrollBarPanel scb;
+		int oldmap = -1;
+		boolean curMapFound = false;
+		boolean[] inList = new boolean[maps.size()];
+		int row = -1;
+		if (curMap == null) curMapFound = true;
+		if (gotopos != null && Gps != null) {
+			list.addItem("--- Karten von akt. Position und Ziel ---");
+			row++;
+			for(int i = 0; i<maps.size();i++){
+				map = new MapInfoObject();
+				map = (MapInfoObject)maps.get(i);
+				if( map.inBound(Gps.latDec, Gps.lonDec) && map.inBound(gotopos) ) 
+				{
+					list.addItem(i + ": " + map.mapName);
+					row++;
+					inList[i] = true;
+					if (!curMapFound && map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+				} else inList[i] = false;
+			}
+		}
+		if (Gps != null) {
+			list.addItem("--- Karten der aktuellen Position ---");
+			row++;
+			for(int i = 0; i<maps.size();i++){
+				map = new MapInfoObject();
+				map = (MapInfoObject)maps.get(i);
+				if (map.inBound(Gps.latDec, Gps.lonDec) == true) 
+				{
+					list.addItem(i + ": " + map.mapName);
+					row++;
+					inList[i] = true;
+					if (!curMapFound  && map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+				}
+			}
+		}
+		if (gotopos != null) {
+			list.addItem("--- Karten des Ziels ---");
+			row++;
+			for(int i = 0; i<maps.size();i++){
+				map = new MapInfoObject();
+				map = (MapInfoObject)maps.get(i);
+				if(map.inBound(gotopos)) {
+					list.addItem(i + ": " + map.mapName);
+					row++;
+					inList[i] = true;
+					if (!curMapFound  && map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+				}
+			}
+		}
+		list.addItem("--- andere Karten ---");
+		row++;
+		for(int i = 0; i<maps.size();i++){
+			map = new MapInfoObject();
+			map = (MapInfoObject)maps.get(i);
+			if(!inList[i]) {
+				list.addItem(i + ": " + map.mapName);
+				row++;
+				if (!curMapFound  && map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+			}
+		}
+		list.selectItem(oldmap, true);
+		this.addLast(scb = new ScrollBarPanel(list),CellConstants.STRETCH, CellConstants.FILL);
+		cancelButton = new mButton("Cancel");
+		cancelButton.setHotKey(0, KeyEvent.getCancelKey(true));
+		this.addNext(cancelButton,CellConstants.STRETCH, CellConstants.FILL);
+		okButton = new mButton("Select");
+		okButton.setHotKey(0, KeyEvent.getActionKey(true));
+		this.addLast(okButton,CellConstants.STRETCH, CellConstants.FILL);
+		okButton.takeFocus(0);
+	}
+	private boolean mapIsInList(int mapNr){ // it is not used  anymore could be deleted
+		String testitem = new String();
+		int testitemnr;
+		for (int i=0; i<list.countListItems(); i++) {
+			try { 
+				testitem = ((MenuItem)list.items.get(i)).label;
+				testitemnr = Convert.toInt(testitem.substring(0,testitem.indexOf(':')));
+				if ( testitemnr == mapNr) return true;
+			} catch (IndexOutOfBoundsException e) {} // happens on a seperator line because it doesn't contain ":"
+			catch (NegativeArraySizeException e) {} // happens on a seperator line because it doesn't contain ":"
+		}
+		return false;
+	}
+
+	public void mapSelected() {
+		try { 
+			selectedMap = null;
+			int mapNum = 0;
+			String it = new String();
+			it = list.getText();
+			if (it != ""){
+				it = it.substring(0,it.indexOf(':'));
+				mapNum = Convert.toInt(it);
+				//	Vm.debug("Kartennummer: " + mapNum);
+				selectedMap = (MapInfoObject)maps.get(mapNum);
+				selected = true;
+				this.close(FormBase.IDOK);
+			}
+			else {
+				selected = false;
+				this.close(FormBase.IDCANCEL);
+			}
+		}catch (NegativeArraySizeException e) {} // happens in substring when a dividing line selected 
+	}
+
+	public void onEvent(Event ev){
+		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+			if (ev.target == cancelButton){
+				selectedMap = null;
+				selected = false;
+				this.close(FormBase.IDCANCEL);
+			}
+			if (ev.target == okButton || ev.target == list){ // ev.target == list is posted by mList if a selection was double clicked
+				mapSelected();
+			}
+		}
+		super.onEvent(ev);
+	}
+
+	public void  penDoubleClicked(Point where) {
+		mapSelected();
+	}
+}
+
+class ArrowsOnMap extends AniImage {
+	float gotoDir = -361;
+	float sunDir = -361;
+	float moveDir = -361;
+
+	int minY;
+	Graphics draw;
+	private MapInfoObject map=null;
+
+	Color moveDirColor = new Color(255,0,0); // RED 
+	final static Color sunDirColor = new Color(255,255,0); // Yellow
+	//final static Color GREEN = new Color(0,255,0);
+	final static Color gotoDirColor = new Color(0,0,128); // dark blue
+	final static Color northDirColor = new Color(0,0,255); // Blue
+	Point[] sunDirArrow = null;
+	Point[] gotoDirArrow = null;
+	Point[] moveDirArrow = null;
+	Point[] northDirArrow = null;
+	
+	/**
+	 * @param gd goto direction
+	 * @param sd sun direction
+	 * @param md moving direction
+	 */
+	public ArrowsOnMap(){
+		super();
+		newImage();
+		//	setDirections(90, 180, -90);
+	}
+
+	public void newImage() {
+		setImage(new Image(80,80), Color.White);
+		draw = new Graphics(image);
+	}
+	public void setMap(MapInfoObject m) {
+		map = m;
+		makeArrows();
+	}
+
+	public void setDirections(float gd, float sd, float md ) {
+		if (java.lang.Math.abs(gotoDir - gd) > 1 // to save cpu-usage only update if the is a change of directions of more than 1 degree
+				|| java.lang.Math.abs(sunDir - sd) > 1
+				|| java.lang.Math.abs(moveDir - md) > 1)
+		{
+			//dirsChanged = false;
+			gotoDir = gd;
+			sunDir = sd;
+			moveDir = md;
+			makeArrows();
+		}
+	}
+
+	/**
+	 * draw arrows for the directions of movement and destination waypoint
+	 * @param ctrl the control to paint on
+	 * @param moveDir degrees of movement
+	 * @param destDir degrees of destination waypoint
+	 */
+
+	public void doDraw(Graphics g,int options) {
+		if (map == null || g == null) return;
+		drawArrows(g);
+		return;
+/*		if (!dirsChanged) {
+			g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height); // the transparency with a transparent color doesn't work in ewe-vm for pocketpc, it works in java-vm, ewe-vm on pocketpc2003 
+			return;
+		}
+		dirsChanged = false;
+		//super.doDraw(g, options);
+		draw.setColor(Color.White);
+		draw.fillRect(0, 0, location.width, location.height);
+		minY = Integer.MAX_VALUE;
+		drawArrows(draw);
+		draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw 
+		g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
+*/	}
+
+	private void makeArrows(){
+			// draw only valid arrows
+			if (moveDir < 360 && moveDir > -360) {
+				if (moveDirArrow == null) moveDirArrow = new Point[2];
+				makeArrow(moveDirArrow, moveDir, 1.0f);
+			} else moveDirArrow = null;
+			if (gotoDir < 360 && gotoDir > -360) {
+				if (gotoDirArrow == null) gotoDirArrow = new Point[2];
+				makeArrow(gotoDirArrow, gotoDir, 1.0f);
+			} else gotoDirArrow = null;
+			if (sunDir < 360 && sunDir> -360) {
+				if (sunDirArrow == null ) sunDirArrow = new Point[2];
+				makeArrow(sunDirArrow, sunDir, 0.75f);
+			} else sunDirArrow = null;
+			if (java.lang.Math.abs(map.rotationRad) > 1.5 / 180 * java.lang.Math.PI)	{ // show northth arrow only if it has more than 1.5 degree deviation from vertical direction
+				if (northDirArrow == null) northDirArrow = new Point[2];
+				makeArrow(northDirArrow, 0, 1.0f); // north direction
+			} else northDirArrow = null;
+			
+			//select moveDirColor according to difference to gotoDir
+			moveDirColor = new Color(255,0,0); // red
+			
+			if (moveDirArrow != null && gotoDirArrow != null)
+			{
+				float diff = java.lang.Math.abs(moveDir - gotoDir);
+				while (diff > 360)
+				{
+					diff -= 360.0f;
+				}
+				if (diff > 180)
+				{
+					diff = 360.0f - diff;
+				}
+				
+				if (diff <= 5.0)
+				{
+					moveDirColor = new Color(0,192,0);// darkgreen
+				}
+				else if (diff <= 22.5)
+				{
+					moveDirColor = new Color(0,255,0);// green
+				}
+				else if (diff <= 45.0)
+				{
+					moveDirColor = new Color(255,128,0);// orange
+				}
+			}
+		}
+
+	/**
+	 * make (calculate) Pixel array for a single arrow 
+	 * @param g handle for drawing
+	 * @param angle angle of arrow
+	 * @param col color of arrow
+	 */
+	private void makeArrow(Point[] arrow, float angle, float scale) {
+		if (map == null) return;
+
+		float angleRad;
+		int centerX = location.width/2, centerY = location.height/2;
+		if (arrow[0] == null) arrow[0] = new Point();
+		if (arrow[1] == null) arrow[1] = new Point();
+		arrow[0].x = centerX;
+		arrow[0].y = centerY;
+		angleRad = angle * (float)java.lang.Math.PI / 180 + map.rotationRad;
+		arrow[1].x = centerX + new Float(centerX * java.lang.Math.sin(angleRad) * scale).intValue();
+		arrow[1].y = centerY - new Float(centerY * java.lang.Math.cos(angleRad) * scale).intValue();
+		//	g.setPen(new Pen(Color.Black,Pen.SOLID,7));
+		//	g.drawLine(centerX,centerY,x,y);
+	}
+
+	public void drawArrows(Graphics g) {
+		drawArrow(g, northDirArrow, northDirColor);
+		drawArrow(g, gotoDirArrow, gotoDirColor);
+		drawArrow(g, moveDirArrow, moveDirColor);
+		drawArrow(g, sunDirArrow, sunDirColor);
+	}
+	
+	public void drawArrow(Graphics g, Point[] arrow, Color col) {
+		if (arrow == null) return;
+		g.setPen(new Pen(col,Pen.SOLID,3));
+		g.drawLine(arrow[0].x, arrow[0].y, arrow[1].x,arrow[1].y);
+	}
+}
+
+

Copied: trunk/src/CacheWolf/map/Navigate.java (from rev 878, trunk/src/CacheWolf/Navigate.java)
===================================================================
--- trunk/src/CacheWolf/Navigate.java	2007-09-04 23:05:39 UTC (rev 878)
+++ trunk/src/CacheWolf/map/Navigate.java	2007-09-05 02:06:44 UTC (rev 880)
@@ -0,0 +1,235 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.Global;
+import CacheWolf.Preferences;
+import ewe.fx.Color;
+import ewe.io.IOException;
+import ewe.io.SerialPort;
+import ewe.io.SerialPortOptions;
+import ewe.net.Socket;
+import ewe.sys.Convert;
+import ewe.sys.mThread;
+import ewe.ui.MessageBox;
+import ewe.util.mString;
+
+public class Navigate {
+	public CWPoint destination = new CWPoint();
+	public CWGPSPoint gpsPos = new CWGPSPoint();
+	public Track curTrack = null;
+	Color trackColor = new Color(255,0,0); // red
+	public CWPoint skyOrientationDir = new CWPoint();
+	public int luminary = SkyOrientation.SUN;
+
+	public GotoPanel gotoPanel = null;
+	public MovingMap movingMap = null;
+	public SerialThread serThread = null;
+	public Preferences pref = Global.getPref();
+	public UpdateThread tickerThread;
+	public boolean gpsRunning = false;
+	boolean lograw = false;
+	int logIntervall = 10;
+
+	public void setGotoPanel(GotoPanel gp) {
+		gotoPanel = gp;
+	}
+	public void setMovingMap (MovingMap mm) {
+		movingMap = mm;
+		if (gpsRunning) mm.gpsStarted();
+	}
+
+	public void startGps() {
+		if (serThread != null) if (serThread.isAlive()) return; // TODO use gpsRunning
+		try {
+			serThread = new SerialThread(pref.mySPO, gpsPos, (pref.forwardGPS ? pref.forwardGpsHost : ""));
+			if (pref.forwardGPS && !serThread.tcpForward) {
+				(new MessageBox("Warning", "Ignoring error:\n could not forward GPS data to host:\n"+pref.forwardGpsHost+"\n"+serThread.lastError+"\nstop and start GPS to retry",MessageBox.OKB)).exec();
+			}
+			if (gpsPos.latDec == 0 && gpsPos.lonDec == 0) { // TODO use isValid() // TODO raus damit?
+				gpsPos.latDec = destination.latDec; // setze Zielpunkt als Ausgangspunkt
+				gpsPos.lonDec = destination.lonDec;
+			}
+			serThread.start();
+			startDisplayTimer();
+			gpsRunning = true;
+			curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
+			if (lograw)	gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
+			if (gotoPanel != null) gotoPanel.gpsStarted();
+			if (movingMap != null) movingMap.gpsStarted();
+		} catch (IOException e) {
+			(new MessageBox("Error", "Could not connect to GPS-receiver.\n Error while opening serial Port " + e.getMessage()+"\npossible reasons:\n Another (GPS-)program is blocking the port\nwrong port\nOn Loox: active infra-red port is blocking GPS", MessageBox.OKB)).execute(); 
+		}
+	}
+
+	public void setRawLogging(boolean on, int intervall) {
+		lograw = on;
+		logIntervall = intervall; // TODO switch on and off during serthread running
+	}
+	public void startDisplayTimer() {
+		tickerThread = new UpdateThread(this, 1000);
+		tickerThread.start();
+	}
+
+	public void stopDisplayTimer(){
+		if (tickerThread != null) tickerThread.stop();
+	}
+
+	public void stopGps() {
+		serThread.stop();
+		stopDisplayTimer();
+		gpsPos.stopLog();
+		gpsRunning = false;
+		if (gotoPanel != null) gotoPanel.gpsStoped();
+		if (movingMap != null) movingMap.gpsStoped();
+	}
+
+	public boolean isGpsPosValid() {
+		return 	serThread != null && serThread.isAlive() && gpsPos.isValid() ; // && gpsPos.getfiex();
+
+	}
+
+
+	public void setDestination(String LatLon) { 
+		setDestination(new CWPoint(LatLon));
+	}
+
+
+	public void setDestination(CWPoint d) {
+		destination = new CWPoint (d);
+		if (gotoPanel != null) gotoPanel.destChanged(destination);
+		if (movingMap != null) movingMap.destChanged(destination);
+	}
+	/**
+	 * use the constants SkyOrientation.SUN, SkyOrientation.MOON etc.
+	 * @param lu
+	 */
+	public void setLuminary(int lu) {
+		luminary = lu;
+	}
+	public void ticked() {
+		int fix = gpsPos.getFix();
+		if (fix > 0 && (gpsPos.getSats()>= 0)) {
+			//gpsPosition.printAll();
+			//Vm.debug("currTrack.add: voher");
+			if (curTrack == null) curTrack = new Track(trackColor);
+			try {
+				curTrack.add(gpsPos);
+			} catch (IndexOutOfBoundsException e) { // track full -> create a new one
+				curTrack = new Track(trackColor); 
+				curTrack.add(gpsPos);
+				if (movingMap != null) movingMap.addTrack(curTrack); // TODO maybe gotoPanel should also hold a list of Tracks, because otherwise they will be destroyed if not saved in mmp before
+			}
+			try {
+				SkyOrientation.getSunAzimut(gpsPos.Time, gpsPos.Date, gpsPos.latDec, gpsPos.lonDec);
+				double jd = SkyOrientation.utc2juliandate(gpsPos.Time, gpsPos.Date);
+				skyOrientationDir = SkyOrientation.getLuminaryDir(luminary, jd, gpsPos);
+				ewe.sys.Vm.debug("neu: "+ skyOrientationDir.lonDec+ "jd: " + jd);
+			} catch (NumberFormatException e) { // irgendeine Info zu Berechnung des Sonnenaziumt fehlt (insbesondere Datum und Uhrzeit sind nicht unbedingt gleichzeitig verf?gbar wenn es einen Fix gibt)
+				skyOrientationDir.set(-361, -361); // any value out of range (bigger than 360) will prevent drawArrows from drawing it 
+			}
+
+		} else {
+			skyOrientationDir.set(-361, -361); // any value out of range (bigger than 360) will prevent drawArrows from drawing it		
+		}
+		gotoPanel.updateGps(fix);
+		if (movingMap != null) movingMap.updateGps(fix);
+	}
+}
+
+/**
+ * Thread for reading data from COM-port
+ *
+ */
+class SerialThread extends mThread{
+	SerialPort comSp;   
+	byte[] comBuff = new byte[1024*10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
+	int comLength = 0;
+	CWGPSPoint myGPS;
+	boolean run, tcpForward;
+	Socket tcpConn;
+	String lastError = new String();
+
+	public SerialThread(SerialPortOptions spo, CWGPSPoint GPSPoint, String forwardIP) throws IOException {
+		try{
+			comSp = new SerialPort(spo);
+		} catch (IOException e) {
+			throw new IOException(spo.portName);
+		} // catch (UnsatisfiedLinkError e) {} // TODO in original java-vm 
+		if (forwardIP.length()>0) { 
+			try {
+				tcpConn = new Socket(forwardIP, 23);
+				tcpForward = true;
+			} catch (ewe.net.UnknownHostException e) { tcpForward = false; lastError = e.getMessage();
+			} catch (IOException e) { tcpForward = false; lastError = e.getMessage(); 
+			}
+		}
+		myGPS = GPSPoint;
+	}
+
+	public void run() {
+		int noData = 0;
+		int notinterpreted = 0;
+		run = true;
+		while (run){
+			try {
+				sleep(1000);
+				//Vm.debug("Loop? " + noData);
+				noData++;
+				if (noData > 5) { myGPS.noDataError(); }
+			} catch (InterruptedException e) {}
+			if (comSp != null)	{
+				comLength = comSp.nonBlockingRead(comBuff, 0 ,comBuff.length);
+				//Vm.debug("Length: " + comBuff.length);
+				if (comLength > 0)	{
+					noData = 0;
+					String str = mString.fromAscii(comBuff, 0, comLength); 
+					if (tcpForward) {
+						try {
+							tcpConn.write(comBuff, 0, comLength);
+						} catch (IOException e) { tcpForward = false; }
+					}
+					//Vm.debug(str);
+					if (myGPS.examine(str)) notinterpreted = 0; else notinterpreted++;
+					if (notinterpreted > 22) myGPS.noInterpretableData();
+				}
+			}
+		} // while
+		myGPS.noData();
+		tcpConn.close();
+	}
+
+	public void stop() {
+		run = false;
+		if (comSp != null) comSp.close();
+	}
+}
+
+/** 
+ * Class for creating a new mThread to create timer ticks to be able to do form.close in the ticked-thread. 
+ * Using the Vm.requestTimer-Method causes "ewe.sys.EventDirectionException: This task cannot be done within 
+ * a Timer Tick." in the ewe-vm when form.close is called.  
+ */
+
+class UpdateThread extends mThread {
+	public boolean run;
+	public int calldelay;
+	public Navigate ticked;
+
+	public UpdateThread (Navigate gp, int cd) {
+		ticked = gp;
+		calldelay = cd;
+	}
+
+	public void run () {
+		run = true;
+		while (run) {
+			try { sleep (calldelay);} catch (InterruptedException e) {}
+			ticked.ticked();
+		}
+	}
+
+	public void stop() {
+		run = false;
+	}
+}
+

Copied: trunk/src/CacheWolf/map/SelectMap.java (from rev 878, trunk/src/CacheWolf/SelectMap.java)
===================================================================
--- trunk/src/CacheWolf/SelectMap.java	2007-09-04 23:05:39 UTC (rev 878)
+++ trunk/src/CacheWolf/map/SelectMap.java	2007-09-05 02:06:44 UTC (rev 880)
@@ -0,0 +1,90 @@
+package CacheWolf.navi;
+
+import CacheWolf.Global;
+import CacheWolf.InfoBox;
+import utils.FileBugfix;
+import ewe.util.*;
+import ewe.io.*;
+import ewe.filechooser.*;
+import ewe.sys.*;
+import ewe.ui.*;
+
+/**
+*	This class displays a user interface to select maps that should be or are already calibrated
+*	class id = 4100
+*/
+public class SelectMap extends Form{
+	ScrollBarPanel top;
+	ScrollBarPanel bot;
+	mButton mBCancel, mBLoad;
+	Locale l = Vm.getLocale();
+	LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
+	String mapsPath = new String();
+	mList nonCMaps = new mList(3,1,false);
+	mList CMaps = new mList(3,1,false);
+	String dateien[];
+	String selectedMap = new String();
+	public boolean worldfileexists = false;
+	
+	public SelectMap(){
+		mapsPath = Global.getPref().getMapManuallySavePath(false)+"/"; //  File.getProgramDirectory() + "/maps/";
+		top = new ScrollBarPanel(CMaps);
+		bot = new ScrollBarPanel(nonCMaps);
+		this.title = (String)lr.get(4101,"Maps");
+		this.addLast(new mLabel((String)lr.get(4102,"Calibrated Maps")), CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(top, CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(new mLabel((String)lr.get(4103,"Non Calibrated Maps")), CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(bot, CellConstants.STRETCH, CellConstants.FILL);
+		this.addNext(mBCancel = new mButton((String)lr.get(4104,"Cancel")),CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(mBLoad = new mButton((String)lr.get(4105,"Open")),CellConstants.STRETCH, CellConstants.FILL);
+		InfoBox inf = new InfoBox("Info", (String)lr.get(4109,"Loading maps...")); 
+		inf.show();
+		try{
+			File files = new FileBugfix(mapsPath);
+			File checkWFL;
+			String rawFileName = new String();
+			dateien = files.listMultiple("*.png,*.jpg,*.gif,*.bmp", File.LIST_FILES_ONLY);
+			for(int i = 0; i < dateien.length;i++){
+				rawFileName = dateien[i].substring(0, dateien[i].lastIndexOf("."));
+				checkWFL = new File(mapsPath + rawFileName + ".wfl");
+				
+				if(checkWFL.exists()){
+					CMaps.addItem(rawFileName);
+				} else {
+					nonCMaps.addItem(rawFileName);
+				}
+			}
+		}catch(Exception ex){
+			//Vm.debug("Problem retrieveing map files");
+		}
+		inf.close(0);
+	}
+	
+	public void onEvent(Event ev){
+		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+			if(ev.target == mBCancel){
+				this.close(0);
+			}
+			if(ev.target == mBLoad){
+				this.close(0);
+			}
+		}
+		if(ev instanceof ListEvent && ev.type == ListEvent.SELECTED){
+			if(ev.target == nonCMaps){
+				selectedMap = nonCMaps.getText();
+				CMaps.deleteSelection();
+				worldfileexists = false;
+			}
+			if(ev.target == CMaps){
+				selectedMap = CMaps.getText();
+				nonCMaps.deleteSelection();
+				worldfileexists = true;
+			}
+		}
+		super.onEvent(ev);
+	}
+	
+	public String getSelectedMap(){
+		return selectedMap;
+	}
+}
\ No newline at end of file

Copied: trunk/src/CacheWolf/map/SkyOrientation.java (from rev 878, trunk/src/CacheWolf/SkyOrientation.java)
===================================================================
--- trunk/src/CacheWolf/SkyOrientation.java	2007-09-04 23:05:39 UTC (rev 878)
+++ trunk/src/CacheWolf/map/SkyOrientation.java	2007-09-05 02:06:44 UTC (rev 880)
@@ -0,0 +1,354 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.MyLocale;
+import ewe.sys.Convert;
+
+/** Class to caculate positions of luminaries
+ * all methods are static
+ * usage:
+ * call utc2juliandate and then getLuminaryDir
+ * in ressources/cachewolf.languages messege numbers from 6100
+ * 
+ * @author Pfeffer
+ *
+ */
+public class SkyOrientation {
+
+	public final static int SUN = 0;
+	public final static int MOON = 1;
+	public static final int ALIOTH = 2; // brightest star in Grater Bear (Grosser Wagen) Rektaszension 12 h 54 m 2 s Deklination +55 Grad 57' 36"
+	public static final int GREATER_BEAR = ALIOTH;
+	public static final int ALNILAM = 3; //Orion = Alnilam = mittlerer Guertelstern Aequinoktium 2000): Rektaszension 5h36m13s; Deklination -1 Grad 12'7"
+	public static final int ORION = ALNILAM; 
+	public static final int CASSIOPEIA_GAMMA = 4; // Kassiopeia Gamma: 00h 56m 42.50s	+60 Grad 43' 00.3"
+	public static final int CASSIOPEIA = CASSIOPEIA_GAMMA;
+	public static final int DENEB = 5;
+	public static final int CYGNUS = DENEB; // Cygnus = Schwan
+	public static final int MIMOSA = 6; // second brightest star in Southern Cross
+	public static final int SOUTHERN_CROSS = MIMOSA; // SOUTHERN_CROSS = Kreus des S?dens = Crux australia
+	
+	public static final CWPoint[] STARS = {
+		// (Deklination, Rektaszension)
+		/*ALIOTH*/		new CWPoint(55. +57./60. + 36./3600., (12. + 54./60. + 2./3600.)*15.), // ALIOTH: Rektaszension 12 h 54 m 2 s Deklination +55 Grad 57' 36"
+		/*ALNILAM*/		new CWPoint(-1. -12./60. -7./3600., (5.+36./60. + 13./3600.)*15.), // (-1. -12./60. -7./3600., (5. + 36./60. + 13./3600.)*15.) <- wikipedia // -1.19748, 5.60978 * 15.) <- www.... // (-1. -11./60. -52./3600., (5. + 36./60. + 35./3600.)*15.)  <- Stellarium 
+		/*Cassiopeia*/	new CWPoint(60. + 43./60. + 0.3/3600., (0 + 56./60. +42.5/3600.)*15.), // CASSIOPALA_GAMMA 00h 56m 42.50s, 60 Grad 43' 00.3" <-- wikipedia, Stellarium: 57m 11s, 60 Grad 45' 29"
+		/*Deneb*/		new CWPoint(45. + 16./60. + 49.2/3600., (20 + 41./60. +25.6/3600.)*15.), // im Schwan (Sommerdreieck) Quelle: Stellarium
+		/*Mimosa*/		new CWPoint(-59. - 41./60. - 19./3600., (12 + 47./60. +43.2/3600.)*15.) // im Schwan (Sommerdreieck) Quelle: Stellarium
+		// Sirius
+	};
+	
+	public static String [] LUMINARY_NAMES = { // TODO MyLocale.getMsg(xxx, "Sun"),
+		MyLocale.getMsg(6100, "Sun"), 
+		MyLocale.getMsg(6101, "Moon"), 
+		MyLocale.getMsg(6102, "Grater Bear"),
+		MyLocale.getMsg(6103, "Orion"),
+		MyLocale.getMsg(6104, "Cassiopeia"), 
+		MyLocale.getMsg(6105, "Cygnus"),
+		MyLocale.getMsg(6106, "Southern Cross")
+	};
+
+	public static String [] LUMINARY_DESC = { // TODO MyLocale.getMsg(xxx, "Sun"),
+		MyLocale.getMsg(6100, "Sun"), 
+		MyLocale.getMsg(6101, "Moon"), 
+		MyLocale.getMsg(6122, "Alioth in Greater Bear"),
+		MyLocale.getMsg(6123, "Alnilam in Orion"),
+		MyLocale.getMsg(6124, "Cassiopeia Gamma"), 
+		MyLocale.getMsg(6125, "Deneb in Cygnus"),
+		MyLocale.getMsg(6126, "Becrux in Southern Cross")
+	};
+
+	/**
+	 * Get the friendly name of the luminary
+	 * @param luminary
+	 * @return
+	 */
+	public static String getLuminaryName(int luminary) {
+		return LUMINARY_NAMES[luminary]; 
+	}
+	
+	/**
+	 * Get a more exact description of the luminary 
+	 * @param lu
+	 * @return
+	 */
+	public static String getLuminaryDesc(int lu) {
+		return LUMINARY_DESC[lu];
+	}
+
+	/**
+	 * get azimuth from north and elevation for horizont for a given 
+	 * Luminary (planet or star) 
+	 * @param luminary one of SUN, MOON, ALIOTH, GRAETER_BEAR, ALNILAM, ORION, CASSIOPEIA_GAMMA, CASSIOPEIA
+	 * @param jd julian date must be calculated in advance e.g. from utc2julian
+	 * @param onEarth place on earth of the observer
+	 * @return lon = azimuth from north, lat = elevation from horizont
+	 */
+	public static CWPoint getLuminaryDir(int luminary, double jd, CWPoint onEarth) {
+		switch (luminary) {
+		case SUN: return getSunDir(jd, onEarth);
+		case MOON: return getMoonDir(jd, onEarth);
+		default: 
+			return equatorial2AzimutCoos(onEarth, jd, STARS[luminary-MOON-1]);
+		}
+	}
+
+	/**
+	 * @param utc in the format as it comes from gps DDMMYY
+	 * @param datum in the format as it comes from gps HHMMSS
+	 * @return juliandate
+	 * @throws NumberFormatException if utc / datum could not be parsed successfully
+	 */
+	public static double utc2juliandate(String utc, String datum) {
+		try {
+			int tag, monat, jahr, stunde, minute, sekunde;
+			tag     = Convert.parseInt(datum.substring(0, 2));
+			monat   = Convert.parseInt(datum.substring(2, 4));
+			jahr    = Convert.parseInt(datum.substring(4, 6)) + 2000;
+			stunde  = Convert.parseInt(utc.substring(0, 2));
+			minute  = Convert.parseInt(utc.substring(2, 4));
+			sekunde = Convert.parseInt(utc.substring(4, 6)); // Kommastellen werden abgeschnitten
+			// julianisches "Datum" jd berechnen (see http://de.wikipedia.org/wiki/Julianisches_Datum )
+			if (monat<2) {jahr--; monat+=12;} // verlegung des Jahres Endes auf Feb macht Berechnung von SChaltjahren einfacher
+			double a = (int)java.lang.Math.floor((double)jahr/100.); // Alle hundert Jahre kein Schlatjahr (abrunden)
+			double b = 2 - a + java.lang.Math.floor((double)a/4.);
+			double jd = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) + (double)tag + (double)stunde/24 + (double)minute/1440 + (double)sekunde/86400 + b - 1524.5;
+			return jd;
+			//double jd0 = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) +(double)tag + b - 1524.5;
+		} catch (IndexOutOfBoundsException e) {
+			// wird von substring geworfen wenn datum / utc nicht genug Ziffern haben
+			// NumberFormatException wird au?erdem von Convert.ParseInt direkt geworfen wenn
+			// nicht in Int konvertiert werden kann
+			throw new NumberFormatException();
+		}
+	}
+
+	/**
+	 * old version, gives the same as the new one
+	 * @param utc
+	 * @param datum
+	 * @param lat
+	 * @param lon
+	 * @return
+	 */
+	public static float getSunAzimut (String utc, String datum, double lat, double lon) {
+		//	(new MessageBox("test", "utc:"+utc+" datum: "+datum+", lat: "+lat+", len: "+lon, MessageBox.OKB)).exec();
+		try {
+			int tag, monat, jahr, stunde, minute, sekunde;
+			tag = Convert.parseInt(datum.substring(0, 2));
+			monat = Convert.parseInt(datum.substring(2, 4));
+			jahr = Convert.parseInt(datum.substring(4, 6)) + 2000;
+			stunde=Convert.parseInt(utc.substring(0, 2));
+			minute=Convert.parseInt(utc.substring(2, 4));
+			sekunde=Convert.parseInt(utc.substring(4, 6)); // Kommastellen werden abgeschnitten
+			// julianisches "Datum" jd berechnen (see http://de.wikipedia.org/wiki/Julianisches_Datum )
+			if (monat<2) {jahr--; monat+=12;} // verlegung des Jahres Endes auf Feb macht Berechnung von SChaltjahren einfacher
+			double a = (int)java.lang.Math.floor((double)jahr/100.); // Alle hundert Jahre kein Schlatjahr (abrunden)
+			double b = 2 - a + java.lang.Math.floor((double)a/4.);
+			double jd = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) + (double)tag + (double)stunde/24 + (double)minute/1440 + (double)sekunde/86400 + b - 1524.5;
+			double jd0 = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) +(double)tag + b - 1524.5;
+			// Ekliptikalkoordinaten der Sonne berechnen (see http://de.wikipedia.org/wiki/Sonnenstand )
+			double n = jd - 2451545.0;
+			double l = 280.46 + 0.9856474 * n;
+			double g = 357.528 + 0.9856003 * n;
+			double d = l + 1.915*java.lang.Math.sin(g/180*java.lang.Math.PI) + 0.02 * java.lang.Math.sin(2*g/180*java.lang.Math.PI);
+			// Rektaszension alpha und Deklination delta der Sonne berechnen
+			double e = 23.439 -0.0000004 * n;
+			double alphaNenner = java.lang.Math.cos(d/180*java.lang.Math.PI);
+			double alpha = 180/java.lang.Math.PI*java.lang.Math.atan(java.lang.Math.cos(e/180*java.lang.Math.PI)*java.lang.Math.sin(d/180*java.lang.Math.PI)/alphaNenner);
+			double delta = 180/java.lang.Math.PI*java.lang.Math.asin(java.lang.Math.sin(e/180*java.lang.Math.PI)*java.lang.Math.sin(d/180*java.lang.Math.PI) );
+			if (alphaNenner<0) {alpha +=180;}
+			// Azimut
+			double t0 = (jd0 - 2451545.)/36525.; // schon in t0 bzw jd0 richtig berechnet?
+			double thetaHG = 6.697376 + 2400.05134 * t0 + 1.002738 * ((double)stunde + (double)minute/60. + (double)sekunde/3600.);
+			double theta = thetaHG * 15. + lon;
+			double azimutNenner = java.lang.Math.cos((theta-alpha)/180*java.lang.Math.PI)*java.lang.Math.sin(lat/180*java.lang.Math.PI)-
+			java.lang.Math.tan(delta/180*java.lang.Math.PI)*java.lang.Math.cos(lat/180*java.lang.Math.PI);
+			float azimut = (float) java.lang.Math.atan(java.lang.Math.sin((theta-alpha)/180*java.lang.Math.PI)/
+					azimutNenner);
+			azimut = (float) (azimut * 180f / java.lang.Math.PI);
+			if (azimutNenner<0) azimut +=180.;
+			// null = Sueden auf Null = Norden umrechnen
+			azimut +=180.;
+			if (azimut >360.) azimut -=360.;
+			ewe.sys.Vm.debug("sunAzimut1: " + azimut);
+			ewe.sys.Vm.debug("sun Elevation: " +getSunAzimut2 (utc, datum, lat, lon).latDec);
+			CWPoint MoonDir = getMoonDir(jd, new CWPoint(lat, lon));
+			ewe.sys.Vm.debug("Moon Elevation: " + MoonDir.latDec + "Moon Azimut: " + MoonDir.lonDec);
+			CWPoint OrionDir = getAlnilamDir(jd, new CWPoint(lat, lon));
+			ewe.sys.Vm.debug("Alnilam (Orion) Elevation: " + OrionDir.latDec + "Alnilam (Orion) Azimut: " + OrionDir.lonDec );
+			
+			return azimut;
+		} catch (IndexOutOfBoundsException e) {
+			// wird von substring geworfen wenn datum / utc nicht genug Ziffern haben
+			// NumberFormatException wird ausserdem von Convert.ParseInt direkt geworfen wenn
+			// nicht in Int konvertiert werden kann
+			throw new NumberFormatException();
+		}
+	}
+
+	public static CWPoint getSunAzimut2 (String utc, String datum, double lat, double lon) {
+		double jd = utc2juliandate(utc, datum);
+		CWPoint eclCoos = getSunEclipticCoos(jd);
+		// calculate ecliptic coos
+		// convert coos
+		return ecliptic2AzimutCoos(new CWPoint(lat, lon), jd, eclCoos);
+	}
+
+	public static CWPoint getSunDir (double jd, CWPoint onEarth) {
+		CWPoint eclCoos = getSunEclipticCoos(jd);
+		// calculate ecliptic coos
+		// convert coos
+		return ecliptic2AzimutCoos(onEarth, jd, eclCoos);
+	}
+
+	public static CWPoint getMoonDir(double jd, CWPoint onEarth) {
+		CWPoint eclCoo = getMoonEclipticCoos(jd);
+		return ecliptic2AzimutCoos(onEarth, jd, eclCoo);
+	}
+
+	public static CWPoint getAlnilamDir(double jd, CWPoint onEarth) {
+		// Koordinaten Alnilam (mittlerer Guertelstern des Orion), Rektaszension 5h36m13s; Deklination -1?12'7 TODO Aequinoktium 2000
+		// Source: wikipedia
+		return equatorial2AzimutCoos(onEarth, jd, new CWPoint(-1. -12./60. -7./3600., (5. + 36./60. + 13./3600.)*15.) ); // (-1. -12./60. -7./3600., (5. + 36./60. + 13./3600.)*15.) <- wikipedia // -1.19748, 5.60978 * 15.) <- www.... // (-1. -11./60. -52./3600., (5. + 36./60. + 35./3600.)*15.)  <- Stellarium
+	}
+
+	/**
+	 * get the ecliptic coordinates of the sun
+	 * @param juliandate
+	 * @return
+	 */
+	public static CWPoint getSunEclipticCoos(double juliandate) {
+		double n = juliandate - 2451545.0;
+		double l = 280.46 + 0.9856474 * n;
+		double g = 357.528 + 0.9856003 * n;
+		double lambda = l + 1.915*java.lang.Math.sin(g/180*java.lang.Math.PI) + 0.02 * java.lang.Math.sin(2*g/180*java.lang.Math.PI);
+		return new CWPoint(0, lambda);
+	}
+
+
+	// the following code is adopted from http://lexikon.astronomie.info/java/sunmoon/sunmoon.html
+	// ignores the time difference between juliandate and TDT, which is something like 1 minute
+	public static CWPoint getMoonEclipticCoos(double julianDate) {
+		final double DEG = Math.PI / 180;  
+		final double RAD = 1/DEG;
+		double sunAnomalyMean = 360*DEG/365.242191*(julianDate - 2447891.5) + 279.403303*DEG - 282.768422*DEG;
+		double D = julianDate-2447891.5;
+
+		// Mean Moon orbit elements as of 1990.0
+		double l0 = 318.351648*DEG;
+		double P0 =  36.340410*DEG;
+		double N0 = 318.510107*DEG;
+		double i  = 5.145396*DEG;
+
+		double l = 13.1763966*DEG*D+l0;
+		double MMoon = l-0.1114041*DEG*D-P0; // Moon's mean anomaly M
+		double N = N0-0.0529539*DEG*D;       // Moon's mean ascending node longitude
+
+		double sunlon = getSunEclipticCoos(julianDate).lonDec; 
+		double C = l-sunlon;
+		double Ev = 1.2739*DEG*Math.sin(2*C-MMoon);
+		double Ae = 0.1858*DEG*Math.sin(sunAnomalyMean);
+		double A3 = 0.37*DEG*Math.sin(sunAnomalyMean);
+
+		double MMoon2 = MMoon+Ev-Ae-A3;  // corrected Moon anomaly
+		double Ec = 6.2886*DEG*Math.sin(MMoon2);  // equation of centre
+		double A4 = 0.214*DEG*Math.sin(2*MMoon2);
+		double l2 = l+Ev+Ec-Ae+A4; // corrected Moon's longitude
+		double V = 0.6583*DEG*Math.sin(2*(l2-sunlon));
+
+		double l3 = l2+V; // true orbital longitude;
+		double N2 = N-0.16*DEG*Math.sin(sunAnomalyMean);
+
+		CWPoint moonCoor = new CWPoint();  
+		moonCoor.lonDec = (( N2 + Math.atan2( Math.sin(l3-N2)*Math.cos(i), Math.cos(l3-N2) ) ) * RAD)% 360;
+		moonCoor.latDec = Math.asin( Math.sin(l3-N2)*Math.sin(i) ) * RAD;
+		//moonCoor.orbitLon = l3;
+		return moonCoor;
+
+		/*
+		double e  = 0.054900;
+		double a  = 384401; // km
+		double diameter0 = 0.5181*DEG; // angular diameter of Moon at a distance
+		double parallax0 = 0.9507*DEG; // parallax at distance a
+
+		  // relative distance to semi mayor axis of lunar oribt
+		  moonCoor.distance = (1-sqr(e)) / (1+e*Math.cos(MMoon2+Ec) );
+		  moonCoor.diameter = diameter0/moonCoor.distance; // angular diameter in radians
+		  moonCoor.parallax = parallax0/moonCoor.distance; // horizontal parallax in radians
+		  moonCoor.distance *= a;	// distance in km
+
+		  // Age of Moon in radians since New Moon (0) - Full Moon (pi)
+		  moonCoor.moonAge = Mod2Pi(l3-sunCoor.lon);   
+		  moonCoor.phase   = 0.5*(1-Math.cos(moonCoor.moonAge)); // Moon phase, 0-1
+
+		  var phases = new Array("Neumond", "Zunehmende Sichel", "Erstes Viertel", "Zunnehmender Mond", 
+		  	"Vollmond", "Abnehmender Mond", "Letztes Viertel", "Abnehmende Sichel", "Neumond");
+		  var mainPhase = 1./29.53*360*DEG; // show 'Newmoon, 'Quarter' for +/-1 day arond the actual event
+		  var p = Mod(moonCoor.moonAge, 90.*DEG);
+		  if (p < mainPhase || p > 90*DEG-mainPhase) p = 2*Math.round(moonCoor.moonAge / (90.*DEG));
+		  else p = 2*Math.floor(moonCoor.moonAge / (90.*DEG))+1;
+		  moonCoor.moonPhase = phases[p];
+
+		  moonCoor.sign = Sign(moonCoor.lon);
+		  return (float) moonCoor.lonDec;
+		return 0;
+	}
+		 */
+	}
+
+	public static CWPoint ecliptic2AzimutCoos(CWPoint onEarth, double julianDate, CWPoint ecliptic) {
+		CWPoint equat = ecliptic2Equatorial(ecliptic, julianDate);
+		return equatorial2AzimutCoos(onEarth, julianDate, equat);
+	}
+	/**
+	 * convert rektaszension alpha and deklination delta to azimuth / elevation
+	 * @param onEarth pos. on earth for which the azimut is wanted
+	 * @param julianDate
+	 * @param equatorial: lonDec = rektaszension (alpha), latDec = Deklination (delta)
+	 * @return lonDec: azimuth in degrees from north, lat: elevation in degrees from horizont
+	 * alogithism from wikipedia sonnenbahn
+	 */
+	public static CWPoint equatorial2AzimutCoos(CWPoint onEarth, double julianDate, CWPoint equatorial) {
+		double stunde = ((julianDate + 0.5) % 1) * 24;
+		double jd0 = julianDate - stunde /24; // julian date at UTC 0:00
+		double t0 = (jd0 - 2451545.)/36525.; // schon in t0 bzw jd0 richtig berechnet?
+		double thetaHG = 6.697376 + 2400.05134 * t0 + 1.002738 * stunde; // + (double)minute/60.);
+		double theta = thetaHG * 15. + onEarth.lonDec;
+		double tau = (theta - equatorial.lonDec ) /180*Math.PI;
+		double phi = onEarth.latDec/180*Math.PI;
+		double azimutNenner = Math.cos(tau)*Math.sin(phi)-
+		Math.tan(equatorial.latDec/180*Math.PI)*Math.cos(onEarth.latDec/180*java.lang.Math.PI);
+		float azimut = (float) java.lang.Math.atan(java.lang.Math.sin((theta-equatorial.lonDec)/180*Math.PI)/
+				azimutNenner);
+		azimut = (float) (azimut * 180f / java.lang.Math.PI);
+		if (azimutNenner<0) azimut +=180.;
+		double h = 180 / Math.PI * Math.asin(Math.cos(equatorial.latDec/180*Math.PI) * Math.cos(tau)*Math.cos(phi) + Math.sin(equatorial.latDec/180 *Math.PI) * Math.sin(phi));
+		// null = Sueden auf Null = Norden umrechnen
+		azimut +=180.;
+		if (azimut >360.) azimut -=360.;
+		return new CWPoint(h, azimut);
+	}
+
+	/**
+	 * convert from eliptical to equatorial coordinates
+	 * @param juliandate
+	 * @param eklipCoo ecliptic coos in degrees  
+	 * @return lon: Deklination (delta), lat: Rektaszension (alpha) in degree
+	 * this is adopted from http://lexikon.astronomie.info/java/sunmoon/sunmoon.html 
+	 */
+	public static CWPoint ecliptic2Equatorial(CWPoint eklipCoo, double juliandate) {
+		double T = (juliandate - 2451545.0)/36525.; // Epoch 2000 January 1.5
+		double eps = (23.+(26+21.45/60)/60 + T*(-46.815 +T*(-0.0006 + T*0.00181) )/3600 ) / 180 * java.lang.Math.PI; // schiefe der Ekliptik
+		double coseps = Math.cos(eps);
+		double sineps = Math.sin(eps);
+
+		double sinlon = Math.sin(eklipCoo.lonDec / 180 * Math.PI);
+		CWPoint equatorial = new CWPoint();
+		equatorial.lonDec = (180 / Math.PI * Math.atan2( (sinlon*coseps-Math.tan(eklipCoo.latDec /180 * Math.PI)*sineps), Math.cos(eklipCoo.lonDec/180 * Math.PI) ) ) % 360; // rektaszension (alpha)
+		equatorial.latDec = 180 / Math.PI * Math.asin( Math.sin(eklipCoo.latDec/180 * Math.PI)*coseps + Math.cos(eklipCoo.latDec/180 * Math.PI)*sineps*sinlon ); // deklination (delta)
+
+		return equatorial;
+	}
+}
+

Added: trunk/src/CacheWolf/map/Track.java
===================================================================
--- trunk/src/CacheWolf/map/Track.java	2007-09-05 01:58:25 UTC (rev 879)
+++ trunk/src/CacheWolf/map/Track.java	2007-09-05 02:06:44 UTC (rev 880)
@@ -0,0 +1,56 @@
+package CacheWolf.navi;
+
+import ewe.fx.*;
+
+public class Track {
+	public Color trackColor;
+	public TrackPoint TrackPoints[];
+	public int num;
+	
+	public Track(Color f) {
+		trackColor = f;
+		TrackPoints = new TrackPoint[5000];
+		num = 0;
+	}
+/*===== add is currently not used	
+	public void add(double lat, double lon) {
+		TrackPoints[num] = new TrackPoint(lat, lon);
+		num++;
+	}
+=====*/	
+	/*
+	 * throws IndexOutOfBoundsException when track is full
+	 */
+	public void add(TrackPoint t) { 
+		if (TrackPoints == null || t == null) return;
+		TrackPoints[num] = new TrackPoint(t);
+		num++;
+	}
+/*===== loadTrack/saveTrack are currently not used
+	public void loadTrack(String filename){ // TODO untested!
+		byte [] all = ewe.sys.Vm.readResource(null,filename);
+		if (all == null) return; // TODO error handling
+		num = Utils.readInt(all, 0, 4);
+		for (int i=0; i<=num; i++){
+			TrackPoints[i].latDec = Double.longBitsToDouble(Utils.readLong(all, (i*2)*8 + 4));
+			TrackPoints[i].lonDec = Double.longBitsToDouble(Utils.readLong(all, (i*2+1)*8 + 4));
+		}
+	}
+	
+	public void saveTrack(String filename){  // TODO untested!
+	//ByteArray ba=new ByteArray();
+	byte[] ba = new byte[8*2*num+4]; // 8 bytes is one double int has size 4
+	Utils.writeInt(num, ba, 0, 4);
+	for (int i=0; i<=num; i++){
+		Utils.writeLong(Double.doubleToLongBits(TrackPoints[i].latDec), ba, (i*2)*8 + 4);
+		Utils.writeLong(Double.doubleToLongBits(TrackPoints[i].lonDec), ba, (i*2+1)*8 + 4);
+	}
+	try{
+		PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(filename)));
+		outp.print(ba.toString());
+	}catch (IOException e) {
+		(new MessageBox("Error", "Error reading trackfile:\n"+e.toString(), MessageBox.OKB)).execute();}
+	}
+=====*/
+
+}

Copied: trunk/src/CacheWolf/map/TrackOverlay.java (from rev 878, trunk/src/CacheWolf/TrackOverlay.java)
===================================================================
--- trunk/src/CacheWolf/TrackOverlay.java	2007-09-04 23:05:39 UTC (rev 878)
+++ trunk/src/CacheWolf/map/TrackOverlay.java	2007-09-05 02:06:44 UTC (rev 880)
@@ -0,0 +1,299 @@
+package CacheWolf.navi;
+
+//import java.awt.image.BufferedImage;
+
+import ewe.fx.Color;
+import ewe.fx.Graphics;
+import ewe.fx.IImage;
+import ewe.fx.Image;
+import ewe.fx.Pen;
+import ewe.graphics.AniImage;
+import ewe.sys.Convert;
+import ewe.fx.Point;
+import ewe.fx.Mask;
+
+import ewe.util.Vector;
+
+
+public class TrackOverlay extends MapImage {
+	public TrackPoint topLeft;
+	public TrackPoint bottomRight;
+	Graphics draw;
+	Graphics drawMask;
+	int test;
+	MapInfoObject trans; 
+	public Vector tracks;
+	boolean imageChangesDontShow = false;
+	public Point trackPixels[] = null;
+	public Color trackPixelsColor[] = null;
+	public int numPixels = 0;
+	final static int maxPixelsInCache = 100;
+	final static Color transparentColorForOverlay = Color.White; // only for use when transparent color is used
+	static boolean useTransparentColor;
+	public TrackOverlay (TrackPoint topLefti, int widthi, int highti, MapInfoObject transi) {
+		super();
+		topLeft = new TrackPoint(topLefti);
+		trans = transi;
+		bottomRight = calcLatLonInImage(widthi, highti);
+		if (ewe.sys.Vm.getPlatform().equalsIgnoreCase("java")) {
+			useTransparentColor = true; 
+			setImage(new Image(widthi, highti), transparentColorForOverlay); // java-vm: transparency with a mask is very memory consuming, but transparency with a mask is much faster in ewe-vm and doesn't consume more memory than a transparency color (ewe 1.49)
+		} else {
+			useTransparentColor = false; // // momentanously this it not used, but this is only because ewe treats areas as opaque which has a non white color in the image, so that the mask doesn't need to be changed
+			Image maski = new Image(widthi, highti);
+			drawMask = new Graphics(maski);
+			drawMask.setColor(Color.White);
+			drawMask.fillRect(0, 0, maski.getWidth(), maski.getHeight());
+			setImage(new Image(widthi, highti), maski); // java-vm: transparency with a mask is very memory consuming, but transparency with a mask is much faster in ewe-vm and doesn't consume more memory than a transparency color (ewe 1.49)
+			maski.free(); //setimage produces an inverted copy of the mask
+			maski = null;
+		}
+		//properties = AlwaysOnTop; // arrows are above, so dont set it.
+		draw = new Graphics(image);
+		draw.setDrawOp(Graphics.DRAW_OVER);
+		if (useTransparentColor) draw.setColor(transparentColorForOverlay);
+		else draw.setColor(Color.White);
+		draw.fillRect(0, 0, widthi, highti);
+		//int[] markImage = {0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000};
+		//int[] markMaskOpaque = {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff};
+		//mask.setPixels( markMaskOpaque, 0, 50, 50, 2, 2, 0);
+		//draw.fillRectRGB(50, 50, 52, 52, 0x00ff0000); // fillRectRGB has a Bug - it never returns - use fillRect instead
+		//image.setPixels(markImage, 0, 50, 50, 2, 2, 0); // out of an to me unkwon reason this doesn't work here, but it does in painttracks
+	}
+	public void imageSet()
+//	==================================================================
+	{
+		IImage i = drawable;
+		if (i == null) i = image;
+		if (i != null){
+			location.width = i.getWidth();
+			location.height = i.getHeight();
+		}
+		if (image != null && image != sourceImage) image.freeze();
+//		if (mask != null && mask != sourceMask) mask.freeze(); // dont freeze the mask, it could change. Anyway momentanously it doesnt change, because when the image contains non-white in the opaque areas, it will be opaque without changing the mask
+		properties &= ~HasChanged;
+	}
+
+
+	public void paintTracks() {
+	// for debugging TrackOverlayPositions
+	// draw.setPen(new Pen(Color.LightBlue,Pen.SOLID,1));
+	// draw.fillRect(1, 1, image.getWidth()-1, image.getHeight()-1);
+		//draw.setColor(255,0,0);
+		//draw.setPen(new Pen(new Color(255,0,0),Pen.SOLID,3));
+		//draw.fillRect(50, 50, 4, 4); // fillRectRGB has a Bug - it never returns - use fillRect instead
+
+		if (tracks == null || tracks.size() == 0) return;
+		int tri, i;
+		Track tr;
+		for (tri=tracks.size()-1; tri >= 0; tri--) {
+			tr = (Track)tracks.get(tri);
+			//draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
+			draw.setColor(tr.trackColor);
+			if (tr.num > 0) {
+				for (i=0; i < tr.num; i++) {
+					paintPoint(tr.trackColor, tr.TrackPoints[i].latDec, tr.TrackPoints[i].lonDec);
+				}
+			}
+		}
+	}
+	
+
+	/**
+	 * 
+	 * @param f
+	 * @param lat
+	 * @param lon
+	 * @return true if point was on this overlay
+	 */
+	public boolean paintPoint(Color f, double lat, double lon){
+		if (lat<bottomRight.latDec || lat > topLeft.latDec || lon<topLeft.lonDec || lon>bottomRight.lonDec) return false;
+		//ewe.sys.Vm.debug("showlastaddedpoint, lat: "+lat+"   lon: "+lon);
+		double b[] = new double[2];
+		int x, y;
+		b[0] = lat - topLeft.latDec; // see calcXYinImage (TrackPoint p) 
+		b[1] = lon - topLeft.lonDec; 
+		x=(int) (trans.transLatX* b[0] + trans.transLonX*b[1]);
+		y=(int) (trans.transLatY* b[0] + trans.transLonY*b[1]);
+		//draw.drawLine(x, y, x, y);
+		//ewe.sys.Vm.debug("showlastaddedpoint, x: "+x+"   y: "+y+"loc.x: "+location.x+"  loc.y:"+location.y);
+		draw.fillRect(x-1, y-1, 3, 3);
+		//drawMask.fillRect(x-1, y-1, 3, 3);
+		/*	if (image.bufferedImage != null) { // funktioniert gut, allerdings nur in der java-VM wenn ewe.fx.Image.bufferedImage als public definiert
+			int yd;
+			for  (int xd=-1; xd<=1; xd++) {
+				for (yd=-1; yd<=1; yd++) {
+					((BufferedImage)image.bufferedImage).setRGB(x+xd, y+yd, -65536);
+				}
+			} */
+		if (imageChangesDontShow) {
+			try {addPixelIfNeccessary(x, y, f); }
+			catch (IndexOutOfBoundsException e) // thrown when there are more than pixels stored than possible
+			{ fixate();  }
+		}
+		return true;
+	}
+
+	/**
+	 * this method forces ewe to transfer the drawn points
+	 * from _awtImage to bufferedImage, which is drawn to the screen
+	 *
+	 */
+	private void fixate() {
+		if (numPixels == 0) return;
+		//	draw.drawImage(image,null,Color.DarkBlue,0,0,location.width,location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+		draw.drawImage(image, null, Color.Pink, 0, 0, 1, 1); // width and height is anyway ignored, evtl. testen,  
+		imageChangesDontShow = false;
+		removeAllPixels();
+	}
+
+	private void removeAllPixels() {
+		numPixels = 0;
+		trackPixels = null;
+		trackPixelsColor = null;
+	}
+
+	public Point calcXYinImage (TrackPoint p) {
+		double b[] = new double[2]; // see method paintPoint it should actually call this method but it doesn't because of speed raesons
+		int x, y;
+		b[0] = p.latDec - topLeft.latDec;
+		b[1] = p.lonDec - topLeft.lonDec;
+		x=(int) (trans.transLatX* b[0] + trans.transLonX*b[1]);
+		y=(int) (trans.transLatY* b[0] + trans.transLonY*b[1]);
+		return new Point(x,y);
+	}
+
+	public TrackPoint calcLatLonInImage (double x, double y) {
+		// see trans.calcLatLon(p);
+		TrackPoint ll = new TrackPoint(); 
+		ll.latDec = (double)x * trans.affine[0] + (double)y * trans.affine[2] + topLeft.latDec;
+		ll.lonDec = (double)x * trans.affine[1] + (double)y * trans.affine[3] + topLeft.lonDec;
+		return ll;
+	}
+
+	public void addPixel(int x, int y, Color f) throws IndexOutOfBoundsException {
+		if (trackPixels==null) { trackPixels = new Point[maxPixelsInCache]; trackPixelsColor = new Color[maxPixelsInCache]; } 
+		trackPixels[numPixels] = new Point(x, y); // IndexOutOfBoundsException is handled in PaintPoint
+		trackPixelsColor[numPixels] = f.getCopy();
+		numPixels++;
+	}
+
+	public void addPixelIfNeccessary(int x, int y, Color f){
+		if (trackPixels != null) {
+			int ll =(numPixels<30 ? 0 : numPixels-30); // look in the last 50 added Pixels if the same Pixel is already in the list (for performance reasons dont look in the whole list)
+			for (int i=numPixels-1; i>=ll; i--) {
+				if (trackPixels[i].x == x && trackPixels[i].y == y && f.equals(trackPixelsColor[i])) 
+				{ return; } 
+			}
+		}
+		addPixel(x, y, f);
+	}
+
+	public static final int FIXATE_IF_NO_PIXELS_NUM = 60;
+	private int notOnThisOverlaySince = 0;
+
+	public void paintLastAddedPoint(Track tr) { 
+		//draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
+		draw.setColor(tr.trackColor);
+		if (paintPoint(tr.trackColor, tr.TrackPoints[tr.num-1].latDec, tr.TrackPoints[tr.num-1].lonDec)) notOnThisOverlaySince = 0;
+		else notOnThisOverlaySince++;
+		if (notOnThisOverlaySince > FIXATE_IF_NO_PIXELS_NUM) { // zur Performanceverbesserung: wenn in den letzten 60 Updates keines mehr f?r dieses Overlay dabei war, Overlay Pixels fest schreiben, damit doDraw entlastet wird.
+			fixate();
+			notOnThisOverlaySince = 0;
+		}
+
+	}
+
+	public void doDraw(Graphics g,int options) { // this is automatically called when the image need to be (re-)drawn on the screen
+		super.doDraw(g, options);
+		imageChangesDontShow = true; // g.drawImage (in super) copies _awtImage into bufferedImage, any later changes to _awtImage dont show up until the mask or the image has changed - unfortunately bufferedImage is not accessable from outside
+		// draw trackpoints which were added after image changes don't show up on the screen
+		if (tracks == null || tracks.size() == 0) return;
+		int i;
+		for (i=0; i<numPixels; i++) {
+			g.setColor(trackPixelsColor[i]);
+			g.fillRect(trackPixels[i].x-1, trackPixels[i].y-1, 3, 3);
+		}
+		//g.drawText(Convert.toString(test), 10, 10);
+		//g.drawRect(10 + test, 10, 10, 10);
+		//test++;
+	}
+}
+
+
+/* draw zeichnet auf _awtImage
+ * image.drawImage erzeugt bufferedImage, wenn es vorher null war 
+ * und kopiert den entsprechenden Teil in das ?bergebene Surface
+ * Das Problem ist, dass bufferedImage nicht mehr upgedatet wird, wenn
+ * es einmal erzugt wurde. Es wird nur dann upgedatet, wenn das Image ein anderes wird
+ * oder die Maske eine andere. Das Update erfolgt dann ?ber doDraw, was doCheckMask aufruft,
+ * das das eigentliche kopieren aus _awtImage vornimmt.
+ * 
+ *  Problem: das kopieren von _awtImage in BufferedImage ist sehr zeitaufw?ndig, weil
+ *  es keine native Routine ist und jedes Pixel einzeln gepr?ft wird.
+ *  Deswegen w?re die beste L?sung, wenn ich bufferedImage direkt updaten k?nnte.
+ *  Aber bufferedImage ist privat, ich kann auch in abgeleiteten Klassen nicht drauf
+ *  zugreifen. 
+ *  
+ *  Zur Not w?re auch denkbar, doDraw zu ?berschreiben, um bei jedem Aufruf alle 
+ *  Trackpoints neu zu zeichnen.
+ *  Work-Aorund: draw.drawImage(image,null,Color.Pink,0,0,1,1); bewirkt, dass awtImage ins
+ *  bufferedImage kopiert wird. Dabei wird die transparentColor (in mImage) nicht ge?ndert
+ *  und beim Aufruf von doDraw wird wieder die urspr?ngliche transparentColor verwendet
+ *  
+ */
+//was alles nicht funktioniert:
+//drawmask.setDrawOp(Graphics.DRAW_OVER);
+//drawmask.drawRect(x-1, y-1, 2, 2, 1);
+//this.setImage(image, mask);
+//n?chster Versuch: image.bufferedImage in ewe.fx.Image public definieren !!!
+//image.rgb
+//draw._g.surfaceData.bufImg.raster.data[y*this.location.width + x] = -65536; := image._awtImage
+//((Image)image).eImage(colorOrMask)._awtImage.raster.data[0]=0;
+//image
+//((BufferedImage)(image).se.^.bufferedImage.raster.data[y*this.location.width + x]=-65536; //was dort steht wird tats?chlich angezeigt, allerdings kann ich es nicht direkt setzen :-(
+//int[] markPixels = new int[4];
+//for (int i = 0; i<markPixels.length; i++) { markPixels[i] = -65536; }
+//image.transparent = null; hilft auhc nicht
+//image.mask = null;
+//image.bufferedImage = null;
+//image.setPixels(markPixels, 0 , x-20, y, 2, 2, 0); // dadrin sollte bufferedImage = null gesetzt werden, wird es aber nicht :-(
+//ewe.fx.mImage mark = new mImage();
+//Image mark = new Image(2,2);
+//new Graphics(mark).drawImage(image, null, transparentColor, x-40, y, 2, 2);
+//mark.draw(draw, x-50, y, Graphics.DRAW_OVER); // options (Graphics.DRAW_OVER) are ignored anyway
+//image.bufferedImage = null; // this solves the problem
+//toCursor(null);
+//this.draw(draw);
+//image=(BufferedImage)this.toNativeImage(transparentColor);
+//(java.awt.Image.b)
+//image.bufferedImage=null;
+//draw.flush();
+//ewe.ui.PenEvent.refreshTip(draw.surface);
+//draw.setPixelRGB(x, y, -65536);
+//this.changed(); hilft auch nicht
+//this.refresh(); // hilft nicht :-(
+//lastDrawn.x = lastDrawn.x -10; hilft auch nicht
+//imageMayChange = true; // hilft auch nicht :-(
+
+/*
+ * In der ewe-VM f?r PocketPC-ARM funktioniert die Festlegung einer 
+ * transparenten Farbe nicht (Hintergrund wird wei? statt durchsichtig)
+ * deswegen (und weil in ewe-VM effizienter) Umstellung auf Transparenzmaske
+ * statt transparenter Farbe
+ * TODO Dies ist in Java-VM allerdings extrem Speicher fressend -> evtl abfragen 
+static int fixMask(WObject image,WObject col,int isMask):
+	in Maske: 0 an durchsichtiger Stelle, sonst ff
+	in Image: ffffff an durchsichtiger Stelle
+
+	in java-VM
+	in Maske: ffffffff in image.mask, wenn nicht durchsichtig
+	          ff000000 an durchsichtiger Stelle
+	image.doCheckMask erzeugt ein Image mit 0 an den durchsichtigen Stellen, die dadurch definiert sind, dass im image 0xffffff und in (mask & 0xffffff == 0) steht.
+ */
+/*
+ * this class is only needed to have a fast access to the list of pixels
+ * which are added but aniimage.draw will not lead to a change on the screen
+ * so that these pixels will be drawn seperately by doDraw
+ * 
+ */

Copied: trunk/src/CacheWolf/map/TrackPoint.java (from rev 878, trunk/src/CacheWolf/TrackPoint.java)
===================================================================
--- trunk/src/CacheWolf/TrackPoint.java	2007-09-04 23:05:39 UTC (rev 878)
+++ trunk/src/CacheWolf/map/TrackPoint.java	2007-09-05 02:06:44 UTC (rev 880)
@@ -0,0 +1,38 @@
+package CacheWolf.navi;
+
+import ewe.io.BufferedWriter;
+import ewe.io.FileWriter;
+import ewe.io.IOException;
+import ewe.io.PrintWriter;
+import ewe.ui.MessageBox;
+import ewe.util.Utils;
+
+/**
+ * this is not CWPoint because it should be as small as possible
+ * @author pfeffer
+ *
+ */
+
+public class TrackPoint  {
+	public double latDec;
+	public double lonDec;
+	
+	public TrackPoint(){
+		latDec = -91;
+		lonDec = -361;
+	}
+	
+	public TrackPoint(TrackPoint t) {
+		latDec = t.latDec;
+		lonDec = t.lonDec;
+	}
+	public TrackPoint(double lat, double lon) {
+		latDec = lat;
+		lonDec = lon;
+	}
+	public boolean equals(TrackPoint tp) {
+		return latDec == tp.latDec && lonDec == tp.lonDec;
+	}
+
+}
+



From pfeffer at mail.berlios.de  Wed Sep  5 04:08:19 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 5 Sep 2007 04:08:19 +0200
Subject: [Cachewolf-svn] r881 - trunk/src/CacheWolf
Message-ID: <200709050208.l8528JnH006380@sheep.berlios.de>

Author: pfeffer
Date: 2007-09-05 04:08:11 +0200 (Wed, 05 Sep 2007)
New Revision: 881

Removed:
   trunk/src/CacheWolf/Area.java
   trunk/src/CacheWolf/AreaList.java
   trunk/src/CacheWolf/CWGPSPoint.java
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/Map.java
   trunk/src/CacheWolf/MapDetailForm.java
   trunk/src/CacheWolf/MapInfoObject.java
   trunk/src/CacheWolf/MapLoader.java
   trunk/src/CacheWolf/MapLoaderGui.java
   trunk/src/CacheWolf/MapsList.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/Navigate.java
   trunk/src/CacheWolf/SelectMap.java
   trunk/src/CacheWolf/SkyOrientation.java
   trunk/src/CacheWolf/TrackOverlay.java
   trunk/src/CacheWolf/TrackPoint.java
Modified:
   trunk/src/CacheWolf/CWPoint.java
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/MainForm.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/Profile.java
Log:
necessary changes for the last commit: all classes that deal anyhow with navigation (goto, map, gps) moved to package CacheWolf.navi in order to make the source more clearly arranged, .jnf, bat and sh accordingly adjusted, please test

Deleted: trunk/src/CacheWolf/Area.java
===================================================================
--- trunk/src/CacheWolf/Area.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/Area.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -1,72 +0,0 @@
-package CacheWolf;
-
-class Area {
-	 public final static int NOT_ON_EDGE = -1;
-	 public final static int AT_TOP_EDGE = 1;
-	 public final static int AT_RIGHT_EDGE = 2;
-	 public final static int AT_BUTTOM_EDGE = 3;
-	 public final static int AT_LEFT_EDGE = 4;
-	 public static double edgeTolerance = 3 * 360/40000000; // approx 3m will be seen as the same
-
-	 CWPoint topleft;
-	 CWPoint buttomright;
-
-	 public Area(CWPoint tl, CWPoint br){
-		 topleft = new CWPoint(tl);
-		 buttomright = new CWPoint(br);
-	 }
-
-	 public boolean isInBound(CWPoint p) {
-		 if (topleft.latDec >= p.latDec && topleft.lonDec <= p.lonDec 
-				 && buttomright.latDec <= p.latDec && buttomright.lonDec >= p.lonDec) return true;
-		 else return false;
-	 }
-	 //if(affine[4] >= lati && lati >= lowlat && affine[5] <= loni && loni <= lowlon) isInBound = true;
-		
-	 public boolean isInBound(double lat, double lon) {
-		 if (topleft.latDec >= lat && topleft.lonDec <= lon
-				 && buttomright.latDec <= lat && buttomright.lonDec >= lon) return true;
-		 else return false;
-	 }
-	 
-	 public boolean isOverlapping(Area a) {
-		 if (       isInBound(a.topleft) || isInBound(a.buttomright) 
-				 || isInBound(a.buttomright.latDec, a.topleft.lonDec) // buttom left
-				 || isInBound(a.topleft.latDec, a.buttomright.lonDec) // top right
-				 // in case this is completly within a, the above tests will give false, so testing the otherway around
-				 || a.isInBound(this.topleft) || a.isInBound(this.buttomright)
-				 || a.isInBound(this.buttomright.latDec, this.topleft.lonDec) // buttom left
-				 || a.isInBound(this.topleft.latDec, this.buttomright.lonDec)) // top right
-			 return true;
-		 else return false;
-	 }
-
-	 public boolean equals(Area a) {
-		 if(java.lang.Math.abs(topleft.latDec - a.topleft.latDec) < edgeTolerance 
-				 && java.lang.Math.abs(topleft.lonDec - a.topleft.lonDec) < edgeTolerance
-				 && java.lang.Math.abs(buttomright.latDec - a.buttomright.latDec) < edgeTolerance
-				 && java.lang.Math.abs(buttomright.lonDec - a.buttomright.lonDec) < edgeTolerance )
-			 return true;
-		 else return false;
-	 }
-	 
-	 public int getEdge(CWPoint tl, CWPoint br) {
-		 if (java.lang.Math.abs(topleft.latDec - br.latDec) < edgeTolerance 
-				 && java.lang.Math.abs(topleft.lonDec - tl.lonDec) < edgeTolerance 
-				 && java.lang.Math.abs(buttomright.lonDec - br.lonDec) < edgeTolerance)
-			 return AT_TOP_EDGE;
-			 if (java.lang.Math.abs(topleft.latDec - tl.latDec) < edgeTolerance 
-					 && java.lang.Math.abs(buttomright.lonDec - tl.lonDec) < edgeTolerance 
-					 && java.lang.Math.abs(buttomright.latDec - br.latDec) < edgeTolerance)
-				 return AT_RIGHT_EDGE;
-			 if (java.lang.Math.abs(topleft.lonDec - tl.lonDec) < edgeTolerance 
-					 && java.lang.Math.abs(buttomright.latDec - tl.latDec) < edgeTolerance 
-					 && java.lang.Math.abs(buttomright.lonDec - br.lonDec) < edgeTolerance)
-				 return AT_BUTTOM_EDGE;
-			 if (java.lang.Math.abs(topleft.latDec - tl.latDec) < edgeTolerance 
-					 && java.lang.Math.abs(topleft.lonDec - br.lonDec) < edgeTolerance 
-					 && java.lang.Math.abs(buttomright.latDec - br.latDec) < edgeTolerance)
-				 return AT_LEFT_EDGE;
-			 return NOT_ON_EDGE;
-	 }
-}
\ No newline at end of file

Deleted: trunk/src/CacheWolf/AreaList.java
===================================================================
--- trunk/src/CacheWolf/AreaList.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/AreaList.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -1,73 +0,0 @@
-package CacheWolf;
-
-
-/**
- * Class for handling a list of areas covered by a list of maps.
- * this is needed to determine if a new map should be downloaded or
- * if a map for the requested area already exists
- *
- * @author pfeffer
- *
- */
- public class AreaList extends ewe.util.LinkedListElement { // in java since v1.2 I would use java.util.TreeSet
-/*
-	 public AreaList(int s) {super(s);}
-
-	 public void addArea(CWPoint topleft, CWPoint buttomright) {
-		 Area tp = getArea(topleft);
-		 if (tp != null && tp.isInBound(buttomright)) return; // area already completly in list
-		 int edge = tp.getEdge(topleft, buttomright);
-		 switch (edge) {
-		 case Area.AT_TOP_EDGE: tp.topleft.latDec = topleft.latDec; break;
-		 case Area.AT_RIGHT_EDGE: tp.buttomright.lonDec = buttomright.lonDec; break;
-		 case Area.AT_BUTTOM_EDGE: tp.buttomright.latDec = buttomright.latDec; break;
-		 case Area.AT_LEFT_EDGE: tp.topleft.lonDec = topleft.lonDec; break;
-		 case Area.NOT_ON_EDGE: addAreaUnconditionally(new Area(topleft, buttomright));
-		 }
-	 }
-
-	 public boolean AreaIsCovered(CWPoint topleft, CWPoint buttomright) {
-		 Area tp = getArea(topleft);
-		 if (tp != null && tp.isInBound(buttomright)) return true; // area already completly in list
-		 else return false;
-
-	 }
-
-	 public void addArea(Area a) {
-		 addArea(a.topleft, a.buttomright);
-	 }
-
-	 public static AreaList joinAreas(AreaList al){
-		 AreaList ret = null;
-		 while (!al.equals(ret)) {
-			 ret = new AreaList(al.size());
-			 for (int i=al.size()-1; i >= 0; i--) {
-				 ret.addArea((Area)al.get(i));
-			 }
-		 }
-		 return ret;
-	 }
-
-	 public boolean equals(AreaList al){
-		 if (size() != al.size()) return false;
-		 for (int i = size()-1; i >= 0; i--) {
-			 if (!( ((Area)get(i)).equals((Area)al.get(i)) )) return false;
-		 }
-		 return true;
-	 }
-
-	 private void addAreaUnconditionally(Area a) {
-		 add(a); // TODO insert at the correct / sorted position
-	 }
-
-	 public Area getArea(CWPoint p) {
-		 Area ret;
-		 for (int i=size()-1; i>=0; i--) {
-			 ret = ((Area)get(i));
-			 if(ret.isInBound(p)) return ret;
-		 }
-		 return null;
-	 }
-
-*/
- }

Deleted: trunk/src/CacheWolf/CWGPSPoint.java
===================================================================
--- trunk/src/CacheWolf/CWGPSPoint.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/CWGPSPoint.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -1,332 +0,0 @@
-/*
- * Created on 02.04.2005
- *
- * TODO To change the template for this generated file go to
- * Window - Preferences - Java - Code Style - Code Templates
- */
-package CacheWolf;
-import ewe.sys.*;
-import ewe.ui.ExecTransfer;
-import ewe.io.*;
-
-
-
-/**
- * @author Kalle
- * Class for decoding NMEA sentences
- */
-
-public class CWGPSPoint extends CWPoint implements TimerProc{
-	static protected final int LOGNMEA = 0x01;
-	static protected final int LOGRAW  = 0x02;
-	static protected final int LOGALL  = LOGNMEA|LOGRAW;
-
-	double Speed; //Speed
-	double Bear;	//Bearing
-	String Time; //Time
-	String Date;
-	int Fix; //Fix
-	int numSat; //Satellites in use, -1 indicates no data, -2 that data could not be interpreted
-	double HDOP; // Horizontal dilution of precision
-	double Alt; //Altitude
-
-	//Logging
-	int logTimer = 0;
-	int logFlag = 0;
-	boolean writeLog = false;
-	boolean doLogging = false;
-	FileWriter logFile;
-	String lastStrExamined = new String();
-
-
-	public CWGPSPoint()
-	{
-		super();
-		this.Speed = 0;
-		this.Bear = 0;
-		this.Time = "";
-		this.Date="";
-		this.Fix = 0;
-		this.numSat = 0;
-		this.Alt = 0;
-		this.HDOP = 0;
-	}
-
-
-	public double getSpeed(){
-		return this.Speed;
-	}
-
-	public double getBear (){
-		return this.Bear;
-	}
-	public String getTime(){
-		return this.Time;
-	}
-
-	public int getFix(){
-		return this.Fix;
-	}
-
-	/**
-	 * this method should be called, if COM-Port is closed
-	 */
-	public void noData(){
-		this.Fix = 0;
-		this.numSat = 0;
-	}
-
-	/**
-	 * this method should be called, if not data is coming from COM-Port but is expected to come
-	 */
-	public void noDataError(){
-		this.Fix = -1;
-		this.numSat = -1;
-	}
-
-	/**
-	 * this method should be called, if examine returns for several calls that it couldn't interprete the data
-	 */
-	public void noInterpretableData(){
-		this.Fix = -2;
-		this.numSat = -2;
-	}
-
-	public void ticked(int timerId, int elapsed){
-		if (timerId == logTimer) {
-			writeLog = true;
-		}
-
-	}
-
-	/**
-	 * 
-	 * @param logFileDir directory for logfile
-	 * @param seconds	 intervall for writing to logfile
-	 * @param flag		 level of logging
-	 * @return 0 success, -1 failure
-	 */
-	public int startLog(String logFileDir, int seconds, int flag){
-
-		Time currTime = new Time();
-		currTime.getTime();
-		currTime.setFormat("yyyyMMdd'_'HHmm");
-		String logFileName = new String(logFileDir + currTime.toString()+ ".log");
-		// create Logfile
-		try {
-			logFile = new FileWriter(logFileName);
-		} catch (IOException e) {
-			Vm.debug("Error creating LogFile " + logFileName);
-			return -1;
-		} 
-		// start timer
-		logTimer = Vm.requestTimer(this, 1000 * seconds);
-		logFlag = flag;
-		doLogging = true;
-		return 0;
-	}
-
-	public void stopLog() {
-		writeLog = false;
-
-		if (doLogging){
-			try {
-				logFile.close();
-			} catch (IOException e) {}
-			if (logTimer > 0) {
-				Vm.cancelTimer(logTimer);
-				logTimer = 0;
-			}
-		}
-		doLogging = false;
-	}
-
-
-	public int getSats(){
-		return this.numSat;
-	}
-
-	public double getAlt(){
-		return this.Alt;
-	}
-
-	public double getHDOP(){
-		return this.HDOP;
-	}
-
-	/**
-	 * 
-	 * @param NMEA	string with data to examine
-	 * @return true if some data could be interpreted false otherwise
-	 */
-	public boolean examine(String NMEA){ 
-		boolean interpreted = false;
-		try {
-			int i, start, end;
-			String latDeg="0", latMin="0", latNS="N"; 
-			String lonDeg="0", lonMin="0", lonEW="E";
-			String currToken;
-			end = 0;
-			lastStrExamined = NMEA;
-			//Vm.debug(NMEA);
-			if (writeLog && (logFlag & LOGRAW) > 0){ 
-				try {
-					logFile.write(NMEA);
-					writeLog = false;
-				} catch (IOException e) {}
-			}
-			while(true){
-				start = NMEA.indexOf("$GP", end);  
-				if (start == -1) return interpreted;  
-				end = NMEA.indexOf("*", start);  
-				if ((end == -1)||(end+3 > NMEA.length())) return interpreted;  
-
-
-				//Vm.debug(NMEA.substring(start,end+3));
-				if ((end - start) < 15 || !checkSumOK(NMEA.substring(start,end+3))){
-					//Vm.debug("checksum wrong");
-					continue;
-				}
-				Extractor ex = new Extractor ("," + NMEA.substring(start,end), ",",",",0,true);
-				currToken = ex.findNext();
-				if (currToken.equals("$GPGGA")){
-					//Vm.debug("In $GPGGA");
-					i = 0;
-					while(ex.endOfSearch() != true){
-						currToken = ex.findNext();
-						i++;
-						if (currToken.length()==0) continue; // sometimes there are 2 colons directly one after the other like ",," (e.g. loox)
-						switch (i){
-						case 1: this.Time = currToken; break;
-						case 2: try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {}
-						try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {}
-						break;
-						case 3: latNS = currToken;
-						break;
-
-						case 4: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {}
-						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true; } catch (IndexOutOfBoundsException e) {}
-						break;
-						case 5: lonEW = currToken;
-						break;
-						case 6: this.Fix = Convert.toInt(currToken); interpreted = true; break;
-						case 7: this.numSat = Convert.toInt(currToken); interpreted = true; break;
-						case 8: try {this.HDOP = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} break;
-						case 9: try {this.Alt = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} break;
-						} // switch
-					} // while
-					if (Fix > 0) this.set(latNS, latDeg, latMin, "0", lonEW, lonDeg, lonMin, "0", CWPoint.DMM);
-
-				} // if
-
-				if (currToken.equals("$GPVTG")){
-					i = 0;
-					while(ex.endOfSearch() != true){
-						currToken = ex.findNext();
-						i++;
-						if (currToken.length()==0) continue;
-						switch (i){
-						case 1: try { this.Bear =Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {}
-						if (this.Bear > 360) Vm.debug("Error bear VTG");
-						break;
-						case 7: try { this.Speed = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} 
-						break;
-						} // switch
-					} // while
-				} // if
-
-				if (currToken.equals("$GPRMC")){
-					//Vm.debug("In $GPRMC");
-					i = 0;
-					String status = "V";
-					while(ex.endOfSearch() != true){
-						currToken = ex.findNext();
-						i++;
-						if (currToken.length()==0) continue;
-						//Vm.debug("zz: " + i);
-						//Vm.debug(currToken);
-						switch (i){
-						case 1: this.Time = currToken; interpreted = true; break;
-						case 2: status = currToken; 
-						if (status.equals("A")) this.Fix = 1;
-						else this.Fix = 0;
-						interpreted = true;
-						break;
-						case 3: 	//Vm.debug("Here--->");
-							try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {}
-							//Vm.debug(":" + latDeg);
-							try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {}
-							//Vm.debug(":" + latMin);
-							break;
-						case 4: latNS = currToken; interpreted = true;
-						break;
-						case 5: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {}
-						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {}
-						break;
-						case 6: lonEW = currToken;
-						interpreted = true;
-						break;
-						case 7: if (status.equals("A")){
-							try {this.Speed = Common.parseDouble(currToken)*1.854;
-							interpreted = true; } catch (NumberFormatException e) { }
-						}
-						break;
-						case 8: if (status.equals("A") && currToken.length()> 0){
-							try {this.Bear = Common.parseDouble(currToken);
-							interpreted = true; } catch (NumberFormatException e) { }
-						}
-						break;
-						case 9: if (status.equals("A") && currToken.length()> 0){
-							try {this.Date = currToken;
-							interpreted = true; } catch (NumberFormatException e) { }
-						}
-						break;
-						} // switch
-					} // while
-					if (status.equals("A")){
-						this.set(latNS, latDeg, latMin, "0",
-								lonEW, lonDeg, lonMin, "0", CWPoint.DMM);				
-					}
-				} // if
-				//Vm.debug("End of examine");
-			} //while
-		} catch (Exception e) {
-			Global.getPref().log("Exception in examine in CWGPSPoint", e, true);
-			e.printStackTrace();
-			return interpreted;
-		}
-	}
-
-	private boolean checkSumOK(String nmea){
-		int startPos = 1; // begin after $
-		int endPos = nmea.length() - 3;// without * an two checksum chars
-		byte checkSum = 0;
-
-		for (int i= startPos; i<endPos;i++){
-			checkSum ^= nmea.charAt(i);
-		}
-		//Vm.debug(nmea.substring(3,6)+" Checksum: " + nmea.substring(endPos+1) + " Calculated: " + Convert.intToHexString(checkSum));
-		try { return (checkSum == Byte.parseByte(nmea.substring(endPos+1),16));
-		} catch (IndexOutOfBoundsException e) {
-			return false;
-		} catch (NumberFormatException e) {
-			return false;
-		}
-	}
-
-
-
-	public void printAll(){
-		Vm.debug("Latitude:  " + this.getLatDeg(DD));
-		Vm.debug("Longitude: " + this.getLonDeg(DD));
-		Vm.debug("Speed:     " + this.Speed);
-		Vm.debug("Bearing:   " + this.Bear);
-		Vm.debug("Time:      " + this.Time);
-		Vm.debug("Fix:       " + this.Fix);
-		Vm.debug("Sats:      " + this.numSat);
-		Vm.debug("HDOP:      " + this.HDOP);
-		Vm.debug("Alt:       " + this.Alt);
-		Vm.debug("----------------");
-	}
-}
-

Modified: trunk/src/CacheWolf/CWPoint.java
===================================================================
--- trunk/src/CacheWolf/CWPoint.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/CWPoint.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -5,6 +5,8 @@
 import ewe.sys.Double;
 import ewe.sys.Locale;
 import ewe.sys.Convert;
+import CacheWolf.navi.TrackPoint;
+
 import com.bbn.openmap.proj.coords.*;
 import com.bbn.openmap.proj.*;
 import com.bbn.openmap.*;
@@ -22,8 +24,8 @@
  *
  */
 public class CWPoint extends TrackPoint{
-	MGRSPoint utm = new MGRSPoint();
-	boolean utmValid = false;
+	public MGRSPoint utm = new MGRSPoint();
+	public boolean utmValid = false;
 
 	public static final int DD = 0;
 	public static final int DMM = 1;

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -91,10 +91,10 @@
 private static StringBuffer sb=new StringBuffer(530); // Used in toXML()
 
 //static int nObjects=0;
-CacheHolder() {//nObjects++;Vm.debug("CacheHolder() nO="+nObjects);
+public CacheHolder() {//nObjects++;Vm.debug("CacheHolder() nO="+nObjects);
 }
 
-CacheHolder(CacheHolder ch) {//nObjects++;Vm.debug("CacheHolder(ch) nO="+nObjects);
+public CacheHolder(CacheHolder ch) {//nObjects++;Vm.debug("CacheHolder(ch) nO="+nObjects);
 	update(ch);
 }
 

Deleted: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -1,838 +0,0 @@
-package CacheWolf;
-
-import ewe.ui.*;
-import ewe.util.Vector;
-import ewe.util.mString;
-import ewe.fx.*;
-import ewe.graphics.AniImage;
-import ewe.io.*;
-import ewe.net.Socket;
-//import ewe.io.IOException;
-//import ewe.io.SerialPort;
-//import ewe.io.SerialPortOptions;
-import ewe.sys.*;
-import ewe.sys.Double;
-
-/**
- *	Class to create the panel which handles the connection to the GPS-device<br>
- *	Displays: current position,speed and bearing; relation to destination waypoint<br>
- *	Class ID: 1500
- */
-
-
-public class GotoPanel extends CellPanel {
-
-	//public CWGPSPoint gpsPosition = new CWGPSPoint();
-	//public CWPoint toPoint = new CWPoint();
-	public Navigate myNavigation;
-	mButton btnGPS, btnCenter,btnSave;
-	mButton btnGoto, btnMap;
-	int currFormat;
-
-	mLabel lblGPS, lblPosition, lblDST;
-	mLabel lblLog;
-	Color gpsStatus;
-	mCheckBox chkLog;
-	mInput inpLogSeconds;
-
-	MainTab mainT;
-	Vector cacheDB;
-	DetailsPanel detP;
-
-	Preferences pref;
-	Profile profile;
-	// different panels to avoid spanning
-	CellPanel ButtonP = new CellPanel();
-	CellPanel CoordsP = new CellPanel();
-	CellPanel roseP = new CellPanel();
-	CellPanel LogP = new CellPanel();
-
-	ImageControl icRose;
-	GotoRose compassRose;
-
-	final static Color RED = new Color(255,0,0);
-	final static Color YELLOW = new Color(255,255,0);
-	final static Color GREEN = new Color(0,255,0);
-	final static Color BLUE = new Color(0,0,255);
-
-	final static Font BOLD = new Font("Arial", Font.BOLD, 14);
-
-	int ticker = 0;
-	
-	Menu mnuContextFormt;
-	MenuItem miDMM, miDMS, miDD, miUTM;
-	
-	Menu mnuContextRose;
-	MenuItem miLuminary[] = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
-	MenuItem miNorthCentered;
-	
-	/**
-	 * Create GotoPanel 
-	 * @param Preferences 	global preferences
-	 * @param MainTab		reference to MainTable
-	 * @param DetailsPanel 	reference to DetailsPanel
-	 * @param Vector		cacheDB
-	 */
-	public GotoPanel(Navigate nav) {
-		myNavigation = nav;
-		pref = Global.getPref();
-		profile=Global.getProfile();
-		mainT = Global.mainTab;
-		detP = mainT.detP;
-		cacheDB = profile.cacheDB;
-
-		// Button
-		ButtonP.addNext(btnGPS = new mButton("Start"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		ButtonP.addNext(btnCenter = new mButton(MyLocale.getMsg(309,"Center")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		ButtonP.addNext(btnSave = new mButton(MyLocale.getMsg(311,"Create Waypoint")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		ButtonP.addLast(btnMap = new mButton("Map"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-
-		//Format selection for coords		
-		//context menu
-		mnuContextFormt = new Menu();
-		mnuContextFormt.addItem(miDD = new MenuItem("d.d?"));
-		miDD.modifiers &= ~MenuItem.Checked;
-		mnuContextFormt.addItem(miDMM = new MenuItem("d?m.m\'"));
-		miDMM.modifiers |= MenuItem.Checked;
-		mnuContextFormt.addItem(miDMS = new MenuItem("d?m\'s\""));
-		miDMS.modifiers &= ~MenuItem.Checked;
-		mnuContextFormt.addItem(miUTM = new MenuItem("UTM"));
-		miUTM.modifiers &= ~MenuItem.Checked;
-		currFormat = CWPoint.DMM;
-
-		// Create context menu for compass rose: select luminary for orientation
-		mnuContextRose = new Menu();
-		for (int i=0; i<SkyOrientation.LUMINARY_NAMES.length; i++) {
-			mnuContextRose.addItem(miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i)));
-			if (i == myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
-			else miLuminary[i].modifiers &= MenuItem.Checked;
-		}
-
-		//Coords
-		CoordsP.addNext(lblGPS = new mLabel("GPS: "),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		lblGPS.backGround = RED;
-		lblGPS.setMenu(mnuContextFormt);
-		lblGPS.modifyAll(Control.WantHoldDown, 0);
-		CoordsP.addLast(lblPosition = new mLabel(myNavigation.gpsPos.toString(currFormat)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		lblPosition.setMenu(mnuContextFormt);
-		lblPosition.modifyAll(Control.WantHoldDown, 0);
-		CoordsP.addNext(lblDST = new mLabel(MyLocale.getMsg(1500,"DST:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		lblDST.backGround = new Color(0,0,255);
-		lblDST.setMenu(mnuContextFormt);
-		lblDST.modifyAll(Control.WantHoldDown, 0);
-		CoordsP.addLast(btnGoto = new mButton(getGotoBtnText()),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-
-		//Rose for bearing
-		compassRose = new GotoRose("rose.png");
-		icRose = new ImageControl(compassRose);
-		icRose.setMenu(mnuContextRose);
-		icRose.modifyAll(Control.WantHoldDown, 0); // this is necessary in order to make PenHold on a PDA work as right click
-		roseP.addLast(icRose,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTH));
-		
-		mnuContextRose.addItem(new MenuItem("", MenuItem.Separator, null));
-		mnuContextRose.addItem(miNorthCentered = new MenuItem(MyLocale.getMsg(1503,"North Centered")));
-		if (compassRose.isNorthCentered()) miNorthCentered.modifiers |= MenuItem.Checked;
-		else miNorthCentered.modifiers &= MenuItem.Checked;
-
-		//log
-		LogP.addNext(lblLog = new mLabel("Log "),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		LogP.addNext(chkLog = new mCheckBox(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		LogP.addNext(inpLogSeconds = new mInput("10"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		LogP.addLast(new mLabel("sec"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-
-		chkLog.useCross = true;
-		chkLog.setState(false);
-		inpLogSeconds.columns = 5;
-
-		//add Panels
-		this.addLast(ButtonP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
-		this.addLast(CoordsP,CellConstants.HSTRETCH, CellConstants.HFILL|CellConstants.NORTH).setTag(SPAN,new Dimension(2,1));
-		this.addLast(roseP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
-		//this.addLast(LogP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.NORTHWEST).setTag(SPAN,new Dimension(1,1));
-
-		// for debuging
-		/*		CWGPSPoint myGPS;
-		myGPS = new CWGPSPoint();
-		String ex = new String();
-		boolean test = false;
-		try { FileReader f = new FileReader("c:\\kw\\20060928_1051.log");
-		ex = f.readAll();
-		test = myGPS.examine(ex);
-		f.close();
-		} catch (IOException e ) {
-			Vm.debug(e.toString());
-		}
-		test = myGPS.examine("$GPGLL,5226.8935,N,01338.5327,E,084635.00,A,D*6E");
-		test = myGPS.examine("$GPGSA,A,3,10,28,26,29,09,,,,,,,,04.1,02.6,03.2*0F");
-		test = myGPS.examine("$GPGSV,4,1,13,08,40,072,28,10,29,201,47,27,15,079,29,28,62,102,44*7E");
-		test = myGPS.examine("$GPGSV,4,2,13,29,72,289,38,26,63,296,41,09,12,259,35,18,14,324,*79");
-		test = myGPS.examine("$GPGSV,4,3,13,19,09,025,,17,06,138,,21,06,300,,37,29,171,40*7A");
-		test = myGPS.examine("$GPGSV,4,4,13,39,29,166,38*40");
-		 */
-
-		//while (true){
-//		int notinterpreted = 0;
-//		if (myGPS.examine("@??H @??H?@??HH???????H")) { notinterpreted = 0;} else notinterpreted++;
-//		if (notinterpreted > 5) myGPS.noInterpretableData();
-//		// myGPS.noInterpretableData();
-
-
-//		}	
-	}
-
-
-	/**
-	 * set the coords of the destination  
-	 * @param dest destination
-	 */ 
-	public void setDestination(CWPoint dest){
-		myNavigation.setDestination(dest);
-		if (!myNavigation.destination.isValid()) (new MessageBox("Error", "Coordinates are out of range: \n"+"latitude: "+myNavigation.destination.latDec+"\n longditue: "+myNavigation.destination.lonDec, MessageBox.OKB)).execute();
-		
-	}
-	
-	public void destChanged(CWPoint d) { // called from myNavigate
-		btnGoto.setText(getGotoBtnText());
-		updateDistance();
-	}
-	
-
-	/**
-	 * set the coords of the destination and switch to gotoPanel  
-	 * @param LatLon destination
-	 */ 
-	public void setDestinationAndSwitch(String LatLon) {
-		myNavigation.setDestination(LatLon);
-		mainT.select(this);
-	}
-	
-	/**
-	 * updates distance and bearing
-	 *
-	 */
-	
-	public void updateDistance() {
-		//update distance
-		float distance = -1.0f;
-		if (myNavigation.gpsPos.isValid() && myNavigation.destination.isValid() ) {
-			distance = (float)myNavigation.gpsPos.getDistance(myNavigation.destination);
-		}
-		compassRose.setWaypointDirectionDist((float)myNavigation.gpsPos.getBearing(myNavigation.destination), distance);
-	}
-
-	/**
-	 * method which is called if a timer is set up  
-	 */ 
-	public void updateGps(int fix) {
-		Double bearMov = new Double();
-		Double speed = new Double();
-		Double sunAzimut = new Double();
-		Vm.debug("ticked: voher");
-		compassRose.setGpsStatus(fix, myNavigation.gpsPos.getSats(), myNavigation.gpsPos.getHDOP());
-		if ((fix > 0) && (myNavigation.gpsPos.getSats()>= 0)) {
-			// display values only, if signal good
-			//Vm.debug("currTrack.add: nachher");
-			lblPosition.setText(myNavigation.gpsPos.toString(currFormat));
-			sunAzimut.set(myNavigation.skyOrientationDir.lonDec);
-			bearMov.set(myNavigation.gpsPos.getBear());
-			updateDistance();
-			compassRose.setSunMoveDirections((float)sunAzimut.value, (float)bearMov.value, (float)speed.value);
-			// Set background to signal quality
-		}
-
-		// receiving data, but signal ist not good
-		if ((fix == 0) && (myNavigation.gpsPos.getSats()>= 0)) {
-			gpsStatus = YELLOW;
-		}
-		// receiving no data
-		if (fix == -1) {
-			if (gpsStatus != RED) (new MessageBox("Error", "No data from GPS\nConnection to serial port closed",MessageBox.OKB)).exec();
-			gpsStatus = RED;
-			myNavigation.stopGps();
-		}
-		// cannot interprete data
-		if (fix == -2) {
-			if (gpsStatus != RED) (new MessageBox("Error", "Cannot interpret data from GPS\n possible reasons:\n wrong Port,\n wrong Baudrate,\n not NMEA-Protocol\nConnection to serial port closed\nLast String tried to interprete:\n "+myNavigation.gpsPos.lastStrExamined, MessageBox.OKB)).exec();
-			gpsStatus = RED;
-			myNavigation.stopGps(); // TODO automatic in myNavigate?
-		}
-	}
-
-	public void gpsStarted() {
-		chkLog.modify(ControlConstants.Disabled,0);
-		btnGPS.setText("Stop");
-	}
-	
-	public void startGps() {
-		myNavigation.setRawLogging(chkLog.getState(), Convert.toInt(inpLogSeconds.getText()));
-		myNavigation.startGps();
-	}
-
-	public void gpsStoped() {
-		btnGPS.setText("Start");
-		gpsStatus = this.backGround;
-		chkLog.modify(0,ControlConstants.Disabled);
-		this.repaintNow(); // without this the change in the background color will not be displayed
-	}
-
-	
-	private String getGotoBtnText() {
-		if (myNavigation.destination == null) return "not set";
-		else return myNavigation.destination.toString(currFormat);
-	}
-	
-	public void switchToMovingMap() {
-		CWPoint centerTo;
-		if (myNavigation.isGpsPosValid()) centerTo = new CWPoint(myNavigation.gpsPos); // set gps-pos if gps is on
-		else {
-			// setze Zielpunkt als Ausgangspunkt, wenn GPS aus ist und lade entsprechende Karte
-			//centerTo = new CWPoint(myNavigation.destination);
-			if (myNavigation.destination.isValid())	centerTo = new CWPoint(myNavigation.destination);
-			else centerTo = new CWPoint(pref.curCentrePt); // if not goto-point defined move map to centere point
-		}  
-		mainT.SwitchToMovingMap(centerTo, false);
-	}
-	
-	/**
-	 * Eventhandler
-	 */
-
-	public void onEvent(Event ev){
-		if (ev instanceof MenuEvent) { 
-			if (ev.type == MenuEvent.SELECTED ) {
-				MenuItem action = (MenuItem) mnuContextFormt.getSelectedItem(); 
-				if (action != null) {
-					if (action == miDD) {
-						mnuContextFormt.close();
-						currFormat = CWPoint.DD;
-					}
-					if (action == miDMM) {
-						mnuContextFormt.close();
-						currFormat = CWPoint.DMM;
-					}
-					if (action == miDMS) {
-						mnuContextFormt.close();
-						currFormat = CWPoint.DMS;
-					}
-					if (action == miUTM) {
-						mnuContextFormt.close();
-						currFormat = CWPoint.UTM;
-					}
-					miDD.modifiers &= ~MenuItem.Checked;
-					miDMM.modifiers &= ~MenuItem.Checked;
-					miDMS.modifiers &= ~MenuItem.Checked;
-					miUTM.modifiers &= ~MenuItem.Checked;
-					switch (currFormat) {
-					case CWPoint.DD: miDD.modifiers |= MenuItem.Checked; break;   
-					case CWPoint.DMM: miDMM.modifiers |= MenuItem.Checked; break;   
-					case CWPoint.DMS: miDMS.modifiers |= MenuItem.Checked; break;   
-					case CWPoint.UTM: miUTM.modifiers |= MenuItem.Checked; break;
-					}
-
-					lblPosition.setText(myNavigation.gpsPos.toString(currFormat));
-					btnGoto.setText(getGotoBtnText());
-				} // end lat-lon-format context menu
-				action = (MenuItem) mnuContextRose.getSelectedItem();
-				if (action != null) {
-					for (int i=0; i<miLuminary.length; i++) {
-						if (action == miLuminary[i]) {
-							myNavigation.setLuminary(i);
-							miLuminary[i].modifiers |= MenuItem.Checked;
-							compassRose.setLuminaryName(SkyOrientation.getLuminaryName(myNavigation.luminary));
-						} else miLuminary[i].modifiers &= ~MenuItem.Checked;
-					}
-					if (action == miNorthCentered) {
-						if (compassRose.isNorthCentered()) {
-							compassRose.setNorthCentered(false);
-							miNorthCentered.modifiers &= ~MenuItem.Checked;							
-						}
-						else
-						{
-							compassRose.setNorthCentered(true);
-							miNorthCentered.modifiers |= MenuItem.Checked;
-						}
-					}
-				}
-			}
-		}
-
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			// start/stop GPS connection
-			if (ev.target == btnGPS){
-				if (btnGPS.getText().equals("Start")) startGps();
-				else myNavigation.stopGps();
-			}
-
-			// set current position as center and recalculate distance of caches in MainTab 
-			if (ev.target == btnCenter){
-				Vm.showWait(true);
-				pref.curCentrePt.set(myNavigation.gpsPos);
-				mainT.updateBearDist();
-				Vm.showWait(false);
-			}
-			//Start moving map
-			if (ev.target == btnMap){
-				switchToMovingMap();
-			} 
-			// create new waypoint with current GPS-position
-			if (ev.target == btnSave){
-				CacheHolder ch = new CacheHolder();
-				ch.LatLon = myNavigation.gpsPos.toString();
-				ch.pos = new CWPoint(myNavigation.gpsPos);
-				mainT.newWaypoint(ch);
-			}
-			// change destination waypoint
-			if (ev.target == btnGoto){
-				CoordsScreen cs = new CoordsScreen();
-				if (myNavigation.destination.isValid())	cs.setFields(myNavigation.destination, currFormat);
-				else cs.setFields(new CWPoint(0,0), currFormat);
-				if (cs.execute(null, Gui.TOP) == CoordsScreen.IDOK)
-					setDestination(cs.getCoords());
-			}
-		}
-		super.onEvent(ev);
-	}
-}
-
-/** class for displaying the compass rose
- * including goto, sun and moving direction
- */
-class GotoRose extends AniImage {
-	float gotoDir = -361;
-	float sunDir = -361;
-	float moveDir = -361;
-	float distance = -1;
-	
-	int m_fix = -1;
-	int m_sats = -1;
-	double m_hdop = -1;
-	float m_speed = -1;
-	
-	String m_Luminary = MyLocale.getMsg(6100, "Sun");
-	
-	FontMetrics fm;
-	
-	boolean northCentered = Global.getPref().northCenteredGoto;
-	
-	final static Color RED = new Color(255,0,0);
-	final static Color YELLOW = new Color(255,255,0);
-	final static Color GREEN = new Color(0,255,0);
-	final static Color BLUE = new Color(0,0,255);
-	final static Color ORANGE = new Color(255,128,0);
-	final static Color DARKGREEN = new Color(0,192,0);
-	final static Color CYAN = new Color(0,255,255);
-	final static Color MAGENTA = new Color(255,0,255);
-
-	/**
-	 * @param gd goto direction
-	 * @param sd sun direction
-	 * @param md moving direction
-	 */
-	public GotoRose(String fn){
-		super(fn);
-	}
-	
-	public void setWaypointDirectionDist(float wd, float dist) {
-		gotoDir = wd;
-		distance = dist;
-	}
-	
-	public void setSunMoveDirections(float sd, float md, float speed ) {
-		sunDir = sd;
-		moveDir = md;
-		m_speed = speed;
-		refresh();
-	}
-	
-	public void setGpsStatus(int fix, int sats, double hdop) {
-		m_fix = fix;
-		m_sats = sats;
-		m_hdop = hdop;
-		refresh();
-	}
-	
-	public void setLuminaryName(String Luminary) {
-		m_Luminary = Luminary;
-		refresh();
-	}
-
-	
-	/**
-	 * draw arrows for the directions of movement and destination waypoint
-	 * @param ctrl the control to paint on
-	 * @param moveDir degrees of movement
-	 * @param destDir degrees of destination waypoint
-	 */
-	
-	public void doDraw(Graphics g,int options) {
-		if (northCentered) {
-			super.doDraw(g, options);
-		}
-		else {
-			g.setColor(Color.White);
-			g.fillRect(0, 0, location.width, location.height);
-		}
-		Font font = new Font("Verdana", Font.BOLD, 12);
-		g.setFont(font);
-		fm = g.getFontMetrics(font);
-		drawArrows(g);
-		drawWayPointData(g);
-		drawGpsData(g);
-		drawLuminaryData(g);
-		drawGpsStatus(g);
-	}
-		
-	private void drawWayPointData(Graphics g){
-		String strTemp = "WayPoint";
-		g.setColor(Color.DarkBlue);
-		g.fillRect(0, 0, fm.getTextWidth(strTemp) + 4 ,fm.getHeight());
-		g.setColor(Color.White);		
-		g.drawText(strTemp, 2, 0);
-		
-		g.setColor(Color.Black);		
-		
-		Double tmp = new Double();
-		strTemp = "";
-		if ( distance >= 0.0f ) {
-			tmp.set(distance);
-			if (tmp.value >= 1){
-				strTemp = MyLocale.formatDouble(tmp,"0.000")+ " km";
-			}
-			else {
-				tmp.set(tmp.value * 1000);
-				strTemp = tmp.toString(3,0,0) + " m";
-			}
-		}
-		else strTemp = "--- km";
-		g.drawText(strTemp, 2, 12);
-		
-		tmp.set(gotoDir);
-		if ((tmp.value <= 360) && (tmp.value >= -360))
-			strTemp = tmp.toString(0,0,0) + " " + MyLocale.getMsg(1502,"deg");
-		else strTemp = "---" + " " + MyLocale.getMsg(1502,"deg");
-		g.drawText(strTemp, 2, 24);
-	}
-	
-	private void drawGpsData(Graphics g){
-		g.setColor(RED);
-		
-		String strHeadline = MyLocale.getMsg(1501,"Current");
-		
-		Double tmp = new Double();
-
-		tmp.set(m_speed);
-		String strSpeed = "- km/h";
-		if (m_speed >= 0) {
-			if (m_speed >= 100) {
-				strSpeed = MyLocale.formatDouble(tmp,"0") + " km/h";				
-			}
-			else {
-				strSpeed = MyLocale.formatDouble(tmp,"0.0") + " km/h";
-			}
-		}
-		
-		tmp.set(moveDir);
-		String strMoveDir = "---" + " " + MyLocale.getMsg(1502,"deg");
-		if ((tmp.value <= 360) && (tmp.value >= -360))
-			strMoveDir = tmp.toString(0,0,0) + " " + MyLocale.getMsg(1502,"deg");
-
-		int textWidth = java.lang.Math.max(fm.getTextWidth(strSpeed), fm.getTextWidth(strMoveDir));
-		textWidth = java.lang.Math.max(textWidth, fm.getTextWidth(strHeadline));
-		
-		int startX = location.width - (textWidth + 4);
-		g.fillRect(startX, 0, location.width - startX ,12);
-		
-		g.setColor(Color.Black);		
-		g.drawText(strHeadline, startX + 2, 0);		
-		g.drawText(strSpeed, startX + 2, 12);
-		g.drawText(strMoveDir, startX + 2, 24);
-	}
-	
-	private void drawLuminaryData(Graphics g){
-		g.setColor(YELLOW);
-
-		String strSunDir = "---" + " " + MyLocale.getMsg(1502,"deg");
-		if (sunDir < 360 && sunDir > -360) {
-			Double tmp = new Double();
-			tmp.set(sunDir);
-			strSunDir = tmp.toString(0,0,0) + " " + MyLocale.getMsg(1502,"deg");
-		}
-
-		int textWidth = java.lang.Math.max(fm.getTextWidth(m_Luminary), fm.getTextWidth(strSunDir));
-		int startY = location.height - 24;
-		g.fillRect(0, startY, textWidth + 4, location.height - startY);
-
-		g.setColor(Color.Black);		
-		g.drawText(m_Luminary, 2, startY);
-		g.drawText(strSunDir, 2, startY + 12);
-	}
-	
-	private void drawGpsStatus(Graphics g){
-		if ((m_fix > 0) && (m_sats >= 0)) {
-			// Set background to signal quality
-			g.setColor(GREEN);
-		}
-		else
-		// receiving data, but signal ist not good
-		if ((m_fix == 0) && (m_sats >= 0)) {
-			g.setColor(YELLOW);
-		}
-		else {
-			g.setColor(RED);
-		}
-
-		String strSats = "Sats: -";
-		if (m_sats >= 0) strSats = "Sats: " + Convert.toString(m_sats);
-		String strHdop = "HDOP: -";
-		if (m_hdop >= 0) strHdop = "HDOP: " + Convert.toString(m_hdop);
-
-		int textWidth = java.lang.Math.max(fm.getTextWidth(strSats), fm.getTextWidth(strHdop));
-		int startX = location.width - (textWidth + 4);
-		int startY = location.height - 24;
-		g.fillRect(startX, startY, location.width - startX ,location.height - startY);
-
-		g.setColor(Color.Black);
-		g.drawText(strSats, startX + 2, startY);
-		g.drawText(strHdop, startX + 2, startY + 12);
-	}
-
-	private void drawArrows(Graphics g){
-		if (g != null)
-		{
-			// select moveDirColor according to difference to gotoDir
-			Color moveDirColor = RED;
-			
-			if (gotoDir < 360 && gotoDir > -360 && moveDir < 360 && moveDir > -360)
-			{
-				float diff = java.lang.Math.abs(moveDir - gotoDir);
-				while (diff > 360)
-				{
-					diff -= 360.0f;
-				}
-				if (diff > 180.0f)
-				{
-					diff = 360.0f - diff;
-				}
-				
-				if (diff <= 12.25f)
-				{
-					moveDirColor = GREEN;
-				}
-				else if (diff <= 22.5f)
-				{
-					moveDirColor = CYAN;
-				}
-				else if (diff <= 45.0f)
-				{
-					moveDirColor = ORANGE;
-				}
-				else if (diff <= 90.0f)
-				{
-					moveDirColor = MAGENTA;
-				}
-			}
-
-			// draw only valid arrows
-			if (northCentered) {
-				if (gotoDir < 360 && gotoDir > -360) drawThickArrow(g, gotoDir, Color.DarkBlue, 1.0f);
-				if (moveDir < 360 && moveDir > -360) drawThinArrow(g, moveDir, RED, moveDirColor, 1.0f);
-				if (sunDir < 360 && sunDir > -360) drawSunArrow(g, sunDir, YELLOW, 0.75f);
-			}
-			else {
-				//moveDir centered
-				int radius = (int)((float)(java.lang.Math.min(location.width, location.height) / 2) * 0.75f);
-
-				g.setPen(new Pen(new Color(150,150,150),Pen.SOLID,3));
-				g.drawEllipse(location.width/2 - radius, location.height/2 - radius, 2 * radius, 2 * radius );
-
-				if (moveDir < 360 && moveDir > -360) {
-					//drawDoubleArrow(g, 360 - moveDir, BLUE, new Color(175,0,0), 1.0f);
-					drawRose(g, 360 - moveDir, new Color(100,100,100), new Color(200,200,200), 1.0f);
-					
-					g.setPen(new Pen(RED,Pen.SOLID,3));
-					g.drawLine(location.width/2, location.height/2 - radius, location.width/2, location.height/2 + radius);
-					
-					if (gotoDir < 360 && gotoDir > -360) drawThinArrow(g, gotoDir - moveDir, Color.DarkBlue, moveDirColor, 1.0f);
-					if (sunDir < 360 && sunDir > -360) drawSunArrow(g, sunDir - moveDir, YELLOW, 0.75f);					
-				}				
-			}
-		}
-	}
-
-	/**
-	 * draw single arrow 
-	 * @param g handle for drawing
-	 * @param angle angle of arrow
-	 * @param col color of arrow
-	 */
-	private void drawSimpleArrow(Graphics g, float angle, Color col, float scale) {
-		float angleRad;
-		int x, y, centerX = location.width/2, centerY = location.height/2;
-		int arrowLength = java.lang.Math.min(centerX, centerY); 
-
-		angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		x = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad) * scale).intValue();
-		y = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad) * scale).intValue();
-		g.setPen(new Pen(col,Pen.SOLID,3));
-		g.drawLine(centerX,centerY,x,y);
-	}
-	
-	private void drawSunArrow(Graphics g, float angle, Color col, float scale) {
-		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
-		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
-		float halfArrowWidth = arrowLength * 0.08f;
-		float circlePos = arrowLength * 0.7f;
-		int circleRadius = (int)(arrowLength * 0.1f);
-
-		int pointX = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
-		int pointY = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
-		int circleX = centerX + new Float(circlePos * java.lang.Math.sin(angleRad)).intValue();
-		int circleY = centerY - new Float(circlePos * java.lang.Math.cos(angleRad)).intValue();
-
-		int[] pointsX = new int[4];
-		int[] pointsY = new int[4];
-
-		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
-		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
-		pointsX[1] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
-		pointsY[1] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
-		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
-		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
-		pointsX[3] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
-		pointsY[3] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
-		
-//		g.setPen(new Pen(col,Pen.SOLID,3));
-//		g.drawLine(centerX,centerY,pointX,pointY);
-		
-		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
-		g.setBrush(new Brush(col, Brush.SOLID));
-		g.fillPolygon(pointsX, pointsY, 4);
-		g.fillEllipse(circleX - circleRadius, circleY - circleRadius, 2 * circleRadius, 2 * circleRadius);
-	}
-	
-	private void drawThinArrow(Graphics g, float angle, Color col, Color colPoint, float scale) {
-		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
-		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
-		float halfOpeningAngle = (float)(java.lang.Math.PI * 0.03);
-		float sideLineLength = arrowLength * 0.75f;
-		
-		int[] pointsX = new int[4];
-		int[] pointsY = new int[4];
-
-		pointsX[0] = centerX + new Float(sideLineLength * java.lang.Math.sin(angleRad - halfOpeningAngle)).intValue();
-		pointsY[0] = centerY - new Float(sideLineLength * java.lang.Math.cos(angleRad - halfOpeningAngle)).intValue();
-		pointsX[1] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
-		pointsY[1] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
-		pointsX[2] = centerX + new Float(sideLineLength * java.lang.Math.sin(angleRad + halfOpeningAngle)).intValue();
-		pointsY[2] = centerY - new Float(sideLineLength * java.lang.Math.cos(angleRad + halfOpeningAngle)).intValue();
-		pointsX[3] = centerX;
-		pointsY[3] = centerY;
-		
-		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
-		g.setBrush(new Brush(col, Brush.SOLID));
-		g.fillPolygon(pointsX, pointsY, 4);
-		if (colPoint != null) {
-			g.setBrush(new Brush(colPoint, Brush.SOLID));
-			g.fillPolygon(pointsX, pointsY, 3);			
-		}
-	}
-	
-	private void drawDoubleArrow(Graphics g, float angle, Color colFront, Color colRear, float scale) {
-		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
-		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
-		float halfArrowWidth = arrowLength * 0.1f;
-		
-		int[] pointsX = new int[3];
-		int[] pointsY = new int[3];
-
-		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
-		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
-		pointsX[1] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
-		pointsY[1] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
-		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
-		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
-		
-		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
-		g.setBrush(new Brush(colFront, Brush.SOLID));
-		g.fillPolygon(pointsX, pointsY, 3);
-		
-		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
-		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
-		
-		g.setBrush(new Brush(colRear, Brush.SOLID));
-		g.fillPolygon(pointsX, pointsY, 3);
-	}
-	
-	private void drawRose(Graphics g, float angle, Color colFront, Color colRear, float scale) {
-		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
-		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
-		float halfArrowWidth = arrowLength * 0.12f;
-		
-		int[] pointsX = new int[8];
-		int[] pointsY = new int[8];
-
-		pointsX[0] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 4.0)).intValue();
-		pointsY[0] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 4.0)).intValue();
-		pointsX[1] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
-		pointsY[1] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
-		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 4.0)).intValue();
-		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 4.0)).intValue();
-		pointsX[3] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
-		pointsY[3] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
-		pointsX[4] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + 3.0 * java.lang.Math.PI / 4.0)).intValue();
-		pointsY[4] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + 3.0 * java.lang.Math.PI / 4.0)).intValue();
-		pointsX[5] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
-		pointsY[5] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
-		pointsX[6] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - 3.0 * java.lang.Math.PI / 4.0)).intValue();
-		pointsY[6] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - 3.0 * java.lang.Math.PI / 4.0)).intValue();
-		pointsX[7] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
-		pointsY[7] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
-		
-		g.setPen(new Pen(colRear,Pen.SOLID,1));
-		g.setBrush(new Brush(colRear, Brush.SOLID));
-		g.fillPolygon(pointsX, pointsY, 8);
-		
-		g.setBrush(new Brush(colFront, Brush.SOLID));
-		g.fillPolygon(pointsX, pointsY, 3);
-	}
-	
-	private void drawThickArrow(Graphics g, float angle, Color col, float scale) {
-		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
-		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
-		float halfArrowWidth = arrowLength * 0.1f;
-		
-		int[] pointsX = new int[4];
-		int[] pointsY = new int[4];
-
-		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
-		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
-		pointsX[1] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
-		pointsY[1] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
-		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
-		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
-		pointsX[3] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
-		pointsY[3] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
-		
-		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
-		g.setBrush(new Brush(col, Brush.SOLID));
-		g.fillPolygon(pointsX, pointsY, 4);
-	}
-	
-	public void setNorthCentered(boolean nc) {
-		northCentered = nc;
-		if (northCentered != Global.getPref().northCenteredGoto) {
-			Global.getPref().northCenteredGoto = northCentered;
-			Global.getPref().savePreferences();
-		}
-		refresh();
-	}
-	
-	public boolean isNorthCentered() {
-		return northCentered;
-	}
-}

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/MainForm.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -10,8 +10,8 @@
 */
 public class MainForm extends Editor {
 	// The next three declares are for the cachelist
-	boolean cacheListVisible=false;
-    CacheList cacheList;
+	public boolean cacheListVisible=false;
+    public CacheList cacheList;
     SplittablePanel split;
 	
 	StatusBar statBar=null;

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/MainMenu.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -1,5 +1,8 @@
 package CacheWolf;
 
+import CacheWolf.navi.Map;
+import CacheWolf.navi.MapLoaderGui;
+import CacheWolf.navi.SelectMap;
 import ewe.ui.*;
 import ewe.util.Vector;
 //import ewe.util.mString;

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/MainTab.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -1,5 +1,9 @@
 package CacheWolf;
 
+import CacheWolf.navi.GotoPanel;
+import CacheWolf.navi.MapImage;
+import CacheWolf.navi.MovingMap;
+import CacheWolf.navi.Navigate;
 import ewe.sys.Vm;
 import ewe.ui.*;
 import ewe.fx.*;
@@ -17,7 +21,7 @@
 	HintLogPanel hintLP = new HintLogPanel();
 	TablePanel tbP;
 	Vector cacheDB;
-	DetailsPanel detP = new DetailsPanel();
+	public DetailsPanel detP = new DetailsPanel();
 	CalcPanel calcP;
 	Preferences pref;
 	Profile profile;
@@ -26,11 +30,11 @@
 	ImagePanel imageP;
 	SolverPanel solverP;
 	String lastselected = "";
-	CacheHolder ch=null;
+	public CacheHolder ch=null;
 	CacheHolderDetail chD =null, chMain=null;
 	MainMenu mnuMain;
 	StatusBar statBar;
-	MovingMap mm;
+	public MovingMap mm;
 	Navigate nav;
 	String mainCache="";
 	int oldCard=0;

Deleted: trunk/src/CacheWolf/Map.java
===================================================================
--- trunk/src/CacheWolf/Map.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/Map.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -1,491 +0,0 @@
-package CacheWolf;
-
-import ewe.util.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-import ewe.sys.*;
-import ewe.ui.*;
-import ewe.graphics.*;
-import ewe.fx.*;
-
-import com.stevesoft.ewe_pat.*;
-
-/**
- *	This class is the main class for mapping,
- *	 (moving map, georeferencing maps, etc)
- *	in CacheWolf.
- *	It also provides a class for importing maps
- *	This class id=4100
- */
-public class Map extends Form {
-	Preferences pref;
-	String mapsPath = new String();
-	String thisMap = new String();
-	public String selectedMap = new String();
-	CellPanel infPanel;
-	mLabel infLabel = new mLabel("                          ");
-	Vector GCPs = new Vector();
-	MapInfoObject wfl = new MapInfoObject();
-	mButton infButton;
-	ScrollBarPanel scp;
-	AniImage mapImg;
-	int imageWidth, imageHeight = 0;
-
-	/**
-	 *	This constructor should be used when importing maps
-	 */
-	public Map(Preferences pref){
-		this.pref = pref;
-		mapsPath = pref.getMapManuallySavePath(true)+"/"; //File.getProgramDirectory() + "/maps/";
-	}
-
-	/**
-	 *	When a user clicks on the map and more than three ground control points exist
-	 *	then the calculated coordinate based on the affine transformation is displayed in the
-	 *	info panel below the map.
-	 *	It helps to identify how good the georeferencing works based on the set GCPs.
-	 */
-	public void updatePosition(int x, int y){
-		if(GCPs.size()>=3  || (wfl.affine[4] > 0 && wfl.affine[5] > 0)){
-			double x_ = 0;
-			double y_ = 0;
-			x_ = wfl.affine[0]*x + wfl.affine[2]*y + wfl.affine[4];
-			y_ = wfl.affine[1]*x + wfl.affine[3]*y + wfl.affine[5];
-			CWPoint p = new CWPoint(x_ , y_);
-			infLabel.setText("--> " + p.getLatDeg(CWPoint.DMS) + " " +p.getLatMin(CWPoint.DMM) + " / " + p.getLonDeg(CWPoint.DMS) + " " + p.getLonMin(CWPoint.DMM));
-		}
-	}
-
-	/**
-	 *	This is the correct constructor for georeferencing maps.
-	 */
-	public Map(Preferences pref, String mapToLoad, boolean worldfileexists){
-		this.pref = pref;
-		this.title = MyLocale.getMsg(4106,"Calibrate map:") + " " + mapToLoad;
-		this.resizable = true;
-		this.moveable = true;
-		//this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
-		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
-		thisMap = mapToLoad;
-		mapsPath = pref.getMapManuallySavePath(true)+"/"; //File.getProgramDirectory() + "/maps/"; // TDO veraltet
-		try {
-			wfl.loadwfl(mapsPath, thisMap);
-		}catch(FileNotFoundException ex){
-			//	Vm.debug("Cannot load world file!");
-		}catch (IOException ex) { // is thrown if lat/lon out of range
-			MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, "Error"), ex.getMessage(), MessageBox.OKB);
-			tmpMB.execute();
-			Vm.debug("Cannot load world file!");
-		}
-		mapInteractivePanel pane = new mapInteractivePanel(this);
-		scp = new ScrollBarPanel(pane);
-		Image img = new Image(Common.getImageName(mapsPath + thisMap));
-		PixelBuffer pB = new PixelBuffer(img);
-		//pB = pB.scale((int)(pref.myAppWidth*0.98),(int)(pref.myAppHeight*0.98));
-		mapImg = new AniImage(pB.toDrawableImage());
-		pane.addImage(mapImg);
-		scp.setPreferredSize(mapImg.getWidth(),mapImg.getHeight());
-		imageWidth = mapImg.getWidth();
-		imageHeight = mapImg.getHeight();
-		this.addLast(scp.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
-		infPanel = new CellPanel();
-		infPanel.addNext(infLabel,CellConstants.STRETCH, CellConstants.FILL);
-		infButton = new mButton(MyLocale.getMsg(4107,"Done!"));
-		infPanel.addLast(infButton,CellConstants.DONTSTRETCH, CellConstants.FILL);
-		this.addLast(infPanel, CellConstants.DONTSTRETCH, CellConstants.FILL);
-		//scp.repaintNow();
-		//this.repaintNow();
-	}
-
-	/**
-	 *	Add a ground control point to the list
-	 *	If the list is longer than 3 GCPs these will be evaluated
-	 *	to obtain the required parameters for the affine
-	 *	transformation.
-	 */
-	public void addGCP(GCPoint GCP){
-		if (GCP.latDec>90 || GCP.latDec<-90 || GCP.lonDec>360 || GCP.lonDec<-180) throw new IllegalArgumentException("lat/lon out of range: "+GCP.toString());
-		GCPs.add(GCP);
-		if(GCPs.size() >= 3){
-			evalGCP();
-		}
-	}
-
-	/**
-	 *	Returns the number of ground control points in the list. (Vector GCPs)
-	 */
-	public int getGCPCount(){
-		return GCPs.size();
-	}
-
-	/**
-	 *	Actuall method to evaluate the ground control points and identify the parameters
-	 *	for thew affine transformation
-	 */
-	private void evalGCP(){
-		//N 48 16.000 E 11 32.000
-		//N 48 16.000 E 11 50.000
-		//N 48 9.000 E 11 32.000
-		GCPoint gcp = new GCPoint();
-		//Calculate parameters for latitutde affine transformation (affine 0,2,4)
-		Matrix X = new Matrix(GCPs.size(),3);
-		Matrix trg = new Matrix(GCPs.size(),1);
-		for(int i = 0; i < GCPs.size();i++){
-			gcp = (GCPoint)GCPs.get(i);
-			X.matrix[i][0] = 1; X.matrix[i][1] = gcp.bitMapX; X.matrix[i][2] = gcp.bitMapY;
-			trg.matrix[i][0] = gcp.latDec;
-		}
-		Matrix Xtran = new Matrix(X);
-		Xtran.Transpose();
-		Matrix XtranX = new Matrix(Xtran);
-		XtranX.Multiply(X);
-		Matrix XtranXinv = new Matrix(XtranX);
-		XtranXinv.Inverse();
-		Matrix beta = new Matrix(XtranXinv);
-		beta.Multiply(Xtran);
-		beta.Multiply(trg);
-		wfl.affine[0] = beta.matrix[1][0];
-		wfl.affine[2] = beta.matrix[2][0];
-		wfl.affine[4] = beta.matrix[0][0];
-
-		//Calculate parameters for longitude affine transformation (affine 1,3,5)
-		X = new Matrix(GCPs.size(),3);
-		trg = new Matrix(GCPs.size(),1);
-		for(int i = 0; i < GCPs.size();i++){
-			gcp = (GCPoint)GCPs.get(i);
-			X.matrix[i][0] = 1;
-			X.matrix[i][1] = gcp.bitMapX;
-			X.matrix[i][2] = gcp.bitMapY;
-			trg.matrix[i][0] = gcp.lonDec;
-		}
-		Xtran = new Matrix(X);
-		Xtran.Transpose();
-		XtranX = new Matrix(Xtran);
-		XtranX.Multiply(X);
-		XtranXinv = new Matrix(XtranX);
-		XtranXinv.Inverse();
-		beta = new Matrix(XtranXinv);
-		beta.Multiply(Xtran);
-		beta.Multiply(trg);
-		wfl.affine[1] = beta.matrix[1][0];
-		wfl.affine[3] = beta.matrix[2][0];
-		wfl.affine[5] = beta.matrix[0][0];
-		double x_ = 0;
-		double y_ = 0;
-		x_ = wfl.affine[0]*imageWidth+ wfl.affine[2]*imageHeight + wfl.affine[4];
-		y_ = wfl.affine[1]*imageWidth + wfl.affine[3]*imageHeight + wfl.affine[5];
-		CWPoint p = new CWPoint(x_ , y_);
-		wfl.lowlon = p.lonDec;
-		wfl.lowlat = p.latDec;
-		//Vm.debug("A B C" + affine[0] + " " + affine[2] + " " + affine[4]);
-		//Vm.debug("D E F" + affine[1] + " " + affine[3] + " " + affine[5]);
-	}
-
-	/**
-	 *	Method to copy ("import") a png based map
-	 *	into the maps folder in the CacheWolf base directory.
-	 *	
-	 *	If the maps directory does not exist it will create it.
-	 *	If it finds .map files it will assume these are oziexplorer calibration files.
-	 *	It will use these files to automatically georeference the files during import.
-	 */
-	public int importMap(){
-		String rawFileName = new String();
-		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir);
-		fc.addMask("*.png,*.gif,*.bmp,*.jpg");
-		fc.setTitle((String)MyLocale.getMsg(4100,"Select Directory:"));
-		int tmp = fc.execute() ; 
-		if(tmp != FileChooser.IDYES) return Form.IDCANCEL;
-		File inDir = fc.getChosenFile();
-		File mapFile;
-		InfoBox inf = new InfoBox("Info", MyLocale.getMsg(4109,"Loading maps...            \n"), InfoBox.PROGRESS_WITH_WARNINGS, false); 
-		inf.setPreferredSize(220, 300);
-		inf.setInfoHeight(100);
-		inf.relayout(false);
-		Vm.showWait(this, true);
-		inf.exec();
-
-		//User selected a map, but maybe there are more png(s)
-		//copy all of them!
-		//at the same time try to find associated .map files!
-		//These are georeference files targeted for OziExplorer.
-		//So lets check if we have more than 1 png file:
-		String line = new String();
-		InputStream in = null;
-		OutputStream out = null;
-		FileReader inMap;
-		byte[] buf;
-		int len;
-		String[] parts;
-		String [] files = inDir.listMultiple("*.png,*.jpg,*.gif,*.bmp", File.LIST_FILES_ONLY);
-
-		String currfile = null;
-		String curInFullPath;
-		String curOutFullPath;
-		int num = files.length;
-		for(int i =  num -1 ; i >= 0;i--){
-			currfile = (String) files[i];
-			inf.setInfo(MyLocale.getMsg(4110,"Loading: ")+ "\n" + currfile + "\n("+(num-i)+"/"+num+")");
-			//Copy the file
-			//Vm.debug("Copy: " + inDir.getFullPath() + "/" +files[i]);
-			//Vm.debug("to: " + mapsPath + files[i]);
-			curInFullPath = inDir.getFullPath() + "/" +currfile;
-			curOutFullPath = mapsPath + currfile;
-			boolean imageerror = false;
-			try {
-				in = new FileInputStream(curInFullPath);
-				buf = new byte[1024*10];
-				boolean first = true;
-				ByteArray header = new ByteArray(buf);
-				while ((len = in.read(buf)) > 0) {
-					if (first) {
-						first = false;
-						header.copyFrom(buf, 0, len);
-						ImageInfo tmpII = Image.getImageInfo(header,null);
-						imageWidth = tmpII.width;
-						imageHeight = tmpII.height;
-						out = new FileOutputStream(curOutFullPath); // only create outfile if geImageInfo didn't throw an exception so do it only here not directly after opening input stream
-					}
-					out.write(buf, 0, len);
-				}
-			} catch(IOException ex){
-				imageerror = true;
-				inf.addWarning("\nIO-Error while copying image from: " + curInFullPath + " to: " + curOutFullPath + " error: " + ex.getMessage());
-			} catch (IllegalArgumentException e) { // thrown from Image.getImageInfo when it could not interprete the header (e.g. bmp with 32 bits per pixel)
-				imageerror = true;
-				inf.addWarning("\nError: could not decode image: " + curInFullPath + " - image not copied");
-			} finally {
-				try {
-					if (in != null) in.close();
-					if (out  != null) out.close(); 
-				} catch (Throwable e) {}
-			}
-			//Check for a .map file
-			rawFileName = currfile.substring(0, currfile.lastIndexOf("."));
-			mapFile = new File(inDir.getFullPath() + "/" + rawFileName + ".map");
-			if(!imageerror && mapFile.exists()){
-				GCPoint gcp1 = new GCPoint();
-				GCPoint gcp2 = new GCPoint();
-				GCPoint gcp3 = new GCPoint();
-				GCPoint gcp4 = new GCPoint();
-				GCPoint gcpG = new GCPoint();
-				//Vm.debug("Found file: " + inDir.getFullPath() + "/" + rawFileName + ".map");
-				try {
-					inMap = new FileReader(inDir.getFullPath() + "/" + rawFileName + ".map");
-					while((line = inMap.readLine()) != null){
-						if(line.equals("MMPNUM,4")){
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							gcp1.bitMapX = Convert.toInt(parts[2]);
-							gcp1.bitMapY = Convert.toInt(parts[3]);
-							if(gcp1.bitMapX == 0) gcp1.bitMapX = 1;
-							if(gcp1.bitMapY == 0) gcp1.bitMapY = 1;
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							gcp2.bitMapX = Convert.toInt(parts[2]);
-							gcp2.bitMapY = Convert.toInt(parts[3]);
-							if(gcp2.bitMapX == 0) gcp2.bitMapX = 1;
-							if(gcp2.bitMapY == 0) gcp2.bitMapY = 1;
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							gcp3.bitMapX = Convert.toInt(parts[2]);
-							gcp3.bitMapY = Convert.toInt(parts[3]);
-							if(gcp3.bitMapX == 0) gcp3.bitMapX = 1;
-							if(gcp3.bitMapY == 0) gcp3.bitMapY = 1;
-							//imageWidth = gcp3.bitMapX;
-							//imageHeight = gcp3.bitMapY;
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							gcp4.bitMapX = Convert.toInt(parts[2]);
-							gcp4.bitMapY = Convert.toInt(parts[3]);
-							if(gcp4.bitMapX == 0) gcp4.bitMapX = 1;
-							if(gcp4.bitMapY == 0) gcp4.bitMapY = 1;
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							if(pref.digSeparator.equals(",")) {
-								parts[3]= parts[3].replace('.', ',');
-								parts[2]= parts[2].replace('.', ',');
-							}
-							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
-							gcpG.bitMapX = gcp1.bitMapX;
-							gcpG.bitMapY = gcp1.bitMapY;
-							addGCP(gcpG);
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							if(pref.digSeparator.equals(",")) {
-								parts[3]= parts[3].replace('.', ',');
-								parts[2]= parts[2].replace('.', ',');
-							}
-							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
-							gcpG.bitMapX = gcp2.bitMapX;
-							gcpG.bitMapY = gcp2.bitMapY;
-							addGCP(gcpG);
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							if(pref.digSeparator.equals(",")) {
-								parts[3]= parts[3].replace('.', ',');
-								parts[2]= parts[2].replace('.', ',');
-							}
-							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
-							gcpG.bitMapX = gcp3.bitMapX;
-							gcpG.bitMapY = gcp3.bitMapY;
-							addGCP(gcpG);
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							if(pref.digSeparator.equals(",")) {
-								parts[3]= parts[3].replace('.', ',');
-								parts[2]= parts[2].replace('.', ',');
-							}
-							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
-							gcpG.bitMapX = gcp4.bitMapX;
-							gcpG.bitMapY = gcp4.bitMapY;
-							addGCP(gcpG);
-							/* already read from image file itself
-							// get dimensions of image
-							while ( (line = inMap.readLine()) != null){
-								if (line.startsWith("IWH")){
-									parts = mString.split(line, ',');
-									imageWidth = Convert.toInt(parts[2]);
-									imageHeight = Convert.toInt(parts[3]);
-								}
-							}
-							 */
-							evalGCP();
-							//Vm.debug("Saving .map file to: " + mapsPath + "/" + rawFileName + ".wfl");
-							wfl.saveWFL(mapsPath, rawFileName);
-							GCPs.clear();
-						} // if
-
-					} // while
-					if (inMap != null)	inMap.close();
-				} catch(IllegalArgumentException ex){ // is thrown from Convert.toDouble and saveWFL if affine[0-5]==0 NumberFormatException is a subclass of IllegalArgumentExepction
-					inf.addWarning("\nError while importing .map-file: "+ex.getMessage());
-				} catch(IOException ex){
-					inf.addWarning("\nIO-Error while reading or writing calibration file\n" + ex.getMessage());
-				} 
-			} else { // if map file.exists
-				if (!imageerror) inf.addWarning("\nNo calibration file found for: " + currfile + " - you can calibrate it manually");
-			}
-		} // for file
-		Vm.showWait(this, false);
-		inf.addText("\ndone.");
-		inf.addOkButton();
-		//inf.addOkButton(); doesn't work
-		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
-		return Form.IDOK;
-	}
-
-
-
-	/**
-	 *	Handles button pressed event
-	 *	When the button is pressed a mapname.wfl file is saved in the
-	 *	maps directory.
-	 */
-	public void onEvent(Event ev){
-
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			// display coords in another format
-			if (ev.target == infButton){
-				boolean retry = true;
-				while (retry == true) {
-					try {
-						retry = false;
-						wfl.saveWFL(mapsPath, thisMap);
-						if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
-					} catch (IOException e) {
-						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(321, "Error writing file ") + e.getMessage()+MyLocale.getMsg(324, " - retry?"), MessageBox.YESB | MessageBox.NOB);
-						if (tmpMB.execute() == MessageBox.IDYES) retry = true;
-					}catch (IllegalArgumentException e) {
-						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(325, "Map not calibrated")+MyLocale.getMsg(324, " - retry?"), MessageBox.YESB | MessageBox.NOB);
-						if (tmpMB.execute() == MessageBox.IDYES) { retry = true; break; }
-					}
-				}
-				if (!retry) close(0);
-			}
-		}
-	}
-}
-
-/**
- *	Class that creates a panel and loads a map.
- *	It catches click events to display a form where the user may enter the required ccordinates
- *	The data is stored as a ground control point in the calling class: Map
- */
-class mapInteractivePanel extends InteractivePanel{
-	Map f;
-	Locale l = Vm.getLocale();
-	LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
-	public mapInteractivePanel(Map f){
-		this.f = f;
-	}
-
-	/**
-	 *	Event handler to catch clicks on the map
-	 */
-	public void imageClicked(AniImage which, Point pos){
-		//Vm.debug("X = " +pos.x + " Y = " + pos.y);
-		Image img = new Image(31, 31);
-		Graphics g = new Graphics(img);
-		g.setColor(new Color(0,0,0));
-		g.fillRect(0,0,31,31);
-		g.setColor(new Color(255,0,0));
-		g.drawLine(0,16,31,16);
-		g.drawLine(16,0,16,31);
-		AniImage aImg = new AniImage(img);
-		aImg.setLocation(pos.x-16,pos.y-16);
-		aImg.transparentColor = new Color(0,0,0);
-		//aImg.properties = mImage.IsNotHot;
-		aImg.properties = mImage.AlwaysOnTop;
-		this.addImage(aImg);
-		g.free();
-		this.repaintNow();
-		f.updatePosition(pos.x, pos.y);
-
-		CoordsScreen cooS = new CoordsScreen(); // (String)lr.get(4108,"Coordinates:"), (String)lr.get(4108,"Coordinates:"), InfoBox.INPUT);
-		if (cooS.execute()==CoordsScreen.IDOK) {
-			GCPoint gcp = new GCPoint(cooS.getCoords());
-			gcp.bitMapX = pos.x;
-			gcp.bitMapY = pos.y;
-			f.addGCP(gcp); // throws IllegalArgumentException in case of lon/lat out of range
-//			} catch (IllegalArgumentException e) { // NumberFormatException is a subclass of IllagalArgumentException
-//			coosInputFormat();
-//			this.removeImage(aImg);
-		} else this.removeImage(aImg); // CANCEL pressed
-	}
-
-	private void coosInputFormat () {
-		MessageBox tmpMB = new MessageBox((String)lr.get(312,"Error"), (String)lr.get(4111,"Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"), MessageBox.OKB);
-		tmpMB.exec();
-
-	}
-}
-/**
- *	Class based on CWPoint but intended to handle bitmap x and y
- *	Used for georeferencing bitmaps.
- */
-class GCPoint extends CWPoint{
-	public int bitMapX = 0;
-	public int bitMapY = 0;
-
-	public GCPoint(){
-	}
-
-	public GCPoint(CWPoint p) {
-		super(p);
-	}
-
-	public GCPoint(double lat, double lon){
-		this.latDec = lat;
-		this.lonDec = lon;
-		this.utmValid = false;
-	}
-}
\ No newline at end of file

Deleted: trunk/src/CacheWolf/MapDetailForm.java
===================================================================
--- trunk/src/CacheWolf/MapDetailForm.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/MapDetailForm.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -1,60 +0,0 @@
-package CacheWolf;
-import ewe.graphics.*;
-import ewe.sys.*;
-import ewe.fx.*;
-import ewe.ui.*;
-import ewe.util.*;
-
-/**
- *	Class to display map images in different zoom levels.
- *	Extends ImageDetailForm that handles the resizing to screen
- *	size. The extension in this class handles the switching between
- *	different (map) images.
- */
-public class MapDetailForm extends ImageDetailForm {
-
-	mButton btSwitch;
-	String cache;
-	String imgLoc = new String();
-	int status = 0;
-	Profile profile;
-	
-	public MapDetailForm(String cacheName, Preferences p, Profile prof){
-		profile=prof;  // keep ref for later use
-		cache=cacheName;
-		imgLoc = prof.dataDir + cacheName + "_map.gif";
-		scp = new ScrollBarPanel(ipp);
-		setUp(imgLoc, p);
-		this.title = "Maps";
-		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
-		this.addLast(scp.getScrollablePanel(), this.STRETCH, this.FILL);
-		CellPanel butPanel = new CellPanel();
-		btSwitch = new mButton("Zoom");
-		butPanel.addLast(btSwitch);
-		this.addLast(butPanel, this.HSTRETCH, this.FILL);
-	}
-
-	public void onEvent(Event ev){
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if (ev.target == btSwitch){
-				ipp.removeImage(ai);
-				imgLoc = profile.dataDir + cache;
-				if(status == 0) {
-					imgLoc = imgLoc + "_map_2.gif";
-					status = 1;
-				} else {
-					imgLoc = imgLoc + "_map.gif";
-					status = 0;
-				}
-				try {
-					setUp(imgLoc, pref);
-					this.repaintNow();
-				} catch (IllegalArgumentException e) {
-					MessageBox tmp = new MessageBox(MyLocale.getMsg(321,"Fehler"), MyLocale.getMsg(322,"Kann Bild/Karte nicht finden")+": "+imgLoc, MessageBox.OKB); // @todo: language support
-					tmp.exec();
-				}
-			}
-		}
-	}
-}
-

Deleted: trunk/src/CacheWolf/MapInfoObject.java
===================================================================
--- trunk/src/CacheWolf/MapInfoObject.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/MapInfoObject.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -1,331 +0,0 @@
-package CacheWolf;
-
-import ewe.fx.Point;
-import ewe.io.BufferedWriter;
-import ewe.io.FileReader;
-import ewe.io.FileWriter;
-import ewe.io.FilenameFilter;
-import ewe.io.File;
-import ewe.io.IOException;
-import ewe.io.PrintWriter;
-import ewe.sys.*;
-
-/**
- * @author r
- *
- */
-public class MapInfoObject{
-	//World file:
-	// x scale
-	// y scale
-	// x rotation
-	// y rotation
-	// lon of upper left corner of image
-	// lat of upper left corner of image
-	// lon of lower right corner of image
-	// lat of lower right corner of image
-	public double[] affine = {0,0,0,0,0,0};
-	public double lowlat = 0;
-	public double lowlon = 0;
-	public double transLatX, transLatY, transLonX, transLonY; // this are needed for the inervers calculation from lat/lon to x/y
-	public CWPoint center = new CWPoint();
-	public float sizeKm = 0; // diagonale
-	public float scale; // in meters per pixel, note: it is assumed that this scale identifying the scale of the map, automatically adjusted when zooming
-	public float zoomFactor = 1; // if the image is zoomed, direct after laoding always 1
-	public Point shift = new Point (0,0);
-	public CWPoint OrigUpperLeft; // this is only valid after zooming 
-	public float rotationRad; // contains the rotation of the map == north direction in rad
-	public String fileNameWFL = new String();
-	public String fileName = new String();
-	public String mapName = new String();
-	//private Character digSep = new Character(' ');
-	static private String digSep = MyLocale.getDigSeparator();
-	/*
-	 * loads an .wfl file
-	 * throws FileNotFoundException and IOException (data out of range)
-	 * @maps Path to .wfl file
-	 * @thisMap filename of .wfl file without ".wfl"
-	 * @DigSep "." or ","
-	 */	
-
-	public MapInfoObject() {
-		//double testA = Convert.toDouble("1,50") + Convert.toDouble("3,00");
-		//if(testA == 4.5) digSep = ","; else digSep = ".";
-	}
-	
-	public MapInfoObject(MapInfoObject map) {
-		mapName = map.mapName;
-		affine[0] = map.affine[0];
-		affine[1] = map.affine[1];
-		affine[2] = map.affine[2];
-		affine[3] = map.affine[3];
-		affine[4] = map.affine[4];
-		affine[5] = map.affine[5];
-		lowlat = map.lowlat;
-		lowlon = map.lowlon;
-		OrigUpperLeft = new CWPoint (map.OrigUpperLeft);
-		zoomFactor = map.zoomFactor;
-		shift.set(map.shift);
-		fileName = new String(map.fileName);
-		fileNameWFL = new String(map.fileNameWFL);
-		mapName = new String(mapName);
-		doCalculations();
-	}
-
-	/*
-	 * constructes an MapInfoObject without an associated map
-	 * but with 1 Pixel = scale meters
-	 */
-	public MapInfoObject(double scalei, double lat) {
-		mapName="empty 1 Pixel = "+scalei+"meters";
-		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double pixel2deg = meters2deg * scalei;
-		affine[0]=0; //x2lat
-		affine[1]=pixel2deg / java.lang.Math.cos(lat); //x2lon
-		affine[2]=-pixel2deg; //y2lat
-		affine[3]=0; //y2lon
-		affine[4]=1; //top
-		affine[5]=0; //left
-		lowlat = 0; //buttom
-		lowlon = 1; //right
-		OrigUpperLeft = new CWPoint(affine[4], affine[5]);
-		doCalculations();
-	}
-
-	/**
-	 * constructs an MapInfoObject with an associated map
-	 * with 1 Pixel = scale meters, center and width, hight in pixels
-	 * @param name path and filename of .wfl file without the extension (it is needed because the image will be searched in the same directory)
-	 */
-	public MapInfoObject(double scalei, CWPoint center, int width, int hight, String name) {
-		mapName = name+".wfl";
-
-		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double pixel2deg = meters2deg * scalei;
-		double pixel2deghorizontal = pixel2deg / java.lang.Math.cos(center.latDec*java.lang.Math.PI / 180); 
-		affine[0]=0; //x2lat
-		affine[1]=pixel2deghorizontal; //x2lon
-		affine[2]=-pixel2deg; //y2lat
-		affine[3]=0; //y2lon
-		affine[4]=center.latDec + hight / 2 *pixel2deg; //top
-		affine[5]=center.lonDec - width / 2 *pixel2deghorizontal; //left
-		lowlat = center.latDec - hight / 2 *pixel2deg; //buttom
-		lowlon = center.lonDec + width / 2 *pixel2deghorizontal; //right
-		fileNameWFL = name;
-		OrigUpperLeft = new CWPoint(affine[4], affine[5]);
-		doCalculations();
-	}
-	
-
-	/** 
-	 * @return the filename of the associated map image, "" if no file is associated, null if associated file could not be found
-	 */
-	public String getImageFilename() {
-		if (fileName == null || fileName.length() > 0) return fileName;
-		if (fileNameWFL.length() == 0) return "";
-		String n = fileNameWFL.substring(0, fileNameWFL.lastIndexOf("."));
-		return Common.getImageName(n);
-	}
-	
-	/**
-	 * Method to load a .wfl-file
-	 * @throws IOException when there was a problem reading .wfl-file
-	 * @throws IOException when lat/lon were out of range
-	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
-	 */
-	public void loadwfl(String mapsPath, String thisMap) throws IOException, ArithmeticException {
-		FileReader in = new FileReader(mapsPath + thisMap + ".wfl");
-		String line = new String();
-		try {
-			for(int i = 0; i<6;i++){
-				line = in.readLine();
-				if (digSep.equals(",")) {line = line.replace('.',','); } // digSep == ',' musss genau so lauten. digsep.equals(',') wirft eine Exception auf PocketPC, digsep.equals(",") wirft keine Exception, funktioniert aber nicht! 
-				else line = line.replace(',','.');
-				affine[i] = Convert.toDouble(line);
-			}
-			line = in.readLine();
-			if (digSep.equals(",")) {line = line.replace('.',','); }
-			else line = line.replace(',','.');
-			lowlat = Convert.toDouble(line);
-			line = in.readLine();
-			if (digSep.equals(",")) {line = line.replace('.',','); }
-			else line = line.replace(',','.');
-			lowlon = Convert.toDouble(line);
-
-			fileNameWFL = mapsPath + thisMap + ".wfl";
-			fileName = ""; //mapsPath + thisMap + ".png";
-			mapName = thisMap;
-			in.close();
-			if(affine[4] > 90 || affine[4] < -90 || affine[5] < -180 || affine[5] > 360 ||
-					lowlat > 90 || lowlat < -90 || lowlon > 360 || lowlon < -180 ) {
-				affine[0] = 0; affine[1] = 0; affine[2] = 0; affine[3] = 0; affine[4] = 0; affine[5] = 0;
-				lowlat = 0; lowlon = 0;
-				throw (new IOException("Lat/Lon out of range while reading "+mapsPath + thisMap + ".wfl"));
-			}
-		} catch (NullPointerException e) { // in.readline liefert null zur?ck, wenn keine Daten mehr vorhanden sind
-			throw (new IOException("not enough lines in file "+mapsPath + thisMap + ".wfl"));
-		}
-		OrigUpperLeft = new CWPoint(affine[4], affine[5]);
-		doCalculations();
-	}
-
-	/**
-	 * calculates center, diagonal size of the map and inverse to affine transformation
-	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
-	 */
-
-	private void doCalculations() throws ArithmeticException {
-		try {
-			center.set((lowlat + affine[4])/2,(lowlon + affine[5])/2);
-			sizeKm = java.lang.Math.abs((float)center.getDistance(lowlat, lowlon)) *2;
-
-			//calculate reverse affine
-			double nenner=(-affine[1]*affine[2]+affine[0]*affine[3]);
-			transLatX = affine[3]/nenner; // nenner == 0 cannot happen as long als affine is correct
-			transLonX = -affine[2]/nenner;
-			transLatY = -affine[1]/nenner;
-			transLonY = affine[0]/nenner;
-
-			// calculate north direction
-			float scaleXpixels = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLonX,2)+java.lang.Math.pow(transLonY,2));
-			//	float scaleY = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLatX,2)+java.lang.Math.pow(transLatY,2));
-			float rotationX2x=(float)transLonX*scaleXpixels;
-			float rotationX2y=(float)transLonY*scaleXpixels;
-			//rotationY2y=-(float)transLatY*scaleY; // lat -> y = -, y -> y = +
-			//rotationY2x=-(float)transLatX*scaleY; // uncomment an make it a field of MapInfoObject if you need translation from x to x rotated
-			rotationRad = (float)java.lang.Math.atan(rotationX2y);
-			if (rotationX2x < 0) rotationRad = (float)java.lang.Math.PI - rotationRad;
-			// calculate scale in meters per pixel
-			double metersPerLat = 1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0));
-			scale = (float) java.lang.Math.abs((affine[2] * metersPerLat)); 
-		} catch (ArithmeticException ex) { throw new ArithmeticException("Not allowed values in affine\n (matrix cannot be inverted)\n in file \n" + fileNameWFL); }
-	}
-
-
-	/**
-	 *	Method to save a world file (.wfl)
-	 * @param mapsPath without "/" at the end
-	 * @param mapFileName without file extension
-	 * @throws IOException when there was a problem writing .wfl-file
-	 * @throws IllegalArgumentException when affine[x] for all x == 0 ("map not calibrated").
-	 */
-	public void saveWFL(String mapsPath, String mapFileName) throws IOException, IllegalArgumentException {
-		if (affine[0]==0 && affine[1]==0 && affine[2]==0 && affine[3]==0 && 
-				affine[4]==0 && affine[5]==0 ) throw (new IllegalArgumentException("map not calibrated"));
-		PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(mapsPath + "/" + mapFileName + ".wfl")));
-		String towrite=Convert.toString(affine[0])+"\n" +
-		Convert.toString(affine[1])+"\n" +
-		Convert.toString(affine[2])+"\n" + 
-		Convert.toString(affine[3])+"\n" + 
-		Convert.toString(affine[4])+"\n" +
-		Convert.toString(affine[5])+"\n" +
-		Convert.toString(lowlat)+"\n" +
-		Convert.toString(lowlon)+"\n";
-		if (digSep.equals(",")) towrite=towrite.replace(',', '.');
-		outp.print(towrite);
-		outp.close();
-		this.fileName = ""; // this will be set in getImageFilenam //mapsPath + "/" + mapFileName + ".png";
-		this.fileNameWFL = mapsPath + "/" + mapFileName + ".wfl";
-		this.mapName = mapFileName;
-	}
-
-	public boolean inBound(CWPoint pos){
-		boolean isInBound = false;
-		/*
-		Vm.debug(mapName);
-		Vm.debug("Top: " + affine[4]);
-		Vm.debug("Bottom: " + lowlat);
-		Vm.debug("Test: " + pos.latDec);
-		Vm.debug("Left: " + affine[5]);
-		Vm.debug("Right: " + lowlon);
-		Vm.debug("Test: " + pos.lonDec);
-		 */
-		if(affine[4] >= pos.latDec && pos.latDec >= lowlat && affine[5] <= pos.lonDec && pos.lonDec <= lowlon) isInBound = true;
-		return isInBound;
-	}
-
-	/**
-	 * zoom in / out
-	 * @param zf zf > 1 == zoom in, zoom is relative to original unscaled image
-	 * @param diffX shift of map in pixels (if the map was cropped while zooming) in the not zoomed image
-	 * @param diffY
-	 */
-	public void zoom(float zf, int diffX, int diffY) {
-		// restore original values to calculate corret shift (upperleft)
-		affine[4] = OrigUpperLeft.latDec;
-		affine[5] = OrigUpperLeft.lonDec;
-		affine[0] = affine[0] * zoomFactor; 
-		affine[1] = affine[1] * zoomFactor; 
-		affine[2] = affine[2] * zoomFactor;
-		affine[3] = affine[3] * zoomFactor;
-		CWPoint upperleft = calcLatLon(diffX, diffY);
-		affine[4] = upperleft.latDec;
-		affine[5] = upperleft.lonDec;
-		affine[0] = affine[0] / zf ; 
-		affine[1] = affine[1] / zf ; 
-		affine[2] = affine[2] / zf ; 
-		affine[3] = affine[3] / zf ; 
-		zoomFactor = zf ;
-		shift.x = diffX;
-		shift.y = diffY;
-		doCalculations(); // TODO lowlat neu berechnen?
-	}
-
-	public boolean inBound(CWGPSPoint pos){
-		boolean isInBound = false;
-		/*
-		Vm.debug(mapName);
-		Vm.debug("Top: " + affine[4]);
-		Vm.debug("Bottom: " + lowlat);
-		Vm.debug("Test: " + pos.latDec);
-		Vm.debug("Left: " + affine[5]);
-		Vm.debug("Right: " + lowlon); // lowlon should be left?!
-		Vm.debug("Test: " + pos.lonDec);
-		 */
-		if(affine[4] >= pos.latDec && pos.latDec >= lowlat && affine[5] <= pos.lonDec && pos.lonDec <= lowlon) isInBound = true;
-		return isInBound;
-	}
-	public boolean inBound(double lati, double loni){
-		boolean isInBound = false;
-		if(affine[4] >= lati && lati >= lowlat && affine[5] <= loni && loni <= lowlon) isInBound = true;
-		return isInBound;
-	}
-	/**
-	 * Method to calculate bitmap x,y of the current map using
-	 * lat and lon target coordinates. There ist no garanty that
-	 * the returned coordinates are inside of the map. They can be negative.
-	 * @param lat
-	 * @param lon
-	 */
-	public Point calcMapXY(double lat, double lon){
-		Point coords = new Point();
-		double b[] = new double[2];
-		b[0] = lat - affine[4];
-		b[1] = lon - affine[5];
-		double mapx=transLatX* b[0] + transLonX*b[1];
-		double mapy=transLatY* b[0] + transLonY*b[1];
-		coords.x = (int)mapx;
-		coords.y = (int)mapy;
-		//Vm.debug("mapX=mapx2: "+mapx+"="+mapx2+"; mapy=mapy2: "+mapy+"="+mapy2);
-		return coords;
-	}
-
-	/**
-	 * gives back lat/lon from x, y in map
-	 * @param x
-	 * @param y
-	 * @return
-	 */
-	public CWPoint calcLatLon(int x, int y) {
-		CWPoint ll = new CWPoint();
-		ll.latDec = (double)x * affine[0] + (double)y * affine[2] + affine[4];
-		ll.lonDec = (double)x * affine[1] + (double)y * affine[3] + affine[5];
-		return ll;
-	}
-	public CWPoint calcLatLon(Point p) {
-		return calcLatLon(p.x, p.y);
-	}
-	public Area getArea(){
-		return new Area(new CWPoint(affine[4], affine[5]), new CWPoint(lowlat, lowlon));
-	}
-}
\ No newline at end of file

Deleted: trunk/src/CacheWolf/MapLoader.java
===================================================================
--- trunk/src/CacheWolf/MapLoader.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/MapLoader.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -1,237 +0,0 @@
-package CacheWolf;
-
-import ewe.ui.*;
-import ewe.io.*;
-import ewe.fx.*;
-import ewe.util.*;
-import ewe.sys.*;
-import ewe.sys.Double;
-import ewe.net.*;
-
-/**
-*
-*/
-
-// Um Karten zu holen!
-// http://www.expedia.de/pub/agent.dll?qscr=mrdt&ID=3kQaz.&CenP=48.09901667,11.35688333&Lang=EUR0407&Alti=1&Size=600,600&Offs=0.000000,0.000000&Pins=|5748|
-// oder
-// http://www.expedia.de/pub/agent.dll?qscr=mrdt&ID=3kQaz.&CenP=48.15,11.5833&Alti=2&Lang=EUR0407&Size=900,900&Offs=0,0&MapS=0&Pins=|48.15,11.5833|4|48.15,11.5833&Pins=|48.15,11.5833|1|48.15,%2011.5833||
-
-
-public class MapLoader {
-	String proxy = new String();
-	String port = new String();
-	InfoBox progressInfobox;
-	
-	final static float downloadMapScaleFactorExpedia_east = 3950;
-	final static float MAPBLAST_METERS_PER_PIXEL = 1.0f/2817.947378f;
-	final static float EXPEDIA_METERS_PER_PIXEL = downloadMapScaleFactorExpedia_east * MAPBLAST_METERS_PER_PIXEL; 
-
-	int numMapsY;
-	int numMapsX;
-	double latinc;
-	double loninc;
-	CWPoint topleft;
-	CWPoint buttomright;
-	Point tilesSize;
-	int tileScale;
-
-	public MapLoader(String prxy, String prt){
-		port = prt;
-		proxy = prxy;
-		progressInfobox = null;
-	}
-	
-	/**
-	 * download maps from expedia at zoomlevel alti and save the maps and the .wfl 
-	 * in path
-	 * @param center center of all tiles
-	 * @param radius in meters
-	 * @param scale in "alti" value 1 alti =  3950 /2817.947378 = 1,046861280317350198581316446428 meters per pixel
-	 * @param size in pixels
-	 * @param overlapping in pixels
-	 * @param path without "/" at the end
-	 * 
-	 */
-	public void setTiles (CWPoint center, float radius, int scale, Point size, int overlapping) {
-		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double metersPerLon = metersPerLat * java.lang.Math.cos(center.latDec/180*java.lang.Math.PI);
-		topleft = new CWPoint(center.latDec + (radius / metersPerLat), center.lonDec - (radius / metersPerLon));
-		buttomright = new CWPoint(center.latDec - (radius / metersPerLat), center.lonDec + (radius / metersPerLon));
-		
-		this.setTiles(topleft, buttomright, scale, size, overlapping);
-	}
-	
-	public void setTiles(CWPoint toplefti, CWPoint buttomrighti, int scale, Point size, int overlapping) {
-		//if (toplefti.latDec <= buttomrighti.latDec || toplefti.lonDec >= toplefti.lonDec) throw new IllegalArgumentException("topleft must be left and above buttom right");
-		topleft = new CWPoint(toplefti);
-		buttomright = new CWPoint(buttomrighti);
-		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + buttomright.latDec)/2/180*java.lang.Math.PI);
-		
-		double pixelsPerLat = metersPerLat / (EXPEDIA_METERS_PER_PIXEL * scale);
-		double pixelsPerLon = metersPerLon / (EXPEDIA_METERS_PER_PIXEL * scale);
-
-		//over all pixelsize without borders
-		double pixelsY = (topleft.latDec - buttomright.latDec) * pixelsPerLat; 
-		double pixelsX = -(topleft.lonDec - buttomright.lonDec) * pixelsPerLon ; 
-		
-		//border sizes around given area and overlapping between tiles
-		//int borderX = (int) java.lang.Math.round((float)size.x * (overlapping - 1.0));
-		//int borderY = (int) java.lang.Math.round((float)size.y * (overlapping - 1.0));
-		int borderX = overlapping;
-		int borderY = overlapping;
-		
-		numMapsY = (int) java.lang.Math.ceil( (pixelsY + (float)borderY) / (float)(size.y - borderY) );
-		numMapsX = (int) java.lang.Math.ceil( (pixelsX + (float)borderX) / (float)(size.x - borderX) );
-		
-		//increments calulated from pixel offset of tiles
-		latinc = (float)-(size.y - borderY) / pixelsPerLat;
-		loninc = (float)(size.x - borderX) / pixelsPerLon;
-		
-		//calculation of center of first tile
-		
-		//additional size for borders and rounding
-		double oversizeX = (float)(numMapsX * (size.x - borderX) + borderX) - pixelsX;
-		double oversizeY = (float)(numMapsY * (size.y - borderY) + borderY) - pixelsY;
-		
-		//offset for upper left corner
-		double offsetLat = -( ((float)size.y - oversizeY) / 2.0 ) / pixelsPerLat;
-		double offsetLon = ( ((float)size.x - oversizeX) / 2.0 ) / pixelsPerLon;
-		
-		topleft.latDec += offsetLat;
-		topleft.lonDec += offsetLon;
-		
-		this.tilesSize = new Point();
-		this.tilesSize.set(size);
-		this.tileScale = scale;
-	}
-
-	public void downlaodTiles(String tilesPath) {
-		double lat = topleft.latDec;
-		double lon = topleft.lonDec;
-		for (int row = 1; row <= numMapsY; row++) {
-			lon = topleft.lonDec;
-			for (int col = 1; col <= numMapsX; col++) {
-				if (progressInfobox != null)
-					progressInfobox.setInfo("Downloading calibrated (georeferenced) \n map image from www.expedia.com \n Downloading tile row: "+row+" / "+numMapsY+" coloumn "+ col + "/"+numMapsX);
-				downloadMap(lat, lon, tileScale, tilesSize.x, tilesSize.y, tilesPath);
-				lon += loninc;
-			}
-			lat += latinc;
-		}
-	}
-	
-	/*
-	public void loadTo(String a, String b) {
-		//loadTo(a, b, "50.74", "7.095");
-	}
-	*/
-
-	public void setProgressInfoBox (InfoBox progrssInfoboxi) {
-		progressInfobox = progrssInfoboxi;
-	}
-	/**
-	 * calculates the Expedia Alti = scale which fits in distance to its edges
-	 * @param center
-	 * @param distance in meters
-	 */
-	public static int getExpediaAlti(CWPoint center, float distance, Point size) {
-		int scaleLatO = (int) java.lang.Math.ceil(( distance * 2 / EXPEDIA_METERS_PER_PIXEL / size.y));
-		int scaleLonO = (int) java.lang.Math.ceil(( distance * 2 / EXPEDIA_METERS_PER_PIXEL / size.x));
-		int scaleO = (scaleLatO < scaleLonO ? scaleLonO : scaleLatO);
-		//loadTo((topleft.latDec + buttomright.latDec)/2, (topleft.lonDec + buttomright.lonDec)/2, scaleO, size.x, size.y, path+"/expedia_alti"+scaleO+"_lat"+latD.toString()+"_lon"+lonD.toString());
-		return scaleO;
-	}
-	
-	public static String createExpediaFilename(double lat, double lon, int alti) {
-		Double latD = new Double(), lonD = new Double();
-		latD.decimalPlaces = 4;
-		lonD.decimalPlaces = 4;
-		latD.set(lat);
-		lonD.set(lon);
-		return "expedia_alti"+alti+"_lat"+latD.toString().replace(',', '.')+"_lon"+lonD.toString().replace(',', '.')+".gif";
-	}
-	
-	public void downloadMap(double lat, double lon, int alti, int PixelWidth, int PixelHeight, String path){
-		loadTo(lat, lon, alti, PixelWidth, PixelHeight, path+"/"+createExpediaFilename(lat, lon, alti));
-	}
-
-	public void loadTo(double lat, double lon, int alti, int PixelWidth, int PixelHeight, String datei){
-		HttpConnection connImg, conn2;
-		Socket sockImg, sock2;
-		InputStream is;
-		FileOutputStream fos;
-		ByteArray daten;
-		String quelle = new String();
-		String zone;
-		if (lon <= -10) zone = "USA0409";
-		else zone = "EUR0809";
-
-		/*
-		 * information from: DownloadMouseMode.properties in project GPSylon ( in directory gpsylon_src-0.5.2\plugins\downloadmousemode\auxiliary\org\dinopolis\gpstool\plugin\downloadmousemode and DownloadMapCalculator.java in Dir gpsylon_src-0.5.2\plugins\downloadmousemode\src\org\dinopolis\gpstool\plugin\downloadmousemode 
-		 * download.map.url.expedia_east=http\://www.expedia.com/pub/agent.dll?qscr=mrdt&ID=3XNsF.&CenP={0,number,#.########},{1,number,#.########}&Lang=EUR0809&Alti={2,number,#}&Size={3,number,#},{4,number,#}&Offs=0.000000,0.000000\&BCheck=1
-		 * download.map.url.expedia_east.title=Url of Expedia Europe
-		 * download.map.scale_factor.expedia_east=3950
-		 */
-		Double latD = new Double();
-		latD.decimalPlaces = 8;
-		latD.set(lat);
-		Double lonD = new Double();
-		lonD.decimalPlaces = 8;
-		lonD.set(lon);
-		quelle = "http://www.expedia.de/pub/agent.dll?qscr=mrdt";
-		quelle = quelle + "&ID=3kQaz.";
-		quelle = quelle + "&CenP=" + latD.toString().replace(',', '.') + "," + lonD.toString().replace(',', '.');
-		quelle = quelle + "&Alti="+Convert.toString(alti)+"&Lang="+zone+"&Size="+Convert.toString(PixelWidth)+","+Convert.toString(PixelHeight)+"&Offs=0,0&MapS=0"; //&Pins=|" + latD.toString().replace(',', '.') + "," + lonD.toString().replace(',', '.') + "|5|";
-		//Vm.debug(lat + "," + lon);
-		if(proxy.length()>0){
-			connImg = new HttpConnection(proxy, Convert.parseInt(port), quelle);
-			//Vm.debug("Loading quelle: " + quelle);
-		}else{
-			connImg = new HttpConnection(quelle);
-		}
-		//datei = "d:\\temp\\test_map.bmp";
-		connImg.setRequestorProperty("USER_AGENT", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0");
-		connImg.setRequestorProperty("Connection", "close");
-		connImg.setRequestorProperty("Cookie", "jscript=1; path=/;");
-		connImg.documentIsEncoded = true;
-		try{
-			File dateiF = new File(datei);
-			if(!dateiF.exists()){
-				sockImg = connImg.connect();
-				//Vm.debug("Redirect: " + connImg.getRedirectTo());
-				quelle = connImg.getRedirectTo();
-				sockImg.close();
-				if(proxy.length()>0){
-					connImg = new HttpConnection(proxy, Convert.parseInt(port), quelle);
-				}else{
-					connImg = new HttpConnection(quelle);
-				}
-				connImg.setRequestorProperty("USER_AGENT", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0");
-				connImg.setRequestorProperty("Connection", "close");
-				connImg.setRequestorProperty("Cookie", "jscript=1; path=/;");
-				connImg.documentIsEncoded = true;
-				sock2 = connImg.connect();
-				daten = connImg.readData(sock2);
-				fos = new FileOutputStream(dateiF);
-				fos.write(daten.toBytes());
-				fos.close();
-				sock2.close();
-			}
-			//Vm.debug("done");
-		}catch(IOException e){
-			(new MessageBox("Error", "Error while downloading or saving map:\n"+e.getMessage(), MessageBox.OKB)).exec();
-		}
-		File dateiF = new File(datei); // change!!!
-		String tmp = dateiF.getName(); // contains the name and the extension
-		String name = tmp.substring(0, tmp.lastIndexOf("."));
-		float metersPerPixel = (float) (alti)*EXPEDIA_METERS_PER_PIXEL;
-		MapInfoObject cal = new MapInfoObject(metersPerPixel, new CWPoint(lat,lon),  PixelWidth, PixelHeight, dateiF.getPath()+"/"+name);
-		try {
-		cal.saveWFL(dateiF.getDrivePath(), name);
-		} catch (IOException e) {
-			(new MessageBox("Error", "Error saving calibration file:\n"+e.getMessage(), MessageBox.OKB)).exec();
-		}
-	}
-}
\ No newline at end of file

Deleted: trunk/src/CacheWolf/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/MapLoaderGui.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/MapLoaderGui.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -1,251 +0,0 @@
-package CacheWolf;
-
-import ewe.io.File;
-import ewe.sys.Convert;
-import ewe.sys.Vm;
-import ewe.ui.*;
-import ewe.util.Vector;
-
-/**
- * @author pfeffer
- * This Class is the Dialog for Download calibrated from expedia.com
- * is called from 
- */
-
-public class MapLoaderGui extends Form {
-	mButton cancelB, okBtiles, okBPerCache, cancelBPerCache;
-	Preferences pref;
-	mTabbedPanel mTab = new mTabbedPanel();
-	CellPanel pnlTiles = new CellPanel();
-	CellPanel pnlPerCache = new CellPanel();
-
-	final String descString = "Download georeferenced maps from expedia.com";
-	mCheckBox forCachesChkBox = new mCheckBox("for");
-	mChoice forSelectedChkBox = new mChoice(new String[] {"all", "selected"}, 0);
-	mChoice forSelectedChkBoxPerCache = new mChoice(new String[] {"all", "selected"}, 1);
-	mLabel cachesLbl = new mLabel("caches");
-	mInput distanceInput;
-	mLabel distLbl;
-	mLabel km = new mLabel("km");
-	mLabel coosLbl;
-	mButton coosBtn;
-	mLabel scaleLbl = new mLabel("Approx. m per pixel:");
-	mInput scaleInput = new mInput ("3");
-	mInput scaleInputPerCache = new mInput ("1");
-	mLabel overlappingLbl = new mLabel("overlapping in pixel:");
-	mInput overlappingInput = new mInput("100");
-	mCheckBox overviewChkBox = new mCheckBox("download an overview map");
-	mCheckBox overviewChkBoxPerCache = new mCheckBox("download an overview map");
-
-	CWPoint center;
-	Vector cacheDB;
-	boolean perCache;
-	boolean onlySelected;
-	float radius;
-	float scale;
-	int overlapping;
-	boolean overviewmap;
-	int numCaches;
-
-	public MapLoaderGui(Vector cacheDBi) {
-		super();
-		this.title = MyLocale.getMsg(1800, "Download georeferenced maps"); 
-		pref = Global.getPref(); // myPreferences sollte sp?ter auch diese Einstellungen speichern
-		center = new CWPoint(pref.curCentrePt);
-		cacheDB = cacheDBi;
-		// tiles panel
-		MessageArea desc = new MessageArea(descString);
-		desc.modifyAll(mTextPad.NotEditable | mTextPad.DisplayOnly | mTextPad.NoFocus, mTextPad.TakesKeyFocus);
-		desc.borderStyle = mTextPad.BDR_NOBORDER;
-		pnlTiles.addLast(desc);
-		pnlTiles.addNext(forCachesChkBox);
-		pnlTiles.addNext(forSelectedChkBox);
-		pnlTiles.addLast(cachesLbl);
-		pnlTiles.addNext(distLbl = new mLabel(MyLocale.getMsg(1802,"Within a rectangle of:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		distanceInput = new mInput();
-		int tmp = Convert.toInt((Global.getProfile().distOC));
-		distanceInput.setText(Convert.toString((tmp > 0 ? tmp : 15)));
-		pnlTiles.addNext(distanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		pnlTiles.addLast(km);
-		pnlTiles.addNext(coosLbl = new mLabel(MyLocale.getMsg(1803, "around the center: ")));
-		pnlTiles.addLast(coosBtn = new mButton(center.toString()));
-		pnlTiles.addNext(scaleLbl);
-		scaleInput.setText("5");
-		this.focusFirst();
-		pnlTiles.addLast(scaleInput);
-		//	pnlTiles.addLast(resolutionLbl);
-		pnlTiles.addNext(overlappingLbl);
-		pnlTiles.addLast(overlappingInput);
-		overviewChkBox.setState(true);
-		pnlTiles.addLast(overviewChkBox);
-		cancelB = new mButton(MyLocale.getMsg(1604,"Cancel"));
-		cancelB.setHotKey(0, IKeys.ESCAPE);
-		pnlTiles.addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		okBtiles = new mButton(MyLocale.getMsg(1605,"OK"));
-		okBtiles.setHotKey(0, IKeys.ACTION);
-		okBtiles.setHotKey(0, IKeys.ENTER);
-		pnlTiles.addLast(okBtiles,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		updateForCachesState();
-		mTab.addCard(pnlTiles, MyLocale.getMsg(1804, "Tiles"), MyLocale.getMsg(1804, "Tiles"));
-
-		// per cache panel
-		pnlPerCache.addLast(new MessageArea(descString));
-		pnlPerCache.addNext(new mLabel("Download one map for"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
-		pnlPerCache.addNext(forSelectedChkBoxPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
-		pnlPerCache.addLast(new mLabel("caches"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
-		pnlPerCache.addNext(new mLabel("Approx. m per pixel"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
-		pnlPerCache.addLast(scaleInputPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
-
-		cancelBPerCache = new mButton(MyLocale.getMsg(1604,"Cancel"));
-		cancelBPerCache.setHotKey(0, IKeys.ESCAPE);
-		pnlPerCache.addNext(cancelBPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
-		okBPerCache = new mButton(MyLocale.getMsg(1605,"OK"));
-		okBPerCache.setHotKey(0, IKeys.ACTION);
-		okBPerCache.setHotKey(0, IKeys.ENTER);
-		pnlPerCache.addLast(okBPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
-
-		mTab.addCard(pnlPerCache, MyLocale.getMsg(1805, "Per cache"), MyLocale.getMsg(1805, "Per Cache"));
-		this.addLast(mTab);
-	}
-	public String getMapsDir() {
-		return Global.getPref().getMapExpediaSavePath();
-	}
-	public void downloadTiles() {
-		String mapsDir = getMapsDir();
-		if (mapsDir == null) return;
-		InfoBox progressBox = new InfoBox("Downloading georeferenced maps", "Downloading georeferenced maps\n from www.expedia.com");
-		progressBox.setPreferredSize(230, 150);
-		progressBox.exec();
-		Vm.showWait(true);
-		ewe.fx.Point size = new ewe.fx.Point(1000,1000); // Size of the downloaded maps
-		MapLoader ml = new MapLoader(Global.getPref().myproxy, Global.getPref().myproxyport);
-		if (forCachesChkBox.getState() || perCache) {
-			Area surArea = Global.getProfile().getSourroundingArea(onlySelected); // calculate map boundaries from cacheDB
-			if (surArea == null) {
-				(new MessageBox("Error", "No Caches are seleted", MessageBox.OKB)).execute();
-				Vm.showWait(false);
-				progressBox.close(0);
-				return;
-			}
-			ml.setTiles(surArea.topleft, surArea.buttomright, (int)scale, size, overlapping );
-			// calculate radius and center for overview map
-			center = new CWPoint((surArea.topleft.latDec + surArea.buttomright.latDec)/2, (surArea.topleft.lonDec + surArea.buttomright.lonDec)/2);
-			double radiuslat = (new CWPoint(center.latDec, surArea.buttomright.lonDec)).getDistance(surArea.buttomright);
-			double radiuslon = (new CWPoint(surArea.buttomright.latDec, center.lonDec)).getDistance(surArea.buttomright);
-			radius = (float) (radiuslat < radiuslon ? radiuslon : radiuslat);
-		} else 
-		{ // calculate from center point an radius
-			ml.setTiles(center, radius * 1000, (int)scale, size, overlapping);
-		}
-		if (overviewmap) {
-			progressBox.setInfo("downloading overview map"); 
-			int expediaAlti = MapLoader.getExpediaAlti(center, radius * 1000, size);
-			ml.downloadMap(center.latDec, center.lonDec, expediaAlti, size.x, size.y, mapsDir);
-		}
-		if (!perCache){  // download tiles
-			ml.setProgressInfoBox(progressBox);
-			ml.downlaodTiles(mapsDir);
-		} else { // per cache
-			CacheHolder ch; 
-			CWPoint tmpca = new CWPoint();
-			int numdownloaded = 0;
-			Global.getProfile().getSourroundingArea(onlySelected); // calculate numCachesInArea
-			int numCaches = Global.getProfile().numCachesInArea;
-			for (int i=cacheDB.size()-1; i >= 0; i--) {
-				ch = (CacheHolder) cacheDB.get(i);
-				if (!this.onlySelected || ch.is_Checked) {
-					if (ch.pos == null) { // this can not happen
-						tmpca.set(ch.LatLon);
-						ch.pos = new CWPoint(tmpca);
-					}
-					if (ch.pos.isValid() && ch.pos.latDec != 0 && ch.pos.lonDec != 0) { // TODO != 0 sollte verschwinden, sobald das handling von nicht gesetzten Koos ?berall korrekt ist
-						numdownloaded++;
-						progressBox.setInfo("Downloading map from expedia.de\n"+numdownloaded+" / "+numCaches+"\n for cache:\n"+ch.CacheName);
-						ml.downloadMap(ch.pos.latDec, ch.pos.lonDec, (int)scale, size.x, size.y, mapsDir);
-					}
-				}
-			}
-		}
-		Vm.showWait(false);
-		ml.setProgressInfoBox(null);
-		progressBox.close(0);
-		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
-		(new MessageBox("Expedia maps", "Downloaded and calibrated the maps successfully", MessageBox.OKB)).execute();
-	}
-
-
-	private void updateForCachesState() {
-		int a, b;
-		if (forCachesChkBox.getState()) {
-			// create map rectangle from caches
-			a = 0;
-			b = Control.Disabled;
-		}
-		else { // use center and distance input
-			a = Control.Disabled;
-			b = 0;
-		}
-		forSelectedChkBox.modify(a, b);
-		cachesLbl.modify(a, b);
-		distanceInput.modify(b, a);
-		distLbl.modify(b, a);
-		coosBtn.modify(b, a);
-		coosLbl.modify(b, a);
-		km.modify(b,a);
-		repaintNow();
-
-	}
-
-	public void onEvent(Event ev){
-		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelB || ev.target == cancelBPerCache){
-				this.close(Form.IDCANCEL);
-			}
-			if (ev.target == okBtiles || ev.target == okBPerCache){
-				if (ev.target == okBtiles) { // get tiles
-					perCache = false;
-					if (forSelectedChkBox.getSelectedItem().toString().equalsIgnoreCase("all")) onlySelected = false;
-					else onlySelected = true;
-					overviewmap = overviewChkBox.getState();
-					radius = Convert.toFloat(distanceInput.getText());
-					scale = Convert.toFloat(scaleInput.getText());
-					overlapping = Convert.toInt(overlappingInput.getText());
-					if (!forCachesChkBox.getState()) {
-						if (radius <= 0) { 
-							(new MessageBox("Error", "'radius' must be graeter than null", MessageBox.OKB)).execute();
-							return;
-						}
-						if (overlapping < 0) { 
-							(new MessageBox("Error", "'overlapping' must be greater or equal 0 ", MessageBox.OKB)).execute();
-							return;
-						}
-					}
-				} else { // per cache
-					perCache = true;
-					if (forSelectedChkBoxPerCache.getSelectedItem().toString().equalsIgnoreCase("all")) onlySelected = false;
-					else onlySelected = true;
-					overviewmap = overviewChkBoxPerCache.getState();
-					scale = Convert.toFloat(scaleInputPerCache.getText());
-				}
-				if (scale < 1 || scale != java.lang.Math.floor(scale)) {
-					(new MessageBox("Error", "'Approx. meter pro pixel' must be greater than 0 and must not contain a point", MessageBox.OKB)).execute();
-					return;
-				}
-				this.close(Form.IDOK); 
-				this.downloadTiles();
-			}
-			if (ev.target == coosBtn) {
-				CoordsScreen cs = new CoordsScreen();
-				cs.setFields(center, CWPoint.CW);
-				if (cs.execute() != CoordsScreen.IDCANCEL) {
-					center = cs.getCoords();
-					coosBtn.setText(center.toString());
-				}
-			}
-			if (ev.target == forCachesChkBox) {
-				updateForCachesState();
-			}
-		} // if controllEvent...
-		super.onEvent(ev);
-	}
-}

Deleted: trunk/src/CacheWolf/MapsList.java
===================================================================
--- trunk/src/CacheWolf/MapsList.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/MapsList.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -1,325 +0,0 @@
-package CacheWolf;
-
-import utils.FileBugfix;
-import ewe.io.File;
-import ewe.io.IOException;
-import ewe.sys.Double;
-import ewe.ui.MessageBox;
-import ewe.util.Hashtable;
-import ewe.util.Vector;
-import ewe.fx.*;
-/**
- * class to handle a list of maps
- * it loads the list, finds the best map for a given location,
- * says if a map is available for a given lat lon at a given scale
- * @author r
- *
- */
-public class MapsList extends Vector {
-	public static float scaleTolerance = 1.15f; // absolute deviations from this factor are seen to have the same scale
-	public Hashtable scales2Area;
-
-	/**
-	 * loads alle the maps in mapsPath in all subDirs but not recursive, only one level 
-	 * @param mapsPath
-	 */
-	public MapsList(String mapsPath) {
-		super(); // forget already loaded maps
-		//if (mmp.mapImage != null) 
-		String dateien[];
-		FileBugfix files = new FileBugfix(mapsPath);
-		String rawFileName = new String();
-		String[] dirstmp = files.list(null, File.LIST_DIRECTORIES_ONLY);
-		Vector dirs;
-		if (dirstmp != null) dirs = new Vector(dirstmp);
-		else dirs = new Vector();
-		dirs.add("."); // include the mapsPath itself
-		MapInfoObject tempMIO;
-		MessageBox f = null;
-		for (int j = dirs.size()-1; j >= 0; j--) {
-			files = new FileBugfix(mapsPath+"/"+dirs.get(j));
-			//ewe.sys.Vm.debug("mapd-Dirs:"+files);
-			dateien = files.list("*.wfl", File.LIST_FILES_ONLY); //"*.xyz" doesn't work on some systems -> use FileBugFix
-			for(int i = 0; i < dateien.length;i++){
-				// if (!dateien[i].endsWith(".wfl")) continue;
-				rawFileName = dateien[i].substring(0, dateien[i].lastIndexOf("."));
-				try {
-					tempMIO = new MapInfoObject();
-					if (dirs.get(j).equals(".")) // the notation dir/./filename doesn't work on all platforms anyhow
-						tempMIO.loadwfl(mapsPath+"/", rawFileName);
-					else tempMIO.loadwfl(mapsPath+"/"+dirs.get(j)+"/", rawFileName);
-					add(tempMIO);
-				}catch(IOException ex){ 
-					if (f == null) (f=new MessageBox("Warning", "Ignoring error while \n reading calibration file \n"+ex.toString(), MessageBox.OKB)).exec();
-				}catch(ArithmeticException ex){ // affine contain not allowed values 
-					if (f == null) (f=new MessageBox("Warning", "Ignoring error while \n reading calibration file \n"+ex.toString(), MessageBox.OKB)).exec();
-				} 
-			}
-		}
-	}
-
-	public void addEmptyMaps(double lat) {
-		MapInfoObject tempMIO;
-		tempMIO = new MapInfoObject(1.0, lat);
-		add(tempMIO);
-		tempMIO = new MapInfoObject(5.0, lat);
-		add(tempMIO);
-		tempMIO = new MapInfoObject(50.0, lat);
-		add(tempMIO);
-		tempMIO = new MapInfoObject(250.0, lat);
-		add(tempMIO);
-		tempMIO = new MapInfoObject(1000.0, lat);
-		add(tempMIO);
-	}
-
-	/**
-	 * find the best map for lat/lon in the list of maps
-	 * currently the best map is the one, whose center is nearest to lat/lon
-	 * and in Area with its scale nearest to scale.
-	 * it always returns a map (if the list is not empty) 
-	 * even if the map is not inbound
-	 * lat/lon
-	 * @param lat
-	 * @param lon
-	 * @param forceScale: when true, return null if no map with specified scale could be found
-	 * @return
-	 */
-	public MapInfoObject getBestMap(double lat, double lon, Rect screen, float scale, boolean forceScale) {
-		if (size() == 0) return null;
-		if (scales2Area != null) scales2Area.clear();
-		MapInfoObject mi;
-		MapInfoObject bestMap = null; // = (MapInfoObject)get(0);
-		double minDistLat = 1000000000000000000000000000000000000000000000.0;
-		double minDistLon = 1000000000000000000000000000000000000000000000.0;
-		boolean latNearer, lonNearer;
-		boolean better = false;
-		Area screenArea = null; // getAreaForScreen(screen, lat, lon, bestMap.scale, bestMap);
-		float lastscale = -1;
-		for (int i=size()-1; i >= 0 ;i--) { 
-			better = false;
-			mi = (MapInfoObject)get(i);
-			if (screenArea == null || !scaleEquals(lastscale, mi) ) {
-				screenArea = getAreaForScreen(screen, lat, lon, mi.scale, mi);
-				lastscale = mi.scale;
-			}
-			if (screenArea.isOverlapping(mi.getArea()) ) { // is on screen
-				if (!forceScale || (forceScale && !scaleEquals(scale, mi))) { // different scale?
-					if (!forceScale && (mi.inBound(lat, lon) && (bestMap == null || scaleNearer(mi.scale, bestMap.scale, scale) || !bestMap.inBound(lat, lon)))) 
-						better = true; // inbound and resolution nearer at wanted resolution or old one is on screen but lat/long not inbound-> better
-					else {
-						if ( bestMap == null || scaleNearerOrEuqal(mi.scale, bestMap.scale, scale)) {
-							latNearer = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm < minDistLat ;
-							lonNearer = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm < minDistLon;
-							if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
-							else {
-								if ( (latNearer || lonNearer )) { 
-									if (bestMap == null || mi.center.getDistanceRad(lat, lon) < bestMap.center.getDistanceRad(lat, lon) ) better = true;
-								}
-							}
-						}
-					}
-					if (better) {
-						minDistLat = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm;
-						minDistLon = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm;
-						bestMap = mi;
-						// Vm.debug("better"+ i);
-					}
-				}
-			}
-		}
-		if (bestMap == null) return null;
-		return new MapInfoObject(bestMap); // return a copy of the MapInfoObject so that zooming won't change the MapInfoObject in the list 
-	}
-	/*
-	public MapInfoObject getBestMapNotStrictScale(double lat, double lon, Area screen, float scale) {
-		MapInfoObject ret = getBestMap(lat, lon, screen, scale, true);
-		if (ret == null) ret = getBestMap(lat, lon, screen, scale, false);
-		return ret;
-	}
-	 */
-	/**
-	 * @return a map which includs topleft and bottomright, 
-	 * if no map includes both it returns null
-	 * @param if more than one map includes topleft and bottomright than the one will
-	 * be returned which has its center nearest to topleft. If you have gps-pos and goto-pos
-	 * as topleft and buttomright use gps as topleft.
-	 * if topleft is really topleft or if it is buttomright is not relevant.  
-	 */
-	
-	public MapInfoObject getMapForArea(CWPoint topleft, CWPoint bottomright){
-		MapInfoObject mi;
-		MapInfoObject fittingmap = null;
-		boolean latNearer, lonNearer;
-		boolean better;
-		double minDistLat = 10000000000000000000000.0;
-		double minDistLon = 10000000000000000000000.0;
-		for (int i=size() -1; i>=0 ;i--) {
-			better = false;
-			mi = (MapInfoObject)get(i);
-			if (mi.inBound(topleft) && mi.inBound(bottomright)) { // both points are inside the map
-				if (fittingmap == null || fittingmap.scale > mi.scale * scaleTolerance) {
-					better = true; // mi map has a better (lower) scale than the last knwon good map
-				} else {
-					if (fittingmap != null && scaleEquals(mi, fittingmap)) { // same scale as bestmap till now -> test if its center is nearer to the gps-point = topleft
-						latNearer = java.lang.Math.abs(topleft.latDec- mi.center.latDec)/mi.sizeKm < minDistLat ;
-						lonNearer = java.lang.Math.abs(topleft.lonDec - mi.center.lonDec)/mi.sizeKm < minDistLon;
-						if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
-						else {
-							if ( (latNearer || lonNearer )) { 
-								if (mi.center.getDistanceRad(topleft.latDec, topleft.lonDec) < fittingmap.center.getDistanceRad(topleft.latDec, topleft.lonDec) ) better = true;
-							}
-						}
-
-					}
-				}
-				if (better) {
-					fittingmap = mi;
-					minDistLat = java.lang.Math.abs(topleft.latDec - mi.center.latDec);
-					minDistLon = java.lang.Math.abs(topleft.lonDec - mi.center.lonDec);
-				}
-			}
-		} // for
-		if (fittingmap == null) return null;
-		return new MapInfoObject(fittingmap);
-	}
-
-	/**
-	 * 
-	 * @param lat a point to be inside the map
-	 * @param lon
-	 * @param screen: width, height of the screen. The map must overlap the screen. xy: where is lat/lon on screen
-	 * @param curScale reference scale to be changed
-	 * @param moreDetails true: find map with more details == higher resolustion = lower scale / false find map with less details = better overview
-	 * @return
-	 */
-	public MapInfoObject getMapChangeResolution(double lat, double lon, Rect screen, float curScale, boolean moreDetails){
-		if (size() == 0) return null;
-		if (scales2Area != null) scales2Area.clear();
-		MapInfoObject mi;
-		MapInfoObject bestMap = null; // = (MapInfoObject)get(0);
-		double minDistLat = 1000000000000000000000000000000000000000000000.0;
-		double minDistLon = 1000000000000000000000000000000000000000000000.0;
-		boolean latNearer, lonNearer;
-		boolean better = false;
-		Area screenArea = null; // getAreaForScreen(screen, lat, lon, bestMap.scale, bestMap);
-		float lastscale = -1;
-		for (int i=size()-1; i >= 0 ;i--) { 
-			better = false;
-			mi = (MapInfoObject)get(i);
-			if (mi.fileNameWFL == "") continue; // exclude "maps" without image // TODO make this a boolean in MapInfoObject
-			if (screenArea == null || !scaleEquals(lastscale, mi)) {
-				screenArea = getAreaForScreen(screen, lat, lon, mi.scale, mi);
-				lastscale = mi.scale;
-			}
-			if (screenArea.isOverlapping(mi.getArea())) { // is on screen
-				if (bestMap == null || !scaleEquals(mi, bestMap)) { // different scale than known bestMap?
-					if (mi.inBound(lat, lon) && (      // more details wanted and this map has more details?                                // less details than bestmap
-							(moreDetails && (curScale > mi.scale * scaleTolerance) && (bestMap == null || mi.scale > bestMap.scale * scaleTolerance ) ) // higher resolution wanted and mi has higher res and a lower res than bestmap, because we dont want to overjump one resolution step
-							|| (!moreDetails && (curScale *  scaleTolerance < mi.scale) && (bestMap == null || mi.scale * scaleTolerance < bestMap.scale) ) // lower resolution wanted and mi has lower res and a higher res than bestmap, because we dont want to overjump one resolution step
-					) )	better = true;	// inbound and higher resolution if higher res wanted -> better
-				} else { // same scale as bestmap -> look if naerer 
-					latNearer = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm < minDistLat ;
-					lonNearer = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm < minDistLon;
-					if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
-					else {
-						if ( (latNearer || lonNearer )) { 
-							if (bestMap == null || mi.center.getDistanceRad(lat, lon) < bestMap.center.getDistanceRad(lat, lon) ) better = true;
-						}
-					}
-				} // same scale
-				if (better) {
-					minDistLat = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm;
-					minDistLon = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm;
-					bestMap = mi;
-					// Vm.debug("better"+ i);
-				}
-			}
-		}
-		if (bestMap == null) return null;
-		return new MapInfoObject(bestMap);
-	}
-	/**
-	 * returns an area in lat/lon of the screen
-	 * @param a screen width / height and position of lat/lon on the screen
-	 * @param lat a (reference) point on the screen
-	 * @param lon
-	 * @param scale scale (meters per pixel) of the map for which the screen edges are wanted
-	 * @param map map for which the screen edges are wanted
-	 * @return
-	 */
-	private Area getAreaForScreen(Rect a, double lat, double lon, float scale, MapInfoObject map) {
-		Area ret = null;
-/*		if (scales2Area == null) scales2Area = new Hashtable();
-		else ret = (Area)scales2Area.get(scale);
-		if (ret != null) return ret;
-	*/	// calculate screen Area
-		Point xy = map.calcMapXY(lat, lon);
-		Point topleft = new Point(xy.x - a.x, xy.y - a.y);
-		ret = new Area(map.calcLatLon(topleft), map.calcLatLon(topleft.x+a.width, topleft.y+a.height));
-		//scales2Area.put(new Float(scale), ret);
-		return ret; 
-	}
-	public static boolean scaleEquals(MapInfoObject a, MapInfoObject b) {
-		//return java.lang.Math.abs(a.scale - b.scale) < scaleTolerance;
-		if (a.scale > b.scale) return a.scale / b.scale < scaleTolerance; 
-		else return b.scale / a.scale < scaleTolerance;
-	}
-	public static boolean scaleEquals(float s, MapInfoObject b) {
-		//return java.lang.Math.abs(s - b.scale) < scaleTolerance;
-		if (s > b.scale) return s / b.scale < scaleTolerance;
-		else return b.scale / s < scaleTolerance;
-	}
-	
-	/**
-	 * 
-	 * @param test
-	 * @param old
-	 * @param wanted
-	 * @return true if test is nearer to wanted than old, false if the change in the scale is lower than scaleTolerance
-	 */
-	public static boolean scaleNearer(float test, float old, float wanted) {
-		float testa, wanta, wantb, olda;
-		if (test > wanted) { // ensure that first term is greater than 1
-			testa = test;
-			wanta = wanted;
-		} else {
-			testa = wanted;
-			wanta = test;
-		}
-		if (old > wanted) { // ensure that second term is greater than 1 
-			olda = old;
-			wantb = wanted;
-		} else {
-			olda = wanted;
-			wantb = old;
-		}
-		return testa/wanta * scaleTolerance < olda/wantb; 
-	}
-
-	public static boolean scaleNearerOrEuqal(float test, float old, float wanted) {
-		float testa, wanta, wantb, olda;
-		if (test > wanted) { // ensure that first term is greater than 1
-			testa = test;
-			wanta = wanted;
-		} else {
-			testa = wanted;
-			wanta = test;
-		}
-		if (old > wanted) { // ensure that second term is greater than 1 
-			olda = old;
-			wantb = wanted;
-		} else {
-			olda = wanted;
-			wantb = old;
-		}
-		return testa/wanta < olda/wantb * scaleTolerance ; 
-	}
-
-	/** for determining if a new map should be downloaded
-	public boolean isInAmap(CWPoint topleft, CWPoint buttomright) {
-		if (!latRangeList.isInRange(topleft.latDec) || !latRangeList.isInRange(buttomright.latDec)) ||
-			!lonRangeList.inInRange(topleft.lonDec) || !lonRangeList.isInRange(buttomright.lonDec)
-			return false;
-	}
-	 */
-}

Deleted: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/MovingMap.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -1,2116 +0,0 @@
-package CacheWolf;
-
-import ewe.ui.*;
-import ewe.graphics.*;
-import ewe.io.File;
-import ewe.io.IOException;
-import ewe.sys.*;
-import ewe.filechooser.FileChooser;
-import ewe.fx.*;
-import ewe.util.Vector;
-
-/**
- *	Class to handle a moving map.
- */
-public class MovingMap extends Form {
-	final static int gotFix = 4; //green
-	final static int lostFix = 3; //yellow
-	final static int noGPSData = 2; // red
-	final static int noGPS = 1; // no GPS-Position marker, manually disconnected 
-	final static int ignoreGPS = -1; // ignore even changes in GPS-signal (eg. from lost fix to gotFix) this is wanted when the map is moved manually
-
-	public MapSymbol gotoPos = null;
-	public int GpsStatus;
-	Preferences pref;
-	MovingMapPanel mmp;
-	MapsList maps;
-	Vector symbols;
-	Vector cacheDB;
-	TrackOverlay[] TrackOverlays;
-	CWPoint TrackOverlaySetCenterTopLeft;
-	Vector tracks;
-	MapInfoObject currentMap = null;
-	String mapPath;
-	Navigate myNavigation;
-	boolean running = false;
-
-	MapImage mapImage1to1;
-	ArrowsOnMap directionArrows = new ArrowsOnMap();
-	AniImage statusImageHaveSignal = new AniImage("position_green.png");
-	AniImage statusImageNoSignal = new AniImage("position_yellow.png");
-	AniImage statusImageNoGps = new AniImage("position_red.png");
-	AniImage bottonImageClose;
-	AniImage bottonImageChooseMap = new AniImage("choose_map.gif"); 
-	AniImage buttonImageGpsOn = new AniImage("snap2gps.gif");
-	AniImage buttonImageLens = new AniImage("lupe.png");
-	AniImage buttonImageLensActivated = new AniImage("lupe_activated.png");
-	AniImage buttonImageZoom1to1 = new AniImage("zoom1to1.png");
-	AniImage DistanceImage;
-	Graphics DistanceImageGraphics;
-	AniImage ScaleImage;
-	Graphics ScaleImageGraphics;
-	MapImage posCircle = new MapImage("position_green.png");
-	public static final String MARK_CACHE_IMAGE = "mark_cache.png";
-	int posCircleX = 0, posCircleY = 0, lastCompareX = Integer.MAX_VALUE, lastCompareY = Integer.MAX_VALUE;
-	double posCircleLat, posCircleLon;
-	FontMetrics fm;
-
-	boolean dontUpdatePos = false; // this is only internaly used to avoid multi-threading problems
-	boolean ignoreGps = false; // ignores updateGps-calls if true
-	boolean autoSelectMap = true;
-	boolean forceMapLoad = true; // only needed to force updateposition to try to load the best map again after OutOfMemoryError after an repeated click on snap-to-gps
-	boolean mapHidden = false;
-	boolean noMapsAvailable;
-	boolean zoomingMode = false;
-	boolean mapsloaded = false;
-	
-	Point lastRepaintMapPos = null;
-	double lastDistance = -1;
-
-	public MovingMap(Navigate nav, Vector cacheDB){
-		this.cacheDB = cacheDB;
-		this.myNavigation = nav;
-		this.pref = Global.getPref();
-		if (pref.myAppHeight <= 640 && pref.myAppWidth <= 640)	this.windowFlagsToSet = Window.FLAG_FULL_SCREEN;
-		this.windowFlagsToClear = Window.FLAG_HAS_TITLE | Window.BDR_NOBORDER;
-		this.hasTopBar = false;
-		this.noBorder = true;
-		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
-		this.title = "Moving Map";
-		this.backGround = new Color(254,254,254); // background must not be black because black is interpreted as transparent and transparent images above (eg trackoverlay) want be drawn in windows-VM, so be care, don|t use white either
-		this.mapPath = Global.getPref().getMapLoadPath();
-
-		mmp = new MovingMapPanel(this);
-		this.addLast(mmp);
-		DrawnIcon closeX = new DrawnIcon(DrawnIcon.CROSS,15,15,new Color(0,0,0));
-		bottonImageClose = new AniImage(new Image(closeX.getWidth(), closeX.getHeight()));
-		Graphics tmp = new Graphics(bottonImageClose.image);
-		tmp.setColor(255, 255, 255);
-		tmp.fillRect(0, 0, closeX.getWidth(), closeX.getHeight());
-		closeX.doDraw(tmp, 0);
-		bottonImageClose.properties |= AniImage.AlwaysOnTop;
-		mmp.addImage(bottonImageClose);
-		buttonImageGpsOn.properties = AniImage.AlwaysOnTop;
-		mmp.addImage(buttonImageGpsOn);
-		bottonImageChooseMap.properties = AniImage.AlwaysOnTop;
-		mmp.addImage(bottonImageChooseMap);
-		directionArrows.properties = AniImage.AlwaysOnTop;
-		mmp.addImage(directionArrows);
-		buttonImageLens.properties = AniImage.AlwaysOnTop;
-		buttonImageLensActivated.properties = AniImage.AlwaysOnTop;
-		mmp.addImage(buttonImageLens);
-		buttonImageZoom1to1.properties = AniImage.AlwaysOnTop;
-		mmp.addImage(buttonImageZoom1to1);
-		//target distance
-		Font font = new Font("Helvetica", Font.PLAIN, 13);
-		fm = getFontMetrics(font);
-		DistanceImage = new AniImage();
-		DistanceImage.setImage(new Image(120, 15), Color.White); // consider the size of the font used
-		DistanceImageGraphics = new Graphics(DistanceImage.image);
-		DistanceImageGraphics.setFont(font);
-		DistanceImage.properties = AniImage.AlwaysOnTop;
-		mmp.addImage(DistanceImage);
-		//scale
-		ScaleImage = new AniImage();
-		ScaleImage.setImage(new Image(120, 15), Color.White); // consider the size of the font used
-		ScaleImageGraphics = new Graphics(ScaleImage.image);
-		ScaleImageGraphics.setFont(font);
-		ScaleImage.properties = AniImage.AlwaysOnTop;
-		mmp.addImage(ScaleImage);
-		//resizeTo(pref.myAppWidth, pref.myAppWidth); // is necessary to initialize mapImage.screenSize
-		setGpsStatus(noGPS);
-		posCircle.properties = AniImage.AlwaysOnTop;
-		mmp.addImage(posCircle);
-		mmp.startDragResolution = 5;
-		mapsloaded = false;
-		posCircleLat = -361;
-		posCircleLon = -361; // make them invalid
-		//updateDistance(); // fill Rect with transparent color
-		scaleWanted = 1;
-		mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
-		
-		lastRepaintMapPos = new Point(pref.myAppWidth +1, pref.myAppHeight +1);
-	}
-
-	public void resizeTo(int w,int h) {
-		super.resizeTo(w, h);
-		updateFormSize(w, h);
-	}
-
-	public void updateFormSize(int w, int h) {
-		MapImage.setScreenSize(w, h);
-		bottonImageClose.setLocation(w- bottonImageClose.getWidth()- 5, 5);
-		buttonImageGpsOn.setLocation(w- bottonImageChooseMap.getWidth()-5, bottonImageClose.getHeight() + 20);
-		bottonImageChooseMap.setLocation(10,10);
-		directionArrows.setLocation(w/2-directionArrows.getWidth()/2, 10);
-		buttonImageZoom1to1.setLocation(w - buttonImageZoom1to1.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 - buttonImageZoom1to1.getHeight() -10);
-		buttonImageLens.setLocation(w - buttonImageLens.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 );
-		buttonImageLensActivated.setLocation(w - buttonImageLens.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 );
-		DistanceImage.setLocation(0, h - DistanceImage.getHeight());
-		ScaleImage.setLocation(w - ScaleImage.getWidth(), h - ScaleImage.getHeight());
-		if (mmp.mapImage != null) mmp.mapImage.move(mmp.mapImage.locAlways.x, mmp.mapImage.locAlways.y); // this is necessary to make a new decision if it is still on the screen (and actually mor important because MapImage only now gets to know the screen size) 
-		if (posCircle != null) posCircle.move(posCircle.locAlways.x, posCircle.locAlways.y); // this is necessary to make a new decision if it is still on the screen (and actually mor important because MapImage only now gets to know the screen size) 
-		if (tracks != null) addOverlaySet();
-	}
-
-	boolean loadingMapList = false;
-	/**
-	 * loads the list of maps
-	 * @param mapsPath must not have a trailing end "/"
-	 * @param lat used to create empty maps with correct conversion from lon to meters the latitude must be known
-	 */
-	public void loadMaps(String mapsPath, double lat){
-		if (loadingMapList) return;
-		loadingMapList = true;
-		this.mapPath = mapsPath;
-		Vm.showWait(this, true);
-		resetCenterOfMap();
-		InfoBox inf = new InfoBox("Info", "Loading list of maps...");
-		inf.exec();
-		inf.waitUntilPainted(100);
-		boolean saveGpsIgnoreStatus = dontUpdatePos;
-		dontUpdatePos = true;
-		maps = new MapsList(mapsPath); // this actually loads the maps
-		if (maps.isEmpty()) {
-			(new MessageBox(MyLocale.getMsg(327, "Information"), MyLocale.getMsg(326, "Es steht keine kalibrierte Karte zur Verf?gung \n Bitte w?hlen Sie einen Ma?stab,\n in dem der Track und die markierten Caches angezeigt werden sollen"), MessageBox.OKB)).execute();
-			noMapsAvailable = true;
-		} else noMapsAvailable = false;
-		maps.addEmptyMaps(lat);
-		dontUpdatePos = saveGpsIgnoreStatus;
-		inf.close(0);
-		Vm.showWait(this, false);
-		this.mapsloaded = true;
-		loadingMapList = false;
-	}
-
-	public void updateScale() {
-		ScaleImageGraphics.setColor(ScaleImage.transparentColor);
-		ScaleImageGraphics.fillRect(0, 0, ScaleImage.location.width,ScaleImage.location.height);
-		
-		if (currentMap != null)
-		{
-			float lineLengthMeters = 40 * currentMap.scale;
-			float digits = (float)java.lang.Math.floor( java.lang.Math.log(lineLengthMeters) / java.lang.Math.log(10.0) );
-			lineLengthMeters = (float)java.lang.Math.ceil( lineLengthMeters / (float)java.lang.Math.pow(10, digits) ) * (float)java.lang.Math.pow(10, digits);
-			int lineLengthPixels = (int)java.lang.Math.round( lineLengthMeters / currentMap.scale );
-
-			String lineLengthString;
-			if (lineLengthMeters < 1000)
-			{
-				lineLengthString = Convert.toString((int) lineLengthMeters) + "m";
-			}
-			else
-			{
-				lineLengthString = Convert.toString((int) lineLengthMeters / 1000) + "km";
-			}
-			
-			int backgroundStartX = ScaleImage.location.width - (lineLengthPixels + fm.getTextWidth(lineLengthString) + 7);
-			
-			ScaleImageGraphics.setColor(new Color(250,250,250));
-			ScaleImageGraphics.fillRect(backgroundStartX, 0, ScaleImage.location.width - backgroundStartX ,ScaleImage.location.height);
-
-			ScaleImageGraphics.setPen(new Pen(Color.DarkBlue,Pen.SOLID,3));
-			ScaleImageGraphics.drawLine(backgroundStartX + 2, ScaleImage.location.height / 2, backgroundStartX+2+lineLengthPixels, ScaleImage.location.height / 2);
-			ScaleImageGraphics.setColor(Color.DarkBlue);
-			ScaleImageGraphics.drawText(lineLengthString , backgroundStartX + lineLengthPixels + 5, 0);
-		}
-		
-		ScaleImageGraphics.drawImage(ScaleImage.image,null,Color.LightBlue,0,0,ScaleImage.location.width,ScaleImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
-		ScaleImageGraphics.drawImage(ScaleImage.image,null,Color.White,0,0,ScaleImage.location.width,ScaleImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
-	}
-	
-	public void updateDistance(boolean repaint) {
-		DistanceImageGraphics.setColor(DistanceImage.transparentColor);
-		DistanceImageGraphics.fillRect(0, 0, DistanceImage.location.width,DistanceImage.location.height);
-		if (gotoPos != null && posCircleLat >= -360)
-		{
-			double currentDistance = (new CWPoint(gotoPos.lat, gotoPos.lon).getDistance(posCircleLat, posCircleLon));
-			if (currentDistance != lastDistance)
-			{
-				lastDistance = currentDistance;
-				ewe.sys.Double dd = new ewe.sys.Double();
-				dd.set(currentDistance);
-				String d;
-				if (dd.value < 1) {
-					dd.value = dd.value * 1000; 
-					dd.decimalPlaces = 0;
-					d = "Dist: " + dd.toString() + "m";
-					int digits = (int)java.lang.Math.floor( java.lang.Math.log(dd.value) / java.lang.Math.log(10.0) );
-					digits = java.lang.Math.max(0, digits);
-				} 
-				else {
-					dd.decimalPlaces = 2;
-					d = "Dist: " + dd.toString() + "km";
-					int digits = (int)java.lang.Math.floor( java.lang.Math.log(dd.value) / java.lang.Math.log(10.0) );
-					digits = java.lang.Math.max(0, digits);
-				}
-				
-				int backgroundWidth = fm.getTextWidth(d) + 4;
-
-				DistanceImageGraphics.setColor(new Color(250,250,250));
-				DistanceImageGraphics.fillRect(0, 0, backgroundWidth ,DistanceImage.location.height);
-
-				DistanceImageGraphics.setColor(Color.DarkBlue);
-				DistanceImageGraphics.drawText(d, 2, 0);
-				
-				DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.LightBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
-				DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.White,0,0,DistanceImage.location.width,DistanceImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
-				if (repaint)
-				{
-					DistanceImage.refreshNow();
-				}
-			}
-		}
-		else
-		{
-			DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.LightBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
-			DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.White,0,0,DistanceImage.location.width,DistanceImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
-		}
-	}
-
-	public void forceMapLoad() {
-		forceMapLoad = true;
-		updatePosition(posCircleLat, posCircleLon); // this sets forceMapLoad to false after loading a map
-	}
-
-	public final FormFrame myExec() {
-		// update cache symbols in map
-		running = true;
-		MainTab mainT = Global.mainTab;
-		if (Global.getProfile().selectionChanged) {
-			Global.getProfile().selectionChanged = false;
-			removeAllMapSymbolsButGoto();
-			CacheHolder ch;
-			for (int i=cacheDB.size()-1; i>=0; i--) {
-				ch = (CacheHolder) cacheDB.get(i);
-				if (ch.is_Checked && !ch.is_filtered && ch != mainT.ch) {
-					int ct = Convert.parseInt(ch.type);
-					addSymbol(ch.CacheName, ch, myTableModel.cacheImages[ct], ch.pos.latDec, ch.pos.lonDec);
-				}
-			}
-		}
-		setMarkedCache(mainT.ch);
-		addTrack(myNavigation.curTrack);
-		if (tracks != null && tracks.size() > 0 && ((Track)tracks.get(0)).num > 0) 
-			addOverlaySet(); // show points which where added when MavingMap was not running
-		destChanged(myNavigation.destination);
-		FormFrame ret = exec();
-		return ret;
-	}
-	
-	CacheHolder markedCache = null;
-	public void setMarkedCache(CacheHolder ch) {
-		if (ch == markedCache) return;
-		if (markedCache != null) {
-			removeMapSymbol("selectedCache");
-			if (!markedCache.is_Checked) removeMapSymbol(markedCache);
-		}
-		if (ch != null) {
-			addSymbol("selectedCache", MARK_CACHE_IMAGE, ch.pos.latDec, ch.pos.lonDec);
-			int ct = Convert.parseInt(ch.type);
-			addSymbolIfNecessary(ch.CacheName, ch, myTableModel.cacheImages[ct], ch.pos.latDec, ch.pos.lonDec);
-		}
-		markedCache = ch;
-	}
-	
-	public void addTrack(Track tr) {
-		if (tr == null) return;
-		if (tracks == null) tracks = new Vector();
-		if (tracks.find(tr) >= 0 ) return; // track already in list
-		tracks.add(tr);
-		addOverlaySet();
-	}
-
-	public void addTracks(Track[] trs) {
-		if (trs==null || trs.length == 0) return;
-		for (int i=0; i<trs.length; i++) {
-			addTrack(trs[i]);
-		}
-		addOverlaySet();
-	}
-
-	/**
-	 * adds an 3x3 set of overlays to the map-window which contain the track
-	 * 
-	 * add tracks with addtrack(track) before
-	 */
-
-	public void addOverlaySet() {
-		destroyOverlaySet();
-		if (tracks == null) return; // no tracks
-		try {
-			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
-			addMissingOverlays();
-		} catch (NullPointerException e) {} // hapens if currentmap == null or PosCircle not valid
-		catch (IllegalArgumentException e) {} // happens if screensize is still not known    ---> in both cases creation of Overlayset will be done in updateOverlayPos if tracks != null 
-	}
-
-	public void destroyOverlaySet() {
-		if (TrackOverlays != null) {
-			for (int i=0; i< TrackOverlays.length; i++) {	destroyOverlay(i);	}
-		}
-		Vm.getUsedMemory(true); // call garbage collection
-		Vm.gc();
-	}
-
-
-	public void addMissingOverlays() {
-		if (currentMap == null || posCircleLat < -360 || width == 0 || height == 0) return; // height == 0 happens if this is called before the form ist displayed on the screen
-		if (TrackOverlays == null) {
-			TrackOverlays = new TrackOverlay[9];
-			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
-		}
-		boolean saveGPSIgnoreStatus = dontUpdatePos; // avoid multi-threading problems
-		dontUpdatePos = true;
-		Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft.latDec, TrackOverlaySetCenterTopLeft.lonDec); // TrackOverlay[4] == center of Trackoverlays 
-		//upperleftOf4.x = (upperleftOf4.x + 1* width) % (width * 2) - 1 * width;
-		//upperleftOf4.y = (upperleftOf4.y + 1* height) % (height * 2) - 1 * height;
-		int i;
-		for (int yi=0; yi<3; yi++) {
-			for (int xi=0; xi<3; xi++) {
-				i = yi*3+xi;
-				if (TrackOverlays[i]==null) { 
-					TrackOverlays[i]= new TrackOverlay(ScreenXY2LatLon(upperleftOf4.x+(xi-1)*width, upperleftOf4.y+(yi-1)*height), width, height, currentMap); 
-					TrackOverlays[i].setLocation(width+1, height+1); // outside of the screen will hide it automatically it will get the correct position in upadteOverlayposition 
-					TrackOverlays[i].tracks = this.tracks;
-					TrackOverlays[i].paintTracks();
-					mmp.addImage(TrackOverlays[i]);
-				}
-			}
-		}
-		updateOverlayOnlyPos();
-		if (mmp.mapImage != null) mmp.images.moveToBack(mmp.mapImage);
-		dontUpdatePos = saveGPSIgnoreStatus;
-	}
-
-	private void destroyOverlay(int ov) {
-		if (TrackOverlays[ov] == null) return; 
-		mmp.removeImage(TrackOverlays[ov]);
-		TrackOverlays[ov].free();
-		TrackOverlays[ov]=null;
-	}
-	public void rearangeOverlays() {
-		Point oldp = getXYonScreen(TrackOverlaySetCenterTopLeft.latDec, TrackOverlaySetCenterTopLeft.lonDec);
-		if (TrackOverlays[1].isOnScreen()) { // oben raus
-			TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y - 2* height));
-			destroyOverlay(6);
-			destroyOverlay(7);
-			destroyOverlay(8);
-			mmp.removeImage(TrackOverlays[0]);
-			mmp.removeImage(TrackOverlays[1]);
-			mmp.removeImage(TrackOverlays[2]);
-			TrackOverlays[6]=TrackOverlays[0];
-			TrackOverlays[7]=TrackOverlays[1];
-			TrackOverlays[8]=TrackOverlays[2];
-			mmp.addImage(TrackOverlays[6]);
-			mmp.addImage(TrackOverlays[7]);
-			mmp.addImage(TrackOverlays[8]);
-			TrackOverlays[0] = null;
-			TrackOverlays[1] = null;
-			TrackOverlays[2] = null;
-			destroyOverlay(3);
-			destroyOverlay(4);
-			destroyOverlay(5);
-		} else {
-			if (TrackOverlays[3].isOnScreen()) { // links raus
-				TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y ));
-				destroyOverlay(2);
-				destroyOverlay(5);
-				destroyOverlay(8);
-				mmp.removeImage(TrackOverlays[0]);
-				mmp.removeImage(TrackOverlays[3]);
-				mmp.removeImage(TrackOverlays[6]);
-				TrackOverlays[2]=TrackOverlays[0];
-				TrackOverlays[5]=TrackOverlays[3];
-				TrackOverlays[8]=TrackOverlays[6];
-				mmp.addImage(TrackOverlays[2]);
-				mmp.addImage(TrackOverlays[5]);
-				mmp.addImage(TrackOverlays[8]);
-				TrackOverlays[0] = null;
-				TrackOverlays[3] = null;
-				TrackOverlays[6] = null;
-				destroyOverlay(1);
-				destroyOverlay(4);
-				destroyOverlay(7);
-			} else {
-				if (TrackOverlays[5].isOnScreen()) { // rechts raus
-					TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y ));
-					destroyOverlay(0);
-					destroyOverlay(3);
-					destroyOverlay(6);
-					mmp.removeImage(TrackOverlays[2]);
-					mmp.removeImage(TrackOverlays[5]);
-					mmp.removeImage(TrackOverlays[8]);
-					TrackOverlays[0]=TrackOverlays[2];
-					TrackOverlays[3]=TrackOverlays[5];
-					TrackOverlays[6]=TrackOverlays[8];
-					mmp.addImage(TrackOverlays[0]);
-					mmp.addImage(TrackOverlays[3]);
-					mmp.addImage(TrackOverlays[6]);
-					TrackOverlays[2] = null;
-					TrackOverlays[5] = null;
-					TrackOverlays[8] = null;
-					destroyOverlay(1);
-					destroyOverlay(4);
-					destroyOverlay(7);
-				} else {
-					if (TrackOverlays[7].isOnScreen()) { // unten raus
-						TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y + 2* height));
-						destroyOverlay(0);
-						destroyOverlay(1);
-						destroyOverlay(2);
-						mmp.removeImage(TrackOverlays[6]);
-						mmp.removeImage(TrackOverlays[7]);
-						mmp.removeImage(TrackOverlays[8]);
-						TrackOverlays[0]=TrackOverlays[6];
-						TrackOverlays[1]=TrackOverlays[7];
-						TrackOverlays[2]=TrackOverlays[8];
-						mmp.addImage(TrackOverlays[0]);
-						mmp.addImage(TrackOverlays[1]);
-						mmp.addImage(TrackOverlays[2]);
-						TrackOverlays[6] = null;
-						TrackOverlays[7] = null;
-						TrackOverlays[8] = null;
-						destroyOverlay(3);
-						destroyOverlay(4);
-						destroyOverlay(5);
-					} else { // it is important to test for diagonal only if the other didn't match
-						if (TrackOverlays[0].isOnScreen()) {  // links oben raus
-							TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y - 2* height));
-							destroyOverlay(8);
-							mmp.removeImage(TrackOverlays[0]);
-							TrackOverlays[8]=TrackOverlays[0];
-							mmp.addImage(TrackOverlays[8]);
-							TrackOverlays[0] = null;
-							destroyOverlay(1);
-							destroyOverlay(2);
-							destroyOverlay(3);
-							destroyOverlay(4);
-							destroyOverlay(5);
-							destroyOverlay(6);
-							destroyOverlay(7);
-						} else {
-							if (TrackOverlays[2].isOnScreen()) { // rechts oben raus
-								TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y - 2* height));
-								destroyOverlay(6);
-								mmp.removeImage(TrackOverlays[2]);
-								TrackOverlays[6]=TrackOverlays[2];
-								mmp.addImage(TrackOverlays[6]);
-								TrackOverlays[2] = null;
-								destroyOverlay(0);
-								destroyOverlay(1);
-								destroyOverlay(3);
-								destroyOverlay(4);
-								destroyOverlay(5);
-								destroyOverlay(7);
-								destroyOverlay(8);
-							} else {
-								if (TrackOverlays[6].isOnScreen()) { // links unten raus
-									TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y + 2* height));
-									destroyOverlay(2);
-									mmp.removeImage(TrackOverlays[6]);
-									TrackOverlays[2]=TrackOverlays[6];
-									mmp.addImage(TrackOverlays[2]);
-									TrackOverlays[6] = null;
-									destroyOverlay(0);
-									destroyOverlay(1);
-									destroyOverlay(3);
-									destroyOverlay(4);
-									destroyOverlay(5);
-									destroyOverlay(7);
-									destroyOverlay(8);
-								} else {
-									if (TrackOverlays[8].isOnScreen()) { // rechts unten raus
-										TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y + 2* height));
-										destroyOverlay(0);
-										mmp.removeImage(TrackOverlays[8]);
-										TrackOverlays[0]=TrackOverlays[8];
-										mmp.addImage(TrackOverlays[0]);
-										TrackOverlays[8] = null;
-										destroyOverlay(1);
-										destroyOverlay(2);
-										destroyOverlay(3);
-										destroyOverlay(4);
-										destroyOverlay(5);
-										destroyOverlay(6);
-										destroyOverlay(7);
-									}else
-										for (int i=0; i<TrackOverlays.length; i++) {
-											destroyOverlay(i);
-											TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
-										} // this happens if a position jump occured
-								}}}}}}} // close all IFs
-		Vm.gc(); // call garbage collection
-		Vm.debug("Overlayrearanged"+TrackOverlays.toString());
-	}
-
-	public void ShowLastAddedPoint(Track tr) {
-		if (TrackOverlays == null || tr == null) return;
-		for (int i=0; i<TrackOverlays.length; i++){
-			TrackOverlays[i].paintLastAddedPoint(tr);
-		}
-	}
-
-	public void updateOverlayOnlyPos() {
-		if (TrackOverlays == null || TrackOverlays[4] == null) return;
-		//	Point upperleft = getMapXYPosition();
-		Point posOnScreen;
-		posOnScreen = getXYonScreen(TrackOverlays[4].topLeft.latDec, TrackOverlays[4].topLeft.lonDec);
-		Dimension ws = mmp.getSize(null);
-		int ww = ws.width;
-		int wh = ws.height;
-		//Vm.sleep(100); // this is necessary because the ewe vm ist not multi-threaded and the serial thread also needs time
-		int num, x, y;
-		for (int yi=0; yi<3; yi++) {
-			for (int xi=0; xi<3; xi++) {
-				num = yi*3+xi;
-				x = posOnScreen.x+(xi-1)*ww;
-				y = posOnScreen.y+(yi-1)*wh; 
-				TrackOverlays[num].setLocation(x, y);
-			}
-		}
-	}
-
-	public void updateOverlayPos() {
-		if (tracks == null || tracks.size() == 0) return;
-		if (TrackOverlays == null || TrackOverlays[4] == null) addMissingOverlays();
-		else {
-			updateOverlayOnlyPos();
-			if (TrackOverlays[0].locAlways.x > 0 || TrackOverlays[2].locAlways.x < 0
-					|| TrackOverlays[0].locAlways.y > 0 || TrackOverlays[8].locAlways.y < 0) { // testForNeedToRearange
-				rearangeOverlays();
-				addMissingOverlays();
-				// updateOverlayOnlyPos(); is called from addMissingOverlays 
-			}
-		}
-	}
-
-	/**
-	 * move posCircle to the Center of the Screen
-	 *
-	 */
-	public void resetCenterOfMap() {
-		if (width != 0) {
-			posCircleX = width /2;
-			posCircleY = height /2;
-		} else {
-			posCircleX = pref.myAppWidth/2; // maybe this could /should be repleced to windows size
-			posCircleY = pref.myAppHeight/2;
-		}
-		posCircle.hidden = false;
-		posCircle.move(posCircleX-posCircle.getWidth()/2, posCircleY-posCircle.getHeight()/2); // posCircle.setLocation caused a problem -> hiding the posCircle in some situation
-	}
-
-	public void movePosCircleToLatLon(CWPoint p, boolean repaint) {
-		moveScreenXYtoLatLon(new Point(posCircleX, posCircleY), p, repaint);
-	}
-
-	public void setCenterOfScreen (CWPoint c, boolean repaint) {
-		moveScreenXYtoLatLon(new Point (this.width/2, this.height/2), c, repaint);
-	}
-
-	public void moveScreenXYtoLatLon(Point s, CWPoint c, boolean repaint) {
-		Point mappos = getMapPositionOnScreen();
-		Point onscreenpos = getXYonScreen(c.latDec, c.lonDec);
-		if (mmp != null && mmp.mapImage != null) mmp.mapImage.move(mappos.x - onscreenpos.x + s.x, mappos.y - onscreenpos.y + s.y);
-		mapMoved(s.x - onscreenpos.x, s.y - onscreenpos.y);
-		if (repaint) mmp.repaintNow();
-	}
-
-	/** call this if the map moved on the screen (by dragging)
-	 * this routine will adjust (move accordingly) all other symbols on the screen
-	 * @param diffX
-	 * @param diffY
-	 */
-	public void mapMoved(int diffX, int diffY) {
-		int w = posCircle.getWidth();
-		int h = posCircle.getHeight();
-		int npx = posCircleX-w/2+diffX; 
-		int npy = posCircleY-h/2+diffY;
-		posCircle.move(npx, npy);
-		posCircleX = posCircleX+diffX;
-		posCircleY = posCircleY+diffY;
-		updateSymbolPositions();
-		updateOverlayPos();
-	}
-
-	/**
-	 * get upper left corner of map on window
-	 * this is called when the map needs to be moved / the position of the map is wanted
-	 * the map-position is calculated relativ to posCircle (x,y and lat/lon)
-	 * returns the same as mmp.mapImage.getLocation(mapPos);
-	 * but also works if mmp == null and is used to move the map to the correct point
-	 * @return
-	 */
-	public Point getMapPositionOnScreen() {
-		if (currentMap == null || posCircleLon < -360) return new Point(pref.myAppWidth +1, pref.myAppHeight +1); // in case no calculation is possible return somthing outside of the screen
-		Point mapPos = new Point(); 
-		//if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
-		//else {
-		Point mapposint = currentMap.calcMapXY(posCircleLat, posCircleLon);
-		mapPos.x = posCircleX - mapposint.x;
-		mapPos.y = posCircleY - mapposint.y;
-		//}
-		return mapPos;
-	}
-
-	/**
-	 * 
-	 * @param lat
-	 * @param lon
-	 * @return
-	 */
-	public Point getXYonScreen(double lat, double lon){
-		if (currentMap == null) return null;
-		Point coords = currentMap.calcMapXY(lat, lon);
-		Point mapPos = getMapPositionOnScreen();
-		//		Vm.debug("getXYinMap, posCiLat: "+posCircleLat+"poscLOn: "+ posCircleLon+"gotoLat: "+ lat + "gotoLon: "+ lon+" mapPosX: "+mapPos.x+"mapposY"+mapPos.y);
-		return new Point(coords.x + mapPos.x, coords.y + mapPos.y);
-	}
-
-	public CWPoint ScreenXY2LatLon (int x, int y){
-		Point mapPos = getMapPositionOnScreen();
-		return currentMap.calcLatLon(x - mapPos.x, y - mapPos.y);
-	}
-
-
-	public void updateSymbolPositions() {
-		if (symbols == null) return;
-		Point pOnScreen;
-		MapSymbol symb;
-		int ww = this.width;
-		int wh = this.height;
-		int w, h;
-		for (int i=symbols.size()-1; i>=0; i--) {
-			symb = (MapSymbol)symbols.get(i);
-			pOnScreen = getXYonScreen(symb.lat, symb.lon);
-			w=symb.getWidth();
-			h=symb.getHeight();
-			if (pOnScreen.x+w >= 0 && pOnScreen.x <= ww && pOnScreen.y+h >= 0 &&  pOnScreen.y <= wh) 
-			{
-				symb.properties &= ~mImage.IsInvisible;
-				symb.move(pOnScreen.x-w/2, pOnScreen.y-h/2);
-			}
-			else 
-			{symb.properties |= mImage.IsInvisible;
-			symb.move(30, 30);
-			}
-			//symb.pic.move(ww+1, wh+1);
-		}
-	}
-
-	public MapSymbol addSymbol(String name, String filename, double lat, double lon) {
-		if (symbols==null) symbols=new Vector();
-		MapSymbol ms = new MapSymbol(name, filename, lat, lon);
-		ms.loadImage();
-		ms.properties |= AniImage.AlwaysOnTop;
-		Point pOnScreen = getXYonScreen(lat, lon);
-		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
-		symbols.add(ms);
-		mmp.addImage(ms);
-		return ms;
-	}
-	
-	public void addSymbolIfNecessary(String name, Object mapObject, Image imSymb, double lat, double lon) {
-		if (findMapSymbol(name) >= 0) return;
-		else addSymbol(name, mapObject, imSymb, lat, lon);
-		
-	}
-		
-	public void addSymbol(String name, Object mapObject, Image imSymb, double lat, double lon) {
-		if (symbols==null) symbols=new Vector();
-		MapSymbol ms = new MapSymbol(name, mapObject, imSymb, lat, lon);
-		ms.properties = AniImage.AlwaysOnTop;
-		Point pOnScreen=getXYonScreen(lat, lon);
-		if (pOnScreen != null) ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
-		symbols.add(ms);
-		mmp.addImage(ms);
-	}
-
-	public void destChanged(CWPoint d) {
-		if(!running || (d == null && gotoPos == null) || 
-				(d != null && gotoPos != null && d.latDec == gotoPos.lat && d.lonDec == gotoPos.lon)) return;
-		removeGotoPosition();
-		if (d == null || !d.isValid() ) return;
-		gotoPos = addSymbol("goto", "goto_map.png", d.latDec, d.lonDec);
-		//updateDistance(); - this is called from updatePosition
-		forceMapLoad = true;
-		if (this.width != 0) updatePosition(posCircleLat, posCircleLon); // dirty hack: if this.width == 0, then the symbols are not on the screen and get hidden by updateSymbolPositions
-	}
-
-	public void removeGotoPosition() {
-		removeMapSymbol("goto");
-	}
-
-	public CWPoint getGotoPos(){
-		if (gotoPos == null) return null;
-		return new CWPoint(gotoPos.lat, gotoPos.lon);
-	}
-
-	public void removeAllMapSymbolsButGoto(){
-		if (symbols == null) return;
-		for (int i = symbols.size()-1; i >= 0; i--) {
-			mmp.removeImage((MapSymbol)symbols.get(i));
-		}
-		symbols.removeAllElements();
-		if (gotoPos != null) symbols.add(gotoPos);
-	}
-
-	public void removeMapSymbol(String name) {
-		int symbNr = findMapSymbol(name);
-		if (symbNr != -1) removeMapSymbol(symbNr);
-	}
-
-	public void removeMapSymbol(Object obj) {
-		int symbNr = findMapSymbol(obj);
-		if (symbNr != -1) removeMapSymbol(symbNr);
-	}
-
-
-	public void removeMapSymbol(int SymNr) {
-		mmp.removeImage(((MapSymbol)symbols.get(SymNr)));
-		symbols.removeElementAt(SymNr);
-	}
-
-	public int findMapSymbol(String name) {
-		if (symbols == null) return -1;
-		MapSymbol ms;
-		for (int i = symbols.size() -1; i >= 0 ; i--) {
-			ms= (MapSymbol)symbols.get(i);
-			if (ms.name == name) return i;
-		}
-		return -1;
-	}
-	
-	public int findMapSymbol(Object obj) {
-		if (symbols == null) return -1;
-		MapSymbol ms;
-		for (int i = symbols.size() -1; i >= 0 ; i--) {
-			ms= (MapSymbol)symbols.get(i);
-			if (ms.mapObject == obj) return i;
-		}
-		return -1;
-	}
-
-	/**
-	 * Move the map so that the posCircle is at lat/lon
-	 * 
-	 * @param  
-	 */
-	public void updateOnlyPosition(double lat, double lon, boolean updateOverlay){
-		//Point oldMapPos = getMapPositionOnScreen();
-		posCircleLat = lat;
-		posCircleLon = lon;
-		Point mapPos = getMapPositionOnScreen();
-		//Vm.debug("mapx = " + mapx);
-		//Vm.debug("mapy = " + mapy);
-		if (forceMapLoad || (java.lang.Math.abs(lastRepaintMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(lastRepaintMapPos.y - mapPos.y) > 1)) 
-		{
-			lastRepaintMapPos = mapPos;
-			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x, mapPos.y);
-			updateSymbolPositions();
-			updateDistance(false);
-			if (updateOverlay ) updateOverlayPos(); // && TrackOverlays != null
-			mmp.repaintNow(); 
-		}
-		else
-		{
-			updateDistance(true);
-		}
-		//Vm.debug("update only position");			
-	}
-	/**
-	 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
-	 */
-	public void updatePosition(double lat, double lon){
-		if (dontUpdatePos || loadingMapList) return; // avoid multi-threading problems
-		Vm.debug("updatepors, lat: "+lat+" lon: "+lon);
-		if (!mapsloaded) {
-			loadMaps(mapPath, lat);
-			lastCompareX = Integer.MAX_VALUE;
-			lastCompareY = Integer.MAX_VALUE;
-			autoSelectMap = true;
-			setBestMap(lat, lon, true);
-			forceMapLoad = false;
-			return;
-		}
-		updateOnlyPosition(lat, lon, true);
-		if (!autoSelectMap) return;
-		Point mapPos = getMapPositionOnScreen();
-		boolean screenNotCompletlyCovered =  mmp.mapImage == null || (mmp.mapImage != null && ( mapPos.y > 0 || mapPos.x > 0 || mapPos.y+mmp.mapImage.getHeight()<this.height	|| mapPos.x+mmp.mapImage.getWidth()<this.width));
-		if (forceMapLoad || wantMapTest|| screenNotCompletlyCovered) 	{ // if force || want || map doesn't cover the scree completly
-			//Vm.debug("Screen not completly covered by map");
-			if (forceMapLoad || (java.lang.Math.abs(lastCompareX-mapPos.x) > this.width/10 || java.lang.Math.abs(lastCompareY-mapPos.y) > this.height/10)) {
-				// more then 1/10 of screen moved since last time we tried to find a better map
-				lastCompareX = mapPos.x;
-				lastCompareY = mapPos.y;
-				setBestMap(lat, lon, screenNotCompletlyCovered);
-				forceMapLoad = false;
-			}
-		}
-	}
-
-	public void updateGps(int fix) {
-		if (!running || ignoreGps) return;
-		// runMovingMap neccessary in case of multi-threaded Java-VM: ticked could be called during load of mmp 
-		if ((fix > 0) && (myNavigation.gpsPos.getSats()>= 0)) { // TODO is getSats really necessary?
-			directionArrows.setDirections((float)myNavigation.gpsPos.getBearing(myNavigation.destination),
-					(float)myNavigation.skyOrientationDir.lonDec, (float)myNavigation.gpsPos.getBear());
-			setGpsStatus(MovingMap.gotFix);
-			updatePosition(myNavigation.gpsPos.latDec, myNavigation.gpsPos.lonDec);
-			ShowLastAddedPoint(myNavigation.curTrack);
-		}
-		if (fix == 0 && myNavigation.gpsPos.getSats()== 0) 	setGpsStatus(MovingMap.lostFix);
-		if (fix < 0 )	setGpsStatus(MovingMap.noGPSData);
-	}
-	
-	public void gpsStarted() {
-		addTrack(myNavigation.curTrack);
-		ignoreGps = false;
-	}
-	public void gpsStoped() {
-		setGpsStatus(MovingMap.noGPS);
-	}
-
-	int mapChangeModus;
-	float scaleWanted;
-	boolean wantMapTest = true; // if true updateposition calls setBestMap regulary even if the currentmap covers the whole screen
-	public final static int NORMAL_KEEP_RESOLUTION = 1; // keeps the choosen resolution as long as a map is available that overlaps with the screen and with the PosCircle - it changes the resolution if no such map is available. It wil cahnge back to the wanted scale as soon as a map becomes available (through movement of the GPS-receiver)
-	public final static int HIGHEST_RESOLUTION = 2;
-	public final static int HIGHEST_RESOLUTION_GPS_DEST = 3;
-	boolean inBestMap = false; // to avoid multi-threading problems
-
-	/**
-	 * loads the best map for lat/lon according to mapChangeModus
-	 * lat/lon will be at the screen-pos of posCircle
-	 * when posCircle is not on the screen (shifted outside my the user)
-	 * then this routine uses the center of the screen to find the best map
-	 * but anyway the map will be adjusted (moved) relativ to posCircle
-	 * when a better map was found the called method updateposition will set
-	 * posCirleLat/-Lon to lat/lon.
-	 * 
-	 * @param lat
-	 * @param lon
-	 * @param loadIfSameScale false: will not change the map if the better map has the same scale as the current - this is used not to change the map if it covers already the screen completely
-	 * true: willchange the map, regardless of change in scale
-	 */
-	public void setBestMap(double lat, double lon, boolean loadIfSameScale) {
-		if (inBestMap) return;
-		inBestMap = true;
-		Object [] s = getRectForMapChange(lat, lon);
-		CWPoint cll = (CWPoint) s[0]; 
-		Rect screen = (Rect) s[1]; 
-		MapInfoObject newmap = null;
-		//if (mapChangeModus == 0) mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
-		wantMapTest = true;
-		switch (mapChangeModus) {
-		case NORMAL_KEEP_RESOLUTION: 
-			newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, scaleWanted, false);
-			if (newmap == null) newmap = currentMap;
-			if (MapsList.scaleEquals(scaleWanted, newmap)) wantMapTest = false;
-			break;
-		case HIGHEST_RESOLUTION: newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 0.000001f, false); break;
-		case HIGHEST_RESOLUTION_GPS_DEST: 
-			if (gotoPos!= null && GpsStatus != noGPS && posCircleLat>= -90 && posCircleLat <= 90 && posCircleLon >= -360 && posCircleLon <= 360) {
-				newmap = maps.getMapForArea(new CWPoint(posCircleLat, posCircleLon), new CWPoint(gotoPos.lat, gotoPos.lon)); // TODO use home-coos if no gps? - consider start from details panel and from gotopanel
-				if (newmap == null) newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 10000000000000000000000000000000000f, false); // use map with most available overview if no map containing PosCircle and GotoPos is available
-			}
-			//	either Goto-Pos or GPS-Pos not set
-			else newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 0.000001f, false); 
-			break;
-		default: (new MessageBox("Error", "Programmfehler: \nillegal mapChangeModus: " + mapChangeModus, MessageBox.OKB)).execute(); break;
-		}
-		if ( newmap != null && (currentMap == null || !currentMap.mapName.equals(newmap.mapName)) ) {
-			if (loadIfSameScale || !MapsList.scaleEquals(currentMap.scale / currentMap.zoomFactor, newmap) ) {
-				Vm.debug("better map found");
-				setMap(newmap, lat, lon);
-				moveScreenXYtoLatLon(new Point(screen.x, screen.y), cll, true);
-			}
-			inBestMap = false;
-			return;
-		}
-		if (currentMap == null && newmap == null) {
-			(new MessageBox("Information", "F?r die aktuelle Position steht keine Karte zur Verf?ng, bitte w?hlen Sie eine manuell", MessageBox.OKB)).execute();
-			posCircleLat = cll.latDec;
-			posCircleLon = cll.lonDec; // choosemap calls setmap with posCircle-coos
-			while (currentMap == null) {
-				mmp.chooseMap(); // force the user to select a scale // TODO empty maps on top?
-				if (currentMap == null) (new MessageBox("Error", "Moving map cannot run without a map - please select one. \n You can select an empty map", MessageBox.OKB)).execute();
-			}
-		}
-		inBestMap = false;
-	}
-
-	public void setResModus (int modus) {
-		scaleWanted = currentMap.scale;
-		if (mapChangeModus == modus) return;
-		mapChangeModus = modus;
-		if (modus != NORMAL_KEEP_RESOLUTION) setBestMap(posCircleLat, posCircleLon, true);
-	}
-	/**
-	 * method to get a point on the screen which must be included in the map
-	 * the map methods are looking for. If the poscircle is on the screen this will be 
-	 * that point. If it is outside then the center of the screen will be used.
-	 * 
-	 * returns [0] = CWPoint of that point, [1] Rect describing the screen around it 
-	 * @param lat
-	 * @param lon
-	 * @return
-	 */
-	public Object[] getRectForMapChange(double lat, double lon) {
-		int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
-		int h = (height != 0 ? height : pref.myAppHeight);
-		int x, y;
-		CWPoint cll;
-		if (posCircleX >= 0 && posCircleX <= w && posCircleY >= 0 && posCircleY <= h) {
-			x = posCircleX; // posCircle is inside the screen
-			y = posCircleY; // TODO eigentlich interessiert, ob nach dem evtl. Kartenwechsel PosCircle on Screen ist. So wie es jetzt ist, kann 2mal der gleiche Aufruf zum laden unterschiedlicher Karten f?hren, wenn voher PosCircle nicht auf dem SChirm war, nach dem ersten Laden aber schon.
-			cll = new CWPoint(lat, lon);
-		} else { // when posCircle out of screen - use center of screen as point which as to be included in the map
-			cll = ScreenXY2LatLon(w/2, h/2);
-			x = w/2;
-			y = h/2;
-		} 
-		Object[] ret = new Object[2];
-		ret[0] = cll;
-		ret[1] = new Rect(x, y, w, h);
-		return ret; 
-	}
-
-	/**
-	 * 
-	 * @param betterOverview true: getmap with better overview
-	 * @return
-	 */
-	public void loadMoreDetailedMap(boolean betterOverview){
-		Object [] s = getRectForMapChange(posCircleLat, posCircleLon);
-		CWPoint cll = (CWPoint) s[0]; 
-		Rect screen = (Rect) s[1]; 
-		//Rect screen = new Rect(posCircleX, posCircleY, (width != 0 ? width : pref.myAppWidth), (height != 0 ? height : pref.myAppHeight));
-		MapInfoObject m = maps.getMapChangeResolution(cll.latDec, cll.lonDec, screen, currentMap.scale / currentMap.zoomFactor, !betterOverview);
-		if (m != null) {
-			boolean saveGpsIgnStatus = dontUpdatePos;
-			dontUpdatePos = true;
-			setMap(m, posCircleLat, posCircleLon);
-			setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
-			dontUpdatePos = saveGpsIgnStatus;
-		}
-		else (new MessageBox("Error", "No "+ (betterOverview ? "less" : "more") + " deteiled map available", MessageBox.OKB)).execute();
-	}
-
-	public void loadMapForAllCaches(){
-		Area sur = Global.getProfile().getSourroundingArea(true);
-		if (sur == null) {
-			(new MessageBox("Error", "Keine  Caches mit H?ckchen ausgew?hlt", MessageBox.OKB)).execute();
-			return;
-		}
-		MapInfoObject newmap = maps.getMapForArea(sur.topleft, sur.buttomright);
-		if (newmap == null ) { // no map that includs all caches is available -> load map with lowest resolution
-			Object [] s = getRectForMapChange(posCircleLat, posCircleLon);
-			CWPoint cll = (CWPoint) s[0]; 
-			Rect screen = (Rect) s[1]; 
-			newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, Float.MAX_VALUE -1, false);
-		}
-		boolean saveGpsIgnStatus = dontUpdatePos;
-		dontUpdatePos = true;
-		setMap(newmap, posCircleLat, posCircleLon);
-		setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
-		dontUpdatePos = saveGpsIgnStatus;
-	}
-
-	public void setGpsStatus (int status) {
-		if (status == GpsStatus) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
-		GpsStatus = status;
-		dontUpdatePos = false;
-		ignoreGps = false;
-		switch (status) {
-		case noGPS: 	{ posCircle.change(null); ignoreGps = true; break; }
-		case gotFix:    { posCircle.change(statusImageHaveSignal); break; }
-		case lostFix:   { posCircle.change(statusImageNoSignal); break; }
-		case noGPSData: { posCircle.change(statusImageNoGps); break; }
-		}
-		posCircle.refreshNow();
-	}
-
-	public void SnapToGps() {
-		resetCenterOfMap();
-		dontUpdatePos = false;
-		ignoreGps = false;
-		lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
-		lastCompareY = Integer.MAX_VALUE;
-		autoSelectMap = true;
-		forceMapLoad = true;
-		showMap();
-		if (myNavigation.gpsPos.Fix <=0) updatePosition(posCircleLat, posCircleLon);
-		else updateGps(myNavigation.gpsPos.getFix());
-	}
-
-	/** sets and displays the map
-	 * 
-	 * @param newmap
-	 * @param lat move map so that lat/lon is in the center / -361: don't adust to lat/lon
-	 * @param lon -361: don't adust to lat/lon
-	 */
-	public void setMap(MapInfoObject newmap, double lat, double lon) {
-		if (currentMap != null && newmap.mapName.equals(currentMap.mapName) && !forceMapLoad) { // note: newmap.mapName == currentMap.mapName won't work because they are different String containing the same text 
-			updateOnlyPosition(lat, lon, true); 
-			return;
-		}
-		Vm.showWait(true);
-		boolean saveIgnoreStatus;
-		saveIgnoreStatus = dontUpdatePos;
-		dontUpdatePos = true;  // make updatePosition ignore calls during loading new map
-		InfoBox inf;
-		inf = new InfoBox("Info", "Loading map...");
-		inf.show();
-		inf.waitUntilPainted(100);
-		try {
-			this.currentMap = newmap; 
-			this.title = currentMap.mapName;
-			lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
-			lastCompareY = Integer.MAX_VALUE;
-			if (mmp.mapImage != null ) {
-				//Vm.debug("free: "+Vm.getUsedMemory(false)+"classMemory: "+Vm.getClassMemory()+ "after garbage collection: "+Vm.getUsedMemory(false));
-				mmp.removeImage(mmp.mapImage); mmp.mapImage.free(); mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
-
-				//Vm.debug("free: "+Vm.getUsedMemory(false)+"classMemory: "+Vm.getClassMemory()+ "after garbage collection: "+Vm.getUsedMemory(false));
-				Vm.getUsedMemory(true); // calls the garbage collection
-			} // give memory free before loading the new map to avoid out of memory error
-			String ImageFilename = currentMap.getImageFilename(); 
-			if (ImageFilename == null ) {
-				mmp.mapImage = new MapImage();
-				(new MessageBox("Error", "Could not find image associated with: \n"+currentMap.fileNameWFL, MessageBox.OKB)).execute();
-			}
-			else { 
-				if (ImageFilename.length() > 0) mmp.mapImage = new MapImage(ImageFilename); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
-				else mmp.mapImage = new MapImage();
-			}
-			mapImage1to1 = mmp.mapImage;
-			mmp.mapImage.properties = mmp.mapImage.properties | AniImage.IsMoveable;
-			if (mapHidden) mmp.mapImage.hide();
-			mmp.mapImage.move(0,0);
-			mmp.addImage(mmp.mapImage);
-			mmp.images.moveToBack(mmp.mapImage);
-			addOverlaySet();
-			forceMapLoad = true; // forces updateOnlyPosition to redraw
-			updateOnlyPosition(lat, lon, false);
-			forceMapLoad = false;
-			directionArrows.setMap(currentMap);
-			updateScale();
-			inf.close(0);  // this doesn't work in a ticked-thread in the ewe-vm. That's why i made a new mThread in gotoPanel for ticked
-			Vm.showWait(false);
-			dontUpdatePos = saveIgnoreStatus;
-		} catch (IllegalArgumentException e) { // thrown by new AniImage() in ewe-vm if file not found;
-			if (mmp.mapImage != null) {
-				mmp.removeImage(mmp.mapImage); 
-				mmp.mapImage.free();
-				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
-			}
-			addOverlaySet();
-			updateOnlyPosition(lat, lon, false);
-			inf.close(0);
-			Vm.showWait(false);
-			(new MessageBox("Error", "Could not load map: "+ newmap.getImageFilename(), MessageBox.OKB)).execute();
-			dontUpdatePos = saveIgnoreStatus;
-		} catch (OutOfMemoryError e) {
-			if (mmp.mapImage != null) {
-				mmp.removeImage(mmp.mapImage); 
-				mmp.mapImage.free();
-				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
-			}
-			addOverlaySet();
-			updateOnlyPosition(lat, lon, false);
-			inf.close(0);
-			Vm.showWait(false);
-			(new MessageBox("Error", "Not enough memory to load map: "+ newmap.getImageFilename()+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
-			dontUpdatePos = saveIgnoreStatus;
-		}catch (SystemResourceException e) {
-			if (mmp.mapImage != null) {
-				mmp.removeImage(mmp.mapImage); 
-				mmp.mapImage.free();
-				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
-			}
-			addOverlaySet();
-			updateOnlyPosition(lat, lon, false);
-			inf.close(0);
-			Vm.showWait(false);
-			(new MessageBox("Error", "Not enough ressources to load map: "+ newmap.getImageFilename()+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
-			dontUpdatePos = saveIgnoreStatus;
-		}
-	}
-
-	public void hideMap() {
-		if (mmp != null && mmp.mapImage != null)
-			mmp.mapImage.hide();
-		mapHidden = true;
-		repaintNow();
-	}
-
-	public void showMap() {
-		if (mmp != null && mmp.mapImage != null) mmp.mapImage.unhide();
-		mapHidden = false;
-		repaintNow();
-	}
-
-	public void setZoomingMode() {
-		mmp.removeImage(buttonImageLens);
-		mmp.addImage(buttonImageLensActivated);
-		repaintNow();
-		zoomingMode = true;
-	}
-
-	/**
-	 * zommes in if w>0 and out if w<0
-	 * @param firstclickpoint
-	 * @param w
-	 * @param h
-	 */
-	public void zoomScreenRect(Point firstclickpoint, int w, int h) {
-		int newImageWidth = (int) (this.width *  (this.width  < 481 ? 2 : 1.6)); // (maximal) size of the zoomed image 
-		int newImageHeight= (int) (this.height * (this.width < 481 ?  2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors 
-		CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y + h/2);
-		float zoomFactor;
-		if (w > 0)  zoomFactor = (float)this.width / (float)w; // zoom in
-		else {
-			w = java.lang.Math.abs(w);
-			firstclickpoint.x = firstclickpoint.x - w; // make firstclickedpoint the upper left corner
-			zoomFactor = (float)w / (float)this.width;
-		}
-		if (h < 0) {
-			h = java.lang.Math.abs(h);
-			firstclickpoint.y = firstclickpoint.y - h;
-		}
-		// calculate rect in unzoomed image in a way that the center of the new image is the center of selected area but give priority to the prefered image size of the scaled image
-		newImageHeight = (int) (newImageHeight / zoomFactor / currentMap.zoomFactor);
-		newImageWidth = (int) (newImageWidth / zoomFactor / currentMap.zoomFactor);
-		Point mappos = getMapPositionOnScreen();
-		int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w/2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth /2);
-		int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h/2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight /2);
-		Rect newImageRect = new Rect(xinunscaledimage , yinunscaledimage, newImageWidth, newImageHeight);
-		if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
-		{
-			// try to avoid overlapping by shifting
-			if (newImageRect.x < 0) 
-				newImageRect.x = 0; // align left if left overlapping
-			if (newImageRect.y < 0) 
-				newImageRect.y = 0;
-			if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) 
-				newImageRect.x = mapImage1to1.getWidth()- newImageWidth; // align right if right overlaping
-			if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight()) 
-				newImageRect.y = mapImage1to1.getHeight()- newImageHeight;
-			// crop if after shifting still overlapping
-			if (newImageRect.x < 0) 
-				newImageRect.x = 0;
-			if (newImageRect.y < 0) 
-				newImageRect.y = 0;
-			if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) 
-				newImageRect.width = mapImage1to1.getWidth() - newImageRect.x;
-			if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight()) 
-				newImageRect.height= mapImage1to1.getHeight()- newImageRect.y;
-		}
-		zoomFromUnscaled(zoomFactor * currentMap.zoomFactor, newImageRect, center);
-	}
-
-	public void zoom1to1() {
-		CWPoint center = ScreenXY2LatLon(this.width /2 , this.height/2);
-		if (mapImage1to1 != null) zoomFromUnscaled(1, new Rect(0,0,mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
-		else zoomFromUnscaled(1, new Rect(0,0, 1,1), center);
-	}
-
-	/**
-	 * do the actual scaling
-	 * @param zoomFactor relative to original image
-	 * @param newImageRect Rect in the 1:1 image that contains the area to be zoomed into
-	 * @param center
-	 */		
-	public void zoomFromUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
-		Vm.showWait(this, true);
-		boolean savegpsstatus = dontUpdatePos;
-		if (mapImage1to1 != null) {
-			dontUpdatePos = true; // avoid multi-thread problems
-			int saveprop = AniImage.IsMoveable;
-			MapImage tmp = null; // = mmp.mapImage;
-			if (mmp.mapImage != null) {
-				tmp = mmp.mapImage;
-				saveprop = mmp.mapImage.properties;
-				mmp.removeImage(mmp.mapImage);
-				if (mmp.mapImage != mapImage1to1) {
-					mmp.mapImage.free();
-					mmp.mapImage = null;
-				} else tmp = mapImage1to1;
-			}
-			Vm.getUsedMemory(true);
-			try {
-				if (zoomFactor == 1) tmp = mapImage1to1;
-				else tmp = new MapImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor), (int)(newImageRect.height*zoomFactor), newImageRect, 0));
-				currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
-			} catch (OutOfMemoryError e) {
-				(new MessageBox("Error", "Out of memory error", MessageBox.OKB)).execute();
-				//tmp = mapImage1to1;
-			} //if (tmp != null) currentMap.zoom();}
-			Vm.getUsedMemory(true);
-			mmp.mapImage = tmp; // use unscaled or no image in case of OutOfMemoryError
-			mmp.mapImage.properties = saveprop;
-			if (mapHidden) mmp.mapImage.hide();
-			mmp.addImage(mmp.mapImage);
-			mmp.images.moveToBack(mmp.mapImage);
-			if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
-			{
-				Point mappos = getMapPositionOnScreen();
-				mmp.mapImage.move(mappos.x,mappos.y);
-			}
-		} else // no map image loaded 
-		{ currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y); }
-		// scaleWanted = currentMap.scale; use this if you want to change automatically to a map scale that best fits the zooming
-		destroyOverlaySet();
-		Vm.getUsedMemory(true); // call garbage collection
-		setCenterOfScreen(center, false);
-		addOverlaySet();
-		updateScale();
-		this.repaintNow();
-		Vm.showWait(this, false);
-		dontUpdatePos = savegpsstatus;
-	}
-
-	/*	public void gotFocus(int how) {
-		super.gotFocus(how);
-		Dimension ws = getSize(null);
-		onWindowResize(ws.width, ws.height);
-		Vm.debug(ws.width + " h: "+ws.height);
-		this.setPreferredSize(width, height)
-	}
-	 */
-	public void onEvent(Event ev){
-		if(ev instanceof FormEvent && (ev.type == FormEvent.CLOSED )){
-			running = false;
-		}  
-		if(ev instanceof KeyEvent && ev.target == this && ((KeyEvent)ev).key == IKeys.ESCAPE) {
-			this.close(0);
-			ev.consumed = true;
-		}
-		super.onEvent(ev);
-	}
-}
-
-/**
- *	Class to display the map bitmap and to select another bitmap to display.
- */
-class MovingMapPanel extends InteractivePanel implements EventListener {
-	Menu kontextMenu;
-	MenuItem gotoMenuItem = new MenuItem("Goto here$g", 0, null);
-	MenuItem newWayPointMenuItem = new MenuItem("Create new Waypoint here$n", 0, null);;
-	MenuItem openCacheDescMenuItem,addCachetoListMenuItem;
-	
-	MenuItem miLuminary[];
-
-	Menu mapsMenu;
-	MenuItem selectMapMI = new MenuItem("Select a map manually$s", 0, null);
-	MenuItem changeMapDirMI = new MenuItem("Change map directory$c", 0, null);
-	MenuItem showMapMI = new MenuItem("Show map", 0, null);
-	MenuItem hideMapMI = new MenuItem("Hide map", 0, null);
-	// automatic
-	MenuItem mapChangeModusMI = new MenuItem("Modus for automatic map change", MenuItem.Separator, null);;
-	MenuItem highestResGpsDestMI = new MenuItem("Highest res. containing dest. & cur. position", 0, null); //immer h?chste Aufl?sung w?hlen, die akt. Pos. und Ziel enthalten 
-	MenuItem highestResolutionMI = new MenuItem("Highest resolution", 0, null); //immer h?chste Aufl?sung w?hlen 
-	MenuItem keepManResolutionMI = new MenuItem("Keep manual resolution", 0, null); // manuell gew?hlte Aufl?sung beibehalten  
-	// manuell
-	MenuItem mapChangeResMI = new MenuItem("Change resolution manually", MenuItem.Separator, null);;
-	MenuItem AllCachesResMI = new MenuItem("Load a map containing all marked caches", 0, null); // Karte w?hlen, die alle markierten Caches enth?lt  
-	MenuItem moreDetailsMI = new MenuItem("Load a map with more details", 0, null); // detailreichere Karte laden 
-	MenuItem moreOverviewMI = new MenuItem("Load a map for a better overview", 0, null); // Karte mit mehr ?bersicht w?hlen  
-	// move map to
-	MenuItem moveToMI = new MenuItem("Move map to an load map", MenuItem.Separator, null);;
-	MenuItem moveToDestMI = new MenuItem("move to goto point", 0, null); //* Karte zum Ziel verschieben (und ggf. entsprechende Karte laden) 
-	MenuItem moveToGpsMI = new MenuItem("move to GPS position", 0, null);   
-	MenuItem moveToCenterMI = new MenuItem("move to Center", 0, null);   
-
-	CacheHolder clickedCache;
-	MovingMap mm;
-	MapImage mapImage;
-	Point saveMapLoc = null;
-	boolean saveGpsIgnoreStatus;
-	boolean paintingZoomArea;
-	ImageList saveImageList = null;
-	int lastZoomWidth , lastZoomHeight;
-	public MovingMapPanel(MovingMap f){
-		this.mm = f;
-		set(Control.WantHoldDown, true); // want to get simulated right-clicks
-	}
-
-	public boolean imageBeginDragged(AniImage which,Point pos) {
-		if (mm.zoomingMode == true) { // zoom
-//			saveMapLoc = pos;
-			//		saveGpsIgnoreStatus = mm.ignoreGps;
-			//	mm.ignoreGps = true;
-			return false;
-		}
-		// move (drag) map
-		//if (!(which == null || which == mapImage || which instanceof TrackOverlay || which == mm.directionArrows) ) return false;
-		saveGpsIgnoreStatus = mm.dontUpdatePos; 
-		mm.dontUpdatePos = true;
-		saveMapLoc = pos;
-		bringMapToTop();
-		if (mapImage.isOnScreen() && !mapImage.hidden ) return super.imageBeginDragged(mapImage, pos);
-		else return super.imageBeginDragged(null, pos);
-	}
-
-	public boolean imageNotDragged(ImageDragContext dc,Point pos){
-		boolean ret = super.imageNotDragged(dc, pos);
-		bringMaptoBack();
-		if (dc.image == null) moveMap(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
-		else mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
-		mm.dontUpdatePos = saveGpsIgnoreStatus;
-		this.repaintNow();
-		return ret;
-	}
-
-	public void onPenEvent(PenEvent ev) {
-		if (!mm.zoomingMode && ev.type == PenEvent.PEN_DOWN) {
-			saveMapLoc = new Point (ev.x, ev.y);
-		}
-		if (mm.zoomingMode && ev.type == PenEvent.PEN_DOWN) {
-			saveGpsIgnoreStatus = mm.dontUpdatePos;
-			mm.dontUpdatePos = true;
-			saveMapLoc = new Point (ev.x, ev.y);
-			paintingZoomArea = true;
-			mm.zoomingMode = true;
-		} 
-		if (!mm.zoomingMode && ev.type == PenEvent.PEN_DOWN && ev.modifiers == PenEvent.RIGHT_BUTTON) {
-			penHeld(new Point (ev.x, ev.y));
-		}
-		if (mm.zoomingMode && ev.type == PenEvent.PEN_UP ) {
-			paintingZoomArea = false;
-			mm.zoomingMode = false;
-			mm.dontUpdatePos = saveGpsIgnoreStatus;
-			removeImage(mm.buttonImageLensActivated);
-			addImage(mm.buttonImageLens);
-			if (java.lang.Math.abs(lastZoomWidth) < 15 || java.lang.Math.abs(lastZoomHeight) < 15)  {
-				repaintNow();
-				return; // dont make to big zoom jumps - it is most probable not an intentional zoom
-			}
-			mm.zoomScreenRect(saveMapLoc, lastZoomWidth, lastZoomHeight);
-		}
-
-		if (mm.zoomingMode && paintingZoomArea && (ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {
-			int left, top;
-			Graphics dr = this.getGraphics();
-			if (lastZoomWidth < 0)left = saveMapLoc.x + lastZoomWidth;
-			else left = saveMapLoc.x;
-			if (lastZoomHeight < 0)top = saveMapLoc.y + lastZoomHeight;
-			else top = saveMapLoc.y;
-			left -= 2;
-			top -= 2;
-			if (top < 0) top = 0;
-			if (left < 0) left = 0;
-			this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth)+4, java.lang.Math.abs(lastZoomHeight)+4));
-			lastZoomWidth = ev.x - saveMapLoc.x;
-			lastZoomHeight =  ev.y - saveMapLoc.y;
-			if (lastZoomWidth < 0) left = saveMapLoc.x + lastZoomWidth;
-			else left = saveMapLoc.x;
-			if (lastZoomHeight < 0)top = saveMapLoc.y + lastZoomHeight;
-			else top = saveMapLoc.y;
-			dr.setPen(new Pen(new Color(255,0,0),Pen.SOLID,3));
-			dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight), 0); // bug in ewe: thickness parameter is ignored
-		}
-		super.onPenEvent(ev);
-	}
-
-	private void bringMapToTop() {
-		if (mapImage == null || mapImage.hidden) {
-			saveImageList = null;
-			return;
-		}
-		saveImageList = new ImageList();
-		saveImageList.copyFrom(images);
-		images.removeAllElements();
-		images.add(mapImage);
-	}
-	private void bringMaptoBack() {
-		if (saveImageList == null) return;
-		images = saveImageList;
-		saveImageList = null;
-	}
-
-	public void moveMap(int diffX, int diffY) {
-		Point p = new Point();
-		if (mapImage!= null) {
-			p = mapImage.locAlways;
-			mapImage.move(p.x+diffX,p.y+diffY);
-			//		if (mm.mapHidden) mapImage.properties |= AniImage.IsInvisible; // this is neccesarry because move will unhide the map if the coos show that the map is on the screen
-		}
-		mapMoved(diffX, diffY);
-	}
-
-	public void mapMoved(int diffX, int diffY){
-		mm.mapMoved(diffX, diffY);
-		this.repaintNow();
-	}
-
-	public void doPaint(Graphics g,Rect area) {
-		super.doPaint(g, area);
-		if (mm.gotoPos != null) {
-			Point dest = mm.getXYonScreen(mm.gotoPos.lat, mm.gotoPos.lon);
-			g.setPen(new Pen(Color.DarkBlue, Pen.SOLID, 3));
-			g.drawLine(mm.posCircleX, mm.posCircleY, dest.x, dest.y);
-		}
-	}
-
-	public void chooseMap() {
-		CWPoint gpspos;
-		if (mm.myNavigation.gpsPos.Fix > 0) gpspos = new CWPoint(mm.myNavigation.gpsPos.latDec, mm.myNavigation.gpsPos.lonDec);
-		else gpspos = null;
-		ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos(), mm.currentMap);
-		if(l.execute() == FormBase.IDOK){
-//			Vm.debug("Trying map: " + l.selectedMap.fileName);
-			mm.autoSelectMap = false;
-			if (l.selectedMap.inBound(mm.posCircleLat, mm.posCircleLon) || l.selectedMap.getImageFilename().length()==0) {
-				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon);
-				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
-				mm.ignoreGps = false;
-			} else {
-				mm.setGpsStatus(MovingMap.noGPS);
-				mm.ignoreGps = true;
-				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon); 
-				if (mm.currentMap.fileNameWFL.length() > 0)
-					mm.setCenterOfScreen(l.selectedMap.center, true); // if map has an image
-				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
-				//Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
-				//double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4]; 
-				//mm.posCircleX = 0; // place map to the upper left corner of windows
-				//mm.posCircleY = 0;
-				//mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
-			}
-		}
-	}
-
-	/**
-	 *	Method to react to user.
-	 */
-	public void imageClicked(AniImage which, Point pos){
-		if (which == mm.bottonImageChooseMap){
-			mapsMenu = new Menu();
-			mapsMenu.addItem(selectMapMI);
-			mapsMenu.addItem(changeMapDirMI);
-			if (!mm.noMapsAvailable) 
-			{
-				if (mm.mapHidden) mapsMenu.addItem(showMapMI);
-				else mapsMenu.addItem(hideMapMI);
-			}
-
-			// automatic
-			highestResGpsDestMI.modifiers &= ~MenuItem.Checked;
-			highestResolutionMI.modifiers &= ~MenuItem.Checked;
-			keepManResolutionMI.modifiers &= ~MenuItem.Checked;
-			switch (mm.mapChangeModus) {
-			case MovingMap.NORMAL_KEEP_RESOLUTION: keepManResolutionMI.modifiers |= MenuItem.Checked; break;   
-			case MovingMap.HIGHEST_RESOLUTION: highestResolutionMI.modifiers |= MenuItem.Checked; break;   
-			case MovingMap.HIGHEST_RESOLUTION_GPS_DEST: highestResGpsDestMI.modifiers |= MenuItem.Checked; break;   
-			}
-			mapsMenu.addItem(mapChangeModusMI);
-			mapsMenu.addItem(highestResGpsDestMI);
-			mapsMenu.addItem(highestResolutionMI);
-			mapsMenu.addItem(keepManResolutionMI);
-			// manuell
-			mapsMenu.addItem(mapChangeResMI);
-			mapsMenu.addItem(AllCachesResMI);
-			mapsMenu.addItem(moreDetailsMI);
-			mapsMenu.addItem(moreOverviewMI);
-			// move map to
-			mapsMenu.addItem(moveToMI);
-			if (mm.gotoPos != null) moveToDestMI.modifiers &= ~MenuItem.Disabled;
-			else moveToDestMI.modifiers |= MenuItem.Disabled;
-			mapsMenu.addItem(moveToDestMI);
-			if (Global.getPref().curCentrePt.isValid()) moveToCenterMI.modifiers &= ~MenuItem.Disabled;
-			else moveToCenterMI.modifiers |= MenuItem.Disabled;
-			mapsMenu.addItem(moveToCenterMI);
-			mapsMenu.addItem(moveToGpsMI);
-
-			//m.set(Menu., status)
-			mapsMenu.exec(this, new Point(which.location.x, which.location.y), this);
-		}
-		if (which == mm.buttonImageGpsOn) {
-			this.snapToGps();
-		}
-		if (which == mm.buttonImageLens) {
-			mm.setZoomingMode();
-			lastZoomWidth = 0;
-			lastZoomHeight = 0;
-		}
-		if (which == mm.buttonImageZoom1to1) {
-			mm.zoom1to1(); 
-		}
-		if (which == mm.bottonImageClose) {
-			WindowEvent tmp = new WindowEvent();
-			tmp.type = WindowEvent.CLOSE;
-			mm.postEvent(tmp);
-		}
-	}
-
-	public void snapToGps() {
-		mm.myNavigation.startGps();
-		mm.SnapToGps();
-	}
-
-	public void penHeld(Point p){
-		//	if (!menuIsActive()) doMenu(p);
-		if (!mm.zoomingMode) { 
-			//( (ev.type == PenEvent.PEN_DOWN) && ((PenEvent)ev).modifiers == PenEvent.RIGHT_BUTTON)
-			//|| ((ev.type == PenEvent.RIGHT_BUTTON) ) )) ---> these events are not posted --> this overridering is the only solution 
-			kontextMenu = new Menu();
-			if ( !(mm.directionArrows.onHotArea(p.x, p.y)) ) {
-				kontextMenu.addItem(gotoMenuItem);
-				kontextMenu.addItem(newWayPointMenuItem);
-				AniImage clickedOnImage = images.findHotImage(p);
-				if (clickedOnImage != null && clickedOnImage instanceof MapSymbol) {
-					clickedCache = ((CacheHolder)((MapSymbol)clickedOnImage).mapObject);
-					if (clickedCache != null) openCacheDescMenuItem = new MenuItem("Open '"+(clickedCache.CacheName.length()>0?clickedCache.CacheName:clickedCache.wayPoint)+"'$o"); // clickedCache == null can happen if clicked on the goto-symbol
-					kontextMenu.addItem(openCacheDescMenuItem);
-					if (clickedCache !=null && Global.mainForm.cacheListVisible) { 
-						addCachetoListMenuItem = new MenuItem(MyLocale.getMsg(199,"Add to cachetour"));
-						kontextMenu.addItem(addCachetoListMenuItem);
-					}
-				}
-			}
-			else {			
-				miLuminary = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
-
-				for (int i=0; i<SkyOrientation.LUMINARY_NAMES.length; i++) {
-					kontextMenu.addItem(miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i)));
-					if (i == mm.myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
-					else miLuminary[i].modifiers &= MenuItem.Checked;
-				}
-			}
-			kontextMenu.exec(this, new Point(p.x, p.y), this);
-		}
-	}
-
-	public void onEvent(Event ev){
-		if (mapsMenu != null && ev instanceof PenEvent && ev.type == PenEvent.PEN_DOWN && ev.target == this) {mapsMenu.close(); mapsMenu = null;}
-		if (kontextMenu != null && ev instanceof PenEvent && ev.type == PenEvent.PEN_DOWN && ev.target == this) {kontextMenu.close(); kontextMenu = null; }
-
-		if (ev instanceof MenuEvent) { 
-			if (ev.target == mapsMenu) {
-				if (ev.type == MenuEvent.ABORTED || ev.type == MenuEvent.CANCELLED || ev.type == MenuEvent.FOCUS_OUT) mapsMenu.close(); // TODO menuIsActive() benutzen? 
-				if (ev.type == MenuEvent.SELECTED ) {
-					MenuItem action = (MenuItem) mapsMenu.getSelectedItem(); 
-					if (mapsMenu.getSelectedItem() != null) {
-						//maps
-						if (action == selectMapMI)	{ 
-							mapsMenu.close();
-							chooseMap();
-						}
-						if (action == changeMapDirMI)	{
-							mapsMenu.close();
-							FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir+"maps");
-							fc.addMask("*.wfl");
-							fc.setTitle((String)MyLocale.getMsg(4200,"Select map directory:"));
-							if(fc.execute() != FileChooser.IDCANCEL){
-								mm.loadMaps(fc.getChosen().toString(), mm.posCircleLat);
-								mm.forceMapLoad();
-							}
-						}
-						//dont show map
-						if (action == hideMapMI) {
-							mapsMenu.close();
-							mm.hideMap();
-						}
-						// show map
-						if (action == showMapMI) {
-							mapsMenu.close();
-							mm.showMap();
-						}
-						// map change modus
-						if (action == highestResGpsDestMI) {
-							mapsMenu.close();
-							mm.setResModus(MovingMap.HIGHEST_RESOLUTION_GPS_DEST);
-						}
-						if (action == highestResolutionMI) {
-							mapsMenu.close();
-							mm.setResModus(MovingMap.HIGHEST_RESOLUTION);
-						}
-						if (action == keepManResolutionMI) {
-							mapsMenu.close();
-							mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
-						}
-						// manually change map resolution
-						if (action == moreDetailsMI) {
-							mapsMenu.close();
-							mm.loadMoreDetailedMap(false);
-						} 
-						if (action == moreOverviewMI) {
-							mapsMenu.close();
-							mm.loadMoreDetailedMap(true);
-						}
-						if (action == AllCachesResMI) {
-							mapsMenu.close();
-							mm.loadMapForAllCaches();
-						}
-						// moveto position
-						if (action == moveToCenterMI) {
-							mapsMenu.close();
-							mm.setCenterOfScreen(Global.getPref().curCentrePt, true);
-						}
-						if (action == moveToDestMI) {
-							mapsMenu.close();
-							mm.setCenterOfScreen(new CWPoint(mm.gotoPos.lat, mm.gotoPos.lon), true);
-						}
-						if (action == moveToGpsMI) {
-							mapsMenu.close();
-							this.snapToGps();						
-						}
-
-					}
-				}
-			} // if (ev.target == mapsMenu)
-			if (ev.target == kontextMenu) {
-				if ((((MenuEvent)ev).type==MenuEvent.SELECTED)) {
-					MenuItem action = (MenuItem) kontextMenu.getSelectedItem(); 
-					if (action == gotoMenuItem) {
-						kontextMenu.close();
-						mm.myNavigation.setDestination(mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y));	
-					}
-					if (action == openCacheDescMenuItem) {
-						//mm.onEvent(new FormEvent(FormEvent.CLOSED, mm));
-						kontextMenu.close();
-						WindowEvent close = new WindowEvent();
-						close.target = mm;
-						close.type = WindowEvent.CLOSE;
-						mm.postEvent(close);
-						MainTab mainT = Global.mainTab;
-						mainT.openDesciptionPanel(clickedCache);
-					}
-					if (action == newWayPointMenuItem) {
-						kontextMenu.close();
-						WindowEvent close = new WindowEvent();
-						close.target = mm; 
-						close.type = WindowEvent.CLOSE;
-						mm.postEvent(close);
-						CacheHolder newWP = new CacheHolder();
-						newWP.pos = mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y);
-						newWP.LatLon=newWP.pos.toString(); 
-						Global.mainTab.newWaypoint(newWP);
-					}
-					if (action == addCachetoListMenuItem) {
-						kontextMenu.close();
-						Global.mainForm.cacheList.addCache(clickedCache.wayPoint);
-					}
-					for (int i=0; i<miLuminary.length; i++) {
-						if (action == miLuminary[i]) {
-							kontextMenu.close();
-							mm.myNavigation.setLuminary(i);
-							mm.updateGps(mm.myNavigation.gpsPos.getFix());
-							miLuminary[i].modifiers |= MenuItem.Checked;
-						} else miLuminary[i].modifiers &= ~MenuItem.Checked;
-					}
-				}
-			} // if (ev.target == kontextMenu)
-		} // if (ev instanceof ControlEvent ) 
-		super.onEvent(ev);
-	}
-}
-
-
-/**
- *	Class to display maps to choose from
- */
-class ListBox extends Form{
-	public MapInfoObject selectedMap = new MapInfoObject();
-	mButton cancelButton, okButton;
-	mList list = new mList(4,1,false);
-	public boolean selected = false;
-	Vector maps;
-
-	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos, MapInfoObject curMap){
-		this.title = "Maps";
-		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else 
-		// set width to screenwidth *3/4 but to at least 240 if the screen is big engough for 240px width
-		this.setPreferredSize(java.lang.Math.max(MyLocale.getScreenWidth()*3/4, java.lang.Math.min(240, MyLocale.getScreenWidth()) ), MyLocale.getScreenHeight()*3/4);
-		this.maps = maps;
-		MapInfoObject map;
-		ScrollBarPanel scb;
-		int oldmap = -1;
-		boolean curMapFound = false;
-		boolean[] inList = new boolean[maps.size()];
-		int row = -1;
-		if (curMap == null) curMapFound = true;
-		if (gotopos != null && Gps != null) {
-			list.addItem("--- Karten von akt. Position und Ziel ---");
-			row++;
-			for(int i = 0; i<maps.size();i++){
-				map = new MapInfoObject();
-				map = (MapInfoObject)maps.get(i);
-				if( map.inBound(Gps.latDec, Gps.lonDec) && map.inBound(gotopos) ) 
-				{
-					list.addItem(i + ": " + map.mapName);
-					row++;
-					inList[i] = true;
-					if (!curMapFound && map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
-				} else inList[i] = false;
-			}
-		}
-		if (Gps != null) {
-			list.addItem("--- Karten der aktuellen Position ---");
-			row++;
-			for(int i = 0; i<maps.size();i++){
-				map = new MapInfoObject();
-				map = (MapInfoObject)maps.get(i);
-				if (map.inBound(Gps.latDec, Gps.lonDec) == true) 
-				{
-					list.addItem(i + ": " + map.mapName);
-					row++;
-					inList[i] = true;
-					if (!curMapFound  && map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
-				}
-			}
-		}
-		if (gotopos != null) {
-			list.addItem("--- Karten des Ziels ---");
-			row++;
-			for(int i = 0; i<maps.size();i++){
-				map = new MapInfoObject();
-				map = (MapInfoObject)maps.get(i);
-				if(map.inBound(gotopos)) {
-					list.addItem(i + ": " + map.mapName);
-					row++;
-					inList[i] = true;
-					if (!curMapFound  && map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
-				}
-			}
-		}
-		list.addItem("--- andere Karten ---");
-		row++;
-		for(int i = 0; i<maps.size();i++){
-			map = new MapInfoObject();
-			map = (MapInfoObject)maps.get(i);
-			if(!inList[i]) {
-				list.addItem(i + ": " + map.mapName);
-				row++;
-				if (!curMapFound  && map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
-			}
-		}
-		list.selectItem(oldmap, true);
-		this.addLast(scb = new ScrollBarPanel(list),CellConstants.STRETCH, CellConstants.FILL);
-		cancelButton = new mButton("Cancel");
-		cancelButton.setHotKey(0, KeyEvent.getCancelKey(true));
-		this.addNext(cancelButton,CellConstants.STRETCH, CellConstants.FILL);
-		okButton = new mButton("Select");
-		okButton.setHotKey(0, KeyEvent.getActionKey(true));
-		this.addLast(okButton,CellConstants.STRETCH, CellConstants.FILL);
-		okButton.takeFocus(0);
-	}
-	private boolean mapIsInList(int mapNr){ // it is not used  anymore could be deleted
-		String testitem = new String();
-		int testitemnr;
-		for (int i=0; i<list.countListItems(); i++) {
-			try { 
-				testitem = ((MenuItem)list.items.get(i)).label;
-				testitemnr = Convert.toInt(testitem.substring(0,testitem.indexOf(':')));
-				if ( testitemnr == mapNr) return true;
-			} catch (IndexOutOfBoundsException e) {} // happens on a seperator line because it doesn't contain ":"
-			catch (NegativeArraySizeException e) {} // happens on a seperator line because it doesn't contain ":"
-		}
-		return false;
-	}
-
-	public void mapSelected() {
-		try { 
-			selectedMap = null;
-			int mapNum = 0;
-			String it = new String();
-			it = list.getText();
-			if (it != ""){
-				it = it.substring(0,it.indexOf(':'));
-				mapNum = Convert.toInt(it);
-				//	Vm.debug("Kartennummer: " + mapNum);
-				selectedMap = (MapInfoObject)maps.get(mapNum);
-				selected = true;
-				this.close(FormBase.IDOK);
-			}
-			else {
-				selected = false;
-				this.close(FormBase.IDCANCEL);
-			}
-		}catch (NegativeArraySizeException e) {} // happens in substring when a dividing line selected 
-	}
-
-	public void onEvent(Event ev){
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelButton){
-				selectedMap = null;
-				selected = false;
-				this.close(FormBase.IDCANCEL);
-			}
-			if (ev.target == okButton || ev.target == list){ // ev.target == list is posted by mList if a selection was double clicked
-				mapSelected();
-			}
-		}
-		super.onEvent(ev);
-	}
-
-	public void  penDoubleClicked(Point where) {
-		mapSelected();
-	}
-}
-
-class MapSymbol extends AniImage { // TODO make this implement MapImage, so that it will be invisible automatically if not on screen. When doing so, test if setgoto-pos -> open map from gotopanel shows the map symbols (directly after starting CW)
-	Object mapObject;
-	String name;
-	String filename;
-	double lat, lon;
-	public MapSymbol(String namei, String filenamei, double lati, double loni) {
-		name = namei;
-		filename = filenamei;
-		lat = lati;
-		lon = loni;
-	}
-	public MapSymbol(String namei, Object mapObjecti, Image fromIm, double lati, double loni) {
-		name = namei;
-		lat = lati;
-		lon = loni;
-		mapObject = mapObjecti;
-		setImage(fromIm);
-	}
-	public void loadImage(){
-		setImage(new Image(filename),0); freeSource();;
-		//properties = AniImage.AlwaysOnTop;
-	}
-}
-
-class ArrowsOnMap extends AniImage {
-	float gotoDir = -361;
-	float sunDir = -361;
-	float moveDir = -361;
-
-	int minY;
-	Graphics draw;
-	private MapInfoObject map=null;
-
-	Color moveDirColor = new Color(255,0,0); // RED 
-	final static Color sunDirColor = new Color(255,255,0); // Yellow
-	//final static Color GREEN = new Color(0,255,0);
-	final static Color gotoDirColor = new Color(0,0,128); // dark blue
-	final static Color northDirColor = new Color(0,0,255); // Blue
-	Point[] sunDirArrow = null;
-	Point[] gotoDirArrow = null;
-	Point[] moveDirArrow = null;
-	Point[] northDirArrow = null;
-	
-	/**
-	 * @param gd goto direction
-	 * @param sd sun direction
-	 * @param md moving direction
-	 */
-	public ArrowsOnMap(){
-		super();
-		newImage();
-		//	setDirections(90, 180, -90);
-	}
-
-	public void newImage() {
-		setImage(new Image(80,80), Color.White);
-		draw = new Graphics(image);
-	}
-	public void setMap(MapInfoObject m) {
-		map = m;
-		makeArrows();
-	}
-
-	public void setDirections(float gd, float sd, float md ) {
-		if (java.lang.Math.abs(gotoDir - gd) > 1 // to save cpu-usage only update if the is a change of directions of more than 1 degree
-				|| java.lang.Math.abs(sunDir - sd) > 1
-				|| java.lang.Math.abs(moveDir - md) > 1)
-		{
-			//dirsChanged = false;
-			gotoDir = gd;
-			sunDir = sd;
-			moveDir = md;
-			makeArrows();
-		}
-	}
-
-	/**
-	 * draw arrows for the directions of movement and destination waypoint
-	 * @param ctrl the control to paint on
-	 * @param moveDir degrees of movement
-	 * @param destDir degrees of destination waypoint
-	 */
-
-	public void doDraw(Graphics g,int options) {
-		if (map == null || g == null) return;
-		drawArrows(g);
-		return;
-/*		if (!dirsChanged) {
-			g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height); // the transparency with a transparent color doesn't work in ewe-vm for pocketpc, it works in java-vm, ewe-vm on pocketpc2003 
-			return;
-		}
-		dirsChanged = false;
-		//super.doDraw(g, options);
-		draw.setColor(Color.White);
-		draw.fillRect(0, 0, location.width, location.height);
-		minY = Integer.MAX_VALUE;
-		drawArrows(draw);
-		draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw 
-		g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
-*/	}
-
-	private void makeArrows(){
-			// draw only valid arrows
-			if (moveDir < 360 && moveDir > -360) {
-				if (moveDirArrow == null) moveDirArrow = new Point[2];
-				makeArrow(moveDirArrow, moveDir, 1.0f);
-			} else moveDirArrow = null;
-			if (gotoDir < 360 && gotoDir > -360) {
-				if (gotoDirArrow == null) gotoDirArrow = new Point[2];
-				makeArrow(gotoDirArrow, gotoDir, 1.0f);
-			} else gotoDirArrow = null;
-			if (sunDir < 360 && sunDir> -360) {
-				if (sunDirArrow == null ) sunDirArrow = new Point[2];
-				makeArrow(sunDirArrow, sunDir, 0.75f);
-			} else sunDirArrow = null;
-			if (java.lang.Math.abs(map.rotationRad) > 1.5 / 180 * java.lang.Math.PI)	{ // show northth arrow only if it has more than 1.5 degree deviation from vertical direction
-				if (northDirArrow == null) northDirArrow = new Point[2];
-				makeArrow(northDirArrow, 0, 1.0f); // north direction
-			} else northDirArrow = null;
-			
-			//select moveDirColor according to difference to gotoDir
-			moveDirColor = new Color(255,0,0); // red
-			
-			if (moveDirArrow != null && gotoDirArrow != null)
-			{
-				float diff = java.lang.Math.abs(moveDir - gotoDir);
-				while (diff > 360)
-				{
-					diff -= 360.0f;
-				}
-				if (diff > 180)
-				{
-					diff = 360.0f - diff;
-				}
-				
-				if (diff <= 5.0)
-				{
-					moveDirColor = new Color(0,192,0);// darkgreen
-				}
-				else if (diff <= 22.5)
-				{
-					moveDirColor = new Color(0,255,0);// green
-				}
-				else if (diff <= 45.0)
-				{
-					moveDirColor = new Color(255,128,0);// orange
-				}
-			}
-		}
-
-	/**
-	 * make (calculate) Pixel array for a single arrow 
-	 * @param g handle for drawing
-	 * @param angle angle of arrow
-	 * @param col color of arrow
-	 */
-	private void makeArrow(Point[] arrow, float angle, float scale) {
-		if (map == null) return;
-
-		float angleRad;
-		int centerX = location.width/2, centerY = location.height/2;
-		if (arrow[0] == null) arrow[0] = new Point();
-		if (arrow[1] == null) arrow[1] = new Point();
-		arrow[0].x = centerX;
-		arrow[0].y = centerY;
-		angleRad = angle * (float)java.lang.Math.PI / 180 + map.rotationRad;
-		arrow[1].x = centerX + new Float(centerX * java.lang.Math.sin(angleRad) * scale).intValue();
-		arrow[1].y = centerY - new Float(centerY * java.lang.Math.cos(angleRad) * scale).intValue();
-		//	g.setPen(new Pen(Color.Black,Pen.SOLID,7));
-		//	g.drawLine(centerX,centerY,x,y);
-	}
-
-	public void drawArrows(Graphics g) {
-		drawArrow(g, northDirArrow, northDirColor);
-		drawArrow(g, gotoDirArrow, gotoDirColor);
-		drawArrow(g, moveDirArrow, moveDirColor);
-		drawArrow(g, sunDirArrow, sunDirColor);
-	}
-	
-	public void drawArrow(Graphics g, Point[] arrow, Color col) {
-		if (arrow == null) return;
-		g.setPen(new Pen(col,Pen.SOLID,3));
-		g.drawLine(arrow[0].x, arrow[0].y, arrow[1].x,arrow[1].y);
-	}
-}
-/** 
- * class that can be used with any x and any y
- * it will save taht location and make itself automatically
- * invisible if it is not on the screen. Call setscreensize to
- * set the screensize
- * @author r
- *
- */
-class MapImage extends AniImage {
-	public Point locAlways = new Point(); // contains the theoretical location even if it the location is out of the screen. If the image is on the screen, it contains the same as location
-	static Dimension screenDim;
-	boolean hidden = false;
-	public MapImage() {
-		super();
-		if (screenDim == null) screenDim = new Dimension(0,0);
-	}
-
-	public MapImage(String f) {
-		super(f);
-		if (screenDim == null) screenDim = new Dimension(0,0);
-	}
-
-	public MapImage(mImage im) {
-		super(im);
-		if (screenDim == null) screenDim = new Dimension(0,0);
-	}
-
-	public static void setScreenSize(int w, int h) {
-		screenDim = new Dimension(w, h);
-	}
-
-	public void setImage(Image im, Color c) {
-		super.setImage(im, c);
-		if (screenDim == null) screenDim = new Dimension(0,0);
-	}
-
-	public void setLocation (int x, int y) {
-		locAlways.x = x;
-		locAlways.y = y;
-		if (!hidden && isOnScreen()) { 
-			super.setLocation(x, y);
-			properties &= ~AniImage.IsInvisible;
-		} else {
-			properties |= AniImage.IsInvisible;
-			super.move(0, 0);
-		}
-	}
-
-	public void move (int x, int y) {
-		locAlways.x = x;
-		locAlways.y = y;
-		if (!hidden && isOnScreen()) { 
-			super.move(x, y);
-			properties &= ~AniImage.IsInvisible;
-		} else {
-			properties |= AniImage.IsInvisible;
-			super.move(0, 0);
-		}
-	}
-
-	public boolean isOnScreen() { 
-		if ( (locAlways.x + location.width > 0 && locAlways.x < screenDim.width) && 
-				(locAlways.y + location.height > 0 && locAlways.y < screenDim.height) ) return true;
-		else return false;
-	}
-
-	public void hide() {
-		hidden = true;
-		properties |= AniImage.IsInvisible;
-	}
-	public void unhide() {
-		hidden = false;
-		move(locAlways.x, locAlways.y);
-	}
-}
-
-

Deleted: trunk/src/CacheWolf/Navigate.java
===================================================================
--- trunk/src/CacheWolf/Navigate.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/Navigate.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -1,232 +0,0 @@
-package CacheWolf;
-
-import ewe.fx.Color;
-import ewe.io.IOException;
-import ewe.io.SerialPort;
-import ewe.io.SerialPortOptions;
-import ewe.net.Socket;
-import ewe.sys.Convert;
-import ewe.sys.mThread;
-import ewe.ui.MessageBox;
-import ewe.util.mString;
-
-public class Navigate {
-	public CWPoint destination = new CWPoint();
-	public CWGPSPoint gpsPos = new CWGPSPoint();
-	public Track curTrack = null;
-	Color trackColor = new Color(255,0,0); // red
-	CWPoint skyOrientationDir = new CWPoint();
-	int luminary = SkyOrientation.SUN;
-
-	public GotoPanel gotoPanel = null;
-	public MovingMap movingMap = null;
-	public SerialThread serThread = null;
-	public Preferences pref = Global.getPref();
-	public UpdateThread tickerThread;
-	public boolean gpsRunning = false;
-	boolean lograw = false;
-	int logIntervall = 10;
-
-	public void setGotoPanel(GotoPanel gp) {
-		gotoPanel = gp;
-	}
-	public void setMovingMap (MovingMap mm) {
-		movingMap = mm;
-		if (gpsRunning) mm.gpsStarted();
-	}
-
-	public void startGps() {
-		if (serThread != null) if (serThread.isAlive()) return; // TODO use gpsRunning
-		try {
-			serThread = new SerialThread(pref.mySPO, gpsPos, (pref.forwardGPS ? pref.forwardGpsHost : ""));
-			if (pref.forwardGPS && !serThread.tcpForward) {
-				(new MessageBox("Warning", "Ignoring error:\n could not forward GPS data to host:\n"+pref.forwardGpsHost+"\n"+serThread.lastError+"\nstop and start GPS to retry",MessageBox.OKB)).exec();
-			}
-			if (gpsPos.latDec == 0 && gpsPos.lonDec == 0) { // TODO use isValid() // TODO raus damit?
-				gpsPos.latDec = destination.latDec; // setze Zielpunkt als Ausgangspunkt
-				gpsPos.lonDec = destination.lonDec;
-			}
-			serThread.start();
-			startDisplayTimer();
-			gpsRunning = true;
-			curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
-			if (lograw)	gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
-			if (gotoPanel != null) gotoPanel.gpsStarted();
-			if (movingMap != null) movingMap.gpsStarted();
-		} catch (IOException e) {
-			(new MessageBox("Error", "Could not connect to GPS-receiver.\n Error while opening serial Port " + e.getMessage()+"\npossible reasons:\n Another (GPS-)program is blocking the port\nwrong port\nOn Loox: active infra-red port is blocking GPS", MessageBox.OKB)).execute(); 
-		}
-	}
-
-	public void setRawLogging(boolean on, int intervall) {
-		lograw = on;
-		logIntervall = intervall; // TODO switch on and off during serthread running
-	}
-	public void startDisplayTimer() {
-		tickerThread = new UpdateThread(this, 1000);
-		tickerThread.start();
-	}
-
-	public void stopDisplayTimer(){
-		if (tickerThread != null) tickerThread.stop();
-	}
-
-	public void stopGps() {
-		serThread.stop();
-		stopDisplayTimer();
-		gpsPos.stopLog();
-		gpsRunning = false;
-		if (gotoPanel != null) gotoPanel.gpsStoped();
-		if (movingMap != null) movingMap.gpsStoped();
-	}
-
-	public boolean isGpsPosValid() {
-		return 	serThread != null && serThread.isAlive() && gpsPos.isValid() ; // && gpsPos.getfiex();
-
-	}
-
-
-	public void setDestination(String LatLon) { 
-		setDestination(new CWPoint(LatLon));
-	}
-
-
-	public void setDestination(CWPoint d) {
-		destination = new CWPoint (d);
-		if (gotoPanel != null) gotoPanel.destChanged(destination);
-		if (movingMap != null) movingMap.destChanged(destination);
-	}
-	/**
-	 * use the constants SkyOrientation.SUN, SkyOrientation.MOON etc.
-	 * @param lu
-	 */
-	public void setLuminary(int lu) {
-		luminary = lu;
-	}
-	public void ticked() {
-		int fix = gpsPos.getFix();
-		if (fix > 0 && (gpsPos.getSats()>= 0)) {
-			//gpsPosition.printAll();
-			//Vm.debug("currTrack.add: voher");
-			if (curTrack == null) curTrack = new Track(trackColor);
-			try {
-				curTrack.add(gpsPos);
-			} catch (IndexOutOfBoundsException e) { // track full -> create a new one
-				curTrack = new Track(trackColor); 
-				curTrack.add(gpsPos);
-				if (movingMap != null) movingMap.addTrack(curTrack); // TODO maybe gotoPanel should also hold a list of Tracks, because otherwise they will be destroyed if not saved in mmp before
-			}
-			try {
-				SkyOrientation.getSunAzimut(gpsPos.Time, gpsPos.Date, gpsPos.latDec, gpsPos.lonDec);
-				double jd = SkyOrientation.utc2juliandate(gpsPos.Time, gpsPos.Date);
-				skyOrientationDir = SkyOrientation.getLuminaryDir(luminary, jd, gpsPos);
-				ewe.sys.Vm.debug("neu: "+ skyOrientationDir.lonDec+ "jd: " + jd);
-			} catch (NumberFormatException e) { // irgendeine Info zu Berechnung des Sonnenaziumt fehlt (insbesondere Datum und Uhrzeit sind nicht unbedingt gleichzeitig verf?gbar wenn es einen Fix gibt)
-				skyOrientationDir.set(-361, -361); // any value out of range (bigger than 360) will prevent drawArrows from drawing it 
-			}
-
-		} else {
-			skyOrientationDir.set(-361, -361); // any value out of range (bigger than 360) will prevent drawArrows from drawing it		
-		}
-		gotoPanel.updateGps(fix);
-		if (movingMap != null) movingMap.updateGps(fix);
-	}
-}
-
-/**
- * Thread for reading data from COM-port
- *
- */
-class SerialThread extends mThread{
-	SerialPort comSp;   
-	byte[] comBuff = new byte[1024*10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
-	int comLength = 0;
-	CWGPSPoint myGPS;
-	boolean run, tcpForward;
-	Socket tcpConn;
-	String lastError = new String();
-
-	public SerialThread(SerialPortOptions spo, CWGPSPoint GPSPoint, String forwardIP) throws IOException {
-		try{
-			comSp = new SerialPort(spo);
-		} catch (IOException e) {
-			throw new IOException(spo.portName);
-		} // catch (UnsatisfiedLinkError e) {} // TODO in original java-vm 
-		if (forwardIP.length()>0) { 
-			try {
-				tcpConn = new Socket(forwardIP, 23);
-				tcpForward = true;
-			} catch (ewe.net.UnknownHostException e) { tcpForward = false; lastError = e.getMessage();
-			} catch (IOException e) { tcpForward = false; lastError = e.getMessage(); 
-			}
-		}
-		myGPS = GPSPoint;
-	}
-
-	public void run() {
-		int noData = 0;
-		int notinterpreted = 0;
-		run = true;
-		while (run){
-			try {
-				sleep(1000);
-				//Vm.debug("Loop? " + noData);
-				noData++;
-				if (noData > 5) { myGPS.noDataError(); }
-			} catch (InterruptedException e) {}
-			if (comSp != null)	{
-				comLength = comSp.nonBlockingRead(comBuff, 0 ,comBuff.length);
-				//Vm.debug("Length: " + comBuff.length);
-				if (comLength > 0)	{
-					noData = 0;
-					String str = mString.fromAscii(comBuff, 0, comLength); 
-					if (tcpForward) {
-						try {
-							tcpConn.write(comBuff, 0, comLength);
-						} catch (IOException e) { tcpForward = false; }
-					}
-					//Vm.debug(str);
-					if (myGPS.examine(str)) notinterpreted = 0; else notinterpreted++;
-					if (notinterpreted > 22) myGPS.noInterpretableData();
-				}
-			}
-		} // while
-		myGPS.noData();
-		tcpConn.close();
-	}
-
-	public void stop() {
-		run = false;
-		if (comSp != null) comSp.close();
-	}
-}
-
-/** 
- * Class for creating a new mThread to create timer ticks to be able to do form.close in the ticked-thread. 
- * Using the Vm.requestTimer-Method causes "ewe.sys.EventDirectionException: This task cannot be done within 
- * a Timer Tick." in the ewe-vm when form.close is called.  
- */
-
-class UpdateThread extends mThread {
-	public boolean run;
-	public int calldelay;
-	public Navigate ticked;
-
-	public UpdateThread (Navigate gp, int cd) {
-		ticked = gp;
-		calldelay = cd;
-	}
-
-	public void run () {
-		run = true;
-		while (run) {
-			try { sleep (calldelay);} catch (InterruptedException e) {}
-			ticked.ticked();
-		}
-	}
-
-	public void stop() {
-		run = false;
-	}
-}
-

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/Parser.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -45,6 +45,8 @@
 package CacheWolf;
 
 import ewe.util.*;
+import CacheWolf.navi.Navigate;
+
 import com.stevesoft.ewe_pat.*;
 import ewe.sys.*;
 import java.lang.Double;

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/Profile.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -1,5 +1,6 @@
 package CacheWolf;
 
+import CacheWolf.navi.Area;
 import HTML.Tmpl.Element.If;
 import ewe.io.BufferedWriter;
 import ewe.io.File;
@@ -372,7 +373,7 @@
 	} 
 
 
-	int numCachesInArea; // only valid after calling getSourroundingArea
+	public int numCachesInArea; // only valid after calling getSourroundingArea
 	public Area getSourroundingArea(boolean onlyOfSelected) {
 		if (cacheDB == null || cacheDB.size() == 0) return null;
 		CacheHolder ch;

Deleted: trunk/src/CacheWolf/SelectMap.java
===================================================================
--- trunk/src/CacheWolf/SelectMap.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/SelectMap.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -1,88 +0,0 @@
-package CacheWolf;
-
-import utils.FileBugfix;
-import ewe.util.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-import ewe.sys.*;
-import ewe.ui.*;
-
-/**
-*	This class displays a user interface to select maps that should be or are already calibrated
-*	class id = 4100
-*/
-class SelectMap extends Form{
-	ScrollBarPanel top;
-	ScrollBarPanel bot;
-	mButton mBCancel, mBLoad;
-	Locale l = Vm.getLocale();
-	LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
-	String mapsPath = new String();
-	mList nonCMaps = new mList(3,1,false);
-	mList CMaps = new mList(3,1,false);
-	String dateien[];
-	String selectedMap = new String();
-	public boolean worldfileexists = false;
-	
-	public SelectMap(){
-		mapsPath = Global.getPref().getMapManuallySavePath(false)+"/"; //  File.getProgramDirectory() + "/maps/";
-		top = new ScrollBarPanel(CMaps);
-		bot = new ScrollBarPanel(nonCMaps);
-		this.title = (String)lr.get(4101,"Maps");
-		this.addLast(new mLabel((String)lr.get(4102,"Calibrated Maps")), CellConstants.STRETCH, CellConstants.FILL);
-		this.addLast(top, CellConstants.STRETCH, CellConstants.FILL);
-		this.addLast(new mLabel((String)lr.get(4103,"Non Calibrated Maps")), CellConstants.STRETCH, CellConstants.FILL);
-		this.addLast(bot, CellConstants.STRETCH, CellConstants.FILL);
-		this.addNext(mBCancel = new mButton((String)lr.get(4104,"Cancel")),CellConstants.STRETCH, CellConstants.FILL);
-		this.addLast(mBLoad = new mButton((String)lr.get(4105,"Open")),CellConstants.STRETCH, CellConstants.FILL);
-		InfoBox inf = new InfoBox("Info", (String)lr.get(4109,"Loading maps...")); 
-		inf.show();
-		try{
-			File files = new FileBugfix(mapsPath);
-			File checkWFL;
-			String rawFileName = new String();
-			dateien = files.listMultiple("*.png,*.jpg,*.gif,*.bmp", File.LIST_FILES_ONLY);
-			for(int i = 0; i < dateien.length;i++){
-				rawFileName = dateien[i].substring(0, dateien[i].lastIndexOf("."));
-				checkWFL = new File(mapsPath + rawFileName + ".wfl");
-				
-				if(checkWFL.exists()){
-					CMaps.addItem(rawFileName);
-				} else {
-					nonCMaps.addItem(rawFileName);
-				}
-			}
-		}catch(Exception ex){
-			//Vm.debug("Problem retrieveing map files");
-		}
-		inf.close(0);
-	}
-	
-	public void onEvent(Event ev){
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if(ev.target == mBCancel){
-				this.close(0);
-			}
-			if(ev.target == mBLoad){
-				this.close(0);
-			}
-		}
-		if(ev instanceof ListEvent && ev.type == ListEvent.SELECTED){
-			if(ev.target == nonCMaps){
-				selectedMap = nonCMaps.getText();
-				CMaps.deleteSelection();
-				worldfileexists = false;
-			}
-			if(ev.target == CMaps){
-				selectedMap = CMaps.getText();
-				nonCMaps.deleteSelection();
-				worldfileexists = true;
-			}
-		}
-		super.onEvent(ev);
-	}
-	
-	public String getSelectedMap(){
-		return selectedMap;
-	}
-}
\ No newline at end of file

Deleted: trunk/src/CacheWolf/SkyOrientation.java
===================================================================
--- trunk/src/CacheWolf/SkyOrientation.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/SkyOrientation.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -1,352 +0,0 @@
-package CacheWolf;
-
-import ewe.sys.Convert;
-
-/** Class to caculate positions of luminaries
- * all methods are static
- * usage:
- * call utc2juliandate and then getLuminaryDir
- * in ressources/cachewolf.languages messege numbers from 6100
- * 
- * @author Pfeffer
- *
- */
-public class SkyOrientation {
-
-	public final static int SUN = 0;
-	public final static int MOON = 1;
-	public static final int ALIOTH = 2; // brightest star in Grater Bear (Grosser Wagen) Rektaszension 12 h 54 m 2 s Deklination +55 Grad 57' 36"
-	public static final int GREATER_BEAR = ALIOTH;
-	public static final int ALNILAM = 3; //Orion = Alnilam = mittlerer Guertelstern Aequinoktium 2000): Rektaszension 5h36m13s; Deklination -1 Grad 12'7"
-	public static final int ORION = ALNILAM; 
-	public static final int CASSIOPEIA_GAMMA = 4; // Kassiopeia Gamma: 00h 56m 42.50s	+60 Grad 43' 00.3"
-	public static final int CASSIOPEIA = CASSIOPEIA_GAMMA;
-	public static final int DENEB = 5;
-	public static final int CYGNUS = DENEB; // Cygnus = Schwan
-	public static final int MIMOSA = 6; // second brightest star in Southern Cross
-	public static final int SOUTHERN_CROSS = MIMOSA; // SOUTHERN_CROSS = Kreus des S?dens = Crux australia
-	
-	public static final CWPoint[] STARS = {
-		// (Deklination, Rektaszension)
-		/*ALIOTH*/		new CWPoint(55. +57./60. + 36./3600., (12. + 54./60. + 2./3600.)*15.), // ALIOTH: Rektaszension 12 h 54 m 2 s Deklination +55 Grad 57' 36"
-		/*ALNILAM*/		new CWPoint(-1. -12./60. -7./3600., (5.+36./60. + 13./3600.)*15.), // (-1. -12./60. -7./3600., (5. + 36./60. + 13./3600.)*15.) <- wikipedia // -1.19748, 5.60978 * 15.) <- www.... // (-1. -11./60. -52./3600., (5. + 36./60. + 35./3600.)*15.)  <- Stellarium 
-		/*Cassiopeia*/	new CWPoint(60. + 43./60. + 0.3/3600., (0 + 56./60. +42.5/3600.)*15.), // CASSIOPALA_GAMMA 00h 56m 42.50s, 60 Grad 43' 00.3" <-- wikipedia, Stellarium: 57m 11s, 60 Grad 45' 29"
-		/*Deneb*/		new CWPoint(45. + 16./60. + 49.2/3600., (20 + 41./60. +25.6/3600.)*15.), // im Schwan (Sommerdreieck) Quelle: Stellarium
-		/*Mimosa*/		new CWPoint(-59. - 41./60. - 19./3600., (12 + 47./60. +43.2/3600.)*15.) // im Schwan (Sommerdreieck) Quelle: Stellarium
-		// Sirius
-	};
-	
-	public static String [] LUMINARY_NAMES = { // TODO MyLocale.getMsg(xxx, "Sun"),
-		MyLocale.getMsg(6100, "Sun"), 
-		MyLocale.getMsg(6101, "Moon"), 
-		MyLocale.getMsg(6102, "Grater Bear"),
-		MyLocale.getMsg(6103, "Orion"),
-		MyLocale.getMsg(6104, "Cassiopeia"), 
-		MyLocale.getMsg(6105, "Cygnus"),
-		MyLocale.getMsg(6106, "Southern Cross")
-	};
-
-	public static String [] LUMINARY_DESC = { // TODO MyLocale.getMsg(xxx, "Sun"),
-		MyLocale.getMsg(6100, "Sun"), 
-		MyLocale.getMsg(6101, "Moon"), 
-		MyLocale.getMsg(6122, "Alioth in Greater Bear"),
-		MyLocale.getMsg(6123, "Alnilam in Orion"),
-		MyLocale.getMsg(6124, "Cassiopeia Gamma"), 
-		MyLocale.getMsg(6125, "Deneb in Cygnus"),
-		MyLocale.getMsg(6126, "Becrux in Southern Cross")
-	};
-
-	/**
-	 * Get the friendly name of the luminary
-	 * @param luminary
-	 * @return
-	 */
-	public static String getLuminaryName(int luminary) {
-		return LUMINARY_NAMES[luminary]; 
-	}
-	
-	/**
-	 * Get a more exact description of the luminary 
-	 * @param lu
-	 * @return
-	 */
-	public static String getLuminaryDesc(int lu) {
-		return LUMINARY_DESC[lu];
-	}
-
-	/**
-	 * get azimuth from north and elevation for horizont for a given 
-	 * Luminary (planet or star) 
-	 * @param luminary one of SUN, MOON, ALIOTH, GRAETER_BEAR, ALNILAM, ORION, CASSIOPEIA_GAMMA, CASSIOPEIA
-	 * @param jd julian date must be calculated in advance e.g. from utc2julian
-	 * @param onEarth place on earth of the observer
-	 * @return lon = azimuth from north, lat = elevation from horizont
-	 */
-	public static CWPoint getLuminaryDir(int luminary, double jd, CWPoint onEarth) {
-		switch (luminary) {
-		case SUN: return getSunDir(jd, onEarth);
-		case MOON: return getMoonDir(jd, onEarth);
-		default: 
-			return equatorial2AzimutCoos(onEarth, jd, STARS[luminary-MOON-1]);
-		}
-	}
-
-	/**
-	 * @param utc in the format as it comes from gps DDMMYY
-	 * @param datum in the format as it comes from gps HHMMSS
-	 * @return juliandate
-	 * @throws NumberFormatException if utc / datum could not be parsed successfully
-	 */
-	public static double utc2juliandate(String utc, String datum) {
-		try {
-			int tag, monat, jahr, stunde, minute, sekunde;
-			tag     = Convert.parseInt(datum.substring(0, 2));
-			monat   = Convert.parseInt(datum.substring(2, 4));
-			jahr    = Convert.parseInt(datum.substring(4, 6)) + 2000;
-			stunde  = Convert.parseInt(utc.substring(0, 2));
-			minute  = Convert.parseInt(utc.substring(2, 4));
-			sekunde = Convert.parseInt(utc.substring(4, 6)); // Kommastellen werden abgeschnitten
-			// julianisches "Datum" jd berechnen (see http://de.wikipedia.org/wiki/Julianisches_Datum )
-			if (monat<2) {jahr--; monat+=12;} // verlegung des Jahres Endes auf Feb macht Berechnung von SChaltjahren einfacher
-			double a = (int)java.lang.Math.floor((double)jahr/100.); // Alle hundert Jahre kein Schlatjahr (abrunden)
-			double b = 2 - a + java.lang.Math.floor((double)a/4.);
-			double jd = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) + (double)tag + (double)stunde/24 + (double)minute/1440 + (double)sekunde/86400 + b - 1524.5;
-			return jd;
-			//double jd0 = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) +(double)tag + b - 1524.5;
-		} catch (IndexOutOfBoundsException e) {
-			// wird von substring geworfen wenn datum / utc nicht genug Ziffern haben
-			// NumberFormatException wird au?erdem von Convert.ParseInt direkt geworfen wenn
-			// nicht in Int konvertiert werden kann
-			throw new NumberFormatException();
-		}
-	}
-
-	/**
-	 * old version, gives the same as the new one
-	 * @param utc
-	 * @param datum
-	 * @param lat
-	 * @param lon
-	 * @return
-	 */
-	public static float getSunAzimut (String utc, String datum, double lat, double lon) {
-		//	(new MessageBox("test", "utc:"+utc+" datum: "+datum+", lat: "+lat+", len: "+lon, MessageBox.OKB)).exec();
-		try {
-			int tag, monat, jahr, stunde, minute, sekunde;
-			tag = Convert.parseInt(datum.substring(0, 2));
-			monat = Convert.parseInt(datum.substring(2, 4));
-			jahr = Convert.parseInt(datum.substring(4, 6)) + 2000;
-			stunde=Convert.parseInt(utc.substring(0, 2));
-			minute=Convert.parseInt(utc.substring(2, 4));
-			sekunde=Convert.parseInt(utc.substring(4, 6)); // Kommastellen werden abgeschnitten
-			// julianisches "Datum" jd berechnen (see http://de.wikipedia.org/wiki/Julianisches_Datum )
-			if (monat<2) {jahr--; monat+=12;} // verlegung des Jahres Endes auf Feb macht Berechnung von SChaltjahren einfacher
-			double a = (int)java.lang.Math.floor((double)jahr/100.); // Alle hundert Jahre kein Schlatjahr (abrunden)
-			double b = 2 - a + java.lang.Math.floor((double)a/4.);
-			double jd = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) + (double)tag + (double)stunde/24 + (double)minute/1440 + (double)sekunde/86400 + b - 1524.5;
-			double jd0 = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) +(double)tag + b - 1524.5;
-			// Ekliptikalkoordinaten der Sonne berechnen (see http://de.wikipedia.org/wiki/Sonnenstand )
-			double n = jd - 2451545.0;
-			double l = 280.46 + 0.9856474 * n;
-			double g = 357.528 + 0.9856003 * n;
-			double d = l + 1.915*java.lang.Math.sin(g/180*java.lang.Math.PI) + 0.02 * java.lang.Math.sin(2*g/180*java.lang.Math.PI);
-			// Rektaszension alpha und Deklination delta der Sonne berechnen
-			double e = 23.439 -0.0000004 * n;
-			double alphaNenner = java.lang.Math.cos(d/180*java.lang.Math.PI);
-			double alpha = 180/java.lang.Math.PI*java.lang.Math.atan(java.lang.Math.cos(e/180*java.lang.Math.PI)*java.lang.Math.sin(d/180*java.lang.Math.PI)/alphaNenner);
-			double delta = 180/java.lang.Math.PI*java.lang.Math.asin(java.lang.Math.sin(e/180*java.lang.Math.PI)*java.lang.Math.sin(d/180*java.lang.Math.PI) );
-			if (alphaNenner<0) {alpha +=180;}
-			// Azimut
-			double t0 = (jd0 - 2451545.)/36525.; // schon in t0 bzw jd0 richtig berechnet?
-			double thetaHG = 6.697376 + 2400.05134 * t0 + 1.002738 * ((double)stunde + (double)minute/60. + (double)sekunde/3600.);
-			double theta = thetaHG * 15. + lon;
-			double azimutNenner = java.lang.Math.cos((theta-alpha)/180*java.lang.Math.PI)*java.lang.Math.sin(lat/180*java.lang.Math.PI)-
-			java.lang.Math.tan(delta/180*java.lang.Math.PI)*java.lang.Math.cos(lat/180*java.lang.Math.PI);
-			float azimut = (float) java.lang.Math.atan(java.lang.Math.sin((theta-alpha)/180*java.lang.Math.PI)/
-					azimutNenner);
-			azimut = (float) (azimut * 180f / java.lang.Math.PI);
-			if (azimutNenner<0) azimut +=180.;
-			// null = Sueden auf Null = Norden umrechnen
-			azimut +=180.;
-			if (azimut >360.) azimut -=360.;
-			ewe.sys.Vm.debug("sunAzimut1: " + azimut);
-			ewe.sys.Vm.debug("sun Elevation: " +getSunAzimut2 (utc, datum, lat, lon).latDec);
-			CWPoint MoonDir = getMoonDir(jd, new CWPoint(lat, lon));
-			ewe.sys.Vm.debug("Moon Elevation: " + MoonDir.latDec + "Moon Azimut: " + MoonDir.lonDec);
-			CWPoint OrionDir = getAlnilamDir(jd, new CWPoint(lat, lon));
-			ewe.sys.Vm.debug("Alnilam (Orion) Elevation: " + OrionDir.latDec + "Alnilam (Orion) Azimut: " + OrionDir.lonDec );
-			
-			return azimut;
-		} catch (IndexOutOfBoundsException e) {
-			// wird von substring geworfen wenn datum / utc nicht genug Ziffern haben
-			// NumberFormatException wird ausserdem von Convert.ParseInt direkt geworfen wenn
-			// nicht in Int konvertiert werden kann
-			throw new NumberFormatException();
-		}
-	}
-
-	public static CWPoint getSunAzimut2 (String utc, String datum, double lat, double lon) {
-		double jd = utc2juliandate(utc, datum);
-		CWPoint eclCoos = getSunEclipticCoos(jd);
-		// calculate ecliptic coos
-		// convert coos
-		return ecliptic2AzimutCoos(new CWPoint(lat, lon), jd, eclCoos);
-	}
-
-	public static CWPoint getSunDir (double jd, CWPoint onEarth) {
-		CWPoint eclCoos = getSunEclipticCoos(jd);
-		// calculate ecliptic coos
-		// convert coos
-		return ecliptic2AzimutCoos(onEarth, jd, eclCoos);
-	}
-
-	public static CWPoint getMoonDir(double jd, CWPoint onEarth) {
-		CWPoint eclCoo = getMoonEclipticCoos(jd);
-		return ecliptic2AzimutCoos(onEarth, jd, eclCoo);
-	}
-
-	public static CWPoint getAlnilamDir(double jd, CWPoint onEarth) {
-		// Koordinaten Alnilam (mittlerer Guertelstern des Orion), Rektaszension 5h36m13s; Deklination -1?12'7 TODO Aequinoktium 2000
-		// Source: wikipedia
-		return equatorial2AzimutCoos(onEarth, jd, new CWPoint(-1. -12./60. -7./3600., (5. + 36./60. + 13./3600.)*15.) ); // (-1. -12./60. -7./3600., (5. + 36./60. + 13./3600.)*15.) <- wikipedia // -1.19748, 5.60978 * 15.) <- www.... // (-1. -11./60. -52./3600., (5. + 36./60. + 35./3600.)*15.)  <- Stellarium
-	}
-
-	/**
-	 * get the ecliptic coordinates of the sun
-	 * @param juliandate
-	 * @return
-	 */
-	public static CWPoint getSunEclipticCoos(double juliandate) {
-		double n = juliandate - 2451545.0;
-		double l = 280.46 + 0.9856474 * n;
-		double g = 357.528 + 0.9856003 * n;
-		double lambda = l + 1.915*java.lang.Math.sin(g/180*java.lang.Math.PI) + 0.02 * java.lang.Math.sin(2*g/180*java.lang.Math.PI);
-		return new CWPoint(0, lambda);
-	}
-
-
-	// the following code is adopted from http://lexikon.astronomie.info/java/sunmoon/sunmoon.html
-	// ignores the time difference between juliandate and TDT, which is something like 1 minute
-	public static CWPoint getMoonEclipticCoos(double julianDate) {
-		final double DEG = Math.PI / 180;  
-		final double RAD = 1/DEG;
-		double sunAnomalyMean = 360*DEG/365.242191*(julianDate - 2447891.5) + 279.403303*DEG - 282.768422*DEG;
-		double D = julianDate-2447891.5;
-
-		// Mean Moon orbit elements as of 1990.0
-		double l0 = 318.351648*DEG;
-		double P0 =  36.340410*DEG;
-		double N0 = 318.510107*DEG;
-		double i  = 5.145396*DEG;
-
-		double l = 13.1763966*DEG*D+l0;
-		double MMoon = l-0.1114041*DEG*D-P0; // Moon's mean anomaly M
-		double N = N0-0.0529539*DEG*D;       // Moon's mean ascending node longitude
-
-		double sunlon = getSunEclipticCoos(julianDate).lonDec; 
-		double C = l-sunlon;
-		double Ev = 1.2739*DEG*Math.sin(2*C-MMoon);
-		double Ae = 0.1858*DEG*Math.sin(sunAnomalyMean);
-		double A3 = 0.37*DEG*Math.sin(sunAnomalyMean);
-
-		double MMoon2 = MMoon+Ev-Ae-A3;  // corrected Moon anomaly
-		double Ec = 6.2886*DEG*Math.sin(MMoon2);  // equation of centre
-		double A4 = 0.214*DEG*Math.sin(2*MMoon2);
-		double l2 = l+Ev+Ec-Ae+A4; // corrected Moon's longitude
-		double V = 0.6583*DEG*Math.sin(2*(l2-sunlon));
-
-		double l3 = l2+V; // true orbital longitude;
-		double N2 = N-0.16*DEG*Math.sin(sunAnomalyMean);
-
-		CWPoint moonCoor = new CWPoint();  
-		moonCoor.lonDec = (( N2 + Math.atan2( Math.sin(l3-N2)*Math.cos(i), Math.cos(l3-N2) ) ) * RAD)% 360;
-		moonCoor.latDec = Math.asin( Math.sin(l3-N2)*Math.sin(i) ) * RAD;
-		//moonCoor.orbitLon = l3;
-		return moonCoor;
-
-		/*
-		double e  = 0.054900;
-		double a  = 384401; // km
-		double diameter0 = 0.5181*DEG; // angular diameter of Moon at a distance
-		double parallax0 = 0.9507*DEG; // parallax at distance a
-
-		  // relative distance to semi mayor axis of lunar oribt
-		  moonCoor.distance = (1-sqr(e)) / (1+e*Math.cos(MMoon2+Ec) );
-		  moonCoor.diameter = diameter0/moonCoor.distance; // angular diameter in radians
-		  moonCoor.parallax = parallax0/moonCoor.distance; // horizontal parallax in radians
-		  moonCoor.distance *= a;	// distance in km
-
-		  // Age of Moon in radians since New Moon (0) - Full Moon (pi)
-		  moonCoor.moonAge = Mod2Pi(l3-sunCoor.lon);   
-		  moonCoor.phase   = 0.5*(1-Math.cos(moonCoor.moonAge)); // Moon phase, 0-1
-
-		  var phases = new Array("Neumond", "Zunehmende Sichel", "Erstes Viertel", "Zunnehmender Mond", 
-		  	"Vollmond", "Abnehmender Mond", "Letztes Viertel", "Abnehmende Sichel", "Neumond");
-		  var mainPhase = 1./29.53*360*DEG; // show 'Newmoon, 'Quarter' for +/-1 day arond the actual event
-		  var p = Mod(moonCoor.moonAge, 90.*DEG);
-		  if (p < mainPhase || p > 90*DEG-mainPhase) p = 2*Math.round(moonCoor.moonAge / (90.*DEG));
-		  else p = 2*Math.floor(moonCoor.moonAge / (90.*DEG))+1;
-		  moonCoor.moonPhase = phases[p];
-
-		  moonCoor.sign = Sign(moonCoor.lon);
-		  return (float) moonCoor.lonDec;
-		return 0;
-	}
-		 */
-	}
-
-	public static CWPoint ecliptic2AzimutCoos(CWPoint onEarth, double julianDate, CWPoint ecliptic) {
-		CWPoint equat = ecliptic2Equatorial(ecliptic, julianDate);
-		return equatorial2AzimutCoos(onEarth, julianDate, equat);
-	}
-	/**
-	 * convert rektaszension alpha and deklination delta to azimuth / elevation
-	 * @param onEarth pos. on earth for which the azimut is wanted
-	 * @param julianDate
-	 * @param equatorial: lonDec = rektaszension (alpha), latDec = Deklination (delta)
-	 * @return lonDec: azimuth in degrees from north, lat: elevation in degrees from horizont
-	 * alogithism from wikipedia sonnenbahn
-	 */
-	public static CWPoint equatorial2AzimutCoos(CWPoint onEarth, double julianDate, CWPoint equatorial) {
-		double stunde = ((julianDate + 0.5) % 1) * 24;
-		double jd0 = julianDate - stunde /24; // julian date at UTC 0:00
-		double t0 = (jd0 - 2451545.)/36525.; // schon in t0 bzw jd0 richtig berechnet?
-		double thetaHG = 6.697376 + 2400.05134 * t0 + 1.002738 * stunde; // + (double)minute/60.);
-		double theta = thetaHG * 15. + onEarth.lonDec;
-		double tau = (theta - equatorial.lonDec ) /180*Math.PI;
-		double phi = onEarth.latDec/180*Math.PI;
-		double azimutNenner = Math.cos(tau)*Math.sin(phi)-
-		Math.tan(equatorial.latDec/180*Math.PI)*Math.cos(onEarth.latDec/180*java.lang.Math.PI);
-		float azimut = (float) java.lang.Math.atan(java.lang.Math.sin((theta-equatorial.lonDec)/180*Math.PI)/
-				azimutNenner);
-		azimut = (float) (azimut * 180f / java.lang.Math.PI);
-		if (azimutNenner<0) azimut +=180.;
-		double h = 180 / Math.PI * Math.asin(Math.cos(equatorial.latDec/180*Math.PI) * Math.cos(tau)*Math.cos(phi) + Math.sin(equatorial.latDec/180 *Math.PI) * Math.sin(phi));
-		// null = Sueden auf Null = Norden umrechnen
-		azimut +=180.;
-		if (azimut >360.) azimut -=360.;
-		return new CWPoint(h, azimut);
-	}
-
-	/**
-	 * convert from eliptical to equatorial coordinates
-	 * @param juliandate
-	 * @param eklipCoo ecliptic coos in degrees  
-	 * @return lon: Deklination (delta), lat: Rektaszension (alpha) in degree
-	 * this is adopted from http://lexikon.astronomie.info/java/sunmoon/sunmoon.html 
-	 */
-	public static CWPoint ecliptic2Equatorial(CWPoint eklipCoo, double juliandate) {
-		double T = (juliandate - 2451545.0)/36525.; // Epoch 2000 January 1.5
-		double eps = (23.+(26+21.45/60)/60 + T*(-46.815 +T*(-0.0006 + T*0.00181) )/3600 ) / 180 * java.lang.Math.PI; // schiefe der Ekliptik
-		double coseps = Math.cos(eps);
-		double sineps = Math.sin(eps);
-
-		double sinlon = Math.sin(eklipCoo.lonDec / 180 * Math.PI);
-		CWPoint equatorial = new CWPoint();
-		equatorial.lonDec = (180 / Math.PI * Math.atan2( (sinlon*coseps-Math.tan(eklipCoo.latDec /180 * Math.PI)*sineps), Math.cos(eklipCoo.lonDec/180 * Math.PI) ) ) % 360; // rektaszension (alpha)
-		equatorial.latDec = 180 / Math.PI * Math.asin( Math.sin(eklipCoo.latDec/180 * Math.PI)*coseps + Math.cos(eklipCoo.latDec/180 * Math.PI)*sineps*sinlon ); // deklination (delta)
-
-		return equatorial;
-	}
-}
-

Deleted: trunk/src/CacheWolf/TrackOverlay.java
===================================================================
--- trunk/src/CacheWolf/TrackOverlay.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/TrackOverlay.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -1,299 +0,0 @@
-package CacheWolf;
-
-//import java.awt.image.BufferedImage;
-
-import ewe.fx.Color;
-import ewe.fx.Graphics;
-import ewe.fx.IImage;
-import ewe.fx.Image;
-import ewe.fx.Pen;
-import ewe.graphics.AniImage;
-import ewe.sys.Convert;
-import ewe.fx.Point;
-import ewe.fx.Mask;
-
-import ewe.util.Vector;
-
-
-public class TrackOverlay extends MapImage {
-	TrackPoint topLeft;
-	TrackPoint bottomRight;
-	Graphics draw;
-	Graphics drawMask;
-	int test;
-	MapInfoObject trans; 
-	Vector tracks;
-	boolean imageChangesDontShow = false;
-	public Point trackPixels[] = null;
-	public Color trackPixelsColor[] = null;
-	public int numPixels = 0;
-	final static int maxPixelsInCache = 100;
-	final static Color transparentColorForOverlay = Color.White; // only for use when transparent color is used
-	static boolean useTransparentColor;
-	public TrackOverlay (TrackPoint topLefti, int widthi, int highti, MapInfoObject transi) {
-		super();
-		topLeft = new TrackPoint(topLefti);
-		trans = transi;
-		bottomRight = calcLatLonInImage(widthi, highti);
-		if (ewe.sys.Vm.getPlatform().equalsIgnoreCase("java")) {
-			useTransparentColor = true; 
-			setImage(new Image(widthi, highti), transparentColorForOverlay); // java-vm: transparency with a mask is very memory consuming, but transparency with a mask is much faster in ewe-vm and doesn't consume more memory than a transparency color (ewe 1.49)
-		} else {
-			useTransparentColor = false; // // momentanously this it not used, but this is only because ewe treats areas as opaque which has a non white color in the image, so that the mask doesn't need to be changed
-			Image maski = new Image(widthi, highti);
-			drawMask = new Graphics(maski);
-			drawMask.setColor(Color.White);
-			drawMask.fillRect(0, 0, maski.getWidth(), maski.getHeight());
-			setImage(new Image(widthi, highti), maski); // java-vm: transparency with a mask is very memory consuming, but transparency with a mask is much faster in ewe-vm and doesn't consume more memory than a transparency color (ewe 1.49)
-			maski.free(); //setimage produces an inverted copy of the mask
-			maski = null;
-		}
-		//properties = AlwaysOnTop; // arrows are above, so dont set it.
-		draw = new Graphics(image);
-		draw.setDrawOp(Graphics.DRAW_OVER);
-		if (useTransparentColor) draw.setColor(transparentColorForOverlay);
-		else draw.setColor(Color.White);
-		draw.fillRect(0, 0, widthi, highti);
-		//int[] markImage = {0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000};
-		//int[] markMaskOpaque = {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff};
-		//mask.setPixels( markMaskOpaque, 0, 50, 50, 2, 2, 0);
-		//draw.fillRectRGB(50, 50, 52, 52, 0x00ff0000); // fillRectRGB has a Bug - it never returns - use fillRect instead
-		//image.setPixels(markImage, 0, 50, 50, 2, 2, 0); // out of an to me unkwon reason this doesn't work here, but it does in painttracks
-	}
-	public void imageSet()
-//	==================================================================
-	{
-		IImage i = drawable;
-		if (i == null) i = image;
-		if (i != null){
-			location.width = i.getWidth();
-			location.height = i.getHeight();
-		}
-		if (image != null && image != sourceImage) image.freeze();
-//		if (mask != null && mask != sourceMask) mask.freeze(); // dont freeze the mask, it could change. Anyway momentanously it doesnt change, because when the image contains non-white in the opaque areas, it will be opaque without changing the mask
-		properties &= ~HasChanged;
-	}
-
-
-	public void paintTracks() {
-	// for debugging TrackOverlayPositions
-	// draw.setPen(new Pen(Color.LightBlue,Pen.SOLID,1));
-	// draw.fillRect(1, 1, image.getWidth()-1, image.getHeight()-1);
-		//draw.setColor(255,0,0);
-		//draw.setPen(new Pen(new Color(255,0,0),Pen.SOLID,3));
-		//draw.fillRect(50, 50, 4, 4); // fillRectRGB has a Bug - it never returns - use fillRect instead
-
-		if (tracks == null || tracks.size() == 0) return;
-		int tri, i;
-		Track tr;
-		for (tri=tracks.size()-1; tri >= 0; tri--) {
-			tr = (Track)tracks.get(tri);
-			//draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
-			draw.setColor(tr.trackColor);
-			if (tr.num > 0) {
-				for (i=0; i < tr.num; i++) {
-					paintPoint(tr.trackColor, tr.TrackPoints[i].latDec, tr.TrackPoints[i].lonDec);
-				}
-			}
-		}
-	}
-	
-
-	/**
-	 * 
-	 * @param f
-	 * @param lat
-	 * @param lon
-	 * @return true if point was on this overlay
-	 */
-	public boolean paintPoint(Color f, double lat, double lon){
-		if (lat<bottomRight.latDec || lat > topLeft.latDec || lon<topLeft.lonDec || lon>bottomRight.lonDec) return false;
-		//ewe.sys.Vm.debug("showlastaddedpoint, lat: "+lat+"   lon: "+lon);
-		double b[] = new double[2];
-		int x, y;
-		b[0] = lat - topLeft.latDec; // see calcXYinImage (TrackPoint p) 
-		b[1] = lon - topLeft.lonDec; 
-		x=(int) (trans.transLatX* b[0] + trans.transLonX*b[1]);
-		y=(int) (trans.transLatY* b[0] + trans.transLonY*b[1]);
-		//draw.drawLine(x, y, x, y);
-		//ewe.sys.Vm.debug("showlastaddedpoint, x: "+x+"   y: "+y+"loc.x: "+location.x+"  loc.y:"+location.y);
-		draw.fillRect(x-1, y-1, 3, 3);
-		//drawMask.fillRect(x-1, y-1, 3, 3);
-		/*	if (image.bufferedImage != null) { // funktioniert gut, allerdings nur in der java-VM wenn ewe.fx.Image.bufferedImage als public definiert
-			int yd;
-			for  (int xd=-1; xd<=1; xd++) {
-				for (yd=-1; yd<=1; yd++) {
-					((BufferedImage)image.bufferedImage).setRGB(x+xd, y+yd, -65536);
-				}
-			} */
-		if (imageChangesDontShow) {
-			try {addPixelIfNeccessary(x, y, f); }
-			catch (IndexOutOfBoundsException e) // thrown when there are more than pixels stored than possible
-			{ fixate();  }
-		}
-		return true;
-	}
-
-	/**
-	 * this method forces ewe to transfer the drawn points
-	 * from _awtImage to bufferedImage, which is drawn to the screen
-	 *
-	 */
-	private void fixate() {
-		if (numPixels == 0) return;
-		//	draw.drawImage(image,null,Color.DarkBlue,0,0,location.width,location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
-		draw.drawImage(image, null, Color.Pink, 0, 0, 1, 1); // width and height is anyway ignored, evtl. testen,  
-		imageChangesDontShow = false;
-		removeAllPixels();
-	}
-
-	private void removeAllPixels() {
-		numPixels = 0;
-		trackPixels = null;
-		trackPixelsColor = null;
-	}
-
-	public Point calcXYinImage (TrackPoint p) {
-		double b[] = new double[2]; // see method paintPoint it should actually call this method but it doesn't because of speed raesons
-		int x, y;
-		b[0] = p.latDec - topLeft.latDec;
-		b[1] = p.lonDec - topLeft.lonDec;
-		x=(int) (trans.transLatX* b[0] + trans.transLonX*b[1]);
-		y=(int) (trans.transLatY* b[0] + trans.transLonY*b[1]);
-		return new Point(x,y);
-	}
-
-	public TrackPoint calcLatLonInImage (double x, double y) {
-		// see trans.calcLatLon(p);
-		TrackPoint ll = new TrackPoint(); 
-		ll.latDec = (double)x * trans.affine[0] + (double)y * trans.affine[2] + topLeft.latDec;
-		ll.lonDec = (double)x * trans.affine[1] + (double)y * trans.affine[3] + topLeft.lonDec;
-		return ll;
-	}
-
-	public void addPixel(int x, int y, Color f) throws IndexOutOfBoundsException {
-		if (trackPixels==null) { trackPixels = new Point[maxPixelsInCache]; trackPixelsColor = new Color[maxPixelsInCache]; } 
-		trackPixels[numPixels] = new Point(x, y); // IndexOutOfBoundsException is handled in PaintPoint
-		trackPixelsColor[numPixels] = f.getCopy();
-		numPixels++;
-	}
-
-	public void addPixelIfNeccessary(int x, int y, Color f){
-		if (trackPixels != null) {
-			int ll =(numPixels<30 ? 0 : numPixels-30); // look in the last 50 added Pixels if the same Pixel is already in the list (for performance reasons dont look in the whole list)
-			for (int i=numPixels-1; i>=ll; i--) {
-				if (trackPixels[i].x == x && trackPixels[i].y == y && f.equals(trackPixelsColor[i])) 
-				{ return; } 
-			}
-		}
-		addPixel(x, y, f);
-	}
-
-	public static final int FIXATE_IF_NO_PIXELS_NUM = 60;
-	private int notOnThisOverlaySince = 0;
-
-	public void paintLastAddedPoint(Track tr) { 
-		//draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
-		draw.setColor(tr.trackColor);
-		if (paintPoint(tr.trackColor, tr.TrackPoints[tr.num-1].latDec, tr.TrackPoints[tr.num-1].lonDec)) notOnThisOverlaySince = 0;
-		else notOnThisOverlaySince++;
-		if (notOnThisOverlaySince > FIXATE_IF_NO_PIXELS_NUM) { // zur Performanceverbesserung: wenn in den letzten 60 Updates keines mehr f?r dieses Overlay dabei war, Overlay Pixels fest schreiben, damit doDraw entlastet wird.
-			fixate();
-			notOnThisOverlaySince = 0;
-		}
-
-	}
-
-	public void doDraw(Graphics g,int options) { // this is automatically called when the image need to be (re-)drawn on the screen
-		super.doDraw(g, options);
-		imageChangesDontShow = true; // g.drawImage (in super) copies _awtImage into bufferedImage, any later changes to _awtImage dont show up until the mask or the image has changed - unfortunately bufferedImage is not accessable from outside
-		// draw trackpoints which were added after image changes don't show up on the screen
-		if (tracks == null || tracks.size() == 0) return;
-		int i;
-		for (i=0; i<numPixels; i++) {
-			g.setColor(trackPixelsColor[i]);
-			g.fillRect(trackPixels[i].x-1, trackPixels[i].y-1, 3, 3);
-		}
-		//g.drawText(Convert.toString(test), 10, 10);
-		//g.drawRect(10 + test, 10, 10, 10);
-		//test++;
-	}
-}
-
-
-/* draw zeichnet auf _awtImage
- * image.drawImage erzeugt bufferedImage, wenn es vorher null war 
- * und kopiert den entsprechenden Teil in das ?bergebene Surface
- * Das Problem ist, dass bufferedImage nicht mehr upgedatet wird, wenn
- * es einmal erzugt wurde. Es wird nur dann upgedatet, wenn das Image ein anderes wird
- * oder die Maske eine andere. Das Update erfolgt dann ?ber doDraw, was doCheckMask aufruft,
- * das das eigentliche kopieren aus _awtImage vornimmt.
- * 
- *  Problem: das kopieren von _awtImage in BufferedImage ist sehr zeitaufw?ndig, weil
- *  es keine native Routine ist und jedes Pixel einzeln gepr?ft wird.
- *  Deswegen w?re die beste L?sung, wenn ich bufferedImage direkt updaten k?nnte.
- *  Aber bufferedImage ist privat, ich kann auch in abgeleiteten Klassen nicht drauf
- *  zugreifen. 
- *  
- *  Zur Not w?re auch denkbar, doDraw zu ?berschreiben, um bei jedem Aufruf alle 
- *  Trackpoints neu zu zeichnen.
- *  Work-Aorund: draw.drawImage(image,null,Color.Pink,0,0,1,1); bewirkt, dass awtImage ins
- *  bufferedImage kopiert wird. Dabei wird die transparentColor (in mImage) nicht ge?ndert
- *  und beim Aufruf von doDraw wird wieder die urspr?ngliche transparentColor verwendet
- *  
- */
-//was alles nicht funktioniert:
-//drawmask.setDrawOp(Graphics.DRAW_OVER);
-//drawmask.drawRect(x-1, y-1, 2, 2, 1);
-//this.setImage(image, mask);
-//n?chster Versuch: image.bufferedImage in ewe.fx.Image public definieren !!!
-//image.rgb
-//draw._g.surfaceData.bufImg.raster.data[y*this.location.width + x] = -65536; := image._awtImage
-//((Image)image).eImage(colorOrMask)._awtImage.raster.data[0]=0;
-//image
-//((BufferedImage)(image).se.^.bufferedImage.raster.data[y*this.location.width + x]=-65536; //was dort steht wird tats?chlich angezeigt, allerdings kann ich es nicht direkt setzen :-(
-//int[] markPixels = new int[4];
-//for (int i = 0; i<markPixels.length; i++) { markPixels[i] = -65536; }
-//image.transparent = null; hilft auhc nicht
-//image.mask = null;
-//image.bufferedImage = null;
-//image.setPixels(markPixels, 0 , x-20, y, 2, 2, 0); // dadrin sollte bufferedImage = null gesetzt werden, wird es aber nicht :-(
-//ewe.fx.mImage mark = new mImage();
-//Image mark = new Image(2,2);
-//new Graphics(mark).drawImage(image, null, transparentColor, x-40, y, 2, 2);
-//mark.draw(draw, x-50, y, Graphics.DRAW_OVER); // options (Graphics.DRAW_OVER) are ignored anyway
-//image.bufferedImage = null; // this solves the problem
-//toCursor(null);
-//this.draw(draw);
-//image=(BufferedImage)this.toNativeImage(transparentColor);
-//(java.awt.Image.b)
-//image.bufferedImage=null;
-//draw.flush();
-//ewe.ui.PenEvent.refreshTip(draw.surface);
-//draw.setPixelRGB(x, y, -65536);
-//this.changed(); hilft auch nicht
-//this.refresh(); // hilft nicht :-(
-//lastDrawn.x = lastDrawn.x -10; hilft auch nicht
-//imageMayChange = true; // hilft auch nicht :-(
-
-/*
- * In der ewe-VM f?r PocketPC-ARM funktioniert die Festlegung einer 
- * transparenten Farbe nicht (Hintergrund wird wei? statt durchsichtig)
- * deswegen (und weil in ewe-VM effizienter) Umstellung auf Transparenzmaske
- * statt transparenter Farbe
- * TODO Dies ist in Java-VM allerdings extrem Speicher fressend -> evtl abfragen 
-static int fixMask(WObject image,WObject col,int isMask):
-	in Maske: 0 an durchsichtiger Stelle, sonst ff
-	in Image: ffffff an durchsichtiger Stelle
-
-	in java-VM
-	in Maske: ffffffff in image.mask, wenn nicht durchsichtig
-	          ff000000 an durchsichtiger Stelle
-	image.doCheckMask erzeugt ein Image mit 0 an den durchsichtigen Stellen, die dadurch definiert sind, dass im image 0xffffff und in (mask & 0xffffff == 0) steht.
- */
-/*
- * this class is only needed to have a fast access to the list of pixels
- * which are added but aniimage.draw will not lead to a change on the screen
- * so that these pixels will be drawn seperately by doDraw
- * 
- */

Deleted: trunk/src/CacheWolf/TrackPoint.java
===================================================================
--- trunk/src/CacheWolf/TrackPoint.java	2007-09-05 02:06:44 UTC (rev 880)
+++ trunk/src/CacheWolf/TrackPoint.java	2007-09-05 02:08:11 UTC (rev 881)
@@ -1,93 +0,0 @@
-package CacheWolf;
-
-import ewe.fx.Color;
-import ewe.io.BufferedWriter;
-import ewe.io.FileWriter;
-import ewe.io.IOException;
-import ewe.io.PrintWriter;
-import ewe.ui.MessageBox;
-import ewe.util.Utils;
-
-/**
- * this is not CWPoint because it should be as small as possible
- * @author pfeffer
- *
- */
-
-public class TrackPoint  {
-	double latDec;
-	double lonDec;
-	
-	public TrackPoint(){
-		latDec = -91;
-		lonDec = -361;
-	}
-	
-	public TrackPoint(TrackPoint t) {
-		latDec = t.latDec;
-		lonDec = t.lonDec;
-	}
-	public TrackPoint(double lat, double lon) {
-		latDec = lat;
-		lonDec = lon;
-	}
-	public boolean equals(TrackPoint tp) {
-		return latDec == tp.latDec && lonDec == tp.lonDec;
-	}
-
-}
-
-
-class Track {
-	Color trackColor;
-	TrackPoint TrackPoints[];
-	int num;
-	
-	public Track(Color f) {
-		trackColor = f;
-		TrackPoints = new TrackPoint[5000];
-		num = 0;
-	}
-/*===== add is currently not used	
-	public void add(double lat, double lon) {
-		TrackPoints[num] = new TrackPoint(lat, lon);
-		num++;
-	}
-=====*/	
-	/*
-	 * throws IndexOutOfBoundsException when track is full
-	 */
-	public void add(TrackPoint t) { 
-		if (TrackPoints == null || t == null) return;
-		TrackPoints[num] = new TrackPoint(t);
-		num++;
-	}
-/*===== loadTrack/saveTrack are currently not used
-	public void loadTrack(String filename){ // TODO untested!
-		byte [] all = ewe.sys.Vm.readResource(null,filename);
-		if (all == null) return; // TODO error handling
-		num = Utils.readInt(all, 0, 4);
-		for (int i=0; i<=num; i++){
-			TrackPoints[i].latDec = Double.longBitsToDouble(Utils.readLong(all, (i*2)*8 + 4));
-			TrackPoints[i].lonDec = Double.longBitsToDouble(Utils.readLong(all, (i*2+1)*8 + 4));
-		}
-	}
-	
-	public void saveTrack(String filename){  // TODO untested!
-	//ByteArray ba=new ByteArray();
-	byte[] ba = new byte[8*2*num+4]; // 8 bytes is one double int has size 4
-	Utils.writeInt(num, ba, 0, 4);
-	for (int i=0; i<=num; i++){
-		Utils.writeLong(Double.doubleToLongBits(TrackPoints[i].latDec), ba, (i*2)*8 + 4);
-		Utils.writeLong(Double.doubleToLongBits(TrackPoints[i].lonDec), ba, (i*2+1)*8 + 4);
-	}
-	try{
-		PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(filename)));
-		outp.print(ba.toString());
-	}catch (IOException e) {
-		(new MessageBox("Error", "Error reading trackfile:\n"+e.toString(), MessageBox.OKB)).execute();}
-	}
-=====*/
-
-}
-



From pfeffer at mail.berlios.de  Wed Sep  5 04:09:34 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 5 Sep 2007 04:09:34 +0200
Subject: [Cachewolf-svn] r882 - trunk
Message-ID: <200709050209.l8529Yoc006399@sheep.berlios.de>

Author: pfeffer
Date: 2007-09-05 04:09:32 +0200 (Wed, 05 Sep 2007)
New Revision: 882

Modified:
   trunk/compile.bat
   trunk/compile.sh
   trunk/cwberlios.jnf
Log:
necessary changes in bulding tools for last commit. please test, because I don't use them myself

Modified: trunk/compile.bat
===================================================================
--- trunk/compile.bat	2007-09-05 02:08:11 UTC (rev 881)
+++ trunk/compile.bat	2007-09-05 02:09:32 UTC (rev 882)
@@ -1,3 +1,3 @@
 if not exist bin\CacheWolf mkdir bin\CacheWolf
 if not exist bin\exp mkdir bin\exp
-javac -cp ./lib/CompileEwe.zip;./lib/ewesoft.zip;./lib/EwesoftRegex.zip;./lib/HTML.zip;./lib/openmap.jar  -d ./bin/ -deprecation ./src/CacheWolf/*.java ./src/exp/*.java ./src/utils/*.java
+javac -classpath ./lib/CompileEwe.zip;./lib/ewesoft.zip;./lib/EwesoftRegex.zip;./lib/HTML.zip;./lib/openmap.jar  -d ./bin/ -deprecation ./src/CacheWolf/*.java ./src/exp/*.java ./src/utils/*.java ./src/CacheWolf/navi/*.java

Modified: trunk/compile.sh
===================================================================
--- trunk/compile.sh	2007-09-05 02:08:11 UTC (rev 881)
+++ trunk/compile.sh	2007-09-05 02:09:32 UTC (rev 882)
@@ -1,2 +1,2 @@
 #!/bin/sh
-javac -cp ./lib/CompileEwe.zip:./lib/ewesoft.zip:./lib/EwesoftRegex.zip:./lib/HTML.zip:./lib/openmap.jar  -d ./bin/ -deprecation -nowarn  ./src/CacheWolf/*.java ./src/exp/*.java ./src/utils/*.java
+javac -cp ./lib/CompileEwe.zip:./lib/ewesoft.zip:./lib/EwesoftRegex.zip:./lib/HTML.zip:./lib/openmap.jar  -d ./bin/ -deprecation -nowarn  ./src/CacheWolf/*.java ./src/exp/*.java ./src/utils/*.java ./src/CacheWolf/navi/*.java 

Modified: trunk/cwberlios.jnf
===================================================================
--- trunk/cwberlios.jnf	2007-09-05 02:08:11 UTC (rev 881)
+++ trunk/cwberlios.jnf	2007-09-05 02:09:32 UTC (rev 882)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B12M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2%252526%25253DPocketPC%25252B2003%252526%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253DPocketPC%25252B-%25252BMIPS%252526%25253DPocketPC%25252B-%25252BSH3%252526%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&createWithPnf=true&eweInfo=outputFile%3D./work/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/exp%252526ma!
 sk%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253Dexp/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources%252526mask%25253D*.gif;*.png;*.ico;*.tp;*.zip;*.html%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources/%252526mask%25253Dcachewolf.Languages.cfg%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D_config/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./lib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/utils%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253Dutils/%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526!
 vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%252!
 6appletI
nFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B12M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dtrue%26useClassPool%3Dfalse&icon=(Default)
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B12M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2%252526%25253DPocketPC%25252B2003%252526%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253DPocketPC%25252B-%25252BMIPS%252526%25253DPocketPC%25252B-%25252BSH3%252526%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&createWithPnf=true&eweInfo=outputFile%3D./work/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/exp%252526mas!
 k%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253Dexp/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources%252526mask%25253D*.gif;*.png;*.ico;*.tp;*.zip;*.html%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources/%252526mask%25253Dcachewolf.Languages.cfg%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D_config/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./lib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/utils%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253Dutils/%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526v!
 mStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526!
 appletIn
Frame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B12M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dtrue%26useClassPool%3Dfalse&icon=(Default)



From pfeffer at mail.berlios.de  Wed Sep  5 04:11:30 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 5 Sep 2007 04:11:30 +0200
Subject: [Cachewolf-svn] r883 - trunk/src/CacheWolf
Message-ID: <200709050211.l852BU7J006578@sheep.berlios.de>

Author: pfeffer
Date: 2007-09-05 04:11:26 +0200 (Wed, 05 Sep 2007)
New Revision: 883

Removed:
   trunk/src/CacheWolf/map/
Log:
correct a mistake...



From pfeffer at mail.berlios.de  Wed Sep  5 15:31:35 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 5 Sep 2007 15:31:35 +0200
Subject: [Cachewolf-svn] r884 - in trunk/src/CacheWolf: . navi
Message-ID: <200709051331.l85DVZH5004963@sheep.berlios.de>

Author: pfeffer
Date: 2007-09-05 15:31:24 +0200 (Wed, 05 Sep 2007)
New Revision: 884

Added:
   trunk/src/CacheWolf/navi/
   trunk/src/CacheWolf/navi/Area.java
   trunk/src/CacheWolf/navi/CWGPSPoint.java
   trunk/src/CacheWolf/navi/GotoPanel.java
   trunk/src/CacheWolf/navi/Map.java
   trunk/src/CacheWolf/navi/MapDetailForm.java
   trunk/src/CacheWolf/navi/MapImage.java
   trunk/src/CacheWolf/navi/MapInfoObject.java
   trunk/src/CacheWolf/navi/MapLoader.java
   trunk/src/CacheWolf/navi/MapLoaderGui.java
   trunk/src/CacheWolf/navi/MapSymbol.java
   trunk/src/CacheWolf/navi/MapsList.java
   trunk/src/CacheWolf/navi/MovingMap.java
   trunk/src/CacheWolf/navi/Navigate.java
   trunk/src/CacheWolf/navi/SelectMap.java
   trunk/src/CacheWolf/navi/SkyOrientation.java
   trunk/src/CacheWolf/navi/Track.java
   trunk/src/CacheWolf/navi/TrackOverlay.java
   trunk/src/CacheWolf/navi/TrackPoint.java
Log:
I hope, it works now

Added: trunk/src/CacheWolf/navi/Area.java
===================================================================
--- trunk/src/CacheWolf/navi/Area.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/Area.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,74 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+
+public class Area {
+	 public final static int NOT_ON_EDGE = -1;
+	 public final static int AT_TOP_EDGE = 1;
+	 public final static int AT_RIGHT_EDGE = 2;
+	 public final static int AT_BUTTOM_EDGE = 3;
+	 public final static int AT_LEFT_EDGE = 4;
+	 public static double edgeTolerance = 3 * 360/40000000; // approx 3m will be seen as the same
+
+	 CWPoint topleft;
+	 CWPoint buttomright;
+
+	 public Area(CWPoint tl, CWPoint br){
+		 topleft = new CWPoint(tl);
+		 buttomright = new CWPoint(br);
+	 }
+
+	 public boolean isInBound(CWPoint p) {
+		 if (topleft.latDec >= p.latDec && topleft.lonDec <= p.lonDec 
+				 && buttomright.latDec <= p.latDec && buttomright.lonDec >= p.lonDec) return true;
+		 else return false;
+	 }
+	 //if(affine[4] >= lati && lati >= lowlat && affine[5] <= loni && loni <= lowlon) isInBound = true;
+		
+	 public boolean isInBound(double lat, double lon) {
+		 if (topleft.latDec >= lat && topleft.lonDec <= lon
+				 && buttomright.latDec <= lat && buttomright.lonDec >= lon) return true;
+		 else return false;
+	 }
+	 
+	 public boolean isOverlapping(Area a) {
+		 if (       isInBound(a.topleft) || isInBound(a.buttomright) 
+				 || isInBound(a.buttomright.latDec, a.topleft.lonDec) // buttom left
+				 || isInBound(a.topleft.latDec, a.buttomright.lonDec) // top right
+				 // in case this is completly within a, the above tests will give false, so testing the otherway around
+				 || a.isInBound(this.topleft) || a.isInBound(this.buttomright)
+				 || a.isInBound(this.buttomright.latDec, this.topleft.lonDec) // buttom left
+				 || a.isInBound(this.topleft.latDec, this.buttomright.lonDec)) // top right
+			 return true;
+		 else return false;
+	 }
+
+	 public boolean equals(Area a) {
+		 if(java.lang.Math.abs(topleft.latDec - a.topleft.latDec) < edgeTolerance 
+				 && java.lang.Math.abs(topleft.lonDec - a.topleft.lonDec) < edgeTolerance
+				 && java.lang.Math.abs(buttomright.latDec - a.buttomright.latDec) < edgeTolerance
+				 && java.lang.Math.abs(buttomright.lonDec - a.buttomright.lonDec) < edgeTolerance )
+			 return true;
+		 else return false;
+	 }
+	 
+	 public int getEdge(CWPoint tl, CWPoint br) {
+		 if (java.lang.Math.abs(topleft.latDec - br.latDec) < edgeTolerance 
+				 && java.lang.Math.abs(topleft.lonDec - tl.lonDec) < edgeTolerance 
+				 && java.lang.Math.abs(buttomright.lonDec - br.lonDec) < edgeTolerance)
+			 return AT_TOP_EDGE;
+			 if (java.lang.Math.abs(topleft.latDec - tl.latDec) < edgeTolerance 
+					 && java.lang.Math.abs(buttomright.lonDec - tl.lonDec) < edgeTolerance 
+					 && java.lang.Math.abs(buttomright.latDec - br.latDec) < edgeTolerance)
+				 return AT_RIGHT_EDGE;
+			 if (java.lang.Math.abs(topleft.lonDec - tl.lonDec) < edgeTolerance 
+					 && java.lang.Math.abs(buttomright.latDec - tl.latDec) < edgeTolerance 
+					 && java.lang.Math.abs(buttomright.lonDec - br.lonDec) < edgeTolerance)
+				 return AT_BUTTOM_EDGE;
+			 if (java.lang.Math.abs(topleft.latDec - tl.latDec) < edgeTolerance 
+					 && java.lang.Math.abs(topleft.lonDec - br.lonDec) < edgeTolerance 
+					 && java.lang.Math.abs(buttomright.latDec - br.latDec) < edgeTolerance)
+				 return AT_LEFT_EDGE;
+			 return NOT_ON_EDGE;
+	 }
+}
\ No newline at end of file

Added: trunk/src/CacheWolf/navi/CWGPSPoint.java
===================================================================
--- trunk/src/CacheWolf/navi/CWGPSPoint.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/CWGPSPoint.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,336 @@
+/*
+ * Created on 02.04.2005
+ *
+ * TODO To change the template for this generated file go to
+ * Window - Preferences - Java - Code Style - Code Templates
+ */
+package CacheWolf.navi;
+import CacheWolf.CWPoint;
+import CacheWolf.Common;
+import CacheWolf.Extractor;
+import CacheWolf.Global;
+import ewe.sys.*;
+import ewe.ui.ExecTransfer;
+import ewe.io.*;
+
+
+
+/**
+ * @author Kalle
+ * Class for decoding NMEA sentences
+ */
+
+public class CWGPSPoint extends CWPoint implements TimerProc{
+	public static final int LOGNMEA = 0x01;
+	public static final int LOGRAW  = 0x02;
+	public static final int LOGALL  = LOGNMEA|LOGRAW;
+
+	public double Speed; //Speed
+	public double Bear;	//Bearing
+	public String Time; //Time
+	public String Date;
+	public int Fix; //Fix
+	public int numSat; //Satellites in use, -1 indicates no data, -2 that data could not be interpreted
+	public double HDOP; // Horizontal dilution of precision
+	public double Alt; //Altitude
+
+	//Logging
+	int logTimer = 0;
+	int logFlag = 0;
+	boolean writeLog = false;
+	boolean doLogging = false;
+	FileWriter logFile;
+	String lastStrExamined = new String();
+
+
+	public CWGPSPoint()
+	{
+		super();
+		this.Speed = 0;
+		this.Bear = 0;
+		this.Time = "";
+		this.Date="";
+		this.Fix = 0;
+		this.numSat = 0;
+		this.Alt = 0;
+		this.HDOP = 0;
+	}
+
+
+	public double getSpeed(){
+		return this.Speed;
+	}
+
+	public double getBear (){
+		return this.Bear;
+	}
+	public String getTime(){
+		return this.Time;
+	}
+
+	public int getFix(){
+		return this.Fix;
+	}
+
+	/**
+	 * this method should be called, if COM-Port is closed
+	 */
+	public void noData(){
+		this.Fix = 0;
+		this.numSat = 0;
+	}
+
+	/**
+	 * this method should be called, if not data is coming from COM-Port but is expected to come
+	 */
+	public void noDataError(){
+		this.Fix = -1;
+		this.numSat = -1;
+	}
+
+	/**
+	 * this method should be called, if examine returns for several calls that it couldn't interprete the data
+	 */
+	public void noInterpretableData(){
+		this.Fix = -2;
+		this.numSat = -2;
+	}
+
+	public void ticked(int timerId, int elapsed){
+		if (timerId == logTimer) {
+			writeLog = true;
+		}
+
+	}
+
+	/**
+	 * 
+	 * @param logFileDir directory for logfile
+	 * @param seconds	 intervall for writing to logfile
+	 * @param flag		 level of logging
+	 * @return 0 success, -1 failure
+	 */
+	public int startLog(String logFileDir, int seconds, int flag){
+
+		Time currTime = new Time();
+		currTime.getTime();
+		currTime.setFormat("yyyyMMdd'_'HHmm");
+		String logFileName = new String(logFileDir + currTime.toString()+ ".log");
+		// create Logfile
+		try {
+			logFile = new FileWriter(logFileName);
+		} catch (IOException e) {
+			Vm.debug("Error creating LogFile " + logFileName);
+			return -1;
+		} 
+		// start timer
+		logTimer = Vm.requestTimer(this, 1000 * seconds);
+		logFlag = flag;
+		doLogging = true;
+		return 0;
+	}
+
+	public void stopLog() {
+		writeLog = false;
+
+		if (doLogging){
+			try {
+				logFile.close();
+			} catch (IOException e) {}
+			if (logTimer > 0) {
+				Vm.cancelTimer(logTimer);
+				logTimer = 0;
+			}
+		}
+		doLogging = false;
+	}
+
+
+	public int getSats(){
+		return this.numSat;
+	}
+
+	public double getAlt(){
+		return this.Alt;
+	}
+
+	public double getHDOP(){
+		return this.HDOP;
+	}
+
+	/**
+	 * 
+	 * @param NMEA	string with data to examine
+	 * @return true if some data could be interpreted false otherwise
+	 */
+	public boolean examine(String NMEA){ 
+		boolean interpreted = false;
+		try {
+			int i, start, end;
+			String latDeg="0", latMin="0", latNS="N"; 
+			String lonDeg="0", lonMin="0", lonEW="E";
+			String currToken;
+			end = 0;
+			lastStrExamined = NMEA;
+			//Vm.debug(NMEA);
+			if (writeLog && (logFlag & LOGRAW) > 0){ 
+				try {
+					logFile.write(NMEA);
+					writeLog = false;
+				} catch (IOException e) {}
+			}
+			while(true){
+				start = NMEA.indexOf("$GP", end);  
+				if (start == -1) return interpreted;  
+				end = NMEA.indexOf("*", start);  
+				if ((end == -1)||(end+3 > NMEA.length())) return interpreted;  
+
+
+				//Vm.debug(NMEA.substring(start,end+3));
+				if ((end - start) < 15 || !checkSumOK(NMEA.substring(start,end+3))){
+					//Vm.debug("checksum wrong");
+					continue;
+				}
+				Extractor ex = new Extractor ("," + NMEA.substring(start,end), ",",",",0,true);
+				currToken = ex.findNext();
+				if (currToken.equals("$GPGGA")){
+					//Vm.debug("In $GPGGA");
+					i = 0;
+					while(ex.endOfSearch() != true){
+						currToken = ex.findNext();
+						i++;
+						if (currToken.length()==0) continue; // sometimes there are 2 colons directly one after the other like ",," (e.g. loox)
+						switch (i){
+						case 1: this.Time = currToken; break;
+						case 2: try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+						try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+						break;
+						case 3: latNS = currToken;
+						break;
+
+						case 4: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true; } catch (IndexOutOfBoundsException e) {}
+						break;
+						case 5: lonEW = currToken;
+						break;
+						case 6: this.Fix = Convert.toInt(currToken); interpreted = true; break;
+						case 7: this.numSat = Convert.toInt(currToken); interpreted = true; break;
+						case 8: try {this.HDOP = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} break;
+						case 9: try {this.Alt = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} break;
+						} // switch
+					} // while
+					if (Fix > 0) this.set(latNS, latDeg, latMin, "0", lonEW, lonDeg, lonMin, "0", CWPoint.DMM);
+
+				} // if
+
+				if (currToken.equals("$GPVTG")){
+					i = 0;
+					while(ex.endOfSearch() != true){
+						currToken = ex.findNext();
+						i++;
+						if (currToken.length()==0) continue;
+						switch (i){
+						case 1: try { this.Bear =Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {}
+						if (this.Bear > 360) Vm.debug("Error bear VTG");
+						break;
+						case 7: try { this.Speed = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} 
+						break;
+						} // switch
+					} // while
+				} // if
+
+				if (currToken.equals("$GPRMC")){
+					//Vm.debug("In $GPRMC");
+					i = 0;
+					String status = "V";
+					while(ex.endOfSearch() != true){
+						currToken = ex.findNext();
+						i++;
+						if (currToken.length()==0) continue;
+						//Vm.debug("zz: " + i);
+						//Vm.debug(currToken);
+						switch (i){
+						case 1: this.Time = currToken; interpreted = true; break;
+						case 2: status = currToken; 
+						if (status.equals("A")) this.Fix = 1;
+						else this.Fix = 0;
+						interpreted = true;
+						break;
+						case 3: 	//Vm.debug("Here--->");
+							try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+							//Vm.debug(":" + latDeg);
+							try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+							//Vm.debug(":" + latMin);
+							break;
+						case 4: latNS = currToken; interpreted = true;
+						break;
+						case 5: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+						break;
+						case 6: lonEW = currToken;
+						interpreted = true;
+						break;
+						case 7: if (status.equals("A")){
+							try {this.Speed = Common.parseDouble(currToken)*1.854;
+							interpreted = true; } catch (NumberFormatException e) { }
+						}
+						break;
+						case 8: if (status.equals("A") && currToken.length()> 0){
+							try {this.Bear = Common.parseDouble(currToken);
+							interpreted = true; } catch (NumberFormatException e) { }
+						}
+						break;
+						case 9: if (status.equals("A") && currToken.length()> 0){
+							try {this.Date = currToken;
+							interpreted = true; } catch (NumberFormatException e) { }
+						}
+						break;
+						} // switch
+					} // while
+					if (status.equals("A")){
+						this.set(latNS, latDeg, latMin, "0",
+								lonEW, lonDeg, lonMin, "0", CWPoint.DMM);				
+					}
+				} // if
+				//Vm.debug("End of examine");
+			} //while
+		} catch (Exception e) {
+			Global.getPref().log("Exception in examine in CWGPSPoint", e, true);
+			e.printStackTrace();
+			return interpreted;
+		}
+	}
+
+	private boolean checkSumOK(String nmea){
+		int startPos = 1; // begin after $
+		int endPos = nmea.length() - 3;// without * an two checksum chars
+		byte checkSum = 0;
+
+		for (int i= startPos; i<endPos;i++){
+			checkSum ^= nmea.charAt(i);
+		}
+		//Vm.debug(nmea.substring(3,6)+" Checksum: " + nmea.substring(endPos+1) + " Calculated: " + Convert.intToHexString(checkSum));
+		try { return (checkSum == Byte.parseByte(nmea.substring(endPos+1),16));
+		} catch (IndexOutOfBoundsException e) {
+			return false;
+		} catch (NumberFormatException e) {
+			return false;
+		}
+	}
+
+
+
+	public void printAll(){
+		Vm.debug("Latitude:  " + this.getLatDeg(DD));
+		Vm.debug("Longitude: " + this.getLonDeg(DD));
+		Vm.debug("Speed:     " + this.Speed);
+		Vm.debug("Bearing:   " + this.Bear);
+		Vm.debug("Time:      " + this.Time);
+		Vm.debug("Fix:       " + this.Fix);
+		Vm.debug("Sats:      " + this.numSat);
+		Vm.debug("HDOP:      " + this.HDOP);
+		Vm.debug("Alt:       " + this.Alt);
+		Vm.debug("----------------");
+	}
+}
+

Added: trunk/src/CacheWolf/navi/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/navi/GotoPanel.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/GotoPanel.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,847 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.CacheHolder;
+import CacheWolf.CoordsScreen;
+import CacheWolf.DetailsPanel;
+import CacheWolf.Global;
+import CacheWolf.MainTab;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+import CacheWolf.Profile;
+import ewe.ui.*;
+import ewe.util.Vector;
+import ewe.util.mString;
+import ewe.fx.*;
+import ewe.graphics.AniImage;
+import ewe.io.*;
+import ewe.net.Socket;
+//import ewe.io.IOException;
+//import ewe.io.SerialPort;
+//import ewe.io.SerialPortOptions;
+import ewe.sys.*;
+import ewe.sys.Double;
+
+/**
+ *	Class to create the panel which handles the connection to the GPS-device<br>
+ *	Displays: current position,speed and bearing; relation to destination waypoint<br>
+ *	Class ID: 1500
+ */
+
+
+public class GotoPanel extends CellPanel {
+
+	//public CWGPSPoint gpsPosition = new CWGPSPoint();
+	//public CWPoint toPoint = new CWPoint();
+	public Navigate myNavigation;
+	mButton btnGPS, btnCenter,btnSave;
+	mButton btnGoto, btnMap;
+	int currFormat;
+
+	mLabel lblGPS, lblPosition, lblDST;
+	mLabel lblLog;
+	Color gpsStatus;
+	mCheckBox chkLog;
+	mInput inpLogSeconds;
+
+	MainTab mainT;
+	Vector cacheDB;
+	DetailsPanel detP;
+
+	Preferences pref;
+	Profile profile;
+	// different panels to avoid spanning
+	CellPanel ButtonP = new CellPanel();
+	CellPanel CoordsP = new CellPanel();
+	CellPanel roseP = new CellPanel();
+	CellPanel LogP = new CellPanel();
+
+	ImageControl icRose;
+	GotoRose compassRose;
+
+	final static Color RED = new Color(255,0,0);
+	final static Color YELLOW = new Color(255,255,0);
+	final static Color GREEN = new Color(0,255,0);
+	final static Color BLUE = new Color(0,0,255);
+
+	final static Font BOLD = new Font("Arial", Font.BOLD, 14);
+
+	int ticker = 0;
+	
+	Menu mnuContextFormt;
+	MenuItem miDMM, miDMS, miDD, miUTM;
+	
+	Menu mnuContextRose;
+	MenuItem miLuminary[] = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
+	MenuItem miNorthCentered;
+	
+	/**
+	 * Create GotoPanel 
+	 * @param Preferences 	global preferences
+	 * @param MainTab		reference to MainTable
+	 * @param DetailsPanel 	reference to DetailsPanel
+	 * @param Vector		cacheDB
+	 */
+	public GotoPanel(Navigate nav) {
+		myNavigation = nav;
+		pref = Global.getPref();
+		profile=Global.getProfile();
+		mainT = Global.mainTab;
+		detP = mainT.detP;
+		cacheDB = profile.cacheDB;
+
+		// Button
+		ButtonP.addNext(btnGPS = new mButton("Start"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addNext(btnCenter = new mButton(MyLocale.getMsg(309,"Center")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addNext(btnSave = new mButton(MyLocale.getMsg(311,"Create Waypoint")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addLast(btnMap = new mButton("Map"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+
+		//Format selection for coords		
+		//context menu
+		mnuContextFormt = new Menu();
+		mnuContextFormt.addItem(miDD = new MenuItem("d.d?"));
+		miDD.modifiers &= ~MenuItem.Checked;
+		mnuContextFormt.addItem(miDMM = new MenuItem("d?m.m\'"));
+		miDMM.modifiers |= MenuItem.Checked;
+		mnuContextFormt.addItem(miDMS = new MenuItem("d?m\'s\""));
+		miDMS.modifiers &= ~MenuItem.Checked;
+		mnuContextFormt.addItem(miUTM = new MenuItem("UTM"));
+		miUTM.modifiers &= ~MenuItem.Checked;
+		currFormat = CWPoint.DMM;
+
+		// Create context menu for compass rose: select luminary for orientation
+		mnuContextRose = new Menu();
+		for (int i=0; i<SkyOrientation.LUMINARY_NAMES.length; i++) {
+			mnuContextRose.addItem(miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i)));
+			if (i == myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
+			else miLuminary[i].modifiers &= MenuItem.Checked;
+		}
+
+		//Coords
+		CoordsP.addNext(lblGPS = new mLabel("GPS: "),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		lblGPS.backGround = RED;
+		lblGPS.setMenu(mnuContextFormt);
+		lblGPS.modifyAll(Control.WantHoldDown, 0);
+		CoordsP.addLast(lblPosition = new mLabel(myNavigation.gpsPos.toString(currFormat)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		lblPosition.setMenu(mnuContextFormt);
+		lblPosition.modifyAll(Control.WantHoldDown, 0);
+		CoordsP.addNext(lblDST = new mLabel(MyLocale.getMsg(1500,"DST:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		lblDST.backGround = new Color(0,0,255);
+		lblDST.setMenu(mnuContextFormt);
+		lblDST.modifyAll(Control.WantHoldDown, 0);
+		CoordsP.addLast(btnGoto = new mButton(getGotoBtnText()),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+
+		//Rose for bearing
+		compassRose = new GotoRose("rose.png");
+		icRose = new ImageControl(compassRose);
+		icRose.setMenu(mnuContextRose);
+		icRose.modifyAll(Control.WantHoldDown, 0); // this is necessary in order to make PenHold on a PDA work as right click
+		roseP.addLast(icRose,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTH));
+		
+		mnuContextRose.addItem(new MenuItem("", MenuItem.Separator, null));
+		mnuContextRose.addItem(miNorthCentered = new MenuItem(MyLocale.getMsg(1503,"North Centered")));
+		if (compassRose.isNorthCentered()) miNorthCentered.modifiers |= MenuItem.Checked;
+		else miNorthCentered.modifiers &= MenuItem.Checked;
+
+		//log
+		LogP.addNext(lblLog = new mLabel("Log "),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		LogP.addNext(chkLog = new mCheckBox(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		LogP.addNext(inpLogSeconds = new mInput("10"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		LogP.addLast(new mLabel("sec"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+
+		chkLog.useCross = true;
+		chkLog.setState(false);
+		inpLogSeconds.columns = 5;
+
+		//add Panels
+		this.addLast(ButtonP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
+		this.addLast(CoordsP,CellConstants.HSTRETCH, CellConstants.HFILL|CellConstants.NORTH).setTag(SPAN,new Dimension(2,1));
+		this.addLast(roseP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
+		//this.addLast(LogP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.NORTHWEST).setTag(SPAN,new Dimension(1,1));
+
+		// for debuging
+		/*		CWGPSPoint myGPS;
+		myGPS = new CWGPSPoint();
+		String ex = new String();
+		boolean test = false;
+		try { FileReader f = new FileReader("c:\\kw\\20060928_1051.log");
+		ex = f.readAll();
+		test = myGPS.examine(ex);
+		f.close();
+		} catch (IOException e ) {
+			Vm.debug(e.toString());
+		}
+		test = myGPS.examine("$GPGLL,5226.8935,N,01338.5327,E,084635.00,A,D*6E");
+		test = myGPS.examine("$GPGSA,A,3,10,28,26,29,09,,,,,,,,04.1,02.6,03.2*0F");
+		test = myGPS.examine("$GPGSV,4,1,13,08,40,072,28,10,29,201,47,27,15,079,29,28,62,102,44*7E");
+		test = myGPS.examine("$GPGSV,4,2,13,29,72,289,38,26,63,296,41,09,12,259,35,18,14,324,*79");
+		test = myGPS.examine("$GPGSV,4,3,13,19,09,025,,17,06,138,,21,06,300,,37,29,171,40*7A");
+		test = myGPS.examine("$GPGSV,4,4,13,39,29,166,38*40");
+		 */
+
+		//while (true){
+//		int notinterpreted = 0;
+//		if (myGPS.examine("@??H @??H?@??HH???????H")) { notinterpreted = 0;} else notinterpreted++;
+//		if (notinterpreted > 5) myGPS.noInterpretableData();
+//		// myGPS.noInterpretableData();
+
+
+//		}	
+	}
+
+
+	/**
+	 * set the coords of the destination  
+	 * @param dest destination
+	 */ 
+	public void setDestination(CWPoint dest){
+		myNavigation.setDestination(dest);
+		if (!myNavigation.destination.isValid()) (new MessageBox("Error", "Coordinates are out of range: \n"+"latitude: "+myNavigation.destination.latDec+"\n longditue: "+myNavigation.destination.lonDec, MessageBox.OKB)).execute();
+		
+	}
+	
+	public void destChanged(CWPoint d) { // called from myNavigate
+		btnGoto.setText(getGotoBtnText());
+		updateDistance();
+	}
+	
+
+	/**
+	 * set the coords of the destination and switch to gotoPanel  
+	 * @param LatLon destination
+	 */ 
+	public void setDestinationAndSwitch(String LatLon) {
+		myNavigation.setDestination(LatLon);
+		mainT.select(this);
+	}
+	
+	/**
+	 * updates distance and bearing
+	 *
+	 */
+	
+	public void updateDistance() {
+		//update distance
+		float distance = -1.0f;
+		if (myNavigation.gpsPos.isValid() && myNavigation.destination.isValid() ) {
+			distance = (float)myNavigation.gpsPos.getDistance(myNavigation.destination);
+		}
+		compassRose.setWaypointDirectionDist((float)myNavigation.gpsPos.getBearing(myNavigation.destination), distance);
+	}
+
+	/**
+	 * method which is called if a timer is set up  
+	 */ 
+	public void updateGps(int fix) {
+		Double bearMov = new Double();
+		Double speed = new Double();
+		Double sunAzimut = new Double();
+		Vm.debug("ticked: voher");
+		compassRose.setGpsStatus(fix, myNavigation.gpsPos.getSats(), myNavigation.gpsPos.getHDOP());
+		if ((fix > 0) && (myNavigation.gpsPos.getSats()>= 0)) {
+			// display values only, if signal good
+			//Vm.debug("currTrack.add: nachher");
+			lblPosition.setText(myNavigation.gpsPos.toString(currFormat));
+			sunAzimut.set(myNavigation.skyOrientationDir.lonDec);
+			bearMov.set(myNavigation.gpsPos.getBear());
+			updateDistance();
+			compassRose.setSunMoveDirections((float)sunAzimut.value, (float)bearMov.value, (float)speed.value);
+			// Set background to signal quality
+		}
+
+		// receiving data, but signal ist not good
+		if ((fix == 0) && (myNavigation.gpsPos.getSats()>= 0)) {
+			gpsStatus = YELLOW;
+		}
+		// receiving no data
+		if (fix == -1) {
+			if (gpsStatus != RED) (new MessageBox("Error", "No data from GPS\nConnection to serial port closed",MessageBox.OKB)).exec();
+			gpsStatus = RED;
+			myNavigation.stopGps();
+		}
+		// cannot interprete data
+		if (fix == -2) {
+			if (gpsStatus != RED) (new MessageBox("Error", "Cannot interpret data from GPS\n possible reasons:\n wrong Port,\n wrong Baudrate,\n not NMEA-Protocol\nConnection to serial port closed\nLast String tried to interprete:\n "+myNavigation.gpsPos.lastStrExamined, MessageBox.OKB)).exec();
+			gpsStatus = RED;
+			myNavigation.stopGps(); // TODO automatic in myNavigate?
+		}
+	}
+
+	public void gpsStarted() {
+		chkLog.modify(ControlConstants.Disabled,0);
+		btnGPS.setText("Stop");
+	}
+	
+	public void startGps() {
+		myNavigation.setRawLogging(chkLog.getState(), Convert.toInt(inpLogSeconds.getText()));
+		myNavigation.startGps();
+	}
+
+	public void gpsStoped() {
+		btnGPS.setText("Start");
+		gpsStatus = this.backGround;
+		chkLog.modify(0,ControlConstants.Disabled);
+		this.repaintNow(); // without this the change in the background color will not be displayed
+	}
+
+	
+	private String getGotoBtnText() {
+		if (myNavigation.destination == null) return "not set";
+		else return myNavigation.destination.toString(currFormat);
+	}
+	
+	public void switchToMovingMap() {
+		CWPoint centerTo;
+		if (myNavigation.isGpsPosValid()) centerTo = new CWPoint(myNavigation.gpsPos); // set gps-pos if gps is on
+		else {
+			// setze Zielpunkt als Ausgangspunkt, wenn GPS aus ist und lade entsprechende Karte
+			//centerTo = new CWPoint(myNavigation.destination);
+			if (myNavigation.destination.isValid())	centerTo = new CWPoint(myNavigation.destination);
+			else centerTo = new CWPoint(pref.curCentrePt); // if not goto-point defined move map to centere point
+		}  
+		mainT.SwitchToMovingMap(centerTo, false);
+	}
+	
+	/**
+	 * Eventhandler
+	 */
+
+	public void onEvent(Event ev){
+		if (ev instanceof MenuEvent) { 
+			if (ev.type == MenuEvent.SELECTED ) {
+				MenuItem action = (MenuItem) mnuContextFormt.getSelectedItem(); 
+				if (action != null) {
+					if (action == miDD) {
+						mnuContextFormt.close();
+						currFormat = CWPoint.DD;
+					}
+					if (action == miDMM) {
+						mnuContextFormt.close();
+						currFormat = CWPoint.DMM;
+					}
+					if (action == miDMS) {
+						mnuContextFormt.close();
+						currFormat = CWPoint.DMS;
+					}
+					if (action == miUTM) {
+						mnuContextFormt.close();
+						currFormat = CWPoint.UTM;
+					}
+					miDD.modifiers &= ~MenuItem.Checked;
+					miDMM.modifiers &= ~MenuItem.Checked;
+					miDMS.modifiers &= ~MenuItem.Checked;
+					miUTM.modifiers &= ~MenuItem.Checked;
+					switch (currFormat) {
+					case CWPoint.DD: miDD.modifiers |= MenuItem.Checked; break;   
+					case CWPoint.DMM: miDMM.modifiers |= MenuItem.Checked; break;   
+					case CWPoint.DMS: miDMS.modifiers |= MenuItem.Checked; break;   
+					case CWPoint.UTM: miUTM.modifiers |= MenuItem.Checked; break;
+					}
+
+					lblPosition.setText(myNavigation.gpsPos.toString(currFormat));
+					btnGoto.setText(getGotoBtnText());
+				} // end lat-lon-format context menu
+				action = (MenuItem) mnuContextRose.getSelectedItem();
+				if (action != null) {
+					for (int i=0; i<miLuminary.length; i++) {
+						if (action == miLuminary[i]) {
+							myNavigation.setLuminary(i);
+							miLuminary[i].modifiers |= MenuItem.Checked;
+							compassRose.setLuminaryName(SkyOrientation.getLuminaryName(myNavigation.luminary));
+						} else miLuminary[i].modifiers &= ~MenuItem.Checked;
+					}
+					if (action == miNorthCentered) {
+						if (compassRose.isNorthCentered()) {
+							compassRose.setNorthCentered(false);
+							miNorthCentered.modifiers &= ~MenuItem.Checked;							
+						}
+						else
+						{
+							compassRose.setNorthCentered(true);
+							miNorthCentered.modifiers |= MenuItem.Checked;
+						}
+					}
+				}
+			}
+		}
+
+		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+			// start/stop GPS connection
+			if (ev.target == btnGPS){
+				if (btnGPS.getText().equals("Start")) startGps();
+				else myNavigation.stopGps();
+			}
+
+			// set current position as center and recalculate distance of caches in MainTab 
+			if (ev.target == btnCenter){
+				Vm.showWait(true);
+				pref.curCentrePt.set(myNavigation.gpsPos);
+				mainT.updateBearDist();
+				Vm.showWait(false);
+			}
+			//Start moving map
+			if (ev.target == btnMap){
+				switchToMovingMap();
+			} 
+			// create new waypoint with current GPS-position
+			if (ev.target == btnSave){
+				CacheHolder ch = new CacheHolder();
+				ch.LatLon = myNavigation.gpsPos.toString();
+				ch.pos = new CWPoint(myNavigation.gpsPos);
+				mainT.newWaypoint(ch);
+			}
+			// change destination waypoint
+			if (ev.target == btnGoto){
+				CoordsScreen cs = new CoordsScreen();
+				if (myNavigation.destination.isValid())	cs.setFields(myNavigation.destination, currFormat);
+				else cs.setFields(new CWPoint(0,0), currFormat);
+				if (cs.execute(null, Gui.TOP) == CoordsScreen.IDOK)
+					setDestination(cs.getCoords());
+			}
+		}
+		super.onEvent(ev);
+	}
+}
+
+/** class for displaying the compass rose
+ * including goto, sun and moving direction
+ */
+class GotoRose extends AniImage {
+	float gotoDir = -361;
+	float sunDir = -361;
+	float moveDir = -361;
+	float distance = -1;
+	
+	int m_fix = -1;
+	int m_sats = -1;
+	double m_hdop = -1;
+	float m_speed = -1;
+	
+	String m_Luminary = MyLocale.getMsg(6100, "Sun");
+	
+	FontMetrics fm;
+	
+	boolean northCentered = Global.getPref().northCenteredGoto;
+	
+	final static Color RED = new Color(255,0,0);
+	final static Color YELLOW = new Color(255,255,0);
+	final static Color GREEN = new Color(0,255,0);
+	final static Color BLUE = new Color(0,0,255);
+	final static Color ORANGE = new Color(255,128,0);
+	final static Color DARKGREEN = new Color(0,192,0);
+	final static Color CYAN = new Color(0,255,255);
+	final static Color MAGENTA = new Color(255,0,255);
+
+	/**
+	 * @param gd goto direction
+	 * @param sd sun direction
+	 * @param md moving direction
+	 */
+	public GotoRose(String fn){
+		super(fn);
+	}
+	
+	public void setWaypointDirectionDist(float wd, float dist) {
+		gotoDir = wd;
+		distance = dist;
+	}
+	
+	public void setSunMoveDirections(float sd, float md, float speed ) {
+		sunDir = sd;
+		moveDir = md;
+		m_speed = speed;
+		refresh();
+	}
+	
+	public void setGpsStatus(int fix, int sats, double hdop) {
+		m_fix = fix;
+		m_sats = sats;
+		m_hdop = hdop;
+		refresh();
+	}
+	
+	public void setLuminaryName(String Luminary) {
+		m_Luminary = Luminary;
+		refresh();
+	}
+
+	
+	/**
+	 * draw arrows for the directions of movement and destination waypoint
+	 * @param ctrl the control to paint on
+	 * @param moveDir degrees of movement
+	 * @param destDir degrees of destination waypoint
+	 */
+	
+	public void doDraw(Graphics g,int options) {
+		if (northCentered) {
+			super.doDraw(g, options);
+		}
+		else {
+			g.setColor(Color.White);
+			g.fillRect(0, 0, location.width, location.height);
+		}
+		Font font = new Font("Verdana", Font.BOLD, 12);
+		g.setFont(font);
+		fm = g.getFontMetrics(font);
+		drawArrows(g);
+		drawWayPointData(g);
+		drawGpsData(g);
+		drawLuminaryData(g);
+		drawGpsStatus(g);
+	}
+		
+	private void drawWayPointData(Graphics g){
+		String strTemp = "WayPoint";
+		g.setColor(Color.DarkBlue);
+		g.fillRect(0, 0, fm.getTextWidth(strTemp) + 4 ,fm.getHeight());
+		g.setColor(Color.White);		
+		g.drawText(strTemp, 2, 0);
+		
+		g.setColor(Color.Black);		
+		
+		Double tmp = new Double();
+		strTemp = "";
+		if ( distance >= 0.0f ) {
+			tmp.set(distance);
+			if (tmp.value >= 1){
+				strTemp = MyLocale.formatDouble(tmp,"0.000")+ " km";
+			}
+			else {
+				tmp.set(tmp.value * 1000);
+				strTemp = tmp.toString(3,0,0) + " m";
+			}
+		}
+		else strTemp = "--- km";
+		g.drawText(strTemp, 2, 12);
+		
+		tmp.set(gotoDir);
+		if ((tmp.value <= 360) && (tmp.value >= -360))
+			strTemp = tmp.toString(0,0,0) + " " + MyLocale.getMsg(1502,"deg");
+		else strTemp = "---" + " " + MyLocale.getMsg(1502,"deg");
+		g.drawText(strTemp, 2, 24);
+	}
+	
+	private void drawGpsData(Graphics g){
+		g.setColor(RED);
+		
+		String strHeadline = MyLocale.getMsg(1501,"Current");
+		
+		Double tmp = new Double();
+
+		tmp.set(m_speed);
+		String strSpeed = "- km/h";
+		if (m_speed >= 0) {
+			if (m_speed >= 100) {
+				strSpeed = MyLocale.formatDouble(tmp,"0") + " km/h";				
+			}
+			else {
+				strSpeed = MyLocale.formatDouble(tmp,"0.0") + " km/h";
+			}
+		}
+		
+		tmp.set(moveDir);
+		String strMoveDir = "---" + " " + MyLocale.getMsg(1502,"deg");
+		if ((tmp.value <= 360) && (tmp.value >= -360))
+			strMoveDir = tmp.toString(0,0,0) + " " + MyLocale.getMsg(1502,"deg");
+
+		int textWidth = java.lang.Math.max(fm.getTextWidth(strSpeed), fm.getTextWidth(strMoveDir));
+		textWidth = java.lang.Math.max(textWidth, fm.getTextWidth(strHeadline));
+		
+		int startX = location.width - (textWidth + 4);
+		g.fillRect(startX, 0, location.width - startX ,12);
+		
+		g.setColor(Color.Black);		
+		g.drawText(strHeadline, startX + 2, 0);		
+		g.drawText(strSpeed, startX + 2, 12);
+		g.drawText(strMoveDir, startX + 2, 24);
+	}
+	
+	private void drawLuminaryData(Graphics g){
+		g.setColor(YELLOW);
+
+		String strSunDir = "---" + " " + MyLocale.getMsg(1502,"deg");
+		if (sunDir < 360 && sunDir > -360) {
+			Double tmp = new Double();
+			tmp.set(sunDir);
+			strSunDir = tmp.toString(0,0,0) + " " + MyLocale.getMsg(1502,"deg");
+		}
+
+		int textWidth = java.lang.Math.max(fm.getTextWidth(m_Luminary), fm.getTextWidth(strSunDir));
+		int startY = location.height - 24;
+		g.fillRect(0, startY, textWidth + 4, location.height - startY);
+
+		g.setColor(Color.Black);		
+		g.drawText(m_Luminary, 2, startY);
+		g.drawText(strSunDir, 2, startY + 12);
+	}
+	
+	private void drawGpsStatus(Graphics g){
+		if ((m_fix > 0) && (m_sats >= 0)) {
+			// Set background to signal quality
+			g.setColor(GREEN);
+		}
+		else
+		// receiving data, but signal ist not good
+		if ((m_fix == 0) && (m_sats >= 0)) {
+			g.setColor(YELLOW);
+		}
+		else {
+			g.setColor(RED);
+		}
+
+		String strSats = "Sats: -";
+		if (m_sats >= 0) strSats = "Sats: " + Convert.toString(m_sats);
+		String strHdop = "HDOP: -";
+		if (m_hdop >= 0) strHdop = "HDOP: " + Convert.toString(m_hdop);
+
+		int textWidth = java.lang.Math.max(fm.getTextWidth(strSats), fm.getTextWidth(strHdop));
+		int startX = location.width - (textWidth + 4);
+		int startY = location.height - 24;
+		g.fillRect(startX, startY, location.width - startX ,location.height - startY);
+
+		g.setColor(Color.Black);
+		g.drawText(strSats, startX + 2, startY);
+		g.drawText(strHdop, startX + 2, startY + 12);
+	}
+
+	private void drawArrows(Graphics g){
+		if (g != null)
+		{
+			// select moveDirColor according to difference to gotoDir
+			Color moveDirColor = RED;
+			
+			if (gotoDir < 360 && gotoDir > -360 && moveDir < 360 && moveDir > -360)
+			{
+				float diff = java.lang.Math.abs(moveDir - gotoDir);
+				while (diff > 360)
+				{
+					diff -= 360.0f;
+				}
+				if (diff > 180.0f)
+				{
+					diff = 360.0f - diff;
+				}
+				
+				if (diff <= 12.25f)
+				{
+					moveDirColor = GREEN;
+				}
+				else if (diff <= 22.5f)
+				{
+					moveDirColor = CYAN;
+				}
+				else if (diff <= 45.0f)
+				{
+					moveDirColor = ORANGE;
+				}
+				else if (diff <= 90.0f)
+				{
+					moveDirColor = MAGENTA;
+				}
+			}
+
+			// draw only valid arrows
+			if (northCentered) {
+				if (gotoDir < 360 && gotoDir > -360) drawThickArrow(g, gotoDir, Color.DarkBlue, 1.0f);
+				if (moveDir < 360 && moveDir > -360) drawThinArrow(g, moveDir, RED, moveDirColor, 1.0f);
+				if (sunDir < 360 && sunDir > -360) drawSunArrow(g, sunDir, YELLOW, 0.75f);
+			}
+			else {
+				//moveDir centered
+				int radius = (int)((float)(java.lang.Math.min(location.width, location.height) / 2) * 0.75f);
+
+				g.setPen(new Pen(new Color(150,150,150),Pen.SOLID,3));
+				g.drawEllipse(location.width/2 - radius, location.height/2 - radius, 2 * radius, 2 * radius );
+
+				if (moveDir < 360 && moveDir > -360) {
+					//drawDoubleArrow(g, 360 - moveDir, BLUE, new Color(175,0,0), 1.0f);
+					drawRose(g, 360 - moveDir, new Color(100,100,100), new Color(200,200,200), 1.0f);
+					
+					g.setPen(new Pen(RED,Pen.SOLID,3));
+					g.drawLine(location.width/2, location.height/2 - radius, location.width/2, location.height/2 + radius);
+					
+					if (gotoDir < 360 && gotoDir > -360) drawThinArrow(g, gotoDir - moveDir, Color.DarkBlue, moveDirColor, 1.0f);
+					if (sunDir < 360 && sunDir > -360) drawSunArrow(g, sunDir - moveDir, YELLOW, 0.75f);					
+				}				
+			}
+		}
+	}
+
+	/**
+	 * draw single arrow 
+	 * @param g handle for drawing
+	 * @param angle angle of arrow
+	 * @param col color of arrow
+	 */
+	private void drawSimpleArrow(Graphics g, float angle, Color col, float scale) {
+		float angleRad;
+		int x, y, centerX = location.width/2, centerY = location.height/2;
+		int arrowLength = java.lang.Math.min(centerX, centerY); 
+
+		angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		x = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad) * scale).intValue();
+		y = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad) * scale).intValue();
+		g.setPen(new Pen(col,Pen.SOLID,3));
+		g.drawLine(centerX,centerY,x,y);
+	}
+	
+	private void drawSunArrow(Graphics g, float angle, Color col, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = location.width/2, centerY = location.height/2;
+		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
+		float halfArrowWidth = arrowLength * 0.08f;
+		float circlePos = arrowLength * 0.7f;
+		int circleRadius = (int)(arrowLength * 0.1f);
+
+		int pointX = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		int pointY = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		int circleX = centerX + new Float(circlePos * java.lang.Math.sin(angleRad)).intValue();
+		int circleY = centerY - new Float(circlePos * java.lang.Math.cos(angleRad)).intValue();
+
+		int[] pointsX = new int[4];
+		int[] pointsY = new int[4];
+
+		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[1] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsY[1] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
+		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
+		pointsX[3] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		pointsY[3] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		
+//		g.setPen(new Pen(col,Pen.SOLID,3));
+//		g.drawLine(centerX,centerY,pointX,pointY);
+		
+		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setBrush(new Brush(col, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 4);
+		g.fillEllipse(circleX - circleRadius, circleY - circleRadius, 2 * circleRadius, 2 * circleRadius);
+	}
+	
+	private void drawThinArrow(Graphics g, float angle, Color col, Color colPoint, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = location.width/2, centerY = location.height/2;
+		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
+		float halfOpeningAngle = (float)(java.lang.Math.PI * 0.03);
+		float sideLineLength = arrowLength * 0.75f;
+		
+		int[] pointsX = new int[4];
+		int[] pointsY = new int[4];
+
+		pointsX[0] = centerX + new Float(sideLineLength * java.lang.Math.sin(angleRad - halfOpeningAngle)).intValue();
+		pointsY[0] = centerY - new Float(sideLineLength * java.lang.Math.cos(angleRad - halfOpeningAngle)).intValue();
+		pointsX[1] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[1] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[2] = centerX + new Float(sideLineLength * java.lang.Math.sin(angleRad + halfOpeningAngle)).intValue();
+		pointsY[2] = centerY - new Float(sideLineLength * java.lang.Math.cos(angleRad + halfOpeningAngle)).intValue();
+		pointsX[3] = centerX;
+		pointsY[3] = centerY;
+		
+		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setBrush(new Brush(col, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 4);
+		if (colPoint != null) {
+			g.setBrush(new Brush(colPoint, Brush.SOLID));
+			g.fillPolygon(pointsX, pointsY, 3);			
+		}
+	}
+	
+	private void drawDoubleArrow(Graphics g, float angle, Color colFront, Color colRear, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = location.width/2, centerY = location.height/2;
+		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
+		float halfArrowWidth = arrowLength * 0.1f;
+		
+		int[] pointsX = new int[3];
+		int[] pointsY = new int[3];
+
+		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[1] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsY[1] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		
+		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setBrush(new Brush(colFront, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 3);
+		
+		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
+		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
+		
+		g.setBrush(new Brush(colRear, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 3);
+	}
+	
+	private void drawRose(Graphics g, float angle, Color colFront, Color colRear, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = location.width/2, centerY = location.height/2;
+		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
+		float halfArrowWidth = arrowLength * 0.12f;
+		
+		int[] pointsX = new int[8];
+		int[] pointsY = new int[8];
+
+		pointsX[0] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 4.0)).intValue();
+		pointsY[0] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 4.0)).intValue();
+		pointsX[1] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[1] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 4.0)).intValue();
+		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 4.0)).intValue();
+		pointsX[3] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsY[3] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsX[4] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + 3.0 * java.lang.Math.PI / 4.0)).intValue();
+		pointsY[4] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + 3.0 * java.lang.Math.PI / 4.0)).intValue();
+		pointsX[5] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
+		pointsY[5] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
+		pointsX[6] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - 3.0 * java.lang.Math.PI / 4.0)).intValue();
+		pointsY[6] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - 3.0 * java.lang.Math.PI / 4.0)).intValue();
+		pointsX[7] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		pointsY[7] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		
+		g.setPen(new Pen(colRear,Pen.SOLID,1));
+		g.setBrush(new Brush(colRear, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 8);
+		
+		g.setBrush(new Brush(colFront, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 3);
+	}
+	
+	private void drawThickArrow(Graphics g, float angle, Color col, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = location.width/2, centerY = location.height/2;
+		float arrowLength = (float)java.lang.Math.min(centerX, centerY) * scale;
+		float halfArrowWidth = arrowLength * 0.1f;
+		
+		int[] pointsX = new int[4];
+		int[] pointsY = new int[4];
+
+		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[1] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsY[1] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
+		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
+		pointsX[3] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		pointsY[3] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		
+		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setBrush(new Brush(col, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 4);
+	}
+	
+	public void setNorthCentered(boolean nc) {
+		northCentered = nc;
+		if (northCentered != Global.getPref().northCenteredGoto) {
+			Global.getPref().northCenteredGoto = northCentered;
+			Global.getPref().savePreferences();
+		}
+		refresh();
+	}
+	
+	public boolean isNorthCentered() {
+		return northCentered;
+	}
+}

Added: trunk/src/CacheWolf/navi/Map.java
===================================================================
--- trunk/src/CacheWolf/navi/Map.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/Map.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,500 @@
+package CacheWolf.navi;
+
+import ewe.util.*;
+import ewe.io.*;
+import ewe.filechooser.*;
+import ewe.sys.*;
+import ewe.ui.*;
+import ewe.graphics.*;
+import ewe.fx.*;
+
+import CacheWolf.CWPoint;
+import CacheWolf.Common;
+import CacheWolf.CoordsScreen;
+import CacheWolf.Global;
+import CacheWolf.InfoBox;
+import CacheWolf.Matrix;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+
+import com.stevesoft.ewe_pat.*;
+
+/**
+ *	This class is the main class for mapping,
+ *	 (moving map, georeferencing maps, etc)
+ *	in CacheWolf.
+ *	It also provides a class for importing maps
+ *	This class id=4100
+ */
+public class Map extends Form {
+	Preferences pref;
+	String mapsPath = new String();
+	String thisMap = new String();
+	public String selectedMap = new String();
+	CellPanel infPanel;
+	mLabel infLabel = new mLabel("                          ");
+	Vector GCPs = new Vector();
+	MapInfoObject wfl = new MapInfoObject();
+	mButton infButton;
+	ScrollBarPanel scp;
+	AniImage mapImg;
+	int imageWidth, imageHeight = 0;
+
+	/**
+	 *	This constructor should be used when importing maps
+	 */
+	public Map(Preferences pref){
+		this.pref = pref;
+		mapsPath = pref.getMapManuallySavePath(true)+"/"; //File.getProgramDirectory() + "/maps/";
+	}
+
+	/**
+	 *	When a user clicks on the map and more than three ground control points exist
+	 *	then the calculated coordinate based on the affine transformation is displayed in the
+	 *	info panel below the map.
+	 *	It helps to identify how good the georeferencing works based on the set GCPs.
+	 */
+	public void updatePosition(int x, int y){
+		if(GCPs.size()>=3  || (wfl.affine[4] > 0 && wfl.affine[5] > 0)){
+			double x_ = 0;
+			double y_ = 0;
+			x_ = wfl.affine[0]*x + wfl.affine[2]*y + wfl.affine[4];
+			y_ = wfl.affine[1]*x + wfl.affine[3]*y + wfl.affine[5];
+			CWPoint p = new CWPoint(x_ , y_);
+			infLabel.setText("--> " + p.getLatDeg(CWPoint.DMS) + " " +p.getLatMin(CWPoint.DMM) + " / " + p.getLonDeg(CWPoint.DMS) + " " + p.getLonMin(CWPoint.DMM));
+		}
+	}
+
+	/**
+	 *	This is the correct constructor for georeferencing maps.
+	 */
+	public Map(Preferences pref, String mapToLoad, boolean worldfileexists){
+		this.pref = pref;
+		this.title = MyLocale.getMsg(4106,"Calibrate map:") + " " + mapToLoad;
+		this.resizable = true;
+		this.moveable = true;
+		//this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
+		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
+		thisMap = mapToLoad;
+		mapsPath = pref.getMapManuallySavePath(true)+"/"; //File.getProgramDirectory() + "/maps/"; // TDO veraltet
+		try {
+			wfl.loadwfl(mapsPath, thisMap);
+		}catch(FileNotFoundException ex){
+			//	Vm.debug("Cannot load world file!");
+		}catch (IOException ex) { // is thrown if lat/lon out of range
+			MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, "Error"), ex.getMessage(), MessageBox.OKB);
+			tmpMB.execute();
+			Vm.debug("Cannot load world file!");
+		}
+		mapInteractivePanel pane = new mapInteractivePanel(this);
+		scp = new ScrollBarPanel(pane);
+		Image img = new Image(Common.getImageName(mapsPath + thisMap));
+		PixelBuffer pB = new PixelBuffer(img);
+		//pB = pB.scale((int)(pref.myAppWidth*0.98),(int)(pref.myAppHeight*0.98));
+		mapImg = new AniImage(pB.toDrawableImage());
+		pane.addImage(mapImg);
+		scp.setPreferredSize(mapImg.getWidth(),mapImg.getHeight());
+		imageWidth = mapImg.getWidth();
+		imageHeight = mapImg.getHeight();
+		this.addLast(scp.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
+		infPanel = new CellPanel();
+		infPanel.addNext(infLabel,CellConstants.STRETCH, CellConstants.FILL);
+		infButton = new mButton(MyLocale.getMsg(4107,"Done!"));
+		infPanel.addLast(infButton,CellConstants.DONTSTRETCH, CellConstants.FILL);
+		this.addLast(infPanel, CellConstants.DONTSTRETCH, CellConstants.FILL);
+		//scp.repaintNow();
+		//this.repaintNow();
+	}
+
+	/**
+	 *	Add a ground control point to the list
+	 *	If the list is longer than 3 GCPs these will be evaluated
+	 *	to obtain the required parameters for the affine
+	 *	transformation.
+	 */
+	public void addGCP(GCPoint GCP){
+		if (GCP.latDec>90 || GCP.latDec<-90 || GCP.lonDec>360 || GCP.lonDec<-180) throw new IllegalArgumentException("lat/lon out of range: "+GCP.toString());
+		GCPs.add(GCP);
+		if(GCPs.size() >= 3){
+			evalGCP();
+		}
+	}
+
+	/**
+	 *	Returns the number of ground control points in the list. (Vector GCPs)
+	 */
+	public int getGCPCount(){
+		return GCPs.size();
+	}
+
+	/**
+	 *	Actuall method to evaluate the ground control points and identify the parameters
+	 *	for thew affine transformation
+	 */
+	private void evalGCP(){
+		//N 48 16.000 E 11 32.000
+		//N 48 16.000 E 11 50.000
+		//N 48 9.000 E 11 32.000
+		GCPoint gcp = new GCPoint();
+		//Calculate parameters for latitutde affine transformation (affine 0,2,4)
+		Matrix X = new Matrix(GCPs.size(),3);
+		Matrix trg = new Matrix(GCPs.size(),1);
+		for(int i = 0; i < GCPs.size();i++){
+			gcp = (GCPoint)GCPs.get(i);
+			X.matrix[i][0] = 1; X.matrix[i][1] = gcp.bitMapX; X.matrix[i][2] = gcp.bitMapY;
+			trg.matrix[i][0] = gcp.latDec;
+		}
+		Matrix Xtran = new Matrix(X);
+		Xtran.Transpose();
+		Matrix XtranX = new Matrix(Xtran);
+		XtranX.Multiply(X);
+		Matrix XtranXinv = new Matrix(XtranX);
+		XtranXinv.Inverse();
+		Matrix beta = new Matrix(XtranXinv);
+		beta.Multiply(Xtran);
+		beta.Multiply(trg);
+		wfl.affine[0] = beta.matrix[1][0];
+		wfl.affine[2] = beta.matrix[2][0];
+		wfl.affine[4] = beta.matrix[0][0];
+
+		//Calculate parameters for longitude affine transformation (affine 1,3,5)
+		X = new Matrix(GCPs.size(),3);
+		trg = new Matrix(GCPs.size(),1);
+		for(int i = 0; i < GCPs.size();i++){
+			gcp = (GCPoint)GCPs.get(i);
+			X.matrix[i][0] = 1;
+			X.matrix[i][1] = gcp.bitMapX;
+			X.matrix[i][2] = gcp.bitMapY;
+			trg.matrix[i][0] = gcp.lonDec;
+		}
+		Xtran = new Matrix(X);
+		Xtran.Transpose();
+		XtranX = new Matrix(Xtran);
+		XtranX.Multiply(X);
+		XtranXinv = new Matrix(XtranX);
+		XtranXinv.Inverse();
+		beta = new Matrix(XtranXinv);
+		beta.Multiply(Xtran);
+		beta.Multiply(trg);
+		wfl.affine[1] = beta.matrix[1][0];
+		wfl.affine[3] = beta.matrix[2][0];
+		wfl.affine[5] = beta.matrix[0][0];
+		double x_ = 0;
+		double y_ = 0;
+		x_ = wfl.affine[0]*imageWidth+ wfl.affine[2]*imageHeight + wfl.affine[4];
+		y_ = wfl.affine[1]*imageWidth + wfl.affine[3]*imageHeight + wfl.affine[5];
+		CWPoint p = new CWPoint(x_ , y_);
+		wfl.lowlon = p.lonDec;
+		wfl.lowlat = p.latDec;
+		//Vm.debug("A B C" + affine[0] + " " + affine[2] + " " + affine[4]);
+		//Vm.debug("D E F" + affine[1] + " " + affine[3] + " " + affine[5]);
+	}
+
+	/**
+	 *	Method to copy ("import") a png based map
+	 *	into the maps folder in the CacheWolf base directory.
+	 *	
+	 *	If the maps directory does not exist it will create it.
+	 *	If it finds .map files it will assume these are oziexplorer calibration files.
+	 *	It will use these files to automatically georeference the files during import.
+	 */
+	public int importMap(){
+		String rawFileName = new String();
+		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir);
+		fc.addMask("*.png,*.gif,*.bmp,*.jpg");
+		fc.setTitle((String)MyLocale.getMsg(4100,"Select Directory:"));
+		int tmp = fc.execute() ; 
+		if(tmp != FileChooser.IDYES) return Form.IDCANCEL;
+		File inDir = fc.getChosenFile();
+		File mapFile;
+		InfoBox inf = new InfoBox("Info", MyLocale.getMsg(4109,"Loading maps...            \n"), InfoBox.PROGRESS_WITH_WARNINGS, false); 
+		inf.setPreferredSize(220, 300);
+		inf.setInfoHeight(100);
+		inf.relayout(false);
+		Vm.showWait(this, true);
+		inf.exec();
+
+		//User selected a map, but maybe there are more png(s)
+		//copy all of them!
+		//at the same time try to find associated .map files!
+		//These are georeference files targeted for OziExplorer.
+		//So lets check if we have more than 1 png file:
+		String line = new String();
+		InputStream in = null;
+		OutputStream out = null;
+		FileReader inMap;
+		byte[] buf;
+		int len;
+		String[] parts;
+		String [] files = inDir.listMultiple("*.png,*.jpg,*.gif,*.bmp", File.LIST_FILES_ONLY);
+
+		String currfile = null;
+		String curInFullPath;
+		String curOutFullPath;
+		int num = files.length;
+		for(int i =  num -1 ; i >= 0;i--){
+			currfile = (String) files[i];
+			inf.setInfo(MyLocale.getMsg(4110,"Loading: ")+ "\n" + currfile + "\n("+(num-i)+"/"+num+")");
+			//Copy the file
+			//Vm.debug("Copy: " + inDir.getFullPath() + "/" +files[i]);
+			//Vm.debug("to: " + mapsPath + files[i]);
+			curInFullPath = inDir.getFullPath() + "/" +currfile;
+			curOutFullPath = mapsPath + currfile;
+			boolean imageerror = false;
+			try {
+				in = new FileInputStream(curInFullPath);
+				buf = new byte[1024*10];
+				boolean first = true;
+				ByteArray header = new ByteArray(buf);
+				while ((len = in.read(buf)) > 0) {
+					if (first) {
+						first = false;
+						header.copyFrom(buf, 0, len);
+						ImageInfo tmpII = Image.getImageInfo(header,null);
+						imageWidth = tmpII.width;
+						imageHeight = tmpII.height;
+						out = new FileOutputStream(curOutFullPath); // only create outfile if geImageInfo didn't throw an exception so do it only here not directly after opening input stream
+					}
+					out.write(buf, 0, len);
+				}
+			} catch(IOException ex){
+				imageerror = true;
+				inf.addWarning("\nIO-Error while copying image from: " + curInFullPath + " to: " + curOutFullPath + " error: " + ex.getMessage());
+			} catch (IllegalArgumentException e) { // thrown from Image.getImageInfo when it could not interprete the header (e.g. bmp with 32 bits per pixel)
+				imageerror = true;
+				inf.addWarning("\nError: could not decode image: " + curInFullPath + " - image not copied");
+			} finally {
+				try {
+					if (in != null) in.close();
+					if (out  != null) out.close(); 
+				} catch (Throwable e) {}
+			}
+			//Check for a .map file
+			rawFileName = currfile.substring(0, currfile.lastIndexOf("."));
+			mapFile = new File(inDir.getFullPath() + "/" + rawFileName + ".map");
+			if(!imageerror && mapFile.exists()){
+				GCPoint gcp1 = new GCPoint();
+				GCPoint gcp2 = new GCPoint();
+				GCPoint gcp3 = new GCPoint();
+				GCPoint gcp4 = new GCPoint();
+				GCPoint gcpG = new GCPoint();
+				//Vm.debug("Found file: " + inDir.getFullPath() + "/" + rawFileName + ".map");
+				try {
+					inMap = new FileReader(inDir.getFullPath() + "/" + rawFileName + ".map");
+					while((line = inMap.readLine()) != null){
+						if(line.equals("MMPNUM,4")){
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp1.bitMapX = Convert.toInt(parts[2]);
+							gcp1.bitMapY = Convert.toInt(parts[3]);
+							if(gcp1.bitMapX == 0) gcp1.bitMapX = 1;
+							if(gcp1.bitMapY == 0) gcp1.bitMapY = 1;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp2.bitMapX = Convert.toInt(parts[2]);
+							gcp2.bitMapY = Convert.toInt(parts[3]);
+							if(gcp2.bitMapX == 0) gcp2.bitMapX = 1;
+							if(gcp2.bitMapY == 0) gcp2.bitMapY = 1;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp3.bitMapX = Convert.toInt(parts[2]);
+							gcp3.bitMapY = Convert.toInt(parts[3]);
+							if(gcp3.bitMapX == 0) gcp3.bitMapX = 1;
+							if(gcp3.bitMapY == 0) gcp3.bitMapY = 1;
+							//imageWidth = gcp3.bitMapX;
+							//imageHeight = gcp3.bitMapY;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp4.bitMapX = Convert.toInt(parts[2]);
+							gcp4.bitMapY = Convert.toInt(parts[3]);
+							if(gcp4.bitMapX == 0) gcp4.bitMapX = 1;
+							if(gcp4.bitMapY == 0) gcp4.bitMapY = 1;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(pref.digSeparator.equals(",")) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp1.bitMapX;
+							gcpG.bitMapY = gcp1.bitMapY;
+							addGCP(gcpG);
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(pref.digSeparator.equals(",")) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp2.bitMapX;
+							gcpG.bitMapY = gcp2.bitMapY;
+							addGCP(gcpG);
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(pref.digSeparator.equals(",")) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp3.bitMapX;
+							gcpG.bitMapY = gcp3.bitMapY;
+							addGCP(gcpG);
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(pref.digSeparator.equals(",")) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp4.bitMapX;
+							gcpG.bitMapY = gcp4.bitMapY;
+							addGCP(gcpG);
+							/* already read from image file itself
+							// get dimensions of image
+							while ( (line = inMap.readLine()) != null){
+								if (line.startsWith("IWH")){
+									parts = mString.split(line, ',');
+									imageWidth = Convert.toInt(parts[2]);
+									imageHeight = Convert.toInt(parts[3]);
+								}
+							}
+							 */
+							evalGCP();
+							//Vm.debug("Saving .map file to: " + mapsPath + "/" + rawFileName + ".wfl");
+							wfl.saveWFL(mapsPath, rawFileName);
+							GCPs.clear();
+						} // if
+
+					} // while
+					if (inMap != null)	inMap.close();
+				} catch(IllegalArgumentException ex){ // is thrown from Convert.toDouble and saveWFL if affine[0-5]==0 NumberFormatException is a subclass of IllegalArgumentExepction
+					inf.addWarning("\nError while importing .map-file: "+ex.getMessage());
+				} catch(IOException ex){
+					inf.addWarning("\nIO-Error while reading or writing calibration file\n" + ex.getMessage());
+				} 
+			} else { // if map file.exists
+				if (!imageerror) inf.addWarning("\nNo calibration file found for: " + currfile + " - you can calibrate it manually");
+			}
+		} // for file
+		Vm.showWait(this, false);
+		inf.addText("\ndone.");
+		inf.addOkButton();
+		//inf.addOkButton(); doesn't work
+		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
+		return Form.IDOK;
+	}
+
+
+
+	/**
+	 *	Handles button pressed event
+	 *	When the button is pressed a mapname.wfl file is saved in the
+	 *	maps directory.
+	 */
+	public void onEvent(Event ev){
+
+		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+			// display coords in another format
+			if (ev.target == infButton){
+				boolean retry = true;
+				while (retry == true) {
+					try {
+						retry = false;
+						wfl.saveWFL(mapsPath, thisMap);
+						if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
+					} catch (IOException e) {
+						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(321, "Error writing file ") + e.getMessage()+MyLocale.getMsg(324, " - retry?"), MessageBox.YESB | MessageBox.NOB);
+						if (tmpMB.execute() == MessageBox.IDYES) retry = true;
+					}catch (IllegalArgumentException e) {
+						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(325, "Map not calibrated")+MyLocale.getMsg(324, " - retry?"), MessageBox.YESB | MessageBox.NOB);
+						if (tmpMB.execute() == MessageBox.IDYES) { retry = true; break; }
+					}
+				}
+				if (!retry) close(0);
+			}
+		}
+	}
+}
+
+/**
+ *	Class that creates a panel and loads a map.
+ *	It catches click events to display a form where the user may enter the required ccordinates
+ *	The data is stored as a ground control point in the calling class: Map
+ */
+class mapInteractivePanel extends InteractivePanel{
+	Map f;
+	Locale l = Vm.getLocale();
+	LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
+	public mapInteractivePanel(Map f){
+		this.f = f;
+	}
+
+	/**
+	 *	Event handler to catch clicks on the map
+	 */
+	public void imageClicked(AniImage which, Point pos){
+		//Vm.debug("X = " +pos.x + " Y = " + pos.y);
+		Image img = new Image(31, 31);
+		Graphics g = new Graphics(img);
+		g.setColor(new Color(0,0,0));
+		g.fillRect(0,0,31,31);
+		g.setColor(new Color(255,0,0));
+		g.drawLine(0,16,31,16);
+		g.drawLine(16,0,16,31);
+		AniImage aImg = new AniImage(img);
+		aImg.setLocation(pos.x-16,pos.y-16);
+		aImg.transparentColor = new Color(0,0,0);
+		//aImg.properties = mImage.IsNotHot;
+		aImg.properties = mImage.AlwaysOnTop;
+		this.addImage(aImg);
+		g.free();
+		this.repaintNow();
+		f.updatePosition(pos.x, pos.y);
+
+		CoordsScreen cooS = new CoordsScreen(); // (String)lr.get(4108,"Coordinates:"), (String)lr.get(4108,"Coordinates:"), InfoBox.INPUT);
+		if (cooS.execute()==CoordsScreen.IDOK) {
+			GCPoint gcp = new GCPoint(cooS.getCoords());
+			gcp.bitMapX = pos.x;
+			gcp.bitMapY = pos.y;
+			f.addGCP(gcp); // throws IllegalArgumentException in case of lon/lat out of range
+//			} catch (IllegalArgumentException e) { // NumberFormatException is a subclass of IllagalArgumentException
+//			coosInputFormat();
+//			this.removeImage(aImg);
+		} else this.removeImage(aImg); // CANCEL pressed
+	}
+
+	private void coosInputFormat () {
+		MessageBox tmpMB = new MessageBox((String)lr.get(312,"Error"), (String)lr.get(4111,"Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"), MessageBox.OKB);
+		tmpMB.exec();
+
+	}
+}
+/**
+ *	Class based on CWPoint but intended to handle bitmap x and y
+ *	Used for georeferencing bitmaps.
+ */
+class GCPoint extends CWPoint{
+	public int bitMapX = 0;
+	public int bitMapY = 0;
+
+	public GCPoint(){
+	}
+
+	public GCPoint(CWPoint p) {
+		super(p);
+	}
+
+	public GCPoint(double lat, double lon){
+		this.latDec = lat;
+		this.lonDec = lon;
+		this.utmValid = false;
+	}
+}
\ No newline at end of file

Added: trunk/src/CacheWolf/navi/MapDetailForm.java
===================================================================
--- trunk/src/CacheWolf/navi/MapDetailForm.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/MapDetailForm.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,65 @@
+package CacheWolf.navi;
+import CacheWolf.ImageDetailForm;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+import CacheWolf.Profile;
+import ewe.graphics.*;
+import ewe.sys.*;
+import ewe.fx.*;
+import ewe.ui.*;
+import ewe.util.*;
+
+/**
+ *	Class to display map images in different zoom levels.
+ *	Extends ImageDetailForm that handles the resizing to screen
+ *	size. The extension in this class handles the switching between
+ *	different (map) images.
+ */
+public class MapDetailForm extends ImageDetailForm {
+ /* // it's obsolete since we have a well working moving map 
+	mButton btSwitch;
+	String cache;
+	String imgLoc = new String();
+	int status = 0;
+	Profile profile;
+	
+	public MapDetailForm(String cacheName, Preferences p, Profile prof){
+		profile=prof;  // keep ref for later use
+		cache=cacheName;
+		imgLoc = prof.dataDir + cacheName + "_map.gif";
+		scp = new ScrollBarPanel(ipp);
+		setUp(imgLoc, p);
+		this.title = "Maps";
+		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
+		this.addLast(scp.getScrollablePanel(), this.STRETCH, this.FILL);
+		CellPanel butPanel = new CellPanel();
+		btSwitch = new mButton("Zoom");
+		butPanel.addLast(btSwitch);
+		this.addLast(butPanel, this.HSTRETCH, this.FILL);
+	}
+
+	public void onEvent(Event ev){
+		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+			if (ev.target == btSwitch){
+				ipp.removeImage(ai);
+				imgLoc = profile.dataDir + cache;
+				if(status == 0) {
+					imgLoc = imgLoc + "_map_2.gif";
+					status = 1;
+				} else {
+					imgLoc = imgLoc + "_map.gif";
+					status = 0;
+				}
+				try {
+					setUp(imgLoc, pref);
+					this.repaintNow();
+				} catch (IllegalArgumentException e) {
+					MessageBox tmp = new MessageBox(MyLocale.getMsg(321,"Fehler"), MyLocale.getMsg(322,"Kann Bild/Karte nicht finden")+": "+imgLoc, MessageBox.OKB); // @todo: language support
+					tmp.exec();
+				}
+			}
+		}
+	}
+	*/
+}
+

Added: trunk/src/CacheWolf/navi/MapImage.java
===================================================================
--- trunk/src/CacheWolf/navi/MapImage.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/MapImage.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,78 @@
+package CacheWolf.navi;
+import ewe.fx.*;
+import ewe.graphics.*;
+/** 
+ * class that can be used with any x and any y
+ * it will save taht location and make itself automatically
+ * invisible if it is not on the screen. Call setscreensize to
+ * set the screensize
+ * @author pfeffer
+ *
+ */
+public class MapImage extends AniImage {
+	public Point locAlways = new Point(); // contains the theoretical location even if it the location is out of the screen. If the image is on the screen, it contains the same as location
+	public static Dimension screenDim;
+	boolean hidden = false;
+	public MapImage() {
+		super();
+		if (screenDim == null) screenDim = new Dimension(0,0);
+	}
+
+	public MapImage(String f) {
+		super(f);
+		if (screenDim == null) screenDim = new Dimension(0,0);
+	}
+
+	public MapImage(mImage im) {
+		super(im);
+		if (screenDim == null) screenDim = new Dimension(0,0);
+	}
+
+	public static void setScreenSize(int w, int h) {
+		screenDim = new Dimension(w, h);
+	}
+
+	public void setImage(Image im, Color c) {
+		super.setImage(im, c);
+		if (screenDim == null) screenDim = new Dimension(0,0);
+	}
+
+	public void setLocation (int x, int y) {
+		locAlways.x = x;
+		locAlways.y = y;
+		if (!hidden && isOnScreen()) { 
+			super.setLocation(x, y);
+			properties &= ~AniImage.IsInvisible;
+		} else {
+			properties |= AniImage.IsInvisible;
+			super.move(0, 0);
+		}
+	}
+
+	public void move (int x, int y) {
+		locAlways.x = x;
+		locAlways.y = y;
+		if (!hidden && isOnScreen()) { 
+			super.move(x, y);
+			properties &= ~AniImage.IsInvisible;
+		} else {
+			properties |= AniImage.IsInvisible;
+			super.move(0, 0);
+		}
+	}
+
+	public boolean isOnScreen() { 
+		if ( (locAlways.x + location.width > 0 && locAlways.x < screenDim.width) && 
+				(locAlways.y + location.height > 0 && locAlways.y < screenDim.height) ) return true;
+		else return false;
+	}
+
+	public void hide() {
+		hidden = true;
+		properties |= AniImage.IsInvisible;
+	}
+	public void unhide() {
+		hidden = false;
+		move(locAlways.x, locAlways.y);
+	}
+}

Added: trunk/src/CacheWolf/navi/MapInfoObject.java
===================================================================
--- trunk/src/CacheWolf/navi/MapInfoObject.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/MapInfoObject.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,334 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.Common;
+import CacheWolf.MyLocale;
+import ewe.fx.Point;
+import ewe.io.BufferedWriter;
+import ewe.io.FileReader;
+import ewe.io.FileWriter;
+import ewe.io.FilenameFilter;
+import ewe.io.File;
+import ewe.io.IOException;
+import ewe.io.PrintWriter;
+import ewe.sys.*;
+
+/**
+ * @author r
+ *
+ */
+public class MapInfoObject{
+	//World file:
+	// x scale
+	// y scale
+	// x rotation
+	// y rotation
+	// lon of upper left corner of image
+	// lat of upper left corner of image
+	// lon of lower right corner of image
+	// lat of lower right corner of image
+	public double[] affine = {0,0,0,0,0,0};
+	public double lowlat = 0;
+	public double lowlon = 0;
+	public double transLatX, transLatY, transLonX, transLonY; // this are needed for the inervers calculation from lat/lon to x/y
+	public CWPoint center = new CWPoint();
+	public float sizeKm = 0; // diagonale
+	public float scale; // in meters per pixel, note: it is assumed that this scale identifying the scale of the map, automatically adjusted when zooming
+	public float zoomFactor = 1; // if the image is zoomed, direct after laoding always 1
+	public Point shift = new Point (0,0);
+	public CWPoint OrigUpperLeft; // this is only valid after zooming 
+	public float rotationRad; // contains the rotation of the map == north direction in rad
+	public String fileNameWFL = new String();
+	public String fileName = new String();
+	public String mapName = new String();
+	//private Character digSep = new Character(' ');
+	static private String digSep = MyLocale.getDigSeparator();
+	/*
+	 * loads an .wfl file
+	 * throws FileNotFoundException and IOException (data out of range)
+	 * @maps Path to .wfl file
+	 * @thisMap filename of .wfl file without ".wfl"
+	 * @DigSep "." or ","
+	 */	
+
+	public MapInfoObject() {
+		//double testA = Convert.toDouble("1,50") + Convert.toDouble("3,00");
+		//if(testA == 4.5) digSep = ","; else digSep = ".";
+	}
+	
+	public MapInfoObject(MapInfoObject map) {
+		mapName = map.mapName;
+		affine[0] = map.affine[0];
+		affine[1] = map.affine[1];
+		affine[2] = map.affine[2];
+		affine[3] = map.affine[3];
+		affine[4] = map.affine[4];
+		affine[5] = map.affine[5];
+		lowlat = map.lowlat;
+		lowlon = map.lowlon;
+		OrigUpperLeft = new CWPoint (map.OrigUpperLeft);
+		zoomFactor = map.zoomFactor;
+		shift.set(map.shift);
+		fileName = new String(map.fileName);
+		fileNameWFL = new String(map.fileNameWFL);
+		mapName = new String(mapName);
+		doCalculations();
+	}
+
+	/*
+	 * constructes an MapInfoObject without an associated map
+	 * but with 1 Pixel = scale meters
+	 */
+	public MapInfoObject(double scalei, double lat) {
+		mapName="empty 1 Pixel = "+scalei+"meters";
+		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		double pixel2deg = meters2deg * scalei;
+		affine[0]=0; //x2lat
+		affine[1]=pixel2deg / java.lang.Math.cos(lat); //x2lon
+		affine[2]=-pixel2deg; //y2lat
+		affine[3]=0; //y2lon
+		affine[4]=1; //top
+		affine[5]=0; //left
+		lowlat = 0; //buttom
+		lowlon = 1; //right
+		OrigUpperLeft = new CWPoint(affine[4], affine[5]);
+		doCalculations();
+	}
+
+	/**
+	 * constructs an MapInfoObject with an associated map
+	 * with 1 Pixel = scale meters, center and width, hight in pixels
+	 * @param name path and filename of .wfl file without the extension (it is needed because the image will be searched in the same directory)
+	 */
+	public MapInfoObject(double scalei, CWPoint center, int width, int hight, String name) {
+		mapName = name+".wfl";
+
+		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		double pixel2deg = meters2deg * scalei;
+		double pixel2deghorizontal = pixel2deg / java.lang.Math.cos(center.latDec*java.lang.Math.PI / 180); 
+		affine[0]=0; //x2lat
+		affine[1]=pixel2deghorizontal; //x2lon
+		affine[2]=-pixel2deg; //y2lat
+		affine[3]=0; //y2lon
+		affine[4]=center.latDec + hight / 2 *pixel2deg; //top
+		affine[5]=center.lonDec - width / 2 *pixel2deghorizontal; //left
+		lowlat = center.latDec - hight / 2 *pixel2deg; //buttom
+		lowlon = center.lonDec + width / 2 *pixel2deghorizontal; //right
+		fileNameWFL = name;
+		OrigUpperLeft = new CWPoint(affine[4], affine[5]);
+		doCalculations();
+	}
+	
+
+	/** 
+	 * @return the filename of the associated map image, "" if no file is associated, null if associated file could not be found
+	 */
+	public String getImageFilename() {
+		if (fileName == null || fileName.length() > 0) return fileName;
+		if (fileNameWFL.length() == 0) return "";
+		String n = fileNameWFL.substring(0, fileNameWFL.lastIndexOf("."));
+		return Common.getImageName(n);
+	}
+	
+	/**
+	 * Method to load a .wfl-file
+	 * @throws IOException when there was a problem reading .wfl-file
+	 * @throws IOException when lat/lon were out of range
+	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
+	 */
+	public void loadwfl(String mapsPath, String thisMap) throws IOException, ArithmeticException {
+		FileReader in = new FileReader(mapsPath + thisMap + ".wfl");
+		String line = new String();
+		try {
+			for(int i = 0; i<6;i++){
+				line = in.readLine();
+				if (digSep.equals(",")) {line = line.replace('.',','); } // digSep == ',' musss genau so lauten. digsep.equals(',') wirft eine Exception auf PocketPC, digsep.equals(",") wirft keine Exception, funktioniert aber nicht! 
+				else line = line.replace(',','.');
+				affine[i] = Convert.toDouble(line);
+			}
+			line = in.readLine();
+			if (digSep.equals(",")) {line = line.replace('.',','); }
+			else line = line.replace(',','.');
+			lowlat = Convert.toDouble(line);
+			line = in.readLine();
+			if (digSep.equals(",")) {line = line.replace('.',','); }
+			else line = line.replace(',','.');
+			lowlon = Convert.toDouble(line);
+
+			fileNameWFL = mapsPath + thisMap + ".wfl";
+			fileName = ""; //mapsPath + thisMap + ".png";
+			mapName = thisMap;
+			in.close();
+			if(affine[4] > 90 || affine[4] < -90 || affine[5] < -180 || affine[5] > 360 ||
+					lowlat > 90 || lowlat < -90 || lowlon > 360 || lowlon < -180 ) {
+				affine[0] = 0; affine[1] = 0; affine[2] = 0; affine[3] = 0; affine[4] = 0; affine[5] = 0;
+				lowlat = 0; lowlon = 0;
+				throw (new IOException("Lat/Lon out of range while reading "+mapsPath + thisMap + ".wfl"));
+			}
+		} catch (NullPointerException e) { // in.readline liefert null zur?ck, wenn keine Daten mehr vorhanden sind
+			throw (new IOException("not enough lines in file "+mapsPath + thisMap + ".wfl"));
+		}
+		OrigUpperLeft = new CWPoint(affine[4], affine[5]);
+		doCalculations();
+	}
+
+	/**
+	 * calculates center, diagonal size of the map and inverse to affine transformation
+	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
+	 */
+
+	private void doCalculations() throws ArithmeticException {
+		try {
+			center.set((lowlat + affine[4])/2,(lowlon + affine[5])/2);
+			sizeKm = java.lang.Math.abs((float)center.getDistance(lowlat, lowlon)) *2;
+
+			//calculate reverse affine
+			double nenner=(-affine[1]*affine[2]+affine[0]*affine[3]);
+			transLatX = affine[3]/nenner; // nenner == 0 cannot happen as long als affine is correct
+			transLonX = -affine[2]/nenner;
+			transLatY = -affine[1]/nenner;
+			transLonY = affine[0]/nenner;
+
+			// calculate north direction
+			float scaleXpixels = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLonX,2)+java.lang.Math.pow(transLonY,2));
+			//	float scaleY = 1/(float)java.lang.Math.sqrt(java.lang.Math.pow(transLatX,2)+java.lang.Math.pow(transLatY,2));
+			float rotationX2x=(float)transLonX*scaleXpixels;
+			float rotationX2y=(float)transLonY*scaleXpixels;
+			//rotationY2y=-(float)transLatY*scaleY; // lat -> y = -, y -> y = +
+			//rotationY2x=-(float)transLatX*scaleY; // uncomment an make it a field of MapInfoObject if you need translation from x to x rotated
+			rotationRad = (float)java.lang.Math.atan(rotationX2y);
+			if (rotationX2x < 0) rotationRad = (float)java.lang.Math.PI - rotationRad;
+			// calculate scale in meters per pixel
+			double metersPerLat = 1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0));
+			scale = (float) java.lang.Math.abs((affine[2] * metersPerLat)); 
+		} catch (ArithmeticException ex) { throw new ArithmeticException("Not allowed values in affine\n (matrix cannot be inverted)\n in file \n" + fileNameWFL); }
+	}
+
+
+	/**
+	 *	Method to save a world file (.wfl)
+	 * @param mapsPath without "/" at the end
+	 * @param mapFileName without file extension
+	 * @throws IOException when there was a problem writing .wfl-file
+	 * @throws IllegalArgumentException when affine[x] for all x == 0 ("map not calibrated").
+	 */
+	public void saveWFL(String mapsPath, String mapFileName) throws IOException, IllegalArgumentException {
+		if (affine[0]==0 && affine[1]==0 && affine[2]==0 && affine[3]==0 && 
+				affine[4]==0 && affine[5]==0 ) throw (new IllegalArgumentException("map not calibrated"));
+		PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(mapsPath + "/" + mapFileName + ".wfl")));
+		String towrite=Convert.toString(affine[0])+"\n" +
+		Convert.toString(affine[1])+"\n" +
+		Convert.toString(affine[2])+"\n" + 
+		Convert.toString(affine[3])+"\n" + 
+		Convert.toString(affine[4])+"\n" +
+		Convert.toString(affine[5])+"\n" +
+		Convert.toString(lowlat)+"\n" +
+		Convert.toString(lowlon)+"\n";
+		if (digSep.equals(",")) towrite=towrite.replace(',', '.');
+		outp.print(towrite);
+		outp.close();
+		this.fileName = ""; // this will be set in getImageFilenam //mapsPath + "/" + mapFileName + ".png";
+		this.fileNameWFL = mapsPath + "/" + mapFileName + ".wfl";
+		this.mapName = mapFileName;
+	}
+
+	public boolean inBound(CWPoint pos){
+		boolean isInBound = false;
+		/*
+		Vm.debug(mapName);
+		Vm.debug("Top: " + affine[4]);
+		Vm.debug("Bottom: " + lowlat);
+		Vm.debug("Test: " + pos.latDec);
+		Vm.debug("Left: " + affine[5]);
+		Vm.debug("Right: " + lowlon);
+		Vm.debug("Test: " + pos.lonDec);
+		 */
+		if(affine[4] >= pos.latDec && pos.latDec >= lowlat && affine[5] <= pos.lonDec && pos.lonDec <= lowlon) isInBound = true;
+		return isInBound;
+	}
+
+	/**
+	 * zoom in / out
+	 * @param zf zf > 1 == zoom in, zoom is relative to original unscaled image
+	 * @param diffX shift of map in pixels (if the map was cropped while zooming) in the not zoomed image
+	 * @param diffY
+	 */
+	public void zoom(float zf, int diffX, int diffY) {
+		// restore original values to calculate corret shift (upperleft)
+		affine[4] = OrigUpperLeft.latDec;
+		affine[5] = OrigUpperLeft.lonDec;
+		affine[0] = affine[0] * zoomFactor; 
+		affine[1] = affine[1] * zoomFactor; 
+		affine[2] = affine[2] * zoomFactor;
+		affine[3] = affine[3] * zoomFactor;
+		CWPoint upperleft = calcLatLon(diffX, diffY);
+		affine[4] = upperleft.latDec;
+		affine[5] = upperleft.lonDec;
+		affine[0] = affine[0] / zf ; 
+		affine[1] = affine[1] / zf ; 
+		affine[2] = affine[2] / zf ; 
+		affine[3] = affine[3] / zf ; 
+		zoomFactor = zf ;
+		shift.x = diffX;
+		shift.y = diffY;
+		doCalculations(); // TODO lowlat neu berechnen?
+	}
+
+	public boolean inBound(CWGPSPoint pos){
+		boolean isInBound = false;
+		/*
+		Vm.debug(mapName);
+		Vm.debug("Top: " + affine[4]);
+		Vm.debug("Bottom: " + lowlat);
+		Vm.debug("Test: " + pos.latDec);
+		Vm.debug("Left: " + affine[5]);
+		Vm.debug("Right: " + lowlon); // lowlon should be left?!
+		Vm.debug("Test: " + pos.lonDec);
+		 */
+		if(affine[4] >= pos.latDec && pos.latDec >= lowlat && affine[5] <= pos.lonDec && pos.lonDec <= lowlon) isInBound = true;
+		return isInBound;
+	}
+	public boolean inBound(double lati, double loni){
+		boolean isInBound = false;
+		if(affine[4] >= lati && lati >= lowlat && affine[5] <= loni && loni <= lowlon) isInBound = true;
+		return isInBound;
+	}
+	/**
+	 * Method to calculate bitmap x,y of the current map using
+	 * lat and lon target coordinates. There ist no garanty that
+	 * the returned coordinates are inside of the map. They can be negative.
+	 * @param lat
+	 * @param lon
+	 */
+	public Point calcMapXY(double lat, double lon){
+		Point coords = new Point();
+		double b[] = new double[2];
+		b[0] = lat - affine[4];
+		b[1] = lon - affine[5];
+		double mapx=transLatX* b[0] + transLonX*b[1];
+		double mapy=transLatY* b[0] + transLonY*b[1];
+		coords.x = (int)mapx;
+		coords.y = (int)mapy;
+		//Vm.debug("mapX=mapx2: "+mapx+"="+mapx2+"; mapy=mapy2: "+mapy+"="+mapy2);
+		return coords;
+	}
+
+	/**
+	 * gives back lat/lon from x, y in map
+	 * @param x
+	 * @param y
+	 * @return
+	 */
+	public CWPoint calcLatLon(int x, int y) {
+		CWPoint ll = new CWPoint();
+		ll.latDec = (double)x * affine[0] + (double)y * affine[2] + affine[4];
+		ll.lonDec = (double)x * affine[1] + (double)y * affine[3] + affine[5];
+		return ll;
+	}
+	public CWPoint calcLatLon(Point p) {
+		return calcLatLon(p.x, p.y);
+	}
+	public Area getArea(){
+		return new Area(new CWPoint(affine[4], affine[5]), new CWPoint(lowlat, lowlon));
+	}
+}
\ No newline at end of file

Added: trunk/src/CacheWolf/navi/MapLoader.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoader.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/MapLoader.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,240 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.HttpConnection;
+import CacheWolf.InfoBox;
+import ewe.ui.*;
+import ewe.io.*;
+import ewe.fx.*;
+import ewe.util.*;
+import ewe.sys.*;
+import ewe.sys.Double;
+import ewe.net.*;
+
+/**
+*
+*/
+
+// Um Karten zu holen!
+// http://www.expedia.de/pub/agent.dll?qscr=mrdt&ID=3kQaz.&CenP=48.09901667,11.35688333&Lang=EUR0407&Alti=1&Size=600,600&Offs=0.000000,0.000000&Pins=|5748|
+// oder
+// http://www.expedia.de/pub/agent.dll?qscr=mrdt&ID=3kQaz.&CenP=48.15,11.5833&Alti=2&Lang=EUR0407&Size=900,900&Offs=0,0&MapS=0&Pins=|48.15,11.5833|4|48.15,11.5833&Pins=|48.15,11.5833|1|48.15,%2011.5833||
+
+
+public class MapLoader {
+	String proxy = new String();
+	String port = new String();
+	InfoBox progressInfobox;
+	
+	final static float downloadMapScaleFactorExpedia_east = 3950;
+	final static float MAPBLAST_METERS_PER_PIXEL = 1.0f/2817.947378f;
+	final static float EXPEDIA_METERS_PER_PIXEL = downloadMapScaleFactorExpedia_east * MAPBLAST_METERS_PER_PIXEL; 
+
+	int numMapsY;
+	int numMapsX;
+	double latinc;
+	double loninc;
+	CWPoint topleft;
+	CWPoint buttomright;
+	Point tilesSize;
+	int tileScale;
+
+	public MapLoader(String prxy, String prt){
+		port = prt;
+		proxy = prxy;
+		progressInfobox = null;
+	}
+	
+	/**
+	 * download maps from expedia at zoomlevel alti and save the maps and the .wfl 
+	 * in path
+	 * @param center center of all tiles
+	 * @param radius in meters
+	 * @param scale in "alti" value 1 alti =  3950 /2817.947378 = 1,046861280317350198581316446428 meters per pixel
+	 * @param size in pixels
+	 * @param overlapping in pixels
+	 * @param path without "/" at the end
+	 * 
+	 */
+	public void setTiles (CWPoint center, float radius, int scale, Point size, int overlapping) {
+		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		double metersPerLon = metersPerLat * java.lang.Math.cos(center.latDec/180*java.lang.Math.PI);
+		topleft = new CWPoint(center.latDec + (radius / metersPerLat), center.lonDec - (radius / metersPerLon));
+		buttomright = new CWPoint(center.latDec - (radius / metersPerLat), center.lonDec + (radius / metersPerLon));
+		
+		this.setTiles(topleft, buttomright, scale, size, overlapping);
+	}
+	
+	public void setTiles(CWPoint toplefti, CWPoint buttomrighti, int scale, Point size, int overlapping) {
+		//if (toplefti.latDec <= buttomrighti.latDec || toplefti.lonDec >= toplefti.lonDec) throw new IllegalArgumentException("topleft must be left and above buttom right");
+		topleft = new CWPoint(toplefti);
+		buttomright = new CWPoint(buttomrighti);
+		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		double metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + buttomright.latDec)/2/180*java.lang.Math.PI);
+		
+		double pixelsPerLat = metersPerLat / (EXPEDIA_METERS_PER_PIXEL * scale);
+		double pixelsPerLon = metersPerLon / (EXPEDIA_METERS_PER_PIXEL * scale);
+
+		//over all pixelsize without borders
+		double pixelsY = (topleft.latDec - buttomright.latDec) * pixelsPerLat; 
+		double pixelsX = -(topleft.lonDec - buttomright.lonDec) * pixelsPerLon ; 
+		
+		//border sizes around given area and overlapping between tiles
+		//int borderX = (int) java.lang.Math.round((float)size.x * (overlapping - 1.0));
+		//int borderY = (int) java.lang.Math.round((float)size.y * (overlapping - 1.0));
+		int borderX = overlapping;
+		int borderY = overlapping;
+		
+		numMapsY = (int) java.lang.Math.ceil( (pixelsY + (float)borderY) / (float)(size.y - borderY) );
+		numMapsX = (int) java.lang.Math.ceil( (pixelsX + (float)borderX) / (float)(size.x - borderX) );
+		
+		//increments calulated from pixel offset of tiles
+		latinc = (float)-(size.y - borderY) / pixelsPerLat;
+		loninc = (float)(size.x - borderX) / pixelsPerLon;
+		
+		//calculation of center of first tile
+		
+		//additional size for borders and rounding
+		double oversizeX = (float)(numMapsX * (size.x - borderX) + borderX) - pixelsX;
+		double oversizeY = (float)(numMapsY * (size.y - borderY) + borderY) - pixelsY;
+		
+		//offset for upper left corner
+		double offsetLat = -( ((float)size.y - oversizeY) / 2.0 ) / pixelsPerLat;
+		double offsetLon = ( ((float)size.x - oversizeX) / 2.0 ) / pixelsPerLon;
+		
+		topleft.latDec += offsetLat;
+		topleft.lonDec += offsetLon;
+		
+		this.tilesSize = new Point();
+		this.tilesSize.set(size);
+		this.tileScale = scale;
+	}
+
+	public void downlaodTiles(String tilesPath) {
+		double lat = topleft.latDec;
+		double lon = topleft.lonDec;
+		for (int row = 1; row <= numMapsY; row++) {
+			lon = topleft.lonDec;
+			for (int col = 1; col <= numMapsX; col++) {
+				if (progressInfobox != null)
+					progressInfobox.setInfo("Downloading calibrated (georeferenced) \n map image from www.expedia.com \n Downloading tile row: "+row+" / "+numMapsY+" coloumn "+ col + "/"+numMapsX);
+				downloadMap(lat, lon, tileScale, tilesSize.x, tilesSize.y, tilesPath);
+				lon += loninc;
+			}
+			lat += latinc;
+		}
+	}
+	
+	/*
+	public void loadTo(String a, String b) {
+		//loadTo(a, b, "50.74", "7.095");
+	}
+	*/
+
+	public void setProgressInfoBox (InfoBox progrssInfoboxi) {
+		progressInfobox = progrssInfoboxi;
+	}
+	/**
+	 * calculates the Expedia Alti = scale which fits in distance to its edges
+	 * @param center
+	 * @param distance in meters
+	 */
+	public static int getExpediaAlti(CWPoint center, float distance, Point size) {
+		int scaleLatO = (int) java.lang.Math.ceil(( distance * 2 / EXPEDIA_METERS_PER_PIXEL / size.y));
+		int scaleLonO = (int) java.lang.Math.ceil(( distance * 2 / EXPEDIA_METERS_PER_PIXEL / size.x));
+		int scaleO = (scaleLatO < scaleLonO ? scaleLonO : scaleLatO);
+		//loadTo((topleft.latDec + buttomright.latDec)/2, (topleft.lonDec + buttomright.lonDec)/2, scaleO, size.x, size.y, path+"/expedia_alti"+scaleO+"_lat"+latD.toString()+"_lon"+lonD.toString());
+		return scaleO;
+	}
+	
+	public static String createExpediaFilename(double lat, double lon, int alti) {
+		Double latD = new Double(), lonD = new Double();
+		latD.decimalPlaces = 4;
+		lonD.decimalPlaces = 4;
+		latD.set(lat);
+		lonD.set(lon);
+		return "expedia_alti"+alti+"_lat"+latD.toString().replace(',', '.')+"_lon"+lonD.toString().replace(',', '.')+".gif";
+	}
+	
+	public void downloadMap(double lat, double lon, int alti, int PixelWidth, int PixelHeight, String path){
+		loadTo(lat, lon, alti, PixelWidth, PixelHeight, path+"/"+createExpediaFilename(lat, lon, alti));
+	}
+
+	public void loadTo(double lat, double lon, int alti, int PixelWidth, int PixelHeight, String datei){
+		HttpConnection connImg, conn2;
+		Socket sockImg, sock2;
+		InputStream is;
+		FileOutputStream fos;
+		ByteArray daten;
+		String quelle = new String();
+		String zone;
+		if (lon <= -10) zone = "USA0409";
+		else zone = "EUR0809";
+
+		/*
+		 * information from: DownloadMouseMode.properties in project GPSylon ( in directory gpsylon_src-0.5.2\plugins\downloadmousemode\auxiliary\org\dinopolis\gpstool\plugin\downloadmousemode and DownloadMapCalculator.java in Dir gpsylon_src-0.5.2\plugins\downloadmousemode\src\org\dinopolis\gpstool\plugin\downloadmousemode 
+		 * download.map.url.expedia_east=http\://www.expedia.com/pub/agent.dll?qscr=mrdt&ID=3XNsF.&CenP={0,number,#.########},{1,number,#.########}&Lang=EUR0809&Alti={2,number,#}&Size={3,number,#},{4,number,#}&Offs=0.000000,0.000000\&BCheck=1
+		 * download.map.url.expedia_east.title=Url of Expedia Europe
+		 * download.map.scale_factor.expedia_east=3950
+		 */
+		Double latD = new Double();
+		latD.decimalPlaces = 8;
+		latD.set(lat);
+		Double lonD = new Double();
+		lonD.decimalPlaces = 8;
+		lonD.set(lon);
+		quelle = "http://www.expedia.de/pub/agent.dll?qscr=mrdt";
+		quelle = quelle + "&ID=3kQaz.";
+		quelle = quelle + "&CenP=" + latD.toString().replace(',', '.') + "," + lonD.toString().replace(',', '.');
+		quelle = quelle + "&Alti="+Convert.toString(alti)+"&Lang="+zone+"&Size="+Convert.toString(PixelWidth)+","+Convert.toString(PixelHeight)+"&Offs=0,0&MapS=0"; //&Pins=|" + latD.toString().replace(',', '.') + "," + lonD.toString().replace(',', '.') + "|5|";
+		//Vm.debug(lat + "," + lon);
+		if(proxy.length()>0){
+			connImg = new HttpConnection(proxy, Convert.parseInt(port), quelle);
+			//Vm.debug("Loading quelle: " + quelle);
+		}else{
+			connImg = new HttpConnection(quelle);
+		}
+		//datei = "d:\\temp\\test_map.bmp";
+		connImg.setRequestorProperty("USER_AGENT", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0");
+		connImg.setRequestorProperty("Connection", "close");
+		connImg.setRequestorProperty("Cookie", "jscript=1; path=/;");
+		connImg.documentIsEncoded = true;
+		try{
+			File dateiF = new File(datei);
+			if(!dateiF.exists()){
+				sockImg = connImg.connect();
+				//Vm.debug("Redirect: " + connImg.getRedirectTo());
+				quelle = connImg.getRedirectTo();
+				sockImg.close();
+				if(proxy.length()>0){
+					connImg = new HttpConnection(proxy, Convert.parseInt(port), quelle);
+				}else{
+					connImg = new HttpConnection(quelle);
+				}
+				connImg.setRequestorProperty("USER_AGENT", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0");
+				connImg.setRequestorProperty("Connection", "close");
+				connImg.setRequestorProperty("Cookie", "jscript=1; path=/;");
+				connImg.documentIsEncoded = true;
+				sock2 = connImg.connect();
+				daten = connImg.readData(sock2);
+				fos = new FileOutputStream(dateiF);
+				fos.write(daten.toBytes());
+				fos.close();
+				sock2.close();
+			}
+			//Vm.debug("done");
+		}catch(IOException e){
+			(new MessageBox("Error", "Error while downloading or saving map:\n"+e.getMessage(), MessageBox.OKB)).exec();
+		}
+		File dateiF = new File(datei); // change!!!
+		String tmp = dateiF.getName(); // contains the name and the extension
+		String name = tmp.substring(0, tmp.lastIndexOf("."));
+		float metersPerPixel = (float) (alti)*EXPEDIA_METERS_PER_PIXEL;
+		MapInfoObject cal = new MapInfoObject(metersPerPixel, new CWPoint(lat,lon),  PixelWidth, PixelHeight, dateiF.getPath()+"/"+name);
+		try {
+		cal.saveWFL(dateiF.getDrivePath(), name);
+		} catch (IOException e) {
+			(new MessageBox("Error", "Error saving calibration file:\n"+e.getMessage(), MessageBox.OKB)).exec();
+		}
+	}
+}
\ No newline at end of file

Added: trunk/src/CacheWolf/navi/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoaderGui.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/MapLoaderGui.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,258 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.CacheHolder;
+import CacheWolf.CoordsScreen;
+import CacheWolf.Global;
+import CacheWolf.InfoBox;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+import ewe.io.File;
+import ewe.sys.Convert;
+import ewe.sys.Vm;
+import ewe.ui.*;
+import ewe.util.Vector;
+
+/**
+ * @author pfeffer
+ * This Class is the Dialog for Download calibrated from expedia.com
+ * is called from 
+ */
+
+public class MapLoaderGui extends Form {
+	mButton cancelB, okBtiles, okBPerCache, cancelBPerCache;
+	Preferences pref;
+	mTabbedPanel mTab = new mTabbedPanel();
+	CellPanel pnlTiles = new CellPanel();
+	CellPanel pnlPerCache = new CellPanel();
+
+	final String descString = "Download georeferenced maps from expedia.com";
+	mCheckBox forCachesChkBox = new mCheckBox("for");
+	mChoice forSelectedChkBox = new mChoice(new String[] {"all", "selected"}, 0);
+	mChoice forSelectedChkBoxPerCache = new mChoice(new String[] {"all", "selected"}, 1);
+	mLabel cachesLbl = new mLabel("caches");
+	mInput distanceInput;
+	mLabel distLbl;
+	mLabel km = new mLabel("km");
+	mLabel coosLbl;
+	mButton coosBtn;
+	mLabel scaleLbl = new mLabel("Approx. m per pixel:");
+	mInput scaleInput = new mInput ("3");
+	mInput scaleInputPerCache = new mInput ("1");
+	mLabel overlappingLbl = new mLabel("overlapping in pixel:");
+	mInput overlappingInput = new mInput("100");
+	mCheckBox overviewChkBox = new mCheckBox("download an overview map");
+	mCheckBox overviewChkBoxPerCache = new mCheckBox("download an overview map");
+
+	CWPoint center;
+	Vector cacheDB;
+	boolean perCache;
+	boolean onlySelected;
+	float radius;
+	float scale;
+	int overlapping;
+	boolean overviewmap;
+	int numCaches;
+
+	public MapLoaderGui(Vector cacheDBi) {
+		super();
+		this.title = MyLocale.getMsg(1800, "Download georeferenced maps"); 
+		pref = Global.getPref(); // myPreferences sollte sp?ter auch diese Einstellungen speichern
+		center = new CWPoint(pref.curCentrePt);
+		cacheDB = cacheDBi;
+		// tiles panel
+		MessageArea desc = new MessageArea(descString);
+		desc.modifyAll(mTextPad.NotEditable | mTextPad.DisplayOnly | mTextPad.NoFocus, mTextPad.TakesKeyFocus);
+		desc.borderStyle = mTextPad.BDR_NOBORDER;
+		pnlTiles.addLast(desc);
+		pnlTiles.addNext(forCachesChkBox);
+		pnlTiles.addNext(forSelectedChkBox);
+		pnlTiles.addLast(cachesLbl);
+		pnlTiles.addNext(distLbl = new mLabel(MyLocale.getMsg(1802,"Within a rectangle of:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		distanceInput = new mInput();
+		int tmp = Convert.toInt((Global.getProfile().distOC));
+		distanceInput.setText(Convert.toString((tmp > 0 ? tmp : 15)));
+		pnlTiles.addNext(distanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlTiles.addLast(km);
+		pnlTiles.addNext(coosLbl = new mLabel(MyLocale.getMsg(1803, "around the center: ")));
+		pnlTiles.addLast(coosBtn = new mButton(center.toString()));
+		pnlTiles.addNext(scaleLbl);
+		scaleInput.setText("5");
+		this.focusFirst();
+		pnlTiles.addLast(scaleInput);
+		//	pnlTiles.addLast(resolutionLbl);
+		pnlTiles.addNext(overlappingLbl);
+		pnlTiles.addLast(overlappingInput);
+		overviewChkBox.setState(true);
+		pnlTiles.addLast(overviewChkBox);
+		cancelB = new mButton(MyLocale.getMsg(1604,"Cancel"));
+		cancelB.setHotKey(0, IKeys.ESCAPE);
+		pnlTiles.addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		okBtiles = new mButton(MyLocale.getMsg(1605,"OK"));
+		okBtiles.setHotKey(0, IKeys.ACTION);
+		okBtiles.setHotKey(0, IKeys.ENTER);
+		pnlTiles.addLast(okBtiles,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		updateForCachesState();
+		mTab.addCard(pnlTiles, MyLocale.getMsg(1804, "Tiles"), MyLocale.getMsg(1804, "Tiles"));
+
+		// per cache panel
+		pnlPerCache.addLast(new MessageArea(descString));
+		pnlPerCache.addNext(new mLabel("Download one map for"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addNext(forSelectedChkBoxPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addLast(new mLabel("caches"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addNext(new mLabel("Approx. m per pixel"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addLast(scaleInputPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+
+		cancelBPerCache = new mButton(MyLocale.getMsg(1604,"Cancel"));
+		cancelBPerCache.setHotKey(0, IKeys.ESCAPE);
+		pnlPerCache.addNext(cancelBPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		okBPerCache = new mButton(MyLocale.getMsg(1605,"OK"));
+		okBPerCache.setHotKey(0, IKeys.ACTION);
+		okBPerCache.setHotKey(0, IKeys.ENTER);
+		pnlPerCache.addLast(okBPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+
+		mTab.addCard(pnlPerCache, MyLocale.getMsg(1805, "Per cache"), MyLocale.getMsg(1805, "Per Cache"));
+		this.addLast(mTab);
+	}
+	public String getMapsDir() {
+		return Global.getPref().getMapExpediaSavePath();
+	}
+	public void downloadTiles() {
+		String mapsDir = getMapsDir();
+		if (mapsDir == null) return;
+		InfoBox progressBox = new InfoBox("Downloading georeferenced maps", "Downloading georeferenced maps\n from www.expedia.com");
+		progressBox.setPreferredSize(230, 150);
+		progressBox.exec();
+		Vm.showWait(true);
+		ewe.fx.Point size = new ewe.fx.Point(1000,1000); // Size of the downloaded maps
+		MapLoader ml = new MapLoader(Global.getPref().myproxy, Global.getPref().myproxyport);
+		if (forCachesChkBox.getState() || perCache) {
+			Area surArea = Global.getProfile().getSourroundingArea(onlySelected); // calculate map boundaries from cacheDB
+			if (surArea == null) {
+				(new MessageBox("Error", "No Caches are seleted", MessageBox.OKB)).execute();
+				Vm.showWait(false);
+				progressBox.close(0);
+				return;
+			}
+			ml.setTiles(surArea.topleft, surArea.buttomright, (int)scale, size, overlapping );
+			// calculate radius and center for overview map
+			center = new CWPoint((surArea.topleft.latDec + surArea.buttomright.latDec)/2, (surArea.topleft.lonDec + surArea.buttomright.lonDec)/2);
+			double radiuslat = (new CWPoint(center.latDec, surArea.buttomright.lonDec)).getDistance(surArea.buttomright);
+			double radiuslon = (new CWPoint(surArea.buttomright.latDec, center.lonDec)).getDistance(surArea.buttomright);
+			radius = (float) (radiuslat < radiuslon ? radiuslon : radiuslat);
+		} else 
+		{ // calculate from center point an radius
+			ml.setTiles(center, radius * 1000, (int)scale, size, overlapping);
+		}
+		if (overviewmap) {
+			progressBox.setInfo("downloading overview map"); 
+			int expediaAlti = MapLoader.getExpediaAlti(center, radius * 1000, size);
+			ml.downloadMap(center.latDec, center.lonDec, expediaAlti, size.x, size.y, mapsDir);
+		}
+		if (!perCache){  // download tiles
+			ml.setProgressInfoBox(progressBox);
+			ml.downlaodTiles(mapsDir);
+		} else { // per cache
+			CacheHolder ch; 
+			CWPoint tmpca = new CWPoint();
+			int numdownloaded = 0;
+			Global.getProfile().getSourroundingArea(onlySelected); // calculate numCachesInArea
+			int numCaches = Global.getProfile().numCachesInArea;
+			for (int i=cacheDB.size()-1; i >= 0; i--) {
+				ch = (CacheHolder) cacheDB.get(i);
+				if (!this.onlySelected || ch.is_Checked) {
+					if (ch.pos == null) { // this can not happen
+						tmpca.set(ch.LatLon);
+						ch.pos = new CWPoint(tmpca);
+					}
+					if (ch.pos.isValid() && ch.pos.latDec != 0 && ch.pos.lonDec != 0) { // TODO != 0 sollte verschwinden, sobald das handling von nicht gesetzten Koos ?berall korrekt ist
+						numdownloaded++;
+						progressBox.setInfo("Downloading map from expedia.de\n"+numdownloaded+" / "+numCaches+"\n for cache:\n"+ch.CacheName);
+						ml.downloadMap(ch.pos.latDec, ch.pos.lonDec, (int)scale, size.x, size.y, mapsDir);
+					}
+				}
+			}
+		}
+		Vm.showWait(false);
+		ml.setProgressInfoBox(null);
+		progressBox.close(0);
+		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
+		(new MessageBox("Expedia maps", "Downloaded and calibrated the maps successfully", MessageBox.OKB)).execute();
+	}
+
+
+	private void updateForCachesState() {
+		int a, b;
+		if (forCachesChkBox.getState()) {
+			// create map rectangle from caches
+			a = 0;
+			b = Control.Disabled;
+		}
+		else { // use center and distance input
+			a = Control.Disabled;
+			b = 0;
+		}
+		forSelectedChkBox.modify(a, b);
+		cachesLbl.modify(a, b);
+		distanceInput.modify(b, a);
+		distLbl.modify(b, a);
+		coosBtn.modify(b, a);
+		coosLbl.modify(b, a);
+		km.modify(b,a);
+		repaintNow();
+
+	}
+
+	public void onEvent(Event ev){
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+			if (ev.target == cancelB || ev.target == cancelBPerCache){
+				this.close(Form.IDCANCEL);
+			}
+			if (ev.target == okBtiles || ev.target == okBPerCache){
+				if (ev.target == okBtiles) { // get tiles
+					perCache = false;
+					if (forSelectedChkBox.getSelectedItem().toString().equalsIgnoreCase("all")) onlySelected = false;
+					else onlySelected = true;
+					overviewmap = overviewChkBox.getState();
+					radius = Convert.toFloat(distanceInput.getText());
+					scale = Convert.toFloat(scaleInput.getText());
+					overlapping = Convert.toInt(overlappingInput.getText());
+					if (!forCachesChkBox.getState()) {
+						if (radius <= 0) { 
+							(new MessageBox("Error", "'radius' must be graeter than null", MessageBox.OKB)).execute();
+							return;
+						}
+						if (overlapping < 0) { 
+							(new MessageBox("Error", "'overlapping' must be greater or equal 0 ", MessageBox.OKB)).execute();
+							return;
+						}
+					}
+				} else { // per cache
+					perCache = true;
+					if (forSelectedChkBoxPerCache.getSelectedItem().toString().equalsIgnoreCase("all")) onlySelected = false;
+					else onlySelected = true;
+					overviewmap = overviewChkBoxPerCache.getState();
+					scale = Convert.toFloat(scaleInputPerCache.getText());
+				}
+				if (scale < 1 || scale != java.lang.Math.floor(scale)) {
+					(new MessageBox("Error", "'Approx. meter pro pixel' must be greater than 0 and must not contain a point", MessageBox.OKB)).execute();
+					return;
+				}
+				this.close(Form.IDOK); 
+				this.downloadTiles();
+			}
+			if (ev.target == coosBtn) {
+				CoordsScreen cs = new CoordsScreen();
+				cs.setFields(center, CWPoint.CW);
+				if (cs.execute() != CoordsScreen.IDCANCEL) {
+					center = cs.getCoords();
+					coosBtn.setText(center.toString());
+				}
+			}
+			if (ev.target == forCachesChkBox) {
+				updateForCachesState();
+			}
+		} // if controllEvent...
+		super.onEvent(ev);
+	}
+}

Added: trunk/src/CacheWolf/navi/MapSymbol.java
===================================================================
--- trunk/src/CacheWolf/navi/MapSymbol.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/MapSymbol.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,28 @@
+package CacheWolf.navi;
+
+import ewe.fx.*;
+import ewe.graphics.*;
+
+public class MapSymbol extends AniImage { // TODO make this implement MapImage, so that it will be invisible automatically if not on screen. When doing so, test if setgoto-pos -> open map from gotopanel shows the map symbols (directly after starting CW)
+	Object mapObject;
+	String name;
+	String filename;
+	double lat, lon;
+	public MapSymbol(String namei, String filenamei, double lati, double loni) {
+		name = namei;
+		filename = filenamei;
+		lat = lati;
+		lon = loni;
+	}
+	public MapSymbol(String namei, Object mapObjecti, Image fromIm, double lati, double loni) {
+		name = namei;
+		lat = lati;
+		lon = loni;
+		mapObject = mapObjecti;
+		setImage(fromIm);
+	}
+	public void loadImage(){
+		setImage(new Image(filename),0); freeSource();;
+		//properties = AniImage.AlwaysOnTop;
+	}
+}

Added: trunk/src/CacheWolf/navi/MapsList.java
===================================================================
--- trunk/src/CacheWolf/navi/MapsList.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/MapsList.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,326 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import utils.FileBugfix;
+import ewe.io.File;
+import ewe.io.IOException;
+import ewe.sys.Double;
+import ewe.ui.MessageBox;
+import ewe.util.Hashtable;
+import ewe.util.Vector;
+import ewe.fx.*;
+/**
+ * class to handle a list of maps
+ * it loads the list, finds the best map for a given location,
+ * says if a map is available for a given lat lon at a given scale
+ * @author r
+ *
+ */
+public class MapsList extends Vector {
+	public static float scaleTolerance = 1.15f; // absolute deviations from this factor are seen to have the same scale
+	public Hashtable scales2Area;
+
+	/**
+	 * loads alle the maps in mapsPath in all subDirs but not recursive, only one level 
+	 * @param mapsPath
+	 */
+	public MapsList(String mapsPath) {
+		super(); // forget already loaded maps
+		//if (mmp.mapImage != null) 
+		String dateien[];
+		FileBugfix files = new FileBugfix(mapsPath);
+		String rawFileName = new String();
+		String[] dirstmp = files.list(null, File.LIST_DIRECTORIES_ONLY);
+		Vector dirs;
+		if (dirstmp != null) dirs = new Vector(dirstmp);
+		else dirs = new Vector();
+		dirs.add("."); // include the mapsPath itself
+		MapInfoObject tempMIO;
+		MessageBox f = null;
+		for (int j = dirs.size()-1; j >= 0; j--) {
+			files = new FileBugfix(mapsPath+"/"+dirs.get(j));
+			//ewe.sys.Vm.debug("mapd-Dirs:"+files);
+			dateien = files.list("*.wfl", File.LIST_FILES_ONLY); //"*.xyz" doesn't work on some systems -> use FileBugFix
+			for(int i = 0; i < dateien.length;i++){
+				// if (!dateien[i].endsWith(".wfl")) continue;
+				rawFileName = dateien[i].substring(0, dateien[i].lastIndexOf("."));
+				try {
+					tempMIO = new MapInfoObject();
+					if (dirs.get(j).equals(".")) // the notation dir/./filename doesn't work on all platforms anyhow
+						tempMIO.loadwfl(mapsPath+"/", rawFileName);
+					else tempMIO.loadwfl(mapsPath+"/"+dirs.get(j)+"/", rawFileName);
+					add(tempMIO);
+				}catch(IOException ex){ 
+					if (f == null) (f=new MessageBox("Warning", "Ignoring error while \n reading calibration file \n"+ex.toString(), MessageBox.OKB)).exec();
+				}catch(ArithmeticException ex){ // affine contain not allowed values 
+					if (f == null) (f=new MessageBox("Warning", "Ignoring error while \n reading calibration file \n"+ex.toString(), MessageBox.OKB)).exec();
+				} 
+			}
+		}
+	}
+
+	public void addEmptyMaps(double lat) {
+		MapInfoObject tempMIO;
+		tempMIO = new MapInfoObject(1.0, lat);
+		add(tempMIO);
+		tempMIO = new MapInfoObject(5.0, lat);
+		add(tempMIO);
+		tempMIO = new MapInfoObject(50.0, lat);
+		add(tempMIO);
+		tempMIO = new MapInfoObject(250.0, lat);
+		add(tempMIO);
+		tempMIO = new MapInfoObject(1000.0, lat);
+		add(tempMIO);
+	}
+
+	/**
+	 * find the best map for lat/lon in the list of maps
+	 * currently the best map is the one, whose center is nearest to lat/lon
+	 * and in Area with its scale nearest to scale.
+	 * it always returns a map (if the list is not empty) 
+	 * even if the map is not inbound
+	 * lat/lon
+	 * @param lat
+	 * @param lon
+	 * @param forceScale: when true, return null if no map with specified scale could be found
+	 * @return
+	 */
+	public MapInfoObject getBestMap(double lat, double lon, Rect screen, float scale, boolean forceScale) {
+		if (size() == 0) return null;
+		if (scales2Area != null) scales2Area.clear();
+		MapInfoObject mi;
+		MapInfoObject bestMap = null; // = (MapInfoObject)get(0);
+		double minDistLat = 1000000000000000000000000000000000000000000000.0;
+		double minDistLon = 1000000000000000000000000000000000000000000000.0;
+		boolean latNearer, lonNearer;
+		boolean better = false;
+		Area screenArea = null; // getAreaForScreen(screen, lat, lon, bestMap.scale, bestMap);
+		float lastscale = -1;
+		for (int i=size()-1; i >= 0 ;i--) { 
+			better = false;
+			mi = (MapInfoObject)get(i);
+			if (screenArea == null || !scaleEquals(lastscale, mi) ) {
+				screenArea = getAreaForScreen(screen, lat, lon, mi.scale, mi);
+				lastscale = mi.scale;
+			}
+			if (screenArea.isOverlapping(mi.getArea()) ) { // is on screen
+				if (!forceScale || (forceScale && !scaleEquals(scale, mi))) { // different scale?
+					if (!forceScale && (mi.inBound(lat, lon) && (bestMap == null || scaleNearer(mi.scale, bestMap.scale, scale) || !bestMap.inBound(lat, lon)))) 
+						better = true; // inbound and resolution nearer at wanted resolution or old one is on screen but lat/long not inbound-> better
+					else {
+						if ( bestMap == null || scaleNearerOrEuqal(mi.scale, bestMap.scale, scale)) {
+							latNearer = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm < minDistLat ;
+							lonNearer = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm < minDistLon;
+							if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
+							else {
+								if ( (latNearer || lonNearer )) { 
+									if (bestMap == null || mi.center.getDistanceRad(lat, lon) < bestMap.center.getDistanceRad(lat, lon) ) better = true;
+								}
+							}
+						}
+					}
+					if (better) {
+						minDistLat = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm;
+						minDistLon = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm;
+						bestMap = mi;
+						// Vm.debug("better"+ i);
+					}
+				}
+			}
+		}
+		if (bestMap == null) return null;
+		return new MapInfoObject(bestMap); // return a copy of the MapInfoObject so that zooming won't change the MapInfoObject in the list 
+	}
+	/*
+	public MapInfoObject getBestMapNotStrictScale(double lat, double lon, Area screen, float scale) {
+		MapInfoObject ret = getBestMap(lat, lon, screen, scale, true);
+		if (ret == null) ret = getBestMap(lat, lon, screen, scale, false);
+		return ret;
+	}
+	 */
+	/**
+	 * @return a map which includs topleft and bottomright, 
+	 * if no map includes both it returns null
+	 * @param if more than one map includes topleft and bottomright than the one will
+	 * be returned which has its center nearest to topleft. If you have gps-pos and goto-pos
+	 * as topleft and buttomright use gps as topleft.
+	 * if topleft is really topleft or if it is buttomright is not relevant.  
+	 */
+	
+	public MapInfoObject getMapForArea(CWPoint topleft, CWPoint bottomright){
+		MapInfoObject mi;
+		MapInfoObject fittingmap = null;
+		boolean latNearer, lonNearer;
+		boolean better;
+		double minDistLat = 10000000000000000000000.0;
+		double minDistLon = 10000000000000000000000.0;
+		for (int i=size() -1; i>=0 ;i--) {
+			better = false;
+			mi = (MapInfoObject)get(i);
+			if (mi.inBound(topleft) && mi.inBound(bottomright)) { // both points are inside the map
+				if (fittingmap == null || fittingmap.scale > mi.scale * scaleTolerance) {
+					better = true; // mi map has a better (lower) scale than the last knwon good map
+				} else {
+					if (fittingmap != null && scaleEquals(mi, fittingmap)) { // same scale as bestmap till now -> test if its center is nearer to the gps-point = topleft
+						latNearer = java.lang.Math.abs(topleft.latDec- mi.center.latDec)/mi.sizeKm < minDistLat ;
+						lonNearer = java.lang.Math.abs(topleft.lonDec - mi.center.lonDec)/mi.sizeKm < minDistLon;
+						if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
+						else {
+							if ( (latNearer || lonNearer )) { 
+								if (mi.center.getDistanceRad(topleft.latDec, topleft.lonDec) < fittingmap.center.getDistanceRad(topleft.latDec, topleft.lonDec) ) better = true;
+							}
+						}
+
+					}
+				}
+				if (better) {
+					fittingmap = mi;
+					minDistLat = java.lang.Math.abs(topleft.latDec - mi.center.latDec);
+					minDistLon = java.lang.Math.abs(topleft.lonDec - mi.center.lonDec);
+				}
+			}
+		} // for
+		if (fittingmap == null) return null;
+		return new MapInfoObject(fittingmap);
+	}
+
+	/**
+	 * 
+	 * @param lat a point to be inside the map
+	 * @param lon
+	 * @param screen: width, height of the screen. The map must overlap the screen. xy: where is lat/lon on screen
+	 * @param curScale reference scale to be changed
+	 * @param moreDetails true: find map with more details == higher resolustion = lower scale / false find map with less details = better overview
+	 * @return
+	 */
+	public MapInfoObject getMapChangeResolution(double lat, double lon, Rect screen, float curScale, boolean moreDetails){
+		if (size() == 0) return null;
+		if (scales2Area != null) scales2Area.clear();
+		MapInfoObject mi;
+		MapInfoObject bestMap = null; // = (MapInfoObject)get(0);
+		double minDistLat = 1000000000000000000000000000000000000000000000.0;
+		double minDistLon = 1000000000000000000000000000000000000000000000.0;
+		boolean latNearer, lonNearer;
+		boolean better = false;
+		Area screenArea = null; // getAreaForScreen(screen, lat, lon, bestMap.scale, bestMap);
+		float lastscale = -1;
+		for (int i=size()-1; i >= 0 ;i--) { 
+			better = false;
+			mi = (MapInfoObject)get(i);
+			if (mi.fileNameWFL == "") continue; // exclude "maps" without image // TODO make this a boolean in MapInfoObject
+			if (screenArea == null || !scaleEquals(lastscale, mi)) {
+				screenArea = getAreaForScreen(screen, lat, lon, mi.scale, mi);
+				lastscale = mi.scale;
+			}
+			if (screenArea.isOverlapping(mi.getArea())) { // is on screen
+				if (bestMap == null || !scaleEquals(mi, bestMap)) { // different scale than known bestMap?
+					if (mi.inBound(lat, lon) && (      // more details wanted and this map has more details?                                // less details than bestmap
+							(moreDetails && (curScale > mi.scale * scaleTolerance) && (bestMap == null || mi.scale > bestMap.scale * scaleTolerance ) ) // higher resolution wanted and mi has higher res and a lower res than bestmap, because we dont want to overjump one resolution step
+							|| (!moreDetails && (curScale *  scaleTolerance < mi.scale) && (bestMap == null || mi.scale * scaleTolerance < bestMap.scale) ) // lower resolution wanted and mi has lower res and a higher res than bestmap, because we dont want to overjump one resolution step
+					) )	better = true;	// inbound and higher resolution if higher res wanted -> better
+				} else { // same scale as bestmap -> look if naerer 
+					latNearer = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm < minDistLat ;
+					lonNearer = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm < minDistLon;
+					if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
+					else {
+						if ( (latNearer || lonNearer )) { 
+							if (bestMap == null || mi.center.getDistanceRad(lat, lon) < bestMap.center.getDistanceRad(lat, lon) ) better = true;
+						}
+					}
+				} // same scale
+				if (better) {
+					minDistLat = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm;
+					minDistLon = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm;
+					bestMap = mi;
+					// Vm.debug("better"+ i);
+				}
+			}
+		}
+		if (bestMap == null) return null;
+		return new MapInfoObject(bestMap);
+	}
+	/**
+	 * returns an area in lat/lon of the screen
+	 * @param a screen width / height and position of lat/lon on the screen
+	 * @param lat a (reference) point on the screen
+	 * @param lon
+	 * @param scale scale (meters per pixel) of the map for which the screen edges are wanted
+	 * @param map map for which the screen edges are wanted
+	 * @return
+	 */
+	private Area getAreaForScreen(Rect a, double lat, double lon, float scale, MapInfoObject map) {
+		Area ret = null;
+/*		if (scales2Area == null) scales2Area = new Hashtable();
+		else ret = (Area)scales2Area.get(scale);
+		if (ret != null) return ret;
+	*/	// calculate screen Area
+		Point xy = map.calcMapXY(lat, lon);
+		Point topleft = new Point(xy.x - a.x, xy.y - a.y);
+		ret = new Area(map.calcLatLon(topleft), map.calcLatLon(topleft.x+a.width, topleft.y+a.height));
+		//scales2Area.put(new Float(scale), ret);
+		return ret; 
+	}
+	public static boolean scaleEquals(MapInfoObject a, MapInfoObject b) {
+		//return java.lang.Math.abs(a.scale - b.scale) < scaleTolerance;
+		if (a.scale > b.scale) return a.scale / b.scale < scaleTolerance; 
+		else return b.scale / a.scale < scaleTolerance;
+	}
+	public static boolean scaleEquals(float s, MapInfoObject b) {
+		//return java.lang.Math.abs(s - b.scale) < scaleTolerance;
+		if (s > b.scale) return s / b.scale < scaleTolerance;
+		else return b.scale / s < scaleTolerance;
+	}
+	
+	/**
+	 * 
+	 * @param test
+	 * @param old
+	 * @param wanted
+	 * @return true if test is nearer to wanted than old, false if the change in the scale is lower than scaleTolerance
+	 */
+	public static boolean scaleNearer(float test, float old, float wanted) {
+		float testa, wanta, wantb, olda;
+		if (test > wanted) { // ensure that first term is greater than 1
+			testa = test;
+			wanta = wanted;
+		} else {
+			testa = wanted;
+			wanta = test;
+		}
+		if (old > wanted) { // ensure that second term is greater than 1 
+			olda = old;
+			wantb = wanted;
+		} else {
+			olda = wanted;
+			wantb = old;
+		}
+		return testa/wanta * scaleTolerance < olda/wantb; 
+	}
+
+	public static boolean scaleNearerOrEuqal(float test, float old, float wanted) {
+		float testa, wanta, wantb, olda;
+		if (test > wanted) { // ensure that first term is greater than 1
+			testa = test;
+			wanta = wanted;
+		} else {
+			testa = wanted;
+			wanta = test;
+		}
+		if (old > wanted) { // ensure that second term is greater than 1 
+			olda = old;
+			wantb = wanted;
+		} else {
+			olda = wanted;
+			wantb = old;
+		}
+		return testa/wanta < olda/wantb * scaleTolerance ; 
+	}
+
+	/** for determining if a new map should be downloaded
+	public boolean isInAmap(CWPoint topleft, CWPoint buttomright) {
+		if (!latRangeList.isInRange(topleft.latDec) || !latRangeList.isInRange(buttomright.latDec)) ||
+			!lonRangeList.inInRange(topleft.lonDec) || !lonRangeList.isInRange(buttomright.lonDec)
+			return false;
+	}
+	 */
+}

Added: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,2025 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.CacheHolder;
+import CacheWolf.Global;
+import CacheWolf.InfoBox;
+import CacheWolf.MainTab;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+import CacheWolf.myTableModel;
+import ewe.ui.*;
+import ewe.graphics.*;
+import ewe.io.File;
+import ewe.io.IOException;
+import ewe.sys.*;
+import ewe.filechooser.FileChooser;
+import ewe.fx.*;
+import ewe.util.Vector;
+
+/**
+ *	Class to handle a moving map.
+ */
+public class MovingMap extends Form {
+	public final static int gotFix = 4; //green
+	public final static int lostFix = 3; //yellow
+	public final static int noGPSData = 2; // red
+	public final static int noGPS = 1; // no GPS-Position marker, manually disconnected 
+	public final static int ignoreGPS = -1; // ignore even changes in GPS-signal (eg. from lost fix to gotFix) this is wanted when the map is moved manually
+
+	public MapSymbol gotoPos = null;
+	public int GpsStatus;
+	Preferences pref;
+	MovingMapPanel mmp;
+	MapsList maps;
+	Vector symbols;
+	Vector cacheDB;
+	TrackOverlay[] TrackOverlays;
+	CWPoint TrackOverlaySetCenterTopLeft;
+	Vector tracks;
+	MapInfoObject currentMap = null;
+	String mapPath;
+	Navigate myNavigation;
+	boolean running = false;
+
+	MapImage mapImage1to1;
+	ArrowsOnMap directionArrows = new ArrowsOnMap();
+	AniImage statusImageHaveSignal = new AniImage("position_green.png");
+	AniImage statusImageNoSignal = new AniImage("position_yellow.png");
+	AniImage statusImageNoGps = new AniImage("position_red.png");
+	AniImage bottonImageClose;
+	AniImage bottonImageChooseMap = new AniImage("choose_map.gif"); 
+	AniImage buttonImageGpsOn = new AniImage("snap2gps.gif");
+	AniImage buttonImageLens = new AniImage("lupe.png");
+	AniImage buttonImageLensActivated = new AniImage("lupe_activated.png");
+	AniImage buttonImageZoom1to1 = new AniImage("zoom1to1.png");
+	AniImage DistanceImage;
+	Graphics DistanceImageGraphics;
+	AniImage ScaleImage;
+	Graphics ScaleImageGraphics;
+	MapImage posCircle = new MapImage("position_green.png");
+	public static final String MARK_CACHE_IMAGE = "mark_cache.png";
+	int posCircleX = 0, posCircleY = 0, lastCompareX = Integer.MAX_VALUE, lastCompareY = Integer.MAX_VALUE;
+	double posCircleLat, posCircleLon;
+	FontMetrics fm;
+
+	boolean dontUpdatePos = false; // this is only internaly used to avoid multi-threading problems
+	boolean ignoreGps = false; // ignores updateGps-calls if true
+	boolean autoSelectMap = true;
+	boolean forceMapLoad = true; // only needed to force updateposition to try to load the best map again after OutOfMemoryError after an repeated click on snap-to-gps
+	boolean mapHidden = false;
+	boolean noMapsAvailable;
+	boolean zoomingMode = false;
+	boolean mapsloaded = false;
+	
+	Point lastRepaintMapPos = null;
+	double lastDistance = -1;
+
+	public MovingMap(Navigate nav, Vector cacheDB){
+		this.cacheDB = cacheDB;
+		this.myNavigation = nav;
+		this.pref = Global.getPref();
+		if (pref.myAppHeight <= 640 && pref.myAppWidth <= 640)	this.windowFlagsToSet = Window.FLAG_FULL_SCREEN;
+		this.windowFlagsToClear = Window.FLAG_HAS_TITLE | Window.BDR_NOBORDER;
+		this.hasTopBar = false;
+		this.noBorder = true;
+		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
+		this.title = "Moving Map";
+		this.backGround = new Color(254,254,254); // background must not be black because black is interpreted as transparent and transparent images above (eg trackoverlay) want be drawn in windows-VM, so be care, don|t use white either
+		this.mapPath = Global.getPref().getMapLoadPath();
+
+		mmp = new MovingMapPanel(this);
+		this.addLast(mmp);
+		DrawnIcon closeX = new DrawnIcon(DrawnIcon.CROSS,15,15,new Color(0,0,0));
+		bottonImageClose = new AniImage(new Image(closeX.getWidth(), closeX.getHeight()));
+		Graphics tmp = new Graphics(bottonImageClose.image);
+		tmp.setColor(255, 255, 255);
+		tmp.fillRect(0, 0, closeX.getWidth(), closeX.getHeight());
+		closeX.doDraw(tmp, 0);
+		bottonImageClose.properties |= AniImage.AlwaysOnTop;
+		mmp.addImage(bottonImageClose);
+		buttonImageGpsOn.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(buttonImageGpsOn);
+		bottonImageChooseMap.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(bottonImageChooseMap);
+		directionArrows.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(directionArrows);
+		buttonImageLens.properties = AniImage.AlwaysOnTop;
+		buttonImageLensActivated.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(buttonImageLens);
+		buttonImageZoom1to1.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(buttonImageZoom1to1);
+		//target distance
+		Font font = new Font("Helvetica", Font.PLAIN, 13);
+		fm = getFontMetrics(font);
+		DistanceImage = new AniImage();
+		DistanceImage.setImage(new Image(120, 15), Color.White); // consider the size of the font used
+		DistanceImageGraphics = new Graphics(DistanceImage.image);
+		DistanceImageGraphics.setFont(font);
+		DistanceImage.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(DistanceImage);
+		//scale
+		ScaleImage = new AniImage();
+		ScaleImage.setImage(new Image(120, 15), Color.White); // consider the size of the font used
+		ScaleImageGraphics = new Graphics(ScaleImage.image);
+		ScaleImageGraphics.setFont(font);
+		ScaleImage.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(ScaleImage);
+		//resizeTo(pref.myAppWidth, pref.myAppWidth); // is necessary to initialize mapImage.screenSize
+		setGpsStatus(noGPS);
+		posCircle.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(posCircle);
+		mmp.startDragResolution = 5;
+		mapsloaded = false;
+		posCircleLat = -361;
+		posCircleLon = -361; // make them invalid
+		//updateDistance(); // fill Rect with transparent color
+		scaleWanted = 1;
+		mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
+		
+		lastRepaintMapPos = new Point(pref.myAppWidth +1, pref.myAppHeight +1);
+	}
+
+	public void resizeTo(int w,int h) {
+		super.resizeTo(w, h);
+		updateFormSize(w, h);
+	}
+
+	public void updateFormSize(int w, int h) {
+		MapImage.setScreenSize(w, h);
+		bottonImageClose.setLocation(w- bottonImageClose.getWidth()- 5, 5);
+		buttonImageGpsOn.setLocation(w- bottonImageChooseMap.getWidth()-5, bottonImageClose.getHeight() + 20);
+		bottonImageChooseMap.setLocation(10,10);
+		directionArrows.setLocation(w/2-directionArrows.getWidth()/2, 10);
+		buttonImageZoom1to1.setLocation(w - buttonImageZoom1to1.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 - buttonImageZoom1to1.getHeight() -10);
+		buttonImageLens.setLocation(w - buttonImageLens.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 );
+		buttonImageLensActivated.setLocation(w - buttonImageLens.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 );
+		DistanceImage.setLocation(0, h - DistanceImage.getHeight());
+		ScaleImage.setLocation(w - ScaleImage.getWidth(), h - ScaleImage.getHeight());
+		if (mmp.mapImage != null) mmp.mapImage.move(mmp.mapImage.locAlways.x, mmp.mapImage.locAlways.y); // this is necessary to make a new decision if it is still on the screen (and actually mor important because MapImage only now gets to know the screen size) 
+		if (posCircle != null) posCircle.move(posCircle.locAlways.x, posCircle.locAlways.y); // this is necessary to make a new decision if it is still on the screen (and actually mor important because MapImage only now gets to know the screen size) 
+		if (tracks != null) addOverlaySet();
+	}
+
+	boolean loadingMapList = false;
+	/**
+	 * loads the list of maps
+	 * @param mapsPath must not have a trailing end "/"
+	 * @param lat used to create empty maps with correct conversion from lon to meters the latitude must be known
+	 */
+	public void loadMaps(String mapsPath, double lat){
+		if (loadingMapList) return;
+		loadingMapList = true;
+		this.mapPath = mapsPath;
+		Vm.showWait(this, true);
+		resetCenterOfMap();
+		InfoBox inf = new InfoBox("Info", "Loading list of maps...");
+		inf.exec();
+		inf.waitUntilPainted(100);
+		boolean saveGpsIgnoreStatus = dontUpdatePos;
+		dontUpdatePos = true;
+		maps = new MapsList(mapsPath); // this actually loads the maps
+		if (maps.isEmpty()) {
+			(new MessageBox(MyLocale.getMsg(327, "Information"), MyLocale.getMsg(326, "Es steht keine kalibrierte Karte zur Verf?gung \n Bitte w?hlen Sie einen Ma?stab,\n in dem der Track und die markierten Caches angezeigt werden sollen"), MessageBox.OKB)).execute();
+			noMapsAvailable = true;
+		} else noMapsAvailable = false;
+		maps.addEmptyMaps(lat);
+		dontUpdatePos = saveGpsIgnoreStatus;
+		inf.close(0);
+		Vm.showWait(this, false);
+		this.mapsloaded = true;
+		loadingMapList = false;
+	}
+
+	public void updateScale() {
+		ScaleImageGraphics.setColor(ScaleImage.transparentColor);
+		ScaleImageGraphics.fillRect(0, 0, ScaleImage.location.width,ScaleImage.location.height);
+		
+		if (currentMap != null)
+		{
+			float lineLengthMeters = 40 * currentMap.scale;
+			float digits = (float)java.lang.Math.floor( java.lang.Math.log(lineLengthMeters) / java.lang.Math.log(10.0) );
+			lineLengthMeters = (float)java.lang.Math.ceil( lineLengthMeters / (float)java.lang.Math.pow(10, digits) ) * (float)java.lang.Math.pow(10, digits);
+			int lineLengthPixels = (int)java.lang.Math.round( lineLengthMeters / currentMap.scale );
+
+			String lineLengthString;
+			if (lineLengthMeters < 1000)
+			{
+				lineLengthString = Convert.toString((int) lineLengthMeters) + "m";
+			}
+			else
+			{
+				lineLengthString = Convert.toString((int) lineLengthMeters / 1000) + "km";
+			}
+			
+			int backgroundStartX = ScaleImage.location.width - (lineLengthPixels + fm.getTextWidth(lineLengthString) + 7);
+			
+			ScaleImageGraphics.setColor(new Color(250,250,250));
+			ScaleImageGraphics.fillRect(backgroundStartX, 0, ScaleImage.location.width - backgroundStartX ,ScaleImage.location.height);
+
+			ScaleImageGraphics.setPen(new Pen(Color.DarkBlue,Pen.SOLID,3));
+			ScaleImageGraphics.drawLine(backgroundStartX + 2, ScaleImage.location.height / 2, backgroundStartX+2+lineLengthPixels, ScaleImage.location.height / 2);
+			ScaleImageGraphics.setColor(Color.DarkBlue);
+			ScaleImageGraphics.drawText(lineLengthString , backgroundStartX + lineLengthPixels + 5, 0);
+		}
+		
+		ScaleImageGraphics.drawImage(ScaleImage.image,null,Color.LightBlue,0,0,ScaleImage.location.width,ScaleImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+		ScaleImageGraphics.drawImage(ScaleImage.image,null,Color.White,0,0,ScaleImage.location.width,ScaleImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
+	}
+	
+	public void updateDistance(boolean repaint) {
+		DistanceImageGraphics.setColor(DistanceImage.transparentColor);
+		DistanceImageGraphics.fillRect(0, 0, DistanceImage.location.width,DistanceImage.location.height);
+		if (gotoPos != null && posCircleLat >= -360)
+		{
+			double currentDistance = (new CWPoint(gotoPos.lat, gotoPos.lon).getDistance(posCircleLat, posCircleLon));
+			if (currentDistance != lastDistance)
+			{
+				lastDistance = currentDistance;
+				ewe.sys.Double dd = new ewe.sys.Double();
+				dd.set(currentDistance);
+				String d;
+				if (dd.value < 1) {
+					dd.value = dd.value * 1000; 
+					dd.decimalPlaces = 0;
+					d = "Dist: " + dd.toString() + "m";
+					int digits = (int)java.lang.Math.floor( java.lang.Math.log(dd.value) / java.lang.Math.log(10.0) );
+					digits = java.lang.Math.max(0, digits);
+				} 
+				else {
+					dd.decimalPlaces = 2;
+					d = "Dist: " + dd.toString() + "km";
+					int digits = (int)java.lang.Math.floor( java.lang.Math.log(dd.value) / java.lang.Math.log(10.0) );
+					digits = java.lang.Math.max(0, digits);
+				}
+				
+				int backgroundWidth = fm.getTextWidth(d) + 4;
+
+				DistanceImageGraphics.setColor(new Color(250,250,250));
+				DistanceImageGraphics.fillRect(0, 0, backgroundWidth ,DistanceImage.location.height);
+
+				DistanceImageGraphics.setColor(Color.DarkBlue);
+				DistanceImageGraphics.drawText(d, 2, 0);
+				
+				DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.LightBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+				DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.White,0,0,DistanceImage.location.width,DistanceImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
+				if (repaint)
+				{
+					DistanceImage.refreshNow();
+				}
+			}
+		}
+		else
+		{
+			DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.LightBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+			DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.White,0,0,DistanceImage.location.width,DistanceImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
+		}
+	}
+
+	public void forceMapLoad() {
+		forceMapLoad = true;
+		updatePosition(posCircleLat, posCircleLon); // this sets forceMapLoad to false after loading a map
+	}
+
+	public final FormFrame myExec() {
+		// update cache symbols in map
+		running = true;
+		MainTab mainT = Global.mainTab;
+		if (Global.getProfile().selectionChanged) {
+			Global.getProfile().selectionChanged = false;
+			removeAllMapSymbolsButGoto();
+			CacheHolder ch;
+			for (int i=cacheDB.size()-1; i>=0; i--) {
+				ch = (CacheHolder) cacheDB.get(i);
+				if (ch.is_Checked && !ch.is_filtered && ch != mainT.ch) {
+					int ct = Convert.parseInt(ch.type);
+					addSymbol(ch.CacheName, ch, myTableModel.cacheImages[ct], ch.pos.latDec, ch.pos.lonDec);
+				}
+			}
+		}
+		setMarkedCache(mainT.ch);
+		addTrack(myNavigation.curTrack);
+		if (tracks != null && tracks.size() > 0 && ((Track)tracks.get(0)).num > 0) 
+			addOverlaySet(); // show points which where added when MavingMap was not running
+		destChanged(myNavigation.destination);
+		FormFrame ret = exec();
+		return ret;
+	}
+	
+	CacheHolder markedCache = null;
+	public void setMarkedCache(CacheHolder ch) {
+		if (ch == markedCache) return;
+		if (markedCache != null) {
+			removeMapSymbol("selectedCache");
+			if (!markedCache.is_Checked) removeMapSymbol(markedCache);
+		}
+		if (ch != null) {
+			addSymbol("selectedCache", MARK_CACHE_IMAGE, ch.pos.latDec, ch.pos.lonDec);
+			int ct = Convert.parseInt(ch.type);
+			addSymbolIfNecessary(ch.CacheName, ch, myTableModel.cacheImages[ct], ch.pos.latDec, ch.pos.lonDec);
+		}
+		markedCache = ch;
+	}
+	
+	public void addTrack(Track tr) {
+		if (tr == null) return;
+		if (tracks == null) tracks = new Vector();
+		if (tracks.find(tr) >= 0 ) return; // track already in list
+		tracks.add(tr);
+		addOverlaySet();
+	}
+
+	public void addTracks(Track[] trs) {
+		if (trs==null || trs.length == 0) return;
+		for (int i=0; i<trs.length; i++) {
+			addTrack(trs[i]);
+		}
+		addOverlaySet();
+	}
+
+	/**
+	 * adds an 3x3 set of overlays to the map-window which contain the track
+	 * 
+	 * add tracks with addtrack(track) before
+	 */
+
+	public void addOverlaySet() {
+		destroyOverlaySet();
+		if (tracks == null) return; // no tracks
+		try {
+			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
+			addMissingOverlays();
+		} catch (NullPointerException e) {} // hapens if currentmap == null or PosCircle not valid
+		catch (IllegalArgumentException e) {} // happens if screensize is still not known    ---> in both cases creation of Overlayset will be done in updateOverlayPos if tracks != null 
+	}
+
+	public void destroyOverlaySet() {
+		if (TrackOverlays != null) {
+			for (int i=0; i< TrackOverlays.length; i++) {	destroyOverlay(i);	}
+		}
+		Vm.getUsedMemory(true); // call garbage collection
+		Vm.gc();
+	}
+
+
+	public void addMissingOverlays() {
+		if (currentMap == null || posCircleLat < -360 || width == 0 || height == 0) return; // height == 0 happens if this is called before the form ist displayed on the screen
+		if (TrackOverlays == null) {
+			TrackOverlays = new TrackOverlay[9];
+			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
+		}
+		boolean saveGPSIgnoreStatus = dontUpdatePos; // avoid multi-threading problems
+		dontUpdatePos = true;
+		Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft.latDec, TrackOverlaySetCenterTopLeft.lonDec); // TrackOverlay[4] == center of Trackoverlays 
+		//upperleftOf4.x = (upperleftOf4.x + 1* width) % (width * 2) - 1 * width;
+		//upperleftOf4.y = (upperleftOf4.y + 1* height) % (height * 2) - 1 * height;
+		int i;
+		for (int yi=0; yi<3; yi++) {
+			for (int xi=0; xi<3; xi++) {
+				i = yi*3+xi;
+				if (TrackOverlays[i]==null) { 
+					TrackOverlays[i]= new TrackOverlay(ScreenXY2LatLon(upperleftOf4.x+(xi-1)*width, upperleftOf4.y+(yi-1)*height), width, height, currentMap); 
+					TrackOverlays[i].setLocation(width+1, height+1); // outside of the screen will hide it automatically it will get the correct position in upadteOverlayposition 
+					TrackOverlays[i].tracks = this.tracks;
+					TrackOverlays[i].paintTracks();
+					mmp.addImage(TrackOverlays[i]);
+				}
+			}
+		}
+		updateOverlayOnlyPos();
+		if (mmp.mapImage != null) mmp.images.moveToBack(mmp.mapImage);
+		dontUpdatePos = saveGPSIgnoreStatus;
+	}
+
+	private void destroyOverlay(int ov) {
+		if (TrackOverlays[ov] == null) return; 
+		mmp.removeImage(TrackOverlays[ov]);
+		TrackOverlays[ov].free();
+		TrackOverlays[ov]=null;
+	}
+	public void rearangeOverlays() {
+		Point oldp = getXYonScreen(TrackOverlaySetCenterTopLeft.latDec, TrackOverlaySetCenterTopLeft.lonDec);
+		if (TrackOverlays[1].isOnScreen()) { // oben raus
+			TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y - 2* height));
+			destroyOverlay(6);
+			destroyOverlay(7);
+			destroyOverlay(8);
+			mmp.removeImage(TrackOverlays[0]);
+			mmp.removeImage(TrackOverlays[1]);
+			mmp.removeImage(TrackOverlays[2]);
+			TrackOverlays[6]=TrackOverlays[0];
+			TrackOverlays[7]=TrackOverlays[1];
+			TrackOverlays[8]=TrackOverlays[2];
+			mmp.addImage(TrackOverlays[6]);
+			mmp.addImage(TrackOverlays[7]);
+			mmp.addImage(TrackOverlays[8]);
+			TrackOverlays[0] = null;
+			TrackOverlays[1] = null;
+			TrackOverlays[2] = null;
+			destroyOverlay(3);
+			destroyOverlay(4);
+			destroyOverlay(5);
+		} else {
+			if (TrackOverlays[3].isOnScreen()) { // links raus
+				TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y ));
+				destroyOverlay(2);
+				destroyOverlay(5);
+				destroyOverlay(8);
+				mmp.removeImage(TrackOverlays[0]);
+				mmp.removeImage(TrackOverlays[3]);
+				mmp.removeImage(TrackOverlays[6]);
+				TrackOverlays[2]=TrackOverlays[0];
+				TrackOverlays[5]=TrackOverlays[3];
+				TrackOverlays[8]=TrackOverlays[6];
+				mmp.addImage(TrackOverlays[2]);
+				mmp.addImage(TrackOverlays[5]);
+				mmp.addImage(TrackOverlays[8]);
+				TrackOverlays[0] = null;
+				TrackOverlays[3] = null;
+				TrackOverlays[6] = null;
+				destroyOverlay(1);
+				destroyOverlay(4);
+				destroyOverlay(7);
+			} else {
+				if (TrackOverlays[5].isOnScreen()) { // rechts raus
+					TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y ));
+					destroyOverlay(0);
+					destroyOverlay(3);
+					destroyOverlay(6);
+					mmp.removeImage(TrackOverlays[2]);
+					mmp.removeImage(TrackOverlays[5]);
+					mmp.removeImage(TrackOverlays[8]);
+					TrackOverlays[0]=TrackOverlays[2];
+					TrackOverlays[3]=TrackOverlays[5];
+					TrackOverlays[6]=TrackOverlays[8];
+					mmp.addImage(TrackOverlays[0]);
+					mmp.addImage(TrackOverlays[3]);
+					mmp.addImage(TrackOverlays[6]);
+					TrackOverlays[2] = null;
+					TrackOverlays[5] = null;
+					TrackOverlays[8] = null;
+					destroyOverlay(1);
+					destroyOverlay(4);
+					destroyOverlay(7);
+				} else {
+					if (TrackOverlays[7].isOnScreen()) { // unten raus
+						TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y + 2* height));
+						destroyOverlay(0);
+						destroyOverlay(1);
+						destroyOverlay(2);
+						mmp.removeImage(TrackOverlays[6]);
+						mmp.removeImage(TrackOverlays[7]);
+						mmp.removeImage(TrackOverlays[8]);
+						TrackOverlays[0]=TrackOverlays[6];
+						TrackOverlays[1]=TrackOverlays[7];
+						TrackOverlays[2]=TrackOverlays[8];
+						mmp.addImage(TrackOverlays[0]);
+						mmp.addImage(TrackOverlays[1]);
+						mmp.addImage(TrackOverlays[2]);
+						TrackOverlays[6] = null;
+						TrackOverlays[7] = null;
+						TrackOverlays[8] = null;
+						destroyOverlay(3);
+						destroyOverlay(4);
+						destroyOverlay(5);
+					} else { // it is important to test for diagonal only if the other didn't match
+						if (TrackOverlays[0].isOnScreen()) {  // links oben raus
+							TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y - 2* height));
+							destroyOverlay(8);
+							mmp.removeImage(TrackOverlays[0]);
+							TrackOverlays[8]=TrackOverlays[0];
+							mmp.addImage(TrackOverlays[8]);
+							TrackOverlays[0] = null;
+							destroyOverlay(1);
+							destroyOverlay(2);
+							destroyOverlay(3);
+							destroyOverlay(4);
+							destroyOverlay(5);
+							destroyOverlay(6);
+							destroyOverlay(7);
+						} else {
+							if (TrackOverlays[2].isOnScreen()) { // rechts oben raus
+								TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y - 2* height));
+								destroyOverlay(6);
+								mmp.removeImage(TrackOverlays[2]);
+								TrackOverlays[6]=TrackOverlays[2];
+								mmp.addImage(TrackOverlays[6]);
+								TrackOverlays[2] = null;
+								destroyOverlay(0);
+								destroyOverlay(1);
+								destroyOverlay(3);
+								destroyOverlay(4);
+								destroyOverlay(5);
+								destroyOverlay(7);
+								destroyOverlay(8);
+							} else {
+								if (TrackOverlays[6].isOnScreen()) { // links unten raus
+									TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y + 2* height));
+									destroyOverlay(2);
+									mmp.removeImage(TrackOverlays[6]);
+									TrackOverlays[2]=TrackOverlays[6];
+									mmp.addImage(TrackOverlays[2]);
+									TrackOverlays[6] = null;
+									destroyOverlay(0);
+									destroyOverlay(1);
+									destroyOverlay(3);
+									destroyOverlay(4);
+									destroyOverlay(5);
+									destroyOverlay(7);
+									destroyOverlay(8);
+								} else {
+									if (TrackOverlays[8].isOnScreen()) { // rechts unten raus
+										TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y + 2* height));
+										destroyOverlay(0);
+										mmp.removeImage(TrackOverlays[8]);
+										TrackOverlays[0]=TrackOverlays[8];
+										mmp.addImage(TrackOverlays[0]);
+										TrackOverlays[8] = null;
+										destroyOverlay(1);
+										destroyOverlay(2);
+										destroyOverlay(3);
+										destroyOverlay(4);
+										destroyOverlay(5);
+										destroyOverlay(6);
+										destroyOverlay(7);
+									}else
+										for (int i=0; i<TrackOverlays.length; i++) {
+											destroyOverlay(i);
+											TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
+										} // this happens if a position jump occured
+								}}}}}}} // close all IFs
+		Vm.gc(); // call garbage collection
+		Vm.debug("Overlayrearanged"+TrackOverlays.toString());
+	}
+
+	public void ShowLastAddedPoint(Track tr) {
+		if (TrackOverlays == null || tr == null) return;
+		for (int i=0; i<TrackOverlays.length; i++){
+			TrackOverlays[i].paintLastAddedPoint(tr);
+		}
+	}
+
+	public void updateOverlayOnlyPos() {
+		if (TrackOverlays == null || TrackOverlays[4] == null) return;
+		//	Point upperleft = getMapXYPosition();
+		Point posOnScreen;
+		posOnScreen = getXYonScreen(TrackOverlays[4].topLeft.latDec, TrackOverlays[4].topLeft.lonDec);
+		Dimension ws = mmp.getSize(null);
+		int ww = ws.width;
+		int wh = ws.height;
+		//Vm.sleep(100); // this is necessary because the ewe vm ist not multi-threaded and the serial thread also needs time
+		int num, x, y;
+		for (int yi=0; yi<3; yi++) {
+			for (int xi=0; xi<3; xi++) {
+				num = yi*3+xi;
+				x = posOnScreen.x+(xi-1)*ww;
+				y = posOnScreen.y+(yi-1)*wh; 
+				TrackOverlays[num].setLocation(x, y);
+			}
+		}
+	}
+
+	public void updateOverlayPos() {
+		if (tracks == null || tracks.size() == 0) return;
+		if (TrackOverlays == null || TrackOverlays[4] == null) addMissingOverlays();
+		else {
+			updateOverlayOnlyPos();
+			if (TrackOverlays[0].locAlways.x > 0 || TrackOverlays[2].locAlways.x < 0
+					|| TrackOverlays[0].locAlways.y > 0 || TrackOverlays[8].locAlways.y < 0) { // testForNeedToRearange
+				rearangeOverlays();
+				addMissingOverlays();
+				// updateOverlayOnlyPos(); is called from addMissingOverlays 
+			}
+		}
+	}
+
+	/**
+	 * move posCircle to the Center of the Screen
+	 *
+	 */
+	public void resetCenterOfMap() {
+		if (width != 0) {
+			posCircleX = width /2;
+			posCircleY = height /2;
+		} else {
+			posCircleX = pref.myAppWidth/2; // maybe this could /should be repleced to windows size
+			posCircleY = pref.myAppHeight/2;
+		}
+		posCircle.hidden = false;
+		posCircle.move(posCircleX-posCircle.getWidth()/2, posCircleY-posCircle.getHeight()/2); // posCircle.setLocation caused a problem -> hiding the posCircle in some situation
+	}
+
+	public void movePosCircleToLatLon(CWPoint p, boolean repaint) {
+		moveScreenXYtoLatLon(new Point(posCircleX, posCircleY), p, repaint);
+	}
+
+	public void setCenterOfScreen (CWPoint c, boolean repaint) {
+		moveScreenXYtoLatLon(new Point (this.width/2, this.height/2), c, repaint);
+	}
+
+	public void moveScreenXYtoLatLon(Point s, CWPoint c, boolean repaint) {
+		Point mappos = getMapPositionOnScreen();
+		Point onscreenpos = getXYonScreen(c.latDec, c.lonDec);
+		if (mmp != null && mmp.mapImage != null) mmp.mapImage.move(mappos.x - onscreenpos.x + s.x, mappos.y - onscreenpos.y + s.y);
+		mapMoved(s.x - onscreenpos.x, s.y - onscreenpos.y);
+		if (repaint) mmp.repaintNow();
+	}
+
+	/** call this if the map moved on the screen (by dragging)
+	 * this routine will adjust (move accordingly) all other symbols on the screen
+	 * @param diffX
+	 * @param diffY
+	 */
+	public void mapMoved(int diffX, int diffY) {
+		int w = posCircle.getWidth();
+		int h = posCircle.getHeight();
+		int npx = posCircleX-w/2+diffX; 
+		int npy = posCircleY-h/2+diffY;
+		posCircle.move(npx, npy);
+		posCircleX = posCircleX+diffX;
+		posCircleY = posCircleY+diffY;
+		updateSymbolPositions();
+		updateOverlayPos();
+	}
+
+	/**
+	 * get upper left corner of map on window
+	 * this is called when the map needs to be moved / the position of the map is wanted
+	 * the map-position is calculated relativ to posCircle (x,y and lat/lon)
+	 * returns the same as mmp.mapImage.getLocation(mapPos);
+	 * but also works if mmp == null and is used to move the map to the correct point
+	 * @return
+	 */
+	public Point getMapPositionOnScreen() {
+		if (currentMap == null || posCircleLon < -360) return new Point(pref.myAppWidth +1, pref.myAppHeight +1); // in case no calculation is possible return somthing outside of the screen
+		Point mapPos = new Point(); 
+		//if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
+		//else {
+		Point mapposint = currentMap.calcMapXY(posCircleLat, posCircleLon);
+		mapPos.x = posCircleX - mapposint.x;
+		mapPos.y = posCircleY - mapposint.y;
+		//}
+		return mapPos;
+	}
+
+	/**
+	 * 
+	 * @param lat
+	 * @param lon
+	 * @return
+	 */
+	public Point getXYonScreen(double lat, double lon){
+		if (currentMap == null) return null;
+		Point coords = currentMap.calcMapXY(lat, lon);
+		Point mapPos = getMapPositionOnScreen();
+		//		Vm.debug("getXYinMap, posCiLat: "+posCircleLat+"poscLOn: "+ posCircleLon+"gotoLat: "+ lat + "gotoLon: "+ lon+" mapPosX: "+mapPos.x+"mapposY"+mapPos.y);
+		return new Point(coords.x + mapPos.x, coords.y + mapPos.y);
+	}
+
+	public CWPoint ScreenXY2LatLon (int x, int y){
+		Point mapPos = getMapPositionOnScreen();
+		return currentMap.calcLatLon(x - mapPos.x, y - mapPos.y);
+	}
+
+
+	public void updateSymbolPositions() {
+		if (symbols == null) return;
+		Point pOnScreen;
+		MapSymbol symb;
+		int ww = this.width;
+		int wh = this.height;
+		int w, h;
+		for (int i=symbols.size()-1; i>=0; i--) {
+			symb = (MapSymbol)symbols.get(i);
+			pOnScreen = getXYonScreen(symb.lat, symb.lon);
+			w=symb.getWidth();
+			h=symb.getHeight();
+			if (pOnScreen.x+w >= 0 && pOnScreen.x <= ww && pOnScreen.y+h >= 0 &&  pOnScreen.y <= wh) 
+			{
+				symb.properties &= ~mImage.IsInvisible;
+				symb.move(pOnScreen.x-w/2, pOnScreen.y-h/2);
+			}
+			else 
+			{symb.properties |= mImage.IsInvisible;
+			symb.move(30, 30);
+			}
+			//symb.pic.move(ww+1, wh+1);
+		}
+	}
+
+	public MapSymbol addSymbol(String name, String filename, double lat, double lon) {
+		if (symbols==null) symbols=new Vector();
+		MapSymbol ms = new MapSymbol(name, filename, lat, lon);
+		ms.loadImage();
+		ms.properties |= AniImage.AlwaysOnTop;
+		Point pOnScreen = getXYonScreen(lat, lon);
+		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		symbols.add(ms);
+		mmp.addImage(ms);
+		return ms;
+	}
+	
+	public void addSymbolIfNecessary(String name, Object mapObject, Image imSymb, double lat, double lon) {
+		if (findMapSymbol(name) >= 0) return;
+		else addSymbol(name, mapObject, imSymb, lat, lon);
+		
+	}
+		
+	public void addSymbol(String name, Object mapObject, Image imSymb, double lat, double lon) {
+		if (symbols==null) symbols=new Vector();
+		MapSymbol ms = new MapSymbol(name, mapObject, imSymb, lat, lon);
+		ms.properties = AniImage.AlwaysOnTop;
+		Point pOnScreen=getXYonScreen(lat, lon);
+		if (pOnScreen != null) ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		symbols.add(ms);
+		mmp.addImage(ms);
+	}
+
+	public void destChanged(CWPoint d) {
+		if(!running || (d == null && gotoPos == null) || 
+				(d != null && gotoPos != null && d.latDec == gotoPos.lat && d.lonDec == gotoPos.lon)) return;
+		removeGotoPosition();
+		if (d == null || !d.isValid() ) return;
+		gotoPos = addSymbol("goto", "goto_map.png", d.latDec, d.lonDec);
+		//updateDistance(); - this is called from updatePosition
+		forceMapLoad = true;
+		if (this.width != 0) updatePosition(posCircleLat, posCircleLon); // dirty hack: if this.width == 0, then the symbols are not on the screen and get hidden by updateSymbolPositions
+	}
+
+	public void removeGotoPosition() {
+		removeMapSymbol("goto");
+	}
+
+	public CWPoint getGotoPos(){
+		if (gotoPos == null) return null;
+		return new CWPoint(gotoPos.lat, gotoPos.lon);
+	}
+
+	public void removeAllMapSymbolsButGoto(){
+		if (symbols == null) return;
+		for (int i = symbols.size()-1; i >= 0; i--) {
+			mmp.removeImage((MapSymbol)symbols.get(i));
+		}
+		symbols.removeAllElements();
+		if (gotoPos != null) symbols.add(gotoPos);
+	}
+
+	public void removeMapSymbol(String name) {
+		int symbNr = findMapSymbol(name);
+		if (symbNr != -1) removeMapSymbol(symbNr);
+	}
+
+	public void removeMapSymbol(Object obj) {
+		int symbNr = findMapSymbol(obj);
+		if (symbNr != -1) removeMapSymbol(symbNr);
+	}
+
+
+	public void removeMapSymbol(int SymNr) {
+		mmp.removeImage(((MapSymbol)symbols.get(SymNr)));
+		symbols.removeElementAt(SymNr);
+	}
+
+	public int findMapSymbol(String name) {
+		if (symbols == null) return -1;
+		MapSymbol ms;
+		for (int i = symbols.size() -1; i >= 0 ; i--) {
+			ms= (MapSymbol)symbols.get(i);
+			if (ms.name == name) return i;
+		}
+		return -1;
+	}
+	
+	public int findMapSymbol(Object obj) {
+		if (symbols == null) return -1;
+		MapSymbol ms;
+		for (int i = symbols.size() -1; i >= 0 ; i--) {
+			ms= (MapSymbol)symbols.get(i);
+			if (ms.mapObject == obj) return i;
+		}
+		return -1;
+	}
+
+	/**
+	 * Move the map so that the posCircle is at lat/lon
+	 * 
+	 * @param  
+	 */
+	public void updateOnlyPosition(double lat, double lon, boolean updateOverlay){
+		//Point oldMapPos = getMapPositionOnScreen();
+		posCircleLat = lat;
+		posCircleLon = lon;
+		Point mapPos = getMapPositionOnScreen();
+		//Vm.debug("mapx = " + mapx);
+		//Vm.debug("mapy = " + mapy);
+		if (forceMapLoad || (java.lang.Math.abs(lastRepaintMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(lastRepaintMapPos.y - mapPos.y) > 1)) 
+		{
+			lastRepaintMapPos = mapPos;
+			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x, mapPos.y);
+			updateSymbolPositions();
+			updateDistance(false);
+			if (updateOverlay ) updateOverlayPos(); // && TrackOverlays != null
+			mmp.repaintNow(); 
+		}
+		else
+		{
+			updateDistance(true);
+		}
+		//Vm.debug("update only position");			
+	}
+	/**
+	 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
+	 */
+	public void updatePosition(double lat, double lon){
+		if (dontUpdatePos || loadingMapList) return; // avoid multi-threading problems
+		Vm.debug("updatepors, lat: "+lat+" lon: "+lon);
+		if (!mapsloaded) {
+			loadMaps(mapPath, lat);
+			lastCompareX = Integer.MAX_VALUE;
+			lastCompareY = Integer.MAX_VALUE;
+			autoSelectMap = true;
+			setBestMap(lat, lon, true);
+			forceMapLoad = false;
+			return;
+		}
+		updateOnlyPosition(lat, lon, true);
+		if (!autoSelectMap) return;
+		Point mapPos = getMapPositionOnScreen();
+		boolean screenNotCompletlyCovered =  mmp.mapImage == null || (mmp.mapImage != null && ( mapPos.y > 0 || mapPos.x > 0 || mapPos.y+mmp.mapImage.getHeight()<this.height	|| mapPos.x+mmp.mapImage.getWidth()<this.width));
+		if (forceMapLoad || wantMapTest|| screenNotCompletlyCovered) 	{ // if force || want || map doesn't cover the scree completly
+			//Vm.debug("Screen not completly covered by map");
+			if (forceMapLoad || (java.lang.Math.abs(lastCompareX-mapPos.x) > this.width/10 || java.lang.Math.abs(lastCompareY-mapPos.y) > this.height/10)) {
+				// more then 1/10 of screen moved since last time we tried to find a better map
+				lastCompareX = mapPos.x;
+				lastCompareY = mapPos.y;
+				setBestMap(lat, lon, screenNotCompletlyCovered);
+				forceMapLoad = false;
+			}
+		}
+	}
+
+	public void updateGps(int fix) {
+		if (!running || ignoreGps) return;
+		// runMovingMap neccessary in case of multi-threaded Java-VM: ticked could be called during load of mmp 
+		if ((fix > 0) && (myNavigation.gpsPos.getSats()>= 0)) { // TODO is getSats really necessary?
+			directionArrows.setDirections((float)myNavigation.gpsPos.getBearing(myNavigation.destination),
+					(float)myNavigation.skyOrientationDir.lonDec, (float)myNavigation.gpsPos.getBear());
+			setGpsStatus(MovingMap.gotFix);
+			updatePosition(myNavigation.gpsPos.latDec, myNavigation.gpsPos.lonDec);
+			ShowLastAddedPoint(myNavigation.curTrack);
+		}
+		if (fix == 0 && myNavigation.gpsPos.getSats()== 0) 	setGpsStatus(MovingMap.lostFix);
+		if (fix < 0 )	setGpsStatus(MovingMap.noGPSData);
+	}
+	
+	public void gpsStarted() {
+		addTrack(myNavigation.curTrack);
+		ignoreGps = false;
+	}
+	public void gpsStoped() {
+		setGpsStatus(MovingMap.noGPS);
+	}
+
+	int mapChangeModus;
+	float scaleWanted;
+	boolean wantMapTest = true; // if true updateposition calls setBestMap regulary even if the currentmap covers the whole screen
+	public final static int NORMAL_KEEP_RESOLUTION = 1; // keeps the choosen resolution as long as a map is available that overlaps with the screen and with the PosCircle - it changes the resolution if no such map is available. It wil cahnge back to the wanted scale as soon as a map becomes available (through movement of the GPS-receiver)
+	public final static int HIGHEST_RESOLUTION = 2;
+	public final static int HIGHEST_RESOLUTION_GPS_DEST = 3;
+	boolean inBestMap = false; // to avoid multi-threading problems
+
+	/**
+	 * loads the best map for lat/lon according to mapChangeModus
+	 * lat/lon will be at the screen-pos of posCircle
+	 * when posCircle is not on the screen (shifted outside my the user)
+	 * then this routine uses the center of the screen to find the best map
+	 * but anyway the map will be adjusted (moved) relativ to posCircle
+	 * when a better map was found the called method updateposition will set
+	 * posCirleLat/-Lon to lat/lon.
+	 * 
+	 * @param lat
+	 * @param lon
+	 * @param loadIfSameScale false: will not change the map if the better map has the same scale as the current - this is used not to change the map if it covers already the screen completely
+	 * true: willchange the map, regardless of change in scale
+	 */
+	public void setBestMap(double lat, double lon, boolean loadIfSameScale) {
+		if (inBestMap) return;
+		inBestMap = true;
+		Object [] s = getRectForMapChange(lat, lon);
+		CWPoint cll = (CWPoint) s[0]; 
+		Rect screen = (Rect) s[1]; 
+		MapInfoObject newmap = null;
+		//if (mapChangeModus == 0) mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
+		wantMapTest = true;
+		switch (mapChangeModus) {
+		case NORMAL_KEEP_RESOLUTION: 
+			newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, scaleWanted, false);
+			if (newmap == null) newmap = currentMap;
+			if (MapsList.scaleEquals(scaleWanted, newmap)) wantMapTest = false;
+			break;
+		case HIGHEST_RESOLUTION: newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 0.000001f, false); break;
+		case HIGHEST_RESOLUTION_GPS_DEST: 
+			if (gotoPos!= null && GpsStatus != noGPS && posCircleLat>= -90 && posCircleLat <= 90 && posCircleLon >= -360 && posCircleLon <= 360) {
+				newmap = maps.getMapForArea(new CWPoint(posCircleLat, posCircleLon), new CWPoint(gotoPos.lat, gotoPos.lon)); // TODO use home-coos if no gps? - consider start from details panel and from gotopanel
+				if (newmap == null) newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 10000000000000000000000000000000000f, false); // use map with most available overview if no map containing PosCircle and GotoPos is available
+			}
+			//	either Goto-Pos or GPS-Pos not set
+			else newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 0.000001f, false); 
+			break;
+		default: (new MessageBox("Error", "Programmfehler: \nillegal mapChangeModus: " + mapChangeModus, MessageBox.OKB)).execute(); break;
+		}
+		if ( newmap != null && (currentMap == null || !currentMap.mapName.equals(newmap.mapName)) ) {
+			if (loadIfSameScale || !MapsList.scaleEquals(currentMap.scale / currentMap.zoomFactor, newmap) ) {
+				Vm.debug("better map found");
+				setMap(newmap, lat, lon);
+				moveScreenXYtoLatLon(new Point(screen.x, screen.y), cll, true);
+			}
+			inBestMap = false;
+			return;
+		}
+		if (currentMap == null && newmap == null) {
+			(new MessageBox("Information", "F?r die aktuelle Position steht keine Karte zur Verf?ng, bitte w?hlen Sie eine manuell", MessageBox.OKB)).execute();
+			posCircleLat = cll.latDec;
+			posCircleLon = cll.lonDec; // choosemap calls setmap with posCircle-coos
+			while (currentMap == null) {
+				mmp.chooseMap(); // force the user to select a scale // TODO empty maps on top?
+				if (currentMap == null) (new MessageBox("Error", "Moving map cannot run without a map - please select one. \n You can select an empty map", MessageBox.OKB)).execute();
+			}
+		}
+		inBestMap = false;
+	}
+
+	public void setResModus (int modus) {
+		scaleWanted = currentMap.scale;
+		if (mapChangeModus == modus) return;
+		mapChangeModus = modus;
+		if (modus != NORMAL_KEEP_RESOLUTION) setBestMap(posCircleLat, posCircleLon, true);
+	}
+	/**
+	 * method to get a point on the screen which must be included in the map
+	 * the map methods are looking for. If the poscircle is on the screen this will be 
+	 * that point. If it is outside then the center of the screen will be used.
+	 * 
+	 * returns [0] = CWPoint of that point, [1] Rect describing the screen around it 
+	 * @param lat
+	 * @param lon
+	 * @return
+	 */
+	public Object[] getRectForMapChange(double lat, double lon) {
+		int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
+		int h = (height != 0 ? height : pref.myAppHeight);
+		int x, y;
+		CWPoint cll;
+		if (posCircleX >= 0 && posCircleX <= w && posCircleY >= 0 && posCircleY <= h) {
+			x = posCircleX; // posCircle is inside the screen
+			y = posCircleY; // TODO eigentlich interessiert, ob nach dem evtl. Kartenwechsel PosCircle on Screen ist. So wie es jetzt ist, kann 2mal der gleiche Aufruf zum laden unterschiedlicher Karten f?hren, wenn voher PosCircle nicht auf dem SChirm war, nach dem ersten Laden aber schon.
+			cll = new CWPoint(lat, lon);
+		} else { // when posCircle out of screen - use center of screen as point which as to be included in the map
+			cll = ScreenXY2LatLon(w/2, h/2);
+			x = w/2;
+			y = h/2;
+		} 
+		Object[] ret = new Object[2];
+		ret[0] = cll;
+		ret[1] = new Rect(x, y, w, h);
+		return ret; 
+	}
+
+	/**
+	 * 
+	 * @param betterOverview true: getmap with better overview
+	 * @return
+	 */
+	public void loadMoreDetailedMap(boolean betterOverview){
+		Object [] s = getRectForMapChange(posCircleLat, posCircleLon);
+		CWPoint cll = (CWPoint) s[0]; 
+		Rect screen = (Rect) s[1]; 
+		//Rect screen = new Rect(posCircleX, posCircleY, (width != 0 ? width : pref.myAppWidth), (height != 0 ? height : pref.myAppHeight));
+		MapInfoObject m = maps.getMapChangeResolution(cll.latDec, cll.lonDec, screen, currentMap.scale / currentMap.zoomFactor, !betterOverview);
+		if (m != null) {
+			boolean saveGpsIgnStatus = dontUpdatePos;
+			dontUpdatePos = true;
+			setMap(m, posCircleLat, posCircleLon);
+			setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+			dontUpdatePos = saveGpsIgnStatus;
+		}
+		else (new MessageBox("Error", "No "+ (betterOverview ? "less" : "more") + " deteiled map available", MessageBox.OKB)).execute();
+	}
+
+	public void loadMapForAllCaches(){
+		Area sur = Global.getProfile().getSourroundingArea(true);
+		if (sur == null) {
+			(new MessageBox("Error", "Keine  Caches mit H?ckchen ausgew?hlt", MessageBox.OKB)).execute();
+			return;
+		}
+		MapInfoObject newmap = maps.getMapForArea(sur.topleft, sur.buttomright);
+		if (newmap == null ) { // no map that includs all caches is available -> load map with lowest resolution
+			Object [] s = getRectForMapChange(posCircleLat, posCircleLon);
+			CWPoint cll = (CWPoint) s[0]; 
+			Rect screen = (Rect) s[1]; 
+			newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, Float.MAX_VALUE -1, false);
+		}
+		boolean saveGpsIgnStatus = dontUpdatePos;
+		dontUpdatePos = true;
+		setMap(newmap, posCircleLat, posCircleLon);
+		setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+		dontUpdatePos = saveGpsIgnStatus;
+	}
+
+	public void setGpsStatus (int status) {
+		if (status == GpsStatus) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
+		GpsStatus = status;
+		dontUpdatePos = false;
+		ignoreGps = false;
+		switch (status) {
+		case noGPS: 	{ posCircle.change(null); ignoreGps = true; break; }
+		case gotFix:    { posCircle.change(statusImageHaveSignal); break; }
+		case lostFix:   { posCircle.change(statusImageNoSignal); break; }
+		case noGPSData: { posCircle.change(statusImageNoGps); break; }
+		}
+		posCircle.refreshNow();
+	}
+
+	public void SnapToGps() {
+		resetCenterOfMap();
+		dontUpdatePos = false;
+		ignoreGps = false;
+		lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
+		lastCompareY = Integer.MAX_VALUE;
+		autoSelectMap = true;
+		forceMapLoad = true;
+		showMap();
+		if (myNavigation.gpsPos.Fix <=0) updatePosition(posCircleLat, posCircleLon);
+		else updateGps(myNavigation.gpsPos.getFix());
+	}
+
+	/** sets and displays the map
+	 * 
+	 * @param newmap
+	 * @param lat move map so that lat/lon is in the center / -361: don't adust to lat/lon
+	 * @param lon -361: don't adust to lat/lon
+	 */
+	public void setMap(MapInfoObject newmap, double lat, double lon) {
+		if (currentMap != null && newmap.mapName.equals(currentMap.mapName) && !forceMapLoad) { // note: newmap.mapName == currentMap.mapName won't work because they are different String containing the same text 
+			updateOnlyPosition(lat, lon, true); 
+			return;
+		}
+		Vm.showWait(true);
+		boolean saveIgnoreStatus;
+		saveIgnoreStatus = dontUpdatePos;
+		dontUpdatePos = true;  // make updatePosition ignore calls during loading new map
+		InfoBox inf;
+		inf = new InfoBox("Info", "Loading map...");
+		inf.show();
+		inf.waitUntilPainted(100);
+		try {
+			this.currentMap = newmap; 
+			this.title = currentMap.mapName;
+			lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
+			lastCompareY = Integer.MAX_VALUE;
+			if (mmp.mapImage != null ) {
+				//Vm.debug("free: "+Vm.getUsedMemory(false)+"classMemory: "+Vm.getClassMemory()+ "after garbage collection: "+Vm.getUsedMemory(false));
+				mmp.removeImage(mmp.mapImage); mmp.mapImage.free(); mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+
+				//Vm.debug("free: "+Vm.getUsedMemory(false)+"classMemory: "+Vm.getClassMemory()+ "after garbage collection: "+Vm.getUsedMemory(false));
+				Vm.getUsedMemory(true); // calls the garbage collection
+			} // give memory free before loading the new map to avoid out of memory error
+			String ImageFilename = currentMap.getImageFilename(); 
+			if (ImageFilename == null ) {
+				mmp.mapImage = new MapImage();
+				(new MessageBox("Error", "Could not find image associated with: \n"+currentMap.fileNameWFL, MessageBox.OKB)).execute();
+			}
+			else { 
+				if (ImageFilename.length() > 0) mmp.mapImage = new MapImage(ImageFilename); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
+				else mmp.mapImage = new MapImage();
+			}
+			mapImage1to1 = mmp.mapImage;
+			mmp.mapImage.properties = mmp.mapImage.properties | AniImage.IsMoveable;
+			if (mapHidden) mmp.mapImage.hide();
+			mmp.mapImage.move(0,0);
+			mmp.addImage(mmp.mapImage);
+			mmp.images.moveToBack(mmp.mapImage);
+			addOverlaySet();
+			forceMapLoad = true; // forces updateOnlyPosition to redraw
+			updateOnlyPosition(lat, lon, false);
+			forceMapLoad = false;
+			directionArrows.setMap(currentMap);
+			updateScale();
+			inf.close(0);  // this doesn't work in a ticked-thread in the ewe-vm. That's why i made a new mThread in gotoPanel for ticked
+			Vm.showWait(false);
+			dontUpdatePos = saveIgnoreStatus;
+		} catch (IllegalArgumentException e) { // thrown by new AniImage() in ewe-vm if file not found;
+			if (mmp.mapImage != null) {
+				mmp.removeImage(mmp.mapImage); 
+				mmp.mapImage.free();
+				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+			}
+			addOverlaySet();
+			updateOnlyPosition(lat, lon, false);
+			inf.close(0);
+			Vm.showWait(false);
+			(new MessageBox("Error", "Could not load map: "+ newmap.getImageFilename(), MessageBox.OKB)).execute();
+			dontUpdatePos = saveIgnoreStatus;
+		} catch (OutOfMemoryError e) {
+			if (mmp.mapImage != null) {
+				mmp.removeImage(mmp.mapImage); 
+				mmp.mapImage.free();
+				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+			}
+			addOverlaySet();
+			updateOnlyPosition(lat, lon, false);
+			inf.close(0);
+			Vm.showWait(false);
+			(new MessageBox("Error", "Not enough memory to load map: "+ newmap.getImageFilename()+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
+			dontUpdatePos = saveIgnoreStatus;
+		}catch (SystemResourceException e) {
+			if (mmp.mapImage != null) {
+				mmp.removeImage(mmp.mapImage); 
+				mmp.mapImage.free();
+				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+			}
+			addOverlaySet();
+			updateOnlyPosition(lat, lon, false);
+			inf.close(0);
+			Vm.showWait(false);
+			(new MessageBox("Error", "Not enough ressources to load map: "+ newmap.getImageFilename()+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
+			dontUpdatePos = saveIgnoreStatus;
+		}
+	}
+
+	public void hideMap() {
+		if (mmp != null && mmp.mapImage != null)
+			mmp.mapImage.hide();
+		mapHidden = true;
+		repaintNow();
+	}
+
+	public void showMap() {
+		if (mmp != null && mmp.mapImage != null) mmp.mapImage.unhide();
+		mapHidden = false;
+		repaintNow();
+	}
+
+	public void setZoomingMode() {
+		mmp.removeImage(buttonImageLens);
+		mmp.addImage(buttonImageLensActivated);
+		repaintNow();
+		zoomingMode = true;
+	}
+
+	/**
+	 * zommes in if w>0 and out if w<0
+	 * @param firstclickpoint
+	 * @param w
+	 * @param h
+	 */
+	public void zoomScreenRect(Point firstclickpoint, int w, int h) {
+		int newImageWidth = (int) (this.width *  (this.width  < 481 ? 2 : 1.6)); // (maximal) size of the zoomed image 
+		int newImageHeight= (int) (this.height * (this.width < 481 ?  2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors 
+		CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y + h/2);
+		float zoomFactor;
+		if (w > 0)  zoomFactor = (float)this.width / (float)w; // zoom in
+		else {
+			w = java.lang.Math.abs(w);
+			firstclickpoint.x = firstclickpoint.x - w; // make firstclickedpoint the upper left corner
+			zoomFactor = (float)w / (float)this.width;
+		}
+		if (h < 0) {
+			h = java.lang.Math.abs(h);
+			firstclickpoint.y = firstclickpoint.y - h;
+		}
+		// calculate rect in unzoomed image in a way that the center of the new image is the center of selected area but give priority to the prefered image size of the scaled image
+		newImageHeight = (int) (newImageHeight / zoomFactor / currentMap.zoomFactor);
+		newImageWidth = (int) (newImageWidth / zoomFactor / currentMap.zoomFactor);
+		Point mappos = getMapPositionOnScreen();
+		int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w/2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth /2);
+		int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h/2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight /2);
+		Rect newImageRect = new Rect(xinunscaledimage , yinunscaledimage, newImageWidth, newImageHeight);
+		if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
+		{
+			// try to avoid overlapping by shifting
+			if (newImageRect.x < 0) 
+				newImageRect.x = 0; // align left if left overlapping
+			if (newImageRect.y < 0) 
+				newImageRect.y = 0;
+			if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) 
+				newImageRect.x = mapImage1to1.getWidth()- newImageWidth; // align right if right overlaping
+			if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight()) 
+				newImageRect.y = mapImage1to1.getHeight()- newImageHeight;
+			// crop if after shifting still overlapping
+			if (newImageRect.x < 0) 
+				newImageRect.x = 0;
+			if (newImageRect.y < 0) 
+				newImageRect.y = 0;
+			if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth()) 
+				newImageRect.width = mapImage1to1.getWidth() - newImageRect.x;
+			if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight()) 
+				newImageRect.height= mapImage1to1.getHeight()- newImageRect.y;
+		}
+		zoomFromUnscaled(zoomFactor * currentMap.zoomFactor, newImageRect, center);
+	}
+
+	public void zoom1to1() {
+		CWPoint center = ScreenXY2LatLon(this.width /2 , this.height/2);
+		if (mapImage1to1 != null) zoomFromUnscaled(1, new Rect(0,0,mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
+		else zoomFromUnscaled(1, new Rect(0,0, 1,1), center);
+	}
+
+	/**
+	 * do the actual scaling
+	 * @param zoomFactor relative to original image
+	 * @param newImageRect Rect in the 1:1 image that contains the area to be zoomed into
+	 * @param center
+	 */		
+	public void zoomFromUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
+		Vm.showWait(this, true);
+		boolean savegpsstatus = dontUpdatePos;
+		if (mapImage1to1 != null) {
+			dontUpdatePos = true; // avoid multi-thread problems
+			int saveprop = AniImage.IsMoveable;
+			MapImage tmp = null; // = mmp.mapImage;
+			if (mmp.mapImage != null) {
+				tmp = mmp.mapImage;
+				saveprop = mmp.mapImage.properties;
+				mmp.removeImage(mmp.mapImage);
+				if (mmp.mapImage != mapImage1to1) {
+					mmp.mapImage.free();
+					mmp.mapImage = null;
+				} else tmp = mapImage1to1;
+			}
+			Vm.getUsedMemory(true);
+			try {
+				if (zoomFactor == 1) tmp = mapImage1to1;
+				else tmp = new MapImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor), (int)(newImageRect.height*zoomFactor), newImageRect, 0));
+				currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
+			} catch (OutOfMemoryError e) {
+				(new MessageBox("Error", "Out of memory error", MessageBox.OKB)).execute();
+				//tmp = mapImage1to1;
+			} //if (tmp != null) currentMap.zoom();}
+			Vm.getUsedMemory(true);
+			mmp.mapImage = tmp; // use unscaled or no image in case of OutOfMemoryError
+			mmp.mapImage.properties = saveprop;
+			if (mapHidden) mmp.mapImage.hide();
+			mmp.addImage(mmp.mapImage);
+			mmp.images.moveToBack(mmp.mapImage);
+			if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
+			{
+				Point mappos = getMapPositionOnScreen();
+				mmp.mapImage.move(mappos.x,mappos.y);
+			}
+		} else // no map image loaded 
+		{ currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y); }
+		// scaleWanted = currentMap.scale; use this if you want to change automatically to a map scale that best fits the zooming
+		destroyOverlaySet();
+		Vm.getUsedMemory(true); // call garbage collection
+		setCenterOfScreen(center, false);
+		addOverlaySet();
+		updateScale();
+		this.repaintNow();
+		Vm.showWait(this, false);
+		dontUpdatePos = savegpsstatus;
+	}
+
+	/*	public void gotFocus(int how) {
+		super.gotFocus(how);
+		Dimension ws = getSize(null);
+		onWindowResize(ws.width, ws.height);
+		Vm.debug(ws.width + " h: "+ws.height);
+		this.setPreferredSize(width, height)
+	}
+	 */
+	public void onEvent(Event ev){
+		if(ev instanceof FormEvent && (ev.type == FormEvent.CLOSED )){
+			running = false;
+		}  
+		if(ev instanceof KeyEvent && ev.target == this && ((KeyEvent)ev).key == IKeys.ESCAPE) {
+			this.close(0);
+			ev.consumed = true;
+		}
+		super.onEvent(ev);
+	}
+}
+
+/**
+ *	Class to display the map bitmap and to select another bitmap to display.
+ */
+class MovingMapPanel extends InteractivePanel implements EventListener {
+	Menu kontextMenu;
+	MenuItem gotoMenuItem = new MenuItem("Goto here$g", 0, null);
+	MenuItem newWayPointMenuItem = new MenuItem("Create new Waypoint here$n", 0, null);;
+	MenuItem openCacheDescMenuItem,addCachetoListMenuItem;
+	
+	MenuItem miLuminary[];
+
+	Menu mapsMenu;
+	MenuItem selectMapMI = new MenuItem("Select a map manually$s", 0, null);
+	MenuItem changeMapDirMI = new MenuItem("Change map directory$c", 0, null);
+	MenuItem showMapMI = new MenuItem("Show map", 0, null);
+	MenuItem hideMapMI = new MenuItem("Hide map", 0, null);
+	// automatic
+	MenuItem mapChangeModusMI = new MenuItem("Modus for automatic map change", MenuItem.Separator, null);;
+	MenuItem highestResGpsDestMI = new MenuItem("Highest res. containing dest. & cur. position", 0, null); //immer h?chste Aufl?sung w?hlen, die akt. Pos. und Ziel enthalten 
+	MenuItem highestResolutionMI = new MenuItem("Highest resolution", 0, null); //immer h?chste Aufl?sung w?hlen 
+	MenuItem keepManResolutionMI = new MenuItem("Keep manual resolution", 0, null); // manuell gew?hlte Aufl?sung beibehalten  
+	// manuell
+	MenuItem mapChangeResMI = new MenuItem("Change resolution manually", MenuItem.Separator, null);;
+	MenuItem AllCachesResMI = new MenuItem("Load a map containing all marked caches", 0, null); // Karte w?hlen, die alle markierten Caches enth?lt  
+	MenuItem moreDetailsMI = new MenuItem("Load a map with more details", 0, null); // detailreichere Karte laden 
+	MenuItem moreOverviewMI = new MenuItem("Load a map for a better overview", 0, null); // Karte mit mehr ?bersicht w?hlen  
+	// move map to
+	MenuItem moveToMI = new MenuItem("Move map to an load map", MenuItem.Separator, null);;
+	MenuItem moveToDestMI = new MenuItem("move to goto point", 0, null); //* Karte zum Ziel verschieben (und ggf. entsprechende Karte laden) 
+	MenuItem moveToGpsMI = new MenuItem("move to GPS position", 0, null);   
+	MenuItem moveToCenterMI = new MenuItem("move to Center", 0, null);   
+
+	CacheHolder clickedCache;
+	MovingMap mm;
+	MapImage mapImage;
+	Point saveMapLoc = null;
+	boolean saveGpsIgnoreStatus;
+	boolean paintingZoomArea;
+	ImageList saveImageList = null;
+	int lastZoomWidth , lastZoomHeight;
+	public MovingMapPanel(MovingMap f){
+		this.mm = f;
+		set(Control.WantHoldDown, true); // want to get simulated right-clicks
+	}
+
+	public boolean imageBeginDragged(AniImage which,Point pos) {
+		if (mm.zoomingMode == true) { // zoom
+//			saveMapLoc = pos;
+			//		saveGpsIgnoreStatus = mm.ignoreGps;
+			//	mm.ignoreGps = true;
+			return false;
+		}
+		// move (drag) map
+		//if (!(which == null || which == mapImage || which instanceof TrackOverlay || which == mm.directionArrows) ) return false;
+		saveGpsIgnoreStatus = mm.dontUpdatePos; 
+		mm.dontUpdatePos = true;
+		saveMapLoc = pos;
+		bringMapToTop();
+		if (mapImage.isOnScreen() && !mapImage.hidden ) return super.imageBeginDragged(mapImage, pos);
+		else return super.imageBeginDragged(null, pos);
+	}
+
+	public boolean imageNotDragged(ImageDragContext dc,Point pos){
+		boolean ret = super.imageNotDragged(dc, pos);
+		bringMaptoBack();
+		if (dc.image == null) moveMap(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
+		else mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
+		mm.dontUpdatePos = saveGpsIgnoreStatus;
+		this.repaintNow();
+		return ret;
+	}
+
+	public void onPenEvent(PenEvent ev) {
+		if (!mm.zoomingMode && ev.type == PenEvent.PEN_DOWN) {
+			saveMapLoc = new Point (ev.x, ev.y);
+		}
+		if (mm.zoomingMode && ev.type == PenEvent.PEN_DOWN) {
+			saveGpsIgnoreStatus = mm.dontUpdatePos;
+			mm.dontUpdatePos = true;
+			saveMapLoc = new Point (ev.x, ev.y);
+			paintingZoomArea = true;
+			mm.zoomingMode = true;
+		} 
+		if (!mm.zoomingMode && ev.type == PenEvent.PEN_DOWN && ev.modifiers == PenEvent.RIGHT_BUTTON) {
+			penHeld(new Point (ev.x, ev.y));
+		}
+		if (mm.zoomingMode && ev.type == PenEvent.PEN_UP ) {
+			paintingZoomArea = false;
+			mm.zoomingMode = false;
+			mm.dontUpdatePos = saveGpsIgnoreStatus;
+			removeImage(mm.buttonImageLensActivated);
+			addImage(mm.buttonImageLens);
+			if (java.lang.Math.abs(lastZoomWidth) < 15 || java.lang.Math.abs(lastZoomHeight) < 15)  {
+				repaintNow();
+				return; // dont make to big zoom jumps - it is most probable not an intentional zoom
+			}
+			mm.zoomScreenRect(saveMapLoc, lastZoomWidth, lastZoomHeight);
+		}
+
+		if (mm.zoomingMode && paintingZoomArea && (ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {
+			int left, top;
+			Graphics dr = this.getGraphics();
+			if (lastZoomWidth < 0)left = saveMapLoc.x + lastZoomWidth;
+			else left = saveMapLoc.x;
+			if (lastZoomHeight < 0)top = saveMapLoc.y + lastZoomHeight;
+			else top = saveMapLoc.y;
+			left -= 2;
+			top -= 2;
+			if (top < 0) top = 0;
+			if (left < 0) left = 0;
+			this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth)+4, java.lang.Math.abs(lastZoomHeight)+4));
+			lastZoomWidth = ev.x - saveMapLoc.x;
+			lastZoomHeight =  ev.y - saveMapLoc.y;
+			if (lastZoomWidth < 0) left = saveMapLoc.x + lastZoomWidth;
+			else left = saveMapLoc.x;
+			if (lastZoomHeight < 0)top = saveMapLoc.y + lastZoomHeight;
+			else top = saveMapLoc.y;
+			dr.setPen(new Pen(new Color(255,0,0),Pen.SOLID,3));
+			dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight), 0); // bug in ewe: thickness parameter is ignored
+		}
+		super.onPenEvent(ev);
+	}
+
+	private void bringMapToTop() {
+		if (mapImage == null || mapImage.hidden) {
+			saveImageList = null;
+			return;
+		}
+		saveImageList = new ImageList();
+		saveImageList.copyFrom(images);
+		images.removeAllElements();
+		images.add(mapImage);
+	}
+	private void bringMaptoBack() {
+		if (saveImageList == null) return;
+		images = saveImageList;
+		saveImageList = null;
+	}
+
+	public void moveMap(int diffX, int diffY) {
+		Point p = new Point();
+		if (mapImage!= null) {
+			p = mapImage.locAlways;
+			mapImage.move(p.x+diffX,p.y+diffY);
+			//		if (mm.mapHidden) mapImage.properties |= AniImage.IsInvisible; // this is neccesarry because move will unhide the map if the coos show that the map is on the screen
+		}
+		mapMoved(diffX, diffY);
+	}
+
+	public void mapMoved(int diffX, int diffY){
+		mm.mapMoved(diffX, diffY);
+		this.repaintNow();
+	}
+
+	public void doPaint(Graphics g,Rect area) {
+		super.doPaint(g, area);
+		if (mm.gotoPos != null) {
+			Point dest = mm.getXYonScreen(mm.gotoPos.lat, mm.gotoPos.lon);
+			g.setPen(new Pen(Color.DarkBlue, Pen.SOLID, 3));
+			g.drawLine(mm.posCircleX, mm.posCircleY, dest.x, dest.y);
+		}
+	}
+
+	public void chooseMap() {
+		CWPoint gpspos;
+		if (mm.myNavigation.gpsPos.Fix > 0) gpspos = new CWPoint(mm.myNavigation.gpsPos.latDec, mm.myNavigation.gpsPos.lonDec);
+		else gpspos = null;
+		ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos(), mm.currentMap);
+		if(l.execute() == FormBase.IDOK){
+//			Vm.debug("Trying map: " + l.selectedMap.fileName);
+			mm.autoSelectMap = false;
+			if (l.selectedMap.inBound(mm.posCircleLat, mm.posCircleLon) || l.selectedMap.getImageFilename().length()==0) {
+				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon);
+				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+				mm.ignoreGps = false;
+			} else {
+				mm.setGpsStatus(MovingMap.noGPS);
+				mm.ignoreGps = true;
+				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon); 
+				if (mm.currentMap.fileNameWFL.length() > 0)
+					mm.setCenterOfScreen(l.selectedMap.center, true); // if map has an image
+				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+				//Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
+				//double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4]; 
+				//mm.posCircleX = 0; // place map to the upper left corner of windows
+				//mm.posCircleY = 0;
+				//mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
+			}
+		}
+	}
+
+	/**
+	 *	Method to react to user.
+	 */
+	public void imageClicked(AniImage which, Point pos){
+		if (which == mm.bottonImageChooseMap){
+			mapsMenu = new Menu();
+			mapsMenu.addItem(selectMapMI);
+			mapsMenu.addItem(changeMapDirMI);
+			if (!mm.noMapsAvailable) 
+			{
+				if (mm.mapHidden) mapsMenu.addItem(showMapMI);
+				else mapsMenu.addItem(hideMapMI);
+			}
+
+			// automatic
+			highestResGpsDestMI.modifiers &= ~MenuItem.Checked;
+			highestResolutionMI.modifiers &= ~MenuItem.Checked;
+			keepManResolutionMI.modifiers &= ~MenuItem.Checked;
+			switch (mm.mapChangeModus) {
+			case MovingMap.NORMAL_KEEP_RESOLUTION: keepManResolutionMI.modifiers |= MenuItem.Checked; break;   
+			case MovingMap.HIGHEST_RESOLUTION: highestResolutionMI.modifiers |= MenuItem.Checked; break;   
+			case MovingMap.HIGHEST_RESOLUTION_GPS_DEST: highestResGpsDestMI.modifiers |= MenuItem.Checked; break;   
+			}
+			mapsMenu.addItem(mapChangeModusMI);
+			mapsMenu.addItem(highestResGpsDestMI);
+			mapsMenu.addItem(highestResolutionMI);
+			mapsMenu.addItem(keepManResolutionMI);
+			// manuell
+			mapsMenu.addItem(mapChangeResMI);
+			mapsMenu.addItem(AllCachesResMI);
+			mapsMenu.addItem(moreDetailsMI);
+			mapsMenu.addItem(moreOverviewMI);
+			// move map to
+			mapsMenu.addItem(moveToMI);
+			if (mm.gotoPos != null) moveToDestMI.modifiers &= ~MenuItem.Disabled;
+			else moveToDestMI.modifiers |= MenuItem.Disabled;
+			mapsMenu.addItem(moveToDestMI);
+			if (Global.getPref().curCentrePt.isValid()) moveToCenterMI.modifiers &= ~MenuItem.Disabled;
+			else moveToCenterMI.modifiers |= MenuItem.Disabled;
+			mapsMenu.addItem(moveToCenterMI);
+			mapsMenu.addItem(moveToGpsMI);
+
+			//m.set(Menu., status)
+			mapsMenu.exec(this, new Point(which.location.x, which.location.y), this);
+		}
+		if (which == mm.buttonImageGpsOn) {
+			this.snapToGps();
+		}
+		if (which == mm.buttonImageLens) {
+			mm.setZoomingMode();
+			lastZoomWidth = 0;
+			lastZoomHeight = 0;
+		}
+		if (which == mm.buttonImageZoom1to1) {
+			mm.zoom1to1(); 
+		}
+		if (which == mm.bottonImageClose) {
+			WindowEvent tmp = new WindowEvent();
+			tmp.type = WindowEvent.CLOSE;
+			mm.postEvent(tmp);
+		}
+	}
+
+	public void snapToGps() {
+		mm.myNavigation.startGps();
+		mm.SnapToGps();
+	}
+
+	public void penHeld(Point p){
+		//	if (!menuIsActive()) doMenu(p);
+		if (!mm.zoomingMode) { 
+			//( (ev.type == PenEvent.PEN_DOWN) && ((PenEvent)ev).modifiers == PenEvent.RIGHT_BUTTON)
+			//|| ((ev.type == PenEvent.RIGHT_BUTTON) ) )) ---> these events are not posted --> this overridering is the only solution 
+			kontextMenu = new Menu();
+			if ( !(mm.directionArrows.onHotArea(p.x, p.y)) ) {
+				kontextMenu.addItem(gotoMenuItem);
+				kontextMenu.addItem(newWayPointMenuItem);
+				AniImage clickedOnImage = images.findHotImage(p);
+				if (clickedOnImage != null && clickedOnImage instanceof MapSymbol) {
+					clickedCache = ((CacheHolder)((MapSymbol)clickedOnImage).mapObject);
+					if (clickedCache != null) openCacheDescMenuItem = new MenuItem("Open '"+(clickedCache.CacheName.length()>0?clickedCache.CacheName:clickedCache.wayPoint)+"'$o"); // clickedCache == null can happen if clicked on the goto-symbol
+					kontextMenu.addItem(openCacheDescMenuItem);
+					if (clickedCache !=null && Global.mainForm.cacheListVisible) { 
+						addCachetoListMenuItem = new MenuItem(MyLocale.getMsg(199,"Add to cachetour"));
+						kontextMenu.addItem(addCachetoListMenuItem);
+					}
+				}
+			}
+			else {			
+				miLuminary = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
+
+				for (int i=0; i<SkyOrientation.LUMINARY_NAMES.length; i++) {
+					kontextMenu.addItem(miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i)));
+					if (i == mm.myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
+					else miLuminary[i].modifiers &= MenuItem.Checked;
+				}
+			}
+			kontextMenu.exec(this, new Point(p.x, p.y), this);
+		}
+	}
+
+	public void onEvent(Event ev){
+		if (mapsMenu != null && ev instanceof PenEvent && ev.type == PenEvent.PEN_DOWN && ev.target == this) {mapsMenu.close(); mapsMenu = null;}
+		if (kontextMenu != null && ev instanceof PenEvent && ev.type == PenEvent.PEN_DOWN && ev.target == this) {kontextMenu.close(); kontextMenu = null; }
+
+		if (ev instanceof MenuEvent) { 
+			if (ev.target == mapsMenu) {
+				if (ev.type == MenuEvent.ABORTED || ev.type == MenuEvent.CANCELLED || ev.type == MenuEvent.FOCUS_OUT) mapsMenu.close(); // TODO menuIsActive() benutzen? 
+				if (ev.type == MenuEvent.SELECTED ) {
+					MenuItem action = (MenuItem) mapsMenu.getSelectedItem(); 
+					if (mapsMenu.getSelectedItem() != null) {
+						//maps
+						if (action == selectMapMI)	{ 
+							mapsMenu.close();
+							chooseMap();
+						}
+						if (action == changeMapDirMI)	{
+							mapsMenu.close();
+							FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir+"maps");
+							fc.addMask("*.wfl");
+							fc.setTitle((String)MyLocale.getMsg(4200,"Select map directory:"));
+							if(fc.execute() != FileChooser.IDCANCEL){
+								mm.loadMaps(fc.getChosen().toString(), mm.posCircleLat);
+								mm.forceMapLoad();
+							}
+						}
+						//dont show map
+						if (action == hideMapMI) {
+							mapsMenu.close();
+							mm.hideMap();
+						}
+						// show map
+						if (action == showMapMI) {
+							mapsMenu.close();
+							mm.showMap();
+						}
+						// map change modus
+						if (action == highestResGpsDestMI) {
+							mapsMenu.close();
+							mm.setResModus(MovingMap.HIGHEST_RESOLUTION_GPS_DEST);
+						}
+						if (action == highestResolutionMI) {
+							mapsMenu.close();
+							mm.setResModus(MovingMap.HIGHEST_RESOLUTION);
+						}
+						if (action == keepManResolutionMI) {
+							mapsMenu.close();
+							mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+						}
+						// manually change map resolution
+						if (action == moreDetailsMI) {
+							mapsMenu.close();
+							mm.loadMoreDetailedMap(false);
+						} 
+						if (action == moreOverviewMI) {
+							mapsMenu.close();
+							mm.loadMoreDetailedMap(true);
+						}
+						if (action == AllCachesResMI) {
+							mapsMenu.close();
+							mm.loadMapForAllCaches();
+						}
+						// moveto position
+						if (action == moveToCenterMI) {
+							mapsMenu.close();
+							mm.setCenterOfScreen(Global.getPref().curCentrePt, true);
+						}
+						if (action == moveToDestMI) {
+							mapsMenu.close();
+							mm.setCenterOfScreen(new CWPoint(mm.gotoPos.lat, mm.gotoPos.lon), true);
+						}
+						if (action == moveToGpsMI) {
+							mapsMenu.close();
+							this.snapToGps();						
+						}
+
+					}
+				}
+			} // if (ev.target == mapsMenu)
+			if (ev.target == kontextMenu) {
+				if ((((MenuEvent)ev).type==MenuEvent.SELECTED)) {
+					MenuItem action = (MenuItem) kontextMenu.getSelectedItem(); 
+					if (action == gotoMenuItem) {
+						kontextMenu.close();
+						mm.myNavigation.setDestination(mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y));	
+					}
+					if (action == openCacheDescMenuItem) {
+						//mm.onEvent(new FormEvent(FormEvent.CLOSED, mm));
+						kontextMenu.close();
+						WindowEvent close = new WindowEvent();
+						close.target = mm;
+						close.type = WindowEvent.CLOSE;
+						mm.postEvent(close);
+						MainTab mainT = Global.mainTab;
+						mainT.openDesciptionPanel(clickedCache);
+					}
+					if (action == newWayPointMenuItem) {
+						kontextMenu.close();
+						WindowEvent close = new WindowEvent();
+						close.target = mm; 
+						close.type = WindowEvent.CLOSE;
+						mm.postEvent(close);
+						CacheHolder newWP = new CacheHolder();
+						newWP.pos = mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y);
+						newWP.LatLon=newWP.pos.toString(); 
+						Global.mainTab.newWaypoint(newWP);
+					}
+					if (action == addCachetoListMenuItem) {
+						kontextMenu.close();
+						Global.mainForm.cacheList.addCache(clickedCache.wayPoint);
+					}
+					for (int i=0; i<miLuminary.length; i++) {
+						if (action == miLuminary[i]) {
+							kontextMenu.close();
+							mm.myNavigation.setLuminary(i);
+							mm.updateGps(mm.myNavigation.gpsPos.getFix());
+							miLuminary[i].modifiers |= MenuItem.Checked;
+						} else miLuminary[i].modifiers &= ~MenuItem.Checked;
+					}
+				}
+			} // if (ev.target == kontextMenu)
+		} // if (ev instanceof ControlEvent ) 
+		super.onEvent(ev);
+	}
+}
+
+
+/**
+ *	Class to display maps to choose from
+ */
+class ListBox extends Form{
+	public MapInfoObject selectedMap = new MapInfoObject();
+	mButton cancelButton, okButton;
+	mList list = new mList(4,1,false);
+	public boolean selected = false;
+	Vector maps;
+
+	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos, MapInfoObject curMap){
+		this.title = "Maps";
+		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else 
+		// set width to screenwidth *3/4 but to at least 240 if the screen is big engough for 240px width
+		this.setPreferredSize(java.lang.Math.max(MyLocale.getScreenWidth()*3/4, java.lang.Math.min(240, MyLocale.getScreenWidth()) ), MyLocale.getScreenHeight()*3/4);
+		this.maps = maps;
+		MapInfoObject map;
+		ScrollBarPanel scb;
+		int oldmap = -1;
+		boolean curMapFound = false;
+		boolean[] inList = new boolean[maps.size()];
+		int row = -1;
+		if (curMap == null) curMapFound = true;
+		if (gotopos != null && Gps != null) {
+			list.addItem("--- Karten von akt. Position und Ziel ---");
+			row++;
+			for(int i = 0; i<maps.size();i++){
+				map = new MapInfoObject();
+				map = (MapInfoObject)maps.get(i);
+				if( map.inBound(Gps.latDec, Gps.lonDec) && map.inBound(gotopos) ) 
+				{
+					list.addItem(i + ": " + map.mapName);
+					row++;
+					inList[i] = true;
+					if (!curMapFound && map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+				} else inList[i] = false;
+			}
+		}
+		if (Gps != null) {
+			list.addItem("--- Karten der aktuellen Position ---");
+			row++;
+			for(int i = 0; i<maps.size();i++){
+				map = new MapInfoObject();
+				map = (MapInfoObject)maps.get(i);
+				if (map.inBound(Gps.latDec, Gps.lonDec) == true) 
+				{
+					list.addItem(i + ": " + map.mapName);
+					row++;
+					inList[i] = true;
+					if (!curMapFound  && map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+				}
+			}
+		}
+		if (gotopos != null) {
+			list.addItem("--- Karten des Ziels ---");
+			row++;
+			for(int i = 0; i<maps.size();i++){
+				map = new MapInfoObject();
+				map = (MapInfoObject)maps.get(i);
+				if(map.inBound(gotopos)) {
+					list.addItem(i + ": " + map.mapName);
+					row++;
+					inList[i] = true;
+					if (!curMapFound  && map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+				}
+			}
+		}
+		list.addItem("--- andere Karten ---");
+		row++;
+		for(int i = 0; i<maps.size();i++){
+			map = new MapInfoObject();
+			map = (MapInfoObject)maps.get(i);
+			if(!inList[i]) {
+				list.addItem(i + ": " + map.mapName);
+				row++;
+				if (!curMapFound  && map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+			}
+		}
+		list.selectItem(oldmap, true);
+		this.addLast(scb = new ScrollBarPanel(list),CellConstants.STRETCH, CellConstants.FILL);
+		cancelButton = new mButton("Cancel");
+		cancelButton.setHotKey(0, KeyEvent.getCancelKey(true));
+		this.addNext(cancelButton,CellConstants.STRETCH, CellConstants.FILL);
+		okButton = new mButton("Select");
+		okButton.setHotKey(0, KeyEvent.getActionKey(true));
+		this.addLast(okButton,CellConstants.STRETCH, CellConstants.FILL);
+		okButton.takeFocus(0);
+	}
+	private boolean mapIsInList(int mapNr){ // it is not used  anymore could be deleted
+		String testitem = new String();
+		int testitemnr;
+		for (int i=0; i<list.countListItems(); i++) {
+			try { 
+				testitem = ((MenuItem)list.items.get(i)).label;
+				testitemnr = Convert.toInt(testitem.substring(0,testitem.indexOf(':')));
+				if ( testitemnr == mapNr) return true;
+			} catch (IndexOutOfBoundsException e) {} // happens on a seperator line because it doesn't contain ":"
+			catch (NegativeArraySizeException e) {} // happens on a seperator line because it doesn't contain ":"
+		}
+		return false;
+	}
+
+	public void mapSelected() {
+		try { 
+			selectedMap = null;
+			int mapNum = 0;
+			String it = new String();
+			it = list.getText();
+			if (it != ""){
+				it = it.substring(0,it.indexOf(':'));
+				mapNum = Convert.toInt(it);
+				//	Vm.debug("Kartennummer: " + mapNum);
+				selectedMap = (MapInfoObject)maps.get(mapNum);
+				selected = true;
+				this.close(FormBase.IDOK);
+			}
+			else {
+				selected = false;
+				this.close(FormBase.IDCANCEL);
+			}
+		}catch (NegativeArraySizeException e) {} // happens in substring when a dividing line selected 
+	}
+
+	public void onEvent(Event ev){
+		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+			if (ev.target == cancelButton){
+				selectedMap = null;
+				selected = false;
+				this.close(FormBase.IDCANCEL);
+			}
+			if (ev.target == okButton || ev.target == list){ // ev.target == list is posted by mList if a selection was double clicked
+				mapSelected();
+			}
+		}
+		super.onEvent(ev);
+	}
+
+	public void  penDoubleClicked(Point where) {
+		mapSelected();
+	}
+}
+
+class ArrowsOnMap extends AniImage {
+	float gotoDir = -361;
+	float sunDir = -361;
+	float moveDir = -361;
+
+	int minY;
+	Graphics draw;
+	private MapInfoObject map=null;
+
+	Color moveDirColor = new Color(255,0,0); // RED 
+	final static Color sunDirColor = new Color(255,255,0); // Yellow
+	//final static Color GREEN = new Color(0,255,0);
+	final static Color gotoDirColor = new Color(0,0,128); // dark blue
+	final static Color northDirColor = new Color(0,0,255); // Blue
+	Point[] sunDirArrow = null;
+	Point[] gotoDirArrow = null;
+	Point[] moveDirArrow = null;
+	Point[] northDirArrow = null;
+	
+	/**
+	 * @param gd goto direction
+	 * @param sd sun direction
+	 * @param md moving direction
+	 */
+	public ArrowsOnMap(){
+		super();
+		newImage();
+		//	setDirections(90, 180, -90);
+	}
+
+	public void newImage() {
+		setImage(new Image(80,80), Color.White);
+		draw = new Graphics(image);
+	}
+	public void setMap(MapInfoObject m) {
+		map = m;
+		makeArrows();
+	}
+
+	public void setDirections(float gd, float sd, float md ) {
+		if (java.lang.Math.abs(gotoDir - gd) > 1 // to save cpu-usage only update if the is a change of directions of more than 1 degree
+				|| java.lang.Math.abs(sunDir - sd) > 1
+				|| java.lang.Math.abs(moveDir - md) > 1)
+		{
+			//dirsChanged = false;
+			gotoDir = gd;
+			sunDir = sd;
+			moveDir = md;
+			makeArrows();
+		}
+	}
+
+	/**
+	 * draw arrows for the directions of movement and destination waypoint
+	 * @param ctrl the control to paint on
+	 * @param moveDir degrees of movement
+	 * @param destDir degrees of destination waypoint
+	 */
+
+	public void doDraw(Graphics g,int options) {
+		if (map == null || g == null) return;
+		drawArrows(g);
+		return;
+/*		if (!dirsChanged) {
+			g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height); // the transparency with a transparent color doesn't work in ewe-vm for pocketpc, it works in java-vm, ewe-vm on pocketpc2003 
+			return;
+		}
+		dirsChanged = false;
+		//super.doDraw(g, options);
+		draw.setColor(Color.White);
+		draw.fillRect(0, 0, location.width, location.height);
+		minY = Integer.MAX_VALUE;
+		drawArrows(draw);
+		draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw 
+		g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
+*/	}
+
+	private void makeArrows(){
+			// draw only valid arrows
+			if (moveDir < 360 && moveDir > -360) {
+				if (moveDirArrow == null) moveDirArrow = new Point[2];
+				makeArrow(moveDirArrow, moveDir, 1.0f);
+			} else moveDirArrow = null;
+			if (gotoDir < 360 && gotoDir > -360) {
+				if (gotoDirArrow == null) gotoDirArrow = new Point[2];
+				makeArrow(gotoDirArrow, gotoDir, 1.0f);
+			} else gotoDirArrow = null;
+			if (sunDir < 360 && sunDir> -360) {
+				if (sunDirArrow == null ) sunDirArrow = new Point[2];
+				makeArrow(sunDirArrow, sunDir, 0.75f);
+			} else sunDirArrow = null;
+			if (java.lang.Math.abs(map.rotationRad) > 1.5 / 180 * java.lang.Math.PI)	{ // show northth arrow only if it has more than 1.5 degree deviation from vertical direction
+				if (northDirArrow == null) northDirArrow = new Point[2];
+				makeArrow(northDirArrow, 0, 1.0f); // north direction
+			} else northDirArrow = null;
+			
+			//select moveDirColor according to difference to gotoDir
+			moveDirColor = new Color(255,0,0); // red
+			
+			if (moveDirArrow != null && gotoDirArrow != null)
+			{
+				float diff = java.lang.Math.abs(moveDir - gotoDir);
+				while (diff > 360)
+				{
+					diff -= 360.0f;
+				}
+				if (diff > 180)
+				{
+					diff = 360.0f - diff;
+				}
+				
+				if (diff <= 5.0)
+				{
+					moveDirColor = new Color(0,192,0);// darkgreen
+				}
+				else if (diff <= 22.5)
+				{
+					moveDirColor = new Color(0,255,0);// green
+				}
+				else if (diff <= 45.0)
+				{
+					moveDirColor = new Color(255,128,0);// orange
+				}
+			}
+		}
+
+	/**
+	 * make (calculate) Pixel array for a single arrow 
+	 * @param g handle for drawing
+	 * @param angle angle of arrow
+	 * @param col color of arrow
+	 */
+	private void makeArrow(Point[] arrow, float angle, float scale) {
+		if (map == null) return;
+
+		float angleRad;
+		int centerX = location.width/2, centerY = location.height/2;
+		if (arrow[0] == null) arrow[0] = new Point();
+		if (arrow[1] == null) arrow[1] = new Point();
+		arrow[0].x = centerX;
+		arrow[0].y = centerY;
+		angleRad = angle * (float)java.lang.Math.PI / 180 + map.rotationRad;
+		arrow[1].x = centerX + new Float(centerX * java.lang.Math.sin(angleRad) * scale).intValue();
+		arrow[1].y = centerY - new Float(centerY * java.lang.Math.cos(angleRad) * scale).intValue();
+		//	g.setPen(new Pen(Color.Black,Pen.SOLID,7));
+		//	g.drawLine(centerX,centerY,x,y);
+	}
+
+	public void drawArrows(Graphics g) {
+		drawArrow(g, northDirArrow, northDirColor);
+		drawArrow(g, gotoDirArrow, gotoDirColor);
+		drawArrow(g, moveDirArrow, moveDirColor);
+		drawArrow(g, sunDirArrow, sunDirColor);
+	}
+	
+	public void drawArrow(Graphics g, Point[] arrow, Color col) {
+		if (arrow == null) return;
+		g.setPen(new Pen(col,Pen.SOLID,3));
+		g.drawLine(arrow[0].x, arrow[0].y, arrow[1].x,arrow[1].y);
+	}
+}
+
+

Added: trunk/src/CacheWolf/navi/Navigate.java
===================================================================
--- trunk/src/CacheWolf/navi/Navigate.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/Navigate.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,235 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.Global;
+import CacheWolf.Preferences;
+import ewe.fx.Color;
+import ewe.io.IOException;
+import ewe.io.SerialPort;
+import ewe.io.SerialPortOptions;
+import ewe.net.Socket;
+import ewe.sys.Convert;
+import ewe.sys.mThread;
+import ewe.ui.MessageBox;
+import ewe.util.mString;
+
+public class Navigate {
+	public CWPoint destination = new CWPoint();
+	public CWGPSPoint gpsPos = new CWGPSPoint();
+	public Track curTrack = null;
+	Color trackColor = new Color(255,0,0); // red
+	public CWPoint skyOrientationDir = new CWPoint();
+	public int luminary = SkyOrientation.SUN;
+
+	public GotoPanel gotoPanel = null;
+	public MovingMap movingMap = null;
+	public SerialThread serThread = null;
+	public Preferences pref = Global.getPref();
+	public UpdateThread tickerThread;
+	public boolean gpsRunning = false;
+	boolean lograw = false;
+	int logIntervall = 10;
+
+	public void setGotoPanel(GotoPanel gp) {
+		gotoPanel = gp;
+	}
+	public void setMovingMap (MovingMap mm) {
+		movingMap = mm;
+		if (gpsRunning) mm.gpsStarted();
+	}
+
+	public void startGps() {
+		if (serThread != null) if (serThread.isAlive()) return; // TODO use gpsRunning
+		try {
+			serThread = new SerialThread(pref.mySPO, gpsPos, (pref.forwardGPS ? pref.forwardGpsHost : ""));
+			if (pref.forwardGPS && !serThread.tcpForward) {
+				(new MessageBox("Warning", "Ignoring error:\n could not forward GPS data to host:\n"+pref.forwardGpsHost+"\n"+serThread.lastError+"\nstop and start GPS to retry",MessageBox.OKB)).exec();
+			}
+			if (gpsPos.latDec == 0 && gpsPos.lonDec == 0) { // TODO use isValid() // TODO raus damit?
+				gpsPos.latDec = destination.latDec; // setze Zielpunkt als Ausgangspunkt
+				gpsPos.lonDec = destination.lonDec;
+			}
+			serThread.start();
+			startDisplayTimer();
+			gpsRunning = true;
+			curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
+			if (lograw)	gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
+			if (gotoPanel != null) gotoPanel.gpsStarted();
+			if (movingMap != null) movingMap.gpsStarted();
+		} catch (IOException e) {
+			(new MessageBox("Error", "Could not connect to GPS-receiver.\n Error while opening serial Port " + e.getMessage()+"\npossible reasons:\n Another (GPS-)program is blocking the port\nwrong port\nOn Loox: active infra-red port is blocking GPS", MessageBox.OKB)).execute(); 
+		}
+	}
+
+	public void setRawLogging(boolean on, int intervall) {
+		lograw = on;
+		logIntervall = intervall; // TODO switch on and off during serthread running
+	}
+	public void startDisplayTimer() {
+		tickerThread = new UpdateThread(this, 1000);
+		tickerThread.start();
+	}
+
+	public void stopDisplayTimer(){
+		if (tickerThread != null) tickerThread.stop();
+	}
+
+	public void stopGps() {
+		serThread.stop();
+		stopDisplayTimer();
+		gpsPos.stopLog();
+		gpsRunning = false;
+		if (gotoPanel != null) gotoPanel.gpsStoped();
+		if (movingMap != null) movingMap.gpsStoped();
+	}
+
+	public boolean isGpsPosValid() {
+		return 	serThread != null && serThread.isAlive() && gpsPos.isValid() ; // && gpsPos.getfiex();
+
+	}
+
+
+	public void setDestination(String LatLon) { 
+		setDestination(new CWPoint(LatLon));
+	}
+
+
+	public void setDestination(CWPoint d) {
+		destination = new CWPoint (d);
+		if (gotoPanel != null) gotoPanel.destChanged(destination);
+		if (movingMap != null) movingMap.destChanged(destination);
+	}
+	/**
+	 * use the constants SkyOrientation.SUN, SkyOrientation.MOON etc.
+	 * @param lu
+	 */
+	public void setLuminary(int lu) {
+		luminary = lu;
+	}
+	public void ticked() {
+		int fix = gpsPos.getFix();
+		if (fix > 0 && (gpsPos.getSats()>= 0)) {
+			//gpsPosition.printAll();
+			//Vm.debug("currTrack.add: voher");
+			if (curTrack == null) curTrack = new Track(trackColor);
+			try {
+				curTrack.add(gpsPos);
+			} catch (IndexOutOfBoundsException e) { // track full -> create a new one
+				curTrack = new Track(trackColor); 
+				curTrack.add(gpsPos);
+				if (movingMap != null) movingMap.addTrack(curTrack); // TODO maybe gotoPanel should also hold a list of Tracks, because otherwise they will be destroyed if not saved in mmp before
+			}
+			try {
+				SkyOrientation.getSunAzimut(gpsPos.Time, gpsPos.Date, gpsPos.latDec, gpsPos.lonDec);
+				double jd = SkyOrientation.utc2juliandate(gpsPos.Time, gpsPos.Date);
+				skyOrientationDir = SkyOrientation.getLuminaryDir(luminary, jd, gpsPos);
+				ewe.sys.Vm.debug("neu: "+ skyOrientationDir.lonDec+ "jd: " + jd);
+			} catch (NumberFormatException e) { // irgendeine Info zu Berechnung des Sonnenaziumt fehlt (insbesondere Datum und Uhrzeit sind nicht unbedingt gleichzeitig verf?gbar wenn es einen Fix gibt)
+				skyOrientationDir.set(-361, -361); // any value out of range (bigger than 360) will prevent drawArrows from drawing it 
+			}
+
+		} else {
+			skyOrientationDir.set(-361, -361); // any value out of range (bigger than 360) will prevent drawArrows from drawing it		
+		}
+		gotoPanel.updateGps(fix);
+		if (movingMap != null) movingMap.updateGps(fix);
+	}
+}
+
+/**
+ * Thread for reading data from COM-port
+ *
+ */
+class SerialThread extends mThread{
+	SerialPort comSp;   
+	byte[] comBuff = new byte[1024*10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
+	int comLength = 0;
+	CWGPSPoint myGPS;
+	boolean run, tcpForward;
+	Socket tcpConn;
+	String lastError = new String();
+
+	public SerialThread(SerialPortOptions spo, CWGPSPoint GPSPoint, String forwardIP) throws IOException {
+		try{
+			comSp = new SerialPort(spo);
+		} catch (IOException e) {
+			throw new IOException(spo.portName);
+		} // catch (UnsatisfiedLinkError e) {} // TODO in original java-vm 
+		if (forwardIP.length()>0) { 
+			try {
+				tcpConn = new Socket(forwardIP, 23);
+				tcpForward = true;
+			} catch (ewe.net.UnknownHostException e) { tcpForward = false; lastError = e.getMessage();
+			} catch (IOException e) { tcpForward = false; lastError = e.getMessage(); 
+			}
+		}
+		myGPS = GPSPoint;
+	}
+
+	public void run() {
+		int noData = 0;
+		int notinterpreted = 0;
+		run = true;
+		while (run){
+			try {
+				sleep(1000);
+				//Vm.debug("Loop? " + noData);
+				noData++;
+				if (noData > 5) { myGPS.noDataError(); }
+			} catch (InterruptedException e) {}
+			if (comSp != null)	{
+				comLength = comSp.nonBlockingRead(comBuff, 0 ,comBuff.length);
+				//Vm.debug("Length: " + comBuff.length);
+				if (comLength > 0)	{
+					noData = 0;
+					String str = mString.fromAscii(comBuff, 0, comLength); 
+					if (tcpForward) {
+						try {
+							tcpConn.write(comBuff, 0, comLength);
+						} catch (IOException e) { tcpForward = false; }
+					}
+					//Vm.debug(str);
+					if (myGPS.examine(str)) notinterpreted = 0; else notinterpreted++;
+					if (notinterpreted > 22) myGPS.noInterpretableData();
+				}
+			}
+		} // while
+		myGPS.noData();
+		tcpConn.close();
+	}
+
+	public void stop() {
+		run = false;
+		if (comSp != null) comSp.close();
+	}
+}
+
+/** 
+ * Class for creating a new mThread to create timer ticks to be able to do form.close in the ticked-thread. 
+ * Using the Vm.requestTimer-Method causes "ewe.sys.EventDirectionException: This task cannot be done within 
+ * a Timer Tick." in the ewe-vm when form.close is called.  
+ */
+
+class UpdateThread extends mThread {
+	public boolean run;
+	public int calldelay;
+	public Navigate ticked;
+
+	public UpdateThread (Navigate gp, int cd) {
+		ticked = gp;
+		calldelay = cd;
+	}
+
+	public void run () {
+		run = true;
+		while (run) {
+			try { sleep (calldelay);} catch (InterruptedException e) {}
+			ticked.ticked();
+		}
+	}
+
+	public void stop() {
+		run = false;
+	}
+}
+

Added: trunk/src/CacheWolf/navi/SelectMap.java
===================================================================
--- trunk/src/CacheWolf/navi/SelectMap.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/SelectMap.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,90 @@
+package CacheWolf.navi;
+
+import CacheWolf.Global;
+import CacheWolf.InfoBox;
+import utils.FileBugfix;
+import ewe.util.*;
+import ewe.io.*;
+import ewe.filechooser.*;
+import ewe.sys.*;
+import ewe.ui.*;
+
+/**
+*	This class displays a user interface to select maps that should be or are already calibrated
+*	class id = 4100
+*/
+public class SelectMap extends Form{
+	ScrollBarPanel top;
+	ScrollBarPanel bot;
+	mButton mBCancel, mBLoad;
+	Locale l = Vm.getLocale();
+	LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
+	String mapsPath = new String();
+	mList nonCMaps = new mList(3,1,false);
+	mList CMaps = new mList(3,1,false);
+	String dateien[];
+	String selectedMap = new String();
+	public boolean worldfileexists = false;
+	
+	public SelectMap(){
+		mapsPath = Global.getPref().getMapManuallySavePath(false)+"/"; //  File.getProgramDirectory() + "/maps/";
+		top = new ScrollBarPanel(CMaps);
+		bot = new ScrollBarPanel(nonCMaps);
+		this.title = (String)lr.get(4101,"Maps");
+		this.addLast(new mLabel((String)lr.get(4102,"Calibrated Maps")), CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(top, CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(new mLabel((String)lr.get(4103,"Non Calibrated Maps")), CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(bot, CellConstants.STRETCH, CellConstants.FILL);
+		this.addNext(mBCancel = new mButton((String)lr.get(4104,"Cancel")),CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(mBLoad = new mButton((String)lr.get(4105,"Open")),CellConstants.STRETCH, CellConstants.FILL);
+		InfoBox inf = new InfoBox("Info", (String)lr.get(4109,"Loading maps...")); 
+		inf.show();
+		try{
+			File files = new FileBugfix(mapsPath);
+			File checkWFL;
+			String rawFileName = new String();
+			dateien = files.listMultiple("*.png,*.jpg,*.gif,*.bmp", File.LIST_FILES_ONLY);
+			for(int i = 0; i < dateien.length;i++){
+				rawFileName = dateien[i].substring(0, dateien[i].lastIndexOf("."));
+				checkWFL = new File(mapsPath + rawFileName + ".wfl");
+				
+				if(checkWFL.exists()){
+					CMaps.addItem(rawFileName);
+				} else {
+					nonCMaps.addItem(rawFileName);
+				}
+			}
+		}catch(Exception ex){
+			//Vm.debug("Problem retrieveing map files");
+		}
+		inf.close(0);
+	}
+	
+	public void onEvent(Event ev){
+		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+			if(ev.target == mBCancel){
+				this.close(0);
+			}
+			if(ev.target == mBLoad){
+				this.close(0);
+			}
+		}
+		if(ev instanceof ListEvent && ev.type == ListEvent.SELECTED){
+			if(ev.target == nonCMaps){
+				selectedMap = nonCMaps.getText();
+				CMaps.deleteSelection();
+				worldfileexists = false;
+			}
+			if(ev.target == CMaps){
+				selectedMap = CMaps.getText();
+				nonCMaps.deleteSelection();
+				worldfileexists = true;
+			}
+		}
+		super.onEvent(ev);
+	}
+	
+	public String getSelectedMap(){
+		return selectedMap;
+	}
+}
\ No newline at end of file

Added: trunk/src/CacheWolf/navi/SkyOrientation.java
===================================================================
--- trunk/src/CacheWolf/navi/SkyOrientation.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/SkyOrientation.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,354 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.MyLocale;
+import ewe.sys.Convert;
+
+/** Class to caculate positions of luminaries
+ * all methods are static
+ * usage:
+ * call utc2juliandate and then getLuminaryDir
+ * in ressources/cachewolf.languages messege numbers from 6100
+ * 
+ * @author Pfeffer
+ *
+ */
+public class SkyOrientation {
+
+	public final static int SUN = 0;
+	public final static int MOON = 1;
+	public static final int ALIOTH = 2; // brightest star in Grater Bear (Grosser Wagen) Rektaszension 12 h 54 m 2 s Deklination +55 Grad 57' 36"
+	public static final int GREATER_BEAR = ALIOTH;
+	public static final int ALNILAM = 3; //Orion = Alnilam = mittlerer Guertelstern Aequinoktium 2000): Rektaszension 5h36m13s; Deklination -1 Grad 12'7"
+	public static final int ORION = ALNILAM; 
+	public static final int CASSIOPEIA_GAMMA = 4; // Kassiopeia Gamma: 00h 56m 42.50s	+60 Grad 43' 00.3"
+	public static final int CASSIOPEIA = CASSIOPEIA_GAMMA;
+	public static final int DENEB = 5;
+	public static final int CYGNUS = DENEB; // Cygnus = Schwan
+	public static final int MIMOSA = 6; // second brightest star in Southern Cross
+	public static final int SOUTHERN_CROSS = MIMOSA; // SOUTHERN_CROSS = Kreus des S?dens = Crux australia
+	
+	public static final CWPoint[] STARS = {
+		// (Deklination, Rektaszension)
+		/*ALIOTH*/		new CWPoint(55. +57./60. + 36./3600., (12. + 54./60. + 2./3600.)*15.), // ALIOTH: Rektaszension 12 h 54 m 2 s Deklination +55 Grad 57' 36"
+		/*ALNILAM*/		new CWPoint(-1. -12./60. -7./3600., (5.+36./60. + 13./3600.)*15.), // (-1. -12./60. -7./3600., (5. + 36./60. + 13./3600.)*15.) <- wikipedia // -1.19748, 5.60978 * 15.) <- www.... // (-1. -11./60. -52./3600., (5. + 36./60. + 35./3600.)*15.)  <- Stellarium 
+		/*Cassiopeia*/	new CWPoint(60. + 43./60. + 0.3/3600., (0 + 56./60. +42.5/3600.)*15.), // CASSIOPALA_GAMMA 00h 56m 42.50s, 60 Grad 43' 00.3" <-- wikipedia, Stellarium: 57m 11s, 60 Grad 45' 29"
+		/*Deneb*/		new CWPoint(45. + 16./60. + 49.2/3600., (20 + 41./60. +25.6/3600.)*15.), // im Schwan (Sommerdreieck) Quelle: Stellarium
+		/*Mimosa*/		new CWPoint(-59. - 41./60. - 19./3600., (12 + 47./60. +43.2/3600.)*15.) // im Schwan (Sommerdreieck) Quelle: Stellarium
+		// Sirius
+	};
+	
+	public static String [] LUMINARY_NAMES = { // TODO MyLocale.getMsg(xxx, "Sun"),
+		MyLocale.getMsg(6100, "Sun"), 
+		MyLocale.getMsg(6101, "Moon"), 
+		MyLocale.getMsg(6102, "Grater Bear"),
+		MyLocale.getMsg(6103, "Orion"),
+		MyLocale.getMsg(6104, "Cassiopeia"), 
+		MyLocale.getMsg(6105, "Cygnus"),
+		MyLocale.getMsg(6106, "Southern Cross")
+	};
+
+	public static String [] LUMINARY_DESC = { // TODO MyLocale.getMsg(xxx, "Sun"),
+		MyLocale.getMsg(6100, "Sun"), 
+		MyLocale.getMsg(6101, "Moon"), 
+		MyLocale.getMsg(6122, "Alioth in Greater Bear"),
+		MyLocale.getMsg(6123, "Alnilam in Orion"),
+		MyLocale.getMsg(6124, "Cassiopeia Gamma"), 
+		MyLocale.getMsg(6125, "Deneb in Cygnus"),
+		MyLocale.getMsg(6126, "Becrux in Southern Cross")
+	};
+
+	/**
+	 * Get the friendly name of the luminary
+	 * @param luminary
+	 * @return
+	 */
+	public static String getLuminaryName(int luminary) {
+		return LUMINARY_NAMES[luminary]; 
+	}
+	
+	/**
+	 * Get a more exact description of the luminary 
+	 * @param lu
+	 * @return
+	 */
+	public static String getLuminaryDesc(int lu) {
+		return LUMINARY_DESC[lu];
+	}
+
+	/**
+	 * get azimuth from north and elevation for horizont for a given 
+	 * Luminary (planet or star) 
+	 * @param luminary one of SUN, MOON, ALIOTH, GRAETER_BEAR, ALNILAM, ORION, CASSIOPEIA_GAMMA, CASSIOPEIA
+	 * @param jd julian date must be calculated in advance e.g. from utc2julian
+	 * @param onEarth place on earth of the observer
+	 * @return lon = azimuth from north, lat = elevation from horizont
+	 */
+	public static CWPoint getLuminaryDir(int luminary, double jd, CWPoint onEarth) {
+		switch (luminary) {
+		case SUN: return getSunDir(jd, onEarth);
+		case MOON: return getMoonDir(jd, onEarth);
+		default: 
+			return equatorial2AzimutCoos(onEarth, jd, STARS[luminary-MOON-1]);
+		}
+	}
+
+	/**
+	 * @param utc in the format as it comes from gps DDMMYY
+	 * @param datum in the format as it comes from gps HHMMSS
+	 * @return juliandate
+	 * @throws NumberFormatException if utc / datum could not be parsed successfully
+	 */
+	public static double utc2juliandate(String utc, String datum) {
+		try {
+			int tag, monat, jahr, stunde, minute, sekunde;
+			tag     = Convert.parseInt(datum.substring(0, 2));
+			monat   = Convert.parseInt(datum.substring(2, 4));
+			jahr    = Convert.parseInt(datum.substring(4, 6)) + 2000;
+			stunde  = Convert.parseInt(utc.substring(0, 2));
+			minute  = Convert.parseInt(utc.substring(2, 4));
+			sekunde = Convert.parseInt(utc.substring(4, 6)); // Kommastellen werden abgeschnitten
+			// julianisches "Datum" jd berechnen (see http://de.wikipedia.org/wiki/Julianisches_Datum )
+			if (monat<2) {jahr--; monat+=12;} // verlegung des Jahres Endes auf Feb macht Berechnung von SChaltjahren einfacher
+			double a = (int)java.lang.Math.floor((double)jahr/100.); // Alle hundert Jahre kein Schlatjahr (abrunden)
+			double b = 2 - a + java.lang.Math.floor((double)a/4.);
+			double jd = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) + (double)tag + (double)stunde/24 + (double)minute/1440 + (double)sekunde/86400 + b - 1524.5;
+			return jd;
+			//double jd0 = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) +(double)tag + b - 1524.5;
+		} catch (IndexOutOfBoundsException e) {
+			// wird von substring geworfen wenn datum / utc nicht genug Ziffern haben
+			// NumberFormatException wird au?erdem von Convert.ParseInt direkt geworfen wenn
+			// nicht in Int konvertiert werden kann
+			throw new NumberFormatException();
+		}
+	}
+
+	/**
+	 * old version, gives the same as the new one
+	 * @param utc
+	 * @param datum
+	 * @param lat
+	 * @param lon
+	 * @return
+	 */
+	public static float getSunAzimut (String utc, String datum, double lat, double lon) {
+		//	(new MessageBox("test", "utc:"+utc+" datum: "+datum+", lat: "+lat+", len: "+lon, MessageBox.OKB)).exec();
+		try {
+			int tag, monat, jahr, stunde, minute, sekunde;
+			tag = Convert.parseInt(datum.substring(0, 2));
+			monat = Convert.parseInt(datum.substring(2, 4));
+			jahr = Convert.parseInt(datum.substring(4, 6)) + 2000;
+			stunde=Convert.parseInt(utc.substring(0, 2));
+			minute=Convert.parseInt(utc.substring(2, 4));
+			sekunde=Convert.parseInt(utc.substring(4, 6)); // Kommastellen werden abgeschnitten
+			// julianisches "Datum" jd berechnen (see http://de.wikipedia.org/wiki/Julianisches_Datum )
+			if (monat<2) {jahr--; monat+=12;} // verlegung des Jahres Endes auf Feb macht Berechnung von SChaltjahren einfacher
+			double a = (int)java.lang.Math.floor((double)jahr/100.); // Alle hundert Jahre kein Schlatjahr (abrunden)
+			double b = 2 - a + java.lang.Math.floor((double)a/4.);
+			double jd = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) + (double)tag + (double)stunde/24 + (double)minute/1440 + (double)sekunde/86400 + b - 1524.5;
+			double jd0 = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) +(double)tag + b - 1524.5;
+			// Ekliptikalkoordinaten der Sonne berechnen (see http://de.wikipedia.org/wiki/Sonnenstand )
+			double n = jd - 2451545.0;
+			double l = 280.46 + 0.9856474 * n;
+			double g = 357.528 + 0.9856003 * n;
+			double d = l + 1.915*java.lang.Math.sin(g/180*java.lang.Math.PI) + 0.02 * java.lang.Math.sin(2*g/180*java.lang.Math.PI);
+			// Rektaszension alpha und Deklination delta der Sonne berechnen
+			double e = 23.439 -0.0000004 * n;
+			double alphaNenner = java.lang.Math.cos(d/180*java.lang.Math.PI);
+			double alpha = 180/java.lang.Math.PI*java.lang.Math.atan(java.lang.Math.cos(e/180*java.lang.Math.PI)*java.lang.Math.sin(d/180*java.lang.Math.PI)/alphaNenner);
+			double delta = 180/java.lang.Math.PI*java.lang.Math.asin(java.lang.Math.sin(e/180*java.lang.Math.PI)*java.lang.Math.sin(d/180*java.lang.Math.PI) );
+			if (alphaNenner<0) {alpha +=180;}
+			// Azimut
+			double t0 = (jd0 - 2451545.)/36525.; // schon in t0 bzw jd0 richtig berechnet?
+			double thetaHG = 6.697376 + 2400.05134 * t0 + 1.002738 * ((double)stunde + (double)minute/60. + (double)sekunde/3600.);
+			double theta = thetaHG * 15. + lon;
+			double azimutNenner = java.lang.Math.cos((theta-alpha)/180*java.lang.Math.PI)*java.lang.Math.sin(lat/180*java.lang.Math.PI)-
+			java.lang.Math.tan(delta/180*java.lang.Math.PI)*java.lang.Math.cos(lat/180*java.lang.Math.PI);
+			float azimut = (float) java.lang.Math.atan(java.lang.Math.sin((theta-alpha)/180*java.lang.Math.PI)/
+					azimutNenner);
+			azimut = (float) (azimut * 180f / java.lang.Math.PI);
+			if (azimutNenner<0) azimut +=180.;
+			// null = Sueden auf Null = Norden umrechnen
+			azimut +=180.;
+			if (azimut >360.) azimut -=360.;
+			ewe.sys.Vm.debug("sunAzimut1: " + azimut);
+			ewe.sys.Vm.debug("sun Elevation: " +getSunAzimut2 (utc, datum, lat, lon).latDec);
+			CWPoint MoonDir = getMoonDir(jd, new CWPoint(lat, lon));
+			ewe.sys.Vm.debug("Moon Elevation: " + MoonDir.latDec + "Moon Azimut: " + MoonDir.lonDec);
+			CWPoint OrionDir = getAlnilamDir(jd, new CWPoint(lat, lon));
+			ewe.sys.Vm.debug("Alnilam (Orion) Elevation: " + OrionDir.latDec + "Alnilam (Orion) Azimut: " + OrionDir.lonDec );
+			
+			return azimut;
+		} catch (IndexOutOfBoundsException e) {
+			// wird von substring geworfen wenn datum / utc nicht genug Ziffern haben
+			// NumberFormatException wird ausserdem von Convert.ParseInt direkt geworfen wenn
+			// nicht in Int konvertiert werden kann
+			throw new NumberFormatException();
+		}
+	}
+
+	public static CWPoint getSunAzimut2 (String utc, String datum, double lat, double lon) {
+		double jd = utc2juliandate(utc, datum);
+		CWPoint eclCoos = getSunEclipticCoos(jd);
+		// calculate ecliptic coos
+		// convert coos
+		return ecliptic2AzimutCoos(new CWPoint(lat, lon), jd, eclCoos);
+	}
+
+	public static CWPoint getSunDir (double jd, CWPoint onEarth) {
+		CWPoint eclCoos = getSunEclipticCoos(jd);
+		// calculate ecliptic coos
+		// convert coos
+		return ecliptic2AzimutCoos(onEarth, jd, eclCoos);
+	}
+
+	public static CWPoint getMoonDir(double jd, CWPoint onEarth) {
+		CWPoint eclCoo = getMoonEclipticCoos(jd);
+		return ecliptic2AzimutCoos(onEarth, jd, eclCoo);
+	}
+
+	public static CWPoint getAlnilamDir(double jd, CWPoint onEarth) {
+		// Koordinaten Alnilam (mittlerer Guertelstern des Orion), Rektaszension 5h36m13s; Deklination -1?12'7 TODO Aequinoktium 2000
+		// Source: wikipedia
+		return equatorial2AzimutCoos(onEarth, jd, new CWPoint(-1. -12./60. -7./3600., (5. + 36./60. + 13./3600.)*15.) ); // (-1. -12./60. -7./3600., (5. + 36./60. + 13./3600.)*15.) <- wikipedia // -1.19748, 5.60978 * 15.) <- www.... // (-1. -11./60. -52./3600., (5. + 36./60. + 35./3600.)*15.)  <- Stellarium
+	}
+
+	/**
+	 * get the ecliptic coordinates of the sun
+	 * @param juliandate
+	 * @return
+	 */
+	public static CWPoint getSunEclipticCoos(double juliandate) {
+		double n = juliandate - 2451545.0;
+		double l = 280.46 + 0.9856474 * n;
+		double g = 357.528 + 0.9856003 * n;
+		double lambda = l + 1.915*java.lang.Math.sin(g/180*java.lang.Math.PI) + 0.02 * java.lang.Math.sin(2*g/180*java.lang.Math.PI);
+		return new CWPoint(0, lambda);
+	}
+
+
+	// the following code is adopted from http://lexikon.astronomie.info/java/sunmoon/sunmoon.html
+	// ignores the time difference between juliandate and TDT, which is something like 1 minute
+	public static CWPoint getMoonEclipticCoos(double julianDate) {
+		final double DEG = Math.PI / 180;  
+		final double RAD = 1/DEG;
+		double sunAnomalyMean = 360*DEG/365.242191*(julianDate - 2447891.5) + 279.403303*DEG - 282.768422*DEG;
+		double D = julianDate-2447891.5;
+
+		// Mean Moon orbit elements as of 1990.0
+		double l0 = 318.351648*DEG;
+		double P0 =  36.340410*DEG;
+		double N0 = 318.510107*DEG;
+		double i  = 5.145396*DEG;
+
+		double l = 13.1763966*DEG*D+l0;
+		double MMoon = l-0.1114041*DEG*D-P0; // Moon's mean anomaly M
+		double N = N0-0.0529539*DEG*D;       // Moon's mean ascending node longitude
+
+		double sunlon = getSunEclipticCoos(julianDate).lonDec; 
+		double C = l-sunlon;
+		double Ev = 1.2739*DEG*Math.sin(2*C-MMoon);
+		double Ae = 0.1858*DEG*Math.sin(sunAnomalyMean);
+		double A3 = 0.37*DEG*Math.sin(sunAnomalyMean);
+
+		double MMoon2 = MMoon+Ev-Ae-A3;  // corrected Moon anomaly
+		double Ec = 6.2886*DEG*Math.sin(MMoon2);  // equation of centre
+		double A4 = 0.214*DEG*Math.sin(2*MMoon2);
+		double l2 = l+Ev+Ec-Ae+A4; // corrected Moon's longitude
+		double V = 0.6583*DEG*Math.sin(2*(l2-sunlon));
+
+		double l3 = l2+V; // true orbital longitude;
+		double N2 = N-0.16*DEG*Math.sin(sunAnomalyMean);
+
+		CWPoint moonCoor = new CWPoint();  
+		moonCoor.lonDec = (( N2 + Math.atan2( Math.sin(l3-N2)*Math.cos(i), Math.cos(l3-N2) ) ) * RAD)% 360;
+		moonCoor.latDec = Math.asin( Math.sin(l3-N2)*Math.sin(i) ) * RAD;
+		//moonCoor.orbitLon = l3;
+		return moonCoor;
+
+		/*
+		double e  = 0.054900;
+		double a  = 384401; // km
+		double diameter0 = 0.5181*DEG; // angular diameter of Moon at a distance
+		double parallax0 = 0.9507*DEG; // parallax at distance a
+
+		  // relative distance to semi mayor axis of lunar oribt
+		  moonCoor.distance = (1-sqr(e)) / (1+e*Math.cos(MMoon2+Ec) );
+		  moonCoor.diameter = diameter0/moonCoor.distance; // angular diameter in radians
+		  moonCoor.parallax = parallax0/moonCoor.distance; // horizontal parallax in radians
+		  moonCoor.distance *= a;	// distance in km
+
+		  // Age of Moon in radians since New Moon (0) - Full Moon (pi)
+		  moonCoor.moonAge = Mod2Pi(l3-sunCoor.lon);   
+		  moonCoor.phase   = 0.5*(1-Math.cos(moonCoor.moonAge)); // Moon phase, 0-1
+
+		  var phases = new Array("Neumond", "Zunehmende Sichel", "Erstes Viertel", "Zunnehmender Mond", 
+		  	"Vollmond", "Abnehmender Mond", "Letztes Viertel", "Abnehmende Sichel", "Neumond");
+		  var mainPhase = 1./29.53*360*DEG; // show 'Newmoon, 'Quarter' for +/-1 day arond the actual event
+		  var p = Mod(moonCoor.moonAge, 90.*DEG);
+		  if (p < mainPhase || p > 90*DEG-mainPhase) p = 2*Math.round(moonCoor.moonAge / (90.*DEG));
+		  else p = 2*Math.floor(moonCoor.moonAge / (90.*DEG))+1;
+		  moonCoor.moonPhase = phases[p];
+
+		  moonCoor.sign = Sign(moonCoor.lon);
+		  return (float) moonCoor.lonDec;
+		return 0;
+	}
+		 */
+	}
+
+	public static CWPoint ecliptic2AzimutCoos(CWPoint onEarth, double julianDate, CWPoint ecliptic) {
+		CWPoint equat = ecliptic2Equatorial(ecliptic, julianDate);
+		return equatorial2AzimutCoos(onEarth, julianDate, equat);
+	}
+	/**
+	 * convert rektaszension alpha and deklination delta to azimuth / elevation
+	 * @param onEarth pos. on earth for which the azimut is wanted
+	 * @param julianDate
+	 * @param equatorial: lonDec = rektaszension (alpha), latDec = Deklination (delta)
+	 * @return lonDec: azimuth in degrees from north, lat: elevation in degrees from horizont
+	 * alogithism from wikipedia sonnenbahn
+	 */
+	public static CWPoint equatorial2AzimutCoos(CWPoint onEarth, double julianDate, CWPoint equatorial) {
+		double stunde = ((julianDate + 0.5) % 1) * 24;
+		double jd0 = julianDate - stunde /24; // julian date at UTC 0:00
+		double t0 = (jd0 - 2451545.)/36525.; // schon in t0 bzw jd0 richtig berechnet?
+		double thetaHG = 6.697376 + 2400.05134 * t0 + 1.002738 * stunde; // + (double)minute/60.);
+		double theta = thetaHG * 15. + onEarth.lonDec;
+		double tau = (theta - equatorial.lonDec ) /180*Math.PI;
+		double phi = onEarth.latDec/180*Math.PI;
+		double azimutNenner = Math.cos(tau)*Math.sin(phi)-
+		Math.tan(equatorial.latDec/180*Math.PI)*Math.cos(onEarth.latDec/180*java.lang.Math.PI);
+		float azimut = (float) java.lang.Math.atan(java.lang.Math.sin((theta-equatorial.lonDec)/180*Math.PI)/
+				azimutNenner);
+		azimut = (float) (azimut * 180f / java.lang.Math.PI);
+		if (azimutNenner<0) azimut +=180.;
+		double h = 180 / Math.PI * Math.asin(Math.cos(equatorial.latDec/180*Math.PI) * Math.cos(tau)*Math.cos(phi) + Math.sin(equatorial.latDec/180 *Math.PI) * Math.sin(phi));
+		// null = Sueden auf Null = Norden umrechnen
+		azimut +=180.;
+		if (azimut >360.) azimut -=360.;
+		return new CWPoint(h, azimut);
+	}
+
+	/**
+	 * convert from eliptical to equatorial coordinates
+	 * @param juliandate
+	 * @param eklipCoo ecliptic coos in degrees  
+	 * @return lon: Deklination (delta), lat: Rektaszension (alpha) in degree
+	 * this is adopted from http://lexikon.astronomie.info/java/sunmoon/sunmoon.html 
+	 */
+	public static CWPoint ecliptic2Equatorial(CWPoint eklipCoo, double juliandate) {
+		double T = (juliandate - 2451545.0)/36525.; // Epoch 2000 January 1.5
+		double eps = (23.+(26+21.45/60)/60 + T*(-46.815 +T*(-0.0006 + T*0.00181) )/3600 ) / 180 * java.lang.Math.PI; // schiefe der Ekliptik
+		double coseps = Math.cos(eps);
+		double sineps = Math.sin(eps);
+
+		double sinlon = Math.sin(eklipCoo.lonDec / 180 * Math.PI);
+		CWPoint equatorial = new CWPoint();
+		equatorial.lonDec = (180 / Math.PI * Math.atan2( (sinlon*coseps-Math.tan(eklipCoo.latDec /180 * Math.PI)*sineps), Math.cos(eklipCoo.lonDec/180 * Math.PI) ) ) % 360; // rektaszension (alpha)
+		equatorial.latDec = 180 / Math.PI * Math.asin( Math.sin(eklipCoo.latDec/180 * Math.PI)*coseps + Math.cos(eklipCoo.latDec/180 * Math.PI)*sineps*sinlon ); // deklination (delta)
+
+		return equatorial;
+	}
+}
+

Added: trunk/src/CacheWolf/navi/Track.java
===================================================================
--- trunk/src/CacheWolf/navi/Track.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/Track.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,56 @@
+package CacheWolf.navi;
+
+import ewe.fx.*;
+
+public class Track {
+	public Color trackColor;
+	public TrackPoint TrackPoints[];
+	public int num;
+	
+	public Track(Color f) {
+		trackColor = f;
+		TrackPoints = new TrackPoint[5000];
+		num = 0;
+	}
+/*===== add is currently not used	
+	public void add(double lat, double lon) {
+		TrackPoints[num] = new TrackPoint(lat, lon);
+		num++;
+	}
+=====*/	
+	/*
+	 * throws IndexOutOfBoundsException when track is full
+	 */
+	public void add(TrackPoint t) { 
+		if (TrackPoints == null || t == null) return;
+		TrackPoints[num] = new TrackPoint(t);
+		num++;
+	}
+/*===== loadTrack/saveTrack are currently not used
+	public void loadTrack(String filename){ // TODO untested!
+		byte [] all = ewe.sys.Vm.readResource(null,filename);
+		if (all == null) return; // TODO error handling
+		num = Utils.readInt(all, 0, 4);
+		for (int i=0; i<=num; i++){
+			TrackPoints[i].latDec = Double.longBitsToDouble(Utils.readLong(all, (i*2)*8 + 4));
+			TrackPoints[i].lonDec = Double.longBitsToDouble(Utils.readLong(all, (i*2+1)*8 + 4));
+		}
+	}
+	
+	public void saveTrack(String filename){  // TODO untested!
+	//ByteArray ba=new ByteArray();
+	byte[] ba = new byte[8*2*num+4]; // 8 bytes is one double int has size 4
+	Utils.writeInt(num, ba, 0, 4);
+	for (int i=0; i<=num; i++){
+		Utils.writeLong(Double.doubleToLongBits(TrackPoints[i].latDec), ba, (i*2)*8 + 4);
+		Utils.writeLong(Double.doubleToLongBits(TrackPoints[i].lonDec), ba, (i*2+1)*8 + 4);
+	}
+	try{
+		PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(filename)));
+		outp.print(ba.toString());
+	}catch (IOException e) {
+		(new MessageBox("Error", "Error reading trackfile:\n"+e.toString(), MessageBox.OKB)).execute();}
+	}
+=====*/
+
+}

Added: trunk/src/CacheWolf/navi/TrackOverlay.java
===================================================================
--- trunk/src/CacheWolf/navi/TrackOverlay.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/TrackOverlay.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,299 @@
+package CacheWolf.navi;
+
+//import java.awt.image.BufferedImage;
+
+import ewe.fx.Color;
+import ewe.fx.Graphics;
+import ewe.fx.IImage;
+import ewe.fx.Image;
+import ewe.fx.Pen;
+import ewe.graphics.AniImage;
+import ewe.sys.Convert;
+import ewe.fx.Point;
+import ewe.fx.Mask;
+
+import ewe.util.Vector;
+
+
+public class TrackOverlay extends MapImage {
+	public TrackPoint topLeft;
+	public TrackPoint bottomRight;
+	Graphics draw;
+	Graphics drawMask;
+	int test;
+	MapInfoObject trans; 
+	public Vector tracks;
+	boolean imageChangesDontShow = false;
+	public Point trackPixels[] = null;
+	public Color trackPixelsColor[] = null;
+	public int numPixels = 0;
+	final static int maxPixelsInCache = 100;
+	final static Color transparentColorForOverlay = Color.White; // only for use when transparent color is used
+	static boolean useTransparentColor;
+	public TrackOverlay (TrackPoint topLefti, int widthi, int highti, MapInfoObject transi) {
+		super();
+		topLeft = new TrackPoint(topLefti);
+		trans = transi;
+		bottomRight = calcLatLonInImage(widthi, highti);
+		if (ewe.sys.Vm.getPlatform().equalsIgnoreCase("java")) {
+			useTransparentColor = true; 
+			setImage(new Image(widthi, highti), transparentColorForOverlay); // java-vm: transparency with a mask is very memory consuming, but transparency with a mask is much faster in ewe-vm and doesn't consume more memory than a transparency color (ewe 1.49)
+		} else {
+			useTransparentColor = false; // // momentanously this it not used, but this is only because ewe treats areas as opaque which has a non white color in the image, so that the mask doesn't need to be changed
+			Image maski = new Image(widthi, highti);
+			drawMask = new Graphics(maski);
+			drawMask.setColor(Color.White);
+			drawMask.fillRect(0, 0, maski.getWidth(), maski.getHeight());
+			setImage(new Image(widthi, highti), maski); // java-vm: transparency with a mask is very memory consuming, but transparency with a mask is much faster in ewe-vm and doesn't consume more memory than a transparency color (ewe 1.49)
+			maski.free(); //setimage produces an inverted copy of the mask
+			maski = null;
+		}
+		//properties = AlwaysOnTop; // arrows are above, so dont set it.
+		draw = new Graphics(image);
+		draw.setDrawOp(Graphics.DRAW_OVER);
+		if (useTransparentColor) draw.setColor(transparentColorForOverlay);
+		else draw.setColor(Color.White);
+		draw.fillRect(0, 0, widthi, highti);
+		//int[] markImage = {0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000};
+		//int[] markMaskOpaque = {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff};
+		//mask.setPixels( markMaskOpaque, 0, 50, 50, 2, 2, 0);
+		//draw.fillRectRGB(50, 50, 52, 52, 0x00ff0000); // fillRectRGB has a Bug - it never returns - use fillRect instead
+		//image.setPixels(markImage, 0, 50, 50, 2, 2, 0); // out of an to me unkwon reason this doesn't work here, but it does in painttracks
+	}
+	public void imageSet()
+//	==================================================================
+	{
+		IImage i = drawable;
+		if (i == null) i = image;
+		if (i != null){
+			location.width = i.getWidth();
+			location.height = i.getHeight();
+		}
+		if (image != null && image != sourceImage) image.freeze();
+//		if (mask != null && mask != sourceMask) mask.freeze(); // dont freeze the mask, it could change. Anyway momentanously it doesnt change, because when the image contains non-white in the opaque areas, it will be opaque without changing the mask
+		properties &= ~HasChanged;
+	}
+
+
+	public void paintTracks() {
+	// for debugging TrackOverlayPositions
+	// draw.setPen(new Pen(Color.LightBlue,Pen.SOLID,1));
+	// draw.fillRect(1, 1, image.getWidth()-1, image.getHeight()-1);
+		//draw.setColor(255,0,0);
+		//draw.setPen(new Pen(new Color(255,0,0),Pen.SOLID,3));
+		//draw.fillRect(50, 50, 4, 4); // fillRectRGB has a Bug - it never returns - use fillRect instead
+
+		if (tracks == null || tracks.size() == 0) return;
+		int tri, i;
+		Track tr;
+		for (tri=tracks.size()-1; tri >= 0; tri--) {
+			tr = (Track)tracks.get(tri);
+			//draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
+			draw.setColor(tr.trackColor);
+			if (tr.num > 0) {
+				for (i=0; i < tr.num; i++) {
+					paintPoint(tr.trackColor, tr.TrackPoints[i].latDec, tr.TrackPoints[i].lonDec);
+				}
+			}
+		}
+	}
+	
+
+	/**
+	 * 
+	 * @param f
+	 * @param lat
+	 * @param lon
+	 * @return true if point was on this overlay
+	 */
+	public boolean paintPoint(Color f, double lat, double lon){
+		if (lat<bottomRight.latDec || lat > topLeft.latDec || lon<topLeft.lonDec || lon>bottomRight.lonDec) return false;
+		//ewe.sys.Vm.debug("showlastaddedpoint, lat: "+lat+"   lon: "+lon);
+		double b[] = new double[2];
+		int x, y;
+		b[0] = lat - topLeft.latDec; // see calcXYinImage (TrackPoint p) 
+		b[1] = lon - topLeft.lonDec; 
+		x=(int) (trans.transLatX* b[0] + trans.transLonX*b[1]);
+		y=(int) (trans.transLatY* b[0] + trans.transLonY*b[1]);
+		//draw.drawLine(x, y, x, y);
+		//ewe.sys.Vm.debug("showlastaddedpoint, x: "+x+"   y: "+y+"loc.x: "+location.x+"  loc.y:"+location.y);
+		draw.fillRect(x-1, y-1, 3, 3);
+		//drawMask.fillRect(x-1, y-1, 3, 3);
+		/*	if (image.bufferedImage != null) { // funktioniert gut, allerdings nur in der java-VM wenn ewe.fx.Image.bufferedImage als public definiert
+			int yd;
+			for  (int xd=-1; xd<=1; xd++) {
+				for (yd=-1; yd<=1; yd++) {
+					((BufferedImage)image.bufferedImage).setRGB(x+xd, y+yd, -65536);
+				}
+			} */
+		if (imageChangesDontShow) {
+			try {addPixelIfNeccessary(x, y, f); }
+			catch (IndexOutOfBoundsException e) // thrown when there are more than pixels stored than possible
+			{ fixate();  }
+		}
+		return true;
+	}
+
+	/**
+	 * this method forces ewe to transfer the drawn points
+	 * from _awtImage to bufferedImage, which is drawn to the screen
+	 *
+	 */
+	private void fixate() {
+		if (numPixels == 0) return;
+		//	draw.drawImage(image,null,Color.DarkBlue,0,0,location.width,location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+		draw.drawImage(image, null, Color.Pink, 0, 0, 1, 1); // width and height is anyway ignored, evtl. testen,  
+		imageChangesDontShow = false;
+		removeAllPixels();
+	}
+
+	private void removeAllPixels() {
+		numPixels = 0;
+		trackPixels = null;
+		trackPixelsColor = null;
+	}
+
+	public Point calcXYinImage (TrackPoint p) {
+		double b[] = new double[2]; // see method paintPoint it should actually call this method but it doesn't because of speed raesons
+		int x, y;
+		b[0] = p.latDec - topLeft.latDec;
+		b[1] = p.lonDec - topLeft.lonDec;
+		x=(int) (trans.transLatX* b[0] + trans.transLonX*b[1]);
+		y=(int) (trans.transLatY* b[0] + trans.transLonY*b[1]);
+		return new Point(x,y);
+	}
+
+	public TrackPoint calcLatLonInImage (double x, double y) {
+		// see trans.calcLatLon(p);
+		TrackPoint ll = new TrackPoint(); 
+		ll.latDec = (double)x * trans.affine[0] + (double)y * trans.affine[2] + topLeft.latDec;
+		ll.lonDec = (double)x * trans.affine[1] + (double)y * trans.affine[3] + topLeft.lonDec;
+		return ll;
+	}
+
+	public void addPixel(int x, int y, Color f) throws IndexOutOfBoundsException {
+		if (trackPixels==null) { trackPixels = new Point[maxPixelsInCache]; trackPixelsColor = new Color[maxPixelsInCache]; } 
+		trackPixels[numPixels] = new Point(x, y); // IndexOutOfBoundsException is handled in PaintPoint
+		trackPixelsColor[numPixels] = f.getCopy();
+		numPixels++;
+	}
+
+	public void addPixelIfNeccessary(int x, int y, Color f){
+		if (trackPixels != null) {
+			int ll =(numPixels<30 ? 0 : numPixels-30); // look in the last 50 added Pixels if the same Pixel is already in the list (for performance reasons dont look in the whole list)
+			for (int i=numPixels-1; i>=ll; i--) {
+				if (trackPixels[i].x == x && trackPixels[i].y == y && f.equals(trackPixelsColor[i])) 
+				{ return; } 
+			}
+		}
+		addPixel(x, y, f);
+	}
+
+	public static final int FIXATE_IF_NO_PIXELS_NUM = 60;
+	private int notOnThisOverlaySince = 0;
+
+	public void paintLastAddedPoint(Track tr) { 
+		//draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
+		draw.setColor(tr.trackColor);
+		if (paintPoint(tr.trackColor, tr.TrackPoints[tr.num-1].latDec, tr.TrackPoints[tr.num-1].lonDec)) notOnThisOverlaySince = 0;
+		else notOnThisOverlaySince++;
+		if (notOnThisOverlaySince > FIXATE_IF_NO_PIXELS_NUM) { // zur Performanceverbesserung: wenn in den letzten 60 Updates keines mehr f?r dieses Overlay dabei war, Overlay Pixels fest schreiben, damit doDraw entlastet wird.
+			fixate();
+			notOnThisOverlaySince = 0;
+		}
+
+	}
+
+	public void doDraw(Graphics g,int options) { // this is automatically called when the image need to be (re-)drawn on the screen
+		super.doDraw(g, options);
+		imageChangesDontShow = true; // g.drawImage (in super) copies _awtImage into bufferedImage, any later changes to _awtImage dont show up until the mask or the image has changed - unfortunately bufferedImage is not accessable from outside
+		// draw trackpoints which were added after image changes don't show up on the screen
+		if (tracks == null || tracks.size() == 0) return;
+		int i;
+		for (i=0; i<numPixels; i++) {
+			g.setColor(trackPixelsColor[i]);
+			g.fillRect(trackPixels[i].x-1, trackPixels[i].y-1, 3, 3);
+		}
+		//g.drawText(Convert.toString(test), 10, 10);
+		//g.drawRect(10 + test, 10, 10, 10);
+		//test++;
+	}
+}
+
+
+/* draw zeichnet auf _awtImage
+ * image.drawImage erzeugt bufferedImage, wenn es vorher null war 
+ * und kopiert den entsprechenden Teil in das ?bergebene Surface
+ * Das Problem ist, dass bufferedImage nicht mehr upgedatet wird, wenn
+ * es einmal erzugt wurde. Es wird nur dann upgedatet, wenn das Image ein anderes wird
+ * oder die Maske eine andere. Das Update erfolgt dann ?ber doDraw, was doCheckMask aufruft,
+ * das das eigentliche kopieren aus _awtImage vornimmt.
+ * 
+ *  Problem: das kopieren von _awtImage in BufferedImage ist sehr zeitaufw?ndig, weil
+ *  es keine native Routine ist und jedes Pixel einzeln gepr?ft wird.
+ *  Deswegen w?re die beste L?sung, wenn ich bufferedImage direkt updaten k?nnte.
+ *  Aber bufferedImage ist privat, ich kann auch in abgeleiteten Klassen nicht drauf
+ *  zugreifen. 
+ *  
+ *  Zur Not w?re auch denkbar, doDraw zu ?berschreiben, um bei jedem Aufruf alle 
+ *  Trackpoints neu zu zeichnen.
+ *  Work-Aorund: draw.drawImage(image,null,Color.Pink,0,0,1,1); bewirkt, dass awtImage ins
+ *  bufferedImage kopiert wird. Dabei wird die transparentColor (in mImage) nicht ge?ndert
+ *  und beim Aufruf von doDraw wird wieder die urspr?ngliche transparentColor verwendet
+ *  
+ */
+//was alles nicht funktioniert:
+//drawmask.setDrawOp(Graphics.DRAW_OVER);
+//drawmask.drawRect(x-1, y-1, 2, 2, 1);
+//this.setImage(image, mask);
+//n?chster Versuch: image.bufferedImage in ewe.fx.Image public definieren !!!
+//image.rgb
+//draw._g.surfaceData.bufImg.raster.data[y*this.location.width + x] = -65536; := image._awtImage
+//((Image)image).eImage(colorOrMask)._awtImage.raster.data[0]=0;
+//image
+//((BufferedImage)(image).se.^.bufferedImage.raster.data[y*this.location.width + x]=-65536; //was dort steht wird tats?chlich angezeigt, allerdings kann ich es nicht direkt setzen :-(
+//int[] markPixels = new int[4];
+//for (int i = 0; i<markPixels.length; i++) { markPixels[i] = -65536; }
+//image.transparent = null; hilft auhc nicht
+//image.mask = null;
+//image.bufferedImage = null;
+//image.setPixels(markPixels, 0 , x-20, y, 2, 2, 0); // dadrin sollte bufferedImage = null gesetzt werden, wird es aber nicht :-(
+//ewe.fx.mImage mark = new mImage();
+//Image mark = new Image(2,2);
+//new Graphics(mark).drawImage(image, null, transparentColor, x-40, y, 2, 2);
+//mark.draw(draw, x-50, y, Graphics.DRAW_OVER); // options (Graphics.DRAW_OVER) are ignored anyway
+//image.bufferedImage = null; // this solves the problem
+//toCursor(null);
+//this.draw(draw);
+//image=(BufferedImage)this.toNativeImage(transparentColor);
+//(java.awt.Image.b)
+//image.bufferedImage=null;
+//draw.flush();
+//ewe.ui.PenEvent.refreshTip(draw.surface);
+//draw.setPixelRGB(x, y, -65536);
+//this.changed(); hilft auch nicht
+//this.refresh(); // hilft nicht :-(
+//lastDrawn.x = lastDrawn.x -10; hilft auch nicht
+//imageMayChange = true; // hilft auch nicht :-(
+
+/*
+ * In der ewe-VM f?r PocketPC-ARM funktioniert die Festlegung einer 
+ * transparenten Farbe nicht (Hintergrund wird wei? statt durchsichtig)
+ * deswegen (und weil in ewe-VM effizienter) Umstellung auf Transparenzmaske
+ * statt transparenter Farbe
+ * TODO Dies ist in Java-VM allerdings extrem Speicher fressend -> evtl abfragen 
+static int fixMask(WObject image,WObject col,int isMask):
+	in Maske: 0 an durchsichtiger Stelle, sonst ff
+	in Image: ffffff an durchsichtiger Stelle
+
+	in java-VM
+	in Maske: ffffffff in image.mask, wenn nicht durchsichtig
+	          ff000000 an durchsichtiger Stelle
+	image.doCheckMask erzeugt ein Image mit 0 an den durchsichtigen Stellen, die dadurch definiert sind, dass im image 0xffffff und in (mask & 0xffffff == 0) steht.
+ */
+/*
+ * this class is only needed to have a fast access to the list of pixels
+ * which are added but aniimage.draw will not lead to a change on the screen
+ * so that these pixels will be drawn seperately by doDraw
+ * 
+ */

Added: trunk/src/CacheWolf/navi/TrackPoint.java
===================================================================
--- trunk/src/CacheWolf/navi/TrackPoint.java	2007-09-05 02:11:26 UTC (rev 883)
+++ trunk/src/CacheWolf/navi/TrackPoint.java	2007-09-05 13:31:24 UTC (rev 884)
@@ -0,0 +1,38 @@
+package CacheWolf.navi;
+
+import ewe.io.BufferedWriter;
+import ewe.io.FileWriter;
+import ewe.io.IOException;
+import ewe.io.PrintWriter;
+import ewe.ui.MessageBox;
+import ewe.util.Utils;
+
+/**
+ * this is not CWPoint because it should be as small as possible
+ * @author pfeffer
+ *
+ */
+
+public class TrackPoint  {
+	public double latDec;
+	public double lonDec;
+	
+	public TrackPoint(){
+		latDec = -91;
+		lonDec = -361;
+	}
+	
+	public TrackPoint(TrackPoint t) {
+		latDec = t.latDec;
+		lonDec = t.lonDec;
+	}
+	public TrackPoint(double lat, double lon) {
+		latDec = lat;
+		lonDec = lon;
+	}
+	public boolean equals(TrackPoint tp) {
+		return latDec == tp.latDec && lonDec == tp.lonDec;
+	}
+
+}
+



From mik77 at mail.berlios.de  Wed Sep  5 19:32:55 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Wed, 5 Sep 2007 19:32:55 +0200
Subject: [Cachewolf-svn] r885 - trunk/src/CacheWolf
Message-ID: <200709051732.l85HWtnL003537@sheep.berlios.de>

Author: mik77
Date: 2007-09-05 19:32:49 +0200 (Wed, 05 Sep 2007)
New Revision: 885

Added:
   trunk/src/CacheWolf/map/
Log:
directory with correct history restored

Copied: trunk/src/CacheWolf/map (from rev 882, trunk/src/CacheWolf/map)



From mik77 at mail.berlios.de  Wed Sep  5 19:43:39 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Wed, 5 Sep 2007 19:43:39 +0200
Subject: [Cachewolf-svn] r886 - trunk/src/CacheWolf
Message-ID: <200709051743.l85Hhd3S004149@sheep.berlios.de>

Author: mik77
Date: 2007-09-05 19:43:37 +0200 (Wed, 05 Sep 2007)
New Revision: 886

Removed:
   trunk/src/CacheWolf/navi/
Log:
delete directory without history



From mik77 at mail.berlios.de  Wed Sep  5 19:46:58 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Wed, 5 Sep 2007 19:46:58 +0200
Subject: [Cachewolf-svn] r887 - trunk/src/CacheWolf
Message-ID: <200709051746.l85HkwL6004404@sheep.berlios.de>

Author: mik77
Date: 2007-09-05 19:46:54 +0200 (Wed, 05 Sep 2007)
New Revision: 887

Added:
   trunk/src/CacheWolf/navi/
Removed:
   trunk/src/CacheWolf/map/
Log:
correct directory name with correctly versioned content

Copied: trunk/src/CacheWolf/navi (from rev 885, trunk/src/CacheWolf/map)



From mik77 at mail.berlios.de  Wed Sep  5 20:14:53 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Wed, 5 Sep 2007 20:14:53 +0200
Subject: [Cachewolf-svn] r888 - trunk/src/CacheWolf
Message-ID: <200709051814.l85IErln005910@sheep.berlios.de>

Author: mik77
Date: 2007-09-05 20:14:40 +0200 (Wed, 05 Sep 2007)
New Revision: 888

Modified:
   trunk/src/CacheWolf/CalcPanel.java
   trunk/src/CacheWolf/DateTimeChooser.java
   trunk/src/CacheWolf/ProfilesForm.java
   trunk/src/CacheWolf/RadarPanel.java
   trunk/src/CacheWolf/TravelbugJourneyScreen.java
   trunk/src/CacheWolf/myTableModel.java
Log:
removed some warnings (still some todo)

Modified: trunk/src/CacheWolf/CalcPanel.java
===================================================================
--- trunk/src/CacheWolf/CalcPanel.java	2007-09-05 17:46:54 UTC (rev 887)
+++ trunk/src/CacheWolf/CalcPanel.java	2007-09-05 18:14:40 UTC (rev 888)
@@ -84,7 +84,7 @@
 			inpBearing.setPreferredSize(fm.getTextWidth("99999999"),fm.getHeight()*4/3);
 			inpDistance.setPreferredSize(fm.getTextWidth("99999999"),fm.getHeight()*4/3);
 		}
-		BottomP.addLast(chcDistUnit = new mChoice(new String[]{"m", "km"},0),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST)).setTag(this.INSETS,new ewe.fx.Insets(0,2,0,0));
+		BottomP.addLast(chcDistUnit = new mChoice(new String[]{"m", "km"},0),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST)).setTag(CellConstants.INSETS,new ewe.fx.Insets(0,2,0,0));
 		chcDistUnit.setInt(0);
 		
 		// Buttons for calc and save

Modified: trunk/src/CacheWolf/DateTimeChooser.java
===================================================================
--- trunk/src/CacheWolf/DateTimeChooser.java	2007-09-05 17:46:54 UTC (rev 887)
+++ trunk/src/CacheWolf/DateTimeChooser.java	2007-09-05 18:14:40 UTC (rev 888)
@@ -153,7 +153,7 @@
 			}else if (ev.target == monthChooser){
 				month = (int)((ewe.sys.Long)(((TableEvent)ev).cellData)).value;
 				newDate();
-				monthName = locale.getString(locale.SHORT_MONTH,month,0);
+				monthName = locale.getString(Locale.SHORT_MONTH,month,0);
 				toControls("monthName");
 				if (autoAdvance && !didAll) {
 					panels.select("year");
@@ -189,7 +189,7 @@
 				toControls("time");
 			}
 		}
-		if (ev.type == ev.CANCELLED) exit(IDCANCEL);
+		if (ev.type == ControlEvent.CANCELLED) exit(IDCANCEL);
 		else super.onControlEvent(ev);
 	}
 	
@@ -201,7 +201,7 @@
 		String s = Time.toString(t,t instanceof TimeOfDay ? t.getFormat() : locale.getString(Locale.SHORT_DATE_FORMAT,0,0),locale);
 		day = t.day; month = t.month; year = t.year; hour=t.hour; minute=t.minute;
 		time=MyLocale.formatLong(hour,"00")+":"+MyLocale.formatLong(minute,"00");
-		monthName = locale.getString(locale.SHORT_MONTH,t.month,0);
+		monthName = locale.getString(Locale.SHORT_MONTH,t.month,0);
 		toControls("day,month,year,monthName,time"); 
 	}
 	
@@ -267,7 +267,7 @@
 	public TableCellAttributes getCellAttributes(int row,int col,boolean isSelected,TableCellAttributes ta) {
 		ta.flat = true;
 		ta = super.getCellAttributes(row,col,isSelected,ta);
-		ta.borderStyle = fixBorder(table.BDR_OUTLINE|table.BF_BOTTOM|table.BF_RIGHT,row,col,true);
+		ta.borderStyle = fixBorder(UIConstants.BDR_OUTLINE|UIConstants.BF_BOTTOM|UIConstants.BF_RIGHT,row,col,true);
 		if (getMonthFor(row,col) == chosenMonth && !isSelected){
 			ta.fillColor = new Color(0x80,0x80,0xff);
 		}
@@ -275,7 +275,7 @@
 	}
 
 	public Object getCellText(int row,int col) {
-		return locale.getString(locale.SHORT_MONTH,getMonthFor(row,col),0);
+		return locale.getString(Locale.SHORT_MONTH,getMonthFor(row,col),0);
 	}
 
 	public Object getCellData(int row,int col) {
@@ -300,7 +300,7 @@
 		//ewe.sys.Vm.debug(month+","+year);
 		numDays = Time.numberOfDays(month,year);
 		Time t = new Time(1,month,year);
-		firstDayIndex = t.indexOfDayInWeek(t.dayOfWeek,locale)-1;
+		firstDayIndex = Time.indexOfDayInWeek(t.dayOfWeek,locale)-1;
 		//ewe.sys.Vm.debug(""+firstDayIndex+", "+numDays);
 		int oldDay = chosenDay;
 		chosenDay = day;
@@ -331,7 +331,7 @@
 	public TableCellAttributes getCellAttributes(int row,int col,boolean isSelected,TableCellAttributes ta) {
 		ta.flat = true;
 		ta = super.getCellAttributes(row,col,isSelected,ta);
-		ta.borderStyle = fixBorder(table.BDR_OUTLINE|table.BF_BOTTOM|table.BF_RIGHT,row,col,true);
+		ta.borderStyle = fixBorder(UIConstants.BDR_OUTLINE|UIConstants.BF_BOTTOM|UIConstants.BF_RIGHT,row,col,true);
 		if (getDayFor(row,col) == chosenDay && !isSelected){
 			ta.fillColor = new Color(0x80,0x80,0xff);
 		}
@@ -344,7 +344,7 @@
 		numCols = 7;
 		hasColumnHeaders = true;
 		hasRowHeaders = false;
-		for (int i = 1; i<=7; i++) days.add(l.getString(l.SHORT_DAY_OF_WEEK,i,0));
+		for (int i = 1; i<=7; i++) days.add(l.getString(Locale.SHORT_DAY_OF_WEEK,i,0));
 	
 		fillToEqualHeights = fillToEqualWidths = true;
 	}

Modified: trunk/src/CacheWolf/ProfilesForm.java
===================================================================
--- trunk/src/CacheWolf/ProfilesForm.java	2007-09-05 17:46:54 UTC (rev 887)
+++ trunk/src/CacheWolf/ProfilesForm.java	2007-09-05 18:14:40 UTC (rev 888)
@@ -61,7 +61,7 @@
 		int w=MyLocale.getScreenWidth();
 		if (w>240) w=240;
 		setPreferredSize(w,240);
-	    defaultTags.set(this.INSETS,new Insets(2,2,2,2));		
+	    defaultTags.set(CellConstants.INSETS,new Insets(2,2,2,2));		
 		title = MyLocale.getMsg(1301,"Select Profile:");
 		if (hasNewButton) {
 			addNext(new mLabel(MyLocale.getMsg(1106,"Choose profile or New")),DONTSTRETCH,DONTSTRETCH|LEFT);

Modified: trunk/src/CacheWolf/RadarPanel.java
===================================================================
--- trunk/src/CacheWolf/RadarPanel.java	2007-09-05 17:46:54 UTC (rev 887)
+++ trunk/src/CacheWolf/RadarPanel.java	2007-09-05 18:14:40 UTC (rev 888)
@@ -34,12 +34,12 @@
 	* "navigation" buttons.
 	*/
 	public RadarPanel(){
-		this.addLast(iActP = new myInteractivePanel(), this.STRETCH, this.FILL);
+		this.addLast(iActP = new myInteractivePanel(), CellConstants.STRETCH, CellConstants.FILL);
 		CellPanel cp = new CellPanel();
-		cp.addNext(btMinus,this.DONTSTRETCH, (this.DONTFILL|this.WEST));
-		cp.addNext(btToggle,this.HSTRETCH, this.FILL);
-		cp.addLast(btPlus,this.DONTSTRETCH, (this.DONTFILL|this.EAST));
-		this.addLast(cp, this.HSTRETCH, this.FILL);
+		cp.addNext(btMinus,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		cp.addNext(btToggle,CellConstants.HSTRETCH, CellConstants.FILL);
+		cp.addLast(btPlus,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.EAST));
+		this.addLast(cp, CellConstants.HSTRETCH, CellConstants.FILL);
 	}
 	
 	public void setMainTab(MainTab tb){

Modified: trunk/src/CacheWolf/TravelbugJourneyScreen.java
===================================================================
--- trunk/src/CacheWolf/TravelbugJourneyScreen.java	2007-09-05 17:46:54 UTC (rev 887)
+++ trunk/src/CacheWolf/TravelbugJourneyScreen.java	2007-09-05 18:14:40 UTC (rev 888)
@@ -322,8 +322,8 @@
 	
 	public TableCellAttributes getCellAttributes(int row,int col,boolean isSelected,TableCellAttributes ta) {
 		ta=super.getCellAttributes(row,col,isSelected,ta);
-		ta.alignment = ta.LEFT;
-		ta.anchor = ta.LEFT;
+		ta.alignment = CellConstants.LEFT;
+		ta.anchor = CellConstants.LEFT;
 		// Color the elements red, if we have not yet logged
 		if (row>=0)
 		switch (columnMap[col]) {

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-09-05 17:46:54 UTC (rev 887)
+++ trunk/src/CacheWolf/myTableModel.java	2007-09-05 18:14:40 UTC (rev 888)
@@ -181,8 +181,8 @@
 	*/
 	public TableCellAttributes getCellAttributes(int row,int col,boolean  isSelected, TableCellAttributes ta){
 		ta = super.getCellAttributes(row, col, isSelected, ta);
-		ta.alignment = ta.LEFT;
-		ta.anchor = ta.LEFT;
+		ta.alignment = CellConstants.LEFT;
+		ta.anchor = CellConstants.LEFT;
 		if(row >= 0){ 
 			try {
 			   CacheHolder ch = (CacheHolder)cacheDB.get(row);



From mik77 at mail.berlios.de  Wed Sep  5 21:02:02 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Wed, 5 Sep 2007 21:02:02 +0200
Subject: [Cachewolf-svn] r889 - trunk/src/CacheWolf
Message-ID: <200709051902.l85J22Pf008452@sheep.berlios.de>

Author: mik77
Date: 2007-09-05 21:01:55 +0200 (Wed, 05 Sep 2007)
New Revision: 889

Modified:
   trunk/src/CacheWolf/RadarPanel.java
Log:
Buttons made same size to avoid SIP-Button problems.

Modified: trunk/src/CacheWolf/RadarPanel.java
===================================================================
--- trunk/src/CacheWolf/RadarPanel.java	2007-09-05 18:14:40 UTC (rev 888)
+++ trunk/src/CacheWolf/RadarPanel.java	2007-09-05 19:01:55 UTC (rev 889)
@@ -36,9 +36,9 @@
 	public RadarPanel(){
 		this.addLast(iActP = new myInteractivePanel(), CellConstants.STRETCH, CellConstants.FILL);
 		CellPanel cp = new CellPanel();
-		cp.addNext(btMinus,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		cp.addNext(btMinus,CellConstants.HSTRETCH, (CellConstants.FILL|CellConstants.WEST));
 		cp.addNext(btToggle,CellConstants.HSTRETCH, CellConstants.FILL);
-		cp.addLast(btPlus,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.EAST));
+		cp.addLast(btPlus,CellConstants.HSTRETCH, (CellConstants.FILL|CellConstants.EAST));
 		this.addLast(cp, CellConstants.HSTRETCH, CellConstants.FILL);
 	}
 	



From mik77 at mail.berlios.de  Wed Sep  5 21:09:51 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Wed, 5 Sep 2007 21:09:51 +0200
Subject: [Cachewolf-svn] r890 - trunk/src/CacheWolf
Message-ID: <200709051909.l85J9p7J009134@sheep.berlios.de>

Author: mik77
Date: 2007-09-05 21:09:45 +0200 (Wed, 05 Sep 2007)
New Revision: 890

Modified:
   trunk/src/CacheWolf/HintLogPanel.java
Log:
Hints are now under the logs as workaround for SIP-Button problems. (Better idea: show decoded Hint in message-box on Button in DescriptionPanel)

Modified: trunk/src/CacheWolf/HintLogPanel.java
===================================================================
--- trunk/src/CacheWolf/HintLogPanel.java	2007-09-05 19:01:55 UTC (rev 889)
+++ trunk/src/CacheWolf/HintLogPanel.java	2007-09-05 19:09:45 UTC (rev 890)
@@ -35,8 +35,8 @@
 	mButton prevBt = new mButton("<<");
 	public HintLogPanel(){
 		SplittablePanel split = new SplittablePanel(PanelSplitter.VERTICAL);
+		CellPanel logpane = split.getNextPanel();
 		CellPanel hintpane = split.getNextPanel();
-		CellPanel logpane = split.getNextPanel();
 		split.setSplitter(PanelSplitter.AFTER|PanelSplitter.HIDDEN,PanelSplitter.BEFORE|PanelSplitter.HIDDEN,0);
 		int initialHintHeight=Global.getPref().initialHintHeight;
 		if (initialHintHeight<0 || initialHintHeight>1000) initialHintHeight=Global.getPref().DEFAULT_INITIAL_HINT_HEIGHT;



From bilbowolf at mail.berlios.de  Wed Sep  5 22:59:20 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Wed, 5 Sep 2007 22:59:20 +0200
Subject: [Cachewolf-svn] r891 - in trunk: docs src/CacheWolf src/utils
Message-ID: <200709052059.l85KxK0o016396@sheep.berlios.de>

Author: bilbowolf
Date: 2007-09-05 22:42:56 +0200 (Wed, 05 Sep 2007)
New Revision: 891

Added:
   trunk/docs/XMLmind_XML_Editor.zip
Modified:
   trunk/src/CacheWolf/Version.java
   trunk/src/utils/FileBugfix.java
Log:
XMLMind ist ein editor f?r docbook. Was man mit docbook machen kann,
siehe die Datei "Dokumentationen mit DocBook-XML.htm".

Ich m?chte die Dokumentation f?r CW offline nehmen und in dem docbook
Format umwandeln. Es ist doch im wiki etwas m?hsam die komplette
doku zu machen. docbook erlaubt eine einfache umwandlung in pdf, html,
etc.


Added: trunk/docs/XMLmind_XML_Editor.zip
===================================================================
(Binary files differ)


Property changes on: trunk/docs/XMLmind_XML_Editor.zip
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/src/CacheWolf/Version.java
===================================================================
--- trunk/src/CacheWolf/Version.java	2007-09-05 19:09:45 UTC (rev 890)
+++ trunk/src/CacheWolf/Version.java	2007-09-05 20:42:56 UTC (rev 891)
@@ -10,7 +10,7 @@
 	static final String VER_MAJOR = "BE";
 	static final String VER_MINOR = "";
 	static final String VER_BUILD = " ";
-	static final String VER_SVN ="$LastChangedRevision$"; // the number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
+	static final String VER_SVN ="$LastChangedRevision$"; //the number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
 	
 	/**
 	 * @return

Modified: trunk/src/utils/FileBugfix.java
===================================================================
--- trunk/src/utils/FileBugfix.java	2007-09-05 19:09:45 UTC (rev 890)
+++ trunk/src/utils/FileBugfix.java	2007-09-05 20:42:56 UTC (rev 891)
@@ -6,7 +6,7 @@
 import ewe.io.*;
 import ewe.util.FileComparer;
 import ewe.util.mString;
-
+import CacheWolf.*;
 /**
  * @author pfeffer
  * class to fix a bug in ewe.io.File, which occurs only on some systems (e.g. linux): the mask "*.xyz" doesn't work



From salzkammergut at mail.berlios.de  Wed Sep  5 23:02:19 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Wed, 5 Sep 2007 23:02:19 +0200
Subject: [Cachewolf-svn] r892 - trunk/src/CacheWolf
Message-ID: <200709052102.l85L2JsE016587@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-05 23:02:18 +0200 (Wed, 05 Sep 2007)
New Revision: 892

Modified:
   trunk/src/CacheWolf/DetailsPanel.java
Log:
DetailsPanel: Status nach oben gerueckt damit er auch auf kleinen Bildschirmen ohne Scrollen sichtbar ist. 
Besitzer und Versteckdatum sind ja weniger wichtig.

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-09-05 20:42:56 UTC (rev 891)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-09-05 21:02:18 UTC (rev 892)
@@ -110,23 +110,22 @@
 		this.addNext(new mLabel(MyLocale.getMsg(304,"Location:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		this.addLast(btnWayLoc.setTag(Control.SPAN, new Dimension(2,1)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		
-		this.addNext(new mLabel(MyLocale.getMsg(305,"Hidden on:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		this.addNext(new mLabel(MyLocale.getMsg(307,"Status:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		CellPanel cp=new CellPanel();
+		cp.addNext(chcStatus,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		cp.addLast(btnFoundDate=new mButton(new mImage("calendar.png")),DONTSTRETCH,DONTFILL);
+		this.addLast(cp,DONTSTRETCH,HFILL).setTag(Control.SPAN, new Dimension(2,1));
 		
+		this.addNext(new mLabel(MyLocale.getMsg(306,"Owner:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		this.addLast(inpOwner.setTag(Control.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		
+		this.addNext(new mLabel(MyLocale.getMsg(305,"Hidden on:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		CellPanel ip=new CellPanel();
 		ip.addNext(inpHidden,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		ip.addLast(btnHiddenDate=new mButton(new mImage("calendar.png")),DONTSTRETCH,DONTFILL);
 		this.addLast(ip,DONTSTRETCH,HFILL).setTag(Control.SPAN, new Dimension(2,1));
 		inpHidden.modifyAll(DisplayOnly,0);
 		
-		this.addNext(new mLabel(MyLocale.getMsg(306,"Owner:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		this.addLast(inpOwner.setTag(Control.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		
-		this.addNext(new mLabel(MyLocale.getMsg(307,"Status:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		CellPanel cp=new CellPanel();
-		cp.addNext(chcStatus,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		cp.addLast(btnFoundDate=new mButton(new mImage("calendar.png")),DONTSTRETCH,DONTFILL);
-		this.addLast(cp,DONTSTRETCH,HFILL).setTag(Control.SPAN, new Dimension(2,1));
-		
 		//btnNotes = new mButton("Notes");
 		//this.addLast(btnNotes.setTag(Control.SPAN, new Dimension(3,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		//this.addNext(new mLabel(MyLocale.getMsg(308,"Notes:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));



From mik77 at mail.berlios.de  Wed Sep  5 23:13:55 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Wed, 5 Sep 2007 23:13:55 +0200
Subject: [Cachewolf-svn] r893 - trunk/src/CacheWolf
Message-ID: <200709052113.l85LDtAa016977@sheep.berlios.de>

Author: mik77
Date: 2007-09-05 23:13:53 +0200 (Wed, 05 Sep 2007)
New Revision: 893

Modified:
   trunk/src/CacheWolf/myTableModel.java
Log:
clear cell adjustments after reading out current real column widths

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-09-05 21:02:18 UTC (rev 892)
+++ trunk/src/CacheWolf/myTableModel.java	2007-09-05 21:13:53 UTC (rev 893)
@@ -127,6 +127,7 @@
 		for (int col=0; col<numCols; col++) {
 			colWidth[colMap[col]]=getColWidth(col);
 		}
+		clearCellAdjustments();
 		// Convert to string
 		StringBuffer sb=new StringBuffer(40);
 		for (int i=0; i<colWidth.length; i++) {



From salzkammergut at mail.berlios.de  Thu Sep  6 00:28:50 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Thu, 6 Sep 2007 00:28:50 +0200
Subject: [Cachewolf-svn] r894 - trunk/src/CacheWolf
Message-ID: <200709052228.l85MSo9U020905@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-06 00:28:47 +0200 (Thu, 06 Sep 2007)
New Revision: 894

Modified:
   trunk/src/CacheWolf/myTableControl.java
Log:
Bugfix: myTableControl. Die Tastenfolge: [rechte Maustaste Cache anklicken] (Liste-Popupmenue oeffnet sich),
[Klick auf Tab Detailpanel] zeigte den falschen Cache an. Ueberzaehligen Table-refresh entfernt. 

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-09-05 21:13:53 UTC (rev 893)
+++ trunk/src/CacheWolf/myTableControl.java	2007-09-05 22:28:47 UTC (rev 894)
@@ -95,10 +95,8 @@
 		Global.getProfile().setSelectForAll(selectStatus);
 		tbp.refreshTable();
 	}
-
 	public void popupMenuEvent(Object selectedItem){
 		CacheHolder ch;
-
 		if (selectedItem.toString().equals(MyLocale.getMsg(1015,"Select all"))){
 			setSelectForAll(true);
 		}
@@ -195,7 +193,7 @@
 			} else {				
 				pref.curCentrePt.set(cp);
 				Global.mainTab.updateBearDist(); // Update the distances with a warning message
-				tbp.refreshTable();
+				//tbp.refreshTable();
 			}
 		}
 
@@ -229,8 +227,24 @@
 	public void penDoubleClicked(Point where) {
 		Global.mainTab.select(Global.mainTab.descP);
 	}
+	
+	int rowRightMouseClick=-1;
 	public void onEvent(Event ev) {
-	    if (ev instanceof PenEvent) Global.mainTab.tbP.myMod.penEventModifiers=((PenEvent)ev).modifiers;
+	    if (ev instanceof PenEvent) {
+			// Ensure that row is selected on right mouse key to show the correct
+	    	// cache details
+	    	if (ev.type==PenEvent.PEN_DOWN && (((PenEvent)ev).modifiers&PenEvent.RIGHT_BUTTON)!=0) { 
+				Point p=cellAtPoint(((PenEvent)ev).x,((PenEvent)ev).y,null);
+				rowRightMouseClick=p.y;
+				// The selection of the row on right mouse click ist delayed
+				// until the menu has been drawn to speed up the refreshing of the screen
+			}
+			Global.mainTab.tbP.myMod.penEventModifiers=((PenEvent)ev).modifiers;
+	    }
+	    if (ev instanceof ControlEvent && ev.type==ControlEvent.POPUP_CLOSED) {
+			// Delayed switch to new row on right mouse click when pop-up menu has been opened
+			Global.mainTab.tbP.selectRow(rowRightMouseClick);
+	    }
 		super.onEvent(ev);
 	}
     ///////////////////////////////////////////////////



From salzkammergut at mail.berlios.de  Thu Sep  6 21:27:00 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Thu, 6 Sep 2007 21:27:00 +0200
Subject: [Cachewolf-svn] r895 - trunk/src/CacheWolf
Message-ID: <200709061927.l86JR0fv023061@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-06 21:26:54 +0200 (Thu, 06 Sep 2007)
New Revision: 895

Modified:
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/SpiderGC.java
   trunk/src/CacheWolf/myTableControl.java
Log:
SpiderGC: Feature: Im Importmenue kann festgelegt werden ob man sich bei GC jedes mal neu einloggen muss, 
oder ob der letzte Login weiter verwendet werden soll.

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-09-05 22:28:47 UTC (rev 894)
+++ trunk/src/CacheWolf/MainMenu.java	2007-09-06 19:26:54 UTC (rev 895)
@@ -32,7 +32,7 @@
 	private MenuItem filtCreate, filtClear, filtInvert, filtSelected, filtBlack, filtApply;
 	private MenuItem exportGPS, exportCacheMate,mnuSeparator;
 	private MenuItem orgCopy, orgMove, orgDelete;
-	public MenuItem filtCacheTour,orgTravelbugs;
+	public MenuItem filtCacheTour,orgTravelbugs, mnuForceLogin;
 	private MenuItem mnuNewProfile, mnuOpenProfile, mnuEditCenter;
 	private Form father;
 	private TablePanel tbp;
@@ -53,11 +53,14 @@
 		///////////////////////////////////////////////////////////////////////
 		// subMenu for import, part of "Application" menu below
 		///////////////////////////////////////////////////////////////////////
-		MenuItem[] mnuImport = new MenuItem[3];
+		MenuItem[] mnuImport = new MenuItem[5];
 		mnuImport[0] = loadcaches  = new MenuItem(MyLocale.getMsg(129,"Import GPX")); //TODO internationalization
 		mnuImport[1] = loadOC      = new MenuItem(MyLocale.getMsg(130,"Download von opencaching.de")); 
 		mnuImport[2] = spider      = new MenuItem(MyLocale.getMsg(131,"Spider von geocaching.com")); 
+		mnuImport[3] = mnuSeparator = new MenuItem("-"); 
+		mnuImport[4] = mnuForceLogin      = new MenuItem("Always login to GC"); 
 		Menu importMenu = new Menu(mnuImport, MyLocale.getMsg(175,"Import"));
+		if (Global.getPref().forceLogin) mnuForceLogin.modifiers^=MenuItem.Checked;
 		
 		///////////////////////////////////////////////////////////////////////
 		// subMenu for export, part of "Application" menu below
@@ -97,7 +100,7 @@
 		appMenuItems[0] = profiles 	 = new MenuItem(MyLocale.getMsg(121,"Profile"), 0, profileMenu); 
 		appMenuItems[1] = preferences = new MenuItem(MyLocale.getMsg(108,"Preferences")); 
 		appMenuItems[2] = mnuEditCenter = new MenuItem(MyLocale.getMsg(1110,"Center"));
-		appMenuItems[3] = mnuSeparator = new MenuItem("-");
+		appMenuItems[3] = mnuSeparator;
 		appMenuItems[4] = new MenuItem(MyLocale.getMsg(175,"Import"),0,importMenu);
 		appMenuItems[5] = new MenuItem(MyLocale.getMsg(107,"Export"),0,exportMenu);
 		appMenuItems[6] = new MenuItem(MyLocale.getMsg(149,"Maps"),0,mapsMenu);
@@ -191,6 +194,10 @@
 			mnuOpenProfile.modifiers|=MenuItem.Disabled;
 		}
 	}
+	
+	public void setForceLogin() {
+		mnuForceLogin.modifiers=Global.getPref().forceLogin ? Global.mainTab.mnuMain.modifiers|MenuItem.Checked : Global.mainTab.mnuMain.modifiers&~MenuItem.Checked;
+	}
 
 	public static void search() {
 		String srch = new InputBox(MyLocale.getMsg(119,"Search for:")).input("",10);
@@ -253,6 +260,62 @@
 				f.close(0);
 			}
 			///////////////////////////////////////////////////////////////////////
+			// subMenu for import, part of "Application" menu 
+			///////////////////////////////////////////////////////////////////////
+			if(mev.selectedItem == spider){
+				SpiderGC spGC = new SpiderGC(pref, profile, true);
+				spGC.doIt();
+				cacheDB.clear();
+				profile.readIndex();
+				profile.restoreFilter();
+				profile.updateBearingDistance();
+				tbp.resetModel();
+			}
+			if(mev.selectedItem == loadcaches){
+				FileChooser fc = new FileChooser(FileChooser.OPEN|FileChooser.MULTI_SELECT, pref.baseDir);
+				fc.addMask("*.gpx,*.zip,*.loc");
+				fc.setTitle(MyLocale.getMsg(909,"Select file(s)"));
+				if(fc.execute() != FileChooser.IDCANCEL){
+					String dir = fc.getChosenDirectory().toString();
+					String files[] = fc.getAllChosen();
+					/*
+					int how = GPXImporter.DOIT_ASK;
+					if (files.length > 0){
+							InfoBox iB = new InfoBox("Spider?", "Spider Images?", InfoBox.CHECKBOX);
+							iB.execute();
+							boolean doSpider = iB.mCB_state;
+							if (doSpider) how = GPXImporter.DOIT_WITHSPOILER;
+							else how = GPXImporter.DOIT_NOSPOILER;
+					}
+					*/
+					for (int i = 0; i < files.length; i++){ 
+						String file = dir + "/" + files[i];
+						if (file.endsWith("loc")){
+							LOCXMLImporter loc = new LOCXMLImporter(pref, profile, file);
+							loc.doIt();
+						}
+						else {
+							GPXImporter gpx = new GPXImporter(pref, profile, file);
+							gpx.doIt(0);
+						}
+					}
+				}
+				Filter.showBlacklisted=false;
+				filtBlack.modifiers&=~MenuItem.Checked;
+				tbp.resetModel();
+			}
+			if(mev.selectedItem == loadOC){
+				OCXMLImporter oc = new OCXMLImporter(pref,profile);
+				oc.doIt();
+				Filter.showBlacklisted=false;
+				filtBlack.modifiers&=~MenuItem.Checked;
+				tbp.resetModel();
+			}
+			if(mev.selectedItem == mnuForceLogin) {
+				mnuForceLogin.modifiers^=MenuItem.Checked;
+				Global.getPref().forceLogin=(mnuForceLogin.modifiers&MenuItem.Checked)!=0;
+			}
+			///////////////////////////////////////////////////////////////////////
 			// subMenu for export, part of "Application" menu 
 			///////////////////////////////////////////////////////////////////////
 			if(mev.selectedItem == exporthtml){
@@ -372,55 +435,6 @@
 				pfs.execute(father.getFrame(), Gui.CENTER_FRAME);
 				pref.readPrefFile();
 			}
-			if(mev.selectedItem == loadcaches){
-				FileChooser fc = new FileChooser(FileChooser.OPEN|FileChooser.MULTI_SELECT, pref.baseDir);
-				fc.addMask("*.gpx,*.zip,*.loc");
-				fc.setTitle(MyLocale.getMsg(909,"Select file(s)"));
-				if(fc.execute() != FileChooser.IDCANCEL){
-					String dir = fc.getChosenDirectory().toString();
-					String files[] = fc.getAllChosen();
-					/*
-					int how = GPXImporter.DOIT_ASK;
-					if (files.length > 0){
-							InfoBox iB = new InfoBox("Spider?", "Spider Images?", InfoBox.CHECKBOX);
-							iB.execute();
-							boolean doSpider = iB.mCB_state;
-							if (doSpider) how = GPXImporter.DOIT_WITHSPOILER;
-							else how = GPXImporter.DOIT_NOSPOILER;
-					}
-					*/
-					for (int i = 0; i < files.length; i++){ 
-						String file = dir + "/" + files[i];
-						if (file.endsWith("loc")){
-							LOCXMLImporter loc = new LOCXMLImporter(pref, profile, file);
-							loc.doIt();
-						}
-						else {
-							GPXImporter gpx = new GPXImporter(pref, profile, file);
-							gpx.doIt(0);
-						}
-					}
-				}
-				Filter.showBlacklisted=false;
-				filtBlack.modifiers&=~MenuItem.Checked;
-				tbp.resetModel();
-			}
-			if(mev.selectedItem == loadOC){
-				OCXMLImporter oc = new OCXMLImporter(pref,profile);
-				oc.doIt();
-				Filter.showBlacklisted=false;
-				filtBlack.modifiers&=~MenuItem.Checked;
-				tbp.resetModel();
-			}
-			if(mev.selectedItem == spider){
-				SpiderGC spGC = new SpiderGC(pref, profile, true);
-				spGC.doIt();
-				cacheDB.clear();
-				profile.readIndex();
-				profile.restoreFilter();
-				profile.updateBearingDistance();
-				tbp.resetModel();
-			}
 			if(mev.selectedItem == savenoxit){
 				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
 				tbp.saveColWidth(pref);

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-09-05 22:28:47 UTC (rev 894)
+++ trunk/src/CacheWolf/Preferences.java	2007-09-06 19:26:54 UTC (rev 895)
@@ -81,6 +81,7 @@
 	public String forwardGpsHost = "";
 	public int fontSize = 12;
 	
+	public boolean forceLogin=true;
 	public String listColMap="0,1,2,3,4,5,6,7,8,9,10,11";
 	public String listColWidth="15,20,20,25,92,177,144,83,60,105,50,104";
 	/** The columns which are to be displayed in TravelbugsJourneyScreen. See also TravelbugJourney */
@@ -404,6 +405,9 @@
 		if (name.equals("gotopanel")) {
 			northCenteredGoto = Boolean.valueOf(atts.getValue("northcentered")).booleanValue();
 		}
+		if (name.equals("spider")) {
+			forceLogin = Boolean.valueOf(atts.getValue("forcelogin")).booleanValue();
+		}
 	}
 
 	public void characters( char ch[], int start, int length ) {
@@ -453,6 +457,7 @@
 			outp.print("    <garmin connection = \""+garminConn+"\" GPSBabelOptions = \""+garminGPSBabelOptions+"\" />\n");
 			outp.print("    <opencaching downloadPicsOC=\""+downloadPicsOC+"\" downloadMaps=\""+downloadMapsOC+"\" downloadMissing=\""+downloadmissingOC+"\"/>\n");
 			outp.print("	<location lat = \""+curCentrePt.getLatDeg(CWPoint.DD)+"\" long = \""+curCentrePt.getLonDeg(CWPoint.DD)+"\"/>\n");
+			outp.print("    <spider forcelogin=\""+forceLogin+"\"/>/n");
 			outp.print("    <gotopanel northcentered=\""+northCenteredGoto+"\" />\n");
 			if (customMapsPath!=null) outp.print("	<mapspath dir = \""+ customMapsPath +"\"/>\n");
 			if (debug) outp.print("    <debug value=\"true\" />\n"); // Keep the debug switch if it is set

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-09-05 22:28:47 UTC (rev 894)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-09-06 19:26:54 UTC (rev 895)
@@ -43,6 +43,7 @@
 	 */
 	public static int MAXLOGS=250; // Can be pre-set from preferences
 	public static String passwort = ""; // Can be pre-set from preferences
+	public static boolean loggedIn = false;
 
 	private static int ERR_LOGIN = -10;
 	private static Preferences pref;
@@ -56,7 +57,6 @@
 	private Vector cachesToLoad = new Vector();
 	private Hashtable indexDB;
 	private InfoBox infB;
-	private boolean loggedIn = false;
 	private static myProperties p=null;
 
 	public SpiderGC(Preferences prf, Profile profile, boolean bypass){
@@ -218,8 +218,10 @@
 		String completeWebPage;
 		// Check whether spider definitions could be loaded, if not issue appropriate message and terminate
 		// Try to login. If login fails, issue appropriate message and terminate
-		if (login()!=Form.IDOK) {
-			return "";
+		if (!loggedIn || Global.getPref().forceLogin) {
+			if (login()!=Form.IDOK) {
+				return "";
+			}
 		}
 		InfoBox infB = new InfoBox("Info", "Loading", InfoBox.PROGRESS_WITH_WARNINGS);
 		infB.exec();
@@ -264,9 +266,11 @@
 		String start = "";
 		Regex rex = new Regex("name=\"__VIEWSTATE\" value=\"(.*)\" />");
 		String doc = "";
-
-		if(login() != Form.IDOK) return;
-
+		
+		if (!loggedIn || Global.getPref().forceLogin) {
+			if(login() != Form.IDOK) return;
+		}
+		
 		OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(5510,"Spider Options"),	OCXMLImporterScreen.INCLUDEFOUND | OCXMLImporterScreen.DIST| OCXMLImporterScreen.IMAGES);
 		options.distanceInput.setText("");
 		if (options.execute() == OCXMLImporterScreen.IDCANCEL) {return; }

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-09-05 22:28:47 UTC (rev 894)
+++ trunk/src/CacheWolf/myTableControl.java	2007-09-06 19:26:54 UTC (rev 895)
@@ -134,6 +134,7 @@
 			SpiderGC spider = new SpiderGC(pref, profile, false);
 			OCXMLImporter ocSync = new OCXMLImporter(pref, profile);
 			//Vm.debug("ByPass? " + profile.byPassIndexActive);
+			if (!spider.loggedIn || Global.getPref().forceLogin) spider.login();
 			Vm.showWait(true);
 			boolean alreadySaid = false;
 			boolean alreadySaid2 = false;



From salzkammergut at mail.berlios.de  Thu Sep  6 21:44:15 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Thu, 6 Sep 2007 21:44:15 +0200
Subject: [Cachewolf-svn] r896 - trunk/resources
Message-ID: <200709061944.l86JiFGo023905@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-06 21:44:11 +0200 (Thu, 06 Sep 2007)
New Revision: 896

Modified:
   trunk/resources/cachewolf.Languages.cfg
Log:
Nachtrag zum letzten Commit

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-09-06 19:26:54 UTC (rev 895)
+++ trunk/resources/cachewolf.Languages.cfg	2007-09-06 19:44:11 UTC (rev 896)
@@ -93,6 +93,7 @@
 		204=L%f6ser
 		205=Radar
 		206=Liste
+		207=Immer neu einloggen
 		300=Type:
 		301=Gr%f6%dfe:
 		302=Wegpunkt:
@@ -640,6 +641,7 @@
 		204=Solver
 		205=Radar
 		206=List
+		207=Always login to GC
 		300=Type:
 		301=Size:
 		302=Waypoint:



From salzkammergut at mail.berlios.de  Thu Sep  6 22:46:20 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Thu, 6 Sep 2007 22:46:20 +0200
Subject: [Cachewolf-svn] r897 - trunk/src/CacheWolf
Message-ID: <200709062046.l86KkK6H028219@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-06 22:46:17 +0200 (Thu, 06 Sep 2007)
New Revision: 897

Modified:
   trunk/src/CacheWolf/ImagePanel.java
Log:
ImagePanel: Bugfix. Gelegentlich wurden Bilder nicht angezeigt.

Modified: trunk/src/CacheWolf/ImagePanel.java
===================================================================
--- trunk/src/CacheWolf/ImagePanel.java	2007-09-06 19:44:11 UTC (rev 896)
+++ trunk/src/CacheWolf/ImagePanel.java	2007-09-06 20:46:17 UTC (rev 897)
@@ -122,7 +122,7 @@
 		double dummyC;
 		ImagePanelImage ipi;
 		AniImage AimgText;
-		
+		locCounter=0;
 		for(int i = 0; i<images.size(); i++){
 			location = profile.dataDir + (String)images.get(i);
 			if (!(new File(location)).exists()) {



From mik77 at mail.berlios.de  Fri Sep  7 20:59:33 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Fri, 7 Sep 2007 20:59:33 +0200
Subject: [Cachewolf-svn] r898 - in trunk: resources src/CacheWolf
Message-ID: <200709071859.l87IxXUD031101@sheep.berlios.de>

Author: mik77
Date: 2007-09-07 20:59:30 +0200 (Fri, 07 Sep 2007)
New Revision: 898

Modified:
   trunk/resources/spider.def
   trunk/src/CacheWolf/SpiderGC.java
   trunk/src/CacheWolf/TravelbugJourneyScreen.java
Log:
try to get mission by tracking number first, before searching by name

Modified: trunk/resources/spider.def
===================================================================
--- trunk/resources/spider.def	2007-09-06 20:46:17 UTC (rev 897)
+++ trunk/resources/spider.def	2007-09-07 18:59:30 UTC (rev 898)
@@ -11,7 +11,8 @@
 # Version 2.7 - 20070811 Bugfix fuer verschluesselte Logs
 # Version 2.8 - 20070814 Findet jetzt auch Addi Wpts in eigenen Caches
 # Version 2.9 - 20070817 Bessere Unterscheidung zwischen Werbung vs.normalen Caches + Caches ohne Richtung/Entfenung
-# Version 1.10 - 20070825 Travelbug support
+# Version 2.10 - 20070825 Travelbug support
+# Version 2.11 - 20070907 get travelbug mission by tracking number
 #============================================================
 # A suffix of Rex indicates a regular expression
 # A suffix of ExStart indicates the start of an Extractor search pattern
@@ -96,6 +97,7 @@
 getBugByName       = http://www.geocaching.com/track/search.aspx?k=
 getBugByGuid       = http://www.geocaching.com/track/details.aspx?guid=
 getBugById         = http://www.geocaching.com/track/details.aspx?id=
+getBugByTrackNr    = http://www.geocaching.com/track/details.aspx?tracker=
 bugGuidExStart     = www.geocaching.com/track/details.aspx?id=
 bugGuidExEnd       = "
 bugNotFound        = No\ results\ were\ found\ for\ your\ search

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-09-06 20:46:17 UTC (rev 897)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-09-07 18:59:30 UTC (rev 898)
@@ -1339,6 +1339,32 @@
 			return "";
 		}
 	}
+	
+	/**
+	 * Fetch a bug's mission for a given tracking number
+	 * @param trackNr the tracking number of the travelbug
+	 * @return The mission
+	 */
+	public String getBugMissionByTrackNr(String trackNr) {
+		String bugDetails;
+		try{
+			pref.log("Fetching bug detailsByTrackNr: "+trackNr);
+			bugDetails = fetch(p.getProp("getBugByTrackNr")+trackNr);
+		}catch(Exception ex){
+			pref.log("Could not fetch bug details");
+			bugDetails="";
+		}
+		try {
+			if (bugDetails.indexOf(p.getProp("bugNotFound"))>=0) {
+//				(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(6020,"Travelbug not found."), MessageBox.OKB)).execute();
+				return "";
+			}
+			Extractor exDetails = new Extractor(bugDetails,p.getProp("bugDetailsStart"),p.getProp("bugDetailsEnd"),0,Extractor.EXCLUDESTARTEND);
+			return exDetails.findNext();
+		} catch (Exception ex) {
+			return "";
+		}
+	}
 
 	private class myProperties extends Properties {
 		myProperties() {

Modified: trunk/src/CacheWolf/TravelbugJourneyScreen.java
===================================================================
--- trunk/src/CacheWolf/TravelbugJourneyScreen.java	2007-09-06 20:46:17 UTC (rev 897)
+++ trunk/src/CacheWolf/TravelbugJourneyScreen.java	2007-09-07 18:59:30 UTC (rev 898)
@@ -534,11 +534,25 @@
 			TravelbugJourney tbj=tblMyTravelbugJourneys.getTBJourney(selectedRow);
 			SpiderGC spider=new SpiderGC(Global.getPref(),Global.getProfile(),false);
 			Vm.showWait(true);
-			// First check whether ID is set, if not get it
-			if (tbj.getTb().getGuid().length()==0) tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName().trim()));
+			String strBugMission = "";
+			// First check whether ID is set
+			if (tbj.getTb().getGuid().length()==0) {
+				//if not, try to get mission by tracking number
+				if (tbj.getTb().getTrackingNo().length() != 0) {
+					strBugMission = spider.getBugMissionByTrackNr(tbj.getTb().getTrackingNo());
+				}
+				//if this has't worked, try to get ID by name
+				if (strBugMission.length() == 0) {
+					tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName().trim()));
+				}
+ 			}
 			// If we have an ID, we can get the mission
-			if (tbj.getTb().getGuid().length()!=0) 
-				tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+			if ( (strBugMission.length() == 0) && (tbj.getTb().getGuid().length()!=0)) { 
+				strBugMission = spider.getBugMissionByGuid(tbj.getTb().getGuid());
+			}
+			if (strBugMission.length() != 0) {
+				tbj.getTb().setMission(strBugMission);
+			}			
 			Vm.showWait(false);
 			tcTbJourneyList.repaint();
 			txtMission.setHtml(tbj.getTb().getMission());



From mik77 at mail.berlios.de  Fri Sep  7 21:11:43 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Fri, 7 Sep 2007 21:11:43 +0200
Subject: [Cachewolf-svn] r899 - trunk/src/CacheWolf/navi
Message-ID: <200709071911.l87JBhk8031461@sheep.berlios.de>

Author: mik77
Date: 2007-09-07 21:11:40 +0200 (Fri, 07 Sep 2007)
New Revision: 899

Modified:
   trunk/src/CacheWolf/navi/GotoPanel.java
Log:
set speed correctly for GotoPanel

Modified: trunk/src/CacheWolf/navi/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/navi/GotoPanel.java	2007-09-07 18:59:30 UTC (rev 898)
+++ trunk/src/CacheWolf/navi/GotoPanel.java	2007-09-07 19:11:40 UTC (rev 899)
@@ -242,6 +242,7 @@
 			// display values only, if signal good
 			//Vm.debug("currTrack.add: nachher");
 			lblPosition.setText(myNavigation.gpsPos.toString(currFormat));
+			speed.set(myNavigation.gpsPos.getSpeed());
 			sunAzimut.set(myNavigation.skyOrientationDir.lonDec);
 			bearMov.set(myNavigation.gpsPos.getBear());
 			updateDistance();



From mik77 at mail.berlios.de  Sat Sep  8 00:05:49 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sat, 8 Sep 2007 00:05:49 +0200
Subject: [Cachewolf-svn] r900 - trunk/src/CacheWolf/navi
Message-ID: <200709072205.l87M5nqd012084@sheep.berlios.de>

Author: mik77
Date: 2007-09-08 00:05:45 +0200 (Sat, 08 Sep 2007)
New Revision: 900

Modified:
   trunk/src/CacheWolf/navi/GotoPanel.java
Log:
made all offsets fontsize dependent (to be more flexible in future)

Modified: trunk/src/CacheWolf/navi/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/navi/GotoPanel.java	2007-09-07 19:11:40 UTC (rev 899)
+++ trunk/src/CacheWolf/navi/GotoPanel.java	2007-09-07 22:05:45 UTC (rev 900)
@@ -421,6 +421,7 @@
 	String m_Luminary = MyLocale.getMsg(6100, "Sun");
 	
 	FontMetrics fm;
+	int lineHeight;
 	
 	boolean northCentered = Global.getPref().northCenteredGoto;
 	
@@ -485,6 +486,7 @@
 		Font font = new Font("Verdana", Font.BOLD, 12);
 		g.setFont(font);
 		fm = g.getFontMetrics(font);
+		lineHeight = fm.getHeight() + 1;
 		drawArrows(g);
 		drawWayPointData(g);
 		drawGpsData(g);
@@ -495,7 +497,7 @@
 	private void drawWayPointData(Graphics g){
 		String strTemp = "WayPoint";
 		g.setColor(Color.DarkBlue);
-		g.fillRect(0, 0, fm.getTextWidth(strTemp) + 4 ,fm.getHeight());
+		g.fillRect(0, 0, fm.getTextWidth(strTemp) + 4, lineHeight);
 		g.setColor(Color.White);		
 		g.drawText(strTemp, 2, 0);
 		
@@ -514,13 +516,13 @@
 			}
 		}
 		else strTemp = "--- km";
-		g.drawText(strTemp, 2, 12);
+		g.drawText(strTemp, 2, lineHeight);
 		
 		tmp.set(gotoDir);
 		if ((tmp.value <= 360) && (tmp.value >= -360))
 			strTemp = tmp.toString(0,0,0) + " " + MyLocale.getMsg(1502,"deg");
 		else strTemp = "---" + " " + MyLocale.getMsg(1502,"deg");
-		g.drawText(strTemp, 2, 24);
+		g.drawText(strTemp, 2, 2*lineHeight);
 	}
 	
 	private void drawGpsData(Graphics g){
@@ -550,12 +552,12 @@
 		textWidth = java.lang.Math.max(textWidth, fm.getTextWidth(strHeadline));
 		
 		int startX = location.width - (textWidth + 4);
-		g.fillRect(startX, 0, location.width - startX ,12);
+		g.fillRect(startX, 0, location.width - startX, lineHeight);
 		
 		g.setColor(Color.Black);		
 		g.drawText(strHeadline, startX + 2, 0);		
-		g.drawText(strSpeed, startX + 2, 12);
-		g.drawText(strMoveDir, startX + 2, 24);
+		g.drawText(strSpeed, startX + 2, lineHeight);
+		g.drawText(strMoveDir, startX + 2, 2*lineHeight);
 	}
 	
 	private void drawLuminaryData(Graphics g){
@@ -569,12 +571,12 @@
 		}
 
 		int textWidth = java.lang.Math.max(fm.getTextWidth(m_Luminary), fm.getTextWidth(strSunDir));
-		int startY = location.height - 24;
+		int startY = location.height - 2*lineHeight;
 		g.fillRect(0, startY, textWidth + 4, location.height - startY);
 
 		g.setColor(Color.Black);		
 		g.drawText(m_Luminary, 2, startY);
-		g.drawText(strSunDir, 2, startY + 12);
+		g.drawText(strSunDir, 2, startY + lineHeight);
 	}
 	
 	private void drawGpsStatus(Graphics g){
@@ -598,12 +600,12 @@
 
 		int textWidth = java.lang.Math.max(fm.getTextWidth(strSats), fm.getTextWidth(strHdop));
 		int startX = location.width - (textWidth + 4);
-		int startY = location.height - 24;
+		int startY = location.height - 2*lineHeight;
 		g.fillRect(startX, startY, location.width - startX ,location.height - startY);
 
 		g.setColor(Color.Black);
 		g.drawText(strSats, startX + 2, startY);
-		g.drawText(strHdop, startX + 2, startY + 12);
+		g.drawText(strHdop, startX + 2, startY + lineHeight);
 	}
 
 	private void drawArrows(Graphics g){



From salzkammergut at mail.berlios.de  Sat Sep  8 13:54:59 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 8 Sep 2007 13:54:59 +0200
Subject: [Cachewolf-svn] r901 - trunk/src/CacheWolf
Message-ID: <200709081154.l88BsxH6023640@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-08 13:54:55 +0200 (Sat, 08 Sep 2007)
New Revision: 901

Modified:
   trunk/src/CacheWolf/PreferencesScreen.java
   trunk/src/CacheWolf/SpiderGC.java
Log:
Bei Passworteingabe in PreferencesScreen bzw. beim Spidern werden nur * statt des Passworts angezeigt.
(Ein ein den Preferences festgelegtes Passwort wird weiterhin unverschluesselt in der pref.xml gespeichert)

Modified: trunk/src/CacheWolf/PreferencesScreen.java
===================================================================
--- trunk/src/CacheWolf/PreferencesScreen.java	2007-09-07 22:05:45 UTC (rev 900)
+++ trunk/src/CacheWolf/PreferencesScreen.java	2007-09-08 11:54:55 UTC (rev 901)
@@ -74,6 +74,7 @@
 		pnlBrowser.addNext(new mLabel(MyLocale.getMsg(594,"Pwd")));
 		pnlBrowser.addLast(inpPassword=new mInput(pref.password),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		inpPassword.setToolTip(MyLocale.getMsg(593,"Password is optional here.\nEnter only if you want to store it in pref.xml"));
+		inpPassword.isPassword=true;
 		pnlGeneral.addLast(pnlBrowser,HSTRETCH,HFILL);
 		
 		pnlGeneral.addNext(gpsB = new mButton("GPS"),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-09-07 22:05:45 UTC (rev 900)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-09-08 11:54:55 UTC (rev 901)
@@ -89,6 +89,7 @@
 		//Get password
 		InfoBox infB = new InfoBox(MyLocale.getMsg(5506,"Password"), MyLocale.getMsg(5505,"Enter Password"), InfoBox.INPUT);
 		infB.feedback.setText(passwort); // Remember the PWD for next time
+		infB.feedback.isPassword=true;
 		int code = infB.execute();
 		passwort = infB.getInput();
 		infB.close(0);



From pfeffer at mail.berlios.de  Sat Sep  8 18:55:24 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sat, 8 Sep 2007 18:55:24 +0200
Subject: [Cachewolf-svn] r902 - trunk/src/CacheWolf
Message-ID: <200709081655.l88GtO0x021238@sheep.berlios.de>

Author: pfeffer
Date: 2007-09-08 18:55:21 +0200 (Sat, 08 Sep 2007)
New Revision: 902

Modified:
   trunk/src/CacheWolf/MainForm.java
Log:
fix: avoid java.lang.ArrayIndexOutOfBoundsException at CacheWolf.CacheList.onEvent(CacheList.java:162), which is caused by the fact, taht ewe focuses and passes events to the first Control in a container -> sequence of controls changed

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-09-08 11:54:55 UTC (rev 901)
+++ trunk/src/CacheWolf/MainForm.java	2007-09-08 16:55:21 UTC (rev 902)
@@ -94,9 +94,9 @@
 		mTab = new MainTab(mMenu,statBar);
 		split=new SplittablePanel(PanelSplitter.HORIZONTAL);
 		split.theSplitter.thickness=0; split.theSplitter.modify(Invisible,0);
-		CellPanel pnlCacheList = split.getNextPanel();
 		CellPanel pnlMainTab = split.getNextPanel(); 
-		split.setSplitter(PanelSplitter.MIN_SIZE|PanelSplitter.BEFORE,PanelSplitter.HIDDEN|PanelSplitter.BEFORE,PanelSplitter.CLOSED);
+		CellPanel pnlCacheList = split.getNextPanel(); // ewe sends the key events to the first panel even when it is hidden -> to avoid an exception cachetour must be the second panel
+		split.setSplitter(PanelSplitter.MIN_SIZE|PanelSplitter.AFTER,PanelSplitter.HIDDEN|PanelSplitter.AFTER,PanelSplitter.CLOSED);
 		pnlCacheList.addLast(cacheList=new CacheList(),STRETCH,FILL);
 		pnlMainTab.addLast(mTab,STRETCH,FILL);
 		



From pfeffer at mail.berlios.de  Sat Sep  8 20:03:51 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sat, 8 Sep 2007 20:03:51 +0200
Subject: [Cachewolf-svn] r903 - trunk/src/CacheWolf
Message-ID: <200709081803.l88I3paR030164@sheep.berlios.de>

Author: pfeffer
Date: 2007-09-08 20:03:49 +0200 (Sat, 08 Sep 2007)
New Revision: 903

Modified:
   trunk/src/CacheWolf/TableForm.java
Log:
set the first focus to the cache list instead of the main menu 

Modified: trunk/src/CacheWolf/TableForm.java
===================================================================
--- trunk/src/CacheWolf/TableForm.java	2007-09-08 16:55:21 UTC (rev 902)
+++ trunk/src/CacheWolf/TableForm.java	2007-09-08 18:03:49 UTC (rev 903)
@@ -2,6 +2,8 @@
 
 import ewe.ui.CellConstants;
 import ewe.ui.CellPanel;
+import ewe.ui.Control;
+import ewe.ui.ControlEvent;
 import ewe.ui.Editor;
 
 public class TableForm extends Editor {
@@ -13,6 +15,7 @@
 			this.addLast(tp,STRETCH,FILL);
 			this.addLast(Global.mainForm.mMenu,CellConstants.DONTSTRETCH, CellConstants.FILL);
 		}
+		this.firstFocus = tp; // give the first fokus to the list of caches, not to the main menu
 		/*
 		CellPanel[] menuList = addToolbar();
 		menuList[0].addLast(Global.mainForm.mMenu);



From mirabilos at mail.berlios.de  Sat Sep  8 21:54:02 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Sat, 8 Sep 2007 21:54:02 +0200
Subject: [Cachewolf-svn] r904 - trunk
Message-ID: <200709081954.l88Js21r003260@sheep.berlios.de>

Author: mirabilos
Date: 2007-09-08 21:54:01 +0200 (Sat, 08 Sep 2007)
New Revision: 904

Modified:
   trunk/cwberlios.jnf
Log:
remove the leading dot+slash from pathnames, confuses Jewel on Lunix


Modified: trunk/cwberlios.jnf
===================================================================
--- trunk/cwberlios.jnf	2007-09-08 18:03:49 UTC (rev 903)
+++ trunk/cwberlios.jnf	2007-09-08 19:54:01 UTC (rev 904)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B12M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2%252526%25253DPocketPC%25252B2003%252526%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253DPocketPC%25252B-%25252BMIPS%252526%25253DPocketPC%25252B-%25252BSH3%252526%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&createWithPnf=true&eweInfo=outputFile%3D./work/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/exp%252526mas!
 k%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253Dexp/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources%252526mask%25253D*.gif;*.png;*.ico;*.tp;*.zip;*.html%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources/%252526mask%25253Dcachewolf.Languages.cfg%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D_config/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./lib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/utils%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253Dutils/%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526v!
 mStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526!
 appletIn
Frame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B12M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dtrue%26useClassPool%3Dfalse&icon=(Default)
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B12M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2%252526%25253DPocketPC%25252B2003%252526%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253DPocketPC%25252B-%25252BMIPS%252526%25253DPocketPC%25252B-%25252BSH3%252526%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/exp%252526mask%2525!
 3D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253Dexp/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico;*.tp;*.zip;*.html%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources/%252526mask%25253Dcachewolf.Languages.cfg%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D_config/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/utils%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253Dutils/%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2!
 526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%!
 253Dfals
e%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B12M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dtrue%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico



From mirabilos at mail.berlios.de  Sat Sep  8 21:57:26 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Sat, 8 Sep 2007 21:57:26 +0200
Subject: [Cachewolf-svn] r905 - trunk/src/CacheWolf
Message-ID: <200709081957.l88JvQ58003418@sheep.berlios.de>

Author: mirabilos
Date: 2007-09-08 21:57:25 +0200 (Sat, 08 Sep 2007)
New Revision: 905

Modified:
   trunk/src/CacheWolf/SpiderGC.java
Log:
make the regexen which scan for the Set-Cookie: header case insensitive,
so that they work with the changed routine in fetch() which adds headers
back from the documentProperties into the data as well (because the pro-
perty elements are lowercased)


Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-09-08 19:54:01 UTC (rev 904)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-09-08 19:57:25 UTC (rev 905)
@@ -110,9 +110,9 @@
 			return ERR_LOGIN;
 		}
 		if (!infB.isClosed) { // If user has not aborted, we continue
-			Regex rexCookieID = new Regex("Set-Cookie: userid=(.*?);.*");
+			Regex rexCookieID = new Regex("(?i)Set-Cookie: userid=(.*?);.*");
 			Regex rex = new Regex("name=\"__VIEWSTATE\" value=\"(.*?)\" />");
-			Regex rexCookieSession = new Regex("Set-Cookie: ASP.NET_SessionId=(.*?);.*");
+			Regex rexCookieSession = new Regex("(?i)Set-Cookie: ASP.NET_SessionId=(.*?);.*");
 			rex.search(start);
 			if(rex.didMatch()){
 				viewstate = rex.stringMatched(1);
@@ -128,7 +128,7 @@
 				    + "&" + URL.encodeURL("cookie",false) +"="+ URL.encodeURL("on",false)
 				    + "&" + URL.encodeURL("Button1",false) +"="+ URL.encodeURL("Login",false);
 				start = fetch_post(loginPage, doc, nextPage);  // /login/default.aspx
-				if(start.indexOf(loginSuccess) > 0) 
+				if(start.indexOf(loginSuccess) > 0)
 					pref.log("Login successful");
 				else {
 					pref.log("Login failed. Wrong Account or Password?");
@@ -202,7 +202,7 @@
 			if (ret) {
 				pref.log("Saving to:" + profile.dataDir);
 				chD.saveCacheDetails(profile.dataDir);
-				((CacheHolder) cacheDB.get(number)).update(chD); 
+				((CacheHolder) cacheDB.get(number)).update(chD);
 			}
 		}catch(Exception ex){
 			pref.log("Error spidering " + chD.wayPoint + " in spiderSingle");
@@ -267,11 +267,11 @@
 		String start = "";
 		Regex rex = new Regex("name=\"__VIEWSTATE\" value=\"(.*)\" />");
 		String doc = "";
-		
+
 		if (!loggedIn || Global.getPref().forceLogin) {
 			if(login() != Form.IDOK) return;
 		}
-		
+
 		OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(5510,"Spider Options"),	OCXMLImporterScreen.INCLUDEFOUND | OCXMLImporterScreen.DIST| OCXMLImporterScreen.IMAGES);
 		options.distanceInput.setText("");
 		if (options.execute() == OCXMLImporterScreen.IDCANCEL) {return; }
@@ -493,7 +493,7 @@
 				pref.log("Trying logs");
 				chD.setCacheLogs(getLogs(completeWebPage, chD));
 				pref.log("Found logs");
-				
+
 				// If the switch is set to not store found caches and we found the cache => return
 				if (chD.is_found && doNotGetFound) return !infB.isClosed;
 
@@ -835,7 +835,7 @@
 		String longDesc = "";
 		try {
 			if (chD.wayPoint.startsWith("TC")) longDesc = doc;
-			else 
+			else
 				longDesc = getLongDesc(doc);
 			longDesc = STRreplace.replace(longDesc, "<img", "<IMG");
 			longDesc = STRreplace.replace(longDesc, "src=", "SRC=");
@@ -1002,7 +1002,7 @@
 				cxD.setLongDescription(descRex.stringMatched(1));
 				cxD.is_found = is_found;
 				cxD.saveCacheDetails(profile.dataDir);
-				
+
 				int idx=profile.getCacheIndex(cxD.wayPoint);
 				if (idx<0){
 					cacheDB.add(new CacheHolder(cxD));
@@ -1053,7 +1053,7 @@
 				if(cookieSession.length()>0){
 					conn.setRequestorProperty("Cookie", "ASP.NET_SessionId="+cookieSession +"; userid="+cookieID);
 					pref.log("Cookie Zeug: " + "Cookie: ASP.NET_SessionId="+cookieSession +"; userid="+cookieID);
-				} else 
+				} else
 					pref.log("No Cookie found");
 				conn.setRequestorProperty("Connection", "close");
 				conn.documentIsEncoded = true;
@@ -1340,7 +1340,7 @@
 			return "";
 		}
 	}
-	
+
 	/**
 	 * Fetch a bug's mission for a given tracking number
 	 * @param trackNr the tracking number of the travelbug
@@ -1385,6 +1385,6 @@
 			}
 			return s;
 		}
-		
+
 	}
 }



From mirabilos at mail.berlios.de  Sat Sep  8 22:03:55 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Sat, 8 Sep 2007 22:03:55 +0200
Subject: [Cachewolf-svn] r906 - trunk/docs
Message-ID: <200709082003.l88K3tLP003771@sheep.berlios.de>

Author: mirabilos
Date: 2007-09-08 22:03:55 +0200 (Sat, 08 Sep 2007)
New Revision: 906

Modified:
   trunk/docs/Readme.txt
Log:
document what else is needed, besides CacheWolf.ewe (and what not)


Modified: trunk/docs/Readme.txt
===================================================================
--- trunk/docs/Readme.txt	2007-09-08 19:57:25 UTC (rev 905)
+++ trunk/docs/Readme.txt	2007-09-08 20:03:55 UTC (rev 906)
@@ -30,10 +30,12 @@
 runjewel.sh habe ich mir selbst aus runJewel.bat erzeugt.
 
 - In dem Verzeichnis lib die folgenden Dateien rekursiv auspacken (.jar-Files sind zip-Dateien, falls der Entpacker muckt, einfach tempor?r in .zip umbenennen)
- - ewesoft.zip
- - EwesoftRegex.zip
- - HTML.zip
- - openmap.jar
- Es gibt dann die Unterverzeichnisse com, ewesoft und HTML
+  - ewesoft.zip
+  - EwesoftRegex.zip
+  - HTML.zip
+  - openmap.jar
+  Es gibt dann die Unterverzeichnisse com, ewesoft und HTML
 - Script buildexe.bat bzw. ./buildexe.sh aufrufen, es wird ein Verzeichnis CacheWolf erzeugt mit Unterverzeichnissen f?r die unterschiedlichen Plattformen.
 - mit dem Script runjewel k?nnen ?nderungen an der Datei cwberlios.jnf vorgenommen werden.
+
+An weiteren Dateien neben CacheWolf.ewe werden im Programmverzeichnis noch *.def, *.tpl und attributes/*.gif aus dem Verzeichnis ?resources? ben?tigt.



From mirabilos at mail.berlios.de  Sat Sep  8 22:13:29 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Sat, 8 Sep 2007 22:13:29 +0200
Subject: [Cachewolf-svn] r907 - in trunk: docs resources
	resources/attributes-big
Message-ID: <200709082013.l88KDT3b004500@sheep.berlios.de>

Author: mirabilos
Date: 2007-09-08 22:13:19 +0200 (Sat, 08 Sep 2007)
New Revision: 907

Added:
   trunk/resources/attributes-big/
   trunk/resources/attributes-big/available-no.gif
   trunk/resources/attributes-big/available-yes.gif
   trunk/resources/attributes-big/bicycles-no.gif
   trunk/resources/attributes-big/bicycles-yes.gif
   trunk/resources/attributes-big/boat-no.gif
   trunk/resources/attributes-big/boat-yes.gif
   trunk/resources/attributes-big/cactus-no.gif
   trunk/resources/attributes-big/cactus-yes.gif
   trunk/resources/attributes-big/campfires-no.gif
   trunk/resources/attributes-big/campfires-yes.gif
   trunk/resources/attributes-big/camping-no.gif
   trunk/resources/attributes-big/camping-yes.gif
   trunk/resources/attributes-big/cliff-no.gif
   trunk/resources/attributes-big/cliff-yes.gif
   trunk/resources/attributes-big/climbing-no.gif
   trunk/resources/attributes-big/climbing-yes.gif
   trunk/resources/attributes-big/compass-no.gif
   trunk/resources/attributes-big/compass-yes.gif
   trunk/resources/attributes-big/cow-no.gif
   trunk/resources/attributes-big/cow-yes.gif
   trunk/resources/attributes-big/danger-no.gif
   trunk/resources/attributes-big/danger-yes.gif
   trunk/resources/attributes-big/dogs-no.gif
   trunk/resources/attributes-big/dogs-yes.gif
   trunk/resources/attributes-big/error.gif
   trunk/resources/attributes-big/fee-no.gif
   trunk/resources/attributes-big/fee-yes.gif
   trunk/resources/attributes-big/hiking-no.gif
   trunk/resources/attributes-big/hiking-yes.gif
   trunk/resources/attributes-big/horses-no.gif
   trunk/resources/attributes-big/horses-yes.gif
   trunk/resources/attributes-big/hunting-no.gif
   trunk/resources/attributes-big/hunting-yes.gif
   trunk/resources/attributes-big/jeeps-no.gif
   trunk/resources/attributes-big/jeeps-yes.gif
   trunk/resources/attributes-big/kids-no.gif
   trunk/resources/attributes-big/kids-yes.gif
   trunk/resources/attributes-big/mine-no.gif
   trunk/resources/attributes-big/mine-yes.gif
   trunk/resources/attributes-big/motorcycles-no.gif
   trunk/resources/attributes-big/motorcycles-yes.gif
   trunk/resources/attributes-big/night-no.gif
   trunk/resources/attributes-big/night-yes.gif
   trunk/resources/attributes-big/onehour-no.gif
   trunk/resources/attributes-big/onehour-yes.gif
   trunk/resources/attributes-big/parking-no.gif
   trunk/resources/attributes-big/parking-yes.gif
   trunk/resources/attributes-big/phone-no.gif
   trunk/resources/attributes-big/phone-yes.gif
   trunk/resources/attributes-big/picnic-no.gif
   trunk/resources/attributes-big/picnic-yes.gif
   trunk/resources/attributes-big/poisonoak-no.gif
   trunk/resources/attributes-big/poisonoak-yes.gif
   trunk/resources/attributes-big/public-no.gif
   trunk/resources/attributes-big/public-yes.gif
   trunk/resources/attributes-big/quads-no.gif
   trunk/resources/attributes-big/quads-yes.gif
   trunk/resources/attributes-big/rappelling-no.gif
   trunk/resources/attributes-big/rappelling-yes.gif
   trunk/resources/attributes-big/restrooms-no.gif
   trunk/resources/attributes-big/restrooms-yes.gif
   trunk/resources/attributes-big/scenic-no.gif
   trunk/resources/attributes-big/scenic-yes.gif
   trunk/resources/attributes-big/scuba-no.gif
   trunk/resources/attributes-big/scuba-yes.gif
   trunk/resources/attributes-big/snakes-no.gif
   trunk/resources/attributes-big/snakes-yes.gif
   trunk/resources/attributes-big/snowmobiles-no.gif
   trunk/resources/attributes-big/snowmobiles-yes.gif
   trunk/resources/attributes-big/stealth-no.gif
   trunk/resources/attributes-big/stealth-yes.gif
   trunk/resources/attributes-big/stroller-no.gif
   trunk/resources/attributes-big/stroller-yes.gif
   trunk/resources/attributes-big/swimming-no.gif
   trunk/resources/attributes-big/swimming-yes.gif
   trunk/resources/attributes-big/thorn-no.gif
   trunk/resources/attributes-big/thorn-yes.gif
   trunk/resources/attributes-big/ticks-no.gif
   trunk/resources/attributes-big/ticks-yes.gif
   trunk/resources/attributes-big/wading-no.gif
   trunk/resources/attributes-big/wading-yes.gif
   trunk/resources/attributes-big/water-no.gif
   trunk/resources/attributes-big/water-yes.gif
   trunk/resources/attributes-big/wheelchair-no.gif
   trunk/resources/attributes-big/wheelchair-yes.gif
   trunk/resources/attributes-big/winter-no.gif
   trunk/resources/attributes-big/winter-yes.gif
Modified:
   trunk/docs/Readme.txt
Log:
add the 30x30px attributes from
http://prdownload.berlios.de/cachewolf/attributes_Large.zip

ok MiK77


Modified: trunk/docs/Readme.txt
===================================================================
--- trunk/docs/Readme.txt	2007-09-08 20:03:55 UTC (rev 906)
+++ trunk/docs/Readme.txt	2007-09-08 20:13:19 UTC (rev 907)
@@ -38,4 +38,4 @@
 - Script buildexe.bat bzw. ./buildexe.sh aufrufen, es wird ein Verzeichnis CacheWolf erzeugt mit Unterverzeichnissen f?r die unterschiedlichen Plattformen.
 - mit dem Script runjewel k?nnen ?nderungen an der Datei cwberlios.jnf vorgenommen werden.
 
-An weiteren Dateien neben CacheWolf.ewe werden im Programmverzeichnis noch *.def, *.tpl und attributes/*.gif aus dem Verzeichnis ?resources? ben?tigt.
+An weiteren Dateien neben CacheWolf.ewe werden im Programmverzeichnis noch *.def, *.tpl und attributes/*.gif aus dem Verzeichnis ?resources? ben?tigt. Wahlweise kann man stattdessen auch resources/attributes-big/*.gif in ?Programmverzeichnis?/attributes/ packen.

Added: trunk/resources/attributes-big/available-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/available-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/available-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/available-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/bicycles-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/bicycles-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/bicycles-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/bicycles-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/boat-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/boat-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/boat-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/boat-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/cactus-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/cactus-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/cactus-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/cactus-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/campfires-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/campfires-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/campfires-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/campfires-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/camping-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/camping-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/camping-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/camping-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/cliff-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/cliff-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/cliff-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/cliff-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/climbing-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/climbing-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/climbing-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/climbing-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/compass-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/compass-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/compass-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/compass-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/cow-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/cow-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/cow-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/cow-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/danger-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/danger-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/danger-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/danger-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/dogs-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/dogs-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/dogs-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/dogs-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/error.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/error.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/fee-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/fee-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/fee-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/fee-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/hiking-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/hiking-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/hiking-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/hiking-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/horses-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/horses-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/horses-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/horses-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/hunting-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/hunting-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/hunting-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/hunting-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/jeeps-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/jeeps-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/jeeps-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/jeeps-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/kids-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/kids-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/kids-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/kids-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/mine-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/mine-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/mine-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/mine-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/motorcycles-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/motorcycles-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/motorcycles-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/motorcycles-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/night-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/night-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/night-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/night-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/onehour-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/onehour-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/onehour-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/onehour-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/parking-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/parking-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/parking-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/parking-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/phone-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/phone-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/phone-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/phone-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/picnic-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/picnic-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/picnic-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/picnic-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/poisonoak-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/poisonoak-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/poisonoak-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/poisonoak-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/public-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/public-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/public-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/public-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/quads-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/quads-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/quads-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/quads-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/rappelling-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/rappelling-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/rappelling-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/rappelling-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/restrooms-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/restrooms-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/restrooms-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/restrooms-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/scenic-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/scenic-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/scenic-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/scenic-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/scuba-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/scuba-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/scuba-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/scuba-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/snakes-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/snakes-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/snakes-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/snakes-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/snowmobiles-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/snowmobiles-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/snowmobiles-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/snowmobiles-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/stealth-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/stealth-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/stealth-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/stealth-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/stroller-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/stroller-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/stroller-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/stroller-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/swimming-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/swimming-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/swimming-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/swimming-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/thorn-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/thorn-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/thorn-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/thorn-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/ticks-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/ticks-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/ticks-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/ticks-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/wading-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/wading-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/wading-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/wading-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/water-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/water-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/water-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/water-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/wheelchair-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/wheelchair-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/wheelchair-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/wheelchair-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/winter-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/winter-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/winter-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/winter-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From salzkammergut at mail.berlios.de  Sat Sep  8 22:13:30 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 8 Sep 2007 22:13:30 +0200
Subject: [Cachewolf-svn] r908 - trunk/src/CacheWolf
Message-ID: <200709082013.l88KDUrb004514@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-08 22:13:28 +0200 (Sat, 08 Sep 2007)
New Revision: 908

Modified:
   trunk/src/CacheWolf/TravelbugJourneyScreen.java
Log:
TravelbugJourneyScreen: Kleiner Fix der fontmetrics

Modified: trunk/src/CacheWolf/TravelbugJourneyScreen.java
===================================================================
--- trunk/src/CacheWolf/TravelbugJourneyScreen.java	2007-09-08 20:13:19 UTC (rev 907)
+++ trunk/src/CacheWolf/TravelbugJourneyScreen.java	2007-09-08 20:13:28 UTC (rev 908)
@@ -277,7 +277,7 @@
 		//shadeAlternateRows=true;
 		cursorSize=new Dimension(12,1);
 		clipData=true;
-		fm=this.fm;
+		fm=getFontMetrics();
 		// A red dot indicates that the journey has not been completely logged
 		imgRed = new Image("red.png");
 	}



From mirabilos at mail.berlios.de  Sat Sep  8 22:24:03 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Sat, 8 Sep 2007 22:24:03 +0200
Subject: [Cachewolf-svn] r909 - trunk/resources/attributes-big
Message-ID: <200709082024.l88KO3wt004925@sheep.berlios.de>

Author: mirabilos
Date: 2007-09-08 22:24:03 +0200 (Sat, 08 Sep 2007)
New Revision: 909

Added:
   trunk/resources/attributes-big/firstaid-no.gif
   trunk/resources/attributes-big/firstaid-yes.gif
Log:
MiK77 noted these were missing from the .zip
that?s all now, I hope


Added: trunk/resources/attributes-big/firstaid-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/firstaid-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/firstaid-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/firstaid-yes.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From salzkammergut at mail.berlios.de  Sat Sep  8 23:38:29 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 8 Sep 2007 23:38:29 +0200
Subject: [Cachewolf-svn] r910 - trunk/src/CacheWolf
Message-ID: <200709082138.l88LcTkP008042@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-08 23:38:26 +0200 (Sat, 08 Sep 2007)
New Revision: 910

Modified:
   trunk/src/CacheWolf/Preferences.java
Log:
Preferences: Aufgeraeumt

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-09-08 20:24:03 UTC (rev 909)
+++ trunk/src/CacheWolf/Preferences.java	2007-09-08 21:38:26 UTC (rev 910)
@@ -1,5 +1,4 @@
 package CacheWolf;
-//TODO Option to generate backup when saving index.xml
 import utils.FileBugfix;
 import ewe.io.*;
 import ewe.sys.*;
@@ -17,22 +16,52 @@
  */
 public class Preferences extends MinML{
 
-	static protected final int PROFILE_SELECTOR_FORCED_ON=0;
-	static protected final int PROFILE_SELECTOR_FORCED_OFF=1;
-	static protected final int PROFILE_SELECTOR_ONOROFF=2;
+	public final int DEFAULT_MAX_LOGS_TO_SPIDER=250;
+	public final int DEFAULT_LOGS_PER_PAGE=5;
+	public final int DEFAULT_INITIAL_HINT_HEIGHT=50;
 
-	/** The currently used centre point, can be different from the profile's centrepoint. This is used
-	 *  for spidering */
-	public CWPoint curCentrePt=new CWPoint();
+	//////////////////////////////////////////////////////////////////////////////////////
+    // Constructor
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	/**
+	 * Singleton pattern - return reference to Preferences
+	 * @return Singleton Preferences object
+	 */
+	public static Preferences getPrefObject() {
+		if (_reference == null)
+			// it's ok, we can call this constructor
+			_reference = new Preferences();
+		return _reference;
+	}
+
+	private static Preferences _reference;
+
+	/**
+	 * Constructor is private for a singleton object
+	 */
+	private Preferences(){
+		digSeparator=MyLocale.getDigSeparator();
+		mySPO.bits = 8;
+		mySPO.parity = SerialPort.NOPARITY;
+		mySPO.stopBits = 1;
+		mySPO.baudRate = 4800;
+		if ( ((ewe.fx.Rect) (Window.getGuiInfo(Window.INFO_SCREEN_RECT,null,new ewe.fx.Rect(),0))).height > 400) 
+			 fontSize = 16;
+		else 
+			 fontSize = 12;
+	}
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // Public fields stored in pref.xml
+	//////////////////////////////////////////////////////////////////////////////////////
+	
+	/** The base directory contains one subdirectory for each profile*/
+	public String baseDir = "";  
 	/** Name of last used profile */
 	public String lastProfile=""; 
 	/** If true, the last profile is reloaded automatically without a dialogue */
 	public boolean autoReloadLastProfile=false; 
-	/** The base directory contains one subdirectory for each profile*/
-	public String baseDir = "";  // TODO Set this initially to mydataDir ??
-
-	public String myproxy = "";    
-	public String myproxyport = "";
 	/** This is the login alias for geocaching.com and opencaching.de */
 	public String myAlias = "";
 	/** Optional password */
@@ -42,47 +71,33 @@
 	public String myAlias2 = "";
 	/** The path to the browser */
 	public String browser = "";
-	public boolean showDeletedImages=true; /* Used in ImagePanel */
-	public boolean solverIgnoreCase=false;
-
-	/**
-	 * Forced language. If specified it overrides the default language.
-	 * Example: To run CW in English language on a German PC specify "EN" here.
-	 */
-	public String language="";
-	public int myAppHeight = 0;
-	public int myAppWidth = 0;
-	public final int DEFAULT_MAX_LOGS_TO_SPIDER=250;
-	public int maxLogsToSpider = DEFAULT_MAX_LOGS_TO_SPIDER;
-	public boolean dirty = false;
-
-	public String garminConn="com1";  // The type of connection which GPSBABEL uses: com1 OR usb.
-	public String garminGPSBabelOptions=""; // Additional options for GPSBabel, i.e. -s to synthethize short names
+	/** Name of proxy for spidering */
+	public String myproxy = "";    
+	/** Proxyport when spidering */
+	public String myproxyport = "";
+	/** Serial port name and baudrate */
+	public SerialPortOptions mySPO = new SerialPortOptions();
+	/** True if the GPS data should be forwarded to an IP address */
+	public boolean forwardGPS = false;
+	/** IP address for forwarding GPS data */
+	public String forwardGpsHost = "";
+	/** The default font size */
+	public int fontSize = 12;
 	// These settings govern where the menu and the tabs are displayed and whether the statusbas is shown
+	/** True if the menu is to be displayed at the top of the screen */
 	public boolean menuAtTop=true;
+	/** True if the tabs are to be displayed at the top of the screen */
 	public boolean tabsAtTop=true;
+	/** True if the status bar is to be displayed (hidden if false) */
 	public boolean showStatus=true;
+	/** True if the application can be closed by clicking on the close button in the top line.
+	 * This can be set to avoid accidental closing of the application */
 	public boolean hasCloseButton=true;
-	// This setting determines how many logs are shown per page of hintlogs (default 5)
-	public final int DEFAULT_LOGS_PER_PAGE=5;
-	public int logsPerPage=DEFAULT_LOGS_PER_PAGE;
-	// Initial height of hints field (set to 0 to hide them initially)
-	public final int DEFAULT_INITIAL_HINT_HEIGHT=50;
-	public int initialHintHeight=DEFAULT_INITIAL_HINT_HEIGHT; 
-	public boolean downloadPicsOC = true; //TODO Sollten die auch im Profil gespeichert werden mit Preferences als default Werte ?
-	public boolean downloadMapsOC = true;
-	public boolean downloadmissingOC = false;
+	/** True if the SIP is always visible */
 	public boolean fixSIP = false;
-
-	public String digSeparator = "";
-	public boolean debug = false;
-	public SerialPortOptions mySPO = new SerialPortOptions();
-	public boolean forwardGPS = false;
-	public String forwardGpsHost = "";
-	public int fontSize = 12;
-	
-	public boolean forceLogin=true;
+	/** The list of visible columns in the list view */
 	public String listColMap="0,1,2,3,4,5,6,7,8,9,10,11";
+	/** The widths for each column in list view */
 	public String listColWidth="15,20,20,25,92,177,144,83,60,105,50,104";
 	/** The columns which are to be displayed in TravelbugsJourneyScreen. See also TravelbugJourney */
 	public String travelbugColMap="1,4,5,6,8,9,10,7";
@@ -90,161 +105,59 @@
 	public String travelbugColWidth="212,136,62,90,50,56,90,38,50,50,94,50";
 	/** If this flag is true, only non-logged travelbug journeys will be shown */
 	public boolean travelbugShowOnlyNonLogged=false;
-	
+	/** If this is true, deleted images are shown with a ? in the imagepanel */
+	public boolean showDeletedImages=true; 
+	/** This setting determines how many logs are shown per page of hintlogs (default 5) */
+	public int logsPerPage=DEFAULT_LOGS_PER_PAGE;
+	/** Initial height of hints field (set to 0 to hide them initially) */
+	public int initialHintHeight=DEFAULT_INITIAL_HINT_HEIGHT; 
+	/** Maximum logs to spider */ 
+	public int maxLogsToSpider = DEFAULT_MAX_LOGS_TO_SPIDER;
+	/** True if the Solver should ignore the case of variables */
+	public boolean solverIgnoreCase=true;
+	/** The type of connection which GPSBABEL uses: com1 OR usb. */
+	public String garminConn="com1";  
+	/** Additional options for GPSBabel, i.e. -s to synthethize short names */
+	public String garminGPSBabelOptions=""; 
+	public boolean downloadPicsOC = true; //TODO Sollten die auch im Profil gespeichert werden mit Preferences als default Werte ?
+	public boolean downloadMapsOC = true;
+	public boolean downloadmissingOC = false;
+	/** The currently used centre point, can be different from the profile's centrepoint. This is used
+	 *  for spidering */
+	public CWPoint curCentrePt=new CWPoint();
+	/** True if a login screen is displayed on each spider operation */
+	public boolean forceLogin=true;
+	/** True if the goto panel is North centered */
 	public boolean northCenteredGoto = true;
-	
-	public String mapsPath = "maps/standard";
-	// Helper variables for XML parser 
-	private StringBuffer collectElement=null; 
-	private String lastName; // The string to the last XML that was processed
+	/** If not null, a customs map path has been specified by the user */
+	private String customMapsPath=null; 
 
-	private final String LOGFILENAME=File.getProgramDirectory()+"/log.txt";
-	// The following declarations may eventually be moved to a separate class
-	/** The actual directory of a profile, for new profiles this is a direct child of baseDir */
-	//TODO Find all references amd move to profile.dataDir
-	//public String mydatadir = new String();  //Redundant ??
-	/** The centre as read from the profile */
-
-	// Hashtable for storing the last export path
-	private Hashtable exporterPaths = new Hashtable();
-	/**
-	 * Singleton pattern - return reference to Preferences
-	 * @return Singleton Preferences object
+	//////////////////////////////////////////////
+	/** The debug switch (Can be used to activate dormant code) by adding
+	 * the line: <pre><debug value="true"></pre>
+	 * to the pref.xml file.
 	 */
+	public boolean debug = false;
+	//////////////////////////////////////////////
 
-	public static Preferences getPrefObject() {
-		if (_reference == null)
-			// it's ok, we can call this constructor
-			_reference = new Preferences();
-		return _reference;
-	}
-
-	private static Preferences _reference;
-
-	/**
-	 * Constructor is private for a singleton object
-	 *
-	 */
-	private Preferences(){
-		digSeparator=MyLocale.getDigSeparator();
-		//Vm.debug("Separ: " + digSeparator);
-		mySPO.bits = 8;
-		mySPO.parity = SerialPort.NOPARITY;
-		mySPO.stopBits = 1;
-		mySPO.baudRate = 4800;
-		if ( ((ewe.fx.Rect) (Window.getGuiInfo(Window.INFO_SCREEN_RECT,null,new ewe.fx.Rect(),0))).height > 400) fontSize = 16;
-		else fontSize = 12;
-		// Ensure that logfile does not grow infinitely. Not really needed as every spider resets it
-		File logFile = new File(LOGFILENAME);
-		if (logFile.length()>60000) logInit();
-	}
-
-	private String customMapsPath=null; // The maps path set by the user
+    //////////////////////////////////////////////////////////////////////////////////////
+    // Public fields not stored in pref.xml
+	//////////////////////////////////////////////////////////////////////////////////////
 	
-	/**
-	 * Gibt den vom Benutzer gesetzten Pfad zu den Maps
-	 * @return custom Maps Path, null wenn nicht gesetzt
-	 */
-	public String getCustomMapsPath() {
-	   return customMapsPath;	
-	}
+	/** The height of the application */
+	public int myAppHeight = 0;
+	/** The width of the application */
+	public int myAppWidth = 0;
+	/** True if the preferences were changed and need to be saved */
+	public boolean dirty = false;
+	/** The decimal separator (from MyLocale) */
+	public String digSeparator = "";
 	
-	void saveCustomMapsPath(String mapspath) {
-		customMapsPath=mapsPath;
-	}
+    //////////////////////////////////////////////////////////////////////////////////////
+    // Read pref.xml file
+	//////////////////////////////////////////////////////////////////////////////////////
 	
 	/**
-	 * gets the path to the calibrated maps
-	 * it first tries if there are manually imported maps
-	 * in <baseDir>/maps/standard then it tries 
-	 * the legacy dir: <program-dir>/maps
-	 * In case in both locations are no .wfl-files
-	 * it returns  <baseDir>/maps/expedia - the place where
-	 * the automatically downloaded maps are placed.
-	 * 
-	 * Later the maps-path shall be saved in the preferences
-	 */
-	public String getMapLoadPath() {
-		// here could also a list of map-types displayed...
-		// standard dir
-		File t = new FileBugfix(getMapManuallySavePath(false));
-		String[] f = t.list("*.wfl", File.LIST_ALWAYS_INCLUDE_DIRECTORIES | File.LIST_FILES_ONLY);
-		if (f != null && f.length > 0) return  baseDir + mapsPath;
-		f = t.list("*.wfl", File.LIST_DIRECTORIES_ONLY | File.LIST_ALWAYS_INCLUDE_DIRECTORIES);
-		if (f != null && f.length > 0) { // see if in a subdir of <baseDir>/maps/standard are .wfl files
-			String[] f2;
-			for (int i = 0; i< f.length; i++) {
-				t.set(null, getMapManuallySavePath(false)+"/"+f[i]);
-				f2 = t.list("*.wfl", File.LIST_FILES_ONLY);
-				if (f2 != null && f2.length > 0) return  getMapManuallySavePath(false);
-			}
-		}
-		// lagacy dir 
-		t.set(null, File.getProgramDirectory() + "/maps");
-		f = t.list("*.wfl", File.LIST_FILES_ONLY);
-		if (f != null && f.length > 0) {
-			MessageBox inf = new MessageBox("Information", "The directory for calibrated maps \nhas moved in this program version\n to '<profiles directory>/maps/standard'\n Do you want to move your calibrated maps there now?", MessageBox.YESB | MessageBox.NOB);
-			if (inf.execute() == MessageBox.IDYES) {
-				String sp = getMapManuallySavePath(false);
-				File spF = new File(sp);
-				if (!spF.exists()) spF.mkdirs();
-				String image;
-				String lagacypath = File.getProgramDirectory() + "/maps/";
-				for (int i=0; i<f.length; i++) {
-					t.set(null, lagacypath+f[i]);
-					spF.set(null, sp+"/"+f[i]);
-					t.move(spF);
-					image = Common.getImageName(lagacypath+f[i].substring(0, f[i].lastIndexOf(".")));
-					t.set(null, image);
-					spF.set(null, sp+"/"+t.getFileExt());
-					t.move(spF);
-				}
-				t.set(null, lagacypath);
-				t.delete();
-				return sp;
-			}
-			else return  File.getProgramDirectory() + "/maps";
-		}
-		// expedia dir
-		return getMapExpediaLoadPath(); 
-	}
-
-	/**
-	 * it creates the directory if it doesn't exist
-	 * @return the path where manually imported maps should be stored
-	 * this should be adjustable in preferences...
-	 */
-	public String getMapManuallySavePath(boolean create) {
-		String mapsDir = baseDir + mapsPath;
-		if (create && !(new File(mapsDir).isDirectory())) { // dir exists? 
-			if (new File(mapsDir).mkdirs() == false) {// dir creation failed?
-				(new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(172,"Error: cannot create maps directory: \n")+mapsDir, MessageBox.OKB)).exec();
-				return null;
-			}
-		}
-		return mapsDir;
-	}
-
-	/**
-	 * to this path the automatically downloaded maps are saved
-	 */
-	public String getMapExpediaSavePath() {
-		String subdir = Global.getProfile().dataDir.substring(Global.getPref().baseDir.length());
-		String mapsDir = Global.getPref().baseDir + "maps/expedia/" + subdir;
-		if (!(new File(mapsDir).isDirectory())) { // dir exists? 
-			if (new File(mapsDir).mkdirs() == false) // dir creation failed?
-			{(new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(172,"Error: cannot create maps directory: \n")+new File(mapsDir).getParentFile(), MessageBox.OKB)).exec();
-			return null;
-			}
-		}
-		return mapsDir;
-	}
-
-	public String getMapExpediaLoadPath() {
-		return Global.getPref().baseDir + "maps/expedia"; // baseDir has trailing /
-	}
-
-	/**
 	 * Method to open and parse the pref.xml file. Results are stored in the
 	 * public variables of this class.
 	 */
@@ -263,53 +176,10 @@
 		}
 	}
 
-	/**
-	 * Open Profile selector screen 
-	 * @param prof
-	 * @param showProfileSelector
-	 * @return True if a profile was selected
-	 */
+	/** Helper variables for XML parser */ 
+	private StringBuffer collectElement=null; 
+	private String lastName; // The string to the last XML that was processed
 
-	public boolean selectProfile(Profile prof, int showProfileSelector, boolean hasNewButton) {
-		// If datadir is empty, ask for one
-		if (baseDir.length()==0 || !(new File(baseDir)).exists()) {
-			do {
-				FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT,baseDir);
-				fc.title = MyLocale.getMsg(170,"Select base directory for cache data");
-				// If no base directory given, terminate
-				if (fc.execute() == FileChooser.IDCANCEL) ewe.sys.Vm.exit(0);
-				baseDir = fc.getChosenFile().toString();
-			}while (!(new File(baseDir)).exists());
-		}
-		baseDir=baseDir.replace('\\','/');
-		if (!baseDir.endsWith("/")) baseDir+="/";
-		//Vm.showWait(false);
-		boolean profileExists=true;  // Assume that the profile exists
-		do {	
-			if(!profileExists || (showProfileSelector==PROFILE_SELECTOR_FORCED_ON) || 
-					(showProfileSelector==PROFILE_SELECTOR_ONOROFF && !autoReloadLastProfile)){ // Ask for the profile
-				ProfilesForm f = new ProfilesForm(baseDir,lastProfile,!profileExists || hasNewButton);
-				int code = f.execute();
-				// If no profile chosen (includes a new one), terminate
-				if (code==-1) return false; // Cancel pressed
-				prof.clearProfile();
-				curCentrePt.set(0,0); // No centre yet
-				lastProfile=f.newSelectedProfile;
-			}
-			profileExists=(new File(baseDir+lastProfile)).exists();
-			if (!profileExists) (new MessageBox(MyLocale.getMsg(144,"Warning"),
-					           MyLocale.getMsg(171,"Profile does not exist: ")+lastProfile,MessageBox.MBOK)).execute();
-		} while (profileExists==false);
-		// Now we are sure that baseDir exists and basDir+profile exists
-		prof.name=lastProfile;
-		prof.dataDir=baseDir+lastProfile;
-		prof.dataDir=prof.dataDir.replace('\\','/');
-		if (!prof.dataDir.endsWith("/")) prof.dataDir+='/';
-		savePreferences();
-		return true;
-
-	}
-
 	/**
 	 * Method that gets called when a new element has been identified in pref.xml
 	 */
@@ -426,7 +296,10 @@
 		collectElement=null;
 	}
 
-
+    //////////////////////////////////////////////////////////////////////////////////////
+    // Write pref.xml file
+	//////////////////////////////////////////////////////////////////////////////////////
+	
 	/**
 	 * Method to save current preferences in the pref.xml file
 	 */
@@ -475,7 +348,175 @@
 		}
 	}
 
+    //////////////////////////////////////////////////////////////////////////////////////
+    // Maps
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	public String mapsPath = "maps/standard";
+	
 	/**
+	 * Gibt den vom Benutzer gesetzten Pfad zu den Maps
+	 * @return custom Maps Path, null wenn nicht gesetzt
+	 */
+	public String getCustomMapsPath() {
+	   return customMapsPath;	
+	}
+	
+	void saveCustomMapsPath(String mapspath) {
+		customMapsPath=mapsPath;
+	}
+	
+	/**
+	 * gets the path to the calibrated maps
+	 * it first tries if there are manually imported maps
+	 * in <baseDir>/maps/standard then it tries 
+	 * the legacy dir: <program-dir>/maps
+	 * In case in both locations are no .wfl-files
+	 * it returns  <baseDir>/maps/expedia - the place where
+	 * the automatically downloaded maps are placed.
+	 * 
+	 * Later the maps-path shall be saved in the preferences
+	 */
+	public String getMapLoadPath() {
+		// here could also a list of map-types displayed...
+		// standard dir
+		File t = new FileBugfix(getMapManuallySavePath(false));
+		String[] f = t.list("*.wfl", File.LIST_ALWAYS_INCLUDE_DIRECTORIES | File.LIST_FILES_ONLY);
+		if (f != null && f.length > 0) return  baseDir + mapsPath;
+		f = t.list("*.wfl", File.LIST_DIRECTORIES_ONLY | File.LIST_ALWAYS_INCLUDE_DIRECTORIES);
+		if (f != null && f.length > 0) { // see if in a subdir of <baseDir>/maps/standard are .wfl files
+			String[] f2;
+			for (int i = 0; i< f.length; i++) {
+				t.set(null, getMapManuallySavePath(false)+"/"+f[i]);
+				f2 = t.list("*.wfl", File.LIST_FILES_ONLY);
+				if (f2 != null && f2.length > 0) return  getMapManuallySavePath(false);
+			}
+		}
+		// lagacy dir 
+		t.set(null, File.getProgramDirectory() + "/maps");
+		f = t.list("*.wfl", File.LIST_FILES_ONLY);
+		if (f != null && f.length > 0) {
+			MessageBox inf = new MessageBox("Information", "The directory for calibrated maps \nhas moved in this program version\n to '<profiles directory>/maps/standard'\n Do you want to move your calibrated maps there now?", MessageBox.YESB | MessageBox.NOB);
+			if (inf.execute() == MessageBox.IDYES) {
+				String sp = getMapManuallySavePath(false);
+				File spF = new File(sp);
+				if (!spF.exists()) spF.mkdirs();
+				String image;
+				String lagacypath = File.getProgramDirectory() + "/maps/";
+				for (int i=0; i<f.length; i++) {
+					t.set(null, lagacypath+f[i]);
+					spF.set(null, sp+"/"+f[i]);
+					t.move(spF);
+					image = Common.getImageName(lagacypath+f[i].substring(0, f[i].lastIndexOf(".")));
+					t.set(null, image);
+					spF.set(null, sp+"/"+t.getFileExt());
+					t.move(spF);
+				}
+				t.set(null, lagacypath);
+				t.delete();
+				return sp;
+			}
+			else return  File.getProgramDirectory() + "/maps";
+		}
+		// expedia dir
+		return getMapExpediaLoadPath(); 
+	}
+
+	/**
+	 * it creates the directory if it doesn't exist
+	 * @return the path where manually imported maps should be stored
+	 * this should be adjustable in preferences...
+	 */
+	public String getMapManuallySavePath(boolean create) {
+		String mapsDir = baseDir + mapsPath;
+		if (create && !(new File(mapsDir).isDirectory())) { // dir exists? 
+			if (new File(mapsDir).mkdirs() == false) {// dir creation failed?
+				(new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(172,"Error: cannot create maps directory: \n")+mapsDir, MessageBox.OKB)).exec();
+				return null;
+			}
+		}
+		return mapsDir;
+	}
+
+	/**
+	 * to this path the automatically downloaded maps are saved
+	 */
+	public String getMapExpediaSavePath() {
+		String subdir = Global.getProfile().dataDir.substring(Global.getPref().baseDir.length());
+		String mapsDir = Global.getPref().baseDir + "maps/expedia/" + subdir;
+		if (!(new File(mapsDir).isDirectory())) { // dir exists? 
+			if (new File(mapsDir).mkdirs() == false) // dir creation failed?
+			{(new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(172,"Error: cannot create maps directory: \n")+new File(mapsDir).getParentFile(), MessageBox.OKB)).exec();
+			return null;
+			}
+		}
+		return mapsDir;
+	}
+
+	public String getMapExpediaLoadPath() {
+		return Global.getPref().baseDir + "maps/expedia"; // baseDir has trailing /
+	}
+	
+    //////////////////////////////////////////////////////////////////////////////////////
+    // Profile Selector
+	//////////////////////////////////////////////////////////////////////////////////////
+	
+	static protected final int PROFILE_SELECTOR_FORCED_ON=0;
+	static protected final int PROFILE_SELECTOR_FORCED_OFF=1;
+	static protected final int PROFILE_SELECTOR_ONOROFF=2;
+
+	/**
+	 * Open Profile selector screen 
+	 * @param prof
+	 * @param showProfileSelector
+	 * @return True if a profile was selected
+	 */
+	public boolean selectProfile(Profile prof, int showProfileSelector, boolean hasNewButton) {
+		// If datadir is empty, ask for one
+		if (baseDir.length()==0 || !(new File(baseDir)).exists()) {
+			do {
+				FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT,baseDir);
+				fc.title = MyLocale.getMsg(170,"Select base directory for cache data");
+				// If no base directory given, terminate
+				if (fc.execute() == FileChooser.IDCANCEL) ewe.sys.Vm.exit(0);
+				baseDir = fc.getChosenFile().toString();
+			}while (!(new File(baseDir)).exists());
+		}
+		baseDir=baseDir.replace('\\','/');
+		if (!baseDir.endsWith("/")) baseDir+="/";
+		boolean profileExists=true;  // Assume that the profile exists
+		do {	
+			if(!profileExists || (showProfileSelector==PROFILE_SELECTOR_FORCED_ON) || 
+					(showProfileSelector==PROFILE_SELECTOR_ONOROFF && !autoReloadLastProfile)){ // Ask for the profile
+				ProfilesForm f = new ProfilesForm(baseDir,lastProfile,!profileExists || hasNewButton);
+				int code = f.execute();
+				// If no profile chosen (includes a new one), terminate
+				if (code==-1) return false; // Cancel pressed
+				prof.clearProfile();
+				curCentrePt.set(0,0); // No centre yet
+				lastProfile=f.newSelectedProfile;
+			}
+			profileExists=(new File(baseDir+lastProfile)).exists();
+			if (!profileExists) (new MessageBox(MyLocale.getMsg(144,"Warning"),
+					           MyLocale.getMsg(171,"Profile does not exist: ")+lastProfile,MessageBox.MBOK)).execute();
+		} while (profileExists==false);
+		// Now we are sure that baseDir exists and basDir+profile exists
+		prof.name=lastProfile;
+		prof.dataDir=baseDir+lastProfile;
+		prof.dataDir=prof.dataDir.replace('\\','/');
+		if (!prof.dataDir.endsWith("/")) prof.dataDir+='/';
+		savePreferences();
+		return true;
+	}
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // Log functions
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	/** Log file is in program directory and called log.txt */
+	private final String LOGFILENAME=File.getProgramDirectory()+"/log.txt";
+	
+	/**
 	 * Method to delete an existing log file. Called on every SpiderGC.
 	 * The log file is also cleared when Preferences is created and the filesize > 60KB
 	 */
@@ -544,6 +585,13 @@
 		log (message,e,false);
 	}
 		
+    //////////////////////////////////////////////////////////////////////////////////////
+    // Exporter path functions
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	/** Hashtable for storing the last export path */
+	private Hashtable exporterPaths = new Hashtable();
+
 	public void setExportPath(String exporter,String path){
 		exporterPaths.put(exporter, path);
 	}



From salzkammergut at mail.berlios.de  Sun Sep  9 01:54:38 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 9 Sep 2007 01:54:38 +0200
Subject: [Cachewolf-svn] r911 - trunk/src/CacheWolf
Message-ID: <200709082354.l88NscMq000267@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-09 01:54:37 +0200 (Sun, 09 Sep 2007)
New Revision: 911

Modified:
   trunk/src/CacheWolf/CacheList.java
Log:
CacheList: Bugfix: ArrayOutOfBounds Exception bei Events

Modified: trunk/src/CacheWolf/CacheList.java
===================================================================
--- trunk/src/CacheWolf/CacheList.java	2007-09-08 21:38:26 UTC (rev 910)
+++ trunk/src/CacheWolf/CacheList.java	2007-09-08 23:54:37 UTC (rev 911)
@@ -158,7 +158,7 @@
 	
 	public void onEvent(Event ev) {
 		if (ev instanceof MenuEvent && ev.type==MenuEvent.SELECTED) {
-			if (lstCaches.itemsSize()>0) {
+			if (lstCaches.itemsSize()>0 && !needsInit) {
 				int lstCacheIdx=lstCaches.getSelectedIndex(0);
 				CacheHolder ch=(CacheHolder)cacheList.get(lstCacheIdx);
 				int idx=Global.getProfile().cacheDB.find(ch);



From salzkammergut at mail.berlios.de  Sun Sep  9 14:32:56 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 9 Sep 2007 14:32:56 +0200
Subject: [Cachewolf-svn] r912 - trunk/src/CacheWolf
Message-ID: <200709091232.l89CWuD5020673@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-09 14:32:51 +0200 (Sun, 09 Sep 2007)
New Revision: 912

Modified:
   trunk/src/CacheWolf/CacheList.java
   trunk/src/CacheWolf/MainForm.java
   trunk/src/CacheWolf/myTableControl.java
Log:
Fix fuer Probleme mit KeyEvents (siehe auch Rev 902)
@Pfeffer: Bitte teste ob das Deine Probleme loest
Fix fuer Problem Listenansicht: Bei der ersten Zeile wurde die letzte Spalte nicht invertiert dargestellt.

Modified: trunk/src/CacheWolf/CacheList.java
===================================================================
--- trunk/src/CacheWolf/CacheList.java	2007-09-08 23:54:37 UTC (rev 911)
+++ trunk/src/CacheWolf/CacheList.java	2007-09-09 12:32:51 UTC (rev 912)
@@ -119,6 +119,16 @@
 		// Alternative method of deleting a cache from the list through
 		// Keyboard interface
 		public void onKeyEvent(KeyEvent ev) {
+			/* This is a bit of a hack. By default Ewe sends key events to 
+			 * this panel. So if the list has not had anything dragged into it,
+			 * we redirect the focus to the list view, assuming that that is where
+			 * the key event needs to go.
+			 */
+			if (needsInit) {
+				Gui.takeFocus(Global.mainTab.tbP.tc, Control.ByKeyboard);
+				ev.target=Global.mainTab.tbP.tc;
+				postEvent(ev);
+			}
 			if (ev.type == KeyEvent.KEY_PRESS && ev.target == this){
 				if (ev.key == IKeys.DELETE && cacheList.size()>0) {
 			    	 idx=getSelectedIndex(0);

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-09-08 23:54:37 UTC (rev 911)
+++ trunk/src/CacheWolf/MainForm.java	2007-09-09 12:32:51 UTC (rev 912)
@@ -94,9 +94,9 @@
 		mTab = new MainTab(mMenu,statBar);
 		split=new SplittablePanel(PanelSplitter.HORIZONTAL);
 		split.theSplitter.thickness=0; split.theSplitter.modify(Invisible,0);
+		CellPanel pnlCacheList = split.getNextPanel();
 		CellPanel pnlMainTab = split.getNextPanel(); 
-		CellPanel pnlCacheList = split.getNextPanel(); // ewe sends the key events to the first panel even when it is hidden -> to avoid an exception cachetour must be the second panel
-		split.setSplitter(PanelSplitter.MIN_SIZE|PanelSplitter.AFTER,PanelSplitter.HIDDEN|PanelSplitter.AFTER,PanelSplitter.CLOSED);
+		split.setSplitter(PanelSplitter.MIN_SIZE|PanelSplitter.BEFORE,PanelSplitter.HIDDEN|PanelSplitter.BEFORE,PanelSplitter.CLOSED);
 		pnlCacheList.addLast(cacheList=new CacheList(),STRETCH,FILL);
 		pnlMainTab.addLast(mTab,STRETCH,FILL);
 		

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-09-08 23:54:37 UTC (rev 911)
+++ trunk/src/CacheWolf/myTableControl.java	2007-09-09 12:32:51 UTC (rev 912)
@@ -95,6 +95,13 @@
 		Global.getProfile().setSelectForAll(selectStatus);
 		tbp.refreshTable();
 	}
+	
+	 
+	/** always select a whole row */
+	public boolean isSelected(int row,int col) {
+		return row==selection.y;
+	}
+	
 	public void popupMenuEvent(Object selectedItem){
 		CacheHolder ch;
 		if (selectedItem.toString().equals(MyLocale.getMsg(1015,"Select all"))){
@@ -256,7 +263,7 @@
 	String wayPoint;
 	int row;
 	
-	public void startDragging(DragContext dc) {//TODO Dragging of header widths
+	public void startDragging(DragContext dc) {
 		 Vector cacheDB=Global.getProfile().cacheDB;
 		 Point p=cellAtPoint(dc.start.x,dc.start.y,null);
 		 wayPoint=null;
@@ -297,5 +304,4 @@
 	 	else
 	 		super.dragged(dc);
 	 }
-
 }



From salzkammergut at mail.berlios.de  Sun Sep  9 14:54:52 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 9 Sep 2007 14:54:52 +0200
Subject: [Cachewolf-svn] r913 - trunk/src/CacheWolf
Message-ID: <200709091254.l89CsqZK021918@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-09 14:54:45 +0200 (Sun, 09 Sep 2007)
New Revision: 913

Modified:
   trunk/src/CacheWolf/StatusBar.java
Log:
Nachtrag zum letzten Commit: Nach Oeffnen/Schliessen Cachliste wird der Fokus wieder auf die grosse Liste gesetzt

Modified: trunk/src/CacheWolf/StatusBar.java
===================================================================
--- trunk/src/CacheWolf/StatusBar.java	2007-09-09 12:32:51 UTC (rev 912)
+++ trunk/src/CacheWolf/StatusBar.java	2007-09-09 12:54:45 UTC (rev 913)
@@ -76,6 +76,7 @@
 			if (ev.target == btnCacheTour){
 				Global.mainForm.toggleCacheListVisible();			
 			}
+			Gui.takeFocus(Global.mainTab.tbP.tc, Control.ByKeyboard);
 		}
 		super.onEvent(ev);
 	}



From salzkammergut at mail.berlios.de  Sun Sep  9 16:22:42 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 9 Sep 2007 16:22:42 +0200
Subject: [Cachewolf-svn] r914 - trunk/src/CacheWolf
Message-ID: <200709091422.l89EMg93026754@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-09 16:22:37 +0200 (Sun, 09 Sep 2007)
New Revision: 914

Modified:
   trunk/src/CacheWolf/CacheList.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/myTableControl.java
   trunk/src/CacheWolf/myTableModel.java
Log:
TableControl: Mit key.LEFT kann ein Cache auch per Tastatur in die Cacheliste kopiert werden (wenn diese offen ist). Fix: Diverse Probleme mit Tastatureingaben und Klicks bei leerer Liste. 

Modified: trunk/src/CacheWolf/CacheList.java
===================================================================
--- trunk/src/CacheWolf/CacheList.java	2007-09-09 12:54:45 UTC (rev 913)
+++ trunk/src/CacheWolf/CacheList.java	2007-09-09 14:22:37 UTC (rev 914)
@@ -295,7 +295,7 @@
 	 * @return true if the cache is not already in lstCaches */
 	public boolean addCache(String wayPoint) {
 		// Check whether this is the first cache being added
-		if (needsInit)  {lstCaches.deleteItem(0);lstCaches.deleteItem(0);  needsInit=false; }
+		if (needsInit)  {lstCaches.deleteItem(0);lstCaches.deleteItem(0);  needsInit=false; lstCaches.repaint(); }
 		int idx=Global.getProfile().getCacheIndex(wayPoint);
 		if (idx==-1) return false;
 		CacheHolder ch=(CacheHolder) Global.getProfile().cacheDB.get(idx);

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-09-09 12:54:45 UTC (rev 913)
+++ trunk/src/CacheWolf/MainTab.java	2007-09-09 14:22:37 UTC (rev 914)
@@ -120,7 +120,7 @@
 			// If it is Addi get details of main Wpt (chMain)
 			chMain=null;
 			cacheDirty=false;
-			if (tbP.getSelectedCache()>=Global.mainTab.tbP.myMod.numRows) {
+			if (tbP.getSelectedCache()>=Global.mainTab.tbP.myMod.numRows || tbP.getSelectedCache()<0) {
 				ch=null; chD=null; 
 				lastselected="";
 			} else {
@@ -234,7 +234,8 @@
 	public void updateBearDist(){// Called from DetailsPanel, GotoPanel and myTableControl
 		tbP.pref = pref;
 		profile.updateBearingDistance();
-		tbP.refreshTable();
+		//tbP.refreshTable();
+		tbP.tc.repaint();
 		//(new MessageBox(MyLocale.getMsg(327,"Information"), MyLocale.getMsg(1024,"Entfernungen in der Listenansicht \nvom aktuellen Standpunkt aus \nneu berechnet").replace('~','\n'), MessageBox.OKB)).execute();
 	}
 

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-09-09 12:54:45 UTC (rev 913)
+++ trunk/src/CacheWolf/myTableControl.java	2007-09-09 14:22:37 UTC (rev 914)
@@ -84,6 +84,7 @@
 			else if (ev.key == IKeys.ACTION || ev.key == IKeys.ENTER) Global.mainTab.select(Global.mainTab.descP);
 			else if (ev.key == IKeys.DOWN) Global.mainTab.tbP.selectRow(java.lang.Math.min(cursor.y+ 1, model.numRows-1)); 
 			else if (ev.key == IKeys.UP) Global.mainTab.tbP.selectRow(java.lang.Math.max(cursor.y-1, 0));
+			else if (ev.key == IKeys.LEFT && Global.mainForm.cacheListVisible && cursor.y>=0 && cursor.y<tbp.myMod.numRows) Global.mainForm.cacheList.addCache(((CacheHolder)cacheDB.elementAt(cursor.y)).wayPoint); 
 			else if (ev.key == 6 ) MainMenu.search(); // (char)6 == ctrl + f 
 			else super.onKeyEvent(ev);
 		}

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-09-09 12:54:45 UTC (rev 913)
+++ trunk/src/CacheWolf/myTableModel.java	2007-09-09 14:22:37 UTC (rev 914)
@@ -59,8 +59,8 @@
 		tcControl = tc;
 		setColumnNamesAndWidths(); 
 		this.numRows = cacheDB.size();
-		Dimension selrow = new Dimension(-1,1);
-		this.cursorSize = selrow;
+		//Dimension selrow = new Dimension(-1,1);
+		//this.cursorSize = selrow;
 		cacheImages[0] = new Image("0.png");
 		//cacheImages[1] = new Image();
 		cacheImages[2] = new Image("2.png");
@@ -286,8 +286,8 @@
 	
 	public boolean penPressed(Point onTable,Point cell){
 		boolean retval = false;
+		if (cell==null) return false;
 		try{
-			if (cell.y>=0) Global.mainTab.tbP.setSelectedCache(cell.y);
 			// Check whether the click is on the checkbox image
 			if (cell.y>=0 && cell.x==0) {
 				Global.getProfile().selectionChanged = true;
@@ -334,7 +334,7 @@
 				tcControl.update(true);
 				retval = true;
 			}
-		}catch(NullPointerException npex){}
+		} catch(NullPointerException npex){Global.getPref().log("NPE in myTableModel.Penpressed");}
 		return retval;
 	}
 	



From salzkammergut at mail.berlios.de  Sun Sep  9 16:41:54 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 9 Sep 2007 16:41:54 +0200
Subject: [Cachewolf-svn] r915 - trunk/src/CacheWolf
Message-ID: <200709091441.l89EfssQ027704@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-09 16:41:47 +0200 (Sun, 09 Sep 2007)
New Revision: 915

Modified:
   trunk/src/CacheWolf/myTableControl.java
Log:
myTableControl: Bugfix NPE bei leere Tabelle und rechtem Mausklick

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-09-09 14:22:37 UTC (rev 914)
+++ trunk/src/CacheWolf/myTableControl.java	2007-09-09 14:41:47 UTC (rev 915)
@@ -244,8 +244,11 @@
 	    	// cache details
 	    	if (ev.type==PenEvent.PEN_DOWN && (((PenEvent)ev).modifiers&PenEvent.RIGHT_BUTTON)!=0) { 
 				Point p=cellAtPoint(((PenEvent)ev).x,((PenEvent)ev).y,null);
-				rowRightMouseClick=p.y;
-				// The selection of the row on right mouse click ist delayed
+				if (p==null)
+					rowRightMouseClick=-1;
+				else
+					rowRightMouseClick=p.y;
+				// The selection of the row on right mouse click is delayed
 				// until the menu has been drawn to speed up the refreshing of the screen
 			}
 			Global.mainTab.tbP.myMod.penEventModifiers=((PenEvent)ev).modifiers;



From salzkammergut at mail.berlios.de  Sun Sep  9 17:13:33 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 9 Sep 2007 17:13:33 +0200
Subject: [Cachewolf-svn] r916 - trunk/src/CacheWolf
Message-ID: <200709091513.l89FDXnd029127@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-09 17:13:30 +0200 (Sun, 09 Sep 2007)
New Revision: 916

Modified:
   trunk/src/CacheWolf/myTableControl.java
Log:
myTableControl: Wenn Login beim Aktualisieren von Caches abgebrochen wurde, wurde noch ein Login Fenster geoeffnet

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-09-09 14:41:47 UTC (rev 915)
+++ trunk/src/CacheWolf/myTableControl.java	2007-09-09 15:13:30 UTC (rev 916)
@@ -143,6 +143,7 @@
 			OCXMLImporter ocSync = new OCXMLImporter(pref, profile);
 			//Vm.debug("ByPass? " + profile.byPassIndexActive);
 			if (!spider.loggedIn || Global.getPref().forceLogin) spider.login();
+			if (!spider.loggedIn) return;
 			Vm.showWait(true);
 			boolean alreadySaid = false;
 			boolean alreadySaid2 = false;



From salzkammergut at mail.berlios.de  Sun Sep  9 23:05:25 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 9 Sep 2007 23:05:25 +0200
Subject: [Cachewolf-svn] r917 - trunk/src/CacheWolf
Message-ID: <200709092105.l89L5PAY000628@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-09 23:05:21 +0200 (Sun, 09 Sep 2007)
New Revision: 917

Modified:
   trunk/src/CacheWolf/Preferences.java
Log:
Preferences: Kleiner Fix beim Speichern

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-09-09 15:13:30 UTC (rev 916)
+++ trunk/src/CacheWolf/Preferences.java	2007-09-09 21:05:21 UTC (rev 917)
@@ -330,7 +330,7 @@
 			outp.print("    <garmin connection = \""+garminConn+"\" GPSBabelOptions = \""+garminGPSBabelOptions+"\" />\n");
 			outp.print("    <opencaching downloadPicsOC=\""+downloadPicsOC+"\" downloadMaps=\""+downloadMapsOC+"\" downloadMissing=\""+downloadmissingOC+"\"/>\n");
 			outp.print("	<location lat = \""+curCentrePt.getLatDeg(CWPoint.DD)+"\" long = \""+curCentrePt.getLonDeg(CWPoint.DD)+"\"/>\n");
-			outp.print("    <spider forcelogin=\""+forceLogin+"\"/>/n");
+			outp.print("    <spider forcelogin=\""+forceLogin+"\"/>\n");
 			outp.print("    <gotopanel northcentered=\""+northCenteredGoto+"\" />\n");
 			if (customMapsPath!=null) outp.print("	<mapspath dir = \""+ customMapsPath +"\"/>\n");
 			if (debug) outp.print("    <debug value=\"true\" />\n"); // Keep the debug switch if it is set



From salzkammergut at mail.berlios.de  Sun Sep  9 23:16:31 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 9 Sep 2007 23:16:31 +0200
Subject: [Cachewolf-svn] r918 - trunk/src/CacheWolf
Message-ID: <200709092116.l89LGVB3001168@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-09 23:16:26 +0200 (Sun, 09 Sep 2007)
New Revision: 918

Modified:
   trunk/src/CacheWolf/TablePanel.java
   trunk/src/CacheWolf/myTableControl.java
Log:
Listenansicht: Verbesserung der Darstellung bei Navigation mittels Tastatur.
Wenn eine Spalte angeklickt wurde bleibt sie dann beim Scrollen mittels Tastatur auch weiterhin sichtbar.
Fix: Die letzte Spalte wurde manchmal nicht grau dargestellt

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-09-09 21:05:21 UTC (rev 917)
+++ trunk/src/CacheWolf/TablePanel.java	2007-09-09 21:16:26 UTC (rev 918)
@@ -41,46 +41,18 @@
 		tc.setTableModel(myMod);
 	}
 	
-	public void setSelectedCache(int row){ 
-	/*	selectedCh=null;
-		selectedIdx=-1;
-		if (row>=0 && row<cacheDB.size())  {
-			selectedCh=(CacheHolder) cacheDB.get(row);
-			selectedIdx=row;
-		} 		
-	*/
-	}
-	
 	/** Mark the row as selected so that myTableModel can color it grey */
 	public void selectRow(int row) {
-		setSelectedCache(row);
-//		tc.addToSelection(row,0); 
-//		tc.addToSelection(row,myMod.MAXCOLUMNS-1);
 		// Ensure that the highlighted row is visible (e.g. when coming from radar panel)
-		tc.scrollToVisible(row,0);
 		// Next line needed for key scrolling 
-		tc.cursorTo(row, tc.cursor.x+tc.listMode, true);
-// <<<<<<< .mine
-		//tc.scrollToVisible(row,0);
-		//tc.clearSelection(null);
-		//tc.addToSelection(row,0); 
-		//tc.addToSelection(row,myMod.MAXCOLUMNS-1); 
-		//tc.scrollToVisible(row,0);
-		/*tc.clearSelection(null);
-		tc.addToSelection(row,0); 
-		tc.addToSelection(row,myMod.MAXCOLUMNS-1);*/ 
-		//tc.paintSelectedCells();
-//=======
-//>>>>>>> .r820
+		tc.cursorTo(row, tc.cursor.x+tc.listMode, true); 
 	}
 	
 	/** Highlight the first row in grey. It can be unhighlighted by clicking */
 	public void selectFirstRow() {
 		myMod.cursorSize=new Dimension(-1,1);
 		if (cacheDB.size()>0) {
-			tc.cursorTo(0, -1, true);
-//			tc.addToSelection(0,0); 
-//			tc.addToSelection(0,myMod.MAXCOLUMNS-1);
+			tc.cursorTo(0, 0, true);
 		}
 	}
 	
@@ -90,20 +62,6 @@
 	 */
 	public int getSelectedCache(){
 		return tc.cursor.y;
-		/*
-		// If cacheDB is empty return -1, cannot select a cache
-		if (cacheDB.size()==0) return -1;
-		// If cacheDB has entries, but all are filtered, return -1
-		if (((CacheHolder)cacheDB.get(0)).is_filtered) return -1;
-		// Now we have at least one visible cache
-		// Check whether selected cache was deleted or filtered 
-		if (selectedIdx>=Global.mainTab.tbP.myMod.numRows) return Global.mainTab.tbP.myMod.numRows-1;
-		// We had a previously selected cache, check whether it is now filtered
-		if (selectedCh==null || selectedCh.is_filtered) return 0; // Return first visible cache
-		// Check whether the order of the list has changed because of sort/filter/search operations
-		if (cacheDB.get(selectedIdx)==selectedCh) return selectedIdx;
-		// The position has changed, return the new position
-		return cacheDB.find(selectedCh); */
 	}
 	
 	public void saveColWidth(Preferences pref){
@@ -114,15 +72,7 @@
 		}
 	}
 	
-	/*
-	public void selectAndActive(int rownum){
-		//		tc.scrollToVisible(rownum, 0);
-		selectRow(rownum);  // color it in grey
-	}
-	*/
-	
 	public void resetModel() {
-		setSelectedCache(0);
 		myMod.numRows = cacheDB.size();
 		Global.getProfile().updateBearingDistance();
 		Filter flt = new Filter();
@@ -140,7 +90,7 @@
 		tc.update(true);
 	}
 	
-	/** Move all filtered caches to the end of the table and redesplay table */
+	/** Move all filtered caches to the end of the table and redisplay table */
 	//TODO Add a sort here to restore the sort after a filter
 	public void refreshTable(){
 		myMod.updateRows();

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-09-09 21:05:21 UTC (rev 917)
+++ trunk/src/CacheWolf/myTableControl.java	2007-09-09 21:16:26 UTC (rev 918)
@@ -309,4 +309,21 @@
 	 	else
 	 		super.dragged(dc);
 	 }
+
+	 public void cursorTo(int row,int col,boolean selectNew) {
+		if (row != -2 && col != -2 && !canSelect(row,col)) return;
+		cursor.set(col,row);
+		if (selectNew){
+			clearSelectedCells(oldExtendedSelection);
+			paintCells(null,oldExtendedSelection);
+			if (row != -2 && col != -2){
+				if (scrollToVisible(row,col)) repaintNow();
+				addToSelection(Rect.buff.set(0,row,model.numCols,1),true);
+				fireSelectionEvent(TableEvent.FLAG_SELECTED_BY_ARROWKEY);
+				clickedFlags = TableEvent.FLAG_SELECTED_BY_ARROWKEY;
+				if (clickMode) clicked(row,col);
+				clickedFlags = 0;
+			}
+		}
+	 }
 }



From salzkammergut at mail.berlios.de  Sat Sep 15 15:27:38 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 15 Sep 2007 15:27:38 +0200
Subject: [Cachewolf-svn] r919 - trunk/src/CacheWolf
Message-ID: <200709151327.l8FDRcQc003528@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-15 15:27:30 +0200 (Sat, 15 Sep 2007)
New Revision: 919

Modified:
   trunk/src/CacheWolf/myInteractivePanel.java
Log:
CacheList: Scrollen des Radarpanels beim Ziehen von Caches deaktiviert (http://www.geoclub.de/ftopic18789.html).
Caches koennen jetzt nur gezogen werden wenn die CacheListe sichtbar ist.

Modified: trunk/src/CacheWolf/myInteractivePanel.java
===================================================================
--- trunk/src/CacheWolf/myInteractivePanel.java	2007-09-09 21:16:26 UTC (rev 918)
+++ trunk/src/CacheWolf/myInteractivePanel.java	2007-09-15 13:27:30 UTC (rev 919)
@@ -4,7 +4,6 @@
 import ewe.util.Vector;
 import ewe.sys.*;
 import ewe.fx.*;
-import ewe.graphics.*;
 
 /**
 *	This class allows handling of a user click on a cache
@@ -25,6 +24,7 @@
 	String strDifficulty=MyLocale.getMsg(1120,"Diff");
 	String strTerrain=MyLocale.getMsg(1121,"Terr");
 	AniImage imgDrag; // Allows the dragging of the cache into the cachelist
+	boolean canScroll=true;
 	
 	private void clearInfo() {
 		removeImage(imgInfo);
@@ -99,9 +99,10 @@
 	String wayPoint;
 	
 	public void startDragging(DragContext dc) {
+		if (!Global.mainForm.cacheListVisible) return;
 		Vector cacheDB=Global.getProfile().cacheDB;
-//Vm.debug("myIAP startDrag "+dc.start.x+"/"+dc.start.y+"  "+ch.wayPoint);
-		 int idx=Global.getProfile().getCacheIndex(wayPoint); 
+//Vm.debug("myIAP startDrag "+dc.start.x+"/"+dc.start.y);
+		int idx=Global.getProfile().getCacheIndex(wayPoint); 
 		if (idx>=0) {
 			 CacheHolder ch=(CacheHolder) cacheDB.get(idx);
 			 //wayPoint=ch.wayPoint;
@@ -111,14 +112,19 @@
 			 icnDrag.addColumn(ch.wayPoint);
 			 dc.dragData=dc.startImageDrag(icnDrag,new Point(8,8),this);
 			 if (dc instanceof ImageDragContext) Vm.debug(">>>>Is Image drag");
+			 canScroll=false;
 		}
 	 }
 
-	 public void stopDragging(DragContext dc) {}
+	 public void stopDragging(DragContext dc) {		 
+		canScroll=true;
+	 }
 	 public void draggingStarted(ImageDragContext dc) {}
 	 public void draggingStopped(ImageDragContext dc) {}
 	 
 	 public boolean imageBeginDragged(AniImage which,Point pos) {
+		if (!Global.mainForm.cacheListVisible) return false;
+		canScroll=false;
 		clearInfo();
 		wayPoint=null;
 		AniImage dragImage=null;
@@ -173,4 +179,14 @@
 	     }
 		 return false; 
 	 }
+	 
+	 public boolean canScreenScroll() {
+		 return canScroll;
+	 }
+	 public boolean scroll(int dx,int dy,Point moved) {
+		 if (canScroll)
+			 return super.scroll(dx,dy,moved);
+		 else
+			 return false;
+	 }
 }



From bilbowolf at mail.berlios.de  Sat Sep 15 22:06:29 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Sat, 15 Sep 2007 22:06:29 +0200
Subject: [Cachewolf-svn] r920 - in trunk/docs: . CacheWolf Doku CacheWolf
	Doku/images CacheWolf Doku/images/callouts
Message-ID: <200709152006.l8FK6T2t005071@sheep.berlios.de>

Author: bilbowolf
Date: 2007-09-15 22:06:08 +0200 (Sat, 15 Sep 2007)
New Revision: 920

Added:
   trunk/docs/CacheWolf Doku/
   trunk/docs/CacheWolf Doku/CacheWolf Dokumentation.html
   trunk/docs/CacheWolf Doku/CacheWolf Dokumentation.xml
   trunk/docs/CacheWolf Doku/Der erste Start.xml
   trunk/docs/CacheWolf Doku/Installation.xml
   trunk/docs/CacheWolf Doku/ansichten.xml
   trunk/docs/CacheWolf Doku/ansichten_liste.xml
   trunk/docs/CacheWolf Doku/html.css
   trunk/docs/CacheWolf Doku/images/
   trunk/docs/CacheWolf Doku/images/callouts/
   trunk/docs/CacheWolf Doku/images/callouts/1.png
   trunk/docs/CacheWolf Doku/images/callouts/10.png
   trunk/docs/CacheWolf Doku/images/callouts/11.png
   trunk/docs/CacheWolf Doku/images/callouts/12.png
   trunk/docs/CacheWolf Doku/images/callouts/13.png
   trunk/docs/CacheWolf Doku/images/callouts/14.png
   trunk/docs/CacheWolf Doku/images/callouts/15.png
   trunk/docs/CacheWolf Doku/images/callouts/2.png
   trunk/docs/CacheWolf Doku/images/callouts/3.png
   trunk/docs/CacheWolf Doku/images/callouts/4.png
   trunk/docs/CacheWolf Doku/images/callouts/5.png
   trunk/docs/CacheWolf Doku/images/callouts/6.png
   trunk/docs/CacheWolf Doku/images/callouts/7.png
   trunk/docs/CacheWolf Doku/images/callouts/8.png
   trunk/docs/CacheWolf Doku/images/callouts/9.png
   trunk/docs/CacheWolf Doku/images/draft.png
   trunk/docs/CacheWolf Doku/pics/
Log:
Erste Teile der Dokumentation in Docbook

Added: trunk/docs/CacheWolf Doku/CacheWolf Dokumentation.html
===================================================================
--- trunk/docs/CacheWolf Doku/CacheWolf Dokumentation.html	2007-09-15 13:27:30 UTC (rev 919)
+++ trunk/docs/CacheWolf Doku/CacheWolf Dokumentation.html	2007-09-15 20:06:08 UTC (rev 920)
@@ -0,0 +1,3 @@
+<html><head>
+      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+   <title>CacheWolf Dokumentation</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.70.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>CacheWolf Dokumentation</h1></div></div><hr></div><div class="toc"><dl><dt><span class="chapter"><a href="#d0e4">1. Installation</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e34">1.1. Welche Cachewolf - Version f&uuml;r was?</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e38">1.1.1. Windows</a></span></dt><dt><span class="section"><a href="#d0e43">1.1.2. Java</a></span></dt><dt><span class="section"><a href="#d0e52">1.1.3. Pocket PC</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e111">1.1.3.1. Wichtige Information zur Nutzung von GPS Empf&auml;ngern</a></span></dt></dl></dd><dt><span class!
 ="section"><a href="#d0e127">1.1.4. Zaurus</a></span></dt></dl></dd></dl></dd></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e4"></a>Chapter&nbsp;1.&nbsp;Installation</h2></div><div><div class="author"><h3 class="author"><span class="surname">Marc Schnitzler</span></h3></div></div><div><p class="releaseinfo">Review f&uuml;r Freigabe</p></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr><tr><td align="left">Revision 0.1</td><td align="left">7. September 2007</td><td align="left"><span class="surname">Marc Schnitzler<br></span></td></tr><tr><td align="left" colspan="3"><p>Erster Entwurf, kopiert www.cachewolf.de</p></td></tr></table></div></div></div></div><p>Cachewolf ist verf&uuml;gbar in verschiedenen Versionen f&uuml;r Windows, Linux, PocketPC (ARM/PPC) und Zaurus. Die prim&auml;re Downloadseite i!
 st BerliOS, als Alternative kannst du dir den Cachewolf auch d!
 irekt un
ter <code class="uri">http://www.cachewolf.de/wiki/pmwiki.php/Main/Download</code> herunterladen.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e34"></a>1.1.&nbsp;Welche Cachewolf - Version f&uuml;r was?</h2></div></div></div><p></p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e38"></a>1.1.1.&nbsp;Windows</h3></div></div></div><p>Hier ist die Installation sehr einfach. Einfach die .zip-Datei in ein Verzeichnis Deiner Wahl entpacken. Durch einen Doppelklick auf das CacheWolf Icon startet das Programm.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e43"></a>1.1.2.&nbsp;Java</h3></div></div></div><p>F&uuml;r den Einsatz der Java-Version ben&ouml;tigst du eine Java-Runtime in der Version 1.5 oder h&ouml;her. Diese bekommst du entweder direkt bei Sun oder &uuml;ber die Linux-eigene Paketverwaltung (SuSE: YaST,!
  Debian: apt-get,...).</p><p>&Uuml;ber die Kommandozeile startest du das Programm mittels: <code class="literal">java -jar "/Pfadzucachewolf/CacheWolf.jar" &amp;</code></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e52"></a>1.1.3.&nbsp;Pocket PC</h3></div></div></div><p>Der Cachewolf l&auml;uft auf PocketPC's &uuml;ber eine sogenannte virtuelle Maschine (EWE VM). Diese stellt die Grundlage aller Funktionen des CW dar und dadurch l&auml;uft er auf fast allen PocketPC's.</p><p>Es existieren zwei optimierte Versionen von Cachewolf f&uuml;r den PocketPC: f&uuml;r Ger&auml;te mit ARM-Prozessor und f&uuml;r Ger&auml;te mit Intel-Prozessor. Welche Version ben&ouml;tigt wird, kann man auch durch Probieren ermitteln. (Teilweise laufen auch beide Versionen.)</p><p>CacheWolf erkennt &uuml;brigens VGA-Ger&auml;te und stellt die Aufl&ouml;sung entsprechend ein.</p><table bgcolor="#FFFFCC"><tr><td><div class="highlights"><p>Aus der !
 FAQ:</p><p>Frage 3: Welche Version von CacheWolf ist die richt!
 ige f&uu
ml;r mein Pocket PC?</p><p>Antwort: Diese Frage ist leider nicht so einfach zu beantworten.</p><p>Auf dieser Seite www.pocketpc-users.de gibt es eine sehr gute Beschreibung.</p><p>Vielleicht hilft aber folgende (kurze) Zusammenfassung:</p><p>* Hast Du ein Pocket PC 2000 Ger&auml;t, dann benutzt es wahrscheinlich einen ARM (kompatiblen) Prozessor. Es gibt allerdings Ausnahmen, die einen SH3 oder MIPS Prozessor nutzen.</p><p>* Pocket PC 2002 und 2003 Ger&auml;te nutzen ausschlie&szlig; einen ARM (kompatiblen) Prozessor.</p><p>* Hast Du eine Ger&auml;t, da&szlig; Du in der zweiten H&auml;lfte 2004 gekauft hast, dann solltest Du die "PocketPC" Version von CacheWolf installieren. Beispiele (von Nutzern): PocketPCArm: XDA Trion, ASUS632,Yakumo Delta GPS, Loox N520, Compaq IPAQ 6915, Medion MDPPC250, FSC Loox N560, Dell Axim X51V, Yakumo DeltaX5BT, Acer N35 PocketPC: Loox N520, Mio Digi Walker P550 Zaurus: Sharp SL-C1000</p><p>Sagt dir das alles gar nichts probier einfach die Versi!
 onen durch - eine wird auf jeden Fall funktionieren!</p></div></td></tr></table><p>Die Installation ist ein mehrstufiger Prozess:</p><div class="itemizedlist"><ul type="disc"><li><p>Zuerst muss die EWE VM (Virtual Machine) installiert werden:</p><div class="itemizedlist"><ul type="circle"><li><p>EWE VM unter <code class="uri">http://www.ewesoft.com/Downloads/Downloads.html#_Toc105819897</code> herunterladen.</p><p>Hier darauf achten, die richtige Version ("Low Resolution" f&uuml;r normale PDA's oder "High Resolution" f&uuml;r VGA-PDA's zu laden.</p></li><li><p>Installation der VM wie unter dem Download Link beschrieben: die cab-Datei auf den PDA &uuml;bertragen (mittels Speicherkarte oder ActiveSync) und dann auf dem PDA ausf&uuml;hren.</p></li><li><p>Nach erfolgter Installation unter Start -&gt; Programme -&gt; EWE das Programm EWE starten. Damit werden noch notwendige Systemeintr&auml;ge gemacht und die VM ist nun funktionsf&auml;hig. Das Programm wieder schlie&szlig;en u!
 nd die Funktion &uuml;berpr&uuml;fen, indem eines der beiligen!
 den Prog
ramme (z.B. Solitaire) gestartet wird.</p></li></ul></div></li><li><p>Die entsprechende CacheWolf .zip-Datei auf dem PC entpacken.</p></li><li><p>Die ganzen Dateien dann auf den PocketPC in ein Verzeichnis deiner Wahl kopiert werden.</p></li><li><p>Nach dem Kopieren wird CacheWolf durch Klick auf die Cachewolf.exe gestartet.</p></li></ul></div><p></p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e111"></a>1.1.3.1.&nbsp;Wichtige Information zur Nutzung von GPS Empf&auml;ngern</h4></div></div></div><p>Bevor der Cachewolf sauber l&auml;uft gilt es, je nach PDA ein paar Hindernisse zu umschiffen (die aber nicht vom CW stammen!).</p><div class="orderedlist"><ol type="1"><li><p><span class="bold"><strong>Zugriff auf GPS:</strong></span> Solltest du neben dem CW noch weitere Software einsetzen (z.B. Navi-Software), die Zugriff auf das GPS haben will so kann es (je nach Software und PDA) vorkommen dass diese Software - einmal gestartet !
 - den Zugriff auf das GPS exklusiv nimmt und andere Programme das nachsehen haben (auch wenn z.B. die Navi-Software gerade nicht mehr l&auml;uft!) \\ Die L&ouml;sung besteht darin, das GPS-Signal zu splitten, was beispielsweise der VirtCommMgr kann.</p></li><li><p><span class="bold"><strong>Static Navigation:</strong></span> dies bezeichnet ein "Feature" f&uuml;r Navis, die die Routenf&uuml;hrung aussetzt wenn man sich langsamer als 6 km/h bewegt. F&uuml;rs cachen nat&uuml;rlich etwas doof, aber man kann es (ohne Nebenwirkungen f&uuml;r Navi-Software) abschalten - z.B. mittels des Programms SirfTech.</p></li></ol></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e127"></a>1.1.4.&nbsp;Zaurus</h3></div></div></div><p>Wie auch beim PocketPC ist die Installation ein mehrstufiger Prozess.</p><div class="itemizedlist"><ul type="disc"><li><p>Zuerst muss die EWE VM (Virtual Machine) installiert werden: Download hier: <cod!
 e class="uri">http://www.ewesoft.com/Downloads/Downloads.html#!
 _Toc105<
/code></p></li><li><p>F&uuml;r den Zaurus existiert eine .ipk-Datei, womit die Installation recht einfach ist.</p></li><li><p>Danach muss der Inhalt der CacheWolf .zip-Datei in ein Verzeichnis deiner Wahl auf den Zaurus &uuml;bertragen werden.</p></li><li><p>Das Programm wird mit CacheWolf.ewe gestartet.</p></li></ul></div></div></div></div></div></body></html>
\ No newline at end of file

Added: trunk/docs/CacheWolf Doku/CacheWolf Dokumentation.xml
===================================================================
--- trunk/docs/CacheWolf Doku/CacheWolf Dokumentation.xml	2007-09-15 13:27:30 UTC (rev 919)
+++ trunk/docs/CacheWolf Doku/CacheWolf Dokumentation.xml	2007-09-15 20:06:08 UTC (rev 920)
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
+"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
+<!ENTITY __Installation__f6afn1eo SYSTEM "Installation.xml">
+<!ENTITY __DerersteStart__f6anus0g SYSTEM "Der%20erste%20Start.xml">
+<!ENTITY __ansichten__f6anvxip SYSTEM "ansichten.xml">
+]>
+<book>
+  <title>CacheWolf Dokumentation</title>
+
+  &__Installation__f6afn1eo;
+
+  &__DerersteStart__f6anus0g;
+
+  &__ansichten__f6anvxip;
+</book>
\ No newline at end of file

Added: trunk/docs/CacheWolf Doku/Der erste Start.xml
===================================================================
--- trunk/docs/CacheWolf Doku/Der erste Start.xml	2007-09-15 13:27:30 UTC (rev 919)
+++ trunk/docs/CacheWolf Doku/Der erste Start.xml	2007-09-15 20:06:08 UTC (rev 920)
@@ -0,0 +1,97 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<chapter>
+  <chapterinfo>
+    <date>7.9.2007</date>
+
+    <releaseinfo>In Bearbeitung</releaseinfo>
+
+    <edition>CacheWolf 1.0</edition>
+
+    <author>
+      <surname>Marc Schnitzler</surname>
+    </author>
+
+    <revhistory>
+      <revision>
+        <revnumber>0.1</revnumber>
+
+        <date>7. September 2007</date>
+
+        <author>
+          <surname>Marc Schnitzler</surname>
+        </author>
+
+        <revdescription>
+          <para>Erster Entwurf, kopiert www.cachewolf.de</para>
+        </revdescription>
+      </revision>
+    </revhistory>
+  </chapterinfo>
+
+  <title>Der erste Start</title>
+
+  <section>
+    <title>Programmstart</title>
+
+    <para>Wenn man CacheWolf zum ersten Mal startet, erscheint erst folgendes
+    Bild:</para>
+
+    <para><warning>
+        <para>Bild fehlt</para>
+      </warning>kurz darauf der Dateidialog</para>
+
+    <para><warning>
+        <para>Bild fehlt</para>
+      </warning>Dieser fordert dich nun auf, ein Basisverzeichnis auszuw?hlen
+    f?r die noch kommenden Cache-Daten. Die Idee dahinter ist folgende: In
+    diesem Verzeichnis kannst du beliebig viele Unterordner anlegen; jeder
+    dieser ordner ist ein eigenes Profil (kommt noch!) innerhalb des
+    Cachewolf.</para>
+
+    <tip>
+      <para>Auf einem PocketPC kannst du dieses Verzeichnis auf die
+      Speicherkarte legen (den CW am besten auf dem Ger?t oder der Flash-Disk
+      ablegen).</para>
+    </tip>
+
+    <para>W?hle nun ein Verzeichnis aus und best?tige mit <literal>Select
+    Folder</literal></para>
+  </section>
+
+  <section>
+    <title>Einstellen der Pr?ferenzen</title>
+
+    <para>Es erscheint nun ein bisher leeres Fenster, die
+    Listenansicht:</para>
+
+    <para>Keine Angst, wir f?llen dieses gleich... </para>
+
+    <para>Doch zuerst einmal w?hle den Men?punkt <literal>Anwendung -
+    Pr?ferenzen</literal>, hier stellen wir nun ein paar grunds?tzliche Dinge
+    ein: </para>
+  </section>
+
+  <section>
+    <title>Cachedaten bekommen</title>
+
+    <para></para>
+
+    <section>
+      <title>Import einer GPX - Datei</title>
+
+      <para></para>
+    </section>
+
+    <section>
+      <title>Import einer LOC - Datei</title>
+
+      <para></para>
+    </section>
+
+    <section>
+      <title>Direktes herunterladen (spidern)</title>
+
+      <para></para>
+    </section>
+  </section>
+</chapter>
\ No newline at end of file

Added: trunk/docs/CacheWolf Doku/Installation.xml
===================================================================
--- trunk/docs/CacheWolf Doku/Installation.xml	2007-09-15 13:27:30 UTC (rev 919)
+++ trunk/docs/CacheWolf Doku/Installation.xml	2007-09-15 20:06:08 UTC (rev 920)
@@ -0,0 +1,227 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<chapter>
+  <chapterinfo>
+    <date>7.9.2007</date>
+
+    <releaseinfo>Review f?r Freigabe</releaseinfo>
+
+    <edition>CacheWolf 1.0</edition>
+
+    <author>
+      <surname>Marc Schnitzler</surname>
+    </author>
+
+    <revhistory>
+      <revision>
+        <revnumber>0.1</revnumber>
+
+        <date>7. September 2007</date>
+
+        <author>
+          <surname>Marc Schnitzler</surname>
+        </author>
+
+        <revdescription>
+          <para>Erster Entwurf, kopiert www.cachewolf.de</para>
+        </revdescription>
+      </revision>
+    </revhistory>
+  </chapterinfo>
+
+  <title>Installation</title>
+
+  <para>Cachewolf ist verf?gbar in verschiedenen Versionen f?r Windows, Linux,
+  PocketPC (ARM/PPC) und Zaurus. Die prim?re Downloadseite ist BerliOS, als
+  Alternative kannst du dir den Cachewolf auch direkt unter
+  <uri>http://www.cachewolf.de/wiki/pmwiki.php/Main/Download</uri>
+  herunterladen.</para>
+
+  <section>
+    <title>Welche Cachewolf - Version f?r was?</title>
+
+    <para></para>
+
+    <section>
+      <title>Windows</title>
+
+      <para>Hier ist die Installation sehr einfach. Einfach die .zip-Datei in
+      ein Verzeichnis Deiner Wahl entpacken. Durch einen Doppelklick auf das
+      CacheWolf Icon startet das Programm. </para>
+    </section>
+
+    <section>
+      <title>Java</title>
+
+      <para>F?r den Einsatz der Java-Version ben?tigst du eine Java-Runtime in
+      der Version 1.5 oder h?her. Diese bekommst du entweder direkt bei Sun
+      oder ?ber die Linux-eigene Paketverwaltung (SuSE: YaST, Debian:
+      apt-get,...).</para>
+
+      <para> ?ber die Kommandozeile startest du das Programm mittels:
+      <literal>java -jar "/Pfadzucachewolf/CacheWolf.jar" &amp;</literal>
+      </para>
+    </section>
+
+    <section>
+      <title>Pocket PC</title>
+
+      <para>Der Cachewolf l?uft auf PocketPC's ?ber eine sogenannte virtuelle
+      Maschine (EWE VM). Diese stellt die Grundlage aller Funktionen des CW
+      dar und dadurch l?uft er auf fast allen PocketPC's.</para>
+
+      <para>Es existieren zwei optimierte Versionen von Cachewolf f?r den
+      PocketPC: f?r Ger?te mit ARM-Prozessor und f?r Ger?te mit
+      Intel-Prozessor. Welche Version ben?tigt wird, kann man auch durch
+      Probieren ermitteln. (Teilweise laufen auch beide Versionen.)</para>
+
+      <para>CacheWolf erkennt ?brigens VGA-Ger?te und stellt die Aufl?sung
+      entsprechend ein.</para>
+
+      <highlights>
+        <para>Aus der FAQ:</para>
+
+        <para>Frage 3: Welche Version von CacheWolf ist die richtige f?r mein
+        Pocket PC? </para>
+
+        <para>Antwort: Diese Frage ist leider nicht so einfach zu beantworten.
+        </para>
+
+        <para>Auf dieser Seite www.pocketpc-users.de gibt es eine sehr gute
+        Beschreibung. </para>
+
+        <para>Vielleicht hilft aber folgende (kurze) Zusammenfassung: </para>
+
+        <para>* Hast Du ein Pocket PC 2000 Ger?t, dann benutzt es
+        wahrscheinlich einen ARM (kompatiblen) Prozessor. Es gibt allerdings
+        Ausnahmen, die einen SH3 oder MIPS Prozessor nutzen. </para>
+
+        <para>* Pocket PC 2002 und 2003 Ger?te nutzen ausschlie? einen ARM
+        (kompatiblen) Prozessor. </para>
+
+        <para>* Hast Du eine Ger?t, da? Du in der zweiten H?lfte 2004 gekauft
+        hast, dann solltest Du die "PocketPC" Version von CacheWolf
+        installieren. Beispiele (von Nutzern): PocketPCArm: XDA Trion,
+        ASUS632,Yakumo Delta GPS, Loox N520, Compaq IPAQ 6915, Medion
+        MDPPC250, FSC Loox N560, Dell Axim X51V, Yakumo DeltaX5BT, Acer N35
+        PocketPC: Loox N520, Mio Digi Walker P550 Zaurus: Sharp SL-C1000
+        </para>
+
+        <para>Sagt dir das alles gar nichts probier einfach die Versionen
+        durch - eine wird auf jeden Fall funktionieren!</para>
+      </highlights>
+
+      <para>Die Installation ist ein mehrstufiger Prozess:</para>
+
+      <itemizedlist>
+        <listitem>
+          <para>Zuerst muss die EWE VM (Virtual Machine) installiert
+          werden:</para>
+
+          <itemizedlist>
+            <listitem>
+              <para>EWE VM unter
+              <uri>http://www.ewesoft.com/Downloads/Downloads.html#_Toc105819897</uri>
+              herunterladen.</para>
+
+              <para>Hier darauf achten, die richtige Version ("Low Resolution"
+              f?r normale PDA's oder "High Resolution" f?r VGA-PDA's zu
+              laden.</para>
+            </listitem>
+
+            <listitem>
+              <para>Installation der VM wie unter dem Download Link
+              beschrieben: die cab-Datei auf den PDA ?bertragen (mittels
+              Speicherkarte oder ActiveSync) und dann auf dem PDA
+              ausf?hren.</para>
+            </listitem>
+
+            <listitem>
+              <para>Nach erfolgter Installation unter Start -&gt; Programme
+              -&gt; EWE das Programm EWE starten. Damit werden noch notwendige
+              Systemeintr?ge gemacht und die VM ist nun funktionsf?hig. Das
+              Programm wieder schlie?en und die Funktion ?berpr?fen, indem
+              eines der beiligenden Programme (z.B. Solitaire) gestartet
+              wird.</para>
+            </listitem>
+          </itemizedlist>
+        </listitem>
+
+        <listitem>
+          <para>Die entsprechende CacheWolf .zip-Datei auf dem PC
+          entpacken.</para>
+        </listitem>
+
+        <listitem>
+          <para>Die ganzen Dateien dann auf den PocketPC in ein Verzeichnis
+          deiner Wahl kopiert werden.</para>
+        </listitem>
+
+        <listitem>
+          <para>Nach dem Kopieren wird CacheWolf durch Klick auf die
+          Cachewolf.exe gestartet.</para>
+        </listitem>
+      </itemizedlist>
+
+      <para></para>
+
+      <section>
+        <title>Wichtige Information zur Nutzung von GPS Empf?ngern</title>
+
+        <para>Bevor der Cachewolf sauber l?uft gilt es, je nach PDA ein paar
+        Hindernisse zu umschiffen (die aber nicht vom CW stammen!).</para>
+
+        <orderedlist>
+          <listitem>
+            <para><emphasis role="bold">Zugriff auf GPS:</emphasis> Solltest
+            du neben dem CW noch weitere Software einsetzen (z.B.
+            Navi-Software), die Zugriff auf das GPS haben will so kann es (je
+            nach Software und PDA) vorkommen dass diese Software - einmal
+            gestartet - den Zugriff auf das GPS exklusiv nimmt und andere
+            Programme das nachsehen haben (auch wenn z.B. die Navi-Software
+            gerade nicht mehr l?uft!) \\ Die L?sung besteht darin, das
+            GPS-Signal zu splitten, was beispielsweise der VirtCommMgr
+            kann.</para>
+          </listitem>
+
+          <listitem>
+            <para><emphasis role="bold">Static Navigation:</emphasis> dies
+            bezeichnet ein "Feature" f?r Navis, die die Routenf?hrung aussetzt
+            wenn man sich langsamer als 6 km/h bewegt. F?rs cachen nat?rlich
+            etwas doof, aber man kann es (ohne Nebenwirkungen f?r
+            Navi-Software) abschalten - z.B. mittels des Programms
+            SirfTech.</para>
+          </listitem>
+        </orderedlist>
+      </section>
+    </section>
+
+    <section>
+      <title>Zaurus</title>
+
+      <para>Wie auch beim PocketPC ist die Installation ein mehrstufiger
+      Prozess.</para>
+
+      <itemizedlist>
+        <listitem>
+          <para>Zuerst muss die EWE VM (Virtual Machine) installiert werden:
+          Download hier:
+          <uri>http://www.ewesoft.com/Downloads/Downloads.html#_Toc105</uri></para>
+        </listitem>
+
+        <listitem>
+          <para>F?r den Zaurus existiert eine .ipk-Datei, womit die
+          Installation recht einfach ist.</para>
+        </listitem>
+
+        <listitem>
+          <para>Danach muss der Inhalt der CacheWolf .zip-Datei in ein
+          Verzeichnis deiner Wahl auf den Zaurus ?bertragen werden.</para>
+        </listitem>
+
+        <listitem>
+          <para>Das Programm wird mit CacheWolf.ewe gestartet.</para>
+        </listitem>
+      </itemizedlist>
+    </section>
+  </section>
+</chapter>
\ No newline at end of file

Added: trunk/docs/CacheWolf Doku/ansichten.xml
===================================================================
--- trunk/docs/CacheWolf Doku/ansichten.xml	2007-09-15 13:27:30 UTC (rev 919)
+++ trunk/docs/CacheWolf Doku/ansichten.xml	2007-09-15 20:06:08 UTC (rev 920)
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<chapter>
+  <title>Ansichten</title>
+
+  <xi:include href="ansichten_liste.xml"
+              xmlns:xi="http://www.w3.org/2001/XInclude" />
+</chapter>
\ No newline at end of file

Added: trunk/docs/CacheWolf Doku/ansichten_liste.xml
===================================================================
--- trunk/docs/CacheWolf Doku/ansichten_liste.xml	2007-09-15 13:27:30 UTC (rev 919)
+++ trunk/docs/CacheWolf Doku/ansichten_liste.xml	2007-09-15 20:06:08 UTC (rev 920)
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<section>
+  <sectioninfo>
+    <date>7.9.2007</date>
+
+    <releaseinfo>In Bearbeitung</releaseinfo>
+
+    <edition>CacheWolf 1.0</edition>
+
+    <author>
+      <surname>Marc Schnitzler</surname>
+    </author>
+
+    <revhistory>
+      <revision>
+        <revnumber>0.1</revnumber>
+
+        <date>7. September 2007</date>
+
+        <author>
+          <surname>Marc Schnitzler</surname>
+        </author>
+
+        <revdescription>
+          <para>Erster Entwurf, kopiert www.cachewolf.de</para>
+        </revdescription>
+      </revision>
+    </revhistory>
+  </sectioninfo>
+
+  <title>Liste</title>
+
+  <para></para>
+</section>
\ No newline at end of file

Added: trunk/docs/CacheWolf Doku/html.css
===================================================================
--- trunk/docs/CacheWolf Doku/html.css	2007-09-15 13:27:30 UTC (rev 919)
+++ trunk/docs/CacheWolf Doku/html.css	2007-09-15 20:06:08 UTC (rev 920)
@@ -0,0 +1,27 @@
+body { 
+    background: #FFFFFF; 
+}
+
+h1, h2, h3, h4, h5 { 
+    color: #800000; 
+    font-family: sans-serif; 
+}
+
+span.term { 
+    font-weight: bold; 
+}
+
+div.sidebar { 
+    background: #F0F0F0; 
+    border: 1px solid gray; 
+    padding: 5px; 
+    margin: 20px; 
+}
+
+pre.programlisting { 
+    background: #F0F0F0; 
+    border: 1px solid gray; 
+    padding: 2px; 
+    font-size: 10pt;
+    white-space: pre;
+}

Added: trunk/docs/CacheWolf Doku/images/callouts/1.png
===================================================================
(Binary files differ)


Property changes on: trunk/docs/CacheWolf Doku/images/callouts/1.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/docs/CacheWolf Doku/images/callouts/10.png
===================================================================
(Binary files differ)


Property changes on: trunk/docs/CacheWolf Doku/images/callouts/10.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/docs/CacheWolf Doku/images/callouts/11.png
===================================================================
(Binary files differ)


Property changes on: trunk/docs/CacheWolf Doku/images/callouts/11.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/docs/CacheWolf Doku/images/callouts/12.png
===================================================================
(Binary files differ)


Property changes on: trunk/docs/CacheWolf Doku/images/callouts/12.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/docs/CacheWolf Doku/images/callouts/13.png
===================================================================
(Binary files differ)


Property changes on: trunk/docs/CacheWolf Doku/images/callouts/13.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/docs/CacheWolf Doku/images/callouts/14.png
===================================================================
(Binary files differ)


Property changes on: trunk/docs/CacheWolf Doku/images/callouts/14.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/docs/CacheWolf Doku/images/callouts/15.png
===================================================================
(Binary files differ)


Property changes on: trunk/docs/CacheWolf Doku/images/callouts/15.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/docs/CacheWolf Doku/images/callouts/2.png
===================================================================
(Binary files differ)


Property changes on: trunk/docs/CacheWolf Doku/images/callouts/2.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/docs/CacheWolf Doku/images/callouts/3.png
===================================================================
(Binary files differ)


Property changes on: trunk/docs/CacheWolf Doku/images/callouts/3.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/docs/CacheWolf Doku/images/callouts/4.png
===================================================================
(Binary files differ)


Property changes on: trunk/docs/CacheWolf Doku/images/callouts/4.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/docs/CacheWolf Doku/images/callouts/5.png
===================================================================
(Binary files differ)


Property changes on: trunk/docs/CacheWolf Doku/images/callouts/5.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/docs/CacheWolf Doku/images/callouts/6.png
===================================================================
(Binary files differ)


Property changes on: trunk/docs/CacheWolf Doku/images/callouts/6.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/docs/CacheWolf Doku/images/callouts/7.png
===================================================================
(Binary files differ)


Property changes on: trunk/docs/CacheWolf Doku/images/callouts/7.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/docs/CacheWolf Doku/images/callouts/8.png
===================================================================
(Binary files differ)


Property changes on: trunk/docs/CacheWolf Doku/images/callouts/8.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/docs/CacheWolf Doku/images/callouts/9.png
===================================================================
(Binary files differ)


Property changes on: trunk/docs/CacheWolf Doku/images/callouts/9.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/docs/CacheWolf Doku/images/draft.png
===================================================================
(Binary files differ)


Property changes on: trunk/docs/CacheWolf Doku/images/draft.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From salzkammergut at mail.berlios.de  Sun Sep 16 19:55:58 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 16 Sep 2007 19:55:58 +0200
Subject: [Cachewolf-svn] r921 - trunk/src/CacheWolf
Message-ID: <200709161755.l8GHtwFS000856@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-16 19:55:56 +0200 (Sun, 16 Sep 2007)
New Revision: 921

Modified:
   trunk/src/CacheWolf/ImageDetailForm.java
   trunk/src/CacheWolf/ImageInteractivePanel.java
Log:
ImageInteractivePanel: Kleines Feature: Close Button im Kontextmenue (http://www.geoclub.de/ftopic18720.html).

Modified: trunk/src/CacheWolf/ImageDetailForm.java
===================================================================
--- trunk/src/CacheWolf/ImageDetailForm.java	2007-09-15 20:06:08 UTC (rev 920)
+++ trunk/src/CacheWolf/ImageDetailForm.java	2007-09-16 17:55:56 UTC (rev 921)
@@ -62,5 +62,11 @@
 			throw(t);
 		}
 	}
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent && ev.type==ControlEvent.EXITED) {
+			ev.consumed=true;
+			this.close(0);
+		} else super.onEvent(ev);
+	}
 }
 

Modified: trunk/src/CacheWolf/ImageInteractivePanel.java
===================================================================
--- trunk/src/CacheWolf/ImageInteractivePanel.java	2007-09-15 20:06:08 UTC (rev 920)
+++ trunk/src/CacheWolf/ImageInteractivePanel.java	2007-09-16 17:55:56 UTC (rev 921)
@@ -14,6 +14,8 @@
 	int scaleX = 0, scaleY = 0;
 	ScrollBarPanel scp;
 	String imgLoc = new String();
+	private Menu mClose = new Menu(new String[]{
+			"Close"},"");
 	
 	public void setParams(int state, int scaleX, int scaleY, int origH, int origW, ScrollBarPanel sp, String loc){
 		imgLoc = loc;
@@ -23,6 +25,7 @@
 		this.origH = origH;
 		this.origW = origW;
 		scp = sp;
+		setMenu(mClose);
 	}
 	
 	public void imageClicked(AniImage which, Point pos){
@@ -30,7 +33,7 @@
 			//Vm.debug("Hit and state -1!");
 			this.removeImage(which);
 			mImage mI = new mImage(imgLoc);
-			this.refresh();
+			//this.refresh();
 			which = new AniImage(mI);
 			this.addImage(which);
 			//this.setPreferredSize(origW, origH);
@@ -40,13 +43,22 @@
 		if(state == 1){
 			//Vm.debug("Hit and state 1!");
 			this.removeImage(which);
-			this.refresh();
+			//this.refresh();
 			which = new AniImage(which.scale(scaleX,scaleY,null,0));
 			this.addImage(which);
 			//this.setPreferredSize(b,h);
 			this.repaintNow();
 			scp.repaintNow();
 		}
-		if(state == -1) state = 1; else state = -1;
+		state = -state;
 	}
+	public void penRightReleased(Point p){
+			menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
+	}
+	public void penHeld(Point p){
+			menuState.doShowMenu(p,true,null); 
+	}
+	public void popupMenuEvent(Object selectedItem){
+		postEvent(new ControlEvent(ControlEvent.EXITED,this));
+	}
 }



From bilbowolf at mail.berlios.de  Sun Sep 16 22:16:26 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Sun, 16 Sep 2007 22:16:26 +0200
Subject: [Cachewolf-svn] r922 - trunk/resources
Message-ID: <200709162016.l8GKGQmj013892@sheep.berlios.de>

Author: bilbowolf
Date: 2007-09-16 22:16:24 +0200 (Sun, 16 Sep 2007)
New Revision: 922

Modified:
   trunk/resources/cachewolf.Languages.cfg
Log:
Holl??ndische ??bersetzung eingef??gt

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-09-16 17:55:56 UTC (rev 921)
+++ trunk/resources/cachewolf.Languages.cfg	2007-09-16 20:16:24 UTC (rev 922)
@@ -1090,5 +1090,544 @@
 		6105=Cygnus
 		6106=Mimosa in Southern Cross
 		{..}
+		{nl}
+		100=naar HTML
+		101=naar PCX5 MapSource
+		102=naar TOP50 ASCII
+		103=naar GPX
+		104=naar ASC
+		105=naar TomTom
+		106=naar MS AutoRoute CSV
+		107=Exporteren
+		108=Voorkeuren
+		109=Caches laden
+		110=Opslaan & Exit
+		111=Exit
+		112=Zoeken
+		113=Stop zoeken
+		114=Nieuw
+		115=Omkeren
+		116=Stoppen
+		117=Over
+		118=Wolflanguage
+		119=Zoeken naar:
+		120=Toepassing
+		121=Profiel
+		122=Naar Garmin
+		123=Naar CacheMate
+		124=Naar OZI
+		125=Naar Google Earth
+		126=Naar TomTom OV2
+		127=Opslaan
+		128=Via sjabloon
+		129=Importeren GPX
+		130=Download van opencaching.de
+		131=Werkgeheugen van geocaching.com
+		139=Beheren Travelbugs
+		140=Organiseren
+		141=Kopi?ren
+		142=Verplaatsen
+		143=Verwijderen
+		144=Waarschuwing
+		145=Cache data van ALLE GETOONDE caches worden verwijderd! Doorgaan?
+		146=Cache data van ALLE GETOONDE caches worden gekopieerd! Doorgaan?
+		147=Cache data van ALLE GETOONDE caches worden verplaatst! Doorgaan?
+		148=Selecteer doel map
+		149=Kaarten
+		150=Importeren
+		151=Kalibreren
+		152=Kaart importeren
+		153=Kaart importeren gelukt.
+		154=Fout bij importeren kaart.
+		155=Verklaring
+		156=Te weinig geheugen, kaart is te groot!
+		157=Systeem
+		158=Versie controle
+		159=Filter
+		161=Toon Blacklist
+		162=Gekalibreerde kaarten downloaden.
+		170=Selecteer basis map voor cache data.
+		171=Profiel bestaat niet:+
+		172=Fout: kan kaarten map niet maken:%0a.
+		173=GPSBabel:
+		174=Verkorte namen
+		175=Importeren
+		176=Nieuwe versie
+		177=Nieuwe versie%0abeschikbaar.
+		178=Versie controle
+		179=Je hebt de%0anieuwste versie.
+		180=Verplaats caches
+		181=Hier
+		182=Nieuwe lijst
+		183=Geladen lijst
+		184=Opslaan als
+		185=Opslaan (zonder bevestiging).
+		186=Additionele Waypoints mee verplaatsen.
+		187=Toon alleen deze Waypoints.
+		188=CACHE TOUR: NIEUW
+		189=Lijst toepassen
+		190=Toon alleen deze Waypoints.
+		191=Selecteer file
+		192=Wijzigingen opslaan
+		193=Additionele Waypoints toevoegen
+		195=Huidige middelpunt
+		196=Totaal aantal # caches (GC&OC)%0aTotaal # zichtbaar%0aTotaal # gevonden.
+		197=Toon/verberg cache tour.
+		198=Cache tour
+		199=Aan cache tour toevoegen.
+		200=Details
+		201=Beschrijving
+		202=Afbeeldingen
+		203=Hints & logs
+		204=Oplosser
+		205=Radar
+		206=Lijst
+		300=Type:
+		301=Grote:
+		302=Waypoint:
+		303=Naam:
+		304=Co?rdinaten:
+		305=Verborgen op:
+		306=Eigenaar:
+		307=Status:
+		308=Opmerkingen:
+		309=Selecteer als middelpunt.
+		310=Verwijder
+		311=Nieuw Waypoint
+		312=Opslaan
+		313=Vlag 1
+		314=Vlag 2
+		315=Vlag 3
+		316=Vlag 4
+		317=Zoeken
+		318=Gevonden
+		319=Niet gevonden
+		320=Eigenaar
+		321=Fout
+		322=Kan afbeelding/kaart niet vinden.
+		323=Fout bij schrijven van data.
+		324=-opnieuw?
+		325=Te weinig referentiepunten, kaart is niet gekalibreerd.
+		326=Geen gekalibreerde kaart aanwezig. %0aAub selecteer een schaal om de track en caches te tonen.
+		327=Notities
+		328=Gegevens gevonden
+		329=Verborgen op
+		340=Cache afbeeldingen
+		341=Eigen afbeeldingen
+		342=Verwijderd
+		343=Niet genoeg geheugen om cache afbeeldingen te laden.
+		344=Verwijder afbeeldingen
+		345=Ga naar deze co?rdinaten.
+		346=Toon Travelbugs
+		347=Toon kaart
+		348=Eigen afbeeldingen toevoegen.
+		349=Status Blacklist omkeren.
+		350=Tijdmarkering toevoegen aan notities.
+		351=Toevoegen/wijzigingen notities.
+		400=Decoderen
+		500=Omdraaien
+		591=Laat leeg voor standaard taal of%0avoeg 2 karakters toe voor taal, bv. DE,EN,NL
+		592=Taal(herstart noodzakelijk)
+		593=Password is optioneel.%0aAlleen gebruiken als je het wil opslaan in pref.xml.
+		594=Password
+		595=Lijst
+		596=Naam
+		597=Waypoint
+		598=Type
+		599=Checkbox
+		600=Voorkeuren
+		601=Jouw Nickname
+		602=Thuis co?rdinaten
+		603=Profiel map
+		604=Zoeken
+		605=Tabel kolommen
+		606=Moeilijkheidsgraad
+		607=Terrein
+		608=Co?rdinaten
+		609=Eigenaar
+		610=Verborgen op
+		611=Status
+		612=Afstand
+		613=Richting
+		614=Afbreken
+		615=Toepassen
+		616=Selecteer map
+		617=Plakken
+		618=Kopieer
+		619=Bloktekst
+		620=Opslaan
+		621=Algemeen
+		622=Scherm
+		623=Afbeeldingen:
+		624=Toon verwijderde afbeeldingen.
+		625=Scherm(herstart noodzakelijk)
+		626=Menu boven
+		627=Tabs boven
+		628=Status
+		629=Laatste profiel automatisch laden.
+		630=Hints/logs: logs per pagina.
+		631=PDA heeft stopknop.
+		632=Meer
+		633=Maximale logs naar werkgeheugen
+		700=Selecteer filter
+		701=Afstand
+		702=Moeilijkheidsgraad
+		703=Gevonden
+		704=Niet gevonden
+		705=In laatste
+		706=Gevonden
+		707=Eigenaar
+		708=Afbreken
+		709=Toepassen
+		710=Gearchiveerd
+		711=Niet beschikbaar
+		712=Selecteer route file.
+		713=Sla filter op.
+		714=Richting & afstand
+		715=Toon alle caches met status:
+		716=Deselecteer alles
+		717=Selecteer alles
+		718=Cache beoordeling
+		719=Cache type
+		720=Status
+		721=Richting
+		722=Beoordeling
+		723=Type
+		724=Container
+		725=Notities: Filters zijn aanpasbaar, actieve filter=groen.
+		726=Additionele Waypoints
+		727=Container
+		728=Additionele Waypoint
+		729=Niet gearchiveerd
+		730=Beschikbaar
+		731=Nog niet gevonden
+		732=Andere eigenaar
+		733=Additionele Waypoint
+		734=Geen hoofd Waypoint gevonden voor
+		735=Additionele Waypoints moeten het formaat hebben xxYYYY, waarbij xx 2 karakters zijn en YYYY de karakters achter GC van het hoofd Waypoint zijn.
+		800=Maak lijst
+		801=Zoeken.....
+		802=Caches gevonden. Zoeken......
+		803=Klaar!
+		804=Verzamelen van de cache gegevens.
+		805=Verzamel gegevens voor:
+		900=Lijst
+		901=Loc
+		902=Dichtstbijzijnde
+		903=Annuleer
+		904=Multi
+		905=Laad caches
+		906=Lijst van caches:
+		907=Maximale afstand:
+		908=Selecteer Waypoint file:
+		909=Selecteer file(s)
+		910=Selecteer sjabloon file
+		950=Verplaats
+		951=Zenden naar GPS
+		952=Converteren......
+		999=Not set
+		1000=D
+		1001=T
+		1002=Waypoint
+		1003=Naam
+		1004=Co?rdinaat
+		1005=Eigenaar
+		1006=Verborgen op
+		1007=Status
+		1008=Afstand
+		1009=Richting
+		1010=Ga hier naartoe.
+		1011=Niet geselecteerden uitfilteren.
+		1012=Verwijder geselecteerden
+		1013=Met selectie
+		1014=Update cache data
+		1015=Selecteer alles
+		1016=Deselecteer alles
+		1018=Toon offline in Browser.
+		1019=Zet deze als middelpunt.
+		1020=Toon online in Browser.
+		1021=Toon cachebeschrijving
+		1022=Verwijder alle caches die zijn aangevinkt.
+		1023=Deze functie is momenteel alleen beschikbaar voor geocaching.com.
+		1024=Afstand in lijst is~ten opzichte van de huidige positie~herberekend.
+		1025=Kan middelpunt niet toepassen (verkeerde GPS co?rdinaten).
+		1100=Profielen
+		1105=Bladeren
+		1106=Kies profiel of nieuw.
+		1107=Nieuw profiel
+		1108=Kies profiel
+		1109=Open profiel
+		1110=Middelpunt
+		1111=Maak een nieuw profiel.
+		1112=Naam nieuw profiel.
+		1113=Kan geen map maken (mag geen karakters hebben die niet door het OS worden geaccepteerd).
+		1114=Map bestaat al
+		1115=Middelpunt
+		1116=Huidig
+		1117=Kopie
+		1118=Profiel
+		1119=Oude profielen
+		1120=Moeilijkheidsgraad
+		1121=Terrein
+		1200=Lijst
+		1201=Details
+		1202=Beschrijving
+		1203=Afbeeldingen
+		1204=Hints & logs
+		1205=Oplosser
+		1206=Calculator
+		1207=Jouw profiel is veranderd, wil je het profiel opslaan?
+		1300=Laatste instellingen
+		1301=Selecteer profiel
+		1400=Zone
+		1401=Noordelijk	
+		1402=Oostelijk
+		1403=Richting
+		1404=Afstand
+		1405=Om co?rdinaten te laden van GC, geef onder in GCxxxx.
+		1406=Geef co?rdinaten in (alle formaten mogelijk) of GCxxxx.
+		1500=Doel:
+		1501=Huidig
+		1502=Graden
+		1503=Noord voor
+		1600=Download van Opencaching.de 
+		1601=Afstand:
+		1602=Download afbeeldingen
+		1603=Download kaarten
+		1604=Annuleren
+		1605=OK
+		1606=Redownload alles
+		1607=Update van Opencaching.de is gelukt.
+		1608=Download data van Opencaching.de.
+		1609=Importeren cache
+		1610=Download missende kaart.
+		1611=Import cache beschrijving.
+		1612=Import log
+		1613=Import afbeelding
+		1614=Fout bij het unzippen van update file.
+		1615=Fout bij het interpreteren van update file, status:
+		1616=Fout: Kan de update file niet downloaden van Opencaching.de.
+		1617=Negeert fout in html-cache-beschrijving:"<img" without "src=" in cache+
+		1618=Negeert fout in cache:+
+		1619=: kon de afbeelding van URL niet downloaden:+	
+		1620=download bijgesloten afbeeldingen:+
+		1621=Fout tijdens interpreteren data%0a van Opencaching.de,%0aDit is vermoedelijk een fout bij Opencaching.de%0aprobeer later nogmaals%0aStatus:
+		1700=Fout in lijn:
+		1701=Positie:
+		1702=Variabele niet gedefinieerd.
+		1703=Geen geldig nummer.
+		1704=Plotseling eind van zoekopdracht.
+		1705=Geen ENDIF
+		1706=Verwacht:
+		1707=Gevonden:
+		1708=Geen eensluidende functienaam:
+		1709=Onbekende functie:
+		1710=Kan de lege string niet tellen.
+		1711=Gekopieerde karakter strings moeten van dezelfde lengte zijn.
+		1712=Ongeldige co?rdinaten:
+		1713=Ongeldig co?rdinaat formaat. Toegestaan zijn CW/DD/DMM/DMS/UTM
+		1714=Ga naar: Waypoint bestaat niet:
+		1715=Instr: Start co?rdinaat niet in string.
+		1716=Mid: Geheel getal verwacht.
+		1717=Mid: Argument valt buiten de range.
+		1718=Kan geen negatieve afstand projecteren.
+		1719=Projectiehoek moet liggen tussen 0 en 360.
+		1720=Kan niet rekenen met negatieve getallen.
+		1723=Vergelijking van operator verwacht.
+		1724=Variabele niet benoemd.
+		1725=Onverwachte karakter(s)
+		1726=Te veel argumenten voor deze functie.
+		1727=Ongeldig aantal argumenten.
+		1728=Functie niet ge?mplementeerd.
+		1729=Deling door 0.
+		1730=Oneindige string
+		1731=Ongeldig formaat karakters.
+		1732=Ongeldige karakter
+		1733=Opdracht ingeven
+		1734=Verwijder ingaven
+		1735=Oplossen!
+		1736=Laden
+		1737=Opslaan
+		1738=Opslaan als
+		1800=Downloaden GEO gerelateerde kaarten.
+		1801=Downloaden tegels
+		2000=Exporten GPX
+		2001=Van
+		2500=Fout bij laden of onbekende pictogrammen.
+		2501=Geen 24/7 cache
+		2502=Beschikbaar 24/7
+		2503=Geen fietsen
+		2504=Fietsen toegestaan
+		2505=*geen boten
+		2506=*boten toegestaan
+		2507=*geen cactus
+		2508=*cactus aanwezig
+		2509=Geen kampvuur
+		2510=Kampvuur toegestaan
+		2511=Niet kamperen
+		2512=Kamperen toegestaan
+		2513=*geen kliffen
+		2514=Vallende rotsen nabij.
+		2515=Geen moeilijke klimpartijen.
+		2516=Moeilijke klimpartijen
+		2517=*geen kompas
+		2518=*kompas toegestaan
+		2519=*geen koeien
+		2520=Let op ongedierte
+		2521=*geen gevaar
+		2522=Gevaarlijk gebied
+		2523=Geen honden
+		2524=Honden toegestaan
+		2525=*geen kosten
+		2526=Toegaan/parkeer kosten
+		2527=*geen wandeling
+		2528=Aanmerkelijke wandeling
+		2529=Geen paarden
+		2530=Paarden toegestaan
+		2531=*geen jagen
+		2532=Jachtgebied.
+		2533=Geen terreinwagens
+		2534=Terreinwagens toegestaan
+		2535=Kind onvriendelijk
+		2536=Kind vriendelijk
+		2537=*mijnen 
+		2538=*geen mijnen
+		2539=Geen motorfietsen
+		2540=Motorfietsen toegestaan
+		2541=Niet aanbevolen tijdens donker
+		2542=Nacht cache
+		2543=Duurt langer dan 1 uur
+		2544=Duurt korter dan 1 uur
+		2545=*geen parkeerplaats
+		2546=Parkeerplaats aanwezig
+		2547=*geen telefoon
+		2548=Telefoon dichtbij
+		2549=*picknicken verboden
+		2550=Picknicken toegestaan
+		2551=*geen gifeik
+		2552=*wel gifeik
+		2553=*geen openbaarvervoer
+		2554=Openbaarvervoer aanwezig
+		2555=Geen quads
+		2556=Quads toegestaan
+		2557=*geen abseilen
+		2558=Klimmiddelen nodig
+		2559=*geen overnachting
+		2560=Overnachting aanwezig
+		2561=*geen pittoresk uitzicht
+		2562=Pittoresk uitzicht
+		2563=*geen duikuitrusting
+		2564=Duikuitrusting nodig
+		2565=*geen haaien
+		2566=*haaien aanwezig
+		2567=*geen sneeuwvoertuigen
+		2568=*sneeuwvoertuigen toegestaan
+		2569=Stiekemheid niet nodig
+		2570=Stiekemheid geboden 
+		2571=Kinderwagen onvriendelijk
+		2572=Kinderwagen vriendelijk
+		2573=*geen zwemmen
+		2574=*zwemmen noodzakelijk
+		2575=*geen doorns
+		2576=Doorns
+		2577=*geen teken
+		2578=Teken
+		2579=*geen waden
+		2580=Waden is mogelijk
+		2581=*geen water
+		2582=Drinkbaar water in de buurt
+		2583=Rolstoel onvriendelijk
+		2584=Rolstoel vriendelijk
+		2585=Niet beschikbaar in de winter
+		2586=In de winter beschikbaar
+		2587=Onderhoud noodzakelijk
+		2588=Geen onderhoud nodig
+		3000=Sluiten
+		4000=Geladen caches
+		4101=Kaarten
+		4102=Gekalibreerde kaarten
+		4103=Niet gekalibreerde kaarten
+		4104=Wijzigen
+		4105=Laden
+		4106=Kalibreert kaart
+		4107=Gebeurt!
+		4108=Co?rdinaten:
+		4109=bezig kaarten te laden..
+		4110=Bezig met laden
+		4111=Co?rdinaten moeten in dit formaat worden ingegeven N XX XX.XXX E XXX XX.XXX.
+		4200=Kies kaarten map
+		4500=Tot:
+		4501=Vis:
+		4502=Fnd:
+		4600=Sommige caches kunnen niet worden getoond door verkeerde blacklist status.
+		5000=Laad cache lijst
+		5497=Fout, verdwenen tag in spider.def.
+		5498=Login fout. Fout bij het laden van de pagina na login.
+		5499=Fout bij het laden van de login pagina.
+		5500=Fout
+		5501=Login mislukt! Verkeerde accountnaam of password
+		5502=Ophalen eerste pagina.
+		5503=Fout bij ophalen eerste pagina.
+		5504=Kon 'spider.def' niet laden
+		5505=Geef password in
+		5506=Password
+		5507=Status
+		5508=Bezig met inloggen...
+		5509=Co?rdinaten voor middelpunt moeten worden ingegeven.
+		5510=Spider options
+		5511=Gevonden+
+		5512=+caches
+		5513=Bezig met laden:+
+		5514=%0aTravelbug
+		6000=Guid
+		6001=Naam
+		6002=Track#
+		6003=Doel
+		6004=Van profiel
+		6005=Van Waypoint
+		6006=Van datum
+		6007=Van log
+		6008=Naar profiel
+		6009=Naar Waypoint
+		6010=Naar datum
+		6011=Naar log
+		6015=***ANDER***
+		6016=Retrieve Travelbug
+		6017=Drop Travelbug
+		6018=Naam Travelbug
+		6019=Tracking nummer
+		6020=Travelbug niet gevonden
+		6021=Meer dan ??n Travelbug gevonden. Specificeer de namen duidelijker.
+		6022=:Huidige cache:+
+		6025=Naam:
+		6026=Tracking #:
+		6027=Id/Guid:
+		6028=Naam
+		6029=Profiel/cache:
+		6030=Datum gevonden:
+		6031=Gelogd
+		6032=Van
+		6033=Datum gedropt
+		6034=Naar
+		6035=Doel:
+		6036=Doel
+		6040=Retrieve Travelbug uit huidige cache.
+		6041=Travelbug in cache gedropt.
+		6042=Nieuwe Travelbug
+		6043=Verwijder Travelbug
+		6044=Toon doel
+		6045=Toon online
+		6046=Toon alleen gelogd.
+		6047=Verwijder geselecteerde Travelbugs.
+		6050=Toon kolom
+		6051=Toon kolom niet.
+		6100=Zon
+		6101=Maan
+		6102=Grote Beer
+		6103=Orion
+		6104=Cassiopeia
+		6105=Zwaan
+		6106=Zuiderkruis
+		{..}
 	{..}
 {..}



From bilbowolf at mail.berlios.de  Sun Sep 16 22:20:36 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Sun, 16 Sep 2007 22:20:36 +0200
Subject: [Cachewolf-svn] r923 - trunk/resources
Message-ID: <200709162020.l8GKKarW014124@sheep.berlios.de>

Author: bilbowolf
Date: 2007-09-16 22:20:35 +0200 (Sun, 16 Sep 2007)
New Revision: 923

Modified:
   trunk/resources/cachewolf.Languages.cfg
Log:
Kleines update in nl ??bersetzung

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-09-16 20:16:24 UTC (rev 922)
+++ trunk/resources/cachewolf.Languages.cfg	2007-09-16 20:20:35 UTC (rev 923)
@@ -1380,8 +1380,8 @@
 		1300=Laatste instellingen
 		1301=Selecteer profiel
 		1400=Zone
-		1401=Noordelijk	
-		1402=Oostelijk
+		1401=Northing	
+		1402=Easting
 		1403=Richting
 		1404=Afstand
 		1405=Om co?rdinaten te laden van GC, geef onder in GCxxxx.



From salzkammergut at mail.berlios.de  Sun Sep 16 22:25:20 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 16 Sep 2007 22:25:20 +0200
Subject: [Cachewolf-svn] r924 - trunk/src/CacheWolf
Message-ID: <200709162025.l8GKPKp7014395@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-16 22:25:15 +0200 (Sun, 16 Sep 2007)
New Revision: 924

Modified:
   trunk/src/CacheWolf/myTableControl.java
Log:
myTableControl: ProgressBar wenn Caches ueber das Kontextmenue geloescht werden.
Grund: Beim Loeschen von mehreren Caches war das Gui aktiv, man konnte also gleichzeitig andere Aktivitaetetn starten wie z.B. Sortierung. Das fuehrt gelegentlich zu Exceptions. Durch den ProgressBar ist das nicht moeglich. Wenn das ProgressBarForm geschlossen wird, wird das Loeschen abgebrochen. 

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-09-16 20:20:35 UTC (rev 923)
+++ trunk/src/CacheWolf/myTableControl.java	2007-09-16 20:25:15 UTC (rev 924)
@@ -123,19 +123,37 @@
 			tbp.refreshTable();
 		}
 		if (selectedItem.toString().equals(MyLocale.getMsg(1012,"Delete"))){
-			if ((new MessageBox(MyLocale.getMsg(144,"Warnung"),MyLocale.getMsg(1022, "Delete all caches that have a tick?"), MessageBox.YESB | MessageBox.NOB)).execute() != Form.IDYES) return;
-			DataMover dm=new DataMover();
 			Vm.showWait(true);
+			// Count # of caches to delete
+			int count=0;
 			for(int i = cacheDB.size()-1; i >=0; i--){
-				ch = (CacheHolder)cacheDB.get(i);
-				if(ch.is_Checked == true) {
-					dm.deleteCacheFiles(ch.wayPoint,profile.dataDir);
-					cacheDB.remove(ch);
+				if ( ((CacheHolder)cacheDB.get(i)).is_Checked) count++;
+			}
+			if (count>0) {
+				if ((new MessageBox(MyLocale.getMsg(144,"Warnung"),MyLocale.getMsg(1022, "Delete all caches that have a tick?"), MessageBox.YESB | MessageBox.NOB)).execute() != Form.IDYES) return;
+				DataMover dm=new DataMover();
+				myProgressBarForm pbf = new myProgressBarForm();
+				Handle h = new Handle();
+				pbf.setTask(h,MyLocale.getMsg(1012, "Delete selected"));
+				pbf.exec();
+				int nDeleted=0;
+				int size=cacheDB.size();
+				for(int i = 0; i <size; i++){
+					ch = (CacheHolder)cacheDB.get(i);
+					if(ch.is_Checked == true) {
+						nDeleted++;
+						h.progress = ((float)nDeleted)/(float)count;
+						h.changed();
+						dm.deleteCacheFiles(ch.wayPoint,profile.dataDir);
+						cacheDB.remove(ch);
+						if (pbf.isClosed) break;
+					}
 				}
+				pbf.exit(0);
+				profile.saveIndex(pref,true);	
+				tbp.refreshTable();
 			}
 			Vm.showWait(false);
-			profile.saveIndex(pref,true);	
-			tbp.refreshTable();
 		}
 
 		if (selectedItem.toString().equals(MyLocale.getMsg(1014,"Update"))){
@@ -326,4 +344,15 @@
 			}
 		}
 	 }
+	 
+	 class myProgressBarForm extends ProgressBarForm {
+
+		 boolean isClosed=false;
+		 
+		 protected boolean canExit(int exitCode) {
+			isClosed=true;
+			return true;
+		 }
+		 
+	 }
 }



From bilbowolf at mail.berlios.de  Sun Sep 16 22:35:07 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Sun, 16 Sep 2007 22:35:07 +0200
Subject: [Cachewolf-svn] r925 - trunk/src/CacheWolf
Message-ID: <200709162035.l8GKZ737014719@sheep.berlios.de>

Author: bilbowolf
Date: 2007-09-16 22:34:59 +0200 (Sun, 16 Sep 2007)
New Revision: 925

Modified:
   trunk/src/CacheWolf/Version.java
Log:
F?r eine neue BE :)

Modified: trunk/src/CacheWolf/Version.java
===================================================================
--- trunk/src/CacheWolf/Version.java	2007-09-16 20:25:15 UTC (rev 924)
+++ trunk/src/CacheWolf/Version.java	2007-09-16 20:34:59 UTC (rev 925)
@@ -10,7 +10,7 @@
 	static final String VER_MAJOR = "BE";
 	static final String VER_MINOR = "";
 	static final String VER_BUILD = " ";
-	static final String VER_SVN ="$LastChangedRevision$"; //the number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
+	static final String VER_SVN ="$LastChangedRevision$"; // the number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
 	
 	/**
 	 * @return



From pfeffer at mail.berlios.de  Tue Sep 18 00:40:00 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Tue, 18 Sep 2007 00:40:00 +0200
Subject: [Cachewolf-svn] r926 - trunk/src/CacheWolf/navi
Message-ID: <200709172240.l8HMe009002921@sheep.berlios.de>

Author: pfeffer
Date: 2007-09-18 00:39:52 +0200 (Tue, 18 Sep 2007)
New Revision: 926

Added:
   trunk/src/CacheWolf/navi/MapImporter.java
Modified:
   trunk/src/CacheWolf/navi/Area.java
   trunk/src/CacheWolf/navi/MapInfoObject.java
   trunk/src/CacheWolf/navi/MapsList.java
   trunk/src/CacheWolf/navi/MovingMap.java
Log:
MovingMap: rearanged the classes to be better prepared for upcoming changes

Modified: trunk/src/CacheWolf/navi/Area.java
===================================================================
--- trunk/src/CacheWolf/navi/Area.java	2007-09-16 20:34:59 UTC (rev 925)
+++ trunk/src/CacheWolf/navi/Area.java	2007-09-17 22:39:52 UTC (rev 926)
@@ -12,6 +12,11 @@
 
 	 CWPoint topleft;
 	 CWPoint buttomright;
+	 
+	 public Area() {
+		 topleft = new CWPoint();
+		 buttomright = new CWPoint();
+	 }
 
 	 public Area(CWPoint tl, CWPoint br){
 		 topleft = new CWPoint(tl);
@@ -30,7 +35,17 @@
 				 && buttomright.latDec <= lat && buttomright.lonDec >= lon) return true;
 		 else return false;
 	 }
+
+	/**
+	 * test if a is completly within this
+	 * @param a
+	 * @return
+	 */
+	 public boolean isInBound(Area a) {
+		 return (isInBound(a.topleft) && isInBound(a.buttomright));
+	 }
 	 
+	 
 	 public boolean isOverlapping(Area a) {
 		 if (       isInBound(a.topleft) || isInBound(a.buttomright) 
 				 || isInBound(a.buttomright.latDec, a.topleft.lonDec) // buttom left
@@ -71,4 +86,50 @@
 				 return AT_LEFT_EDGE;
 			 return NOT_ON_EDGE;
 	 }
+	 
+	 public String getEasyFindString() {
+		 String ul = getEasyFindString(topleft, 60);
+		 String br = getEasyFindString(buttomright, 60);
+		 int i;
+		 for (i=0; i<br.length(); i++ ) {
+			 if (ul.charAt(i) != br.charAt(i)) break;
+		 }
+		 ewe.sys.Vm.debug(ul+"\n"+br+"\n i:"+i);
+		 return ul.substring(0, i);
+	 }
+	 
+	 /**
+	  * 
+	  * @param prec number of digits to return, min 2, max: 63
+	  * @return
+	  */
+	 public static String getEasyFindString(CWPoint p, int prec) {
+		 double longinrange = p.lonDec;
+		 if (longinrange > 180) longinrange -= 180;
+		 Double kw = new Double(((p.latDec+90)/180) * (double) (1l << (prec)));
+		 Long lat = new Double(((p.latDec+90)/180) * (double) (1l << (prec))).longValue(); // TODO handle negative values
+		 lat = kw.longValue();
+		 kw = (double) (1l << (prec));
+		 
+		 kw = new Double(((longinrange+180)/360) * (2 ^ (prec -1)));
+		 Long lon = new Double(((longinrange+180)/360) * (double) (1l << (prec))).longValue(); // 180 = 10110100
+		 String ret = "";
+		 Long tmp;
+		 for (int i=prec-1; i>=0;  i--) {
+			 tmp = (1l << i);
+			 tmp = (lat & (1l << i));
+			 tmp = ((lat & (1l << i)) >> i);
+			 tmp = ((lon & (1l << i)) >> i) + (((lat & (1l << i) ) << 1) >> i);
+			 ret += tmp.toString();
+		 }
+/*		 Area cmp = new Area(new CWPoint (90,0), new CWPoint(-90,180));
+		 if (cmp.isInBound(this)) ret += "0";
+		 else ret += "1";
+		 int i;
+		 while (true) {
+			 for (i=0) 
+			 break;
+		 }
+	*/	 return ret;
+	 }
 }
\ No newline at end of file

Copied: trunk/src/CacheWolf/navi/MapImporter.java (from rev 925, trunk/src/CacheWolf/navi/Map.java)
===================================================================
--- trunk/src/CacheWolf/navi/Map.java	2007-09-16 20:34:59 UTC (rev 925)
+++ trunk/src/CacheWolf/navi/MapImporter.java	2007-09-17 22:39:52 UTC (rev 926)
@@ -0,0 +1,391 @@
+package CacheWolf.navi;
+
+import ewe.util.*;
+import ewe.io.*;
+import ewe.filechooser.*;
+import ewe.sys.*;
+import ewe.ui.*;
+import ewe.graphics.*;
+import ewe.fx.*;
+
+import CacheWolf.CWPoint;
+import CacheWolf.Common;
+import CacheWolf.CoordsScreen;
+import CacheWolf.Global;
+import CacheWolf.InfoBox;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+
+/**
+ *	This class is for importing and manually georeferencing maps
+ *	This class id=4100 for cachewolf-languages
+ */
+public class MapImporter extends Form {
+	Preferences pref;
+	String mapsPath = new String();
+	String thisMap = new String();
+	public String selectedMap = new String();
+	CellPanel infPanel;
+	mLabel infLabel = new mLabel("                          ");
+	Vector GCPs = new Vector();
+	MapInfoObject wfl = new MapInfoObject();
+	mButton infButton;
+	ScrollBarPanel scp;
+	AniImage mapImg;
+	int imageWidth, imageHeight = 0;
+
+	/**
+	 *	This constructor should be used when importing maps
+	 */
+	public MapImporter(Preferences pref){
+		this.pref = pref;
+		mapsPath = pref.getMapManuallySavePath(true)+"/"; //File.getProgramDirectory() + "/maps/";
+	}
+
+	/**
+	 *	When a user clicks on the map and more than three ground control points exist
+	 *	then the calculated coordinate based on the affine transformation is displayed in the
+	 *	info panel below the map.
+	 *	It helps to identify how good the georeferencing works based on the set GCPs.
+	 */
+	public void updatePosition(int x, int y){
+		if(GCPs.size()>=3  || (wfl.topleft.isValid())){
+			CWPoint p = wfl.calcLatLon(x,y);
+			infLabel.setText("--> " + p.getLatDeg(CWPoint.DMS) + " " +p.getLatMin(CWPoint.DMM) + " / " + p.getLonDeg(CWPoint.DMS) + " " + p.getLonMin(CWPoint.DMM));
+		}
+	}
+
+	/**
+	 *	This is the correct constructor for georeferencing maps.
+	 */
+	public MapImporter(Preferences pref, String mapToLoad, boolean worldfileexists){
+		this.pref = pref;
+		this.title = MyLocale.getMsg(4106,"Calibrate map:") + " " + mapToLoad;
+		this.resizable = true;
+		this.moveable = true;
+		//this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
+		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
+		thisMap = mapToLoad;
+		mapsPath = pref.getMapManuallySavePath(true)+"/"; //File.getProgramDirectory() + "/maps/"; // TDO veraltet
+		try {
+			wfl.loadwfl(mapsPath, thisMap);
+		}catch(FileNotFoundException ex){
+			//	Vm.debug("Cannot load world file!");
+		}catch (IOException ex) { // is thrown if lat/lon out of range
+			MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, "Error"), ex.getMessage(), MessageBox.OKB);
+			tmpMB.execute();
+			Vm.debug("Cannot load world file!");
+		}
+		mapInteractivePanel pane = new mapInteractivePanel(this);
+		scp = new ScrollBarPanel(pane);
+		Image img = new Image(Common.getImageName(mapsPath + thisMap));
+		PixelBuffer pB = new PixelBuffer(img);
+		//pB = pB.scale((int)(pref.myAppWidth*0.98),(int)(pref.myAppHeight*0.98));
+		mapImg = new AniImage(pB.toDrawableImage());
+		pane.addImage(mapImg);
+		scp.setPreferredSize(mapImg.getWidth(),mapImg.getHeight());
+		imageWidth = mapImg.getWidth();
+		imageHeight = mapImg.getHeight();
+		this.addLast(scp.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
+		infPanel = new CellPanel();
+		infPanel.addNext(infLabel,CellConstants.STRETCH, CellConstants.FILL);
+		infButton = new mButton(MyLocale.getMsg(4107,"Done!"));
+		infPanel.addLast(infButton,CellConstants.DONTSTRETCH, CellConstants.FILL);
+		this.addLast(infPanel, CellConstants.DONTSTRETCH, CellConstants.FILL);
+		//scp.repaintNow();
+		//this.repaintNow();
+	}
+
+	/**
+	 *	Add a ground control point to the list
+	 *	If the list is longer than 3 GCPs these will be evaluated
+	 *	to obtain the required parameters for the affine
+	 *	transformation.
+	 */
+	public void addGCP(GCPoint GCP){
+		if (GCP.latDec>90 || GCP.latDec<-90 || GCP.lonDec>360 || GCP.lonDec<-180) throw new IllegalArgumentException("lat/lon out of range: "+GCP.toString());
+		GCPs.add(GCP);
+		if(GCPs.size() >= 3){
+			wfl.evalGCP(GCPs, imageWidth, imageHeight);
+		}
+	}
+
+
+	/**
+	 *	Method to copy ("import") a png based map
+	 *	into the maps folder in the CacheWolf base directory.
+	 *	
+	 *	If the maps directory does not exist it will create it.
+	 *	If it finds .map files it will assume these are oziexplorer calibration files.
+	 *	It will use these files to automatically georeference the files during import.
+	 */
+	public int importMap(){
+		String rawFileName = new String();
+		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir);
+		fc.addMask("*.png,*.gif,*.bmp,*.jpg");
+		fc.setTitle((String)MyLocale.getMsg(4100,"Select Directory:"));
+		int tmp = fc.execute() ; 
+		if(tmp != FileChooser.IDYES) return Form.IDCANCEL;
+		File inDir = fc.getChosenFile();
+		File mapFile;
+		InfoBox inf = new InfoBox("Info", MyLocale.getMsg(4109,"Loading maps...            \n"), InfoBox.PROGRESS_WITH_WARNINGS, false); 
+		inf.setPreferredSize(220, 300);
+		inf.setInfoHeight(100);
+		inf.relayout(false);
+		Vm.showWait(this, true);
+		inf.exec();
+
+		//User selected a map, but maybe there are more png(s)
+		//copy all of them!
+		//at the same time try to find associated .map files!
+		//These are georeference files targeted for OziExplorer.
+		//So lets check if we have more than 1 png file:
+		String line = new String();
+		InputStream in = null;
+		OutputStream out = null;
+		FileReader inMap;
+		byte[] buf;
+		int len;
+		String[] parts;
+		String [] files = inDir.listMultiple("*.png,*.jpg,*.gif,*.bmp", File.LIST_FILES_ONLY);
+
+		String currfile = null;
+		String curInFullPath;
+		String curOutFullPath;
+		int num = files.length;
+		for(int i =  num -1 ; i >= 0;i--){
+			currfile = (String) files[i];
+			inf.setInfo(MyLocale.getMsg(4110,"Loading: ")+ "\n" + currfile + "\n("+(num-i)+"/"+num+")");
+			//Copy the file
+			//Vm.debug("Copy: " + inDir.getFullPath() + "/" +files[i]);
+			//Vm.debug("to: " + mapsPath + files[i]);
+			curInFullPath = inDir.getFullPath() + "/" +currfile;
+			curOutFullPath = mapsPath + currfile;
+			boolean imageerror = false;
+			try {
+				in = new FileInputStream(curInFullPath);
+				buf = new byte[1024*10];
+				boolean first = true;
+				ByteArray header = new ByteArray(buf);
+				while ((len = in.read(buf)) > 0) {
+					if (first) {
+						first = false;
+						header.copyFrom(buf, 0, len);
+						ImageInfo tmpII = Image.getImageInfo(header,null);
+						imageWidth = tmpII.width;
+						imageHeight = tmpII.height;
+						out = new FileOutputStream(curOutFullPath); // only create outfile if geImageInfo didn't throw an exception so do it only here not directly after opening input stream
+					}
+					out.write(buf, 0, len);
+				}
+			} catch(IOException ex){
+				imageerror = true;
+				inf.addWarning("\nIO-Error while copying image from: " + curInFullPath + " to: " + curOutFullPath + " error: " + ex.getMessage());
+			} catch (IllegalArgumentException e) { // thrown from Image.getImageInfo when it could not interprete the header (e.g. bmp with 32 bits per pixel)
+				imageerror = true;
+				inf.addWarning("\nError: could not decode image: " + curInFullPath + " - image not copied");
+			} finally {
+				try {
+					if (in != null) in.close();
+					if (out  != null) out.close(); 
+				} catch (Throwable e) {}
+			}
+			//Check for a .map file
+			rawFileName = currfile.substring(0, currfile.lastIndexOf("."));
+			mapFile = new File(inDir.getFullPath() + "/" + rawFileName + ".map");
+			if(!imageerror && mapFile.exists()){
+				GCPoint gcp1 = new GCPoint();
+				GCPoint gcp2 = new GCPoint();
+				GCPoint gcp3 = new GCPoint();
+				GCPoint gcp4 = new GCPoint();
+				GCPoint gcpG = new GCPoint();
+				//Vm.debug("Found file: " + inDir.getFullPath() + "/" + rawFileName + ".map");
+				try {
+					inMap = new FileReader(inDir.getFullPath() + "/" + rawFileName + ".map");
+					while((line = inMap.readLine()) != null){
+						if(line.equals("MMPNUM,4")){
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp1.bitMapX = Convert.toInt(parts[2]);
+							gcp1.bitMapY = Convert.toInt(parts[3]);
+							if(gcp1.bitMapX == 0) gcp1.bitMapX = 1;
+							if(gcp1.bitMapY == 0) gcp1.bitMapY = 1;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp2.bitMapX = Convert.toInt(parts[2]);
+							gcp2.bitMapY = Convert.toInt(parts[3]);
+							if(gcp2.bitMapX == 0) gcp2.bitMapX = 1;
+							if(gcp2.bitMapY == 0) gcp2.bitMapY = 1;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp3.bitMapX = Convert.toInt(parts[2]);
+							gcp3.bitMapY = Convert.toInt(parts[3]);
+							if(gcp3.bitMapX == 0) gcp3.bitMapX = 1;
+							if(gcp3.bitMapY == 0) gcp3.bitMapY = 1;
+							//imageWidth = gcp3.bitMapX;
+							//imageHeight = gcp3.bitMapY;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp4.bitMapX = Convert.toInt(parts[2]);
+							gcp4.bitMapY = Convert.toInt(parts[3]);
+							if(gcp4.bitMapX == 0) gcp4.bitMapX = 1;
+							if(gcp4.bitMapY == 0) gcp4.bitMapY = 1;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(pref.digSeparator.equals(",")) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp1.bitMapX;
+							gcpG.bitMapY = gcp1.bitMapY;
+							addGCP(gcpG);
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(pref.digSeparator.equals(",")) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp2.bitMapX;
+							gcpG.bitMapY = gcp2.bitMapY;
+							addGCP(gcpG);
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(pref.digSeparator.equals(",")) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp3.bitMapX;
+							gcpG.bitMapY = gcp3.bitMapY;
+							addGCP(gcpG);
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(pref.digSeparator.equals(",")) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp4.bitMapX;
+							gcpG.bitMapY = gcp4.bitMapY;
+							addGCP(gcpG);
+							/* already read from image file itself
+							// get dimensions of image
+							while ( (line = inMap.readLine()) != null){
+								if (line.startsWith("IWH")){
+									parts = mString.split(line, ',');
+									imageWidth = Convert.toInt(parts[2]);
+									imageHeight = Convert.toInt(parts[3]);
+								}
+							}
+							 */
+							wfl.evalGCP(GCPs, imageWidth, imageHeight);
+							//Vm.debug("Saving .map file to: " + mapsPath + "/" + rawFileName + ".wfl");
+							wfl.saveWFL(mapsPath, rawFileName);
+							GCPs.clear();
+						} // if
+
+					} // while
+					if (inMap != null)	inMap.close();
+				} catch(IllegalArgumentException ex){ // is thrown from Convert.toDouble and saveWFL if affine[0-5]==0 NumberFormatException is a subclass of IllegalArgumentExepction
+					inf.addWarning("\nError while importing .map-file: "+ex.getMessage());
+				} catch(IOException ex){
+					inf.addWarning("\nIO-Error while reading or writing calibration file\n" + ex.getMessage());
+				} 
+			} else { // if map file.exists
+				if (!imageerror) inf.addWarning("\nNo calibration file found for: " + currfile + " - you can calibrate it manually");
+			}
+		} // for file
+		Vm.showWait(this, false);
+		inf.addText("\ndone.");
+		inf.addOkButton();
+		//inf.addOkButton(); doesn't work
+		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
+		return Form.IDOK;
+	}
+
+
+
+	/**
+	 *	Handles button pressed event
+	 *	When the button is pressed a mapname.wfl file is saved in the
+	 *	maps directory.
+	 */
+	public void onEvent(Event ev){
+
+		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+			// display coords in another format
+			if (ev.target == infButton){
+				boolean retry = true;
+				while (retry == true) {
+					try {
+						retry = false;
+						wfl.saveWFL(mapsPath, thisMap);
+						if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
+					} catch (IOException e) {
+						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(321, "Error writing file ") + e.getMessage()+MyLocale.getMsg(324, " - retry?"), MessageBox.YESB | MessageBox.NOB);
+						if (tmpMB.execute() == MessageBox.IDYES) retry = true;
+					}catch (IllegalArgumentException e) {
+						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(325, "Map not calibrated")+MyLocale.getMsg(324, " - retry?"), MessageBox.YESB | MessageBox.NOB);
+						if (tmpMB.execute() == MessageBox.IDYES) { retry = true; break; }
+					}
+				}
+				if (!retry) close(0);
+			}
+		}
+	}
+}
+
+/**
+ *	Class that creates a panel and loads a map.
+ *	It catches click events to display a form where the user may enter the required ccordinates
+ *	The data is stored as a ground control point in the calling class: Map
+ */
+class mapInteractivePanel extends InteractivePanel{
+	MapImporter f;
+	Locale l = Vm.getLocale();
+	LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
+	public mapInteractivePanel(MapImporter f){
+		this.f = f;
+	}
+
+	/**
+	 *	Event handler to catch clicks on the map
+	 */
+	public void imageClicked(AniImage which, Point pos){
+		//Vm.debug("X = " +pos.x + " Y = " + pos.y);
+		Image img = new Image(31, 31);
+		Graphics g = new Graphics(img);
+		g.setColor(new Color(0,0,0));
+		g.fillRect(0,0,31,31);
+		g.setColor(new Color(255,0,0));
+		g.drawLine(0,16,31,16);
+		g.drawLine(16,0,16,31);
+		AniImage aImg = new AniImage(img);
+		aImg.setLocation(pos.x-16,pos.y-16);
+		aImg.transparentColor = new Color(0,0,0);
+		//aImg.properties = mImage.IsNotHot;
+		aImg.properties = mImage.AlwaysOnTop;
+		this.addImage(aImg);
+		g.free();
+		this.repaintNow();
+		f.updatePosition(pos.x, pos.y);
+
+		CoordsScreen cooS = new CoordsScreen(); // (String)lr.get(4108,"Coordinates:"), (String)lr.get(4108,"Coordinates:"), InfoBox.INPUT);
+		if (cooS.execute()==CoordsScreen.IDOK) {
+			GCPoint gcp = new GCPoint(cooS.getCoords());
+			gcp.bitMapX = pos.x;
+			gcp.bitMapY = pos.y;
+			f.addGCP(gcp); 
+		} else this.removeImage(aImg); // CANCEL pressed
+	}
+}

Modified: trunk/src/CacheWolf/navi/MapInfoObject.java
===================================================================
--- trunk/src/CacheWolf/navi/MapInfoObject.java	2007-09-16 20:34:59 UTC (rev 925)
+++ trunk/src/CacheWolf/navi/MapInfoObject.java	2007-09-17 22:39:52 UTC (rev 926)
@@ -2,6 +2,7 @@
 
 import CacheWolf.CWPoint;
 import CacheWolf.Common;
+import CacheWolf.Matrix;
 import CacheWolf.MyLocale;
 import ewe.fx.Point;
 import ewe.io.BufferedWriter;
@@ -14,10 +15,11 @@
 import ewe.sys.*;
 
 /**
- * @author r
+ * class to read, save and do the calculations for calibrated and calibrating maps
+ * @author pfeffer
  *
  */
-public class MapInfoObject{
+public class MapInfoObject extends Area {
 	//World file:
 	// x scale
 	// y scale
@@ -27,9 +29,10 @@
 	// lat of upper left corner of image
 	// lon of lower right corner of image
 	// lat of lower right corner of image
-	public double[] affine = {0,0,0,0,0,0};
-	public double lowlat = 0;
-	public double lowlon = 0;
+
+	public double[] affine = {0,0,0,0};
+	//public double lowlat = 0;
+	//public double lowlon = 0;
 	public double transLatX, transLatY, transLonX, transLonY; // this are needed for the inervers calculation from lat/lon to x/y
 	public CWPoint center = new CWPoint();
 	public float sizeKm = 0; // diagonale
@@ -43,29 +46,19 @@
 	public String mapName = new String();
 	//private Character digSep = new Character(' ');
 	static private String digSep = MyLocale.getDigSeparator();
-	/*
-	 * loads an .wfl file
-	 * throws FileNotFoundException and IOException (data out of range)
-	 * @maps Path to .wfl file
-	 * @thisMap filename of .wfl file without ".wfl"
-	 * @DigSep "." or ","
-	 */	
 
-	public MapInfoObject() {
+	public MapInfoObject() { // TODO remove this
 		//double testA = Convert.toDouble("1,50") + Convert.toDouble("3,00");
 		//if(testA == 4.5) digSep = ","; else digSep = ".";
 	}
 	
 	public MapInfoObject(MapInfoObject map) {
+		super (map.topleft, map.buttomright);
 		mapName = map.mapName;
 		affine[0] = map.affine[0];
 		affine[1] = map.affine[1];
 		affine[2] = map.affine[2];
 		affine[3] = map.affine[3];
-		affine[4] = map.affine[4];
-		affine[5] = map.affine[5];
-		lowlat = map.lowlat;
-		lowlon = map.lowlon;
 		OrigUpperLeft = new CWPoint (map.OrigUpperLeft);
 		zoomFactor = map.zoomFactor;
 		shift.set(map.shift);
@@ -75,11 +68,12 @@
 		doCalculations();
 	}
 
-	/*
+	/**
 	 * constructes an MapInfoObject without an associated map
 	 * but with 1 Pixel = scale meters
 	 */
 	public MapInfoObject(double scalei, double lat) {
+		super(new CWPoint(1,0), new CWPoint(0,1));
 		mapName="empty 1 Pixel = "+scalei+"meters";
 		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
 		double pixel2deg = meters2deg * scalei;
@@ -87,11 +81,11 @@
 		affine[1]=pixel2deg / java.lang.Math.cos(lat); //x2lon
 		affine[2]=-pixel2deg; //y2lat
 		affine[3]=0; //y2lon
-		affine[4]=1; //top
-		affine[5]=0; //left
-		lowlat = 0; //buttom
-		lowlon = 1; //right
-		OrigUpperLeft = new CWPoint(affine[4], affine[5]);
+		/*topleft.latDec=1; //top
+		topleft.lonDec=0; //left
+		buttomright.latDec = 0; //buttom
+		buttomright.lonDec = 1; //right
+		*/OrigUpperLeft = new CWPoint(topleft);
 		doCalculations();
 	}
 
@@ -101,8 +95,8 @@
 	 * @param name path and filename of .wfl file without the extension (it is needed because the image will be searched in the same directory)
 	 */
 	public MapInfoObject(double scalei, CWPoint center, int width, int hight, String name) {
+		super();
 		mapName = name+".wfl";
-
 		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
 		double pixel2deg = meters2deg * scalei;
 		double pixel2deghorizontal = pixel2deg / java.lang.Math.cos(center.latDec*java.lang.Math.PI / 180); 
@@ -110,15 +104,19 @@
 		affine[1]=pixel2deghorizontal; //x2lon
 		affine[2]=-pixel2deg; //y2lat
 		affine[3]=0; //y2lon
-		affine[4]=center.latDec + hight / 2 *pixel2deg; //top
-		affine[5]=center.lonDec - width / 2 *pixel2deghorizontal; //left
-		lowlat = center.latDec - hight / 2 *pixel2deg; //buttom
-		lowlon = center.lonDec + width / 2 *pixel2deghorizontal; //right
+		topleft.latDec=center.latDec + hight / 2 *pixel2deg; //top
+		topleft.lonDec=center.lonDec - width / 2 *pixel2deghorizontal; //left
+		buttomright.latDec = center.latDec - hight / 2 *pixel2deg; //buttom
+		buttomright.lonDec = center.lonDec + width / 2 *pixel2deghorizontal; //right
 		fileNameWFL = name;
-		OrigUpperLeft = new CWPoint(affine[4], affine[5]);
+		OrigUpperLeft = new CWPoint(topleft);
 		doCalculations();
 	}
 	
+	public MapInfoObject(String mapsPath, String thisMap) throws IOException, ArithmeticException {
+		super();
+		loadwfl(mapsPath, thisMap);
+	}
 
 	/** 
 	 * @return the filename of the associated map image, "" if no file is associated, null if associated file could not be found
@@ -132,6 +130,8 @@
 	
 	/**
 	 * Method to load a .wfl-file
+	 * @param mapsPath path to the map inclunding / at the end
+	 * @param thisMap name of the map without extension
 	 * @throws IOException when there was a problem reading .wfl-file
 	 * @throws IOException when lat/lon were out of range
 	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
@@ -140,7 +140,7 @@
 		FileReader in = new FileReader(mapsPath + thisMap + ".wfl");
 		String line = new String();
 		try {
-			for(int i = 0; i<6;i++){
+			for(int i = 0; i<4;i++){
 				line = in.readLine();
 				if (digSep.equals(",")) {line = line.replace('.',','); } // digSep == ',' musss genau so lauten. digsep.equals(',') wirft eine Exception auf PocketPC, digsep.equals(",") wirft keine Exception, funktioniert aber nicht! 
 				else line = line.replace(',','.');
@@ -149,38 +149,107 @@
 			line = in.readLine();
 			if (digSep.equals(",")) {line = line.replace('.',','); }
 			else line = line.replace(',','.');
-			lowlat = Convert.toDouble(line);
+			topleft.latDec = Convert.toDouble(line);
 			line = in.readLine();
 			if (digSep.equals(",")) {line = line.replace('.',','); }
 			else line = line.replace(',','.');
-			lowlon = Convert.toDouble(line);
+			topleft.lonDec = Convert.toDouble(line);
+			line = in.readLine();
+			if (digSep.equals(",")) {line = line.replace('.',','); }
+			else line = line.replace(',','.');
+			buttomright.latDec = Convert.toDouble(line);
+			line = in.readLine();
+			if (digSep.equals(",")) {line = line.replace('.',','); }
+			else line = line.replace(',','.');
+			buttomright.lonDec = Convert.toDouble(line);
 
 			fileNameWFL = mapsPath + thisMap + ".wfl";
 			fileName = ""; //mapsPath + thisMap + ".png";
 			mapName = thisMap;
 			in.close();
-			if(affine[4] > 90 || affine[4] < -90 || affine[5] < -180 || affine[5] > 360 ||
-					lowlat > 90 || lowlat < -90 || lowlon > 360 || lowlon < -180 ) {
-				affine[0] = 0; affine[1] = 0; affine[2] = 0; affine[3] = 0; affine[4] = 0; affine[5] = 0;
-				lowlat = 0; lowlon = 0;
+			if( !topleft.isValid() ) {
+				affine[0] = 0; affine[1] = 0; affine[2] = 0; affine[3] = 0; 
+				buttomright.makeInvalid();
 				throw (new IOException("Lat/Lon out of range while reading "+mapsPath + thisMap + ".wfl"));
 			}
 		} catch (NullPointerException e) { // in.readline liefert null zur?ck, wenn keine Daten mehr vorhanden sind
 			throw (new IOException("not enough lines in file "+mapsPath + thisMap + ".wfl"));
 		}
-		OrigUpperLeft = new CWPoint(affine[4], affine[5]);
+		OrigUpperLeft = new CWPoint(topleft);
 		doCalculations();
 	}
 
 	/**
+	 *	Method to evaluate ground control points (georeferenced points) and identify the parameters
+	 *	for the affine transformation
+	 *  @throws IllegalArgumentException when less than 3 georeferenced points were given in GCPs
+	 */
+
+	public void evalGCP(ewe.util.Vector GCPs, int imageWidth, int imageHeight) throws IllegalArgumentException {
+		//N 48 16.000 E 11 32.000
+		//N 48 16.000 E 11 50.000
+		//N 48 9.000 E 11 32.000
+		if (GCPs.size() < 3 ) throw new IllegalArgumentException("not enough points to calibrate the map");
+		GCPoint gcp = new GCPoint();
+		//Calculate parameters for latitutde affine transformation (affine 0,2,4)
+		Matrix X = new Matrix(GCPs.size(),3);
+		Matrix trg = new Matrix(GCPs.size(),1);
+		for(int i = 0; i < GCPs.size();i++){
+			gcp = (GCPoint)GCPs.get(i);
+			X.matrix[i][0] = 1; X.matrix[i][1] = gcp.bitMapX; X.matrix[i][2] = gcp.bitMapY;
+			trg.matrix[i][0] = gcp.latDec;
+		}
+		Matrix Xtran = new Matrix(X);
+		Xtran.Transpose();
+		Matrix XtranX = new Matrix(Xtran);
+		XtranX.Multiply(X);
+		Matrix XtranXinv = new Matrix(XtranX);
+		XtranXinv.Inverse();
+		Matrix beta = new Matrix(XtranXinv);
+		beta.Multiply(Xtran);
+		beta.Multiply(trg);
+		affine[0] = beta.matrix[1][0];
+		affine[2] = beta.matrix[2][0];
+		topleft.latDec = beta.matrix[0][0];
+
+		//Calculate parameters for longitude affine transformation (affine 1,3,5)
+		X = new Matrix(GCPs.size(),3);
+		trg = new Matrix(GCPs.size(),1);
+		for(int i = 0; i < GCPs.size();i++){
+			gcp = (GCPoint)GCPs.get(i);
+			X.matrix[i][0] = 1;
+			X.matrix[i][1] = gcp.bitMapX;
+			X.matrix[i][2] = gcp.bitMapY;
+			trg.matrix[i][0] = gcp.lonDec;
+		}
+		Xtran = new Matrix(X);
+		Xtran.Transpose();
+		XtranX = new Matrix(Xtran);
+		XtranX.Multiply(X);
+		XtranXinv = new Matrix(XtranX);
+		XtranXinv.Inverse();
+		beta = new Matrix(XtranXinv);
+		beta.Multiply(Xtran);
+		beta.Multiply(trg);
+		affine[1] = beta.matrix[1][0];
+		affine[3] = beta.matrix[2][0];
+		topleft.lonDec = beta.matrix[0][0];
+		
+		buttomright = calcLatLon(imageWidth, imageHeight);
+		doCalculations();
+		//Vm.debug("A B C" + affine[0] + " " + affine[2] + " " + affine[4]);
+		//Vm.debug("D E F" + affine[1] + " " + affine[3] + " " + affine[5]);
+	}
+
+	/**
 	 * calculates center, diagonal size of the map and inverse to affine transformation
 	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
 	 */
 
 	private void doCalculations() throws ArithmeticException {
 		try {
-			center.set((lowlat + affine[4])/2,(lowlon + affine[5])/2);
-			sizeKm = java.lang.Math.abs((float)center.getDistance(lowlat, lowlon)) *2;
+			center.set((buttomright.latDec + topleft.latDec)/2,(buttomright.lonDec + topleft.lonDec)/2);
+			sizeKm = java.lang.Math.abs((float)center.getDistance(buttomright.latDec, buttomright.lonDec)) *2;
 
 			//calculate reverse affine
 			double nenner=(-affine[1]*affine[2]+affine[0]*affine[3]);
@@ -214,16 +283,16 @@
 	 */
 	public void saveWFL(String mapsPath, String mapFileName) throws IOException, IllegalArgumentException {
 		if (affine[0]==0 && affine[1]==0 && affine[2]==0 && affine[3]==0 && 
-				affine[4]==0 && affine[5]==0 ) throw (new IllegalArgumentException("map not calibrated"));
+				!topleft.isValid()) throw (new IllegalArgumentException("map not calibrated"));
 		PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(mapsPath + "/" + mapFileName + ".wfl")));
 		String towrite=Convert.toString(affine[0])+"\n" +
 		Convert.toString(affine[1])+"\n" +
 		Convert.toString(affine[2])+"\n" + 
 		Convert.toString(affine[3])+"\n" + 
-		Convert.toString(affine[4])+"\n" +
-		Convert.toString(affine[5])+"\n" +
-		Convert.toString(lowlat)+"\n" +
-		Convert.toString(lowlon)+"\n";
+		Convert.toString(topleft.latDec)+"\n" +
+		Convert.toString(topleft.lonDec)+"\n" +
+		Convert.toString(buttomright.latDec)+"\n" +
+		Convert.toString(buttomright.lonDec)+"\n";
 		if (digSep.equals(",")) towrite=towrite.replace(',', '.');
 		outp.print(towrite);
 		outp.close();
@@ -232,8 +301,8 @@
 		this.mapName = mapFileName;
 	}
 
-	public boolean inBound(CWPoint pos){
-		boolean isInBound = false;
+//	public boolean inBound(CWPoint pos){
+	//	boolean isInBound = false;
 		/*
 		Vm.debug(mapName);
 		Vm.debug("Top: " + affine[4]);
@@ -243,9 +312,9 @@
 		Vm.debug("Right: " + lowlon);
 		Vm.debug("Test: " + pos.lonDec);
 		 */
-		if(affine[4] >= pos.latDec && pos.latDec >= lowlat && affine[5] <= pos.lonDec && pos.lonDec <= lowlon) isInBound = true;
-		return isInBound;
-	}
+//		if(topleft.latDec >= pos.latDec && pos.latDec >= buttomright.latDec && topleft.lonDec <= pos.lonDec && pos.lonDec <= buttomright.lonDec) isInBound = true;
+	//	return isInBound;
+	//}
 
 	/**
 	 * zoom in / out
@@ -255,15 +324,15 @@
 	 */
 	public void zoom(float zf, int diffX, int diffY) {
 		// restore original values to calculate corret shift (upperleft)
-		affine[4] = OrigUpperLeft.latDec;
-		affine[5] = OrigUpperLeft.lonDec;
+		topleft.latDec = OrigUpperLeft.latDec;
+		topleft.lonDec = OrigUpperLeft.lonDec;
 		affine[0] = affine[0] * zoomFactor; 
 		affine[1] = affine[1] * zoomFactor; 
 		affine[2] = affine[2] * zoomFactor;
 		affine[3] = affine[3] * zoomFactor;
 		CWPoint upperleft = calcLatLon(diffX, diffY);
-		affine[4] = upperleft.latDec;
-		affine[5] = upperleft.lonDec;
+		topleft.latDec = upperleft.latDec;
+		topleft.lonDec = upperleft.lonDec;
 		affine[0] = affine[0] / zf ; 
 		affine[1] = affine[1] / zf ; 
 		affine[2] = affine[2] / zf ; 
@@ -274,25 +343,12 @@
 		doCalculations(); // TODO lowlat neu berechnen?
 	}
 
-	public boolean inBound(CWGPSPoint pos){
+/*	public boolean inBound(double lati, double loni){
 		boolean isInBound = false;
-		/*
-		Vm.debug(mapName);
-		Vm.debug("Top: " + affine[4]);
-		Vm.debug("Bottom: " + lowlat);
-		Vm.debug("Test: " + pos.latDec);
-		Vm.debug("Left: " + affine[5]);
-		Vm.debug("Right: " + lowlon); // lowlon should be left?!
-		Vm.debug("Test: " + pos.lonDec);
-		 */
-		if(affine[4] >= pos.latDec && pos.latDec >= lowlat && affine[5] <= pos.lonDec && pos.lonDec <= lowlon) isInBound = true;
+		if(topleft.latDec >= lati && lati >= buttomright.latDec && topleft.lonDec <= loni && loni <= buttomright.lonDec) isInBound = true;
 		return isInBound;
 	}
-	public boolean inBound(double lati, double loni){
-		boolean isInBound = false;
-		if(affine[4] >= lati && lati >= lowlat && affine[5] <= loni && loni <= lowlon) isInBound = true;
-		return isInBound;
-	}
+	*/
 	/**
 	 * Method to calculate bitmap x,y of the current map using
 	 * lat and lon target coordinates. There ist no garanty that
@@ -303,8 +359,8 @@
 	public Point calcMapXY(double lat, double lon){
 		Point coords = new Point();
 		double b[] = new double[2];
-		b[0] = lat - affine[4];
-		b[1] = lon - affine[5];
+		b[0] = lat - topleft.latDec;
+		b[1] = lon - topleft.lonDec;
 		double mapx=transLatX* b[0] + transLonX*b[1];
 		double mapy=transLatY* b[0] + transLonY*b[1];
 		coords.x = (int)mapx;
@@ -321,14 +377,37 @@
 	 */
 	public CWPoint calcLatLon(int x, int y) {
 		CWPoint ll = new CWPoint();
-		ll.latDec = (double)x * affine[0] + (double)y * affine[2] + affine[4];
-		ll.lonDec = (double)x * affine[1] + (double)y * affine[3] + affine[5];
+		ll.latDec = (double)x * affine[0] + (double)y * affine[2] + topleft.latDec;
+		ll.lonDec = (double)x * affine[1] + (double)y * affine[3] + topleft.lonDec;
 		return ll;
 	}
 	public CWPoint calcLatLon(Point p) {
 		return calcLatLon(p.x, p.y);
 	}
-	public Area getArea(){
-		return new Area(new CWPoint(affine[4], affine[5]), new CWPoint(lowlat, lowlon));
+	
+/*	public Area getArea(){
+		return new Area(new CWPoint(topleft), new CWPoint(buttomright));
+	} */
+}
+
+/**
+ *	Class based on CWPoint but intended to handle bitmap x and y
+ *	Used for georeferencing bitmaps.
+ */
+class GCPoint extends CWPoint{
+	public int bitMapX = 0;
+	public int bitMapY = 0;
+
+	public GCPoint(){
 	}
+
+	public GCPoint(CWPoint p) {
+		super(p);
+	}
+
+	public GCPoint(double lat, double lon){
+		this.latDec = lat;
+		this.lonDec = lon;
+		this.utmValid = false;
+	}
 }
\ No newline at end of file

Modified: trunk/src/CacheWolf/navi/MapsList.java
===================================================================
--- trunk/src/CacheWolf/navi/MapsList.java	2007-09-16 20:34:59 UTC (rev 925)
+++ trunk/src/CacheWolf/navi/MapsList.java	2007-09-17 22:39:52 UTC (rev 926)
@@ -45,11 +45,11 @@
 				// if (!dateien[i].endsWith(".wfl")) continue;
 				rawFileName = dateien[i].substring(0, dateien[i].lastIndexOf("."));
 				try {
-					tempMIO = new MapInfoObject();
 					if (dirs.get(j).equals(".")) // the notation dir/./filename doesn't work on all platforms anyhow
-						tempMIO.loadwfl(mapsPath+"/", rawFileName);
-					else tempMIO.loadwfl(mapsPath+"/"+dirs.get(j)+"/", rawFileName);
+						tempMIO = new MapInfoObject(mapsPath+"/", rawFileName);
+					else tempMIO = new MapInfoObject(mapsPath+"/"+dirs.get(j)+"/", rawFileName);
 					add(tempMIO);
+					ewe.sys.Vm.debug(tempMIO.getEasyFindString() + tempMIO.mapName);
 				}catch(IOException ex){ 
 					if (f == null) (f=new MessageBox("Warning", "Ignoring error while \n reading calibration file \n"+ex.toString(), MessageBox.OKB)).exec();
 				}catch(ArithmeticException ex){ // affine contain not allowed values 
@@ -103,9 +103,9 @@
 				screenArea = getAreaForScreen(screen, lat, lon, mi.scale, mi);
 				lastscale = mi.scale;
 			}
-			if (screenArea.isOverlapping(mi.getArea()) ) { // is on screen
+			if (screenArea.isOverlapping(mi) ) { // is on screen
 				if (!forceScale || (forceScale && !scaleEquals(scale, mi))) { // different scale?
-					if (!forceScale && (mi.inBound(lat, lon) && (bestMap == null || scaleNearer(mi.scale, bestMap.scale, scale) || !bestMap.inBound(lat, lon)))) 
+					if (!forceScale && (mi.isInBound(lat, lon) && (bestMap == null || scaleNearer(mi.scale, bestMap.scale, scale) || !bestMap.isInBound(lat, lon)))) 
 						better = true; // inbound and resolution nearer at wanted resolution or old one is on screen but lat/long not inbound-> better
 					else {
 						if ( bestMap == null || scaleNearerOrEuqal(mi.scale, bestMap.scale, scale)) {
@@ -157,7 +157,7 @@
 		for (int i=size() -1; i>=0 ;i--) {
 			better = false;
 			mi = (MapInfoObject)get(i);
-			if (mi.inBound(topleft) && mi.inBound(bottomright)) { // both points are inside the map
+			if (mi.isInBound(topleft) && mi.isInBound(bottomright)) { // both points are inside the map
 				if (fittingmap == null || fittingmap.scale > mi.scale * scaleTolerance) {
 					better = true; // mi map has a better (lower) scale than the last knwon good map
 				} else {
@@ -212,9 +212,9 @@
 				screenArea = getAreaForScreen(screen, lat, lon, mi.scale, mi);
 				lastscale = mi.scale;
 			}
-			if (screenArea.isOverlapping(mi.getArea())) { // is on screen
+			if (screenArea.isOverlapping(mi)) { // is on screen
 				if (bestMap == null || !scaleEquals(mi, bestMap)) { // different scale than known bestMap?
-					if (mi.inBound(lat, lon) && (      // more details wanted and this map has more details?                                // less details than bestmap
+					if (mi.isInBound(lat, lon) && (      // more details wanted and this map has more details?                                // less details than bestmap
 							(moreDetails && (curScale > mi.scale * scaleTolerance) && (bestMap == null || mi.scale > bestMap.scale * scaleTolerance ) ) // higher resolution wanted and mi has higher res and a lower res than bestmap, because we dont want to overjump one resolution step
 							|| (!moreDetails && (curScale *  scaleTolerance < mi.scale) && (bestMap == null || mi.scale * scaleTolerance < bestMap.scale) ) // lower resolution wanted and mi has lower res and a higher res than bestmap, because we dont want to overjump one resolution step
 					) )	better = true;	// inbound and higher resolution if higher res wanted -> better

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2007-09-16 20:34:59 UTC (rev 925)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2007-09-17 22:39:52 UTC (rev 926)
@@ -1471,7 +1471,7 @@
 		if(l.execute() == FormBase.IDOK){
 //			Vm.debug("Trying map: " + l.selectedMap.fileName);
 			mm.autoSelectMap = false;
-			if (l.selectedMap.inBound(mm.posCircleLat, mm.posCircleLon) || l.selectedMap.getImageFilename().length()==0) {
+			if (l.selectedMap.isInBound(mm.posCircleLat, mm.posCircleLon) || l.selectedMap.getImageFilename().length()==0) {
 				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon);
 				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
 				mm.ignoreGps = false;
@@ -1722,7 +1722,7 @@
  *	Class to display maps to choose from
  */
 class ListBox extends Form{
-	public MapInfoObject selectedMap = new MapInfoObject();
+	public MapInfoObject selectedMap; // = new MapInfoObject();
 	mButton cancelButton, okButton;
 	mList list = new mList(4,1,false);
 	public boolean selected = false;
@@ -1745,9 +1745,8 @@
 			list.addItem("--- Karten von akt. Position und Ziel ---");
 			row++;
 			for(int i = 0; i<maps.size();i++){
-				map = new MapInfoObject();
-				map = (MapInfoObject)maps.get(i);
-				if( map.inBound(Gps.latDec, Gps.lonDec) && map.inBound(gotopos) ) 
+				map = new MapInfoObject((MapInfoObject)maps.get(i));
+				if( map.isInBound(Gps.latDec, Gps.lonDec) && map.isInBound(gotopos) ) 
 				{
 					list.addItem(i + ": " + map.mapName);
 					row++;
@@ -1760,9 +1759,8 @@
 			list.addItem("--- Karten der aktuellen Position ---");
 			row++;
 			for(int i = 0; i<maps.size();i++){
-				map = new MapInfoObject();
-				map = (MapInfoObject)maps.get(i);
-				if (map.inBound(Gps.latDec, Gps.lonDec) == true) 
+				map = new MapInfoObject((MapInfoObject)maps.get(i));
+				if (map.isInBound(Gps.latDec, Gps.lonDec) == true) 
 				{
 					list.addItem(i + ": " + map.mapName);
 					row++;
@@ -1775,9 +1773,8 @@
 			list.addItem("--- Karten des Ziels ---");
 			row++;
 			for(int i = 0; i<maps.size();i++){
-				map = new MapInfoObject();
-				map = (MapInfoObject)maps.get(i);
-				if(map.inBound(gotopos)) {
+				map = new MapInfoObject((MapInfoObject)maps.get(i));
+				if(map.isInBound(gotopos)) {
 					list.addItem(i + ": " + map.mapName);
 					row++;
 					inList[i] = true;
@@ -1788,8 +1785,7 @@
 		list.addItem("--- andere Karten ---");
 		row++;
 		for(int i = 0; i<maps.size();i++){
-			map = new MapInfoObject();
-			map = (MapInfoObject)maps.get(i);
+			map = new MapInfoObject((MapInfoObject)maps.get(i));
 			if(!inList[i]) {
 				list.addItem(i + ": " + map.mapName);
 				row++;



From mirabilos at mail.berlios.de  Tue Sep 18 12:19:24 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Tue, 18 Sep 2007 12:19:24 +0200
Subject: [Cachewolf-svn] r927 - trunk/resources/attributes-big
Message-ID: <200709181019.l8IAJOIw008570@sheep.berlios.de>

Author: mirabilos
Date: 2007-09-18 12:19:23 +0200 (Tue, 18 Sep 2007)
New Revision: 927

Added:
   trunk/resources/attributes-big/oconly-no.gif
   trunk/resources/attributes-big/oconly.gif
Log:
OC.de kann jetzt Cacheattribute, das hier ist das erste, wo mir aufgefallen
ist: ?Dieser Cache ist OC.de-only? ?

Gr??e 34x34, daher hier drin. Einbinden in CW ist noch nicht erfolgt, ich
plazier? die erst mal nur hier. Die ?ja?-Form hei?t oconly.gif und nicht,
wie bei GC.com, oconly-yes.gif (sollte man im Code ber?cksichtigen).


Added: trunk/resources/attributes-big/oconly-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/oconly-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/oconly.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/oconly.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From mik77 at mail.berlios.de  Tue Sep 18 19:04:05 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Tue, 18 Sep 2007 19:04:05 +0200
Subject: [Cachewolf-svn] r928 - trunk/src/CacheWolf/navi
Message-ID: <200709181704.l8IH45NM010145@sheep.berlios.de>

Author: mik77
Date: 2007-09-18 19:03:52 +0200 (Tue, 18 Sep 2007)
New Revision: 928

Removed:
   trunk/src/CacheWolf/navi/MapImporter.java
Modified:
   trunk/src/CacheWolf/navi/Map.java
Log:
first step of correct renaming Map.java -> MapImporter.java

Modified: trunk/src/CacheWolf/navi/Map.java
===================================================================
--- trunk/src/CacheWolf/navi/Map.java	2007-09-18 10:19:23 UTC (rev 927)
+++ trunk/src/CacheWolf/navi/Map.java	2007-09-18 17:03:52 UTC (rev 928)
@@ -13,20 +13,14 @@
 import CacheWolf.CoordsScreen;
 import CacheWolf.Global;
 import CacheWolf.InfoBox;
-import CacheWolf.Matrix;
 import CacheWolf.MyLocale;
 import CacheWolf.Preferences;
 
-import com.stevesoft.ewe_pat.*;
-
 /**
- *	This class is the main class for mapping,
- *	 (moving map, georeferencing maps, etc)
- *	in CacheWolf.
- *	It also provides a class for importing maps
- *	This class id=4100
+ *	This class is for importing and manually georeferencing maps
+ *	This class id=4100 for cachewolf-languages
  */
-public class Map extends Form {
+public class MapImporter extends Form {
 	Preferences pref;
 	String mapsPath = new String();
 	String thisMap = new String();
@@ -43,7 +37,7 @@
 	/**
 	 *	This constructor should be used when importing maps
 	 */
-	public Map(Preferences pref){
+	public MapImporter(Preferences pref){
 		this.pref = pref;
 		mapsPath = pref.getMapManuallySavePath(true)+"/"; //File.getProgramDirectory() + "/maps/";
 	}
@@ -55,12 +49,8 @@
 	 *	It helps to identify how good the georeferencing works based on the set GCPs.
 	 */
 	public void updatePosition(int x, int y){
-		if(GCPs.size()>=3  || (wfl.affine[4] > 0 && wfl.affine[5] > 0)){
-			double x_ = 0;
-			double y_ = 0;
-			x_ = wfl.affine[0]*x + wfl.affine[2]*y + wfl.affine[4];
-			y_ = wfl.affine[1]*x + wfl.affine[3]*y + wfl.affine[5];
-			CWPoint p = new CWPoint(x_ , y_);
+		if(GCPs.size()>=3  || (wfl.topleft.isValid())){
+			CWPoint p = wfl.calcLatLon(x,y);
 			infLabel.setText("--> " + p.getLatDeg(CWPoint.DMS) + " " +p.getLatMin(CWPoint.DMM) + " / " + p.getLonDeg(CWPoint.DMS) + " " + p.getLonMin(CWPoint.DMM));
 		}
 	}
@@ -68,7 +58,7 @@
 	/**
 	 *	This is the correct constructor for georeferencing maps.
 	 */
-	public Map(Preferences pref, String mapToLoad, boolean worldfileexists){
+	public MapImporter(Preferences pref, String mapToLoad, boolean worldfileexists){
 		this.pref = pref;
 		this.title = MyLocale.getMsg(4106,"Calibrate map:") + " " + mapToLoad;
 		this.resizable = true;
@@ -116,81 +106,12 @@
 		if (GCP.latDec>90 || GCP.latDec<-90 || GCP.lonDec>360 || GCP.lonDec<-180) throw new IllegalArgumentException("lat/lon out of range: "+GCP.toString());
 		GCPs.add(GCP);
 		if(GCPs.size() >= 3){
-			evalGCP();
+			wfl.evalGCP(GCPs, imageWidth, imageHeight);
 		}
 	}
 
-	/**
-	 *	Returns the number of ground control points in the list. (Vector GCPs)
-	 */
-	public int getGCPCount(){
-		return GCPs.size();
-	}
 
 	/**
-	 *	Actuall method to evaluate the ground control points and identify the parameters
-	 *	for thew affine transformation
-	 */
-	private void evalGCP(){
-		//N 48 16.000 E 11 32.000
-		//N 48 16.000 E 11 50.000
-		//N 48 9.000 E 11 32.000
-		GCPoint gcp = new GCPoint();
-		//Calculate parameters for latitutde affine transformation (affine 0,2,4)
-		Matrix X = new Matrix(GCPs.size(),3);
-		Matrix trg = new Matrix(GCPs.size(),1);
-		for(int i = 0; i < GCPs.size();i++){
-			gcp = (GCPoint)GCPs.get(i);
-			X.matrix[i][0] = 1; X.matrix[i][1] = gcp.bitMapX; X.matrix[i][2] = gcp.bitMapY;
-			trg.matrix[i][0] = gcp.latDec;
-		}
-		Matrix Xtran = new Matrix(X);
-		Xtran.Transpose();
-		Matrix XtranX = new Matrix(Xtran);
-		XtranX.Multiply(X);
-		Matrix XtranXinv = new Matrix(XtranX);
-		XtranXinv.Inverse();
-		Matrix beta = new Matrix(XtranXinv);
-		beta.Multiply(Xtran);
-		beta.Multiply(trg);
-		wfl.affine[0] = beta.matrix[1][0];
-		wfl.affine[2] = beta.matrix[2][0];
-		wfl.affine[4] = beta.matrix[0][0];
-
-		//Calculate parameters for longitude affine transformation (affine 1,3,5)
-		X = new Matrix(GCPs.size(),3);
-		trg = new Matrix(GCPs.size(),1);
-		for(int i = 0; i < GCPs.size();i++){
-			gcp = (GCPoint)GCPs.get(i);
-			X.matrix[i][0] = 1;
-			X.matrix[i][1] = gcp.bitMapX;
-			X.matrix[i][2] = gcp.bitMapY;
-			trg.matrix[i][0] = gcp.lonDec;
-		}
-		Xtran = new Matrix(X);
-		Xtran.Transpose();
-		XtranX = new Matrix(Xtran);
-		XtranX.Multiply(X);
-		XtranXinv = new Matrix(XtranX);
-		XtranXinv.Inverse();
-		beta = new Matrix(XtranXinv);
-		beta.Multiply(Xtran);
-		beta.Multiply(trg);
-		wfl.affine[1] = beta.matrix[1][0];
-		wfl.affine[3] = beta.matrix[2][0];
-		wfl.affine[5] = beta.matrix[0][0];
-		double x_ = 0;
-		double y_ = 0;
-		x_ = wfl.affine[0]*imageWidth+ wfl.affine[2]*imageHeight + wfl.affine[4];
-		y_ = wfl.affine[1]*imageWidth + wfl.affine[3]*imageHeight + wfl.affine[5];
-		CWPoint p = new CWPoint(x_ , y_);
-		wfl.lowlon = p.lonDec;
-		wfl.lowlat = p.latDec;
-		//Vm.debug("A B C" + affine[0] + " " + affine[2] + " " + affine[4]);
-		//Vm.debug("D E F" + affine[1] + " " + affine[3] + " " + affine[5]);
-	}
-
-	/**
 	 *	Method to copy ("import") a png based map
 	 *	into the maps folder in the CacheWolf base directory.
 	 *	
@@ -367,7 +288,7 @@
 								}
 							}
 							 */
-							evalGCP();
+							wfl.evalGCP(GCPs, imageWidth, imageHeight);
 							//Vm.debug("Saving .map file to: " + mapsPath + "/" + rawFileName + ".wfl");
 							wfl.saveWFL(mapsPath, rawFileName);
 							GCPs.clear();
@@ -430,10 +351,10 @@
  *	The data is stored as a ground control point in the calling class: Map
  */
 class mapInteractivePanel extends InteractivePanel{
-	Map f;
+	MapImporter f;
 	Locale l = Vm.getLocale();
 	LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
-	public mapInteractivePanel(Map f){
+	public mapInteractivePanel(MapImporter f){
 		this.f = f;
 	}
 
@@ -464,37 +385,7 @@
 			GCPoint gcp = new GCPoint(cooS.getCoords());
 			gcp.bitMapX = pos.x;
 			gcp.bitMapY = pos.y;
-			f.addGCP(gcp); // throws IllegalArgumentException in case of lon/lat out of range
-//			} catch (IllegalArgumentException e) { // NumberFormatException is a subclass of IllagalArgumentException
-//			coosInputFormat();
-//			this.removeImage(aImg);
+			f.addGCP(gcp); 
 		} else this.removeImage(aImg); // CANCEL pressed
 	}
-
-	private void coosInputFormat () {
-		MessageBox tmpMB = new MessageBox((String)lr.get(312,"Error"), (String)lr.get(4111,"Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"), MessageBox.OKB);
-		tmpMB.exec();
-
-	}
 }
-/**
- *	Class based on CWPoint but intended to handle bitmap x and y
- *	Used for georeferencing bitmaps.
- */
-class GCPoint extends CWPoint{
-	public int bitMapX = 0;
-	public int bitMapY = 0;
-
-	public GCPoint(){
-	}
-
-	public GCPoint(CWPoint p) {
-		super(p);
-	}
-
-	public GCPoint(double lat, double lon){
-		this.latDec = lat;
-		this.lonDec = lon;
-		this.utmValid = false;
-	}
-}
\ No newline at end of file

Deleted: trunk/src/CacheWolf/navi/MapImporter.java
===================================================================
--- trunk/src/CacheWolf/navi/MapImporter.java	2007-09-18 10:19:23 UTC (rev 927)
+++ trunk/src/CacheWolf/navi/MapImporter.java	2007-09-18 17:03:52 UTC (rev 928)
@@ -1,391 +0,0 @@
-package CacheWolf.navi;
-
-import ewe.util.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-import ewe.sys.*;
-import ewe.ui.*;
-import ewe.graphics.*;
-import ewe.fx.*;
-
-import CacheWolf.CWPoint;
-import CacheWolf.Common;
-import CacheWolf.CoordsScreen;
-import CacheWolf.Global;
-import CacheWolf.InfoBox;
-import CacheWolf.MyLocale;
-import CacheWolf.Preferences;
-
-/**
- *	This class is for importing and manually georeferencing maps
- *	This class id=4100 for cachewolf-languages
- */
-public class MapImporter extends Form {
-	Preferences pref;
-	String mapsPath = new String();
-	String thisMap = new String();
-	public String selectedMap = new String();
-	CellPanel infPanel;
-	mLabel infLabel = new mLabel("                          ");
-	Vector GCPs = new Vector();
-	MapInfoObject wfl = new MapInfoObject();
-	mButton infButton;
-	ScrollBarPanel scp;
-	AniImage mapImg;
-	int imageWidth, imageHeight = 0;
-
-	/**
-	 *	This constructor should be used when importing maps
-	 */
-	public MapImporter(Preferences pref){
-		this.pref = pref;
-		mapsPath = pref.getMapManuallySavePath(true)+"/"; //File.getProgramDirectory() + "/maps/";
-	}
-
-	/**
-	 *	When a user clicks on the map and more than three ground control points exist
-	 *	then the calculated coordinate based on the affine transformation is displayed in the
-	 *	info panel below the map.
-	 *	It helps to identify how good the georeferencing works based on the set GCPs.
-	 */
-	public void updatePosition(int x, int y){
-		if(GCPs.size()>=3  || (wfl.topleft.isValid())){
-			CWPoint p = wfl.calcLatLon(x,y);
-			infLabel.setText("--> " + p.getLatDeg(CWPoint.DMS) + " " +p.getLatMin(CWPoint.DMM) + " / " + p.getLonDeg(CWPoint.DMS) + " " + p.getLonMin(CWPoint.DMM));
-		}
-	}
-
-	/**
-	 *	This is the correct constructor for georeferencing maps.
-	 */
-	public MapImporter(Preferences pref, String mapToLoad, boolean worldfileexists){
-		this.pref = pref;
-		this.title = MyLocale.getMsg(4106,"Calibrate map:") + " " + mapToLoad;
-		this.resizable = true;
-		this.moveable = true;
-		//this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
-		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
-		thisMap = mapToLoad;
-		mapsPath = pref.getMapManuallySavePath(true)+"/"; //File.getProgramDirectory() + "/maps/"; // TDO veraltet
-		try {
-			wfl.loadwfl(mapsPath, thisMap);
-		}catch(FileNotFoundException ex){
-			//	Vm.debug("Cannot load world file!");
-		}catch (IOException ex) { // is thrown if lat/lon out of range
-			MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, "Error"), ex.getMessage(), MessageBox.OKB);
-			tmpMB.execute();
-			Vm.debug("Cannot load world file!");
-		}
-		mapInteractivePanel pane = new mapInteractivePanel(this);
-		scp = new ScrollBarPanel(pane);
-		Image img = new Image(Common.getImageName(mapsPath + thisMap));
-		PixelBuffer pB = new PixelBuffer(img);
-		//pB = pB.scale((int)(pref.myAppWidth*0.98),(int)(pref.myAppHeight*0.98));
-		mapImg = new AniImage(pB.toDrawableImage());
-		pane.addImage(mapImg);
-		scp.setPreferredSize(mapImg.getWidth(),mapImg.getHeight());
-		imageWidth = mapImg.getWidth();
-		imageHeight = mapImg.getHeight();
-		this.addLast(scp.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
-		infPanel = new CellPanel();
-		infPanel.addNext(infLabel,CellConstants.STRETCH, CellConstants.FILL);
-		infButton = new mButton(MyLocale.getMsg(4107,"Done!"));
-		infPanel.addLast(infButton,CellConstants.DONTSTRETCH, CellConstants.FILL);
-		this.addLast(infPanel, CellConstants.DONTSTRETCH, CellConstants.FILL);
-		//scp.repaintNow();
-		//this.repaintNow();
-	}
-
-	/**
-	 *	Add a ground control point to the list
-	 *	If the list is longer than 3 GCPs these will be evaluated
-	 *	to obtain the required parameters for the affine
-	 *	transformation.
-	 */
-	public void addGCP(GCPoint GCP){
-		if (GCP.latDec>90 || GCP.latDec<-90 || GCP.lonDec>360 || GCP.lonDec<-180) throw new IllegalArgumentException("lat/lon out of range: "+GCP.toString());
-		GCPs.add(GCP);
-		if(GCPs.size() >= 3){
-			wfl.evalGCP(GCPs, imageWidth, imageHeight);
-		}
-	}
-
-
-	/**
-	 *	Method to copy ("import") a png based map
-	 *	into the maps folder in the CacheWolf base directory.
-	 *	
-	 *	If the maps directory does not exist it will create it.
-	 *	If it finds .map files it will assume these are oziexplorer calibration files.
-	 *	It will use these files to automatically georeference the files during import.
-	 */
-	public int importMap(){
-		String rawFileName = new String();
-		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir);
-		fc.addMask("*.png,*.gif,*.bmp,*.jpg");
-		fc.setTitle((String)MyLocale.getMsg(4100,"Select Directory:"));
-		int tmp = fc.execute() ; 
-		if(tmp != FileChooser.IDYES) return Form.IDCANCEL;
-		File inDir = fc.getChosenFile();
-		File mapFile;
-		InfoBox inf = new InfoBox("Info", MyLocale.getMsg(4109,"Loading maps...            \n"), InfoBox.PROGRESS_WITH_WARNINGS, false); 
-		inf.setPreferredSize(220, 300);
-		inf.setInfoHeight(100);
-		inf.relayout(false);
-		Vm.showWait(this, true);
-		inf.exec();
-
-		//User selected a map, but maybe there are more png(s)
-		//copy all of them!
-		//at the same time try to find associated .map files!
-		//These are georeference files targeted for OziExplorer.
-		//So lets check if we have more than 1 png file:
-		String line = new String();
-		InputStream in = null;
-		OutputStream out = null;
-		FileReader inMap;
-		byte[] buf;
-		int len;
-		String[] parts;
-		String [] files = inDir.listMultiple("*.png,*.jpg,*.gif,*.bmp", File.LIST_FILES_ONLY);
-
-		String currfile = null;
-		String curInFullPath;
-		String curOutFullPath;
-		int num = files.length;
-		for(int i =  num -1 ; i >= 0;i--){
-			currfile = (String) files[i];
-			inf.setInfo(MyLocale.getMsg(4110,"Loading: ")+ "\n" + currfile + "\n("+(num-i)+"/"+num+")");
-			//Copy the file
-			//Vm.debug("Copy: " + inDir.getFullPath() + "/" +files[i]);
-			//Vm.debug("to: " + mapsPath + files[i]);
-			curInFullPath = inDir.getFullPath() + "/" +currfile;
-			curOutFullPath = mapsPath + currfile;
-			boolean imageerror = false;
-			try {
-				in = new FileInputStream(curInFullPath);
-				buf = new byte[1024*10];
-				boolean first = true;
-				ByteArray header = new ByteArray(buf);
-				while ((len = in.read(buf)) > 0) {
-					if (first) {
-						first = false;
-						header.copyFrom(buf, 0, len);
-						ImageInfo tmpII = Image.getImageInfo(header,null);
-						imageWidth = tmpII.width;
-						imageHeight = tmpII.height;
-						out = new FileOutputStream(curOutFullPath); // only create outfile if geImageInfo didn't throw an exception so do it only here not directly after opening input stream
-					}
-					out.write(buf, 0, len);
-				}
-			} catch(IOException ex){
-				imageerror = true;
-				inf.addWarning("\nIO-Error while copying image from: " + curInFullPath + " to: " + curOutFullPath + " error: " + ex.getMessage());
-			} catch (IllegalArgumentException e) { // thrown from Image.getImageInfo when it could not interprete the header (e.g. bmp with 32 bits per pixel)
-				imageerror = true;
-				inf.addWarning("\nError: could not decode image: " + curInFullPath + " - image not copied");
-			} finally {
-				try {
-					if (in != null) in.close();
-					if (out  != null) out.close(); 
-				} catch (Throwable e) {}
-			}
-			//Check for a .map file
-			rawFileName = currfile.substring(0, currfile.lastIndexOf("."));
-			mapFile = new File(inDir.getFullPath() + "/" + rawFileName + ".map");
-			if(!imageerror && mapFile.exists()){
-				GCPoint gcp1 = new GCPoint();
-				GCPoint gcp2 = new GCPoint();
-				GCPoint gcp3 = new GCPoint();
-				GCPoint gcp4 = new GCPoint();
-				GCPoint gcpG = new GCPoint();
-				//Vm.debug("Found file: " + inDir.getFullPath() + "/" + rawFileName + ".map");
-				try {
-					inMap = new FileReader(inDir.getFullPath() + "/" + rawFileName + ".map");
-					while((line = inMap.readLine()) != null){
-						if(line.equals("MMPNUM,4")){
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							gcp1.bitMapX = Convert.toInt(parts[2]);
-							gcp1.bitMapY = Convert.toInt(parts[3]);
-							if(gcp1.bitMapX == 0) gcp1.bitMapX = 1;
-							if(gcp1.bitMapY == 0) gcp1.bitMapY = 1;
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							gcp2.bitMapX = Convert.toInt(parts[2]);
-							gcp2.bitMapY = Convert.toInt(parts[3]);
-							if(gcp2.bitMapX == 0) gcp2.bitMapX = 1;
-							if(gcp2.bitMapY == 0) gcp2.bitMapY = 1;
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							gcp3.bitMapX = Convert.toInt(parts[2]);
-							gcp3.bitMapY = Convert.toInt(parts[3]);
-							if(gcp3.bitMapX == 0) gcp3.bitMapX = 1;
-							if(gcp3.bitMapY == 0) gcp3.bitMapY = 1;
-							//imageWidth = gcp3.bitMapX;
-							//imageHeight = gcp3.bitMapY;
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							gcp4.bitMapX = Convert.toInt(parts[2]);
-							gcp4.bitMapY = Convert.toInt(parts[3]);
-							if(gcp4.bitMapX == 0) gcp4.bitMapX = 1;
-							if(gcp4.bitMapY == 0) gcp4.bitMapY = 1;
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							if(pref.digSeparator.equals(",")) {
-								parts[3]= parts[3].replace('.', ',');
-								parts[2]= parts[2].replace('.', ',');
-							}
-							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
-							gcpG.bitMapX = gcp1.bitMapX;
-							gcpG.bitMapY = gcp1.bitMapY;
-							addGCP(gcpG);
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							if(pref.digSeparator.equals(",")) {
-								parts[3]= parts[3].replace('.', ',');
-								parts[2]= parts[2].replace('.', ',');
-							}
-							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
-							gcpG.bitMapX = gcp2.bitMapX;
-							gcpG.bitMapY = gcp2.bitMapY;
-							addGCP(gcpG);
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							if(pref.digSeparator.equals(",")) {
-								parts[3]= parts[3].replace('.', ',');
-								parts[2]= parts[2].replace('.', ',');
-							}
-							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
-							gcpG.bitMapX = gcp3.bitMapX;
-							gcpG.bitMapY = gcp3.bitMapY;
-							addGCP(gcpG);
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							if(pref.digSeparator.equals(",")) {
-								parts[3]= parts[3].replace('.', ',');
-								parts[2]= parts[2].replace('.', ',');
-							}
-							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
-							gcpG.bitMapX = gcp4.bitMapX;
-							gcpG.bitMapY = gcp4.bitMapY;
-							addGCP(gcpG);
-							/* already read from image file itself
-							// get dimensions of image
-							while ( (line = inMap.readLine()) != null){
-								if (line.startsWith("IWH")){
-									parts = mString.split(line, ',');
-									imageWidth = Convert.toInt(parts[2]);
-									imageHeight = Convert.toInt(parts[3]);
-								}
-							}
-							 */
-							wfl.evalGCP(GCPs, imageWidth, imageHeight);
-							//Vm.debug("Saving .map file to: " + mapsPath + "/" + rawFileName + ".wfl");
-							wfl.saveWFL(mapsPath, rawFileName);
-							GCPs.clear();
-						} // if
-
-					} // while
-					if (inMap != null)	inMap.close();
-				} catch(IllegalArgumentException ex){ // is thrown from Convert.toDouble and saveWFL if affine[0-5]==0 NumberFormatException is a subclass of IllegalArgumentExepction
-					inf.addWarning("\nError while importing .map-file: "+ex.getMessage());
-				} catch(IOException ex){
-					inf.addWarning("\nIO-Error while reading or writing calibration file\n" + ex.getMessage());
-				} 
-			} else { // if map file.exists
-				if (!imageerror) inf.addWarning("\nNo calibration file found for: " + currfile + " - you can calibrate it manually");
-			}
-		} // for file
-		Vm.showWait(this, false);
-		inf.addText("\ndone.");
-		inf.addOkButton();
-		//inf.addOkButton(); doesn't work
-		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
-		return Form.IDOK;
-	}
-
-
-
-	/**
-	 *	Handles button pressed event
-	 *	When the button is pressed a mapname.wfl file is saved in the
-	 *	maps directory.
-	 */
-	public void onEvent(Event ev){
-
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			// display coords in another format
-			if (ev.target == infButton){
-				boolean retry = true;
-				while (retry == true) {
-					try {
-						retry = false;
-						wfl.saveWFL(mapsPath, thisMap);
-						if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
-					} catch (IOException e) {
-						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(321, "Error writing file ") + e.getMessage()+MyLocale.getMsg(324, " - retry?"), MessageBox.YESB | MessageBox.NOB);
-						if (tmpMB.execute() == MessageBox.IDYES) retry = true;
-					}catch (IllegalArgumentException e) {
-						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(325, "Map not calibrated")+MyLocale.getMsg(324, " - retry?"), MessageBox.YESB | MessageBox.NOB);
-						if (tmpMB.execute() == MessageBox.IDYES) { retry = true; break; }
-					}
-				}
-				if (!retry) close(0);
-			}
-		}
-	}
-}
-
-/**
- *	Class that creates a panel and loads a map.
- *	It catches click events to display a form where the user may enter the required ccordinates
- *	The data is stored as a ground control point in the calling class: Map
- */
-class mapInteractivePanel extends InteractivePanel{
-	MapImporter f;
-	Locale l = Vm.getLocale();
-	LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
-	public mapInteractivePanel(MapImporter f){
-		this.f = f;
-	}
-
-	/**
-	 *	Event handler to catch clicks on the map
-	 */
-	public void imageClicked(AniImage which, Point pos){
-		//Vm.debug("X = " +pos.x + " Y = " + pos.y);
-		Image img = new Image(31, 31);
-		Graphics g = new Graphics(img);
-		g.setColor(new Color(0,0,0));
-		g.fillRect(0,0,31,31);
-		g.setColor(new Color(255,0,0));
-		g.drawLine(0,16,31,16);
-		g.drawLine(16,0,16,31);
-		AniImage aImg = new AniImage(img);
-		aImg.setLocation(pos.x-16,pos.y-16);
-		aImg.transparentColor = new Color(0,0,0);
-		//aImg.properties = mImage.IsNotHot;
-		aImg.properties = mImage.AlwaysOnTop;
-		this.addImage(aImg);
-		g.free();
-		this.repaintNow();
-		f.updatePosition(pos.x, pos.y);
-
-		CoordsScreen cooS = new CoordsScreen(); // (String)lr.get(4108,"Coordinates:"), (String)lr.get(4108,"Coordinates:"), InfoBox.INPUT);
-		if (cooS.execute()==CoordsScreen.IDOK) {
-			GCPoint gcp = new GCPoint(cooS.getCoords());
-			gcp.bitMapX = pos.x;
-			gcp.bitMapY = pos.y;
-			f.addGCP(gcp); 
-		} else this.removeImage(aImg); // CANCEL pressed
-	}
-}



From mik77 at mail.berlios.de  Tue Sep 18 19:05:11 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Tue, 18 Sep 2007 19:05:11 +0200
Subject: [Cachewolf-svn] r929 - trunk/src/CacheWolf/navi
Message-ID: <200709181705.l8IH5BbQ011359@sheep.berlios.de>

Author: mik77
Date: 2007-09-18 19:05:01 +0200 (Tue, 18 Sep 2007)
New Revision: 929

Added:
   trunk/src/CacheWolf/navi/MapImporter.java
Removed:
   trunk/src/CacheWolf/navi/Map.java
Log:
second step of correct renaming Map.java -> MapImporter.java

Deleted: trunk/src/CacheWolf/navi/Map.java
===================================================================
--- trunk/src/CacheWolf/navi/Map.java	2007-09-18 17:03:52 UTC (rev 928)
+++ trunk/src/CacheWolf/navi/Map.java	2007-09-18 17:05:01 UTC (rev 929)
@@ -1,391 +0,0 @@
-package CacheWolf.navi;
-
-import ewe.util.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-import ewe.sys.*;
-import ewe.ui.*;
-import ewe.graphics.*;
-import ewe.fx.*;
-
-import CacheWolf.CWPoint;
-import CacheWolf.Common;
-import CacheWolf.CoordsScreen;
-import CacheWolf.Global;
-import CacheWolf.InfoBox;
-import CacheWolf.MyLocale;
-import CacheWolf.Preferences;
-
-/**
- *	This class is for importing and manually georeferencing maps
- *	This class id=4100 for cachewolf-languages
- */
-public class MapImporter extends Form {
-	Preferences pref;
-	String mapsPath = new String();
-	String thisMap = new String();
-	public String selectedMap = new String();
-	CellPanel infPanel;
-	mLabel infLabel = new mLabel("                          ");
-	Vector GCPs = new Vector();
-	MapInfoObject wfl = new MapInfoObject();
-	mButton infButton;
-	ScrollBarPanel scp;
-	AniImage mapImg;
-	int imageWidth, imageHeight = 0;
-
-	/**
-	 *	This constructor should be used when importing maps
-	 */
-	public MapImporter(Preferences pref){
-		this.pref = pref;
-		mapsPath = pref.getMapManuallySavePath(true)+"/"; //File.getProgramDirectory() + "/maps/";
-	}
-
-	/**
-	 *	When a user clicks on the map and more than three ground control points exist
-	 *	then the calculated coordinate based on the affine transformation is displayed in the
-	 *	info panel below the map.
-	 *	It helps to identify how good the georeferencing works based on the set GCPs.
-	 */
-	public void updatePosition(int x, int y){
-		if(GCPs.size()>=3  || (wfl.topleft.isValid())){
-			CWPoint p = wfl.calcLatLon(x,y);
-			infLabel.setText("--> " + p.getLatDeg(CWPoint.DMS) + " " +p.getLatMin(CWPoint.DMM) + " / " + p.getLonDeg(CWPoint.DMS) + " " + p.getLonMin(CWPoint.DMM));
-		}
-	}
-
-	/**
-	 *	This is the correct constructor for georeferencing maps.
-	 */
-	public MapImporter(Preferences pref, String mapToLoad, boolean worldfileexists){
-		this.pref = pref;
-		this.title = MyLocale.getMsg(4106,"Calibrate map:") + " " + mapToLoad;
-		this.resizable = true;
-		this.moveable = true;
-		//this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
-		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
-		thisMap = mapToLoad;
-		mapsPath = pref.getMapManuallySavePath(true)+"/"; //File.getProgramDirectory() + "/maps/"; // TDO veraltet
-		try {
-			wfl.loadwfl(mapsPath, thisMap);
-		}catch(FileNotFoundException ex){
-			//	Vm.debug("Cannot load world file!");
-		}catch (IOException ex) { // is thrown if lat/lon out of range
-			MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, "Error"), ex.getMessage(), MessageBox.OKB);
-			tmpMB.execute();
-			Vm.debug("Cannot load world file!");
-		}
-		mapInteractivePanel pane = new mapInteractivePanel(this);
-		scp = new ScrollBarPanel(pane);
-		Image img = new Image(Common.getImageName(mapsPath + thisMap));
-		PixelBuffer pB = new PixelBuffer(img);
-		//pB = pB.scale((int)(pref.myAppWidth*0.98),(int)(pref.myAppHeight*0.98));
-		mapImg = new AniImage(pB.toDrawableImage());
-		pane.addImage(mapImg);
-		scp.setPreferredSize(mapImg.getWidth(),mapImg.getHeight());
-		imageWidth = mapImg.getWidth();
-		imageHeight = mapImg.getHeight();
-		this.addLast(scp.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
-		infPanel = new CellPanel();
-		infPanel.addNext(infLabel,CellConstants.STRETCH, CellConstants.FILL);
-		infButton = new mButton(MyLocale.getMsg(4107,"Done!"));
-		infPanel.addLast(infButton,CellConstants.DONTSTRETCH, CellConstants.FILL);
-		this.addLast(infPanel, CellConstants.DONTSTRETCH, CellConstants.FILL);
-		//scp.repaintNow();
-		//this.repaintNow();
-	}
-
-	/**
-	 *	Add a ground control point to the list
-	 *	If the list is longer than 3 GCPs these will be evaluated
-	 *	to obtain the required parameters for the affine
-	 *	transformation.
-	 */
-	public void addGCP(GCPoint GCP){
-		if (GCP.latDec>90 || GCP.latDec<-90 || GCP.lonDec>360 || GCP.lonDec<-180) throw new IllegalArgumentException("lat/lon out of range: "+GCP.toString());
-		GCPs.add(GCP);
-		if(GCPs.size() >= 3){
-			wfl.evalGCP(GCPs, imageWidth, imageHeight);
-		}
-	}
-
-
-	/**
-	 *	Method to copy ("import") a png based map
-	 *	into the maps folder in the CacheWolf base directory.
-	 *	
-	 *	If the maps directory does not exist it will create it.
-	 *	If it finds .map files it will assume these are oziexplorer calibration files.
-	 *	It will use these files to automatically georeference the files during import.
-	 */
-	public int importMap(){
-		String rawFileName = new String();
-		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir);
-		fc.addMask("*.png,*.gif,*.bmp,*.jpg");
-		fc.setTitle((String)MyLocale.getMsg(4100,"Select Directory:"));
-		int tmp = fc.execute() ; 
-		if(tmp != FileChooser.IDYES) return Form.IDCANCEL;
-		File inDir = fc.getChosenFile();
-		File mapFile;
-		InfoBox inf = new InfoBox("Info", MyLocale.getMsg(4109,"Loading maps...            \n"), InfoBox.PROGRESS_WITH_WARNINGS, false); 
-		inf.setPreferredSize(220, 300);
-		inf.setInfoHeight(100);
-		inf.relayout(false);
-		Vm.showWait(this, true);
-		inf.exec();
-
-		//User selected a map, but maybe there are more png(s)
-		//copy all of them!
-		//at the same time try to find associated .map files!
-		//These are georeference files targeted for OziExplorer.
-		//So lets check if we have more than 1 png file:
-		String line = new String();
-		InputStream in = null;
-		OutputStream out = null;
-		FileReader inMap;
-		byte[] buf;
-		int len;
-		String[] parts;
-		String [] files = inDir.listMultiple("*.png,*.jpg,*.gif,*.bmp", File.LIST_FILES_ONLY);
-
-		String currfile = null;
-		String curInFullPath;
-		String curOutFullPath;
-		int num = files.length;
-		for(int i =  num -1 ; i >= 0;i--){
-			currfile = (String) files[i];
-			inf.setInfo(MyLocale.getMsg(4110,"Loading: ")+ "\n" + currfile + "\n("+(num-i)+"/"+num+")");
-			//Copy the file
-			//Vm.debug("Copy: " + inDir.getFullPath() + "/" +files[i]);
-			//Vm.debug("to: " + mapsPath + files[i]);
-			curInFullPath = inDir.getFullPath() + "/" +currfile;
-			curOutFullPath = mapsPath + currfile;
-			boolean imageerror = false;
-			try {
-				in = new FileInputStream(curInFullPath);
-				buf = new byte[1024*10];
-				boolean first = true;
-				ByteArray header = new ByteArray(buf);
-				while ((len = in.read(buf)) > 0) {
-					if (first) {
-						first = false;
-						header.copyFrom(buf, 0, len);
-						ImageInfo tmpII = Image.getImageInfo(header,null);
-						imageWidth = tmpII.width;
-						imageHeight = tmpII.height;
-						out = new FileOutputStream(curOutFullPath); // only create outfile if geImageInfo didn't throw an exception so do it only here not directly after opening input stream
-					}
-					out.write(buf, 0, len);
-				}
-			} catch(IOException ex){
-				imageerror = true;
-				inf.addWarning("\nIO-Error while copying image from: " + curInFullPath + " to: " + curOutFullPath + " error: " + ex.getMessage());
-			} catch (IllegalArgumentException e) { // thrown from Image.getImageInfo when it could not interprete the header (e.g. bmp with 32 bits per pixel)
-				imageerror = true;
-				inf.addWarning("\nError: could not decode image: " + curInFullPath + " - image not copied");
-			} finally {
-				try {
-					if (in != null) in.close();
-					if (out  != null) out.close(); 
-				} catch (Throwable e) {}
-			}
-			//Check for a .map file
-			rawFileName = currfile.substring(0, currfile.lastIndexOf("."));
-			mapFile = new File(inDir.getFullPath() + "/" + rawFileName + ".map");
-			if(!imageerror && mapFile.exists()){
-				GCPoint gcp1 = new GCPoint();
-				GCPoint gcp2 = new GCPoint();
-				GCPoint gcp3 = new GCPoint();
-				GCPoint gcp4 = new GCPoint();
-				GCPoint gcpG = new GCPoint();
-				//Vm.debug("Found file: " + inDir.getFullPath() + "/" + rawFileName + ".map");
-				try {
-					inMap = new FileReader(inDir.getFullPath() + "/" + rawFileName + ".map");
-					while((line = inMap.readLine()) != null){
-						if(line.equals("MMPNUM,4")){
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							gcp1.bitMapX = Convert.toInt(parts[2]);
-							gcp1.bitMapY = Convert.toInt(parts[3]);
-							if(gcp1.bitMapX == 0) gcp1.bitMapX = 1;
-							if(gcp1.bitMapY == 0) gcp1.bitMapY = 1;
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							gcp2.bitMapX = Convert.toInt(parts[2]);
-							gcp2.bitMapY = Convert.toInt(parts[3]);
-							if(gcp2.bitMapX == 0) gcp2.bitMapX = 1;
-							if(gcp2.bitMapY == 0) gcp2.bitMapY = 1;
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							gcp3.bitMapX = Convert.toInt(parts[2]);
-							gcp3.bitMapY = Convert.toInt(parts[3]);
-							if(gcp3.bitMapX == 0) gcp3.bitMapX = 1;
-							if(gcp3.bitMapY == 0) gcp3.bitMapY = 1;
-							//imageWidth = gcp3.bitMapX;
-							//imageHeight = gcp3.bitMapY;
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							gcp4.bitMapX = Convert.toInt(parts[2]);
-							gcp4.bitMapY = Convert.toInt(parts[3]);
-							if(gcp4.bitMapX == 0) gcp4.bitMapX = 1;
-							if(gcp4.bitMapY == 0) gcp4.bitMapY = 1;
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							if(pref.digSeparator.equals(",")) {
-								parts[3]= parts[3].replace('.', ',');
-								parts[2]= parts[2].replace('.', ',');
-							}
-							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
-							gcpG.bitMapX = gcp1.bitMapX;
-							gcpG.bitMapY = gcp1.bitMapY;
-							addGCP(gcpG);
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							if(pref.digSeparator.equals(",")) {
-								parts[3]= parts[3].replace('.', ',');
-								parts[2]= parts[2].replace('.', ',');
-							}
-							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
-							gcpG.bitMapX = gcp2.bitMapX;
-							gcpG.bitMapY = gcp2.bitMapY;
-							addGCP(gcpG);
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							if(pref.digSeparator.equals(",")) {
-								parts[3]= parts[3].replace('.', ',');
-								parts[2]= parts[2].replace('.', ',');
-							}
-							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
-							gcpG.bitMapX = gcp3.bitMapX;
-							gcpG.bitMapY = gcp3.bitMapY;
-							addGCP(gcpG);
-
-							line = inMap.readLine();
-							parts = mString.split(line, ',');
-							if(pref.digSeparator.equals(",")) {
-								parts[3]= parts[3].replace('.', ',');
-								parts[2]= parts[2].replace('.', ',');
-							}
-							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
-							gcpG.bitMapX = gcp4.bitMapX;
-							gcpG.bitMapY = gcp4.bitMapY;
-							addGCP(gcpG);
-							/* already read from image file itself
-							// get dimensions of image
-							while ( (line = inMap.readLine()) != null){
-								if (line.startsWith("IWH")){
-									parts = mString.split(line, ',');
-									imageWidth = Convert.toInt(parts[2]);
-									imageHeight = Convert.toInt(parts[3]);
-								}
-							}
-							 */
-							wfl.evalGCP(GCPs, imageWidth, imageHeight);
-							//Vm.debug("Saving .map file to: " + mapsPath + "/" + rawFileName + ".wfl");
-							wfl.saveWFL(mapsPath, rawFileName);
-							GCPs.clear();
-						} // if
-
-					} // while
-					if (inMap != null)	inMap.close();
-				} catch(IllegalArgumentException ex){ // is thrown from Convert.toDouble and saveWFL if affine[0-5]==0 NumberFormatException is a subclass of IllegalArgumentExepction
-					inf.addWarning("\nError while importing .map-file: "+ex.getMessage());
-				} catch(IOException ex){
-					inf.addWarning("\nIO-Error while reading or writing calibration file\n" + ex.getMessage());
-				} 
-			} else { // if map file.exists
-				if (!imageerror) inf.addWarning("\nNo calibration file found for: " + currfile + " - you can calibrate it manually");
-			}
-		} // for file
-		Vm.showWait(this, false);
-		inf.addText("\ndone.");
-		inf.addOkButton();
-		//inf.addOkButton(); doesn't work
-		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
-		return Form.IDOK;
-	}
-
-
-
-	/**
-	 *	Handles button pressed event
-	 *	When the button is pressed a mapname.wfl file is saved in the
-	 *	maps directory.
-	 */
-	public void onEvent(Event ev){
-
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			// display coords in another format
-			if (ev.target == infButton){
-				boolean retry = true;
-				while (retry == true) {
-					try {
-						retry = false;
-						wfl.saveWFL(mapsPath, thisMap);
-						if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
-					} catch (IOException e) {
-						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(321, "Error writing file ") + e.getMessage()+MyLocale.getMsg(324, " - retry?"), MessageBox.YESB | MessageBox.NOB);
-						if (tmpMB.execute() == MessageBox.IDYES) retry = true;
-					}catch (IllegalArgumentException e) {
-						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(325, "Map not calibrated")+MyLocale.getMsg(324, " - retry?"), MessageBox.YESB | MessageBox.NOB);
-						if (tmpMB.execute() == MessageBox.IDYES) { retry = true; break; }
-					}
-				}
-				if (!retry) close(0);
-			}
-		}
-	}
-}
-
-/**
- *	Class that creates a panel and loads a map.
- *	It catches click events to display a form where the user may enter the required ccordinates
- *	The data is stored as a ground control point in the calling class: Map
- */
-class mapInteractivePanel extends InteractivePanel{
-	MapImporter f;
-	Locale l = Vm.getLocale();
-	LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
-	public mapInteractivePanel(MapImporter f){
-		this.f = f;
-	}
-
-	/**
-	 *	Event handler to catch clicks on the map
-	 */
-	public void imageClicked(AniImage which, Point pos){
-		//Vm.debug("X = " +pos.x + " Y = " + pos.y);
-		Image img = new Image(31, 31);
-		Graphics g = new Graphics(img);
-		g.setColor(new Color(0,0,0));
-		g.fillRect(0,0,31,31);
-		g.setColor(new Color(255,0,0));
-		g.drawLine(0,16,31,16);
-		g.drawLine(16,0,16,31);
-		AniImage aImg = new AniImage(img);
-		aImg.setLocation(pos.x-16,pos.y-16);
-		aImg.transparentColor = new Color(0,0,0);
-		//aImg.properties = mImage.IsNotHot;
-		aImg.properties = mImage.AlwaysOnTop;
-		this.addImage(aImg);
-		g.free();
-		this.repaintNow();
-		f.updatePosition(pos.x, pos.y);
-
-		CoordsScreen cooS = new CoordsScreen(); // (String)lr.get(4108,"Coordinates:"), (String)lr.get(4108,"Coordinates:"), InfoBox.INPUT);
-		if (cooS.execute()==CoordsScreen.IDOK) {
-			GCPoint gcp = new GCPoint(cooS.getCoords());
-			gcp.bitMapX = pos.x;
-			gcp.bitMapY = pos.y;
-			f.addGCP(gcp); 
-		} else this.removeImage(aImg); // CANCEL pressed
-	}
-}

Copied: trunk/src/CacheWolf/navi/MapImporter.java (from rev 928, trunk/src/CacheWolf/navi/Map.java)



From pfeffer at mail.berlios.de  Tue Sep 18 19:48:10 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Tue, 18 Sep 2007 19:48:10 +0200
Subject: [Cachewolf-svn] r930 - trunk/src/CacheWolf
Message-ID: <200709181748.l8IHmAZ8013424@sheep.berlios.de>

Author: pfeffer
Date: 2007-09-18 19:48:07 +0200 (Tue, 18 Sep 2007)
New Revision: 930

Modified:
   trunk/src/CacheWolf/SpiderGC.java
Log:
ignore case in alias when determining if "found" by user in spider requested here: http://www.geoclub.de/ftopic18812-10.html

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-09-18 17:05:01 UTC (rev 929)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-09-18 17:48:07 UTC (rev 930)
@@ -751,7 +751,7 @@
 			name = exName.findNext();
 			String d=DateFormat.logdate2YMD(exDate.findNext());
 			if((icon.equals(p.getProp("icon_smile")) || icon.equals(p.getProp("icon_camera"))) &&
-				(name.equals(pref.myAlias) || (pref.myAlias2.length()>0 && name.equals(pref.myAlias2))) )  {
+				(name.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()>0 && name.equalsIgnoreCase(pref.myAlias2))) )  {
 				chD.is_found = true;
 				chD.CacheStatus = d;
 			}



From pfeffer at mail.berlios.de  Tue Sep 18 20:20:23 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Tue, 18 Sep 2007 20:20:23 +0200
Subject: [Cachewolf-svn] r931 - trunk/src/CacheWolf
Message-ID: <200709181820.l8IIKNGv016435@sheep.berlios.de>

Author: pfeffer
Date: 2007-09-18 20:20:19 +0200 (Tue, 18 Sep 2007)
New Revision: 931

Modified:
   trunk/src/CacheWolf/CWPoint.java
Log:
i forgot to commit this one in my previous rearangement commit

Modified: trunk/src/CacheWolf/CWPoint.java
===================================================================
--- trunk/src/CacheWolf/CWPoint.java	2007-09-18 17:48:07 UTC (rev 930)
+++ trunk/src/CacheWolf/CWPoint.java	2007-09-18 18:20:19 UTC (rev 931)
@@ -276,6 +276,14 @@
 				lonDec <= 360 && lonDec >= -360;
 	}
 	
+	/**
+	 * mark the Point as invalid
+	 *
+	 */
+	public void makeInvalid() {
+		latDec = -361;
+		lonDec = 91;
+	}
 
 	/**
 	 * set lat and lon by using UTM coordinates  



From pfeffer at mail.berlios.de  Thu Sep 20 02:18:57 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 20 Sep 2007 02:18:57 +0200
Subject: [Cachewolf-svn] r932 - trunk/src/CacheWolf/navi
Message-ID: <200709200018.l8K0IvSo013048@sheep.berlios.de>

Author: pfeffer
Date: 2007-09-20 02:18:53 +0200 (Thu, 20 Sep 2007)
New Revision: 932

Modified:
   trunk/src/CacheWolf/navi/MovingMap.java
Log:
fix: nullpointerexception on right-click in moving map (caused by the earlier extension for moon and star directions)

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2007-09-18 18:20:19 UTC (rev 931)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2007-09-20 00:18:53 UTC (rev 932)
@@ -1342,6 +1342,10 @@
 	int lastZoomWidth , lastZoomHeight;
 	public MovingMapPanel(MovingMap f){
 		this.mm = f;
+		miLuminary = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
+		for (int i=0; i<SkyOrientation.LUMINARY_NAMES.length; i++) {
+			miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i));
+		}
 		set(Control.WantHoldDown, true); // want to get simulated right-clicks
 	}
 
@@ -1580,10 +1584,8 @@
 				}
 			}
 			else {			
-				miLuminary = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
-
 				for (int i=0; i<SkyOrientation.LUMINARY_NAMES.length; i++) {
-					kontextMenu.addItem(miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i)));
+					kontextMenu.addItem(miLuminary[i]);
 					if (i == mm.myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
 					else miLuminary[i].modifiers &= MenuItem.Checked;
 				}



From kalli at mail.berlios.de  Sat Sep 22 14:29:43 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Sat, 22 Sep 2007 14:29:43 +0200
Subject: [Cachewolf-svn] r933 - trunk/src/exp
Message-ID: <200709221229.l8MCThEn026105@sheep.berlios.de>

Author: kalli
Date: 2007-09-22 14:29:37 +0200 (Sat, 22 Sep 2007)
New Revision: 933

Modified:
   trunk/src/exp/Exporter.java
Log:
Bugfix: OVL-Export hat nicht funktioniert

Modified: trunk/src/exp/Exporter.java
===================================================================
--- trunk/src/exp/Exporter.java	2007-09-20 00:18:53 UTC (rev 932)
+++ trunk/src/exp/Exporter.java	2007-09-22 12:29:37 UTC (rev 933)
@@ -243,7 +243,7 @@
 	 * @param count of actual record
 	 * @return formated cache data
 	 */
-	public String record(CacheHolder ch, String lat, String lon, int count){
+	public String record(CacheHolderDetail ch, String lat, String lon, int count){
 		return null;
 	}
 	



From salzkammergut at mail.berlios.de  Sat Sep 22 17:58:55 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 22 Sep 2007 17:58:55 +0200
Subject: [Cachewolf-svn] r934 - in trunk: resources src/CacheWolf
Message-ID: <200709221558.l8MFwtSM007680@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-22 17:58:47 +0200 (Sat, 22 Sep 2007)
New Revision: 934

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/PreferencesScreen.java
   trunk/src/CacheWolf/SpiderGC.java
Log:
Feature: Proxyeinstellungen koennen ueber Checkbox ein-/ausgeschaltet werden

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-09-22 12:29:37 UTC (rev 933)
+++ trunk/resources/cachewolf.Languages.cfg	2007-09-22 15:58:47 UTC (rev 934)
@@ -181,6 +181,7 @@
 		631=PDA hat Schliessen Button 
 		632=Mehr
 		633=Max. logs spidern
+		634=Proxy verwenden
 		700=Filter setzen
 		701=Entfernung
 		702=Schwierigkeit
@@ -730,6 +731,7 @@
 		631=PDA has close Button
 		632=More
 		633=Max. logs to spider
+		634=use Proxy
 		700=Set filter
 		701=Distance
 		702=Difficulty
@@ -1269,6 +1271,7 @@
 		631=PDA heeft stopknop.
 		632=Meer
 		633=Maximale logs naar werkgeheugen
+		634=use Proxy
 		700=Selecteer filter
 		701=Afstand
 		702=Moeilijkheidsgraad

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-09-22 12:29:37 UTC (rev 933)
+++ trunk/src/CacheWolf/Preferences.java	2007-09-22 15:58:47 UTC (rev 934)
@@ -75,6 +75,8 @@
 	public String myproxy = "";    
 	/** Proxyport when spidering */
 	public String myproxyport = "";
+	/** Flag whether proxy is to be used */
+	public boolean proxyActive=false;
 	/** Serial port name and baudrate */
 	public SerialPortOptions mySPO = new SerialPortOptions();
 	/** True if the GPS data should be forwarded to an IP address */
@@ -233,6 +235,8 @@
 		if(name.equals("proxy")) {
 			myproxy = atts.getValue("prx");
 			myproxyport = atts.getValue("prt");
+			tmp = atts.getValue("active");
+			if (tmp != null) proxyActive=Boolean.valueOf(tmp).booleanValue();
 		}
 		if (name.equals("garmin")) {
 			garminConn=atts.getValue("connection");
@@ -316,7 +320,7 @@
 			outp.print("	<alias name =\""+ SafeXML.clean(myAlias) +"\" password=\""+SafeXML.clean(password)+"\" />\n");
 			outp.print("	<alias2 name =\""+ SafeXML.clean(myAlias2) +"\"/>\n");
 			outp.print("	<browser name = \""+browser+"\"/>\n");
-			outp.print("	<proxy prx = \""+ myproxy+"\" prt = \""+ myproxyport + "\"/>\n");
+			outp.print("	<proxy prx = \""+ myproxy+"\" prt = \""+ myproxyport + "\" active = \""+ proxyActive +"\" />\n");
 			outp.print("	<port portname = \""+ mySPO.portName +"\" baud = \""+ mySPO.baudRate+"\"/>\n");
 			outp.print("	<portforward active= \""+ Convert.toString(forwardGPS)+"\" destinationHost = \""+ forwardGpsHost+"\"/>\n");
 			outp.print("    <font size =\""+fontSize+"\"/>\n");

Modified: trunk/src/CacheWolf/PreferencesScreen.java
===================================================================
--- trunk/src/CacheWolf/PreferencesScreen.java	2007-09-22 12:29:37 UTC (rev 933)
+++ trunk/src/CacheWolf/PreferencesScreen.java	2007-09-22 15:58:47 UTC (rev 934)
@@ -18,7 +18,7 @@
 	mInput NSDeg, NSm, EWDeg, EWm, DataDir, Proxy, ProxyPort, Alias, nLogs, Browser, fontSize, inpGPS, 
 	       inpLogsPerPage,inpMaxLogsToSpider,inpPassword,inpLanguage;
 	mCheckBox dif, ter, loc, own, hid, stat, dist, bear, chkAutoLoad, chkShowDeletedImg, chkMenuAtTop, 
-	          chkTabsAtTop, chkShowStatus,chkHasCloseButton,chkSynthShort;
+	          chkTabsAtTop, chkShowStatus,chkHasCloseButton,chkSynthShort,chkProxyActive;
 	mTabbedPanel mTab;
 	mChoice chcGarminPort;
 	mLabel lblGarmin;
@@ -154,12 +154,14 @@
 		/////////////////////////////////////////////////////////
 		CellPanel pnlProxy=new CellPanel();
 		pnlProxy.addNext(new mLabel("Proxy"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		pnlProxy.addLast(Proxy = new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		pnlProxy.addLast(Proxy = new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST)).setTag(SPAN,new Dimension(2,1));
 		Proxy.setText(pref.myproxy);
 		pnlProxy.addNext(new mLabel("Port"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		pnlProxy.addNext(ProxyPort = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlProxy.addLast(ProxyPort = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		ProxyPort.setText(pref.myproxyport);
-		pnlProxy.addLast(new mLabel("")).setTag(SPAN,new Dimension(2,1));
+		pnlProxy.addNext(new mLabel(""),HSTRETCH,HFILL);
+		pnlProxy.addLast(chkProxyActive=new mCheckBox(MyLocale.getMsg(634,"use Proxy")));
+		chkProxyActive.setState(pref.proxyActive);
 		pnlMore.addLast(pnlProxy,HSTRETCH,HFILL);
 		pnlMore.addNext(new mLabel(MyLocale.getMsg(592,"Language (needs restart)")),DONTSTRETCH,DONTFILL|WEST);
 		pnlMore.addLast(inpLanguage=new mInput(MyLocale.language),DONTSTRETCH,DONTFILL|WEST);
@@ -239,6 +241,7 @@
 				//Vm.debug(myPreferences.browser);
 				pref.myproxy = Proxy.getText();
 				pref.myproxyport = ProxyPort.getText();
+				pref.proxyActive=chkProxyActive.getState();
 				//myPreferences.nLogs = Convert.parseInt(nLogs.getText());
 				pref.autoReloadLastProfile=chkAutoLoad.getState();
 				pref.showDeletedImages=chkShowDeletedImg.getState();

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-09-22 12:29:37 UTC (rev 933)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-09-22 15:58:47 UTC (rev 934)
@@ -383,7 +383,7 @@
 				if (!getCacheByWaypointName(chD,false,getImages,doNotgetFound,true)) break;
 				if (!chD.is_found || !doNotgetFound ) {
 					chD.saveCacheDetails(profile.dataDir);
-					cacheDB.add(new CacheHolder(chD)); // TODO Could copy into existing object
+					cacheDB.add(new CacheHolder(chD)); 
 				}
 			}
 		}
@@ -939,7 +939,7 @@
 		ByteArray daten;
 		String datei = "";
 		datei = profile.dataDir + target;
-		if(pref.myproxy.length()>0){
+		if(pref.myproxy.length()>0 && pref.proxyActive){
 			connImg = new HttpConnection(pref.myproxy, Convert.parseInt(pref.myproxyport), imgUrl);
 		}else{
 			connImg = new HttpConnection(imgUrl);
@@ -1042,7 +1042,7 @@
 			try{
 				//Vm.debug(address);
 				HttpConnection conn;
-				if(pref.myproxy.length() > 0){
+				if(pref.myproxy.length() > 0 && pref.proxyActive){
 					pref.log("Using proxy: " + pref.myproxy + " / " +pref.myproxyport);
 					conn = new HttpConnection(pref.myproxy, Convert.parseInt(pref.myproxyport), address);
 					//Vm.debug(address);
@@ -1108,7 +1108,7 @@
 
 			//String line = "";
 			String totline = "";
-			if(pref.myproxy.length()==0){
+			if(!pref.proxyActive){
 				try {
 					/*
 					// Create a socket to the host



From salzkammergut at mail.berlios.de  Sat Sep 22 18:13:17 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 22 Sep 2007 18:13:17 +0200
Subject: [Cachewolf-svn] r935 - trunk/src/CacheWolf
Message-ID: <200709221613.l8MGDHML008631@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-22 18:13:10 +0200 (Sat, 22 Sep 2007)
New Revision: 935

Modified:
   trunk/src/CacheWolf/myTableControl.java
Log:
myTableControl: Bugfix Loeschen von Caches: NPE 

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-09-22 15:58:47 UTC (rev 934)
+++ trunk/src/CacheWolf/myTableControl.java	2007-09-22 16:13:10 UTC (rev 935)
@@ -138,7 +138,7 @@
 				pbf.exec();
 				int nDeleted=0;
 				int size=cacheDB.size();
-				for(int i = 0; i <size; i++){
+				for(int i = size-1; i >=0; i--){// Start Counting down, as the size decreases with each deleted cache
 					ch = (CacheHolder)cacheDB.get(i);
 					if(ch.is_Checked == true) {
 						nDeleted++;



From mirabilos at mail.berlios.de  Mon Sep 24 14:15:26 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Mon, 24 Sep 2007 14:15:26 +0200
Subject: [Cachewolf-svn] r936 - trunk/resources/attributes-big
Message-ID: <200709241215.l8OCFQYu011685@sheep.berlios.de>

Author: mirabilos
Date: 2007-09-24 14:15:26 +0200 (Mon, 24 Sep 2007)
New Revision: 936

Added:
   trunk/resources/attributes-big/night.gif
Log:
OC.de?s ?nightcache yes? gif
(we use the GC.com one for the ?nightcache no?)


Added: trunk/resources/attributes-big/night.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/night.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From pfeffer at mail.berlios.de  Mon Sep 24 16:56:43 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Mon, 24 Sep 2007 16:56:43 +0200
Subject: [Cachewolf-svn] r937 - trunk/src/CacheWolf
Message-ID: <200709241456.l8OEuhui025401@sheep.berlios.de>

Author: pfeffer
Date: 2007-09-24 16:56:38 +0200 (Mon, 24 Sep 2007)
New Revision: 937

Modified:
   trunk/src/CacheWolf/MainMenu.java
Log:
it semmes that I forgot to commit this file some time ago. Thanks to MGisbers for finding the compile problem

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-09-24 12:15:26 UTC (rev 936)
+++ trunk/src/CacheWolf/MainMenu.java	2007-09-24 14:56:38 UTC (rev 937)
@@ -1,6 +1,6 @@
 package CacheWolf;
 
-import CacheWolf.navi.Map;
+import CacheWolf.navi.MapImporter;
 import CacheWolf.navi.MapLoaderGui;
 import CacheWolf.navi.SelectMap;
 import ewe.ui.*;
@@ -410,7 +410,7 @@
 			}
 			if(mev.selectedItem == importmap){
 
-				Map map = new Map(pref);
+				MapImporter map = new MapImporter(pref);
 				map.importMap();
 			}
 			if(mev.selectedItem == kalibmap){
@@ -418,7 +418,7 @@
 				sM.execute();
 				if((sM.getSelectedMap()).length()>0){
 					try {
-						Map map = new Map(pref, sM.getSelectedMap(),sM.worldfileexists);
+						MapImporter map = new MapImporter(pref, sM.getSelectedMap(),sM.worldfileexists);
 						map.execute(null, Gui.CENTER_FRAME);
 					} catch (java.lang.OutOfMemoryError e) {
 						MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, "Error"), MyLocale.getMsg(156,"Out of memory error, map to big"), MessageBox.OKB);



From bilbowolf at mail.berlios.de  Mon Sep 24 17:13:48 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Mon, 24 Sep 2007 17:13:48 +0200
Subject: [Cachewolf-svn] r938 - in trunk: resources src/CacheWolf
	src/CacheWolf/imp
Message-ID: <200709241513.l8OFDmXJ027138@sheep.berlios.de>

Author: bilbowolf
Date: 2007-09-24 17:13:26 +0200 (Mon, 24 Sep 2007)
New Revision: 938

Added:
   trunk/src/CacheWolf/imp/
   trunk/src/CacheWolf/imp/KMLImporter.java
Modified:
   trunk/resources/goto.gif
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/Version.java
Log:


Modified: trunk/resources/goto.gif
===================================================================
(Binary files differ)

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-09-24 14:56:38 UTC (rev 937)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-09-24 15:13:26 UTC (rev 938)
@@ -80,6 +80,8 @@
 public boolean is_HTML = true;
 /** List of additional waypoints associated with this waypoint */
 public Vector addiWpts = new Vector();
+/** in range is used by the route filter to identify caches in range of a segment*/
+public boolean in_range = false;
 /** If this is an additional waypoint, this links back to the main waypoint */
 public CacheHolder mainCache;
 /** The date this cache was last synced with OC in format yyyyMMddHHmmss */

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2007-09-24 14:56:38 UTC (rev 937)
+++ trunk/src/CacheWolf/Filter.java	2007-09-24 15:13:26 UTC (rev 938)
@@ -4,6 +4,7 @@
 import ewe.sys.*;
 import ewe.io.*;
 import com.stevesoft.ewe_pat.*;
+import CacheWolf.imp.*;
 
 /**
 *	Class that actually filters the cache database.<br>
@@ -119,40 +120,46 @@
 		CacheHolder ch;
 		double lat,lon, calcDistance = 0;
 		try{
-			FileReader in = new FileReader(routeFile);
-			String line; 
-			while((line = in.readLine()) != null){
-				rex.search(line);
-				/*
-				Vm.debug(line);
-				Vm.debug(rex.stringMatched(1));
-				Vm.debug(rex.stringMatched(2));
-				Vm.debug(rex.stringMatched(3));
-				Vm.debug(rex.stringMatched(5));
-				
-				Vm.debug(rex.stringMatched(6));
-				Vm.debug(rex.stringMatched(7));
-				Vm.debug(rex.stringMatched(8));
-				Vm.debug(rex.stringMatched(10));
-				Vm.debug(" ");
-				*/
-				// parse the route file
-				if(rex.didMatch()){
-					lat = Convert.toDouble(rex.stringMatched(2)) + Convert.toDouble(rex.stringMatched(3))/60 + Convert.toDouble(rex.stringMatched(5))/60000;
-					lon = Convert.toDouble(rex.stringMatched(7)) + Convert.toDouble(rex.stringMatched(8))/60 + Convert.toDouble(rex.stringMatched(10))/60000;
-				
-					if(rex.stringMatched(1).equals("S") || rex.stringMatched(1).equals("s")) lat = -lat;
-					if(rex.stringMatched(6).equals("W") || rex.stringMatched(6).equals("w")) lon = -lon;	
-				
-					cwp = new CWPoint(lat, lon);
+			if((routeFile.getFullPath()).indexOf(".kml") > 0){
+				KMLImporter kml = new KMLImporter(routeFile.getFullPath());
+				kml.importFile();
+				wayPoints = kml.getPoints();
+			} else {
+				FileReader in = new FileReader(routeFile);
+				String line; 
+				while((line = in.readLine()) != null){
+					rex.search(line);
+					/*
+					Vm.debug(line);
+					Vm.debug(rex.stringMatched(1));
+					Vm.debug(rex.stringMatched(2));
+					Vm.debug(rex.stringMatched(3));
+					Vm.debug(rex.stringMatched(5));
 					
-					wayPoints.add(cwp);
+					Vm.debug(rex.stringMatched(6));
+					Vm.debug(rex.stringMatched(7));
+					Vm.debug(rex.stringMatched(8));
+					Vm.debug(rex.stringMatched(10));
+					Vm.debug(" ");
+					*/
+					// parse the route file
+					if(rex.didMatch()){
+						lat = Convert.toDouble(rex.stringMatched(2)) + Convert.toDouble(rex.stringMatched(3))/60 + Convert.toDouble(rex.stringMatched(5))/60000;
+						lon = Convert.toDouble(rex.stringMatched(7)) + Convert.toDouble(rex.stringMatched(8))/60 + Convert.toDouble(rex.stringMatched(10))/60000;
+					
+						if(rex.stringMatched(1).equals("S") || rex.stringMatched(1).equals("s")) lat = -lat;
+						if(rex.stringMatched(6).equals("W") || rex.stringMatched(6).equals("w")) lon = -lon;	
+					
+						cwp = new CWPoint(lat, lon);
+						
+						wayPoints.add(cwp);
+					}
 				}
 			}
 			//initialize database
 			for(int i = cacheDB.size()-1; i >=0 ; i--){
 				ch = (CacheHolder)cacheDB.get(i);
-				ch.is_filtered = true;
+				ch.in_range = false;
 				//cacheDB.set(i, ch);
 			}
 			// for each segment of the route...
@@ -170,13 +177,16 @@
 					calcDistance = calcDistance * 1.852;
 					//Vm.debug("Distcalc: " + calcDistance + "Cache: " +ch.CacheName + " / z is = " + z);
 					if(calcDistance <= distance) {
-						Vm.debug("Distcalc: " + calcDistance + "Cache: " +ch.CacheName + " / z is = " + z);
-						ch.is_filtered = false;
+						//Vm.debug("Distcalc: " + calcDistance + "Cache: " +ch.CacheName + " / z is = " + z);
+						ch.in_range = true;
 					}
 					//cacheDB.set(i, ch);
 				} // for database
 			} // for segments
-			
+			for(int i = cacheDB.size()-1; i >=0 ; i--){
+				ch = (CacheHolder)cacheDB.get(i);
+				if(ch.is_filtered == false && ch.in_range == false) ch.is_filtered = true;
+			}
 		}catch(FileNotFoundException fnex){
 			(new MessageBox("Error", "File not found", MessageBox.OKB)).execute();
 		}catch(IOException ioex){

Modified: trunk/src/CacheWolf/Version.java
===================================================================
--- trunk/src/CacheWolf/Version.java	2007-09-24 14:56:38 UTC (rev 937)
+++ trunk/src/CacheWolf/Version.java	2007-09-24 15:13:26 UTC (rev 938)
@@ -10,7 +10,7 @@
 	static final String VER_MAJOR = "BE";
 	static final String VER_MINOR = "";
 	static final String VER_BUILD = " ";
-	static final String VER_SVN ="$LastChangedRevision$"; // the number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
+	static final String VER_SVN ="$LastChangedRevision$"; //the number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
 	
 	/**
 	 * @return

Added: trunk/src/CacheWolf/imp/KMLImporter.java
===================================================================
--- trunk/src/CacheWolf/imp/KMLImporter.java	2007-09-24 14:56:38 UTC (rev 937)
+++ trunk/src/CacheWolf/imp/KMLImporter.java	2007-09-24 15:13:26 UTC (rev 938)
@@ -0,0 +1,93 @@
+package CacheWolf.imp;
+
+import ewesoft.xml.*;
+import ewe.util.*;
+import ewesoft.xml.sax.*;
+import ewe.io.*;
+import ewe.sys.*;
+import CacheWolf.Extractor;
+import CacheWolf.CWPoint;
+
+/**
+ * Class to import coordinates from a KML file generated from
+ * google earth.
+ * it looks for <placemark><MultiGeometry><LineString><coordinates>
+ * and gathers all coordinated in a vector
+ * @author Bilbowolf
+ *
+ */
+public class KMLImporter extends MinML {
+	
+	public Vector points = new Vector();
+	private CWPoint point = new CWPoint();
+	private String file = new String();
+	String strData = new String();
+	private int status = 0;
+	private static int MultiGeometry = 1;
+	private static int LineString = 2;
+	private static int coordinates = 3;
+	
+	public KMLImporter(String file){
+		this.file = file;
+	}
+	
+	public void importFile() {
+		try{
+			Reader r;
+			Vm.showWait(true);
+			r = new FileReader(file);
+			parse(r);
+			r.close();
+			Vm.showWait(false);
+		}catch(Exception e){
+			//Vm.debug(e.toString());
+			Vm.showWait(false);
+		}
+	}
+	
+	public Vector getPoints(){
+		return points;
+	}
+	
+	public void startElement(String name, AttributeList atts){
+		strData = "";
+		if(name.equals("MultiGeometry")) status = MultiGeometry;
+		if(name.equals("LineString") && status == MultiGeometry) status = LineString;
+		if(name.equals("coordinates") && status == LineString) status = coordinates;
+	}
+	
+	public void endElement(String name){
+		if(name.equals("coordinates") && status == coordinates){
+			parseCoordinatesLine();
+			//10.09052,49.78188000000001,0
+		}
+		if(name.equals("LineString") && status == coordinates) status = LineString;
+		if(name.equals("MultiGeometry") && status == LineString) status = 0;
+	}
+	
+	public void characters(char[] ch,int start,int length){
+		String chars = new String(ch,start,length);
+		strData += chars;
+	}
+	
+	private void parseCoordinatesLine(){
+		StringTokenizer exBlock = new StringTokenizer(strData, " ");
+		StringTokenizer numbers;
+		String lat = new String();
+		String lon = new String();
+		
+		String test = new String();
+		
+		while(exBlock.hasMoreTokens()){
+			test = exBlock.nextToken();
+			//Vm.debug("==> " + test + " <==");
+			numbers = new StringTokenizer(test, ",");
+			//Vm.debug(numbers.nextToken());
+			//Vm.debug(numbers.nextToken());
+			lon = numbers.nextToken();
+			lat = numbers.nextToken();
+			point = new CWPoint(Convert.parseDouble(lat),Convert.parseDouble(lon));
+			points.add(point);
+		}
+	}
+}
\ No newline at end of file



From pfeffer at mail.berlios.de  Tue Sep 25 16:36:13 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Tue, 25 Sep 2007 16:36:13 +0200
Subject: [Cachewolf-svn] r939 - trunk/src/CacheWolf/navi
Message-ID: <200709251436.l8PEaDOp018176@sheep.berlios.de>

Author: pfeffer
Date: 2007-09-25 16:36:00 +0200 (Tue, 25 Sep 2007)
New Revision: 939

Modified:
   trunk/src/CacheWolf/navi/MapLoaderGui.java
Log:
fix: new error message when trying to download maps around a not set center see http://www.geoclub.de/ftopic19034-0.html

Modified: trunk/src/CacheWolf/navi/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoaderGui.java	2007-09-24 15:13:26 UTC (rev 938)
+++ trunk/src/CacheWolf/navi/MapLoaderGui.java	2007-09-25 14:36:00 UTC (rev 939)
@@ -226,6 +226,10 @@
 							(new MessageBox("Error", "'overlapping' must be greater or equal 0 ", MessageBox.OKB)).execute();
 							return;
 						}
+						if (!center.isValid() && !forCachesChkBox.getState()) {
+							(new MessageBox("Error", "Please enter the 'center' around which the maps shall be downloaded", MessageBox.OKB)).execute();
+							return;
+						}
 					}
 				} else { // per cache
 					perCache = true;



From mirabilos at mail.berlios.de  Tue Sep 25 17:06:47 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Tue, 25 Sep 2007 17:06:47 +0200
Subject: [Cachewolf-svn] r940 - in trunk: resources src/CacheWolf
	src/CacheWolf/navi src/exp
Message-ID: <200709251506.l8PF6lPh019979@sheep.berlios.de>

Author: mirabilos
Date: 2007-09-25 17:06:44 +0200 (Tue, 25 Sep 2007)
New Revision: 940

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/ImagePanel.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/MyLocale.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/OCXMLImporterScreen.java
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/RadarPanel.java
   trunk/src/CacheWolf/SolverPanel.java
   trunk/src/CacheWolf/SpiderGC.java
   trunk/src/CacheWolf/StatusBar.java
   trunk/src/CacheWolf/TablePanel.java
   trunk/src/CacheWolf/Tokenizer.java
   trunk/src/CacheWolf/myTableControl.java
   trunk/src/CacheWolf/navi/GotoPanel.java
   trunk/src/CacheWolf/navi/MapInfoObject.java
   trunk/src/CacheWolf/navi/MapLoader.java
   trunk/src/CacheWolf/navi/MapLoaderGui.java
   trunk/src/CacheWolf/navi/MapsList.java
   trunk/src/CacheWolf/navi/MovingMap.java
   trunk/src/CacheWolf/navi/Navigate.java
   trunk/src/exp/TPLExporter.java
Log:
fix English: center->centre, updatepors, ticked voher(comment out) (ok pfeffer@), while here, also ???ize->???ise

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/resources/cachewolf.Languages.cfg	2007-09-25 15:06:44 UTC (rev 940)
@@ -630,7 +630,7 @@
 		191=Select file
 		192=Save changes
 		193=add Addis
-		195=Current Center
+		195=Current Centre
 		196=Total # of caches (GC&OC)%0aTotal # visible%0aTotal # found
 		197=Show/Hide cachetour	
 		198=Cachetour
@@ -652,7 +652,7 @@
 		306=Owner:
 		307=Status:
 		308=Notes:
-		309=Set as center
+		309=Set as centre
 		310=Delete
 		311=New Waypoint
 		312=Save
@@ -807,7 +807,7 @@
 		1015=Select all
 		1016=Deselect all
 		1018=Open offline in Browser
-		1019=Set this as center
+		1019=Set this as centre
 		1020=Open online in Browser
 		1021=Open cache description
 		1022=Delete all caches that have a tick?
@@ -820,7 +820,7 @@
 		1107=New
 		1108=Choose profile
 		1109=Open
-		1110=Center
+		1110=Centre
 		1111=Create new profile:
 		1112=New profile name
 		1113=Cannot create directory (must not contain caracters forbidden by operating system)
@@ -1036,7 +1036,7 @@
 		5506=Password
 		5507=Status
 		5508=Logging in...
-		5509=Coordinates for center must be set
+		5509=Coordinates for centre must be set
 		5510=Spider Options
 		5511=Found+
 		5512=+caches

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -30,13 +30,13 @@
 public String DateHidden = EMPTY;
 /** The size of the cache (as per GC cache sizes Micro, Small, ....) */
 public String CacheSize = "None";
-/** The distance from the center in km */
+/** The distance from the centre in km */
 public double kilom = 0;
 /** The formatted distance such as "x.xx km" */
 public String distance = NODISTANCE;
-/** The bearing N, NNE, NE, ENE ... from the current center to this point */
+/** The bearing N, NNE, NE, ENE ... from the current centre to this point */
 public String bearing = NOBEARING;
-/** The angle (0=North, 180=South) from the current center to this point */
+/** The angle (0=North, 180=South) from the current centre to this point */
 public double degrees = 0;
 /** The difficulty of the cache from 1 to 5 in .5 incements */ 
 public String hard = EMPTY;

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -129,7 +129,7 @@
 		//btnNotes = new mButton("Notes");
 		//this.addLast(btnNotes.setTag(Control.SPAN, new Dimension(3,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		//this.addNext(new mLabel(MyLocale.getMsg(308,"Notes:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		//this.addLast(btnCenter = new mButton(MyLocale.getMsg(309,"Make Center")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		//this.addLast(btnCenter = new mButton(MyLocale.getMsg(309,"Make Centre")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 //		this.addLast(btnDelete = new mButton(MyLocale.getMsg(310,"Delete")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		attV=new AttributesViewer();
 		this.addLast(attV);
@@ -364,9 +364,9 @@
 					thisCache.pos.set(coords);
 					btnWayLoc.setText(coords.toString());
 					thisCache.LatLon=coords.toString();
-					// If the current center is valid, calculate the distance and bearing to it
-					CWPoint center=Global.getPref().curCentrePt;
-					if (center.isValid()) thisCache.calcDistance(center);
+					// If the current centre is valid, calculate the distance and bearing to it
+					CWPoint centre=Global.getPref().curCentrePt;
+					if (centre.isValid()) thisCache.calcDistance(centre);
 				}
 			}
 			else if (ev.target==btnFoundDate) {

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/Filter.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -156,7 +156,7 @@
 					}
 				}
 			}
-			//initialize database
+			//initialise database
 			for(int i = cacheDB.size()-1; i >=0 ; i--){
 				ch = (CacheHolder)cacheDB.get(i);
 				ch.in_range = false;

Modified: trunk/src/CacheWolf/ImagePanel.java
===================================================================
--- trunk/src/CacheWolf/ImagePanel.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/ImagePanel.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -17,7 +17,7 @@
 public class ImagePanel extends InteractivePanel{
 	/** Picture to replace deleted pictures */
 	private final String NO_IMAGE="no_picture.png";
-	/** Minimum time (msec) to recognize a long pen down event (=right mouse key) */
+	/** Minimum time (msec) to recognise a long pen down event (=right mouse key) */
 	private final int LONG_PEN_DOWN_DURATION=500;
 
 	Preferences pref;

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/MainMenu.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -92,14 +92,14 @@
 		mapMenuItems[2] = kalibmap = new MenuItem(MyLocale.getMsg(151,"Calibrate"));
 		Menu mapsMenu = new Menu(mapMenuItems, null);
 
-		// Now we start with the horizontal menu bar "Application", "Search", "Filter", "Organize", "About"
+		// Now we start with the horizontal menu bar "Application", "Search", "Filter", "Organise", "About"
 		///////////////////////////////////////////////////////////////////////
 		// Create the "Application" pulldown menu
 		///////////////////////////////////////////////////////////////////////
 		MenuItem [] appMenuItems=new MenuItem[11];
 		appMenuItems[0] = profiles 	 = new MenuItem(MyLocale.getMsg(121,"Profile"), 0, profileMenu); 
 		appMenuItems[1] = preferences = new MenuItem(MyLocale.getMsg(108,"Preferences")); 
-		appMenuItems[2] = mnuEditCenter = new MenuItem(MyLocale.getMsg(1110,"Center"));
+		appMenuItems[2] = mnuEditCenter = new MenuItem(MyLocale.getMsg(1110,"Centre"));
 		appMenuItems[3] = mnuSeparator;
 		appMenuItems[4] = new MenuItem(MyLocale.getMsg(175,"Import"),0,importMenu);
 		appMenuItems[5] = new MenuItem(MyLocale.getMsg(107,"Export"),0,exportMenu);
@@ -159,15 +159,15 @@
 		}
 		
 		///////////////////////////////////////////////////////////////////////
-		// Create the "Organize" pulldown menu
+		// Create the "Organise" pulldown menu
 		///////////////////////////////////////////////////////////////////////
-		MenuItem[] organizeMenuItems=new MenuItem[5];
-		organizeMenuItems[0] = orgCopy  = new MenuItem(MyLocale.getMsg(141,"Copy")); 
-		organizeMenuItems[1] = orgMove  = new MenuItem(MyLocale.getMsg(142,"Move")); 
-		organizeMenuItems[2] = orgDelete   = new MenuItem(MyLocale.getMsg(143,"Delete"));
-		organizeMenuItems[3] = mnuSeparator;
-		organizeMenuItems[4] = orgTravelbugs = new MenuItem(MyLocale.getMsg(139,"Manage travelbugs"));
-		this.addMenu(new PullDownMenu(MyLocale.getMsg(140,"Organize"),new Menu(organizeMenuItems,null)));
+		MenuItem[] organiseMenuItems=new MenuItem[5];
+		organiseMenuItems[0] = orgCopy  = new MenuItem(MyLocale.getMsg(141,"Copy")); 
+		organiseMenuItems[1] = orgMove  = new MenuItem(MyLocale.getMsg(142,"Move")); 
+		organiseMenuItems[2] = orgDelete   = new MenuItem(MyLocale.getMsg(143,"Delete"));
+		organiseMenuItems[3] = mnuSeparator;
+		organiseMenuItems[4] = orgTravelbugs = new MenuItem(MyLocale.getMsg(139,"Manage travelbugs"));
+		this.addMenu(new PullDownMenu(MyLocale.getMsg(140,"Organise"),new Menu(organiseMenuItems,null)));
 
 		///////////////////////////////////////////////////////////////////////
 		// Create the "About" pulldown menu
@@ -510,7 +510,7 @@
 				Global.mainForm.toggleCacheListVisible();			
 			}
 			///////////////////////////////////////////////////////////////////////
-			// "Organize" pulldown menu
+			// "Organise" pulldown menu
 			///////////////////////////////////////////////////////////////////////
 			if(mev.selectedItem == orgCopy){
 				profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/MainTab.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -229,7 +229,7 @@
 		}
 	}
 	
-	/** Update the distances of all caches to the center and display a message 
+	/** Update the distances of all caches to the centre and display a message 
 	 */
 	public void updateBearDist(){// Called from DetailsPanel, GotoPanel and myTableControl
 		tbP.pref = pref;

Modified: trunk/src/CacheWolf/MyLocale.java
===================================================================
--- trunk/src/CacheWolf/MyLocale.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/MyLocale.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -48,9 +48,9 @@
 	}
 
 	/**
-	 * Return a localized string
+	 * Return a localised string
 	 * 
-     * The localized strings are stored in the configuration file (relative to
+     * The localised strings are stored in the configuration file (relative to
      *  executable:<br>
      *  	_config/cachewolf.Languages.cfg
      * If the configuration file does not exist or a string cannot be found in
@@ -58,7 +58,7 @@
      *   
 	 * @param resourceID   The unique number of the resource
 	 * @param defaultValue The default value of the string (if not found in the config file)
-	 * @return The localized string 
+	 * @return The localised string 
 	 */
 	public static String getMsg(int resourceID, String defaultValue) {
 		if (l==null) 

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -131,9 +131,9 @@
 		String url = new String();
 
 		String lastS =  profile.last_sync_opencaching;
-		CWPoint center = pref.curCentrePt; // No need to clone curCentrePt as center is only read
-		if (!center.isValid()) {
-			(new MessageBox("Error", "Coordinates for center must be set", MessageBox.OKB)).execute();
+		CWPoint centre = pref.curCentrePt; // No need to clone curCentrePt as centre is only read
+		if (!centre.isValid()) {
+			(new MessageBox("Error", "Coordinates for centre must be set", MessageBox.OKB)).execute();
 			return;
 		}
 		OCXMLImporterScreen importOpt = new OCXMLImporterScreen( MyLocale.getMsg(1600, "Opencaching.de Download"),
@@ -166,8 +166,8 @@
 			+ "&picture=1"
 			+ "&cachelog=1"
 			+ "&removedobject=0"
-			+ "&lat=" + center.getLatDeg(CWPoint.DD)
-			+ "&lon=" + center.getLonDeg(CWPoint.DD)
+			+ "&lat=" + centre.getLatDeg(CWPoint.DD)
+			+ "&lon=" + centre.getLonDeg(CWPoint.DD)
 			+ "&distance=" + dist
 			+ "&charset=utf-8"
 			+ "&cdata=0"

Modified: trunk/src/CacheWolf/OCXMLImporterScreen.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporterScreen.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/OCXMLImporterScreen.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -10,7 +10,7 @@
  * @author pfeffer
  * This Class is the Dialog for Download from Opencaching.de 
  * is called from OCXMLImporter
- * 20061209 Bugfix: Checking for uninitialized missingCheckBox
+ * 20061209 Bugfix: Checking for uninitialised missingCheckBox
  */
 public class OCXMLImporterScreen extends Form {
 	mButton cancelB, okB;

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/Parser.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -96,6 +96,7 @@
     	new fnType("asin","asin",2),
     	new fnType("atan","atan",2),
       	new fnType("bearing","bearing",4),
+     	new fnType("centre","center",3)
     	new fnType("center","center",3),
     	new fnType("cls","cls",1),
     	new fnType("clearscreen","cls",1),
@@ -117,6 +118,7 @@
     	new fnType("mid","mid",12),
      	new fnType("pc","pz",3),
      	new fnType("profilecenter","pz",3),
+     	new fnType("profilecentre","pz",3),
      	new fnType("profilzentrum","pz",3),
     	new fnType("project","project",8),
      	new fnType("pz","pz",3),
@@ -340,7 +342,7 @@
 //  FUNCTIONS
 ///////////////////////////////////////////
     
-	/** Get or set the current center */
+	/** Get or set the current centre */
 	private void funcCenter(int nargs) throws Exception {
 		if (nargs==0) {
 			calcStack.add(Global.getPref().curCentrePt.toString());
@@ -536,7 +538,7 @@
     	}
     }
  
-	/** Get or set the profile center */
+	/** Get or set the profile centre */
 	private void funcPz(int nargs) throws Exception {
 		if (nargs==0) {
 			calcStack.add(Global.getProfile().centre.toString());

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/Preferences.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -119,7 +119,7 @@
 	public boolean solverIgnoreCase=true;
 	/** The type of connection which GPSBABEL uses: com1 OR usb. */
 	public String garminConn="com1";  
-	/** Additional options for GPSBabel, i.e. -s to synthethize short names */
+	/** Additional options for GPSBabel, i.e. -s to synthethise short names */
 	public String garminGPSBabelOptions=""; 
 	public boolean downloadPicsOC = true; //TODO Sollten die auch im Profil gespeichert werden mit Preferences als default Werte ?
 	public boolean downloadMapsOC = true;

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/Profile.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -43,7 +43,7 @@
 	public final static boolean SHOW_PROGRESS_BAR = true;
 	public final static boolean NO_SHOW_PROGRESS_BAR = false;
 
-	// When extending the filter check "normalizeFilters"
+	// When extending the filter check "normaliseFilters"
 	// which ensures backward compatibility. Normally no change should be needed
 	public final static String FILTERTYPE="111111111111111111";
 	public final static String FILTERROSE="1111111111111111";
@@ -283,7 +283,7 @@
 					//Need this to stay "downward" compatible. New type introduced
 					//if(filterType.length()<=17) filterType = filterType + "1";
 					//Vm.debug("fil len: " +filterType.length());
-					//This is handled by "normalizeFilters" which is called at the end.
+					//This is handled by "normaliseFilters" which is called at the end.
 					filterVar = ex.findNext();
 					filterDist = ex.findNext();
 					filterDiff = ex.findNext();
@@ -307,7 +307,7 @@
 		} catch (IOException e){
 			Global.getPref().log("Problem reading index.xml in dir: "+dataDir,e,true); 
 		}
-		normalizeFilters();
+		normaliseFilters();
 		hasUnsavedChanges=false;
 	}
 
@@ -435,7 +435,7 @@
 	 */
 	public void buildReferences(){
 		CacheHolder ch, mainCh;
-		Hashtable dbIndex = new Hashtable((int)(cacheDB.size()/0.75f + 1), 0.75f); // initialize so that von rehashing is neccessary
+		Hashtable dbIndex = new Hashtable((int)(cacheDB.size()/0.75f + 1), 0.75f); // initialise so that von rehashing is neccessary
 
 		Integer index;
 		// Build index for faster search and clear all references
@@ -493,7 +493,7 @@
 	/** Ensure that all filters have the proper length so that the 'charAt' access in the filter
 	 * do not cause nullPointer Exceptions
 	 */
-	private void normalizeFilters() {
+	private void normaliseFilters() {
 		String manyOnes="11111111111111111111111111111";
 		if (filterRose.length()<FILTERROSE.length()) { 
 			filterRose=(filterRose+manyOnes).substring(0,FILTERROSE.length()); 

Modified: trunk/src/CacheWolf/RadarPanel.java
===================================================================
--- trunk/src/CacheWolf/RadarPanel.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/RadarPanel.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -6,7 +6,7 @@
 import ewe.graphics.*;
 
 /**
-*	The radar panel. Displays the caches around a center point.<br>
+*	The radar panel. Displays the caches around a centre point.<br>
 *	Handles scaling as well as toggling the different views in the radar panel.<br>
 *	Also handles clicking on a cache.<br>
 *	Class ID=500
@@ -64,7 +64,7 @@
 		//width = (int)width * 2;
 	}
 	
-	// Call this after the center has changed to re-center the radar panel
+	// Call this after the centre has changed to re-center the radar panel
 	public void recenterRadar() {
 		reCenterImage=true;
 	}

Modified: trunk/src/CacheWolf/SolverPanel.java
===================================================================
--- trunk/src/CacheWolf/SolverPanel.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/SolverPanel.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -9,7 +9,7 @@
 import ewe.sys.*;
 
 /**
-* Class to create the solver panel. Calls the parser and tokenizer and handles
+* Class to create the solver panel. Calls the parser and tokeniser and handles
 *	the parser results.
 *	@see Parser
 *	@see Tokenizer
@@ -22,7 +22,7 @@
 	Preferences pref;
 	Profile profile;
 	String currFile;
-	Tokenizer tokenizer = new Tokenizer();
+	Tokenizer tokeniser = new Tokenizer();
 	Parser parser = new Parser();
 	Vector msgFIFO = new Vector();
 	Menu mnuContext;
@@ -106,8 +106,8 @@
 	
     private void processCommand(String s) {
 		msgFIFO.clear();
-		tokenizer.tokenizeSource(s, msgFIFO); // Tokenizer sets message if an error occurred
-		if (msgFIFO.size()==0) parser.parse(tokenizer.TokenStack, msgFIFO);
+		tokeniser.tokenizeSource(s, msgFIFO); // Tokeniser sets message if an error occurred
+		if (msgFIFO.size()==0) parser.parse(tokeniser.TokenStack, msgFIFO);
 		String msgStr = "";
 		for(int i = 0; i < msgFIFO.size(); i++){
 			msgStr = msgStr + msgFIFO.get(i) + "\n";

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -244,7 +244,7 @@
 	}
 
 	/**
-	*	Method to start the spider for a search around the center coordinates
+	*	Method to start the spider for a search around the centre coordinates
 	*/
 	public void doIt(){
 		String postStr, dummy, ln, wpt;
@@ -252,7 +252,7 @@
 		CacheHolderDetail chD;
 		CWPoint origin = pref.curCentrePt; // No need to copy curCentrePt as it is only read and not written
 		if (!origin.isValid()) {
-			(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5509,"Coordinates for center must be set"), MessageBox.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5509,"Coordinates for centre must be set"), MessageBox.OKB)).execute();
 			return;
 		}
 		// Prepare an index of caches for faster searching

Modified: trunk/src/CacheWolf/StatusBar.java
===================================================================
--- trunk/src/CacheWolf/StatusBar.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/StatusBar.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -35,7 +35,7 @@
 		btnFlt.setToolTip("Filter status");
 //		addNext(lblFlt= new mLabel("Flt"),CellConstants.DONTSTRETCH, CellConstants.DONTFILL); lblFlt.backGround=new ewe.fx.Color(0,255,0);
 		addLast(lblCenter=new mLabel(""),CellConstants.STRETCH, WEST|CellConstants.FILL);
-		lblCenter.setToolTip(MyLocale.getMsg(195,"Current center"));
+		lblCenter.setToolTip(MyLocale.getMsg(195,"Current centre"));
 		updateDisplay();
 	}
 	

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/TablePanel.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -22,7 +22,7 @@
 	 * selectedIdx=-1 if no caches are visible (i.e. database empty or filtered). In 
 	 * this case selectedch is "null".
 	 * Otherwise selectedIdx points to a visible cache.
-	 * When the cacheDB is reorganized (by sort/filter/search), the selected cache
+	 * When the cacheDB is reorganised (by sort/filter/search), the selected cache
 	 * may end up at a new index.
 	 */
 	int selectedIdx=0;

Modified: trunk/src/CacheWolf/Tokenizer.java
===================================================================
--- trunk/src/CacheWolf/Tokenizer.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/Tokenizer.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -4,7 +4,7 @@
 import ewe.util.*;
 
 /**
-*	Class to tokenize (break up) the code into single tokens, so the
+*	Class to tokenise (break up) the code into single tokens, so the
 *	parser my do its job.
 *	@see Parser
 */
@@ -15,7 +15,7 @@
 	 * the newline does not terminate the command even if this variable is true.
 	 */
 	public boolean newLineIsSeparator=true;
-	/** instructions to tokenize */
+	/** instructions to tokenise */
 	String mySource;
 	/** source character */
 	char look;
@@ -56,7 +56,7 @@
 	 * @param c Char to convert
 	 * @return Converted char
 	 */
-	private char standardizeSourceChar(char c) {
+	private char standardiseSourceChar(char c) {
 		if (c=='\u00A0' || (c>='\u2002' && c<='\u200b')) c=' ';
 		if (c>='\u2010' && c<='\u2015') c='-';
 		if (c>='\u201c' && c<='\u201f') c='"';
@@ -81,7 +81,7 @@
 		if(sourcePointer >= mySource.length())
 			return '\n';
 		else {
-			char c=standardizeSourceChar(mySource.charAt(sourcePointer));
+			char c=standardiseSourceChar(mySource.charAt(sourcePointer));
 			return c;
 		}
 	}
@@ -136,7 +136,7 @@
 		boolean foundDecSep=false; // To check that only one decimal point is allowed in a number
 		startToken();
 		while(getChar()){
-			look=standardizeSourceChar(look);
+			look=standardiseSourceChar(look);
 			if(isDigit(look) || (look=='.' && !foundDecSep)) {
 				currentStream += look;
 				if (look=='.') foundDecSep=true;
@@ -214,7 +214,7 @@
 		currentStream="";
 		startToken();
 		while (getChar() && look!=':') {
-			look=standardizeSourceChar(look);
+			look=standardiseSourceChar(look);
 			currentStream += look;
 			if (look!='.' && look!='0' && look!='#') err(MyLocale.getMsg(1731,"Invalid format character"));
 		}
@@ -231,7 +231,7 @@
 		currentStream="";
 		try {
 			while(getChar()){
-				look=standardizeSourceChar(look);
+				look=standardiseSourceChar(look);
 				if (look==' ') continue;
 				currentStream += look;
 				if(isAlpha(look) || look=='$') streamAlphas();

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/myTableControl.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -212,7 +212,7 @@
 			tbp.refreshTable();
 			Vm.showWait(false);
 		}
-		if (selectedItem.toString().equals(MyLocale.getMsg(1019,"Center"))){
+		if (selectedItem.toString().equals(MyLocale.getMsg(1019,"Centre"))){
 			CacheHolder thisCache = (CacheHolder)cacheDB.get(tbp.getSelectedCache());
 			CWPoint cp=new CWPoint(thisCache.LatLon);
 			if (!cp.isValid()){

Modified: trunk/src/CacheWolf/navi/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/navi/GotoPanel.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/navi/GotoPanel.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -92,7 +92,7 @@
 
 		// Button
 		ButtonP.addNext(btnGPS = new mButton("Start"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		ButtonP.addNext(btnCenter = new mButton(MyLocale.getMsg(309,"Center")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addNext(btnCenter = new mButton(MyLocale.getMsg(309,"Centre")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		ButtonP.addNext(btnSave = new mButton(MyLocale.getMsg(311,"Create Waypoint")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		ButtonP.addLast(btnMap = new mButton("Map"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 
@@ -236,7 +236,7 @@
 		Double bearMov = new Double();
 		Double speed = new Double();
 		Double sunAzimut = new Double();
-		Vm.debug("ticked: voher");
+		//Vm.debug("ticked: before");
 		compassRose.setGpsStatus(fix, myNavigation.gpsPos.getSats(), myNavigation.gpsPos.getHDOP());
 		if ((fix > 0) && (myNavigation.gpsPos.getSats()>= 0)) {
 			// display values only, if signal good
@@ -373,7 +373,7 @@
 				else myNavigation.stopGps();
 			}
 
-			// set current position as center and recalculate distance of caches in MainTab 
+			// set current position as centre and recalculate distance of caches in MainTab 
 			if (ev.target == btnCenter){
 				Vm.showWait(true);
 				pref.curCentrePt.set(myNavigation.gpsPos);

Modified: trunk/src/CacheWolf/navi/MapInfoObject.java
===================================================================
--- trunk/src/CacheWolf/navi/MapInfoObject.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/navi/MapInfoObject.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -91,7 +91,7 @@
 
 	/**
 	 * constructs an MapInfoObject with an associated map
-	 * with 1 Pixel = scale meters, center and width, hight in pixels
+	 * with 1 Pixel = scale meters, centre and width, hight in pixels
 	 * @param name path and filename of .wfl file without the extension (it is needed because the image will be searched in the same directory)
 	 */
 	public MapInfoObject(double scalei, CWPoint center, int width, int hight, String name) {
@@ -242,7 +242,7 @@
 	}
 
 	/**
-	 * calculates center, diagonal size of the map and inverse to affine transformation
+	 * calculates centre, diagonal size of the map and inverse to affine transformation
 	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
 	 */
 

Modified: trunk/src/CacheWolf/navi/MapLoader.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoader.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/navi/MapLoader.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -48,7 +48,7 @@
 	/**
 	 * download maps from expedia at zoomlevel alti and save the maps and the .wfl 
 	 * in path
-	 * @param center center of all tiles
+	 * @param center centre of all tiles
 	 * @param radius in meters
 	 * @param scale in "alti" value 1 alti =  3950 /2817.947378 = 1,046861280317350198581316446428 meters per pixel
 	 * @param size in pixels
@@ -92,7 +92,7 @@
 		latinc = (float)-(size.y - borderY) / pixelsPerLat;
 		loninc = (float)(size.x - borderX) / pixelsPerLon;
 		
-		//calculation of center of first tile
+		//calculation of centre of first tile
 		
 		//additional size for borders and rounding
 		double oversizeX = (float)(numMapsX * (size.x - borderX) + borderX) - pixelsX;

Modified: trunk/src/CacheWolf/navi/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoaderGui.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/navi/MapLoaderGui.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -74,7 +74,7 @@
 		distanceInput.setText(Convert.toString((tmp > 0 ? tmp : 15)));
 		pnlTiles.addNext(distanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		pnlTiles.addLast(km);
-		pnlTiles.addNext(coosLbl = new mLabel(MyLocale.getMsg(1803, "around the center: ")));
+		pnlTiles.addNext(coosLbl = new mLabel(MyLocale.getMsg(1803, "around the centre: ")));
 		pnlTiles.addLast(coosBtn = new mButton(center.toString()));
 		pnlTiles.addNext(scaleLbl);
 		scaleInput.setText("5");
@@ -135,13 +135,13 @@
 				return;
 			}
 			ml.setTiles(surArea.topleft, surArea.buttomright, (int)scale, size, overlapping );
-			// calculate radius and center for overview map
+			// calculate radius and centre for overview map
 			center = new CWPoint((surArea.topleft.latDec + surArea.buttomright.latDec)/2, (surArea.topleft.lonDec + surArea.buttomright.lonDec)/2);
 			double radiuslat = (new CWPoint(center.latDec, surArea.buttomright.lonDec)).getDistance(surArea.buttomright);
 			double radiuslon = (new CWPoint(surArea.buttomright.latDec, center.lonDec)).getDistance(surArea.buttomright);
 			radius = (float) (radiuslat < radiuslon ? radiuslon : radiuslat);
 		} else 
-		{ // calculate from center point an radius
+		{ // calculate from centre point an radius
 			ml.setTiles(center, radius * 1000, (int)scale, size, overlapping);
 		}
 		if (overviewmap) {
@@ -188,7 +188,7 @@
 			a = 0;
 			b = Control.Disabled;
 		}
-		else { // use center and distance input
+		else { // use centre and distance input
 			a = Control.Disabled;
 			b = 0;
 		}
@@ -227,7 +227,7 @@
 							return;
 						}
 						if (!center.isValid() && !forCachesChkBox.getState()) {
-							(new MessageBox("Error", "Please enter the 'center' around which the maps shall be downloaded", MessageBox.OKB)).execute();
+							(new MessageBox("Error", "Please enter the 'centre' around which the maps shall be downloaded", MessageBox.OKB)).execute();
 							return;
 						}
 					}

Modified: trunk/src/CacheWolf/navi/MapsList.java
===================================================================
--- trunk/src/CacheWolf/navi/MapsList.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/navi/MapsList.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -75,7 +75,7 @@
 
 	/**
 	 * find the best map for lat/lon in the list of maps
-	 * currently the best map is the one, whose center is nearest to lat/lon
+	 * currently the best map is the one, whose centre is nearest to lat/lon
 	 * and in Area with its scale nearest to scale.
 	 * it always returns a map (if the list is not empty) 
 	 * even if the map is not inbound
@@ -142,7 +142,7 @@
 	 * @return a map which includs topleft and bottomright, 
 	 * if no map includes both it returns null
 	 * @param if more than one map includes topleft and bottomright than the one will
-	 * be returned which has its center nearest to topleft. If you have gps-pos and goto-pos
+	 * be returned which has its centre nearest to topleft. If you have gps-pos and goto-pos
 	 * as topleft and buttomright use gps as topleft.
 	 * if topleft is really topleft or if it is buttomright is not relevant.  
 	 */
@@ -161,7 +161,7 @@
 				if (fittingmap == null || fittingmap.scale > mi.scale * scaleTolerance) {
 					better = true; // mi map has a better (lower) scale than the last knwon good map
 				} else {
-					if (fittingmap != null && scaleEquals(mi, fittingmap)) { // same scale as bestmap till now -> test if its center is nearer to the gps-point = topleft
+					if (fittingmap != null && scaleEquals(mi, fittingmap)) { // same scale as bestmap till now -> test if its centre is nearer to the gps-point = topleft
 						latNearer = java.lang.Math.abs(topleft.latDec- mi.center.latDec)/mi.sizeKm < minDistLat ;
 						lonNearer = java.lang.Math.abs(topleft.lonDec - mi.center.lonDec)/mi.sizeKm < minDistLon;
 						if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -125,7 +125,7 @@
 		ScaleImageGraphics.setFont(font);
 		ScaleImage.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(ScaleImage);
-		//resizeTo(pref.myAppWidth, pref.myAppWidth); // is necessary to initialize mapImage.screenSize
+		//resizeTo(pref.myAppWidth, pref.myAppWidth); // is necessary to initialise mapImage.screenSize
 		setGpsStatus(noGPS);
 		posCircle.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(posCircle);
@@ -594,7 +594,7 @@
 	}
 
 	/**
-	 * move posCircle to the Center of the Screen
+	 * move posCircle to the Centre of the Screen
 	 *
 	 */
 	public void resetCenterOfMap() {
@@ -832,7 +832,7 @@
 	 */
 	public void updatePosition(double lat, double lon){
 		if (dontUpdatePos || loadingMapList) return; // avoid multi-threading problems
-		Vm.debug("updatepors, lat: "+lat+" lon: "+lon);
+		Vm.debug("updatepos, lat: "+lat+" lon: "+lon);
 		if (!mapsloaded) {
 			loadMaps(mapPath, lat);
 			lastCompareX = Integer.MAX_VALUE;
@@ -892,7 +892,7 @@
 	 * loads the best map for lat/lon according to mapChangeModus
 	 * lat/lon will be at the screen-pos of posCircle
 	 * when posCircle is not on the screen (shifted outside my the user)
-	 * then this routine uses the center of the screen to find the best map
+	 * then this routine uses the centre of the screen to find the best map
 	 * but anyway the map will be adjusted (moved) relativ to posCircle
 	 * when a better map was found the called method updateposition will set
 	 * posCirleLat/-Lon to lat/lon.
@@ -958,7 +958,7 @@
 	/**
 	 * method to get a point on the screen which must be included in the map
 	 * the map methods are looking for. If the poscircle is on the screen this will be 
-	 * that point. If it is outside then the center of the screen will be used.
+	 * that point. If it is outside then the centre of the screen will be used.
 	 * 
 	 * returns [0] = CWPoint of that point, [1] Rect describing the screen around it 
 	 * @param lat
@@ -972,9 +972,9 @@
 		CWPoint cll;
 		if (posCircleX >= 0 && posCircleX <= w && posCircleY >= 0 && posCircleY <= h) {
 			x = posCircleX; // posCircle is inside the screen
-			y = posCircleY; // TODO eigentlich interessiert, ob nach dem evtl. Kartenwechsel PosCircle on Screen ist. So wie es jetzt ist, kann 2mal der gleiche Aufruf zum laden unterschiedlicher Karten f?hren, wenn voher PosCircle nicht auf dem SChirm war, nach dem ersten Laden aber schon.
+			y = posCircleY; // TODO eigentlich interessiert, ob nach dem evtl. Kartenwechsel PosCircle on Screen ist. So wie es jetzt ist, kann 2mal der gleiche Aufruf zum laden unterschiedlicher Karten f?hren, wenn vorher PosCircle nicht auf dem SChirm war, nach dem ersten Laden aber schon.
 			cll = new CWPoint(lat, lon);
-		} else { // when posCircle out of screen - use center of screen as point which as to be included in the map
+		} else { // when posCircle out of screen - use centre of screen as point which as to be included in the map
 			cll = ScreenXY2LatLon(w/2, h/2);
 			x = w/2;
 			y = h/2;
@@ -1056,7 +1056,7 @@
 	/** sets and displays the map
 	 * 
 	 * @param newmap
-	 * @param lat move map so that lat/lon is in the center / -361: don't adust to lat/lon
+	 * @param lat move map so that lat/lon is in the centre / -361: don't adust to lat/lon
 	 * @param lon -361: don't adust to lat/lon
 	 */
 	public void setMap(MapInfoObject newmap, double lat, double lon) {
@@ -1188,7 +1188,7 @@
 			h = java.lang.Math.abs(h);
 			firstclickpoint.y = firstclickpoint.y - h;
 		}
-		// calculate rect in unzoomed image in a way that the center of the new image is the center of selected area but give priority to the prefered image size of the scaled image
+		// calculate rect in unzoomed image in a way that the centre of the new image is the centre of selected area but give priority to the prefered image size of the scaled image
 		newImageHeight = (int) (newImageHeight / zoomFactor / currentMap.zoomFactor);
 		newImageWidth = (int) (newImageWidth / zoomFactor / currentMap.zoomFactor);
 		Point mappos = getMapPositionOnScreen();
@@ -1330,7 +1330,7 @@
 	MenuItem moveToMI = new MenuItem("Move map to an load map", MenuItem.Separator, null);;
 	MenuItem moveToDestMI = new MenuItem("move to goto point", 0, null); //* Karte zum Ziel verschieben (und ggf. entsprechende Karte laden) 
 	MenuItem moveToGpsMI = new MenuItem("move to GPS position", 0, null);   
-	MenuItem moveToCenterMI = new MenuItem("move to Center", 0, null);   
+	MenuItem moveToCenterMI = new MenuItem("move to Centre", 0, null);   
 
 	CacheHolder clickedCache;
 	MovingMap mm;

Modified: trunk/src/CacheWolf/navi/Navigate.java
===================================================================
--- trunk/src/CacheWolf/navi/Navigate.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/CacheWolf/navi/Navigate.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -110,7 +110,7 @@
 		int fix = gpsPos.getFix();
 		if (fix > 0 && (gpsPos.getSats()>= 0)) {
 			//gpsPosition.printAll();
-			//Vm.debug("currTrack.add: voher");
+			//Vm.debug("currTrack.add: before");
 			if (curTrack == null) curTrack = new Track(trackColor);
 			try {
 				curTrack.add(gpsPos);

Modified: trunk/src/exp/TPLExporter.java
===================================================================
--- trunk/src/exp/TPLExporter.java	2007-09-25 14:36:00 UTC (rev 939)
+++ trunk/src/exp/TPLExporter.java	2007-09-25 15:06:44 UTC (rev 940)
@@ -246,7 +246,7 @@
 			System.runFinalization();
 			Vm.gc(); // this doesn't help :-( - I don't know why :-(
 			//Vm.debug("n: "+Vm.countObjects(true));
-			(new MessageBox("Error", "Not enough memory available to load all cache data (incl. description and logs)\nexport aborted\nFilter caches to minimize memory needed for TPL-Export\nWe recommend to restart CacheWolf now", MessageBox.OKB)).execute();
+			(new MessageBox("Error", "Not enough memory available to load all cache data (incl. description and logs)\nexport aborted\nFilter caches to minimise memory needed for TPL-Export\nWe recommend to restart CacheWolf now", MessageBox.OKB)).execute();
 			//Vm.debug("n: "+Vm.countObjects(true));
 		}
 		pbf.exit(0);



From mirabilos at mail.berlios.de  Tue Sep 25 17:09:46 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Tue, 25 Sep 2007 17:09:46 +0200
Subject: [Cachewolf-svn] r941 - trunk
Message-ID: <200709251509.l8PF9kqY020140@sheep.berlios.de>

Author: mirabilos
Date: 2007-09-25 17:09:46 +0200 (Tue, 25 Sep 2007)
New Revision: 941

Modified:
   trunk/compile.bat
   trunk/compile.sh
Log:
someone forgot that ./src/CacheWolf/imp/*.java was not added


Modified: trunk/compile.bat
===================================================================
--- trunk/compile.bat	2007-09-25 15:06:44 UTC (rev 940)
+++ trunk/compile.bat	2007-09-25 15:09:46 UTC (rev 941)
@@ -1,3 +1,3 @@
 if not exist bin\CacheWolf mkdir bin\CacheWolf
 if not exist bin\exp mkdir bin\exp
-javac -classpath ./lib/CompileEwe.zip;./lib/ewesoft.zip;./lib/EwesoftRegex.zip;./lib/HTML.zip;./lib/openmap.jar  -d ./bin/ -deprecation ./src/CacheWolf/*.java ./src/exp/*.java ./src/utils/*.java ./src/CacheWolf/navi/*.java
+javac -classpath ./lib/CompileEwe.zip;./lib/ewesoft.zip;./lib/EwesoftRegex.zip;./lib/HTML.zip;./lib/openmap.jar  -d ./bin/ -deprecation ./src/CacheWolf/*.java ./src/CacheWolf/*/*.java ./src/exp/*.java ./src/utils/*.java

Modified: trunk/compile.sh
===================================================================
--- trunk/compile.sh	2007-09-25 15:06:44 UTC (rev 940)
+++ trunk/compile.sh	2007-09-25 15:09:46 UTC (rev 941)
@@ -1,2 +1,2 @@
 #!/bin/sh
-javac -cp ./lib/CompileEwe.zip:./lib/ewesoft.zip:./lib/EwesoftRegex.zip:./lib/HTML.zip:./lib/openmap.jar  -d ./bin/ -deprecation -nowarn  ./src/CacheWolf/*.java ./src/exp/*.java ./src/utils/*.java ./src/CacheWolf/navi/*.java 
+javac -cp ./lib/CompileEwe.zip:./lib/ewesoft.zip:./lib/EwesoftRegex.zip:./lib/HTML.zip:./lib/openmap.jar  -d ./bin/ -deprecation -nowarn ./src/CacheWolf/*.java ./src/CacheWolf/*/*.java ./src/exp/*.java ./src/utils/*.java



From mirabilos at mail.berlios.de  Tue Sep 25 17:14:12 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Tue, 25 Sep 2007 17:14:12 +0200
Subject: [Cachewolf-svn] r942 - trunk/src/CacheWolf
Message-ID: <200709251514.l8PFECad020535@sheep.berlios.de>

Author: mirabilos
Date: 2007-09-25 17:14:12 +0200 (Tue, 25 Sep 2007)
New Revision: 942

Modified:
   trunk/src/CacheWolf/Parser.java
Log:
oops?

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-09-25 15:09:46 UTC (rev 941)
+++ trunk/src/CacheWolf/Parser.java	2007-09-25 15:14:12 UTC (rev 942)
@@ -96,7 +96,7 @@
     	new fnType("asin","asin",2),
     	new fnType("atan","atan",2),
       	new fnType("bearing","bearing",4),
-     	new fnType("centre","center",3)
+     	new fnType("centre","center",3),
     	new fnType("center","center",3),
     	new fnType("cls","cls",1),
     	new fnType("clearscreen","cls",1),



From pfeffer at mail.berlios.de  Tue Sep 25 17:34:12 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Tue, 25 Sep 2007 17:34:12 +0200
Subject: [Cachewolf-svn] r943 - trunk/src/CacheWolf/navi
Message-ID: <200709251534.l8PFYCv4021961@sheep.berlios.de>

Author: pfeffer
Date: 2007-09-25 17:34:10 +0200 (Tue, 25 Sep 2007)
New Revision: 943

Modified:
   trunk/src/CacheWolf/navi/Area.java
   trunk/src/CacheWolf/navi/MapsList.java
Log:
avoid compile problems on linux mashines (by commenting out till now not needed functions)

Modified: trunk/src/CacheWolf/navi/Area.java
===================================================================
--- trunk/src/CacheWolf/navi/Area.java	2007-09-25 15:14:12 UTC (rev 942)
+++ trunk/src/CacheWolf/navi/Area.java	2007-09-25 15:34:10 UTC (rev 943)
@@ -86,7 +86,7 @@
 				 return AT_LEFT_EDGE;
 			 return NOT_ON_EDGE;
 	 }
-	 
+	 /*
 	 public String getEasyFindString() {
 		 String ul = getEasyFindString(topleft, 60);
 		 String br = getEasyFindString(buttomright, 60);
@@ -97,22 +97,23 @@
 		 ewe.sys.Vm.debug(ul+"\n"+br+"\n i:"+i);
 		 return ul.substring(0, i);
 	 }
-	 
+	 */
 	 /**
 	  * 
 	  * @param prec number of digits to return, min 2, max: 63
 	  * @return
 	  */
+	 /*
 	 public static String getEasyFindString(CWPoint p, int prec) {
 		 double longinrange = p.lonDec;
 		 if (longinrange > 180) longinrange -= 180;
 		 Double kw = new Double(((p.latDec+90)/180) * (double) (1l << (prec)));
-		 Long lat = new Double(((p.latDec+90)/180) * (double) (1l << (prec))).longValue(); // TODO handle negative values
+		 long lat = new Double(((p.latDec+90)/180) * (double) (1l << (prec))).longValue(); // TODO handle negative values
 		 lat = kw.longValue();
 		 kw = (double) (1l << (prec));
 		 
 		 kw = new Double(((longinrange+180)/360) * (2 ^ (prec -1)));
-		 Long lon = new Double(((longinrange+180)/360) * (double) (1l << (prec))).longValue(); // 180 = 10110100
+		 long lon = new Double(((longinrange+180)/360) * (double) (1l << (prec))).longValue(); // 180 = 10110100
 		 String ret = "";
 		 Long tmp;
 		 for (int i=prec-1; i>=0;  i--) {
@@ -130,6 +131,7 @@
 			 for (i=0) 
 			 break;
 		 }
-	*/	 return ret;
+	*/	/* return ret;
 	 }
+*/
 }
\ No newline at end of file

Modified: trunk/src/CacheWolf/navi/MapsList.java
===================================================================
--- trunk/src/CacheWolf/navi/MapsList.java	2007-09-25 15:14:12 UTC (rev 942)
+++ trunk/src/CacheWolf/navi/MapsList.java	2007-09-25 15:34:10 UTC (rev 943)
@@ -49,7 +49,7 @@
 						tempMIO = new MapInfoObject(mapsPath+"/", rawFileName);
 					else tempMIO = new MapInfoObject(mapsPath+"/"+dirs.get(j)+"/", rawFileName);
 					add(tempMIO);
-					ewe.sys.Vm.debug(tempMIO.getEasyFindString() + tempMIO.mapName);
+			//		ewe.sys.Vm.debug(tempMIO.getEasyFindString() + tempMIO.mapName);
 				}catch(IOException ex){ 
 					if (f == null) (f=new MessageBox("Warning", "Ignoring error while \n reading calibration file \n"+ex.toString(), MessageBox.OKB)).exec();
 				}catch(ArithmeticException ex){ // affine contain not allowed values 



From pfeffer at mail.berlios.de  Wed Sep 26 23:20:59 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 26 Sep 2007 23:20:59 +0200
Subject: [Cachewolf-svn] r944 - in trunk: resources src/CacheWolf/navi
Message-ID: <200709262120.l8QLKxew019358@sheep.berlios.de>

Author: pfeffer
Date: 2007-09-26 23:20:54 +0200 (Wed, 26 Sep 2007)
New Revision: 944

Added:
   trunk/resources/lupe_activated_zin.png
   trunk/resources/lupe_activated_zout.png
Modified:
   trunk/src/CacheWolf/navi/MovingMap.java
Log:
MovingMap: added feature: show +/- in the lupe to indicate zooming in or out. Thanx to blackeye501 for the pics.

Added: trunk/resources/lupe_activated_zin.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/lupe_activated_zin.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/lupe_activated_zout.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/lupe_activated_zout.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2007-09-25 15:34:10 UTC (rev 943)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2007-09-26 21:20:54 UTC (rev 944)
@@ -52,6 +52,8 @@
 	AniImage buttonImageGpsOn = new AniImage("snap2gps.gif");
 	AniImage buttonImageLens = new AniImage("lupe.png");
 	AniImage buttonImageLensActivated = new AniImage("lupe_activated.png");
+	AniImage buttonImageLensActivatedZoomIn = new AniImage("lupe_activated_zin.png");
+	AniImage buttonImageLensActivatedZoomOut = new AniImage("lupe_activated_zout.png");
 	AniImage buttonImageZoom1to1 = new AniImage("zoom1to1.png");
 	AniImage DistanceImage;
 	Graphics DistanceImageGraphics;
@@ -106,6 +108,8 @@
 		mmp.addImage(directionArrows);
 		buttonImageLens.properties = AniImage.AlwaysOnTop;
 		buttonImageLensActivated.properties = AniImage.AlwaysOnTop;
+		buttonImageLensActivatedZoomIn.properties = AniImage.AlwaysOnTop;
+		buttonImageLensActivatedZoomOut.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(buttonImageLens);
 		buttonImageZoom1to1.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(buttonImageZoom1to1);
@@ -153,7 +157,9 @@
 		directionArrows.setLocation(w/2-directionArrows.getWidth()/2, 10);
 		buttonImageZoom1to1.setLocation(w - buttonImageZoom1to1.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 - buttonImageZoom1to1.getHeight() -10);
 		buttonImageLens.setLocation(w - buttonImageLens.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 );
-		buttonImageLensActivated.setLocation(w - buttonImageLens.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 );
+		buttonImageLensActivated.setLocation(w - buttonImageLensActivated.getWidth()-10, h/2 - buttonImageLensActivated.getHeight()/2 );
+		buttonImageLensActivatedZoomIn.setLocation(w - buttonImageLensActivatedZoomIn.getWidth()-10, h/2 - buttonImageLensActivatedZoomIn.getHeight()/2 );
+		buttonImageLensActivatedZoomOut.setLocation(w - buttonImageLensActivatedZoomOut.getWidth()-10, h/2 - buttonImageLensActivatedZoomOut.getHeight()/2 );
 		DistanceImage.setLocation(0, h - DistanceImage.getHeight());
 		ScaleImage.setLocation(w - ScaleImage.getWidth(), h - ScaleImage.getHeight());
 		if (mmp.mapImage != null) mmp.mapImage.move(mmp.mapImage.locAlways.x, mmp.mapImage.locAlways.y); // this is necessary to make a new decision if it is still on the screen (and actually mor important because MapImage only now gets to know the screen size) 
@@ -1414,6 +1420,18 @@
 			top -= 2;
 			if (top < 0) top = 0;
 			if (left < 0) left = 0;
+			if ((lastZoomWidth <= 0) && (ev.x - saveMapLoc.x > 0)) { // changed from zooming out to zooming in 
+				removeImage(mm.buttonImageLensActivated);
+				removeImage(mm.buttonImageLensActivatedZoomOut);
+				addImage(mm.buttonImageLensActivatedZoomIn);
+				this.repaintNow(dr, new Rect(mm.buttonImageLensActivatedZoomIn.location.x, mm.buttonImageLensActivatedZoomIn.location.y, mm.buttonImageLensActivatedZoomIn.getWidth(), mm.buttonImageLensActivatedZoomIn.getHeight()));
+			}
+			if ((lastZoomWidth >= 0) && (ev.x - saveMapLoc.x < 0)) { // changed from zooming out to zooming in 
+				removeImage(mm.buttonImageLensActivated);
+				removeImage(mm.buttonImageLensActivatedZoomIn);
+				addImage(mm.buttonImageLensActivatedZoomOut);
+				this.repaintNow(dr, new Rect(mm.buttonImageLensActivatedZoomOut.location.x, mm.buttonImageLensActivatedZoomOut.location.y, mm.buttonImageLensActivatedZoomOut.getWidth(), mm.buttonImageLensActivatedZoomOut.getHeight()));
+			}
 			this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth)+4, java.lang.Math.abs(lastZoomHeight)+4));
 			lastZoomWidth = ev.x - saveMapLoc.x;
 			lastZoomHeight =  ev.y - saveMapLoc.y;



From pfeffer at mail.berlios.de  Thu Sep 27 00:06:55 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 27 Sep 2007 00:06:55 +0200
Subject: [Cachewolf-svn] r945 - in trunk: resources src/CacheWolf/navi
Message-ID: <200709262206.l8QM6teQ022090@sheep.berlios.de>

Author: pfeffer
Date: 2007-09-27 00:06:51 +0200 (Thu, 27 Sep 2007)
New Revision: 945

Added:
   trunk/resources/lupe_better_overview.png
   trunk/resources/lupe_more_details.png
Modified:
   trunk/src/CacheWolf/navi/MovingMap.java
Log:
MovingMap: new Feature: show icons in menu for loading a map with more / less details

Added: trunk/resources/lupe_better_overview.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/lupe_better_overview.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/lupe_more_details.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/lupe_more_details.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2007-09-26 21:20:54 UTC (rev 944)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2007-09-26 22:06:51 UTC (rev 945)
@@ -1330,8 +1330,8 @@
 	// manuell
 	MenuItem mapChangeResMI = new MenuItem("Change resolution manually", MenuItem.Separator, null);;
 	MenuItem AllCachesResMI = new MenuItem("Load a map containing all marked caches", 0, null); // Karte w?hlen, die alle markierten Caches enth?lt  
-	MenuItem moreDetailsMI = new MenuItem("Load a map with more details", 0, null); // detailreichere Karte laden 
-	MenuItem moreOverviewMI = new MenuItem("Load a map for a better overview", 0, null); // Karte mit mehr ?bersicht w?hlen  
+	MenuItem moreDetailsMI = new MenuItem("Load a map with more details", new IconAndText(new mImage("lupe_more_details.png"), "Load a map with more details", null, Graphics.RIGHT)); // laod a map with more details 
+	MenuItem moreOverviewMI = new MenuItem("Load a map for a better overview", new IconAndText(new mImage("lupe_better_overview.png"), "Load a map for a better overview", null, Graphics.RIGHT)); // Load a map for a better overview --> lesser details  
 	// move map to
 	MenuItem moveToMI = new MenuItem("Move map to an load map", MenuItem.Separator, null);;
 	MenuItem moveToDestMI = new MenuItem("move to goto point", 0, null); //* Karte zum Ziel verschieben (und ggf. entsprechende Karte laden) 



From mirabilos at mail.berlios.de  Thu Sep 27 13:55:12 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Thu, 27 Sep 2007 13:55:12 +0200
Subject: [Cachewolf-svn] r946 - trunk/src/CacheWolf/navi
Message-ID: <200709271155.l8RBtCQg013241@sheep.berlios.de>

Author: mirabilos
Date: 2007-09-27 13:55:11 +0200 (Thu, 27 Sep 2007)
New Revision: 946

Modified:
   trunk/src/CacheWolf/navi/MapLoader.java
Log:
fix typo (coloumn)


Modified: trunk/src/CacheWolf/navi/MapLoader.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoader.java	2007-09-26 22:06:51 UTC (rev 945)
+++ trunk/src/CacheWolf/navi/MapLoader.java	2007-09-27 11:55:11 UTC (rev 946)
@@ -117,7 +117,7 @@
 			lon = topleft.lonDec;
 			for (int col = 1; col <= numMapsX; col++) {
 				if (progressInfobox != null)
-					progressInfobox.setInfo("Downloading calibrated (georeferenced) \n map image from www.expedia.com \n Downloading tile row: "+row+" / "+numMapsY+" coloumn "+ col + "/"+numMapsX);
+					progressInfobox.setInfo("Downloading calibrated (georeferenced) \n map image from www.expedia.com \n Downloading tile \n row "+row+" / "+numMapsY+" column "+ col + " / "+numMapsX);
 				downloadMap(lat, lon, tileScale, tilesSize.x, tilesSize.y, tilesPath);
 				lon += loninc;
 			}



From salzkammergut at mail.berlios.de  Fri Sep 28 23:08:04 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Fri, 28 Sep 2007 23:08:04 +0200
Subject: [Cachewolf-svn] r947 - trunk/src/CacheWolf
Message-ID: <200709282108.l8SL84aY020544@sheep.berlios.de>

Author: salzkammergut
Date: 2007-09-28 23:08:02 +0200 (Fri, 28 Sep 2007)
New Revision: 947

Modified:
   trunk/src/CacheWolf/SolverPanel.java
Log:
SolverPanel: Added button for WolfLanguage

Modified: trunk/src/CacheWolf/SolverPanel.java
===================================================================
--- trunk/src/CacheWolf/SolverPanel.java	2007-09-27 11:55:11 UTC (rev 946)
+++ trunk/src/CacheWolf/SolverPanel.java	2007-09-28 21:08:02 UTC (rev 947)
@@ -16,7 +16,7 @@
 */
 public class SolverPanel extends CellPanel{
 	mButton mBtSolve;
-	mButton btnLoad, btnSave, btnSaveAs;
+	mButton btnLoad, btnSave, btnSaveAs,btnWolfLang;
 	mTextPad mText;
 	OutputPanel mOutput;
 	Preferences pref;
@@ -85,8 +85,9 @@
 		outputPanel = split.getNextPanel();
 		split.setSplitter(PanelSplitter.AFTER|PanelSplitter.HIDDEN,PanelSplitter.BEFORE|PanelSplitter.HIDDEN,0);
 
-		programPanel.addLast(new ScrollBarPanel(mText = new InputPanel()));
-		programPanel.addNext(mBtSolve= new mButton(MyLocale.getMsg(1735,"Solve!")),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		programPanel.addLast(new ScrollBarPanel(mText = new InputPanel())).setTag(SPAN, new Dimension(2,1));
+		programPanel.addNext(mBtSolve= new mButton(MyLocale.getMsg(1735,"Solve!")),CellConstants.HSTRETCH, CellConstants.HFILL);
+		programPanel.addLast(btnWolfLang= new mButton(MyLocale.getMsg(118,"WolfLanguage")),CellConstants.HSTRETCH, CellConstants.HFILL);
 		/*programPanel.addNext(btnLoad= new mButton(MyLocale.getMsg(1736,"Load")),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		programPanel.addNext(btnSave= new mButton(MyLocale.getMsg(1737,"Save")),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		programPanel.addLast(btnSaveAs= new mButton(MyLocale.getMsg(1738,"SaveAs")),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
@@ -120,6 +121,10 @@
 			if(ev.target == mBtSolve){
 				processCommand(mText.getText());
 			}
+			if (ev.target==btnWolfLang) {
+				InfoScreen is = new InfoScreen(File.getProgramDirectory() + "/" + "wolflang.html", MyLocale.getMsg(118,"WolfLanguage"), true, pref);
+				is.execute(parent.getFrame(), Gui.CENTER_FRAME);
+			}
 /*			if(ev.target == btnLoad){
 				FileChooser fc = new FileChooser(FileChooser.OPEN, profile.dataDir);
 				



From kalli at mail.berlios.de  Sat Sep 29 18:14:11 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Sat, 29 Sep 2007 18:14:11 +0200
Subject: [Cachewolf-svn] r948 - trunk
Message-ID: <200709291614.l8TGEBA1032114@sheep.berlios.de>

Author: kalli
Date: 2007-09-29 18:14:03 +0200 (Sat, 29 Sep 2007)
New Revision: 948

Modified:
   trunk/compile.bat
Log:
Path for .../navi and .../imp added

Modified: trunk/compile.bat
===================================================================
--- trunk/compile.bat	2007-09-28 21:08:02 UTC (rev 947)
+++ trunk/compile.bat	2007-09-29 16:14:03 UTC (rev 948)
@@ -1,3 +1,3 @@
 if not exist bin\CacheWolf mkdir bin\CacheWolf
 if not exist bin\exp mkdir bin\exp
-javac -classpath ./lib/CompileEwe.zip;./lib/ewesoft.zip;./lib/EwesoftRegex.zip;./lib/HTML.zip;./lib/openmap.jar  -d ./bin/ -deprecation ./src/CacheWolf/*.java ./src/CacheWolf/*/*.java ./src/exp/*.java ./src/utils/*.java
+javac -classpath ./lib/CompileEwe.zip;./lib/ewesoft.zip;./lib/EwesoftRegex.zip;./lib/HTML.zip;./lib/openmap.jar  -d ./bin/ -deprecation ./src/CacheWolf/*.java ./src/CacheWolf/imp/*.java ./src/CacheWolf/navi/*.java ./src/exp/*.java ./src/utils/*.java



