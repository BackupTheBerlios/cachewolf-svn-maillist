<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r777 - in trunk: resources src/CacheWolf
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2007-July/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r777%20-%20in%20trunk%3A%20resources%20src/CacheWolf&In-Reply-To=%3C200707072113.l67LDvOt011116%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000663.html">
   <LINK REL="Next"  HREF="000665.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r777 - in trunk: resources src/CacheWolf</H1>
    <B>salzkammergut at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r777%20-%20in%20trunk%3A%20resources%20src/CacheWolf&In-Reply-To=%3C200707072113.l67LDvOt011116%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r777 - in trunk: resources src/CacheWolf">salzkammergut at mail.berlios.de
       </A><BR>
    <I>Sat Jul  7 23:13:57 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000663.html">[Cachewolf-svn] r776 - trunk/src/CacheWolf
</A></li>
        <LI>Next message: <A HREF="000665.html">[Cachewolf-svn] r778 - trunk/src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#664">[ date ]</a>
              <a href="thread.html#664">[ thread ]</a>
              <a href="subject.html#664">[ subject ]</a>
              <a href="author.html#664">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: salzkammergut
Date: 2007-07-07 23:13:41 +0200 (Sat, 07 Jul 2007)
New Revision: 777

Added:
   trunk/resources/cachetour.png
   trunk/resources/clnew.png
   trunk/resources/clopen.png
   trunk/resources/clsave.png
   trunk/resources/clsaveas.png
   trunk/src/CacheWolf/CacheList.java
Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/Global.java
   trunk/src/CacheWolf/MainForm.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/StatusBar.java
   trunk/src/CacheWolf/myInteractivePanel.java
   trunk/src/CacheWolf/myTableControl.java
Log:
Neues Feature: Cachetour - Zusammenstellen von Cachetouren innerhalb eines Profils
Durch ein Icon in Statuszeile bzw. Menue Verwalten wird eine Liste eingeblendet, in die Caches aus der Listenansicht bzw.
dem Radarpanel gezogen werden koennen. Optional werden Addis automatisch mitgezogen. 
Durch &quot;Anwenden&quot; werden nur die ausgewaehlten Caches in der exakten gewaehlten Reihenfolge in der Listenansicht
dargestellt, alle anderen werden weggefiltert. 

Added: trunk/resources/cachetour.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/cachetour.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-07-03 21:37:34 UTC (rev 776)
+++ trunk/resources/cachewolf.Languages.cfg	2007-07-07 21:13:41 UTC (rev 777)
@@ -62,6 +62,28 @@
 		173=Garmin: PC Port:
 		174=Kurznamen
 		175=Import
+		176=Neue Version
+		177=Neue Version%0averf%fcgbar
+		178=Versionspr%fcfung
+		179=Sie haben die%0aaktuelle Version.
+		180=Caches hierher
+		181=ziehen
+		182=Neue Liste
+		183=Liste laden
+		184=Speichern als
+		185=Speichern (ohne Nachfrage)
+		186=Addi Wegpunkte mitziehen
+		187=Nur diese Wegpunkte anzeigen
+		188=CACHETOUR: NEU
+		189=Liste anwenden
+		190=Nur diese Wegpunkte zeigen
+		191=Datei w%e4hlen
+		192=%c4nderungen speichern
+		193=Addis hinzuf%fcgen
+		195=Derzeitiges Zentrum		
+		196=Gesamte # Caches (GC&amp;OC)%0aGesamt # sichtbar%0aGesamt # gefunden
+		197=Cachetour anzeigen/verbergen
+		198=Cachetour	
 		200=Details
 		201=Beschreibung
 		202=Bilder
@@ -495,6 +517,28 @@
 		173=Garmin: PC Port:
 		174=Short Names
 		175=Import
+		176=New version
+		177=New version%0aavailable
+		178=Version Check
+		179=You are at%0athe current version.
+		180=Drag caches
+		181=here
+		182=New list
+		183=Load list
+		184=Save as
+		185=Save (without confirmation)
+		186=Also drag Addi Wpts
+		187=Show only these waypoints
+		188=CACHETOUR: NEW
+		189=Apply list
+		190=Show only these waypoints
+		191=Select file
+		192=Save changes
+		193=add Addis
+		195=Current Center
+		196=Total # of caches (GC&amp;OC)%0aTotal # visible%0aTotal # found
+		197=Show/Hide cachetour	
+		198=Cachetour
 		200=Details
 		201=Description
 		202=Images

Added: trunk/resources/clnew.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/clnew.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/clopen.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/clopen.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/clsave.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/clsave.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/clsaveas.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/clsaveas.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/src/CacheWolf/CacheList.java
===================================================================
--- trunk/src/CacheWolf/CacheList.java	2007-07-03 21:37:34 UTC (rev 776)
+++ trunk/src/CacheWolf/CacheList.java	2007-07-07 21:13:41 UTC (rev 777)
@@ -0,0 +1,409 @@
+package CacheWolf;
+
+import ewe.filechooser.FileChooser;
+import ewe.fx.*;
+import ewe.io.*;
+import ewe.sys.*;
+import ewe.ui.*;
+import ewe.util.*;
+
+/********************************************************
+ * This class implements the core functionality of a flexible cachelist for collecting
+ * &quot;Cachetours&quot;. Caches can be dragged into the list from the main list view and
+ * from the radar panel view. Caches can be removed from the list by dragging them
+ * out or selecting them and pressing the &quot;delete&quot; key. Within the list the selected
+ * cache can be moved up/down using two buttons. The finished list can be saved and 
+ * reloaded with the selected position being stored. The list can be applied as
+ * a filter to the main list, thereby hiding all caches that are not in the list
+ * and sorting the caches according to the list. 
+ * Created by skg, Februar 2007
+ ********************************************************/
+public class CacheList extends CellPanel {
+    /** The extension for cachelists (CL) */ 
+    private final String EXTENSION=&quot;CL&quot;;
+	private final String TITLE=MyLocale.getMsg(188,&quot;CACHETOUR: NEW&quot;);
+    CacheList() {
+		this.setPreferredSize(100,-1); 
+		this.equalWidths=true;
+		mImage imgDown=new mImage(&quot;ewe/downarrowsmall.bmp&quot;); imgDown.transparentColor=Color.White;
+		mImage imgUp=new mImage(&quot;ewe/uparrowsmall.bmp&quot;); imgUp.transparentColor=Color.White;
+		// Title
+		lblTitle=new mLabel(TITLE);
+		lblTitle.backGround=new Color(0,0,200); lblTitle.foreGround=Color.White; 
+		addLast(lblTitle,HSTRETCH,HFILL|HCENTER);
+		// The actual list
+		lstCaches=new myList(10,1,false); lstCaches.text=&quot;CacheList&quot;; 
+		lstCaches.addItem(MyLocale.getMsg(180,&quot;Drag caches&quot;));lstCaches.addItem(MyLocale.getMsg(181,&quot;here&quot;));
+		ScrollablePanel scp=lstCaches.getScrollablePanel();
+		addLast(scp,STRETCH,FILL); scp.setOptions(ScrollablePanel.NeverShowHorizontalScrollers);
+		// The buttons to move the selected cache
+		addNext(btnDown=new mButton(imgDown),HSHRINK,HFILL); btnDown.modify(Disabled,0);
+		addLast(btnUp=new mButton(imgUp),HSHRINK,HFILL); btnUp.modify(Disabled,0);
+		// Buttons to clear, load and save the list
+		CellPanel cp=new CellPanel(); cp.equalWidths=true;
+		cp.addNext(btnNew=new mButton(imgNew=new mImage(&quot;clnew.png&quot;)),HSTRETCH,HFILL);
+		imgNew.transparentColor=new Color(255,0,0); btnNew.setToolTip(MyLocale.getMsg(182,&quot;New list&quot;));
+		cp.addNext(btnLoad=new mButton(imgOpen=new mImage(&quot;clopen.png&quot;)),HSTRETCH,HFILL);
+		imgOpen.transparentColor=new Color(255,0,0);btnLoad.setToolTip(MyLocale.getMsg(183,&quot;Load list&quot;));
+		cp.addNext(btnSaveAs=new mButton(imgSaveAs=new mImage(&quot;clsaveas.png&quot;)),HSTRETCH,HFILL);
+		imgSaveAs.transparentColor=new Color(0,255,0);btnSaveAs.setToolTip(MyLocale.getMsg(184,&quot;Save as&quot;));
+		cp.addLast(btnSave=new mButton(imgSave=new mImage(&quot;clsave.png&quot;)),HSTRETCH,HFILL);
+		imgSave.transparentColor=new Color(255,0,0);btnSave.setToolTip(MyLocale.getMsg(185,&quot;Save (without confirmation)&quot;));
+		addLast(cp,HSTRETCH,HFILL);
+		// Button to toggle whether additional waypoints are automatically dragged
+		// with the parent waypoint
+		addLast(chkAddAddis=new mCheckBox(MyLocale.getMsg(193,&quot;add Addis&quot;)),HSTRETCH,HFILL);
+		chkAddAddis.setToolTip(MyLocale.getMsg(186,&quot;Also drag Addi Wpts&quot;));
+		// Finally button to apply the list as a filter
+		addLast(btnFilter=new mButton(MyLocale.getMsg(189,&quot;Apply List&quot;)),HSTRETCH,HFILL);btnFilter.modify(Disabled,0);
+		btnFilter.setToolTip(MyLocale.getMsg(190,&quot;Show only these waypoints&quot;));
+	}
+    /** Flag to ensure the initial message &quot;Caches hierher ziehen&quot; is cleared
+     * when the first cache is dragged into the list */
+	private boolean needsInit=true;
+	/** The actual list. This is mirrored by cacheList */
+	private myList lstCaches;
+	/** True if there are unsaved changes */
+	private boolean dirty=false;
+	// The UI elements
+	private mLabel lblTitle; 
+	private mCheckBox chkAddAddis;
+	private mButton btnDown, btnUp, btnLoad, btnNew, btnSave, btnSaveAs, btnFilter;
+    private mImage imgOpen,imgNew,imgSave,imgSaveAs;
+	/** This list mirrors the items in the list of selected caches for faster access. When the 
+     * list of selected caches is manipulated (btnUp, btnDown), this list is also kept up to date
+     */
+	private Vector cacheList=new Vector(20);
+	/** The full filename of the current file */
+	private String currFile=null;
+	
+	private class myList extends mList {
+		myList(int rows, int columns, boolean multi) { super(rows,columns,multi); }
+		
+		//  Allow the caches to be dragged out of the cachelist
+		String wayPoint;
+		int idx;
+		
+		public void startDragging(DragContext dc) {
+			 idx=getSelectedIndex(0);
+			 if (idx&gt;=0) {
+				 CacheHolder ch=(CacheHolder)cacheList.get(idx);
+				 wayPoint=ch.wayPoint;
+				 IconAndText imgDrag=new IconAndText();
+				 imgDrag.addColumn((IImage) Global.mainTab.tbP.myMod.cacheImages[Convert.parseInt(ch.type)]);
+				 imgDrag.addColumn(ch.wayPoint);
+				 dc.dragData=dc.startImageDrag(imgDrag,new Point(8,8),this);
+			 } 
+		}
+
+		public void dragged(DragContext dc) {
+			 	dc.imageDrag();
+		}
+		 
+		public void stopDragging(DragContext dc) {
+			 dc.stopImageDrag(true);
+			 Point p = Gui.getPosInParent(this,getWindow());
+			 p.x += dc.curPoint.x;
+			 p.y += dc.curPoint.y;
+			 Control c = getWindow().findChild(p.x,p.y);
+		     if (!(c instanceof myList)) { 
+		    	 // target is not myList =&gt; Remove dragged cache from list
+		    	 cacheList.del(idx);
+		    	 lstCaches.deleteItem(idx);
+		    	 repaint();
+		    	 changeUpDownButtonStatus();
+		     }
+		 }
+		
+		// Alternative method of deleting a cache from the list through
+		// Keyboard interface
+		public void onKeyEvent(KeyEvent ev) {
+			if (ev.type == KeyEvent.KEY_PRESS &amp;&amp; ev.target == this){
+				if (ev.key == IKeys.DELETE &amp;&amp; cacheList.size()&gt;0) {
+			    	 idx=getSelectedIndex(0);
+					 cacheList.del(idx);
+			    	 lstCaches.deleteItem(idx);
+			    	 repaint();
+			    	 changeUpDownButtonStatus();
+				}
+			}
+			super.onKeyEvent(ev);
+		}
+
+	} //******************* myList
+	
+	/** Simple sort to ensure that the main list keeps the order of this list */
+	private class mySort implements Comparer{
+		public int compare(Object o1, Object o2){
+			CacheHolder oo1 = (CacheHolder)o1;
+			CacheHolder oo2 = (CacheHolder)o2;
+			return oo1.sort.compareTo(oo2.sort);
+		}
+	}
+	
+	/** Enable the up/down buttons only if at least 2 caches are in the list */
+	private void changeUpDownButtonStatus() {
+		btnUp.modify(0,Disabled);
+		if (needsInit || lstCaches.itemsSize()&lt;2 || lstCaches.getSelectedIndex(0)==0) btnUp.modify(Disabled,0);
+		btnDown.modify(0,Disabled);
+		if (needsInit || lstCaches.itemsSize()&lt;2 || lstCaches.getSelectedIndex(0)==lstCaches.itemsSize()-1) btnDown.modify(Disabled,0);
+		btnUp.repaintNow();
+		btnDown.repaintNow();
+		// Need at least 2 caches in list to enable it
+		btnFilter.modify(0,Disabled);
+		if (needsInit || lstCaches.itemsSize()&lt;2) btnFilter.modify(Disabled,0);
+		btnFilter.repaintNow();
+	}
+	
+	public void onEvent(Event ev) {
+		if (ev instanceof MenuEvent &amp;&amp; ev.type==MenuEvent.SELECTED) {
+			if (lstCaches.itemsSize()&gt;0) {
+				int lstCacheIdx=lstCaches.getSelectedIndex(0);
+				CacheHolder ch=(CacheHolder)cacheList.get(lstCacheIdx);
+				int idx=Global.getProfile().cacheDB.find(ch);
+				// Select the cache also in the main list view
+				Global.mainTab.tbP.selectRow(idx);
+				// Ensure that the main view is updated with the selected cache, i.e.
+				// DetailsPanel, HintLog, Pictures etc.
+				int activeTab=Global.mainTab.cardPanel.selectedItem;
+				if (activeTab==0) 
+					Global.mainTab.tbP.tc.repaint();
+				else
+					Global.mainTab.onEvent(new MultiPanelEvent(0,Global.mainTab,activeTab));
+			}
+		}
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
+			if (ev.target==btnNew) { 
+				newCacheList();
+			} else if(ev.target == btnLoad){
+				FileChooser fc = new FileChooser(FileChooser.OPEN, Global.getProfile().dataDir);
+				//fc.addMask(currCh.wayPoint + &quot;.wl&quot;);
+				fc.addMask(&quot;*.&quot;+EXTENSION);
+				fc.addMask(&quot;*.*&quot;);
+				fc.setTitle(MyLocale.getMsg(191,&quot;Select File&quot;));
+				if(fc.execute() != FileChooser.IDCANCEL){
+					currFile = fc.getChosen();
+					readFromFile(currFile);
+				}
+			} else if((ev.target == btnSave) &amp;&amp; (currFile != null)){
+				saveToFile(currFile);
+			} else if((ev.target == btnSaveAs)||((ev.target == btnSave) &amp;&amp; (currFile == null))){
+				FileChooser fc = new FileChooser(FileChooser.SAVE, Global.getProfile().dataDir);
+				//fc.addMask(currCh.wayPoint + &quot;.wl&quot;);
+				fc.addMask(&quot;*.&quot;+EXTENSION);
+				fc.setTitle(MyLocale.getMsg(191,&quot;Select File&quot;));
+				if(fc.execute() != FileChooser.IDCANCEL){
+					currFile = fc.getChosen();
+					saveToFile(currFile);
+				}
+			} else if (ev.target==btnUp) {
+				int sel=lstCaches.getSelectedIndex(0);
+				if (sel&gt;0) {
+					dirty=true;
+					// Swap items in hidden list
+					Object swap=cacheList.get(sel-1);
+					cacheList.set(sel-1,cacheList.get(sel));
+					cacheList.set(sel,swap);
+					// Swap items in visible cachelist and repaint
+					swap=lstCaches.items.get(sel-1);
+					lstCaches.items.set(sel-1,lstCaches.items.get(sel));
+					lstCaches.items.set(sel,swap);
+					lstCaches.repaintDataNow();
+					lstCaches.select(sel-1);
+				}
+			} else if (ev.target==btnDown) {
+				int sel=lstCaches.getSelectedIndex(0);
+				if (sel&lt;lstCaches.itemsSize()-1) {
+					dirty=true;
+					// Swap items in hidden list
+					Object swap=cacheList.get(sel+1);
+					cacheList.set(sel+1,cacheList.get(sel));
+					cacheList.set(sel,swap);
+					// Swap items in visible cachelist and repaint
+					swap=lstCaches.items.get(sel+1);
+					lstCaches.items.set(sel+1,lstCaches.items.get(sel));
+					lstCaches.items.set(sel,swap);
+					lstCaches.repaintDataNow();
+					lstCaches.select(sel+1);
+				}
+			} else if (ev.target==btnFilter) {
+				Vector cacheDB=Global.getProfile().cacheDB;
+				CacheHolder ch;
+				// Start by setting all caches to filtered
+				for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+					ch = (CacheHolder)cacheDB.get(i);
+					ch.is_filtered=true ; // ignore blacklist attribute
+					ch.sort=&quot;\uFFFF&quot;;
+				}
+				// Now &quot;unfilter&quot; the caches in our list
+				for (int i = cacheList.size()-1; i&gt;=0; i--) {
+					ch = (CacheHolder)cacheList.get(i);
+					ch.is_filtered=false;
+					ch.sort=MyLocale.formatLong(i,&quot;00000&quot;);
+				}
+				// The sort command places all filtered caches at the end
+				cacheDB.sort(new mySort(),false);
+				Filter.filterActive=true;
+				Filter.filterInverted=false;
+				updateScreen();
+			}
+		}
+		changeUpDownButtonStatus();
+	}
+
+
+	/** Add a cache (and its addis) to the list 
+	 * @return true if the cache is not already in lstCaches */
+	public boolean addCache(String wayPoint) {
+		// Check whether this is the first cache being added
+		if (needsInit)  {lstCaches.deleteItem(0);lstCaches.deleteItem(0);  needsInit=false; }
+		int idx=Global.getProfile().getCacheIndex(wayPoint);
+		if (idx==-1) return false;
+		CacheHolder ch=(CacheHolder) Global.getProfile().cacheDB.get(idx);
+		boolean cachesAdded=false;
+		// Add addis if user wants it
+		if (chkAddAddis.state &amp;&amp; ch.hasAddiWpt()) {
+			CacheHolder addiWpt;
+			for (int j=0; j&lt;ch.addiWpts.getCount();j++){
+				addiWpt = (CacheHolder)ch.addiWpts.get(j);
+				if (!addiWpt.is_filtered) cachesAdded|=addCache(addiWpt);
+			}
+		}
+		// Add main cache
+		cachesAdded|=addCache(ch);
+		// Update screen if any cache was added
+		if (cachesAdded) {	
+			lstCaches.select(lstCaches.itemsSize()-1);
+			changeUpDownButtonStatus();
+		}
+		return cachesAdded;	
+	}
+
+	/** Add a cache to the visible and invisible list */
+	private boolean addCache(CacheHolder ch) {
+		if (cacheList.find(ch)&lt;0) {
+			// Add cache reference to hidden list
+			cacheList.add(ch);
+			// Add Cache and cache icon to visible list
+			lstCaches.addItem((new MenuItem()).iconize(ch.wayPoint+&quot;   &quot;+ch.CacheName,(IImage) Global.mainTab.tbP.myMod.cacheImages[Convert.parseInt(ch.type)],true));
+		    dirty=true;
+			return true;
+		} else
+			return false;
+	}
+	
+	void updateScreen() {
+		Global.mainTab.tbP.myMod.numRows=cacheList.size();
+		// Check whether the currently selected cache is still visible
+		//selectRow(getSelectedCache());
+		Global.mainTab.tbP.tc.update(true); // Update and repaint
+		if (Global.mainTab.tbP.statBar!=null) Global.mainTab.tbP.statBar.updateDisplay();
+		int selPanel;
+		if ((selPanel=Global.mainTab.cardPanel.selectedItem)&gt;-1) {
+			if (selPanel==1) {
+				//postEvent(new MultiPanelEvent(MultiPanelEvent.SELECTED,Global.mainTab,1));
+				Global.mainTab.detP.repaint();
+			}
+		}
+	}
+
+	/** Check if there are any unsaved changes and ask user if he wants to save */
+	public void saveIfDirty() {
+		if (dirty) {
+			if ((new MessageBox(MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(192,&quot;Save changes&quot;),MessageBox.MBYESNO)).execute()==MessageBox.IDYES) {
+				if (currFile!=null)
+					saveToFile(currFile);
+				else {
+					FileChooser fc = new FileChooser(FileChooser.SAVE, Global.getProfile().dataDir);
+					fc.addMask(&quot;*.&quot;+EXTENSION);
+					fc.setTitle(MyLocale.getMsg(191,&quot;Select File&quot;));
+					if(fc.execute() != FileChooser.IDCANCEL){
+						currFile = fc.getChosen();
+						saveToFile(currFile);
+					}
+				}
+			}
+		}
+		dirty=false;
+	}
+	
+	/** Clear the cachelist (save unsaved changes if needed) */
+	private void newCacheList() { 		
+		saveIfDirty();
+		lstCaches.items.clear();
+		cacheList.clear();
+		lstCaches.repaint();
+		lblTitle.setText(TITLE);
+		currFile=null;
+	}
+	
+	/** Read a list of caches */
+	private void readFromFile(String fileName) {
+		if (needsInit)  {lstCaches.deleteItem(0);lstCaches.deleteItem(0);  needsInit=false; }
+		int select=-1;
+		try {
+			FileReader in = new FileReader(fileName);
+			String wayPoint;
+			int idx;
+			Vector cacheDB=Global.getProfile().cacheDB;
+			int lineNr=0;
+			while ((wayPoint = in.readLine()) != null){
+				wayPoint=wayPoint.trim();
+				// Select the cache starting with &gt;
+				if (wayPoint.startsWith(&quot;&gt;&quot;)) {
+					wayPoint=wayPoint.substring(1);
+					select=lineNr;
+				}
+				// Only add the cache if it is in this profile
+				idx=Global.getProfile().getCacheIndex(wayPoint);
+				if (idx&gt;=0) {
+					addCache((CacheHolder) cacheDB.get(idx));
+				}
+				lineNr++;
+			}
+			in.close();
+		} catch(Exception e) {
+			Global.getPref().log(&quot;Problem reading: &quot; +fileName,e,true);
+		}
+		if (select&gt;-1)
+			lstCaches.select(select);
+		else	
+		    lstCaches.select(lstCaches.itemsSize()-1);
+		lstCaches.repaint();
+		this.postEvent(new MenuEvent(MenuEvent.SELECTED,this,null));
+		changeUpDownButtonStatus();
+		setTitle(fileName);
+		dirty=false;
+	}
+	
+	/** Save the cachelist */
+	private void saveToFile(String fileName) {
+		int selectedIndex=lstCaches.getSelectedIndex(0);
+		try {
+			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(fileName)));
+			for (int i=0; i&lt;cacheList.size(); i++) {
+				// Put a &gt; in front of the selected cache
+				outp.print((i==selectedIndex?&quot;&gt;&quot;:&quot;&quot;)+((CacheHolder)cacheList.get(i)).wayPoint+&quot;\n&quot;);
+			}
+			outp.close();
+		} catch(Exception e) {
+			Global.getPref().log(&quot;Problem saving: &quot; +fileName,e,true);
+		}
+		setTitle(fileName);
+		dirty=false;
+	}
+	
+	/** Set the title */
+	private void setTitle(String fileName) {
+		String localFileName=fileName.replace('\\','/');
+		// Delete the path preceding the filename
+		if (localFileName.lastIndexOf('/')&gt;0)
+			localFileName=localFileName.substring(localFileName.lastIndexOf('/')+1);
+		// Drop the extension
+		if (localFileName.indexOf('.')&gt;0)
+			lblTitle.setText(localFileName.substring(0,localFileName.indexOf('.')));
+		else
+			lblTitle.setText(localFileName);
+		lblTitle.repaint();
+	}
+}

Modified: trunk/src/CacheWolf/Global.java
===================================================================
--- trunk/src/CacheWolf/Global.java	2007-07-03 21:37:34 UTC (rev 776)
+++ trunk/src/CacheWolf/Global.java	2007-07-07 21:13:41 UTC (rev 777)
@@ -18,5 +18,6 @@
 	  }
       // A bit of a hack to allow access from one panel to another
 	  static public MainTab mainTab;
+	  static public MainForm mainForm;
 }
 

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-07-03 21:37:34 UTC (rev 776)
+++ trunk/src/CacheWolf/MainForm.java	2007-07-07 21:13:41 UTC (rev 777)
@@ -9,6 +9,10 @@
 *	Class ID = 5000
 */
 public class MainForm extends Form {
+	// The next three declares are for the cachelist
+	boolean cacheListVisible=false;
+    CacheList cacheList;
+    SplittablePanel split;
 	
 	StatusBar statBar=null;
 	Preferences pref = Global.getPref(); // Singleton pattern
@@ -42,6 +46,7 @@
 	}
 	
 	public void doIt(){
+		Global.mainForm=this;
 		this.title = &quot;CacheWolf &quot; + Version.getRelease();
 		this.exitSystemOnClose = true;
 		this.resizable = true;
@@ -83,16 +88,25 @@
 		if (pref.showStatus) statBar = new StatusBar(pref, profile.cacheDB);
 		mMenu = new MainMenu(this);
 		mTab = new MainTab(mMenu,statBar);
+		split=new SplittablePanel(PanelSplitter.HORIZONTAL);
+		split.theSplitter.thickness=0; split.theSplitter.modify(Invisible,0);
+		CellPanel pnlCacheList = split.getNextPanel();
+		CellPanel pnlMainTab = split.getNextPanel(); 
+		split.setSplitter(PanelSplitter.MIN_SIZE|PanelSplitter.BEFORE,PanelSplitter.HIDDEN|PanelSplitter.BEFORE,PanelSplitter.CLOSED);
+		pnlCacheList.addLast(cacheList=new CacheList(),STRETCH,FILL);
+		pnlMainTab.addLast(mTab,STRETCH,FILL);
+		mTab.dontAutoScroll=true;
 		if (pref.menuAtTop) {
 			this.addLast(mMenu,CellConstants.DONTSTRETCH, CellConstants.FILL);
-			this.addLast(mTab,CellConstants.STRETCH, CellConstants.FILL);
+			this.addLast(split,STRETCH,FILL);
 		} else {
-			this.addLast(mTab,CellConstants.STRETCH, CellConstants.FILL);
+			this.addLast(split,STRETCH,FILL);
 			this.addLast(mMenu,CellConstants.DONTSTRETCH, CellConstants.FILL);
 		}
 		mMenu.setTablePanel(mTab.getTablePanel());
 		infB.close(0);
 		mTab.tbP.selectFirstRow();
+		//mTab.tbP.tc.paintSelection();
 		Vm.showWait(false);
 	}
 
@@ -122,4 +136,22 @@
 		super.onEvent(ev);
 	}
 
+	public void toggleCacheListVisible() {
+		cacheListVisible=!cacheListVisible;
+		if (cacheListVisible) {
+			// Make the splitterbar visible with a width of 6 
+			split.theSplitter.modify(0,Invisible);
+			split.theSplitter.resizeTo(6,split.theSplitter.getRect().height);
+			Global.mainForm.mMenu.orgCacheTour.modifiers|=MenuItem.Checked;
+		} else {
+			// Hide the splitterbar and set width to 0
+			split.theSplitter.modify(Invisible,0);
+			split.theSplitter.resizeTo(0,split.theSplitter.getRect().height);
+			Global.mainForm.mMenu.orgCacheTour.modifiers&amp;=~MenuItem.Checked;
+		}
+		split.theSplitter.doOpenClose(cacheListVisible);
+		Global.mainForm.mMenu.repaint();
+		
+	}
+	
 }

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-07-03 21:37:34 UTC (rev 776)
+++ trunk/src/CacheWolf/MainMenu.java	2007-07-07 21:13:41 UTC (rev 777)
@@ -29,6 +29,7 @@
 	private MenuItem filtCreate, filtClear, filtInvert, filtSelected, filtBlack, filtApply;
 	private MenuItem exportGPS, exportCacheMate,mnuSeparator;
 	private MenuItem orgCopy, orgMove, orgDelete;
+	public MenuItem orgCacheTour;
 	private MenuItem mnuNewProfile, mnuOpenProfile, mnuEditCenter;
 	private Form father;
 	private TablePanel tbp;
@@ -150,10 +151,12 @@
 		///////////////////////////////////////////////////////////////////////
 		// Create the &quot;Organize&quot; pulldown menu
 		///////////////////////////////////////////////////////////////////////
-		MenuItem[] organizeMenuItems=new MenuItem[3];
+		MenuItem[] organizeMenuItems=new MenuItem[5];
 		organizeMenuItems[0] = orgCopy  = new MenuItem(MyLocale.getMsg(141,&quot;Copy&quot;)); 
 		organizeMenuItems[1] = orgMove  = new MenuItem(MyLocale.getMsg(142,&quot;Move&quot;)); 
 		organizeMenuItems[2] = orgDelete   = new MenuItem(MyLocale.getMsg(143,&quot;Delete&quot;));
+		organizeMenuItems[3] = mnuSeparator;
+		organizeMenuItems[4] = orgCacheTour = new MenuItem(MyLocale.getMsg(198,&quot;Cachetour&quot;));
 		this.addMenu(new PullDownMenu(MyLocale.getMsg(140,&quot;Organize&quot;),new Menu(organizeMenuItems,null)));
 
 		///////////////////////////////////////////////////////////////////////
@@ -496,6 +499,10 @@
 				dm.deleteCaches();
 				tbp.refreshTable();
 			}
+			if(mev.selectedItem == orgCacheTour){
+				orgCacheTour.modifiers^=MenuItem.Checked;
+				Global.mainForm.toggleCacheListVisible();			
+			}
 			///////////////////////////////////////////////////////////////////////
 			// &quot;About&quot; pulldown menu
 			///////////////////////////////////////////////////////////////////////
@@ -533,14 +540,15 @@
 			if(mev.selectedItem == chkVersion){
 				Version vers = new Version();
 				if(vers.newVersionAvailable(pref)){
-					InfoBox inf = new InfoBox(&quot;New Version&quot;, &quot;New version\navailable.&quot;);// TODO Internationalisation when code has been written
+					InfoBox inf = new InfoBox(MyLocale.getMsg(176,&quot;New Version&quot;), MyLocale.getMsg(177,&quot;New version\navailable.&quot;));
 					inf.execute();
 				} else {
-					InfoBox inf = new InfoBox(&quot;Version Check&quot;, &quot;You are at\nthe current version.&quot;);// TODO Internationalisation when code has been written
+					InfoBox inf = new InfoBox(MyLocale.getMsg(178,&quot;Version Check&quot;), MyLocale.getMsg(179,&quot;You are at\nthe current version.&quot;));
 					inf.execute();
 				}
 			}
 
 		}
 	}
+	
 }

Modified: trunk/src/CacheWolf/StatusBar.java
===================================================================
--- trunk/src/CacheWolf/StatusBar.java	2007-07-03 21:37:34 UTC (rev 776)
+++ trunk/src/CacheWolf/StatusBar.java	2007-07-07 21:13:41 UTC (rev 777)
@@ -16,12 +16,18 @@
 	Preferences pref;
 	mButton btnFlt;
 	mImage imgFlt;
+	mButton btnCacheTour;
+	mImage imgCacheTour; 
 	
 	public StatusBar(Preferences p, Vector db){
 		pref=p;
+		addNext(btnCacheTour=new mButton(imgCacheTour=new mImage(&quot;cachetour.png&quot;)),CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		imgCacheTour.transparentColor=Color.White;
+		btnCacheTour.setPreferredSize(20,13);btnCacheTour.borderWidth=0; 
+		btnCacheTour.setToolTip(MyLocale.getMsg(197,&quot;Show/Hide cachetour&quot;));
 		stats = new DBStats(db);
 		addNext(disp = new mLabel(&quot;&quot;),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		disp.setToolTip(&quot;Total # of caches (GC&amp;OC)\nTotal # visible\nTotal # found&quot;);
+		disp.setToolTip(MyLocale.getMsg(196,&quot;Total # of caches (GC&amp;OC)\nTotal # visible\nTotal # found&quot;));
 		addNext(btnFlt= new mButton(imgFlt=new mImage(&quot;filter.png&quot;)),CellConstants.DONTSTRETCH, CellConstants.DONTFILL); 
 		btnFlt.backGround=new ewe.fx.Color(0,255,0); 
 		btnFlt.setPreferredSize(20,13);
@@ -29,7 +35,7 @@
 		btnFlt.setToolTip(&quot;Filter status&quot;);
 //		addNext(lblFlt= new mLabel(&quot;Flt&quot;),CellConstants.DONTSTRETCH, CellConstants.DONTFILL); lblFlt.backGround=new ewe.fx.Color(0,255,0);
 		addLast(lblCenter=new mLabel(&quot;&quot;),CellConstants.STRETCH, WEST|CellConstants.FILL);
-		lblCenter.setToolTip(&quot;Current center&quot;);
+		lblCenter.setToolTip(MyLocale.getMsg(195,&quot;Current center&quot;));
 		updateDisplay();
 	}
 	
@@ -65,6 +71,9 @@
 				}
 				Global.mainTab.tbP.refreshTable();
 			}
+			if (ev.target == btnCacheTour){
+				Global.mainForm.toggleCacheListVisible();			
+			}
 		}
 		super.onEvent(ev);
 	}

Modified: trunk/src/CacheWolf/myInteractivePanel.java
===================================================================
--- trunk/src/CacheWolf/myInteractivePanel.java	2007-07-03 21:37:34 UTC (rev 776)
+++ trunk/src/CacheWolf/myInteractivePanel.java	2007-07-07 21:13:41 UTC (rev 777)
@@ -1,6 +1,7 @@
 package CacheWolf;
 import ewe.graphics.*;
 import ewe.ui.*;
+import ewe.util.Vector;
 import ewe.sys.*;
 import ewe.fx.*;
 import ewe.graphics.*;
@@ -23,6 +24,7 @@
 	AniImage imgInfo;
 	String strDifficulty=MyLocale.getMsg(1120,&quot;Diff&quot;);
 	String strTerrain=MyLocale.getMsg(1121,&quot;Terr&quot;);
+	AniImage imgDrag; // Allows the dragging of the cache into the cachelist
 	
 	private void clearInfo() {
 		removeImage(imgInfo);
@@ -74,7 +76,8 @@
 		imgInfo.properties = mImage.IsNotHot;
 		addImage(imgInfo);
 		refreshOnScreen(imgInfo);
-		return true;
+		imgDrag=which;
+	return true;
 	}
 	public boolean imageMovedOff(AniImage which) {
 		clearInfo();
@@ -82,41 +85,92 @@
 	}
 	public void onPenEvent(PenEvent ev) {
 		super.onPenEvent(ev);
-		if (ev.type==PenEvent.PEN_UP) clearInfo();
+		if (ev.type==PenEvent.PEN_UP) {
+			clearInfo();
+			// The next line is needed due to a bug in EWE (it does not call penReleased)
+			if (isDragging) penReleased(new Point(ev.x,ev.y));
+		}
 	}
-	/*
-	public void onEvent(Event ev){
-		BufferedGraphics bfg;
-		Graphics g;
-		if(ev instanceof PenEvent &amp;&amp; ev.type == PenEvent.PEN_DRAG){
-			PenEvent pev = (PenEvent)ev;
-			if(penMoving == false){
-				penMoving = true;
-				x1 = pev.x;
-				y1 = pev.y;
-				x2 = x1;
-				y2 = y1;
-				Vm.debug(&quot;Pen starting&quot;);
-			} else {
-				bfg = new BufferedGraphics(this.getGraphics(), new Rect(new Dimension(50,50)));
-				g = bfg.getGraphics();
-				g.setDrawOp(Graphics.DRAW_XOR);
-				g.setPen(new Pen(RED,Pen.SOLID,1));
-				g.drawRect(x1,y1,20,20);
-				bfg.release();
-				x2 = pev.x;
-				y2 = pev.y;
-				bfg = new BufferedGraphics(this.getGraphics(), new Rect(new Dimension(50,50)));
-				g = bfg.getGraphics();
-				g.setDrawOp(Graphics.DRAW_XOR);
-				g.setPen(new Pen(RED,Pen.SOLID,1));
-				g.drawRect(x1,y1,x2-x1,y2-y1);
-				bfg.release();
-				Vm.debug(&quot;Pen moving&quot;);
-			}
+	
+    ///////////////////////////////////////////////////
+	//  Allow the caches to be dragged into a cachelist
+    ///////////////////////////////////////////////////
+	
+	String wayPoint;
+	
+	public void startDragging(DragContext dc) {
+		Vector cacheDB=Global.getProfile().cacheDB;
+//Vm.debug(&quot;myIAP startDrag &quot;+dc.start.x+&quot;/&quot;+dc.start.y+&quot;  &quot;+ch.wayPoint);
+		 int idx=Global.getProfile().getCacheIndex(wayPoint); 
+		if (idx&gt;=0) {
+			 CacheHolder ch=(CacheHolder) cacheDB.get(idx);
+			 //wayPoint=ch.wayPoint;
+			 //Vm.debug(&quot;Waypoint : &quot;+ch.wayPoint);
+			 IconAndText icnDrag=new IconAndText();
+			 icnDrag.addColumn((IImage) Global.mainTab.tbP.myMod.cacheImages[Convert.parseInt(ch.type)]);
+			 icnDrag.addColumn(ch.wayPoint);
+			 dc.dragData=dc.startImageDrag(icnDrag,new Point(8,8),this);
+			 if (dc instanceof ImageDragContext) Vm.debug(&quot;&gt;&gt;&gt;&gt;Is Image drag&quot;);
+		}
+	 }
+
+	 public void stopDragging(DragContext dc) {}
+	 public void draggingStarted(ImageDragContext dc) {}
+	 public void draggingStopped(ImageDragContext dc) {}
+	 
+	 public boolean imageBeginDragged(AniImage which,Point pos) {
+		clearInfo();
+		wayPoint=null;
+		AniImage dragImage=null;
+		if (which instanceof RadarPanelImage) {
+			RadarPanelImage imgRP=(RadarPanelImage) which;
+			ewe.util.Vector cacheDB=Global.getProfile().cacheDB;
+			CacheHolder ch=(CacheHolder) cacheDB.get(imgRP.rownum);
+			wayPoint=ch.wayPoint;
 			
+			int tw,th;
+			Image img = new Image(tw=fm.getTextWidth(wayPoint+15),th=fm.getHeight()&gt;15?fm.getHeight():15);
+			Graphics g = new Graphics(img);
+			g.setColor(Color.White);
+			g.fillRect(0,0,tw, th);
+			g.setColor(new Color(255,0,0));
+			g.drawText(wayPoint, 15,1);
+			g.drawImage(which.image,0,0);
+			dragImage=new AniImage(img);
+			dragImage.properties|=AniImage.IsMoveable;
+			dragImage.setLocation(pos.x,pos.y);
 		}
-		super.onEvent(ev);
-	}
-	*/
+		return super.imageBeginDragged(dragImage,pos);
+	 }
+
+	 public boolean imageDragged(ImageDragContext drag, Point pos) {
+		 	if (drag.image!=null) {
+/*			    Point p = Gui.getPosInParent(this,getWindow());
+			 	p.x += pos.x-origin.x;
+			 	p.y += pos.y-origin.y;
+			 	Control c = getWindow().findChild(p.x,p.y);
+*/
+				drag.clearPendingDrags();
+		 	}
+		 	return super.imageDragged(drag,pos);
+	 }
+	 
+	 public boolean imageNotDragged(ImageDragContext drag, Point pos) {
+		if (drag.image!=null) {
+			images.remove(drag.image);
+			drag.image=null;
+			refresh();
+		}			
+		 Point p = Gui.getPosInParent(this,getWindow());
+		 p.x += drag.curPoint.x-origin.x;
+		 p.y += drag.curPoint.y-origin.y;
+		 Control c = getWindow().findChild(p.x,p.y);
+	     if (c instanceof mList &amp;&amp; c.text.equals(&quot;CacheList&quot;)) {
+	    	 if (Global.mainForm.cacheList.addCache(wayPoint)) {
+	    		 c.repaintNow();
+	    		 ((mList) c).makeItemVisible(((mList)c).itemsSize()-1);
+	    	 }
+	     }
+		 return false; 
+	 }
 }

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-07-03 21:37:34 UTC (rev 776)
+++ trunk/src/CacheWolf/myTableControl.java	2007-07-07 21:13:41 UTC (rev 777)
@@ -213,4 +213,51 @@
 	    if (ev instanceof PenEvent) Global.mainTab.tbP.myMod.penEventModifiers=((PenEvent)ev).modifiers;
 		super.onEvent(ev);
 	}
+    ///////////////////////////////////////////////////
+	//  Allow the caches to be dragged into a cachelist
+    ///////////////////////////////////////////////////
+	
+	IconAndText imgDrag;
+	String wayPoint;
+	
+	public void startDragging(DragContext dc) {//TODO Dragging of header widths
+		 Vector cacheDB=Global.getProfile().cacheDB;
+		 Point p=cellAtPoint(dc.start.x,dc.start.y,null);
+		 wayPoint=null;
+		 if (p.y&gt;=0) { 
+			 CacheHolder ch=(CacheHolder)cacheDB.get(p.y);
+			 wayPoint=ch.wayPoint;
+			 //Vm.debug(&quot;Waypoint : &quot;+ch.wayPoint);
+			 imgDrag=new IconAndText();
+			 imgDrag.addColumn((IImage) Global.mainTab.tbP.myMod.cacheImages[Convert.parseInt(ch.type)]);
+			 imgDrag.addColumn(ch.wayPoint);
+			 dc.dragData=dc.startImageDrag(imgDrag,new Point(8,8),this);
+		 } else super.startDragging(dc);
+	 }
+
+	 public void stopDragging(DragContext dc) {
+		 if (wayPoint!=null) {
+			 //Vm.debug(&quot;Stop  Dragging&quot;+dc.curPoint.x+&quot;/&quot;+dc.curPoint.y);
+			 dc.stopImageDrag(true);
+			 Point p = Gui.getPosInParent(this,getWindow());
+			 p.x += dc.curPoint.x;
+			 p.y += dc.curPoint.y;
+			 Control c = getWindow().findChild(p.x,p.y);
+		     if (c instanceof mList &amp;&amp; c.text.equals(&quot;CacheList&quot;)) {
+		    	 if (Global.mainForm.cacheList.addCache(wayPoint)) {
+		    		 c.repaintNow();
+		    		 ((mList) c).makeItemVisible(((mList)c).itemsSize()-1);
+		    	 }
+		     }
+			 //Vm.debug(&quot;Control &quot;+c.toString()+&quot;/&quot;+c.text);
+		 }else super.stopDragging(dc);
+	 }
+	 
+	 public void dragged(DragContext dc) {
+	 	if (wayPoint!=null)
+		   dc.imageDrag();
+	 	else
+	 		super.dragged(dc);
+	 }
+
 }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000663.html">[Cachewolf-svn] r776 - trunk/src/CacheWolf
</A></li>
	<LI>Next message: <A HREF="000665.html">[Cachewolf-svn] r778 - trunk/src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#664">[ date ]</a>
              <a href="thread.html#664">[ thread ]</a>
              <a href="subject.html#664">[ subject ]</a>
              <a href="author.html#664">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
