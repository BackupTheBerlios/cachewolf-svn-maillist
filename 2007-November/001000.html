<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r1107 - trunk/src/CacheWolf
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2007-November/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1107%20-%20trunk/src/CacheWolf&In-Reply-To=%3C200711261703.lAQH3dg6025639%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000999.html">
   <LINK REL="Next"  HREF="001001.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r1107 - trunk/src/CacheWolf</H1>
    <B>pfeffer at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1107%20-%20trunk/src/CacheWolf&In-Reply-To=%3C200711261703.lAQH3dg6025639%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r1107 - trunk/src/CacheWolf">pfeffer at mail.berlios.de
       </A><BR>
    <I>Mon Nov 26 18:03:39 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000999.html">[Cachewolf-svn] r1106 - trunk/src/CacheWolf
</A></li>
        <LI>Next message: <A HREF="001001.html">[Cachewolf-svn] r1108 - trunk/src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1000">[ date ]</a>
              <a href="thread.html#1000">[ thread ]</a>
              <a href="subject.html#1000">[ subject ]</a>
              <a href="author.html#1000">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: pfeffer
Date: 2007-11-26 18:03:23 +0100 (Mon, 26 Nov 2007)
New Revision: 1107

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/Log.java
   trunk/src/CacheWolf/LogList.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/myTableModel.java
Log:
Download from OC: merged the changes from SKG and me // still some problems -&gt; I am working on it

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-11-25 22:33:25 UTC (rev 1106)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-11-26 17:03:23 UTC (rev 1107)
@@ -1,4 +1,5 @@
 package CacheWolf;
+
 import ewe.io.IOException;
 import ewe.sys.Convert;
 import ewe.sys.Vm;
@@ -6,442 +7,484 @@
 import ewe.util.Vector;
 
 /**
-*	A class to hold information on a cache.&lt;br&gt;
-*	Not all attributes are filled at once. You will have to look at other
-*	classes and methods to get more information.
-*	
-*/
+ *	A class to hold information on a cache.&lt;br&gt;
+ *	Not all attributes are filled at once. You will have to look at other
+ *	classes and methods to get more information.
+ *	
+ */
 public class CacheHolder {
-protected static final String NODISTANCE = &quot;? km&quot;;
-protected static final String NOBEARING = &quot;?&quot;;
-protected static final String EMPTY = &quot;&quot;;
+	protected static final String NODISTANCE = &quot;? km&quot;;
+	protected static final String NOBEARING = &quot;?&quot;;
+	protected static final String EMPTY = &quot;&quot;;
 
-/** Cachestatus is Found, Not found or a date in format yyyy-mm-dd hh:mm for found date */
-public String CacheStatus = EMPTY;
-/** The name of the waypoint typicall GC.... or OC.... or CW...... (can be any characters) */
-public String wayPoint = EMPTY;
-/** The name of the cache (short description) */
-public String CacheName = EMPTY;
-/** The alias of the owner */
-public String CacheOwner = EMPTY;
-/** The coordinates of the cache */
-public CWPoint pos = new CWPoint();
-/** The coordinates of the cache */
-public String LatLon = pos.toString();
-/** The date when the cache was hidden in format yyyy-mm-dd */
-public String DateHidden = EMPTY;
-/** The size of the cache (as per GC cache sizes Micro, Small, ....) */
-public String CacheSize = &quot;None&quot;;
-/** The distance from the centre in km */
-public double kilom = 0;
-/** The formatted distance such as &quot;x.xx km&quot; */
-public String distance = NODISTANCE;
-/** The bearing N, NNE, NE, ENE ... from the current centre to this point */
-public String bearing = NOBEARING;
-/** The angle (0=North, 180=South) from the current centre to this point */
-public double degrees = 0;
-/** The difficulty of the cache from 1 to 5 in .5 incements */ 
-public String hard = EMPTY;
-/** The terrain rating of the cache from 1 to 5 in .5 incements */
-public String terrain = EMPTY;
-/** The cache type (@see CacheType for translation table)  */
-public String type = &quot;0&quot;; //TODO Should be an int
-/** True if the cache has been archived */
-public boolean is_archived = false;
-/** True if the cache is available for searching */
-public boolean is_available = true;
-/** True if we own this cache */
-public boolean is_owned = false;
-/** True if we have found this cache */
-public boolean is_found = false;
-/** If this is true, the cache has been filtered (is currently invisible) */
-public boolean is_filtered = false;
-/** True if the number of logs for this cache has changed */
-public boolean is_log_update = false;
-/** True if cache details have changed: longDescription, Hints,  */
-public boolean is_update = false;
-/** True if the cache data is incomplete (e.g. an error occurred during spidering */
-public boolean is_incomplete = false;
-/** True if the cache is blacklisted */
-public boolean is_black = false;
-/** True if the cache is new */
-public boolean is_new = false;
-/** True if the cache is part of the results of a search */
-public boolean is_flaged = false;
-/** True if the cache has been selected using the tick box in the list view */
-public boolean is_Checked = false;
-/** Not used: This attribute is saved with the cache and read back but never set */
-//public String dirty = EMPTY;
-/** The unique OC cache ID */
-public String ocCacheID = EMPTY;
-/** The number of times this cache has not been found (max. 5) */
-public int noFindLogs = 0;
-/** Number of recommendations (from the opencaching logs) */
-public int numRecommended = 0;
-/** Number of logs since start of recommendations system */
-public int numLogsSinceRecommendation = 0;
-/** Recommendation score: calculated as ratio  numRecommended / numLogsSinceRecommendation * 100 */
-public int recommendationScore = 0;
-/** True if this cache has travelbugs */
-public boolean has_bug = false;
-/** True if the cache description is stored in HTML format */
-public boolean is_HTML = true;
-/** List of additional waypoints associated with this waypoint */
-public Vector addiWpts = new Vector();
-/** in range is used by the route filter to identify caches in range of a segment*/
-public boolean in_range = false;
-/** If this is an additional waypoint, this links back to the main waypoint */
-public CacheHolder mainCache;
-/** The date this cache was last synced with OC in format yyyyMMddHHmmss */
-public String lastSyncOC = EMPTY;
-public CacheHolderDetail details = null;
-/** When sorting the cacheDB this field is used. The relevant field is copied here and
- *  the sort is always done on this field to speed up the sorting process 
- */
-public String sort;
-private static StringBuffer sb=new StringBuffer(530); // Used in toXML()
+	/** Cachestatus is Found, Not found or a date in format yyyy-mm-dd hh:mm for found date */
+	public String CacheStatus = EMPTY;
+	/** The name of the waypoint typicall GC.... or OC.... or CW...... (can be any characters) */
+	public String wayPoint = EMPTY;
+	/** The name of the cache (short description) */
+	public String CacheName = EMPTY;
+	/** The alias of the owner */
+	public String CacheOwner = EMPTY;
+	/** The coordinates of the cache */
+	public CWPoint pos = new CWPoint();
+	/** The coordinates of the cache */
+	public String LatLon = pos.toString();
+	/** The date when the cache was hidden in format yyyy-mm-dd */
+	public String DateHidden = EMPTY;
+	/** The size of the cache (as per GC cache sizes Micro, Small, ....) */
+	public String CacheSize = &quot;None&quot;;
+	/** The distance from the centre in km */
+	public double kilom = 0;
+	/** The formatted distance such as &quot;x.xx km&quot; */
+	public String distance = NODISTANCE;
+	/** The bearing N, NNE, NE, ENE ... from the current centre to this point */
+	public String bearing = NOBEARING;
+	/** The angle (0=North, 180=South) from the current centre to this point */
+	public double degrees = 0;
+	/** The difficulty of the cache from 1 to 5 in .5 incements */ 
+	public String hard = EMPTY;
+	/** The terrain rating of the cache from 1 to 5 in .5 incements */
+	public String terrain = EMPTY;
+	/** The cache type (@see CacheType for translation table)  */
+	public String type = &quot;0&quot;; //TODO Should be an int
+	/** True if the cache has been archived */
+	public boolean is_archived = false;
+	/** True if the cache is available for searching */
+	public boolean is_available = true;
+	/** True if we own this cache */
+	public boolean is_owned = false;
+	/** True if we have found this cache */
+	public boolean is_found = false;
+	/** If this is true, the cache has been filtered (is currently invisible) */
+	public boolean is_filtered = false;
+	/** True if the number of logs for this cache has changed */
+	public boolean is_log_update = false;
+	/** True if cache details have changed: longDescription, Hints,  */
+	public boolean is_update = false;
+	/** True if the cache data is incomplete (e.g. an error occurred during spidering */
+	public boolean is_incomplete = false;
+	/** True if the cache is blacklisted */
+	public boolean is_black = false;
+	/** True if the cache is new */
+	public boolean is_new = false;
+	/** True if the cache is part of the results of a search */
+	public boolean is_flaged = false;
+	/** True if the cache has been selected using the tick box in the list view */
+	public boolean is_Checked = false;
+	/** Not used: This attribute is saved with the cache and read back but never set */
+//	public String dirty = EMPTY;
+	/** The unique OC cache ID */
+	public String ocCacheID = EMPTY;
+	/** The number of times this cache has not been found (max. 5) */
+	public int noFindLogs = 0;
+	/** Number of recommendations (from the opencaching logs) */
+	public int numRecommended = 0;
+	/** Number of logs since start of recommendations system */
+	public int numLogsSinceRecommendation = 0;
+	/** Recommendation score: calculated as rations  numRecommended / numLogsSinceRecommendation * 100 */
+	public int recommendationScore = 0;
+	/** True if this cache has travelbugs */
+	public boolean has_bug = false;
+	/** True if the cache description is stored in HTML format */
+	public boolean is_HTML = true;
+	/** List of additional waypoints associated with this waypoint */
+	public Vector addiWpts = new Vector();
+	/** in range is used by the route filter to identify caches in range of a segment*/
+	public boolean in_range = false;
+	/** If this is an additional waypoint, this links back to the main waypoint */
+	public CacheHolder mainCache;
+	/** The date this cache was last synced with OC in format yyyyMMddHHmmss */
+	public String lastSyncOC = EMPTY;
+	public CacheHolderDetail details = null;
+	/** When sorting the cacheDB this field is used. The relevant field is copied here and
+	 *  the sort is always done on this field to speed up the sorting process 
+	 */
+	public String sort;
+	private static StringBuffer sb=new StringBuffer(530); // Used in toXML()
 
-//static int nObjects=0;
-public CacheHolder() {//nObjects++;Vm.debug(&quot;CacheHolder() nO=&quot;+nObjects);
-}
+//	static int nObjects=0;
+	public CacheHolder() {//nObjects++;Vm.debug(&quot;CacheHolder() nO=&quot;+nObjects);
+	}
 
-public CacheHolder(CacheHolder ch) {//nObjects++;Vm.debug(&quot;CacheHolder(ch) nO=&quot;+nObjects);
-	update(ch);
-}
+	public CacheHolder(CacheHolder ch) {//nObjects++;Vm.debug(&quot;CacheHolder(ch) nO=&quot;+nObjects);
+		update(ch);
+	}
 
-static char decSep,notDecSep;
-static {
-	decSep=MyLocale.getDigSeparator().charAt(0);
-	notDecSep=decSep=='.'?',':'.';
-}
+	static char decSep,notDecSep;
+	static {
+		decSep=MyLocale.getDigSeparator().charAt(0);
+		notDecSep=decSep=='.'?',':'.';
+	}
 
-public CacheHolder(String xmlString) {
-	int start,end;
-	try {
-		start=xmlString.indexOf('&quot;'); end=xmlString.indexOf('&quot;',start+1);
-		CacheName = SafeXML.cleanback(xmlString.substring(start+1,end));
-		
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		CacheOwner = SafeXML.cleanback(xmlString.substring(start+1,end));
+	public CacheHolder(String xmlString) {
+		int start,end;
+		try {
+			start=xmlString.indexOf('&quot;'); end=xmlString.indexOf('&quot;',start+1);
+			CacheName = SafeXML.cleanback(xmlString.substring(start+1,end));
 
-		// Assume coordinates are in decimal format
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		double lat=Convert.parseDouble(xmlString.substring(start+1,end).replace(notDecSep,decSep));
+			// Assume coordinates are in decimal format
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			double lat=Convert.parseDouble(xmlString.substring(start+1,end).replace(notDecSep,decSep));
 
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		double lon=Convert.parseDouble(xmlString.substring(start+1,end).replace(notDecSep,decSep));
-		pos=new CWPoint(lat,lon);
-		LatLon=pos.toString();
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			double lon=Convert.parseDouble(xmlString.substring(start+1,end).replace(notDecSep,decSep));
+			pos=new CWPoint(lat,lon);
+			LatLon=pos.toString();
 
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		DateHidden = xmlString.substring(start+1,end); 
-		// Convert the US format to YYYY-MM-DD if necessary
-		if (DateHidden.indexOf('/')&gt;-1) DateHidden=DateFormat.MDY2YMD(DateHidden);
-		
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		wayPoint = SafeXML.cleanback(xmlString.substring(start+1,end));
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			DateHidden = xmlString.substring(start+1,end); 
+			// Convert the US format to YYYY-MM-DD if necessary
+			if (DateHidden.indexOf('/')&gt;-1) DateHidden=DateFormat.MDY2YMD(DateHidden);
 
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		CacheStatus = xmlString.substring(start+1,end);
-	
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		type = xmlString.substring(start+1,end);
-		
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		hard = xmlString.substring(start+1,end);
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			wayPoint = SafeXML.cleanback(xmlString.substring(start+1,end));
 
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		terrain = xmlString.substring(start+1,end);
-		
-		// The next item was 'dirty' but this is no longer used.
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		is_filtered = xmlString.substring(start+1,end).equals(&quot;true&quot;); 
-	
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		CacheSize = xmlString.substring(start+1,end);
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			CacheStatus = xmlString.substring(start+1,end);
 
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		is_available = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			type = xmlString.substring(start+1,end);
 
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		is_archived = xmlString.substring(start+1,end).equals(&quot;true&quot;);
-		
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		has_bug = xmlString.substring(start+1,end).equals(&quot;true&quot;);
-		
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		is_black = xmlString.substring(start+1,end).equals(&quot;true&quot;);
-		if(is_black) is_filtered = true;
-	
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		is_owned = xmlString.substring(start+1,end).equals(&quot;true&quot;);
-	
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		is_found = xmlString.substring(start+1,end).equals(&quot;true&quot;);
-	
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		is_new = xmlString.substring(start+1,end).equals(&quot;true&quot;);
-	
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		is_log_update = xmlString.substring(start+1,end).equals(&quot;true&quot;);
-	
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		is_update = xmlString.substring(start+1,end).equals(&quot;true&quot;);
-	
-		// for backwards compatibility set value to true, if it is not in the file
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		is_HTML = !xmlString.substring(start+1,end).equals(&quot;false&quot;);
-	
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		noFindLogs = Convert.toInt(xmlString.substring(start+1,end));
-	
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		ocCacheID = xmlString.substring(start+1,end);
-	
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		is_incomplete = xmlString.substring(start+1,end).equals(&quot;true&quot;);
-	
-		start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-		lastSyncOC = xmlString.substring(start+1,end);
-	} catch (Exception ex) {
-		
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			hard = xmlString.substring(start+1,end);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			terrain = xmlString.substring(start+1,end);
+
+			// The next item was 'dirty' but this is no longer used.
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_filtered = xmlString.substring(start+1,end).equals(&quot;true&quot;); 
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			CacheSize = xmlString.substring(start+1,end);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_available = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_archived = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			has_bug = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_black = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+			if(is_black) is_filtered = true;
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_owned = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_found = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_new = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_log_update = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_update = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+
+			// for backwards compatibility set value to true, if it is not in the file
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_HTML = !xmlString.substring(start+1,end).equals(&quot;false&quot;);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			noFindLogs = Convert.toInt(xmlString.substring(start+1,end));
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			ocCacheID = xmlString.substring(start+1,end);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_incomplete = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			lastSyncOC = xmlString.substring(start+1,end);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			numLogsSinceRecommendation = Convert.toInt(xmlString.substring(start+1,end));
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			numRecommended = Convert.toInt(xmlString.substring(start+1,end));
+			recommendationScore = LogList.getScore(numRecommended, numLogsSinceRecommendation);
+		} catch (Exception ex) {
+
+		}
 	}
-}
 
-public void update(CacheHolder ch) {
-	/* Here we have to distinguish several cases:
+	public void update(CacheHolder ch) {
+		this.recommendationScore = ch.recommendationScore;
+		this.numLogsSinceRecommendation = ch.numLogsSinceRecommendation;
+		this.numRecommended = ch.numRecommended;
+		/* Here we have to distinguish several cases:
 	   this.is_found       this                ch               Update 'this'
 	   --------------------------------------------------------------------
 	   false               empty               yyyy-mm-dd       yes
 	   true                &quot;Found&quot;             yyyy-mm-dd       yes
 	   true                yyyy-mm-dd          yyyy-mm-dd       no (or yes)
 	   true                yyyy-mm-dd hh:mm    yyyy-mm-dd       no
-	*/
-	if (!this.is_found || this.CacheStatus.indexOf(&quot;:&quot;)&lt;0) {
-		this.CacheStatus=ch.CacheStatus;
-		this.is_found = ch.is_found;
-	}this.wayPoint = ch.wayPoint;
-	this.CacheName = ch.CacheName;
-	this.CacheOwner = ch.CacheOwner;
-	// Don't overwrite valid coordinates with invalid ones
-	if (ch.pos.isValid() || !this.pos.isValid()) {
-		this.pos = ch.pos;
-		this.LatLon = ch.LatLon;
+		 */
+		if (!this.is_found || this.CacheStatus.indexOf(&quot;:&quot;)&lt;0) {
+			this.CacheStatus=ch.CacheStatus;
+			this.is_found = ch.is_found;
+		}this.wayPoint = ch.wayPoint;
+		this.CacheName = ch.CacheName;
+		this.CacheOwner = ch.CacheOwner;
+		// Don't overwrite valid coordinates with invalid ones
+		if (ch.pos.isValid() || !this.pos.isValid()) {
+			this.pos = ch.pos;
+			this.LatLon = ch.LatLon;
+		}
+		this.DateHidden = ch.DateHidden;
+		this.CacheSize = ch.CacheSize;
+		this.kilom = ch.kilom;
+		this.distance = ch.distance;
+		this.bearing = ch.bearing;
+		this.degrees = ch.degrees;
+		this.hard = ch.hard;
+		this.terrain = ch.terrain;
+		this.type = ch.type;
+		this.is_archived = ch.is_archived;
+		this.is_available = ch.is_available;
+		this.is_owned = ch.is_owned;
+		this.is_filtered = ch.is_filtered;
+		this.is_log_update = ch.is_log_update;
+		this.is_update = ch.is_update;
+		this.is_incomplete = ch.is_incomplete;
+		this.is_black=ch.is_black;
+		this.addiWpts = ch.addiWpts;
+		this.mainCache=ch.mainCache;
+		this.is_new=ch.is_new;
+		this.is_flaged = ch.is_flaged;
+		this.is_Checked = ch.is_Checked;
+		//this.dirty = ch.dirty;
+		this.ocCacheID = ch.ocCacheID;
+		this.noFindLogs = ch.noFindLogs;
+		this.has_bug = ch.has_bug;
+		this.is_HTML = ch.is_HTML;
+		this.sort=ch.sort;
+		this.lastSyncOC = ch.lastSyncOC;
 	}
-	this.DateHidden = ch.DateHidden;
-	this.CacheSize = ch.CacheSize;
-	this.kilom = ch.kilom;
-	this.distance = ch.distance;
-	this.bearing = ch.bearing;
-	this.degrees = ch.degrees;
-	this.hard = ch.hard;
-	this.terrain = ch.terrain;
-	this.type = ch.type;
-	this.is_archived = ch.is_archived;
-	this.is_available = ch.is_available;
-	this.is_owned = ch.is_owned;
-	this.is_filtered = ch.is_filtered;
-	this.is_log_update = ch.is_log_update;
-	this.is_update = ch.is_update;
-	this.is_incomplete = ch.is_incomplete;
-	this.is_black=ch.is_black;
-	this.addiWpts = ch.addiWpts;
-	this.mainCache=ch.mainCache;
-	this.is_new=ch.is_new;
-	this.is_flaged = ch.is_flaged;
-	this.is_Checked = ch.is_Checked;
-    //this.dirty = ch.dirty;
-	this.ocCacheID = ch.ocCacheID;
-	this.noFindLogs = ch.noFindLogs;
-	this.has_bug = ch.has_bug;
-	this.is_HTML = ch.is_HTML;
-	this.sort=ch.sort;
-	this.lastSyncOC = ch.lastSyncOC;
-}
+	/**
+	 * Call it only when necessary, it takes time, because all logs must be parsed
+	 *
+	 */
+	public void calcRecommendationScore() {
+		if (wayPoint.toLowerCase().startsWith(&quot;oc&quot;) ) {
+			if (getCacheDetails(false) != null) {
+				CacheHolderDetail chD;
+				if (this instanceof CacheHolderDetail)	chD = (CacheHolderDetail)this;
+				else chD = details;
+				chD.CacheLogs.calcRecommendations();
+				recommendationScore = chD.CacheLogs.recommendationRating;
+				numLogsSinceRecommendation = chD.CacheLogs.foundsSinceRecommendation;
+				numRecommended = chD.CacheLogs.numRecommended;
+			} else { // cache doesn't have details
+				recommendationScore = -1;
+				numLogsSinceRecommendation = -1;
+				numRecommended = -1;
+			}
+		} else {
+			recommendationScore = -1;
+			numLogsSinceRecommendation = -1;
+			numRecommended = -1;
+		}
+		if (details != null) {
+		details.recommendationScore = recommendationScore;
+		details.numLogsSinceRecommendation = numLogsSinceRecommendation;
+		details.numRecommended = numRecommended;
+		}
+	}
+	
+	/** Return a XML string containing all the cache data for storing in index.xml */
+	public String toXML() {
+		if (this instanceof CacheHolderDetail || (details != null &amp;&amp; details.hasUnsavedChanges)) calcRecommendationScore(); 
+		sb.delete(0,sb.length());
+		sb.append(&quot;    &lt;CACHE name = \&quot;&quot;);
+		sb.append(SafeXML.clean(CacheName));
+		sb.append(&quot;\&quot; owner = \&quot;&quot;);		sb.append(SafeXML.clean(CacheOwner));
+		sb.append(&quot;\&quot; lat = \&quot;&quot;); 		sb.append(pos.latDec ); 
+		sb.append(&quot;\&quot; lon = \&quot;&quot;);		sb.append(pos.lonDec);
+		sb.append(&quot;\&quot; hidden = \&quot;&quot;);	sb.append(DateHidden);
+		sb.append(&quot;\&quot; wayp = \&quot;&quot;);		sb.append(SafeXML.clean(wayPoint));
+		sb.append(&quot;\&quot; status = \&quot;&quot;);	sb.append(CacheStatus);
+		sb.append(&quot;\&quot; type = \&quot;&quot;);		sb.append(type);
+		sb.append(&quot;\&quot; dif = \&quot;&quot;);		sb.append(hard);
+		sb.append(&quot;\&quot; terrain = \&quot;&quot; );	sb.append(terrain ); 
+		sb.append(&quot;\&quot; filtered = \&quot;&quot; ); sb.append(is_filtered); // This was 'dirty', but dirty is not used
+		sb.append(&quot;\&quot; size = \&quot;&quot;);		sb.append(CacheSize);
+		sb.append(&quot;\&quot; online = \&quot;&quot; );	sb.append(is_available); 
+		sb.append(&quot;\&quot; archived = \&quot;&quot; );	sb.append(is_archived); 
+		sb.append(&quot;\&quot; has_bug = \&quot;&quot; ); 	sb.append(has_bug); 
+		sb.append(&quot;\&quot; black = \&quot;&quot; ); 	sb.append(is_black); 
+		sb.append(&quot;\&quot; owned = \&quot;&quot; ); 	sb.append(is_owned); 
+		sb.append(&quot;\&quot; found = \&quot;&quot; ); 	sb.append(is_found); 
+		sb.append(&quot;\&quot; is_new = \&quot;&quot; );	sb.append(is_new);
+		sb.append(&quot;\&quot; is_log_update = \&quot;&quot; );sb.append(is_log_update); 
+		sb.append(&quot;\&quot; is_update = \&quot;&quot; );sb.append(is_update); 
+		sb.append(&quot;\&quot; is_HTML = \&quot;&quot; ); 	sb.append(is_HTML); 
+		sb.append(&quot;\&quot; DNFLOGS = \&quot;&quot; ); 	sb.append(noFindLogs ); 
+		sb.append(&quot;\&quot; ocCacheID = \&quot;&quot; );sb.append(ocCacheID ); 
+		sb.append(&quot;\&quot; is_INCOMPLETE = \&quot;&quot;);sb.append(is_incomplete); 
+		sb.append(&quot;\&quot; lastSyncOC = \&quot;&quot; );sb.append(lastSyncOC ); 
+		sb.append(&quot;\&quot; num_recommended = \&quot;&quot;);sb.append(Convert.formatInt(numRecommended)); 
+		sb.append(&quot;\&quot; num_found = \&quot;&quot; );sb.append(Convert.formatInt(numLogsSinceRecommendation));
+		sb.append(&quot;\&quot; /&gt;\n&quot;);
+		return sb.toString();
+	}
 
-/** Return a XML string containing all the cache data for storing in index.xml */
-public String toXML() {
-	sb.delete(0,sb.length());
-	sb.append(&quot;    &lt;CACHE name = \&quot;&quot;);
-	sb.append(SafeXML.clean(CacheName));
-	sb.append(&quot;\&quot; owner = \&quot;&quot;);		sb.append(SafeXML.clean(CacheOwner));
-	sb.append(&quot;\&quot; lat = \&quot;&quot;); 		sb.append(pos.latDec ); 
-	sb.append(&quot;\&quot; lon = \&quot;&quot;);		sb.append(pos.lonDec);
-	sb.append(&quot;\&quot; hidden = \&quot;&quot;);	sb.append(DateHidden);
-	sb.append(&quot;\&quot; wayp = \&quot;&quot;);		sb.append(SafeXML.clean(wayPoint));
-	sb.append(&quot;\&quot; status = \&quot;&quot;);	sb.append(CacheStatus);
-	sb.append(&quot;\&quot; type = \&quot;&quot;);		sb.append(type);
-	sb.append(&quot;\&quot; dif = \&quot;&quot;);		sb.append(hard);
-	sb.append(&quot;\&quot; terrain = \&quot;&quot; );	sb.append(terrain ); 
-	sb.append(&quot;\&quot; filtered = \&quot;&quot; ); sb.append(is_filtered); // This was 'dirty', but dirty is not used
-	sb.append(&quot;\&quot; size = \&quot;&quot;);		sb.append(CacheSize);
-	sb.append(&quot;\&quot; online = \&quot;&quot; );	sb.append(is_available); 
-	sb.append(&quot;\&quot; archived = \&quot;&quot; );	sb.append(is_archived); 
-	sb.append(&quot;\&quot; has_bug = \&quot;&quot; ); 	sb.append(has_bug); 
-	sb.append(&quot;\&quot; black = \&quot;&quot; ); 	sb.append(is_black); 
-	sb.append(&quot;\&quot; owned = \&quot;&quot; ); 	sb.append(is_owned); 
-	sb.append(&quot;\&quot; found = \&quot;&quot; ); 	sb.append(is_found); 
-	sb.append(&quot;\&quot; is_new = \&quot;&quot; );	sb.append(is_new);
-	sb.append(&quot;\&quot; is_log_update = \&quot;&quot; );sb.append(is_log_update); 
-	sb.append(&quot;\&quot; is_update = \&quot;&quot; );sb.append(is_update); 
-	sb.append(&quot;\&quot; is_HTML = \&quot;&quot; ); 	sb.append(is_HTML); 
-	sb.append(&quot;\&quot; DNFLOGS = \&quot;&quot; ); 	sb.append(noFindLogs ); 
-	sb.append(&quot;\&quot; ocCacheID = \&quot;&quot; );sb.append(ocCacheID ); 
-	sb.append(&quot;\&quot; is_INCOMPLETE = \&quot;&quot;);sb.append(is_incomplete); 
-	sb.append(&quot;\&quot; lastSyncOC = \&quot;&quot; );sb.append(lastSyncOC ); 
-	sb.append(&quot;\&quot; /&gt;\n&quot;);
-	return sb.toString();
-}
+	public void setLatLon(String latLon) {
+		latLon=latLon.trim();
+		if (!latLon.equals(LatLon.trim())) is_update=true;
+		LatLon = latLon;
+		pos.set(latLon);
+	}
 
-public void setLatLon(String latLon) {
-	latLon=latLon.trim();
-	if (!latLon.equals(LatLon.trim())) is_update=true;
-	LatLon = latLon;
-	pos.set(latLon);
-}
+	public boolean isAddiWpt() {
+		return CacheType.isAddiWpt(this.type);
+	}
 
-public boolean isAddiWpt() {
-	   return CacheType.isAddiWpt(this.type);
-   }
+	public boolean hasAddiWpt() {
+		if (this.addiWpts.getCount()&gt;0) return true;
+		else return false;
+	}
 
-   public boolean hasAddiWpt() {
-	   if (this.addiWpts.getCount()&gt;0) return true;
-	   else return false;
-   }
 
-   
-   public void calcDistance(CWPoint toPoint) {	
-	   if(pos.isValid()){
+	public void calcDistance(CWPoint toPoint) {	
+		if(pos.isValid()){
 			kilom = pos.getDistance(toPoint);
 			degrees = toPoint.getBearing(pos);
 			bearing = CWPoint.getDirection(degrees);
 			distance = MyLocale.formatDouble(kilom,&quot;0.00&quot;)+&quot; km&quot;;
-	   } else {
-		   distance = NODISTANCE;
-		   bearing = NOBEARING;
-	   }
-   }
-   public void setAttributesFromMainCache(CacheHolder mainCh){
-	   this.CacheOwner = mainCh.CacheOwner;
-	   this.CacheStatus = mainCh.CacheStatus;
-	   this.is_archived = mainCh.is_archived;
-	   this.is_available = mainCh.is_available;
-	   this.is_black = mainCh.is_black;
-	   this.is_owned = mainCh.is_owned;
-	   this.is_new = mainCh.is_new;
-	   this.is_found = mainCh.is_found;
-   }
-   
-   public void setAttributesToAddiWpts(){
-	   if (this.hasAddiWpt()){
-		   CacheHolder addiWpt;
-		   for (int i= this.addiWpts.getCount() - 1;  i&gt;=0; i--){
-			    addiWpt = (CacheHolder) this.addiWpts.get(i);
-			    addiWpt.setAttributesFromMainCache(this);
-		   }
-	   }
-   }
-   
-   /**
-    * True if ch and this belong to the same main cache. 
-    * @param ch
-    * @return
-    */
-   public boolean hasSameMainCache(CacheHolder ch) {
-	   if (this == ch) return true;
-	   if (ch == null) return false;
-	   if ((!this.isAddiWpt()) &amp;&amp; (!ch.isAddiWpt())) return false;
-	   CacheHolder main1, main2;
-	   if (this.isAddiWpt()) main1 = this.mainCache;  else main1 = this;
-	   if (ch.isAddiWpt()) main2 = ch.mainCache; else main2 = ch; 
-	   return main1 == main2;
-   }
-   
-   /** 
-    * Call this method to get the long-description and so on.
-    * If the according .xml-file is already read, it will return
-    * that one, otherwise it will be loaded.
-    * To avoid memory problems this routine loads not for more caches than maxDetails
-    * the details. If maxdetails is reached, it will remove from RAM the details 
-    * of the 5 caches that were loaded most long ago.
-    * 
-    * @return the respective CacheHolderDetail, null if according xml-file could not be read
-    */
-   
-   public CacheHolderDetail getCacheDetails(boolean maybenew) {
-	   if (details != null) {
-		   details.update(this); // TODO is this logic? what happens if the details were changed and getDetails() is called afterwards all changes will be lost?!
-		   return details;
-	   }
-	   details = new CacheHolderDetail(this);
-	   try {
-		   details.readCache(Global.getProfile().dataDir);
-	   } catch (IOException e) {
-		   if (maybenew) details.update(this);
-		   else {
-			   (new MessageBox(&quot;Error&quot;, &quot;Could not read cache details for cache: &quot;+this.wayPoint, MessageBox.OKB)).execute();
-			   return null;
-		   } 
-	   }
-	   detailsAdded();
-	   return details;
-   }
-   
-   /**
-    * Call this after you added the cache with details to the 
-    * cacheDB &lt;br&gt; It is assumed that that details is set
-    * for an example see OCXMLImporter.endCache()
-    *
-    */
-   public void detailsAdded() {
-	   if (cachesWithLoadedDetails.size() &gt;= Global.getPref().maxDetails) removeOldestDetails();
-	   cachesWithLoadedDetails.add(this);
-	   
-   }
-   
-   public void releaseCacheDetails() {
-	   if (details != null &amp;&amp; details.hasUnsavedChanges) 
-		   details.saveCacheDetails(Global.getProfile().dataDir);
-	   details = null;
-	   cachesWithLoadedDetails.remove(this);
-   }
-   
-   public void cacheAdded(CacheHolderDetail chd) {
-	   
-   }
-   
-   //final static int maxDetails = 50; 
-   static Vector cachesWithLoadedDetails = new Vector(Global.getPref().maxDetails);
-   
-   public static void removeOldestDetails() {
-	   for (int i=0; i&lt;Global.getPref().deleteDetails; i++)
-		   ((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
-   }
- 
-   public static void removeAllDetails() {
-	   for (int i=cachesWithLoadedDetails.size()-1; i&gt;=0; i--)
-		   ((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
-   }
-   
-   /**
-    * when importing caches you can set details.saveChanges = true
-    * when the import ist finished call this method to save the pending changes
-    *
-    */
-   public static void saveAllModifiedDetails() {
-	   CacheHolderDetail chD;
-	   for (int i=cachesWithLoadedDetails.size()-1; i&gt;=0; i--) {
-		   chD = ((CacheHolder)(cachesWithLoadedDetails.get(i))).getCacheDetails(false);
-		   if (chD.hasUnsavedChanges) 
-			   chD.saveCacheDetails(Global.getProfile().dataDir);
-		   	
-	   }
-   }
+		} else {
+			distance = NODISTANCE;
+			bearing = NOBEARING;
+		}
+	}
+	public void setAttributesFromMainCache(CacheHolder mainCh){
+		this.CacheOwner = mainCh.CacheOwner;
+		this.CacheStatus = mainCh.CacheStatus;
+		this.is_archived = mainCh.is_archived;
+		this.is_available = mainCh.is_available;
+		this.is_black = mainCh.is_black;
+		this.is_owned = mainCh.is_owned;
+		this.is_new = mainCh.is_new;
+		this.is_found = mainCh.is_found;
+	}
 
-   /*
+	public void setAttributesToAddiWpts(){
+		if (this.hasAddiWpt()){
+			CacheHolder addiWpt;
+			for (int i= this.addiWpts.getCount() - 1;  i&gt;=0; i--){
+				addiWpt = (CacheHolder) this.addiWpts.get(i);
+				addiWpt.setAttributesFromMainCache(this);
+			}
+		}
+	}
+
+	/**
+	 * True if ch and this belong to the same main cache. 
+	 * @param ch
+	 * @return
+	 */
+	public boolean hasSameMainCache(CacheHolder ch) {
+		if (this == ch) return true;
+		if (ch == null) return false;
+		if ((!this.isAddiWpt()) &amp;&amp; (!ch.isAddiWpt())) return false;
+		CacheHolder main1, main2;
+		if (this.isAddiWpt()) main1 = this.mainCache;  else main1 = this;
+		if (ch.isAddiWpt()) main2 = ch.mainCache; else main2 = ch; 
+		return main1 == main2;
+	}
+
+	/** 
+	 * Call this method to get the long-description and so on.
+	 * If the according .xml-file is already read, it will return
+	 * that one, otherwise it will be loaded.
+	 * To avoid memory problems this routine loads not for more caches than maxDetails
+	 * the details. If maxdetails is reached, it will remove from RAM the details 
+	 * of the 5 caches that were loaded most long ago.
+	 * 
+	 * @return the respective CacheHolderDetail, null if according xml-file could not be read
+	 */
+
+	public CacheHolderDetail getCacheDetails(boolean maybenew) {
+		if (details != null) {
+			details.update(this); // TODO is this logic? what happens if the details were changed and getDetails() is called afterwards all changes will be lost?!
+			return details;
+		}
+		details = new CacheHolderDetail(this);
+		try {
+			details.readCache(Global.getProfile().dataDir);
+		} catch (IOException e) {
+			if (maybenew) details.update(this);
+			else {
+				(new MessageBox(&quot;Error&quot;, &quot;Could not read cache details for cache: &quot;+this.wayPoint, MessageBox.OKB)).execute();
+				return null;
+			} 
+		}
+		detailsAdded();
+		return details;
+	}
+
+	/**
+	 * Call this after you added the cache with details to the 
+	 * cacheDB &lt;br&gt; It is assumed that that details is set
+	 * for an example see OCXMLImporter.endCache()
+	 *
+	 */
+	public void detailsAdded() {
+		cachesWithLoadedDetails.add(this);
+		if (cachesWithLoadedDetails.size() &gt;= Global.getPref().maxDetails) removeOldestDetails();
+	}
+
+	public void releaseCacheDetails() {
+		if (details != null &amp;&amp; details.hasUnsavedChanges){
+			//calcRecommendationScore();
+			details.saveCacheDetails(Global.getProfile().dataDir);
+			this.update(details);
+		}
+		details = null;
+		cachesWithLoadedDetails.remove(this);
+	}
+
+	//final static int maxDetails = 50; 
+	static Vector cachesWithLoadedDetails = new Vector(Global.getPref().maxDetails);
+
+	public static void removeOldestDetails() {
+		for (int i=0; i&lt;Global.getPref().deleteDetails; i++)
+			((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
+	}
+
+	public static void removeAllDetails() {
+		for (int i=cachesWithLoadedDetails.size()-1; i&gt;=0; i--)
+			((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
+	}
+
+	/**
+	 * when importing caches you can set details.saveChanges = true
+	 * when the import ist finished call this method to save the pending changes
+	 *
+	 */
+	public static void saveAllModifiedDetails() {
+		CacheHolder ch;
+		CacheHolderDetail chD;
+		for (int i=cachesWithLoadedDetails.size()-1; i&gt;=0; i--) {
+			ch = (CacheHolder)(cachesWithLoadedDetails.get(i));
+			chD = ch.getCacheDetails(false);
+			if (chD.hasUnsavedChanges) {
+				//ch.calcRecommendationScore();
+				chD.saveCacheDetails(Global.getProfile().dataDir);
+				ch.update(chD);
+			}
+		}
+	}
+
+	/*
 public void finalize() {nObjects--;
    Vm.debug(&quot;Destroying CacheHolder &quot;+wayPoint);
    Vm.debug(&quot;CacheHolder: &quot;+nObjects+&quot; objects left&quot;);
 }
-*/
+	 */
 }
\ No newline at end of file

Modified: trunk/src/CacheWolf/Log.java
===================================================================
--- trunk/src/CacheWolf/Log.java	2007-11-25 22:33:25 UTC (rev 1106)
+++ trunk/src/CacheWolf/Log.java	2007-11-26 17:03:23 UTC (rev 1107)
@@ -1,6 +1,6 @@
 package CacheWolf;
 
-public class Log {//static int nObj=0;
+public class Log {
 	private static String MAXLOGICON=&quot;MAXLOG&quot;;
 	private static String INVALIDLOGICON=null;
 	/** The icon which describes the log e.g. icon_sad */
@@ -19,7 +19,7 @@
 	 * or &lt;img src='ICON'&gt;&nbsp;DATE by LOGGER&lt;br&gt;MESSAGE&lt;/pre&gt;
 	 * @param logLine
 	 */
-	Log(String logLine) {//nObj++;ewe.sys.Vm.debug(&quot;Log: &quot;+nObj+&quot; objects&quot;);
+	Log(String logLine) {
 //		RECOMMENDED=&quot;1&quot;&lt;img src='icon_smile.gif'&gt;&nbsp;2007-01-14 xyz&lt;br&gt;a wonderful log
 		try {
 			int ic1=logLine.indexOf(&quot;RECOMMENDED=\&quot;1\&quot;&quot;);
@@ -47,7 +47,7 @@
 		}
 	}
 	
-	Log(String icon, String date, String logger, String message) {//nObj++;ewe.sys.Vm.debug(&quot;Log: &quot;+nObj+&quot; objects&quot;);
+	Log(String icon, String date, String logger, String message) {
 		this(icon, date, logger, message, false);
 	}
 	
@@ -59,7 +59,7 @@
 		this.recommended = recommended_;
 	}
 	
-	public static Log maxLog() {//nObj++;ewe.sys.Vm.debug(&quot;Log: &quot;+nObj+&quot; objects&quot;);
+	public static Log maxLog() {
 		return new Log(MAXLOGICON,&quot;1900-00-00&quot;,&quot;&quot;,&quot;&quot;);
 	}
 	
@@ -87,13 +87,17 @@
 	public void setMessage(String message) {
 		this.message = message.trim();
 	}
-	public void setRecommendation (boolean recommended_) {
+	public void setRecommandation (boolean recommended_) {
 		recommended = recommended_;
 	}
-	public boolean getRecommendation () {
+	public boolean isRecomended() {
 		return recommended;
 	}
-
+	
+	public boolean isFoundLog() {
+		return icon.equals(GPXImporter.typeText2Image(&quot;Found&quot;));
+	}
+	
 	/** Return XML representation of log for storing in cache.xml */
 	public String toXML(){
 		StringBuffer s=new StringBuffer(400);
@@ -122,8 +126,4 @@
 		s.append(message.trim());
 		return s.toString();
 	}
-/*	public void finalize() {nObj--;
-	   ewe.sys.Vm.debug(&quot;Log: &quot;+nObj+&quot; objects left&quot;);
-	}
-*/	
 }

Modified: trunk/src/CacheWolf/LogList.java
===================================================================
--- trunk/src/CacheWolf/LogList.java	2007-11-25 22:33:25 UTC (rev 1106)
+++ trunk/src/CacheWolf/LogList.java	2007-11-26 17:03:23 UTC (rev 1107)
@@ -101,15 +101,34 @@
 		}
 		return countNoFoundLogs;
 	 }
-	
+
+	 /** only valid after calling calcRecommendations() */
+	 int numRecommended = 0;
+	 /** only valid after calling calcRecommendations() */
+	 int foundsSinceRecommendation = 0;
+	 /** only valid after calling calcRecommendations() */
+	 int recommendationRating = 0;
+	 
 	 /**
-	  * Count the number of OC Recommendations
-	  * @return Number of OC recommendations
+	  * call this to 
+	  *
 	  */
-	 public int countRecommendations() {
-		 int nRec=0;
-		 for (int i=size()-1; i&gt;=0; i--)
-			 if (getLog(i).getRecommendation()) nRec++;
-		 return nRec;
+	 public void calcRecommendations() {
+		 numRecommended = 0;
+		 foundsSinceRecommendation = 0;
+		 Log l;
+		 int s = size();
+		 int i;
+		 for (i= 0 ; i &lt; s; i++){
+			 l = getLog(i);
+			 if (l.getDate().compareTo(&quot;2007-01-14&quot;) &lt; 0) break; // this is the date when the recommendation system was introdueced in opencaching.de see: <A HREF="http://www.geoclub.de/viewtopic.php?t=14901&amp;highlight=formel">http://www.geoclub.de/viewtopic.php?t=14901&amp;highlight=formel</A>
+			 if (l.isRecomended()) numRecommended++;
+			 if (l.isFoundLog()) foundsSinceRecommendation++; 
+		 }
+		 recommendationRating = getScore(numRecommended, foundsSinceRecommendation);
 	 }
+	 
+	 public static int getScore(int numrecommends, int numfoudlogs) {
+		 return Math.round(((numrecommends * numrecommends +1 ) / (numfoudlogs / 10 +1))*100);
+	 }
 }

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-11-25 22:33:25 UTC (rev 1106)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-11-26 17:03:23 UTC (rev 1107)
@@ -77,20 +77,21 @@
 		}//for
 
 	}
+
+	/** true, if not the last syncdate shall be used, but the caches shall be reloaded
+	 * only used in syncSingle */
+	boolean reload;
 	/**
 	 * 
 	 * @param number
 	 * @param infB
 	 * @return true, if some change was made to the cacheDB
 	 */
-	/** true, if not the last syncdate shall be used, but the caches shall be reloaded
-	 * only used in syncSingle */
-	boolean reload;
 	public boolean syncSingle(int number, InfoBox infB) {
 		boolean success=true;
 
 		ch = (CacheHolder)cacheDB.get(number);
-		chD= new CacheHolderDetail(ch); //TODO is this still correct? use getDetails ?
+		chD= null; //new CacheHolderDetail(ch); //TODO is this still correct? use getDetails ?
 
 		if (infB.isClosed) {
 			if (askForOptions) return false; 
@@ -200,8 +201,6 @@
 			finalMessage = MyLocale.getMsg(1607,&quot;Update from opencaching successful&quot;);
 			inf.setInfo(finalMessage);
 		}
-		CacheHolder.saveAllModifiedDetails();
-		profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
 		inf.addOkButton();
 	}
 	
@@ -265,6 +264,14 @@
 		} finally {
 			if (tmpFile != null) tmpFile.delete();
 		}
+		/*
+		for (int i=cacheDB.size()-1; i &gt;=0; i--) {
+			ch = (CacheHolder)cacheDB.get(i);
+			if (ch.wayPoint.toUpperCase().startsWith(&quot;OC&quot;)) { //TODO only handle changed caches
+				ch.calcRecommendationScore();
+			}
+		} */
+		profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
 		inf.setInfo(finalMessage);
 
 		return success;

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-11-25 22:33:25 UTC (rev 1106)
+++ trunk/src/CacheWolf/Profile.java	2007-11-26 17:03:23 UTC (rev 1107)
@@ -112,6 +112,7 @@
 			pbf.setTask(h,&quot;Saving Index&quot;);
 			pbf.exec();
 		}
+		CacheHolder.saveAllModifiedDetails(); // this must be called first as it makes some calculations
 		PrintWriter detfile;
 		CacheHolder ch;
 		try {
@@ -170,7 +171,6 @@
 			detfile.print(&quot;&lt;/CACHELIST&gt;\n&quot;);
 			detfile.close();
 			buildReferences(); //TODO Why is this needed here?
-			CacheHolder.saveAllModifiedDetails();
 			if(showprogress) pbf.exit(0);
 		}catch(Exception e){
 			Vm.debug(&quot;Problem writing to index file &quot;+e.toString());

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-11-25 22:33:25 UTC (rev 1106)
+++ trunk/src/CacheWolf/myTableModel.java	2007-11-26 17:03:23 UTC (rev 1107)
@@ -301,11 +301,11 @@
 						}
 					case 13: // OC number of recommendations
 						if (ch.wayPoint.startsWith(&quot;OC&quot;))
-							return (new Integer(ch.numRecommended)).toString();
+							return Convert.formatInt(ch.numRecommended);
 						return null;
 					case 14: // OC rating	
 						if (ch.wayPoint.startsWith(&quot;OC&quot;))
-							return (new Integer(ch.recommendationScore)).toString();
+							return Convert.formatInt(ch.recommendationScore);
 						return null;
 				} // Switch
 			} // if


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000999.html">[Cachewolf-svn] r1106 - trunk/src/CacheWolf
</A></li>
	<LI>Next message: <A HREF="001001.html">[Cachewolf-svn] r1108 - trunk/src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1000">[ date ]</a>
              <a href="thread.html#1000">[ thread ]</a>
              <a href="subject.html#1000">[ subject ]</a>
              <a href="author.html#1000">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
