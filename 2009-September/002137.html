<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r2213 - trunk/src/CacheWolf/navi
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r2213%20-%20trunk/src/CacheWolf/navi&In-Reply-To=%3C200909271312.n8RDCuYK010044%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002136.html">
   <LINK REL="Next"  HREF="002138.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r2213 - trunk/src/CacheWolf/navi</H1>
    <B>araber95 at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r2213%20-%20trunk/src/CacheWolf/navi&In-Reply-To=%3C200909271312.n8RDCuYK010044%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r2213 - trunk/src/CacheWolf/navi">araber95 at mail.berlios.de
       </A><BR>
    <I>Sun Sep 27 15:12:56 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002136.html">[Cachewolf-svn] r2212 - trunk/src/CacheWolf/navi
</A></li>
        <LI>Next message: <A HREF="002138.html">[Cachewolf-svn] r2214 - trunk/src/CacheWolf/navi
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2137">[ date ]</a>
              <a href="thread.html#2137">[ thread ]</a>
              <a href="subject.html#2137">[ subject ]</a>
              <a href="author.html#2137">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: araber95
Date: 2009-09-27 15:12:55 +0200 (Sun, 27 Sep 2009)
New Revision: 2213

Modified:
   trunk/src/CacheWolf/navi/MovingMap.java
Log:
loading &quot;list of maps&quot; now reflects changed path of maps (example on changing profile).
(sorry for the removed trailing spaces)

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2009-09-27 13:03:28 UTC (rev 2212)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2009-09-27 13:12:55 UTC (rev 2213)
@@ -27,7 +27,7 @@
 	public final static int gotFix = 4; //green
 	public final static int lostFix = 3; //yellow
 	public final static int noGPSData = 2; // red
-	public final static int noGPS = 1; // no GPS-Position marker, manually disconnected 
+	public final static int noGPS = 1; // no GPS-Position marker, manually disconnected
 	public final static int ignoreGPS = -1; // ignore even changes in GPS-signal (eg. from lost fix to gotFix) this is wanted when the map is moved manually
 
 	public MapSymbol gotoPos = null;
@@ -44,14 +44,14 @@
 	//String mapPath;
 	Navigate myNavigation;
 	boolean running = false;
-	
+
 	MapImage mapImage1to1;
 	ArrowsOnMap directionArrows = new ArrowsOnMap();
 	AniImage statusImageHaveSignal;
 	AniImage statusImageNoSignal;
 	AniImage statusImageNoGps;
 	AniImage bottonImageClose;
-	AniImage bottonImageChooseMap; 
+	AniImage bottonImageChooseMap;
 	AniImage buttonImageGpsOn;
 	AniImage buttonImageLens;
 	AniImage buttonImageLensActivated;
@@ -79,7 +79,7 @@
 	boolean additionalOverlaysDeleted=true;
 	Point lastRepaintMapPos = null;
 	double lastDistance = -1;
-	
+
 	float lastHighestResolutionGPSDestScale = -1;
 
 	public static final int tileWidth = 100;
@@ -110,22 +110,22 @@
 		this.hasTopBar = false;
 		this.noBorder = true;
 		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
-		this.title = &quot;Moving Map&quot;; 
+		this.title = &quot;Moving Map&quot;;
 		this.backGround = new Color(254,254,254); // background must not be black because black is interpreted as transparent and transparent images above (eg trackoverlay) want be drawn in windows-VM, so be care, don|t use white either
 		//this.mapPath = Global.getPref().getMapLoadPath();
 
 		mmp = new MovingMapPanel(this);
 		this.addLast(mmp);
-		
+
 		boolean mobileVGA = false;
-		if (Vm.isMobile() &amp;&amp; MyLocale.getScreenWidth() &gt;= 400) mobileVGA = true;  
+		if (Vm.isMobile() &amp;&amp; MyLocale.getScreenWidth() &gt;= 400) mobileVGA = true;
 		String imagesize=&quot;&quot;;
 		if(mobileVGA) imagesize=&quot;_vga&quot;;
-		
+
 		statusImageHaveSignal = new AniImage(&quot;position_green&quot;+imagesize+&quot;.png&quot;);
 		statusImageNoSignal = new AniImage(&quot;position_yellow&quot;+imagesize+&quot;.png&quot;);
 		statusImageNoGps = new AniImage(&quot;position_red&quot;+imagesize+&quot;.png&quot;);
-		bottonImageChooseMap = new AniImage(&quot;choose_map&quot;+imagesize+&quot;.gif&quot;); 
+		bottonImageChooseMap = new AniImage(&quot;choose_map&quot;+imagesize+&quot;.gif&quot;);
 		buttonImageGpsOn = new AniImage(&quot;snap2gps&quot;+imagesize+&quot;.gif&quot;);
 		buttonImageLens = new AniImage(&quot;lupe&quot;+imagesize+&quot;.png&quot;);
 		buttonImageLensActivated = new AniImage(&quot;lupe_activated&quot;+imagesize+&quot;.png&quot;);
@@ -134,7 +134,7 @@
 		buttonImageZoom1to1 = new AniImage(&quot;zoom1to1&quot;+imagesize+&quot;.png&quot;);
 		posCircle = new MapSymbol(&quot;position_green&quot;+imagesize+&quot;.png&quot;, &quot;gps-position&quot;, new CWPoint());
 		MARK_CACHE_IMAGE = &quot;mark_cache.png&quot;;
-		
+
 		DrawnIcon closeX;
 		if(mobileVGA)
 			closeX = new DrawnIcon(DrawnIcon.CROSS,30,30,new Color(0,0,0));
@@ -187,7 +187,7 @@
 		scaleWanted = 1;
 		mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
 		lastHighestResolutionGPSDestScale = -1;
-		
+
 		lastRepaintMapPos = new Point(pref.myAppWidth +1, pref.myAppHeight +1);
 	}
 
@@ -209,7 +209,7 @@
 		buttonImageLensActivatedZoomOut.setLocation(w - buttonImageLensActivatedZoomOut.getWidth()-10, h/2 - buttonImageLensActivatedZoomOut.getHeight()/2 );
 		DistanceImage.setLocation(0, h - DistanceImage.getHeight());
 		ScaleImage.setLocation(w - ScaleImage.getWidth(), h - ScaleImage.getHeight());
-		if (mmp.mapImage != null) mmp.mapImage.screenDimChanged(); 
+		if (mmp.mapImage != null) mmp.mapImage.screenDimChanged();
 		if (posCircle != null) posCircle.screenDimChanged();
 		if (tracks != null) rebuildOverlaySet();
 		if (symbols != null) { // TODO: see if the rest of the code works with symbols = null
@@ -255,14 +255,14 @@
 	public void updateScale() {
 		ScaleImageGraphics.setColor(ScaleImage.transparentColor);
 		ScaleImageGraphics.fillRect(0, 0, ScaleImage.location.width,ScaleImage.location.height);
-		
+
 		if (currentMap != null)
 		{
 			double lineLengthMeters = 40 * currentMap.scale;
-			
+
 			int metricSystem = Global.getPref().metricSystem;
 			double localizedLineLength = 0;
-			int bigUnit = -1; 
+			int bigUnit = -1;
 			int smallUnit = -1;
 			double threshold = -1;
 			// Allow for different metric systems
@@ -270,18 +270,18 @@
 				bigUnit = Metrics.MILES;
 				smallUnit = Metrics.FEET;
 				threshold = 501;
-				
+
 				localizedLineLength = Metrics.convertUnit( lineLengthMeters, Metrics.METER, smallUnit);
 			} else {
 				bigUnit = Metrics.KILOMETER;
 				smallUnit = Metrics.METER;
 				threshold = 1000;
-				
+
 				localizedLineLength = lineLengthMeters;
 			}
-			
+
 			int currentUnit = smallUnit;
-						
+
 			float digits = (float)java.lang.Math.floor( java.lang.Math.log(localizedLineLength) / java.lang.Math.log(10.0) );
 			localizedLineLength = (float)java.lang.Math.ceil( localizedLineLength / (float)java.lang.Math.pow(10, digits) ) * (float)java.lang.Math.pow(10, digits);
 
@@ -289,28 +289,28 @@
 			{
 				currentUnit = bigUnit;
 				localizedLineLength = Metrics.convertUnit( lineLengthMeters, Metrics.METER, currentUnit);
-				
+
 				digits = (float)java.lang.Math.floor( java.lang.Math.log(localizedLineLength) / java.lang.Math.log(10.0) );
 				localizedLineLength = (float)java.lang.Math.ceil( localizedLineLength / (float)java.lang.Math.pow(10, digits) ) * (float)java.lang.Math.pow(10, digits);
 			}
-			
+
 			String lineLengthString = Convert.toString((int) localizedLineLength) + Metrics.getUnit(currentUnit);
-			
+
 			if	(digits &lt; 0){
 				Double tmp = new Double();
 				tmp.set(localizedLineLength);
-				
+
 				int decimals = (int)(-1 * digits);
-				
+
 				lineLengthString = tmp.toString(decimals+2,decimals,0) + Metrics.getUnit(currentUnit);
 //				lineLengthString = MyLocale.formatDouble(tmp,&quot;0.000&quot;) + Metrics.getUnit(currentUnit);
 			}
 
 			lineLengthMeters = Metrics.convertUnit( localizedLineLength, currentUnit, Metrics.METER);
-			
-			int lineLengthPixels = (int)java.lang.Math.round( lineLengthMeters / currentMap.scale );			
+
+			int lineLengthPixels = (int)java.lang.Math.round( lineLengthMeters / currentMap.scale );
 			int backgroundStartX = ScaleImage.location.width - (lineLengthPixels + fm.getTextWidth(lineLengthString) + 7);
-			
+
 			ScaleImageGraphics.setColor(new Color(250,250,250));
 			ScaleImageGraphics.fillRect(backgroundStartX, 0, ScaleImage.location.width - backgroundStartX ,ScaleImage.location.height);
 
@@ -319,11 +319,11 @@
 			ScaleImageGraphics.setColor(Color.DarkBlue);
 			ScaleImageGraphics.drawText(lineLengthString , backgroundStartX + lineLengthPixels + 5, 0);
 		}
-		
-		ScaleImageGraphics.drawImage(ScaleImage.image,null,Color.LightBlue,0,0,ScaleImage.location.width,ScaleImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+
+		ScaleImageGraphics.drawImage(ScaleImage.image,null,Color.LightBlue,0,0,ScaleImage.location.width,ScaleImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed
 		ScaleImageGraphics.drawImage(ScaleImage.image,null,Color.White,0,0,ScaleImage.location.width,ScaleImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
 	}
-	
+
 	public void updateDistance(boolean repaint) {
 		DistanceImageGraphics.setColor(DistanceImage.transparentColor);
 		DistanceImageGraphics.fillRect(0, 0, DistanceImage.location.width,DistanceImage.location.height);
@@ -335,10 +335,10 @@
 				lastDistance = currentDistance;
 				ewe.sys.Double dd = new ewe.sys.Double();
 				String d;
-				
+
 				int metricSystem = Global.getPref().metricSystem;
 				double localizedDistance = 0;
-				int bigUnit = -1; 
+				int bigUnit = -1;
 				int smallUnit = -1;
 				double threshold = -1;
 				// Allow for different metric systems
@@ -353,7 +353,7 @@
 					smallUnit = Metrics.METER;
 					threshold = 1.0;
 					localizedDistance = currentDistance;
-				} 
+				}
 				dd.set(localizedDistance);
 				if (dd.value &gt;= threshold){
 					d = MyLocale.formatDouble(dd,&quot;0.000&quot;) + Metrics.getUnit(bigUnit);
@@ -361,7 +361,7 @@
 					dd.set(Metrics.convertUnit(dd.value, bigUnit, smallUnit));
 					d = dd.toString(3,0,0) + Metrics.getUnit(smallUnit);
 				}
-				
+
 				int backgroundWidth = fm.getTextWidth(d) + 4;
 
 				DistanceImageGraphics.setColor(new Color(250,250,250));
@@ -369,8 +369,8 @@
 
 				DistanceImageGraphics.setColor(Color.DarkBlue);
 				DistanceImageGraphics.drawText(d, 2, 0);
-				
-				DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.LightBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+
+				DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.LightBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed
 				DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.White,0,0,DistanceImage.location.width,DistanceImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
 				if (repaint)
 				{
@@ -380,7 +380,7 @@
 		}
 		else
 		{
-			DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.LightBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+			DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.LightBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed
 			DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.White,0,0,DistanceImage.location.width,DistanceImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
 		}
 	}
@@ -407,7 +407,7 @@
 		}
 		setMarkedCache(mainT.ch);
 		addTrack(myNavigation.curTrack);
-		if (tracks != null &amp;&amp; tracks.size() &gt; 0 &amp;&amp; ((Track)tracks.get(0)).num &gt; 0) 
+		if (tracks != null &amp;&amp; tracks.size() &gt; 0 &amp;&amp; ((Track)tracks.get(0)).num &gt; 0)
 			rebuildOverlaySet(); // show points which where added when MavingMap was not running
 		if (myNavigation.destinationIsCache) {
 			destChanged(myNavigation.destinationCache);
@@ -415,11 +415,11 @@
 		else {
 			destChanged(myNavigation.destination);
 		}
-		
+
 		FormFrame ret = exec();
 		return ret;
 	}
-	
+
 	CacheHolder markedCache = null;
 	public void setMarkedCache(CacheHolder ch) {
 		if (ch == markedCache) return;
@@ -435,7 +435,7 @@
 			}
 		}
 	}
-	
+
 	public void addTrack(Track tr) {
 		if (tr == null) return;
 		if (tracks == null) tracks = new Vector();
@@ -454,7 +454,7 @@
 
 	/**
 	 * adds an 3x3 set of overlays to the map-window which contain the track
-	 * 
+	 *
 	 * add tracks with addtrack(track) before
 	 */
 
@@ -465,10 +465,10 @@
 			addMissingOverlays();
 		} catch (NullPointerException e) {
 			// hapens if currentmap == null or PosCircle not valid
-		} 
+		}
 		catch (IllegalArgumentException e) {
 			// happens if screensize is still not known    ---&gt; in both cases creation of Overlayset will be done in updateOverlayPos if tracks != null
-		}  
+		}
 	}
 
 	public void destroyOverlaySet() {
@@ -492,16 +492,16 @@
 		}
 		boolean saveGPSIgnoreStatus = dontUpdatePos; // avoid multi-threading problems
 		dontUpdatePos = true;
-		Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft); // TrackOverlay[4] == center of Trackoverlays 
+		Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft); // TrackOverlay[4] == center of Trackoverlays
 		//upperleftOf4.x = (upperleftOf4.x + 1* width) % (width * 2) - 1 * width;
 		//upperleftOf4.y = (upperleftOf4.y + 1* height) % (height * 2) - 1 * height;
 		int i;
 		for (int yi=0; yi&lt;3; yi++) {
 			for (int xi=0; xi&lt;3; xi++) {
 				i = yi*3+xi;
-				if (TrackOverlays[i]==null) { 
-					TrackOverlays[i]= new TrackOverlay(ScreenXY2LatLon(upperleftOf4.x+(xi-1)*width, upperleftOf4.y+(yi-1)*height), width, height, currentMap); 
-					TrackOverlays[i].setLocation(width+1, height+1); // outside of the screen will hide it automatically it will get the correct position in upadteOverlayposition 
+				if (TrackOverlays[i]==null) {
+					TrackOverlays[i]= new TrackOverlay(ScreenXY2LatLon(upperleftOf4.x+(xi-1)*width, upperleftOf4.y+(yi-1)*height), width, height, currentMap);
+					TrackOverlays[i].setLocation(width+1, height+1); // outside of the screen will hide it automatically it will get the correct position in upadteOverlayposition
 					TrackOverlays[i].tracks = this.tracks;
 					TrackOverlays[i].paintTracks();
 					mmp.addImage(TrackOverlays[i]);
@@ -514,7 +514,7 @@
 	}
 
 	private void destroyOverlay(int ov) {
-		if (TrackOverlays[ov] == null) return; 
+		if (TrackOverlays[ov] == null) return;
 		mmp.removeImage(TrackOverlays[ov]);
 		TrackOverlays[ov].free();
 		TrackOverlays[ov]=null;
@@ -695,7 +695,7 @@
 			for (int xi=0; xi&lt;3; xi++) {
 				num = yi*3+xi;
 				pX = posOnScreen.x+(xi-1)*ww;
-				pY = posOnScreen.y+(yi-1)*wh; 
+				pY = posOnScreen.y+(yi-1)*wh;
 				TrackOverlays[num].setLocation(pX, pY);
 			}
 		}
@@ -710,7 +710,7 @@
 					|| TrackOverlays[0].locAlways.y &gt; 0 || TrackOverlays[8].locAlways.y &lt; 0) { // testForNeedToRearange
 				rearangeOverlays();
 				addMissingOverlays();
-				// updateOverlayOnlyPos(); is called from addMissingOverlays 
+				// updateOverlayOnlyPos(); is called from addMissingOverlays
 			}
 		}
 	}
@@ -755,7 +755,7 @@
 	public void mapMoved(int diffX, int diffY) {
 		int w = posCircle.getWidth();
 		int h = posCircle.getHeight();
-		int npx = posCircleX-w/2+diffX; 
+		int npx = posCircleX-w/2+diffX;
 		int npy = posCircleY-h/2+diffY;
 		posCircle.move(npx, npy);
 		posCircleX = posCircleX+diffX;
@@ -777,10 +777,10 @@
 	 * @return
 	 */
 	public Point getMapPositionOnScreen() {
-		if (currentMap == null || !posCircle.where.isValid()) 
-			return new Point(pref.myAppWidth +1, pref.myAppHeight +1); 
+		if (currentMap == null || !posCircle.where.isValid())
+			return new Point(pref.myAppWidth +1, pref.myAppHeight +1);
 		// in case no calculation is possible return somthing outside of the screen
-		Point mapPos = new Point(); 
+		Point mapPos = new Point();
 		//if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
 		//else {
 		Point mapposint = currentMap.calcMapXY(posCircle.where);
@@ -791,7 +791,7 @@
 	}
 
 	/**
-	 * 
+	 *
 	 * @param lat
 	 * @param lon
 	 * @return
@@ -847,13 +847,13 @@
 		mmp.addImage(ms);
 		return ms;
 	}
-	
+
 	public void addSymbolIfNecessary(String pName, Object mapObject, Image imSymb, CWPoint where) {
 		if (findMapSymbol(pName) &gt;= 0) return;
 		else addSymbol(pName, mapObject, imSymb, where);
-		
+
 	}
-		
+
 	public void addSymbol(String pName, Object mapObject, Image imSymb, CWPoint ll) {
 		if (symbols==null) symbols=new Vector();
 		MapSymbol ms = new MapSymbol(pName, mapObject, imSymb, ll);
@@ -865,7 +865,7 @@
 	}
 
 	public void destChanged(CWPoint d) {
-		if(!running || (d == null &amp;&amp; gotoPos == null) || 
+		if(!running || (d == null &amp;&amp; gotoPos == null) ||
 				(d != null &amp;&amp; gotoPos != null &amp;&amp; gotoPos.where.equals(d))) return;
 		removeGotoPosition();
 		if (d == null || !d.isValid() ) return;
@@ -929,7 +929,7 @@
 		}
 		return -1;
 	}
-	
+
 	public int findMapSymbol(Object obj) {
 		if (symbols == null) return -1;
 		MapSymbol ms;
@@ -942,8 +942,8 @@
 
 	/**
 	 * Move the map so that the posCircle is at lat/lon
-	 * 
-	 * @param  
+	 *
+	 * @param
 	 */
 	public void updateOnlyPosition(CWPoint where, boolean updateOverlay){
 		//Point oldMapPos = getMapPositionOnScreen();
@@ -951,20 +951,20 @@
 		Point mapPos = getMapPositionOnScreen();
 		//Vm.debug(&quot;mapx = &quot; + mapx);
 		//Vm.debug(&quot;mapy = &quot; + mapy);
-		if (forceMapLoad || (java.lang.Math.abs(lastRepaintMapPos.x - mapPos.x) &gt; 1 || java.lang.Math.abs(lastRepaintMapPos.y - mapPos.y) &gt; 1)) 
+		if (forceMapLoad || (java.lang.Math.abs(lastRepaintMapPos.x - mapPos.x) &gt; 1 || java.lang.Math.abs(lastRepaintMapPos.y - mapPos.y) &gt; 1))
 		{
 			lastRepaintMapPos = mapPos;
 			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x, mapPos.y);
 			updateSymbolPositions();
 			updateDistance(false);
 			if (updateOverlay ) updateOverlayPos(); // &amp;&amp; TrackOverlays != null
-			mmp.repaintNow(); 
+			mmp.repaintNow();
 		}
 		else
 		{
 			updateDistance(true);
 		}
-		//Vm.debug(&quot;update only position&quot;);			
+		//Vm.debug(&quot;update only position&quot;);
 	}
 	/**
 	 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
@@ -972,7 +972,7 @@
 	public void updatePosition(CWPoint where){
 		if (dontUpdatePos || loadingMapList) return; // avoid multi-threading problems
 		//Vm.debug(&quot;updatepos, lat: &quot;+where.latDec+&quot; lon: &quot;+where.lonDec);
-		if (!mapsloaded) {
+		if (!mapsloaded || !this.maps.getMapsPath().equals(Global.getPref().getCustomMapsPath())) {
 			loadMaps(Global.getPref().getMapLoadPath(), where.latDec);
 			lastCompareX = Integer.MAX_VALUE;
 			lastCompareY = Integer.MAX_VALUE;
@@ -1060,7 +1060,7 @@
 					AniImage im = (AniImage) i.next();
 					if ((im instanceof MapImage)
 						&amp;&amp; (!((im instanceof MapSymbol)
-							|| (im instanceof TrackOverlay) 
+							|| (im instanceof TrackOverlay)
 							|| mmp.mapImage == im))) {
 						//locAlways contains the real coordinates while
 						//location is only correct if the image is on the screen.
@@ -1087,7 +1087,7 @@
 		int middleheight = r.y + (r.height)/2;
 		CWPoint centerPoint = ScreenXY2LatLon(middlewidth, middleheight);
 		Rect screen = new Rect ();
-		screen.height = r.height ;//- r.y; 
+		screen.height = r.height ;//- r.y;
 		screen.width = r.width ;//- r.x;
 		MapInfoObject bestMap = maps.getBestMap(centerPoint, screen, currentMap.scale, true);
 		if (bestMap == null){
@@ -1133,7 +1133,7 @@
 			}
 		}
 	}
-	
+
 	private void generateTiles(Rect blackArea, String filename, Point mapPos,
 			Dimension rect2, MapImage fullImage) {
 		//Generate tiles from the map
@@ -1145,7 +1145,7 @@
 				if (!isCoveredByBlackArea(mapPos, row, column, blackArea, rect2)) {
 					continue;
 				}
-				//Get tile from cache or if not found, put all tiles for this image into the cache. 
+				//Get tile from cache or if not found, put all tiles for this image into the cache.
 				MapImage im = MovingMapCache.getCache().get(filename, row, column);
 				if (im == null) {
 					if (fullImage == null){
@@ -1219,7 +1219,7 @@
 		UR= &quot; (&quot;+String.valueOf(r.x+r.width)+&quot;,&quot;+String.valueOf(r.y+r.height)+&quot;) &quot;;
 		return OL+&quot; :&quot;+UR;
 	}
-	
+
 	private void calculateRectangles(Rect blackArea, Rect whiteArea, Vector rectangles) {
 		if (width == 0 || height == 0) return;
 		int offsetX = width/10;
@@ -1227,7 +1227,7 @@
 		int width=this.width+offsetX;
 		int height=this.height+offsetY;
 		if (whiteArea.x &gt;= width || whiteArea.y &gt;= height) return;
-		
+
 		if (blackArea.x &lt; -offsetX){
 			blackArea.width += blackArea.x + offsetX;
 			blackArea.x = -offsetX;
@@ -1242,7 +1242,7 @@
 		if (blackArea.y + blackArea.height &gt; height){
 			blackArea.height = height - blackArea.y;
 		}
-		
+
 		if (blackArea.x &gt; whiteArea.x) {
 			Rect r= new Rect ();
 			r.x = -offsetX;
@@ -1283,7 +1283,7 @@
 
 	public void updateGps(int fix) {
 		if (!running || ignoreGps) return;
-		// runMovingMap neccessary in case of multi-threaded Java-VM: ticked could be called during load of mmp 
+		// runMovingMap neccessary in case of multi-threaded Java-VM: ticked could be called during load of mmp
 		if ((fix &gt; 0) &amp;&amp; (myNavigation.gpsPos.getSats()&gt;= 0)) { // TODO is getSats really necessary?
 			directionArrows.setDirections((float)myNavigation.gpsPos.getBearing(myNavigation.destination),
 					(float)myNavigation.skyOrientationDir.lonDec, (float)myNavigation.gpsPos.getBear());
@@ -1294,7 +1294,7 @@
 		if (fix == 0 &amp;&amp; myNavigation.gpsPos.getSats()== 0) 	setGpsStatus(MovingMap.lostFix);
 		if (fix &lt; 0 )	setGpsStatus(MovingMap.noGPSData);
 	}
-	
+
 	public void gpsStarted() {
 		addTrack(myNavigation.curTrack);
 		ignoreGps = false;
@@ -1319,10 +1319,10 @@
 	 * but anyway the map will be adjusted (moved) relativ to posCircle
 	 * when a better map was found the called method updateposition will set
 	 * posCirleLat/-Lon to lat/lon.
-	 * 
+	 *
 	 * @param lat
 	 * @param lon
-	 * @param loadIfSameScale 
+	 * @param loadIfSameScale
 	 * 			false: will not change the map if the better map has the same scale as the current
 	 * 			  - this is used not to change the map if it covers already the screen completely
 	 * 			true: willchange the map, regardless of change in scale
@@ -1331,14 +1331,14 @@
 		if (inBestMap) return;
 		inBestMap = true;
 		Object [] s = getRectForMapChange(where);
-		CWPoint cll = (CWPoint) s[0]; 
-		Rect screen = (Rect) s[1]; 
+		CWPoint cll = (CWPoint) s[0];
+		Rect screen = (Rect) s[1];
 		boolean posCircleOnScreen = ((Boolean) s[2]).booleanValue();
 		MapInfoObject newmap = null;
 		//if (mapChangeModus == 0) mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
 		wantMapTest = true;
 		switch (mapChangeModus) {
-		case NORMAL_KEEP_RESOLUTION: 
+		case NORMAL_KEEP_RESOLUTION:
 			lastHighestResolutionGPSDestScale = -1;
 			newmap = maps.getBestMap(cll, screen, scaleWanted, false);
 			if (newmap == null) newmap = currentMap;
@@ -1348,27 +1348,27 @@
 			lastHighestResolutionGPSDestScale = -1;
 			newmap = maps.getBestMap(cll, screen, 0.000001f, false);
 			break;
-		case HIGHEST_RESOLUTION_GPS_DEST: 
+		case HIGHEST_RESOLUTION_GPS_DEST:
 			if (gotoPos!= null &amp;&amp; GpsStatus != noGPS &amp;&amp; posCircle.where.isValid()) {
 				if ( ( !posCircleOnScreen ) &amp;&amp; ( lastHighestResolutionGPSDestScale &gt; 0 ) ) {
 					newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale , false);
 				} else {
 					newmap = maps.getMapForArea(posCircle.where, gotoPos.where); // TODO use home-coos if no gps? - consider start from details panel and from gotopanel
 					if (newmap == null)	newmap = maps.getBestMap(cll, screen, 10000000000000000000000000000000000f, false); // use map with most available overview if no map containing PosCircle and GotoPos is available
-					
+
 					if (newmap != null) {
-						lastHighestResolutionGPSDestScale = newmap.scale;	
-						
+						lastHighestResolutionGPSDestScale = newmap.scale;
+
 						if (!posCircleOnScreen) {
 							newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale , false);
-						}						
+						}
 					}
 				}
 			}
 			//	either Goto-Pos or GPS-Pos not set
 			else {
 				lastHighestResolutionGPSDestScale = -1;
-				newmap = maps.getBestMap(cll, screen, 0.000001f, false); 
+				newmap = maps.getBestMap(cll, screen, 0.000001f, false);
 			}
 			break;
 		default: (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4208, &quot;Bug: \nillegal mapChangeModus: &quot;) + mapChangeModus, FormBase.OKB)).execute(); break;
@@ -1389,7 +1389,7 @@
 				setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), where); // beware: &quot;-4&quot; only works if the empty maps were added last see MapsList.addEmptyMaps
 			} catch (IOException e) { (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4209, &quot;setBestMap: problem in: setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), lat, lon) lat/lon:&quot;) + where.toString(), FormBase.OKB)).exec(); }
 			while (currentMap == null) { // this actually cannot happen, but maybe in case of an inconstistent code change (esp. regarding empty maps)
-				mmp.chooseMap(); // force the user to select a scale 
+				mmp.chooseMap(); // force the user to select a scale
 				 if (currentMap == null) (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4210, &quot;Moving map cannot run without a map - please select one. \n You can select an empty map&quot;), FormBase.OKB)).execute();
 			}
 		}
@@ -1405,10 +1405,10 @@
 	}
 	/**
 	 * method to get a point on the screen which must be included in the map
-	 * the map methods are looking for. If the poscircle is on the screen this will be 
+	 * the map methods are looking for. If the poscircle is on the screen this will be
 	 * that point. If it is outside then the centre of the screen will be used.
-	 * 
-	 * returns [0] = CWPoint of that point, [1] Rect describing the screen around it 
+	 *
+	 * returns [0] = CWPoint of that point, [1] Rect describing the screen around it
 	 * @param lat
 	 * @param lon
 	 * @return
@@ -1428,16 +1428,16 @@
 			cll = ScreenXY2LatLon(w/2, h/2);
 			pX = w/2;
 			pY = h/2;
-		} 
+		}
 		Object[] ret = new Object[3];
 		ret[0] = cll;
 		ret[1] = new Rect(pX, pY, w, h);
 		ret[2] = posCircleOnScreen;
-		return ret; 
+		return ret;
 	}
 
 	/**
-	 * 
+	 *
 	 * @param betterOverview true: getmap with better overview
 	 * @return
 	 */
@@ -1452,7 +1452,7 @@
 		} else {
 			cll = new CWPoint(posCircle.where);
 		}
-		
+
 		MapInfoObject m = maps.getMapChangeResolution(cll, screen, currentMap.scale * currentMap.zoomFactor, !betterOverview);
 		if (m != null) {
 			boolean saveGpsIgnStatus = dontUpdatePos;
@@ -1461,9 +1461,9 @@
 			setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
 			dontUpdatePos = saveGpsIgnStatus;
 		}
-		else (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4211, &quot;No &quot;) + 
-				(betterOverview ? MyLocale.getMsg(4212, &quot;less&quot;) : MyLocale.getMsg(4213, &quot;more&quot;) ) + 
-				MyLocale.getMsg(4214, &quot; detailed map available&quot;), 
+		else (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4211, &quot;No &quot;) +
+				(betterOverview ? MyLocale.getMsg(4212, &quot;less&quot;) : MyLocale.getMsg(4213, &quot;more&quot;) ) +
+				MyLocale.getMsg(4214, &quot; detailed map available&quot;),
 				FormBase.OKB)).execute();
 	}
 
@@ -1476,15 +1476,15 @@
 		MapInfoObject newmap = maps.getMapForArea(sur.topleft, sur.buttomright);
 		if (newmap == null ) { // no map that includs all caches is available -&gt; load map with lowest resolution
 			Object [] s = getRectForMapChange(posCircle.where);
-			CWPoint cll = (CWPoint) s[0]; 
-			Rect screen = (Rect) s[1]; 
+			CWPoint cll = (CWPoint) s[0];
+			Rect screen = (Rect) s[1];
 			newmap = maps.getBestMap(cll, screen, Float.MAX_VALUE -1, false);
 		}
 		if (newmap == null) { // no map is covering any area of the caches -&gt; zoom an empty map to cover all caches on screen
 			try {
 				Object [] s = getRectForMapChange(posCircle.where);
-			//	CWPoint cll = (CWPoint) s[0]; 
-				Rect screen = (Rect) s[1]; 
+			//	CWPoint cll = (CWPoint) s[0];
+				Rect screen = (Rect) s[1];
 				float neededscalex = (float) (sur.topleft.getDistance(sur.topleft.latDec, sur.buttomright.lonDec) * 1000 / (screen.width-15)); // 15 for the size of the cache image
 				float neededscaley = (float) (sur.topleft.getDistance(sur.buttomright.latDec, sur.topleft.lonDec) * 1000 / (screen.height-15)); // 15 for the size of the cache image
 				newmap = ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(); // beware: &quot;-4&quot; only works if the empty maps were added last see MapsList.addEmptyMaps
@@ -1510,7 +1510,7 @@
 		case lostFix:   { posCircle.change(statusImageNoSignal); break; }
 		case noGPSData: { posCircle.change(statusImageNoGps); break; }
 		}
-		mapMoved(0, 0); // positions the posCircle correctly accourding to its size (which can change when the image changes, e.g. from null to something else 
+		mapMoved(0, 0); // positions the posCircle correctly accourding to its size (which can change when the image changes, e.g. from null to something else
 		posCircle.refreshNow();
 	}
 
@@ -1528,14 +1528,14 @@
 	}
 
 	/** sets and displays the map
-	 * 
+	 *
 	 * @param newmap
 	 * @param lat move map so that lat/lon is in the centre / -361: don't adust to lat/lon
 	 * @param lon -361: don't adust to lat/lon
 	 */
 	public void setMap(MapInfoObject newmap, CWPoint where) {
-		if (currentMap != null &amp;&amp; newmap.mapName.equals(currentMap.mapName) &amp;&amp; !forceMapLoad) { // note: newmap.mapName == currentMap.mapName won't work because they are different String containing the same text 
-			updateOnlyPosition(where, true); 
+		if (currentMap != null &amp;&amp; newmap.mapName.equals(currentMap.mapName) &amp;&amp; !forceMapLoad) { // note: newmap.mapName == currentMap.mapName won't work because they are different String containing the same text
+			updateOnlyPosition(where, true);
 			return;
 		}
 		Vm.showWait(true);
@@ -1550,7 +1550,7 @@
 			Global.getPref().log(MyLocale.getMsg(4216, &quot;Loading map...&quot;));
 		}
 		try {
-			this.currentMap = newmap; 
+			this.currentMap = newmap;
 			this.title = currentMap.mapName;
 			lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
 			lastCompareY = Integer.MAX_VALUE;
@@ -1561,13 +1561,13 @@
 				//Vm.debug(&quot;free: &quot;+Vm.getUsedMemory(false)+&quot;classMemory: &quot;+Vm.getClassMemory()+ &quot;after garbage collection: &quot;+Vm.getUsedMemory(false));
 				Vm.getUsedMemory(true); // calls the garbage collection
 			} // give memory free before loading the new map to avoid out of memory error
-			String ImageFilename = currentMap.getImageFilename(); 
+			String ImageFilename = currentMap.getImageFilename();
 			if (ImageFilename == null ) {
 				mmp.mapImage = new MapImage();
 				maps.remove(currentMap);
 				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4217, &quot;Could not find image associated with: \n&quot;)+currentMap.fileNameWFL, FormBase.OKB)).execute();
 			}
-			else { 
+			else {
 				if (ImageFilename.length() &gt; 0) mmp.mapImage = new MapImage(ImageFilename); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
 				else mmp.mapImage = new MapImage(); // no image associated with the calibration info (&quot;empty map&quot;)
 			}
@@ -1588,7 +1588,7 @@
 			dontUpdatePos = saveIgnoreStatus;
 		} catch (IllegalArgumentException e) { // thrown by new AniImage() in ewe-vm if file not found;
 			if (mmp.mapImage != null) {
-				mmp.removeImage(mmp.mapImage); 
+				mmp.removeImage(mmp.mapImage);
 				mmp.mapImage.free();
 				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
 			}
@@ -1600,7 +1600,7 @@
 			dontUpdatePos = saveIgnoreStatus;
 		} catch (OutOfMemoryError e) {
 			if (mmp.mapImage != null) {
-				mmp.removeImage(mmp.mapImage); 
+				mmp.removeImage(mmp.mapImage);
 				mmp.mapImage.free();
 				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
 			}
@@ -1608,29 +1608,29 @@
 			updateOnlyPosition(where, false);
 			inf.close(0);
 			Vm.showWait(false);
-			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4219, &quot;Not enough memory to load map: \n&quot;) 
+			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4219, &quot;Not enough memory to load map: \n&quot;)
 					+ newmap.getImageFilename()
-					+ MyLocale.getMsg(4220, &quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;), 
+					+ MyLocale.getMsg(4220, &quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;),
 					FormBase.OKB)).execute();
 			dontUpdatePos = saveIgnoreStatus;
 		}catch (SystemResourceException e) {
 			if (mmp.mapImage != null) {
-				mmp.removeImage(mmp.mapImage); 
+				mmp.removeImage(mmp.mapImage);
 				mmp.mapImage.free();
 				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
 			}
 			rebuildOverlaySet();
-			updateOnlyPosition(where, false); // TODO this doesn't work correctly if the resolution changed, I guess because the pixels of PosCircle will be interpreted from the new resolution, but should be interpreted using the old resolution to test: select a map with a much greater value of m per pixel manually 
+			updateOnlyPosition(where, false); // TODO this doesn't work correctly if the resolution changed, I guess because the pixels of PosCircle will be interpreted from the new resolution, but should be interpreted using the old resolution to test: select a map with a much greater value of m per pixel manually
 			inf.close(0);
 			Vm.showWait(false);
 			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4221, &quot;Not enough ressources to load map: &quot;)
 					+ newmap.getImageFilename()
-					+ MyLocale.getMsg(4220, &quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;), 
+					+ MyLocale.getMsg(4220, &quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;),
 					FormBase.OKB)).execute();
 			dontUpdatePos = saveIgnoreStatus;
 		}
 	}
-	
+
 	private void updateAfterMapChange(CWPoint newCenter) {
 		if (!posCircle.where.isValid()) {
 			posCircle.where.set(newCenter);
@@ -1643,17 +1643,17 @@
 		int mapPosY = h/2 - centerOnMap.y;
 		int newPosCircleX = mapPosX + circlePosOnMap.x;
 		int newPosCircleY = mapPosY + circlePosOnMap.y;
-		
+
 		if (mmp != null &amp;&amp; mmp.mapImage != null) mmp.mapImage.move(mapPosX, mapPosY);
-		
+
 		int wCircle = posCircle.getWidth();
 		int hCircle = posCircle.getHeight();
-		int npx = newPosCircleX-wCircle/2; 
+		int npx = newPosCircleX-wCircle/2;
 		int npy = newPosCircleY-hCircle/2;
 		posCircle.move(npx, npy);
 		posCircleX = newPosCircleX;
 		posCircleY = newPosCircleY;
-		
+
 		updateOnlyPosition(posCircle.where, true);
 	}
 
@@ -1684,8 +1684,8 @@
 	 * @param h
 	 */
 	public void zoomScreenRect(Point firstclickpoint, int w, int h) {
-		int newImageWidth = (int) (this.width *  (this.width  &lt; 481 ? 2 : 1.6)); // (maximal) size of the zoomed image 
-		int newImageHeight= (int) (this.height * (this.width &lt; 481 ?  2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors 
+		int newImageWidth = (int) (this.width *  (this.width  &lt; 481 ? 2 : 1.6)); // (maximal) size of the zoomed image
+		int newImageHeight= (int) (this.height * (this.width &lt; 481 ?  2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors
 		CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y + h/2);
 		float zoomFactor;
 		if (h &lt; 0) {
@@ -1710,22 +1710,22 @@
 		if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.image != null)
 		{
 			// try to avoid overlapping by shifting
-			if (newImageRect.x &lt; 0) 
+			if (newImageRect.x &lt; 0)
 				newImageRect.x = 0; // align left if left overlapping
-			if (newImageRect.y &lt; 0) 
+			if (newImageRect.y &lt; 0)
 				newImageRect.y = 0;
-			if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth()) 
+			if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth())
 				newImageRect.x = mapImage1to1.getWidth()- newImageWidth; // align right if right overlaping
-			if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight()) 
+			if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight())
 				newImageRect.y = mapImage1to1.getHeight()- newImageHeight;
 			// crop if after shifting still overlapping
-			if (newImageRect.x &lt; 0) 
+			if (newImageRect.x &lt; 0)
 				newImageRect.x = 0;
-			if (newImageRect.y &lt; 0) 
+			if (newImageRect.y &lt; 0)
 				newImageRect.y = 0;
-			if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth()) 
+			if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth())
 				newImageRect.width = mapImage1to1.getWidth() - newImageRect.x;
-			if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight()) 
+			if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight())
 				newImageRect.height= mapImage1to1.getHeight()- newImageRect.y;
 		}
 		zoomFromUnscaled(zoomFactor * currentMap.zoomFactor, newImageRect, center);
@@ -1742,7 +1742,7 @@
 	 * @param zoomFactor relative to original image
 	 * @param newImageRect Rect in the 1:1 image that contains the area to be zoomed into
 	 * @param center
-	 */		
+	 */
 	public void zoomFromUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
 		Vm.showWait(this, true);
 		boolean savegpsstatus = dontUpdatePos;
@@ -1765,7 +1765,7 @@
 				else tmp = new MapImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor), (int)(newImageRect.height*zoomFactor), newImageRect, 0));
 				currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
 			} catch (OutOfMemoryError e) {
-				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), 
+				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;),
 						MyLocale.getMsg(4222, &quot;Out of memory error&quot;), FormBase.OKB)).execute();
 				//tmp = mapImage1to1;
 			} //if (tmp != null) currentMap.zoom();}
@@ -1780,7 +1780,7 @@
 				Point mappos = getMapPositionOnScreen();
 				mmp.mapImage.move(mappos.x,mappos.y);
 			}
-		} else // no map image loaded 
+		} else // no map image loaded
 		{ currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y); }
 		// scaleWanted = currentMap.scale; use this if you want to change automatically to a map scale that best fits the zooming
 		destroyOverlaySet();
@@ -1804,7 +1804,7 @@
 	public void onEvent(Event ev){
 		if(ev instanceof FormEvent &amp;&amp; (ev.type == FormEvent.CLOSED )){
 			running = false;
-		}  
+		}
 		if( ev instanceof KeyEvent &amp;&amp; ev.target == this &amp;&amp; ( (((KeyEvent)ev).key == IKeys.ESCAPE) || (((KeyEvent)ev).key == IKeys.ENTER) || (((KeyEvent)ev).key == IKeys.ACTION) ) ) {
 			this.close(0);
 			ev.consumed = true;
@@ -1821,7 +1821,7 @@
 	MenuItem gotoMenuItem = new MenuItem(MyLocale.getMsg(4230, &quot;Goto here$g&quot;), 0, null);
 	MenuItem newWayPointMenuItem = new MenuItem(MyLocale.getMsg(4232, &quot;Create new Waypoint here$n&quot;), 0, null);;
 	MenuItem openCacheDescMenuItem,addCachetoListMenuItem,gotoCacheMenuItem;
-	
+
 	MenuItem miLuminary[];
 
 	Menu mapsMenu;
@@ -1833,19 +1833,19 @@
 	MenuItem noFillMapMI = new MenuItem(MyLocale.getMsg(4266, &quot;Fill white areas&quot;), new IconAndText(new mImage(&quot;map_off.png&quot;), MyLocale.getMsg(4266, &quot;Fill white areas&quot;), null, CellConstants.RIGHT));
 	// automatic
 	MenuItem mapChangeModusMI = new MenuItem(MyLocale.getMsg(4242, &quot;Modus for automatic map change&quot;), MenuItem.Separator, null);;
-	MenuItem highestResGpsDestMI = new MenuItem(MyLocale.getMsg(4244, &quot;Highest res. containing dest. &amp; cur. position&quot;), new IconAndText(new mImage(&quot;res_gps_goto.png&quot;), MyLocale.getMsg(4245, &quot;Highest res. containing dest. &amp; cur. position&quot;), null, CellConstants.RIGHT)); //immer h&#65533;chste Aufl&#65533;sung w&#65533;hlen, die akt. Pos. und Ziel enthalten 
-	MenuItem highestResolutionMI = new MenuItem(MyLocale.getMsg(4246, &quot;Highest resolution&quot;), new IconAndText(new mImage(&quot;res_high.png&quot;), MyLocale.getMsg(4247, &quot;Highest resolution&quot;), null, CellConstants.RIGHT)); //immer h&#65533;chste Aufl&#65533;sung w&#65533;hlen 
-	MenuItem keepManResolutionMI = new MenuItem(MyLocale.getMsg(4248, &quot;Keep manual resolution&quot;), new IconAndText(new mImage(&quot;res_manuell.png&quot;), MyLocale.getMsg(4249, &quot;Keep manual resolution&quot;), null, CellConstants.RIGHT)); // manuell gew&#65533;hlte Aufl&#65533;sung beibehalten  
+	MenuItem highestResGpsDestMI = new MenuItem(MyLocale.getMsg(4244, &quot;Highest res. containing dest. &amp; cur. position&quot;), new IconAndText(new mImage(&quot;res_gps_goto.png&quot;), MyLocale.getMsg(4245, &quot;Highest res. containing dest. &amp; cur. position&quot;), null, CellConstants.RIGHT)); //immer h&#65533;chste Aufl&#65533;sung w&#65533;hlen, die akt. Pos. und Ziel enthalten
+	MenuItem highestResolutionMI = new MenuItem(MyLocale.getMsg(4246, &quot;Highest resolution&quot;), new IconAndText(new mImage(&quot;res_high.png&quot;), MyLocale.getMsg(4247, &quot;Highest resolution&quot;), null, CellConstants.RIGHT)); //immer h&#65533;chste Aufl&#65533;sung w&#65533;hlen
+	MenuItem keepManResolutionMI = new MenuItem(MyLocale.getMsg(4248, &quot;Keep manual resolution&quot;), new IconAndText(new mImage(&quot;res_manuell.png&quot;), MyLocale.getMsg(4249, &quot;Keep manual resolution&quot;), null, CellConstants.RIGHT)); // manuell gew&#65533;hlte Aufl&#65533;sung beibehalten
 	// manuell
 	MenuItem mapChangeResMI = new MenuItem(MyLocale.getMsg(4250, &quot;Change resolution manually&quot;), MenuItem.Separator, null);;
-	MenuItem AllCachesResMI = new MenuItem(MyLocale.getMsg(4252, &quot;Load a map containing all marked caches&quot;),  new IconAndText(new mImage(&quot;loupe_all.png&quot;), MyLocale.getMsg(4253, &quot;Load a map containing all marked caches&quot;), null, CellConstants.RIGHT));   
-	MenuItem moreDetailsMI = new MenuItem(MyLocale.getMsg(4254, &quot;Load a map with more details&quot;), new IconAndText(new mImage(&quot;loupe_more_details.png&quot;), MyLocale.getMsg(4255, &quot;Load a map with more details&quot;), null, CellConstants.RIGHT)); // laod a map with more details 
-	MenuItem moreOverviewMI = new MenuItem(MyLocale.getMsg(4256, &quot;Load a map for a better overview&quot;), new IconAndText(new mImage(&quot;loupe_better_overview.png&quot;), MyLocale.getMsg(4257, &quot;Load a map for a better overview&quot;), null, CellConstants.RIGHT)); // Load a map for a better overview --&gt; lesser details  
+	MenuItem AllCachesResMI = new MenuItem(MyLocale.getMsg(4252, &quot;Load a map containing all marked caches&quot;),  new IconAndText(new mImage(&quot;loupe_all.png&quot;), MyLocale.getMsg(4253, &quot;Load a map containing all marked caches&quot;), null, CellConstants.RIGHT));
+	MenuItem moreDetailsMI = new MenuItem(MyLocale.getMsg(4254, &quot;Load a map with more details&quot;), new IconAndText(new mImage(&quot;loupe_more_details.png&quot;), MyLocale.getMsg(4255, &quot;Load a map with more details&quot;), null, CellConstants.RIGHT)); // laod a map with more details
+	MenuItem moreOverviewMI = new MenuItem(MyLocale.getMsg(4256, &quot;Load a map for a better overview&quot;), new IconAndText(new mImage(&quot;loupe_better_overview.png&quot;), MyLocale.getMsg(4257, &quot;Load a map for a better overview&quot;), null, CellConstants.RIGHT)); // Load a map for a better overview --&gt; lesser details
 	// move map to
 	MenuItem moveToMI = new MenuItem(MyLocale.getMsg(4258, &quot;Move map to and load map&quot;), MenuItem.Separator, null);;
-	MenuItem moveToDestMI = new MenuItem(MyLocale.getMsg(4260, &quot;Move to goto point&quot;), new IconAndText(new mImage(&quot;move2goto.png&quot;), MyLocale.getMsg(4261, &quot;Move to goto point&quot;), null, CellConstants.RIGHT)); //* Karte zum Ziel verschieben (und ggf. entsprechende Karte laden) 
-	MenuItem moveToGpsMI = new MenuItem(MyLocale.getMsg(4262, &quot;Move to GPS position&quot;), new IconAndText(new mImage(&quot;move2gps.png&quot;), MyLocale.getMsg(4263, &quot;Move to GPS position&quot;), null, CellConstants.RIGHT));   
-	MenuItem moveToCenterMI = new MenuItem(MyLocale.getMsg(4264, &quot;Move to centre&quot;), new IconAndText(new mImage(&quot;move2center.png&quot;), MyLocale.getMsg(4265, &quot;Move to centre&quot;), null, CellConstants.RIGHT));   
+	MenuItem moveToDestMI = new MenuItem(MyLocale.getMsg(4260, &quot;Move to goto point&quot;), new IconAndText(new mImage(&quot;move2goto.png&quot;), MyLocale.getMsg(4261, &quot;Move to goto point&quot;), null, CellConstants.RIGHT)); //* Karte zum Ziel verschieben (und ggf. entsprechende Karte laden)
+	MenuItem moveToGpsMI = new MenuItem(MyLocale.getMsg(4262, &quot;Move to GPS position&quot;), new IconAndText(new mImage(&quot;move2gps.png&quot;), MyLocale.getMsg(4263, &quot;Move to GPS position&quot;), null, CellConstants.RIGHT));
+	MenuItem moveToCenterMI = new MenuItem(MyLocale.getMsg(4264, &quot;Move to centre&quot;), new IconAndText(new mImage(&quot;move2center.png&quot;), MyLocale.getMsg(4265, &quot;Move to centre&quot;), null, CellConstants.RIGHT));
 
 	CacheHolder clickedCache;
 	MovingMap mm;
@@ -1855,7 +1855,7 @@
 	boolean paintingZoomArea;
 	ImageList saveImageList = null;
 	int lastZoomWidth , lastZoomHeight;
-	
+
 	public MovingMapPanel(MovingMap f){
 		this.mm = f;
 		miLuminary = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
@@ -1874,7 +1874,7 @@
 		}
 		// move (drag) map
 		//if (!(which == null || which == mapImage || which instanceof TrackOverlay || which == mm.directionArrows) ) return false;
-		saveGpsIgnoreStatus = mm.dontUpdatePos; 
+		saveGpsIgnoreStatus = mm.dontUpdatePos;
 		mm.dontUpdatePos = true;
 		saveMapLoc = pos;
 		bringMapToTop();
@@ -1902,7 +1902,7 @@
 			saveMapLoc = new Point (ev.x, ev.y);
 			paintingZoomArea = true;
 			mm.zoomingMode = true;
-		} 
+		}
 		if (!mm.zoomingMode &amp;&amp; ev.type == PenEvent.PEN_DOWN &amp;&amp; ev.modifiers == PenEvent.RIGHT_BUTTON) {
 			penHeld(new Point (ev.x, ev.y));
 		}
@@ -1930,13 +1930,13 @@
 			top -= 2;
 			if (top &lt; 0) top = 0;
 			if (left &lt; 0) left = 0;
-			if ((lastZoomWidth &lt;= 0) &amp;&amp; (ev.x - saveMapLoc.x &gt; 0)) { // changed from zooming out to zooming in 
+			if ((lastZoomWidth &lt;= 0) &amp;&amp; (ev.x - saveMapLoc.x &gt; 0)) { // changed from zooming out to zooming in
 				removeImage(mm.buttonImageLensActivated);
 				removeImage(mm.buttonImageLensActivatedZoomOut);
 				addImage(mm.buttonImageLensActivatedZoomIn);
 				this.repaintNow(dr, new Rect(mm.buttonImageLensActivatedZoomIn.location.x, mm.buttonImageLensActivatedZoomIn.location.y, mm.buttonImageLensActivatedZoomIn.getWidth(), mm.buttonImageLensActivatedZoomIn.getHeight()));
 			}
-			if ((lastZoomWidth &gt;= 0) &amp;&amp; (ev.x - saveMapLoc.x &lt; 0)) { // changed from zooming out to zooming in 
+			if ((lastZoomWidth &gt;= 0) &amp;&amp; (ev.x - saveMapLoc.x &lt; 0)) { // changed from zooming out to zooming in
 				removeImage(mm.buttonImageLensActivated);
 				removeImage(mm.buttonImageLensActivatedZoomIn);
 				addImage(mm.buttonImageLensActivatedZoomOut);
@@ -2010,12 +2010,12 @@
 			} else {
 				mm.setGpsStatus(MovingMap.noGPS);
 				mm.ignoreGps = true;
-				mm.setMap(l.selectedMap, mm.posCircle.where); 
+				mm.setMap(l.selectedMap, mm.posCircle.where);
 				if (mm.currentMap.fileNameWFL.length() &gt; 0)
 					mm.setCenterOfScreen(l.selectedMap.center, true); // if map has an image
 				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
 				//Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
-				//double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4]; 
+				//double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4];
 				//mm.posCircleX = 0; // place map to the upper left corner of windows
 				//mm.posCircleY = 0;
 				//mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
@@ -2031,7 +2031,7 @@
 			mapsMenu = new Menu();
 			mapsMenu.addItem(selectMapMI);
 			mapsMenu.addItem(changeMapDirMI);
-			if (!mm.noMapsAvailable) 
+			if (!mm.noMapsAvailable)
 			{
 				if (mm.mapHidden) mapsMenu.addItem(showMapMI);
 				else mapsMenu.addItem(hideMapMI);
@@ -2047,9 +2047,9 @@
 			highestResolutionMI.modifiers &amp;= ~MenuItem.Checked;
 			keepManResolutionMI.modifiers &amp;= ~MenuItem.Checked;
 			switch (mm.mapChangeModus) {
-			case MovingMap.NORMAL_KEEP_RESOLUTION: keepManResolutionMI.modifiers |= MenuItem.Checked; break;   
-			case MovingMap.HIGHEST_RESOLUTION: highestResolutionMI.modifiers |= MenuItem.Checked; break;   
-			case MovingMap.HIGHEST_RESOLUTION_GPS_DEST: highestResGpsDestMI.modifiers |= MenuItem.Checked; break;   
+			case MovingMap.NORMAL_KEEP_RESOLUTION: keepManResolutionMI.modifiers |= MenuItem.Checked; break;
+			case MovingMap.HIGHEST_RESOLUTION: highestResolutionMI.modifiers |= MenuItem.Checked; break;
+			case MovingMap.HIGHEST_RESOLUTION_GPS_DEST: highestResGpsDestMI.modifiers |= MenuItem.Checked; break;
 			}
 			mapsMenu.addItem(mapChangeModusMI);
 			mapsMenu.addItem(highestResGpsDestMI);
@@ -2082,7 +2082,7 @@
 			lastZoomHeight = 0;
 		}
 		if (which == mm.buttonImageZoom1to1) {
-			mm.zoom1to1(); 
+			mm.zoom1to1();
 		}
 		if (which == mm.bottonImageClose) {
 			WindowEvent tmp = new WindowEvent();
@@ -2098,9 +2098,9 @@
 
 	public void penHeld(Point p){
 		//	if (!menuIsActive()) doMenu(p);
-		if (!mm.zoomingMode) { 
+		if (!mm.zoomingMode) {
 			//( (ev.type == PenEvent.PEN_DOWN) &amp;&amp; ((PenEvent)ev).modifiers == PenEvent.RIGHT_BUTTON)
-			//|| ((ev.type == PenEvent.RIGHT_BUTTON) ) )) ---&gt; these events are not posted --&gt; this overridering is the only solution 
+			//|| ((ev.type == PenEvent.RIGHT_BUTTON) ) )) ---&gt; these events are not posted --&gt; this overridering is the only solution
 			kontextMenu = new Menu();
 			if ( !(mm.directionArrows.onHotArea(p.x, p.y)) ) {
 				kontextMenu.addItem(gotoMenuItem);
@@ -2113,14 +2113,14 @@
 						kontextMenu.addItem(openCacheDescMenuItem);
 						gotoCacheMenuItem = new MenuItem(MyLocale.getMsg(4279, &quot;Goto&quot;)+ &quot; '&quot;+(clickedCache.getCacheName().length()&gt;0 ? clickedCache.getCacheName() : clickedCache.getWayPoint())+&quot;'$g&quot;); // clickedCache == null can happen if clicked on the goto-symbol
 						kontextMenu.addItem(gotoCacheMenuItem);
-						if (Global.mainForm.cacheListVisible) { 
+						if (Global.mainForm.cacheListVisible) {
 							addCachetoListMenuItem = new MenuItem(MyLocale.getMsg(199,&quot;Add to cachetour&quot;));
 							kontextMenu.addItem(addCachetoListMenuItem);
 						}
 					}
 				}
 			}
-			else {			
+			else {
 				for (int i=0; i&lt;SkyOrientation.LUMINARY_NAMES.length; i++) {
 					kontextMenu.addItem(miLuminary[i]);
 					if (i == mm.myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
@@ -2135,14 +2135,14 @@
 		if (mapsMenu != null &amp;&amp; ev instanceof PenEvent &amp;&amp; ev.type == PenEvent.PEN_DOWN &amp;&amp; ev.target == this) {mapsMenu.close(); mapsMenu = null;}
 		if (kontextMenu != null &amp;&amp; ev instanceof PenEvent &amp;&amp; ev.type == PenEvent.PEN_DOWN &amp;&amp; ev.target == this) {kontextMenu.close(); kontextMenu = null; }
 
-		if (ev instanceof MenuEvent) { 
+		if (ev instanceof MenuEvent) {
 			if (ev.target == mapsMenu) {
-				if (ev.type == MenuEvent.ABORTED || ev.type == ControlEvent.CANCELLED || ev.type == ControlEvent.FOCUS_OUT) mapsMenu.close(); // TODO menuIsActive() benutzen? 
+				if (ev.type == MenuEvent.ABORTED || ev.type == ControlEvent.CANCELLED || ev.type == ControlEvent.FOCUS_OUT) mapsMenu.close(); // TODO menuIsActive() benutzen?
 				if (ev.type == MenuEvent.SELECTED ) {
-					MenuItem action = (MenuItem) mapsMenu.getSelectedItem(); 
+					MenuItem action = (MenuItem) mapsMenu.getSelectedItem();
 					if (mapsMenu.getSelectedItem() != null) {
 						//maps
-						if (action == selectMapMI)	{ 
+						if (action == selectMapMI)	{
 							mapsMenu.close();
 							chooseMap();
 						}
@@ -2196,7 +2196,7 @@
 						else if (action == moreDetailsMI) {
 							mapsMenu.close();
 							mm.loadMoreDetailedMap(false);
-						} 
+						}
 						else if (action == moreOverviewMI) {
 							mapsMenu.close();
 							mm.loadMoreDetailedMap(true);
@@ -2216,7 +2216,7 @@
 						}
 						else if (action == moveToGpsMI) {
 							mapsMenu.close();
-							this.snapToGps();						
+							this.snapToGps();
 						}
 
 					}
@@ -2224,10 +2224,10 @@
 			} // if (ev.target == mapsMenu)
 			if (ev.target == kontextMenu) {
 				if ((((MenuEvent)ev).type==MenuEvent.SELECTED)) {
-					MenuItem action = (MenuItem) kontextMenu.getSelectedItem(); 
+					MenuItem action = (MenuItem) kontextMenu.getSelectedItem();
 					if (action == gotoMenuItem) {
 						kontextMenu.close();
-						mm.myNavigation.setDestination(mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y));	
+						mm.myNavigation.setDestination(mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y));
 					}
 					if (action == openCacheDescMenuItem) {
 						//mm.onEvent(new FormEvent(FormEvent.CLOSED, mm));
@@ -2241,17 +2241,17 @@
 					}
 					if (action == gotoCacheMenuItem) {
 						kontextMenu.close();
-						mm.myNavigation.setDestination(clickedCache);	
+						mm.myNavigation.setDestination(clickedCache);
 					}
 					if (action == newWayPointMenuItem) {
 						kontextMenu.close();
 						WindowEvent close = new WindowEvent();
-						close.target = mm; 
+						close.target = mm;
 						close.type = WindowEvent.CLOSE;
 						mm.postEvent(close);
 						CacheHolder newWP = new CacheHolder();
 						newWP.pos = mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y);
-						newWP.LatLon=newWP.pos.toString(); 
+						newWP.LatLon=newWP.pos.toString();
 						Global.mainTab.newWaypoint(newWP);
 					}
 					if (action == addCachetoListMenuItem) {
@@ -2268,7 +2268,7 @@
 					}
 				}
 			} // if (ev.target == kontextMenu)
-		} // if (ev instanceof ControlEvent ) 
+		} // if (ev instanceof ControlEvent )
 		super.onEvent(ev);
 	}
 }
@@ -2286,7 +2286,7 @@
 
 	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos, MapInfoObject curMap){
 		this.title = MyLocale.getMsg(4271, &quot;Maps&quot;);
-		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else 
+		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else
 		// set width to screenwidth *3/4 but to at least 240 if the screen is big engough for 240px width
 		this.setPreferredSize(java.lang.Math.max(MyLocale.getScreenWidth()*3/4, java.lang.Math.min(240, MyLocale.getScreenWidth()) ), MyLocale.getScreenHeight()*3/4);
 		this.maps = maps;
@@ -2308,14 +2308,14 @@
 					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
 					else { map = ml.getMap();}
 				} catch (IOException ex) {continue; } // could not read .wfl-file
-				if( map.isInBound(Gps.latDec, Gps.lonDec) &amp;&amp; map.isInBound(gotopos) ) 
+				if( map.isInBound(Gps.latDec, Gps.lonDec) &amp;&amp; map.isInBound(gotopos) )
 				{
 					list.addItem(i + &quot;: &quot; + map.mapName);
 					row++;
 					inList[i] = true;
-					if (!curMapFound &amp;&amp; curMap!=null &amp;&amp; map.mapName.equals(curMap.mapName)) { 
-						oldmap = row; 
-						curMapFound = true; 
+					if (!curMapFound &amp;&amp; curMap!=null &amp;&amp; map.mapName.equals(curMap.mapName)) {
+						oldmap = row;
+						curMapFound = true;
 					}
 				} else inList[i] = false;
 			}
@@ -2330,14 +2330,14 @@
 					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
 					else { map = ml.getMap();}
 				} catch (IOException ex) {continue; } // could not read .wfl-file
-				if( map.isInBound(Gps.latDec, Gps.lonDec) ) 
+				if( map.isInBound(Gps.latDec, Gps.lonDec) )
 				{
 					list.addItem(i + &quot;: &quot; + map.mapName);
 					row++;
 					inList[i] = true;
-					if (!curMapFound  &amp;&amp; curMap!=null &amp;&amp; map.mapName.equals(curMap.mapName)) { 
-						oldmap = row; 
-						curMapFound = true; 
+					if (!curMapFound  &amp;&amp; curMap!=null &amp;&amp; map.mapName.equals(curMap.mapName)) {
+						oldmap = row;
+						curMapFound = true;
 					}
 				}
 			}
@@ -2356,9 +2356,9 @@
 					list.addItem(i + &quot;: &quot; + map.mapName);
 					row++;
 					inList[i] = true;
-					if (!curMapFound  &amp;&amp; curMap!=null &amp;&amp; map.mapName.equals(curMap.mapName)) { 
-						oldmap = row; 
-						curMapFound = true; 
+					if (!curMapFound  &amp;&amp; curMap!=null &amp;&amp; map.mapName.equals(curMap.mapName)) {
+						oldmap = row;
+						curMapFound = true;
 					}
 				}
 			}
@@ -2370,9 +2370,9 @@
 			if(!inList[i]) {
 				list.addItem(i + &quot;: &quot; + ml.filename);
 				row++;
-				if (!curMapFound &amp;&amp; curMap!=null &amp;&amp; ml.filename.equals(curMap.mapName)) { 
-					oldmap = row; 
-					curMapFound = true; 
+				if (!curMapFound &amp;&amp; curMap!=null &amp;&amp; ml.filename.equals(curMap.mapName)) {
+					oldmap = row;
+					curMapFound = true;
 				}
 			}
 		}
@@ -2387,7 +2387,7 @@
 		okButton.takeFocus(0);
 	}
 	public void mapSelected() {
-		try { 
+		try {
 			selectedMap = null;
 			int mapNum = 0;
 			String it = new String();
@@ -2401,7 +2401,7 @@
 				selected = true;
 				this.close(FormBase.IDOK);
 				} catch (IOException e) {
-					(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4278, &quot;Cannot load wfl-file: \n&quot;) 
+					(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4278, &quot;Cannot load wfl-file: \n&quot;)
 							+ ((MapListEntry)maps.get(mapNum)).filename, FormBase.OKB)).execute();
 				}
 			}
@@ -2410,8 +2410,8 @@
 				this.close(FormBase.IDCANCEL);
 			}
 		}catch (NegativeArraySizeException e) {
-			// happens in substring when a dividing line selected 
-		} 
+			// happens in substring when a dividing line selected
+		}
 	}
 
 	public void onEvent(Event ev){
@@ -2442,7 +2442,7 @@
 	Graphics draw;
 	private MapInfoObject map=null;
 
-	Color moveDirColor = new Color(255,0,0); // RED 
+	Color moveDirColor = new Color(255,0,0); // RED
 	final static Color sunDirColor = new Color(255,255,0); // Yellow
 	//final static Color GREEN = new Color(0,255,0);
 	final static Color gotoDirColor = new Color(0,0,128); // dark blue
@@ -2451,10 +2451,10 @@
 	Point[] gotoDirArrow = null;
 	Point[] moveDirArrow = null;
 	Point[] northDirArrow = null;
-	
+
 	int imageSize = Global.getPref().fontSize * 8;
 	int arrowThickness = imageSize / 28;
-	
+
 	/**
 	 * @param gd goto direction
 	 * @param sd sun direction
@@ -2500,7 +2500,7 @@
 		drawArrows(g);
 		return;
 /*		if (!dirsChanged) {
-			g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height); // the transparency with a transparent color doesn't work in ewe-vm for pocketpc, it works in java-vm, ewe-vm on pocketpc2003 
+			g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height); // the transparency with a transparent color doesn't work in ewe-vm for pocketpc, it works in java-vm, ewe-vm on pocketpc2003
 			return;
 		}
 		dirsChanged = false;
@@ -2509,7 +2509,7 @@
 		draw.fillRect(0, 0, location.width, location.height);
 		minY = Integer.MAX_VALUE;
 		drawArrows(draw);
-		draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw 
+		draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw
 		g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
 */	}
 
@@ -2531,10 +2531,10 @@
 				if (northDirArrow == null) northDirArrow = new Point[2];
 				makeArrow(northDirArrow, 0, 1.0f); // north direction
 			} else northDirArrow = null;
-			
+
 			//select moveDirColor according to difference to gotoDir
 			moveDirColor = new Color(255,0,0); // red
-			
+
 			if (moveDirArrow != null &amp;&amp; gotoDirArrow != null)
 			{
 				float diff = java.lang.Math.abs(moveDir - gotoDir);
@@ -2546,7 +2546,7 @@
 				{
 					diff = 360.0f - diff;
 				}
-				
+
 				if (diff &lt;= 5.0)
 				{
 					moveDirColor = new Color(0,192,0);// darkgreen
@@ -2563,7 +2563,7 @@
 		}
 
 	/**
-	 * make (calculate) Pixel array for a single arrow 
+	 * make (calculate) Pixel array for a single arrow
 	 * @param g handle for drawing
 	 * @param angle angle of arrow
 	 * @param col color of arrow
@@ -2590,7 +2590,7 @@
 		drawArrow(g, moveDirArrow, moveDirColor);
 		drawArrow(g, sunDirArrow, sunDirColor);
 	}
-	
+
 	public void drawArrow(Graphics g, Point[] arrow, Color col) {
 		if (arrow == null) return;
 		g.setPen(new Pen(col,Pen.SOLID,arrowThickness));


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002136.html">[Cachewolf-svn] r2212 - trunk/src/CacheWolf/navi
</A></li>
	<LI>Next message: <A HREF="002138.html">[Cachewolf-svn] r2214 - trunk/src/CacheWolf/navi
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2137">[ date ]</a>
              <a href="thread.html#2137">[ thread ]</a>
              <a href="subject.html#2137">[ subject ]</a>
              <a href="author.html#2137">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
