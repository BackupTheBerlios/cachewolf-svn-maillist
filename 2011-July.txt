From araber95 at mail.berlios.de  Fri Jul  1 10:11:00 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Fri,  1 Jul 2011 10:11:00 AM +0200
Subject: [Cachewolf-svn] r3033 - in trunk: res_noewe src/CacheWolf
	src/CacheWolf/imp
Message-ID: <20110701081100.93DAF481351@sheep.berlios.de>

Author: araber95
Date: 2011-07-01 10:11:00 +0200 (Fri, 01 Jul 2011)
New Revision: 3033

Modified:
   trunk/res_noewe/spider.def
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/imp/SpiderGC.java
Log:
1. intermediate change for spidering TBs
2. typo corrected in MainTab

Modified: trunk/res_noewe/spider.def
===================================================================
--- trunk/res_noewe/spider.def	2011-06-27 17:29:22 UTC (rev 3032)
+++ trunk/res_noewe/spider.def	2011-07-01 08:11:00 UTC (rev 3033)
@@ -154,7 +154,8 @@
 #--------------------------------------
 # blockEx extrahiert zun?chst den Bugbereich aus der gesamten Seite
 blockExStart       = ctl00_ContentBody_uxTravelBugList_uxInventoryLabel
-blockExEnd         = ctl00_ContentBody_uxTravelBugList_uxTrackableItemsLinks
+#blockExEnd         = ctl00_ContentBody_uxTravelBugList_uxTrackableItemsLinks
+blockExEnd         = ctl00_ContentBody_uxTravelBugList_uxTrackableItemsHistory
 # bugEx extrahiert die Namen der einzelnen Bugs aus dem Bugbereich
 bugExStart         = <a\ href="
 bugExEnd           = </a>

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2011-06-27 17:29:22 UTC (rev 3032)
+++ trunk/src/CacheWolf/MainTab.java	2011-07-01 08:11:00 UTC (rev 3033)
@@ -53,7 +53,7 @@
 	static int DETAILS_CARD;
 	static int DESCRIPTION_CARD;
 	static int IMAGES_CARD;
-	static int HINTSANSLOGS_CARD;
+	static int HINTSANDLOGS_CARD;
 	static int SOLVER_CARD;
 	static int CALC_CARD;
 	static int GOTO_CARD;
@@ -126,7 +126,7 @@
 		c.iconize(new Image("images" + imagesize + ".gif"), true);
 
 		c = this.addCard(hintLP, MyLocale.getMsg(1204, "Hints & Logs"), null);
-		HINTSANSLOGS_CARD = this.cardPanel.cards.size() - 1;
+		HINTSANDLOGS_CARD = this.cardPanel.cards.size() - 1;
 		c.iconize(new Image("more" + imagesize + ".gif"), true);
 
 		c = this.addCard(solverP = new SolverPanel(pref, profile), MyLocale.getMsg(1205, "Solver"), null);
@@ -292,7 +292,7 @@
 			} else {
 				imageP.setImages(chD);
 			}
-		} else if (panelNo == HINTSANSLOGS_CARD) {
+		} else if (panelNo == HINTSANDLOGS_CARD) {
 			if (ch.isAddiWpt()) {
 				hintLP.setText(ch.mainCache.getCacheDetails(true));
 			} else {
@@ -318,7 +318,7 @@
 				select(descP);
 			} else if (oldCard == IMAGES_CARD) {
 				select(imageP);
-			} else if (oldCard == HINTSANSLOGS_CARD) {
+			} else if (oldCard == HINTSANDLOGS_CARD) {
 				select(hintLP);
 			} else if (oldCard == SOLVER_CARD) {
 				select(solverP);
@@ -340,7 +340,8 @@
 	/**
 	 * this is called from MovingMap Cache context menu
 	 * 
-	 * @param chi ,
+	 * @param chi
+	 *            ,
 	 *            the CacheHolder for the Cache to switch to
 	 * @param panelNo
 	 *            1=DetailsPanel 2=Description Panel
@@ -439,8 +440,8 @@
 						i++;
 						ewe.sys.mThread.sleep(100);
 					} // wait until the window size of the moving map is
-					// known note: ewe.sys.sleep() will pause the whole
-					// vm - no other thread will run
+						// known note: ewe.sys.sleep() will pause the whole
+						// vm - no other thread will run
 					if (i >= 10 * 60) {
 						(new MessageBox("Error", "MovingMap cannot be displayed - this is most likely a bug - plaese report it on www.geoclub.de", FormBase.OKB)).execute();
 						return;

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-06-27 17:29:22 UTC (rev 3032)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-07-01 08:11:00 UTC (rev 3033)
@@ -1008,7 +1008,7 @@
 
 	/**
 	 * Method to spider a single cache. It assumes a login has already been performed!
-	 *
+	 * 
 	 * @return 1 if spider was successful, -1 if spider was cancelled by closing the infobox, 0 error, but continue with
 	 *         next cache
 	 */
@@ -1055,7 +1055,7 @@
 
 	/**
 	 * Fetch the coordinates of a waypoint from GC
-	 *
+	 * 
 	 * @param wayPoint
 	 *            the name of the waypoint
 	 * @return the cache coordinates
@@ -1747,7 +1747,7 @@
 
 	/**
 	 * check if new Update exists
-	 *
+	 * 
 	 * @param ch
 	 *            CacheHolder
 	 * @param CacheDescription
@@ -1832,7 +1832,7 @@
 
 	/**
 	 * Get num found
-	 *
+	 * 
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return numFound
@@ -1952,7 +1952,7 @@
 
 	/**
 	 * Get the waypoint name
-	 *
+	 * 
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return Name of waypoint to add to list
@@ -2177,9 +2177,9 @@
 
 	/*
 	 * @param CacheHolder ch
-	 *
+	 * 
 	 * @param String cacheDescGC
-	 *
+	 * 
 	 * @return boolean newLogExists
 	 */
 	private boolean newFoundExists(CacheHolder ch, String cacheDescription) {
@@ -2221,22 +2221,22 @@
 	 * Read a complete cachepage from geocaching.com including all logs. This is used both when updating already
 	 * existing caches (via spiderSingle) and when spidering around a centre. It is also used when reading a GPX file
 	 * and fetching the images.
-	 *
+	 * 
 	 * This is the workhorse function of the spider.
-	 *
+	 * 
 	 * @param CacheHolderDetail
 	 *            chD The element wayPoint must be set to the name of a waypoint
 	 * @param boolean
-	 *            isUpdate True if an existing cache is being updated, false if it is a new cache
+	 *        isUpdate True if an existing cache is being updated, false if it is a new cache
 	 * @param boolean
-	 *            fetchImages True if the pictures are to be fetched
+	 *        fetchImages True if the pictures are to be fetched
 	 * @param boolean
-	 *            fetchTBs True if the TBs are to be fetched
+	 *        fetchTBs True if the TBs are to be fetched
 	 * @param boolean
-	 *            doNotGetFound True if the cache is not to be spidered if it has already been found
+	 *        doNotGetFound True if the cache is not to be spidered if it has already been found
 	 * @param boolean
-	 *            fetchAllLogs True if all logs are to be fetched (by adding option '&logs=y' to command line). This is
-	 *            normally false when spidering from GPXImport as the logs are part of the GPX file, and true otherwise
+	 *        fetchAllLogs True if all logs are to be fetched (by adding option '&logs=y' to command line). This is
+	 *        normally false when spidering from GPXImport as the logs are part of the GPX file, and true otherwise
 	 * @return -1 if the infoBox was closed (cancel spidering), 0 if there was an error (continue with next cache), 1 if
 	 *         everything ok
 	 */
@@ -2429,7 +2429,7 @@
 
 	/**
 	 * Get the coordinates of the cache
-	 *
+	 * 
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return Cache coordinates
@@ -2448,7 +2448,7 @@
 
 	/**
 	 * Get the long description
-	 *
+	 * 
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return the long description
@@ -2483,7 +2483,7 @@
 
 	/**
 	 * Get the cache location (country and state)
-	 *
+	 * 
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return the location (country and state) of the cache
@@ -2500,7 +2500,7 @@
 
 	/**
 	 * Get the cache name
-	 *
+	 * 
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return the name of the cache
@@ -2517,7 +2517,7 @@
 
 	/**
 	 * Get the cache owner
-	 *
+	 * 
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return the cache owner
@@ -2534,7 +2534,7 @@
 
 	/**
 	 * Get the date when the cache was hidden
-	 *
+	 * 
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return Hidden date
@@ -2551,7 +2551,7 @@
 
 	/**
 	 * Get the hints
-	 *
+	 * 
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return Cachehints
@@ -2568,7 +2568,7 @@
 
 	/**
 	 * Get the cache size
-	 *
+	 * 
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return Cache size
@@ -2586,7 +2586,7 @@
 
 	/**
 	 * Get the Difficulty
-	 *
+	 * 
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return The cache difficulty
@@ -2604,7 +2604,7 @@
 
 	/**
 	 * Get the terrain rating
-	 *
+	 * 
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return Terrain rating
@@ -2622,7 +2622,7 @@
 
 	/**
 	 * Get the waypoint type
-	 *
+	 * 
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @return the waypoint type (Tradi, Multi, etc.)
@@ -2639,7 +2639,7 @@
 
 	/**
 	 * Get the logs
-	 *
+	 * 
 	 * @param doc
 	 *            A previously fetched cachepage
 	 * @param chD
@@ -2706,7 +2706,7 @@
 
 	/**
 	 * This methods cleans up the path for inlined smilies in logtexts.
-	 *
+	 * 
 	 * @param logText
 	 * @return
 	 */
@@ -2724,7 +2724,7 @@
 	/**
 	 * Read the travelbug names from a previously fetched Cache page and then read the travelbug purpose for each
 	 * travelbug
-	 *
+	 * 
 	 * @param doc
 	 *            The previously fetched cachepage
 	 * @return A HTML formatted string with bug names and there purpose
@@ -2738,7 +2738,9 @@
 		final Extractor exBug = new Extractor("", p.getProp("bugExStart"), p.getProp("bugExEnd"), 0, Extractor.EXCLUDESTARTEND);
 		final Extractor exBugName = new Extractor("", "", "", 0, Extractor.EXCLUDESTARTEND);
 		final String bugBlock;
-		if ((bugBlock = exBlock.findNext()).length() > 0) {
+		bugBlock = exBlock.findNext();
+		int blockLength = bugBlock.length();
+		if (blockLength > 0) {
 			String link, bug, linkPlusBug, bugDetails;
 			final String oldInfoBox = infB.getInfo();
 			boolean exBugWrong = true;
@@ -2769,16 +2771,16 @@
 			}
 			infB.setInfo(oldInfoBox);
 			if (exBugWrong)
-				pref.log("[SpiderGC.java:getBugs]check TBs bugExStart / bugExEnd!", null);
+				pref.log("[SpiderGC.java:getBugs]check TBs bugExStart / bugExEnd! blockLength = " + blockLength, null);
 		} else {
-			pref.log("[SpiderGC.java:getBugs]check TBs blockExStart / blockExEnd!", null);
+			pref.log("[SpiderGC.java:getBugs]check TBs blockExStart / blockExEnd! ", null);
 		}
 	}
 
 	/**
 	 * Get the images for a previously fetched cache page. Images are extracted from two areas: The long description and
 	 * the pictures section (including the spoiler)
-	 *
+	 * 
 	 * @param doc
 	 *            The previously fetched cachepage
 	 * @param chD
@@ -2965,7 +2967,7 @@
 
 	/**
 	 * Read an image from the server
-	 *
+	 * 
 	 * @param imgUrl
 	 *            The Url of the image
 	 * @param target
@@ -2987,7 +2989,7 @@
 
 	/**
 	 * Read all additional waypoints from a previously fetched cachepage.
-	 *
+	 * 
 	 * @param doc
 	 *            The previously fetched cachepage
 	 * @param wayPoint
@@ -3122,7 +3124,7 @@
 	 * Load the bug id for a given name. This method is not ideal, as there are sometimes several bugs with identical
 	 * names but different IDs. Normally the bug GUID is used which can be obtained from the cache page.<br>
 	 * Note that each bug has both an ID and a GUID.
-	 *
+	 * 
 	 * @param name
 	 *            The name (or partial name) of a travelbug
 	 * @return the id of the bug
@@ -3158,7 +3160,7 @@
 	/**
 	 * Fetch a bug's mission for a given GUID or ID. If the guid String is longer than 10 characters it is assumed to be
 	 * a GUID, otherwise it is an ID.
-	 *
+	 * 
 	 * @param guid
 	 *            the guid or id of the travelbug
 	 * @return The mission
@@ -3191,7 +3193,7 @@
 
 	/**
 	 * Fetch a bug's mission for a given tracking number
-	 *
+	 * 
 	 * @param trackNr
 	 *            the tracking number of the travelbug
 	 * @return The mission
@@ -3223,7 +3225,7 @@
 
 	/**
 	 * Fetch a bug's mission and namefor a given tracking number
-	 *
+	 * 
 	 * @param TB
 	 *            the travelbug
 	 * @return true if suceeded
@@ -3270,7 +3272,7 @@
 
 		/**
 		 * Gets an entry in spider.def by its key (tag)
-		 *
+		 * 
 		 * @param key
 		 *            The key which is attributed to a specific entry
 		 * @return The value for the key



From araber95 at mail.berlios.de  Fri Jul  1 12:57:57 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Fri,  1 Jul 2011 12:57:57 PM +0200
Subject: [Cachewolf-svn] r3034 - in trunk/src/CacheWolf: . imp
Message-ID: <20110701105757.7FD874813E9@sheep.berlios.de>

Author: araber95
Date: 2011-07-01 12:57:57 +0200 (Fri, 01 Jul 2011)
New Revision: 3034

Modified:
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/PreferencesScreen.java
   trunk/src/CacheWolf/imp/SpiderGC.java
Log:
1. use Radar or Map Tab in Preferences affects MainTab.java on small screens
2. direct access of pref isbigscreen and usebigicons in DetailsPamel.java
3.  reflecting a non consistent presentation of caches without TBs (for Info of check Extraction String) in SpiderGC.java

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2011-07-01 08:11:00 UTC (rev 3033)
+++ trunk/src/CacheWolf/DetailsPanel.java	2011-07-01 10:57:57 UTC (rev 3034)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.TransformCoordinates;
@@ -64,7 +64,7 @@
  */
 public class DetailsPanel extends CellPanel {
 
-    // ===== GUI elements =====
+	// ===== GUI elements =====
 	/** way point id. */
 	private static mInput inpWaypoint;
 	/** way point name. */
@@ -135,24 +135,20 @@
 	private boolean blackStatusChanged;
 	/** FIXME */
 	private boolean needsTableUpdate;
-	/** screen is VGA or better */
-	private final boolean isBigScreen;
-	/** use big icons */
-	private final boolean useBigIcons;
-	/** String to display for invalid or not applicable terrain or difficulty values.*/
+	/** String to display for invalid or not applicable terrain or difficulty values. */
 	private final static String DTINVALID = ": -.-";
-	public boolean evWaypointChanged=false;
-	private String warnedForWaypoint="";
+	public boolean evWaypointChanged = false;
+	private String warnedForWaypoint = "";
 
-    // TODO: move images to image broker
-    //mImage imgBlack, imgBlackNo, imgShowBug, imgShowBugNo, imgNewWpt, imgGoto, imgShowMaps, imgAddImages, imgNotes;
+	// TODO: move images to image broker
+	// mImage imgBlack, imgBlackNo, imgShowBug, imgShowBugNo, imgNewWpt, imgGoto, imgShowMaps, imgAddImages, imgNotes;
 
 	/**
 	 * public constructor for detail panels. should only be called from main tab.
 	 */
 	public DetailsPanel() {
 		super();
-        // ===== local objects =====
+		// ===== local objects =====
 		/** helper panels to organize layout */
 		CellPanel helperPanel1, helperPanel2, helperPanel3, helperPanel4, helperPanel5;
 
@@ -166,11 +162,9 @@
 		blackStatus = false;
 		blackStatusChanged = false;
 		needsTableUpdate = false;
-		isBigScreen = pref.isBigScreen;
-		useBigIcons = pref.useBigIcons;
 
 		// ===== initialize GUI objects =====
-        // ----- main body -----
+		// ----- main body -----
 
 		helperPanel1 = new CellPanel();
 		helperPanel2 = new CellPanel();
@@ -183,7 +177,7 @@
 		chcType.alwaysDrop = true;
 		chcSize = new mChoice(CacheSize.guiSizeStrings(), 0);
 		chcSize.alwaysDrop = true;
-		chcStatus = new mComboBox(CacheHolder.GetGuiLogTypes(),0);
+		chcStatus = new mComboBox(CacheHolder.GetGuiLogTypes(), 0);
 		inpWaypoint = new mInput();
 		inpName = new mInput();
 
@@ -196,7 +190,7 @@
 
 		// ===== put the controls onto the GUI =====
 
-        // ----- helper panels -----
+		// ----- helper panels -----
 
 		btnDiff = new mButton(MyLocale.getMsg(1000, "D") + ": 5.5");
 		btnDiff.setPreferredSize(pref.fontSize * 3, chcSize.getPreferredSize(null).height);
@@ -208,10 +202,10 @@
 
 		lblAddiCount = new mLabel(MyLocale.getMsg(1044, "Addis") + ": 888");
 
-		btnFoundDate = new mButton(new mImage(useBigIcons ? "calendar_vga.png" : "calendar.png"));
+		btnFoundDate = new mButton(new mImage(pref.useBigIcons ? "calendar_vga.png" : "calendar.png"));
 		btnFoundDate.setToolTip(MyLocale.getMsg(31415, "Set found date / time"));
 
-		btnHiddenDate = new mButton(new mImage(useBigIcons ? "calendar_vga.png"	: "calendar.png"));
+		btnHiddenDate = new mButton(new mImage(pref.useBigIcons ? "calendar_vga.png" : "calendar.png"));
 		btnHiddenDate.setToolTip(MyLocale.getMsg(31415, "Set hidden date"));
 
 		helperPanel1.addNext(chcType, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
@@ -226,7 +220,7 @@
 		helperPanel4.addNext(chcStatus, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
 		helperPanel4.addLast(btnFoundDate, DONTSTRETCH, DONTFILL);
 
-		helperPanel5.addNext(inpHidden, CellConstants.HSTRETCH,	(CellConstants.HFILL | CellConstants.WEST));
+		helperPanel5.addNext(inpHidden, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
 		helperPanel5.addLast(btnHiddenDate, DONTSTRETCH, DONTFILL);
 
 		// ----- main body -----
@@ -242,10 +236,10 @@
 		addLast(helperPanel3, DONTSTRETCH, HFILL).setTag(CellConstants.SPAN, new Dimension(2, 1));
 
 		addNext(new mLabel(MyLocale.getMsg(303, "Name:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
-		addLast(inpName.setTag(CellConstants.SPAN, new Dimension(2, 1)), CellConstants.DONTSTRETCH,	(CellConstants.HFILL | CellConstants.WEST));
+		addLast(inpName.setTag(CellConstants.SPAN, new Dimension(2, 1)), CellConstants.DONTSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
 
 		addNext(new mLabel(MyLocale.getMsg(304, "Coordinates:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
-		addLast(btnCoordinates.setTag(CellConstants.SPAN, new Dimension(2, 1)),	CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		addLast(btnCoordinates.setTag(CellConstants.SPAN, new Dimension(2, 1)), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
 
 		addNext(new mLabel(MyLocale.getMsg(307, "Status:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		addLast(helperPanel4, DONTSTRETCH, HFILL).setTag(CellConstants.SPAN, new Dimension(2, 1));
@@ -258,56 +252,56 @@
 
 		addLast(attViewer);
 
-		//TODO: decide whether to still use the object without display on small screens to handle notes
-		if (isBigScreen) {
+		// TODO: decide whether to still use the object without display on small screens to handle notes
+		if (pref.isBigScreen) {
 			addLast(new mLabel(MyLocale.getMsg(308, "Notes:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			waypointNotes = new mTextPad();
 			waypointNotes.modify(ControlConstants.NotEditable, 0);
 			addLast(new MyScrollBarPanel(waypointNotes));
 		}
 
-		//FIXME: get rid of this
-		imgBlack = new mImage(useBigIcons?"is_black_vga.png":"is_black.png");
+		// FIXME: get rid of this
+		imgBlack = new mImage(pref.useBigIcons ? "is_black_vga.png" : "is_black.png");
 		imgBlack.transparentColor = Color.White;
-		imgBlackNo = new mImage(useBigIcons ? "no_black_vga.png" : "no_black.png");
+		imgBlackNo = new mImage(pref.useBigIcons ? "no_black_vga.png" : "no_black.png");
 		imgBlackNo.transparentColor = Color.Black;
-		imgShowBug = new mImage(useBigIcons ? "bug_vga.gif":"bug.gif");
-		imgShowBugNo = new mImage(useBigIcons ? "bug_no_vga.gif":"bug_no.gif");
+		imgShowBug = new mImage(pref.useBigIcons ? "bug_vga.gif" : "bug.gif");
+		imgShowBugNo = new mImage(pref.useBigIcons ? "bug_no_vga.gif" : "bug_no.gif");
 	}
 
 	private CellPanel createToolsPanel() {
 		final CellPanel pnlTools = new CellPanel();
 
-		btnNewWpt = new mButton(imgNewWpt = new mImage(useBigIcons ? "newwpt_vga.png" : "newwpt.png"));
+		btnNewWpt = new mButton(imgNewWpt = new mImage(pref.useBigIcons ? "newwpt_vga.png" : "newwpt.png"));
 		// FIXME: get an image with proper transparency
 		imgNewWpt.transparentColor = new Color(255, 0, 0);
 		btnNewWpt.setToolTip(MyLocale.getMsg(311, "Create Waypoint"));
 
-		btnGoto = new mButton(imgGoto = new mImage(useBigIcons ? "goto_vga.png"	: "goto.png"));
+		btnGoto = new mButton(imgGoto = new mImage(pref.useBigIcons ? "goto_vga.png" : "goto.png"));
 		// FIXME: get an image with proper transparency
 		imgGoto.transparentColor = Color.White;
 		btnGoto.setToolTip(MyLocale.getMsg(345, "Goto these coordinates"));
 
-		btnShowBug = new mButton(new mImage(useBigIcons ? "bug_no_vga.gif" : "bug_no.gif"));
+		btnShowBug = new mButton(new mImage(pref.useBigIcons ? "bug_no_vga.gif" : "bug_no.gif"));
 		btnShowBug.setToolTip(MyLocale.getMsg(346, "Show travelbugs"));
 
-		btnShowMap = new mButton(new mImage(useBigIcons ? "globe_small_vga.gif" : "globe_small.gif"));
+		btnShowMap = new mButton(new mImage(pref.useBigIcons ? "globe_small_vga.gif" : "globe_small.gif"));
 		btnShowMap.setToolTip(MyLocale.getMsg(347, "Show map"));
 
-		btnAddPicture = new mButton(new mImage(useBigIcons ? "images_vga.gif" : "images.gif"));
+		btnAddPicture = new mButton(new mImage(pref.useBigIcons ? "images_vga.gif" : "images.gif"));
 		btnAddPicture.setToolTip(MyLocale.getMsg(348, "Add user pictures"));
 
-		btnBlack = new mButton(imgBlack = new mImage(useBigIcons ? "no_black_vga.png" : "no_black.png"));
+		btnBlack = new mButton(imgBlack = new mImage(pref.useBigIcons ? "no_black_vga.png" : "no_black.png"));
 		// FIXME: get an image with proper transparency
 		imgBlack.transparentColor = Color.Black;
 		btnBlack.setToolTip(MyLocale.getMsg(349, "Toggle Blacklist status"));
 
-		btnNotes = new mButton(imgNotes = new mImage(useBigIcons ? "notes_vga.gif" : "notes.gif"));
+		btnNotes = new mButton(imgNotes = new mImage(pref.useBigIcons ? "notes_vga.gif" : "notes.gif"));
 		// FIXME: get an image with proper transparency
 		imgNotes.transparentColor = Color.DarkBlue;
 		btnNotes.setToolTip(MyLocale.getMsg(351, "Add/Edit notes"));
 
-		btnAddDateTime = new mButton(new mImage(useBigIcons ? "date_time_vga.gif" : "date_time.gif"));
+		btnAddDateTime = new mButton(new mImage(pref.useBigIcons ? "date_time_vga.gif" : "date_time.gif"));
 		btnAddDateTime.setToolTip(MyLocale.getMsg(350, "Add timestamp to notes"));
 
 		pnlTools.addNext(btnNewWpt);
@@ -425,7 +419,7 @@
 		}
 		lblAddiCount.setText(MyLocale.getMsg(1044, "Addis") + ": " + addiCount);
 
-		if (isBigScreen) {
+		if (pref.isBigScreen) {
 			waypointNotes.setText(ch.getCacheDetails(true).getCacheNotes());
 		}
 	}
@@ -436,307 +430,275 @@
 	 */
 	public void createWptName() {
 		final String wpt = inpWaypoint.getText().toUpperCase();
-		if (CacheType.isAddiWpt(CacheType.guiSelect2Cw(chcType.getInt()))
-				&& Global.mainTab.mainCache != null
-				&& (Global.mainTab.mainCache.startsWith("GC")
-					|| OC.isOC(Global.mainTab.mainCache) || Global.mainTab.mainCache.startsWith("CW"))
+		if (CacheType.isAddiWpt(CacheType.guiSelect2Cw(chcType.getInt())) && Global.mainTab.mainCache != null && (Global.mainTab.mainCache.startsWith("GC") || OC.isOC(Global.mainTab.mainCache) || Global.mainTab.mainCache.startsWith("CW"))
 				&& wpt.startsWith("CW")) {
 			// for creating the Addiname on creating a new Waypoint
-			Global.mainTab.lastselected = Global.mainTab.mainCache; 
+			Global.mainTab.lastselected = Global.mainTab.mainCache;
 
-			inpWaypoint.setText(Global.getProfile().getNewAddiWayPointName(
-					Global.mainTab.mainCache));
+			inpWaypoint.setText(Global.getProfile().getNewAddiWayPointName(Global.mainTab.mainCache));
 		}
-		if (!CacheType.isAddiWpt(CacheType.guiSelect2Cw(chcType.getInt()))
-				&& !(wpt.startsWith("GC")
-					|| OC.isOC(wpt) || wpt.startsWith("CW"))) {
+		if (!CacheType.isAddiWpt(CacheType.guiSelect2Cw(chcType.getInt())) && !(wpt.startsWith("GC") || OC.isOC(wpt) || wpt.startsWith("CW"))) {
 			inpWaypoint.setText(Global.getProfile().getNewWayPointName());
 		}
 	}
 
-    /**
-     * Method to react to a user input.
-     */
-    public void onEvent(final Event ev) {
-        if (ev instanceof DataChangeEvent) {
-            if (ev.target == inpWaypoint) {
-                if (evWaypointChanged) {
-                    String iTmp=inpWaypoint.getText();
-                    String uTmp=iTmp.toUpperCase();
-                    if (!iTmp.equals(uTmp)){
-                        inpWaypoint.setText(uTmp); // If user entered LowerCase -> convert directly to UpperCase
-                        evWaypointChanged=false; //next DataChangeEvent fired by change to UpperCase will be ignored
-                    }
-                    // already warned(multi same DataChangeEvents) or same waypointname as before edit !!!
-                    if(!warnedForWaypoint.equals(uTmp) && !uTmp.equals(this.cache.getWayPoint())){
-                        if ((new File(profile.dataDir + iTmp.toLowerCase()+".xml")).exists()) {
-                            warnedForWaypoint=uTmp; // before MessageBox cause Multithread DataChangeEvents
-                            // filename is LowerCase
-                            new MessageBox("Warning :",uTmp+"\n"+MyLocale.getMsg(275,"Waypoint already exists!"),MessageBox.OKB).execute();
-                            // revert waypointname
-                            inpWaypoint.setText(this.cache.getWayPoint());
-                        }
-                    }
-                }
-                else {
-                    // first DataChangeEvent is fired by Klick into (after reload).
-                    // that really didn't change anything
-                    evWaypointChanged=true;
-                }
-                // FIXME: if name was changed, we should rename the waypoint.xml file. how? where?
-            } else if (ev.target == chcType) {
-                createWptName();
-                if (CacheType.isCacheWpt(CacheType.guiSelect2Cw(chcType.selectedIndex))) {
-                    activateControl(btnTerr);
-                    activateControl(btnDiff);
-                    activateControl(chcSize);
-                    activateControl(inpOwner);
-                    activateControl(inpHidden);
-                    activateControl(btnShowBug);
-                    activateControl(btnBlack);
-                } else {
-                    deactivateControl(btnTerr);
-                    deactivateControl(btnDiff);
-                    deactivateControl(chcSize);
-                    deactivateControl(inpOwner);
-                    deactivateControl(inpHidden);
-                    deactivateControl(btnShowBug);
-                    deactivateControl(btnBlack);
-                    chcSize.select(0);
-                    btnTerr.setText(MyLocale.getMsg(1001, "T") + DTINVALID);
-                    btnDiff.setText(MyLocale.getMsg(1000, "D") + DTINVALID);
-                }
-            }
-            //FIXME: check if something was actually changed, since datacachnge events also occur if you just hop through the fileds with the tab key (Why? don't know!)
-            dirtyDetails = true;
-            needsTableUpdate = true;
-        }
-        if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
-            if (ev.target == btnNotes) {
-                dirtyNotes = true; // TODO I think this is redundant, because
-                                    // the notes are saved separately by the notes screen itself
-                final NotesScreen nsc = new NotesScreen(cache.getCacheDetails(true));
-                nsc.execute(this.getFrame(), Gui.CENTER_FRAME);
-                if (isBigScreen) {
-                    waypointNotes.setText(cache.getCacheDetails(true).getCacheNotes());
-                }
-            } else if (ev.target == btnShowMap) {
-                Global.mainTab.SwitchToMovingMap(cache.pos, true);
-            } else if (ev.target == btnShowBug) {
-                // InfoScreen is = new InfoScreen(thisCache.Travelbugs.toHtml(),
-                // "Travelbugs",
-                // false, pref);
-                // is.execute();
-                final TravelbugInCacheScreen ts = new TravelbugInCacheScreen(cache.getCacheDetails(true).Travelbugs.toHtml(),	"Travelbugs");
-                ts.execute(this.getFrame(), Gui.CENTER_FRAME);
-            /* not fully implemented
-            } else if (ev.target == btnCenter) {
-                final CWPoint cp = new CWPoint(cache.LatLon);
-                if (cp.isValid()) {
-                    pref.setCurCentrePt(cp);
-                } else {
-                    final MessageBox tmpMB = new MessageBox(
-                            MyLocale.getMsg(312, "Error"),
-                            MyLocale.getMsg(4111, "Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"),
-                            FormBase.OKB);
-                    tmpMB.exec();
-                }
-            */
+	/**
+	 * Method to react to a user input.
+	 */
+	public void onEvent(final Event ev) {
+		if (ev instanceof DataChangeEvent) {
+			if (ev.target == inpWaypoint) {
+				if (evWaypointChanged) {
+					String iTmp = inpWaypoint.getText();
+					String uTmp = iTmp.toUpperCase();
+					if (!iTmp.equals(uTmp)) {
+						inpWaypoint.setText(uTmp); // If user entered LowerCase -> convert directly to UpperCase
+						evWaypointChanged = false; // next DataChangeEvent fired by change to UpperCase will be ignored
+					}
+					// already warned(multi same DataChangeEvents) or same waypointname as before edit !!!
+					if (!warnedForWaypoint.equals(uTmp) && !uTmp.equals(this.cache.getWayPoint())) {
+						if ((new File(profile.dataDir + iTmp.toLowerCase() + ".xml")).exists()) {
+							warnedForWaypoint = uTmp; // before MessageBox cause Multithread DataChangeEvents
+							// filename is LowerCase
+							new MessageBox("Warning :", uTmp + "\n" + MyLocale.getMsg(275, "Waypoint already exists!"), MessageBox.OKB).execute();
+							// revert waypointname
+							inpWaypoint.setText(this.cache.getWayPoint());
+						}
+					}
+				} else {
+					// first DataChangeEvent is fired by Klick into (after reload).
+					// that really didn't change anything
+					evWaypointChanged = true;
+				}
+				// FIXME: if name was changed, we should rename the waypoint.xml file. how? where?
+			} else if (ev.target == chcType) {
+				createWptName();
+				if (CacheType.isCacheWpt(CacheType.guiSelect2Cw(chcType.selectedIndex))) {
+					activateControl(btnTerr);
+					activateControl(btnDiff);
+					activateControl(chcSize);
+					activateControl(inpOwner);
+					activateControl(inpHidden);
+					activateControl(btnShowBug);
+					activateControl(btnBlack);
+				} else {
+					deactivateControl(btnTerr);
+					deactivateControl(btnDiff);
+					deactivateControl(chcSize);
+					deactivateControl(inpOwner);
+					deactivateControl(inpHidden);
+					deactivateControl(btnShowBug);
+					deactivateControl(btnBlack);
+					chcSize.select(0);
+					btnTerr.setText(MyLocale.getMsg(1001, "T") + DTINVALID);
+					btnDiff.setText(MyLocale.getMsg(1000, "D") + DTINVALID);
+				}
+			}
+			// FIXME: check if something was actually changed, since datacachnge events also occur if you just hop through the fileds with the tab key (Why? don't know!)
+			dirtyDetails = true;
+			needsTableUpdate = true;
+		}
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
+			if (ev.target == btnNotes) {
+				dirtyNotes = true; // TODO I think this is redundant, because
+									// the notes are saved separately by the notes screen itself
+				final NotesScreen nsc = new NotesScreen(cache.getCacheDetails(true));
+				nsc.execute(this.getFrame(), Gui.CENTER_FRAME);
+				if (pref.isBigScreen) {
+					waypointNotes.setText(cache.getCacheDetails(true).getCacheNotes());
+				}
+			} else if (ev.target == btnShowMap) {
+				Global.mainTab.SwitchToMovingMap(cache.pos, true);
+			} else if (ev.target == btnShowBug) {
+				// InfoScreen is = new InfoScreen(thisCache.Travelbugs.toHtml(),
+				// "Travelbugs",
+				// false, pref);
+				// is.execute();
+				final TravelbugInCacheScreen ts = new TravelbugInCacheScreen(cache.getCacheDetails(true).Travelbugs.toHtml(), "Travelbugs");
+				ts.execute(this.getFrame(), Gui.CENTER_FRAME);
+				/*
+				 * not fully implemented
+				 * } else if (ev.target == btnCenter) {
+				 * final CWPoint cp = new CWPoint(cache.LatLon);
+				 * if (cp.isValid()) {
+				 * pref.setCurCentrePt(cp);
+				 * } else {
+				 * final MessageBox tmpMB = new MessageBox(
+				 * MyLocale.getMsg(312, "Error"),
+				 * MyLocale.getMsg(4111, "Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"),
+				 * FormBase.OKB);
+				 * tmpMB.exec();
+				 * }
+				 */
 
-            } else if (ev.target == btnAddDateTime) {
-                dirtyNotes = true;
+			} else if (ev.target == btnAddDateTime) {
+				dirtyNotes = true;
 
-                final StringBuffer newNote = new StringBuffer();
-                newNote.append(cache.getCacheDetails(true).getCacheNotes());
+				final StringBuffer newNote = new StringBuffer();
+				newNote.append(cache.getCacheDetails(true).getCacheNotes());
 
-                final Time dtm = new Time();
-                dtm.getTime();
-                dtm.setFormat("E dd.MM.yyyy '/' HH:mm");
+				final Time dtm = new Time();
+				dtm.getTime();
+				dtm.setFormat("E dd.MM.yyyy '/' HH:mm");
 
-                if (newNote.length() > 0) {
-                    newNote.append('\n');
-                }
-                newNote.append(dtm.toString()).append('\n');
+				if (newNote.length() > 0) {
+					newNote.append('\n');
+				}
+				newNote.append(dtm.toString()).append('\n');
 
-                cache.getCacheDetails(true).setCacheNotes(newNote.toString());
-                //FIXME: better use saveDirtyWaypoint()?
-                cache.save();
-            } else if (ev.target == btnAddPicture) {
-                cache.getCacheDetails(true).addUserImage(profile);
-            } else if (ev.target == btnBlack) {
-                if (cache.is_black()) {
-                    cache.setBlack(false);
-                    btnBlack.image = imgBlackNo;
-                } else {
-                    cache.setBlack(true);
-                    btnBlack.image = imgBlack;
-                }
-                blackStatus = cache.is_black();
-                cache.setAttributesToAddiWpts();
-                btnBlack.repaintNow();
-                dirtyDetails = true;
-                blackStatusChanged = true;
-            } else if (ev.target == btnNewWpt) {
-                final CacheHolder ch = new CacheHolder();
-                ch.setLatLon(cache.getLatLon());
-                ch.pos = new CWPoint(cache.pos);
-                ch.setType(CacheType.CW_TYPE_STAGE);
-                ch.setHard(CacheTerrDiff.CW_DT_UNSET);
-                ch.setTerrain(CacheTerrDiff.CW_DT_UNSET);
-                ch.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
-                Global.mainTab.newWaypoint(ch);
-            } else if (ev.target == btnGoto) {
-                // FIXME: if something changed saveDirtyWaypoint();
-                Global.mainTab.gotoP.setDestinationAndSwitch(cache);
-            } else if (ev.target == btnCoordinates) {
-                CWPoint coords = new CWPoint(btnCoordinates.getText(), TransformCoordinates.CW);
-                if(Vm.isMobile()){
-                    InputScreen InScr = new InputScreen(TransformCoordinates.CW, true);
-                    if (coords.isValid())	InScr.setCoords(coords);
-                        else InScr.setCoords(new CWPoint(0,0));
-                    if (InScr.execute(null, CellConstants.TOP) == FormBase.IDOK)
-                    {
-                        dirtyDetails = true;
-                        coords = InScr.getCoords();
-                        Global.getProfile().notifyUnsavedChanges(!cache.pos.toString().equals(coords.toString()));
-                        cache.pos.set(coords);
-                        btnCoordinates.setText(coords.toString());
-                        cache.setLatLon(coords.toString());
-                        // If the current centre is valid, calculate the distance and bearing to it
-                        final CWPoint centre = Global.getPref().getCurCentrePt();
-                        if (centre.isValid()) {
-                            cache.calcDistance(centre); // todo perhaps sortTable
-                        }
-                    }
-                }else{
-                    final CoordsScreen cs = new CoordsScreen(true);
-                    cs.setFields(coords, TransformCoordinates.CW);
-                    if (cs.execute() == FormBase.IDOK) {
-                        dirtyDetails = true;
-                        coords = cs.getCoords();
-                        Global.getProfile().notifyUnsavedChanges(!cache.pos.toString().equals(coords.toString()));
-                        cache.pos.set(coords);
-                        btnCoordinates.setText(coords.toString());
-                        cache.setLatLon(coords.toString());
-                        // If the current centre is valid, calculate the distance and bearing to it
-                        final CWPoint centre = Global.getPref().getCurCentrePt();
-                        if (centre.isValid()) {
-                            cache.calcDistance(centre); // todo perhaps sortTable
-                        }
-                    }
-                }
-            } else if (ev.target == btnFoundDate) {
-            	int msgNr=318; // normal found
-            	if (cache.getType() == CacheType.CW_TYPE_WEBCAM) { msgNr=361;}
-            	else if (cache.getType() == CacheType.CW_TYPE_EVENT 
-            			|| cache.getType() == CacheType.CW_TYPE_MEGA_EVENT) { msgNr=355;}
-                // DateChooser.dayFirst=true;
-                final DateTimeChooser dc = new DateTimeChooser(Vm.getLocale());
-                dc.title = MyLocale.getMsg(328, "Date found");
-                dc.setPreferredSize(240, 240);
-                String foundDate = chcStatus.getText();
-                if (foundDate.startsWith(MyLocale.getMsg(msgNr, "Found") + " ")) {
-                    foundDate = foundDate.substring(MyLocale.getMsg(msgNr, "Found").length() + 1);
-                }
-                else if (foundDate.endsWith(MyLocale.getMsg(319, "not Found"))) {
-                    foundDate = foundDate.substring(0,foundDate.length()-MyLocale.getMsg(319, "not Found").length());
-                    dc.title=MyLocale.getMsg(330,"Date Not Found");
-                }
-                foundDate=foundDate.trim();
-                if (foundDate.length()>0 && foundDate.indexOf('-')>0) { //Don't try and parse empty date
-                    final Time t = new Time();
-                    try {
-                        t.parse(foundDate, "y-M-d H:m");
-                    } catch (IllegalArgumentException e) {
-                        try {
-                            t.parse(foundDate, "y-M-d");
-                        } catch (IllegalArgumentException e1) {
-                            Global.getPref().log("No parsable date given - should not appear ("+foundDate+")", e1, true);
-                        }
-                    }
+				cache.getCacheDetails(true).setCacheNotes(newNote.toString());
+				// FIXME: better use saveDirtyWaypoint()?
+				cache.save();
+			} else if (ev.target == btnAddPicture) {
+				cache.getCacheDetails(true).addUserImage(profile);
+			} else if (ev.target == btnBlack) {
+				if (cache.is_black()) {
+					cache.setBlack(false);
+					btnBlack.image = imgBlackNo;
+				} else {
+					cache.setBlack(true);
+					btnBlack.image = imgBlack;
+				}
+				blackStatus = cache.is_black();
+				cache.setAttributesToAddiWpts();
+				btnBlack.repaintNow();
+				dirtyDetails = true;
+				blackStatusChanged = true;
+			} else if (ev.target == btnNewWpt) {
+				final CacheHolder ch = new CacheHolder();
+				ch.setLatLon(cache.getLatLon());
+				ch.pos = new CWPoint(cache.pos);
+				ch.setType(CacheType.CW_TYPE_STAGE);
+				ch.setHard(CacheTerrDiff.CW_DT_UNSET);
+				ch.setTerrain(CacheTerrDiff.CW_DT_UNSET);
+				ch.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
+				Global.mainTab.newWaypoint(ch);
+			} else if (ev.target == btnGoto) {
+				// FIXME: if something changed saveDirtyWaypoint();
+				Global.mainTab.gotoP.setDestinationAndSwitch(cache);
+			} else if (ev.target == btnCoordinates) {
+				CWPoint coords = new CWPoint(btnCoordinates.getText(), TransformCoordinates.CW);
+				if (Vm.isMobile()) {
+					InputScreen InScr = new InputScreen(TransformCoordinates.CW, true);
+					if (coords.isValid())
+						InScr.setCoords(coords);
+					else
+						InScr.setCoords(new CWPoint(0, 0));
+					if (InScr.execute(null, CellConstants.TOP) == FormBase.IDOK) {
+						dirtyDetails = true;
+						coords = InScr.getCoords();
+						Global.getProfile().notifyUnsavedChanges(!cache.pos.toString().equals(coords.toString()));
+						cache.pos.set(coords);
+						btnCoordinates.setText(coords.toString());
+						cache.setLatLon(coords.toString());
+						// If the current centre is valid, calculate the distance and bearing to it
+						final CWPoint centre = Global.getPref().getCurCentrePt();
+						if (centre.isValid()) {
+							cache.calcDistance(centre); // todo perhaps sortTable
+						}
+					}
+				} else {
+					final CoordsScreen cs = new CoordsScreen(true);
+					cs.setFields(coords, TransformCoordinates.CW);
+					if (cs.execute() == FormBase.IDOK) {
+						dirtyDetails = true;
+						coords = cs.getCoords();
+						Global.getProfile().notifyUnsavedChanges(!cache.pos.toString().equals(coords.toString()));
+						cache.pos.set(coords);
+						btnCoordinates.setText(coords.toString());
+						cache.setLatLon(coords.toString());
+						// If the current centre is valid, calculate the distance and bearing to it
+						final CWPoint centre = Global.getPref().getCurCentrePt();
+						if (centre.isValid()) {
+							cache.calcDistance(centre); // todo perhaps sortTable
+						}
+					}
+				}
+			} else if (ev.target == btnFoundDate) {
+				int msgNr = 318; // normal found
+				if (cache.getType() == CacheType.CW_TYPE_WEBCAM) {
+					msgNr = 361;
+				} else if (cache.getType() == CacheType.CW_TYPE_EVENT || cache.getType() == CacheType.CW_TYPE_MEGA_EVENT) {
+					msgNr = 355;
+				}
+				// DateChooser.dayFirst=true;
+				final DateTimeChooser dc = new DateTimeChooser(Vm.getLocale());
+				dc.title = MyLocale.getMsg(328, "Date found");
+				dc.setPreferredSize(240, 240);
+				String foundDate = chcStatus.getText();
+				if (foundDate.startsWith(MyLocale.getMsg(msgNr, "Found") + " ")) {
+					foundDate = foundDate.substring(MyLocale.getMsg(msgNr, "Found").length() + 1);
+				} else if (foundDate.endsWith(MyLocale.getMsg(319, "not Found"))) {
+					foundDate = foundDate.substring(0, foundDate.length() - MyLocale.getMsg(319, "not Found").length());
+					dc.title = MyLocale.getMsg(330, "Date Not Found");
+				}
+				foundDate = foundDate.trim();
+				if (foundDate.length() > 0 && foundDate.indexOf('-') > 0) { // Don't try and parse empty date
+					final Time t = new Time();
+					try {
+						t.parse(foundDate, "y-M-d H:m");
+					} catch (IllegalArgumentException e) {
+						try {
+							t.parse(foundDate, "y-M-d");
+						} catch (IllegalArgumentException e1) {
+							Global.getPref().log("No parsable date given - should not appear (" + foundDate + ")", e1, true);
+						}
+					}
 
-                    dc.reset(t);
-                }
-                // We can create a not found log with date in two ways:
-                //   1) Exiting the date-time dialog by clicking the x if the status is empty (somewhat
-                //      non-standard but quick and dirty)
-                //   2) Exiting the date-time dialog by clicking the tick. Then we check whether
-                //      the status field was preset with the not-found text. If yes it stays a not found
-                //      but the date is prepended
-                //TODO: The functions for extracting the date and the found/not-found text should not be in the GUI
-                int retCode=dc.execute();
-                if (retCode == ewe.ui.FormBase.IDOK && !chcStatus.getText().endsWith(MyLocale.getMsg(319, "not Found"))) {
-                    chcStatus.setText(MyLocale.getMsg(msgNr, "Found") + " "
-                                    + Convert.toString(dc.year) + "-"
-                                    + MyLocale.formatLong(dc.month, "00") + "-"
-                                    + MyLocale.formatLong(dc.day, "00") + " "
-                                    + dc.time);
-                    dirtyDetails = true;
-                }
-                else if (chcStatus.getText().length()==0 ||
-                		(retCode==ewe.ui.FormBase.IDOK && chcStatus.getText().endsWith(MyLocale.getMsg(319, "not Found")) )) {
-                    chcStatus.setText(Convert.toString(dc.year) + "-"
-                            + MyLocale.formatLong(dc.month, "00") + "-"
-                            + MyLocale.formatLong(dc.day, "00") + " "
-                            + dc.time + " "
-                            + MyLocale.getMsg(319, "not Found")
-                            );
-                    dirtyDetails = true;
-                }
-            } else if (ev.target == btnHiddenDate) {
-                DateChooser.dayFirst = true;
-                final DateChooser dc = new DateChooser(Vm.getLocale());
-                dc.title = MyLocale.getMsg(329, "Hidden date");
-                dc.setPreferredSize(240, 240);
-                if (inpHidden.getText().length() == 10)
-                    try {
-                        dc.setDate(new Time(Convert.parseInt(inpHidden
-                                .getText().substring(8)), Convert
-                                .parseInt(inpHidden.getText().substring(5, 7)),
-                                Convert.parseInt(inpHidden.getText().substring(
-                                        0, 4))));
-                    } catch (NumberFormatException e) {
-                        dc.reset(new Time());
-                    }
-                if (dc.execute() == ewe.ui.FormBase.IDOK) {
-                    inpHidden.setText(Convert.toString(dc.year) + "-"
-                            + MyLocale.formatLong(dc.month, "00") + "-"
-                            + MyLocale.formatLong(dc.day, "00"));
-                    dirtyDetails = true;
-                    // profile.hasUnsavedChanges=true;
-                }
-            } else if (ev.target == btnTerr) {
-                int returnValue;
-                final TerrDiffForm tdf = new TerrDiffForm(true,
-                        decodeTerrDiff(btnTerr,
-                                MyLocale.getMsg(1001, "T"),
-                                CacheType.isCacheWpt(CacheType.guiSelect2Cw(chcType.getInt()))
-                            )
-                        );
-                returnValue = tdf.execute();
-                if (returnValue == 1) {
-                    btnTerr.setText(MyLocale.getMsg(1001, "T") + ": " + CacheTerrDiff.longDT(tdf.getDT()));
-                    dirtyDetails = true;
-                }
-            } else if (ev.target == btnDiff) {
-                int returnValue;
-                final TerrDiffForm tdf = new TerrDiffForm(false,
-                        decodeTerrDiff(btnDiff,
-                                MyLocale.getMsg(1001, "D"),
-                                CacheType.isCacheWpt(CacheType.guiSelect2Cw(chcType.getInt()))
-                            )
-                        );
+					dc.reset(t);
+				}
+				// We can create a not found log with date in two ways:
+				// 1) Exiting the date-time dialog by clicking the x if the status is empty (somewhat
+				// non-standard but quick and dirty)
+				// 2) Exiting the date-time dialog by clicking the tick. Then we check whether
+				// the status field was preset with the not-found text. If yes it stays a not found
+				// but the date is prepended
+				// TODO: The functions for extracting the date and the found/not-found text should not be in the GUI
+				int retCode = dc.execute();
+				if (retCode == ewe.ui.FormBase.IDOK && !chcStatus.getText().endsWith(MyLocale.getMsg(319, "not Found"))) {
+					chcStatus.setText(MyLocale.getMsg(msgNr, "Found") + " " + Convert.toString(dc.year) + "-" + MyLocale.formatLong(dc.month, "00") + "-" + MyLocale.formatLong(dc.day, "00") + " " + dc.time);
+					dirtyDetails = true;
+				} else if (chcStatus.getText().length() == 0 || (retCode == ewe.ui.FormBase.IDOK && chcStatus.getText().endsWith(MyLocale.getMsg(319, "not Found")))) {
+					chcStatus.setText(Convert.toString(dc.year) + "-" + MyLocale.formatLong(dc.month, "00") + "-" + MyLocale.formatLong(dc.day, "00") + " " + dc.time + " " + MyLocale.getMsg(319, "not Found"));
+					dirtyDetails = true;
+				}
+			} else if (ev.target == btnHiddenDate) {
+				DateChooser.dayFirst = true;
+				final DateChooser dc = new DateChooser(Vm.getLocale());
+				dc.title = MyLocale.getMsg(329, "Hidden date");
+				dc.setPreferredSize(240, 240);
+				if (inpHidden.getText().length() == 10)
+					try {
+						dc.setDate(new Time(Convert.parseInt(inpHidden.getText().substring(8)), Convert.parseInt(inpHidden.getText().substring(5, 7)), Convert.parseInt(inpHidden.getText().substring(0, 4))));
+					} catch (NumberFormatException e) {
+						dc.reset(new Time());
+					}
+				if (dc.execute() == ewe.ui.FormBase.IDOK) {
+					inpHidden.setText(Convert.toString(dc.year) + "-" + MyLocale.formatLong(dc.month, "00") + "-" + MyLocale.formatLong(dc.day, "00"));
+					dirtyDetails = true;
+					// profile.hasUnsavedChanges=true;
+				}
+			} else if (ev.target == btnTerr) {
+				int returnValue;
+				final TerrDiffForm tdf = new TerrDiffForm(true, decodeTerrDiff(btnTerr, MyLocale.getMsg(1001, "T"), CacheType.isCacheWpt(CacheType.guiSelect2Cw(chcType.getInt()))));
+				returnValue = tdf.execute();
+				if (returnValue == 1) {
+					btnTerr.setText(MyLocale.getMsg(1001, "T") + ": " + CacheTerrDiff.longDT(tdf.getDT()));
+					dirtyDetails = true;
+				}
+			} else if (ev.target == btnDiff) {
+				int returnValue;
+				final TerrDiffForm tdf = new TerrDiffForm(false, decodeTerrDiff(btnDiff, MyLocale.getMsg(1001, "D"), CacheType.isCacheWpt(CacheType.guiSelect2Cw(chcType.getInt()))));
 
-                returnValue = tdf.execute();
-                if (returnValue == 1) {
-                    btnDiff.setText(MyLocale.getMsg(1000, "D") + ": "
-                            + CacheTerrDiff.longDT(tdf.getDT()));
-                    dirtyDetails = true;
-                }
-            }
-            ev.consumed = true;
-        }
-    }
+				returnValue = tdf.execute();
+				if (returnValue == 1) {
+					btnDiff.setText(MyLocale.getMsg(1000, "D") + ": " + CacheTerrDiff.longDT(tdf.getDT()));
+					dirtyDetails = true;
+				}
+			}
+			ev.consumed = true;
+		}
+	}
 
 	/** allow user input on control item */
 	private void activateControl(final Control ctrl) {
@@ -751,39 +713,39 @@
 	}
 
 	public void saveDirtyWaypoint() {
-		//FIXME: here we should check if the data is now different from what it used to be when calling the details panel instead of relying on dirty flags
-		//FIXME: take care of renaming waypoints
-		//FIXME: add method to convert back text of difficulty & terrain buttons
-		//FIXME: check if manual changes have converted a cache from incomplete to complete
+		// FIXME: here we should check if the data is now different from what it used to be when calling the details panel instead of relying on dirty flags
+		// FIXME: take care of renaming waypoints
+		// FIXME: add method to convert back text of difficulty & terrain buttons
+		// FIXME: check if manual changes have converted a cache from incomplete to complete
 
 		// We have to update two objects: thisCache (a CacheHolderDetail) which
 		// contains
 		// the full cache which will be written to the cache.xml file AND
 		// the CacheHolder object which sits in cacheDB
-		//FIXME: so how do we do this??
+		// FIXME: so how do we do this??
 
-		int msgNr=318; // normal found
-    	if (cache.getType() == CacheType.CW_TYPE_WEBCAM) { msgNr=361;}
-    	else if (cache.getType() == CacheType.CW_TYPE_EVENT 
-    			|| cache.getType() == CacheType.CW_TYPE_MEGA_EVENT) { msgNr=355;}
+		int msgNr = 318; // normal found
+		if (cache.getType() == CacheType.CW_TYPE_WEBCAM) {
+			msgNr = 361;
+		} else if (cache.getType() == CacheType.CW_TYPE_EVENT || cache.getType() == CacheType.CW_TYPE_MEGA_EVENT) {
+			msgNr = 355;
+		}
 
 		// Strip the found message if the status contains a date
-		if (chcStatus.getText().startsWith(MyLocale.getMsg(msgNr, "Found")) &&
-			chcStatus.getText().length() >= MyLocale.getMsg(msgNr, "Found").length() + 11) {
+		if (chcStatus.getText().startsWith(MyLocale.getMsg(msgNr, "Found")) && chcStatus.getText().length() >= MyLocale.getMsg(msgNr, "Found").length() + 11) {
 			cache.setCacheStatus(chcStatus.getText().substring(MyLocale.getMsg(msgNr, "Found").length() + 1));
 		} else {
 			cache.setCacheStatus(chcStatus.getText());
 		}
 
-		if (chcStatus.getText().startsWith(MyLocale.getMsg(msgNr, "Found")) ||
-			(cache.getCacheStatus().length() == 10 || cache.getCacheStatus().length() == 16) && cache.getCacheStatus().charAt(4) == '-') {
+		if (chcStatus.getText().startsWith(MyLocale.getMsg(msgNr, "Found")) || (cache.getCacheStatus().length() == 10 || cache.getCacheStatus().length() == 16) && cache.getCacheStatus().charAt(4) == '-') {
 			// Use same heuristic condition as in setDetails(CacheHolder) to
 			// determine, if this
 			// cache
 			// has to considered as found.
 			cache.setFound(true);
-		}
-		else cache.setFound(false);
+		} else
+			cache.setFound(false);
 
 		if (!cache.isAddiWpt()) {
 			cache.setCacheOwner(inpOwner.getText().trim());
@@ -791,13 +753,7 @@
 		cache.setOwned(cache.getCacheStatus().equals(MyLocale.getMsg(320, "Owner")));
 		// Avoid setting is_owned if alias is empty and username is empty
 		if (!cache.is_owned()) {
-			cache.setOwned(
-					(!pref.myAlias.equals("") &&
-						pref.myAlias.equals(cache.getCacheOwner()))
-					||
-					(!pref.myAlias2.equals("") &&
-						pref.myAlias2.equals(cache.getCacheOwner()))
-					);
+			cache.setOwned((!pref.myAlias.equals("") && pref.myAlias.equals(cache.getCacheOwner())) || (!pref.myAlias2.equals("") && pref.myAlias2.equals(cache.getCacheOwner())));
 		}
 		cache.setBlack(blackStatus);
 		final String oldWaypoint = cache.getWayPoint();
@@ -833,51 +789,57 @@
 		 * - the cachetype changed from addi->normal or from normal->addi
 		 * - the old cachetype or the new cachetype were 'addi' and the waypointname has changed
 		 */
-		if (CacheType.isAddiWpt(cache.getType()) != CacheType.isAddiWpt(oldType) ||
-			((CacheType.isAddiWpt(cache.getType()) || CacheType.isAddiWpt(oldType)) && !cache.getWayPoint().equals(oldWaypoint))) {
+		if (CacheType.isAddiWpt(cache.getType()) != CacheType.isAddiWpt(oldType) || ((CacheType.isAddiWpt(cache.getType()) || CacheType.isAddiWpt(oldType)) && !cache.getWayPoint().equals(oldWaypoint))) {
 			// If we changed the type to addi, check that a parent exists
-			//FIXME: if cache was renamed we need to rebuild CacheDB.hashDB first
+			// FIXME: if cache was renamed we need to rebuild CacheDB.hashDB first
 			profile.buildReferences();
 		} else {
 			// set status also on addi wpts
 			cache.setAttributesToAddiWpts();
 		}
 		if (!cache.isAddiWpt()) {
-			cache.setHard(decodeTerrDiff(btnDiff,MyLocale.getMsg(1000, "D"),cache.isCacheWpt()));
-			cache.setTerrain(decodeTerrDiff(btnTerr,MyLocale.getMsg(1001, "T"),cache.isCacheWpt()));
+			cache.setHard(decodeTerrDiff(btnDiff, MyLocale.getMsg(1000, "D"), cache.isCacheWpt()));
+			cache.setTerrain(decodeTerrDiff(btnTerr, MyLocale.getMsg(1001, "T"), cache.isCacheWpt()));
 		}
 		dirtyNotes = false;
 		dirtyDetails = false;
 		needsTableUpdate = false;
 		cache.getCacheDetails(false).hasUnsavedChanges = true;
-		if (!oldWaypoint.equals(cache.getWayPoint())){
-		 // Delete old XML - File
-			cache.getCacheDetails(false).deleteFile(Global.getProfile().dataDir+oldWaypoint+".xml");
+		if (!oldWaypoint.equals(cache.getWayPoint())) {
+			// Delete old XML - File
+			cache.getCacheDetails(false).deleteFile(Global.getProfile().dataDir + oldWaypoint + ".xml");
 		}
 	}
 
 	/**
 	 * convert the string displayed in the terrain in difficulty buttons to a byte for intrernal use<br>
 	 * assumes that the relevant information will at positions 3 and 5 in a 0 indexed string
-	 * @param button button control to get the text from
-	 * @param td localized string for abbreviation of terrain or difficulty
-	 * @param isCache true if waypoint is a cache, false for addis and custom
+	 * 
+	 * @param button
+	 *            button control to get the text from
+	 * @param td
+	 *            localized string for abbreviation of terrain or difficulty
+	 * @param isCache
+	 *            true if waypoint is a cache, false for addis and custom
 	 * @return 0 for additional or custum waypoints, -1 for caches if td is not valid, parsed byte otherwise
 	 */
 	private byte decodeTerrDiff(mButton button, String td, boolean isCache) {
 		// terrain and difficulty are always unset for non cache waypoints
-		if (! isCache) return CacheTerrDiff.CW_DT_UNSET;
+		if (!isCache)
+			return CacheTerrDiff.CW_DT_UNSET;
 
 		// cut off beginning of string
-		String buttonText = button.getText().substring(td.length()+2);
+		String buttonText = button.getText().substring(td.length() + 2);
 		// we now should have a string of length 3
-		if (buttonText.length() != 3) return -1;
+		if (buttonText.length() != 3)
+			return -1;
 
 		final StringBuffer tdv = new StringBuffer(2);
-		buttonText=tdv.append(buttonText.charAt(0)).append(buttonText.charAt(2)).toString();
+		buttonText = tdv.append(buttonText.charAt(0)).append(buttonText.charAt(2)).toString();
 
 		// unset value is invalid
-		if ("--".equals(buttonText)) return CacheTerrDiff.CW_DT_ERROR;
+		if ("--".equals(buttonText))
+			return CacheTerrDiff.CW_DT_ERROR;
 
 		return Byte.parseByte(buttonText);
 	}
@@ -887,18 +849,14 @@
 		private final DispPanel disp = new DispPanel();
 		private final mButton btCancel;
 
-
 		TravelbugInCacheScreen(String text, String title) {
 			super();
 			this.setTitle(title);
 			this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
 			disp.setHtml(text);
-			final ScrollBarPanel sbp = new MyScrollBarPanel(disp,
-					ScrollablePanel.NeverShowHorizontalScrollers);
+			final ScrollBarPanel sbp = new MyScrollBarPanel(disp, ScrollablePanel.NeverShowHorizontalScrollers);
 			this.addLast(sbp);
-			this.addLast(
-					btCancel = new mButton(MyLocale.getMsg(3000, "Close")),
-					CellConstants.DONTSTRETCH, CellConstants.FILL);
+			this.addLast(btCancel = new mButton(MyLocale.getMsg(3000, "Close")), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		}
 
 		public void onEvent(Event ev) {
@@ -917,10 +875,8 @@
 
 			DispPanel() {
 				super();
-				tbMenuItems[0] = mnuPickupTB = new MenuItem(MyLocale.getMsg(
-						6016, "Pick up Travelbug"));
-				tbMenuItems[1] = mnuDropTB = new MenuItem(MyLocale.getMsg(6017,
-						"Drop Travelbug"));
+				tbMenuItems[0] = mnuPickupTB = new MenuItem(MyLocale.getMsg(6016, "Pick up Travelbug"));
+				tbMenuItems[1] = mnuDropTB = new MenuItem(MyLocale.getMsg(6017, "Drop Travelbug"));
 				mnuPopup = new Menu(tbMenuItems, "");
 			}
 
@@ -946,8 +902,7 @@
 						tbjList = new TravelbugJourneyList();
 						tbjList.readTravelbugsFile();
 						// Add the tb to this list
-						tbjList.addTbPickup(tb, Global.getProfile().name,
-								cache.getWayPoint());
+						tbjList.addTbPickup(tb, Global.getProfile().name, cache.getWayPoint());
 						tbjList.saveTravelbugsFile();
 						setHtml(cache.getCacheDetails(true).Travelbugs.toHtml());
 						repaint();
@@ -991,8 +946,7 @@
 			resizable = false;
 			setTitle(MyLocale.getMsg(31415, "D & T"));
 
-			addNext(new mLabel(terrain ? MyLocale.getMsg(31415, "Terrain")
-					: MyLocale.getMsg(31415, "Difficulty")));
+			addNext(new mLabel(terrain ? MyLocale.getMsg(31415, "Terrain") : MyLocale.getMsg(31415, "Difficulty")));
 			addLast(mcDT);
 			addButton(btnOk);
 			addButton(btnCancel);

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2011-07-01 08:11:00 UTC (rev 3033)
+++ trunk/src/CacheWolf/MainTab.java	2011-07-01 10:57:57 UTC (rev 3034)
@@ -145,11 +145,13 @@
 		c.iconize(new Image("goto" + imagesize + ".gif"), true);
 		nav.setGotoPanel(gotoP);
 
-		c = this.addCard(mapP = new ewe.ui.CellPanel(), MyLocale.getMsg(347, "Show map"), null);
-		MAP_CARD = this.cardPanel.cards.size() - 1;
-		c.iconize(new Image("globe_small" + imagesize + ".gif"), true);
+		if (pref.isBigScreen || !pref.useRadar) {
+			c = this.addCard(mapP = new ewe.ui.CellPanel(), MyLocale.getMsg(347, "Show map"), null);
+			MAP_CARD = this.cardPanel.cards.size() - 1;
+			c.iconize(new Image("globe_small" + imagesize + ".gif"), true);
+		}
 
-		if (pref.isBigScreen) {
+		if (pref.isBigScreen || pref.useRadar) {
 			c = this.addCard(radarP, "Radar", null);
 			RADAR_CARD = this.cardPanel.cards.size() - 1;
 			radarP.setMainTab(this);

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2011-07-01 08:11:00 UTC (rev 3033)
+++ trunk/src/CacheWolf/Preferences.java	2011-07-01 10:57:57 UTC (rev 3034)
@@ -82,6 +82,7 @@
 	/** display big icons. default only true for VGA PDAs */
 	// TODO: make this configurable via pref.xml
 	public boolean useBigIcons;
+	public boolean useRadar;
 
 	// ////////////////////////////////////////////////////////////////////////////////////
 	// Constructor
@@ -573,6 +574,11 @@
 			else {
 				useBigIcons = MyLocale.getScreenWidth() >= 400 && Vm.isMobile();
 			}
+			if (atts.getValue("useRadar") != null)
+				useRadar = Boolean.valueOf(atts.getValue("useRadar")).booleanValue();
+			else {
+				useRadar = MyLocale.getScreenWidth() >= 400 && Vm.isMobile();
+			}
 		} else if (name.equals("hintlogpanel")) {
 			logsPerPage = Convert.parseInt(atts.getValue("logsperpage"));
 			String strInitialHintHeight = atts.getValue("initialhintheight");
@@ -821,6 +827,7 @@
 					+ " h=\"" + myAppHeight + "\"" //
 					+ " w=\"" + myAppWidth + "\"" //
 					+ " useBigIcons=\"" + useBigIcons + "\"" //
+					+ " useRadar=\"" + useRadar + "\"" //
 					+ " />\n" //
 
 					+ "    <fixedsip state=\"" + SafeXML.strxmlencode(fixSIP) + "\" />\n" //

Modified: trunk/src/CacheWolf/PreferencesScreen.java
===================================================================
--- trunk/src/CacheWolf/PreferencesScreen.java	2011-07-01 08:11:00 UTC (rev 3033)
+++ trunk/src/CacheWolf/PreferencesScreen.java	2011-07-01 10:57:57 UTC (rev 3034)
@@ -61,8 +61,8 @@
 	mButton cancelB, applyB, brwBt, gpsB;
 	mChoice inpLanguage, inpMetric, inpSpiderUpdates;
 	mInput DataDir, Proxy, ProxyPort, Alias, nLogs, Browser, fontName, fontSize, inpLogsPerPage, inpMaxLogsToSpider, inpPassword, inpGcMemberID, inpUserID;
-	mCheckBox chkAutoLoad, chkShowDeletedImg, chkMenuAtTop, chkTabsAtTop, chkShowStatus, chkHasCloseButton, chkUseBigIcons, chkSynthShort, chkProxyActive, chkDescShowImg, chkAddDetailsToWaypoint, chkAddDetailsToName, chkSetCurrentCentreFromGPSPosition,
-			chkSortingGroupedByCache, chkuseOwnSymbols, chkDebug, chkPM;
+	mCheckBox chkAutoLoad, chkShowDeletedImg, chkMenuAtTop, chkTabsAtTop, chkShowStatus, chkHasCloseButton, chkUseBigIcons, chkUseRadar, chkSynthShort, chkProxyActive, chkDescShowImg, chkAddDetailsToWaypoint, chkAddDetailsToName,
+			chkSetCurrentCentreFromGPSPosition, chkSortingGroupedByCache, chkuseOwnSymbols, chkDebug, chkPM;
 	mTabbedPanel mTab;
 	mChoice chcGarminPort;
 	mLabel lblGarmin;
@@ -194,8 +194,10 @@
 		frmScreen.addLast(chkShowStatus = new mCheckBox(MyLocale.getMsg(628, "Status")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkShowStatus.setState(pref.showStatus);
 		chkShowStatus.setTag(INSETS, new Insets(0, 0, 2, 0));
-		frmScreen.addLast(chkUseBigIcons = new mCheckBox("use big Icons"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		frmScreen.addNext(chkUseBigIcons = new mCheckBox("use big Icons"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkUseBigIcons.setState(pref.useBigIcons);
+		frmScreen.addLast(chkUseRadar = new mCheckBox("Radartab on small screen"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		chkUseRadar.setState(pref.useRadar);
 		pnlDisplay.addLast(frmScreen, CellConstants.HSTRETCH, CellConstants.FILL);
 
 		Frame frmImages = new Frame();
@@ -358,6 +360,7 @@
 				pref.showStatus = chkShowStatus.getState();
 				pref.hasCloseButton = chkHasCloseButton.getState();
 				pref.useBigIcons = chkUseBigIcons.getState();
+				pref.useRadar = chkUseRadar.getState();
 				pref.travelbugColMap = tccBugs.getSelectedCols();
 				pref.listColMap = tccList.getSelectedCols();
 				pref.descShowImg = chkDescShowImg.getState();

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-07-01 08:11:00 UTC (rev 3033)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-07-01 10:57:57 UTC (rev 3034)
@@ -2770,8 +2770,10 @@
 				}
 			}
 			infB.setInfo(oldInfoBox);
-			if (exBugWrong)
-				pref.log("[SpiderGC.java:getBugs]check TBs bugExStart / bugExEnd! blockLength = " + blockLength, null);
+			if (exBugWrong) {
+				if (blockLength > 200)
+					pref.log("[SpiderGC.java:getBugs]check TBs bugExStart / bugExEnd! blockLength = " + blockLength + " for " + chD.URL, null);
+			}
 		} else {
 			pref.log("[SpiderGC.java:getBugs]check TBs blockExStart / blockExEnd! ", null);
 		}



From araber95 at mail.berlios.de  Fri Jul  1 05:46:08 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Fri,  1 Jul 2011 05:46:08 PM +0200
Subject: [Cachewolf-svn] r3035 - trunk/res_noewe/webmapservices
Message-ID: <20110701154608.9D4694813EE@sheep.berlios.de>

Author: araber95
Date: 2011-07-01 17:46:08 +0200 (Fri, 01 Jul 2011)
New Revision: 3035

Modified:
   trunk/res_noewe/webmapservices/de_t_itc.wms
Log:
EPSG changed to 4326 (3146x did not work for Saarland)

Modified: trunk/res_noewe/webmapservices/de_t_itc.wms
===================================================================
--- trunk/res_noewe/webmapservices/de_t_itc.wms	2011-07-01 10:57:57 UTC (rev 3034)
+++ trunk/res_noewe/webmapservices/de_t_itc.wms	2011-07-01 15:46:08 UTC (rev 3035)
@@ -5,8 +5,8 @@
 MainUrl:            http://osmwms.itc-halle.de/maps/osmfree?
 ServiceTypeUrlPart: SERVICE=WMS
 VersionUrlPart:     VERSION=1.1.1
-CoordinateReferenceSystemCacheWolf:  31466 31467 31468 31469
-CoordinateReferenceSystemUrlPart: SRS=EPSG:31466 SRS=EPSG:31467 SRS=EPSG:31468 SRS=EPSG:31469 
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
 RequestUrlPart:     REQUEST=GetMap
 #LayersUrlPart:     LAYERS=osmwms|OpenStreetMap-WMS||
 #LayersUrlPart:     LAYERS=grenzen|Administrative Grenzen||



From araber95 at mail.berlios.de  Sun Jul  3 01:03:39 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Sun,  3 Jul 2011 01:03:39 PM +0200
Subject: [Cachewolf-svn] r3036 - trunk/res_noewe/webmapservices
Message-ID: <20110703110339.BE16E480A1F@sheep.berlios.de>

Author: araber95
Date: 2011-07-03 13:03:39 +0200 (Sun, 03 Jul 2011)
New Revision: 3036

Added:
   trunk/res_noewe/webmapservices/de-sl-t.wms
Log:
wms for Saarland added (thx to Teleskopix)

Added: trunk/res_noewe/webmapservices/de-sl-t.wms
===================================================================
--- trunk/res_noewe/webmapservices/de-sl-t.wms	                        (rev 0)
+++ trunk/res_noewe/webmapservices/de-sl-t.wms	2011-07-03 11:03:39 UTC (rev 3036)
@@ -0,0 +1,38 @@
+TakenFromUrl:       http://geoportal.lkvk.saarland.de/freewms/uebersichtsl?
+GetCapabilitiesUrl: http://geoportal.lkvk.saarland.de/freewms/uebersichtsl?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:               de.Saarland t
+MapType:                        topo
+MainUrl:            http://geoportal.lkvk.saarland.de/freewms/uebersichtsl?
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  31466 31467
+CoordinateReferenceSystemUrlPart: SRS=EPSG:31466 SRS=EPSG:31467
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=Saarland|SL_UEBERSICHT||
+#LayersUrlPart:     LAYERS=landesflaeche|Landesflaeche||
+#LayersUrlPart:     LAYERS=gruenland|Gruenland||
+#LayersUrlPart:     LAYERS=industrie|Industrie||
+#LayersUrlPart:     LAYERS=wald|Wald||
+#LayersUrlPart:     LAYERS=sonderkultur|Sonderkulturen||
+#LayersUrlPart:     LAYERS=ortslagen|Ortslagen||
+#LayersUrlPart:     LAYERS=gewaesser|Gewaesser||
+#LayersUrlPart:     LAYERS=weg|Wege||
+#LayersUrlPart:     LAYERS=strasse|Strassen||
+#LayersUrlPart:     LAYERS=gemeindestrasse|Gemeindestrassen||
+#LayersUrlPart:     LAYERS=kreisstrasse|Kreisstrassen||
+#LayersUrlPart:     LAYERS=landesstrasse|Landesstrassen||
+#LayersUrlPart:     LAYERS=bundesstrasse|Bundesstrassen||
+#LayersUrlPart:     LAYERS=autobahn|Autobahnen||
+#LayersUrlPart:     LAYERS=bahn|Bahn||
+#LayersUrlPart:     LAYERS=orte|Orte||
+#LayersUrlPart: LAYERS=Saarland,landesflaeche,gruenland,industrie,wald,sonderkultur,ortslagen,gewaesser,weg,strasse,gemeindestrasse,kreisstrasse,landesstrasse,bundesstrasse,autobahn,bahn,orte
+LayersUrlPart:		LAYERS=Saarland
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 49.6445 E 6.3553
+BoundingBoxBottomRightWGS84: N 49.1094 E 7.4138
+#BBox_Mitte: N 49.37695 E 6.88454
+MinScale:   0.2
+MaxScale:   200
+RecommendedScale:    9 2
+ImageFileExtension: .jpg



From araber95 at mail.berlios.de  Wed Jul  6 09:47:05 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Wed,  6 Jul 2011 09:47:05 PM +0200
Subject: [Cachewolf-svn] r3037 - trunk/src/CacheWolf
Message-ID: <20110706194705.99C96480B8A@sheep.berlios.de>

Author: araber95
Date: 2011-07-06 21:47:05 +0200 (Wed, 06 Jul 2011)
New Revision: 3037

Modified:
   trunk/src/CacheWolf/CacheHolder.java
Log:
prevent possible change of cachename on tpl - export

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2011-07-03 11:03:39 UTC (rev 3036)
+++ trunk/src/CacheWolf/CacheHolder.java	2011-07-06 19:47:05 UTC (rev 3037)
@@ -671,14 +671,15 @@
 		varParams.put("STATUS_DATE", getStatusDate());
 		varParams.put("STATUS_TIME", getStatusTime());
 		varParams.put("CACHE_NAME", cacheName);
+		String cn = cacheName;
 		if (codec instanceof AsciiCodec) {
-			cacheName = Exporter.simplifyString(cacheName);
+			cn = Exporter.simplifyString(cacheName);
 		} // use for "NAME"
 		if (badChars != null) {
-			cacheName = badChars.replaceAll(cacheName);
+			cn = badChars.replaceAll(cacheName);
 		} // use for "NAME"
-		varParams.put("NAME", cacheName); // !!! cacheName used twice
-		String shortName = shortenName(cacheName, shortNameLength);
+		varParams.put("NAME", cn);
+		String shortName = shortenName(cn, shortNameLength);
 		varParams.put("SHORTNAME", shortName);
 		varParams.put("TRAVELBUG", (bugs ? "Y" : "N"));
 		if (gm != null)



From araber95 at mail.berlios.de  Thu Jul  7 06:27:23 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Thu,  7 Jul 2011 06:27:23 PM +0200
Subject: [Cachewolf-svn] r3038 - in trunk: res_noewe/webmapservices
	src/CacheWolf
Message-ID: <20110707162723.51717481532@sheep.berlios.de>

Author: araber95
Date: 2011-07-07 18:27:23 +0200 (Thu, 07 Jul 2011)
New Revision: 3038

Modified:
   trunk/res_noewe/webmapservices/de-ni_t50.wms
   trunk/src/CacheWolf/AttributesSelector.java
Log:
1. wms change server for ni
2. showing one attribute less than should be possible.

Modified: trunk/res_noewe/webmapservices/de-ni_t50.wms
===================================================================
--- trunk/res_noewe/webmapservices/de-ni_t50.wms	2011-07-06 19:47:05 UTC (rev 3037)
+++ trunk/res_noewe/webmapservices/de-ni_t50.wms	2011-07-07 16:27:23 UTC (rev 3038)
@@ -1,43 +1,220 @@
-?TakenFromUrl:       http://www.umweltkarten.niedersachsen.de/arcgis/services/Programme/MapServer/WMSServer
-GetCapabilitiesUrl: http://www.umweltkarten.niedersachsen.de/arcgis/services/Programme/MapServer/WMSServer?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
-Name:               de.Niedersachsen t5
+?TakenFromUrl:       http://www.geodaten.niedersachsen.de/
+GetCapabilitiesUrl: http://geoportal.geodaten.niedersachsen.de/geodatenportal/servlet/gtEntryPoint?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:               de.Niedersachsen t50
 MapType:                        topo
-MainUrl:            http://www.umweltkarten.niedersachsen.de/arcgis/services/Programme/MapServer/WMSServer?
+MainUrl:            http://geoportal.geodaten.niedersachsen.de/geodatenportal/servlet/gtEntryPoint?
 ServiceTypeUrlPart: SERVICE=WMS
 VersionUrlPart:     VERSION=1.1.1
 CoordinateReferenceSystemCacheWolf:  31466 31467 31468 31469
 CoordinateReferenceSystemUrlPart: SRS=EPSG:31466 SRS=EPSG:31467 SRS=EPSG:31468 SRS=EPSG:31469 
 RequestUrlPart:     REQUEST=GetMap
-#LayersUrlPart:     LAYERS=0|Gebiete mit gesamtstaatlicher repr?sentativer Bedeutung|2.772396|Infinity
-#LayersUrlPart:     LAYERS=1|Flie?gew?sserschutzsystem Verbindungsgew?sser|2.772396|Infinity
-#LayersUrlPart:     LAYERS=2|Flie?gew?sserschutzsystem Hauptgew?sser und Auen|2.772396|Infinity
-#LayersUrlPart:     LAYERS=3|Moorschutzprogramm Neubewertung|2.772396|Infinity
-#LayersUrlPart:     LAYERS=4|Moorschutzprogramm Teil II|2.772396|Infinity
-#LayersUrlPart:     LAYERS=5|Abgrenzung des Hochmoorkomplexes MSP Teil I|2.772396|Infinity
-#LayersUrlPart:     LAYERS=6|Moorschutzprogramm (MSP) Teil I|2.772396|Infinity
-#LayersUrlPart:     LAYERS=7|Untere  Naturschutzbeh?rden|2.772396|Infinity
-#LayersUrlPart:     LAYERS=8|Naturr?umliche Regionen und Unterregionen DTK50||
-#LayersUrlPart:     LAYERS=9|Naturr?umliche Regionen DTK50||
-#LayersUrlPart:     LAYERS=10|Landesgrenze inkl. 12 Seemeilen-Zone||
-#LayersUrlPart:     LAYERS=11|Landkreise||
-#LayersUrlPart:     LAYERS=12|Ortslagen|99.000000|237.600000
-#LayersUrlPart:     LAYERS=13|Grosse Seen|198.000000|Infinity
-#LayersUrlPart:     LAYERS=14|Gro?e Fl?sse|198.000000|Infinity
-#LayersUrlPart:     LAYERS=15|Orthophoto Farbe|0.0|2.772000
-#LayersUrlPart:     LAYERS=16|DTK 25|2.772396|4.950000
-#LayersUrlPart:     LAYERS=17|TK 50 |4.950396|9.900000
-#LayersUrlPart:     LAYERS=18|TK 100|9.900396|29.700000
-#LayersUrlPart:     LAYERS=19|DTK 500 |29.700396|99.000000
-#LayersUrlPart:     LAYERS=20|Autobahnen||
-#LayersUrlPart:     LAYERS=21|Schrift: Gro?e Orte||
-#LayersUrlPart:     LAYERS=22|Schrift: Kleine Orte||
-LayersUrlPart:     LAYERS=17
+#LayersUrlPart:     LAYERS=map_618|Kartenhintergrund||
+#LayersUrlPart:     LAYERS=map_2501|Kartenhintergrund (grau / transp.)||
+#LayersUrlPart:     LAYERS=layer_3603|Bundesl?ndergrenzen|4989.031178|0.000499
+#LayersUrlPart:     LAYERS=layer_3602|Kreisgrenzen Bund|748.354677|0.000499
+#LayersUrlPart:     LAYERS=layer_3601|Gemeindegrenzen Bund|249.451559|0.000499
+#LayersUrlPart:     LAYERS=layer_3701|?bersichtskarte 1:5000000||
+#LayersUrlPart:     LAYERS=layer_3702|?bersichtskarte 1:2500000|1184.208959|0.000000
+#LayersUrlPart:     LAYERS=layer_3703|?bersichtskarte 1:1000000|592.104481|0.000000
+#LayersUrlPart:     LAYERS=layer_3704|?bersichtskarte 1:500000|296.052238|0.000000
+#LayersUrlPart:     LAYERS=layer_3705|Topogr. Karte 1:100000|59.210446|0.000000
+#LayersUrlPart:     LAYERS=layer_3707|Digit. Topogr. Karte 1:50000|29.605225|0.000000
+#LayersUrlPart:     LAYERS=layer_3708|Digit. Topogr. Karte 1:25000|19.736817|0.000000
+#LayersUrlPart:     LAYERS=layer_3709|Digit. Stra?enkarte 1:10000|5.921047|0.000000
+#LayersUrlPart:     LAYERS=layer_1445|Hausnummern|3.492322|0.000000
+#LayersUrlPart:     LAYERS=layer_3710|Amtliche Karte 1:5000|6.315779|0.000000
+#LayersUrlPart:     LAYERS=layer_3713|Digit. Orthophoto||
+#LayersUrlPart:     LAYERS=layer_3714|?bersichtskarte 1:5000000||
+#LayersUrlPart:     LAYERS=layer_3715|?bersichtskarte 1:2500000|1184.208959|0.000000
+#LayersUrlPart:     LAYERS=layer_3716|?bersichtskarte 1:1000000|592.104481|0.000000
+#LayersUrlPart:     LAYERS=layer_3717|?bersichtskarte 1:500000|296.052240|0.000000
+#LayersUrlPart:     LAYERS=layer_3718|Topogr. Karte 1:100000|59.210446|0.000000
+#LayersUrlPart:     LAYERS=layer_3720|Digit. Topogr. Karte 1:50000|29.605224|0.000000
+#LayersUrlPart:     LAYERS=layer_3721|Digit. Topogr. Karte 1:25000|19.736817|0.000000
+#LayersUrlPart:     LAYERS=layer_3722|Digit. Stra?enkarte 1:10000|5.921045|0.000000
+#LayersUrlPart:     LAYERS=layer_3723|Amtliche Karte 1:5000|6.315781|0.000000
+#LayersUrlPart:     LAYERS=layer_3724|?bersichtskarte 1:5000000||
+#LayersUrlPart:     LAYERS=layer_3725|?bersichtskarte 1:2500000|1184.208959|0.000000
+#LayersUrlPart:     LAYERS=layer_3726|?bersichtskarte 1:1000000|592.104481|0.000000
+#LayersUrlPart:     LAYERS=layer_3727|?bersichtskarte 1:500000|296.052240|0.000000
+#LayersUrlPart:     LAYERS=layer_3728|Topogr. Karte 1:100000|59.210446|0.000000
+#LayersUrlPart:     LAYERS=layer_3730|Digit. Topogr. Karte 1:50000|29.605224|0.000000
+#LayersUrlPart:     LAYERS=layer_3731|Digit. Topogr. Karte 1:25000|19.736817|0.000000
+#LayersUrlPart:     LAYERS=layer_3732|Digit. Stra?enkarte 1:10000|5.921045|0.000000
+#LayersUrlPart:     LAYERS=layer_3733|Amtliche Karte 1:5000|3.947363|0.000000
+#LayersUrlPart:     LAYERS=layer_1487|Geolog. ?bersichtskarte 1: 500000||
+#LayersUrlPart:     LAYERS=layer_1485|Geologische Karte 1:50000|132.582186|0.000000
+#LayersUrlPart:     LAYERS=layer_2102|Tiefenlage der Quart?rbasis 1:500000||
+#LayersUrlPart:     LAYERS=layer_1489|Hochwassergef?hrdg. 1:500000||
+#LayersUrlPart:     LAYERS=layer_1486|Hochwassergef?hrdg. 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1488|Urspr?ngliche Moorverbreitung||
+#LayersUrlPart:     LAYERS=layer_1490|Rohstoffsicherungskarte 1:25000||
+#LayersUrlPart:     LAYERS=layer_1494|Ingenieurgeolog. Karte 1:500000||
+#LayersUrlPart:     LAYERS=layer_1493|Ingenieurgeolog. Karte 1:50000|132.582186|0.000000
+#LayersUrlPart:     LAYERS=layer_1491|Bodenklassen?bersichtskarte von 0m bis 1m|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1492|Bodenklassen?bersichtskarte von 1m bis 2m (n. DIN 18300) 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1542|Bodengro?landschaften 1:500000||
+#LayersUrlPart:     LAYERS=layer_1535|Bodenversiegelung 1:500000||
+#LayersUrlPart:     LAYERS=layer_1533|Bodenlandschaften 1:200000||
+#LayersUrlPart:     LAYERS=layer_1541|Bodentypenkarte 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1537|Standortbezogenes ackerbaul. Ertragspotenzial 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1534|Standorteignung f?r die Beseitigung von Tierk?rpern bei Seuchenz?gen 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1538|Schutzw?rdige B?den 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1539|Bodensch?tzungskarte 1:25000|33.145547|0.000000
+#LayersUrlPart:     LAYERS=layer_1540|Forstliche Standortstypenkarte 1:25000|33.145547|0.000000
+#LayersUrlPart:     LAYERS=layer_1536|Histor. Landnutzung 1:25000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1902|Hydrogeolog. Einheiten 1:500000||
+#LayersUrlPart:     LAYERS=layer_1913|Hydrogeolog. R?ume u. Teilr?ume 1:500000||
+#LayersUrlPart:     LAYERS=layer_1907|Grundwasserleitertypen der oberfl?chennahen Gesteine 1:500000||
+#LayersUrlPart:     LAYERS=layer_1906|Durchl?ssigkeit der oberfl?chennahen Gesteine 1:500000||
+#LayersUrlPart:     LAYERS=layer_1903|Entnahmebedingungen in den Grundwasser f?hrenden Gesteinen 1:500000||
+#LayersUrlPart:     LAYERS=layer_1914|Grundwasserk?rper 1:500000||
+#LayersUrlPart:     LAYERS=layer_1904|Schutzpotenzial der Grundwasser?berdeckung 1:200000||
+#LayersUrlPart:     LAYERS=layer_1908|Versalzung des Grundwassers 1:200000||
+#LayersUrlPart:     LAYERS=layer_1915|Fliessrichtung im Festgestein||
+#LayersUrlPart:     LAYERS=map_802|Grundwasseroberfl?che 1:200000||
+#LayersUrlPart:     LAYERS=layer_1917|Tiefenstufe||
+#LayersUrlPart:     LAYERS=layer_1916|H?hengleichen u. Beschriftung||
+#LayersUrlPart:     LAYERS=map_803|Grundwasseroberfl?che 1:50000||
+#LayersUrlPart:     LAYERS=layer_1922|Tiefenstufe||
+#LayersUrlPart:     LAYERS=layer_1919|H?hengleichen|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1918|H?hengleichen (Beschriftung)|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1613|Erlaubnisse offshore||
+#LayersUrlPart:     LAYERS=layer_1609|Erlaubnisse onshore||
+#LayersUrlPart:     LAYERS=layer_1611|Bewilligungen offshore||
+#LayersUrlPart:     LAYERS=layer_1612|Bewilligungen onshore||
+#LayersUrlPart:     LAYERS=layer_1608|Bergwerksfelder||
+#LayersUrlPart:     LAYERS=layer_1610|Entenschnabel||
+#LayersUrlPart:     LAYERS=layer_1607|Nutzungsbed. oberfl?chennaher Geothermie||
+#LayersUrlPart:     LAYERS=layer_1606|Potenzielle Standorteignung f?r Erdw?rmekollektoren (Einbautiefe 1,2-1,5m) 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1468|Staatsgrenze (12sm-Grenze)||
+#LayersUrlPart:     LAYERS=layer_1469|Grenzpunkte||
+#LayersUrlPart:     LAYERS=layer_1471|Weitere Grenzen u. Linien||
+#LayersUrlPart:     LAYERS=layer_1470|Tiefwasserreede (Zust. NI)||
+#LayersUrlPart:     LAYERS=layer_1472|Grenze Binnenwasserstr.||
+#LayersUrlPart:     LAYERS=layer_1473|Bereich Emsm?ndung (8.4.1960)||
+#LayersUrlPart:     LAYERS=layer_1474|Grenzbereich Emsm?ndung||
+#LayersUrlPart:     LAYERS=layer_1475|Linie Zusatzabkommen||
+#LayersUrlPart:     LAYERS=layer_1476|Gebiet mit nds. Recht||
+#LayersUrlPart:     LAYERS=layer_1477|Wasserpolizeilicher Bereich|997.805697|0.498903
+#LayersUrlPart:     LAYERS=layer_1478|Wasserpolizeil. Grenzen zum K?stenmeer|1995.611394|0.498903
+#LayersUrlPart:     LAYERS=layer_1479|zust?ndige Bundesl?nder|299.341711|0.498903
+#LayersUrlPart:     LAYERS=layer_1480|Grenze Wasser- u. Schifffahrtsdirektionen Nordwest u. Nord||
+#LayersUrlPart:     LAYERS=layer_1481|Nationalpark Nds. Wattenmeer||
+#LayersUrlPart:     LAYERS=layer_3101|Landschaftsschutzgebiet||
+#LayersUrlPart:     LAYERS=layer_3102|Naturpark||
+#LayersUrlPart:     LAYERS=layer_3103|Biosph?renreservat||
+#LayersUrlPart:     LAYERS=layer_3104|Nationalpark||
+#LayersUrlPart:     LAYERS=layer_3105|Vogelschutzgebiet||
+#LayersUrlPart:     LAYERS=layer_3106|Fauna-Flora-Habitat - Gebiet||
+#LayersUrlPart:     LAYERS=layer_3107|Naturschutzgebiet||
+#LayersUrlPart:     LAYERS=layer_3108|Wasserschutzgebiet||
+#LayersUrlPart:     LAYERS=layer_4111|Nationalpark (NLP)||
+#LayersUrlPart:     LAYERS=layer_4110|Biosph?renreservat (BSR)||
+#LayersUrlPart:     LAYERS=layer_4109|Naturschutzgebiet (NSG)||
+#LayersUrlPart:     LAYERS=layer_4108|Naturdenkmal (ND)||
+#LayersUrlPart:     LAYERS=layer_4107|ND in schmaler Laengsausdehnung||
+#LayersUrlPart:     LAYERS=layer_4106|ND kleiner 1 ha||
+#LayersUrlPart:     LAYERS=layer_4105|Landschaftsschutzgebiet (LSG)||
+#LayersUrlPart:     LAYERS=layer_4104|LSG in schmaler L?ngsausdehnung||
+#LayersUrlPart:     LAYERS=layer_4103|Gesch. Landschaftsbestandteil (GLB)||
+#LayersUrlPart:     LAYERS=layer_4102|GLB in schmaler L?ngsausdehnung||
+#LayersUrlPart:     LAYERS=layer_4101|GLB kleiner 1 ha||
+#LayersUrlPart:     LAYERS=layer_3007|Gebietsname und -nummer||
+#LayersUrlPart:     LAYERS=layer_3008|H?chster Schutzzweck/zone||
+#LayersUrlPart:     LAYERS=layer_3009|Priorit?tenprogramm Trinkwasserschutz||
+#LayersUrlPart:     LAYERS=layer_3010|Zuwendungskulisse ELER||
+#LayersUrlPart:     LAYERS=layer_3011|Wasserrahmenrichtlinie: Gesch?tzte Gebiete||
+#LayersUrlPart:     LAYERS=layer_3013|Heilquellenschutzgebiete||
+#LayersUrlPart:     LAYERS=layer_3014|Trinkwasserschutzgebiete||
+#LayersUrlPart:     LAYERS=layer_3012|Trinkwassergewinnungsgeb.||
+#LayersUrlPart:     LAYERS=layer_3405|vorl?ufig gesicherte ?berschwemmungsgebiete||
+#LayersUrlPart:     LAYERS=layer_3401|?berschwemmungsgebiete im Verfahren (Bremen)||
+#LayersUrlPart:     LAYERS=layer_3402|Verordnungsfl?chen||
+#LayersUrlPart:     LAYERS=layer_3404|... geeignet ab 1: 50000|15.839605|0.000000
+#LayersUrlPart:     LAYERS=layer_3403|... geeignet ab 1: 10000|3.168000|0.000000
+#LayersUrlPart:     LAYERS=layer_1482|Feldbl?cke|9.999999|0.000000
+#LayersUrlPart:     LAYERS=layer_1484|Feldblockinseln|9.999999|0.000000
+#LayersUrlPart:     LAYERS=layer_1483|Landschaftselemente|9.999999|0.000000
+#LayersUrlPart:     LAYERS=layer_4201|Potenzielle Wassererosion|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_4202|Potenzielle Winderosion|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1805|Amtsbezirke ?fL|1000000.000002|1.000001
+#LayersUrlPart:     LAYERS=layer_1806|Dorferneuerung|407.859201|0.000000
+#LayersUrlPart:     LAYERS=layer_1809|Neuvermessungsgebiete|407.859201|0.000000
+#LayersUrlPart:     LAYERS=layer_1807|Stand der Flurbereinigung|407.859201|0.000000
+#LayersUrlPart:     LAYERS=layer_1808|Flurbereinigungsgebiete|407.859201|0.000000
+#LayersUrlPart:     LAYERS=layer_2301|LROP (Stand: 2008)|9899.495094|24.945141
+#LayersUrlPart:     LAYERS=layer_2501|ROKK 2005|548.793430|24.944657
+#LayersUrlPart:     LAYERS=layer_2603|Fl?chennutzungsplan|99.780624|0.049890
+#LayersUrlPart:     LAYERS=layer_2602|B-Plan (Umringe)|54.879343|0.049890
+#LayersUrlPart:     LAYERS=layer_2610|Kompensationsfl?chen|54.879343|0.049890
+#LayersUrlPart:     LAYERS=layer_2601|Liegenschaften|14.967094|0.049890
+#LayersUrlPart:     LAYERS=layer_2611|1: Landsch.-?kolog. Raumeinheiten|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2612|2: Wasser|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2613|3: Boden|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2614|4: Luft|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2615|5a: Arten u. Lebensgemeinschaften|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2616|5b: Schutzgebiete|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2617|6: Vielfalt, Eigenart, Sch?nheit|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2618|7: Belastungen, Gef?hrdungen|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2619|7a: Konflikte mit st?dtebaul. Entwicklung|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2620|8: Ma?nahmen und Entwicklung|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2621|Gew?sser 2. Ordnung|54.879343|0.049890
+#LayersUrlPart:     LAYERS=layer_2622|Gew?sser 3. Ordnung|54.879343|0.049890
+#LayersUrlPart:     LAYERS=layer_2606|Renaturierung der Else|54.879343|0.049890
+#LayersUrlPart:     LAYERS=layer_2201|B-Plan Hiddestorf||
+#LayersUrlPart:     LAYERS=map_1702|Regionale Gesch?ftsbereiche||
+#LayersUrlPart:     LAYERS=layer_2912|GB-Grenzen||
+#LayersUrlPart:     LAYERS=layer_2913|GB-Standorte||
+#LayersUrlPart:     LAYERS=map_1703|Stra?enmeistereien||
+#LayersUrlPart:     LAYERS=layer_2910|SM-Grenzen||
+#LayersUrlPart:     LAYERS=layer_2911|SM-Standorte||
+#LayersUrlPart:     LAYERS=map_1704|Autobahnmeistereien||
+#LayersUrlPart:     LAYERS=layer_2908|AM-Grenzen||
+#LayersUrlPart:     LAYERS=layer_2909|AM-Standorte||
+#LayersUrlPart:     LAYERS=layer_2907|sonstige Dienstorte||
+#LayersUrlPart:     LAYERS=layer_1454|Autobahnen||
+#LayersUrlPart:     LAYERS=layer_1455|Bundesstra?en||
+#LayersUrlPart:     LAYERS=layer_1456|Landesstra?en||
+#LayersUrlPart:     LAYERS=layer_1457|Kreisstra?en||
+#LayersUrlPart:     LAYERS=layer_1458|Anschlussstellenbezeichnung|249.451559|0.000000
+#LayersUrlPart:     LAYERS=layer_1459|Anschlussstellennummer||
+#LayersUrlPart:     LAYERS=layer_1460|Netzknoten||
+#LayersUrlPart:     LAYERS=layer_1461|Nullpunkte||
+#LayersUrlPart:     LAYERS=layer_815|Z?hlstellen||
+#LayersUrlPart:     LAYERS=layer_812|Werte Kraftfahrzeuge||
+#LayersUrlPart:     LAYERS=layer_813|Werte G?terverkehr||
+#LayersUrlPart:     LAYERS=layer_814|Werte Schwerverkehr||
+#LayersUrlPart:     LAYERS=layer_809|Verkehrsmengen Autobahn||
+#LayersUrlPart:     LAYERS=layer_810|Verkehrsmengen Bundesstr.||
+#LayersUrlPart:     LAYERS=layer_811|Verkehrsmengen Landesstr.||
+#LayersUrlPart:     LAYERS=layer_1448|Verkehrsmengen Autobahn||
+#LayersUrlPart:     LAYERS=layer_1449|Verkehrsmengen Bundesstr.||
+#LayersUrlPart:     LAYERS=layer_1450|Verkehrsmengen Landesstr.||
+#LayersUrlPart:     LAYERS=layer_1451|DTV- / SV-Werte Autobahn||
+#LayersUrlPart:     LAYERS=layer_1452|DTV- / SV-Werte Bundesstr.||
+#LayersUrlPart:     LAYERS=layer_1453|DTV- / SV-Werte Landesstr.||
+#LayersUrlPart:     LAYERS=layer_2402|Sonderflugh?fen||
+#LayersUrlPart:     LAYERS=layer_2403|Verkehrsflugh?fen||
+#LayersUrlPart:     LAYERS=layer_2404|Verkehrslandepl?tze||
+#LayersUrlPart:     LAYERS=layer_2405|Sonderlandepl?tze||
+#LayersUrlPart:     LAYERS=layer_2406|Segelfluggel?nde||
+#LayersUrlPart:     LAYERS=layer_802|Arch?ologie (Gro?steingr?ber)|126.713409|1.999998
+#LayersUrlPart:     LAYERS=layer_803|Arch?ologie (GeoLife)|44.901281|1.999998
+#LayersUrlPart:     LAYERS=layer_804|Arch?ologie (Wurten und Deiche)|44.901281|1.999998
+#LayersUrlPart:     LAYERS=layer_805|Bau- und Kunstdenkmalpflege (M?hlen)|44.901281|1.999998
+#LayersUrlPart:     LAYERS=layer_806|Bau- und Kunstdenkmalpflege (Kirchen)|44.901281|1.999998
+#LayersUrlPart:     LAYERS=layer_807|Bau- und Kunstdenkmalpflege (Worpswede)|15.839176|1.999998
+#LayersUrlPart:     LAYERS=layer_808|Bau- und Kunstdenkmalpflege (Herrenhausen)|15.839176|1.999998
+#LayersUrlPart:     LAYERS=layer_1428|Preu?. Landesaufn. 1:25000 (grau/transp.)|24.945141|0.000000
+#LayersUrlPart:     LAYERS=layer_1427|Preu?. Landesaufn. 1:25000 (schwarz/transp.)|24.945141|0.000000
+LayersUrlPart:     LAYERS=layer_3707
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
-BoundingBoxTopLeftWGS84: N 54.0018 E 6.5794
-BoundingBoxBottomRightWGS84: N 51.3727 E 11.7346
-#BBox_Mitte: N 52.6872895 E 9.156994
-MinScale:   2
-MaxScale:   10
-RecommendedScale:    2 3 5
+BoundingBoxTopLeftWGS84: N 53.9771 E 6.4229
+BoundingBoxBottomRightWGS84: N 51.2089 E 11.7272
+#BBox_Mitte: N 52.5929772805 E 9.0750485755
+MinScale:   0
+MaxScale:   16
+RecommendedScale:    5 1 10
 ImageFileExtension: .jpg

Modified: trunk/src/CacheWolf/AttributesSelector.java
===================================================================
--- trunk/src/CacheWolf/AttributesSelector.java	2011-07-06 19:47:05 UTC (rev 3037)
+++ trunk/src/CacheWolf/AttributesSelector.java	2011-07-07 16:27:23 UTC (rev 3038)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import ewe.fx.Image;
@@ -38,99 +38,107 @@
 
 public class AttributesSelector extends Panel {
 	protected static int TILESIZE;
-	protected static int W_OFFSET;  // depends on Global.getPref().fontSize ?
-	protected static int H_OFFSET;	// depends on Global.getPref().fontSize ?
-	private long[] selectionMaskYes = {0l,0l};
-	private long[] selectionMaskNo = {0l,0l};
+	protected static int W_OFFSET; // depends on Global.getPref().fontSize ?
+	protected static int H_OFFSET; // depends on Global.getPref().fontSize ?
+	private long[] selectionMaskYes = { 0l, 0l };
+	private long[] selectionMaskNo = { 0l, 0l };
 	protected mLabel mInfo;
-	protected InteractivePanel iap=new attInteractivePanel();
+	protected InteractivePanel iap = new attInteractivePanel();
 	protected MyScrollBarPanel scp = new MyScrollBarPanel(iap);
-	private int virtualWidth; 
+	private int virtualWidth;
 
 	public AttributesSelector() {
 		scp.setOptions(MyScrollBarPanel.NeverShowHorizontalScrollers);
-		TILESIZE = 30; W_OFFSET=100; H_OFFSET=150;
-		if(Vm.isMobile()){
-			if(MyLocale.getScreenWidth() == 240 & MyLocale.getScreenHeight() == 320){
-				TILESIZE = 28; W_OFFSET=80; H_OFFSET=120;
+		TILESIZE = 30;
+		W_OFFSET = 100;
+		H_OFFSET = 150;
+		if (Vm.isMobile()) {
+			if (MyLocale.getScreenWidth() == 240 & MyLocale.getScreenHeight() == 320) {
+				TILESIZE = 28;
+				W_OFFSET = 80;
+				H_OFFSET = 120;
 			}
-			if(MyLocale.getScreenWidth() == 320 & MyLocale.getScreenHeight() == 240){
+			if (MyLocale.getScreenWidth() == 320 & MyLocale.getScreenHeight() == 240) {
 			}
-			if(MyLocale.getScreenWidth() == 480 & MyLocale.getScreenHeight() == 640){
+			if (MyLocale.getScreenWidth() == 480 & MyLocale.getScreenHeight() == 640) {
 			}
-			if(MyLocale.getScreenWidth() == 480 & MyLocale.getScreenHeight() == 800){
+			if (MyLocale.getScreenWidth() == 480 & MyLocale.getScreenHeight() == 800) {
 			}
-			if(MyLocale.getScreenWidth() == 640 & MyLocale.getScreenHeight() == 480){
+			if (MyLocale.getScreenWidth() == 640 & MyLocale.getScreenHeight() == 480) {
 			}
+		} else {
+			TILESIZE = 36;
+			W_OFFSET = 106;
+			H_OFFSET = 150;
 		}
-		else {
-			TILESIZE = 36; W_OFFSET=106; H_OFFSET=150;
-		}
-		iap.virtualSize = new Rect(0,0,0,0); // create once
-		addLast(scp,STRETCH,FILL);
-		addLast(mInfo=new mLabel(""),HSTRETCH,HFILL);
+		iap.virtualSize = new Rect(0, 0, 0, 0); // create once
+		addLast(scp, STRETCH, FILL);
+		addLast(mInfo = new mLabel(""), HSTRETCH, HFILL);
 	}
 
 	public void setSelectionMasks(long[] SelectionMasks) {
 		selectionMaskYes[0] = SelectionMasks[0];
 		selectionMaskYes[1] = SelectionMasks[1];
 		selectionMaskNo[0] = SelectionMasks[2];
-		selectionMaskNo[1] = SelectionMasks[3];		
+		selectionMaskNo[1] = SelectionMasks[3];
 		showAttributePalette();
 	}
-	
+
 	public long[] getSelectionMasks() {
 		long[] SelectionMasks = new long[4];
 		SelectionMasks[0] = selectionMaskYes[0];
 		SelectionMasks[1] = selectionMaskYes[1];
 		SelectionMasks[2] = selectionMaskNo[0];
-		SelectionMasks[3] = selectionMaskNo[1];		
+		SelectionMasks[3] = selectionMaskNo[1];
 		return SelectionMasks;
 	}
-	
+
 	public boolean isSetSelectionMask() {
-		return  selectionMaskYes[0] != 0l || selectionMaskNo[0] != 0l ||
-				selectionMaskYes[1] != 0l || selectionMaskNo[1] != 0l;
+		return selectionMaskYes[0] != 0l || selectionMaskNo[0] != 0l || selectionMaskYes[1] != 0l || selectionMaskNo[1] != 0l;
 	}
 
 	protected class attImage extends AniImage {
-		public Attribute att;		
-		attImage (mImage img, Attribute _att) {
+		public Attribute att;
+
+		attImage(mImage img, Attribute _att) {
 			super(img);
-			att=_att;
-		}		
+			att = _att;
+		}
+
 		attImage(attImage cp, int val) {
-			att=cp.att;
+			att = cp.att;
 			att.setInc(val);
-			mImage rawImg=att.getImage();
-			setMImage (rawImg.getHeight()!=TILESIZE-2 ? rawImg.scale(TILESIZE-2,TILESIZE-2,null,Image.FOR_DISPLAY) : rawImg  );
+			mImage rawImg = att.getImage();
+			setMImage(rawImg.getHeight() != TILESIZE - 2 ? rawImg.scale(TILESIZE - 2, TILESIZE - 2, null, Image.FOR_DISPLAY) : rawImg);
 			location = cp.location;
 		}
 	}
-	
+
 	protected class attInteractivePanel extends InteractivePanel {
 		public boolean imageMovedOn(AniImage which) {
-			mInfo.setText(((attImage)which).att.getMsg());			
+			mInfo.setText(((attImage) which).att.getMsg());
 			mInfo.repaintNow();
 			return true;
 		}
+
 		public boolean imageMovedOff(AniImage which) {
 			mInfo.setText("");
 			mInfo.repaintNow();
 			return true;
 		}
+
 		public boolean imagePressed(AniImage which, Point pos) {
 			if (which != null) {
-				int value=((attImage)which).att.getInc();
-				value=(value + 1) % 3;
-				((attImage)which).att.setInc(value);
-				selectionMaskNo=((attImage)which).att.getNoBit(selectionMaskNo);
-				selectionMaskYes=((attImage)which).att.getYesBit(selectionMaskYes);
-				attImage tmpImg = new attImage(((attImage)which), value );
+				int value = ((attImage) which).att.getInc();
+				value = (value + 1) % 3;
+				((attImage) which).att.setInc(value);
+				selectionMaskNo = ((attImage) which).att.getNoBit(selectionMaskNo);
+				selectionMaskYes = ((attImage) which).att.getYesBit(selectionMaskYes);
+				attImage tmpImg = new attImage(((attImage) which), value);
 				removeImage(which);
 				addImage(tmpImg);
 				refresh();
-				notifyDataChange(new DataChangeEvent(DataChangeEvent.DATA_CHANGED,this));
+				notifyDataChange(new DataChangeEvent(DataChangeEvent.DATA_CHANGED, this));
 			}
 			return true;
 		}
@@ -139,51 +147,49 @@
 	private void showAttributePalette() {
 		iap.images.clear();
 		int myWidth = virtualWidth;
-		int myX = 2; int myY = 2;
+		int myX = 2;
+		int myY = 2;
 		int inc = 2;
 		for (int i = 0; i < Attribute.maxAttRef; i++) {
 			long[] bitMask = Attribute.getIdBit(i);
-			if ( ((selectionMaskYes[0] & bitMask[0]) != 0 ) || 
-					((selectionMaskYes[1] & bitMask[1]) != 0 ))
+			if (((selectionMaskYes[0] & bitMask[0]) != 0) || ((selectionMaskYes[1] & bitMask[1]) != 0))
 				inc = 1;
-			else if ( ((selectionMaskNo[0] & bitMask[0]) != 0 ) ||
-					((selectionMaskNo[1] & bitMask[1]) != 0 ))
+			else if (((selectionMaskNo[0] & bitMask[0]) != 0) || ((selectionMaskNo[1] & bitMask[1]) != 0))
 				inc = 0;
 			else
-				inc = 2;			
-			Attribute att = new Attribute(i,inc); 
-			mImage rawImg=att.getImage();
-			attImage img=new attImage(rawImg.getHeight()!=TILESIZE-2 ? rawImg.scale(TILESIZE-2,TILESIZE-2,null,Image.FOR_DISPLAY) : rawImg, att);
+				inc = 2;
+			Attribute att = new Attribute(i, inc);
+			mImage rawImg = att.getImage();
+			attImage img = new attImage(rawImg.getHeight() != TILESIZE - 2 ? rawImg.scale(TILESIZE - 2, TILESIZE - 2, null, Image.FOR_DISPLAY) : rawImg, att);
 
-			if (myX+TILESIZE > myWidth) {
+			if (myX + TILESIZE > myWidth) {
 				myX = 2;
 				myY += TILESIZE;
 			}
-			img.location=new Rect(myX,myY,TILESIZE,TILESIZE);
+			img.location = new Rect(myX, myY, TILESIZE, TILESIZE);
 			iap.addImage(img);
 			myX += TILESIZE;
-			
+
 		}
-		iap.repaintNow();		
+		iap.repaintNow();
 	}
-	
 
 	private void setIapSize(int width, int height) {
 		iap.setPreferredSize(width, height);
-		Global.getPref().log("[AttributesSelector:changeIapSize]  pref. area: "+width+"x"+height);
+		Global.getPref().log("[AttributesSelector:changeIapSize]  pref. area: " + width + "x" + height);
 
-		int anzPerWidth = width / (TILESIZE+2);
-		virtualWidth = anzPerWidth * (TILESIZE+2);
+		int anzPerWidth = width / (TILESIZE + 2) - 1;
+		virtualWidth = anzPerWidth * (TILESIZE + 2);
 		double max = Attribute.maxAttRef;
 		int anzPerHeight = (int) java.lang.Math.ceil(max / anzPerWidth);
-		iap.virtualSize.set(0,0,virtualWidth ,anzPerHeight * (TILESIZE+2));
-		Global.getPref().log("[AttributesSelector:setIapSize] virt. area: "+virtualWidth+"x"+anzPerHeight * (TILESIZE+2));
+		iap.virtualSize.set(0, 0, virtualWidth, anzPerHeight * (TILESIZE + 2));
+		Global.getPref().log("[AttributesSelector:setIapSize] virt. area: " + virtualWidth + "x" + anzPerHeight * (TILESIZE + 2));
 
 	}
 
 	public void changeIapSize(int width, int height) {
-		Global.getPref().log("[AttributesSelector:changeIapSize]  max. area: "+width+"x"+height);
-		setIapSize(width-W_OFFSET, height-H_OFFSET);
+		Global.getPref().log("[AttributesSelector:changeIapSize]  max. area: " + width + "x" + height);
+		setIapSize(width - W_OFFSET, height - H_OFFSET);
 		showAttributePalette();
 	}
 



From araber95 at mail.berlios.de  Wed Jul 13 07:52:00 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Wed, 13 Jul 2011 07:52:00 PM +0200
Subject: [Cachewolf-svn] r3039 - trunk/res_noewe/webmapservices
Message-ID: <20110713175200.4EC93481467@sheep.berlios.de>

Author: araber95
Date: 2011-07-13 19:51:59 +0200 (Wed, 13 Jul 2011)
New Revision: 3039

Added:
   trunk/res_noewe/webmapservices/de-bw_t10k.wms
Log:
new wms for baden-w?rttemberg

Added: trunk/res_noewe/webmapservices/de-bw_t10k.wms
===================================================================
--- trunk/res_noewe/webmapservices/de-bw_t10k.wms	                        (rev 0)
+++ trunk/res_noewe/webmapservices/de-bw_t10k.wms	2011-07-13 17:51:59 UTC (rev 3039)
@@ -0,0 +1,22 @@
+TakenFromUrl:       http://deutschlandviewer.bayern.de/deutschlandviewer/D_Viewer_Hilfe/Hilfe_D_Viewer.htm#Geodaten
+GetCapabilitiesUrl: http://www.lv-bw.de/dv/service/getrds.asp?login=dv&pw=anonymous&SERVICE=WMS&REQUEST=GetCapabilities
+Name: de.Baden-Wuerttemberg t10k
+MapType:                        topo
+#MainUrl:            http://www.lv-bw.de/dv/service/getrds.asp?login=dv&pw=anonymous&
+MainUrl:            http://www.lv-bw.de/dv/service/getrds.asp?login=geoportal&pw=gdi_bw&
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  31467
+CoordinateReferenceSystemUrlPart: SRS=EPSG:31467
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=DVDOP2|DOP_2m||
+#LayersUrlPart:     LAYERS=DVTK50K|TK50||
+LayersUrlPart:     LAYERS=RK10
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 50.0000 E 7.6000
+BoundingBoxBottomRightWGS84: N 47.4000 E 10.0000
+MinScale:   0
+MaxScale:   20
+RecommendedScale:    1 5 10
+ImageFileExtension: .jpg



From araber95 at mail.berlios.de  Wed Jul 20 07:37:29 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Wed, 20 Jul 2011 07:37:29 PM +0200
Subject: [Cachewolf-svn] r3040 - trunk/src/CacheWolf
Message-ID: <20110720173729.651FA481462@sheep.berlios.de>

Author: araber95
Date: 2011-07-20 19:37:28 +0200 (Wed, 20 Jul 2011)
New Revision: 3040

Modified:
   trunk/src/CacheWolf/Preferences.java
Log:
struggle with a MinML error : wrong handling of not detecting end of tag distroying &amp;

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2011-07-13 17:51:59 UTC (rev 3039)
+++ trunk/src/CacheWolf/Preferences.java	2011-07-20 17:37:28 UTC (rev 3040)
@@ -767,7 +767,7 @@
 					+ "    <lastprofile" //
 					+ " autoreload=\"" + SafeXML.strxmlencode(autoReloadLastProfile) + "\"" //
 					+ ">" //
-					+ SafeXML.clean(lastProfile) + "</lastprofile>\n" //
+					+ SafeXML.clean(lastProfile) + "</ lastprofile>\n" //
 
 					+ "    <CurrentCentre" //
 					+ " FromGPSPosition=\"" + SafeXML.strxmlencode(setCurrentCentreFromGPSPosition) + "\"" //



From araber95 at mail.berlios.de  Wed Jul 20 10:07:54 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Wed, 20 Jul 2011 10:07:54 PM +0200
Subject: [Cachewolf-svn] r3041 - in trunk/src/CacheWolf: . exp imp
Message-ID: <20110720200754.6E43A4814C0@sheep.berlios.de>

Author: araber95
Date: 2011-07-20 22:07:54 +0200 (Wed, 20 Jul 2011)
New Revision: 3041

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/CacheImages.java
   trunk/src/CacheWolf/exp/SpoilerPOIExporter.java
   trunk/src/CacheWolf/imp/OCLinkImporter.java
   trunk/src/CacheWolf/myTableControl.java
Log:
1. remove \r\n within img - tags (resulting no/wrong local image access in html export)
2. doing cacheName private. correct direct access by getter.

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2011-07-20 17:37:28 UTC (rev 3040)
+++ trunk/src/CacheWolf/CacheHolder.java	2011-07-20 20:07:54 UTC (rev 3041)
@@ -58,7 +58,7 @@
 	/** The name of the waypoint, typically GC.... or OC.... or CW...... (can be any characters) */
 	private String wayPoint = EMPTY;
 	/** The name of the cache (short description) */
-	public String cacheName = EMPTY;
+	private String cacheName = EMPTY;
 	/** The alias of the owner */
 	private String cacheOwner = EMPTY;
 	/** The coordinates of the cache */

Modified: trunk/src/CacheWolf/CacheImages.java
===================================================================
--- trunk/src/CacheWolf/CacheImages.java	2011-07-20 17:37:28 UTC (rev 3040)
+++ trunk/src/CacheWolf/CacheImages.java	2011-07-20 20:07:54 UTC (rev 3041)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.utils.FileBugfix;
@@ -30,66 +30,75 @@
 import ewe.util.Vector;
 
 /**
- * This class holds the image information of a cache. 
+ * This class holds the image information of a cache.
+ * 
  * @author torsti
- *
+ * 
  */
 public class CacheImages {
-	
-	private int initialSize=10;
-	/** Lazy initialization of the vector: It is created only when needed. If it is not accessed,
-	 * it will stay <code>null</code>.*/
-	private Vector vector=null;
+
+	private int initialSize = 10;
+	/**
+	 * Lazy initialization of the vector: It is created only when needed. If it is not accessed,
+	 * it will stay <code>null</code>.
+	 */
+	private Vector vector = null;
 	/** Images that should display in the image panel */
-	private CacheImages display=null;
-	
-	public CacheImages(){ // Public constructor
+	private CacheImages display = null;
+
+	public CacheImages() { // Public constructor
 	}
 
 	public CacheImages(int initialSize) {
-		if (initialSize<0) {
-			throw new IllegalArgumentException("Initial size for CacheImage must be > 0. Value: "+String.valueOf(initialSize));
+		if (initialSize < 0) {
+			throw new IllegalArgumentException("Initial size for CacheImage must be > 0. Value: " + String.valueOf(initialSize));
 		}
 		this.initialSize = initialSize;
 	}
-	private Vector getVector(){
-		if (this.vector==null) {
+
+	private Vector getVector() {
+		if (this.vector == null) {
 			vector = new Vector(this.initialSize);
 		}
 		return this.vector;
 	}
-	
+
 	/**
-	 * Adds an ImageInfo object to the list of images. The object is always appended in the 
+	 * Adds an ImageInfo object to the list of images. The object is always appended in the
 	 * last position.
-	 * @param img ImageInfo object to add.
+	 * 
+	 * @param img
+	 *            ImageInfo object to add.
 	 */
 	public void add(ImageInfo img) {
-		display = null;  // New Image? Force display to get reevaluated 
-        getVector().add(img);
-    }
-	
+		display = null; // New Image? Force display to get reevaluated
+		getVector().add(img);
+	}
+
 	/**
 	 * Gets the ImageInfo object at the specified position.
-	 * @param idx Index of object to retrieve.
+	 * 
+	 * @param idx
+	 *            Index of object to retrieve.
 	 * @return ImageInfo object
 	 */
 	public ImageInfo get(int idx) {
 		return (ImageInfo) getVector().get(idx);
 	}
-	
+
 	/**
 	 * Removes all image information.
 	 */
 	public void clear() {
-		if (this.vector!=null) {
-			display = null; 
+		if (this.vector != null) {
+			display = null;
 			this.vector.clear();
 		}
 	}
-	
+
 	/**
 	 * Returns the number of ImageInfo objects in the collection.
+	 * 
 	 * @return Number
 	 */
 	public int size() {
@@ -99,52 +108,59 @@
 			return this.vector.size();
 		}
 	}
-	
+
 	/**
 	 * Fills the <code>display</code> collection with the images that really should display
 	 * in the image panel.
-	 * @param prefix The prefix which is used to name default image titles
+	 * 
+	 * @param prefix
+	 *            The prefix which is used to name default image titles
 	 */
 	private void checkForDisplayImages(String prefix) {
-		if (this.size()>1) {
+		if (this.size() > 1) {
 			display = new CacheImages(this.size());
 			// Loop over every image
-			for (int i=0; i<this.size(); i++) {
+			for (int i = 0; i < this.size(); i++) {
 				boolean shouldDisplay = true;
 				ImageInfo currImg = this.get(i);
 				// Now check against every other image
-				for (int j=0; j<this.size(); j++) {
-					if (i==j) continue; // Except same image
+				for (int j = 0; j < this.size(); j++) {
+					if (i == j)
+						continue; // Except same image
 					ImageInfo testImg = this.get(j);
 					// Are the filenames the same?
 					if (currImg.getFilename().toLowerCase().equals(testImg.getFilename().toLowerCase())) {
 						// Check if other title is better than current one
-						if (currImg.getTitle().startsWith(prefix) &&
-							!testImg.getTitle().startsWith(prefix)) {
+						if (currImg.getTitle().startsWith(prefix) && !testImg.getTitle().startsWith(prefix)) {
 							// If yes: Don't show the image
 							shouldDisplay = false;
 						}
 					}
 				}
-				if (shouldDisplay) display.add(currImg);
+				if (shouldDisplay)
+					display.add(currImg);
 			}
 		}
 	}
-	
+
 	/**
-	 * Returns a CacheImage collection of the images that should be displayed in the 
-	 * image panel. An image should <b>not</b> be present in this collection if its title is 
+	 * Returns a CacheImage collection of the images that should be displayed in the
+	 * image panel. An image should <b>not</b> be present in this collection if its title is
 	 * starting with the indicated prefix and if there is another image referring to the same file but
 	 * with a different title.<br>
 	 * Normally, the results are cached and don't need to be evaluated again. If they should
-	 * be reevaluated for whatever reason, then pass <code>true</code> as parameter.  
-	 * @param prefix The prefix which is used to name default image titles
-	 * @param forceEvaluation When <code>true</code> the images that should display are
-	 * reexamined.
-	 * @return The CacheImage collection of images. 
+	 * be reevaluated for whatever reason, then pass <code>true</code> as parameter.
+	 * 
+	 * @param prefix
+	 *            The prefix which is used to name default image titles
+	 * @param forceEvaluation
+	 *            When <code>true</code> the images that should display are
+	 *            reexamined.
+	 * @return The CacheImage collection of images.
 	 */
 	public CacheImages getDisplayImages(String prefix, boolean forceEvaluation) {
-		if (display == null || forceEvaluation) this.checkForDisplayImages(prefix);
+		if (display == null || forceEvaluation)
+			this.checkForDisplayImages(prefix);
 		if (display == null) {
 			return this;
 		} else {
@@ -153,40 +169,42 @@
 	}
 
 	/**
-	 * Returns a CacheImage collection of the images that should be displayed in the 
-	 * image panel. An image should <b>not</b> be present in this collection if its title is 
+	 * Returns a CacheImage collection of the images that should be displayed in the
+	 * image panel. An image should <b>not</b> be present in this collection if its title is
 	 * equivalent to its filename and if there is another image referring to the same file but
 	 * with a different title.
-	 * @param prefix The prefix which is used to name default image titles
-	 * @return The CacheImage collection of images. 
+	 * 
+	 * @param prefix
+	 *            The prefix which is used to name default image titles
+	 * @return The CacheImage collection of images.
 	 */
 	public CacheImages getDisplayImages(String prefix) {
 		return this.getDisplayImages(prefix, false);
 	}
-	
+
 	/**
 	 * Checks if a image of a given URL needs to be spidered. It does <b>not</b> need to be spidered
-	 * if the following conditions meet: <ul>
-	 * <li>The url is from <code>http://img.geocaching.com/cache/</code> or 
-	 * <code>http://img.groundspeak.com/cache/</code>. (Reason: Images at these places don't change - 
-	 * if images change, they get a new url.)</li>
+	 * if the following conditions meet:
+	 * <ul>
+	 * <li>The url is from <code>http://img.geocaching.com/cache/</code> or <code>http://img.groundspeak.com/cache/</code>. (Reason: Images at these places don't change - if images change, they get a new url.)</li>
 	 * <li>An image with the given URL is among the images of the caches image object.</li>
 	 * <li>The intended file name is the same.</li>
 	 * <li>The image is present in the file system.</li>
-	 * </ul> If no spidering is needed, then the <code>ImageInfo</code> object of the equivalent image is
+	 * </ul>
+	 * If no spidering is needed, then the <code>ImageInfo</code> object of the equivalent image is
 	 * returned, otherwise (when spidering is needed) <code>null</code> is returned.
-	 * @param pNewUrl URL to check
+	 * 
+	 * @param pNewUrl
+	 *            URL to check
 	 * @return ImageInfo object
 	 */
 	public ImageInfo needsSpidering(String pNewUrl, String pFilename) {
 		String newUrl = CacheImages.optimizeLink(pNewUrl);
 		ImageInfo result = null;
-		if (this.size() > 0 && 
-				(newUrl.startsWith("http://img.geocaching.com/cache/"))) {
-			for (int i=0; i<this.size(); i++) {
+		if (this.size() > 0 && (newUrl.startsWith("http://img.geocaching.com/cache/"))) {
+			for (int i = 0; i < this.size(); i++) {
 				ImageInfo img = this.get(i);
-				if (CacheImages.optimizeLink(img.getURL()).equals(newUrl) 
-						&& img.getFilename().equals(pFilename)) {
+				if (CacheImages.optimizeLink(img.getURL()).equals(newUrl) && img.getFilename().equals(pFilename)) {
 					String location = Global.getProfile().dataDir + pFilename;
 					if ((new FileBugfix(location)).exists()) {
 						result = img;
@@ -197,16 +215,18 @@
 		}
 		return result;
 	}
-	
+
 	/**
-	 * Checks if an image with a certain filename is present in the collection of the caches 
+	 * Checks if an image with a certain filename is present in the collection of the caches
 	 * images.
-	 * @param filename Filename to check
+	 * 
+	 * @param filename
+	 *            Filename to check
 	 * @return <code>true</code> if there is such a file, <code>false</code> if not.
 	 */
 	private boolean hasFile(String filename) {
 		boolean result = false;
-		for (int i=0; i<this.size(); i++) {
+		for (int i = 0; i < this.size(); i++) {
 			if (this.get(i).getFilename().toUpperCase().equals(filename.toUpperCase())) {
 				result = true;
 				break;
@@ -214,47 +234,53 @@
 		}
 		return result;
 	}
-	
+
 	/**
 	 * Deletes images that are no longer needed. It takes two CacheImage objects as arguments, one
-	 * as a collection of images before an update, the other after. Then every file in the old 
+	 * as a collection of images before an update, the other after. Then every file in the old
 	 * collection is checked if it is also present in the new collection. If not, the file is deleted.
 	 * Note that the <i>content</i> of the files is irrelevant. It is only important to remove files
-	 * - regardles of their contents - if they are no longer referenced after a cache update. 
-	 * @param oldImages Set of images before update
-	 * @param newImages Set of images after update
+	 * - regardles of their contents - if they are no longer referenced after a cache update.
+	 * 
+	 * @param oldImages
+	 *            Set of images before update
+	 * @param newImages
+	 *            Set of images after update
 	 */
 	public static void cleanupOldImages(CacheImages oldImages, CacheImages newImages) {
 		// Loop over every image in the old collection
-		for (int i=0; i<oldImages.size(); i++) {
+		for (int i = 0; i < oldImages.size(); i++) {
 			// Check if image file is present in new collection
 			String obsoleteFilename = oldImages.get(i).getFilename();
 			if (!newImages.hasFile(obsoleteFilename)) {
 				String location = Global.getProfile().dataDir + obsoleteFilename;
 				File tmpFile = new FileBugfix(location);
 				if (tmpFile.exists() && tmpFile.canWrite()) {
-					Global.getPref().log("Image not longer needed. Deleting: "+obsoleteFilename);
+					Global.getPref().log("Image not longer needed. Deleting: " + obsoleteFilename);
 					tmpFile.delete();
 				}
 			}
 		}
 	}
-	
+
 	/**
 	 * Takes an image url and does some optimization: As img.groundspeak.com is the same as
-	 * img.geocaching.com and the former is sometimes used by owners in the cache listing html, 
-	 * this method replaces img.groundspeak.com by img.geocaching.com, in order to be able to 
+	 * img.geocaching.com and the former is sometimes used by owners in the cache listing html,
+	 * this method replaces img.groundspeak.com by img.geocaching.com, in order to be able to
 	 * identify identical pictures as such.
-	 * @param pUrl URL to modify
+	 * 
+	 * @param pUrl
+	 *            URL to modify
 	 * @return Same URL, eventually modified
 	 */
 	public static String optimizeLink(String pUrl) {
-		String url = pUrl;
+		String url = STRreplace.replace(pUrl, "\n", "");
+		url = STRreplace.replace(pUrl, "\r", "");
 		// img.groundspeak.com is same as img.geocaching.com, so replace it
 		if (url.toLowerCase().startsWith("http://img.groundspeak.com/")) {
 			url = "http://img.geocaching.com/" + url.substring(27);
 		}
 		return url;
 	}
-	
+
 }

Modified: trunk/src/CacheWolf/exp/SpoilerPOIExporter.java
===================================================================
--- trunk/src/CacheWolf/exp/SpoilerPOIExporter.java	2011-07-20 17:37:28 UTC (rev 3040)
+++ trunk/src/CacheWolf/exp/SpoilerPOIExporter.java	2011-07-20 20:07:54 UTC (rev 3041)
@@ -1,29 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
+
 import CacheWolf.CacheHolder;
 import CacheWolf.CacheImages;
 import CacheWolf.Common;
@@ -35,18 +36,18 @@
 import ewe.sys.Time;
 import ewe.ui.FormBase;
 
-/** 
+/**
  * 
  * @author Kalle
- * Class to create a gpx-File with links to the pictures of a 
- * cache, which is used as input for the POILoader from Garmin.
+ *         Class to create a gpx-File with links to the pictures of a
+ *         cache, which is used as input for the POILoader from Garmin.
  */
 
 public class SpoilerPOIExporter extends Exporter {
 	private SpoilerPOIExporterScreen infoScreen;
 	private boolean onlySpoiler;
-	
-	public SpoilerPOIExporter(Preferences p, Profile prof){
+
+	public SpoilerPOIExporter(Preferences p, Profile prof) {
 		super();
 		this.setMask("*.gpx");
 		this.setHowManyParams(LAT_LON);
@@ -55,19 +56,19 @@
 
 	public void doIt() {
 		infoScreen = new SpoilerPOIExporterScreen("SpoilerPOIExport");
-		if (infoScreen.execute() == FormBase.IDCANCEL) return;
+		if (infoScreen.execute() == FormBase.IDCANCEL)
+			return;
 		onlySpoiler = infoScreen.getOnlySpoiler();
 		super.doIt();
 	}
-	
-	public String header () {
+
+	public String header() {
 		StringBuffer strBuf = new StringBuffer(200);
 		Time tim = new Time();
 
 		strBuf.append("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>\r\n");
-		strBuf.append("<gpx xmlns=\"http://www.topografix.com/GPX/1/1\" creator=\"CacheWolf\" version=\"1.1\"" +
-				      " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" " +
-				      "xsi:schemaLocation=\"http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd\">\r\n");
+		strBuf.append("<gpx xmlns=\"http://www.topografix.com/GPX/1/1\" creator=\"CacheWolf\" version=\"1.1\"" + " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" "
+				+ "xsi:schemaLocation=\"http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd\">\r\n");
 		strBuf.append("  <metadata>\r\n");
 		strBuf.append("    <link href=\"http://www.cachewolf.de\">\r\n");
 		strBuf.append("      <text>CacheWolf</text>\r\n");
@@ -78,48 +79,54 @@
 		strBuf.append("  </metadata>\r\n");
 		return strBuf.toString();
 	}
-	
+
 	public String record(CacheHolder ch, String lat, String lon) {
 		StringBuffer strBuf = new StringBuffer(1000);
-		String comment,filename, url;
+		String comment, filename, url;
 		CacheImages images;
 		int picCounter;
-		
+
 		// Makes only sense for main waypoints
-		if (ch.isAddiWpt()) return null;
-		
+		if (ch.isAddiWpt())
+			return null;
+
 		// First check, if there a any pictures in the db for the wpt
 		ch.getCacheDetails(true);
-		if (! ch.detailsLoaded()) return null;
-		if (ch.getCacheDetails(true).images.size() == 0) return null;
-		
+		if (!ch.detailsLoaded())
+			return null;
+		if (ch.getCacheDetails(true).images.size() == 0)
+			return null;
+
 		images = ch.getCacheDetails(true).images.getDisplayImages(ch.getWayPoint());
 		picCounter = 0;
-		for (int i=0; i < images.size(); i++ ) {
+		for (int i = 0; i < images.size(); i++) {
 			filename = images.get(i).getFilename();
 			comment = images.get(i).getTitle();
 			url = profile.dataDir + filename;
-			
+
 			// POILoader can only work with JPG-Files
-			if ( !filename.endsWith(".jpg")) continue;
+			if (!filename.endsWith(".jpg"))
+				continue;
 			// Try to export only Spoiler
-			if ( onlySpoiler && (comment.indexOf("oiler") < 1)) continue;
+			if (onlySpoiler && (comment.indexOf("oiler") < 1))
+				continue;
 			// check if the file is not deleted
-			if (!(new FileBugfix(url)).exists()) continue;
-			
+			if (!(new FileBugfix(url)).exists())
+				continue;
+
 			picCounter++;
 			strBuf.append("<wpt lat=\"" + lat + "\" lon=\"" + lon + "\">\r\n");
-			strBuf.append("  <name>Sp " + picCounter + ": " + SafeXML.cleanGPX(ch.cacheName) + "</name>\r\n");
+			strBuf.append("  <name>Sp " + picCounter + ": " + SafeXML.cleanGPX(ch.getCacheName()) + "</name>\r\n");
 			strBuf.append("  <cmt>\r\n");
-			if (ch.getCacheDetails(true).Hints.length()> 0){
+			if (ch.getCacheDetails(true).Hints.length() > 0) {
 				strBuf.append("  Hint: " + SafeXML.cleanGPX(Common.rot13(ch.getCacheDetails(true).Hints)) + "\r\n");
 			}
-			if (comment != null){
+			if (comment != null) {
 				strBuf.append("  Comment: " + SafeXML.cleanGPX(SafeXML.cleanback(comment)) + "\r\n");
 			}
 			strBuf.append("  </cmt>\r\n");
 			strBuf.append("  <desc>GCcode: " + ch.getWayPoint() + " </desc>\r\n");
-			strBuf.append("   <link href=\"" + URLUTF8Encoder.encode(url, false)  + "\"/>\r\n");
+			strBuf.append("   <link href=\"" + URLUTF8Encoder.encode(url, false) + "\"/>\r\n");
 			strBuf.append("  <sym>Scenic Area</sym>\r\n");
 			strBuf.append("  <extensions>\r\n");
 			strBuf.append("     <gpxx:WaypointExtension xmlns:gpxx=\"http://www.garmin.com/xmlschemas/GpxExtensions/v3\">\r\n");
@@ -129,10 +136,10 @@
 			strBuf.append("</wpt>\r\n");
 			strBuf.append("\r\n");
 		}
-	
+
 		return strBuf.toString();
 	}
-	
+
 	public String trailer() {
 		return "</gpx>\r\n";
 	}

Modified: trunk/src/CacheWolf/imp/OCLinkImporter.java
===================================================================
--- trunk/src/CacheWolf/imp/OCLinkImporter.java	2011-07-20 17:37:28 UTC (rev 3040)
+++ trunk/src/CacheWolf/imp/OCLinkImporter.java	2011-07-20 20:07:54 UTC (rev 3041)
@@ -105,7 +105,7 @@
 					url = baseurl + "mode=locate&lat=" + nLat + "&lon=" + nLon;
 					result = SafeXML.cleanback(UrlFetcher.fetch(url));
 					String ocCacheName = new Extractor(result, "name=\"", "\"", 0, true).findNext();
-					if (ch.cacheName.equals(ocCacheName)) {
+					if (ch.getCacheName().equals(ocCacheName)) {
 						hasOC = true;
 					} else {
 						int start = result.indexOf("coords=\"") + 8;

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2011-07-20 17:37:28 UTC (rev 3040)
+++ trunk/src/CacheWolf/myTableControl.java	2011-07-20 20:07:54 UTC (rev 3041)
@@ -376,7 +376,7 @@
 			if (ch.pos.isValid()) {
 				String lat = "" + ch.pos.getLatDeg(CWPoint.DD);
 				String lon = "" + ch.pos.getLonDeg(CWPoint.DD);
-				String nameOfCache = UrlFetcher.encodeURL(ch.cacheName, false).replace('#', 'N').replace('@', '_');
+				String nameOfCache = UrlFetcher.encodeURL(ch.getCacheName(), false).replace('#', 'N').replace('@', '_');
 				String language = Vm.getLocale().getString(Locale.LANGUAGE_SHORT, 0, 0);
 				if (!pref.language.equalsIgnoreCase("auto")) {
 					language = pref.language;



From araber95 at mail.berlios.de  Wed Jul 20 10:29:11 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Wed, 20 Jul 2011 10:29:11 PM +0200
Subject: [Cachewolf-svn] r3042 - trunk/src/CacheWolf
Message-ID: <20110720202911.5967C48295E@sheep.berlios.de>

Author: araber95
Date: 2011-07-20 22:29:10 +0200 (Wed, 20 Jul 2011)
New Revision: 3042

Modified:
   trunk/src/CacheWolf/CacheImages.java
Log:
wrong place for correction. (reverting)

Modified: trunk/src/CacheWolf/CacheImages.java
===================================================================
--- trunk/src/CacheWolf/CacheImages.java	2011-07-20 20:07:54 UTC (rev 3041)
+++ trunk/src/CacheWolf/CacheImages.java	2011-07-20 20:29:10 UTC (rev 3042)
@@ -274,8 +274,7 @@
 	 * @return Same URL, eventually modified
 	 */
 	public static String optimizeLink(String pUrl) {
-		String url = STRreplace.replace(pUrl, "\n", "");
-		url = STRreplace.replace(pUrl, "\r", "");
+		String url = pUrl;
 		// img.groundspeak.com is same as img.geocaching.com, so replace it
 		if (url.toLowerCase().startsWith("http://img.groundspeak.com/")) {
 			url = "http://img.geocaching.com/" + url.substring(27);



From araber95 at mail.berlios.de  Thu Jul 21 12:42:35 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Thu, 21 Jul 2011 12:42:35 AM +0200
Subject: [Cachewolf-svn] r3043 - trunk/src/CacheWolf
Message-ID: <20110720224235.4393548295E@sheep.berlios.de>

Author: araber95
Date: 2011-07-21 00:42:34 +0200 (Thu, 21 Jul 2011)
New Revision: 3043

Modified:
   trunk/src/CacheWolf/CacheHolder.java
Log:
correct replacing http-links with file-links (par.ex. GCQY8D)

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2011-07-20 20:29:10 UTC (rev 3042)
+++ trunk/src/CacheWolf/CacheHolder.java	2011-07-20 22:42:34 UTC (rev 3043)
@@ -898,6 +898,9 @@
 			start = chD.LongDescription.indexOf(">", pos) + 1;
 			String oldurl = chD.images.get(imageNo).getURL();
 			String imgString = chD.LongDescription.substring(pos, start);
+			imgString = STRreplace.replace(imgString, "\n", "");
+			imgString = STRreplace.replace(imgString, "\r", "");
+			imgString = STRreplace.replace(imgString, "groundspeak", "geocaching");
 			if (imgString.indexOf(oldurl) == -1) {
 				if (oldurl.startsWith("http://")) {
 					int i = oldurl.indexOf("/", 7) + 1;



From araber95 at mail.berlios.de  Thu Jul 21 10:38:18 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Thu, 21 Jul 2011 10:38:18 AM +0200
Subject: [Cachewolf-svn] r3044 - trunk/src/CacheWolf
Message-ID: <20110721083819.4AFAE48295F@sheep.berlios.de>

Author: araber95
Date: 2011-07-21 10:38:18 +0200 (Thu, 21 Jul 2011)
New Revision: 3044

Modified:
   trunk/src/CacheWolf/MainTab.java
Log:
doing valid coords for waypoint created in goto panel (from selected waypoint if valid else from main cache)

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2011-07-20 22:42:34 UTC (rev 3043)
+++ trunk/src/CacheWolf/MainTab.java	2011-07-21 08:38:18 UTC (rev 3044)
@@ -383,10 +383,19 @@
 		mainCache = lastselected;
 		int selectedIndex = profile.getCacheIndex(lastselected);
 		if (selectedIndex >= 0) {
+			// why not using the target ???
 			CacheHolder selectedCache = profile.cacheDB.get(selectedIndex);
+			// try to start new waypoint with real coords
+			if (!pCh.pos.isValid()) {
+				pCh.pos.set(selectedCache.pos);
+			}
 			if (selectedCache.isAddiWpt()) {
 				if (selectedCache.mainCache != null) {
 					mainCache = selectedCache.mainCache.getWayPoint();
+					// try to start new waypoint with real coords
+					if (!pCh.pos.isValid()) {
+						pCh.pos.set(selectedCache.mainCache.pos);
+					}
 				} else {
 					mainCache = null;
 				}



From araber95 at mail.berlios.de  Thu Jul 21 12:26:34 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Thu, 21 Jul 2011 12:26:34 PM +0200
Subject: [Cachewolf-svn] r3045 - in trunk/src/CacheWolf: . exp imp navi
Message-ID: <20110721102635.68E07483458@sheep.berlios.de>

Author: araber95
Date: 2011-07-21 12:26:34 +0200 (Thu, 21 Jul 2011)
New Revision: 3045

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/CalcPanel.java
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/MyComparer.java
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/RadarPanel.java
   trunk/src/CacheWolf/exp/DistanceComparer.java
   trunk/src/CacheWolf/exp/ExploristExporter.java
   trunk/src/CacheWolf/exp/Exporter.java
   trunk/src/CacheWolf/exp/GpxExportNg.java
   trunk/src/CacheWolf/exp/KMLExporter.java
   trunk/src/CacheWolf/exp/LocExporter.java
   trunk/src/CacheWolf/exp/TPLExporter.java
   trunk/src/CacheWolf/exp/TomTomExporter.java
   trunk/src/CacheWolf/imp/GPXImporter.java
   trunk/src/CacheWolf/imp/LOCXMLImporter.java
   trunk/src/CacheWolf/imp/OCLinkImporter.java
   trunk/src/CacheWolf/imp/OCXMLImporter.java
   trunk/src/CacheWolf/imp/SpiderGC.java
   trunk/src/CacheWolf/myTableControl.java
   trunk/src/CacheWolf/myTableModel.java
   trunk/src/CacheWolf/navi/GotoPanel.java
   trunk/src/CacheWolf/navi/MapLoader.java
   trunk/src/CacheWolf/navi/MapLoaderGui.java
   trunk/src/CacheWolf/navi/MovingMap.java
   trunk/src/CacheWolf/navi/Navigate.java
Log:
using getter and setter for CacheHolder CWPoint pos.
removed String latLon and their getter and setter from CacheHolder (this is pos.toString())

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/CacheHolder.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -28,6 +28,7 @@
 import CacheWolf.exp.Exporter;
 import CacheWolf.exp.GarminMap;
 import CacheWolf.navi.Metrics;
+import CacheWolf.navi.TrackPoint;
 
 import com.stevesoft.ewe_pat.Regex;
 
@@ -62,9 +63,7 @@
 	/** The alias of the owner */
 	private String cacheOwner = EMPTY;
 	/** The coordinates of the cache */
-	public CWPoint pos = new CWPoint();
-	/** The coordinates of the cache */
-	private String LatLon = pos.toString();
+	private CWPoint pos = new CWPoint();
 	/** The date when the cache was hidden in format yyyy-mm-dd */
 	private String dateHidden = EMPTY;
 	/** The size of the cache (as per GC cache sizes Micro, Small, ....) */
@@ -182,8 +181,7 @@
 				start = xmlString.indexOf('"', end + 1);
 				end = xmlString.indexOf('"', start + 1);
 				double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(notDecSep, decSep));
-				pos = new CWPoint(lat, lon);
-				LatLon = pos.toString();
+				pos.set(lat, lon);
 
 				start = xmlString.indexOf('"', end + 1);
 				end = xmlString.indexOf('"', start + 1);
@@ -343,7 +341,6 @@
 				end = xmlString.indexOf('"', start + 1);
 				double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(notDecSep, decSep));
 				pos = new CWPoint(lat, lon);
-				LatLon = pos.toString();
 
 				start = xmlString.indexOf('"', end + 1);
 				end = xmlString.indexOf('"', start + 1);
@@ -492,7 +489,6 @@
 		if (ch.pos.isValid() || !this.pos.isValid()) {
 			if (mayChangeCoordinates) {
 				this.pos = ch.pos;
-				this.LatLon = ch.LatLon;
 			}
 		}
 		this.setWayPoint(ch.getWayPoint());
@@ -655,7 +651,7 @@
 		varParams.put("DISTANCE", decSep.replaceAll(getDistance()));
 		varParams.put("BEARING", bearing);
 		if ((pos != null && pos.isValid())) {
-			varParams.put("LATLON", decSep.replaceAll(LatLon));
+			varParams.put("LATLON", decSep.replaceAll(pos.toString()));
 			varParams.put("LAT", decSep.replaceAll(pos.getLatDeg(CWPoint.DD)));
 			varParams.put("LON", decSep.replaceAll(pos.getLonDeg(CWPoint.DD)));
 		} else {
@@ -1492,16 +1488,14 @@
 
 	// Getter and Setter for private properties
 
-	public String getLatLon() {
-		return LatLon;
+	public CWPoint getPos() {
+		return pos;
 	}
 
-	public void setLatLon(String _LatLon) {
-		_LatLon = _LatLon.trim();
-		if (!_LatLon.equals(LatLon.trim()))
+	public void setPos(TrackPoint _pos) {
+		if (!_pos.toString().equals(pos.toString()))
 			setUpdated(true);
-		LatLon = _LatLon;
-		pos.set(_LatLon);
+		pos.set(_pos);
 	}
 
 	public String getBearing() {

Modified: trunk/src/CacheWolf/CalcPanel.java
===================================================================
--- trunk/src/CacheWolf/CalcPanel.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/CalcPanel.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.Metrics;
@@ -45,10 +45,10 @@
 import ewe.ui.formatted.TextDisplay;
 
 /**
-*	Class to create the panel to do calculation with waypoints<br>
-*	Also allows for creation of a custom waypoint.<br>
-*	Class ID 1400
-*/
+ *	Class to create the panel to do calculation with waypoints<br>
+ *	Also allows for creation of a custom waypoint.<br>
+ *	Class ID 1400
+ */
 
 /**
  * Wrapper class to pass bearing and distance
@@ -57,7 +57,7 @@
 	public double degrees;
 	public double distance;
 
-	public BearingDistance(){
+	public BearingDistance() {
 		this.degrees = 0;
 		this.distance = 0;
 	}
@@ -95,18 +95,17 @@
 	int currFormat;
 	mButton btnChangeLatLon;
 
-	public CalcPanel()	{
+	public CalcPanel() {
 		pref = Global.getPref();
-		profile=Global.getProfile();
+		profile = Global.getProfile();
 		mainT = Global.mainTab;
 		cacheDB = profile.cacheDB;
 
+		TopP.addNext(chkDD = new mCheckBox("d.d?"), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addNext(chkDMM = new mCheckBox("d?m.m\'"), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addNext(chkDMS = new mCheckBox("d?m\'s\""), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addNext(chkCustom = new mCheckBox(""), CellConstants.DONTSTRETCH, CellConstants.WEST);
 
-		TopP.addNext(chkDD =new mCheckBox("d.d?"),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		TopP.addNext(chkDMM =new mCheckBox("d?m.m\'"),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		TopP.addNext(chkDMS =new mCheckBox("d?m\'s\""),CellConstants.DONTSTRETCH,CellConstants.WEST);
-		TopP.addNext(chkCustom =new mCheckBox(""),CellConstants.DONTSTRETCH, CellConstants.WEST);
-
 		chkDD.setGroup(chkFormat);
 		chkDMM.setGroup(chkFormat);
 		chkDMS.setGroup(chkFormat);
@@ -114,24 +113,25 @@
 		chkFormat.setInt(1);
 		currFormat = 1;
 		String[] ls = TransformCoordinates.getProjectedSystemNames();
-		TopP.addLast(localCooSystem = new mChoice(ls, 0),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addLast(localCooSystem = new mChoice(ls, 0), CellConstants.DONTSTRETCH, CellConstants.WEST);
 
-		btnChangeLatLon=new mButton();
-		TopP.addLast(btnChangeLatLon,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		//inpBearing and direction, unit for inpDistance
-		BottomP.addNext(new mLabel(MyLocale.getMsg(1403,"Bearing")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addLast(new mLabel(MyLocale.getMsg(1404,"Distance")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addNext(inpBearing = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		btnChangeLatLon = new mButton();
+		TopP.addLast(btnChangeLatLon, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		// inpBearing and direction, unit for inpDistance
+		BottomP.addNext(new mLabel(MyLocale.getMsg(1403, "Bearing")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		BottomP.addLast(new mLabel(MyLocale.getMsg(1404, "Distance")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		BottomP.addNext(inpBearing = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		inpBearing.setText("0");
-		BottomP.addNext(inpDistance = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		BottomP.addNext(inpDistance = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		inpDistance.setText("0");
 		// Check for narrow screen and reduce width of fields to avoid horizontal scroll panel
-		if (MyLocale.getScreenWidth()<=240) {
+		if (MyLocale.getScreenWidth() <= 240) {
 			FontMetrics fm = getFontMetrics(inpBearing.getFont());
-			inpBearing.setPreferredSize(fm.getTextWidth("99999999"),fm.getHeight()*4/3);
-			inpDistance.setPreferredSize(fm.getTextWidth("99999999"),fm.getHeight()*4/3);
+			inpBearing.setPreferredSize(fm.getTextWidth("99999999"), fm.getHeight() * 4 / 3);
+			inpDistance.setPreferredSize(fm.getTextWidth("99999999"), fm.getHeight() * 4 / 3);
 		}
-		BottomP.addLast(chcDistUnit = new mChoice(new String[]{"m", "km", MyLocale.getMsg(1407,"steps"), MyLocale.getMsg(1408,"feet"), MyLocale.getMsg(1409,"yards"), MyLocale.getMsg(1410,"miles")},0),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST)).setTag(CellConstants.INSETS,new ewe.fx.Insets(0,2,0,0));
+		BottomP.addLast(chcDistUnit = new mChoice(new String[] { "m", "km", MyLocale.getMsg(1407, "steps"), MyLocale.getMsg(1408, "feet"), MyLocale.getMsg(1409, "yards"), MyLocale.getMsg(1410, "miles") }, 0), CellConstants.DONTSTRETCH,
+				(CellConstants.HFILL | CellConstants.WEST)).setTag(CellConstants.INSETS, new ewe.fx.Insets(0, 2, 0, 0));
 		if (Global.getPref().metricSystem == Metrics.METRIC) {
 			chcDistUnit.setInt(0); // Meter
 		} else {
@@ -139,19 +139,19 @@
 		}
 
 		// Buttons for calc and save
-		BottomP.addNext(btnCalc = new mButton("Calc"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addNext(btnClear = new mButton("Clear"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addNext(btnGoto = new mButton("Goto"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addLast(btnSave = new mButton(MyLocale.getMsg(311,"Create Waypoint")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		BottomP.addNext(btnCalc = new mButton("Calc"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		BottomP.addNext(btnClear = new mButton("Clear"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		BottomP.addNext(btnGoto = new mButton("Goto"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		BottomP.addLast(btnSave = new mButton(MyLocale.getMsg(311, "Create Waypoint")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 
 		// Output
-		txtOutput = new TextDisplay(3,1); // Need to limit size for small screens
+		txtOutput = new TextDisplay(3, 1); // Need to limit size for small screens
 		ScrollBarPanel sbp = new MyScrollBarPanel(txtOutput);
-		BottomP.addLast(sbp.setTag(CellConstants.SPAN, new Dimension(4,1)),CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
+		BottomP.addLast(sbp.setTag(CellConstants.SPAN, new Dimension(4, 1)), CellConstants.STRETCH, (CellConstants.FILL | CellConstants.WEST));
 
-		//add Panels
-		this.addLast(TopP,CellConstants.HSTRETCH, CellConstants.WEST);//.setTag(SPAN,new Dimension(4,1));
-		this.addLast(BottomP,CellConstants.VSTRETCH, CellConstants.VFILL|CellConstants.WEST); //.setTag(SPAN,new Dimension(4,1));
+		// add Panels
+		this.addLast(TopP, CellConstants.HSTRETCH, CellConstants.WEST);// .setTag(SPAN,new Dimension(4,1));
+		this.addLast(BottomP, CellConstants.VSTRETCH, CellConstants.VFILL | CellConstants.WEST); // .setTag(SPAN,new Dimension(4,1));
 
 	}
 
@@ -159,13 +159,13 @@
 		return CoordsScreen.getLocalSystem(currFormat);
 	}
 
-	public final void readFields(CWPoint coords, BearingDistance degKm){
+	public final void readFields(CWPoint coords, BearingDistance degKm) {
 		// coords.set(btnChangeLatLon.getText());
 		currFormat = CoordsScreen.combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt());
 		degKm.degrees = Common.parseDouble(inpBearing.getText());
 
 		double rawDistance = Common.parseDouble(inpDistance.getText());
-		switch ( chcDistUnit.getInt() ) {
+		switch (chcDistUnit.getInt()) {
 		case 0:
 			// meter
 			degKm.distance = rawDistance / 1000.0;
@@ -199,88 +199,81 @@
 	}
 
 	// ch must not be null
-	public void setFields(CacheHolder ch){
-		if ( !ch.getWayPoint().equalsIgnoreCase(lastWaypoint) ) {
+	public void setFields(CacheHolder ch) {
+		if (!ch.getWayPoint().equalsIgnoreCase(lastWaypoint)) {
 			lastWaypoint = ch.getWayPoint();
-			if (ch.pos.isValid()) {
+			if (ch.getPos().isValid()) {
 				inpBearing.setText("0");
 				inpDistance.setText("0");
-
-				//currFormat = 1;
-				if (ch.getLatLon().length()== 0) coordInp.set(0,0);
-				else coordInp.set(ch.getLatLon(), TransformCoordinates.CW);
+				coordInp.set(ch.getPos());
 				setFields();
 			}
 		}
 	}
 
-
 	public void setFields() {
 		btnChangeLatLon.setText(coordInp.toString(getLocalCooSystem()));
-		//chkFormat.selectIndex(currFormat);
+		// chkFormat.selectIndex(currFormat);
 	}
 
+	public void onEvent(Event ev) {
 
-	public void onEvent(Event ev){
-
-
-
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if (ev.target == chkFormat
-					|| ((ev.type == ControlEvent.PRESSED) && (ev.target == localCooSystem )) ) {
-				if (ev.target == localCooSystem) chkFormat.selectIndex(3);
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
+			if (ev.target == chkFormat || ((ev.type == ControlEvent.PRESSED) && (ev.target == localCooSystem))) {
+				if (ev.target == localCooSystem)
+					chkFormat.selectIndex(3);
 				readFields(coordInp, bd);
 				setFields();
 				this.repaintNow();
 			}
 
-			if (ev.target == btnCalc){
+			if (ev.target == btnCalc) {
 				readFields(coordInp, bd);
 				coordOut = coordInp.project(bd.degrees, bd.distance);
-				txtOutput.appendText(coordOut.toString(getLocalCooSystem())+ "\n",true);
+				txtOutput.appendText(coordOut.toString(getLocalCooSystem()) + "\n", true);
 			}
-			if (ev.target == btnClear){
+			if (ev.target == btnClear) {
 				txtOutput.setText("");
 			}
-			if (ev.target == btnSave){
+			if (ev.target == btnSave) {
 				CacheHolder ch = new CacheHolder();
 				readFields(coordInp, bd);
 				coordOut = coordInp.project(bd.degrees, bd.distance);
-				ch.setLatLon(coordOut.toString());
-				ch.pos.set(coordOut);
+				ch.setPos(coordOut);
 				ch.setType(CacheType.CW_TYPE_STAGE); // TODO unfertig
 				mainT.newWaypoint(ch);
 			}
 
-			if (ev.target == btnGoto){
+			if (ev.target == btnGoto) {
 				readFields(coordInp, bd);
 				coordOut = coordInp.project(bd.degrees, bd.distance);
 				mainT.gotoP.setDestinationAndSwitch(coordOut);
 			}
-			
-			if (ev.target == btnChangeLatLon){
-				if(Vm.isMobile()){
+
+			if (ev.target == btnChangeLatLon) {
+				if (Vm.isMobile()) {
 					readFields(coordInp, bd);
 					InputScreen InScr = new InputScreen(getLocalCooSystem());
-					if (coordInp.isValid())	InScr.setCoords(coordInp);
-						else InScr.setCoords(new CWPoint(0,0));
-				if (InScr.execute(null, CellConstants.TOP) == FormBase.IDOK)
-				{
-					btnChangeLatLon.setText(InScr.getCoords().toString(getLocalCooSystem()));
-					coordInp.set(InScr.getCoords());
+					if (coordInp.isValid())
+						InScr.setCoords(coordInp);
+					else
+						InScr.setCoords(new CWPoint(0, 0));
+					if (InScr.execute(null, CellConstants.TOP) == FormBase.IDOK) {
+						btnChangeLatLon.setText(InScr.getCoords().toString(getLocalCooSystem()));
+						coordInp.set(InScr.getCoords());
+					}
+				} else {
+					CoordsScreen cs = new CoordsScreen();
+					readFields(coordInp, bd);
+					cs.setFields(coordInp, getLocalCooSystem());
+					if (cs.execute() == FormBase.IDOK) {
+						btnChangeLatLon.setText(cs.getCoords().toString(getLocalCooSystem()));
+						coordInp.set(cs.getCoords());
+					}
 				}
-			}else{
-				CoordsScreen cs = new CoordsScreen();
-				readFields(coordInp, bd);
-				cs.setFields(coordInp, getLocalCooSystem());
-				if (cs.execute()== FormBase.IDOK){
-					btnChangeLatLon.setText(cs.getCoords().toString(getLocalCooSystem()));
-					coordInp.set(cs.getCoords());
-				}
-			}
 
+			}
+			super.onEvent(ev);
 		}
-		super.onEvent(ev);
 	}
-	}
 }
\ No newline at end of file

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/DetailsPanel.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -345,7 +345,7 @@
 		dirtyDetails = false;
 		inpWaypoint.setText(ch.getWayPoint());
 		inpName.setText(ch.getCacheName());
-		btnCoordinates.setText(ch.pos.toString());
+		btnCoordinates.setText(ch.getPos().toString());
 		inpHidden.setText(mainCache.getDateHidden());
 		inpOwner.setText(mainCache.getCacheOwner());
 		chcStatus.setText(ch.getStatusText());
@@ -508,7 +508,7 @@
 					waypointNotes.setText(cache.getCacheDetails(true).getCacheNotes());
 				}
 			} else if (ev.target == btnShowMap) {
-				Global.mainTab.SwitchToMovingMap(cache.pos, true);
+				Global.mainTab.SwitchToMovingMap(cache.getPos(), true);
 			} else if (ev.target == btnShowBug) {
 				// InfoScreen is = new InfoScreen(thisCache.Travelbugs.toHtml(),
 				// "Travelbugs",
@@ -566,8 +566,7 @@
 				blackStatusChanged = true;
 			} else if (ev.target == btnNewWpt) {
 				final CacheHolder ch = new CacheHolder();
-				ch.setLatLon(cache.getLatLon());
-				ch.pos = new CWPoint(cache.pos);
+				ch.setPos(cache.getPos());
 				ch.setType(CacheType.CW_TYPE_STAGE);
 				ch.setHard(CacheTerrDiff.CW_DT_UNSET);
 				ch.setTerrain(CacheTerrDiff.CW_DT_UNSET);
@@ -587,10 +586,8 @@
 					if (InScr.execute(null, CellConstants.TOP) == FormBase.IDOK) {
 						dirtyDetails = true;
 						coords = InScr.getCoords();
-						Global.getProfile().notifyUnsavedChanges(!cache.pos.toString().equals(coords.toString()));
-						cache.pos.set(coords);
+						cache.setPos(coords);
 						btnCoordinates.setText(coords.toString());
-						cache.setLatLon(coords.toString());
 						// If the current centre is valid, calculate the distance and bearing to it
 						final CWPoint centre = Global.getPref().getCurCentrePt();
 						if (centre.isValid()) {
@@ -603,10 +600,8 @@
 					if (cs.execute() == FormBase.IDOK) {
 						dirtyDetails = true;
 						coords = cs.getCoords();
-						Global.getProfile().notifyUnsavedChanges(!cache.pos.toString().equals(coords.toString()));
-						cache.pos.set(coords);
+						cache.setPos(coords);
 						btnCoordinates.setText(coords.toString());
-						cache.setLatLon(coords.toString());
 						// If the current centre is valid, calculate the distance and bearing to it
 						final CWPoint centre = Global.getPref().getCurCentrePt();
 						if (centre.isValid()) {
@@ -771,7 +766,6 @@
 		if (cache.getWayPoint().length() < 2)
 			cache.setWayPoint(cache.getWayPoint() + " ");
 		cache.setCacheName(inpName.getText().trim());
-		cache.setLatLon(cache.pos.toString());
 		if (!cache.isAddiWpt()) {
 			cache.setDateHidden(inpHidden.getText().trim());
 		}

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/Filter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,31 +1,31 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 import CacheWolf.imp.KMLImporter;
-import CacheWolf.navi.TransformCoordinates;
 
 import com.stevesoft.ewe_pat.Regex;
 
@@ -40,21 +40,22 @@
 import ewe.util.Vector;
 
 /**
-*	Class that actually filters the cache database.<br>
-*	The class that uses this filter must set the different public variables.
-*   @author BilboWolf (optimiert von salzkammergut)
-*/
-public class Filter{
-	public static final int FILTER_INACTIVE=0;
-	public static final int FILTER_ACTIVE=1;
-	public static final int FILTER_CACHELIST=2;
-	public static final int FILTER_MARKED_ONLY=3;
-	
+ * Class that actually filters the cache database.<br>
+ * The class that uses this filter must set the different public variables.
+ * 
+ * @author BilboWolf (optimiert von salzkammergut)
+ */
+public class Filter {
+	public static final int FILTER_INACTIVE = 0;
+	public static final int FILTER_ACTIVE = 1;
+	public static final int FILTER_CACHELIST = 2;
+	public static final int FILTER_MARKED_ONLY = 3;
+
 	/** Indicator whether a filter is inverted */
-	//public static boolean filterInverted=false;
+	// public static boolean filterInverted=false;
 	/** Indicator whether a filter is active. Used in status bar to indicate filter status */
-	//public static int filterActive=FILTER_INACTIVE;
-	
+	// public static int filterActive=FILTER_INACTIVE;
+
 	private static final int SMALLER = -1;
 	private static final int EQUAL = 0;
 	private static final int GREATER = 1;
@@ -75,123 +76,125 @@
 	private static final int NW = 8192;
 	private static final int NNW = 16384;
 	private static final int S = 32768;
-	private static final int ROSE_ALL= N|NNE|NE|ENE|E|ESE|SE|SSE|SSW|SW|WSW|W|WNW|NW|NNW|S;
+	private static final int ROSE_ALL = N | NNE | NE | ENE | E | ESE | SE | SSE | SSW | SW | WSW | W | WNW | NW | NNW | S;
 
 	private int distdirec = 0;
 	private int diffdirec = 0;
 	private int terrdirec = 0;
-	
+
 	String[] byVec;
-	
-	
+
 	private int roseMatchPattern;
 	private boolean hasRoseMatchPattern;
 	private int typeMatchPattern;
 	private boolean hasTypeMatchPattern;
 	private int sizeMatchPattern;
 	private boolean hasSizeMatchPattern;
-	
+
 	private boolean foundByMe;
 	private boolean notFoundByMe;
 
 	private String cacheStatus;
 	private boolean useRegexp;
 	private boolean filterNoCoord;
-	
+
 	private boolean ownedByMe;
 	private boolean notOwnedByMe;
 
 	double fscDist;
 	double fscTerr;
 	double fscDiff;
-	
+
 	private boolean archived = false;
 	private boolean notArchived = false;
-	
-	private boolean available=false;
+
+	private boolean available = false;
 	private boolean notAvailable = false;
-	double pi180=java.lang.Math.PI / 180.0;
+	double pi180 = java.lang.Math.PI / 180.0;
 
-	private long[] attributesPattern = {0l,0l,0l,0l};
+	private long[] attributesPattern = { 0l, 0l, 0l, 0l };
 	private int attributesChoice = 0;
-	
+
 	/**
-	*	Apply a route filter. Each waypoint is on a seperate line.
-	*	We use a regex method to allow for different formats of waypoints:
-	*	possible is currently: DD MM.mmm
-	*/
-	public void doFilterRoute(File routeFile, double distance){
+	 * Apply a route filter. Each waypoint is on a seperate line.
+	 * We use a regex method to allow for different formats of waypoints:
+	 * possible is currently: DD MM.mmm
+	 */
+	public void doFilterRoute(File routeFile, double distance) {
 		Global.getProfile().selectionChanged = true;
-	    CacheDB cacheDB=Global.getProfile().cacheDB;
-		//load file into a vector:
+		CacheDB cacheDB = Global.getProfile().cacheDB;
+		// load file into a vector:
 		Vector wayPoints = new Vector();
 		Regex rex = new Regex("(N|S).*?([0-9]{1,2}).*?([0-9]{1,3})(,|.)([0-9]{1,3}).*?(E|W).*?([0-9]{1,2}).*?([0-9]{1,3})(,|.)([0-9]{1,3})");
 		CWPoint cwp, fromPoint, toPoint;
 		CacheHolder ch;
-		double lat,lon, calcDistance = 0;
-		try{
-			if((routeFile.getFullPath()).indexOf(".kml") > 0){
+		double lat, lon, calcDistance = 0;
+		try {
+			if ((routeFile.getFullPath()).indexOf(".kml") > 0) {
 				KMLImporter kml = new KMLImporter(routeFile.getFullPath());
 				kml.importFile();
 				wayPoints = kml.getPoints();
 			} else {
 				FileReader in = new FileReader(routeFile);
-				String line; 
-				while((line = in.readLine()) != null){
+				String line;
+				while ((line = in.readLine()) != null) {
 					rex.search(line);
 					// parse the route file
-					if(rex.didMatch()){
-						lat = Convert.toDouble(rex.stringMatched(2)) + Convert.toDouble(rex.stringMatched(3))/60 + Convert.toDouble(rex.stringMatched(5))/60000;
-						lon = Convert.toDouble(rex.stringMatched(7)) + Convert.toDouble(rex.stringMatched(8))/60 + Convert.toDouble(rex.stringMatched(10))/60000;
-					
-						if(rex.stringMatched(1).equals("S") || rex.stringMatched(1).equals("s")) lat = -lat;
-						if(rex.stringMatched(6).equals("W") || rex.stringMatched(6).equals("w")) lon = -lon;	
-					
+					if (rex.didMatch()) {
+						lat = Convert.toDouble(rex.stringMatched(2)) + Convert.toDouble(rex.stringMatched(3)) / 60 + Convert.toDouble(rex.stringMatched(5)) / 60000;
+						lon = Convert.toDouble(rex.stringMatched(7)) + Convert.toDouble(rex.stringMatched(8)) / 60 + Convert.toDouble(rex.stringMatched(10)) / 60000;
+
+						if (rex.stringMatched(1).equals("S") || rex.stringMatched(1).equals("s"))
+							lat = -lat;
+						if (rex.stringMatched(6).equals("W") || rex.stringMatched(6).equals("w"))
+							lon = -lon;
+
 						cwp = new CWPoint(lat, lon);
-						
+
 						wayPoints.add(cwp);
 					}
 				}
 			}
-			//initialise database
-			for(int i = cacheDB.size()-1; i >=0 ; i--){
+			// initialise database
+			for (int i = cacheDB.size() - 1; i >= 0; i--) {
 				ch = cacheDB.get(i);
 				ch.in_range = false;
-				//cacheDB.set(i, ch);
+				// cacheDB.set(i, ch);
 			}
 			// for each segment of the route...
-			for(int z=0;z<wayPoints.size()-1;z++){
+			for (int z = 0; z < wayPoints.size() - 1; z++) {
 				fromPoint = new CWPoint();
 				toPoint = new CWPoint();
-				fromPoint = (CWPoint)wayPoints.get(z);
-				toPoint = (CWPoint)wayPoints.get(z+1);
-				//... go through the current cache database
-				for(int i = cacheDB.size()-1; i >=0 ; i--){
+				fromPoint = (CWPoint) wayPoints.get(z);
+				toPoint = (CWPoint) wayPoints.get(z + 1);
+				// ... go through the current cache database
+				for (int i = cacheDB.size() - 1; i >= 0; i--) {
 					ch = cacheDB.get(i);
-					cwp = new CWPoint(ch.getLatLon(), TransformCoordinates.CW);
+					cwp = new CWPoint(ch.getPos());
 					calcDistance = DistToSegment(fromPoint, toPoint, cwp);
-					calcDistance = (calcDistance*180*60)/java.lang.Math.PI;
+					calcDistance = (calcDistance * 180 * 60) / java.lang.Math.PI;
 					calcDistance = calcDistance * 1.852;
-					if(calcDistance <= distance) {
+					if (calcDistance <= distance) {
 						ch.in_range = true;
 					}
 				} // for database
 			} // for segments
-			for(int i = cacheDB.size()-1; i >=0 ; i--){
+			for (int i = cacheDB.size() - 1; i >= 0; i--) {
 				ch = cacheDB.get(i);
-				if(ch.is_filtered() == false && ch.in_range == false) ch.setFiltered(true);
+				if (ch.is_filtered() == false && ch.in_range == false)
+					ch.setFiltered(true);
 			}
-		}catch(FileNotFoundException fnex){
+		} catch (FileNotFoundException fnex) {
 			(new MessageBox("Error", "File not found", FormBase.OKB)).execute();
-		}catch(IOException ioex){
+		} catch (IOException ioex) {
 			(new MessageBox("Error", "Problem reading file!", FormBase.OKB)).execute();
 		}
 	}
-	
+
 	/**
-	*	Method to calculate the distance of a point to a segment
-	*/
-	private double DistToSegment(CWPoint fromPoint, CWPoint toPoint, CWPoint cwp){
+	 * Method to calculate the distance of a point to a segment
+	 */
+	private double DistToSegment(CWPoint fromPoint, CWPoint toPoint, CWPoint cwp) {
 		double dist = 0;
 		double px = cwp.lonDec * pi180;
 		double py = cwp.latDec * pi180;
@@ -201,91 +204,114 @@
 		double Y2 = toPoint.latDec * pi180;
 		double dx = X2 - X1;
 		double dy = Y2 - Y1;
-		if(dx == 0 && dy == 0){
+		if (dx == 0 && dy == 0) {
 			// have a point and not a segment!
 			dx = px - X1;
 			dy = py - Y1;
-			return java.lang.Math.sqrt(dx*dx + dy*dy);
+			return java.lang.Math.sqrt(dx * dx + dy * dy);
 		}
-		dist = Matrix.cross(X1,Y1,X2,Y2,px,py) / Matrix.dist(X1,Y1,X2,Y2);
-		double dot1 = Matrix.dot(X1,Y1,X2,Y2,px,py);
-		if(dot1 > 0) return Matrix.dist(X2,Y2,px,py);
-		double dot2 = Matrix.dot(X2,Y2,X1,Y1,px,py);
-		if(dot2 > 0) return Matrix.dist(X1,Y1,px,py);
+		dist = Matrix.cross(X1, Y1, X2, Y2, px, py) / Matrix.dist(X1, Y1, X2, Y2);
+		double dot1 = Matrix.dot(X1, Y1, X2, Y2, px, py);
+		if (dot1 > 0)
+			return Matrix.dist(X2, Y2, px, py);
+		double dot2 = Matrix.dot(X2, Y2, X1, Y1, px, py);
+		if (dot2 > 0)
+			return Matrix.dist(X1, Y1, px, py);
 		dist = java.lang.Math.abs(dist);
 		return dist;
-		
+
 	}
-	
+
 	/**
 	 * Set the filter from the filter data stored in the profile
 	 * (the filterscreen also updates the profile)
 	 */
 	public void setFilter() {
-		Profile profile=Global.getProfile();
-		archived     = profile.getFilterVar().charAt(0) == '1';
-		available    = profile.getFilterVar().charAt(1) == '1';
-		foundByMe    = profile.getFilterVar().charAt(2) == '1';
-		ownedByMe    = profile.getFilterVar().charAt(3) == '1';
-		notArchived  = profile.getFilterVar().charAt(4) == '1';
+		Profile profile = Global.getProfile();
+		archived = profile.getFilterVar().charAt(0) == '1';
+		available = profile.getFilterVar().charAt(1) == '1';
+		foundByMe = profile.getFilterVar().charAt(2) == '1';
+		ownedByMe = profile.getFilterVar().charAt(3) == '1';
+		notArchived = profile.getFilterVar().charAt(4) == '1';
 		notAvailable = profile.getFilterVar().charAt(5) == '1';
 		notFoundByMe = profile.getFilterVar().charAt(6) == '1';
 		notOwnedByMe = profile.getFilterVar().charAt(7) == '1';
-		cacheStatus  = profile.getFilterStatus();
-		useRegexp    = profile.getFilterUseRegexp();
+		cacheStatus = profile.getFilterStatus();
+		useRegexp = profile.getFilterUseRegexp();
 		filterNoCoord = profile.getFilterNoCoord();
-		
-		typeMatchPattern=CacheType.Type_FilterString2Type_FilterPattern(profile.getFilterType());
-		hasTypeMatchPattern=CacheType.hasTypeMatchPattern(typeMatchPattern);
-		roseMatchPattern=0;
-		String filterRose=profile.getFilterRose();
-		if (filterRose.charAt(0) == '1') roseMatchPattern|=NW;
-		if (filterRose.charAt(1) == '1') roseMatchPattern|=NNW;
-		if (filterRose.charAt(2) == '1') roseMatchPattern|=N;
-		if (filterRose.charAt(3) == '1') roseMatchPattern|=NNE;
-		if (filterRose.charAt(4) == '1') roseMatchPattern|=NE;
-		if (filterRose.charAt(5) == '1') roseMatchPattern|=ENE;
-		if (filterRose.charAt(6) == '1') roseMatchPattern|=E;
-		if (filterRose.charAt(7) == '1') roseMatchPattern|=ESE;
-		if (filterRose.charAt(8) == '1') roseMatchPattern|=SE;
-		if (filterRose.charAt(9) == '1') roseMatchPattern|=SSE;
-		if (filterRose.charAt(10) == '1') roseMatchPattern|=S;
-		if (filterRose.charAt(11) == '1') roseMatchPattern|=SSW;
-		if (filterRose.charAt(12) == '1') roseMatchPattern|=SW;
-		if (filterRose.charAt(13) == '1') roseMatchPattern|=WSW;
-		if (filterRose.charAt(14) == '1') roseMatchPattern|=W;
-		if (filterRose.charAt(15) == '1') roseMatchPattern|=WNW;
-		hasRoseMatchPattern=roseMatchPattern!=ROSE_ALL;
-		sizeMatchPattern=0;
-		String filterSize=profile.getFilterSize();
-		if (filterSize.charAt(0) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_MICRO;
-		if (filterSize.charAt(1) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_SMALL;
-		if (filterSize.charAt(2) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_NORMAL;
-		if (filterSize.charAt(3) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_LARGE;
-		if (filterSize.charAt(4) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_VERYLARGE;
-		if (filterSize.charAt(5) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_NONPHYSICAL;
-		hasSizeMatchPattern=sizeMatchPattern!=CacheSize.CW_FILTER_ALL;
-		distdirec = profile.getFilterDist().charAt(0) == 'L' ? SMALLER : GREATER; 
-		fscDist = Common.parseDouble(profile.getFilterDist().substring(1));  // Distance
-		diffdirec = profile.getFilterDiff().charAt(0) == 'L' ? SMALLER : 
-					(profile.getFilterDiff().charAt(0) == '=' ? EQUAL : GREATER );
-		fscDiff = Common.parseDouble(profile.getFilterDiff().substring(1));  // Difficulty
-		terrdirec = profile.getFilterTerr().charAt(0) == 'L' ? SMALLER : 
-				(profile.getFilterTerr().charAt(0) == '=' ? EQUAL : GREATER );
-		fscTerr = Common.parseDouble(profile.getFilterTerr().substring(1));  // Terrain
+
+		typeMatchPattern = CacheType.Type_FilterString2Type_FilterPattern(profile.getFilterType());
+		hasTypeMatchPattern = CacheType.hasTypeMatchPattern(typeMatchPattern);
+		roseMatchPattern = 0;
+		String filterRose = profile.getFilterRose();
+		if (filterRose.charAt(0) == '1')
+			roseMatchPattern |= NW;
+		if (filterRose.charAt(1) == '1')
+			roseMatchPattern |= NNW;
+		if (filterRose.charAt(2) == '1')
+			roseMatchPattern |= N;
+		if (filterRose.charAt(3) == '1')
+			roseMatchPattern |= NNE;
+		if (filterRose.charAt(4) == '1')
+			roseMatchPattern |= NE;
+		if (filterRose.charAt(5) == '1')
+			roseMatchPattern |= ENE;
+		if (filterRose.charAt(6) == '1')
+			roseMatchPattern |= E;
+		if (filterRose.charAt(7) == '1')
+			roseMatchPattern |= ESE;
+		if (filterRose.charAt(8) == '1')
+			roseMatchPattern |= SE;
+		if (filterRose.charAt(9) == '1')
+			roseMatchPattern |= SSE;
+		if (filterRose.charAt(10) == '1')
+			roseMatchPattern |= S;
+		if (filterRose.charAt(11) == '1')
+			roseMatchPattern |= SSW;
+		if (filterRose.charAt(12) == '1')
+			roseMatchPattern |= SW;
+		if (filterRose.charAt(13) == '1')
+			roseMatchPattern |= WSW;
+		if (filterRose.charAt(14) == '1')
+			roseMatchPattern |= W;
+		if (filterRose.charAt(15) == '1')
+			roseMatchPattern |= WNW;
+		hasRoseMatchPattern = roseMatchPattern != ROSE_ALL;
+		sizeMatchPattern = 0;
+		String filterSize = profile.getFilterSize();
+		if (filterSize.charAt(0) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_MICRO;
+		if (filterSize.charAt(1) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_SMALL;
+		if (filterSize.charAt(2) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_NORMAL;
+		if (filterSize.charAt(3) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_LARGE;
+		if (filterSize.charAt(4) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_VERYLARGE;
+		if (filterSize.charAt(5) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_NONPHYSICAL;
+		hasSizeMatchPattern = sizeMatchPattern != CacheSize.CW_FILTER_ALL;
+		distdirec = profile.getFilterDist().charAt(0) == 'L' ? SMALLER : GREATER;
+		fscDist = Common.parseDouble(profile.getFilterDist().substring(1)); // Distance
+		diffdirec = profile.getFilterDiff().charAt(0) == 'L' ? SMALLER : (profile.getFilterDiff().charAt(0) == '=' ? EQUAL : GREATER);
+		fscDiff = Common.parseDouble(profile.getFilterDiff().substring(1)); // Difficulty
+		terrdirec = profile.getFilterTerr().charAt(0) == 'L' ? SMALLER : (profile.getFilterTerr().charAt(0) == '=' ? EQUAL : GREATER);
+		fscTerr = Common.parseDouble(profile.getFilterTerr().substring(1)); // Terrain
 		attributesPattern = profile.getFilterAttr();
 		attributesChoice = profile.getFilterAttrChoice();
 	}
-	
+
 	/**
-	*	Apply the filter. Caches that match a criteria are flagged
-	*	is_filtered = true. The table model is responsible for displaying or
-	*	not displaying a cache that is filtered.
-	*/
-	public void doFilter(){
-		CacheDB cacheDB=Global.getProfile().cacheDB;
+	 * Apply the filter. Caches that match a criteria are flagged
+	 * is_filtered = true. The table model is responsible for displaying or
+	 * not displaying a cache that is filtered.
+	 */
+	public void doFilter() {
+		CacheDB cacheDB = Global.getProfile().cacheDB;
 		Hashtable examinedCaches;
-		if (cacheDB.size()==0) return;
+		if (cacheDB.size() == 0)
+			return;
 		if (!hasFilter()) { // If the filter was completely reset, we can just clear it
 			clearFilter();
 			return;
@@ -293,13 +319,14 @@
 		Global.getProfile().selectionChanged = true;
 		CacheHolder ch;
 		examinedCaches = new Hashtable(cacheDB.size());
-		
-		for(int i = cacheDB.size()-1; i >=0 ; i--){
+
+		for (int i = cacheDB.size() - 1; i >= 0; i--) {
 			ch = cacheDB.get(i);
-			if (examinedCaches.containsKey(ch)) continue;
-			
+			if (examinedCaches.containsKey(ch))
+				continue;
+
 			boolean filterCache = excludedByFilter(ch);
-			if (!filterCache && ch.mainCache!=null && CacheType.hasMainTypeMatchPattern(typeMatchPattern)) {
+			if (!filterCache && ch.mainCache != null && CacheType.hasMainTypeMatchPattern(typeMatchPattern)) {
 				if (examinedCaches.containsKey(ch.mainCache)) {
 					filterCache = ch.mainCache.is_filtered();
 				} else {
@@ -308,270 +335,261 @@
 					examinedCaches.put(ch.mainCache, null);
 				}
 			}
-			ch.setFiltered(filterCache);			
+			ch.setFiltered(filterCache);
 		}
 		Global.getProfile().setFilterActive(FILTER_ACTIVE);
 		examinedCaches = null;
-		//Global.getProfile().hasUnsavedChanges=true;
+		// Global.getProfile().hasUnsavedChanges=true;
 	}
 
 	public boolean excludedByFilter(CacheHolder ch) {
-		//Match once against type pattern and once against rose pattern
-		//Default is_filtered = false, means will be displayed!
-		//If cache does not match type or rose pattern then is_filtered is set to true
+		// Match once against type pattern and once against rose pattern
+		// Default is_filtered = false, means will be displayed!
+		// If cache does not match type or rose pattern then is_filtered is set to true
 		// and we proceed to next cache (no further tests needed)
-		//Then we check the other filter criteria one by one: As soon as one is found that
+		// Then we check the other filter criteria one by one: As soon as one is found that
 		// eliminates the cache (i.e. sets is_filtered to true), we can skip the other tests
 		// A cache is only displayed (i.e. is_filtered = false) if it meets all 9 filter criteria
-	    int cacheTypePattern;
-	    int cacheRosePattern;
-	    int cacheSizePattern;
-	    double dummyd1;
-	    boolean cacheFiltered=false;
-	    do {
-	        ///////////////////////////////
-	        // Filter criterium 1: Cache type
-	        ///////////////////////////////
-	        if (hasTypeMatchPattern) { // Only do the checks if we have a filter
-	        	cacheTypePattern = CacheType.getCacheTypePattern(ch.getType());
-		        if ((cacheTypePattern & typeMatchPattern) == 0) {
-			        cacheFiltered = true; break;
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 2: Bearing from centre
-	        ///////////////////////////////
-	        // The optimal number of comparisons to identify one of 16 objects is 4 (=log2(16))
-	        // By using else if we can reduce the number of comparisons from 16 to just over 8
-	        // By first checking the first letter, we can reduce the average number further to
-	        // just under 5
-	        if (hasRoseMatchPattern) {
-		        if (ch.getBearing().startsWith("N")) {
-			        if (ch.getBearing().equals("NW"))
-				        cacheRosePattern = NW;
-			        else if (ch.getBearing().equals("NNW"))
-				        cacheRosePattern = NNW;
-			        else if (ch.getBearing().equals("N"))
-				        cacheRosePattern = N;
-			        else if (ch.getBearing().equals("NNE"))
-				        cacheRosePattern = NNE;
-			        else
-				        cacheRosePattern = NE;
-		        } else if (ch.getBearing().startsWith("E")) {
-			        if (ch.getBearing().equals("ENE"))
-				        cacheRosePattern = ENE;
-			        else if (ch.getBearing().equals("E"))
-				        cacheRosePattern = E;
-			        else
-				        cacheRosePattern = ESE;
-		        } else if (ch.getBearing().startsWith("S")) {
-			        if (ch.getBearing().equals("SW"))
-				        cacheRosePattern = SW;
-			        else if (ch.getBearing().equals("SSW"))
-				        cacheRosePattern = SSW;
-			        else if (ch.getBearing().equals("S"))
-				        cacheRosePattern = S;
-			        else if (ch.getBearing().equals("SSE"))
-				        cacheRosePattern = SSE;
-			        else
-				        cacheRosePattern = SE;
-		        } else {
-			        if (ch.getBearing().equals("WNW"))
-				        cacheRosePattern = WNW;
-			        else if (ch.getBearing().equals("W"))
-				        cacheRosePattern = W;
-			        else if (ch.getBearing().equals("WSW"))
-				        cacheRosePattern = WSW;
-			        else
-				        cacheRosePattern = 0;
-		        }
-		        if ((cacheRosePattern != 0) && ((cacheRosePattern & roseMatchPattern) == 0)) {
-			        cacheFiltered = true; break;
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 3: Distance
-	        ///////////////////////////////
-	        if (fscDist > 0.0) {
-		        dummyd1 = ch.kilom;
-		        if (distdirec == SMALLER && dummyd1 > fscDist) {
-			        cacheFiltered = true; break;
-		        }
-		        if (distdirec == GREATER && dummyd1 < fscDist) {
-			        cacheFiltered = true; break;
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 4: Difficulty
-	        ///////////////////////////////
-	        if (fscDiff > 0.0) {
-		        dummyd1 = ch.getHard() / 10D;
-		        if (diffdirec == SMALLER && dummyd1 > fscDiff) {
-			        cacheFiltered = true; break;
-		        }
-		        if (diffdirec == EQUAL && dummyd1 != fscDiff) {
-			        cacheFiltered = true; break;
-		        }
-		        if (diffdirec == GREATER && dummyd1 < fscDiff) {
-			        cacheFiltered = true; break;
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 5: Terrain
-	        ///////////////////////////////
-	        if (fscTerr > 0.0) {
-	        	dummyd1 = ch.getTerrain() / 10D;
-		        if (terrdirec == SMALLER && dummyd1 > fscTerr) {
-			        cacheFiltered = true; break;
-		        }
-		        if (terrdirec == EQUAL && dummyd1 != fscTerr) {
-			        cacheFiltered = true; break;
-		        }
-		        if (terrdirec == GREATER && dummyd1 < fscTerr) {
-			        cacheFiltered = true; break;
-		        }
-	        }
+		int cacheTypePattern;
+		int cacheRosePattern;
+		int cacheSizePattern;
+		double dummyd1;
+		boolean cacheFiltered = false;
+		do {
+			// /////////////////////////////
+			// Filter criterium 1: Cache type
+			// /////////////////////////////
+			if (hasTypeMatchPattern) { // Only do the checks if we have a filter
+				cacheTypePattern = CacheType.getCacheTypePattern(ch.getType());
+				if ((cacheTypePattern & typeMatchPattern) == 0) {
+					cacheFiltered = true;
+					break;
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 2: Bearing from centre
+			// /////////////////////////////
+			// The optimal number of comparisons to identify one of 16 objects is 4 (=log2(16))
+			// By using else if we can reduce the number of comparisons from 16 to just over 8
+			// By first checking the first letter, we can reduce the average number further to
+			// just under 5
+			if (hasRoseMatchPattern) {
+				if (ch.getBearing().startsWith("N")) {
+					if (ch.getBearing().equals("NW"))
+						cacheRosePattern = NW;
+					else if (ch.getBearing().equals("NNW"))
+						cacheRosePattern = NNW;
+					else if (ch.getBearing().equals("N"))
+						cacheRosePattern = N;
+					else if (ch.getBearing().equals("NNE"))
+						cacheRosePattern = NNE;
+					else
+						cacheRosePattern = NE;
+				} else if (ch.getBearing().startsWith("E")) {
+					if (ch.getBearing().equals("ENE"))
+						cacheRosePattern = ENE;
+					else if (ch.getBearing().equals("E"))
+						cacheRosePattern = E;
+					else
+						cacheRosePattern = ESE;
+				} else if (ch.getBearing().startsWith("S")) {
+					if (ch.getBearing().equals("SW"))
+						cacheRosePattern = SW;
+					else if (ch.getBearing().equals("SSW"))
+						cacheRosePattern = SSW;
+					else if (ch.getBearing().equals("S"))
+						cacheRosePattern = S;
+					else if (ch.getBearing().equals("SSE"))
+						cacheRosePattern = SSE;
+					else
+						cacheRosePattern = SE;
+				} else {
+					if (ch.getBearing().equals("WNW"))
+						cacheRosePattern = WNW;
+					else if (ch.getBearing().equals("W"))
+						cacheRosePattern = W;
+					else if (ch.getBearing().equals("WSW"))
+						cacheRosePattern = WSW;
+					else
+						cacheRosePattern = 0;
+				}
+				if ((cacheRosePattern != 0) && ((cacheRosePattern & roseMatchPattern) == 0)) {
+					cacheFiltered = true;
+					break;
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 3: Distance
+			// /////////////////////////////
+			if (fscDist > 0.0) {
+				dummyd1 = ch.kilom;
+				if (distdirec == SMALLER && dummyd1 > fscDist) {
+					cacheFiltered = true;
+					break;
+				}
+				if (distdirec == GREATER && dummyd1 < fscDist) {
+					cacheFiltered = true;
+					break;
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 4: Difficulty
+			// /////////////////////////////
+			if (fscDiff > 0.0) {
+				dummyd1 = ch.getHard() / 10D;
+				if (diffdirec == SMALLER && dummyd1 > fscDiff) {
+					cacheFiltered = true;
+					break;
+				}
+				if (diffdirec == EQUAL && dummyd1 != fscDiff) {
+					cacheFiltered = true;
+					break;
+				}
+				if (diffdirec == GREATER && dummyd1 < fscDiff) {
+					cacheFiltered = true;
+					break;
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 5: Terrain
+			// /////////////////////////////
+			if (fscTerr > 0.0) {
+				dummyd1 = ch.getTerrain() / 10D;
+				if (terrdirec == SMALLER && dummyd1 > fscTerr) {
+					cacheFiltered = true;
+					break;
+				}
+				if (terrdirec == EQUAL && dummyd1 != fscTerr) {
+					cacheFiltered = true;
+					break;
+				}
+				if (terrdirec == GREATER && dummyd1 < fscTerr) {
+					cacheFiltered = true;
+					break;
+				}
+			}
 
-	        ///////////////////////////////
-	        // Filter criterium 6: Found by me
-	        ///////////////////////////////
-	        if ((ch.is_found() && !foundByMe) || (!ch.is_found() && !notFoundByMe)) {
-		        cacheFiltered = true; break;
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 7: Owned by me
-	        ///////////////////////////////
-	        if ((ch.is_owned() && !ownedByMe) || (!ch.is_owned() && !notOwnedByMe)) {
-		        cacheFiltered = true; break;
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 8: Archived
-	        ///////////////////////////////
-	        if ((ch.is_archived() && !archived) || (!ch.is_archived() && !notArchived)) {
-		        cacheFiltered = true; break;
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 9: Unavailable
-	        ///////////////////////////////
-	        if ((ch.is_available() && !available) || (!ch.is_available() && !notAvailable)) {
-		        cacheFiltered = true; break;
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 10: Size
-	        ///////////////////////////////
-	        if (hasSizeMatchPattern) {
-		        cacheSizePattern = CacheSize.getFilterPattern(ch.getCacheSize());
-		        if ((cacheSizePattern & sizeMatchPattern) == 0) {
-			        cacheFiltered = true; break;
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 11: Attributes
-	        ///////////////////////////////
-	        if ((attributesPattern[0] != 0 || attributesPattern[1] != 0 || attributesPattern[2] != 0 || attributesPattern[3] != 0) 
-	        		&& ch.mainCache == null) {
-	        	long[] chAtts=ch.getAttributesBits();
-		        if (attributesChoice == 0) {
-			        // AND-condition:
-			        if ((chAtts[0] & attributesPattern[0]) != attributesPattern[0] ||
-				        	(chAtts[1] & attributesPattern[1]) != attributesPattern[1] ||
-				        	(chAtts[2] & attributesPattern[2]) != attributesPattern[2] ||
-				        	(chAtts[3] & attributesPattern[3]) != attributesPattern[3] )
-				        {
-				        cacheFiltered = true;
-				        break;
-			        }
-		        } else if (attributesChoice == 1) {
-			        // OR-condition:
-			        if ((chAtts[0] & attributesPattern[0]) == 0 &&
-				        	(chAtts[1] & attributesPattern[1]) == 0 &&
-				        	(chAtts[2] & attributesPattern[2]) == 0 &&
-				        	(chAtts[3] & attributesPattern[3]) == 0 )
-				        {
-				        cacheFiltered = true;
-				        break;
-			        }
-		        } else {
-			        // NOT-condition:
-			        if ((chAtts[0] & attributesPattern[0]) != 0 ||
-				        	(chAtts[1] & attributesPattern[1]) != 0 ||
-				        	(chAtts[2] & attributesPattern[2]) != 0 ||
-				        	(chAtts[3] & attributesPattern[3]) != 0 )
-				        {
-				        cacheFiltered = true;
-				        break;
-			        }
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 12: Status
-	        ///////////////////////////////
-	        if (!cacheStatus.equals("")) {
-	        	if (!useRegexp) {
-	        		if (ch.getStatusText().toLowerCase().indexOf(cacheStatus.toLowerCase())<0) {
-	        			cacheFiltered = true;
-	        			break;
-	        		}
-	        	} else {
-	        		Regex rex=new Regex(cacheStatus.toLowerCase());
-	        		rex.search(ch.getStatusText().toLowerCase());
-	        		if (rex.stringMatched()==null) {
-	        			cacheFiltered = true;
-	        			break;
-	        		}
-	        	}
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 11: NoCoord
-	        ///////////////////////////////
-	        if (!filterNoCoord && !ch.pos.isValid()) {
-	          cacheFiltered = true;
-	        	break;
-        }
+			// /////////////////////////////
+			// Filter criterium 6: Found by me
+			// /////////////////////////////
+			if ((ch.is_found() && !foundByMe) || (!ch.is_found() && !notFoundByMe)) {
+				cacheFiltered = true;
+				break;
+			}
+			// /////////////////////////////
+			// Filter criterium 7: Owned by me
+			// /////////////////////////////
+			if ((ch.is_owned() && !ownedByMe) || (!ch.is_owned() && !notOwnedByMe)) {
+				cacheFiltered = true;
+				break;
+			}
+			// /////////////////////////////
+			// Filter criterium 8: Archived
+			// /////////////////////////////
+			if ((ch.is_archived() && !archived) || (!ch.is_archived() && !notArchived)) {
+				cacheFiltered = true;
+				break;
+			}
+			// /////////////////////////////
+			// Filter criterium 9: Unavailable
+			// /////////////////////////////
+			if ((ch.is_available() && !available) || (!ch.is_available() && !notAvailable)) {
+				cacheFiltered = true;
+				break;
+			}
+			// /////////////////////////////
+			// Filter criterium 10: Size
+			// /////////////////////////////
+			if (hasSizeMatchPattern) {
+				cacheSizePattern = CacheSize.getFilterPattern(ch.getCacheSize());
+				if ((cacheSizePattern & sizeMatchPattern) == 0) {
+					cacheFiltered = true;
+					break;
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 11: Attributes
+			// /////////////////////////////
+			if ((attributesPattern[0] != 0 || attributesPattern[1] != 0 || attributesPattern[2] != 0 || attributesPattern[3] != 0) && ch.mainCache == null) {
+				long[] chAtts = ch.getAttributesBits();
+				if (attributesChoice == 0) {
+					// AND-condition:
+					if ((chAtts[0] & attributesPattern[0]) != attributesPattern[0] || (chAtts[1] & attributesPattern[1]) != attributesPattern[1] || (chAtts[2] & attributesPattern[2]) != attributesPattern[2]
+							|| (chAtts[3] & attributesPattern[3]) != attributesPattern[3]) {
+						cacheFiltered = true;
+						break;
+					}
+				} else if (attributesChoice == 1) {
+					// OR-condition:
+					if ((chAtts[0] & attributesPattern[0]) == 0 && (chAtts[1] & attributesPattern[1]) == 0 && (chAtts[2] & attributesPattern[2]) == 0 && (chAtts[3] & attributesPattern[3]) == 0) {
+						cacheFiltered = true;
+						break;
+					}
+				} else {
+					// NOT-condition:
+					if ((chAtts[0] & attributesPattern[0]) != 0 || (chAtts[1] & attributesPattern[1]) != 0 || (chAtts[2] & attributesPattern[2]) != 0 || (chAtts[3] & attributesPattern[3]) != 0) {
+						cacheFiltered = true;
+						break;
+					}
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 12: Status
+			// /////////////////////////////
+			if (!cacheStatus.equals("")) {
+				if (!useRegexp) {
+					if (ch.getStatusText().toLowerCase().indexOf(cacheStatus.toLowerCase()) < 0) {
+						cacheFiltered = true;
+						break;
+					}
+				} else {
+					Regex rex = new Regex(cacheStatus.toLowerCase());
+					rex.search(ch.getStatusText().toLowerCase());
+					if (rex.stringMatched() == null) {
+						cacheFiltered = true;
+						break;
+					}
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 11: NoCoord
+			// /////////////////////////////
+			if (!filterNoCoord && !ch.getPos().isValid()) {
+				cacheFiltered = true;
+				break;
+			}
 
-	        break;
-        } while (true);
+			break;
+		} while (true);
 		return cacheFiltered;
-    }
-	
+	}
+
 	/**
-	*	Switches flag to invert filter property.
-	*/
-	public void invertFilter(){
+	 * Switches flag to invert filter property.
+	 */
+	public void invertFilter() {
 		Global.getProfile().setFilterInverted(!Global.getProfile().isFilterInverted());
 	}
-	
+
 	/**
-	*	Clear the is_filtered flag from the cache database.
-	*/
-	public void clearFilter(){
+	 * Clear the is_filtered flag from the cache database.
+	 */
+	public void clearFilter() {
 		Global.getProfile().selectionChanged = true;
-		CacheDB cacheDB=Global.getProfile().cacheDB;
-		for(int i = cacheDB.size()-1; i >=0 ; i--){
+		CacheDB cacheDB = Global.getProfile().cacheDB;
+		for (int i = cacheDB.size() - 1; i >= 0; i--) {
 			CacheHolder ch = cacheDB.get(i);
 			ch.setFiltered(false);
 		}
 		Global.getProfile().setFilterActive(FILTER_INACTIVE);
 	}
 
-		public boolean hasFilter() {
-		Profile prof=Global.getProfile();
-		long[] attribs=prof.getFilterAttr();
-		return !(prof.getFilterType().equals(FilterData.FILTERTYPE) &&
-		    prof.getFilterRose().equals(FilterData.FILTERROSE) &&
-		    prof.getFilterVar().equals(FilterData.FILTERVAR) &&
-		    prof.getFilterSize().equals(FilterData.FILTERSIZE) &&
-		    prof.getFilterDist().equals("L") &&
-		    prof.getFilterDiff().equals("L") &&
-		    prof.getFilterTerr().equals("L") &&
-		    attribs[0] == 0l &&
-		    attribs[1] == 0l &&
-		    attribs[2] == 0l &&
-		    attribs[3] == 0l &&
-		    prof.getFilterStatus().equals("") &&
-        prof.getFilterNoCoord());
+	public boolean hasFilter() {
+		Profile prof = Global.getProfile();
+		long[] attribs = prof.getFilterAttr();
+		return !(prof.getFilterType().equals(FilterData.FILTERTYPE) && prof.getFilterRose().equals(FilterData.FILTERROSE) && prof.getFilterVar().equals(FilterData.FILTERVAR) && prof.getFilterSize().equals(FilterData.FILTERSIZE)
+				&& prof.getFilterDist().equals("L") && prof.getFilterDiff().equals("L") && prof.getFilterTerr().equals("L") && attribs[0] == 0l && attribs[1] == 0l && attribs[2] == 0l && attribs[3] == 0l && prof.getFilterStatus().equals("") && prof
+					.getFilterNoCoord());
 	}
 
 }
-
-

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/MainTab.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -386,15 +386,15 @@
 			// why not using the target ???
 			CacheHolder selectedCache = profile.cacheDB.get(selectedIndex);
 			// try to start new waypoint with real coords
-			if (!pCh.pos.isValid()) {
-				pCh.pos.set(selectedCache.pos);
+			if (!pCh.getPos().isValid()) {
+				pCh.setPos(selectedCache.getPos());
 			}
 			if (selectedCache.isAddiWpt()) {
 				if (selectedCache.mainCache != null) {
 					mainCache = selectedCache.mainCache.getWayPoint();
 					// try to start new waypoint with real coords
-					if (!pCh.pos.isValid()) {
-						pCh.pos.set(selectedCache.mainCache.pos);
+					if (!pCh.getPos().isValid()) {
+						pCh.setPos(selectedCache.mainCache.getPos());
 					}
 				} else {
 					mainCache = null;

Modified: trunk/src/CacheWolf/MyComparer.java
===================================================================
--- trunk/src/CacheWolf/MyComparer.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/MyComparer.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -73,7 +73,7 @@
 		} else if (colToCompare == 6) {
 			for (int i = 0; i < visibleSize; i++) {
 				CacheHolder ch = cacheDB.get(i);
-				ch.sort = ch.getLatLon();
+				ch.sort = ch.getPos().toString();
 			}
 		} else if (colToCompare == 7) {
 			for (int i = 0; i < visibleSize; i++) {

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/Parser.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,72 +1,72 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 /* 
-A parser that parses the following grammar:
-EBNF Meta-Symbols:
-  {xx}        xx can occur any number of times incl 0
-  [xx]        xx or empty
-  |           or
-  "x"         x is terminal symbol
+ A parser that parses the following grammar:
+ EBNF Meta-Symbols:
+ {xx}        xx can occur any number of times incl 0
+ [xx]        xx or empty
+ |           or
+ "x"         x is terminal symbol
 
-command -> if |
-         simplecommand
+ command -> if |
+ simplecommand
 
-simplecommand -> "stop" | "st" |
-		   assign
-         stringexp |
+ simplecommand -> "stop" | "st" |
+ assign
+ stringexp |
 
-if -> "IF" stringexpr compop stringexpr "THEN" simplecommand { ";" simplecommand } "ENDIF"          // Nested IF's not allowed
+ if -> "IF" stringexpr compop stringexpr "THEN" simplecommand { ";" simplecommand } "ENDIF"          // Nested IF's not allowed
 
-compop -> "=" | "<" | ">" | "<=" | "==" | ">=" | "<>" | "!=" | "><"
+ compop -> "=" | "<" | ">" | "<=" | "==" | ">=" | "<>" | "!=" | "><"
 
-assign -> ident = [ stringexpr ]
+ assign -> ident = [ stringexpr ]
 
-stringexp -> (string | expr ) {string | tailexp }
+ stringexp -> (string | expr ) {string | tailexp }
 
-expr -> ["+" | "-"] tailexp [ formatstring ]
+ expr -> ["+" | "-"] tailexp [ formatstring ]
 
-tailexp -> term { ("+" | "-") term }
+ tailexp -> term { ("+" | "-") term }
 
-term -> factor { ("*" | "/") factor }
+ term -> factor { ("*" | "/") factor }
 
-factor -> expfactor { "^" expfactor }
+ factor -> expfactor { "^" expfactor }
 
-expfactor -> ident |
-        number |
-        "(" stringexpr ")" |
-        function "(" stringexpr { "," stringexpr }")"
+ expfactor -> ident |
+ number |
+ "(" stringexpr ")" |
+ function "(" stringexpr { "," stringexpr }")"
 
-function -> "sin" | "cos" | "tan" | "asin" | "acos" | "atan" | "goto" | "project" | "show"  | "crosstotal" |
-          "rot13" | "len" | "mid"
+ function -> "sin" | "cos" | "tan" | "asin" | "acos" | "atan" | "goto" | "project" | "show"  | "crosstotal" |
+ "rot13" | "len" | "mid"
 
-ident -> valid identifier
-number -> valid number
+ ident -> valid identifier
+ number -> valid number
 
 
-*/
+ */
 package CacheWolf;
 
 import CacheWolf.navi.Metrics;
@@ -82,196 +82,155 @@
 import ewe.util.mString;
 
 /**
-*	The wolf language parser. New version - January 2007
-*
-*   New features:
-*   - Improved error handling
-*   - Strings and doubles can be freely mixed as appropriate. Depending on context a conversion is performed,
-*   - Variables can store strings or doubles
-*   - Global variables (starting with $) are remembered across multiple calls to parser
-*   - Global variables are initialised with "", local variables result in error if used before setting value
-*   - IF statement added
-*   - Many new functions (encode,format,goto,len,mid,count, substring,ucase,lcase,val,sval,replace, reverse,project)
-*   - less typing
-*   	- Function aliases
-*   	- Function names can be flexibly abbreviated, i.e. instead of crosstotal write cr or cross or crosst ...
-*   	- show no longer needed
-*   	- Command terminator ; no longer compulsory (only between multiple commands on same line)
-*   - New functions can easily be added
-*   - Can select whether variable names are case sensitive
-*
-*   To add a new function:
-*     1) Add its name and alias and allowed number of args to array functions
-*     2) Add a new private method in the "functions" section
-*     3) Add call to private method in executeFunction
-*   @author salzkammergut Januay 2007
-*/
-public class Parser{
+ * The wolf language parser. New version - January 2007
+ * 
+ * New features:
+ * - Improved error handling
+ * - Strings and doubles can be freely mixed as appropriate. Depending on context a conversion is performed,
+ * - Variables can store strings or doubles
+ * - Global variables (starting with $) are remembered across multiple calls to parser
+ * - Global variables are initialised with "", local variables result in error if used before setting value
+ * - IF statement added
+ * - Many new functions (encode,format,goto,len,mid,count, substring,ucase,lcase,val,sval,replace, reverse,project)
+ * - less typing
+ * - Function aliases
+ * - Function names can be flexibly abbreviated, i.e. instead of crosstotal write cr or cross or crosst ...
+ * - show no longer needed
+ * - Command terminator ; no longer compulsory (only between multiple commands on same line)
+ * - New functions can easily be added
+ * - Can select whether variable names are case sensitive
+ * 
+ * To add a new function:
+ * 1) Add its name and alias and allowed number of args to array functions
+ * 2) Add a new private method in the "functions" section
+ * 3) Add call to private method in executeFunction
+ * 
+ * @author salzkammergut Januay 2007
+ */
+public class Parser {
 
 	private class fnType {
-		public String funcName; 	 // the function name in the user input
-		public String alias;         // the funcName is mapped to this alias
-		public int nargs;            // bitmap for number of args, i.e. 14 = 1 or 2 or 3 args; 5 = 0 or 2 args
-									 // i.e. 1<<nargs ORed together
+		public String funcName; // the function name in the user input
+		public String alias; // the funcName is mapped to this alias
+		public int nargs; // bitmap for number of args, i.e. 14 = 1 or 2 or 3 args; 5 = 0 or 2 args
+							// i.e. 1<<nargs ORed together
+
 		fnType(String funcName, String alias, int nargs) {
-			this.funcName=funcName; this.alias=alias; this.nargs=nargs;
+			this.funcName = funcName;
+			this.alias = alias;
+			this.nargs = nargs;
 		}
-		boolean nargsValid(int testNargs){
-			return ((1<<testNargs)&this.nargs)!=0;
+
+		boolean nargsValid(int testNargs) {
+			return ((1 << testNargs) & this.nargs) != 0;
 		}
 	}
-    fnType[] functions=new fnType[]{ // in alphabetical order
-    	new fnType("abs","abs",2),
-    	new fnType("acos","acos",2),
-    	new fnType("asin","asin",2),
-    	new fnType("atan","atan",2),
-      	new fnType("bearing","bearing",4),
-    	new fnType("cb","cb",16),
-     	new fnType("centre","center",3),
-    	new fnType("center","center",3),
-    	new fnType("cls","cls",1),
-    	new fnType("clearscreen","cls",1),
-    	new fnType("cos","cos",2),
-    	new fnType("count","count",4),
-     	new fnType("cp","cp",1),
-    	new fnType("crossbearing","cb",16),
-    	new fnType("crosstotal","ct",6),
-    	new fnType("ct","ct",2),
-     	new fnType("curpos","cp",1),
-     	new fnType("d2r","deg2rad",2),
-     	new fnType("deg","deg",1),
-     	new fnType("deg2rad","deg2rad",2),
-     	new fnType("distance","distance",4),
-     	new fnType("encode","encode",8),
-    	new fnType("format","format",12),
-    	new fnType("goto","goto",6),
-    	new fnType("ic","ic",3),
-    	new fnType("ignorecase","ic",3),
-    	new fnType("instr","instr",12),
-    	new fnType("int","int",2),
-    	new fnType("lcase","lc",2),
-    	new fnType("length","len",2),
-    	new fnType("mid","mid",12),
-    	new fnType("mod","mod",4),
-     	new fnType("pc","pz",3),
-     	new fnType("profilecenter","pz",3),
-     	new fnType("profilecentre","pz",3),
-     	new fnType("profilzentrum","pz",3),
-    	new fnType("project","project",8),
-     	new fnType("pz","pz",3),
-    	new fnType("quersumme","ct",6),
-    	new fnType("r2d","rad2deg",2),
-    	new fnType("rad","rad",1),
-    	new fnType("rad2deg","rad2deg",2),
-    	new fnType("replace","replace",8),
-    	new fnType("reverse","reverse",2),
-    	new fnType("rot13","rot13",2),
-    	new fnType("show","show",2),
-    	new fnType("sin","sin",2),
-    	new fnType("skeleton","skeleton",3),
-    	new fnType("sqrt","sqrt",2),
-    	new fnType("sval","sval",2),
-    	new fnType("tolowercase","lc",2),
-    	new fnType("touppercase","uc",2),
-    	new fnType("tan","tan",2),
-    	new fnType("ucase","uc",2),
-    	new fnType("val","val",2),
-     	new fnType("zentrum","center",3)
-     	    	};
+
+	fnType[] functions = new fnType[] { // in alphabetical order
+	new fnType("abs", "abs", 2), new fnType("acos", "acos", 2), new fnType("asin", "asin", 2), new fnType("atan", "atan", 2), new fnType("bearing", "bearing", 4), new fnType("cb", "cb", 16), new fnType("centre", "center", 3),
+			new fnType("center", "center", 3), new fnType("cls", "cls", 1), new fnType("clearscreen", "cls", 1), new fnType("cos", "cos", 2), new fnType("count", "count", 4), new fnType("cp", "cp", 1), new fnType("crossbearing", "cb", 16),
+			new fnType("crosstotal", "ct", 6), new fnType("ct", "ct", 2), new fnType("curpos", "cp", 1), new fnType("d2r", "deg2rad", 2), new fnType("deg", "deg", 1), new fnType("deg2rad", "deg2rad", 2), new fnType("distance", "distance", 4),
+			new fnType("encode", "encode", 8), new fnType("format", "format", 12), new fnType("goto", "goto", 6), new fnType("ic", "ic", 3), new fnType("ignorecase", "ic", 3), new fnType("instr", "instr", 12), new fnType("int", "int", 2),
+			new fnType("lcase", "lc", 2), new fnType("length", "len", 2), new fnType("mid", "mid", 12), new fnType("mod", "mod", 4), new fnType("pc", "pz", 3), new fnType("profilecenter", "pz", 3), new fnType("profilecentre", "pz", 3),
+			new fnType("profilzentrum", "pz", 3), new fnType("project", "project", 8), new fnType("pz", "pz", 3), new fnType("quersumme", "ct", 6), new fnType("r2d", "rad2deg", 2), new fnType("rad", "rad", 1), new fnType("rad2deg", "rad2deg", 2),
+			new fnType("replace", "replace", 8), new fnType("reverse", "reverse", 2), new fnType("rot13", "rot13", 2), new fnType("show", "show", 2), new fnType("sin", "sin", 2), new fnType("skeleton", "skeleton", 3), new fnType("sqrt", "sqrt", 2),
+			new fnType("sval", "sval", 2), new fnType("tolowercase", "lc", 2), new fnType("touppercase", "uc", 2), new fnType("tan", "tan", 2), new fnType("ucase", "uc", 2), new fnType("val", "val", 2), new fnType("zentrum", "center", 3) };
 	private static int scanpos = 0;
-	CWPoint cwPt=new CWPoint();
-	Vector calcStack=new Vector();
+	CWPoint cwPt = new CWPoint();
+	Vector calcStack = new Vector();
 	Hashtable symbolTable = new Hashtable(50);
 	TokenObj thisToken = new TokenObj();
 	Vector tokenStack;
 	Vector messageStack;
 
-	public Parser(){ // Global constructor
+	public Parser() { // Global constructor
 	}
 
-///////////////////////////////////////////
-//  Utility functions
-///////////////////////////////////////////
+	// /////////////////////////////////////////
+	// Utility functions
+	// /////////////////////////////////////////
 
-	/* All errors are handled via function 'err'. Rather than creating many different Exceptions,
+	/*
+	 * All errors are handled via function 'err'. Rather than creating many different Exceptions,
 	 * only the standard Exception is used. err raises this exception and thereby causes the stack to be
 	 * unwound until 'parse' eventually catches the exception and returns to SolverPanel, which displays
 	 * the messageStack containing the error message.
 	 */
 
 	/**
-     * Add an error message to the message stack and raise an Exception.
-    */
+	 * Add an error message to the message stack and raise an Exception.
+	 */
 	private void err(String str) throws Exception {
-    	messageStack.add(MyLocale.getMsg(1700,"Error on line: ") + thisToken.line + "  "+MyLocale.getMsg(1701,"position: ") + thisToken.position);
-    	messageStack.add(str);
-    	// move cursor to error location
-    	if (Global.mainTab.solverP.mText.setSelectionRange(0,thisToken.line-1,thisToken.position+thisToken.token.length()-1,thisToken.line-1))Global.mainTab.solverP.mText.repaintNow();
-    	throw new Exception("Error "+str);
-    }
+		messageStack.add(MyLocale.getMsg(1700, "Error on line: ") + thisToken.line + "  " + MyLocale.getMsg(1701, "position: ") + thisToken.position);
+		messageStack.add(str);
+		// move cursor to error location
+		if (Global.mainTab.solverP.mText.setSelectionRange(0, thisToken.line - 1, thisToken.position + thisToken.token.length() - 1, thisToken.line - 1))
+			Global.mainTab.solverP.mText.repaintNow();
+		throw new Exception("Error " + str);
+	}
 
-    /** Shows global symbols */
-    private void showVars(boolean globals) throws Exception {
-    	Iterator it=symbolTable.entries();
-    	while (it.hasNext()) {
-    		String varName=((String)((ewe.util.Map.MapEntry) it.next()).getKey());
-    		if (globals == varName.startsWith("$")) {
-    			String value=(String) getVariable(varName);
-    			if (java.lang.Double.isNaN(toNumber(value)))
-    				messageStack.add(varName+" = \""+STRreplace.replace(value.toString(),"\"","\"\"")+"\"");
-    			else
-    				messageStack.add(varName+" = "+value);
-    		}
-    	}
-    }
+	/** Shows global symbols */
+	private void showVars(boolean globals) throws Exception {
+		Iterator it = symbolTable.entries();
+		while (it.hasNext()) {
+			String varName = ((String) ((ewe.util.Map.MapEntry) it.next()).getKey());
+			if (globals == varName.startsWith("$")) {
+				String value = (String) getVariable(varName);
+				if (java.lang.Double.isNaN(toNumber(value)))
+					messageStack.add(varName + " = \"" + STRreplace.replace(value.toString(), "\"", "\"\"") + "\"");
+				else
+					messageStack.add(varName + " = " + value);
+			}
+		}
+	}
 
 	/** Clears the symbol table of all non-global symbols (those not starting with $) */
-    private void clearLocalSymbols() {
-    	Iterator it=symbolTable.entries();
-    	while (it.hasNext()) {
-    		ewe.util.Map.MapEntry sym=(ewe.util.Map.MapEntry) it.next();
-    		if (!((String)sym.getKey()).startsWith("$"))
-    			symbolTable.remove(sym.getKey());
-    	}
-    	Double pi=new Double(java.lang.Math.PI);
-    	symbolTable.put("PI",pi);
-    	symbolTable.put("pi",pi); // To make it easier for the user we also add a lowercase version of pi
-    }
+	private void clearLocalSymbols() {
+		Iterator it = symbolTable.entries();
+		while (it.hasNext()) {
+			ewe.util.Map.MapEntry sym = (ewe.util.Map.MapEntry) it.next();
+			if (!((String) sym.getKey()).startsWith("$"))
+				symbolTable.remove(sym.getKey());
+		}
+		Double pi = new Double(java.lang.Math.PI);
+		symbolTable.put("PI", pi);
+		symbolTable.put("pi", pi); // To make it easier for the user we also add a lowercase version of pi
+	}
 
 	private boolean isVariable(String varName) {
-		return varName.startsWith("$") ||  // Global variables exist per default
-		       symbolTable.containsKey(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
+		return varName.startsWith("$") || // Global variables exist per default
+				symbolTable.containsKey(Global.getPref().solverIgnoreCase ? varName.toUpperCase() : varName);
 	}
 
 	private boolean isInteger(double d) {
-		return java.lang.Math.ceil(d)==d && java.lang.Math.floor(d)==d;
+		return java.lang.Math.ceil(d) == d && java.lang.Math.floor(d) == d;
 	}
 
-    private boolean isValidCoord(String coord) {
-    	cwPt.set(coord);
-    	return cwPt.isValid();
-    }
+	private boolean isValidCoord(String coord) {
+		cwPt.set(coord);
+		return cwPt.isValid();
+	}
 
 	private Object getVariable(String varName) throws Exception {
 		if (varName.startsWith("$")) { // Potential coordinate
-			CacheHolder ch=Global.getProfile().cacheDB.get(varName.substring(1));
+			CacheHolder ch = Global.getProfile().cacheDB.get(varName.substring(1));
 			if (ch != null) { // Found it!
 				// Check whether coordinates are valid
-				cwPt.set(ch.pos);
-				if (cwPt.isValid() )
+				cwPt.set(ch.getPos());
+				if (cwPt.isValid())
 					return cwPt.toString();
 				else
 					return ""; // Convert invalid coordinates (N 0 0.0 E 0 0.0) into empty string
 			}
 		}
-		Object result = symbolTable.get(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
-		if(result == null) {
+		Object result = symbolTable.get(Global.getPref().solverIgnoreCase ? varName.toUpperCase() : varName);
+		if (result == null) {
 			// If it is a global variable, add it with a default value
 			if (varName.startsWith("$")) {
-				result="";
-				symbolTable.put(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName,"");
+				result = "";
+				symbolTable.put(Global.getPref().solverIgnoreCase ? varName.toUpperCase() : varName, "");
 			} else
-				err (MyLocale.getMsg(1702,"Variable not defined: ")+varName);
+				err(MyLocale.getMsg(1702, "Variable not defined: ") + varName);
 		}
 		return result;
 	}
@@ -281,66 +240,68 @@
 			if (MyLocale.getDigSeparator().equals(","))
 				str = str.replace('.', ',');
 			else
-				str = str.replace(',','.');
+				str = str.replace(',', '.');
 			return java.lang.Double.parseDouble(str);
 		} catch (NumberFormatException e) {
-			 return java.lang.Double.NaN;
+			return java.lang.Double.NaN;
 		}
 	}
 
 	private Double getNumber(String str) throws Exception {
-		double ret=toNumber(str);
+		double ret = toNumber(str);
 		if (java.lang.Double.isNaN(ret))
-			err(MyLocale.getMsg(1703,"Not a valid number: ") + str);
+			err(MyLocale.getMsg(1703, "Not a valid number: ") + str);
 		return new java.lang.Double(ret);
 	}
 
 	/** Get the top element of the calculation stack and try and convert it to a number if it is a string */
 	private double popCalcStackAsNumber(double defaultForEmptyString) throws Exception {
 		double num;
-		if (calcStack.get(calcStack.size()-1) instanceof String) {
-			if (((String)calcStack.get(calcStack.size()-1)).equals(""))
-				num=defaultForEmptyString;
+		if (calcStack.get(calcStack.size() - 1) instanceof String) {
+			if (((String) calcStack.get(calcStack.size() - 1)).equals(""))
+				num = defaultForEmptyString;
 			else
-				num = getNumber((String)calcStack.get(calcStack.size()-1)).doubleValue();
+				num = getNumber((String) calcStack.get(calcStack.size() - 1)).doubleValue();
 		} else {
-			num = ((java.lang.Double)calcStack.get(calcStack.size()-1)).doubleValue();
+			num = ((java.lang.Double) calcStack.get(calcStack.size() - 1)).doubleValue();
 		}
-		calcStack.removeElementAt(calcStack.size()-1);
+		calcStack.removeElementAt(calcStack.size() - 1);
 		return num;
 	}
 
 	private String popCalcStackAsString() {
 		String s;
-		if (calcStack.get(calcStack.size()-1) instanceof Double) {
-			java.lang.Double D=((java.lang.Double)calcStack.get(calcStack.size()-1));
+		if (calcStack.get(calcStack.size() - 1) instanceof Double) {
+			java.lang.Double D = ((java.lang.Double) calcStack.get(calcStack.size() - 1));
 			// Double.toString() formats numbers > 1E7 and < 1E-3 with exponential notation
 			// For large integers we therefore use Longs
-			double d=D.doubleValue();
+			double d = D.doubleValue();
 			// If the double is an integer and within range of longs, use Long
-			if (java.lang.Math.floor(d)==d && d<java.lang.Long.MAX_VALUE && d>java.lang.Long.MIN_VALUE) {
-				java.lang.Long L=new java.lang.Long((long)d);
-				s=L.toString();
+			if (java.lang.Math.floor(d) == d && d < java.lang.Long.MAX_VALUE && d > java.lang.Long.MIN_VALUE) {
+				java.lang.Long L = new java.lang.Long((long) d);
+				s = L.toString();
 			} else { // Use the default Double format
-				s = D.toString().replace(',','.'); // always show numbers with decimal point;
-				if (s.endsWith(".0")) s=s.substring(0,s.length()-2);
+				s = D.toString().replace(',', '.'); // always show numbers with decimal point;
+				if (s.endsWith(".0"))
+					s = s.substring(0, s.length() - 2);
 			}
 		} else
-			s = (String)calcStack.get(calcStack.size()-1);
-		calcStack.removeElementAt(calcStack.size()-1);
+			s = (String) calcStack.get(calcStack.size() - 1);
+		calcStack.removeElementAt(calcStack.size() - 1);
 		return s;
 	}
 
 	private void getToken() throws Exception {
-		if(scanpos < tokenStack.size()){
-			thisToken = (TokenObj)tokenStack.get(scanpos);
+		if (scanpos < tokenStack.size()) {
+			thisToken = (TokenObj) tokenStack.get(scanpos);
 			scanpos++;
-		} else err(MyLocale.getMsg(1704,"Unexpected end of source"));
+		} else
+			err(MyLocale.getMsg(1704, "Unexpected end of source"));
 	}
 
 	private TokenObj peekToken() {
-		if(scanpos < tokenStack.size()){
-			return (TokenObj)tokenStack.get(scanpos);
+		if (scanpos < tokenStack.size()) {
+			return (TokenObj) tokenStack.get(scanpos);
 		} else
 			return new TokenObj();
 	}
@@ -352,54 +313,58 @@
 	}
 
 	private void skipPastEndif(TokenObj ifToken) throws Exception {
-		while(scanpos < tokenStack.size()){
-			thisToken = (TokenObj)tokenStack.get(scanpos);
+		while (scanpos < tokenStack.size()) {
+			thisToken = (TokenObj) tokenStack.get(scanpos);
 			scanpos++;
-			if (thisToken.tt==TokenObj.TT_ENDIF) {
+			if (thisToken.tt == TokenObj.TT_ENDIF) {
 				getToken();
 				return;
 			}
 		}
-		thisToken=ifToken;
-		err(MyLocale.getMsg(1705,"Missing ENDIF"));
+		thisToken = ifToken;
+		err(MyLocale.getMsg(1705, "Missing ENDIF"));
 	}
+
 	private TokenObj lookAheadToken() {
-		return (TokenObj)tokenStack.get(scanpos);
+		return (TokenObj) tokenStack.get(scanpos);
 	}
 
 	private boolean checkNextSymIs(String str) throws Exception {
-		if(thisToken.token.toUpperCase().equals(str)){
+		if (thisToken.token.toUpperCase().equals(str)) {
 			return true;
 		} else {
-			err(MyLocale.getMsg(1706,"Expected ") + str + "  "+MyLocale.getMsg(1707,"Found: ")+thisToken.token);
-			return false; //Dummy as err does not return
+			err(MyLocale.getMsg(1706, "Expected ") + str + "  " + MyLocale.getMsg(1707, "Found: ") + thisToken.token);
+			return false; // Dummy as err does not return
 		}
 	}
 
 	private fnType getFunctionDefinition(String str) throws Exception {
-    	fnType fnd=null;
-    	str=str.toLowerCase();
-    	for (int i=functions.length-1; i>=0; i--) {
-    		// Return the function if there is an exact match
-    		if (functions[i].funcName.equals(str)) return functions[i];
-    		if (functions[i].funcName.startsWith(str)) { // Partial match?
-        		// Only one partial match allowed
-    			if (fnd!=null) err(MyLocale.getMsg(1708,"Ambiguous function name: ")+str);
-    			fnd=functions[i];
-    		}
-    	}
-    	if (fnd==null) err(MyLocale.getMsg(1709,"Unknown function: ")+str);
-    	return fnd;
-    }
+		fnType fnd = null;
+		str = str.toLowerCase();
+		for (int i = functions.length - 1; i >= 0; i--) {
+			// Return the function if there is an exact match
+			if (functions[i].funcName.equals(str))
+				return functions[i];
+			if (functions[i].funcName.startsWith(str)) { // Partial match?
+				// Only one partial match allowed
+				if (fnd != null)
+					err(MyLocale.getMsg(1708, "Ambiguous function name: ") + str);
+				fnd = functions[i];
+			}
+		}
+		if (fnd == null)
+			err(MyLocale.getMsg(1709, "Unknown function: ") + str);
+		return fnd;
+	}
 
-///////////////////////////////////////////
-//  FUNCTIONS
-///////////////////////////////////////////
+	// /////////////////////////////////////////
+	// FUNCTIONS
+	// /////////////////////////////////////////
 
 	/** If we are in DEGree mode, convert the argument to RADiants, if not leave it unchanged */
 	private double makeRadiant(double arg) {
 		if (Global.getPref().solverDegMode)
-			return arg*java.lang.Math.PI/180.0;
+			return arg * java.lang.Math.PI / 180.0;
 		else
 			return arg;
 	}
@@ -407,30 +372,33 @@
 	/** If we are in DEGree mode, convert the argument to degrees */
 	private double makeDegree(double arg) {
 		if (Global.getPref().solverDegMode)
-			return arg/java.lang.Math.PI*180.0;
+			return arg / java.lang.Math.PI * 180.0;
 		else
 			return arg;
 	}
 
-    /** Calculate brearing from one point to the next */
-    private double funcBearing() throws Exception {
-    	String coordB=popCalcStackAsString();
-    	String coordA=popCalcStackAsString();
- 		if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordA);
-		if (!isValidCoord(coordB)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordB);
-	   	cwPt.set(coordA);
-	   	double angleDeg=cwPt.getBearing(new CWPoint(coordB));
-	   	// getBearing returns a result in degrees
-	   	return Global.getPref().solverDegMode ? angleDeg : angleDeg * java.lang.Math.PI/180.0;
-    }
+	/** Calculate brearing from one point to the next */
+	private double funcBearing() throws Exception {
+		String coordB = popCalcStackAsString();
+		String coordA = popCalcStackAsString();
+		if (!isValidCoord(coordA))
+			err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coordA);
+		if (!isValidCoord(coordB))
+			err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coordB);
+		cwPt.set(coordA);
+		double angleDeg = cwPt.getBearing(new CWPoint(coordB));
+		// getBearing returns a result in degrees
+		return Global.getPref().solverDegMode ? angleDeg : angleDeg * java.lang.Math.PI / 180.0;
+	}
 
-    /** Get or set the current centre */
+	/** Get or set the current centre */
 	private void funcCenter(int nargs) throws Exception {
-		if (nargs==0) {
+		if (nargs == 0) {
 			calcStack.add(Global.getPref().getCurCentrePt().toString());
 		} else {
-	    	String coordA=popCalcStackAsString();
-			if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordA);
+			String coordA = popCalcStackAsString();
+			if (!isValidCoord(coordA))
+				err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coordA);
 			Global.getPref().setCurCentrePt(new CWPoint(coordA));
 		}
 	}
@@ -442,218 +410,246 @@
 	}
 
 	private int funcCountChar(String s, char c) {
-    	int count=0;
-    	for (int i=0; i<s.length(); i++)
-    		if (s.charAt(i)==c) count++;
-    	return count;
-    }
+		int count = 0;
+		for (int i = 0; i < s.length(); i++)
+			if (s.charAt(i) == c)
+				count++;
+		return count;
+	}
 
-    /** count(string1,string2)
-     * */
-    private void funcCount()throws Exception {
-       	String s2=popCalcStackAsString();
-    	String s1=popCalcStackAsString();
-    	if (s2.length()==0) err(MyLocale.getMsg(1710,"Cannot count empty string"));
-    	if (s2.length()==1) {
-    		calcStack.add(new Double(funcCountChar(s1,s2.charAt(0))));
-    	} else {
-    		String res="";
-    		for(int i=0; i<s2.length(); i++) {
-    			res+=s2.charAt(i)+"="+funcCountChar(s1,s2.charAt(i))+" ";
-    		}
-    		calcStack.add(res);
-    	}
-    }
+	/**
+	 * count(string1,string2)
+	 * */
+	private void funcCount() throws Exception {
+		String s2 = popCalcStackAsString();
+		String s1 = popCalcStackAsString();
+		if (s2.length() == 0)
+			err(MyLocale.getMsg(1710, "Cannot count empty string"));
+		if (s2.length() == 1) {
+			calcStack.add(new Double(funcCountChar(s1, s2.charAt(0))));
+		} else {
+			String res = "";
+			for (int i = 0; i < s2.length(); i++) {
+				res += s2.charAt(i) + "=" + funcCountChar(s1, s2.charAt(i)) + " ";
+			}
+			calcStack.add(res);
+		}
+	}
 
-    private String funcCp(){
-    	return Global.mainTab.nav.gpsPos.toString();
-    }
+	private String funcCp() {
+		return Global.mainTab.nav.gpsPos.toString();
+	}
 
-    /**
-     *  Crosstotal: Works for both strings and numbers. For strings any non-numeric character is ignored
-     *  Warning: When the number is non-integer or > 9223372036854775807, it is formatted using the E
-     *  notation, i.e. x.xxxxxxEyy. In this case the exponent yy is also included in the crosstotal
-     */
-    private double funcCrossTotal(int nargs) throws Exception {
-    	int cycles=1;
-		if (nargs==2) cycles=(int)popCalcStackAsNumber(1);
-		String aString=popCalcStackAsString().replace('-','0').trim();
-		double a=0;
-		if (cycles<0) cycles=1;
-    	if (cycles>5) cycles=5;
-    	while (cycles-->0) {
-	    	// Cross total = Quersumme berechnen
-			a=0;
-			for (int i=0; i<aString.length(); i++) {
-			   if (aString.charAt(i)>='0' && aString.charAt(i)<='9')
-			      a += aString.charAt(i)-'0';
+	/**
+	 * Crosstotal: Works for both strings and numbers. For strings any non-numeric character is ignored
+	 * Warning: When the number is non-integer or > 9223372036854775807, it is formatted using the E
+	 * notation, i.e. x.xxxxxxEyy. In this case the exponent yy is also included in the crosstotal
+	 */
+	private double funcCrossTotal(int nargs) throws Exception {
+		int cycles = 1;
+		if (nargs == 2)
+			cycles = (int) popCalcStackAsNumber(1);
+		String aString = popCalcStackAsString().replace('-', '0').trim();
+		double a = 0;
+		if (cycles < 0)
+			cycles = 1;
+		if (cycles > 5)
+			cycles = 5;
+		while (cycles-- > 0) {
+			// Cross total = Quersumme berechnen
+			a = 0;
+			for (int i = 0; i < aString.length(); i++) {
+				if (aString.charAt(i) >= '0' && aString.charAt(i) <= '9')
+					a += aString.charAt(i) - '0';
 			}
-			aString=Convert.toString(a);
-    	}
-    	return a;
-    }
+			aString = Convert.toString(a);
+		}
+		return a;
+	}
 
-    private void funcDeg(boolean arg) {
-    	Global.getPref().solverDegMode=arg;
-    	Global.mainTab.solverP.showSolverMode();
-    }
+	private void funcDeg(boolean arg) {
+		Global.getPref().solverDegMode = arg;
+		Global.mainTab.solverP.showSolverMode();
+	}
 
-    /** Convert degrees into Radiants */
-    private double funcDeg2Rad() throws Exception {
-    	double a=popCalcStackAsNumber(0);
-    	return a/180.0*java.lang.Math.PI;
-    }
+	/** Convert degrees into Radiants */
+	private double funcDeg2Rad() throws Exception {
+		double a = popCalcStackAsNumber(0);
+		return a / 180.0 * java.lang.Math.PI;
+	}
 
-    	/** Calculate distance between 2 points */
-    private double funcDistance() throws Exception {
-    	String coordB=popCalcStackAsString();
-    	String coordA=popCalcStackAsString();
-    	double result = 0;
+	/** Calculate distance between 2 points */
+	private double funcDistance() throws Exception {
+		String coordB = popCalcStackAsString();
+		String coordA = popCalcStackAsString();
+		double result = 0;
 		// Attention: isValidCoord has sideeffect of setting cwPt
-    	if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordA);
-		if (!isValidCoord(coordB)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordB);
-    	cwPt.set(coordA);
-    	double distKM = cwPt.getDistance(new CWPoint(coordB));
-    	result = distKM*1000.0;
-    	if (Global.getPref().metricSystem == Metrics.IMPERIAL) {
-    		result = Metrics.convertUnit(distKM, Metrics.KILOMETER, Metrics.YARDS);
-    	}
-    	return result;
-    }
+		if (!isValidCoord(coordA))
+			err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coordA);
+		if (!isValidCoord(coordB))
+			err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coordB);
+		cwPt.set(coordA);
+		double distKM = cwPt.getDistance(new CWPoint(coordB));
+		result = distKM * 1000.0;
+		if (Global.getPref().metricSystem == Metrics.IMPERIAL) {
+			result = Metrics.convertUnit(distKM, Metrics.KILOMETER, Metrics.YARDS);
+		}
+		return result;
+	}
 
-    /**
-     * Encode a string by replacing all characters in a string with their corresponding characters in
-     * another string
-     * @throws Exception
-     */
-    private String funcEncode() throws Exception {
-    	String newChars=popCalcStackAsString();
-    	String oldChars=popCalcStackAsString();
-    	if (newChars.length()!=oldChars.length()) err(MyLocale.getMsg(1711,"Replacement characters strings must be of equal length"));
-    	String s=popCalcStackAsString();
-    	String encodedStr="";
-    	for (int i=0; i<s.length(); i++) {
-    		int pos;
-    		if ((pos=oldChars.indexOf(s.charAt(i)))!=-1) {
-    			encodedStr+=newChars.charAt(pos);
-    		} else
-    			encodedStr+=s.charAt(i);
-    	}
-    	 return encodedStr;
-    }
+	/**
+	 * Encode a string by replacing all characters in a string with their corresponding characters in
+	 * another string
+	 * 
+	 * @throws Exception
+	 */
+	private String funcEncode() throws Exception {
+		String newChars = popCalcStackAsString();
+		String oldChars = popCalcStackAsString();
+		if (newChars.length() != oldChars.length())
+			err(MyLocale.getMsg(1711, "Replacement characters strings must be of equal length"));
+		String s = popCalcStackAsString();
+		String encodedStr = "";
+		for (int i = 0; i < s.length(); i++) {
+			int pos;
+			if ((pos = oldChars.indexOf(s.charAt(i))) != -1) {
+				encodedStr += newChars.charAt(pos);
+			} else
+				encodedStr += s.charAt(i);
+		}
+		return encodedStr;
+	}
 
-    /** Format a valid coordinate
-     *  If called with one args, format the argument on the stack to CW standard
-     *  The optional second argument is one of these strings "UTM","DMS","DD","DMM" or "CW"
-     * @param nargs 1 or 2 args
-     */
-    private String funcFormat(int nargs) throws Exception {
-    	int spart=0;
-    	if (nargs==3) spart=(int) popCalcStackAsNumber(0);
-    	String fmtStr="";
-    	if (nargs>=2)fmtStr=popCalcStackAsString().toLowerCase();
-    	String coord=popCalcStackAsString();
-		if (!isValidCoord(coord)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coord);
-    	cwPt.set(coord);
-    	int fmt = TransformCoordinates.getLocalSystemCode(fmtStr);
-    	if (fmt == TransformCoordinates.LOCALSYSTEM_NOT_SUPPORTED) err(MyLocale.getMsg(1713,"Invalid coordinate format. Allowed are cw / dd / dmm / dms / ") + Common.arrayToString(TransformCoordinates.getProjectedSystemIDs(), " / "));
-    	String ret = cwPt.toString(fmt);
-    	if (nargs==3){
-    		String[] parts=mString.split(ret, ' ');
-    		if (spart>0 && parts.length>=spart)
-    		ret = parts[spart-1];
-    		else err("Param 3 !!! "+MyLocale.getMsg(1713,"Invalid coordinate format."));
-    	}
-    	return ret;
-    }
+	/**
+	 * Format a valid coordinate
+	 * If called with one args, format the argument on the stack to CW standard
+	 * The optional second argument is one of these strings "UTM","DMS","DD","DMM" or "CW"
+	 * 
+	 * @param nargs
+	 *            1 or 2 args
+	 */
+	private String funcFormat(int nargs) throws Exception {
+		int spart = 0;
+		if (nargs == 3)
+			spart = (int) popCalcStackAsNumber(0);
+		String fmtStr = "";
+		if (nargs >= 2)
+			fmtStr = popCalcStackAsString().toLowerCase();
+		String coord = popCalcStackAsString();
+		if (!isValidCoord(coord))
+			err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coord);
+		cwPt.set(coord);
+		int fmt = TransformCoordinates.getLocalSystemCode(fmtStr);
+		if (fmt == TransformCoordinates.LOCALSYSTEM_NOT_SUPPORTED)
+			err(MyLocale.getMsg(1713, "Invalid coordinate format. Allowed are cw / dd / dmm / dms / ") + Common.arrayToString(TransformCoordinates.getProjectedSystemIDs(), " / "));
+		String ret = cwPt.toString(fmt);
+		if (nargs == 3) {
+			String[] parts = mString.split(ret, ' ');
+			if (spart > 0 && parts.length >= spart)
+				ret = parts[spart - 1];
+			else
+				err("Param 3 !!! " + MyLocale.getMsg(1713, "Invalid coordinate format."));
+		}
+		return ret;
+	}
 
-    /** Implements a goto command goto(coordinate,optionalWaypointName).
-     */
-    private void funcGoto(int nargs) throws Exception {
-    	Navigate nav=Global.mainTab.nav;
-		String waypointName=null;
-        if (nargs==2) waypointName=popCalcStackAsString();
-		String coord=popCalcStackAsString();
-		if (!isValidCoord(coord)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coord);
+	/**
+	 * Implements a goto command goto(coordinate,optionalWaypointName).
+	 */
+	private void funcGoto(int nargs) throws Exception {
+		Navigate nav = Global.mainTab.nav;
+		String waypointName = null;
+		if (nargs == 2)
+			waypointName = popCalcStackAsString();
+		String coord = popCalcStackAsString();
+		if (!isValidCoord(coord))
+			err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coord);
 		// Don't want to switch to goto panel, just set the values
 		nav.setDestination(coord);
-		if (nargs==2) { // Now set the value of the addi waypoint (it must exist already)
-    		cwPt.set(coord);
-    		CacheHolder ch=Global.getProfile().cacheDB.get(waypointName);
-    		if (ch == null) {
-    			err(MyLocale.getMsg(1714,"Goto: Waypoint does not exist: ")+waypointName);
-    			return;
-    		}
-    		ch.setLatLon(cwPt.toString(TransformCoordinates.CW));
-    		ch.pos.set(cwPt);
-    		ch.calcDistance(Global.getPref().getCurCentrePt()); // Update distance/bearing
-    		nav.setDestination(ch);
-    	    Global.getProfile().selectionChanged=true; // Tell moving map to updated displayed waypoints
-    	}
-    }
+		if (nargs == 2) { // Now set the value of the addi waypoint (it must exist already)
+			cwPt.set(coord);
+			CacheHolder ch = Global.getProfile().cacheDB.get(waypointName);
+			if (ch == null) {
+				err(MyLocale.getMsg(1714, "Goto: Waypoint does not exist: ") + waypointName);
+				return;
+			}
+			ch.setPos(cwPt);
+			ch.calcDistance(Global.getPref().getCurCentrePt()); // Update distance/bearing
+			nav.setDestination(ch);
+			Global.getProfile().selectionChanged = true; // Tell moving map to updated displayed waypoints
+		}
+	}
 
-    /** Display or change the case sensitivity of variable names */
-    private void funcIgnoreVariableCase(int nargs) throws Exception {
-    	if (nargs==0)
-    		calcStack.add(""+Global.getPref().solverIgnoreCase);
-    	else {
-    		Global.getPref().solverIgnoreCase=(popCalcStackAsNumber(0)!=0)?true:false;
-    	}
-    }
+	/** Display or change the case sensitivity of variable names */
+	private void funcIgnoreVariableCase(int nargs) throws Exception {
+		if (nargs == 0)
+			calcStack.add("" + Global.getPref().solverIgnoreCase);
+		else {
+			Global.getPref().solverIgnoreCase = (popCalcStackAsNumber(0) != 0) ? true : false;
+		}
+	}
 
-    /** VB instr function
-     * instr([start],string1,string2)
-     * */
-    private int funcInstr(int nargs) throws Exception {
-    	String s2=popCalcStackAsString();
-    	String s1=popCalcStackAsString();
-    	int start=1;
-    	if (nargs==3) start=(int) popCalcStackAsNumber(1);
-    	if (start>s1.length()) err(MyLocale.getMsg(1715,"instr: Start position not in string"));
-    	if(s2.equals("")) {
-    		if (s1.equals(""))
-    			return 0;
-    		else
-    			return 1;
-    	}
-    	return s1.indexOf(s2,start-1)+1;
-    }
+	/**
+	 * VB instr function
+	 * instr([start],string1,string2)
+	 * */
+	private int funcInstr(int nargs) throws Exception {
+		String s2 = popCalcStackAsString();
+		String s1 = popCalcStackAsString();
+		int start = 1;
+		if (nargs == 3)
+			start = (int) popCalcStackAsNumber(1);
+		if (start > s1.length())
+			err(MyLocale.getMsg(1715, "instr: Start position not in string"));
+		if (s2.equals("")) {
+			if (s1.equals(""))
+				return 0;
+			else
+				return 1;
+		}
+		return s1.indexOf(s2, start - 1) + 1;
+	}
 
-    /** MID function as in Basic */
-    private String funcMid(int nargs) throws Exception {
-    	if (nargs==2) {
-        	double start=popCalcStackAsNumber(0);
-    		String s=popCalcStackAsString();
-    		if (!isInteger(start)) err(MyLocale.getMsg(1716,"mid: Integer argument expected"));
-    		if (start<1 || start>s.length()) err(MyLocale.getMsg(1717,"mid: Argument out of range"));
-    		return s.substring((int)start-1);
-    	} else {
-        	double len=popCalcStackAsNumber(0);
-        	double start=popCalcStackAsNumber(0);
-    		String s=popCalcStackAsString();
-    		if (!isInteger(start) || !isInteger(len)) err(MyLocale.getMsg(1716,"mid: Integer argument expected"));
-    		int end=(int)(start+len-1);
-    		if (start>s.length() || start<1 || end>s.length()) err(MyLocale.getMsg(1717,"mid: Argument out of range"));
-    		return s.substring((int)start-1,end);
-    	}
-    }
+	/** MID function as in Basic */
+	private String funcMid(int nargs) throws Exception {
+		if (nargs == 2) {
+			double start = popCalcStackAsNumber(0);
+			String s = popCalcStackAsString();
+			if (!isInteger(start))
+				err(MyLocale.getMsg(1716, "mid: Integer argument expected"));
+			if (start < 1 || start > s.length())
+				err(MyLocale.getMsg(1717, "mid: Argument out of range"));
+			return s.substring((int) start - 1);
+		} else {
+			double len = popCalcStackAsNumber(0);
+			double start = popCalcStackAsNumber(0);
+			String s = popCalcStackAsString();
+			if (!isInteger(start) || !isInteger(len))
+				err(MyLocale.getMsg(1716, "mid: Integer argument expected"));
+			int end = (int) (start + len - 1);
+			if (start > s.length() || start < 1 || end > s.length())
+				err(MyLocale.getMsg(1717, "mid: Argument out of range"));
+			return s.substring((int) start - 1, end);
+		}
+	}
 
-    /** MOD function as in Basic */
-    private Double funcMod() throws Exception {
-    	double b=popCalcStackAsNumber(0);
-    	double a=popCalcStackAsNumber(0);
-		if (b==0.0)
-			err(MyLocale.getMsg(1729,"Division by 0"));
+	/** MOD function as in Basic */
+	private Double funcMod() throws Exception {
+		double b = popCalcStackAsNumber(0);
+		double a = popCalcStackAsNumber(0);
+		if (b == 0.0)
+			err(MyLocale.getMsg(1729, "Division by 0"));
 		return new java.lang.Double(a % b);
-    }
+	}
 
 	/** Get or set the profile centre */
 	private void funcPz(int nargs) throws Exception {
-		if (nargs==0) {
+		if (nargs == 0) {
 			calcStack.add(Global.getProfile().centre.toString());
 		} else {
-	    	String coordA=popCalcStackAsString();
-			if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordA);
+			String coordA = popCalcStackAsString();
+			if (!isValidCoord(coordA))
+				err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coordA);
 			Global.getProfile().centre.set(coordA);
 		}
 	}
@@ -662,266 +658,281 @@
 	 * Calculates the crossbearing from point1 with bearing 1 and point2 with bearing2
 	 * point1 and point 2 must be different.
 	 * Not very well tested. No guarantee for correct result if any of the distance is greater than 300 kilometers and / or any of the angles in the spherical triangle id greater then 90degrees
+	 * 
 	 * @return
 	 * @throws Exception
 	 */
-	private String funcCrossBearing () throws Exception{
-		//parameters come in reversed order!
+	private String funcCrossBearing() throws Exception {
+		// parameters come in reversed order!
 		double degrees2 = popCalcStackAsNumber(-1);
 		String coordinates2 = popCalcStackAsString();
 		double degrees1 = popCalcStackAsNumber(-1);
 		String coordinates1 = popCalcStackAsString();
-		if (!isValidCoord(coordinates1)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordinates1);
- 		if (!isValidCoord(coordinates2)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordinates2);
+		if (!isValidCoord(coordinates1))
+			err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coordinates1);
+		if (!isValidCoord(coordinates2))
+			err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coordinates2);
 
-		//Check parameters: Range
-    	if (degrees1<0 || degrees1>360 || degrees2 < 0 || degrees2 > 360){
-    		if (Global.getPref().solverDegMode){
-    			err(MyLocale.getMsg(1740,"Crossbearing degrees must be in interval [0;360]"));
-    		}
-    		else{
-    			err(MyLocale.getMsg(1741,"Crossbearing degrees must be in interval [0;2*PI]"));
-    		}
-    	}
-    	double rAN = Global.getPref().solverDegMode ? degrees1 / 180.0
-				* java.lang.Math.PI : degrees1;
-		double rBN = Global.getPref().solverDegMode ? degrees2 / 180.0
-				* java.lang.Math.PI : degrees2;
+		// Check parameters: Range
+		if (degrees1 < 0 || degrees1 > 360 || degrees2 < 0 || degrees2 > 360) {
+			if (Global.getPref().solverDegMode) {
+				err(MyLocale.getMsg(1740, "Crossbearing degrees must be in interval [0;360]"));
+			} else {
+				err(MyLocale.getMsg(1741, "Crossbearing degrees must be in interval [0;2*PI]"));
+			}
+		}
+		double rAN = Global.getPref().solverDegMode ? degrees1 / 180.0 * java.lang.Math.PI : degrees1;
+		double rBN = Global.getPref().solverDegMode ? degrees2 / 180.0 * java.lang.Math.PI : degrees2;
 
-		CWPoint point1=new CWPoint(coordinates1);
-		CWPoint point2=new CWPoint(coordinates2);
+		CWPoint point1 = new CWPoint(coordinates1);
+		CWPoint point2 = new CWPoint(coordinates2);
 
-    	//check Parameters: bearings to project must be different from the bearing between point1 and point2
-    	if (degrees1 == degrees2){
-    		double bearing1 = point1.getBearing(point2);
-    		double bearing2 = point1.getBearing(point1);
-    		if (bearing1 == degrees1 || bearing2 == degrees2){
-    			err(MyLocale.getMsg(1740,"Invalid crossbearing angles"));
-    		}
-    	}
+		// check Parameters: bearings to project must be different from the bearing between point1 and point2
+		if (degrees1 == degrees2) {
+			double bearing1 = point1.getBearing(point2);
+			double bearing2 = point1.getBearing(point1);
+			if (bearing1 == degrees1 || bearing2 == degrees2) {
+				err(MyLocale.getMsg(1740, "Invalid crossbearing angles"));
+			}
+		}
 
 		CWPoint result2 = crossbearingCalculation(point1, point2, rAN, rBN);
 		return result2.toString();
 	}
 
 	private CWPoint crossbearingCalculation(CWPoint point1, CWPoint point2, double rAN, double rBN) throws Exception {
-		//see german wikipedia keyword vorwaertsschnitt for the calculation.
-		//peilung von a->b
-		//Yes we will make an error, therefore we have to calculate the target-point iteratively.
-		//Testcode for crossbearing:
+		// see german wikipedia keyword vorwaertsschnitt for the calculation.
+		// peilung von a->b
+		// Yes we will make an error, therefore we have to calculate the target-point iteratively.
+		// Testcode for crossbearing:
 		// MP="S35 47.100 W089 43.200" # MP is centre of circle, could be any waypoint
 		// A=project(MP,0,1000); B=project(MP,120,1000) # Points of equilateral triangle on circle
 		// C1=project(MP,240,1000); C2=cb(A,210 ,B,270)
-		//	C1 "=" C2
+		// C1 "=" C2
 		final int maxRadius = 6378;
-    	double distance = point1.getDistance(point2);
-    	if (Math.abs (distance) <= 0.0000000001){
-    		err (MyLocale.getMsg(1742,"Crossbearing: distance between points to small"));
-    	}
-    	double distanceInRad = distance / maxRadius;
-	    double phiAB = point1.getBearing(point2);
-	    if (Global.getPref().solverDegMode) phiAB=phiAB / 180.0 * java.lang.Math.PI;
-	    double phiBA = point2.getBearing(point1);
-	    if (Global.getPref().solverDegMode) phiBA=phiBA / 180.0 * java.lang.Math.PI;
+		double distance = point1.getDistance(point2);
+		if (Math.abs(distance) <= 0.0000000001) {
+			err(MyLocale.getMsg(1742, "Crossbearing: distance between points to small"));
+		}
+		double distanceInRad = distance / maxRadius;
+		double phiAB = point1.getBearing(point2);
+		if (Global.getPref().solverDegMode)
+			phiAB = phiAB / 180.0 * java.lang.Math.PI;
+		double phiBA = point2.getBearing(point1);
+		if (Global.getPref().solverDegMode)
+			phiBA = phiBA / 180.0 * java.lang.Math.PI;
 
-	    double psi = phiAB - rAN;
-	    double phi = rBN - phiBA;
+		double psi = phiAB - rAN;
+		double phi = rBN - phiBA;
 
-	    //calculate projetiondistance
-	    double bInRad = distanceInRad * java.lang.Math.sin(phi) / java.lang.Math.sin(phi+psi);
-	    double b = bInRad * maxRadius ;//* (1-flattening);
-	    double aInRad = distanceInRad * java.lang.Math.sin(psi) / java.lang.Math.sin(phi+psi);
-	    double a = aInRad * maxRadius ;//* (1-flattening);
-	    double phiAN = phiAB - psi;
-	    double phiANDegrees = phiAN * 180.0 / java.lang.Math.PI;
-	    double phiBN = phiBA + phi;
-	    double phiBNDegrees = phiBN * 180.0 / java.lang.Math.PI;
-	    CWPoint result2 = point2.project(phiBNDegrees, a);
-	    CWPoint result = point1.project(phiANDegrees, b);
-	    double errorDistance = result.getDistance(result2);
-	    //if the distance between the points is to large, we will restart the calculation with the new points found.
-	    //since the error is mostly very small these iterations are seldom used and the needed depth is very low.
-	    //First we will make sure, that this calculation will terminate
-	    if (distance < errorDistance){
-    		err (MyLocale.getMsg(1743,"Crossbearing calculation failed. Please inform the developers at geoclub.de"));
-	    }
-	    if (errorDistance * 1000 > 1){
-	    	return crossbearingCalculation(result, result2, rAN, rBN);
-	    }
+		// calculate projetiondistance
+		double bInRad = distanceInRad * java.lang.Math.sin(phi) / java.lang.Math.sin(phi + psi);
+		double b = bInRad * maxRadius;// * (1-flattening);
+		double aInRad = distanceInRad * java.lang.Math.sin(psi) / java.lang.Math.sin(phi + psi);
+		double a = aInRad * maxRadius;// * (1-flattening);
+		double phiAN = phiAB - psi;
+		double phiANDegrees = phiAN * 180.0 / java.lang.Math.PI;
+		double phiBN = phiBA + phi;
+		double phiBNDegrees = phiBN * 180.0 / java.lang.Math.PI;
+		CWPoint result2 = point2.project(phiBNDegrees, a);
+		CWPoint result = point1.project(phiANDegrees, b);
+		double errorDistance = result.getDistance(result2);
+		// if the distance between the points is to large, we will restart the calculation with the new points found.
+		// since the error is mostly very small these iterations are seldom used and the needed depth is very low.
+		// First we will make sure, that this calculation will terminate
+		if (distance < errorDistance) {
+			err(MyLocale.getMsg(1743, "Crossbearing calculation failed. Please inform the developers at geoclub.de"));
+		}
+		if (errorDistance * 1000 > 1) {
+			return crossbearingCalculation(result, result2, rAN, rBN);
+		}
 		return result2;
 	}
 
-    /** Project a waypoint at some angle and some distance */
-    private String funcProject() throws Exception {
-    	double distance=popCalcStackAsNumber(0);
-    	if (distance<0) err(MyLocale.getMsg(1718,"Cannot project a negative distance"));
-    	double degrees=popCalcStackAsNumber(0);
-    	// If we are not in degree mode, arg is in radiants ==> convert it
-    	if (!Global.getPref().solverDegMode) degrees=degrees * 180.0 / java.lang.Math.PI;
-    	if (degrees<0 || degrees>360)
-    		if (Global.getPref().solverDegMode)
-    			err(MyLocale.getMsg(1719,"Projection degrees must be in interval [0;360]"));
-    		else
-    			err(MyLocale.getMsg(1739,"Projection degrees must be in interval [0;2*PI]"));
-    	String coord=popCalcStackAsString();
-		if (!isValidCoord(coord)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coord);
-    	cwPt.set(coord);
-    	if (Global.getPref().metricSystem == Metrics.IMPERIAL) {
-    		distance = Metrics.convertUnit(distance, Metrics.YARDS, Metrics.KILOMETER);
-    	} else {
-    		distance = distance / 1000.0;
-    	}
-    	return cwPt.project(degrees,distance).toString();
-    }
+	/** Project a waypoint at some angle and some distance */
+	private String funcProject() throws Exception {
+		double distance = popCalcStackAsNumber(0);
+		if (distance < 0)
+			err(MyLocale.getMsg(1718, "Cannot project a negative distance"));
+		double degrees = popCalcStackAsNumber(0);
+		// If we are not in degree mode, arg is in radiants ==> convert it
+		if (!Global.getPref().solverDegMode)
+			degrees = degrees * 180.0 / java.lang.Math.PI;
+		if (degrees < 0 || degrees > 360)
+			if (Global.getPref().solverDegMode)
+				err(MyLocale.getMsg(1719, "Projection degrees must be in interval [0;360]"));
+			else
+				err(MyLocale.getMsg(1739, "Projection degrees must be in interval [0;2*PI]"));
+		String coord = popCalcStackAsString();
+		if (!isValidCoord(coord))
+			err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coord);
+		cwPt.set(coord);
+		if (Global.getPref().metricSystem == Metrics.IMPERIAL) {
+			distance = Metrics.convertUnit(distance, Metrics.YARDS, Metrics.KILOMETER);
+		} else {
+			distance = distance / 1000.0;
+		}
+		return cwPt.project(degrees, distance).toString();
+	}
 
-    /** Convert Radiants into degrees */
-    private double funcRad2Deg() throws Exception {
-    	double a=popCalcStackAsNumber(0);
-    	return a*180.0/java.lang.Math.PI;
-    }
+	/** Convert Radiants into degrees */
+	private double funcRad2Deg() throws Exception {
+		double a = popCalcStackAsNumber(0);
+		return a * 180.0 / java.lang.Math.PI;
+	}
 
-    /** Replace all occurrences of a string with another string */
-    private String funcReplace() throws Exception {
-    	String replaceWith=popCalcStackAsString();
-    	String whatToReplace=popCalcStackAsString();
-    	String s=popCalcStackAsString();
-        if (whatToReplace.equals("")) return s;
-        return STRreplace.replace(s,whatToReplace,replaceWith);
-    }
+	/** Replace all occurrences of a string with another string */
+	private String funcReplace() throws Exception {
+		String replaceWith = popCalcStackAsString();
+		String whatToReplace = popCalcStackAsString();
+		String s = popCalcStackAsString();
+		if (whatToReplace.equals(""))
+			return s;
+		return STRreplace.replace(s, whatToReplace, replaceWith);
+	}
 
-    /** Reverse a string */
-    private String funcReverse(String s) {
-    	String res="";
-    	for (int i=s.length()-1; i>=0; i--) res+=s.charAt(i);
-    	return res;
-    }
+	/** Reverse a string */
+	private String funcReverse(String s) {
+		String res = "";
+		for (int i = s.length() - 1; i >= 0; i--)
+			res += s.charAt(i);
+		return res;
+	}
 
-    /** Create a skeleton for multis. This function can be called in three ways:<br>
-     *  <pre>sk()                Create skeleton for current cache (must have addi wpts)
-     *  sk(number)          Create skeleton for number variables
-     */
-    private void funcSkeleton(int nargs) throws Exception {
-   		String waypointName=Global.mainTab.lastselected;
-    	CacheHolder c=Global.getProfile().cacheDB.get(waypointName);
-    	if (c == null) return;
-    	// If it is an addi, find its main cache
-    	if (c.isAddiWpt()) {
-    		waypointName=c.mainCache.getWayPoint();
-    	}
-   		int nStages=-1;
-    	if (nargs==1) {
-    		nStages=(int)popCalcStackAsNumber(-1.0);
-    	}
-    	// Remove the sk command from the instructions
-    	Regex rex=new Regex("sk\\(.*?\\)","");
-    	Global.mainTab.solverP.mText.setText(rex.replaceFirst(Global.mainTab.solverP.mText.getText()));
-		StringBuffer op=new StringBuffer(1000);
-    	// Check for sk(number)
-    	if (nStages>0 && nStages<30) { // e.g. sk(3)
-			/*IF $01xxxx="" THEN
-			   $01xxxx=""
-			   "Station 1 = " $01xxxx
-			   goto($01xxxx); STOP
-			ENDIF*/
-			boolean didCreateWp=false;
-    		for (int i=0; i<nStages; i++) {
-				String stage=MyLocale.formatLong(i,"00");
-				String stageWpt="$"+stage+waypointName.substring(2);
-				String stageName = "Stage "+(i+1);
+	/**
+	 * Create a skeleton for multis. This function can be called in three ways:<br>
+	 * 
+	 * <pre>
+	 * sk()                Create skeleton for current cache (must have addi wpts)
+	 * sk(number)          Create skeleton for number variables
+	 */
+	private void funcSkeleton(int nargs) throws Exception {
+		String waypointName = Global.mainTab.lastselected;
+		CacheHolder c = Global.getProfile().cacheDB.get(waypointName);
+		if (c == null)
+			return;
+		// If it is an addi, find its main cache
+		if (c.isAddiWpt()) {
+			waypointName = c.mainCache.getWayPoint();
+		}
+		int nStages = -1;
+		if (nargs == 1) {
+			nStages = (int) popCalcStackAsNumber(-1.0);
+		}
+		// Remove the sk command from the instructions
+		Regex rex = new Regex("sk\\(.*?\\)", "");
+		Global.mainTab.solverP.mText.setText(rex.replaceFirst(Global.mainTab.solverP.mText.getText()));
+		StringBuffer op = new StringBuffer(1000);
+		// Check for sk(number)
+		if (nStages > 0 && nStages < 30) { // e.g. sk(3)
+			/*
+			 * IF $01xxxx="" THEN
+			 * $01xxxx=""
+			 * "Station 1 = " $01xxxx
+			 * goto($01xxxx); STOP
+			 * ENDIF
+			 */
+			boolean didCreateWp = false;
+			for (int i = 0; i < nStages; i++) {
+				String stage = MyLocale.formatLong(i, "00");
+				String stageWpt = "$" + stage + waypointName.substring(2);
+				String stageName = "Stage " + (i + 1);
 				byte type = CacheType.CW_TYPE_STAGE;
 				if (i == nStages - 1) {
 					stageName = "Final";
 					type = CacheType.CW_TYPE_FINAL;
 				}
-				didCreateWp|=createWptIfNeeded(stage+waypointName.substring(2), stageName, type);
-				op.append("IF "+stageWpt+"=\"\" THEN\n");
-				op.append("  "+stageWpt+" = \"\"\n");
-				op.append("  \""+stageName+" = \" "+stageWpt+"\n");
-				op.append("  goto("+stageWpt+"); STOP\n");
+				didCreateWp |= createWptIfNeeded(stage + waypointName.substring(2), stageName, type);
+				op.append("IF " + stageWpt + "=\"\" THEN\n");
+				op.append("  " + stageWpt + " = \"\"\n");
+				op.append("  \"" + stageName + " = \" " + stageWpt + "\n");
+				op.append("  goto(" + stageWpt + "); STOP\n");
 				op.append("ENDIF\n");
 			}
-			Global.mainTab.solverP.mText.appendText(op.toString(),true);
+			Global.mainTab.solverP.mText.appendText(op.toString(), true);
 			if (didCreateWp) {
-		    	Global.mainTab.updatePendingChanges();
+				Global.mainTab.updatePendingChanges();
 				Global.mainTab.tbP.refreshTable();
 			}
-    	} else {
-	   	    CacheHolder ch=Global.getProfile().cacheDB.get(waypointName);
-	   	    if (ch == null) {
-	   	    	err(MyLocale.getMsg(1714,"Goto: Waypoint does not exist: ")+waypointName);
-	   	    	return;
-	   	    }
+		} else {
+			CacheHolder ch = Global.getProfile().cacheDB.get(waypointName);
+			if (ch == null) {
+				err(MyLocale.getMsg(1714, "Goto: Waypoint does not exist: ") + waypointName);
+				return;
+			}
 			CacheHolder addiWpt;
-	   	    if (ch.hasAddiWpt()){
-	   	    	op.append("cls()\n");
-				for (int j=0; j<ch.addiWpts.getCount();j++){
-					addiWpt = (CacheHolder)ch.addiWpts.get(j);
+			if (ch.hasAddiWpt()) {
+				op.append("cls()\n");
+				for (int j = 0; j < ch.addiWpts.getCount(); j++) {
+					addiWpt = (CacheHolder) ch.addiWpts.get(j);
 					op.append("IF $");
 					op.append(addiWpt.getWayPoint());
 					op.append("=\"\" THEN\n   $");
 					op.append(addiWpt.getWayPoint());
 					op.append("=\"\"");
-					//op.append(addiWpt.pos.toString());
+					// op.append(addiWpt.pos.toString());
 					op.append("\n   \"Punkt ");
-					op.append(addiWpt.getWayPoint().substring(0,2));
+					op.append(addiWpt.getWayPoint().substring(0, 2));
 					op.append(" [");
 					op.append(addiWpt.getCacheName());
 					op.append("] = \" $");
 					op.append(addiWpt.getWayPoint());
-					if (addiWpt.getCacheDetails(true).LongDescription.trim().length()>0)
-						op.append("\n   \""+STRreplace.replace(addiWpt.getCacheDetails(true).LongDescription,"\"","\"\"")+"\"");
+					if (addiWpt.getCacheDetails(true).LongDescription.trim().length() > 0)
+						op.append("\n   \"" + STRreplace.replace(addiWpt.getCacheDetails(true).LongDescription, "\"", "\"\"") + "\"");
 					op.append("\n   goto($");
 					op.append(addiWpt.getWayPoint());
 					op.append("); STOP\nENDIF\n\n");
 				}
-				Global.mainTab.solverP.mText.appendText(op.toString(),true);
+				Global.mainTab.solverP.mText.appendText(op.toString(), true);
 			}// if hasAddiWpt
-    	}
-    }
+		}
+	}
 
-    private double funcSqrt() throws Exception {
-    	double a=popCalcStackAsNumber(0);
-    	if (a<0) err(MyLocale.getMsg(1720,"Cannot calculate square root of a negative number"));
-    	return java.lang.Math.sqrt(a);
-    }
+	private double funcSqrt() throws Exception {
+		double a = popCalcStackAsNumber(0);
+		if (a < 0)
+			err(MyLocale.getMsg(1720, "Cannot calculate square root of a negative number"));
+		return java.lang.Math.sqrt(a);
+	}
 
-    /** Replace each character by its number A=1, B=2 etc. and put result into a string */
-    private String funcSval(String s) {
-       	s=s.toLowerCase();
-    	String res="";
-       	for (int i=0; i<s.length(); i++) {
-    		int pos="abcdefghijklmnopqrstuvwxyz".indexOf(s.charAt(i));
-    		if (pos>=0)
-    			res+=(res==""?"":" ")+MyLocale.formatLong(pos+1,"00");
-    	}
-    	return res;
-    }
+	/** Replace each character by its number A=1, B=2 etc. and put result into a string */
+	private String funcSval(String s) {
+		s = s.toLowerCase();
+		String res = "";
+		for (int i = 0; i < s.length(); i++) {
+			int pos = "abcdefghijklmnopqrstuvwxyz".indexOf(s.charAt(i));
+			if (pos >= 0)
+				res += (res == "" ? "" : " ") + MyLocale.formatLong(pos + 1, "00");
+		}
+		return res;
+	}
 
-    /** Replace each character by its number A=1, B=2 etc. and sum them */
-    private double funcVal(String s) {
-    	s=s.toLowerCase();
-    	int sum=0;
-    	for (int i=0; i<s.length(); i++) {
-    		sum+="abcdefghijklmnopqrstuvwxyz".indexOf(s.charAt(i))+1;
-    	}
-    	return sum;
-    }
+	/** Replace each character by its number A=1, B=2 etc. and sum them */
+	private double funcVal(String s) {
+		s = s.toLowerCase();
+		int sum = 0;
+		for (int i = 0; i < s.length(); i++) {
+			sum += "abcdefghijklmnopqrstuvwxyz".indexOf(s.charAt(i)) + 1;
+		}
+		return sum;
+	}
 
-///////////////////////////////////////////
-//  PARSER
-///////////////////////////////////////////
+	// /////////////////////////////////////////
+	// PARSER
+	// /////////////////////////////////////////
 
+	/**
+	 * The following methods implement a recursive descent parser.
+	 * Each method is called with 'thisToken' containing a valid token. It must return with 'thisToken' again containing
+	 * a valid token.
+	 */
 
-    /** The following methods implement a recursive descent parser.
-     * Each method is called with 'thisToken' containing a valid token. It must return with 'thisToken' again containing
-     * a valid token.
-     */
-
-	private void parseCommand()  throws Exception {
-		while(scanpos < tokenStack.size()) {
+	private void parseCommand() throws Exception {
+		while (scanpos < tokenStack.size()) {
 			getToken();
-			if (thisToken.token.equals(";")) continue;  // skip an empty command
-			if (thisToken.tt==TokenObj.TT_IF)
+			if (thisToken.token.equals(";"))
+				continue; // skip an empty command
+			if (thisToken.tt == TokenObj.TT_IF)
 				parseIf();
 			else
 				parseSimpleCommand();
@@ -929,314 +940,385 @@
 		}
 	}
 
-	private void parseSimpleCommand() throws Exception{
-		if (thisToken.tt==TokenObj.TT_STOP) throw new Exception("STOP");  // Terminate without error message
+	private void parseSimpleCommand() throws Exception {
+		if (thisToken.tt == TokenObj.TT_STOP)
+			throw new Exception("STOP"); // Terminate without error message
 		if (thisToken.token.equals("$")) { // Show all global variables
 			showVars(true);
 			getToken();
 		} else if (thisToken.token.equals("?")) { // Show all local variables
 			showVars(false);
 			getToken();
-		} else if (thisToken.tt==TokenObj.TT_VARIABLE && lookAheadToken().tt==TokenObj.TT_EQ)
+		} else if (thisToken.tt == TokenObj.TT_VARIABLE && lookAheadToken().tt == TokenObj.TT_EQ)
 			parseAssign();
 		else {
 			parseStringExp();
-			while (calcStack.size()>0) messageStack.add(popCalcStackAsString());
+			while (calcStack.size() > 0)
+				messageStack.add(popCalcStackAsString());
 		}
 	}
 
-	private void parseIf() throws Exception{
+	private void parseIf() throws Exception {
 		int compOp;
-		boolean compRes=false;
-		TokenObj ifToken=thisToken;
+		boolean compRes = false;
+		TokenObj ifToken = thisToken;
 		getToken();
 		// Check for "IF varName THEN" construct to check whether a variable is defined
-		if (thisToken.tt==TokenObj.TT_VARIABLE && peekToken().token.toUpperCase().equals("THEN")) {
-			String varName=thisToken.token;
-			getToken(); //THEN
-			Object result = symbolTable.get(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
-			if(result == null) { // Var not found check whether it is a waypoint
+		if (thisToken.tt == TokenObj.TT_VARIABLE && peekToken().token.toUpperCase().equals("THEN")) {
+			String varName = thisToken.token;
+			getToken(); // THEN
+			Object result = symbolTable.get(Global.getPref().solverIgnoreCase ? varName.toUpperCase() : varName);
+			if (result == null) { // Var not found check whether it is a waypoint
 				if (varName.startsWith("$")) { // Could be a cachename
-					varName=varName.substring(1);
-					compRes=Global.getProfile().getCacheIndex(varName)!=-1;
+					varName = varName.substring(1);
+					compRes = Global.getProfile().getCacheIndex(varName) != -1;
 				} else
-					compRes=false;
-			} else // Found the variable, it must have a value
-				compRes=true;
+					compRes = false;
+			} else
+				// Found the variable, it must have a value
+				compRes = true;
 			getNextTokenOtherThanSemi();
 		} else { // Normal: IF expression THEN
 			parseStringExp();
-			compOp=thisToken.tt;
-			if (compOp<TokenObj.TT_LT || compOp>TokenObj.TT_NE) err(MyLocale.getMsg(1723,"Comparison operator expected"));
+			compOp = thisToken.tt;
+			if (compOp < TokenObj.TT_LT || compOp > TokenObj.TT_NE)
+				err(MyLocale.getMsg(1723, "Comparison operator expected"));
 			getToken();
 			parseStringExp();
 			checkNextSymIs("THEN");
 			getNextTokenOtherThanSemi();
-			boolean compAsString=false; //calcStack.get(calcStack.size()-2) instanceof String;
+			boolean compAsString = false; // calcStack.get(calcStack.size()-2) instanceof String;
 			// If we can parse the first argument as a double, we will do a numeric comparison
 			try {
-				Common.parseDoubleException((String)calcStack.get(calcStack.size()-2) );
+				Common.parseDoubleException((String) calcStack.get(calcStack.size() - 2));
 			} catch (Exception ex) {
-				compAsString=true;
+				compAsString = true;
 			}
 			// If the first expression is not a double, compare as string.
 			if (compAsString) {
-				String b=popCalcStackAsString();
-				String a=popCalcStackAsString();
+				String b = popCalcStackAsString();
+				String a = popCalcStackAsString();
 				switch (compOp) {
-					case TokenObj.TT_EQ: compRes=a.equals(b); break;
-					case TokenObj.TT_NE: compRes=!a.equals(b); break;
-					case TokenObj.TT_LT: compRes=a.compareTo(b)<0; break;
-					case TokenObj.TT_GT: compRes=a.compareTo(b)>0; break;
-					case TokenObj.TT_LE: compRes=a.compareTo(b)<=0; break;
-					case TokenObj.TT_GE: compRes=a.compareTo(b)>=0; break;
+				case TokenObj.TT_EQ:
+					compRes = a.equals(b);
+					break;
+				case TokenObj.TT_NE:
+					compRes = !a.equals(b);
+					break;
+				case TokenObj.TT_LT:
+					compRes = a.compareTo(b) < 0;
+					break;
+				case TokenObj.TT_GT:
+					compRes = a.compareTo(b) > 0;
+					break;
+				case TokenObj.TT_LE:
+					compRes = a.compareTo(b) <= 0;
+					break;
+				case TokenObj.TT_GE:
+					compRes = a.compareTo(b) >= 0;
+					break;
 				}
 			} else { // First expression is a number, compare as numbers
-				double b=popCalcStackAsNumber(0);
-				double a=popCalcStackAsNumber(0);
+				double b = popCalcStackAsNumber(0);
+				double a = popCalcStackAsNumber(0);
 				switch (compOp) {
-					case TokenObj.TT_EQ: compRes=a==b; break;
-					case TokenObj.TT_NE: compRes=a!=b; break;
-					case TokenObj.TT_LT: compRes=a<b; break;
-					case TokenObj.TT_GT: compRes=a>b; break;
-					case TokenObj.TT_LE: compRes=a<=b; break;
-					case TokenObj.TT_GE: compRes=a>=b; break;
+				case TokenObj.TT_EQ:
+					compRes = a == b;
+					break;
+				case TokenObj.TT_NE:
+					compRes = a != b;
+					break;
+				case TokenObj.TT_LT:
+					compRes = a < b;
+					break;
+				case TokenObj.TT_GT:
+					compRes = a > b;
+					break;
+				case TokenObj.TT_LE:
+					compRes = a <= b;
+					break;
+				case TokenObj.TT_GE:
+					compRes = a >= b;
+					break;
 				}
 			}
 		}
 		if (compRes) { // comparison resulted in TRUE
-			if (thisToken.tt!=TokenObj.TT_ENDIF) {
+			if (thisToken.tt != TokenObj.TT_ENDIF) {
 				parseSimpleCommand();
 				while (thisToken.token.equals(";")) {
 					getNextTokenOtherThanSemi(); // Now we have either an ENDIF or the start of a simpleexpression
-					if (thisToken.tt==TokenObj.TT_ENDIF) break;
+					if (thisToken.tt == TokenObj.TT_ENDIF)
+						break;
 					parseSimpleCommand();
 				}
 				checkNextSymIs("ENDIF");
 			}
 			getToken();
-		} else // comparison failed
+		} else
+			// comparison failed
 			skipPastEndif(ifToken);
 	}
 
-	private void parseAssign() throws Exception  {
-		String varName=new String(thisToken.token);
-		getToken(); //=
+	private void parseAssign() throws Exception {
+		String varName = new String(thisToken.token);
+		getToken(); // =
 		getToken();
 		// Assigns of the format A=; are ignored so that they can stay as placeholders and
 		// we can fill the data progressively during a multicache
-		if (thisToken.tt==TokenObj.TT_ENDIF || thisToken.token.equals(";")) return;
+		if (thisToken.tt == TokenObj.TT_ENDIF || thisToken.token.equals(";"))
+			return;
 		parseStringExp();
 		if (varName.startsWith("$")) { // Potential coordinate
-			CacheHolder ch=Global.getProfile().cacheDB.get(varName.substring(1));
+			CacheHolder ch = Global.getProfile().cacheDB.get(varName.substring(1));
 			if (ch != null) { // Yes, is a coordinate
 				// Check whether new coordinates are valid
-				String coord=popCalcStackAsString();
+				String coord = popCalcStackAsString();
 				cwPt.set(coord);
 				if (cwPt.isValid() || coord.equals("")) { // Can clear coord with empty string
-					ch.setLatLon(cwPt.toString(TransformCoordinates.CW));
-					ch.pos.set(cwPt);
+					ch.setPos(cwPt);
 					ch.calcDistance(Global.getPref().getCurCentrePt()); // Update distance and bearing
-		    	    Global.getProfile().selectionChanged=true; // Tell moving map to updated displayed waypoints
-				    return;
+					Global.getProfile().selectionChanged = true; // Tell moving map to updated displayed waypoints
+					return;
 				} else
-					err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coord);
+					err(MyLocale.getMsg(1712, "Invalid coordinate: ") + coord);
 			}
 			// Name starts with $ but is not a waypoint, fall through and set it as global variable
 		}
-		symbolTable.put(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName, popCalcStackAsString());
+		symbolTable.put(Global.getPref().solverIgnoreCase ? varName.toUpperCase() : varName, popCalcStackAsString());
 	}
 
-	private void parseStringExp()throws Exception {
-		if (thisToken.tt==TokenObj.TT_STRING) {
+	private void parseStringExp() throws Exception {
+		if (thisToken.tt == TokenObj.TT_STRING) {
 			calcStack.add(thisToken.token);
 			getToken();
 		} else {
 			parseExp();
 		}
-		//calcStack.add(popCalcStackAsString());
-		while (thisToken.tt==TokenObj.TT_STRING ||
-			   thisToken.tt==TokenObj.TT_NUMBER ||
-			   thisToken.tt==TokenObj.TT_VARIABLE ||
-			   thisToken.tt==TokenObj.TT_SYMBOL && thisToken.token.equals("(")) {
-			if (thisToken.tt==TokenObj.TT_STRING) {
+		// calcStack.add(popCalcStackAsString());
+		while (thisToken.tt == TokenObj.TT_STRING || thisToken.tt == TokenObj.TT_NUMBER || thisToken.tt == TokenObj.TT_VARIABLE || thisToken.tt == TokenObj.TT_SYMBOL && thisToken.token.equals("(")) {
+			if (thisToken.tt == TokenObj.TT_STRING) {
 				calcStack.add(thisToken.token);
 				getToken();
 			} else {
 				parseTailExp('+');
 			}
-			String b=popCalcStackAsString();
-			String a=popCalcStackAsString();
-			calcStack.add(a+b);
+			String b = popCalcStackAsString();
+			String a = popCalcStackAsString();
+			calcStack.add(a + b);
 		}
 	}
 
-	private void parseExp()throws Exception {
-		char unaryOp='+';
-		if (thisToken.token.equals("+") || thisToken.token.equals("-") ) {
-			unaryOp=thisToken.token.charAt(0);
+	private void parseExp() throws Exception {
+		char unaryOp = '+';
+		if (thisToken.token.equals("+") || thisToken.token.equals("-")) {
+			unaryOp = thisToken.token.charAt(0);
 			getToken();
 		}
 		parseTailExp(unaryOp);
 	}
 
-	private void parseTailExp(char unaryOp)throws Exception {
+	private void parseTailExp(char unaryOp) throws Exception {
 		parseTerm();
-		if (unaryOp=='-') { // Unary minus, negate the first term
+		if (unaryOp == '-') { // Unary minus, negate the first term
 			calcStack.add(new java.lang.Double(-popCalcStackAsNumber(0)));
 		}
-		while (thisToken.token.equals("+") || thisToken.token.equals("-") ) {
-			char op=thisToken.token.charAt(0);
+		while (thisToken.token.equals("+") || thisToken.token.equals("-")) {
+			char op = thisToken.token.charAt(0);
 			getToken();
 			parseTerm();
-			double b=popCalcStackAsNumber(0);
-			double a=popCalcStackAsNumber(0);
-			if (op=='+')
-				calcStack.add(new java.lang.Double(a+b));
+			double b = popCalcStackAsNumber(0);
+			double a = popCalcStackAsNumber(0);
+			if (op == '+')
+				calcStack.add(new java.lang.Double(a + b));
 			else
-				calcStack.add(new java.lang.Double(a-b));
+				calcStack.add(new java.lang.Double(a - b));
 		}
 		// If expression is followed by a formatstring, format it
-		if (thisToken.tt==TokenObj.TT_FORMATSTR) {
-			calcStack.add(MyLocale.formatDouble(popCalcStackAsNumber(0),thisToken.token).replace(',','.'));
+		if (thisToken.tt == TokenObj.TT_FORMATSTR) {
+			calcStack.add(MyLocale.formatDouble(popCalcStackAsNumber(0), thisToken.token).replace(',', '.'));
 			getToken();
 		}
 	}
 
-	private void parseTerm() throws Exception{
+	private void parseTerm() throws Exception {
 		parseFactor();
-		while (thisToken.token.equals("*") || thisToken.token.equals("/") ) {
-			char op=thisToken.token.charAt(0);
+		while (thisToken.token.equals("*") || thisToken.token.equals("/")) {
+			char op = thisToken.token.charAt(0);
 			getToken();
 			parseFactor();
-			double b=popCalcStackAsNumber(1);
-			double a=popCalcStackAsNumber(1);
-			if (op=='*')
-				calcStack.add(new java.lang.Double(a*b));
+			double b = popCalcStackAsNumber(1);
+			double a = popCalcStackAsNumber(1);
+			if (op == '*')
+				calcStack.add(new java.lang.Double(a * b));
+			else if (b == 0.0)
+				err(MyLocale.getMsg(1729, "Division by 0"));
 			else
-				if (b==0.0)
-					err(MyLocale.getMsg(1729,"Division by 0"));
-				else
-					calcStack.add(new java.lang.Double(a/b));
+				calcStack.add(new java.lang.Double(a / b));
 		}
 	}
 
-	private void parseFactor() throws Exception{
+	private void parseFactor() throws Exception {
 		parseExpFactor();
 		while (thisToken.token.equals("^")) {
 			getToken();
 			parseExpFactor();
-			double exp=popCalcStackAsNumber(0);
-			double base=popCalcStackAsNumber(0);
-			calcStack.add(new java.lang.Double(java.lang.Math.pow(base,exp)));
+			double exp = popCalcStackAsNumber(0);
+			double base = popCalcStackAsNumber(0);
+			calcStack.add(new java.lang.Double(java.lang.Math.pow(base, exp)));
 		}
 	}
 
 	private void parseExpFactor() throws Exception {
 		fnType funcDef;
-		if (thisToken.tt==TokenObj.TT_VARIABLE) {
-			if (isVariable(thisToken.token) && !lookAheadToken().token.equals("(") )
+		if (thisToken.tt == TokenObj.TT_VARIABLE) {
+			if (isVariable(thisToken.token) && !lookAheadToken().token.equals("("))
 				calcStack.add(getVariable(thisToken.token));
-			else if (!lookAheadToken().token.equals("(")) err(MyLocale.getMsg(1724,"Variable not set: ")+thisToken.token);
-			    else {// Must be a function definition
-				funcDef=getFunctionDefinition(thisToken.token); // Does not return if function not defined or ambiguous
+			else if (!lookAheadToken().token.equals("("))
+				err(MyLocale.getMsg(1724, "Variable not set: ") + thisToken.token);
+			else {// Must be a function definition
+				funcDef = getFunctionDefinition(thisToken.token); // Does not return if function not defined or ambiguous
 				parseFunction(funcDef);
-			    }
-		} else if (thisToken.tt==TokenObj.TT_NUMBER) {
+			}
+		} else if (thisToken.tt == TokenObj.TT_NUMBER) {
 			calcStack.add(getNumber(thisToken.token));
-		} else if (thisToken.tt==TokenObj.TT_STRING) {
+		} else if (thisToken.tt == TokenObj.TT_STRING) {
 			calcStack.add(thisToken.token);
 		} else if (thisToken.token.equals("(")) {
 			getToken();
 			parseStringExp();
 			checkNextSymIs(")");
-		}
-		else err(MyLocale.getMsg(1725,"Unexpected character(s): ")+thisToken.token);
+		} else
+			err(MyLocale.getMsg(1725, "Unexpected character(s): ") + thisToken.token);
 		getToken();
 	}
 
 	private void parseFunction(fnType funcDef) throws Exception {
-		String funcName=new String(thisToken.token);
-        int nargs=0;
+		String funcName = new String(thisToken.token);
+		int nargs = 0;
 		getToken();
 		checkNextSymIs("(");
 		getToken();
 		if (!thisToken.token.equals(")")) { // at least one argument
 			parseStringExp();
-			nargs=1;
+			nargs = 1;
 			while (thisToken.token.equals(",")) {
-				if (nargs==4) err(MyLocale.getMsg(1726,"Too many arguments for function ")+funcName);
+				if (nargs == 4)
+					err(MyLocale.getMsg(1726, "Too many arguments for function ") + funcName);
 				getToken();
 				parseStringExp();
 				nargs++;
 			}
 			checkNextSymIs(")");
 		}
-		//getToken(); done in parseFactor
-		executeFunction(funcName,nargs,funcDef);
+		// getToken(); done in parseFactor
+		executeFunction(funcName, nargs, funcDef);
 	}
 
 	private void executeFunction(String funcName, int nargs, fnType funcDef) throws Exception {
-		if (!funcDef.nargsValid(nargs)) err(MyLocale.getMsg(1727,"Invalid number of arguments"));
-	         if (funcDef.alias.equals("asin")) calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.asin(popCalcStackAsNumber(0)))));
-	 	else if (funcDef.alias.equals("abs")) calcStack.add(new java.lang.Double(java.lang.Math.abs(popCalcStackAsNumber(0))));
-	    else if (funcDef.alias.equals("acos")) calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.acos(popCalcStackAsNumber(0)))));
-	    else if (funcDef.alias.equals("atan")) calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.atan(popCalcStackAsNumber(0)))));
-	    else if (funcDef.alias.equals("bearing")) calcStack.add(new java.lang.Double(funcBearing()));
-	    else if (funcDef.alias.equals("center")) funcCenter(nargs);
-	    else if (funcDef.alias.equals("cls")) funcCls();
-	    else if (funcDef.alias.equals("cos")) calcStack.add(new java.lang.Double(java.lang.Math.cos(makeRadiant(popCalcStackAsNumber(0)))));
-	    else if (funcDef.alias.equals("count")) funcCount();
-	    else if (funcDef.alias.equals("cp")) calcStack.add(funcCp());
-	    else if (funcDef.alias.equals("ct")) calcStack.add(new java.lang.Double(funcCrossTotal(nargs)));
-	    else if (funcDef.alias.equals("deg")) funcDeg(true);
-	    else if (funcDef.alias.equals("deg2rad")) calcStack.add(new java.lang.Double(funcDeg2Rad()));
-	    else if (funcDef.alias.equals("distance")) calcStack.add(new java.lang.Double(funcDistance()));
-	    else if (funcDef.alias.equals("encode")) calcStack.add(funcEncode());
-	    else if (funcDef.alias.equals("format")) calcStack.add(funcFormat(nargs));
-	    else if (funcDef.alias.equals("goto")) funcGoto(nargs);
-	    else if (funcDef.alias.equals("ic")) funcIgnoreVariableCase(nargs);
-	    else if (funcDef.alias.equals("instr")) calcStack.add(new Double(funcInstr(nargs)));
-	    else if (funcDef.alias.equals("int")) calcStack.add(new Double(new Double(popCalcStackAsNumber(0)).longValue()));
-	    else if (funcDef.alias.equals("lc")) calcStack.add(popCalcStackAsString().toLowerCase());
-	    else if (funcDef.alias.equals("len")) calcStack.add(new Double(popCalcStackAsString().length()));
-	    else if (funcDef.alias.equals("mid")) calcStack.add(funcMid(nargs));
-	    else if (funcDef.alias.equals("mod")) calcStack.add(funcMod());
-	    else if (funcDef.alias.equals("project")) calcStack.add(funcProject());
-	    else if (funcDef.alias.equals("pz")) funcPz(nargs);
-	    else if (funcDef.alias.equals("rad")) funcDeg(false);
-	    else if (funcDef.alias.equals("rad2deg")) calcStack.add(new java.lang.Double(funcRad2Deg()));
-	    else if (funcDef.alias.equals("replace")) calcStack.add(funcReplace());
-	    else if (funcDef.alias.equals("reverse")) calcStack.add(funcReverse(popCalcStackAsString()));
-	    else if (funcDef.alias.equals("rot13")) calcStack.add(Common.rot13(popCalcStackAsString()));
-//	    else if (funcDef.alias.equals("rs")) funcRequireSemicolon(nargs);
-	    else if (funcDef.alias.equals("show"));
-	    else if (funcDef.alias.equals("sin")) calcStack.add(new java.lang.Double(java.lang.Math.sin(makeRadiant(popCalcStackAsNumber(0)))));
-	    else if (funcDef.alias.equals("skeleton")) funcSkeleton(nargs);
-	    else if (funcDef.alias.equals("sqrt")) calcStack.add(new java.lang.Double(funcSqrt()));
-	    else if (funcDef.alias.equals("sval")) calcStack.add(funcSval(popCalcStackAsString()));
-	    else if (funcDef.alias.equals("tan")) calcStack.add(new java.lang.Double(java.lang.Math.tan(makeRadiant(popCalcStackAsNumber(0)))));
-	    else if (funcDef.alias.equals("uc")) calcStack.add(popCalcStackAsString().toUpperCase());
-	    else if (funcDef.alias.equals("val")) calcStack.add(new java.lang.Double(funcVal(popCalcStackAsString())));
-	    else if (funcDef.alias.equals("cb")) calcStack.add(funcCrossBearing ());
-	    else err(MyLocale.getMsg(1728,"Function not yet implemented: ")+funcName);
+		if (!funcDef.nargsValid(nargs))
+			err(MyLocale.getMsg(1727, "Invalid number of arguments"));
+		if (funcDef.alias.equals("asin"))
+			calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.asin(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals("abs"))
+			calcStack.add(new java.lang.Double(java.lang.Math.abs(popCalcStackAsNumber(0))));
+		else if (funcDef.alias.equals("acos"))
+			calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.acos(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals("atan"))
+			calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.atan(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals("bearing"))
+			calcStack.add(new java.lang.Double(funcBearing()));
+		else if (funcDef.alias.equals("center"))
+			funcCenter(nargs);
+		else if (funcDef.alias.equals("cls"))
+			funcCls();
+		else if (funcDef.alias.equals("cos"))
+			calcStack.add(new java.lang.Double(java.lang.Math.cos(makeRadiant(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals("count"))
+			funcCount();
+		else if (funcDef.alias.equals("cp"))
+			calcStack.add(funcCp());
+		else if (funcDef.alias.equals("ct"))
+			calcStack.add(new java.lang.Double(funcCrossTotal(nargs)));
+		else if (funcDef.alias.equals("deg"))
+			funcDeg(true);
+		else if (funcDef.alias.equals("deg2rad"))
+			calcStack.add(new java.lang.Double(funcDeg2Rad()));
+		else if (funcDef.alias.equals("distance"))
+			calcStack.add(new java.lang.Double(funcDistance()));
+		else if (funcDef.alias.equals("encode"))
+			calcStack.add(funcEncode());
+		else if (funcDef.alias.equals("format"))
+			calcStack.add(funcFormat(nargs));
+		else if (funcDef.alias.equals("goto"))
+			funcGoto(nargs);
+		else if (funcDef.alias.equals("ic"))
+			funcIgnoreVariableCase(nargs);
+		else if (funcDef.alias.equals("instr"))
+			calcStack.add(new Double(funcInstr(nargs)));
+		else if (funcDef.alias.equals("int"))
+			calcStack.add(new Double(new Double(popCalcStackAsNumber(0)).longValue()));
+		else if (funcDef.alias.equals("lc"))
+			calcStack.add(popCalcStackAsString().toLowerCase());
+		else if (funcDef.alias.equals("len"))
+			calcStack.add(new Double(popCalcStackAsString().length()));
+		else if (funcDef.alias.equals("mid"))
+			calcStack.add(funcMid(nargs));
+		else if (funcDef.alias.equals("mod"))
+			calcStack.add(funcMod());
+		else if (funcDef.alias.equals("project"))
+			calcStack.add(funcProject());
+		else if (funcDef.alias.equals("pz"))
+			funcPz(nargs);
+		else if (funcDef.alias.equals("rad"))
+			funcDeg(false);
+		else if (funcDef.alias.equals("rad2deg"))
+			calcStack.add(new java.lang.Double(funcRad2Deg()));
+		else if (funcDef.alias.equals("replace"))
+			calcStack.add(funcReplace());
+		else if (funcDef.alias.equals("reverse"))
+			calcStack.add(funcReverse(popCalcStackAsString()));
+		else if (funcDef.alias.equals("rot13"))
+			calcStack.add(Common.rot13(popCalcStackAsString()));
+		// else if (funcDef.alias.equals("rs")) funcRequireSemicolon(nargs);
+		else if (funcDef.alias.equals("show"))
+			;
+		else if (funcDef.alias.equals("sin"))
+			calcStack.add(new java.lang.Double(java.lang.Math.sin(makeRadiant(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals("skeleton"))
+			funcSkeleton(nargs);
+		else if (funcDef.alias.equals("sqrt"))
+			calcStack.add(new java.lang.Double(funcSqrt()));
+		else if (funcDef.alias.equals("sval"))
+			calcStack.add(funcSval(popCalcStackAsString()));
+		else if (funcDef.alias.equals("tan"))
+			calcStack.add(new java.lang.Double(java.lang.Math.tan(makeRadiant(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals("uc"))
+			calcStack.add(popCalcStackAsString().toUpperCase());
+		else if (funcDef.alias.equals("val"))
+			calcStack.add(new java.lang.Double(funcVal(popCalcStackAsString())));
+		else if (funcDef.alias.equals("cb"))
+			calcStack.add(funcCrossBearing());
+		else
+			err(MyLocale.getMsg(1728, "Function not yet implemented: ") + funcName);
 	}
 
-	public void parse(Vector tck, Vector msgStack){
+	public void parse(Vector tck, Vector msgStack) {
 		calcStack.clear();
 		clearLocalSymbols();
 		tokenStack = tck;
 		messageStack = msgStack;
 		scanpos = 0;
-		try{
+		try {
 			parseCommand();
-		}catch(Exception ex){
+		} catch (Exception ex) {
 		}
 	}
 
-	private boolean createWptIfNeeded(String wayPoint, String name, byte type){
-	   	int ci=Global.getProfile().getCacheIndex(wayPoint);
-    	if (ci >= 0) return false;
+	private boolean createWptIfNeeded(String wayPoint, String name, byte type) {
+		int ci = Global.getProfile().getCacheIndex(wayPoint);
+		if (ci >= 0)
+			return false;
 
 		CacheHolder ch = new CacheHolder();
 		ch.setWayPoint(wayPoint);

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/Profile.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -592,32 +592,29 @@
 		CacheHolder ch;
 		CWPoint topleft = null;
 		CWPoint bottomright = null;
-		CWPoint tmpca = new CWPoint();
 		numCachesInArea = 0;
 		boolean isAddi = false;
 		for (int i = cacheDB.size() - 1; i >= 0; i--) {
 			ch = cacheDB.get(i);
 			if (!onlyOfSelected || ch.is_Checked) {
-				if (ch.pos == null) { // this can not happen
-					tmpca.set(ch.getLatLon());
-					ch.pos = new CWPoint(tmpca);
-				}
-				if (ch.pos.isValid()) { // done: && ch.pos.latDec != 0 && ch.pos.lonDec != 0 TO-DO != 0 sollte rausgenommen werden sobald in der Liste vern?nftig mit nicht gesetzten pos umgegangen wird
+				if (ch.getPos().isValid()) { // done: && ch.pos.latDec != 0 && ch.pos.lonDec != 0 TO-DO != 0 sollte rausgenommen werden sobald in der Liste vern?nftig mit nicht gesetzten pos umgegangen wird
 					isAddi = ch.isAddiWpt();
-					if (!isAddi || (isAddi && ch.mainCache != null && ch.pos.getDistance(ch.mainCache.pos) < 1000)) { // test for plausiblity of coordinates of Additional Waypoints: more then 1000 km away from main Waypoint is unplausible -> ignore it //
-																														// && ch.mainCache != null is only necessary because the data base may be corrupted
+					// test for plausiblity of coordinates of Additional Waypoints: more then 1000 km away from main Waypoint is unplausible ->
+					// ignore it //
+					// && ch.mainCache != null is only necessary because the data base may be corrupted
+					if (!isAddi || (isAddi && ch.mainCache != null && ch.getPos().getDistance(ch.mainCache.getPos()) < 1000)) {
 						if (topleft == null)
-							topleft = new CWPoint(ch.pos);
+							topleft = new CWPoint(ch.getPos());
 						if (bottomright == null)
-							bottomright = new CWPoint(ch.pos);
-						if (topleft.latDec < ch.pos.latDec)
-							topleft.latDec = ch.pos.latDec;
-						if (topleft.lonDec > ch.pos.lonDec)
-							topleft.lonDec = ch.pos.lonDec;
-						if (bottomright.latDec > ch.pos.latDec)
-							bottomright.latDec = ch.pos.latDec;
-						if (bottomright.lonDec < ch.pos.lonDec)
-							bottomright.lonDec = ch.pos.lonDec;
+							bottomright = new CWPoint(ch.getPos());
+						if (topleft.latDec < ch.getPos().latDec)
+							topleft.latDec = ch.getPos().latDec;
+						if (topleft.lonDec > ch.getPos().lonDec)
+							topleft.lonDec = ch.getPos().lonDec;
+						if (bottomright.latDec > ch.getPos().latDec)
+							bottomright.latDec = ch.getPos().latDec;
+						if (bottomright.lonDec < ch.getPos().lonDec)
+							bottomright.lonDec = ch.getPos().lonDec;
 						numCachesInArea++;
 					}
 				}

Modified: trunk/src/CacheWolf/RadarPanel.java
===================================================================
--- trunk/src/CacheWolf/RadarPanel.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/RadarPanel.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -139,7 +139,7 @@
 		final double pi180 = java.lang.Math.PI / 180.0;
 		for (int i = cacheDB.size() - 1; i >= 0; i--) {
 			holder = cacheDB.get(i);
-			if (holder.isVisible() && holder.pos.isValid()) {
+			if (holder.isVisible() && holder.getPos().isValid()) {
 				degrees = holder.degrees * pi180;
 				drX = new Float(holder.kilom / scale * java.lang.Math.sin(degrees)).intValue();
 				drY = -new Float(holder.kilom / scale * java.lang.Math.cos(degrees)).intValue();

Modified: trunk/src/CacheWolf/exp/DistanceComparer.java
===================================================================
--- trunk/src/CacheWolf/exp/DistanceComparer.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/exp/DistanceComparer.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CWPoint;
@@ -30,21 +30,21 @@
 import ewe.util.Comparer;
 
 public class DistanceComparer implements Comparer {
-	
+
 	CWPoint centre;
-	
+
 	public DistanceComparer(CWPoint centre) {
 		this.centre = centre;
 	}
 
 	public int compare(Object one, Object two) {
-		if ((! (one instanceof CacheHolder)) && (!(two instanceof CacheHolder))) {
+		if ((!(one instanceof CacheHolder)) && (!(two instanceof CacheHolder))) {
 			return 0;
 		} else {
 			CacheHolder a = (CacheHolder) one;
 			CacheHolder b = (CacheHolder) two;
-			return (int) ((a.pos.getDistance(centre) - b.pos.getDistance(centre)) * 1000);
+			return (int) ((a.getPos().getDistance(centre) - b.getPos().getDistance(centre)) * 1000);
 		}
 	}
-	
+
 }

Modified: trunk/src/CacheWolf/exp/ExploristExporter.java
===================================================================
--- trunk/src/CacheWolf/exp/ExploristExporter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/exp/ExploristExporter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CWPoint;
@@ -95,19 +95,19 @@
 	public void doIt() {
 		File configFile = new File("magellan.cfg");
 		if (configFile.exists()) {
-			FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, pref.getExportPath(expName+"Dir"));
+			FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, pref.getExportPath(expName + "Dir"));
 			fc.setTitle(MyLocale.getMsg(2104, "Choose directory for exporting .gs files"));
 			String targetDir;
-			if(fc.execute() != FormBase.IDCANCEL){
+			if (fc.execute() != FormBase.IDCANCEL) {
 				targetDir = fc.getChosen() + "/";
-				pref.setExportPath(expName+"Dir", targetDir);
+				pref.setExportPath(expName + "Dir", targetDir);
 
 				CWPoint centre = profile.centre;
 				try {
 					LineNumberReader reader = new LineNumberReader(new BufferedReader(new FileReader(configFile)));
 					String line, fileName, coordinate;
-					while ((line = reader.readLine()) != null)  {
-						StringTokenizer tokenizer = new StringTokenizer(line,"=");
+					while ((line = reader.readLine()) != null) {
+						StringTokenizer tokenizer = new StringTokenizer(line, "=");
 						fileName = targetDir + tokenizer.nextToken().trim() + ".gs";
 						coordinate = tokenizer.nextToken().trim();
 						CWPoint point = new CWPoint(coordinate);
@@ -117,17 +117,16 @@
 					}
 					reader.close();
 				} catch (FileNotFoundException e) {
-					InfoBox info = new InfoBox(MyLocale.getMsg(2100, "Explorist Exporter"),MyLocale.getMsg(2101, "Failure at loading magellan.cfg\n" + e.getMessage()));
+					InfoBox info = new InfoBox(MyLocale.getMsg(2100, "Explorist Exporter"), MyLocale.getMsg(2101, "Failure at loading magellan.cfg\n" + e.getMessage()));
 					info.show();
 				} catch (IOException e) {
-					InfoBox info = new InfoBox(MyLocale.getMsg(2100, "Explorist Exporter"),MyLocale.getMsg(2103, "Failure at reading magellan.cfg\n" + e.getMessage()));
+					InfoBox info = new InfoBox(MyLocale.getMsg(2100, "Explorist Exporter"), MyLocale.getMsg(2103, "Failure at reading magellan.cfg\n" + e.getMessage()));
 					info.show();
 				} finally {
-					cacheDB.sort(new DistanceComparer(centre),false);
+					cacheDB.sort(new DistanceComparer(centre), false);
 				}
 			}
-		}
-		else {
+		} else {
 			doIt(null);
 		}
 	}
@@ -164,18 +163,14 @@
 
 		try {
 			// Set initial value for outp to calm down compiler
-			PrintWriter outp = new PrintWriter(new BufferedWriter(
-								new FileWriter(new File(fileBaseName + expCount
-										/ 200 + ".gs"))));
+			PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(new File(fileBaseName + expCount / 200 + ".gs"))));
 			for (int i = 0; i < cacheDB.size(); i++) {
 				ch = cacheDB.get(i);
 				if (ch.isVisible()) {
 					// all 200 caches we need a new file
 					if (expCount % 200 == 0 && expCount > 0) {
 						outp.close();
-						outp = new PrintWriter(new BufferedWriter(
-								new FileWriter(new File(fileBaseName + expCount
-										/ 200 + ".gs"))));
+						outp = new PrintWriter(new BufferedWriter(new FileWriter(new File(fileBaseName + expCount / 200 + ".gs"))));
 					}
 
 					expCount++;
@@ -195,20 +190,19 @@
 			outp.close();
 			pbf.exit(0);
 		} catch (IOException ioE) {
-			pref.log("Error opening " + outFile.getName(),ioE);
+			pref.log("Error opening " + outFile.getName(), ioE);
 		}
 		// try
 	}
 
 	/**
 	 * uses a filechooser to get the name of the export file
-	 *
+	 * 
 	 * @return
 	 */
 	public File getOutputFile() {
 		File file;
-		FileChooser fc = new FileChooser(FileChooserBase.SAVE, pref
-				.getExportPath(expName));
+		FileChooser fc = new FileChooser(FileChooserBase.SAVE, pref.getExportPath(expName));
 		fc.setTitle(MyLocale.getMsg(2102, "Select target file:"));
 		fc.addMask(mask);
 		if (fc.execute() != FormBase.IDCANCEL) {
@@ -222,7 +216,7 @@
 
 	/**
 	 * this method can be overided by an exporter class
-	 *
+	 * 
 	 * @param ch
 	 *            cachedata
 	 * @return formated cache data
@@ -230,21 +224,21 @@
 	public String record(CacheHolder ch) {
 		CacheHolderDetail det = ch.getCacheDetails(true);
 		/*
-		static protected final int GC_AW_PARKING = 50;
-		static protected final int GC_AW_STAGE_OF_MULTI = 51;
-		static protected final int GC_AW_QUESTION = 52;
-		static protected final int GC_AW_FINAL = 53;
-		static protected final int GC_AW_TRAILHEAD = 54;
-		static protected final int GC_AW_REFERENCE = 55;
-		*/
+		 * static protected final int GC_AW_PARKING = 50;
+		 * static protected final int GC_AW_STAGE_OF_MULTI = 51;
+		 * static protected final int GC_AW_QUESTION = 52;
+		 * static protected final int GC_AW_FINAL = 53;
+		 * static protected final int GC_AW_TRAILHEAD = 54;
+		 * static protected final int GC_AW_REFERENCE = 55;
+		 */
 		StringBuffer sb = new StringBuffer();
 		sb.append("$PMGNGEO,");
-		sb.append(ch.pos.getLatDeg(CWPoint.DMM));
-		sb.append(ch.pos.getLatMin(CWPoint.DMM));
+		sb.append(ch.getPos().getLatDeg(CWPoint.DMM));
+		sb.append(ch.getPos().getLatMin(CWPoint.DMM));
 		sb.append(",");
 		sb.append("N,");
-		sb.append(ch.pos.getLonDeg(CWPoint.DMM));
-		sb.append(ch.pos.getLonMin(CWPoint.DMM));
+		sb.append(ch.getPos().getLonDeg(CWPoint.DMM));
+		sb.append(ch.getPos().getLonMin(CWPoint.DMM));
 		sb.append(",");
 		sb.append("E,");
 		sb.append("0000,"); // Height
@@ -281,11 +275,11 @@
 			sb.append(CacheType.type2GSTypeTag(ch.getType()));
 		}
 		sb.append(",");
-		sb.append(toGsDateFormat(ch.getDateHidden()));  // created - DDMMYYY, YYY = year - 1900
+		sb.append(toGsDateFormat(ch.getDateHidden())); // created - DDMMYYY, YYY = year - 1900
 		sb.append(",");
 		String lastFound = "0000";
 		for (int i = 0; i < det.CacheLogs.size(); i++) {
-			if (det.CacheLogs.getLog(i).isFoundLog() && det.CacheLogs.getLog(i).getDate().compareTo(lastFound) > 0 ) {
+			if (det.CacheLogs.getLog(i).isFoundLog() && det.CacheLogs.getLog(i).getDate().compareTo(lastFound) > 0) {
 				lastFound = det.CacheLogs.getLog(i).getDate();
 			}
 		}
@@ -301,7 +295,7 @@
 
 	/**
 	 * this method can be overided by an exporter class
-	 *
+	 * 
 	 * @return formated trailer data
 	 */
 	public String trailer() {
@@ -310,6 +304,7 @@
 
 	/**
 	 * Changes "," in "." in the input String
+	 * 
 	 * @param input
 	 * @return changed String
 	 */
@@ -319,14 +314,15 @@
 
 	/**
 	 * change the Dateformat from "yyyy-mm-dd" to ddmmyyy, where yyy is years after 1900
-	 * @param input Date in yyyy-mm-dd
- 	 * @return Date in ddmmyyy
+	 * 
+	 * @param input
+	 *            Date in yyyy-mm-dd
+	 * @return Date in ddmmyyy
 	 */
 	private String toGsDateFormat(String input) {
 		if (input.length() >= 10) {
 			return input.substring(8, 10) + input.substring(5, 7) + "1" + input.substring(2, 4);
-		}
-		else {
+		} else {
 			return "";
 		}
 	}

Modified: trunk/src/CacheWolf/exp/Exporter.java
===================================================================
--- trunk/src/CacheWolf/exp/Exporter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/exp/Exporter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CWPoint;
@@ -48,11 +48,11 @@
 
 /**
  * @author Kalle
- * Base class for exporter, handles basic things like selecting
- * outputfile, display a counter etc.
- * A new Exporter must only override the header(), record() and 
- * trailer() methods. The member howManyParams must be set to identify
- * which ethod should be called  
+ *         Base class for exporter, handles basic things like selecting
+ *         outputfile, display a counter etc.
+ *         A new Exporter must only override the header(), record() and
+ *         trailer() methods. The member howManyParams must be set to identify
+ *         which ethod should be called
  */
 
 public class Exporter {
@@ -60,12 +60,12 @@
 	final static int TMP_FILE = 0;
 	// brings up a screen to select a file
 	final static int ASK_FILE = 1;
-	
+
 	// selection, which method should be called
-	final static int NO_PARAMS 	= 0;
-	final static int LAT_LON 	= 1;
-	final static int COUNT 		= 2;
-	
+	final static int NO_PARAMS = 0;
+	final static int LAT_LON = 1;
+	final static int COUNT = 2;
+
 	CacheDB cacheDB;
 	Preferences pref;
 	Profile profile;
@@ -74,97 +74,100 @@
 	// file name, if no file chooser is used
 	String tmpFileName;
 	// decimal separator for lat- and lon-String
-	char decimalSeparator='.';
-	// if  true, the complete cache details are read
-	// before a call to the record method is made 
+	char decimalSeparator = '.';
+	// if true, the complete cache details are read
+	// before a call to the record method is made
 	boolean needCacheDetails = false;
 	// selection, which method should be called
 	int howManyParams = 0;
-	
-	//name of exporter for saving pathname
+
+	// name of exporter for saving pathname
 	String expName;
-	
+
 	public Exporter() {
 		profile = Global.getProfile();
 		pref = Global.getPref();
 		cacheDB = profile.cacheDB;
 		howManyParams = LAT_LON;
-		expName = this.getClass().getName(); 
+		expName = this.getClass().getName();
 		// remove package
 		expName = expName.substring(expName.indexOf(".") + 1);
 	}
-	
-	public void doIt(){
+
+	public void doIt() {
 		this.doIt(ASK_FILE);
 	}
 
 	/**
 	 * Does the most work for exporting data
-	 * @param variant 0, if no filechooser
-	 *                1, if filechooser
+	 * 
+	 * @param variant
+	 *            0, if no filechooser
+	 *            1, if filechooser
 	 */
-	public void doIt(int variant){
+	public void doIt(int variant) {
 		File outFile;
 		String str;
 		CacheHolder ch;
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
 
-
 		if (variant == ASK_FILE) {
 			outFile = getOutputFile();
-			if (outFile == null) return;
+			if (outFile == null)
+				return;
 		} else {
 			outFile = new File(tmpFileName);
 		}
 
 		pbf.showMainTask = false;
-		pbf.setTask(h,"Exporting ...");
+		pbf.setTask(h, "Exporting ...");
 		pbf.exec();
 
 		int counter = cacheDB.countVisible();
 		int expCount = 0;
 
-		try{
+		try {
 			int incompleteWaypoints = 0;
-			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(outFile)));
+			PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(outFile)));
 			str = this.header();
-			if (str != null) outp.print(str);
-			for(int i = 0; i<cacheDB.size(); i++){
-				ch=cacheDB.get(i);
-				if(ch.isVisible()){
+			if (str != null)
+				outp.print(str);
+			for (int i = 0; i < cacheDB.size(); i++) {
+				ch = cacheDB.get(i);
+				if (ch.isVisible()) {
 					if (ch.is_incomplete()) {
-						Global.getPref().log("skipping export of incomplete waypoint "+ch.getWayPoint());
+						Global.getPref().log("skipping export of incomplete waypoint " + ch.getWayPoint());
 						incompleteWaypoints++;
 						continue;
 					}
 					expCount++;
-					h.progress = (float)expCount/(float)counter;
+					h.progress = (float) expCount / (float) counter;
 					h.changed();
 					switch (this.howManyParams) {
 					case NO_PARAMS:
 						str = record(ch);
 						break;
 					case LAT_LON:
-						if (ch.pos.isValid() == false) continue;
-						str = record(ch, ch.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-								     ch.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+						if (ch.getPos().isValid() == false)
+							continue;
+						str = record(ch, ch.getPos().getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), ch.getPos().getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
 						break;
-					case LAT_LON|COUNT: 
-						if (ch.pos.isValid() == false) continue;
-						str = record(ch, ch.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-									 ch.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-											 i);
+					case LAT_LON | COUNT:
+						if (ch.getPos().isValid() == false)
+							continue;
+						str = record(ch, ch.getPos().getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), ch.getPos().getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator), i);
 						break;
 					default:
 						str = null;
 						break;
 					}
-					if (str != null) outp.print(str);
-				}//if
-			}//for
+					if (str != null)
+						outp.print(str);
+				}// if
+			}// for
 			switch (this.howManyParams & COUNT) {
-			case NO_PARAMS: 
+			case NO_PARAMS:
 				str = trailer();
 				break;
 			case COUNT:
@@ -174,64 +177,75 @@
 				str = null;
 				break;
 			}
-			if (str != null) outp.print(str);
+			if (str != null)
+				outp.print(str);
 			outp.close();
 			pbf.exit(0);
 			if (incompleteWaypoints > 0) {
-				new MessageBox("Export Error", incompleteWaypoints+" incomplete waypoints have not been exported. See log for details.", FormBase.OKB).execute();
+				new MessageBox("Export Error", incompleteWaypoints + " incomplete waypoints have not been exported. See log for details.", FormBase.OKB).execute();
 			}
-		} catch (IOException ioE){
-			pref.log("Error opening " + outFile.getName(),ioE);
+		} catch (IOException ioE) {
+			pref.log("Error opening " + outFile.getName(), ioE);
 		}
-		//try
+		// try
 	}
+
 	/**
 	 * sets mask for filechooser
-	 * @param mask 
+	 * 
+	 * @param mask
 	 */
-	public void setMask(String mask){
+	public void setMask(String mask) {
 		this.mask = mask;
 	}
+
 	/**
 	 * sets decimal separator for lat/lon-string
+	 * 
 	 * @param sep
 	 */
-	public void setDecimalSeparator (char sep){
+	public void setDecimalSeparator(char sep) {
 		this.decimalSeparator = sep;
 	}
+
 	/**
-	 *  sets needCacheDetails
+	 * sets needCacheDetails
+	 * 
 	 * @param how
 	 */
-	public void setNeedCacheDetails(boolean how){
+	public void setNeedCacheDetails(boolean how) {
 		this.needCacheDetails = how;
 	}
-	
+
 	/**
 	 * sets howManyParams
+	 * 
 	 * @param paramBits
 	 */
-	public void setHowManyParams(int paramBits){
+	public void setHowManyParams(int paramBits) {
 		this.howManyParams = paramBits;
 	}
+
 	/**
 	 * sets tmpFileName
+	 * 
 	 * @param fName
 	 */
-	public void setTmpFileName(String fName){
+	public void setTmpFileName(String fName) {
 		this.tmpFileName = fName;
 	}
 
 	/**
 	 * uses a filechooser to get the name of the export file
+	 * 
 	 * @return
 	 */
-	public File getOutputFile (){
+	public File getOutputFile() {
 		File file;
 		FileChooser fc = new FileChooser(FileChooserBase.SAVE, pref.getExportPath(expName));
 		fc.setTitle("Select target file:");
 		fc.addMask(mask);
-		if(fc.execute() != FormBase.IDCANCEL){
+		if (fc.execute() != FormBase.IDCANCEL) {
 			file = fc.getChosenFile();
 			pref.setExportPath(expName, file.getPath());
 			return file;
@@ -239,226 +253,145 @@
 			return null;
 		}
 	}
+
 	/**
 	 * this method can be overided by an exporter class
+	 * 
 	 * @return formated header data
-	 */	
-	public String header () {
+	 */
+	public String header() {
 		return null;
 	}
 
 	/**
 	 * this method can be overided by an exporter class
-	 * @param ch	cachedata
+	 * 
+	 * @param ch
+	 *            cachedata
 	 * @return formated cache data
-	 */	
-	public String record(CacheHolder chD){
+	 */
+	public String record(CacheHolder chD) {
 		return null;
 	}
 
 	/**
 	 * this method can be overided by an exporter class
-	 * @param ch	cachedata
-	 * @param lat	
+	 * 
+	 * @param ch
+	 *            cachedata
+	 * @param lat
 	 * @param lon
 	 * @return formated cache data
 	 */
-	public String record(CacheHolder ch, String lat, String lon){
+	public String record(CacheHolder ch, String lat, String lon) {
 		return null;
 	}
+
 	/**
 	 * this method can be overided by an exporter class
-	 * @param ch	cachedata
-	 * @param lat	
+	 * 
+	 * @param ch
+	 *            cachedata
+	 * @param lat
 	 * @param lon
-	 * @param count of actual record
+	 * @param count
+	 *            of actual record
 	 * @return formated cache data
 	 */
-	public String record(CacheHolder ch, String lat, String lon, int count){
+	public String record(CacheHolder ch, String lat, String lon, int count) {
 		return null;
 	}
-	
+
 	/**
 	 * this method can be overided by an exporter class
+	 * 
 	 * @return formated trailer data
-	 */	
-	public String trailer(){
+	 */
+	public String trailer() {
 		return null;
 	}
+
 	/**
 	 * this method can be overided by an exporter class
-	 * @param total count of exported caches
+	 * 
+	 * @param total
+	 *            count of exported caches
 	 * @return
 	 */
-	public String trailer(int total){
+	public String trailer(int total) {
 		return null;
 	}
 
-///////////////////////////////////////////////////
-//  Helper functions for string sanitisation
-///////////////////////////////////////////////////
-	
+	// /////////////////////////////////////////////////
+	// Helper functions for string sanitisation
+	// /////////////////////////////////////////////////
+
 	private static Hashtable iso2simpleMappings = new Hashtable(250);
 	static {
-		String[] mappingArray = new String[] {
-				"34",  "'",
-				"160", " ",
-				"161", "i",
-				"162", "c",
-				"163", "$",
-				"164", "o",
-				"165", "$",
-				"166", "!",
-				"167", "$",
-				"168", " ",
-				"169", " ",
-				"170", " ",
-				"171", "<",
-				"172", " ",
-				"173", "-",
-				"174", " ",
-				"175", "-",
-				"176", " ",
-				"177", "+/-",
-				"178", "2",
-				"179", "3",
-				"180", "'",
-				"181", " ",
-				"182", " ",
-				"183", " ",
-				"184", ",",
-				"185", "1",
-				"186", " ",
-				"187", ">",
-				"188", "1/4",
-				"189", "1/2",
-				"190", "3/4",
-				"191", "?",
-				"192", "A",
-				"193", "A",
-				"194", "A",
-				"195", "A",
-				"196", "Ae",
-				"197", "A",
-				"198", "AE",
-				"199", "C",
-				"200", "E",
-				"201", "E",
-				"202", "E",
-				"203", "E",
-				"204", "I",
-				"205", "I",
-				"206", "I",
-				"207", "I",
-				"208", "D",
-				"209", "N",
-				"210", "O",
-				"211", "O",
-				"212", "O",
-				"213", "O",
-				"214", "Oe",
-				"215", "x",
-				"216", "O",
-				"217", "U",
-				"218", "U",
-				"219", "U",
-				"220", "Ue",
-				"221", "Y",
-				"222", " ",
-				"223", "ss",
-				"224", "a",
-				"225", "a",
-				"226", "a",
-				"227", "a",
-				"228", "ae",
-				"229", "a",
-				"230", "ae",
-				"231", "c",
-				"232", "e",
-				"233", "e",
-				"234", "e",
-				"235", "e",
-				"236", "i",
-				"237", "i",
-				"238", "i",
-				"239", "i",
-				"240", "o",
-				"241", "n",
-				"242", "o",
-				"243", "o",
-				"244", "o",
-				"245", "o",
-				"246", "oe",
-				"247", "/",
-				"248", "o",
-				"249", "u",
-				"250", "u",
-				"251", "u",
-				"252", "ue",
-				"253", "y",
-				"254", "p",
-				"255", "y"
-		};
+		String[] mappingArray = new String[] { "34", "'", "160", " ", "161", "i", "162", "c", "163", "$", "164", "o", "165", "$", "166", "!", "167", "$", "168", " ", "169", " ", "170", " ", "171", "<", "172", " ", "173", "-", "174", " ", "175", "-",
+				"176", " ", "177", "+/-", "178", "2", "179", "3", "180", "'", "181", " ", "182", " ", "183", " ", "184", ",", "185", "1", "186", " ", "187", ">", "188", "1/4", "189", "1/2", "190", "3/4", "191", "?", "192", "A", "193", "A", "194", "A",
+				"195", "A", "196", "Ae", "197", "A", "198", "AE", "199", "C", "200", "E", "201", "E", "202", "E", "203", "E", "204", "I", "205", "I", "206", "I", "207", "I", "208", "D", "209", "N", "210", "O", "211", "O", "212", "O", "213", "O", "214",
+				"Oe", "215", "x", "216", "O", "217", "U", "218", "U", "219", "U", "220", "Ue", "221", "Y", "222", " ", "223", "ss", "224", "a", "225", "a", "226", "a", "227", "a", "228", "ae", "229", "a", "230", "ae", "231", "c", "232", "e", "233", "e",
+				"234", "e", "235", "e", "236", "i", "237", "i", "238", "i", "239", "i", "240", "o", "241", "n", "242", "o", "243", "o", "244", "o", "245", "o", "246", "oe", "247", "/", "248", "o", "249", "u", "250", "u", "251", "u", "252", "ue", "253",
+				"y", "254", "p", "255", "y" };
 		for (int i = 0; i < mappingArray.length; i = i + 2) {
-			iso2simpleMappings.put( Integer.valueOf( mappingArray[i]), mappingArray[i+1]);
+			iso2simpleMappings.put(Integer.valueOf(mappingArray[i]), mappingArray[i + 1]);
 		}
 	}
 
-	
-	protected static String char2simpleChar( char c )
-    {
-        if ( c < 127 ) {
-            // leave alone as equivalent string.
-            return null;
-        } else {
-            String s=(String) iso2simpleMappings.get( new Integer(c));
-            if (s==null) // not in table, replace with empty string just to be sure
-            	return "";
-            else
-            	return s;
-        }
-    } // end charToEntity
-	
-    public static String simplifyString( String text ) {
-        if ( text == null ) return null;
-        int originalTextLength = text.length();
-        StringBuffer sb = new StringBuffer( 50 );
-        int charsToAppend = 0;
-        for ( int i = 0; i < originalTextLength; i++ ) {
-            char c = text.charAt( i );
-            String entity = char2simpleChar( c );
-            if ( entity == null ) {
-                // we could sb.append( c ), but that would be slower
-                // than saving them up for a big append.
-                charsToAppend++;
-            } else {
-                if ( charsToAppend != 0 ) {
-                    sb.append( text.substring( i - charsToAppend, i ) );
-                    charsToAppend = 0;
-                }
-                sb.append( entity );
-            }
-        } // end for
-        // append chars to the right of the last entity.
-        if ( charsToAppend != 0 ) {
-            sb.append( text.substring( originalTextLength - charsToAppend,
-                                       originalTextLength ) );
-        }
-        // if result is not longer, we did not do anything. Save RAM.
-        return ( sb.length() == originalTextLength ) ? text : sb.toString();
-    } // end insertEntities
+	protected static String char2simpleChar(char c) {
+		if (c < 127) {
+			// leave alone as equivalent string.
+			return null;
+		} else {
+			String s = (String) iso2simpleMappings.get(new Integer(c));
+			if (s == null) // not in table, replace with empty string just to be sure
+				return "";
+			else
+				return s;
+		}
+	} // end charToEntity
 
-    public static String getShortDetails( CacheHolder ch ) {
-    	StringBuffer strBuf = new StringBuffer(7);
-    	strBuf.append(CacheType.getExportShortId(ch.getType()).toLowerCase());			
-    	if (!ch.isAddiWpt()) {
-   			strBuf.append(ch.getHard());
-   			strBuf.append("/");
-   			strBuf.append(ch.getTerrain());
-    		strBuf.append(CacheSize.getExportShortId(ch.getCacheSize()));
-    	}
+	public static String simplifyString(String text) {
+		if (text == null)
+			return null;
+		int originalTextLength = text.length();
+		StringBuffer sb = new StringBuffer(50);
+		int charsToAppend = 0;
+		for (int i = 0; i < originalTextLength; i++) {
+			char c = text.charAt(i);
+			String entity = char2simpleChar(c);
+			if (entity == null) {
+				// we could sb.append( c ), but that would be slower
+				// than saving them up for a big append.
+				charsToAppend++;
+			} else {
+				if (charsToAppend != 0) {
+					sb.append(text.substring(i - charsToAppend, i));
+					charsToAppend = 0;
+				}
+				sb.append(entity);
+			}
+		} // end for
+			// append chars to the right of the last entity.
+		if (charsToAppend != 0) {
+			sb.append(text.substring(originalTextLength - charsToAppend, originalTextLength));
+		}
+		// if result is not longer, we did not do anything. Save RAM.
+		return (sb.length() == originalTextLength) ? text : sb.toString();
+	} // end insertEntities
 
-    	return strBuf.toString();
-    }
+	public static String getShortDetails(CacheHolder ch) {
+		StringBuffer strBuf = new StringBuffer(7);
+		strBuf.append(CacheType.getExportShortId(ch.getType()).toLowerCase());
+		if (!ch.isAddiWpt()) {
+			strBuf.append(ch.getHard());
+			strBuf.append("/");
+			strBuf.append(ch.getTerrain());
+			strBuf.append(CacheSize.getExportShortId(ch.getCacheSize()));
+		}
 
+		return strBuf.toString();
+	}
+
 }

Modified: trunk/src/CacheWolf/exp/GpxExportNg.java
===================================================================
--- trunk/src/CacheWolf/exp/GpxExportNg.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/exp/GpxExportNg.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -528,7 +528,7 @@
 		if ((STYLE_GPX_MYFINDS == exportStyle) && (ch.isCustomWpt() || ch.isAddiWpt() || !ch.is_found()))
 			return "";
 
-		if (!ch.pos.isValid()) {
+		if (!ch.getPos().isValid()) {
 			Global.getPref().log("[GPX Export:formatCache] " + ch.getWayPoint() + " has invalid coords.");
 			return "";
 		}
@@ -569,7 +569,7 @@
 
 		// .append("\t\t<desc>@@WPDESC@@</desc>").append(newLine)
 
-		ret.append("  <wpt lat=\"" + ch.pos.getLatDeg(CWPoint.DD) + "\" lon=\"" + ch.pos.getLonDeg(CWPoint.DD) + "\">").append(newLine);
+		ret.append("  <wpt lat=\"" + ch.getPos().getLatDeg(CWPoint.DD) + "\" lon=\"" + ch.getPos().getLonDeg(CWPoint.DD) + "\">").append(newLine);
 
 		if (exportStyle != STYLE_GPX_COMPACT) {
 			if (ch.isAddiWpt()) {
@@ -841,12 +841,12 @@
 		}
 		return trans.replaceFirst(GPXHEADER);
 		/*
-		String ret = STRreplace.replace(GPXHEADER,"@@CREATEDATE@@", new Date().setToCurrentTime().setFormat("yyyy-MM-dd").toString());
-		if (exportStyle==STYLE_GPX_MYFINDS)
-			 { ret=STRreplace.replace(ret,"@@NAME@@","My Finds Pocket Query");}
-		else { ret=STRreplace.replace(ret,"@@NAME@@","Waypoints for Cache Listings, Generated by CacheWolf");}
-		return ret;
-		*/
+		 * String ret = STRreplace.replace(GPXHEADER,"@@CREATEDATE@@", new Date().setToCurrentTime().setFormat("yyyy-MM-dd").toString());
+		 * if (exportStyle==STYLE_GPX_MYFINDS)
+		 * { ret=STRreplace.replace(ret,"@@NAME@@","My Finds Pocket Query");}
+		 * else { ret=STRreplace.replace(ret,"@@NAME@@","Waypoints for Cache Listings, Generated by CacheWolf");}
+		 * return ret;
+		 */
 	}
 
 	/**
@@ -884,7 +884,7 @@
 					trans.add(new Regex("@@ADDIID@@", addi.getWayPoint()));
 					trans.add(new Regex("@@ADDISHORT@@", addi.getCacheName()));
 					trans.add(new Regex("@@ADDIDELIM@@", delim));
-					trans.add(new Regex("@@ADDILAT@@", formatAddiLatLon(addi.pos)));
+					trans.add(new Regex("@@ADDILAT@@", formatAddiLatLon(addi.getPos())));
 					trans.add(new Regex("@@ADDILON@@", ""));
 					trans.add(new Regex("@@ADDILONG@@", addi.getCacheDetails(true).LongDescription));
 					ret.append(trans.replaceAll(GPXADDIINMAIN));
@@ -911,8 +911,7 @@
 	}
 
 	/**
-	 * copy the bitmap identified by <code>prefix</code> and <code>type</code> from <code>poiZip</code> to
-	 * <code>outdir</code>
+	 * copy the bitmap identified by <code>prefix</code> and <code>type</code> from <code>poiZip</code> to <code>outdir</code>
 	 * 
 	 * @param outdir
 	 * @param type

Modified: trunk/src/CacheWolf/exp/KMLExporter.java
===================================================================
--- trunk/src/CacheWolf/exp/KMLExporter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/exp/KMLExporter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -134,8 +134,8 @@
 						h.progress = (float) expCount / (float) counter;
 						h.changed();
 
-						if (ch.pos.isValid()) {
-							str = record(ch, ch.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), ch.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+						if (ch.getPos().isValid()) {
+							str = record(ch, ch.getPos().getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), ch.getPos().getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
 							if (str != null)
 								outp.print(str);
 						}
@@ -144,12 +144,12 @@
 							for (int j = 0; j < ch.addiWpts.size(); j++) {
 								addiWpt = (CacheHolder) ch.addiWpts.get(j);
 								expCount++;
-								if (ch.pos.isValid() && addiWpt.isVisible()) {
+								if (ch.getPos().isValid() && addiWpt.isVisible()) {
 									if (!createdAdditionalWaypointsFolder) {
 										outp.print(startFolder("Additional Waypoints", false));
 										createdAdditionalWaypointsFolder = true;
 									}
-									str = record(addiWpt, addiWpt.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), addiWpt.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+									str = record(addiWpt, addiWpt.getPos().getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), addiWpt.getPos().getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
 									if (str != null)
 										outp.print(str);
 								}

Modified: trunk/src/CacheWolf/exp/LocExporter.java
===================================================================
--- trunk/src/CacheWolf/exp/LocExporter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/exp/LocExporter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,102 +1,106 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
+
 import CacheWolf.CWPoint;
 import CacheWolf.CacheHolder;
 import CacheWolf.CacheHolderDetail;
 import CacheWolf.Common;
 import CacheWolf.Global;
 
-
 /**
-*	Class to export the cache database into an geocaching .loc file that may be exported
-*	by GPSBabel to a Garmin GPS.
-*
-*	Now includes mapping of cachetypes to user defined icons (as defined in file garminmap.xml).
-*/
-public class LocExporter extends Exporter{
+ * Class to export the cache database into an geocaching .loc file that may be exported
+ * by GPSBabel to a Garmin GPS.
+ * 
+ * Now includes mapping of cachetypes to user defined icons (as defined in file garminmap.xml).
+ */
+public class LocExporter extends Exporter {
 	public static int MODE_AUTO = TMP_FILE;
 	/**
 	 * Defines how certain cachetypes are mapped to user icons
 	 */
-	private static GarminMap gm=null;
+	private static GarminMap gm = null;
 
-	public LocExporter(){
+	public LocExporter() {
 		super();
 		this.setMask("*.loc");
 		this.setHowManyParams(NO_PARAMS);
 		if (Global.getPref().addDetailsToName) {
 			this.setNeedCacheDetails(true);
 		}
-		gm=new GarminMap();
+		gm = new GarminMap();
 	}
 
-	public String header () {
+	public String header() {
 		return "<?xml version=\"1.0\"?><loc version=\"1.0\" src=\"EasyGPS\">\r\n";
 	}
 
-	public String record(CacheHolder ch){
+	public String record(CacheHolder ch) {
 
 		// filter out not valid coords
-		if (!ch.pos.isValid()) return null;
+		if (!ch.getPos().isValid())
+			return null;
 		StringBuffer strBuf = new StringBuffer(200);
 		strBuf.append("<waypoint>\r\n   <name id=\"");
-		String wptName=simplifyString(ch.getWayPoint());
+		String wptName = simplifyString(ch.getWayPoint());
 		if (Global.getPref().addDetailsToWaypoint) {
-			wptName += getShortDetails( ch );
+			wptName += getShortDetails(ch);
 		}
-		if (Global.getPref().garminMaxLen==0)
+		if (Global.getPref().garminMaxLen == 0)
 			strBuf.append(wptName);
 		else {
 			try {
-				strBuf.append(wptName.substring(wptName.length()-Global.getPref().garminMaxLen));
-			} catch (Exception ex){ pref.log("[LocExporter:record]Invalid value for garmin.MaxWaypointLength",ex); }
+				strBuf.append(wptName.substring(wptName.length() - Global.getPref().garminMaxLen));
+			} catch (Exception ex) {
+				pref.log("[LocExporter:record]Invalid value for garmin.MaxWaypointLength", ex);
+			}
 		}
 		strBuf.append("\"><![CDATA[");
 		strBuf.append(simplifyString(ch.getCacheName()));
 		if (Global.getPref().addDetailsToName) {
-			if ( !Global.getPref().addDetailsToWaypoint ) {
-				strBuf.append( getShortDetails( ch ) );
+			if (!Global.getPref().addDetailsToWaypoint) {
+				strBuf.append(getShortDetails(ch));
 			}
 			CacheHolderDetail det = ch.getCacheDetails(true);
-			if ( (!det.Hints.equals("null")) && (det.Hints.length() > 0) ) {
+			if ((!det.Hints.equals("null")) && (det.Hints.length() > 0)) {
 				strBuf.append(":");
-				strBuf.append( simplifyString(Common.rot13(det.Hints)) );
+				strBuf.append(simplifyString(Common.rot13(det.Hints)));
 			}
 		}
 		strBuf.append("]]></name>\r\n   <coord lat=\"");
-		strBuf.append(ch.pos.getLatDeg(CWPoint.DD));
+		strBuf.append(ch.getPos().getLatDeg(CWPoint.DD));
 		strBuf.append("\" lon=\"");
-		strBuf.append(ch.pos.getLonDeg(CWPoint.DD));
+		strBuf.append(ch.getPos().getLonDeg(CWPoint.DD));
 		strBuf.append("\"/>\r\n   <type>");
 		strBuf.append(gm.getIcon(ch));
 		strBuf.append("</type>\r\n</waypoint>\r\n");
 		return strBuf.toString();
 	}
-	public String trailer(){
+
+	public String trailer() {
 		return "</loc>\r\n";
 	}
 }

Modified: trunk/src/CacheWolf/exp/TPLExporter.java
===================================================================
--- trunk/src/CacheWolf/exp/TPLExporter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/exp/TPLExporter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -249,7 +249,7 @@
 				imgExpName = expName;
 			for (int i = 0; i < counter; i++) {
 				CacheHolder ch = cacheDB.get(i);
-				if (ch.isVisible() && (ch.pos.isValid() || myFilter.formatModifier > 0)) {
+				if (ch.isVisible() && (ch.getPos().isValid() || myFilter.formatModifier > 0)) {
 					boolean get = true;
 					if (myFilter.getAddiWp) {
 						get = ch.isAddiWpt();

Modified: trunk/src/CacheWolf/exp/TomTomExporter.java
===================================================================
--- trunk/src/CacheWolf/exp/TomTomExporter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/exp/TomTomExporter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CWPoint;
@@ -60,46 +60,51 @@
 	CacheDB cacheDB;
 	Preferences pref;
 	Profile profile;
-	
+
 	public TomTomExporter() {
 		profile = Global.getProfile();
 		pref = Global.getPref();
 		cacheDB = profile.cacheDB;
 	}
-	
-	public void doIt(){
+
+	public void doIt() {
 		String fileName, dirName, prefix;
 		int fileFormat;
 
 		TomTomExporterScreen infoScreen = new TomTomExporterScreen("TomTomExport");
-		if (infoScreen.execute() == FormBase.IDCANCEL) return;
+		if (infoScreen.execute() == FormBase.IDCANCEL)
+			return;
 		fileFormat = infoScreen.getFormat();
 
 		dirName = pref.getExportPath(expName);
-		
-		if (infoScreen.oneFilePerType()){
+
+		if (infoScreen.oneFilePerType()) {
 			FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, dirName);
 			fc.setTitle("Select target dir:");
-			if(fc.execute() == FormBase.IDCANCEL) return;
+			if (fc.execute() == FormBase.IDCANCEL)
+				return;
 			dirName = fc.getChosen();
 			pref.setExportPath(expName, dirName);
 			prefix = infoScreen.getPrefix();
 			writeOneFilePerType(fileFormat, dirName, prefix);
-		} else{
+		} else {
 			FileChooser fc = new FileChooser(FileChooserBase.SAVE, dirName);
 			fc.setTitle("Select target file:");
-	
-			if (fileFormat == TT_ASC) fc.addMask("*.asc");
-			else fc.addMask("*.ov2");
-			
-			if(fc.execute() == FormBase.IDCANCEL) return;
+
+			if (fileFormat == TT_ASC)
+				fc.addMask("*.asc");
+			else
+				fc.addMask("*.ov2");
+
+			if (fc.execute() == FormBase.IDCANCEL)
+				return;
 			fileName = fc.getChosen();
 			pref.setExportPathFromFileName(expName, fileName);
 			writeSingleFile(fileFormat, fileName);
 		}
 	}
-	
-	public void writeOneFilePerType(int format, String dirName, String prefix){
+
+	public void writeOneFilePerType(int format, String dirName, String prefix) {
 		RandomAccessFile out = null;
 		File dfile;
 		String ext, fileName = null;
@@ -108,63 +113,64 @@
 		ProgressBarForm progressForm = new ProgressBarForm();
 		Handle h = new Handle();
 		int currExp, counter;
-		
+
 		progressForm.showMainTask = false;
-		progressForm.setTask(h,"Exporting ...");
+		progressForm.setTask(h, "Exporting ...");
 		progressForm.exec();
-		
+
 		currExp = 0;
 		counter = cacheDB.countVisible();
-		
-		ext = format==TT_ASC?".asc":".ov2";
 
-		try{
-			//loop through type
-			for(int j = 0; j < CacheType.guiTypeStrings().length; j++){
+		ext = format == TT_ASC ? ".asc" : ".ov2";
+
+		try {
+			// loop through type
+			for (int j = 0; j < CacheType.guiTypeStrings().length; j++) {
 				/*
-				String typeName = CacheType.guiTypeStrings()[j];
-				if (typeName.startsWith("Addi: ")) {
-					typeName = typeName.substring(6);
-				}
-				*/
+				 * String typeName = CacheType.guiTypeStrings()[j];
+				 * if (typeName.startsWith("Addi: ")) {
+				 * typeName = typeName.substring(6);
+				 * }
+				 */
 				String typeName = CacheType.typeImageForId(CacheType.guiSelect2Cw(j));
-				typeName=typeName.substring(0, typeName.length()-4);		
-				
+				typeName = typeName.substring(0, typeName.length() - 4);
+
 				fileName = dirName + "/" + prefix + typeName + ext;
 				dfile = new File(fileName);
 				dfile.delete();
-				out =  new RandomAccessFile(fileName,"rw");
-				for(int i = 0; i<cacheDB.size(); i++){
-					holder=cacheDB.get(i);
+				out = new RandomAccessFile(fileName, "rw");
+				for (int i = 0; i < cacheDB.size(); i++) {
+					holder = cacheDB.get(i);
 
-					if(holder.getType() == CacheType.guiSelect2Cw(j) && holder.isVisible()){
+					if (holder.getType() == CacheType.guiSelect2Cw(j) && holder.isVisible()) {
 						currExp++;
-						h.progress = (float)currExp/(float)counter;
+						h.progress = (float) currExp / (float) counter;
 						h.changed();
-						if (holder.pos.isValid() == false) continue;
-						if (format == TT_ASC){
-							writeRecordASCII(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
+						if (holder.getPos().isValid() == false)
+							continue;
+						if (format == TT_ASC) {
+							writeRecordASCII(out, holder, holder.getPos().getLatDeg(CWPoint.DD), holder.getPos().getLonDeg(CWPoint.DD));
 						} else {
-							writeRecordBinary(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
+							writeRecordBinary(out, holder, holder.getPos().getLatDeg(CWPoint.DD), holder.getPos().getLonDeg(CWPoint.DD));
 						}
-					}//if
-				}//for cacheDB
+					}// if
+				}// for cacheDB
 				out.close();
 				// check for empty files and delete them
 				dfile = new File(fileName);
-				if (dfile.length()==0) {
+				if (dfile.length() == 0) {
 					dfile.delete();
 				} else {
-					copyIcon(j, dirName + "/" + prefix,typeName); 
+					copyIcon(j, dirName + "/" + prefix, typeName);
 				}
-			}//for wayType
+			}// for wayType
 			progressForm.exit(0);
-		} catch (IOException e){
-			pref.log("Problem creating file! " + fileName,e,true);
-		}//try
+		} catch (IOException e) {
+			pref.log("Problem creating file! " + fileName, e, true);
+		}// try
 	}
-	
-	public void writeSingleFile(int format, String fileName){
+
+	public void writeSingleFile(int format, String fileName) {
 		RandomAccessFile out = null;
 		File dfile;
 
@@ -173,53 +179,53 @@
 		Handle h = new Handle();
 
 		pbf.showMainTask = false;
-		pbf.setTask(h,"Exporting ...");
+		pbf.setTask(h, "Exporting ...");
 		pbf.exec();
 
 		int counter = cacheDB.countVisible();
 		int expCount = 0;
 
-		try{
+		try {
 			dfile = new File(fileName);
 			dfile.delete();
-			out =  new RandomAccessFile(fileName,"rw");
-			for(int i = 0; i<cacheDB.size(); i++){
-				holder=cacheDB.get(i);
-				if(holder.isVisible()){
+			out = new RandomAccessFile(fileName, "rw");
+			for (int i = 0; i < cacheDB.size(); i++) {
+				holder = cacheDB.get(i);
+				if (holder.isVisible()) {
 					expCount++;
-					h.progress = (float)expCount/(float)counter;
+					h.progress = (float) expCount / (float) counter;
 					h.changed();
-					if (holder.pos.isValid() == false) continue;
-					if (format == TT_ASC){
-						writeRecordASCII(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
+					if (holder.getPos().isValid() == false)
+						continue;
+					if (format == TT_ASC) {
+						writeRecordASCII(out, holder, holder.getPos().getLatDeg(CWPoint.DD), holder.getPos().getLonDeg(CWPoint.DD));
 					} else {
-						writeRecordBinary(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
+						writeRecordBinary(out, holder, holder.getPos().getLatDeg(CWPoint.DD), holder.getPos().getLonDeg(CWPoint.DD));
 					}
-				}//if
-			}//for
+				}// if
+			}// for
 			out.close();
-			copyIcon(0, fileName.substring(0,fileName.indexOf(".")),"");
+			copyIcon(0, fileName.substring(0, fileName.indexOf(".")), "");
 			pbf.exit(0);
-		}catch (Exception e){
-			pref.log("Problem writing to file! " + fileName,e,true);
-		}//try
+		} catch (Exception e) {
+			pref.log("Problem writing to file! " + fileName, e, true);
+		}// try
 	}
-	
-	
-	public void writeRecordASCII(RandomAccessFile outp, CacheHolder ch, String lat, String lon){
+
+	public void writeRecordASCII(RandomAccessFile outp, CacheHolder ch, String lat, String lon) {
 		try {
 			outp.writeBytes(lon);
 			outp.writeBytes(",");
 			outp.writeBytes(lat);
 			outp.writeBytes(",");
-			//outp.writeBytes("\"" + ch.CacheName.replace(',',' ') + "\"\r\n");
+			// outp.writeBytes("\"" + ch.CacheName.replace(',',' ') + "\"\r\n");
 			outp.writeBytes("\"");
 			outp.writeBytes(ch.getWayPoint());
 			outp.writeBytes(" - ");
-			outp.writeBytes(ch.getCacheName().replace(',',' '));
+			outp.writeBytes(ch.getCacheName().replace(',', ' '));
 			outp.writeBytes(" by ");
 			outp.writeBytes(ch.getCacheOwner());
-			outp.writeBytes("- ");             
+			outp.writeBytes("- ");
 			outp.writeBytes(String.valueOf(ch.getHard()));
 			outp.writeBytes("/");
 			outp.writeBytes(String.valueOf(ch.getTerrain()));
@@ -227,52 +233,53 @@
 			outp.writeBytes(CacheSize.cw2ExportString(ch.getCacheSize()));
 			outp.writeBytes("\"\r\n");
 		} catch (IOException e) {
-			pref.log("Error writing to file",e,true);
+			pref.log("Error writing to file", e, true);
 		}
 		return;
 	}
 
-	public void writeRecordBinary(RandomAccessFile outp, CacheHolder ch, String lat, String lon){
-		int d,data;
+	public void writeRecordBinary(RandomAccessFile outp, CacheHolder ch, String lat, String lon) {
+		int d, data;
 		double latlon;
-		
+
 		try {
 			d = 2;
-			outp.writeByte((byte)d);
-			data = ch.getWayPoint().length()+ch.getCacheName().length()+ch.getCacheOwner().length()+String.valueOf(ch.getHard()).length()+String.valueOf(ch.getTerrain()).length()+CacheSize.cw2ExportString(ch.getCacheSize()).length()+27;
+			outp.writeByte((byte) d);
+			data = ch.getWayPoint().length() + ch.getCacheName().length() + ch.getCacheOwner().length() + String.valueOf(ch.getHard()).length() + String.valueOf(ch.getTerrain()).length() + CacheSize.cw2ExportString(ch.getCacheSize()).length() + 27;
 			writeIntBinary(outp, data);
 			latlon = Common.parseDouble(lon);
-			latlon *=100000;
+			latlon *= 100000;
 			writeIntBinary(outp, (int) latlon);
-			latlon = Common.parseDouble(lat);;
-			latlon *=100000;
+			latlon = Common.parseDouble(lat);
+			;
+			latlon *= 100000;
 			writeIntBinary(outp, (int) latlon);
 			outp.writeBytes(ch.getWayPoint());
 			outp.writeBytes(" - ");
 			outp.writeBytes(ch.getCacheName());
 			outp.writeBytes(" by ");
 			outp.writeBytes(ch.getCacheOwner());
-			//Wenn Leerzeichen am Ende von Cache.Owner entfernt: 
-			//Hier wieder einf?gen
-			//und data = holder.wayPoint.length()+holder.CacheName.length()+.....
-			//wider um 1 erh?hen
-			outp.writeBytes("- ");             
+			// Wenn Leerzeichen am Ende von Cache.Owner entfernt:
+			// Hier wieder einf?gen
+			// und data = holder.wayPoint.length()+holder.CacheName.length()+.....
+			// wider um 1 erh?hen
+			outp.writeBytes("- ");
 			outp.writeBytes(String.valueOf(ch.getHard()));
 			outp.writeBytes("/");
 			outp.writeBytes(String.valueOf(ch.getTerrain()));
 			outp.writeBytes(" - ");
 			outp.writeBytes(CacheSize.cw2ExportString(ch.getCacheSize()));
 			d = 0;
-			outp.writeByte((byte)d);
+			outp.writeByte((byte) d);
 		} catch (IOException e) {
-			pref.log("Error writing to file",e,true);
+			pref.log("Error writing to file", e, true);
 		}
 
 		return;
 	}
 
-	public void writeIntBinary(RandomAccessFile outp, int data){
-		
+	public void writeIntBinary(RandomAccessFile outp, int data) {
+
 		ByteArray buf = new ByteArray();
 		buf.appendInt(data);
 		try {
@@ -281,42 +288,44 @@
 			outp.writeByte(buf.data[1]);
 			outp.writeByte(buf.data[0]);
 		} catch (IOException e) {
-			pref.log("Error writing to file",e,true);
+			pref.log("Error writing to file", e, true);
 		}
 
 		return;
 	}
-	
-	public void copyIcon(int intWayType, String prefix, String typeName){
-		ZipFile zif=null;
+
+	public void copyIcon(int intWayType, String prefix, String typeName) {
+		ZipFile zif = null;
 		try {
-			zif = new ZipFile (FileBase.getProgramDirectory() + FileBase.separator+"exporticons"+FileBase.separator+"TomTom.zip");
-		} catch (IOException e) {}
+			zif = new ZipFile(FileBase.getProgramDirectory() + FileBase.separator + "exporticons" + FileBase.separator + "TomTom.zip");
+		} catch (IOException e) {
+		}
 		try {
 			if (zif == null) {
-				zif = new ZipFile (FileBase.getProgramDirectory() + FileBase.separator+"exporticons"+ FileBase.separator+"exporticons"+FileBase.separator+"TomTom.zip");
+				zif = new ZipFile(FileBase.getProgramDirectory() + FileBase.separator + "exporticons" + FileBase.separator + "exporticons" + FileBase.separator + "TomTom.zip");
 			}
 			ZipEntry zipEnt;
 			int len;
-			String entName; 
-			
+			String entName;
+
 			entName = "GC-" + typeName + ".bmp";
 			zipEnt = zif.getEntry(entName);
-			if (zipEnt == null) return;
-			
-		    byte[] buff = new byte[ zipEnt.getSize() ];
-		    InputStream  fis = zif.getInputStream(zipEnt);
-		    FileOutputStream fos = new FileOutputStream( prefix + typeName + ".bmp");
-		    while( 0 < (len = fis.read( buff )) )
-		      fos.write( buff, 0, len );
-		    fos.flush();
-		    fos.close();
-		    fis.close();
+			if (zipEnt == null)
+				return;
+
+			byte[] buff = new byte[zipEnt.getSize()];
+			InputStream fis = zif.getInputStream(zipEnt);
+			FileOutputStream fos = new FileOutputStream(prefix + typeName + ".bmp");
+			while (0 < (len = fis.read(buff)))
+				fos.write(buff, 0, len);
+			fos.flush();
+			fos.close();
+			fis.close();
 		} catch (ZipException e) {
-			pref.log("Problem copying Icon " + "GC-" + typeName + ".bmp" ,e,true);
+			pref.log("Problem copying Icon " + "GC-" + typeName + ".bmp", e, true);
 		} catch (IOException e) {
-			pref.log("Problem copying Icon " + "GC-" + typeName + ".bmp" ,e,true);
+			pref.log("Problem copying Icon " + "GC-" + typeName + ".bmp", e, true);
 		}
 	}
-	
+
 }

Modified: trunk/src/CacheWolf/imp/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/imp/GPXImporter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/imp/GPXImporter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -46,6 +46,7 @@
 import CacheWolf.Travelbug;
 import CacheWolf.UrlFetcher;
 import CacheWolf.imp.SpiderGC.SpiderProperties;
+import CacheWolf.navi.TrackPoint;
 import CacheWolf.utils.FileBugfix;
 
 import com.stevesoft.ewe_pat.Regex;
@@ -191,7 +192,7 @@
 			if (holder.getWayPoint().length() > 0) {
 				pref.log("[GPXImporter:DoIt] " + holder.getWayPoint() + " LogID=" + logId, e, true);
 			} else {
-				pref.log("[GPXImporter:DoIt] " + holder.getLatLon() + " LogID=" + logId, e, true);
+				pref.log("[GPXImporter:DoIt] " + holder.getPos().toString() + " LogID=" + logId, e, true);
 			}
 			infB.close(0);
 			Vm.showWait(false);
@@ -223,8 +224,7 @@
 		}
 		if (name.equals("wpt")) {
 			holder = new CacheHolder();
-			holder.pos.set(Common.parseDouble(atts.getValue("lat")), Common.parseDouble(atts.getValue("lon")));
-			holder.setLatLon(holder.pos.toString());
+			holder.setPos(new TrackPoint(Common.parseDouble(atts.getValue("lat")), Common.parseDouble(atts.getValue("lon"))));
 			inWpt = true;
 			inLogs = false;
 			inBug = false;
@@ -364,8 +364,6 @@
 				// if waypoint starts with "GC"
 				if (doSpider) {
 					if (spiderOK && holder.is_archived() == false) {
-						if (holder.getLatLon().length() > 1) {
-						}
 						// spiderImages();
 						spiderImagesUsingSpider();
 						// Rename image sources

Modified: trunk/src/CacheWolf/imp/LOCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/imp/LOCXMLImporter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/imp/LOCXMLImporter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,31 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.imp;
 
-
 import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
 import CacheWolf.CacheSize;
@@ -34,6 +33,7 @@
 import CacheWolf.Common;
 import CacheWolf.Preferences;
 import CacheWolf.Profile;
+import CacheWolf.navi.TrackPoint;
 import ewe.io.FileReader;
 import ewe.io.Reader;
 import ewe.sys.Vm;
@@ -80,7 +80,7 @@
 	public void startElement(String name, AttributeList atts) {
 		if (debugXML) {
 			for (int i = 0; i < atts.getLength(); i++) {
-				pref.log(" Name: " + atts.getName(i) + " Value: " + atts.getValue(i),null);
+				pref.log(" Name: " + atts.getName(i) + " Value: " + atts.getValue(i), null);
 			}
 		}
 		strData = "";
@@ -89,8 +89,7 @@
 			return;
 		}
 		if (name.equals("coord")) {
-			holder.pos.set(Common.parseDouble(atts.getValue("lat")), Common.parseDouble(atts.getValue("lon")));
-			holder.setLatLon(holder.pos.toString());
+			holder.setPos(new TrackPoint(Common.parseDouble(atts.getValue("lat")), Common.parseDouble(atts.getValue("lon"))));
 			return;
 		}
 	}
@@ -127,7 +126,7 @@
 		String chars = new String(ch, start, length);
 		strData += chars;
 		if (debugXML)
-			pref.log(strData,null);
+			pref.log(strData, null);
 	}
 
 	private CacheHolder getHolder(String wpt) {

Modified: trunk/src/CacheWolf/imp/OCLinkImporter.java
===================================================================
--- trunk/src/CacheWolf/imp/OCLinkImporter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/imp/OCLinkImporter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -100,8 +100,8 @@
 				else {
 					// check over coordinates
 					// getting a cache next to the coordinates
-					String nLat = ch.pos.getLatDeg(CWPoint.DD);
-					String nLon = ch.pos.getLonDeg(CWPoint.DD);
+					String nLat = ch.getPos().getLatDeg(CWPoint.DD);
+					String nLon = ch.getPos().getLonDeg(CWPoint.DD);
 					url = baseurl + "mode=locate&lat=" + nLat + "&lon=" + nLon;
 					result = SafeXML.cleanback(UrlFetcher.fetch(url));
 					String ocCacheName = new Extractor(result, "name=\"", "\"", 0, true).findNext();
@@ -113,7 +113,7 @@
 						int latend = result.indexOf("\"", lonend);
 						double lon = Common.parseDouble(result.substring(start, lonend));
 						double lat = Common.parseDouble(result.substring(lonend + 1, latend));
-						boolean sameCoord = lon == ch.pos.lonDec && lat == ch.pos.latDec;
+						boolean sameCoord = lon == ch.getPos().lonDec && lat == ch.getPos().latDec;
 						if (sameCoord) {
 							start = result.indexOf("username=\"") + 10;
 							int end = result.indexOf("\"", start);

Modified: trunk/src/CacheWolf/imp/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/imp/OCXMLImporter.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/imp/OCXMLImporter.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.imp;
 
 import CacheWolf.CWPoint;
@@ -41,6 +41,7 @@
 import CacheWolf.Profile;
 import CacheWolf.SafeXML;
 import CacheWolf.UrlFetcher;
+import CacheWolf.navi.TrackPoint;
 import CacheWolf.navi.TransformCoordinates;
 import CacheWolf.utils.FileBugfix;
 
@@ -68,11 +69,11 @@
 import ewesoft.xml.sax.AttributeList;
 
 /**
- *	Class to import Data from opencaching.
- *	It uses the lastmodified parameter to identify new or changed caches.
- *	See here: http://www.opencaching.com/phpBB2/viewtopic.php?t=281 (out-dated)
- *   See here: http://www.opencaching.de/doc/xml/xml11.htm and http://develforum.opencaching.de/viewtopic.php?t=135&postdays=0&postorder=asc&start=0
- *	for more information.
+ * Class to import Data from opencaching.
+ * It uses the lastmodified parameter to identify new or changed caches.
+ * See here: http://www.opencaching.com/phpBB2/viewtopic.php?t=281 (out-dated)
+ * See here: http://www.opencaching.de/doc/xml/xml11.htm and http://develforum.opencaching.de/viewtopic.php?t=135&postdays=0&postorder=asc&start=0
+ * for more information.
  */
 public class OCXMLImporter extends MinML {
 	static protected final int STAT_INIT = 0;
@@ -90,7 +91,7 @@
 	boolean debugGPX = false;
 	CacheDB cacheDB;
 	InfoBox inf;
-	//CacheHolder ch;
+	// CacheHolder ch;
 	CacheHolder holder;
 	Preferences pref;
 	Profile profile;
@@ -102,7 +103,7 @@
 	Hashtable DBindexID = new Hashtable();
 
 	String picUrl = "";
-	String picTitle =  "";
+	String picTitle = "";
 	String picID;
 	String cacheID;
 
@@ -118,29 +119,27 @@
 	boolean isHTML;
 	boolean isSyncSingle; // to load archieved
 
-	public OCXMLImporter(Preferences p,Profile prof)
-	{
+	public OCXMLImporter(Preferences p, Profile prof) {
 		pref = p;
-		profile=prof;
+		profile = prof;
 		cacheDB = profile.cacheDB;
-		incUpdate=true;
-		if(profile.getLast_sync_opencaching() == null ||
-				profile.getLast_sync_opencaching().length() < 12){
+		incUpdate = true;
+		if (profile.getLast_sync_opencaching() == null || profile.getLast_sync_opencaching().length() < 12) {
 			profile.setLast_sync_opencaching("20050801000000");
 			incUpdate = false;
 		}
 		user = p.myAlias.toLowerCase();
 		CacheHolder ch;
-		for(int i = 0; i<cacheDB.size();i++){
+		for (int i = 0; i < cacheDB.size(); i++) {
 			ch = cacheDB.get(i);
 			if (!ch.getOcCacheID().equals(""))
 				DBindexID.put(ch.getOcCacheID(), ch.getWayPoint());
-		}//for
+		}// for
 
 	}
 
 	/**
-	 *
+	 * 
 	 * @param number
 	 * @param infB
 	 * @return true, if some change was made to the cacheDB
@@ -149,89 +148,87 @@
 
 		CacheHolder ch;
 		ch = cacheDB.get(number);
-		hostname=OC.getOCHostName(ch.getWayPoint());
-		holder= null;
+		hostname = OC.getOCHostName(ch.getWayPoint());
+		holder = null;
 
 		if (infB.isClosed) {
 			// there could have been an update before
 			return true;
 		}
 
-		inf = new InfoBox("Opencaching download", MyLocale.getMsg(1608,"downloading data\n from " + hostname), InfoBox.PROGRESS_WITH_WARNINGS, false);
+		inf = new InfoBox("Opencaching download", MyLocale.getMsg(1608, "downloading data\n from " + hostname), InfoBox.PROGRESS_WITH_WARNINGS, false);
 		inf.setPreferredSize(220, 300);
 		inf.relayout(false);
 		inf.exec();
 
 		String lastS;
-		/** pref.downloadmissingOC = true, if not the last syncdate shall be used,
-		 *  but the caches shall be reloaded
-		 *  only used in syncSingle  */
+		/**
+		 * pref.downloadmissingOC = true, if not the last syncdate shall be used,
+		 * but the caches shall be reloaded
+		 * only used in syncSingle
+		 */
 		incUpdate = false;
-		if (pref.downloadAllOC)  lastS = "20050801000000";
+		if (pref.downloadAllOC)
+			lastS = "20050801000000";
 		else {
-			if (ch.getLastSync().length() < 14) lastS = "20050801000000";
-			else { lastS = ch.getLastSync(); incUpdate=true; }
+			if (ch.getLastSync().length() < 14)
+				lastS = "20050801000000";
+			else {
+				lastS = ch.getLastSync();
+				incUpdate = true;
+			}
 		}
 		dateOfthisSync = new Time();
 		dateOfthisSync.parse(lastS, "yyyyMMddHHmmss");
 
-
 		picCnt = 0;
-		//Build url
-		String url = "http://" + hostname + "/xml/ocxml11.php?"
-			+ "modifiedsince=" + lastS
-			+ "&cache=1"
-			+ "&cachedesc=1";
+		// Build url
+		String url = "http://" + hostname + "/xml/ocxml11.php?" + "modifiedsince=" + lastS + "&cache=1" + "&cachedesc=1";
 
-		if (pref.downloadPics) url += "&picture=1";
-		else url += "&picture=0";
-		url += "&cachelog=1"
-			+ "&removedobject=0"
-			+ "&wp=" + ch.getWayPoint()
-			+ "&charset=utf-8"
-			+ "&cdata=0"
-			+ "&session=0";
+		if (pref.downloadPics)
+			url += "&picture=1";
+		else
+			url += "&picture=0";
+		url += "&cachelog=1" + "&removedobject=0" + "&wp=" + ch.getWayPoint() + "&charset=utf-8" + "&cdata=0" + "&session=0";
 		ch.setUpdated(false);
-		isSyncSingle=true;
+		isSyncSingle = true;
 		syncOC(url);
 		inf.close(0);
 		return true;
 	}
 
-	public void doIt(){
-		boolean success=true;
+	public void doIt() {
+		boolean success = true;
 		String finalMessage;
 
-		String lastS =  profile.getLast_sync_opencaching();
+		String lastS = profile.getLast_sync_opencaching();
 		final CWPoint centre = pref.getCurCentrePt(); // No need to clone curCentrePt as centre is only read
 		if (!centre.isValid()) {
 			(new MessageBox("Error", "Coordinates for centre must be set", FormBase.OKB)).execute();
 			return;
 		}
-		final OCXMLImporterScreen importOpt = new OCXMLImporterScreen(
-				MyLocale.getMsg(130,"Download from opencaching"),
-				OCXMLImporterScreen.ALL |
-				OCXMLImporterScreen.DIST |
-				OCXMLImporterScreen.IMAGES|
-				OCXMLImporterScreen.INCLUDEFOUND|
-				OCXMLImporterScreen.HOST);
-		if (importOpt.execute() == FormBase.IDCANCEL) {	return; }
+		final OCXMLImporterScreen importOpt = new OCXMLImporterScreen(MyLocale.getMsg(130, "Download from opencaching"), OCXMLImporterScreen.ALL | OCXMLImporterScreen.DIST | OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.INCLUDEFOUND
+				| OCXMLImporterScreen.HOST);
+		if (importOpt.execute() == FormBase.IDCANCEL) {
+			return;
+		}
 		Vm.showWait(true);
 		String dist = importOpt.maxDistanceInput.getText();
 		incFinds = !importOpt.foundCheckBox.getState();
-		if (importOpt.domains.getSelectedItem()!=null) {
-			hostname = (String)importOpt.domains.getSelectedItem();
-			pref.lastOCSite=hostname;
+		if (importOpt.domains.getSelectedItem() != null) {
+			hostname = (String) importOpt.domains.getSelectedItem();
+			pref.lastOCSite = hostname;
 		}
 
-		if (dist.length()== 0) return;
+		if (dist.length() == 0)
+			return;
 
 		final Double distDouble = new Double();
 		distDouble.value = Common.parseDouble(dist);
 		dist = distDouble.toString(0, 1, 0).replace(',', '.');
-		//check, if distance is greater than before
+		// check, if distance is greater than before
 		incUpdate = true;
-		if (Convert.toInt(dist) > Convert.toInt(profile.getDistOC()) ||	pref.downloadAllOC  ){
+		if (Convert.toInt(dist) > Convert.toInt(profile.getDistOC()) || pref.downloadAllOC) {
 			// resysnc
 			lastS = "20050801000000";
 			incUpdate = false;
@@ -239,135 +236,130 @@
 		profile.setDistOC(dist);
 		// Clear status of caches in db
 		CacheHolder ch;
-		for(int i = cacheDB.size()-1; i>=0 ;i--){
+		for (int i = cacheDB.size() - 1; i >= 0; i--) {
 			ch = cacheDB.get(i);
 			ch.setUpdated(false);
 			ch.setNew(false);
 			ch.setLog_updated(false);
 		}
 		picCnt = 0;
-		//Build url
-		String url = "http://" + hostname + "/xml/ocxml11.php?"
-			+ "modifiedsince=" + lastS
-			+ "&cache=1"
-			+ "&cachedesc=1";
-		if (pref.downloadPics) url += "&picture=1";
-		else url += "&picture=0";
-		url += "&cachelog=1"
-			+ "&removedobject=0"
-			+ "&lat=" + centre.getLatDeg(TransformCoordinates.DD)
-			+ "&lon=" + centre.getLonDeg(TransformCoordinates.DD)
-			+ "&distance=" + dist
-			+ "&charset=utf-8"
-			+ "&cdata=0"
-			+ "&session=0";
-		inf = new InfoBox("Opencaching download", MyLocale.getMsg(1608,"downloading data\n from opencaching"), InfoBox.PROGRESS_WITH_WARNINGS, false);
+		// Build url
+		String url = "http://" + hostname + "/xml/ocxml11.php?" + "modifiedsince=" + lastS + "&cache=1" + "&cachedesc=1";
+		if (pref.downloadPics)
+			url += "&picture=1";
+		else
+			url += "&picture=0";
+		url += "&cachelog=1" + "&removedobject=0" + "&lat=" + centre.getLatDeg(TransformCoordinates.DD) + "&lon=" + centre.getLonDeg(TransformCoordinates.DD) + "&distance=" + dist + "&charset=utf-8" + "&cdata=0" + "&session=0";
+		inf = new InfoBox("Opencaching download", MyLocale.getMsg(1608, "downloading data\n from opencaching"), InfoBox.PROGRESS_WITH_WARNINGS, false);
 		inf.setPreferredSize(220, 300);
 		inf.relayout(false);
 		inf.exec();
 
-		isSyncSingle=false;
+		isSyncSingle = false;
 		success = syncOC(url);
-		profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+		profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 		Vm.showWait(false);
 		if (success) {
 			profile.setLast_sync_opencaching(dateOfthisSync.format("yyyyMMddHHmmss"));
-			//pref.savePreferences();
-			finalMessage = MyLocale.getMsg(1607,"Update from opencaching successful");
-			inf.addWarning("\nNumber of"+
-			"\n...caches new/updated: " + numCacheImported + " / " + numCacheUpdated +
-			"\n...cache descriptions new/updated: " + numDescImported +
-			"\n...logs new/updated: " + numLogImported);
+			// pref.savePreferences();
+			finalMessage = MyLocale.getMsg(1607, "Update from opencaching successful");
+			inf.addWarning("\nNumber of" + "\n...caches new/updated: " + numCacheImported + " / " + numCacheUpdated + "\n...cache descriptions new/updated: " + numDescImported + "\n...logs new/updated: " + numLogImported);
 			inf.setInfo(finalMessage);
 		}
 		inf.addOkButton();
 	}
 
 	private boolean syncOC(String address) {
-		boolean success=true;
+		boolean success = true;
 		File tmpFile = null;
 		BufferedReader r;
 
-		//inf = new InfoBox("Opencaching download", MyLocale.getMsg(1608,"downloading data\n from opencaching"), InfoBox.PROGRESS_WITH_WARNINGS, false);
+		// inf = new InfoBox("Opencaching download", MyLocale.getMsg(1608,"downloading data\n from opencaching"), InfoBox.PROGRESS_WITH_WARNINGS, false);
 
 		picCnt = 0;
 		String finalMessage = "";
-		try{
+		try {
 			holder = null;
 			final String target = profile.dataDir + "dummy.zip";
 			UrlFetcher.fetchDataFile(address, target);
 
-			//parse
+			// parse
 			tmpFile = new FileBugfix(target);
-			if (tmpFile.getLength() == 0 ) {
+			if (tmpFile.getLength() == 0) {
 				throw new IOException("no updates available");
 			}
 
-			final ZipFile zif = new ZipFile (target);
+			final ZipFile zif = new ZipFile(target);
 			ZipEntry zipEnt;
 			final Enumeration zipEnum = zif.entries();
 			inf.setInfo("...unzipping update file");
-			while (zipEnum.hasMoreElements())
-			{
+			while (zipEnum.hasMoreElements()) {
 				zipEnt = (ZipEntry) zipEnum.nextElement();
 				// skip over PRC-files and empty files
-				if (zipEnt.getSize()> 0 && zipEnt.getName().endsWith("xml")){
-					r = new BufferedReader (new InputStreamReader(zif.getInputStream(zipEnt), IO.JAVA_UTF8_CODEC));
+				if (zipEnt.getSize() > 0 && zipEnt.getName().endsWith("xml")) {
+					r = new BufferedReader(new InputStreamReader(zif.getInputStream(zipEnt), IO.JAVA_UTF8_CODEC));
 					parse(r);
 					r.close();
 				}
 			}
 			zif.close();
-		}catch (final ZipException e){
-			finalMessage = MyLocale.getMsg(1614,"Error while unzipping udpate file");
+		} catch (final ZipException e) {
+			finalMessage = MyLocale.getMsg(1614, "Error while unzipping udpate file");
 			success = false;
-		}catch (final IOException e){
-			if (e.getMessage().equalsIgnoreCase("no updates available")) { finalMessage = "No updates available"; success = false; }
-			else {
-				if (e.getMessage().equalsIgnoreCase("could not connect") ||
-						e.getMessage().equalsIgnoreCase("unkown host")) { // is there a better way to find out what happened?
-					finalMessage = MyLocale.getMsg(1616,"Error: could not download update file from " + hostname);
-				} else { finalMessage = "IOException: "+e.getMessage(); }
+		} catch (final IOException e) {
+			if (e.getMessage().equalsIgnoreCase("no updates available")) {
+				finalMessage = "No updates available";
 				success = false;
+			} else {
+				if (e.getMessage().equalsIgnoreCase("could not connect") || e.getMessage().equalsIgnoreCase("unkown host")) { // is there a better way to find out what happened?
+					finalMessage = MyLocale.getMsg(1616, "Error: could not download update file from " + hostname);
+				} else {
+					finalMessage = "IOException: " + e.getMessage();
+				}
+				success = false;
 			}
-		}catch (final IllegalArgumentException e) {
-			finalMessage = MyLocale.getMsg(1621,"Error parsing update file\n this is likely a bug in " + hostname + "\nplease try again later\n, state:")+" "+state+", waypoint: "+ holder.getWayPoint();
+		} catch (final IllegalArgumentException e) {
+			finalMessage = MyLocale.getMsg(1621, "Error parsing update file\n this is likely a bug in " + hostname + "\nplease try again later\n, state:") + " " + state + ", waypoint: " + holder.getWayPoint();
 			success = false;
-			pref.log("Parse error: " + state + " " + holder.getWayPoint(),e,true);
-		}catch (final Exception e){ // here should be used the correct exception
-			if (holder != null)	finalMessage = MyLocale.getMsg(1615,"Error parsing update file, state:")+" "+state+", waypoint: "+ holder.getWayPoint();
-			else finalMessage = MyLocale.getMsg(1615,"Error parsing update file, state:")+" "+state+", waypoint: <unkown>";
+			pref.log("Parse error: " + state + " " + holder.getWayPoint(), e, true);
+		} catch (final Exception e) { // here should be used the correct exception
+			if (holder != null)
+				finalMessage = MyLocale.getMsg(1615, "Error parsing update file, state:") + " " + state + ", waypoint: " + holder.getWayPoint();
+			else
+				finalMessage = MyLocale.getMsg(1615, "Error parsing update file, state:") + " " + state + ", waypoint: <unkown>";
 			success = false;
-			pref.log("",e,true);
+			pref.log("", e, true);
 		} finally {
-			if (tmpFile != null) tmpFile.delete();
+			if (tmpFile != null)
+				tmpFile.delete();
 		}
 		/*
-		for (int i=cacheDB.size()-1; i >=0; i--) {
-			ch = (CacheHolder)cacheDB.get(i);
-			if (ch.wayPoint.toUpperCase().startsWith("OC")) { //TODO only handle changed caches
-				ch.calcRecommendationScore();
-			}
-		} */
+		 * for (int i=cacheDB.size()-1; i >=0; i--) {
+		 * ch = (CacheHolder)cacheDB.get(i);
+		 * if (ch.wayPoint.toUpperCase().startsWith("OC")) { //TODO only handle changed caches
+		 * ch.calcRecommendationScore();
+		 * }
+		 * }
+		 */
 		inf.setInfo(finalMessage);
 
 		return success;
 	}
 
-	public void startElement(String name, AttributeList atts){
-		if (debugGPX){
+	public void startElement(String name, AttributeList atts) {
+		if (debugGPX) {
 			for (int i = 0; i < atts.getLength(); i++) {
-				pref.log(" Name: " + atts.getName(i)+ " Value: "+atts.getValue(i));
+				pref.log(" Name: " + atts.getName(i) + " Value: " + atts.getValue(i));
 			}
 		}
-		strData ="";
+		strData = "";
 
-		if (name.equals("oc11xml")){
+		if (name.equals("oc11xml")) {
 			final Time lastSync = new Time();
 			try {
-				lastSync.parse(atts.getValue("date"),"yyyy-MM-dd HH:mm:ss");
-			}catch (final IllegalArgumentException e){
-				pref.log("",e,true);
+				lastSync.parse(atts.getValue("date"), "yyyy-MM-dd HH:mm:ss");
+			} catch (final IllegalArgumentException e) {
+				pref.log("", e, true);
 			}
 			// reduce time at 1 second to avoid sync problems
 			lastSync.setTime(lastSync.getTime() - 1000);
@@ -376,81 +368,110 @@
 		}
 
 		// look for changes in the state
-		if (name.equals("cache")) 		{ state = STAT_CACHE; }
-		if (name.equals("cachedesc")) 	{ state = STAT_CACHE_DESC;}
-		if (name.equals("cachelog")) 	{ state = STAT_CACHE_LOG; logtype = 0;}
-		if (name.equals("picture")) 	{ state = STAT_PICTURE; }
+		if (name.equals("cache")) {
+			state = STAT_CACHE;
+		}
+		if (name.equals("cachedesc")) {
+			state = STAT_CACHE_DESC;
+		}
+		if (name.equals("cachelog")) {
+			state = STAT_CACHE_LOG;
+			logtype = 0;
+		}
+		if (name.equals("picture")) {
+			state = STAT_PICTURE;
+		}
 
-		//examine data
+		// examine data
 		switch (state) {
-		case STAT_CACHE: startCache(name, atts); break;
-		case STAT_CACHE_DESC: startCacheDesc(name, atts); break;
-		case STAT_CACHE_LOG: startCacheLog(name, atts); break;
-		case STAT_PICTURE: startPicture(name,atts); break;
+		case STAT_CACHE:
+			startCache(name, atts);
+			break;
+		case STAT_CACHE_DESC:
+			startCacheDesc(name, atts);
+			break;
+		case STAT_CACHE_LOG:
+			startCacheLog(name, atts);
+			break;
+		case STAT_PICTURE:
+			startPicture(name, atts);
+			break;
 		}
 
 	}
 
-	public void endElement(String name){
-		//examine data
+	public void endElement(String name) {
+		// examine data
 		switch (state) {
-		case STAT_CACHE: endCache(name); break;
-		case STAT_CACHE_DESC: endCacheDesc(name);break;
-		case STAT_CACHE_LOG: endCacheLog(name); break;
-		case STAT_PICTURE: endPicture(name); break;
+		case STAT_CACHE:
+			endCache(name);
+			break;
+		case STAT_CACHE_DESC:
+			endCacheDesc(name);
+			break;
+		case STAT_CACHE_LOG:
+			endCacheLog(name);
+			break;
+		case STAT_PICTURE:
+			endPicture(name);
+			break;
 		}
 
 		// look for changes in the state
-		if (name.equals("cache")) 		state = STAT_INIT;
-		if (name.equals("cachedesc")) 	state = STAT_INIT;
-		if (name.equals("cachelog")) 	state = STAT_INIT;
-		if (name.equals("picture")) 	state = STAT_INIT;
+		if (name.equals("cache"))
+			state = STAT_INIT;
+		if (name.equals("cachedesc"))
+			state = STAT_INIT;
+		if (name.equals("cachelog"))
+			state = STAT_INIT;
+		if (name.equals("picture"))
+			state = STAT_INIT;
 
 	}
 
-	public void characters(char[] ch2,int start,int length){
-		final String chars = new String(ch2,start,length);
+	public void characters(char[] ch2, int start, int length) {
+		final String chars = new String(ch2, start, length);
 		strData += chars;
-		if (debugGPX) pref.log(strData,null);
+		if (debugGPX)
+			pref.log(strData, null);
 	}
 
-	private void startCache(String name, AttributeList atts){
-		if(name.equals("id")){
+	private void startCache(String name, AttributeList atts) {
+		if (name.equals("id")) {
 			cacheID = atts.getValue("id");
 			return;
 		}
-		if (holder==null) return;
-		inf.setInfo(MyLocale.getMsg(1609,"Importing Cache:")+" " + numCacheImported + " / " + numCacheUpdated + "\n");
-		if(name.equals("type")){
+		if (holder == null)
+			return;
+		inf.setInfo(MyLocale.getMsg(1609, "Importing Cache:") + " " + numCacheImported + " / " + numCacheUpdated + "\n");
+		if (name.equals("type")) {
 			holder.setType(CacheType.ocType2CwType(atts.getValue("id")));
 			holder.getCacheDetails(false).attributes.clear();
 			return;
 		}
-		if(name.equals("status")){
-            // meaning of OC status :
-			//  1=Kann gesucht werden ;
-			//  2=Momentan nicht verf?gbar ;
-			//  3=Archiviert ;
-			//  4= ;
-			//  5= ;
-			//  6=Gesperrt ;
-			//  are there more ? ;
+		if (name.equals("status")) {
+			// meaning of OC status :
+			// 1=Kann gesucht werden ;
+			// 2=Momentan nicht verf?gbar ;
+			// 3=Archiviert ;
+			// 4= ;
+			// 5= ;
+			// 6=Gesperrt ;
+			// are there more ? ;
 			if (atts.getValue("id").equals("1")) {
 				holder.setAvailable(true);
 				holder.setArchived(false);
 			} else {
 				holder.setAvailable(false);
-				if( (atts.getValue("id").equals("3")) || (atts.getValue("id").equals("6"))|| (atts.getValue("id").equals("7")) ) {
+				if ((atts.getValue("id").equals("3")) || (atts.getValue("id").equals("6")) || (atts.getValue("id").equals("7"))) {
 					if (!isSyncSingle) {
-						holder=null;
+						holder = null;
 						numCacheImported--;
-					}
-					else {
+					} else {
 						// Umsetzung wie in gpx f?r Status 6
 						if (atts.getValue("id").equals("6")) {
 							holder.setArchived(false);
-						}
-						else {
+						} else {
 							holder.setArchived(true);
 						}
 					}
@@ -458,24 +479,24 @@
 			}
 			return;
 		}
-		if(name.equals("size")){
+		if (name.equals("size")) {
 			holder.setCacheSize(CacheSize.ocXmlString2Cw(atts.getValue("id")));
 			return;
 		}
 
-		if(name.equals("waypoints")){
+		if (name.equals("waypoints")) {
 			holder.setWayPoint(atts.getValue("oc"));
 			final String CName = atts.getValue("nccom") + " " + atts.getValue("gccom");
 			if (!CName.equals(" ")) {
 				holder.setCacheOwner(holder.getCacheOwner() + " / " + CName.trim());
 				holder.getCacheDetails(false).attributes.add(7); // wwwlink
 				holder.setAttribsAsBits(holder.getCacheDetails(false).attributes.getAttribsAsBits());
-			}
-			else {
+			} else {
 				holder.getCacheDetails(false).attributes.add(6); // oconly
 				holder.setAttribsAsBits(holder.getCacheDetails(false).attributes.getAttribsAsBits());
 			}
-			if (holder.getWayPoint().length()==0) throw new IllegalArgumentException("empty waypointname"); // this should not happen - it is likey a bug in opencaching / it happens on 27-12-2006 on cache OC143E
+			if (holder.getWayPoint().length() == 0)
+				throw new IllegalArgumentException("empty waypointname"); // this should not happen - it is likey a bug in opencaching / it happens on 27-12-2006 on cache OC143E
 			return;
 		}
 
@@ -488,17 +509,17 @@
 
 	}
 
-	private void startCacheDesc(String name, AttributeList atts){
-		inf.setInfo(MyLocale.getMsg(1611,"Importing cache description:")+" " + numDescImported);
+	private void startCacheDesc(String name, AttributeList atts) {
+		inf.setInfo(MyLocale.getMsg(1611, "Importing cache description:") + " " + numDescImported);
 
-		if (name.equals("cacheid")){
+		if (name.equals("cacheid")) {
 			cacheID = atts.getValue("id");
 			holder = getHolder(cacheID, false);
 			return;
 		}
 
-		if (name.equals("desc")){
-			isHTML = atts.getValue("html").equals("1")?true:false;
+		if (name.equals("desc")) {
+			isHTML = atts.getValue("html").equals("1") ? true : false;
 			return;
 		}
 
@@ -508,21 +529,22 @@
 		}
 	}
 
-	private void startCacheLog(String name, AttributeList atts){
-		if (name.equals("id")){
+	private void startCacheLog(String name, AttributeList atts) {
+		if (name.equals("id")) {
 			logId = atts.getValue("id");
 			return;
 		}
 
-		if (name.equals("cacheid")){
+		if (name.equals("cacheid")) {
 			holder = getHolder(atts.getValue("id"), false);
 			return;
 		}
-		if (holder==null) return;
+		if (holder == null)
+			return;
 
-		inf.setInfo(MyLocale.getMsg(1612,"Importing Cachlog:")+" " + numLogImported);
+		inf.setInfo(MyLocale.getMsg(1612, "Importing Cachlog:") + " " + numLogImported);
 
-		if (name.equals("logtype")){
+		if (name.equals("logtype")) {
 			logtype = Convert.toInt(atts.getValue("id"));
 			switch (logtype) {
 			case 1:
@@ -530,7 +552,7 @@
 				break;
 			case 2:
 				logIcon = Log.typeText2Image("Not Found");
-				holder.setNoFindLogs((byte)(holder.getNoFindLogs()+1));
+				holder.setNoFindLogs((byte) (holder.getNoFindLogs() + 1));
 				break;
 			case 3:
 				logIcon = Log.typeText2Image("Note");
@@ -540,28 +562,29 @@
 		}
 	}
 
-	private void startPicture(String name, AttributeList atts){
-		if (name.equals("object")){
+	private void startPicture(String name, AttributeList atts) {
+		if (name.equals("object")) {
 			cacheID = atts.getValue("id"); // are there picture without cacheID?
 			holder = getHolder(cacheID, false);
 			return;
 		}
 	}
 
-	private void endCache(String name){
-		if(name.equals("id")){ // </id>
+	private void endCache(String name) {
+		if (name.equals("id")) { // </id>
 			// the guid (=strData) is not part of gpx , so we use id of cacheID
 			holder = getHolder(cacheID, true); // Allocate a new CacheHolder object
 			holder.setOcCacheID(cacheID);
 			holder.getCacheDetails(false).URL = "http://" + hostname + "/viewcache.php?cacheid=" + cacheID;
 			return;
 		}
-		if (holder == null) return; // id should always be the first for a <cache>
-		if (name.equals("cache")){
+		if (holder == null)
+			return; // id should always be the first for a <cache>
+		if (name.equals("cache")) {
 			holder.setLastSync(dateOfthisSync.format("yyyyMMddHHmmss"));
 			int index;
 			index = cacheDB.getIndex(holder.getWayPoint());
-			if (index == -1){
+			if (index == -1) {
 				numCacheImported++;
 				holder.setNew(true);
 				cacheDB.add(holder);
@@ -576,7 +599,7 @@
 				DBindexID.put(holder.getOcCacheID(), holder.getWayPoint());
 			}
 			// clear data (picture, logs) if we do a complete Update
-			if (! incUpdate){
+			if (!incUpdate) {
 				holder.getCacheDetails(false).CacheLogs.clear();
 				holder.getCacheDetails(false).images.clear();
 			}
@@ -586,52 +609,53 @@
 			// chD.saveCacheDetails(profile.dataDir);
 			// profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR); // this is done after .xml is completly processed
 
-			holder=null;
+			holder = null;
 			return;
 		}
 
-		if(name.equals("name")){
+		if (name.equals("name")) {
 			holder.setCacheName(strData);
 			return;
 		}
-		if(name.equals("userid")) {
+		if (name.equals("userid")) {
 			holder.setCacheOwner(strData);
-			if(holder.getCacheOwner().equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()>0 && holder.getCacheOwner().equalsIgnoreCase(pref.myAlias2))) holder.setOwned(true);
+			if (holder.getCacheOwner().equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length() > 0 && holder.getCacheOwner().equalsIgnoreCase(pref.myAlias2)))
+				holder.setOwned(true);
 			return;
 		}
 
-		if(name.equals("longitude")){
+		if (name.equals("longitude")) {
 			longitude = Common.parseDouble(strData);
 			return;
 		}
-		if(name.equals("latitude")) {
-			holder.pos.set(Common.parseDouble(strData),longitude);
-			holder.setLatLon(holder.pos.toString());
+		if (name.equals("latitude")) {
+			holder.setPos(new TrackPoint(Common.parseDouble(strData), longitude));
 			return;
 		}
-		if(name.equals("difficulty")) {
+		if (name.equals("difficulty")) {
 			holder.setHard(CacheTerrDiff.v1Converter(strData));
 			return;
 		}
-		if(name.equals("terrain")) {
+		if (name.equals("terrain")) {
 			holder.setTerrain(CacheTerrDiff.v1Converter(strData));
 			return;
 		}
-		if(name.equals("datehidden")) {
-			holder.setDateHidden(strData.substring(0,10)); //Date;
+		if (name.equals("datehidden")) {
+			holder.setDateHidden(strData.substring(0, 10)); // Date;
 			return;
 		}
-		if (name.equals("country")){
+		if (name.equals("country")) {
 			holder.getCacheDetails(false).Country = strData;
 			return;
 		}
 	}
 
-	private void endCacheDesc(String name){
-		if (holder == null) return;
-		if (name.equals("cachedesc")){
-			 numDescImported++;
-			 holder.setHTML(isHTML);
+	private void endCacheDesc(String name) {
+		if (holder == null)
+			return;
+		if (name.equals("cachedesc")) {
+			numDescImported++;
+			holder.setHTML(isHTML);
 			if (pref.downloadPics && isHTML) {
 				getImageNamesFromDescription();
 			}
@@ -639,56 +663,66 @@
 			return;
 		}
 
-		if (name.equals("shortdesc")){
+		if (name.equals("shortdesc")) {
 			String linebraek;
 
-			if (isHTML)	linebraek = "<br>\n";
-			else 					linebraek = "\n";
+			if (isHTML)
+				linebraek = "<br>\n";
+			else
+				linebraek = "\n";
 
-			     // this is set by "hint" a few lines down: if a long description is already updated, then this one is likely to be in another language
-			if (holder.is_updated())	holder.getCacheDetails(false).LongDescription += linebraek + processingDescLang + ":" +  linebraek + strData  +  linebraek;
-			else 					 	holder.getCacheDetails(false).LongDescription =              processingDescLang + ":" +  linebraek + strData  +  linebraek;
+			// this is set by "hint" a few lines down: if a long description is already updated, then this one is likely to be in another language
+			if (holder.is_updated())
+				holder.getCacheDetails(false).LongDescription += linebraek + processingDescLang + ":" + linebraek + strData + linebraek;
+			else
+				holder.getCacheDetails(false).LongDescription = processingDescLang + ":" + linebraek + strData + linebraek;
 			return;
 		}
 
-		if (name.equals("desc")){ // </desc>
-			if (isHTML)	holder.getCacheDetails(false).LongDescription +=SafeXML.cleanback(strData);
-			else holder.getCacheDetails(false).LongDescription +=strData;
+		if (name.equals("desc")) { // </desc>
+			if (isHTML)
+				holder.getCacheDetails(false).LongDescription += SafeXML.cleanback(strData);
+			else
+				holder.getCacheDetails(false).LongDescription += strData;
 			return;
 		}
-		if (name.equals("hint")){
+		if (name.equals("hint")) {
 			String linebreak;
-			if (isHTML)	linebreak = "<br>\n";
-			else 					linebreak = "\n";
-			if (holder.is_updated())	holder.getCacheDetails(false).Hints += linebreak + "[" + processingDescLang + ":]" +  linebreak + Common.rot13(strData)  +  linebreak;
-			else 					 	holder.getCacheDetails(false).Hints =              "[" + processingDescLang + ":]" +  linebreak + Common.rot13(strData)  +  linebreak;
+			if (isHTML)
+				linebreak = "<br>\n";
+			else
+				linebreak = "\n";
+			if (holder.is_updated())
+				holder.getCacheDetails(false).Hints += linebreak + "[" + processingDescLang + ":]" + linebreak + Common.rot13(strData) + linebreak;
+			else
+				holder.getCacheDetails(false).Hints = "[" + processingDescLang + ":]" + linebreak + Common.rot13(strData) + linebreak;
 			holder.setUpdated(true); // remark: this is used in "shortdesc" to decide weather the description should be appended or replaced
 			return;
 		}
 	}
 
-	private void endCacheLog(String name){
-		if (holder == null) return;
-		if (name.equals("cachelog")){ // </cachelog>
-			if (holder.getCacheDetails(false).CacheLogs.merge(new Log(logIcon, logDate, logFinder, logData, loggerRecommended))> -1) {
+	private void endCacheLog(String name) {
+		if (holder == null)
+			return;
+		if (name.equals("cachelog")) { // </cachelog>
+			if (holder.getCacheDetails(false).CacheLogs.merge(new Log(logIcon, logDate, logFinder, logData, loggerRecommended)) > -1) {
 				numLogImported++;
-				holder.getCacheDetails(false).hasUnsavedChanges = true; //chD.saveCacheDetails(profile.dataDir);
+				holder.getCacheDetails(false).hasUnsavedChanges = true; // chD.saveCacheDetails(profile.dataDir);
 			}
 			//
-			if((logFinder.toLowerCase().compareTo(user) == 0 || logFinder.equalsIgnoreCase(pref.myAlias2)) && logtype == 1) {
+			if ((logFinder.toLowerCase().compareTo(user) == 0 || logFinder.equalsIgnoreCase(pref.myAlias2)) && logtype == 1) {
 				if (incFinds || !holder.is_new()) {
 					// aber vorhandene werden mit gefunden aktualisiert
 					holder.setCacheStatus(logDate);
 					holder.setFound(true);
 					holder.getCacheDetails(false).OwnLogId = logId;
 					holder.getCacheDetails(false).OwnLog = new Log(logIcon, logDate, logFinder, logData, loggerRecommended);
-				}
-				else {
-					//if (holder.is_new())
+				} else {
+					// if (holder.is_new())
 					cacheDB.removeElementAt(cacheDB.getIndex(holder));
 					DBindexID.remove(holder.GetCacheID());
 					// und Dateien l?schen?
-					final File tmpFile = new File(profile.dataDir + holder.getWayPoint()+".xml");
+					final File tmpFile = new File(profile.dataDir + holder.getWayPoint() + ".xml");
 					tmpFile.delete();
 					// todo: was ist mit den schon heruntergeladenen Bildern?
 				}
@@ -696,103 +730,108 @@
 			return;
 		}
 
-		if (name.equals("date"))  {
+		if (name.equals("date")) {
 			logDate = strData;
 			return;
 		}
-		if (name.equals("userid")){
+		if (name.equals("userid")) {
 			logFinder = strData;
 			return;
 		}
-		if (name.equals("text")){
+		if (name.equals("text")) {
 			logData = strData;
 			return;
 		}
 
 	}
 
-	private void endPicture(String name){
-		if (holder == null) return;
+	private void endPicture(String name) {
+		if (holder == null)
+			return;
 
-		if(name.equals("id")){
+		if (name.equals("id")) {
 			picID = strData;
 			return;
 		}
 
-		if (name.equals("url")){
+		if (name.equals("url")) {
 			picUrl = strData;
 			return;
 		}
-		if (name.equals("title")){
+		if (name.equals("title")) {
 			picTitle = strData;
 			return;
 		}
-		if(name.equals("picture")){
-			inf.setInfo(MyLocale.getMsg(1613,"Pictures:")+" " + ++picCnt);
-			//String fileName = holder.wayPoint + "_" + picUrl.substring(picUrl.lastIndexOf("/")+1);
+		if (name.equals("picture")) {
+			inf.setInfo(MyLocale.getMsg(1613, "Pictures:") + " " + ++picCnt);
+			// String fileName = holder.wayPoint + "_" + picUrl.substring(picUrl.lastIndexOf("/")+1);
 			final ImageInfo ii = new ImageInfo();
 			ii.setTitle(picTitle);
 			ii.setURL(picUrl);
 			getPic(ii);
-			holder.getCacheDetails(false).hasUnsavedChanges = true; //saveCacheDetails(profile.dataDir);
+			holder.getCacheDetails(false).hasUnsavedChanges = true; // saveCacheDetails(profile.dataDir);
 			return;
 		}
 	}
 
-	private CacheHolder getHolder(String guid, boolean create){// See also LOCXMLImporter
+	private CacheHolder getHolder(String guid, boolean create) {// See also LOCXMLImporter
 		CacheHolder ch = null;
-		//Integer INTR = (Integer)DBindexID.get(guid);
-		final String wp = (String)DBindexID.get(guid);
-		//if(INTR != null){
-		if(wp != null){
-			//ch = cacheDB.get(INTR.intValue());
+		// Integer INTR = (Integer)DBindexID.get(guid);
+		final String wp = (String) DBindexID.get(guid);
+		// if(INTR != null){
+		if (wp != null) {
+			// ch = cacheDB.get(INTR.intValue());
 			ch = cacheDB.get(wp);
 		} else {
-			if (create) ch = new CacheHolder();
+			if (create)
+				ch = new CacheHolder();
 		}
 		return ch;
 	}
 
-
 	private void getImageNamesFromDescription() {
 		String fetchUrl;
 		String imgTag;
 		String imgAltText;
-		final Regex imgRegexUrl = new Regex("(<img[^>]*src=[\"\']([^>^\"^\']*)[^>]*>|<img[^>]*src=([^>^\"^\'^ ]*)[^>]*>)"); //  Ergebnis enthlt keine Anfhrungszeichen
+		final Regex imgRegexUrl = new Regex("(<img[^>]*src=[\"\']([^>^\"^\']*)[^>]*>|<img[^>]*src=([^>^\"^\'^ ]*)[^>]*>)"); // Ergebnis enthlt keine Anfhrungszeichen
 		final Regex imgRegexAlt = new Regex("(?:alt=[\"\']([^>^\"^\']*)|alt=([^>^\"^\'^ ]*))"); // get alternative text for Pic
 		imgRegexAlt.setIgnoreCase(true);
 		imgRegexUrl.setIgnoreCase(true);
-		int descIndex=0;
-		int numDownloaded=1;
+		int descIndex = 0;
+		int numDownloaded = 1;
 		while (imgRegexUrl.searchFrom(holder.getCacheDetails(false).LongDescription, descIndex)) { // "img" found
-			imgTag=imgRegexUrl.stringMatched(1); // (1) enthlt das gesamte <img ...>-tag
-			fetchUrl=imgRegexUrl.stringMatched(2); // URL in Anfhrungszeichen in (2) falls ohne in (3) Ergebnis ist auf jeden Fall ohne Anfhrungszeichen
-			if (fetchUrl==null) { fetchUrl=imgRegexUrl.stringMatched(3); }
-			if (fetchUrl==null) { // TODO Fehler ausgeben: nicht abgedeckt ist der Fall, dass in einem Cache Links auf Bilder mit unterschiedlichen URL, aber gleichem Dateinamen sind.
-				inf.addWarning(MyLocale.getMsg(1617, "Ignoriere Fehler in html-Cache-Description: \"<img\" without \"src=\" in cache "+holder.getWayPoint()));
+			imgTag = imgRegexUrl.stringMatched(1); // (1) enthlt das gesamte <img ...>-tag
+			fetchUrl = imgRegexUrl.stringMatched(2); // URL in Anfhrungszeichen in (2) falls ohne in (3) Ergebnis ist auf jeden Fall ohne Anfhrungszeichen
+			if (fetchUrl == null) {
+				fetchUrl = imgRegexUrl.stringMatched(3);
+			}
+			if (fetchUrl == null) { // TODO Fehler ausgeben: nicht abgedeckt ist der Fall, dass in einem Cache Links auf Bilder mit unterschiedlichen URL, aber gleichem Dateinamen sind.
+				inf.addWarning(MyLocale.getMsg(1617, "Ignoriere Fehler in html-Cache-Description: \"<img\" without \"src=\" in cache " + holder.getWayPoint()));
 				continue;
 			}
-			inf.setInfo(MyLocale.getMsg(1611,"Importing cache description:")+" " + numDescImported + "\n"+MyLocale.getMsg(1620, "downloading embedded images: ") + numDownloaded++);
+			inf.setInfo(MyLocale.getMsg(1611, "Importing cache description:") + " " + numDescImported + "\n" + MyLocale.getMsg(1620, "downloading embedded images: ") + numDownloaded++);
 			if (imgRegexAlt.search(imgTag)) {
-				imgAltText=imgRegexAlt.stringMatched(1);
-				if (imgAltText==null)	imgAltText=imgRegexAlt.stringMatched(2);
+				imgAltText = imgRegexAlt.stringMatched(1);
+				if (imgAltText == null)
+					imgAltText = imgRegexAlt.stringMatched(2);
 				// no alternative text as image title -> use filename
 			} else {
-				if (fetchUrl.toLowerCase().indexOf("opencaching.") > 0 || fetchUrl.toLowerCase().indexOf("geocaching.com") > 0) //wenn von Opencaching oder geocaching ist Dateiname doch nicht so toll, weil nur aus Nummer bestehend
+				if (fetchUrl.toLowerCase().indexOf("opencaching.") > 0 || fetchUrl.toLowerCase().indexOf("geocaching.com") > 0) // wenn von Opencaching oder geocaching ist Dateiname doch nicht so toll, weil nur aus Nummer bestehend
 					imgAltText = "No image title";
-				else imgAltText = fetchUrl.substring(fetchUrl.lastIndexOf('/')+1);
+				else
+					imgAltText = fetchUrl.substring(fetchUrl.lastIndexOf('/') + 1);
 			}
 			descIndex = imgRegexUrl.matchedTo();
 			try {
-				//TODO this is not quite correct: actually the "base" URL must be known...
-				// but anyway a different baseURL should not happen very often  - it doesn't in my area
+				// TODO this is not quite correct: actually the "base" URL must be known...
+				// but anyway a different baseURL should not happen very often - it doesn't in my area
 				if (!fetchUrl.startsWith("http://")) {
-					fetchUrl = new URL(new URL("http://" + hostname+"/"), fetchUrl).toString();
+					fetchUrl = new URL(new URL("http://" + hostname + "/"), fetchUrl).toString();
 				}
 			} catch (final MalformedURLException e) {
-				final String ErrMessage = MyLocale.getMsg(1618,"Ignoring error in cache: ") + holder.getWayPoint() + ": ignoring MalformedUrlException: " + e.getMessage()+ " while downloading from URL:" + fetchUrl;
-				inf.addWarning("\n"+ErrMessage);
-				pref.log(ErrMessage,e);
+				final String ErrMessage = MyLocale.getMsg(1618, "Ignoring error in cache: ") + holder.getWayPoint() + ": ignoring MalformedUrlException: " + e.getMessage() + " while downloading from URL:" + fetchUrl;
+				inf.addWarning("\n" + ErrMessage);
+				pref.log(ErrMessage, e);
 			}
 			final ImageInfo imageInfo = new ImageInfo();
 			imageInfo.setURL(fetchUrl);
@@ -801,27 +840,27 @@
 		}
 	}
 
-
 	private void getPic(ImageInfo imageInfo) { // TODO handling of relativ URLs
-		String fileName = holder.getWayPoint() + "_" + imageInfo.getURL().substring(imageInfo.getURL().lastIndexOf('/')+1);
+		String fileName = holder.getWayPoint() + "_" + imageInfo.getURL().substring(imageInfo.getURL().lastIndexOf('/') + 1);
 		fileName = Common.ClearForFileName(fileName).toLowerCase();
 		final String target = profile.dataDir + fileName;
 		imageInfo.setFilename(fileName);
 		try {
 			File ftest = new FileBugfix(target);
-			if (ftest.exists()){
-				if (ftest.length() == 0) { ftest.delete(); }
-				else { holder.getCacheDetails(false).images.add(imageInfo);	}
-			}
-			else {
+			if (ftest.exists()) {
+				if (ftest.length() == 0) {
+					ftest.delete();
+				} else {
+					holder.getCacheDetails(false).images.add(imageInfo);
+				}
+			} else {
 				if (pref.downloadPics) {
 					UrlFetcher.fetchDataFile(imageInfo.getURL(), target);
 					ftest = new FileBugfix(target);
-					if (ftest.exists()){
-						if ( ftest.length() > 0 ) {
+					if (ftest.exists()) {
+						if (ftest.length() > 0) {
 							holder.getCacheDetails(false).images.add(imageInfo);
-						}
-						else {
+						} else {
 							ftest.delete();
 						}
 					}
@@ -830,22 +869,26 @@
 		} catch (final IOException e) {
 			String ErrMessage;
 			String wp, n;
-			if (holder != null && holder.getWayPoint() != null) wp = holder.getWayPoint();
-			else 												wp = "WP???";
-			if (holder != null && holder.getCacheName() != null) n = holder.getCacheName();
-			else 												 n = "name???";
+			if (holder != null && holder.getWayPoint() != null)
+				wp = holder.getWayPoint();
+			else
+				wp = "WP???";
+			if (holder != null && holder.getCacheName() != null)
+				n = holder.getCacheName();
+			else
+				n = "name???";
 
-			if (e == null) ErrMessage = "Ignoring error: OCXMLImporter.getPic: IOExeption == null, while downloading picture: "+fileName+" from URL:"+imageInfo.getURL();
+			if (e == null)
+				ErrMessage = "Ignoring error: OCXMLImporter.getPic: IOExeption == null, while downloading picture: " + fileName + " from URL:" + imageInfo.getURL();
 			else {
-				if (e.getMessage().equalsIgnoreCase("could not connect") ||
-						e.getMessage().equalsIgnoreCase("unkown host")) {
+				if (e.getMessage().equalsIgnoreCase("could not connect") || e.getMessage().equalsIgnoreCase("unkown host")) {
 					// is there a better way to find out what happened?
-					ErrMessage = MyLocale.getMsg(1618,"Ignoring error in cache: ")+ n + " ("+wp+")"+MyLocale.getMsg(1619,": could not download image from URL: ")+imageInfo.getURL();
+					ErrMessage = MyLocale.getMsg(1618, "Ignoring error in cache: ") + n + " (" + wp + ")" + MyLocale.getMsg(1619, ": could not download image from URL: ") + imageInfo.getURL();
 				} else
-					ErrMessage = MyLocale.getMsg(1618,"Ignoring error in cache: ")+ n + " ("+wp+"): ignoring IOException: "+e.getMessage()+ " while downloading picture:"+fileName+" from URL:"+imageInfo.getURL();
+					ErrMessage = MyLocale.getMsg(1618, "Ignoring error in cache: ") + n + " (" + wp + "): ignoring IOException: " + e.getMessage() + " while downloading picture:" + fileName + " from URL:" + imageInfo.getURL();
 			}
-			inf.addWarning("\n"+ErrMessage);
-			pref.log(ErrMessage,e,true);
+			inf.addWarning("\n" + ErrMessage);
+			pref.log(ErrMessage, e, true);
 		}
 
 	}

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -460,8 +460,8 @@
 		CacheHolder ch = null;
 		for (int i = 0; i < cacheDB.size(); i++) {
 			ch = cacheDB.get(i);
-			if (ch.is_Checked && ch.pos.isValid()) {
-				final CWPoint tmpPos = ch.pos;
+			if (ch.is_Checked && ch.getPos().isValid()) {
+				final CWPoint tmpPos = ch.getPos();
 				final double tmpDistance = tmpPos.getDistance(startPos);
 				if (nextDistance == 0) {
 					// Startwert
@@ -484,7 +484,7 @@
 			}
 		}
 		if (index > -1) {
-			return cacheDB.get(index).pos;
+			return cacheDB.get(index).getPos();
 		} else
 			return null;
 	}
@@ -630,7 +630,7 @@
 
 				ch = new CacheHolder();
 				ch.setWayPoint(wp);
-				ch.setLatLon(lat + " " + lon);
+				ch.setPos(new CWPoint(lat + " " + lon));
 				ch.setType(cacheType);
 				if (own.equals("true")) {
 					ch.setOwned(true);
@@ -1711,7 +1711,7 @@
 			boolean pm = subrOnly.equals("false") ? false : true;
 			if (pm && !pref.isPremium)
 				ch.setCacheStatus("PM");
-			ch.pos = p;
+			ch.setPos(p);
 			ch.setCacheOwner(owner);
 			// wird nicht mehr geliefert , todo aus Grafik extrahieren.
 			if (owner.equals(pref.myAlias) || owner.equals(pref.myAlias2)) {
@@ -2319,8 +2319,8 @@
 						// ==========
 						// General Cache Data
 						// ==========
-						ch.setLatLon(latLon);
-						pref.log("LatLon: " + ch.getLatLon());
+						ch.setPos(new CWPoint(latLon));
+						pref.log("LatLon: " + ch.getPos().toString());
 
 						final String longDesc = getLongDesc(completeWebPage);
 						ch.getCacheDetails(false).setLongDescription(longDesc);
@@ -3047,7 +3047,7 @@
 
 					koordRex.search(rowBlock);
 					if (koordRex.didMatch()) {
-						hd.setLatLon(koordRex.stringMatched(1));
+						hd.setPos(new CWPoint(koordRex.stringMatched(1)));
 						koords_not_yet_found = false;
 					} else {
 						if (koords_not_yet_found) {

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/myTableControl.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -317,7 +317,7 @@
 				return;
 			}
 			CacheHolder thisCache = cacheDB.get(tbp.getSelectedCache());
-			CWPoint cp = new CWPoint(thisCache.getLatLon());
+			CWPoint cp = new CWPoint(thisCache.getPos());
 			if (!cp.isValid()) {
 				MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(4111, "Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"), FormBase.OKB);
 				tmpMB.execute();
@@ -373,9 +373,9 @@
 
 		if (selectedItem == miOpenGmaps) {
 			ch = cacheDB.get(tbp.getSelectedCache());
-			if (ch.pos.isValid()) {
-				String lat = "" + ch.pos.getLatDeg(CWPoint.DD);
-				String lon = "" + ch.pos.getLonDeg(CWPoint.DD);
+			if (ch.getPos().isValid()) {
+				String lat = "" + ch.getPos().getLatDeg(CWPoint.DD);
+				String lon = "" + ch.getPos().getLonDeg(CWPoint.DD);
 				String nameOfCache = UrlFetcher.encodeURL(ch.getCacheName(), false).replace('#', 'N').replace('@', '_');
 				String language = Vm.getLocale().getString(Locale.LANGUAGE_SHORT, 0, 0);
 				if (!pref.language.equalsIgnoreCase("auto")) {

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/myTableModel.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -417,7 +417,7 @@
 					wpVal.addColumn(ch.getCacheName());
 					return wpVal;
 				case 6: // Location
-					return ch.getLatLon();
+					return ch.getPos().toString();
 				case 7: // Owner
 					return ch.getCacheOwner();
 				case 8: // Date hidden

Modified: trunk/src/CacheWolf/navi/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/navi/GotoPanel.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/navi/GotoPanel.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -68,18 +68,17 @@
 import ewe.ui.mLabel;
 
 /**
- *	Class to create the panel which handles the connection to the GPS-device<br>
- *	Displays: current position,speed and bearing; relation to destination waypoint<br>
- *	Class ID: 1500
+ * Class to create the panel which handles the connection to the GPS-device<br>
+ * Displays: current position,speed and bearing; relation to destination waypoint<br>
+ * Class ID: 1500
  */
 
-
 public final class GotoPanel extends CellPanel {
 
-	//public CWGPSPoint gpsPosition = new CWGPSPoint();
-	//public CWPoint toPoint = new CWPoint();
+	// public CWGPSPoint gpsPosition = new CWGPSPoint();
+	// public CWPoint toPoint = new CWPoint();
 	public Navigate myNavigation;
-	mButton btnGPS, btnCenter,btnSave;
+	mButton btnGPS, btnCenter, btnSave;
 	mButton btnGoto, btnMap;
 	int currFormatSel;
 
@@ -101,13 +100,13 @@
 	ImageControl icRose;
 	GotoRose compassRose;
 
-	final static Color RED = new Color(255,0,0);
-	final static Color YELLOW = new Color(255,255,0);
-	final static Color GREEN = new Color(0,255,0);
-	final static Color BLUE = new Color(0,0,255);
+	final static Color RED = new Color(255, 0, 0);
+	final static Color YELLOW = new Color(255, 255, 0);
+	final static Color GREEN = new Color(0, 255, 0);
+	final static Color BLUE = new Color(0, 0, 255);
 
 	Menu mnuContextFormt;
-	MenuItem miCooformat[] = new MenuItem[TransformCoordinates.localSystems.length + 3]; //miDMM, miDMS, miDD, miUTM, miGK;
+	MenuItem miCooformat[] = new MenuItem[TransformCoordinates.localSystems.length + 3]; // miDMM, miDMS, miDD, miUTM, miGK;
 
 	Menu mnuContextRose;
 	MenuItem miLuminary[] = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
@@ -115,27 +114,32 @@
 
 	/**
 	 * Create GotoPanel
-	 * @param Preferences 	global preferences
-	 * @param MainTab		reference to MainTable
-	 * @param DetailsPanel 	reference to DetailsPanel
-	 * @param Vector		cacheDB
+	 * 
+	 * @param Preferences
+	 *            global preferences
+	 * @param MainTab
+	 *            reference to MainTable
+	 * @param DetailsPanel
+	 *            reference to DetailsPanel
+	 * @param Vector
+	 *            cacheDB
 	 */
 	public GotoPanel(Navigate nav) {
 		myNavigation = nav;
 		pref = Global.getPref();
-		profile=Global.getProfile();
+		profile = Global.getProfile();
 		mainT = Global.mainTab;
 		detP = mainT.detP;
 		cacheDB = profile.cacheDB;
 
 		// Button
-		ButtonP.addNext(btnGPS = new mButton(MyLocale.getMsg(1504,"Start")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		ButtonP.addNext(btnCenter = new mButton(MyLocale.getMsg(309,"Centre")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		ButtonP.addLast(btnSave = new mButton(MyLocale.getMsg(311,"Create Waypoint")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addNext(btnGPS = new mButton(MyLocale.getMsg(1504, "Start")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		ButtonP.addNext(btnCenter = new mButton(MyLocale.getMsg(309, "Centre")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		ButtonP.addLast(btnSave = new mButton(MyLocale.getMsg(311, "Create Waypoint")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		// ButtonP.addLast(btnMap = new mButton(MyLocale.getMsg(1506,"Map")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 
-		//Format selection for coords
-		//context menu
+		// Format selection for coords
+		// context menu
 		mnuContextFormt = new Menu();
 		currFormatSel = 1; // default to d? m.m
 		mnuContextFormt.addItem(miCooformat[0] = new MenuItem("d.d?"));
@@ -148,14 +152,16 @@
 
 		// Create context menu for compass rose: select luminary for orientation
 		mnuContextRose = new Menu();
-		for (int i=0; i<SkyOrientation.LUMINARY_NAMES.length; i++) {
+		for (int i = 0; i < SkyOrientation.LUMINARY_NAMES.length; i++) {
 			mnuContextRose.addItem(miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i)));
-			if (i == myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
-			else miLuminary[i].modifiers &= MenuItem.Checked;
+			if (i == myNavigation.luminary)
+				miLuminary[i].modifiers |= MenuItem.Checked;
+			else
+				miLuminary[i].modifiers &= MenuItem.Checked;
 		}
 
-		//Coords
-		CoordsP.addNext(lblGPS = new mLabel("GPS: "),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		// Coords
+		CoordsP.addNext(lblGPS = new mLabel("GPS: "), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		lblGPS.backGround = RED;
 		lblGPS.setMenu(mnuContextFormt);
 		lblGPS.modifyAll(ControlConstants.WantHoldDown, 0);
@@ -164,45 +170,47 @@
 		lblPosition.anchor = CellConstants.CENTER;
 		lblPosition.setMenu(mnuContextFormt);
 		lblPosition.modifyAll(ControlConstants.WantHoldDown, 0);
-		CoordsP.addLast(lblPosition, CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		CoordsP.addLast(lblPosition, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
 
-		CoordsP.addNext(lblDST = new mLabel(MyLocale.getMsg(1500,"DST:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		lblDST.backGround = new Color(0,0,255);
+		CoordsP.addNext(lblDST = new mLabel(MyLocale.getMsg(1500, "DST:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		lblDST.backGround = new Color(0, 0, 255);
 		lblDST.setMenu(mnuContextFormt);
 		lblDST.modifyAll(ControlConstants.WantHoldDown, 0);
 
-		CoordsP.addLast(btnGoto = new mButton(getGotoBtnText()),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		CoordsP.addLast(btnGoto = new mButton(getGotoBtnText()), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
 
-		//Rose for bearing
-		//		compassRose = new GotoRose("rose.png");
+		// Rose for bearing
+		// compassRose = new GotoRose("rose.png");
 		compassRose = new GotoRose();
 		icRose = new ImageControl(compassRose);
 		icRose.setMenu(mnuContextRose);
 		icRose.modifyAll(ControlConstants.WantHoldDown, 0); // this is necessary in order to make PenHold on a PDA work as right click
-		roseP.addLast(icRose,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTH));
+		roseP.addLast(icRose, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.NORTH));
 
 		mnuContextRose.addItem(new MenuItem("", MenuItem.Separator, null));
-		mnuContextRose.addItem(miNorthCentered = new MenuItem(MyLocale.getMsg(1503,"North Centered")));
-		if (compassRose.isNorthCentered()) miNorthCentered.modifiers |= MenuItem.Checked;
-		else miNorthCentered.modifiers &= MenuItem.Checked;
+		mnuContextRose.addItem(miNorthCentered = new MenuItem(MyLocale.getMsg(1503, "North Centered")));
+		if (compassRose.isNorthCentered())
+			miNorthCentered.modifiers |= MenuItem.Checked;
+		else
+			miNorthCentered.modifiers &= MenuItem.Checked;
 
-		//add Panels
-		HeadP.addLast(ButtonP,CellConstants.HSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
-		HeadP.addLast(CoordsP,CellConstants.HSTRETCH, CellConstants.HFILL|CellConstants.NORTH).setTag(SPAN,new Dimension(2,1));	
-		this.addNext(HeadP,CellConstants.HSTRETCH, CellConstants.WEST).setTag(SPAN,new Dimension(2,1));		
-		this.addLast(btnMap = new mButton(MyLocale.getMsg(1506,"Map")+" "),CellConstants.HSTRETCH, CellConstants.VFILL|CellConstants.RIGHT).setTag(SPAN,new Dimension(2,1));
-		this.addLast(roseP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
-		btnMap.backGround=GREEN;
+		// add Panels
+		HeadP.addLast(ButtonP, CellConstants.HSTRETCH, CellConstants.DONTFILL | CellConstants.WEST).setTag(SPAN, new Dimension(2, 1));
+		HeadP.addLast(CoordsP, CellConstants.HSTRETCH, CellConstants.HFILL | CellConstants.NORTH).setTag(SPAN, new Dimension(2, 1));
+		this.addNext(HeadP, CellConstants.HSTRETCH, CellConstants.WEST).setTag(SPAN, new Dimension(2, 1));
+		this.addLast(btnMap = new mButton(MyLocale.getMsg(1506, "Map") + " "), CellConstants.HSTRETCH, CellConstants.VFILL | CellConstants.RIGHT).setTag(SPAN, new Dimension(2, 1));
+		this.addLast(roseP, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST).setTag(SPAN, new Dimension(2, 1));
+		btnMap.backGround = GREEN;
 	}
 
-	public void resizeTo(int pWidth, int pHeight){
+	public void resizeTo(int pWidth, int pHeight) {
 		super.resizeTo(pWidth, pHeight);
 		Rect coordsRect = CoordsP.getRect();
 		int roseHeight = pHeight - coordsRect.y - coordsRect.height;
 		if (Gui.screenIs(Gui.PDA_SCREEN) && Vm.isMobile()) {
-			//some space for the SIP button
-			if ( (Vm.getParameter(VmConstants.VM_FLAGS) & (VmConstants.VM_FLAG_SIP_BUTTON_ON_SCREEN)) == (VmConstants.VM_FLAG_SIP_BUTTON_ON_SCREEN) ){
-				Rect screen = (Rect)Window.getGuiInfo(WindowConstants.INFO_SCREEN_RECT,null,new Rect(),0);
+			// some space for the SIP button
+			if ((Vm.getParameter(VmConstants.VM_FLAGS) & (VmConstants.VM_FLAG_SIP_BUTTON_ON_SCREEN)) == (VmConstants.VM_FLAG_SIP_BUTTON_ON_SCREEN)) {
+				Rect screen = (Rect) Window.getGuiInfo(WindowConstants.INFO_SCREEN_RECT, null, new Rect(), 0);
 				roseHeight -= screen.height / 14;
 			}
 		}
@@ -211,14 +219,17 @@
 		compassRose.resize(pWidth, roseHeight);
 	}
 
-
 	/**
 	 * set the coords of the destination
-	 * @param dest destination
+	 * 
+	 * @param dest
+	 *            destination
 	 */
-	public void setDestination(CWPoint dest){
+	public void setDestination(CWPoint dest) {
 		myNavigation.setDestination(dest);
-		if (!myNavigation.destination.isValid()) (new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(1507,"Coordinates are out of range:") +"\n"+MyLocale.getMsg(1508,"latitude")+": "+myNavigation.destination.latDec+"\n "+MyLocale.getMsg(1509,"longditue")+": "+myNavigation.destination.lonDec, FormBase.OKB)).execute();
+		if (!myNavigation.destination.isValid())
+			(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1507, "Coordinates are out of range:") + "\n" + MyLocale.getMsg(1508, "latitude") + ": " + myNavigation.destination.latDec + "\n " + MyLocale.getMsg(1509, "longditue") + ": "
+					+ myNavigation.destination.lonDec, FormBase.OKB)).execute();
 
 	}
 
@@ -227,15 +238,17 @@
 		updateDistance();
 	}
 
-
 	/**
 	 * set the coords of the destination and switch to gotoPanel
-	 * @param LatLon destination
+	 * 
+	 * @param LatLon
+	 *            destination
 	 */
 	public void setDestinationAndSwitch(CWPoint where) {
 		myNavigation.setDestination(where);
 		mainT.select(this);
 	}
+
 	public void setDestinationAndSwitch(CacheHolder ch) {
 		myNavigation.setDestination(ch);
 		mainT.select(this);
@@ -243,16 +256,16 @@
 
 	/**
 	 * updates distance and bearing
-	 *
+	 * 
 	 */
 
 	public void updateDistance() {
-		//update distance
+		// update distance
 		float distance = -1.0f;
-		if (myNavigation.gpsPos.isValid() && myNavigation.destination.isValid() ) {
-			distance = (float)myNavigation.gpsPos.getDistance(myNavigation.destination);
+		if (myNavigation.gpsPos.isValid() && myNavigation.destination.isValid()) {
+			distance = (float) myNavigation.gpsPos.getDistance(myNavigation.destination);
 		}
-		compassRose.setWaypointDirectionDist((float)myNavigation.gpsPos.getBearing(myNavigation.destination), distance);
+		compassRose.setWaypointDirectionDist((float) myNavigation.gpsPos.getBearing(myNavigation.destination), distance);
 	}
 
 	/**
@@ -263,37 +276,41 @@
 		Double speed = new Double();
 		Double sunAzimut = new Double();
 		compassRose.setGpsStatus(fix, myNavigation.gpsPos.getSats(), myNavigation.gpsPos.getSatsInView(), myNavigation.gpsPos.getHDOP());
-		if ((fix > 0) && (myNavigation.gpsPos.getSats()>= 0)) {
+		if ((fix > 0) && (myNavigation.gpsPos.getSats() >= 0)) {
 			// display values only, if signal good
 			lblPosition.setText(myNavigation.gpsPos.toString(CoordsScreen.getLocalSystem(currFormatSel)));
 			speed.set(myNavigation.gpsPos.getSpeed());
 			sunAzimut.set(myNavigation.skyOrientationDir.lonDec);
 			bearMov.set(myNavigation.gpsPos.getBear());
 			updateDistance();
-			compassRose.setSunMoveDirections((float)sunAzimut.value, (float)bearMov.value, (float)speed.value);
+			compassRose.setSunMoveDirections((float) sunAzimut.value, (float) bearMov.value, (float) speed.value);
 			// Set background to signal quality
 		}
 
 		// receiving data, but signal ist not good
-		if ((fix == 0) && (myNavigation.gpsPos.getSats()>= 0)) {
+		if ((fix == 0) && (myNavigation.gpsPos.getSats() >= 0)) {
 			gpsStatus = YELLOW;
 		}
 		// receiving no data
 		if (fix == -1) {
-			if (gpsStatus != RED) (new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1510, "No data from GPS.\nConnection to serial port/gpsd closed."),FormBase.OKB)).exec();
+			if (gpsStatus != RED)
+				(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1510, "No data from GPS.\nConnection to serial port/gpsd closed."), FormBase.OKB)).exec();
 			gpsStatus = RED;
 			myNavigation.stopGps();
 		}
 		// cannot interpret data
 		if (fix == -2) {
-			if (gpsStatus != RED) (new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1511, "Cannot interpret data from GPS/gpsd!\nPossible reasons:\nWrong port,\nwrong baud rate,\ninvalid protocol (need NMEA/gpsd).\nConnection to serial port closed.\nLast String tried to interpret:\n")+myNavigation.gpsPos.lastStrExamined, FormBase.OKB)).exec();
+			if (gpsStatus != RED)
+				(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1511,
+						"Cannot interpret data from GPS/gpsd!\nPossible reasons:\nWrong port,\nwrong baud rate,\ninvalid protocol (need NMEA/gpsd).\nConnection to serial port closed.\nLast String tried to interpret:\n")
+						+ myNavigation.gpsPos.lastStrExamined, FormBase.OKB)).exec();
 			gpsStatus = RED;
 			myNavigation.stopGps(); // TODO automatic in myNavigate?
 		}
 	}
 
 	public void gpsStarted() {
-		btnGPS.setText(MyLocale.getMsg(1505,"Stop"));
+		btnGPS.setText(MyLocale.getMsg(1505, "Stop"));
 	}
 
 	public void startGps() {
@@ -301,28 +318,33 @@
 	}
 
 	public void gpsStoped() {
-		btnGPS.setText(MyLocale.getMsg(1504,"Start"));
+		btnGPS.setText(MyLocale.getMsg(1504, "Start"));
 		gpsStatus = this.backGround;
 		this.repaintNow(); // without this the change in the background color will not be displayed
 	}
 
-
 	private String getGotoBtnText() {
-		if (myNavigation.destination == null) return MyLocale.getMsg(999,"Not set");
-		else return myNavigation.destination.toString(CoordsScreen.getLocalSystem(currFormatSel));
+		if (myNavigation.destination == null)
+			return MyLocale.getMsg(999, "Not set");
+		else
+			return myNavigation.destination.toString(CoordsScreen.getLocalSystem(currFormatSel));
 	}
 
 	public void switchToMovingMap() {
 		CWPoint centerTo = null;
-		if (myNavigation.isGpsPosValid()) centerTo = new CWPoint(myNavigation.gpsPos); // set gps-pos if gps is on
+		if (myNavigation.isGpsPosValid())
+			centerTo = new CWPoint(myNavigation.gpsPos); // set gps-pos if gps is on
 		else {
 			// setze Zielpunkt als Ausgangspunkt, wenn GPS aus ist und lade entsprechende Karte
-			//centerTo = new CWPoint(myNavigation.destination);
-			if (myNavigation.destination.isValid())	centerTo = new CWPoint(myNavigation.destination);
+			// centerTo = new CWPoint(myNavigation.destination);
+			if (myNavigation.destination.isValid())
+				centerTo = new CWPoint(myNavigation.destination);
 			else {
-				if (mainT.ch != null && mainT.ch.pos.isValid()) centerTo = new CWPoint(mainT.ch.pos);
+				if (mainT.ch != null && mainT.ch.getPos().isValid())
+					centerTo = new CWPoint(mainT.ch.getPos());
 				else {
-					if (pref.getCurCentrePt().isValid()) centerTo = new CWPoint(pref.getCurCentrePt());
+					if (pref.getCurCentrePt().isValid())
+						centerTo = new CWPoint(pref.getCurCentrePt());
 				}
 			}
 		}
@@ -335,10 +357,10 @@
 	/**
 	 * Eventhandler
 	 */
-	public void onEvent(Event ev){
+	public void onEvent(Event ev) {
 		if (ev instanceof MenuEvent) {
 			if (ev.type == MenuEvent.SELECTED) {
-				if (((MenuEvent)ev).menu == mnuContextFormt) {
+				if (((MenuEvent) ev).menu == mnuContextFormt) {
 					mnuContextFormt.close();
 					mnuContextFormt.getItemAt(currFormatSel).modifiers &= ~MenuItem.Checked;
 					currFormatSel = mnuContextFormt.getInt();
@@ -346,23 +368,22 @@
 					lblPosition.setText(myNavigation.gpsPos.toString(CoordsScreen.getLocalSystem(currFormatSel)));
 					btnGoto.setText(getGotoBtnText());
 				} // end lat-lon-format context menu
-				if (((MenuEvent)ev).menu == mnuContextRose) {
+				if (((MenuEvent) ev).menu == mnuContextRose) {
 					MenuItem action = (MenuItem) mnuContextRose.getSelectedItem();
 					if (action != null) {
-						for (int i=0; i<miLuminary.length; i++) {
+						for (int i = 0; i < miLuminary.length; i++) {
 							if (action == miLuminary[i]) {
 								myNavigation.setLuminary(i);
 								miLuminary[i].modifiers |= MenuItem.Checked;
 								compassRose.setLuminaryName(SkyOrientation.getLuminaryName(myNavigation.luminary));
-							} else miLuminary[i].modifiers &= ~MenuItem.Checked;
+							} else
+								miLuminary[i].modifiers &= ~MenuItem.Checked;
 						}
 						if (action == miNorthCentered) {
 							if (compassRose.isNorthCentered()) {
 								compassRose.setNorthCentered(false);
 								miNorthCentered.modifiers &= ~MenuItem.Checked;
-							}
-							else
-							{
+							} else {
 								compassRose.setNorthCentered(true);
 								miNorthCentered.modifiers |= MenuItem.Checked;
 							}
@@ -372,44 +393,49 @@
 			}
 		}
 
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
 			// start/stop GPS connection
-			if (ev.target == btnGPS){
-				if (btnGPS.getText().equals(MyLocale.getMsg(1504, "Start"))) startGps();
-				else myNavigation.stopGps();
+			if (ev.target == btnGPS) {
+				if (btnGPS.getText().equals(MyLocale.getMsg(1504, "Start")))
+					startGps();
+				else
+					myNavigation.stopGps();
 			}
 
 			// set current position as centre and recalculate distance of caches in MainTab
-			if (ev.target == btnCenter){
+			if (ev.target == btnCenter) {
 				if (myNavigation.gpsPos.isValid()) {
 					pref.setCurCentrePt(myNavigation.gpsPos);
-				} else (new MessageBox(MyLocale.getMsg(312, "Error"), MyLocale.getMsg(1514, "Cannot recalculate distances, because the GPS position is not set"), FormBase.OKB)).execute();
+				} else
+					(new MessageBox(MyLocale.getMsg(312, "Error"), MyLocale.getMsg(1514, "Cannot recalculate distances, because the GPS position is not set"), FormBase.OKB)).execute();
 			}
-			//Start moving map
-			if (ev.target == btnMap){
+			// Start moving map
+			if (ev.target == btnMap) {
 				switchToMovingMap();
 			}
 			// create new waypoint with current GPS-position
-			if (ev.target == btnSave){
+			if (ev.target == btnSave) {
 				CacheHolder ch = new CacheHolder();
-				ch.setLatLon(myNavigation.gpsPos.toString());
-				ch.pos = new CWPoint(myNavigation.gpsPos);
+				ch.setPos(myNavigation.gpsPos);
 				ch.setType(CacheType.CW_TYPE_STAGE); // see CacheType.GC_AW_STAGE_OF_MULTI // TODO unfertig
 				mainT.newWaypoint(ch);
 			}
 			// change destination waypoint
-			if (ev.target == btnGoto){
-				if(Vm.isMobile()){
+			if (ev.target == btnGoto) {
+				if (Vm.isMobile()) {
 					InputScreen InScr = new InputScreen(CoordsScreen.getLocalSystem(currFormatSel));
-					if (myNavigation.destination.isValid())	InScr.setCoords(myNavigation.destination);
-					else InScr.setCoords(new CWPoint(0,0));
+					if (myNavigation.destination.isValid())
+						InScr.setCoords(myNavigation.destination);
+					else
+						InScr.setCoords(new CWPoint(0, 0));
 					if (InScr.execute(null, CellConstants.TOP) == FormBase.IDOK)
 						setDestination(InScr.getCoords());
-				}else
-				{
+				} else {
 					CoordsScreen cs = new CoordsScreen();
-					if (myNavigation.destination.isValid())	cs.setFields(myNavigation.destination, CoordsScreen.getLocalSystem(currFormatSel));
-					else cs.setFields(new CWPoint(0,0), CoordsScreen.getLocalSystem(currFormatSel));
+					if (myNavigation.destination.isValid())
+						cs.setFields(myNavigation.destination, CoordsScreen.getLocalSystem(currFormatSel));
+					else
+						cs.setFields(new CWPoint(0, 0), CoordsScreen.getLocalSystem(currFormatSel));
 					if (cs.execute(null, CellConstants.TOP) == FormBase.IDOK)
 						setDestination(cs.getCoords());
 				}
@@ -420,7 +446,8 @@
 	}
 }
 
-/** class for displaying the compass rose
+/**
+ * class for displaying the compass rose
  * including goto, sun and moving direction
  */
 class GotoRose extends AniImage {
@@ -445,25 +472,28 @@
 
 	boolean northCentered = Global.getPref().northCenteredGoto;
 
-	final static Color RED = new Color(255,0,0);
-	final static Color YELLOW = new Color(255,255,0);
-	final static Color GREEN = new Color(0,255,0);
-	final static Color BLUE = new Color(0,0,255);
-	final static Color ORANGE = new Color(255,128,0);
-	final static Color DARKGREEN = new Color(0,192,0);
-	final static Color CYAN = new Color(0,255,255);
-	final static Color MAGENTA = new Color(255,0,255);
+	final static Color RED = new Color(255, 0, 0);
+	final static Color YELLOW = new Color(255, 255, 0);
+	final static Color GREEN = new Color(0, 255, 0);
+	final static Color BLUE = new Color(0, 0, 255);
+	final static Color ORANGE = new Color(255, 128, 0);
+	final static Color DARKGREEN = new Color(0, 192, 0);
+	final static Color CYAN = new Color(0, 255, 255);
+	final static Color MAGENTA = new Color(255, 0, 255);
 
 	/**
-	 * @param gd goto direction
-	 * @param sd sun direction
-	 * @param md moving direction
+	 * @param gd
+	 *            goto direction
+	 * @param sd
+	 *            sun direction
+	 * @param md
+	 *            moving direction
 	 */
-	public GotoRose(String fn){
+	public GotoRose(String fn) {
 		super(fn);
 	}
 
-	public GotoRose(){
+	public GotoRose() {
 		super();
 	}
 
@@ -472,7 +502,7 @@
 		distance = dist;
 	}
 
-	public void setSunMoveDirections(float sd, float md, float speed ) {
+	public void setSunMoveDirections(float sd, float md, float speed) {
 		sunDir = sd;
 		moveDir = md;
 		m_speed = speed;
@@ -492,15 +522,18 @@
 		refresh();
 	}
 
-
 	/**
 	 * draw arrows for the directions of movement and destination waypoint
-	 * @param ctrl the control to paint on
-	 * @param moveDir degrees of movement
-	 * @param destDir degrees of destination waypoint
+	 * 
+	 * @param ctrl
+	 *            the control to paint on
+	 * @param moveDir
+	 *            degrees of movement
+	 * @param destDir
+	 *            degrees of destination waypoint
 	 */
 
-	public void doDraw(Graphics g,int options) {
+	public void doDraw(Graphics g, int options) {
 		g.setColor(Color.White);
 		g.fillRect(0, 0, location.width, location.height);
 
@@ -512,15 +545,14 @@
 		roseRadius = java.lang.Math.min((location.width * 3) / 4, location.height) / 2;
 
 		if (northCentered) {
-			//scale(location.width, location.height, null, 0);
-			//super.doDraw(g, options);
-			drawFullRose(g, 0, new Color(255,255,255), new Color(200,200,200), new Color(255,255,255), new Color(200,200,200), new Color(150,150,150), new Color(75,75,75), 1.0f, true, true);
-		}
-		else {
-			int radius = (int)(roseRadius * 0.75f);
+			// scale(location.width, location.height, null, 0);
+			// super.doDraw(g, options);
+			drawFullRose(g, 0, new Color(255, 255, 255), new Color(200, 200, 200), new Color(255, 255, 255), new Color(200, 200, 200), new Color(150, 150, 150), new Color(75, 75, 75), 1.0f, true, true);
+		} else {
+			int radius = (int) (roseRadius * 0.75f);
 
-			g.setPen(new Pen(new Color(150,150,150),Pen.SOLID,3));
-			g.drawEllipse(location.width/2 - radius, location.height/2 - radius, 2 * radius, 2 * radius );
+			g.setPen(new Pen(new Color(150, 150, 150), Pen.SOLID, 3));
+			g.drawEllipse(location.width / 2 - radius, location.height / 2 - radius, 2 * radius, 2 * radius);
 		}
 
 		drawArrows(g);
@@ -530,7 +562,7 @@
 		drawGpsStatus(g);
 	}
 
-	private void drawWayPointData(Graphics g){
+	private void drawWayPointData(Graphics g) {
 		String strTemp = MyLocale.getMsg(1512, "Waypoint");
 		g.setColor(Color.DarkBlue);
 		g.fillRect(0, 0, fm.getTextWidth(strTemp) + 4, lineHeight);
@@ -559,29 +591,30 @@
 			threshold = 1.0;
 			newDistance = distance;
 		}
-		if ( newDistance >= 0.0f ) {
+		if (newDistance >= 0.0f) {
 			tmp.set(newDistance);
-			if (tmp.value >= threshold){
-				strTemp = MyLocale.formatDouble(tmp,"0.000")+ " " + Metrics.getUnit(bigUnit);
+			if (tmp.value >= threshold) {
+				strTemp = MyLocale.formatDouble(tmp, "0.000") + " " + Metrics.getUnit(bigUnit);
 			} else {
 				tmp.set(Metrics.convertUnit(tmp.value, bigUnit, smallUnit));
-				strTemp = tmp.toString(3,0,0) + " " + Metrics.getUnit(smallUnit);
+				strTemp = tmp.toString(3, 0, 0) + " " + Metrics.getUnit(smallUnit);
 			}
-		}
-		else strTemp = "--- "+Metrics.getUnit(bigUnit);
+		} else
+			strTemp = "--- " + Metrics.getUnit(bigUnit);
 		g.drawText(strTemp, 2, lineHeight);
 
 		tmp.set(gotoDir);
 		if ((tmp.value <= 360) && (tmp.value >= -360))
-			strTemp = tmp.toString(0,0,0) + " " + MyLocale.getMsg(1502,"deg");
-		else strTemp = "---" + " " + MyLocale.getMsg(1502,"deg");
-		g.drawText(strTemp, 2, 2*lineHeight);
+			strTemp = tmp.toString(0, 0, 0) + " " + MyLocale.getMsg(1502, "deg");
+		else
+			strTemp = "---" + " " + MyLocale.getMsg(1502, "deg");
+		g.drawText(strTemp, 2, 2 * lineHeight);
 	}
 
-	private void drawGpsData(Graphics g){
+	private void drawGpsData(Graphics g) {
 		g.setColor(RED);
 
-		String strHeadline = MyLocale.getMsg(1501,"Current");
+		String strHeadline = MyLocale.getMsg(1501, "Current");
 
 		Double tmp = new Double();
 
@@ -600,17 +633,16 @@
 		}
 		if (tmp.value >= 0) {
 			if (tmp.value >= 100) {
-				strSpeed = MyLocale.formatDouble(tmp,"0") + unit;
+				strSpeed = MyLocale.formatDouble(tmp, "0") + unit;
+			} else {
+				strSpeed = MyLocale.formatDouble(tmp, "0.0") + unit;
 			}
-			else {
-				strSpeed = MyLocale.formatDouble(tmp,"0.0") + unit;
-			}
 		}
 
 		tmp.set(moveDir);
-		String strMoveDir = "---" + " " + MyLocale.getMsg(1502,"deg");
+		String strMoveDir = "---" + " " + MyLocale.getMsg(1502, "deg");
 		if ((tmp.value <= 360) && (tmp.value >= -360))
-			strMoveDir = tmp.toString(0,0,0) + " " + MyLocale.getMsg(1502,"deg");
+			strMoveDir = tmp.toString(0, 0, 0) + " " + MyLocale.getMsg(1502, "deg");
 
 		int textWidth = java.lang.Math.max(fm.getTextWidth(strSpeed), fm.getTextWidth(strMoveDir));
 		textWidth = java.lang.Math.max(textWidth, fm.getTextWidth(strHeadline));
@@ -621,21 +653,21 @@
 		g.setColor(Color.Black);
 		g.drawText(strHeadline, startX + 2, 0);
 		g.drawText(strSpeed, startX + 2, lineHeight);
-		g.drawText(strMoveDir, startX + 2, 2*lineHeight);
+		g.drawText(strMoveDir, startX + 2, 2 * lineHeight);
 	}
 
-	private void drawLuminaryData(Graphics g){
+	private void drawLuminaryData(Graphics g) {
 		g.setColor(YELLOW);
 
-		String strSunDir = "---" + " " + MyLocale.getMsg(1502,"deg");
+		String strSunDir = "---" + " " + MyLocale.getMsg(1502, "deg");
 		if (sunDir < 360 && sunDir > -360) {
 			Double tmp = new Double();
 			tmp.set(sunDir);
-			strSunDir = tmp.toString(0,0,0) + " " + MyLocale.getMsg(1502,"deg");
+			strSunDir = tmp.toString(0, 0, 0) + " " + MyLocale.getMsg(1502, "deg");
 		}
 
 		int textWidth = java.lang.Math.max(fm.getTextWidth(m_Luminary), fm.getTextWidth(strSunDir));
-		int startY = location.height - 2*lineHeight;
+		int startY = location.height - 2 * lineHeight;
 		g.fillRect(0, startY, textWidth + 4, location.height - startY);
 
 		g.setColor(Color.Black);
@@ -643,104 +675,96 @@
 		g.drawText(strSunDir, 2, startY + lineHeight);
 	}
 
-	private void drawGpsStatus(Graphics g){
+	private void drawGpsStatus(Graphics g) {
 		if ((m_fix > 0) && (m_sats >= 0)) {
 			// Set background to signal quality
 			g.setColor(GREEN);
+		} else
+		// receiving data, but signal ist not good
+		if ((m_fix == 0) && (m_sats >= 0)) {
+			g.setColor(YELLOW);
+		} else {
+			g.setColor(RED);
 		}
-		else
-			// receiving data, but signal ist not good
-			if ((m_fix == 0) && (m_sats >= 0)) {
-				g.setColor(YELLOW);
-			}
-			else {
-				g.setColor(RED);
-			}
 
 		String strSats = "Sats: -";
 		if (m_sats >= 0) {
 			strSats = "Sats: " + Convert.toString(m_sats) + "/" + Convert.toString(m_satsInView);
 		}
 		String strHdop = "HDOP: -";
-		if (m_hdop >= 0) strHdop = "HDOP: " + Convert.toString(m_hdop);
+		if (m_hdop >= 0)
+			strHdop = "HDOP: " + Convert.toString(m_hdop);
 
 		int textWidth = java.lang.Math.max(fm.getTextWidth(strSats), fm.getTextWidth(strHdop));
 		int startX = location.width - (textWidth + 4);
-		int startY = location.height - 2*lineHeight;
-		g.fillRect(startX, startY, location.width - startX ,location.height - startY);
+		int startY = location.height - 2 * lineHeight;
+		g.fillRect(startX, startY, location.width - startX, location.height - startY);
 
 		g.setColor(Color.Black);
 		g.drawText(strSats, startX + 2, startY);
 		g.drawText(strHdop, startX + 2, startY + lineHeight);
 	}
 
-	private void drawArrows(Graphics g){
-		if (g != null)
-		{
+	private void drawArrows(Graphics g) {
+		if (g != null) {
 			// select moveDirColor according to difference to gotoDir
 			Color moveDirColor = RED;
 
-			if (gotoDir < 360 && gotoDir > -360 && moveDir < 360 && moveDir > -360)
-			{
+			if (gotoDir < 360 && gotoDir > -360 && moveDir < 360 && moveDir > -360) {
 				float diff = java.lang.Math.abs(moveDir - gotoDir);
-				while (diff > 360)
-				{
+				while (diff > 360) {
 					diff -= 360.0f;
 				}
-				if (diff > 180.0f)
-				{
+				if (diff > 180.0f) {
 					diff = 360.0f - diff;
 				}
 
-				if (diff <= 12.25f)
-				{
+				if (diff <= 12.25f) {
 					moveDirColor = GREEN;
-				}
-				else if (diff <= 22.5f)
-				{
+				} else if (diff <= 22.5f) {
 					moveDirColor = CYAN;
-				}
-				else if (diff <= 45.0f)
-				{
+				} else if (diff <= 45.0f) {
 					moveDirColor = ORANGE;
-				}
-				else if (diff <= 90.0f)
-				{
+				} else if (diff <= 90.0f) {
 					moveDirColor = MAGENTA;
 				}
 			}
 
 			// draw only valid arrows
 			if (northCentered) {
-				if (gotoDir < 360 && gotoDir > -360) drawThickArrow(g, gotoDir, Color.DarkBlue, 1.0f);
-				if (moveDir < 360 && moveDir > -360) drawThinArrow(g, moveDir, RED, moveDirColor, 1.0f);
-				if (sunDir < 360 && sunDir > -360) drawSunArrow(g, sunDir, YELLOW, 0.75f);
-			}
-			else {
-				//moveDir centered
+				if (gotoDir < 360 && gotoDir > -360)
+					drawThickArrow(g, gotoDir, Color.DarkBlue, 1.0f);
+				if (moveDir < 360 && moveDir > -360)
+					drawThinArrow(g, moveDir, RED, moveDirColor, 1.0f);
+				if (sunDir < 360 && sunDir > -360)
+					drawSunArrow(g, sunDir, YELLOW, 0.75f);
+			} else {
+				// moveDir centered
 				if (moveDir < 360 && moveDir > -360) {
-					//drawDoubleArrow(g, 360 - moveDir, BLUE, new Color(175,0,0), 1.0f);
-					//drawRose(g, 360 - moveDir, new Color(100,100,100), new Color(200,200,200), 1.0f);
-					drawFullRose(g, 360 - moveDir, new Color(255,255,255), new Color(200,200,200), new Color(150,150,150), new Color(200,200,200), new Color(200,200,200), new Color(75,75,75), 1.0f, false, false);
+					// drawDoubleArrow(g, 360 - moveDir, BLUE, new Color(175,0,0), 1.0f);
+					// drawRose(g, 360 - moveDir, new Color(100,100,100), new Color(200,200,200), 1.0f);
+					drawFullRose(g, 360 - moveDir, new Color(255, 255, 255), new Color(200, 200, 200), new Color(150, 150, 150), new Color(200, 200, 200), new Color(200, 200, 200), new Color(75, 75, 75), 1.0f, false, false);
 
-					int radius = (int)(roseRadius * 0.75f);
-					g.setPen(new Pen(RED,Pen.SOLID,3));
-					g.drawLine(location.width/2, location.height/2 - radius, location.width/2, location.height/2 + radius);
+					int radius = (int) (roseRadius * 0.75f);
+					g.setPen(new Pen(RED, Pen.SOLID, 3));
+					g.drawLine(location.width / 2, location.height / 2 - radius, location.width / 2, location.height / 2 + radius);
 
-					if (gotoDir < 360 && gotoDir > -360) drawThinArrow(g, gotoDir - moveDir, Color.DarkBlue, moveDirColor, 1.0f);
-					if (sunDir < 360 && sunDir > -360) drawSunArrow(g, sunDir - moveDir, YELLOW, 0.75f);
+					if (gotoDir < 360 && gotoDir > -360)
+						drawThinArrow(g, gotoDir - moveDir, Color.DarkBlue, moveDirColor, 1.0f);
+					if (sunDir < 360 && sunDir > -360)
+						drawSunArrow(g, sunDir - moveDir, YELLOW, 0.75f);
 				}
 			}
 		}
 	}
 
 	private void drawSunArrow(Graphics g, float angle, Color col, float scale) {
-		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
+		float angleRad = (angle) * (float) java.lang.Math.PI / 180;
+		int centerX = location.width / 2, centerY = location.height / 2;
 		float arrowLength = roseRadius * scale;
 		float halfArrowWidth = arrowLength * 0.08f;
 		float circlePos = arrowLength * 0.7f;
-		int circleRadius = (int)(arrowLength * 0.1f);
+		int circleRadius = (int) (arrowLength * 0.1f);
 
 		int circleX = centerX + new Float(circlePos * java.lang.Math.sin(angleRad)).intValue();
 		int circleY = centerY - new Float(circlePos * java.lang.Math.cos(angleRad)).intValue();
@@ -757,20 +781,20 @@
 		pointsX[3] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
 		pointsY[3] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
 
-		//		g.setPen(new Pen(col,Pen.SOLID,3));
-		//		g.drawLine(centerX,centerY,pointX,pointY);
+		// g.setPen(new Pen(col,Pen.SOLID,3));
+		// g.drawLine(centerX,centerY,pointX,pointY);
 
-		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setPen(new Pen(Color.Black, Pen.SOLID, 1));
 		g.setBrush(new Brush(col, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 4);
 		g.fillEllipse(circleX - circleRadius, circleY - circleRadius, 2 * circleRadius, 2 * circleRadius);
 	}
 
 	private void drawThinArrow(Graphics g, float angle, Color col, Color colPoint, float scale) {
-		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
+		float angleRad = (angle) * (float) java.lang.Math.PI / 180;
+		int centerX = location.width / 2, centerY = location.height / 2;
 		float arrowLength = roseRadius * scale;
-		float halfOpeningAngle = (float)(java.lang.Math.PI * 0.03);
+		float halfOpeningAngle = (float) (java.lang.Math.PI * 0.03);
 		float sideLineLength = arrowLength * 0.75f;
 
 		int[] pointsX = new int[4];
@@ -785,7 +809,7 @@
 		pointsX[3] = centerX;
 		pointsY[3] = centerY;
 
-		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setPen(new Pen(Color.Black, Pen.SOLID, 1));
 		g.setBrush(new Brush(col, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 4);
 		if (colPoint != null) {
@@ -794,29 +818,28 @@
 		}
 	}
 
-	private void drawFullRose(Graphics g, float angle, Color colLeft, Color colRight, Color colNorthLeft, Color colNorthRight,
-			Color colBorder, Color colText, float scale, boolean bDrawText, boolean bDrawEightArrows) {
+	private void drawFullRose(Graphics g, float angle, Color colLeft, Color colRight, Color colNorthLeft, Color colNorthRight, Color colBorder, Color colText, float scale, boolean bDrawText, boolean bDrawEightArrows) {
 		float subScale1 = 1.0f;
 		float subScale2 = 0.9f;
 		float innerScale = 0.15f;
-		if(bDrawEightArrows){
+		if (bDrawEightArrows) {
 			innerScale = 0.12f;
-			drawRosePart(g,  45 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, "NE", bDrawText);
+			drawRosePart(g, 45 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, "NE", bDrawText);
 			drawRosePart(g, 135 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, "SE", bDrawText);
 			drawRosePart(g, 225 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, "SW", bDrawText);
 			drawRosePart(g, 315 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, "NW", bDrawText);
 		}
 
-		drawRosePart(g,   0 + angle, colNorthLeft, colNorthRight, colBorder, colText, scale * subScale1, innerScale, "N", bDrawText);
-		drawRosePart(g,  90 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, "E", bDrawText);
+		drawRosePart(g, 0 + angle, colNorthLeft, colNorthRight, colBorder, colText, scale * subScale1, innerScale, "N", bDrawText);
+		drawRosePart(g, 90 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, "E", bDrawText);
 		drawRosePart(g, 180 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, "S", bDrawText);
 		drawRosePart(g, 270 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, "W", bDrawText);
 	}
 
 	private void drawRosePart(Graphics g, float angle, Color colLeft, Color colRight, Color colBorder, Color colText, float scale, float innerScale, String strDir, boolean bDrawText) {
-		float angleRad = angle * (float)java.lang.Math.PI / 180;
-		float angleRadText = (angle + 7.5f) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
+		float angleRad = angle * (float) java.lang.Math.PI / 180;
+		float angleRadText = (angle + 7.5f) * (float) java.lang.Math.PI / 180;
+		int centerX = location.width / 2, centerY = location.height / 2;
 
 		float arrowLength = roseRadius * scale;
 		float halfArrowWidth = arrowLength * innerScale;
@@ -831,7 +854,7 @@
 		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 4.0)).intValue();
 		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 4.0)).intValue();
 
-		g.setPen(new Pen(colBorder,Pen.SOLID,1));
+		g.setPen(new Pen(colBorder, Pen.SOLID, 1));
 		g.setBrush(new Brush(colLeft, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 3);
 
@@ -841,27 +864,26 @@
 		g.setBrush(new Brush(colRight, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 3);
 
-		if (bDrawText){
+		if (bDrawText) {
 			int tempFontSize = new Float(scale * mainFont.getSize()).intValue();
 			Font tempFont = new Font(mainFont.getName(), Font.BOLD, tempFontSize);
 			g.setFont(tempFont);
 			FontMetrics tempFm = g.getFontMetrics(tempFont);
 			float stringHeight = tempFm.getHeight();
-			float stringWidth = tempFm.getTextWidth( strDir );
-			float stringGap = (float)java.lang.Math.sqrt(stringHeight*stringHeight + stringWidth*stringWidth);
+			float stringWidth = tempFm.getTextWidth(strDir);
+			float stringGap = (float) java.lang.Math.sqrt(stringHeight * stringHeight + stringWidth * stringWidth);
 
 			float stringPosition = arrowLength - stringGap / 2.0f;
 			g.setColor(colText);
-			g.drawText(strDir, centerX + new Float(stringPosition * java.lang.Math.sin(angleRadText) - stringWidth / 2.0f).intValue(),
-					centerY - new Float(stringPosition * java.lang.Math.cos(angleRadText) + stringHeight / 2.0f).intValue());
+			g.drawText(strDir, centerX + new Float(stringPosition * java.lang.Math.sin(angleRadText) - stringWidth / 2.0f).intValue(), centerY - new Float(stringPosition * java.lang.Math.cos(angleRadText) + stringHeight / 2.0f).intValue());
 
 			g.setFont(mainFont);
 		}
 	}
 
 	private void drawThickArrow(Graphics g, float angle, Color col, float scale) {
-		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
+		float angleRad = (angle) * (float) java.lang.Math.PI / 180;
+		int centerX = location.width / 2, centerY = location.height / 2;
 		float arrowLength = roseRadius * scale;
 		float halfArrowWidth = arrowLength * 0.1f;
 
@@ -877,7 +899,7 @@
 		pointsX[3] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
 		pointsY[3] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
 
-		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setPen(new Pen(Color.Black, Pen.SOLID, 1));
 		g.setBrush(new Brush(col, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 4);
 	}
@@ -900,15 +922,14 @@
 		FontMetrics metrics = g.getFontMetrics(newFont);
 		int fontHeight = metrics.getHeight();
 
-		float ratio = (float)fontHeight / (float)size;
-		if(ratio < 0.9 || ratio > 1.1){
+		float ratio = (float) fontHeight / (float) size;
+		if (ratio < 0.9 || ratio > 1.1) {
 			size = (int) (size / ratio + 0.5);
-			if(size<5)
-				size=5;
+			if (size < 5)
+				size = 5;
 			newFont = new Font(name, style, size);
 		}
 
 		return newFont;
 	}
 }
-

Modified: trunk/src/CacheWolf/navi/MapLoader.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoader.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/navi/MapLoader.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -56,18 +56,16 @@
 import ewe.util.Vector;
 import ewe.util.mString;
 
-
 /**
- *
+ * 
  * start offset for language file: 4800
  */
 
-//Um Karten zu holen!
-//http://www.expedia.de/pub/agent.dll?qscr=mrdt&ID=3kQaz.&CenP=48.09901667,11.35688333&Lang=EUR0407&Alti=1&Size=600,600&Offs=0.000000,0.000000&Pins=|5748|
-//oder
-//http://www.expedia.de/pub/agent.dll?qscr=mrdt&ID=3kQaz.&CenP=48.15,11.5833&Alti=2&Lang=EUR0407&Size=900,900&Offs=0,0&MapS=0&Pins=|48.15,11.5833|4|48.15,11.5833&Pins=|48.15,11.5833|1|48.15,%2011.5833||
+// Um Karten zu holen!
+// http://www.expedia.de/pub/agent.dll?qscr=mrdt&ID=3kQaz.&CenP=48.09901667,11.35688333&Lang=EUR0407&Alti=1&Size=600,600&Offs=0.000000,0.000000&Pins=|5748|
+// oder
+// http://www.expedia.de/pub/agent.dll?qscr=mrdt&ID=3kQaz.&CenP=48.15,11.5833&Alti=2&Lang=EUR0407&Size=900,900&Offs=0,0&MapS=0&Pins=|48.15,11.5833|4|48.15,11.5833&Pins=|48.15,11.5833|1|48.15,%2011.5833||
 
-
 public class MapLoader {
 	InfoBox progressInfobox;
 
@@ -81,15 +79,16 @@
 	CWPoint bottomright;
 	Point tilesSize;
 	float tileScale;
-	boolean fetchOnlyMapWithCache=false;
+	boolean fetchOnlyMapWithCache = false;
 
 	/**
-	 *
+	 * 
 	 * @param prxy
 	 * @param prt
-	 * @param wmspath without trailing "/"
+	 * @param wmspath
+	 *            without trailing "/"
 	 */
-	public MapLoader(String wmspath){
+	public MapLoader(String wmspath) {
 		long start = new Time().getTime();
 		InfoBox progressBox = null;
 		boolean showprogress = false;
@@ -100,11 +99,11 @@
 		String FileName;
 		OnlineMapService tempOMS;
 		MessageBox f = null;
-		dateien = files.list("*.wms", FileBase.LIST_FILES_ONLY); //"*.xyz" doesn't work on some systems -> use FileBugFix
-		for(int i = 0; i < dateien.length;i++){
+		dateien = files.list("*.wms", FileBase.LIST_FILES_ONLY); // "*.xyz" doesn't work on some systems -> use FileBugFix
+		for (int i = 0; i < dateien.length; i++) {
 			FileName = dateien[i];
 			try {
-				if (!showprogress && ((i & 0) == 0) && (new Time().getTime()-start  > 100) ) { // reason for (i & 7 == 0): test time only after i is incremented 15 times
+				if (!showprogress && ((i & 0) == 0) && (new Time().getTime() - start > 100)) { // reason for (i & 7 == 0): test time only after i is incremented 15 times
 					showprogress = true;
 					progressBox = new InfoBox(MyLocale.getMsg(327, "Info"), MyLocale.getMsg(4800, "Loading online map services"));
 					progressBox.exec();
@@ -113,8 +112,9 @@
 				}
 				tempOMS = new WebMapService(STRreplace.replace(wmspath + "/" + FileName, "//", "/"));
 				onlineMapServices.add(tempOMS);
-			}catch(Exception ex){
-				if (f == null) (f=new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(4801, "Ignoring error while \n reading web map service definition file \n")+ex.toString(), FormBase.OKB)).exec();
+			} catch (Exception ex) {
+				if (f == null)
+					(f = new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(4801, "Ignoring error while \n reading web map service definition file \n") + ex.toString(), FormBase.OKB)).exec();
 			}
 		}
 		tempOMS = new ExpediaMapService();
@@ -126,29 +126,32 @@
 	}
 
 	public void setFetchOnlyMapWithCache(boolean value) {
-		fetchOnlyMapWithCache=value;
+		fetchOnlyMapWithCache = value;
 	}
 
-	public String[] getAvailableOnlineMapServices(){
+	public String[] getAvailableOnlineMapServices() {
 		int s = onlineMapServices.size();
 		String[] services = new String[s];
-		for (int i=0; i < s; i++) {
-			services[i]=onlineMapServices.get(i).toString();
+		for (int i = 0; i < s; i++) {
+			services[i] = onlineMapServices.get(i).toString();
 		}
 		return services;
 	}
 
 	public void setCurrentMapService(int index) {
-		if (index==-1) index=0; // if no center set
+		if (index == -1)
+			index = 0; // if no center set
 		currentOnlineMapService = (OnlineMapService) onlineMapServices.get(index);
 	}
 
 	/**
 	 * calculates the Expedia Alti = scale which fits in distance to its edges
+	 * 
 	 * @param center
-	 * @param distance in meters
+	 * @param distance
+	 *            in meters
 	 * @return meters per pixel calculatet in a way that the circle around center
-	 * is completly within the map
+	 *         is completly within the map
 	 */
 
 	public static float getScale(CWPoint center, float distance, Point size) {
@@ -161,17 +164,24 @@
 	/**
 	 * download maps from expedia at zoomlevel alti and save the maps and the .wfl
 	 * in path
-	 * @param center centre of all tiles
-	 * @param radius in meters
-	 * @param scale in "alti" value 1 alti =  3950 /2817.947378 = 1,046861280317350198581316446428 meters per pixel
-	 * @param size in pixels
-	 * @param overlapping in pixels
-	 * @param path without "/" at the end
-	 *
+	 * 
+	 * @param center
+	 *            centre of all tiles
+	 * @param radius
+	 *            in meters
+	 * @param scale
+	 *            in "alti" value 1 alti = 3950 /2817.947378 = 1,046861280317350198581316446428 meters per pixel
+	 * @param size
+	 *            in pixels
+	 * @param overlapping
+	 *            in pixels
+	 * @param path
+	 *            without "/" at the end
+	 * 
 	 */
-	public void setTiles (CWPoint center, float radius, float scale, Point size, int overlapping) {
-		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double metersPerLon = metersPerLat * java.lang.Math.cos(center.latDec/180*java.lang.Math.PI);
+	public void setTiles(CWPoint center, float radius, float scale, Point size, int overlapping) {
+		double metersPerLat = (1000 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
+		double metersPerLon = metersPerLat * java.lang.Math.cos(center.latDec / 180 * java.lang.Math.PI);
 		topleft = new CWPoint(center.latDec + (radius / metersPerLat), center.lonDec - (radius / metersPerLon));
 		bottomright = new CWPoint(center.latDec - (radius / metersPerLat), center.lonDec + (radius / metersPerLon));
 
@@ -179,41 +189,41 @@
 	}
 
 	public void setTiles(CWPoint toplefti, CWPoint bottomrighti, float scale, Point size, int overlapping) {
-		//if (toplefti.latDec <= bottomrighti.latDec || toplefti.lonDec >= toplefti.lonDec) throw new IllegalArgumentException("topleft must be left and above bottom right");
+		// if (toplefti.latDec <= bottomrighti.latDec || toplefti.lonDec >= toplefti.lonDec) throw new IllegalArgumentException("topleft must be left and above bottom right");
 		topleft = new CWPoint(toplefti);
 		bottomright = new CWPoint(bottomrighti);
-		double metersPerLat = (1000.0 * (new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + bottomright.latDec)/2/180*java.lang.Math.PI);
+		double metersPerLat = (1000.0 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
+		double metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + bottomright.latDec) / 2 / 180 * java.lang.Math.PI);
 		double metersperpixel = currentOnlineMapService.getMetersPerPixel(scale);
 		double pixelsPerLat = metersPerLat / metersperpixel;
 		double pixelsPerLon = metersPerLon / metersperpixel;
 
-		//over all pixelsize without borders
+		// over all pixelsize without borders
 		double pixelsY = (topleft.latDec - bottomright.latDec) * pixelsPerLat;
-		double pixelsX = -(topleft.lonDec - bottomright.lonDec) * pixelsPerLon ;
+		double pixelsX = -(topleft.lonDec - bottomright.lonDec) * pixelsPerLon;
 
-		//border sizes around given area and overlapping between tiles
-		//int borderX = (int) java.lang.Math.round((float)size.x * (overlapping - 1.0));
-		//int borderY = (int) java.lang.Math.round((float)size.y * (overlapping - 1.0));
+		// border sizes around given area and overlapping between tiles
+		// int borderX = (int) java.lang.Math.round((float)size.x * (overlapping - 1.0));
+		// int borderY = (int) java.lang.Math.round((float)size.y * (overlapping - 1.0));
 		int borderX = overlapping;
 		int borderY = overlapping;
 
-		numMapsY = (int) java.lang.Math.ceil( (pixelsY + borderY) / (size.y - borderY) );
-		numMapsX = (int) java.lang.Math.ceil( (pixelsX + borderX) / (size.x - borderX) );
+		numMapsY = (int) java.lang.Math.ceil((pixelsY + borderY) / (size.y - borderY));
+		numMapsX = (int) java.lang.Math.ceil((pixelsX + borderX) / (size.x - borderX));
 
-		//increments calulated from pixel offset of tiles
+		// increments calulated from pixel offset of tiles
 		latinc = -(size.y - borderY) / pixelsPerLat;
 		loninc = (size.x - borderX) / pixelsPerLon;
 
-		//calculation of centre of first tile
+		// calculation of centre of first tile
 
-		//additional size for borders and rounding
+		// additional size for borders and rounding
 		double oversizeX = (numMapsX * (size.x - borderX) + borderX) - pixelsX;
 		double oversizeY = (numMapsY * (size.y - borderY) + borderY) - pixelsY;
 
-		//offset for upper left corner
-		double offsetLat = -( (size.y - oversizeY) / 2.0 ) / pixelsPerLat;
-		double offsetLon = ( (size.x - oversizeX) / 2.0 ) / pixelsPerLon;
+		// offset for upper left corner
+		double offsetLat = -((size.y - oversizeY) / 2.0) / pixelsPerLat;
+		double offsetLon = ((size.x - oversizeX) / 2.0) / pixelsPerLon;
 
 		topleft.latDec += offsetLat;
 		topleft.lonDec += offsetLon;
@@ -231,48 +241,53 @@
 			lon = topleft.lonDec;
 			for (int col = 1; col <= numMapsX; col++) {
 				center.set(lat, lon);
-				if (!fetchOnlyMapWithCache || hasCache(center,latinc,loninc)) {
+				if (!fetchOnlyMapWithCache || hasCache(center, latinc, loninc)) {
 					if (progressInfobox != null)
-						progressInfobox.setInfo(MyLocale.getMsg(4802, "Downloading calibrated (georeferenced) \n map image \n '") + currentOnlineMapService.getName()+MyLocale.getMsg(4803, "' \n Downloading tile \n row")+" "+row+" / "+numMapsY+MyLocale.getMsg(4804, " column")+" "+ col + " / "+numMapsX);
+						progressInfobox.setInfo(MyLocale.getMsg(4802, "Downloading calibrated (georeferenced) \n map image \n '") + currentOnlineMapService.getName() + MyLocale.getMsg(4803, "' \n Downloading tile \n row") + " " + row + " / " + numMapsY
+								+ MyLocale.getMsg(4804, " column") + " " + col + " / " + numMapsX);
 					try {
 						downloadMap(center, tileScale, tilesSize, tilesPath);
 					} catch (Exception e) {
-						this.progressInfobox.addWarning(MyLocale.getMsg(4805, "Tile")+" " + row + "/" + col + MyLocale.getMsg(4806, ": Ignoring error:")+" " + e.getMessage()+"\n");
+						this.progressInfobox.addWarning(MyLocale.getMsg(4805, "Tile") + " " + row + "/" + col + MyLocale.getMsg(4806, ": Ignoring error:") + " " + e.getMessage() + "\n");
 					}
-					if (progressInfobox.isClosed) return;
+					if (progressInfobox.isClosed)
+						return;
 				}
 				lon += loninc;
 			}
 			lat += latinc;
 		}
 	}
+
 	private boolean hasCache(CWPoint center, double latinc, double loninc) {
 		double lat = center.latDec - (latinc / 2.0);
 		double lon = center.lonDec - (loninc / 2.0);
-		CWPoint tl = new CWPoint(lat,lon);
+		CWPoint tl = new CWPoint(lat, lon);
 		lat = center.latDec + (latinc / 2.0);
 		lon = center.lonDec + (loninc / 2.0);
-		CWPoint br = new CWPoint(lat,lon);
-		Area maparea = new Area(tl,br);
+		CWPoint br = new CWPoint(lat, lon);
+		Area maparea = new Area(tl, br);
 		CacheDB cacheDB = Global.getProfile().cacheDB;
 		for (int i = 0; i < cacheDB.size(); i++) {
 			CacheHolder ch = cacheDB.get(i);
-			if (maparea.isInBound(ch.pos)) {
+			if (maparea.isInBound(ch.getPos())) {
 				return true;
 			}
 		}
 		return false;
 	}
 
-	public void setProgressInfoBox (InfoBox progrssInfoboxi) {
+	public void setProgressInfoBox(InfoBox progrssInfoboxi) {
 		progressInfobox = progrssInfoboxi;
 	}
+
 	/**
-	 *
+	 * 
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
-	 * @param path must include trailing "/"
+	 * @param path
+	 *            must include trailing "/"
 	 * @throws Exception
 	 */
 	public void downloadMap(CWPoint center, float scale, Point pixelsize, String path) throws Exception {
@@ -284,26 +299,24 @@
 		String fName = path + imagename + imagetype;
 		FileBugfix fn = new FileBugfix(path + imagename + ".wfl");
 		FileBugfix fn1 = new FileBugfix(fName);
-		if (!fn.exists() || fn.length()==0 || !fn1.exists() || fn1.length()==0) {
+		if (!fn.exists() || fn.length() == 0 || !fn1.exists() || fn1.length() == 0) {
 			if (currentOnlineMapService instanceof ExpediaMapService) {
-				downloadImage(url, path+imagename+imagetype);
-			}
-			else {
+				downloadImage(url, path + imagename + imagetype);
+			} else {
 				WebMapService wms = (WebMapService) currentOnlineMapService;
 				if (wms.requestUrlPart.startsWith("REQUEST")) {
-					downloadImage(url, path+imagename+imagetype);
-				}
-				else {
+					downloadImage(url, path + imagename + imagetype);
+				} else {
 					Area maparea = wms.CenterScaleToArea(center, scale, pixelsize);
-					CWPoint bottomleft = new CWPoint (maparea.bottomright.latDec, maparea.topleft.lonDec);
-					CWPoint topright = new CWPoint (maparea.topleft.latDec, maparea.bottomright.lonDec);
+					CWPoint bottomleft = new CWPoint(maparea.bottomright.latDec, maparea.topleft.lonDec);
+					CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.bottomright.lonDec);
 
-					String mapProgramPath = wms.versionUrlPart+"/";
+					String mapProgramPath = wms.versionUrlPart + "/";
 					mapProgramPath = mapProgramPath.replace('/', FileBase.separatorChar);
-					String mapProgram = mapProgramPath+wms.MainUrl;
-					File f=new FileBugfix(mapProgram);
+					String mapProgram = mapProgramPath + wms.MainUrl;
+					File f = new FileBugfix(mapProgram);
 					if (!f.exists() || !f.canRead()) {
-						MessageBox mb=new MessageBox(MyLocale.getMsg(321,"Error"),MyLocale.getMsg(1834,"Please enter the correct path to Kosmos.Console.exe into the wms-file."),ewe.ui.MessageBox.OKB);
+						MessageBox mb = new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1834, "Please enter the correct path to Kosmos.Console.exe into the wms-file."), ewe.ui.MessageBox.OKB);
 						mb.execute();
 						return;
 					}
@@ -312,68 +325,59 @@
 
 					if (wms.requestUrlPart.equalsIgnoreCase("Kosmos")) {
 						// minx miny maxx maxy + pixelsize.x
-						mapProgramParams="bitmapgen" +
-							" \""+FileBase.getProgramDirectory().replace('/',File.separatorChar)+"\\"+wms.serviceTypeUrlPart+"\""+
-							" \""+path.replace('/', File.separatorChar)+imagename+imagetype+"\""+
-							" -mb " +
-							bottomleft.toString(TransformCoordinates.LAT_LON).replace(',',' ') + " " +
-							topright.toString(TransformCoordinates.LAT_LON).replace(',',' ') +
-							" -w "+pixelsize.x;
+						mapProgramParams = "bitmapgen" + " \"" + FileBase.getProgramDirectory().replace('/', File.separatorChar) + "\\" + wms.serviceTypeUrlPart + "\"" + " \"" + path.replace('/', File.separatorChar) + imagename + imagetype + "\""
+								+ " -mb " + bottomleft.toString(TransformCoordinates.LAT_LON).replace(',', ' ') + " " + topright.toString(TransformCoordinates.LAT_LON).replace(',', ' ') + " -w " + pixelsize.x;
 						Vm.exec(mapProgram, mapProgramParams, 0, true);
-					}
-					else {
+					} else {
 						if (wms.requestUrlPart.equalsIgnoreCase("Maperitive")) {
 							// Maperitive runs on Windows and Linux
 							// generating scriptfile for Maperitive from wmsfile
-							String cwPath = FileBase.getProgramDirectory().replace('/',FileBase.separatorChar) + FileBase.separatorChar;
+							String cwPath = FileBase.getProgramDirectory().replace('/', FileBase.separatorChar) + FileBase.separatorChar;
 							String scriptFileName = cwPath + "maperitive.script";
 
-							PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(scriptFileName)));
+							PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(scriptFileName)));
 							outp.println("use-ruleset alias=default");
 							outp.println("clear-map");
 
 							if (wms.serviceTypeUrlPart.equals("")) {
 								outp.println("add-web-map");
-							}
-							else {
+							} else {
 								outp.println("add-web-map provider=" + wms.serviceTypeUrlPart);
 							}
 
 							if (!wms.stylesUrlPart.equals("")) {
-								String myrules = mapProgramPath + wms.stylesUrlPart.replace('/',FileBase.separatorChar);
+								String myrules = mapProgramPath + wms.stylesUrlPart.replace('/', FileBase.separatorChar);
 								outp.println("use-ruleset location=" + myrules);
 								// outp.println("apply-ruleset");
 							}
 							if (!wms.layersUrlPart.equals("")) {
 								outp.println("clear-map");
-								outp.println("load-source " + mapProgramPath + wms.layersUrlPart.replace('/',FileBase.separatorChar));
+								outp.println("load-source " + mapProgramPath + wms.layersUrlPart.replace('/', FileBase.separatorChar));
 								// implicit does apply-ruleset
 							}
 
 							String koords = bottomleft.toString(TransformCoordinates.LON_LAT) + "," + topright.toString(TransformCoordinates.LON_LAT);
-							outp.println("bounds-set "+koords);
+							outp.println("bounds-set " + koords);
 							outp.println("zoom-bounds");
-							if ( path.indexOf(':') == 1) {
+							if (path.indexOf(':') == 1) {
 								outp.print("export-bitmap file=" + "\"" + fName + "\"");
-							}
-							else {
+							} else {
 								outp.print("export-bitmap file=" + fName);
 							}
-							outp.print(" bounds="+ koords);
-							String pxSize = " width="+pixelsize.x + " height="+pixelsize.y;
+							outp.print(" bounds=" + koords);
+							String pxSize = " width=" + pixelsize.x + " height=" + pixelsize.y;
 							outp.print(pxSize);
 							outp.println(" kml=false");
 							outp.close();
 							// executing the generated script
 							if (mapProgram.indexOf(':') == 1) {
 								mapProgramParams = "-exitafter " + "\"" + scriptFileName + "\"";
-							}
-							else {
+							} else {
 								mapProgramParams = "-exitafter " + scriptFileName;
 							}
 							Vm.exec(mapProgram, mapProgramParams, 0, true);
 							// preparation for generating wfl from the ozi map-file
-							Vector GCPs = map2wfl(path+imagename);
+							Vector GCPs = map2wfl(path + imagename);
 							mio.evalGCP(GCPs, pixelsize.x, pixelsize.y);
 							// can not supress genaration of pgw,jgw-file
 							FileBugfix pgwFile = new FileBugfix(path + imagename + ".pgw"); // seems to bee for png
@@ -391,54 +395,62 @@
 	private Vector map2wfl(String pathAndImageName) {
 		Vector GCPs = new Vector();
 		File mapFile = new File(pathAndImageName + ".map");
-		if(mapFile.exists()){
+		if (mapFile.exists()) {
 			GCPoint gcp1 = new GCPoint();
 			GCPoint gcp2 = new GCPoint();
 			GCPoint gcp3 = new GCPoint();
 			GCPoint gcp4 = new GCPoint();
 			GCPoint gcpG = new GCPoint();
-			String line="";
+			String line = "";
 			String[] parts;
 			try {
 				FileReader inMap = new FileReader(pathAndImageName + ".map");
-				while((line = inMap.readLine()) != null){
-					if(line.equals("MMPNUM,4")){
+				while ((line = inMap.readLine()) != null) {
+					if (line.equals("MMPNUM,4")) {
 
 						line = inMap.readLine();
 						parts = mString.split(line, ',');
 						gcp1.bitMapX = Convert.toInt(parts[2]);
 						gcp1.bitMapY = Convert.toInt(parts[3]);
-						if(gcp1.bitMapX == 0) gcp1.bitMapX = 1;
-						if(gcp1.bitMapY == 0) gcp1.bitMapY = 1;
+						if (gcp1.bitMapX == 0)
+							gcp1.bitMapX = 1;
+						if (gcp1.bitMapY == 0)
+							gcp1.bitMapY = 1;
 
 						line = inMap.readLine();
 						parts = mString.split(line, ',');
 						gcp2.bitMapX = Convert.toInt(parts[2]);
 						gcp2.bitMapY = Convert.toInt(parts[3]);
-						if(gcp2.bitMapX == 0) gcp2.bitMapX = 1;
-						if(gcp2.bitMapY == 0) gcp2.bitMapY = 1;
+						if (gcp2.bitMapX == 0)
+							gcp2.bitMapX = 1;
+						if (gcp2.bitMapY == 0)
+							gcp2.bitMapY = 1;
 
 						line = inMap.readLine();
 						parts = mString.split(line, ',');
 						gcp3.bitMapX = Convert.toInt(parts[2]);
 						gcp3.bitMapY = Convert.toInt(parts[3]);
-						if(gcp3.bitMapX == 0) gcp3.bitMapX = 1;
-						if(gcp3.bitMapY == 0) gcp3.bitMapY = 1;
-						//imageWidth = gcp3.bitMapX;
-						//imageHeight = gcp3.bitMapY;
+						if (gcp3.bitMapX == 0)
+							gcp3.bitMapX = 1;
+						if (gcp3.bitMapY == 0)
+							gcp3.bitMapY = 1;
+						// imageWidth = gcp3.bitMapX;
+						// imageHeight = gcp3.bitMapY;
 
 						line = inMap.readLine();
 						parts = mString.split(line, ',');
 						gcp4.bitMapX = Convert.toInt(parts[2]);
 						gcp4.bitMapY = Convert.toInt(parts[3]);
-						if(gcp4.bitMapX == 0) gcp4.bitMapX = 1;
-						if(gcp4.bitMapY == 0) gcp4.bitMapY = 1;
+						if (gcp4.bitMapX == 0)
+							gcp4.bitMapX = 1;
+						if (gcp4.bitMapY == 0)
+							gcp4.bitMapY = 1;
 
 						line = inMap.readLine();
 						parts = mString.split(line, ',');
-						if(MyLocale.getDigSeparator().equals(",")) {
-							parts[3]= parts[3].replace('.', ',');
-							parts[2]= parts[2].replace('.', ',');
+						if (MyLocale.getDigSeparator().equals(",")) {
+							parts[3] = parts[3].replace('.', ',');
+							parts[2] = parts[2].replace('.', ',');
 						}
 						gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
 						gcpG.bitMapX = gcp1.bitMapX;
@@ -447,9 +459,9 @@
 
 						line = inMap.readLine();
 						parts = mString.split(line, ',');
-						if(MyLocale.getDigSeparator().equals(",")) {
-							parts[3]= parts[3].replace('.', ',');
-							parts[2]= parts[2].replace('.', ',');
+						if (MyLocale.getDigSeparator().equals(",")) {
+							parts[3] = parts[3].replace('.', ',');
+							parts[2] = parts[2].replace('.', ',');
 						}
 						gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
 						gcpG.bitMapX = gcp2.bitMapX;
@@ -458,9 +470,9 @@
 
 						line = inMap.readLine();
 						parts = mString.split(line, ',');
-						if(MyLocale.getDigSeparator().equals(",")) {
-							parts[3]= parts[3].replace('.', ',');
-							parts[2]= parts[2].replace('.', ',');
+						if (MyLocale.getDigSeparator().equals(",")) {
+							parts[3] = parts[3].replace('.', ',');
+							parts[2] = parts[2].replace('.', ',');
 						}
 						gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
 						gcpG.bitMapX = gcp3.bitMapX;
@@ -469,9 +481,9 @@
 
 						line = inMap.readLine();
 						parts = mString.split(line, ',');
-						if(MyLocale.getDigSeparator().equals(",")) {
-							parts[3]= parts[3].replace('.', ',');
-							parts[2]= parts[2].replace('.', ',');
+						if (MyLocale.getDigSeparator().equals(",")) {
+							parts[3] = parts[3].replace('.', ',');
+							parts[2] = parts[2].replace('.', ',');
 						}
 						gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
 						gcpG.bitMapX = gcp4.bitMapX;
@@ -480,9 +492,9 @@
 					} // if
 				} // while
 				inMap.close();
-			} catch(IllegalArgumentException ex){ // is thrown from Convert.toDouble and saveWFL if affine[0-5]==0 NumberFormatException is a subclass of IllegalArgumentExepction
+			} catch (IllegalArgumentException ex) { // is thrown from Convert.toDouble and saveWFL if affine[0-5]==0 NumberFormatException is a subclass of IllegalArgumentExepction
 				Global.getPref().log(MyLocale.getMsg(4117, "Error while importing .map-file: "), ex);
-			} catch(IOException ex){
+			} catch (IOException ex) {
 				Global.getPref().log(MyLocale.getMsg(4118, "IO-Error while reading or writing calibration file"), ex);
 			}
 			mapFile.delete();
@@ -493,17 +505,18 @@
 	}
 
 	public String createFilename(CWPoint center, float scale) {
-		String filename = Common.ClearForFileName(currentOnlineMapService.getNameForFileSystem()+"_s"+Common.DoubleToString(scale,0,1)
-				+ "_c" + center.toString(TransformCoordinates.LAT_LON).replace(',', '-'));
+		String filename = Common.ClearForFileName(currentOnlineMapService.getNameForFileSystem() + "_s" + Common.DoubleToString(scale, 0, 1) + "_c" + center.toString(TransformCoordinates.LAT_LON).replace(',', '-'));
 		return filename;
 	}
 
 	/**
-	 * @param url usual URL. If a redirect is requiered (as in the case of
-	 * Expedia, add an "R" before "http://" --> Don't download the url, retry until getting a http-redirect
-	 * this is necessary for expedia as it delivers the image only after a http-redirect
-	 * and sometimes doesn't send a redirect on the first try
-	 * @param datei path and name of file to save to
+	 * @param url
+	 *            usual URL. If a redirect is requiered (as in the case of
+	 *            Expedia, add an "R" before "http://" --> Don't download the url, retry until getting a http-redirect
+	 *            this is necessary for expedia as it delivers the image only after a http-redirect
+	 *            and sometimes doesn't send a redirect on the first try
+	 * @param datei
+	 *            path and name of file to save to
 	 */
 	public void downloadImage(String url, String datei) throws IOException {
 		String realurl;
@@ -516,19 +529,20 @@
 			realurl = url;
 		}
 		File dateiF = new FileBugfix(datei);
-		if(!dateiF.exists()){
-			if (forceredirect) UrlFetcher.setForceRedirect();
+		if (!dateiF.exists()) {
+			if (forceredirect)
+				UrlFetcher.setForceRedirect();
 			UrlFetcher.fetchDataFile(realurl, datei);
-			String ct=null;
+			String ct = null;
 			try {
-				ct = (String) UrlFetcher.getDocumentProperties().getValue("content-type","no-content-type provided");
+				ct = (String) UrlFetcher.getDocumentProperties().getValue("content-type", "no-content-type provided");
 			} catch (Exception e) {
-				ct="document property content-type does not exist!";
+				ct = "document property content-type does not exist!";
 			}
-			if (!ct.substring(0, 5).equalsIgnoreCase("image") )  {
+			if (!ct.substring(0, 5).equalsIgnoreCase("image")) {
 				dateiF = new FileBugfix(datei);
 				dateiF.delete();
-				throw new IOException(MyLocale.getMsg(4808, "downloadImage: content-type:")+" " + ct + MyLocale.getMsg(4809, " is not an image, begin of content:")+" (deleted)");
+				throw new IOException(MyLocale.getMsg(4808, "downloadImage: content-type:") + " " + ct + MyLocale.getMsg(4809, " is not an image, begin of content:") + " (deleted)");
 			}
 		}
 	}
@@ -541,7 +555,7 @@
 	String mapType;
 	/** Esentially the same as name, but used for the file system. It will be part of the names of the downloaded images */
 	String filename;
-	String MainUrl; //http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS
+	String MainUrl; // http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS
 	/** including "." */
 	String imageFileExt; // ".gif", ".jpg"...
 	double recommendedScales[];
@@ -554,7 +568,7 @@
 	 * This method is used in case the online map service provides only certain steps of
 	 * zoomlevels. In this case the scale in meters per pixel must be returned, which
 	 * will be used instead of the wished scale.
-	 *
+	 * 
 	 * @param scale
 	 * @return
 	 */
@@ -568,6 +582,7 @@
 
 	/**
 	 * Overlaod this to integrate name of layers
+	 * 
 	 * @return friendly service name
 	 */
 	public String getName() {
@@ -578,6 +593,7 @@
 	 * This method is called to get a name of the
 	 * online map service which will be part of the filename
 	 * used for the downloaded image
+	 * 
 	 * @return friendly service name
 	 */
 	public String getNameForFileSystem() {
@@ -587,10 +603,12 @@
 	public String getMapType() {
 		return mapType;
 	}
+
 	/**
 	 * Overload this and return the URL to the map image, don't call super
 	 * Alternatively overload getUrlForBoundingBoxInternal
 	 * You must overload either this method or getUrlForBoundingBox
+	 * 
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -606,6 +624,7 @@
 	 * This is made protected and named "...Internal" because a lot of services
 	 * don't work correctly when a map is requested, that is not exactly quadratic
 	 * --> alway use getUrlForCenter...
+	 * 
 	 * @param surArea
 	 * @param pixelsize
 	 * @return
@@ -617,6 +636,7 @@
 	/**
 	 * overload this if your map service uses a special projection
 	 * an return an Area that is quadratic in that projection
+	 * 
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -624,19 +644,19 @@
 	 */
 	public Area CenterScaleToArea(CWPoint center, float scale, Point pixelsize) {
 		Area bbox = new Area();
-		double halfdiagonal = Math.sqrt(pixelsize.x * pixelsize.x + pixelsize.y * pixelsize.y)/2 * scale / 1000;
+		double halfdiagonal = Math.sqrt(pixelsize.x * pixelsize.x + pixelsize.y * pixelsize.y) / 2 * scale / 1000;
 		bbox.topleft = center.project(-45, halfdiagonal);
 		bbox.bottomright = center.project(135, halfdiagonal);
 		return bbox;
 	}
 
-
 	protected MapInfoObject getMapInfoObjectInternal(Area maparea, Point pixelsize) {
 		throw new IllegalArgumentException(MyLocale.getMsg(4811, "OnlineMapService: getMapInfoObjectInternal(Area maparea, Point pixelsize):\n This method must be overloaded in order to be able to use it"));
 	}
 
 	/**
 	 * Overload this (don't call super()) or alternatively overload getMapInfoObjectInternal
+	 * 
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -654,9 +674,9 @@
 class WebMapService extends OnlineMapService {
 	String layersUrlPart; //
 	String versionUrlPart; // VERSION=1.1.0
-	String serviceTypeUrlPart; //"SERVICE=WMS"
+	String serviceTypeUrlPart; // "SERVICE=WMS"
 	int coordinateReferenceSystem[]; // WGS84: 4326, German GK: 31466 /
-	String coordinateReferenceSystemUrlPart[]; //&SRS=EPSG:31466
+	String coordinateReferenceSystemUrlPart[]; // &SRS=EPSG:31466
 	public String requestUrlPart;
 	String imageFormatUrlPart; // FORMAT=image/png
 	String stylesUrlPart; // STYLES=
@@ -664,12 +684,13 @@
 	double maxscaleWMS;
 
 	/**
-	 *
-	 * @param filename without file extension
+	 * 
+	 * @param filename
+	 *            without file extension
 	 * @throws IOException
 	 * @throws IllegalArgumentException
 	 */
-	public WebMapService (String filename_) throws IOException, IllegalArgumentException{
+	public WebMapService(String filename_) throws IOException, IllegalArgumentException {
 		FileInputStream in = new FileInputStream(filename_);
 		Properties wms = new Properties();
 		wms.load(in);
@@ -677,65 +698,80 @@
 		String tmp = FileBase.getFileExt(filename_);
 		this.filename = tmp.substring(0, tmp.lastIndexOf('.'));
 		name = wms.getProperty("Name", "").trim();
-		if (name == "") throw new IllegalArgumentException(MyLocale.getMsg(4812, "WebMapService: property >Name:< missing in file:\n") + filename);
-		MainUrl = wms.getProperty("MainUrl", "").trim();;
-		if (MainUrl == "") throw new IllegalArgumentException(MyLocale.getMsg(4813, "WebMapService: property >MainUrl:< missing in file:\n") + filename);
+		if (name == "")
+			throw new IllegalArgumentException(MyLocale.getMsg(4812, "WebMapService: property >Name:< missing in file:\n") + filename);
+		MainUrl = wms.getProperty("MainUrl", "").trim();
+		;
+		if (MainUrl == "")
+			throw new IllegalArgumentException(MyLocale.getMsg(4813, "WebMapService: property >MainUrl:< missing in file:\n") + filename);
 		mapType = wms.getProperty("MapType", "maptype_unknown").trim();
 		serviceTypeUrlPart = wms.getProperty("ServiceTypeUrlPart", "SERVICE=WMS").trim();
-		layersUrlPart = wms.getProperty("LayersUrlPart", "").trim();;
-		versionUrlPart = wms.getProperty("VersionUrlPart", "").trim();;
+		layersUrlPart = wms.getProperty("LayersUrlPart", "").trim();
+		;
+		versionUrlPart = wms.getProperty("VersionUrlPart", "").trim();
+		;
 		tmp = wms.getProperty("CoordinateReferenceSystemCacheWolf", "").trim();
-		if (tmp.equals("")) throw new IllegalArgumentException(MyLocale.getMsg(4814, "WebMapService: no CoordinateReferenceSystemCacheWolf given"));
+		if (tmp.equals(""))
+			throw new IllegalArgumentException(MyLocale.getMsg(4814, "WebMapService: no CoordinateReferenceSystemCacheWolf given"));
 		String[] tmp2 = mString.split(tmp, ' ');
 		coordinateReferenceSystem = new int[tmp2.length];
 		for (int i = 0; i < tmp2.length; i++) {
 			coordinateReferenceSystem[i] = Common.parseInt(tmp2[i].trim());
-			if (!TransformCoordinates.isSupported(coordinateReferenceSystem[i])) throw new IllegalArgumentException(MyLocale.getMsg(4815, "Coordinate reference system not supported by CacheWolf:\n") + coordinateReferenceSystem[i]);
+			if (!TransformCoordinates.isSupported(coordinateReferenceSystem[i]))
+				throw new IllegalArgumentException(MyLocale.getMsg(4815, "Coordinate reference system not supported by CacheWolf:\n") + coordinateReferenceSystem[i]);
 		}
 		tmp = wms.getProperty("CoordinateReferenceSystemUrlPart", "").trim();
-		if (tmp == "") throw new IllegalArgumentException(MyLocale.getMsg(4816, "WebMapService: property >CoordinateReferenceSystemUrlPart:< missing in file:\n") + filename);
+		if (tmp == "")
+			throw new IllegalArgumentException(MyLocale.getMsg(4816, "WebMapService: property >CoordinateReferenceSystemUrlPart:< missing in file:\n") + filename);
 		tmp2 = mString.split(tmp, ' ');
-		if (tmp2.length != coordinateReferenceSystem.length) throw new IllegalArgumentException(MyLocale.getMsg(4817, "number of strings in CoordinateReferenceSystemUrlPart (")+tmp2.length+MyLocale.getMsg(4818, ") must match the number of codes in CoordinateReferenceSystemCacheWolf (")+coordinateReferenceSystem.length+MyLocale.getMsg(4819, ") use normal space as separator"));
+		if (tmp2.length != coordinateReferenceSystem.length)
+			throw new IllegalArgumentException(MyLocale.getMsg(4817, "number of strings in CoordinateReferenceSystemUrlPart (") + tmp2.length + MyLocale.getMsg(4818, ") must match the number of codes in CoordinateReferenceSystemCacheWolf (")
+					+ coordinateReferenceSystem.length + MyLocale.getMsg(4819, ") use normal space as separator"));
 		coordinateReferenceSystemUrlPart = new String[tmp2.length];
 		for (int i = 0; i < tmp2.length; i++) {
 			coordinateReferenceSystemUrlPart[i] = tmp2[i].trim();
-			if (coordinateReferenceSystemUrlPart[i] == "") throw new IllegalArgumentException(MyLocale.getMsg(4820, "WebMapService: property >CoordinateReferenceSystemUrlPart:< incorrect in file:\n") + filename);
+			if (coordinateReferenceSystemUrlPart[i] == "")
+				throw new IllegalArgumentException(MyLocale.getMsg(4820, "WebMapService: property >CoordinateReferenceSystemUrlPart:< incorrect in file:\n") + filename);
 		}
 		requestUrlPart = wms.getProperty("RequestUrlPart", "REQUEST=GetMap").trim();
 		imageFormatUrlPart = wms.getProperty("ImageFormatUrlPart", "").trim();
 		stylesUrlPart = wms.getProperty("StylesUrlPart", "").trim();
 		String topleftS = wms.getProperty("BoundingBoxTopLeftWGS84", "").trim();
 		String bottomrightS = wms.getProperty("BoundingBoxBottomRightWGS84");
-		//To be backward-compatible with mispelled property-name: Don't remove these lines until all wms-Files has been changed
-		if (bottomrightS == null){
-		    bottomrightS = wms.getProperty("BoundingBoxButtomRightWGS84", "");
+		// To be backward-compatible with mispelled property-name: Don't remove these lines until all wms-Files has been changed
+		if (bottomrightS == null) {
+			bottomrightS = wms.getProperty("BoundingBoxButtomRightWGS84", "");
 		}
 		bottomrightS.trim();
 		CWPoint topleft = new CWPoint(topleftS);
 		CWPoint bottomright = new CWPoint(bottomrightS);
-		if (!topleft.isValid()) topleft.set(90, -180);
-		if (!bottomright.isValid()) bottomright.set(-90, 180);
-		boundingBox = new Area (topleft, bottomright);
+		if (!topleft.isValid())
+			topleft.set(90, -180);
+		if (!bottomright.isValid())
+			bottomright.set(-90, 180);
+		boundingBox = new Area(topleft, bottomright);
 		minscaleWMS = Common.parseDouble(wms.getProperty("MinScale", "0").trim());
 		maxscaleWMS = Common.parseDouble(wms.getProperty("MaxScale", Convert.toString(java.lang.Double.MAX_VALUE)).trim());
 		minscale = minscaleWMS / Math.sqrt(2); // in WMS scale is measured diagonal while in CacheWolf it is measured vertical
 		maxscale = maxscaleWMS / Math.sqrt(2);
 		imageFileExt = wms.getProperty("ImageFileExtension", "").trim();
-		if (imageFileExt == "") throw new IllegalArgumentException(MyLocale.getMsg(4821, "WebMapService: property >ImageFileExtension:< missing in file:\n") + filename);
-		String [] recommendedScalesStr = mString.split(wms.getProperty("RecommendedScale", "5").trim(), ' ');
+		if (imageFileExt == "")
+			throw new IllegalArgumentException(MyLocale.getMsg(4821, "WebMapService: property >ImageFileExtension:< missing in file:\n") + filename);
+		String[] recommendedScalesStr = mString.split(wms.getProperty("RecommendedScale", "5").trim(), ' ');
 		// convert recommended scales to doube[], sort them and set preselected recommended scale
 		if (recommendedScalesStr.length > 0) {
 			double preselected = Common.parseDouble(recommendedScalesStr[0]);
 			Double[] recommendedScalesObj = new Double[recommendedScalesStr.length];
-			for (int i=0; i < recommendedScalesObj.length; i++) {
+			for (int i = 0; i < recommendedScalesObj.length; i++) {
 				recommendedScalesObj[i] = new Double();
 				recommendedScalesObj[i].set(Common.parseDouble(recommendedScalesStr[i].replace(',', '.')));
 			}
 			Utils.sort(recommendedScalesObj, new StandardComparer(), false);
 			recommendedScales = new double[recommendedScalesStr.length];
-			for (int i=0; i < recommendedScales.length; i++) {
+			for (int i = 0; i < recommendedScales.length; i++) {
 				recommendedScales[i] = recommendedScalesObj[i].value;
-				if (recommendedScales[i] == preselected) preselectedRecScaleIndex = i;
+				if (recommendedScales[i] == preselected)
+					preselectedRecScaleIndex = i;
 			}
 		}
 	}
@@ -744,36 +780,40 @@
 	private static final int BOTTOMRIGHT_INDEX = 1;
 	private static final int TOPRIGHT_INDEX = 2;
 	private static final int BOTTOMLEFT_INDEX = 3;
+
 	/**
-	 *
+	 * 
 	 * @param maparea
 	 * @return [0] = topleft, [1] = bottomright, [2] = topright, [3] = bottomleft
 	 */
 	private ProjectedPoint[] getGkArea(Area maparea) {
 		ProjectedPoint[] ret = new ProjectedPoint[4];
-	//	CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.bottomright.lonDec);
-	//	CWPoint bottomleft = new CWPoint(maparea.bottomright.latDec, maparea.topleft.lonDec);
+		// CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.bottomright.lonDec);
+		// CWPoint bottomleft = new CWPoint(maparea.bottomright.latDec, maparea.topleft.lonDec);
 		int crs = getCrs(maparea.getCenter());
 		// FIXME region is never read. Needed?
 		// int region = TransformCoordinates.getLocalProjectionSystem(coordinateReferenceSystem[crs]);
 		ret[TOPLEFT_INDEX] = TransformCoordinates.wgs84ToEpsg(maparea.topleft, coordinateReferenceSystem[crs]);
 		ret[BOTTOMRIGHT_INDEX] = TransformCoordinates.wgs84ToEpsg(maparea.bottomright, coordinateReferenceSystem[crs]);
-		ret[TOPRIGHT_INDEX] =  ret[BOTTOMRIGHT_INDEX].cloneIt();
-		ret[TOPRIGHT_INDEX].shift(ret[TOPLEFT_INDEX].getNorthing() - ret[BOTTOMRIGHT_INDEX].getNorthing(), 0); // was: new GkPoint(ret[BUTTOMRIGHT_INDEX].getEasting(region), ret[TOPLEFT_INDEX].northing, ret[TOPLEFT_INDEX].stripewidth, ret[TOPLEFT_INDEX].lengthOfStripe0);
+		ret[TOPRIGHT_INDEX] = ret[BOTTOMRIGHT_INDEX].cloneIt();
+		ret[TOPRIGHT_INDEX].shift(ret[TOPLEFT_INDEX].getNorthing() - ret[BOTTOMRIGHT_INDEX].getNorthing(), 0); // was: new GkPoint(ret[BUTTOMRIGHT_INDEX].getEasting(region), ret[TOPLEFT_INDEX].northing, ret[TOPLEFT_INDEX].stripewidth,
+																												// ret[TOPLEFT_INDEX].lengthOfStripe0);
 		ret[BOTTOMLEFT_INDEX] = ret[BOTTOMRIGHT_INDEX].cloneIt();
-		ret[BOTTOMLEFT_INDEX].shift(ret[TOPLEFT_INDEX].getEasting() - ret[BOTTOMRIGHT_INDEX].getEasting(), 1); // was: new GkPoint(ret[TOPLEFT_INDEX].getEasting(region), ret[BUTTOMRIGHT_INDEX].northing, ret[TOPLEFT_INDEX].stripewidth, ret[TOPLEFT_INDEX].lengthOfStripe0);
-		//ret[2] = TransformCoordinates.wgs84ToGermanGk(topright, coordinateReferenceSystem[crs]);
-		//ret[3] = TransformCoordinates.wgs84ToGermanGk(bottomleft, coordinateReferenceSystem[crs]);
+		ret[BOTTOMLEFT_INDEX].shift(ret[TOPLEFT_INDEX].getEasting() - ret[BOTTOMRIGHT_INDEX].getEasting(), 1); // was: new GkPoint(ret[TOPLEFT_INDEX].getEasting(region), ret[BUTTOMRIGHT_INDEX].northing, ret[TOPLEFT_INDEX].stripewidth,
+																												// ret[TOPLEFT_INDEX].lengthOfStripe0);
+		// ret[2] = TransformCoordinates.wgs84ToGermanGk(topright, coordinateReferenceSystem[crs]);
+		// ret[3] = TransformCoordinates.wgs84ToGermanGk(bottomleft, coordinateReferenceSystem[crs]);
 		return ret;
 	}
+
 	public Area CenterScaleToArea(CWPoint center, float scale, Point pixelsize) {
 		Area bbox = new Area();
 		int region = TransformCoordinates.getLocalProjectionSystem(coordinateReferenceSystem[0]);
-		if (region > 0 ) {
+		if (region > 0) {
 			int epsg = coordinateReferenceSystem[getCrs(center)];
 			ProjectedPoint cgk = TransformCoordinates.wgs84ToEpsg(center, epsg);
 			ProjectedPoint tlgk = cgk.cloneIt();
-			tlgk.shift(- pixelsize.x * scale / 2, 1);
+			tlgk.shift(-pixelsize.x * scale / 2, 1);
 			tlgk.shift(pixelsize.y * scale / 2, 0);
 			ProjectedPoint brgk = cgk.cloneIt();
 			brgk.shift(pixelsize.x * scale / 2, 1);
@@ -791,21 +831,25 @@
 				bbox.bottomright.shift(pixelsize.x * scale / 2, 1);
 				bbox.bottomright.shift(-pixelsize.y * scale / 2, 0);
 				break;
-			default: throw new IllegalArgumentException("CenterScaleToArea: epsg: " + coordinateReferenceSystem[0] + " not supported");
+			default:
+				throw new IllegalArgumentException("CenterScaleToArea: epsg: " + coordinateReferenceSystem[0] + " not supported");
 			}
 		}
 		return bbox;
 	}
 
 	protected String getUrlForBoundingBoxInternal(Area maparea, Point pixelsize) {
-		if (!boundingBox.isOverlapping(maparea)) throw new IllegalArgumentException(MyLocale.getMsg(4822, "area:")+" " + maparea.toString() + MyLocale.getMsg(4823, " not covered by service:")+" " + name + MyLocale.getMsg(4824, ", service area:")+" " + boundingBox.toString());
+		if (!boundingBox.isOverlapping(maparea))
+			throw new IllegalArgumentException(MyLocale.getMsg(4822, "area:") + " " + maparea.toString() + MyLocale.getMsg(4823, " not covered by service:") + " " + name + MyLocale.getMsg(4824, ", service area:") + " " + boundingBox.toString());
 		// http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS&VERSION=1.1.0&REQUEST=GetMap&SRS=EPSG:31466&BBOX=2577567.0149,5607721.7566,2578567.0077,5608721.7602&WIDTH=500&HEIGHT=500&LAYERS=Raster:TK25_KMF:Farbkombination&STYLES=&FORMAT=image/png
-		CWPoint bottomleft = new CWPoint (maparea.bottomright.latDec, maparea.topleft.lonDec);
-		CWPoint topright = new CWPoint (maparea.topleft.latDec, maparea.bottomright.lonDec);
+		CWPoint bottomleft = new CWPoint(maparea.bottomright.latDec, maparea.topleft.lonDec);
+		CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.bottomright.lonDec);
 		double scaleh = maparea.bottomright.getDistance(bottomleft) * 1000 / pixelsize.x;
 		double scalev = maparea.topleft.getDistance(topright) * 1000 / pixelsize.y;
 		double scale = Math.sqrt(scaleh * scaleh + scalev * scalev); // meters per pixel measured diagonal
-		if ( scale < minscaleWMS || scale > maxscaleWMS ) throw new IllegalArgumentException(MyLocale.getMsg(4825, "scale")+" " + scale / Math.sqrt(2)+ MyLocale.getMsg(4826, " not supported by online map service, supported scale range:")+" " + minscale + " - " + maxscale + MyLocale.getMsg(4827, " (measured in meters per pixel vertically)"));
+		if (scale < minscaleWMS || scale > maxscaleWMS)
+			throw new IllegalArgumentException(MyLocale.getMsg(4825, "scale") + " " + scale / Math.sqrt(2) + MyLocale.getMsg(4826, " not supported by online map service, supported scale range:") + " " + minscale + " - " + maxscale
+					+ MyLocale.getMsg(4827, " (measured in meters per pixel vertically)"));
 		int crs = 0;
 		String bbox = "BBOX=";
 		int localsystem = TransformCoordinates.getLocalProjectionSystem(coordinateReferenceSystem[0]);
@@ -817,12 +861,11 @@
 			bbox += TransformCoordinates.wgs84ToEpsg(bottomleft, coordinateReferenceSystem[crs]).toString(2, "", ",");
 			bbox += "," + TransformCoordinates.wgs84ToEpsg(topright, coordinateReferenceSystem[crs]).toString(2, "", ",");
 		} else if (coordinateReferenceSystem[0] == TransformCoordinates.EPSG_WGS84)
-			bbox += bottomleft.toString(TransformCoordinates.LON_LAT)  + "," + topright.toString(TransformCoordinates.LON_LAT);
-		else throw new IllegalArgumentException(MyLocale.getMsg(4828, "Coordinate system not supported by cachewolf:")+" " + coordinateReferenceSystem.toString());
-		String ret = MainUrl + serviceTypeUrlPart + "&" + versionUrlPart + "&" + requestUrlPart + "&" +
-		coordinateReferenceSystemUrlPart[crs] + "&" + bbox +
-		"&WIDTH=" + pixelsize.x + "&HEIGHT=" + pixelsize.y + "&" +
-		layersUrlPart + "&" + stylesUrlPart + "&" + imageFormatUrlPart;
+			bbox += bottomleft.toString(TransformCoordinates.LON_LAT) + "," + topright.toString(TransformCoordinates.LON_LAT);
+		else
+			throw new IllegalArgumentException(MyLocale.getMsg(4828, "Coordinate system not supported by cachewolf:") + " " + coordinateReferenceSystem.toString());
+		String ret = MainUrl + serviceTypeUrlPart + "&" + versionUrlPart + "&" + requestUrlPart + "&" + coordinateReferenceSystemUrlPart[crs] + "&" + bbox + "&WIDTH=" + pixelsize.x + "&HEIGHT=" + pixelsize.y + "&" + layersUrlPart + "&" + stylesUrlPart
+				+ "&" + imageFormatUrlPart;
 		Global.getPref().log(ret + " WGS84: Bottom left: " + bottomleft.toString(TransformCoordinates.DD) + "top right: " + topright.toString(TransformCoordinates.DD));
 		return ret;
 	}
@@ -832,7 +875,9 @@
 	 * a) if only one is in the array 0 is returned
 	 * b) if there are more, find out which one matches the correct zone (e.g. Gau?-K?ger stripe)
 	 * Call this routine with center of the area (use Area.getcenter())
-	 * @param p Point for which the epsg code is searched for
+	 * 
+	 * @param p
+	 *            Point for which the epsg code is searched for
 	 * @return
 	 */
 	private int getCrs(TrackPoint p) {
@@ -842,33 +887,38 @@
 			ProjectedPoint gkbl = TransformCoordinates.wgs84ToLocalsystem(p, ls); // TODO: think / read about what to do if bottom left and top right are not in the same Gau?-Kr?ger stripe?
 			int wantepsg = gkbl.getEpsgCode();
 			for (crsindex = 0; crsindex < coordinateReferenceSystem.length; crsindex++) {
-				if (coordinateReferenceSystem[crsindex] == wantepsg) break;
+				if (coordinateReferenceSystem[crsindex] == wantepsg)
+					break;
 			}
 			if (crsindex >= coordinateReferenceSystem.length) { // not match
 				for (crsindex = 0; crsindex < coordinateReferenceSystem.length; crsindex++) {
-					if (Math.abs(coordinateReferenceSystem[crsindex] - wantepsg) == 1) break; // accept 1 zone deviation
+					if (Math.abs(coordinateReferenceSystem[crsindex] - wantepsg) == 1)
+						break; // accept 1 zone deviation
 				}
-				if (crsindex >= coordinateReferenceSystem.length) crsindex = -1;
+				if (crsindex >= coordinateReferenceSystem.length)
+					crsindex = -1;
 
 			}
-			if (crsindex < 0) throw new IllegalArgumentException(MyLocale.getMsg(4829, "getUrlForBoundingBox: Point:")+" " + gkbl.toString() + MyLocale.getMsg(4830, "no matching Gau?-Kr?ger-Stripe in the EPSG-code list in the .wms"));
+			if (crsindex < 0)
+				throw new IllegalArgumentException(MyLocale.getMsg(4829, "getUrlForBoundingBox: Point:") + " " + gkbl.toString() + MyLocale.getMsg(4830, "no matching Gau?-Kr?ger-Stripe in the EPSG-code list in the .wms"));
 		}
 		return crsindex;
 	}
 
 	protected MapInfoObject getMapInfoObjectInternal(Area maparea, Point pixelsize) {
-		if (!boundingBox.isOverlapping(maparea)) throw new IllegalArgumentException(MyLocale.getMsg(4822, "area:")+" " + maparea.toString() + MyLocale.getMsg(4823, " not covered by service:")+" " + name + MyLocale.getMsg(4824, ", service area:")+" " + boundingBox.toString());
+		if (!boundingBox.isOverlapping(maparea))
+			throw new IllegalArgumentException(MyLocale.getMsg(4822, "area:") + " " + maparea.toString() + MyLocale.getMsg(4823, " not covered by service:") + " " + name + MyLocale.getMsg(4824, ", service area:") + " " + boundingBox.toString());
 		Vector georef = new Vector(4);
 
 		// calculate a rectangle in the according coordinate reference system
-		CWPoint bottomleft = new CWPoint (maparea.bottomright.latDec, maparea.topleft.lonDec);
-		CWPoint topright = new CWPoint (maparea.topleft.latDec, maparea.bottomright.lonDec);
+		CWPoint bottomleft = new CWPoint(maparea.bottomright.latDec, maparea.topleft.lonDec);
+		CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.bottomright.lonDec);
 		CWPoint topleft = new CWPoint(maparea.topleft);
 		CWPoint bottomright = new CWPoint(maparea.bottomright);
-		double metersperpixalhorizontal = ( bottomright.getDistance(bottomleft) + topleft.getDistance(topright))/2 * 1000 / pixelsize.x;
-		double metersperpixalvertical = ( bottomright.getDistance(topright) + topleft.getDistance(bottomleft))/2 * 1000 / pixelsize.y;
+		double metersperpixalhorizontal = (bottomright.getDistance(bottomleft) + topleft.getDistance(topright)) / 2 * 1000 / pixelsize.x;
+		double metersperpixalvertical = (bottomright.getDistance(topright) + topleft.getDistance(bottomleft)) / 2 * 1000 / pixelsize.y;
 		int region = TransformCoordinates.getLocalProjectionSystem(coordinateReferenceSystem[0]);
-		if ( region > 0) {
+		if (region > 0) {
 			ProjectedPoint[] gk = getGkArea(maparea);
 			// bounding box in WMS is defined around the pixels, not exactly on the pixels --> the bounding box must be reduced on all edges by half a pixel
 			gk[TOPLEFT_INDEX].shift(metersperpixalhorizontal / 2, 1);
@@ -890,9 +940,10 @@
 			topleft.shift(-metersperpixalvertical / 2, 0);
 			bottomright.shift(-metersperpixalhorizontal, 1);
 			bottomright.shift(metersperpixalhorizontal, 0);
-			topright = new CWPoint (topleft.latDec, bottomright.lonDec);
-			bottomleft = new CWPoint (bottomright.latDec, topleft.lonDec);
-		} else throw new IllegalArgumentException(MyLocale.getMsg(4831, "getMapInfoObject: Coordinate system not supported by cachewolf:")+" " + coordinateReferenceSystem);
+			topright = new CWPoint(topleft.latDec, bottomright.lonDec);
+			bottomleft = new CWPoint(bottomright.latDec, topleft.lonDec);
+		} else
+			throw new IllegalArgumentException(MyLocale.getMsg(4831, "getMapInfoObject: Coordinate system not supported by cachewolf:") + " " + coordinateReferenceSystem);
 		georef.add(new GCPoint(topleft, new Point(0, 0)));
 		georef.add(new GCPoint(bottomright, new Point(pixelsize.x, pixelsize.y)));
 		georef.add(new GCPoint(topright, new Point(pixelsize.x, 0)));
@@ -906,25 +957,26 @@
 
 class ExpediaMapService extends OnlineMapService {
 	/*
-	 * information from: DownloadMouseMode.properties in project GPSylon ( in directory gpsylon_src-0.5.2\plugins\downloadmousemode\auxiliary\org\dinopolis\gpstool\plugin\downloadmousemode and DownloadMapCalculator.java in Dir gpsylon_src-0.5.2\plugins\downloadmousemode\src\org\dinopolis\gpstool\plugin\downloadmousemode
+	 * information from: DownloadMouseMode.properties in project GPSylon ( in directory gpsylon_src-0.5.2\plugins\downloadmousemode\auxiliary\org\dinopolis\gpstool\plugin\downloadmousemode and DownloadMapCalculator.java in Dir
+	 * gpsylon_src-0.5.2\plugins\downloadmousemode\src\org\dinopolis\gpstool\plugin\downloadmousemode
 	 * download.map.url.expedia_east=http\://www.expedia.com/pub/agent.dll?qscr=mrdt&ID=3XNsF.&CenP={0,number,#.########},{1,number,#.########}&Lang=EUR0809&Alti={2,number,#}&Size={3,number,#},{4,number,#}&Offs=0.000000,0.000000\&BCheck=1
 	 * download.map.url.expedia_east.title=Url of Expedia Europe
 	 * download.map.scale_factor.expedia_east=3950
 	 */
 	final static float downloadMapScaleFactorExpedia_east = 3950;
-	final static float MAPBLAST_METERS_PER_PIXEL = 1.0f/2817.947378f;
+	final static float MAPBLAST_METERS_PER_PIXEL = 1.0f / 2817.947378f;
 	final static float EXPEDIA_METERS_PER_PIXEL = downloadMapScaleFactorExpedia_east * MAPBLAST_METERS_PER_PIXEL;
 
 	public ExpediaMapService() {
 		name = "Expedia";
 		filename = "expedia";
-		MainUrl = "Rhttp://www.expedia.de/pub/agent.dll?qscr=mrdt&ID=3kQaz."; //"Rhttp://" forces doenloadUrl to retry the URL until it gets an http-redirect and then downloads from there
+		MainUrl = "Rhttp://www.expedia.de/pub/agent.dll?qscr=mrdt&ID=3kQaz."; // "Rhttp://" forces doenloadUrl to retry the URL until it gets an http-redirect and then downloads from there
 		imageFileExt = ".gif";
 		mapType = "expedia";
-		recommendedScales = new double[]{5};
+		recommendedScales = new double[] { 5 };
 		minscale = getMetersPerPixel(0.00000000000000000000001f);
-		maxscale = getMetersPerPixel((float)new CWPoint(0,0).getDistance(new CWPoint(0,180)) * 2 * 1000 / 1000); // whole world * 1000 because of km -> m. /1000 because we have 1000x1000 Pixel usually
-		boundingBox = new Area(new CWPoint(90,-180), new CWPoint(-90,180));
+		maxscale = getMetersPerPixel((float) new CWPoint(0, 0).getDistance(new CWPoint(0, 180)) * 2 * 1000 / 1000); // whole world * 1000 because of km -> m. /1000 because we have 1000x1000 Pixel usually
+		boundingBox = new Area(new CWPoint(90, -180), new CWPoint(-90, 180));
 	}
 
 	public float getMetersPerPixel(float scale) {
@@ -932,24 +984,25 @@
 	}
 
 	private int getZoomlevel(float scale) {
-		return (int)(Math.ceil(scale / EXPEDIA_METERS_PER_PIXEL));
+		return (int) (Math.ceil(scale / EXPEDIA_METERS_PER_PIXEL));
 	}
 
 	public String getUrlForCenterScale(CWPoint center, float scale, Point pixelsize) {
 		int zoomlevel = getZoomlevel(scale);
 		String zone;
-		if (     (center.lonDec <= -30   && center.lonDec >= -170) ||
-				( center.lonDec > 360-30 && center.lonDec <= 360-170) ) zone = "USA0409"; // TODO test which zone-code ist best for asia
-		else zone = "EUR0809";
+		if ((center.lonDec <= -30 && center.lonDec >= -170) || (center.lonDec > 360 - 30 && center.lonDec <= 360 - 170))
+			zone = "USA0409"; // TODO test which zone-code ist best for asia
+		else
+			zone = "EUR0809";
 		String quelle = MainUrl + "&CenP=" + center.toString(TransformCoordinates.LAT_LON);
-		quelle = quelle + "&Alti="+Convert.toString(zoomlevel)+"&Lang="+zone+"&Size="+Convert.toString(pixelsize.x)+","+Convert.toString(pixelsize.y)+"&Offs=0,0&MapS=0"; //&Pins=|" + latD.toString().replace(',', '.') + "," + lonD.toString().replace(',', '.') + "|5|";
+		quelle = quelle + "&Alti=" + Convert.toString(zoomlevel) + "&Lang=" + zone + "&Size=" + Convert.toString(pixelsize.x) + "," + Convert.toString(pixelsize.y) + "&Offs=0,0&MapS=0"; // &Pins=|" + latD.toString().replace(',', '.') + "," + lonD.toString().replace(',', '.') + "|5|";
 		return quelle;
 	}
 
 	public MapInfoObject getMapInfoObject(CWPoint center, float scale, Point pixelsize) {
 		float metersPerPixel2 = getMetersPerPixel(scale);
 		float metersPerPixel = metersPerPixel2;
-		MapInfoObject cal = new MapInfoObject(metersPerPixel, center,  pixelsize.x, pixelsize.y, name);
+		MapInfoObject cal = new MapInfoObject(metersPerPixel, center, pixelsize.x, pixelsize.y, name);
 		return cal;
 	}
 

Modified: trunk/src/CacheWolf/navi/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoaderGui.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/navi/MapLoaderGui.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -60,47 +60,47 @@
 
 /**
  * @author pfeffer
- * This Class is the Dialog for Download calibrated from expedia.com
- * is called from
- *  * start offset for language file: 1800
+ *         This Class is the Dialog for Download calibrated from expedia.com
+ *         is called from
+ *         * start offset for language file: 1800
  */
 
 public class MapLoaderGui extends Form {
 	mButton cancelB, okBtiles, okBPerCache, cancelBPerCache;
-    Preferences pref = Global.getPref ();
+	Preferences pref = Global.getPref();
 	mTabbedPanel mTab = new mTabbedPanel();
 	CellPanel pnlTiles = new CellPanel();
 	CellPanel pnlPerCache = new CellPanel();
 
-	final String descString = MyLocale.getMsg(1802,"Download georeferenced maps\n Select online service:");
+	final String descString = MyLocale.getMsg(1802, "Download georeferenced maps\n Select online service:");
 	mChoice mapServiceChoice;
-	mCheckBox forCachesChkBox = new mCheckBox(MyLocale.getMsg(1803,"for"));
-	mChoice forSelectedChkBox = new mChoice(new String[] {MyLocale.getMsg(1804,"all"), MyLocale.getMsg(1805,"selected")}, 0);
-	mChoice forSelectedChkBoxPerCache = new mChoice(new String[] {MyLocale.getMsg(1804,"all"), MyLocale.getMsg(1805,"selected")}, 1);
-	mLabel cachesLbl = new mLabel(MyLocale.getMsg(1806,"caches"));
+	mCheckBox forCachesChkBox = new mCheckBox(MyLocale.getMsg(1803, "for"));
+	mChoice forSelectedChkBox = new mChoice(new String[] { MyLocale.getMsg(1804, "all"), MyLocale.getMsg(1805, "selected") }, 0);
+	mChoice forSelectedChkBoxPerCache = new mChoice(new String[] { MyLocale.getMsg(1804, "all"), MyLocale.getMsg(1805, "selected") }, 1);
+	mLabel cachesLbl = new mLabel(MyLocale.getMsg(1806, "caches"));
 	mInput distanceInput;
 	mLabel distLbl;
 	mLabel km = new mLabel("km");
 	mLabel coosLbl;
 	mButton coosBtn;
-	mLabel scaleLbl = new mLabel(MyLocale.getMsg(1807,"Approx. m per pixel:"));
+	mLabel scaleLbl = new mLabel(MyLocale.getMsg(1807, "Approx. m per pixel:"));
 	mComboBox scaleInput = new mComboBox();
 	mComboBox scaleInputPerCache = new mComboBox();
-	mLabel overlappingLbl = new mLabel(MyLocale.getMsg(1808,"overlapping in pixel:"));
-    mInput overlappingInput = new mInput(""+pref.mapOverlapping);
-	mCheckBox overviewChkBox = new mCheckBox(MyLocale.getMsg(1809,"download an overview map"));	
-	mCheckBox fetchOnlyMapWithCacheChkBox = new mCheckBox(MyLocale.getMsg(165,"only for caches"));	
-	mCheckBox overviewChkBoxPerCache = new mCheckBox(MyLocale.getMsg(1809,"download an overview map"));
-    mCheckBox smallTiles = new mCheckBox (MyLocale.getMsg (4280, "Small Tiles"));
-    mCheckBox bigTiles = new mCheckBox (MyLocale.getMsg (4282, "BigTiles"));
-    CheckBoxGroup tileSize = new CheckBoxGroup ();
+	mLabel overlappingLbl = new mLabel(MyLocale.getMsg(1808, "overlapping in pixel:"));
+	mInput overlappingInput = new mInput("" + pref.mapOverlapping);
+	mCheckBox overviewChkBox = new mCheckBox(MyLocale.getMsg(1809, "download an overview map"));
+	mCheckBox fetchOnlyMapWithCacheChkBox = new mCheckBox(MyLocale.getMsg(165, "only for caches"));
+	mCheckBox overviewChkBoxPerCache = new mCheckBox(MyLocale.getMsg(1809, "download an overview map"));
+	mCheckBox smallTiles = new mCheckBox(MyLocale.getMsg(4280, "Small Tiles"));
+	mCheckBox bigTiles = new mCheckBox(MyLocale.getMsg(4282, "BigTiles"));
+	CheckBoxGroup tileSize = new CheckBoxGroup();
 
-    /**
-     * Inputfields for width an height of tile size
-     */
-    private mInput tileWidthInput = new mInput ();
-    private mInput tileHeightInput = new mInput();
-    MapLoader mapLoader;
+	/**
+	 * Inputfields for width an height of tile size
+	 */
+	private mInput tileWidthInput = new mInput();
+	private mInput tileHeightInput = new mInput();
+	MapLoader mapLoader;
 	String[] unsortedMapServices;
 	String[] sortedmapServices;
 	int[] sortingMapServices;
@@ -124,19 +124,19 @@
 		this.title = MyLocale.getMsg(1800, "Download georeferenced maps");
 		center = new CWPoint(pref.getCurCentrePt());
 		tileWidth = pref.tilewidth;
-		tileHeight=pref.tileheight;
+		tileHeight = pref.tileheight;
 		if (tileWidth == 0 || tileHeight == 0) {
-			tileWidth = pref.myAppWidth > 200?pref.myAppWidth:200;
-			tileHeight = pref.myAppHeight > 175?pref.myAppHeight:175;
+			tileWidth = pref.myAppWidth > 200 ? pref.myAppWidth : 200;
+			tileHeight = pref.myAppHeight > 175 ? pref.myAppHeight : 175;
 		}
-		pref.tilewidth=tileWidth;
-		pref.tileheight=tileHeight;
+		pref.tilewidth = tileWidth;
+		pref.tileheight = tileHeight;
 		// ist das wirklich so gewollt?
-		pref.tilewidth=1000;
-		pref.tileheight=1000;
+		pref.tilewidth = 1000;
+		pref.tileheight = 1000;
 		initTileInputfields();
 		cacheDB = cacheDBi;
-		mapLoader = new MapLoader(FileBase.getProgramDirectory()+"/"+"webmapservices");
+		mapLoader = new MapLoader(FileBase.getProgramDirectory() + "/" + "webmapservices");
 
 		// sort the items in the list of services in a way that services which cover the current center point.
 		unsortedMapServices = mapLoader.getAvailableOnlineMapServices();
@@ -151,20 +151,20 @@
 		pnlTiles.addNext(forCachesChkBox);
 		pnlTiles.addNext(forSelectedChkBox);
 		pnlTiles.addLast(cachesLbl);
-		pnlTiles.addNext(distLbl = new mLabel(MyLocale.getMsg(1810,"Within a rectangle of:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlTiles.addNext(distLbl = new mLabel(MyLocale.getMsg(1810, "Within a rectangle of:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		distanceInput = new mInput();
 		int tmp = Convert.toInt((Global.getProfile().getDistOC()));
 		tmp = java.lang.Math.max(tmp, Convert.toInt((Global.getProfile().getDistGC())));
 		distanceInput.setText(Convert.toString((tmp > 0 ? tmp : 15)));
-		pnlTiles.addNext(distanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlTiles.addNext(distanceInput, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		pnlTiles.addLast(km);
-		pnlTiles.addNext(coosLbl = new mLabel(MyLocale.getMsg(1811, "around the centre:")+" "));
+		pnlTiles.addNext(coosLbl = new mLabel(MyLocale.getMsg(1811, "around the centre:") + " "));
 		pnlTiles.addLast(coosBtn = new mButton(center.toString()));
 		pnlTiles.addNext(scaleLbl);
 		mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
 		this.focusFirst();
 		pnlTiles.addLast(scaleInput);
-		//	pnlTiles.addLast(resolutionLbl);
+		// pnlTiles.addLast(resolutionLbl);
 		pnlTiles.addNext(overlappingLbl);
 		pnlTiles.addLast(overlappingInput);
 		overviewChkBox.setState(false);
@@ -174,15 +174,15 @@
 		pnlTiles.addNext(smallTiles);
 		pnlTiles.addLast(bigTiles);
 		smallTiles.setGroup(tileSize);
-                bigTiles.setGroup(tileSize);
+		bigTiles.setGroup(tileSize);
 		tileSize.selectIndex(pref.mapTileSize);
-		cancelB = new mButton(MyLocale.getMsg(1604,"Cancel"));
+		cancelB = new mButton(MyLocale.getMsg(1604, "Cancel"));
 		cancelB.setHotKey(0, IKeys.ESCAPE);
-		pnlTiles.addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		okBtiles = new mButton(MyLocale.getMsg(1605,"OK"));
+		pnlTiles.addNext(cancelB, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		okBtiles = new mButton(MyLocale.getMsg(1605, "OK"));
 		okBtiles.setHotKey(0, IKeys.ACTION);
 		okBtiles.setHotKey(0, IKeys.ENTER);
-		pnlTiles.addLast(okBtiles,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlTiles.addLast(okBtiles, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		updateForCachesState();
 		mTab.addCard(pnlTiles, MyLocale.getMsg(1812, "Tiles"), MyLocale.getMsg(1812, "Tiles"));
 
@@ -191,20 +191,20 @@
 		pnlPerCache.addNext(forSelectedChkBoxPerCache, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
 		pnlPerCache.addLast(new mLabel(MyLocale.getMsg(1806, "caches")), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
 		pnlPerCache.addNext(new mLabel(MyLocale.getMsg(1807, "Approx. m per pixel")), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		pnlPerCache.addLast(scaleInputPerCache, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
-		
-		pnlPerCache.addNext (new mLabel(MyLocale.getMsg(1835, "Tilesize")), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		CellPanel pnl = new CellPanel();		
+		pnlPerCache.addLast(scaleInputPerCache, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
+
+		pnlPerCache.addNext(new mLabel(MyLocale.getMsg(1835, "Tilesize")), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		CellPanel pnl = new CellPanel();
 		tileHeightInput.columns = tileWidthInput.columns = 5;
-		pnl.addNext (tileWidthInput, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		pnl.addNext (new mLabel("x"), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		pnl.addLast (tileHeightInput, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-        pnlPerCache.addLast(pnl,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
-		
-        cancelBPerCache = new mButton(MyLocale.getMsg(1604,"Cancel"));
+		pnl.addNext(tileWidthInput, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		pnl.addNext(new mLabel("x"), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		pnl.addLast(tileHeightInput, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		pnlPerCache.addLast(pnl, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
+
+		cancelBPerCache = new mButton(MyLocale.getMsg(1604, "Cancel"));
 		cancelBPerCache.setHotKey(0, IKeys.ESCAPE);
 		pnlPerCache.addNext(cancelBPerCache, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		okBPerCache = new mButton(MyLocale.getMsg(1605,"OK"));
+		okBPerCache = new mButton(MyLocale.getMsg(1605, "OK"));
 		okBPerCache.setHotKey(0, IKeys.ACTION);
 		okBPerCache.setHotKey(0, IKeys.ENTER);
 		pnlPerCache.addLast(okBPerCache, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
@@ -219,9 +219,9 @@
 		tileHeightInput.setText(Integer.toString(pref.tileheight));
 	}
 
-	private void setRecommScaleInput(){
+	private void setRecommScaleInput() {
 		String[] recScales = new String[mapLoader.currentOnlineMapService.recommendedScales.length];
-		for (int i=0; i<recScales.length; i++) {
+		for (int i = 0; i < recScales.length; i++) {
 			recScales[i] = Convert.toString(mapLoader.currentOnlineMapService.recommendedScales[i]);
 		}
 		scaleInput.choice.set(recScales, mapLoader.currentOnlineMapService.preselectedRecScaleIndex);
@@ -234,70 +234,72 @@
 	 * sort the map services in order to have the services, which cover
 	 * the current center first in the list
 	 * this sets inbound[], sortedMapServices[] and sortingmapServices[]
-	 *
+	 * 
 	 */
 	private void sortMapServices() {
-		sortingMapServices = new int[unsortedMapServices.length+1];
+		sortingMapServices = new int[unsortedMapServices.length + 1];
 		inbound = new boolean[unsortedMapServices.length];
-		int j=0;
-		for (int i=0; i < sortingMapServices.length-1; i++) {
-			if( ((OnlineMapService)mapLoader.onlineMapServices.get(i)).boundingBox.isInBound(center)) {
+		int j = 0;
+		for (int i = 0; i < sortingMapServices.length - 1; i++) {
+			if (((OnlineMapService) mapLoader.onlineMapServices.get(i)).boundingBox.isInBound(center)) {
 				sortingMapServices[j] = i;
 				j++;
 				inbound[i] = true;
-			} else inbound[i] = false;
+			} else
+				inbound[i] = false;
 		}
-		int k=j;
-		sortedmapServices = new String[unsortedMapServices.length+1];
-		for (int i=0; i < sortedmapServices.length-1; i++) {
+		int k = j;
+		sortedmapServices = new String[unsortedMapServices.length + 1];
+		for (int i = 0; i < sortedmapServices.length - 1; i++) {
 			if (!inbound[i]) {
 				sortingMapServices[j] = i;
 				j++;
 			}
-			sortedmapServices[i] = ((OnlineMapService)mapLoader.onlineMapServices.get(sortingMapServices[i])).getName();
+			sortedmapServices[i] = ((OnlineMapService) mapLoader.onlineMapServices.get(sortingMapServices[i])).getName();
 		}
-		sortedmapServices[j]=sortedmapServices[k];
-		sortedmapServices[k]="===== ===== ===== ===== ===== ===== =====";
-		sortingMapServices[j]=sortingMapServices[k];
-		sortingMapServices[k]=-1;
+		sortedmapServices[j] = sortedmapServices[k];
+		sortedmapServices[k] = "===== ===== ===== ===== ===== ===== =====";
+		sortingMapServices[j] = sortingMapServices[k];
+		sortingMapServices[k] = -1;
 	}
 
 	private int getSortedMapServiceIndex(int originalindex) {
 		for (int i = 0; i < sortingMapServices.length; i++) {
-			if (sortingMapServices[i] == originalindex) return i;
+			if (sortingMapServices[i] == originalindex)
+				return i;
 		}
-		throw new IllegalStateException(MyLocale.getMsg(1818, "getSortedMapServiceIndex: index")+" " + originalindex + MyLocale.getMsg(1819, "not found"));
+		throw new IllegalStateException(MyLocale.getMsg(1818, "getSortedMapServiceIndex: index") + " " + originalindex + MyLocale.getMsg(1819, "not found"));
 	}
 
 	public String getMapsDir() {
 		String ret = Global.getPref().getMapDownloadSavePath(mapLoader.currentOnlineMapService.getMapType());
-		Global.getPref().saveCustomMapsPath(getLeadingPath(ret,Global.getPref().getMapLoadPath()));
+		Global.getPref().saveCustomMapsPath(getLeadingPath(ret, Global.getPref().getMapLoadPath()));
 		// Global.getPref().saveCustomMapsPath(ret);
 		// eigentlich d?rft das erst gespeichert werden, wenn erfolgreich heruntergeladen wurde
 		return ret;
 	}
 
-	private String getLeadingPath(String newPath , String oldPath) {
-		String LeadingPath="";
-		int StartPos=0;
+	private String getLeadingPath(String newPath, String oldPath) {
+		String LeadingPath = "";
+		int StartPos = 0;
 		int EndPos;
-		int LastPos = java.lang.Math.min(newPath.length(),oldPath.length());
+		int LastPos = java.lang.Math.min(newPath.length(), oldPath.length());
 		do {
-			EndPos=java.lang.Math.min(newPath.indexOf("/", StartPos),LastPos);
-			if (newPath.substring(StartPos,EndPos).equals(oldPath.substring(StartPos, EndPos))) {
-				LeadingPath=LeadingPath.concat(newPath.substring(StartPos,EndPos+1));
-				StartPos=EndPos+1;
-			}
-			else {
+			EndPos = java.lang.Math.min(newPath.indexOf("/", StartPos), LastPos);
+			if (newPath.substring(StartPos, EndPos).equals(oldPath.substring(StartPos, EndPos))) {
+				LeadingPath = LeadingPath.concat(newPath.substring(StartPos, EndPos + 1));
+				StartPos = EndPos + 1;
+			} else {
 				break;
 			}
-		} while (StartPos<LastPos);
+		} while (StartPos < LastPos);
 		return LeadingPath;
 	}
 
 	public void downloadTiles() {
 		String mapsDir = getMapsDir();
-		if (mapsDir == null) return;
+		if (mapsDir == null)
+			return;
 		InfoBox progressBox = new InfoBox(MyLocale.getMsg(1815, "Downloading georeferenced maps"), MyLocale.getMsg(1816, "Downloading georeferenced maps\n \n \n \n \n"), InfoBox.PROGRESS_WITH_WARNINGS);
 		progressBox.setPreferredSize(220, 300);
 		progressBox.setInfoHeight(160);
@@ -306,16 +308,16 @@
 		mapLoader.setProgressInfoBox(progressBox);
 		Vm.showWait(true);
 		int length;
-        	switch (tileSize.getSelectedIndex()){
-		    //Perhaps introduce a medium size??
+		switch (tileSize.getSelectedIndex()) {
+		// Perhaps introduce a medium size??
 		case 0:
-		    length=500;
-		    break;
+			length = 500;
+			break;
 		default:
-		    length=1000;
+			length = 1000;
 		}
-		//Override size if one tile for each cache is wanted
-			Point size = new Point(length, length);
+		// Override size if one tile for each cache is wanted
+		Point size = new Point(length, length);
 		if (perCache) {
 			length = 1000;
 			size = new Point(tileWidth, tileHeight);
@@ -328,9 +330,8 @@
 				progressBox.close(0);
 				return;
 			}
-			mapLoader.setTiles(surArea.topleft, surArea.bottomright, scale, size, overlapping );
-		} else
-		{ // calculate from centre point an radius
+			mapLoader.setTiles(surArea.topleft, surArea.bottomright, scale, size, overlapping);
+		} else { // calculate from centre point an radius
 			mapLoader.setTiles(center, radius * 1000, scale, size, overlapping);
 		}
 		if (overviewmap) {
@@ -339,33 +340,28 @@
 			try {
 				mapLoader.downloadMap(center, overviewScale, size, mapsDir);
 			} catch (Exception e) {
-				progressBox.addWarning(MyLocale.getMsg(1825, "Overview map: Ignoring error:")+" " + e.getMessage()+"\n");
+				progressBox.addWarning(MyLocale.getMsg(1825, "Overview map: Ignoring error:") + " " + e.getMessage() + "\n");
 			}
 		}
-		if (!perCache){  // download tiles
+		if (!perCache) { // download tiles
 			mapLoader.setProgressInfoBox(progressBox);
 			mapLoader.setFetchOnlyMapWithCache(fetchOnlyMapWithCacheChkBox.getState());
 			mapLoader.downlaodTiles(mapsDir);
 		} else { // per cache
 			CacheHolder ch;
-			CWPoint tmpca = new CWPoint();
 			int numdownloaded = 0;
 			Global.getProfile().getSourroundingArea(onlySelected); // calculate numCachesInArea
 			int numCaches = Global.getProfile().numCachesInArea;
-			for (int i=cacheDB.size()-1; i >= 0; i--) {
+			for (int i = cacheDB.size() - 1; i >= 0; i--) {
 				ch = cacheDB.get(i);
 				if (!this.onlySelected || ch.is_Checked) {
-					if (ch.pos == null) { // this can not happen
-						tmpca.set(ch.getLatLon());
-						ch.pos = new CWPoint(tmpca);
-					}
-					if (ch.pos.isValid() && ch.pos.latDec != 0 && ch.pos.lonDec != 0) { // TODO != 0 sollte verschwinden, sobald das handling von nicht gesetzten Koos ?berall korrekt ist
+					if (ch.getPos().isValid() && ch.getPos().latDec != 0 && ch.getPos().lonDec != 0) { // TODO != 0 sollte verschwinden, sobald das handling von nicht gesetzten Koos ?berall korrekt ist
 						numdownloaded++;
-						progressBox.setInfo(MyLocale.getMsg(1820, "Downloading map '")+mapLoader.currentOnlineMapService.getName()+"'\n"+numdownloaded+" / "+numCaches+MyLocale.getMsg(1821, "\n for cache:\n")+ch.getCacheName());
+						progressBox.setInfo(MyLocale.getMsg(1820, "Downloading map '") + mapLoader.currentOnlineMapService.getName() + "'\n" + numdownloaded + " / " + numCaches + MyLocale.getMsg(1821, "\n for cache:\n") + ch.getCacheName());
 						try {
-							mapLoader.downloadMap(ch.pos, scale, size, mapsDir);
+							mapLoader.downloadMap(ch.getPos(), scale, size, mapsDir);
 						} catch (Exception e) {
-							progressBox.addWarning(MyLocale.getMsg(1822, "Cache:")+" " + ch.getCacheName() + "(" + ch.getWayPoint() + ") "+MyLocale.getMsg(1823, "Ignoring error:")+" " + e.getMessage()+"\n");
+							progressBox.addWarning(MyLocale.getMsg(1822, "Cache:") + " " + ch.getCacheName() + "(" + ch.getWayPoint() + ") " + MyLocale.getMsg(1823, "Ignoring error:") + " " + e.getMessage() + "\n");
 						}
 					}
 				}
@@ -376,20 +372,19 @@
 		progressBox.addOkButton();
 		progressBox.waitUntilClosed();
 		mapLoader.setProgressInfoBox(null);
-		//progressBox.close(0);
-		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false;
-		//	(new MessageBox("Download maps", "Downloaded and calibrated the maps successfully", MessageBox.OKB)).execute();
+		// progressBox.close(0);
+		if (Global.mainTab.mm != null)
+			Global.mainTab.mm.mapsloaded = false;
+		// (new MessageBox("Download maps", "Downloaded and calibrated the maps successfully", MessageBox.OKB)).execute();
 	}
 
-
 	private void updateForCachesState() {
 		int a, b;
 		if (forCachesChkBox.getState()) {
 			// create map rectangle from caches
 			a = 0;
 			b = ControlConstants.Disabled;
-		}
-		else { // use centre and distance input
+		} else { // use centre and distance input
 			a = ControlConstants.Disabled;
 			b = 0;
 		}
@@ -399,28 +394,29 @@
 		distLbl.modify(b, a);
 		coosBtn.modify(b, a);
 		coosLbl.modify(b, a);
-		km.modify(b,a);
+		km.modify(b, a);
 		repaintNow();
 
 	}
 
-	public void onEvent(Event ev){
-		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelB || ev.target == cancelBPerCache){
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
+			if (ev.target == cancelB || ev.target == cancelBPerCache) {
 				this.close(FormBase.IDCANCEL);
-			}
-			else if (ev.target == okBtiles || ev.target == okBPerCache){
+			} else if (ev.target == okBtiles || ev.target == okBPerCache) {
 				if (sortingMapServices[mapServiceChoice.selectedIndex] == -1) {
 					(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1833, "Please don't select the separator line in the wms service option"), FormBase.OKB)).execute();
 				}
 				mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
 				if (ev.target == okBtiles) { // get tiles
 					perCache = false;
-					if (forSelectedChkBox.getSelectedItem().toString().equalsIgnoreCase(MyLocale.getMsg(1804, "all"))) onlySelected = false;
-					else onlySelected = true;
+					if (forSelectedChkBox.getSelectedItem().toString().equalsIgnoreCase(MyLocale.getMsg(1804, "all")))
+						onlySelected = false;
+					else
+						onlySelected = true;
 					overviewmap = overviewChkBox.getState();
-					radius = (float)CacheWolf.Common.parseDouble(distanceInput.getText());
-					scale = (float)CacheWolf.Common.parseDouble(scaleInput.getText());
+					radius = (float) CacheWolf.Common.parseDouble(distanceInput.getText());
+					scale = (float) CacheWolf.Common.parseDouble(scaleInput.getText());
 					overlapping = Convert.toInt(overlappingInput.getText());
 					if (!forCachesChkBox.getState()) {
 						if (radius <= 0) {
@@ -438,41 +434,43 @@
 					}
 				} else { // per cache
 					perCache = true;
-					if (forSelectedChkBoxPerCache.getSelectedItem().toString().equalsIgnoreCase(MyLocale.getMsg(1804, "all"))) onlySelected = false;
-					else onlySelected = true;
+					if (forSelectedChkBoxPerCache.getSelectedItem().toString().equalsIgnoreCase(MyLocale.getMsg(1804, "all")))
+						onlySelected = false;
+					else
+						onlySelected = true;
 					overviewmap = overviewChkBoxPerCache.getState();
-					scale = (float)CacheWolf.Common.parseDouble(scaleInputPerCache.getText());
+					scale = (float) CacheWolf.Common.parseDouble(scaleInputPerCache.getText());
 					tileWidth = CacheWolf.Common.parseInt(tileWidthInput.getText());
 					tileHeight = CacheWolf.Common.parseInt(tileHeightInput.getText());
 					if (tileWidth <= 0) {
 						new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1836, "Width of tiles must be greater 0."), FormBase.OKB).execute();
-						initTileInputfields ();
+						initTileInputfields();
 						return;
 					}
 					if (tileHeight <= 0) {
 						new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1837, "Height of tiles must be greater 0."), FormBase.OKB).execute();
-						initTileInputfields ();
+						initTileInputfields();
 						return;
 					}
 					// If width and height has been valid, set them in preferences also:
-					pref.tileheight=tileHeight;
-					pref.tilewidth=tileWidth;
+					pref.tileheight = tileHeight;
+					pref.tilewidth = tileWidth;
 				}
 				if (scale < mapLoader.currentOnlineMapService.minscale || scale > mapLoader.currentOnlineMapService.maxscale) {
 					if (scale < mapLoader.currentOnlineMapService.minscale) {
 						scaleInput.setText(Convert.toString(mapLoader.currentOnlineMapService.minscale));
-						scaleInputPerCache.setText(Convert.toString(java.lang.Math.ceil(mapLoader.currentOnlineMapService.minscale*100)/100));
+						scaleInputPerCache.setText(Convert.toString(java.lang.Math.ceil(mapLoader.currentOnlineMapService.minscale * 100) / 100));
 					} else {
-						scaleInput.setText(Convert.toString(java.lang.Math.floor(mapLoader.currentOnlineMapService.maxscale*100)/100));
+						scaleInput.setText(Convert.toString(java.lang.Math.floor(mapLoader.currentOnlineMapService.maxscale * 100) / 100));
 						scaleInputPerCache.setText(Convert.toString(mapLoader.currentOnlineMapService.maxscale));
 					}
-					(new MessageBox(MyLocale.getMsg(321, "Error"), "! " + scale + "\n" + MyLocale.getMsg(1830, "The selected online map service provides map in the scale from") + " " + mapLoader.currentOnlineMapService.minscale + MyLocale.getMsg(1831, " to") + " " + mapLoader.currentOnlineMapService.maxscale + MyLocale.getMsg(1832, "\n please adjust 'Approx. meter pro pixel' accordingly"), FormBase.OKB)).execute();
+					(new MessageBox(MyLocale.getMsg(321, "Error"), "! " + scale + "\n" + MyLocale.getMsg(1830, "The selected online map service provides map in the scale from") + " " + mapLoader.currentOnlineMapService.minscale
+							+ MyLocale.getMsg(1831, " to") + " " + mapLoader.currentOnlineMapService.maxscale + MyLocale.getMsg(1832, "\n please adjust 'Approx. meter pro pixel' accordingly"), FormBase.OKB)).execute();
 					return;
 				}
 				this.close(FormBase.IDOK);
 				this.downloadTiles();
-			}
-			else if (ev.target == coosBtn) {
+			} else if (ev.target == coosBtn) {
 				CoordsScreen cs = new CoordsScreen();
 				cs.setFields(center, TransformCoordinates.CW);
 				if (cs.execute() != FormBase.IDCANCEL) {
@@ -482,32 +480,29 @@
 					sortMapServices();
 					mapServiceChoice.set(sortedmapServices, (!inbound[tmp] ? 0 : getSortedMapServiceIndex((tmp))));
 				}
-			}
-			else if (ev.target == forCachesChkBox) {
+			} else if (ev.target == forCachesChkBox) {
 				updateForCachesState();
+			} else if (ev.target == tileSize) {
+				switch (tileSize.getSelectedIndex()) {
+				case 0:
+					overlappingInput.setText("10");
+					pref.mapTileSize = 0;
+					pref.mapOverlapping = 10;
+					break;
+				default:
+					overlappingInput.setText("100");
+					pref.mapTileSize = 1;
+					pref.mapOverlapping = 100;
+				}
 			}
-			else if (ev.target == tileSize){
-			    switch (tileSize.getSelectedIndex()){
-			    case 0:
-			    overlappingInput.setText ("10");
-			    pref.mapTileSize=0;
-			    pref.mapOverlapping=10;
-			    break;
-			    default:
-			    overlappingInput.setText ("100");
-			    pref.mapTileSize=1;
-			    pref.mapOverlapping=100;
-			    }
-			}
 		} // end of "if controllEvent..."
-		if (ev instanceof DataChangeEvent){
-		    if (ev.target == mapServiceChoice) {
-			mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
-			setRecommScaleInput();
-		    }
-		    else if (ev.target == overlappingInput){
-			pref.mapOverlapping = Convert.toInt(overlappingInput.getText ());
-		    }
+		if (ev instanceof DataChangeEvent) {
+			if (ev.target == mapServiceChoice) {
+				mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
+				setRecommScaleInput();
+			} else if (ev.target == overlappingInput) {
+				pref.mapOverlapping = Convert.toInt(overlappingInput.getText());
+			}
 		}
 		super.onEvent(ev);
 	}

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1016,7 +1016,7 @@
 	}
 
 	public void destChanged(CacheHolder ch) {
-		final CWPoint d = new CWPoint(ch.pos);
+		final CWPoint d = new CWPoint(ch.getPos());
 		if (!running || (gotoPos != null && gotoPos.where.equals(d)))
 			return;
 		removeMapSymbol("goto");
@@ -1190,18 +1190,18 @@
 		final Area screenArea = new Area(ScreenXY2LatLon(0, 0), ScreenXY2LatLon(width, height));
 		for (int i = cacheDB.size() - 1; i >= 0; i--) {
 			ch = cacheDB.get(i);
-			if (screenArea.isInBound(ch.pos)) {
+			if (screenArea.isInBound(ch.getPos())) {
 				// because visible and valid don't change while showing map
 				// -->need no remove
-				if (ch.isVisible() && ch.pos.isValid()) {
+				if (ch.isVisible() && ch.getPos().isValid()) {
 					if (pref.showCachesOnMap) {
 						if (addSymbolIsNecessary(ch.getWayPoint())) {
-							addSymbol(ch.getWayPoint(), ch, CacheType.getMapImage(ch), ch.pos);
+							addSymbol(ch.getWayPoint(), ch, CacheType.getMapImage(ch), ch.getPos());
 						}
 					} else {
 						if (ch.is_Checked || ch == cacheDB.get(Global.mainTab.tbP.getSelectedCache())) {
 							if (addSymbolIsNecessary(ch.getWayPoint())) {
-								addSymbol(ch.getWayPoint(), ch, CacheType.getMapImage(ch), ch.pos);
+								addSymbol(ch.getWayPoint(), ch, CacheType.getMapImage(ch), ch.getPos());
 							}
 						} else {
 							removeMapSymbol(ch);
@@ -1223,9 +1223,9 @@
 				gotoPosCH = (CacheHolder) gotoPos.mapObject;
 			}
 			if (gotoPosCH != null) {
-				if (screenArea.isInBound(gotoPosCH.pos)) {
+				if (screenArea.isInBound(gotoPosCH.getPos())) {
 					if (!pref.showCachesOnMap) {
-						addSymbolIfNecessary(gotoPosCH.getWayPoint(), gotoPosCH, CacheType.getMapImage(gotoPosCH), gotoPosCH.pos);
+						addSymbolIfNecessary(gotoPosCH.getWayPoint(), gotoPosCH, CacheType.getMapImage(gotoPosCH), gotoPosCH.getPos());
 					}
 					addSymbolIfNecessary("goto", gotoPosCH, imgGoto, gotoPos.where);
 				}
@@ -1235,8 +1235,8 @@
 		removeMapSymbol("selectedCache");
 		ch = cacheDB.get(Global.mainTab.tbP.getSelectedCache());
 		if (ch != null) {
-			if (screenArea.isInBound(ch.pos)) {
-				addSymbolIfNecessary("selectedCache", ch, imgSelectedCache, ch.pos);
+			if (screenArea.isInBound(ch.getPos())) {
+				addSymbolIfNecessary("selectedCache", ch, imgSelectedCache, ch.getPos());
 			}
 		}
 	}
@@ -2864,8 +2864,7 @@
 					if (action == newWayPointMenuItem) {
 						leaveMovingMap();
 						final CacheHolder newWP = new CacheHolder();
-						newWP.pos = mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y);
-						newWP.setLatLon(newWP.pos.toString());
+						newWP.setPos(mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y));
 						Global.mainTab.newWaypoint(newWP);
 					}
 					if (action == addCachetoListMenuItem) {

Modified: trunk/src/CacheWolf/navi/Navigate.java
===================================================================
--- trunk/src/CacheWolf/navi/Navigate.java	2011-07-21 08:38:18 UTC (rev 3044)
+++ trunk/src/CacheWolf/navi/Navigate.java	2011-07-21 10:26:34 UTC (rev 3045)
@@ -1,30 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
- 
+
 import net.ax86.GPS;
 import net.ax86.GPSException;
 
@@ -46,13 +46,13 @@
 import ewe.ui.MessageBox;
 import ewe.util.mString;
 
-
 /**
  * Non-Gui Class to handle all things regarding navigation
  * (GPS, Sun direction etc.)
  * start offset in localisation file: 4400
+ * 
  * @author Pfeffer
- *
+ * 
  */
 public class Navigate {
 	public CWPoint destination = new CWPoint();
@@ -60,7 +60,7 @@
 	public boolean destinationIsCache = false;
 	public CWGPSPoint gpsPos = new CWGPSPoint();
 	public Track curTrack = null;
-	public Color trackColor = new Color(255,0,0); // red
+	public Color trackColor = new Color(255, 0, 0); // red
 	public CWPoint skyOrientationDir = new CWPoint();
 	public int luminary = SkyOrientation.SUN;
 
@@ -78,160 +78,167 @@
 	public void setGotoPanel(GotoPanel gp) {
 		gotoPanel = gp;
 	}
-	public void setMovingMap (MovingMap mm) {
+
+	public void setMovingMap(MovingMap mm) {
 		movingMap = mm;
-		if (gpsRunning) mm.gpsStarted();
+		if (gpsRunning)
+			mm.gpsStarted();
 	}
 
 	public void startGps(boolean loggingOn, int loggingIntervall) {
 		lograw = loggingOn;
 		logIntervall = loggingIntervall; // TODO switch on and off during serthread running
-		
-		switch(Global.getPref().useGPSD) {
-			// Tblue> TODO: NEW vs. OLD: This is ugly! The only line that's
-			//        different is the one where the object is created!
-			case Preferences.GPSD_FORMAT_NEW:
-				try {
-					gpsdThread = new GpsdThread(gpsPos);
-					gpsdThread.start();
-					startDisplayTimer();
-					gpsRunning = true;
-					curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
-					if (lograw)	gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
-					if (gotoPanel != null) gotoPanel.gpsStarted();
-					if (movingMap != null) movingMap.gpsStarted();
-				} catch (IOException e) {
-					(new MessageBox(MyLocale.getMsg(4403, "Error"),
-						MyLocale.getMsg(4408, "Could not connect to GPSD: ")
-						+ e.getMessage()
-						+ MyLocale.getMsg(4409, "\nPossible reasons:\nGPSD is not running or GPSD host is not reachable"),
-						FormBase.OKB)).execute();
-				} catch( Exception e ) {
-					// Other error (JSON/GPS).
-					(new MessageBox(MyLocale.getMsg(4403, "Error"),
-						MyLocale.getMsg(99999, "Could not initialize GPSD connection: ") 
-						+ e.getMessage(),
-						FormBase.OKB)).execute();
-				}
-				break;
 
-			case Preferences.GPSD_FORMAT_OLD:
-				try {
-					oldGpsdThread = new OldGpsdThread(gpsPos);
-					oldGpsdThread.start();
-					startDisplayTimer();
-					gpsRunning = true;
-					curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
-					if (lograw)	gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
-					if (gotoPanel != null) gotoPanel.gpsStarted();
-					if (movingMap != null) movingMap.gpsStarted();
-				} catch (IOException e) {
-					(new MessageBox(MyLocale.getMsg(4403, "Error"),
-						MyLocale.getMsg(4408, "Could not connect to GPSD: ")
-						+ e.getMessage()
-						+ MyLocale.getMsg(4409, "\nPossible reasons:\nGPSD is not running or GPSD host is not reachable"),
-						FormBase.OKB)).execute();
-				}
-				break;
+		switch (Global.getPref().useGPSD) {
+		// Tblue> TODO: NEW vs. OLD: This is ugly! The only line that's
+		// different is the one where the object is created!
+		case Preferences.GPSD_FORMAT_NEW:
+			try {
+				gpsdThread = new GpsdThread(gpsPos);
+				gpsdThread.start();
+				startDisplayTimer();
+				gpsRunning = true;
+				curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
+				if (lograw)
+					gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
+				if (gotoPanel != null)
+					gotoPanel.gpsStarted();
+				if (movingMap != null)
+					movingMap.gpsStarted();
+			} catch (IOException e) {
+				(new MessageBox(MyLocale.getMsg(4403, "Error"), MyLocale.getMsg(4408, "Could not connect to GPSD: ") + e.getMessage() + MyLocale.getMsg(4409, "\nPossible reasons:\nGPSD is not running or GPSD host is not reachable"), FormBase.OKB))
+						.execute();
+			} catch (Exception e) {
+				// Other error (JSON/GPS).
+				(new MessageBox(MyLocale.getMsg(4403, "Error"), MyLocale.getMsg(99999, "Could not initialize GPSD connection: ") + e.getMessage(), FormBase.OKB)).execute();
+			}
+			break;
 
-			case Preferences.GPSD_DISABLED:
-			default:
-				if (serThread != null) if (serThread.isAlive()) return; // TODO use gpsRunning
-				try {
-					serThread = new SerialThread(pref.mySPO, gpsPos, (pref.forwardGPS ? pref.forwardGpsHost : ""));
-					if (pref.forwardGPS && !serThread.tcpForward) {
-						(new MessageBox(MyLocale.getMsg(4400, "Warning"),
-								MyLocale.getMsg(4401, "Ignoring error:\n could not forward GPS data to host:\n")
-								+ pref.forwardGpsHost+"\n" + serThread.lastError
-								+ MyLocale.getMsg(4402, "\nstop and start GPS to retry"), FormBase.OKB)).exec();
-					}
-					serThread.start();
-					startDisplayTimer();
-					gpsRunning = true;
-					curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
-					if (lograw)	gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
-					if (gotoPanel != null) gotoPanel.gpsStarted();
-					if (movingMap != null) movingMap.gpsStarted();
-				} catch (IOException e) {
-					(new MessageBox(MyLocale.getMsg(4403, "Error"),
-							MyLocale.getMsg(4404, "Could not connect to GPS-receiver.\n Error while opening serial Port ")
-							+ e.getMessage()
-							+ MyLocale.getMsg(4405, "\npossible reasons:\n Another (GPS-)program is blocking the port\nwrong port\nOn Loox: active infra-red port is blocking GPS"),
-							FormBase.OKB)).execute();
-				} catch (UnsatisfiedLinkError e) {
-					(new MessageBox(MyLocale.getMsg(4403, "Error"),
-							MyLocale.getMsg(4404, "Could not connect to GPS-receiver.\n Error while opening serial Port ")
-							+ MyLocale.getMsg(4406, "Please copy jave_ewe.dll into the directory of the cachewolf program"),
-							FormBase.OKB)).execute();
+		case Preferences.GPSD_FORMAT_OLD:
+			try {
+				oldGpsdThread = new OldGpsdThread(gpsPos);
+				oldGpsdThread.start();
+				startDisplayTimer();
+				gpsRunning = true;
+				curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
+				if (lograw)
+					gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
+				if (gotoPanel != null)
+					gotoPanel.gpsStarted();
+				if (movingMap != null)
+					movingMap.gpsStarted();
+			} catch (IOException e) {
+				(new MessageBox(MyLocale.getMsg(4403, "Error"), MyLocale.getMsg(4408, "Could not connect to GPSD: ") + e.getMessage() + MyLocale.getMsg(4409, "\nPossible reasons:\nGPSD is not running or GPSD host is not reachable"), FormBase.OKB))
+						.execute();
+			}
+			break;
+
+		case Preferences.GPSD_DISABLED:
+		default:
+			if (serThread != null)
+				if (serThread.isAlive())
+					return; // TODO use gpsRunning
+			try {
+				serThread = new SerialThread(pref.mySPO, gpsPos, (pref.forwardGPS ? pref.forwardGpsHost : ""));
+				if (pref.forwardGPS && !serThread.tcpForward) {
+					(new MessageBox(MyLocale.getMsg(4400, "Warning"), MyLocale.getMsg(4401, "Ignoring error:\n could not forward GPS data to host:\n") + pref.forwardGpsHost + "\n" + serThread.lastError
+							+ MyLocale.getMsg(4402, "\nstop and start GPS to retry"), FormBase.OKB)).exec();
 				}
-				break;
+				serThread.start();
+				startDisplayTimer();
+				gpsRunning = true;
+				curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
+				if (lograw)
+					gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
+				if (gotoPanel != null)
+					gotoPanel.gpsStarted();
+				if (movingMap != null)
+					movingMap.gpsStarted();
+			} catch (IOException e) {
+				(new MessageBox(MyLocale.getMsg(4403, "Error"), MyLocale.getMsg(4404, "Could not connect to GPS-receiver.\n Error while opening serial Port ") + e.getMessage()
+						+ MyLocale.getMsg(4405, "\npossible reasons:\n Another (GPS-)program is blocking the port\nwrong port\nOn Loox: active infra-red port is blocking GPS"), FormBase.OKB)).execute();
+			} catch (UnsatisfiedLinkError e) {
+				(new MessageBox(MyLocale.getMsg(4403, "Error"), MyLocale.getMsg(4404, "Could not connect to GPS-receiver.\n Error while opening serial Port ")
+						+ MyLocale.getMsg(4406, "Please copy jave_ewe.dll into the directory of the cachewolf program"), FormBase.OKB)).execute();
+			}
+			break;
 		}
 	}
+
 	public void startDisplayTimer() {
 		tickerThread = new UpdateThread(this, 1000);
 		tickerThread.start();
 	}
 
-	public void stopDisplayTimer(){
-		if (tickerThread != null) tickerThread.stop();
+	public void stopDisplayTimer() {
+		if (tickerThread != null)
+			tickerThread.stop();
 	}
 
 	public void stopGps() {
-		if(serThread!=null)	serThread.stop();
-		if(gpsdThread!=null) gpsdThread.stop();
-		if(oldGpsdThread!=null) oldGpsdThread.stop();
+		if (serThread != null)
+			serThread.stop();
+		if (gpsdThread != null)
+			gpsdThread.stop();
+		if (oldGpsdThread != null)
+			oldGpsdThread.stop();
 		stopDisplayTimer();
 		gpsPos.stopLog();
 		gpsRunning = false;
-		if (gotoPanel != null) gotoPanel.gpsStoped();
-		if (movingMap != null) movingMap.gpsStoped();
+		if (gotoPanel != null)
+			gotoPanel.gpsStoped();
+		if (movingMap != null)
+			movingMap.gpsStoped();
 	}
 
 	public boolean isGpsPosValid() {
-		return ((serThread != null && serThread.isAlive()) ||
-		       (gpsdThread != null && gpsdThread.isAlive()) ||
-		       (oldGpsdThread != null && oldGpsdThread.isAlive()))
-		        && gpsPos.isValid() ; // && gpsPos.getfiex();
+		return ((serThread != null && serThread.isAlive()) || (gpsdThread != null && gpsdThread.isAlive()) || (oldGpsdThread != null && oldGpsdThread.isAlive())) && gpsPos.isValid(); // && gpsPos.getfiex();
 	}
 
-
 	public void setDestination(String LatLon) {
 		setDestination(new CWPoint(LatLon));
 	}
 
-
 	public void setDestination(CWPoint d) {
 		destinationIsCache = false;
-		destination = new CWPoint (d);
-		if (gotoPanel != null) gotoPanel.destChanged(destination);
-		if (movingMap != null) movingMap.destChanged(destination);
+		destination = new CWPoint(d);
+		if (gotoPanel != null)
+			gotoPanel.destChanged(destination);
+		if (movingMap != null)
+			movingMap.destChanged(destination);
 	}
 
 	public void setDestination(CacheHolder ch) {
 		destinationIsCache = true;
-		destinationCache=ch;
-		destination = new CWPoint (ch.pos);
-		if (gotoPanel != null) gotoPanel.destChanged(destination);
-		if (movingMap != null) movingMap.destChanged(ch);
+		destinationCache = ch;
+		destination = new CWPoint(ch.getPos());
+		if (gotoPanel != null)
+			gotoPanel.destChanged(destination);
+		if (movingMap != null)
+			movingMap.destChanged(ch);
 	}
 
 	/**
 	 * use the constants SkyOrientation.SUN, SkyOrientation.MOON etc.
+	 * 
 	 * @param lu
 	 */
 	public void setLuminary(int lu) {
 		luminary = lu;
 	}
+
 	public void ticked() {
 		int fix = gpsPos.getFix();
-		if (fix > 0 && (gpsPos.getSats()>= 0)) {
-			if (curTrack == null) curTrack = new Track(trackColor);
+		if (fix > 0 && (gpsPos.getSats() >= 0)) {
+			if (curTrack == null)
+				curTrack = new Track(trackColor);
 			try {
 				curTrack.add(gpsPos);
 			} catch (IndexOutOfBoundsException e) { // track full -> create a new one
 				curTrack = new Track(trackColor);
 				curTrack.add(gpsPos);
-				if (movingMap != null) movingMap.addTrack(curTrack);
+				if (movingMap != null)
+					movingMap.addTrack(curTrack);
 			}
 			try {
 				SkyOrientation.getSunAzimut(gpsPos.Time, gpsPos.Date, gpsPos.latDec, gpsPos.lonDec);
@@ -245,14 +252,14 @@
 			skyOrientationDir.set(-361, -361); // any value out of range (bigger than 360) will prevent drawArrows from drawing it
 		}
 		gotoPanel.updateGps(fix);
-		if (movingMap != null) movingMap.updateGps(fix);
+		if (movingMap != null)
+			movingMap.updateGps(fix);
 	}
 }
 
-
 /**
  * Thread for reading data from gpsd.
- *
+ * 
  * @author Tilman Blumenbach
  */
 class GpsdThread extends mThread {
@@ -260,27 +267,24 @@
 	CWGPSPoint myGPS;
 	boolean run;
 
-
 	public GpsdThread(CWGPSPoint GPSPoint) throws IOException, JSONException, GPSException {
 		JSONObject response;
 		int proto_major;
 
 		myGPS = GPSPoint;
 		gpsObj = new GPS(Global.getPref().gpsdHost, Global.getPref().gpsdPort);
-		gpsObj.stream( GPS.WATCH_ENABLE );
+		gpsObj.stream(GPS.WATCH_ENABLE);
 
 		// Check major protocol version:
 		response = gpsObj.read();
 
-		if( ! response.getString( "class" ).equals( "VERSION" ) ) {
-			throw new GPSException( "Expected VERSION object at connect." );
-		} else if( ( proto_major = response.getInt( "proto_major" ) ) != 3 ) {
-			throw new GPSException( "Invalid protocol API version; got " +
-					proto_major + ", want 3." );
+		if (!response.getString("class").equals("VERSION")) {
+			throw new GPSException("Expected VERSION object at connect.");
+		} else if ((proto_major = response.getInt("proto_major")) != 3) {
+			throw new GPSException("Invalid protocol API version; got " + proto_major + ", want 3.");
 		}
 	}
 
-
 	public void run() {
 		JSONObject response;
 		String respClass;
@@ -290,46 +294,46 @@
 
 		run = true;
 		while (run) {
-			if( gpsObj != null ) {
+			if (gpsObj != null) {
 				gotValidData = false;
 
 				try {
-					/* Tblue> This is ugly, but BufferedReader::ready() seems to
-					 *        be broken in Ewe, so instead of only polling when
-					 *        there is no data from gpsd (by checking the return
-					 *        value of GPS::waiting(), we poll on every iteration.
-					 *        Not ideal, but works for now.
+					/*
+					 * Tblue> This is ugly, but BufferedReader::ready() seems to
+					 * be broken in Ewe, so instead of only polling when
+					 * there is no data from gpsd (by checking the return
+					 * value of GPS::waiting(), we poll on every iteration.
+					 * Not ideal, but works for now.
 					 */
 					gpsObj.poll();
 
-					/* Tblue> TODO: I think this call should not block, but
-					 *              my GPS class does not yet support non-blocking
-					 *              reads...
+					/*
+					 * Tblue> TODO: I think this call should not block, but
+					 * my GPS class does not yet support non-blocking
+					 * reads...
 					 */
-					response  = gpsObj.read();
-					
+					response = gpsObj.read();
+
 					// If we get here we have got some data:
 					noData = 0;
 
-					respClass = response.getString( "class" );
-					if( respClass.equals( "DEVICE" ) && response.has( "activated" ) &&
-						response.getDouble( "activated" ) != 0 )
-					{	// This is a new device, we need to tell gpsd we want to watch it:
-						Global.getPref().log( "New GPS device, sending WATCH command." );
-						gpsObj.stream( GPS.WATCH_ENABLE );
-					} else if( respClass.equals( "POLL" ) ) {
+					respClass = response.getString("class");
+					if (respClass.equals("DEVICE") && response.has("activated") && response.getDouble("activated") != 0) { // This is a new device, we need to tell gpsd we want to watch it:
+						Global.getPref().log("New GPS device, sending WATCH command.");
+						gpsObj.stream(GPS.WATCH_ENABLE);
+					} else if (respClass.equals("POLL")) {
 						gotValidData = myGPS.examineGpsd(response);
-					} else if( respClass.equals( "ERROR" ) ) {
+					} else if (respClass.equals("ERROR")) {
 						// Global.getPref().log( "Ignored gpsd error: " + response.getString( "message" ) );
 					}
-				} catch( Exception e ) {
+				} catch (Exception e) {
 					// Something bad happened, will just ignore this JSON
 					// object:
 					// Ignored Exception", e, true);
 					gotValidData = false;
 				}
 
-				if( gotValidData ) {
+				if (gotValidData) {
 					notInterpreted = 0;
 				} else {
 					notInterpreted++;
@@ -354,18 +358,16 @@
 		myGPS.noData();
 	}
 
-
 	public void stop() {
 		run = false;
 
-		if( gpsObj != null ) {
+		if (gpsObj != null) {
 			gpsObj.cleanup();
 		}
 	}
 }
 
-
-class OldGpsdThread extends mThread{
+class OldGpsdThread extends mThread {
 	Socket gpsdSocket;
 	CWGPSPoint myGPS;
 	boolean run, tcpForward;
@@ -373,7 +375,7 @@
 	String lastError = new String();
 
 	public OldGpsdThread(CWGPSPoint GPSPoint) throws IOException {
-		try{
+		try {
 			gpsdSocket = new Socket(Global.getPref().gpsdHost, Global.getPref().gpsdPort);
 		} catch (IOException e) {
 			throw new IOException(Global.getPref().gpsdHost);
@@ -386,33 +388,36 @@
 		int noData = 0;
 		int notinterpreted = 0;
 		run = true;
-		while (run){
+		while (run) {
 			try {
 				sleep(900);
 				noData++;
-				if (noData > 5) { myGPS.noDataError(); }
+				if (noData > 5) {
+					myGPS.noDataError();
+				}
 			} catch (InterruptedException e) {
 				// Global.getPref().log("Ignored Exception", e, true);
 			}
-			if (gpsdSocket != null)	{
+			if (gpsdSocket != null) {
 				gpsResult = getGpsdData("ADPQTV\r\n");
-				if (gpsResult!=null) {
+				if (gpsResult != null) {
 					noData = 0;
 					if (myGPS.examineOldGpsd(gpsResult))
 						notinterpreted = 0;
 					else
 						notinterpreted++;
-					if (notinterpreted > 22) myGPS.noInterpretableData();
+					if (notinterpreted > 22)
+						myGPS.noInterpretableData();
 				}
 			}
 
-			//myGPS.printAll();
+			// myGPS.printAll();
 		} // while
 		myGPS.noData();
 	}
 
 	private String getGpsdData(String command) {
-		byte[] rcvBuff = new byte[1024*10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
+		byte[] rcvBuff = new byte[1024 * 10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
 		int rcvLength = 0;
 		try {
 			gpsdSocket.write(command.getBytes());
@@ -430,7 +435,7 @@
 			Global.getPref().log("Socket exception", e, true);
 		}
 		String str = null;
-		if (rcvLength > 0)	{
+		if (rcvLength > 0) {
 			str = mString.fromAscii(rcvBuff, 0, rcvLength);
 		}
 		return str;
@@ -438,18 +443,18 @@
 
 	public void stop() {
 		run = false;
-		if (gpsdSocket != null) gpsdSocket.close();
+		if (gpsdSocket != null)
+			gpsdSocket.close();
 	}
 }
 
-
 /**
  * Thread for reading data from COM-port
- *
+ * 
  */
-class SerialThread extends mThread{
+class SerialThread extends mThread {
 	SerialPort comSp;
-	byte[] comBuff = new byte[1024*10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
+	byte[] comBuff = new byte[1024 * 10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
 	int comLength = 0;
 	CWGPSPoint myGPS;
 	boolean run, tcpForward;
@@ -457,18 +462,22 @@
 	String lastError = new String();
 
 	public SerialThread(SerialPortOptions spo, CWGPSPoint GPSPoint, String forwardIP) throws IOException {
-		try{
+		try {
 			spo.portName = CacheWolf.Common.fixSerialPortName(spo.portName);
 			comSp = new SerialPort(spo);
 		} catch (IOException e) {
 			throw new IOException(spo.portName);
 		} // catch (UnsatisfiedLinkError e) {} // TODO in original java-vm
-		if (forwardIP.length()>0) {
+		if (forwardIP.length() > 0) {
 			try {
 				tcpConn = new Socket(forwardIP, 23);
 				tcpForward = true;
-			} catch (ewe.net.UnknownHostException e) { tcpForward = false; lastError = e.getMessage();
-			} catch (IOException e) { tcpForward = false; lastError = e.getMessage();
+			} catch (ewe.net.UnknownHostException e) {
+				tcpForward = false;
+				lastError = e.getMessage();
+			} catch (IOException e) {
+				tcpForward = false;
+				lastError = e.getMessage();
 			}
 		}
 		myGPS = GPSPoint;
@@ -478,26 +487,34 @@
 		int noData = 0;
 		int notinterpreted = 0;
 		run = true;
-		while (run){
+		while (run) {
 			try {
 				sleep(1000);
 				noData++;
-				if (noData > 5) { myGPS.noDataError(); }
+				if (noData > 5) {
+					myGPS.noDataError();
+				}
 			} catch (InterruptedException e) {
 				// Global.getPref().log("Ignored Exception", e, true);
 			}
-			if (comSp != null)	{
-				comLength = comSp.nonBlockingRead(comBuff, 0 ,comBuff.length);
-				if (comLength > 0)	{
+			if (comSp != null) {
+				comLength = comSp.nonBlockingRead(comBuff, 0, comBuff.length);
+				if (comLength > 0) {
 					noData = 0;
 					String str = mString.fromAscii(comBuff, 0, comLength);
 					if (tcpForward) {
 						try {
 							tcpConn.write(comBuff, 0, comLength);
-						} catch (IOException e) { tcpForward = false; }
+						} catch (IOException e) {
+							tcpForward = false;
+						}
 					}
-					if (myGPS.examine(str)) notinterpreted = 0; else notinterpreted++;
-					if (notinterpreted > 22) myGPS.noInterpretableData();
+					if (myGPS.examine(str))
+						notinterpreted = 0;
+					else
+						notinterpreted++;
+					if (notinterpreted > 22)
+						myGPS.noInterpretableData();
 				}
 			}
 		} // while
@@ -507,7 +524,8 @@
 
 	public void stop() {
 		run = false;
-		if (comSp != null) comSp.close();
+		if (comSp != null)
+			comSp.close();
 	}
 }
 
@@ -522,16 +540,21 @@
 	public int calldelay;
 	public Navigate ticked;
 
-	public UpdateThread (Navigate gp, int cd) {
+	public UpdateThread(Navigate gp, int cd) {
 		ticked = gp;
 		calldelay = cd;
 	}
 
-	public void run () {
+	public void run() {
 		run = true;
 		while (run) {
-			try { sleep (calldelay);} catch (InterruptedException e) {	}
-			try { ticked.ticked();} catch (Exception e) {
+			try {
+				sleep(calldelay);
+			} catch (InterruptedException e) {
+			}
+			try {
+				ticked.ticked();
+			} catch (Exception e) {
 				// Global.getPref().log("Navigate.UpdateThread.run(): Ignored Exception. There should not be an Exception, so please report it in the cachewolf forum at www.geoclub.de", e, true);
 			}
 		}
@@ -541,6 +564,3 @@
 		run = false;
 	}
 }
-
-
-



From araber95 at mail.berlios.de  Thu Jul 21 03:29:33 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Thu, 21 Jul 2011 03:29:33 PM +0200
Subject: [Cachewolf-svn] r3046 - in trunk: . src/CacheWolf
Message-ID: <20110721132933.D77D548295F@sheep.berlios.de>

Author: araber95
Date: 2011-07-21 15:29:33 +0200 (Thu, 21 Jul 2011)
New Revision: 3046

Modified:
   trunk/
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/ImagePanel.java
Log:
reduced number of pictures shown in picture tab and tpl/html-export.


Property changes on: trunk
___________________________________________________________________
Modified: svn:ignore
   - .project
.settings
CacheWolf
bin
published
work

   + .project
.settings
CacheWolf
bin
published
work

*.metadata


Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2011-07-21 10:26:34 UTC (rev 3045)
+++ trunk/src/CacheWolf/CacheHolder.java	2011-07-21 13:29:33 UTC (rev 3046)
@@ -810,18 +810,32 @@
 			for (int i = 0; i < det.images.size(); i++) {
 				Hashtable imgs = new Hashtable();
 				String imgFile = det.images.get(i).getFilename();
-				imgs.put("FILENAME", imgFile);
-				imgs.put("TEXT", det.images.get(i).getTitle());
-				imgs.put("COMMENT", det.images.get(i).getComment());
-				imgs.put("URL", det.images.get(i).getURL());
-				if (!expName.equals("")) {
-					String src = Global.getProfile().dataDir + imgFile;
-					String dest = Global.getPref().getExportPath(expName) + imgFile;
-					if (!DataMover.copy(src, dest)) {
-						Global.getPref().log("[CacheHolder:toHashtable]error copying " + imgFile + " to " + Global.getPref().getExportPath(expName));
+				boolean doit = true;
+				for (int j = i + 1; j < det.images.size(); j++) {
+					String jmgFile = det.images.get(j).getFilename();
+					if (imgFile.equals(jmgFile)) {
+						doit = false;
+						break;
 					}
 				}
-				imgVect.add(imgs);
+				if (doit) {
+					imgs.put("FILENAME", imgFile);
+					String title = det.images.get(i).getTitle();
+					imgs.put("TEXT", title);
+					String comment = det.images.get(i).getComment();
+					imgs.put("COMMENT", comment);
+					imgs.put("URL", det.images.get(i).getURL());
+					if (!expName.equals("")) {
+						String src = Global.getProfile().dataDir + imgFile;
+						String dest = Global.getPref().getExportPath(expName) + imgFile;
+						if (!DataMover.copy(src, dest)) {
+							Global.getPref().log("[CacheHolder:toHashtable]error copying " + imgFile + " to " + Global.getPref().getExportPath(expName));
+						}
+					}
+					if (!title.toLowerCase().startsWith(wayPoint.toLowerCase())) {
+						imgVect.add(imgs);
+					}
+				}
 			}
 			varParams.put("cacheImg", imgVect);
 		}

Modified: trunk/src/CacheWolf/ImagePanel.java
===================================================================
--- trunk/src/CacheWolf/ImagePanel.java	2011-07-21 10:26:34 UTC (rev 3045)
+++ trunk/src/CacheWolf/ImagePanel.java	2011-07-21 13:29:33 UTC (rev 3046)
@@ -1,29 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 import CacheWolf.utils.FileBugfix;
 import ewe.fx.Color;
 import ewe.fx.Font;
@@ -45,105 +46,110 @@
 import ewe.ui.MessageBox;
 import ewe.ui.PenEvent;
 
-
 /**
-*	Class to display the cache and log images. It creates a thumbnail view and
-*	allows the user to click on an image that will then be displayed in its original size
-*	as long as the image fits the application size. If the application size is not sufficient
-*	then the image will be scaled to the available screen size.
-*   A right mouseclick on an image will open a dialogue to delete the file. 
-*/
-public class ImagePanel extends InteractivePanel{
+ * Class to display the cache and log images. It creates a thumbnail view and
+ * allows the user to click on an image that will then be displayed in its original size
+ * as long as the image fits the application size. If the application size is not sufficient
+ * then the image will be scaled to the available screen size.
+ * A right mouseclick on an image will open a dialogue to delete the file.
+ */
+public class ImagePanel extends InteractivePanel {
 	/** Picture to replace deleted pictures */
-	private final String NO_IMAGE="no_picture.png";
+	private final String NO_IMAGE = "no_picture.png";
 	/** Minimum time (msec) to recognise a long pen down event (=right mouse key) */
-	private final int LONG_PEN_DOWN_DURATION=500;
+	private final int LONG_PEN_DOWN_DURATION = 500;
 
 	Preferences pref;
 	Profile profile;
-	//private final int thumb_max_size = 300;
-	//private final int thumb_min_size = 100;
+	// private final int thumb_max_size = 300;
+	// private final int thumb_min_size = 100;
 	private final int padding = 20;
 	private int thumb_size = 0;
 	private int locX, locY, locCounter;
 	/** Start and duration of pen-pressed event to simulate right mouse key */
-	private long start, duration=0;
-	
+	private long start, duration = 0;
+
 	/**
-	* Constructor to create the image panel.<p>
-	*/
-	public ImagePanel(){ // Public constructor
+	 * Constructor to create the image panel.
+	 * <p>
+	 */
+	public ImagePanel() { // Public constructor
 	}
-	
-	static CacheHolderDetail oldCache=null;
+
+	static CacheHolderDetail oldCache = null;
+
 	/**
-	* Method to set the individual cache images.
-	* Gets called immediatly before panel is displayed
-	* @see MainTab#onEvent(Event ev)
-	*/
-	public void setImages(CacheHolderDetail cache){
-		if (cache!=oldCache) { 
+	 * Method to set the individual cache images.
+	 * Gets called immediatly before panel is displayed
+	 * 
+	 * @see MainTab#onEvent(Event ev)
+	 */
+	public void setImages(CacheHolderDetail cache) {
+		if (cache != oldCache) {
 			pref = Global.getPref();
-			profile=Global.getProfile();
+			profile = Global.getProfile();
 			Vm.showWait(true);
 			clearImages();
-			thumb_size = ((pref.myAppWidth-2*padding) / 3);
+			thumb_size = ((pref.myAppWidth - 2 * padding) / 3);
 			thumb_size = thumb_size - padding;
 			double rowCounter1 = 0;
-			if (cache.images.getDisplayImages(cache.getParent().getWayPoint()).size()>0) {
+			if (cache.images.getDisplayImages(cache.getParent().getWayPoint()).size() > 0) {
 				rowCounter1 = cache.images.getDisplayImages(cache.getParent().getWayPoint()).size();
-				rowCounter1 = java.lang.Math.ceil(rowCounter1/3);
+				rowCounter1 = java.lang.Math.ceil(rowCounter1 / 3);
 			}
 			double rowCounter2 = 0;
-			if (cache.userImages.size()>0){
+			if (cache.userImages.size() > 0) {
 				rowCounter2 = cache.userImages.size();
-				rowCounter2 = java.lang.Math.ceil(rowCounter2/3);
+				rowCounter2 = java.lang.Math.ceil(rowCounter2 / 3);
 			}
 			int rowCounter = (int) (rowCounter1 + rowCounter2);
-			Rect r = new Rect(0, 0, pref.myAppWidth, rowCounter*thumb_size+rowCounter*padding+padding);
+			Rect r = new Rect(0, 0, pref.myAppWidth, rowCounter * thumb_size + rowCounter * padding + padding);
 			this.virtualSize = r;
-			//this.setPreferredSize(pref.myAppWidth, rowCounter*thumb_size+rowCounter*padding+40);
+			// this.setPreferredSize(pref.myAppWidth, rowCounter*thumb_size+rowCounter*padding+40);
 			// this.checkScrolls();
 			// this.refresh();
-			locY=0;
-			addTitle(MyLocale.getMsg(340,"Cache Images:"));
+			locY = 0;
+			addTitle(MyLocale.getMsg(340, "Cache Images:"));
 			locY = 20;
 			locX = padding;
 			addImages(cache.images.getDisplayImages(cache.getParent().getWayPoint()));
 			// load user images
-			if(locCounter==1 || locCounter ==2) locY = locY + thumb_size;
-			if (cache.userImages.size()> 0){
-				addTitle(MyLocale.getMsg(341,"User Images:"));
+			if (locCounter == 1 || locCounter == 2)
+				locY = locY + thumb_size;
+			if (cache.userImages.size() > 0) {
+				addTitle(MyLocale.getMsg(341, "User Images:"));
 				locY = locY + 20;
 				locX = padding;
 				locCounter = 0;
 				addImages(cache.userImages);
 			}
-			oldCache=cache;
-		} // cache!=oldCache	
-		if (locY>this.height) {
+			oldCache = cache;
+		} // cache!=oldCache
+		if (locY > this.height) {
 			this.checkScrolls();
 		}
 		this.refresh();
 		Vm.showWait(false);
-		//this.repaintNow();
+		// this.repaintNow();
 	}
 
 	/**
 	 * Clear the images in the panel
-	 *
+	 * 
 	 */
 	public void clearImages() {
-		oldCache=null;
+		oldCache = null;
 		int lgr = images.size();
-		for(int i = 0; i<lgr;i++){
-			this.removeImage((AniImage)images.get(0));
+		for (int i = 0; i < lgr; i++) {
+			this.removeImage((AniImage) images.get(0));
 		}
 	}
-	
+
 	/**
 	 * Add a title above the cache images and above the user images
-	 * @param title Title to add ("cache images" or "user images")
+	 * 
+	 * @param title
+	 *            Title to add ("cache images" or "user images")
 	 */
 	private void addTitle(String title) {
 		AniImage aImg;
@@ -151,24 +157,27 @@
 		FontMetrics fm = getFontMetrics();
 		int stringWidth = fm.getTextWidth(title);
 		int stringHeight = fm.getHeight();
-		Image img = new Image(stringWidth*2,stringHeight+5);
+		Image img = new Image(stringWidth * 2, stringHeight + 5);
 		Graphics g = new Graphics(img);
-		g.setColor(new Color(195,195,195));
-		g.fillRect(0,0,stringWidth*2,stringHeight+5);
-		g.setColor(new Color(0,0,0));
+		g.setColor(new Color(195, 195, 195));
+		g.fillRect(0, 0, stringWidth * 2, stringHeight + 5);
+		g.setColor(new Color(0, 0, 0));
 		g.setFont(titleFont);
-		g.drawText(title, 0,0);
+		g.drawText(title, 0, 0);
 		g.free();
 		aImg = new AniImage(img);
 		aImg.setLocation(0, locY);
 		addImage(aImg);
 		aImg.refresh();
 	}
-	
+
 	/**
 	 * Add the images to the panel. Can add both normal and user images
-	 * @param pImages Vector of images or userImages
-	 * @param imagesText Vector of image texts or user image texts
+	 * 
+	 * @param pImages
+	 *            Vector of images or userImages
+	 * @param imagesText
+	 *            Vector of image texts or user image texts
 	 */
 	private void addImages(CacheImages pImages) {
 		String location, imgText;
@@ -177,133 +186,147 @@
 		double dummyC;
 		ImagePanelImage ipi;
 		AniImage AimgText;
-		locCounter=0;
-		for(int i = 0; i<pImages.size(); i++){
-			location = profile.dataDir + pImages.get(i).getFilename();
-			if (!(new FileBugfix(location)).exists()) {
-				location=NO_IMAGE;
-				if (!pref.showDeletedImages) continue; // Don't show the deleted Image if user does not want it
+		locCounter = 0;
+		for (int i = 0; i < pImages.size(); i++) {
+			location = pImages.get(i).getFilename();
+			boolean doit = true;
+			for (int j = i + 1; j < pImages.size(); j++) {
+				String jmgFile = pImages.get(j).getFilename();
+				if (location.equals(jmgFile)) {
+					doit = false;
+					break;
+				}
 			}
-			try{
-				mI = new mImage(location);
-				// actuall new mImage(location); should do the following "if" but it doesn't anyhow
-				if (mI.getWidth() <= 0 || mI.getHeight() <= 0 ) throw new IllegalArgumentException(location);
-				scaleX = thumb_size;
-				scaleY = thumb_size;
-				dummyC = 0;
-				double thumb_size2 = thumb_size;
-				if(mI.getWidth()>mI.getHeight()){
+			if (doit) {
+				location = profile.dataDir + location;
+				if (!(new FileBugfix(location)).exists()) {
+					location = NO_IMAGE;
+					if (!pref.showDeletedImages)
+						continue; // Don't show the deleted Image if user does not want it
+				}
+				try {
+					mI = new mImage(location);
+					// actuall new mImage(location); should do the following "if" but it doesn't anyhow
+					if (mI.getWidth() <= 0 || mI.getHeight() <= 0)
+						throw new IllegalArgumentException(location);
 					scaleX = thumb_size;
-					dummyC = (double)mI.getHeight()/ (double)mI.getWidth();
-					dummyC = dummyC * thumb_size2;
-					scaleY = (int)dummyC;
-				}
-				if(mI.getWidth() <= mI.getHeight()){
 					scaleY = thumb_size;
-					dummyC = (double)mI.getWidth()/(double)mI.getHeight();
-					dummyC = dummyC * thumb_size2;
-					scaleX = (int)dummyC;
+					dummyC = 0;
+					double thumb_size2 = thumb_size;
+					if (mI.getWidth() > mI.getHeight()) {
+						scaleX = thumb_size;
+						dummyC = (double) mI.getHeight() / (double) mI.getWidth();
+						dummyC = dummyC * thumb_size2;
+						scaleY = (int) dummyC;
+					}
+					if (mI.getWidth() <= mI.getHeight()) {
+						scaleY = thumb_size;
+						dummyC = (double) mI.getWidth() / (double) mI.getHeight();
+						dummyC = dummyC * thumb_size2;
+						scaleX = (int) dummyC;
+					}
+					if (mI.getWidth() <= thumb_size) {
+						scaleX = mI.getWidth();
+						scaleY = mI.getHeight();
+					}
+					mI = mI.scale(scaleX, scaleY, null, 0);
+					mI.freeSource();
+					ipi = new ImagePanelImage(mI);
+					ipi.freeSource();
+					// mI.free(); --> this only works in java-VM, in ewe it will delete the image, so leave it commented out
+					ipi.fileName = location; // this is set only to easily identify the filename of the image clicked
+					ipi.setLocation(locX, locY);
+					addImage(ipi);
+					// Name of picture:
+					if (pImages.size() > i) {
+						if (location.equals(NO_IMAGE))
+							imgText = MyLocale.getMsg(342, "Deleted");
+						else
+							imgText = SafeXML.cleanback(pImages.get(i).getTitle());
+						if (imgText.length() == 0)
+							imgText = "???";
+						AimgText = new AniImage();
+						AimgText = getImageText(imgText);
+						AimgText.setLocation(locX, locY + scaleY);
+						addImage(AimgText);
+						AimgText.refresh();
+						ipi.imageText = imgText;
+						ipi.imageComment = SafeXML.cleanback(pImages.get(i).getComment());
+					}
+					ipi.refresh();
+					locX = locX + thumb_size + padding;
+
+					locCounter++;
+					if (locCounter > 2) {
+						locCounter = 0;
+						locX = padding;
+						locY = locY + thumb_size + padding;
+					}
+				} catch (IllegalArgumentException imex) { // file not found, could not decode etc.
+					MessageBox tmp = new MessageBox(MyLocale.getMsg(321, "Fehler"), MyLocale.getMsg(322, "Kann Bild/Karte nicht laden") + ":\n" + imex.getMessage(), FormBase.OKB); // @todo: language support
+					tmp.exec();
+				} catch (OutOfMemoryError e) { // TODO show an error icon in the panel instead of nothing
+					(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(343, "Not enough free memory to load cache image") + ":\n" + location, FormBase.OKB)).exec();
+				} catch (SystemResourceException e) { // TODO show an error icon in the panel instead of nothing
+					(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(343, "Not enough free memory to load cache image") + "\n" + location, FormBase.OKB)).exec();
 				}
-				if(mI.getWidth() <= thumb_size){
-					scaleX = mI.getWidth();
-					scaleY = mI.getHeight();
-				}
-				mI = mI.scale(scaleX,scaleY,null,0);
-				mI.freeSource();
-				ipi = new ImagePanelImage(mI);
-				ipi.freeSource();
-				//mI.free(); --> this only works in java-VM, in ewe it will delete the image, so leave it commented out
-				ipi.fileName = location; // this is set only to easily identify the filename of the image clicked
-				ipi.setLocation(locX, locY);
-				addImage(ipi);
-				//Name of picture:
-				if(pImages.size()>i){
-					if (location.equals(NO_IMAGE))
-						imgText=MyLocale.getMsg(342,"Deleted");
-					else
-						imgText = SafeXML.cleanback(pImages.get(i).getTitle());
-					if(imgText.length()==0) imgText = "???";
-					AimgText = new AniImage();
-					AimgText = getImageText(imgText);
-					AimgText.setLocation(locX,locY+scaleY);
-					addImage(AimgText);
-					AimgText.refresh();
-					ipi.imageText = imgText;
-					ipi.imageComment = SafeXML.cleanback(pImages.get(i).getComment());
-				}
-				ipi.refresh();
-				locX = locX + thumb_size + padding;
-				
-				locCounter++;
-				if(locCounter > 2) {
-					locCounter = 0;
-					locX = padding;
-					locY = locY+thumb_size+padding;
-				}
-			}catch(IllegalArgumentException imex){ // file not found, could not decode etc.
-				MessageBox tmp = new MessageBox(MyLocale.getMsg(321,"Fehler"), MyLocale.getMsg(322,"Kann Bild/Karte nicht laden")+":\n"+imex.getMessage(), FormBase.OKB); // @todo: language support
-				tmp.exec();
-			} catch (OutOfMemoryError e) { // TODO show an error icon in the panel instead of nothing
-				(new MessageBox(MyLocale.getMsg(321,"Error"),MyLocale.getMsg(343,"Not enough free memory to load cache image")+":\n"+location,FormBase.OKB)).exec();
-			} catch (SystemResourceException e) { // TODO show an error icon in the panel instead of nothing
-				(new MessageBox(MyLocale.getMsg(321,"Error"),MyLocale.getMsg(343,"Not enough free memory to load cache image")+"\n"+location,FormBase.OKB)).exec();
 			}
-		} //for
-		
+		} // for
+
 	}
-	
-	private AniImage getImageText(String pText){
+
+	private AniImage getImageText(String pText) {
 		Font aniImageFont = new Font("Verdana", Font.BOLD, 14);
 		FontMetrics fm = getFontMetrics();
 		int stringWidth = fm.getTextWidth(pText);
 		int stringHeight = fm.getHeight();
-		Image img = new Image(stringWidth*2,stringHeight+5);
+		Image img = new Image(stringWidth * 2, stringHeight + 5);
 		Graphics g = new Graphics(img);
-		g.setColor(new Color(195,195,195));
-		g.fillRect(0,0,stringWidth*2,stringHeight+5);
-		g.setColor(new Color(0,0,0));
+		g.setColor(new Color(195, 195, 195));
+		g.fillRect(0, 0, stringWidth * 2, stringHeight + 5);
+		g.setColor(new Color(0, 0, 0));
 		g.setFont(aniImageFont);
-		g.drawText(pText, 0,0);
+		g.drawText(pText, 0, 0);
 		g.free();
 		AniImage a = new AniImage(img);
 		return a;
 	}
 
-	
 	/**
-	* React to when a user clicks an image.
-	* If left mouse key is clicked, will open a new window displaying the image scaled
-	* to window size if the image is larger, otherwise the true size is displayed.
-	* If right mouse key is clicked, a dialogue to delete the image wil be displayed
-	*/
-	public void imageClicked(AniImage which, Point pos){
-		if ((ControlBase.currentPenEvent.modifiers&PenEvent.RIGHT_BUTTON)==PenEvent.RIGHT_BUTTON || duration>LONG_PEN_DOWN_DURATION) {
+	 * React to when a user clicks an image.
+	 * If left mouse key is clicked, will open a new window displaying the image scaled
+	 * to window size if the image is larger, otherwise the true size is displayed.
+	 * If right mouse key is clicked, a dialogue to delete the image wil be displayed
+	 */
+	public void imageClicked(AniImage which, Point pos) {
+		if ((ControlBase.currentPenEvent.modifiers & PenEvent.RIGHT_BUTTON) == PenEvent.RIGHT_BUTTON || duration > LONG_PEN_DOWN_DURATION) {
 			// Right button pressed - delete image to conserve space
-			if (which instanceof ImagePanelImage && !((ImagePanelImage)which).fileName.equals(NO_IMAGE)) {
-				MessageBox mBox = new MessageBox (MyLocale.getMsg(144,"Warning"),MyLocale.getMsg(344,"Delete image")+" \""+((ImagePanelImage)which).imageText+"\"?", FormBase.IDYES |FormBase.IDNO);
-				if (mBox.execute() == FormBase.IDOK){
-						try {
-							File f=new File(((ImagePanelImage)which).fileName);
-							f.delete();
-							removeImage(which);
-						} catch(Exception e) {
-							// Global.getPref().log("Ignored Exception", e, true);
-						};
+			if (which instanceof ImagePanelImage && !((ImagePanelImage) which).fileName.equals(NO_IMAGE)) {
+				MessageBox mBox = new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(344, "Delete image") + " \"" + ((ImagePanelImage) which).imageText + "\"?", FormBase.IDYES | FormBase.IDNO);
+				if (mBox.execute() == FormBase.IDOK) {
+					try {
+						File f = new File(((ImagePanelImage) which).fileName);
+						f.delete();
+						removeImage(which);
+					} catch (Exception e) {
+						// Global.getPref().log("Ignored Exception", e, true);
+					}
+					;
 				}
 			}
-		} else { 
+		} else {
 			String fn = new String();
-			if(which instanceof ImagePanelImage){
-				ImagePanelImage ich = (ImagePanelImage)which;
+			if (which instanceof ImagePanelImage) {
+				ImagePanelImage ich = (ImagePanelImage) which;
 				fn = ich.fileName;
 				try {
 					ImageDetailForm iF = new ImageDetailForm(fn, ich.imageText, ich.imageComment, pref);
 					iF.execute(null, Gui.CENTER_FRAME);
 				} catch (IllegalArgumentException e) {
-					MessageBox tmp = new MessageBox(MyLocale.getMsg(321,"Fehler"), MyLocale.getMsg(322,"Kann Bild/Karte nicht finden"), FormBase.OKB); // @todo: language support
+					MessageBox tmp = new MessageBox(MyLocale.getMsg(321, "Fehler"), MyLocale.getMsg(322, "Kann Bild/Karte nicht finden"), FormBase.OKB); // @todo: language support
 					tmp.exec();
 				} catch (OutOfMemoryError e) {
-					(new MessageBox(MyLocale.getMsg(321,"Error"),MyLocale.getMsg(343,"Not enough free memory to load cache image")+"\n"+fn,FormBase.OKB)).exec();
+					(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(343, "Not enough free memory to load cache image") + "\n" + fn, FormBase.OKB)).exec();
 				}
 			}
 		}
@@ -311,15 +334,15 @@
 
 	/**
 	 * Create a "pen held down" event on hardware that does not support a right mouse key (e.g. Windows Mobile)
-	 * by measuring the time between pen down and pen up events. This is used in imageClicked to differentiate 
+	 * by measuring the time between pen down and pen up events. This is used in imageClicked to differentiate
 	 * between left and right mouse keys.
 	 */
 	public void onPenEvent(PenEvent ev) {
-		if (ev.type==PenEvent.PEN_DOWN) {
+		if (ev.type == PenEvent.PEN_DOWN) {
 			start = Vm.getTimeStampLong();
 		}
-		if (ev.type==PenEvent.PEN_UP) {
-			duration=Vm.getTimeStampLong()-start;
+		if (ev.type == PenEvent.PEN_UP) {
+			duration = Vm.getTimeStampLong() - start;
 		}
 		super.onPenEvent(ev);
 	}



From araber95 at mail.berlios.de  Sat Jul 23 12:09:26 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Sat, 23 Jul 2011 12:09:26 PM +0200
Subject: [Cachewolf-svn] r3047 - in trunk/src/CacheWolf: . navi
Message-ID: <20110723100927.047A7480E14@sheep.berlios.de>

Author: araber95
Date: 2011-07-23 12:09:26 +0200 (Sat, 23 Jul 2011)
New Revision: 3047

Modified:
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/navi/MovingMap.java
Log:
1. no Text on Tabs for screens with width <= 480
2.  no Update of Position if lat = 0 and lon = 0 in movingMap

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2011-07-21 13:29:33 UTC (rev 3046)
+++ trunk/src/CacheWolf/MainTab.java	2011-07-23 10:09:26 UTC (rev 3047)
@@ -102,7 +102,7 @@
 		// Don't expand tabs if the screen is very narrow, i.e. HP IPAQ
 		// 65xx, 69xx
 		int sw = MyLocale.getScreenWidth();
-		if (sw <= 240)
+		if (sw <= 480)
 			this.dontExpandTabs = true;
 		String imagesize = "";
 		if (pref.useBigIcons)

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2011-07-21 13:29:33 UTC (rev 3046)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2011-07-23 10:09:26 UTC (rev 3047)
@@ -823,23 +823,13 @@
 			posCircleX = width / 2;
 			posCircleY = height / 2;
 		} else {
-			posCircleX = pref.myAppWidth / 2; // maybe this could /should
-												// be repleced to windows
-												// size
+			// maybe this could / should be replaced to windows size
+			posCircleX = pref.myAppWidth / 2;
 			posCircleY = pref.myAppHeight / 2;
 		}
 		posCircle.hidden = false;
-		posCircle.move(posCircleX - posCircle.getWidth() / 2, posCircleY - posCircle.getHeight() / 2); // posCircle.setLocation
-																										// caused
-																										// a
-																										// problem
-																										// ->
-																										// hiding
-																										// the
-																										// posCircle
-																										// in
-																										// some
-																										// situation
+		posCircle.move(posCircleX - posCircle.getWidth() / 2, posCircleY - posCircle.getHeight() / 2);
+		// posCircle.setLocation a problem -> hiding the posCircle in some situation
 	}
 
 	public void movePosCircleToLatLon(CWPoint p, boolean repaint) {
@@ -879,8 +869,8 @@
 			dontUpdatePos = false;
 			updatePosition(posCircle.where);
 		} else
-			updateSymbolPositions(); // will also be done in
-										// updatePosition
+			// will also be done in updatePosition
+			updateSymbolPositions();
 		updateOverlayPos();
 	}
 
@@ -1125,7 +1115,7 @@
 	 * posCircle is at lat/lon
 	 */
 	public void updatePosition(CWPoint where) {
-		if (dontUpdatePos || loadingMapList)
+		if (dontUpdatePos || loadingMapList || (where.latDec == 0 && where.lonDec == 0))
 			return; // avoid multi-threading problems
 		loadBestMap(where);
 		if (width == 0 || height == 0) {
@@ -1137,17 +1127,7 @@
 		final boolean screenNotCompletlyCovered = (mmp.mapImage == null) || (mmp.mapImage != null && (mapPos.y > 0 || mapPos.x > 0 || mapPos.y + mmp.mapImage.getHeight() < this.height || mapPos.x + mmp.mapImage.getWidth() < this.width));
 		// if screendimensions changed also force reload of map
 		forceMapLoad |= lastWidth != width || lastHeight != height;
-		if (forceMapLoad || wantMapTest || screenNotCompletlyCovered) { // if
-																		// force
-																		// ||
-																		// want
-																		// ||
-																		// map
-																		// doesn't
-																		// cover
-																		// the
-																		// screen
-																		// completly
+		if (forceMapLoad || wantMapTest || screenNotCompletlyCovered) {
 			if (forceMapLoad || (java.lang.Math.abs(lastCompareX - mapPos.x) > this.width / 10 || java.lang.Math.abs(lastCompareY - mapPos.y) > this.height / 10)) {
 				// more then 1/10 of screen moved since last time we tried
 				// to find a better map



