From pfeffer at mail.berlios.de  Thu Feb  1 01:58:16 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 1 Feb 2007 01:58:16 +0100
Subject: [Cachewolf-svn] r485 - trunk/src/CacheWolf
Message-ID: <200702010058.l110wGme006520@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-01 01:57:59 +0100 (Thu, 01 Feb 2007)
New Revision: 485

Modified:
   trunk/src/CacheWolf/HintLogPanel.java
Log:
Logs: schnelles scrollen dadurch, dass in ein Image gerendert wird. Verschieben jetz auch durch Anfassen unf schieben m?\195?\182glich

Modified: trunk/src/CacheWolf/HintLogPanel.java
===================================================================
--- trunk/src/CacheWolf/HintLogPanel.java	2007-01-31 22:39:12 UTC (rev 484)
+++ trunk/src/CacheWolf/HintLogPanel.java	2007-02-01 00:57:59 UTC (rev 485)
@@ -1,7 +1,14 @@
 package CacheWolf;
 
 import ewe.ui.*;
+import ewe.fx.Dimension;
+import ewe.fx.Graphics;
+import ewe.fx.mImage;
+import ewe.graphics.AniImage;
+import ewe.graphics.InteractivePanel;
 import ewe.sys.*;
+import ewe.fx.Image;
+import ewe.fx.Rect;
 
 /**
 *	Class to create the panel that holds hints and logs.
@@ -18,6 +25,8 @@
 	mTextPad hint = new mTextPad();
 	//mTextPad logs = new mTextPad();
 	HtmlDisplay logs = new HtmlDisplay();
+	AniImage htmlTxtImage;
+	InteractivePanel htmlImagDisp = new InteractivePanel();
 	mButton decodeButton = new mButton("Decode");
 	mButton moreBt = new mButton(">>");
 	mButton prevBt = new mButton("<<");
@@ -35,10 +44,14 @@
 		hintpane.addNext(decodeButton,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		decodeButton.setMinimumSize(MyLocale.getScreenWidth()*2/3,10);
 		hintpane.addLast(moreBt,CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.EAST));
+		hint.modify(Control.NotEditable,0);
 		
-		ScrollBarPanel sbplog = new ScrollBarPanel((ScrollClient)logs, ScrollBarPanel.NeverShowHorizontalScrollers);
-		logpane.addLast(sbplog,CellConstants.STRETCH, CellConstants.FILL);
-		hint.modify(Control.NotEditable,0);
+		ScrollBarPanel sbplog = new ScrollBarPanel((ScrollClient)htmlImagDisp, ScrollBarPanel.NeverShowHorizontalScrollers);
+		//logpane.addLast(sbplog,CellConstants.STRETCH, CellConstants.FILL);
+		Rect r = new Rect(new Dimension (Global.getPref().myAppWidth, 20));
+		htmlImagDisp.virtualSize = r;
+		htmlImagDisp.checkScrolls();
+		logpane.addLast(sbplog.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
 		this.addLast(split);
 	}
 	
@@ -69,7 +82,26 @@
 			dummy.append("</br>");
 			if(++counter >= logsPerPage) break;
 		}
+		if (htmlTxtImage != null) {
+			htmlImagDisp.removeImage(htmlTxtImage);
+			htmlTxtImage.free();
+			}
+		logs.resizeTo(width, 50);
 		logs.setHtml(dummy.toString());
+		int h = logs.getLineHeight() * logs.getNumLines();
+		htmlTxtImage = new AniImage(new Image(width, h));
+		htmlTxtImage.setLocation(0, 0);
+		htmlTxtImage.properties |= AniImage.IsMoveable;
+		Graphics draw = new Graphics(htmlTxtImage.image);
+		logs.resizeTo(htmlTxtImage.getWidth(), htmlTxtImage.getHeight());
+		logs.doPaint(draw, new Rect(0,0,htmlTxtImage.getWidth(), htmlTxtImage.getHeight()));
+		htmlImagDisp.addImage(htmlTxtImage);
+		Rect r = new Rect(new Dimension (width, h));
+		htmlImagDisp.virtualSize = r;
+		htmlImagDisp.checkScrolls();
+
+		htmlImagDisp.repaintNow();
+		repaintNow();
 		Vm.showWait(false);
 	}
 	/**



From admin at berlios.de  Thu Feb  1 15:00:19 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 1 Feb 2007 15:00:19 +0100 (CET)
Subject: [Feature #3066] MovingMap: Kontextmenü hinzufügen
Message-ID: <200702011400.l11E0J8I029938@unicorn.berlios.de>

Feature Request #3066, was updated on 2007-Jan-21 02:43
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3066&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: MovingMap: Kontextmen? hinzuf?gen

By: pfeffer
Date: 2007-Feb-01 15:00

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

ist l?ngst erledigt.

----------------------------------------------------------------------

By: mik77
Date: 2007-Jan-21 02:43

Message:
Logged In: YES 
user_id=34677
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de-AT; rv:1.8.1) Gecko/20061101 SeaMonkey/1.1b Mnenhy/0.7.4.10002

Kontextmen? f?r die MovingMap.
Erster Eintrag: "Goto here"

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3066&group_id=2211


From admin at berlios.de  Thu Feb  1 15:00:52 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 1 Feb 2007 15:00:52 +0100 (CET)
Subject: [Feature #3043] MovingMap: Kartenverzeichnis wählen
Message-ID: <200702011400.l11E0qMR000601@unicorn.berlios.de>

Feature Request #3043, was updated on 2007-Jan-12 15:59
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3043&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: MovingMap: Kartenverzeichnis w?hlen

By: pfeffer
Date: 2007-Jan-12 16:01

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

erledigt mit SVN 381

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-12 15:59

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

MovingMap: Kartenverzeichnis w?hlen: m?glich 
?ber Klick auf die gelben streifen oben links in der 
Moving map.

Beachte: das Verzeichnis f?r die kalibrierten Karte 
habe ich verlegt.
Es ist nun:
<Daten-Verzeichnis>/maps/standard

bisher unter <programm-verzeichnis>/maps 
abgelegte Karten m?ssen per Hand dort hin 
verschoben werden.

Gru?, 

  Pfeffer

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3043&group_id=2211


From admin at berlios.de  Thu Feb  1 15:01:22 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 1 Feb 2007 15:01:22 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3042] MovinMap Verbindungslinie GPS - Goto
Message-ID: <200702011401.l11E1Mdw001179@unicorn.berlios.de>

Feature Request #3042, was updated on 2007-Jan-12 15:55
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3042&group_id=2211

Category: None
Status: Closed
Priority: 5
Summary: MovinMap Verbindungslinie GPS - Goto

By: pfeffer
Date: 2007-Jan-12 15:57

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

erledigt mit SVN 381

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-12 15:55

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

MovinMap: Verbindungslinie zwischen GPS-Position 
und Goto-Position

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3042&group_id=2211


From admin at berlios.de  Thu Feb  1 15:01:50 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 1 Feb 2007 15:01:50 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3026] MovingMap: Anzeige markierter Caches
Message-ID: <200702011401.l11E1oHZ001722@unicorn.berlios.de>

Feature Request #3026, was updated on 2007-Jan-08 03:38
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3026&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: MovingMap: Anzeige markierter Caches

By: pfeffer
Date: 2007-Jan-08 03:38

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

mit irgendeinem SVN-Update um ca. 360-367 erledigt.

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-08 03:38

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

MovingMap: Anzeige markierter Caches

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3026&group_id=2211


From admin at berlios.de  Thu Feb  1 15:02:19 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 1 Feb 2007 15:02:19 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3025] MovingMap: verschieben per
	klick-and-dra
Message-ID: <200702011402.l11E2Jxl002231@unicorn.berlios.de>

Feature Request #3025, was updated on 2007-Jan-08 03:24
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3025&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: MovingMap: verschieben per klick-and-dra

By: pfeffer
Date: 2007-Jan-08 03:26

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

erledigt mit SVN-Update 367.

----------------------------------------------------------------------

By: pfeffer
Date: 2007-Jan-08 03:24

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

MovingMap: verschieben per klick-and-drag

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3025&group_id=2211


From admin at berlios.de  Thu Feb  1 15:08:21 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 1 Feb 2007 15:08:21 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2970] Cacheliste fortlaufend sortieren
Message-ID: <200702011408.l11E8LSN009099@unicorn.berlios.de>

Feature Request #2970, was updated on 2006-Dec-14 08:56
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2970&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Cacheliste fortlaufend sortieren

By: pfeffer
Date: 2007-Feb-01 15:08

Message:
Logged In: YES 
user_id=30639
Browser: Opera/9.02 (Windows NT 5.1; U; de)

wir wollen es so: die Cacheliste bleibt sortiert, egal, ob 
man Filter anwedet, Filter aufhebt, neue Caches l?dt 
usw. siehe http://www.geoclub.de/ftopic13883-20.html

@albsucher: diese Funktion gibt es schon: im Goto-
Panel auf "Zentrum" klicken.

----------------------------------------------------------------------

By: albsucher
Date: 2006-Dec-14 09:09

Message:
Logged In: YES 
user_id=26380
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1) Gecko/20061010 Firefox/2.0

Ich finde einen Automatismus weniger geeignet da man meist
einen bestimmten Cache suchen geht.
Au?erdem d?rfte es aufwendig und sehr performancefressend
sein - vor allem bei langen Listen.

Was m.E. praktischer w?re: einen Men?punkt "nearest Caches"
oder so, wo dann die Liste nach Entfernung vom aktuellen
Standort neu sortiert wird. So kann man "schnell" mal sehen
ob und wo Caches in der N?he sind.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2970&group_id=2211


From admin at berlios.de  Thu Feb  1 23:39:54 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 1 Feb 2007 23:39:54 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #10123] caches verwalten - move
Message-ID: <200702012239.l11MdsAL007651@unicorn.berlios.de>

Bug #10123, was updated on 2007-Jan-25 16:29
Here is a current snapshot of the bug.

Project: CacheWolf
Category: None
Status: Open
Resolution: None
Bug Group: None
Priority: 5
Submitted by: albsucher
Assigned to : none
Summary: caches verwalten - move

Details: Evt. User-Error aber:
auf meinem PDA markiere ich caches inder Liste (vorne Haken rein), dann will ich sie verschieben. Dann scheint er noch was zu machen und dann kommt der mir schon unverst?ndliche Dialog "Weiter?" - danach ist Sense=Absturz!
Mach ich was verkehrt oder wie?
Was ich tun wilL: meine gefundenen und/oder eigenen Caches in ein eigenes (sogar vorher angelegtes) Verzeichnis verschieben. 

ich hoff ich hab mich da vest?ndlich genug ausgedr?ckt...

Follow-Ups:

Date: 2007-Feb-01 23:39
By: salzkammergut

Comment:
Kannst Du das mal mit der RC testen. Im Datamover war ein Bug, den habe ich schon vor ca. 1 Woche gefixt.
-------------------------------------------------------

Date: 2007-Jan-31 22:21
By: albsucher

Comment:
Nein, ich habe vorher nichts gefiltert.
meien Absicht war, die von mir gefundenen caches in ein anderes Verzeichnis zu verschieben. dazu hab ich in der Listenansicht einfach mal ein paar markiert und wollte einen move machen...
-------------------------------------------------------

Date: 2007-Jan-31 21:07
By: kalli

Comment:
Hast Du die Liste nach dem Markieren gefiltert? Das Verschieben wirkt auf alle angezeigten Caches!

Der Dialog, den Du siehst, ist die Sicherheitsabfrage. Vielleicht gibts auf dem PDA ein Problem mit der Menge der Caches beim Verschieben, mit Massendaten habe ich das auf dem PDA noch nicht getestet.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10123&group_id=2211


From pfeffer at mail.berlios.de  Fri Feb  2 00:32:57 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Fri, 2 Feb 2007 00:32:57 +0100
Subject: [Cachewolf-svn] r486 - trunk
Message-ID: <200702012332.l11NWvOv024546@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-02 00:32:46 +0100 (Fri, 02 Feb 2007)
New Revision: 486

Modified:
   trunk/buildexe.bat
Log:
sorgt jetz daf?\195?\188r, dass die aktuellen Ressourcen kopiert werden

Modified: trunk/buildexe.bat
===================================================================
--- trunk/buildexe.bat	2007-02-01 00:57:59 UTC (rev 485)
+++ trunk/buildexe.bat	2007-02-01 23:32:46 UTC (rev 486)
@@ -1 +1,3 @@
-java -cp lib/ewe.jar Ewe ../Ewe/programs/Jewel.ewe -c cwberlios.jnf
+call getres.bat
+java -cp lib/ewe.jar Ewe ../Ewe/programs/Jewel.ewe -c cwberlios.jnf
+pause



From pfeffer at mail.berlios.de  Fri Feb  2 00:41:26 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Fri, 2 Feb 2007 00:41:26 +0100
Subject: [Cachewolf-svn] r487 - trunk/src/CacheWolf
Message-ID: <200702012341.l11NfQMZ007396@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-02 00:41:15 +0100 (Fri, 02 Feb 2007)
New Revision: 487

Modified:
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: @Mik77: ready for testing: Bug: Exception wenn map gestartet wurde und gotopunkt und gps gestartet war, bevor es das erste mal aufgerufen wurde

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-02-01 23:32:46 UTC (rev 486)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-02-01 23:41:15 UTC (rev 487)
@@ -588,7 +588,7 @@
 					if (toPoint.isValid())	mmp.updatePosition(toPoint.latDec, toPoint.lonDec);
 					else mmp.updatePosition(Global.getPref().curCentrePt.latDec, Global.getPref().curCentrePt.lonDec); // if not goto-point defined move map to centere point
 					mmp.ignoreGps = true;
-				}
+				} else mmp.updatePosition(gpsPosition.latDec, gpsPosition.lonDec); // set gps-pos if gps is on 
 				if (currTrack != null) mmp.addTrack(currTrack);
 				if (runbefore) mmp.addOverlaySet(); // draw new trackpoints but only do so if OverlaySet needs to be updated, otherwise it is anyway newly created
 				if (toPoint.isValid()) mmp.setGotoPosition(toPoint.latDec, toPoint.lonDec);

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-01 23:32:46 UTC (rev 486)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-01 23:41:15 UTC (rev 487)
@@ -229,7 +229,7 @@
 
 
 	public void addMissingOverlays() {
-		if (currentMap == null || posCircleLat < -360) return;
+		if (currentMap == null || posCircleLat < -360 || width == 0 || height == 0) return; // height == 0 happens if this is called before the form ist displayed on the screen
 		if (TrackOverlays == null) {
 			TrackOverlays = new TrackOverlay[9];
 			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
@@ -592,7 +592,7 @@
 
 	public void setGotoPosition(double lat, double lon) {
 		removeGotoPosition();
-		gotoPos=addSymbol("goto", "goto_map.png", lat, lon);
+		gotoPos = addSymbol("goto", "goto_map.png", lat, lon);
 		updateDistance();
 		forceMapLoad = true;
 		updatePosition(posCircleLat, posCircleLon);
@@ -647,7 +647,7 @@
 		//Vm.debug("mapx = " + mapx);
 		//Vm.debug("mapy = " + mapy);
 		if (forceMapLoad || (java.lang.Math.abs(oldMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(oldMapPos.y - mapPos.y) > 1)) {
-			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x,mapPos.y);
+			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x, mapPos.y);
 			updateSymbolPositions();
 			updateDistance();
 			if (updateOverlay ) updateOverlayPos(); // && TrackOverlays != null
@@ -677,7 +677,7 @@
 				if (forceMapLoad || wantMapTest|| (mmp.mapImage != null && ( mapPos.y > 0 || mapPos.x > 0 || mapPos.y+mmp.mapImage.getHeight()<this.height	|| mapPos.x+mmp.mapImage.getWidth()<this.width) 
 						|| 	mmp.mapImage == null )) 	{ // if force || want || map doesn't cover the scree completly
 					//Vm.debug("Screen not completly covered by map");
-					if (forceMapLoad || (java.lang.Math.abs(lastCompareX-mapPos.x) > MyLocale.getScreenWidth()/10 || java.lang.Math.abs(lastCompareY-mapPos.y) > MyLocale.getScreenHeight()/10)) {
+					if (forceMapLoad || (java.lang.Math.abs(lastCompareX-mapPos.x) > this.width/10 || java.lang.Math.abs(lastCompareY-mapPos.y) > this.height/10)) {
 						// more then 1/10 of screen moved since last time we tried to find a better map
 						lastCompareX = mapPos.x;
 						lastCompareY = mapPos.y;
@@ -688,6 +688,7 @@
 			}
 		}
 	}
+	
 	int mapChangeModus;
 	float scaleWanted;
 	boolean wantMapTest = true; // if true updateposition calls setBestMap regulary even if the currentmap covers the whole screen



From pfeffer at mail.berlios.de  Fri Feb  2 03:06:36 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Fri, 2 Feb 2007 03:06:36 +0100
Subject: [Cachewolf-svn] r488 - trunk/src/CacheWolf
Message-ID: <200702020206.l1226aXO012764@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-02 03:06:34 +0100 (Fri, 02 Feb 2007)
New Revision: 488

Modified:
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: fixed: konnte nicht gestartet werden, wenn f?\195?\188r aktuellen Standort keine Karte verf?\195?\188gbar war

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-01 23:41:15 UTC (rev 487)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-02 02:06:34 UTC (rev 488)
@@ -733,6 +733,12 @@
 			Vm.debug("better map found");
 			return;
 		}
+		if (currentMap == null && newmap == null) {
+			(new MessageBox("Information", "F?r die aktuelle Position steht keine Karte zur Verf?ung, bitte w?hlen Sie eine manuell", MessageBox.OKB)).execute();
+			posCircleLat = lat;
+			posCircleLon = lon; // choosemap calls setmap with posCircle-coos
+			mmp.chooseMap(); 
+		}
 	}
 
 	public void setResModus (int modus) {
@@ -1229,10 +1235,10 @@
 		ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos(), mm.currentMap);
 		if(l.execute() == FormBase.IDOK){
 //			Vm.debug("Trying map: " + l.selectedMap.fileName);
-			mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
 			mm.autoSelectMap = false;
 			if (l.selectedMap.inBound(mm.posCircleLat, mm.posCircleLon) || l.selectedMap.getImageFilename().length()==0) {
 				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon);
+				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
 				mm.ignoreGpsStatutsChanges = false;
 			} else {
 				mm.ignoreGpsStatutsChanges = false;
@@ -1240,6 +1246,7 @@
 				mm.ignoreGpsStatutsChanges = true;
 				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon); // don't adjust Image to lat/lon
 				mm.setCenterOfScreen(l.selectedMap.center);
+				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
 				mm.repaintNow();
 				//Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
 				//double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4]; 



From pfeffer at mail.berlios.de  Fri Feb  2 03:10:44 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Fri, 2 Feb 2007 03:10:44 +0100
Subject: [Cachewolf-svn] r489 - trunk/src/CacheWolf
Message-ID: <200702020210.l122AiaA013007@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-02 03:10:41 +0100 (Fri, 02 Feb 2007)
New Revision: 489

Modified:
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: wenn manuell leere Karte gew?\195?\164hlt wurde, nicht zum Mittelpunkt der leeren Karte springen

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-02 02:06:34 UTC (rev 488)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-02 02:10:41 UTC (rev 489)
@@ -1244,8 +1244,9 @@
 				mm.ignoreGpsStatutsChanges = false;
 				mm.setGpsStatus(MovingMap.noGPS);
 				mm.ignoreGpsStatutsChanges = true;
-				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon); // don't adjust Image to lat/lon
-				mm.setCenterOfScreen(l.selectedMap.center);
+				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon); 
+				if (mm.currentMap.fileNameWFL.length() > 0)
+					mm.setCenterOfScreen(l.selectedMap.center); // if map has an image
 				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
 				mm.repaintNow();
 				//Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);



From kalli at mail.berlios.de  Fri Feb  2 18:33:31 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Fri, 2 Feb 2007 18:33:31 +0100
Subject: [Cachewolf-svn] r490 - trunk/src/CacheWolf
Message-ID: <200702021733.l12HXVlv027717@sheep.berlios.de>

Author: kalli
Date: 2007-02-02 18:33:16 +0100 (Fri, 02 Feb 2007)
New Revision: 490

Modified:
   trunk/src/CacheWolf/GPXImporter.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/SpiderGC.java
Log:
Workaround, da HTML-Display nicht mit HTML-Umlauten umgehen kann.

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2007-02-02 02:10:41 UTC (rev 489)
+++ trunk/src/CacheWolf/GPXImporter.java	2007-02-02 17:33:16 UTC (rev 490)
@@ -410,12 +410,14 @@
 			return;
 		}
 		if (name.equals("groundspeak:short_description")|| name.equals("summary")) {
-			holder.LongDescription =strData;
+			if (holder.is_HTML)	holder.LongDescription =SafeXML.cleanback(strData);
+			else holder.LongDescription =strData;
 			return;
 		}
 
 		if (name.equals("groundspeak:long_description")|| name.equals("description")) {
-			holder.LongDescription +=strData;
+			if (holder.is_HTML)	holder.LongDescription +=SafeXML.cleanback(strData);
+			else holder.LongDescription +=strData;
 			return;
 		}
 		if (name.equals("groundspeak:encoded_hints") || name.equals("hints")) {

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-02-02 02:10:41 UTC (rev 489)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-02-02 17:33:16 UTC (rev 490)
@@ -458,7 +458,8 @@
 			}
 			
 			if (name.equals("desc")){
-				holder.LongDescription += strData;
+				if (holder.is_HTML)	holder.LongDescription +=SafeXML.cleanback(strData);
+				else holder.LongDescription +=strData;
 				return;
 			}
 			if (name.equals("hint")){

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-02-02 02:10:41 UTC (rev 489)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-02-02 17:33:16 UTC (rev 490)
@@ -643,7 +643,7 @@
 		rex2.search(doc);
 		res = inRex.stringMatched(1) + "<br>";
 		res += rex2.stringMatched(1); 
-		return res;
+		return SafeXML.cleanback(res);
 	}
 	
 	private String getListBlock(String doc){



From kalli at mail.berlios.de  Fri Feb  2 18:53:32 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Fri, 2 Feb 2007 18:53:32 +0100
Subject: [Cachewolf-svn] r491 - trunk/src/exp
Message-ID: <200702021753.l12HrWt9032022@sheep.berlios.de>

Author: kalli
Date: 2007-02-02 18:53:21 +0100 (Fri, 02 Feb 2007)
New Revision: 491

Modified:
   trunk/src/exp/GPXExporter.java
Log:
Bugfix: Zeitformat war nicht gesetzt.

Modified: trunk/src/exp/GPXExporter.java
===================================================================
--- trunk/src/exp/GPXExporter.java	2007-02-02 17:33:16 UTC (rev 490)
+++ trunk/src/exp/GPXExporter.java	2007-02-02 17:53:21 UTC (rev 491)
@@ -47,6 +47,7 @@
 		StringBuffer strBuf = new StringBuffer(1000);
 		Time tim = new Time();
 
+		tim = tim.setFormat("yyyy-MM-dd");
 		try{
 			strBuf.append("  <wpt lat=\""+lat+"\" lon=\""+lon+"\">\r\n");
 			if (ch.DateHidden.length()> 0){



From salzkammergut at mail.berlios.de  Fri Feb  2 21:26:14 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Fri, 2 Feb 2007 21:26:14 +0100
Subject: [Cachewolf-svn] r492 - trunk/src/CacheWolf
Message-ID: <200702022026.l12KQEQs013362@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-02 21:26:04 +0100 (Fri, 02 Feb 2007)
New Revision: 492

Modified:
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/NewProfileForm.java
   trunk/src/CacheWolf/Preferences.java
Log:
Bugfix: Fehlendes / beim Anlegen eines neuen Profils.
Siehe http://www.geoclub.de/ftopic13912.html
Ausserdem Konvertierung von \ nach / in den Pfaden basDir und dataDir

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-02-02 17:53:21 UTC (rev 491)
+++ trunk/src/CacheWolf/MainMenu.java	2007-02-02 20:26:04 UTC (rev 492)
@@ -194,7 +194,7 @@
 					profile.clearProfile(); 
 					pref.lastProfile=profile.name=f.profileDir;
 					pref.savePreferences(); // Remember that this was the last profile used
-					profile.dataDir=pref.baseDir+f.profileDir;
+					profile.dataDir=pref.baseDir+f.profileDir+"/";
 					tbp.refreshTable();
 				}
 				f.close(0);

Modified: trunk/src/CacheWolf/NewProfileForm.java
===================================================================
--- trunk/src/CacheWolf/NewProfileForm.java	2007-02-02 17:53:21 UTC (rev 491)
+++ trunk/src/CacheWolf/NewProfileForm.java	2007-02-02 20:26:04 UTC (rev 492)
@@ -39,7 +39,7 @@
 					mb.execute();
 					profileDir="";
 				} else {
-					if (!f.createDir()) {
+					if (profileDir.indexOf("/")>=0 || profileDir.indexOf("\\")>=0 || !f.createDir()) {
 						MessageBox mb=new MessageBox(MyLocale.getMsg(321,"Error"),MyLocale.getMsg(1113,"Cannot create directory"),IDOK);
 						mb.execute();
 						profileDir="";

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-02-02 17:53:21 UTC (rev 491)
+++ trunk/src/CacheWolf/Preferences.java	2007-02-02 20:26:04 UTC (rev 492)
@@ -255,6 +255,7 @@
 			if (fc.execute() == FileChooser.IDCANCEL) ewe.sys.Vm.exit(0);
 			baseDir = fc.getChosenFile().toString();
 		}
+		baseDir=baseDir.replace('\\','/');
 		if (!baseDir.endsWith("/")) baseDir+="/";
 		//Vm.showWait(false);
 		if((showProfileSelector==PROFILE_SELECTOR_FORCED_ON) || 
@@ -274,9 +275,11 @@
 		else if (lastProfile.equals(profiles[2])) openOldProfile(prof, 2);
 		else if (lastProfile.equals(profiles[3])) openOldProfile(prof, 3);
 		else { 
-			prof.dataDir=baseDir+lastProfile+"/";
+			prof.dataDir=baseDir+lastProfile;
 			//mydatadir=prof.dataDir;
 		}
+		prof.dataDir=prof.dataDir.replace('\\','/');
+		if (!prof.dataDir.endsWith("/")) prof.dataDir+='/';
 		savePreferences();
 		return true;
 



From salzkammergut at mail.berlios.de  Fri Feb  2 22:00:06 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Fri, 2 Feb 2007 22:00:06 +0100
Subject: [Cachewolf-svn] r493 - trunk/resources
Message-ID: <200702022100.l12L06eS016803@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-02 22:00:01 +0100 (Fri, 02 Feb 2007)
New Revision: 493

Modified:
   trunk/resources/cachewolf.Languages.cfg
Log:
Bugfix Filter: Falscher Text angezeigt (Text 716/717 vertauscht)
  [(Filter/erzeugen/Richtung 'alle w?\195?\164hlen' entfernt alle Haken und umgekehrt.]
Weiters einige fehlende englische Texte hinzugef?\195?\188gt 

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-02-02 20:26:04 UTC (rev 492)
+++ trunk/resources/cachewolf.Languages.cfg	2007-02-02 21:00:01 UTC (rev 493)
@@ -147,8 +147,8 @@
 		713=Speicher Filter
 		714=Richtung & Entfernung
 		715=Zeige alle Caches mit Status
-		716=Alle w%e4hlen
-		717=Alle abw%e4hlen
+		716=Alle abw%e4hlen
+		717=Alle w%e4hlen
 		718=Cache Bewertungen
 		719=Cache Typen
 		720=Attribute
@@ -157,7 +157,6 @@
 		723=Typen
 		724=Beh%e4lter
 		725=Hinweis: Filter sind additiv, activ = gr%fcn
-		Note: Filters are additive, active filter=green
 		800=Erstelle Liste
 		801=suche...
 		802=Caches identifiziert. Suche weiter...
@@ -359,6 +358,10 @@
 		149=Maps
 		150=Import
 		151=Calibrate
+		152=Map import
+		153=Map import successful
+		154=Error when importing map!
+		155=Legend
 		156=Out of memory error, map to big
 		157=System
 		158=Version Check
@@ -453,7 +456,20 @@
 		709=Apply
 		710=Archived
 		711=Not available
+		712=Select route file
+		713=Save filter
 		714=Bearing & Distance
+		715=Show all caches with status:
+		716=Deselect all
+		717=Select all
+		718=Cache ratings
+		719=Cache types
+		720=Attributes
+		721=Direction
+		722=Rating
+		723=Types
+		724=Container
+		725=Note: Filters are additive, active filter=green
 		800=Creating list
 		801=searching...
 		802=Caches identified. searching...
@@ -604,6 +620,10 @@
 		4110=loading
 		4111=Coordinates must be entered in the format N XX XX.XXX E XXX XX.XXX
 		4200=Choose map directory
+		4500=Tot:
+		4501=Vis:
+		4502=Fnd:
+		5000=Load Cachelist
 		{..}
 	{..}
 {..}



From salzkammergut at mail.berlios.de  Fri Feb  2 22:30:57 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Fri, 2 Feb 2007 22:30:57 +0100
Subject: [Cachewolf-svn] r494 - trunk/src/CacheWolf
Message-ID: <200702022130.l12LUvUK022581@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-02 22:30:47 +0100 (Fri, 02 Feb 2007)
New Revision: 494

Modified:
   trunk/src/CacheWolf/TablePanel.java
Log:
TablePanel: Unreferenzierten Code entfernt (refreshTableBlack)

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-02-02 21:00:01 UTC (rev 493)
+++ trunk/src/CacheWolf/TablePanel.java	2007-02-02 21:30:47 UTC (rev 494)
@@ -113,18 +113,6 @@
 		if (statBar!=null) statBar.updateDisplay();
 	}
 	
-	public void refreshTableBlack(){
-		CacheHolder ch = new CacheHolder();
-		for (int i=0; i<cacheDB.size(); i++){
-			ch = new CacheHolder();
-			ch = (CacheHolder)cacheDB.get(i);
-			if(ch.is_black) ch.is_filtered = false;
-			else ch.is_filtered = true;
-			cacheDB.set(i, ch);
-		}
-		refreshTable();
-	}
-	
 	public void refreshTable(){
 		myMod.updateRows();
 		tc.update(true);



From salzkammergut at mail.berlios.de  Sat Feb  3 07:25:15 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 3 Feb 2007 07:25:15 +0100
Subject: [Cachewolf-svn] r495 - trunk/src/CacheWolf
Message-ID: <200702030625.l136PFk6017241@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-03 07:25:12 +0100 (Sat, 03 Feb 2007)
New Revision: 495

Modified:
   trunk/src/CacheWolf/SafeXML.java
Log:
SafeXML: Zusaetzliche Zeichen > 8000
z.B. in Caches GCN4T7, GCR5CF

Modified: trunk/src/CacheWolf/SafeXML.java
===================================================================
--- trunk/src/CacheWolf/SafeXML.java	2007-02-02 21:30:47 UTC (rev 494)
+++ trunk/src/CacheWolf/SafeXML.java	2007-02-03 06:25:12 UTC (rev 495)
@@ -13,7 +13,7 @@
 	private static final char ENTITY_START = '&';
 	private static final char ENTITY_END = ';';
 	
-	private static Hashtable iso2htmlMappings = new Hashtable(250);
+	private static Hashtable iso2htmlMappings = new Hashtable(300);
 	static {
 		String[] mappingArray = new String[] {
 				"&apos;",   "'",		// Added 20061227 - not a valid HTML entity but sometimes used
@@ -217,8 +217,24 @@
 				"&#252;", "?",
 				"&#253;", "?",
 				"&#254;", "?",
-				"&#255;", "?"
-		};
+				"&#255;", "?",
+				"&#8208;", "-",
+				"&#8209;", "-",
+				"&#8210;", "-",
+				"&#8211;", "-",
+				"&#8212;", "-",
+				"&#8213;", "-",
+				"&#8216;", "'",
+				"&#8217;", "'",
+				"&#8218;", "'",
+				"&#8219;", "'",
+				"&#8220;", "\"",
+				"&#8221;", "\"",
+				"&#8222;", "\"",
+				"&#8223;", "\"",
+				"&#8242;", "'",
+				"&#8243;", "\""
+				};
 		for (int i = 0; i < mappingArray.length; i = i + 2) {
 			iso2htmlMappings.put( mappingArray[i], mappingArray[i+1]);
 		}
@@ -359,32 +375,6 @@
     } // end insertEntities
 	
 	
-	/**
-	*	This method encodes special characters into
-	*	HTML coded characters.
-	*	see here: http://www.w3.org/MarkUp/html-spec/html-spec_13.html
-	*/
-	/*public static String clean(String str){
-		String dummy = new String();
-		
-		dummy = replace(str,  "&", "&#38;"); // Must be first otherwise the & of the replaced strings will be replaced again
-		dummy = replace(dummy, "<", "&#60;");
-		dummy = replace(dummy, ">", "&#62;");
-		dummy = replace(dummy,  "\"" ,"&#34;");
-		dummy = replace(dummy,  "?","&#176;");
-		dummy = replace(dummy, "'","&apos;");
-//		dummy = replace(dummy, "'", "&#180;");
-		dummy = replace(dummy, "?","&#252;");
-		dummy = replace(dummy, "?","&#228;");
-		dummy = replace(dummy, "?","&#246;");
-		dummy = replace(dummy, "?","&#196;");
-		dummy = replace(dummy,  "?","&#214;");
-		dummy = replace(dummy,  "?","&#220;");
-		dummy = replace(dummy,  "?","&#223;");
-		//dummy = replace(dummy, "&","&amp;");
-		return dummy;
-	}
-*/
 	public static String cleanGPX(String str){
 		String dummy = new String();
 		
@@ -399,34 +389,4 @@
 		return dummy;
 	}
 
-	
-	/**
-	*	This method cleans html coded characters into human
-	*	readable characters.
-	*/
-	/*public static String cleanback(String str){
-		String dummy = new String();
-		if (str.indexOf('&')<0) return str; // If nothing to replace, return immediately
-		dummy = replace(str,  "&#223;", "?"); // Start with the mor probable values
-		dummy = replace(dummy, "&#252;","?"); 
-		dummy = replace(dummy, "&#228;","?");
-		dummy = replace(dummy, "&#246;","?");
-		dummy = replace(dummy, "&#196;","?");
-		dummy = replace(dummy, "&#214;","?");
-		dummy = replace(dummy, "&#220;","?");
-		dummy = replace(dummy, "&apos;", "'");
-		dummy = replace(dummy, "&#180;", "'");
-		if (dummy.indexOf("&")<0) return dummy; 
-		dummy = replace(dummy, "&amp;", "&");
-		dummy = replace(dummy,  "&#38;", "&");
-		dummy = replace(dummy,  "&#34;", "\"");
-		dummy = replace(dummy,  "&#60;","<");
-		dummy = replace(dummy,  "&#62;",">");
-		dummy = replace(dummy,  "&#176;","?");
-		dummy = replace(dummy, "&quot;", "\"");	
-		dummy = replace(dummy, "&lt;", "<");
-		dummy = replace(dummy, "&gt;", ">");
-	
-		return dummy;
-	}*/
 }



From salzkammergut at mail.berlios.de  Sat Feb  3 09:25:43 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 3 Feb 2007 09:25:43 +0100
Subject: [Cachewolf-svn] r496 - trunk/src/CacheWolf
Message-ID: <200702030825.l138PhNX020664@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-03 09:25:41 +0100 (Sat, 03 Feb 2007)
New Revision: 496

Modified:
   trunk/src/CacheWolf/DataMover.java
   trunk/src/CacheWolf/MainMenu.java
Log:
DataMover: Bereinigung Initialisierung
(Vorbereitung Bugfix TableControl)

Modified: trunk/src/CacheWolf/DataMover.java
===================================================================
--- trunk/src/CacheWolf/DataMover.java	2007-02-03 06:25:12 UTC (rev 495)
+++ trunk/src/CacheWolf/DataMover.java	2007-02-03 08:25:41 UTC (rev 496)
@@ -17,10 +17,10 @@
 	Preferences pref;
 	Profile profile;
 	
-	public DataMover(Preferences p, Profile prof){
-		profile=prof;
+	public DataMover(){
+		pref = Global.getPref();
+		profile=Global.getProfile();
 		srcDB = profile.cacheDB;
-		pref = p;
 	}
 	public void deleteCaches(){
 		

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-02-03 06:25:12 UTC (rev 495)
+++ trunk/src/CacheWolf/MainMenu.java	2007-02-03 08:25:41 UTC (rev 496)
@@ -389,7 +389,7 @@
 			if(mev.selectedItem == orgCopy){
 				profile.saveIndex(pref);
 
-				DataMover dm = new DataMover(pref,profile);
+				DataMover dm = new DataMover();
 				dm.copyCaches();
 				tbp.refreshTable();
 			}
@@ -397,7 +397,7 @@
 			if(mev.selectedItem == orgMove){
 				profile.saveIndex(pref);
 
-				DataMover dm = new DataMover(pref,profile);
+				DataMover dm = new DataMover();
 				dm.moveCaches();
 				tbp.refreshTable();
 			}
@@ -405,7 +405,7 @@
 			if(mev.selectedItem == orgDelete){
 				profile.saveIndex(pref);
 
-				DataMover dm = new DataMover(pref,profile);
+				DataMover dm = new DataMover();
 				dm.deleteCaches();
 				tbp.refreshTable();
 			}



From salzkammergut at mail.berlios.de  Sat Feb  3 12:16:10 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 3 Feb 2007 12:16:10 +0100
Subject: [Cachewolf-svn] r497 - trunk/src/CacheWolf
Message-ID: <200702031116.l13BGAaE001035@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-03 12:16:05 +0100 (Sat, 03 Feb 2007)
New Revision: 497

Modified:
   trunk/src/CacheWolf/PreferencesScreen.java
Log:
PreferencesScreen: trim fuer Alias
(Unerwuenschte Leerzeichen koennen dazu fuehren, dass das "owned" Feld nicht gesetzt wird)

Modified: trunk/src/CacheWolf/PreferencesScreen.java
===================================================================
--- trunk/src/CacheWolf/PreferencesScreen.java	2007-02-03 08:25:41 UTC (rev 496)
+++ trunk/src/CacheWolf/PreferencesScreen.java	2007-02-03 11:16:05 UTC (rev 497)
@@ -171,7 +171,7 @@
 				mApp.fontsChanged();
 				mApp.mainApp.font = newGuiFont;
 				
-				pref.myAlias = Alias.getText();
+				pref.myAlias = Alias.getText().trim();
 				pref.browser = Browser.getText();
 				//Vm.debug(myPreferences.browser);
 				pref.myproxy = Proxy.getText();



From kalli at mail.berlios.de  Sat Feb  3 14:14:09 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Sat, 3 Feb 2007 14:14:09 +0100
Subject: [Cachewolf-svn] r498 - trunk/src/CacheWolf
Message-ID: <200702031314.l13DE9C9016329@sheep.berlios.de>

Author: kalli
Date: 2007-02-03 14:14:07 +0100 (Sat, 03 Feb 2007)
New Revision: 498

Modified:
   trunk/src/CacheWolf/DetailsPanel.java
Log:
Bugfix: Neue addi wpts wurden nicht angelegt.

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-02-03 11:16:05 UTC (rev 497)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-02-03 13:14:07 UTC (rev 498)
@@ -269,6 +269,7 @@
 			thisCache.saveCacheDetails(profile.dataDir);
 		}
 		
+		profile.buildReferences();
 		dirty_newOrDelete = true;
 		mainT.selectAndActive(cacheDB.size()-1);
 	}



From admin at berlios.de  Sat Feb  3 16:23:34 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sat, 3 Feb 2007 16:23:34 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3112] Abgleich von Profilen
Message-ID: <200702031523.l13FNYrD008273@unicorn.berlios.de>

Feature Request #3112, was updated on 2007-Feb-03 16:23
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3112&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Abgleich von Profilen

By: salzkammergut
Date: 2007-Feb-03 16:23

Message:
Logged In: YES 
user_id=33713
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Es sollte m?glich sein zwei Profile abzugleichen, d.h.
alle Daten, die in einem Profil aktueller sind in das
ander Profil zu ?bertragen.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3112&group_id=2211


From pfeffer at mail.berlios.de  Sun Feb  4 00:35:15 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 4 Feb 2007 00:35:15 +0100
Subject: [Cachewolf-svn] r499 - trunk/src/CacheWolf
Message-ID: <200702032335.l13NZFD6006063@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-04 00:35:02 +0100 (Sun, 04 Feb 2007)
New Revision: 499

Modified:
   trunk/src/CacheWolf/MapLoaderGui.java
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: bug fixed: kein gps-update nach zoomen
MovingMap: bug (vermutlich) fixed: Karten von Koordinate 0/0 werden nicht mehr geholt

Modified: trunk/src/CacheWolf/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/MapLoaderGui.java	2007-02-03 13:14:07 UTC (rev 498)
+++ trunk/src/CacheWolf/MapLoaderGui.java	2007-02-03 23:35:02 UTC (rev 499)
@@ -157,7 +157,7 @@
 						tmpca.set(ch.LatLon);
 						ch.pos = new CWPoint(tmpca);
 					}
-					if (ch.pos.isValid()) {
+					if (ch.pos.isValid() && ch.pos.latDec != 0 && ch.pos.lonDec != 0) { // TODO != 0 sollte verschwinden, sobald das handling von nicht gesetzten Koos ?berall korrekt ist
 						numdownloaded++;
 						progressBox.setInfo("Downloading map from expedia.de\n"+numdownloaded+" / "+numCaches+"\n for cache:\n"+ch.CacheName);
 						ml.downloadMap(ch.pos.latDec, ch.pos.lonDec, (int)scale, size.x, size.y, mapsDir);

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-03 13:14:07 UTC (rev 498)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-03 23:35:02 UTC (rev 499)
@@ -465,8 +465,13 @@
 	 *
 	 */
 	public void resetCenterOfMap() {
-		posCircleX = pref.myAppWidth/2; // maybe this could /should be repleced to windows size
-		posCircleY = pref.myAppHeight/2;
+		if (width != 0) {
+			posCircleX = width /2;
+			posCircleY = height /2;
+		} else {
+			posCircleX = pref.myAppWidth/2; // maybe this could /should be repleced to windows size
+			posCircleY = pref.myAppHeight/2;
+		}
 		posCircle.hidden = false;
 		posCircle.setLocation(posCircleX-posCircle.getWidth()/2, posCircleY-posCircle.getHeight()/2);
 	}
@@ -688,7 +693,7 @@
 			}
 		}
 	}
-	
+
 	int mapChangeModus;
 	float scaleWanted;
 	boolean wantMapTest = true; // if true updateposition calls setBestMap regulary even if the currentmap covers the whole screen
@@ -746,16 +751,16 @@
 		if (modus == NORMAL_KEEP_RESOLUTION) scaleWanted = currentMap.scale;
 		else setBestMap(posCircleLat, posCircleLon);
 	}
-/**
- * method to get a point on the screen which must be included in the map
- * the map methods are looking for. If the poscircle is on the screen this will be 
- * that point. If it is outside then the center of the screen will be used.
- * 
- * returns [0] = CWPoint of that point, [1] Rect describing the screen around it 
- * @param lat
- * @param lon
- * @return
- */
+	/**
+	 * method to get a point on the screen which must be included in the map
+	 * the map methods are looking for. If the poscircle is on the screen this will be 
+	 * that point. If it is outside then the center of the screen will be used.
+	 * 
+	 * returns [0] = CWPoint of that point, [1] Rect describing the screen around it 
+	 * @param lat
+	 * @param lon
+	 * @return
+	 */
 	public Object[] getRectForMapChange(double lat, double lon) {
 		int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
 		int h = (height != 0 ? height : pref.myAppHeight);
@@ -775,7 +780,7 @@
 		ret[1] = new Rect(x, y, w, h);
 		return ret; 
 	}
-	
+
 	/**
 	 * 
 	 * @param betterOverview true: getmap with better overview
@@ -790,7 +795,7 @@
 		if (m != null) setMap(m, posCircleLat, posCircleLon);
 		else (new MessageBox("Error", "No "+ (betterOverview ? "less" : "more") + " deteiled map available", MessageBox.OKB)).execute();
 	}
-	
+
 	public void loadMapForAllCaches(){
 		Area sur = Global.getProfile().getSourroundingArea(true);
 		MapInfoObject newmap = maps.getMapForArea(sur.topleft, sur.buttomright);
@@ -1116,14 +1121,17 @@
 	}
 
 	public boolean imageBeginDragged(AniImage which,Point pos) {
-		if (mm.zoomingMode == true) {
-			saveMapLoc = pos;
-			mm.ignoreGps = true;
+		if (mm.zoomingMode == true) { // zoom
+//			saveMapLoc = pos;
+	//		saveGpsIgnoreStatus = mm.ignoreGps;
+		//	mm.ignoreGps = true;
 			return false;
 		}
+		// move (drag) map
 		//if (!(which == null || which == mapImage || which instanceof TrackOverlay || which == mm.directionArrows) ) return false;
 		saveGpsIgnoreStatus = mm.ignoreGps; 
 		mm.ignoreGps = true;
+		paintingZoomArea = true;
 		saveMapLoc = pos;
 		bringMapToTop();
 		if (mapImage.isOnScreen() && !mapImage.hidden ) return super.imageBeginDragged(mapImage, pos);
@@ -1145,16 +1153,19 @@
 			saveMapLoc = new Point (ev.x, ev.y);
 		}
 		if (mm.zoomingMode && ev.type == PenEvent.PEN_DOWN) {
+			saveGpsIgnoreStatus = mm.ignoreGps;
+			mm.ignoreGps = true;
 			saveMapLoc = new Point (ev.x, ev.y);
 			paintingZoomArea = true;
 			mm.zoomingMode = true;
-		}
+		} 
 		if (!mm.zoomingMode && ev.type == PenEvent.PEN_DOWN && ev.modifiers == PenEvent.RIGHT_BUTTON) {
 			penHeld(new Point (ev.x, ev.y));
 		}
 		if (mm.zoomingMode && ev.type == PenEvent.PEN_UP ) {
 			paintingZoomArea = false;
 			mm.zoomingMode = false;
+			mm.ignoreGps = saveGpsIgnoreStatus;
 			removeImage(mm.buttonImageLensActivated);
 			addImage(mm.buttonImageLens);
 			if (java.lang.Math.abs(lastZoomWidth) < 15 || java.lang.Math.abs(lastZoomHeight) < 15)  {
@@ -1299,7 +1310,7 @@
 			else moveToCenterMI.modifiers |= MenuItem.Disabled;
 			mapsMenu.addItem(moveToCenterMI);
 			mapsMenu.addItem(moveToGpsMI);
-			
+
 			//m.set(Menu., status)
 			mapsMenu.exec(this, new Point(which.location.x, which.location.y), this);
 		}
@@ -1326,7 +1337,7 @@
 		} 
 		mm.SnapToGps();
 	}
-	
+
 	public void penHeld(Point p){
 		//	if (!menuIsActive()) doMenu(p);
 		if (!mm.zoomingMode) { 



From pfeffer at mail.berlios.de  Sun Feb  4 04:35:56 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 4 Feb 2007 04:35:56 +0100
Subject: [Cachewolf-svn] r500 - trunk/src/CacheWolf
Message-ID: <200702040335.l143ZuF3021880@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-04 04:35:52 +0100 (Sun, 04 Feb 2007)
New Revision: 500

Modified:
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MapsList.java
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: bug fixed: follow GPS war aus beim start der MovingMap
MovingMap: bug fixed: Probleme durch Multi-threading, dadurch kam es manchmal zur Anzeige mehrer Karten gleichzeitig

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-02-03 23:35:02 UTC (rev 499)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-02-04 03:35:52 UTC (rev 500)
@@ -171,6 +171,7 @@
 	public boolean runMovingMap = false;
 	MovingMap mmp;
 	Track currTrack;
+	Color trackColor = RED;
 
 	/**
 	 * Create GotoPanel 
@@ -380,10 +381,11 @@
 		if ((fix > 0) && (gpsPosition.getSats()>= 0)) {
 			//gpsPosition.printAll();
 			//Vm.debug("currTrack.add: voher");
+			if (currTrack == null) currTrack = new Track(trackColor);
 			try {
 				currTrack.add(gpsPosition);
 			} catch (IndexOutOfBoundsException e) { // track full -> create a new one
-				currTrack = new Track(RED); 
+				currTrack = new Track(trackColor); 
 				currTrack.add(gpsPosition);
 				if (mmp != null) mmp.addTrack(currTrack); // TODO maybe gotoPanel should also hold a list of Tracks, because otherwise they will be destroyed if not saved in mmp before
 			}
@@ -429,9 +431,9 @@
 		if (mmp != null && runMovingMap ) { // neccessary in case of multi-threaded Java-VM: ticked could be called during load of mmp 
 			if ((fix > 0) && (gpsPosition.getSats()>= 0)) {
 				mmp.directionArrows.setDirections(-361 /*(float)bearWayP.value*/, (float)sunAzimut.value, -361 /*(float)bearMov.value*/);
+				mmp.setGpsStatus(MovingMap.gotFix);
 				mmp.updatePosition(gpsPosition.latDec, gpsPosition.lonDec);
 				mmp.ShowLastAddedPoint(currTrack);
-				mmp.setGpsStatus(MovingMap.gotFix);
 			}
 			if ((fix == 0) && (gpsPosition.getSats()== 0)) {
 				mmp.setGpsStatus(MovingMap.lostFix);

Modified: trunk/src/CacheWolf/MapsList.java
===================================================================
--- trunk/src/CacheWolf/MapsList.java	2007-02-03 23:35:02 UTC (rev 499)
+++ trunk/src/CacheWolf/MapsList.java	2007-02-04 03:35:52 UTC (rev 500)
@@ -2,6 +2,7 @@
 
 import ewe.io.File;
 import ewe.io.IOException;
+import ewe.sys.Double;
 import ewe.ui.MessageBox;
 import ewe.util.Hashtable;
 import ewe.util.Vector;
@@ -14,7 +15,7 @@
  *
  */
 public class MapsList extends Vector {
-	public float scaleTolerance = 0.01f; // absolute deviations from this factor are seen to have the same scale
+	public static float scaleTolerance = 0.01f; // absolute deviations from this factor are seen to have the same scale
 	public Hashtable scales2Area;
 
 	/**
@@ -131,16 +132,46 @@
 	}
 	 */
 	/**
-	 * return a map which includs topleft and bottomright
-	 * if no map includes both it returns null 
+	 * @return a map which includs topleft and bottomright, 
+	 * if no map includes both it returns null
+	 * @param if more than one map includes topleft and bottomright than the one will
+	 * be returned which has its center nearest to topleft. If you have gps-pos and goto-pos
+	 * as topleft and buttomright use gps as topleft.
+	 * if topleft is really topleft or if it is buttomright is not relevant.  
 	 */
+	
+	// TODO if more than one map contains both -> select the best one of them
 	public MapInfoObject getMapForArea(CWPoint topleft, CWPoint bottomright){
 		MapInfoObject mi;
 		MapInfoObject fittingmap = null;
+		boolean latNearer, lonNearer;
+		boolean better;
+		double minDistLat = 10000000000000000000000.0;
+		double minDistLon = 10000000000000000000000.0;
 		for (int i=size() -1; i>=0 ;i--) {
+			better = false;
 			mi = (MapInfoObject)get(i);
-			if (mi.inBound(topleft) && mi.inBound(bottomright)) {
-				if (fittingmap == null || fittingmap.scale > mi.scale) fittingmap = mi;
+			if (mi.inBound(topleft) && mi.inBound(bottomright)) { // both points are inside the map
+				if (fittingmap == null || fittingmap.scale > mi.scale + scaleTolerance) {
+					better = true; // mi map has a better (lower) scale than the last knwon good map
+				} else {
+					if (fittingmap != null && java.lang.Math.abs(mi.scale - fittingmap.scale) < scaleTolerance) { // same scale as bestmap till now -> test if its center is nearer to the gps-point = topleft
+						latNearer = java.lang.Math.abs(topleft.latDec- mi.center.latDec)/mi.sizeKm < minDistLat ;
+						lonNearer = java.lang.Math.abs(topleft.lonDec - mi.center.lonDec)/mi.sizeKm < minDistLon;
+						if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
+						else {
+							if ( (latNearer || lonNearer )) { 
+								if (mi.center.getDistanceRad(topleft.latDec, topleft.lonDec) < fittingmap.center.getDistanceRad(topleft.latDec, topleft.lonDec) ) better = true;
+							}
+						}
+
+					}
+				}
+				if (better) {
+					fittingmap = mi;
+					minDistLat = java.lang.Math.abs(topleft.latDec - mi.center.latDec);
+					minDistLon = java.lang.Math.abs(topleft.lonDec - mi.center.lonDec);
+				}
 			}
 		} // for
 		return fittingmap;
@@ -148,10 +179,10 @@
 
 	/**
 	 * 
-	 * @param lat
+	 * @param lat a point to be inside the map
 	 * @param lon
 	 * @param screen
-	 * @param curScale
+	 * @param curScale reference scale to be changed
 	 * @param moreDetails true: find map with more details == higher resolustion = lower scale / false find map with less details = better overview
 	 * @return
 	 */
@@ -203,10 +234,10 @@
 	/**
 	 * returns an area in lat/lon of the screen
 	 * @param a screen width / height and position of lat/lon on the screen
-	 * @param lat
+	 * @param lat a (reference) point on the screen
 	 * @param lon
-	 * @param scale
-	 * @param map
+	 * @param scale scale (meters per pixel) of the map for which the screen edges are wanted
+	 * @param map map for which the screen edges are wanted
 	 * @return
 	 */
 	private Area getAreaForScreen(Rect a, double lat, double lon, float scale, MapInfoObject map) {
@@ -221,6 +252,9 @@
 		//scales2Area.put(new Float(scale), ret);
 		return ret; 
 	}
+	public static boolean scaleEquals(MapInfoObject a, MapInfoObject b) {
+		return java.lang.Math.abs(a.scale - b.scale) < scaleTolerance; 
+	}
 
 	/** for determining if a new map should be downloaded
 	public boolean isInAmap(CWPoint topleft, CWPoint buttomright) {

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-03 23:35:02 UTC (rev 499)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-04 03:35:52 UTC (rev 500)
@@ -132,27 +132,33 @@
 		if (tracks != null) addOverlaySet();
 	}
 
+	boolean loadingMapList = false;
 	/**
 	 * loads the list of maps
 	 * @param mapsPath must not have a trailing end "/"
 	 * @param lat used to create empty maps with correct conversion from lon to meters the latitude must be known
 	 */
 	public void loadMaps(String mapsPath, double lat){
+		if (loadingMapList) return;
+		loadingMapList = true;
 		this.mapPath = mapsPath;
 		Vm.showWait(this, true);
 		resetCenterOfMap();
 		InfoBox inf = new InfoBox("Info", "Loading list of maps...");
 		inf.exec();
+		boolean saveGpsIgnoreStatus = ignoreGps;
+		ignoreGps = true;
 		maps = new MapsList(mapsPath); // this actually loads the maps
 		if (maps.isEmpty()) {
 			(new MessageBox(MyLocale.getMsg(327, "Information"), MyLocale.getMsg(326, "Es steht keine kalibrierte Karte zur Verf?gung \n Bitte w?hlen Sie einen Ma?stab,\n in dem der Track und die markierten Caches angezeigt werden sollen"), MessageBox.OKB)).execute();
 			noMapsAvailable = true;
 		} else noMapsAvailable = false;
 		maps.addEmptyMaps(lat);
+		ignoreGps = saveGpsIgnoreStatus;
 		inf.close(0);
 		Vm.showWait(this, false);
-		if (noMapsAvailable) mmp.chooseMap(); // let the user select an scale
 		this.mapsloaded = true;
+		loadingMapList = false;
 	}
 
 	public void updateDistance() {
@@ -665,41 +671,41 @@
 	 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
 	 */
 	public void updatePosition(double lat, double lon){
+		if (ignoreGps || loadingMapList) return; // avoid multi-threading problems
 		Vm.debug("updatepors, lat: "+lat+" lon: "+lon);
 		if (!mapsloaded) {
 			loadMaps(mapPath, lat);
 			lastCompareX = Integer.MAX_VALUE;
 			lastCompareY = Integer.MAX_VALUE;
 			autoSelectMap = true;
-			setBestMap(lat, lon);
+			setBestMap(lat, lon, true);
 			forceMapLoad = false;
 			return;
 		}
-		if(!ignoreGps || forceMapLoad){
-			updateOnlyPosition(lat, lon, true);
-			if (autoSelectMap || forceMapLoad) {
-				Point mapPos = getMapPositionOnScreen();
-				if (forceMapLoad || wantMapTest|| (mmp.mapImage != null && ( mapPos.y > 0 || mapPos.x > 0 || mapPos.y+mmp.mapImage.getHeight()<this.height	|| mapPos.x+mmp.mapImage.getWidth()<this.width) 
-						|| 	mmp.mapImage == null )) 	{ // if force || want || map doesn't cover the scree completly
-					//Vm.debug("Screen not completly covered by map");
-					if (forceMapLoad || (java.lang.Math.abs(lastCompareX-mapPos.x) > this.width/10 || java.lang.Math.abs(lastCompareY-mapPos.y) > this.height/10)) {
-						// more then 1/10 of screen moved since last time we tried to find a better map
-						lastCompareX = mapPos.x;
-						lastCompareY = mapPos.y;
-						setBestMap(lat, lon);
-						forceMapLoad = false;
-					}
-				}
+		updateOnlyPosition(lat, lon, true);
+		if (!autoSelectMap) return;
+		Point mapPos = getMapPositionOnScreen();
+		boolean screenNotCompletlyCovered =  mmp.mapImage == null || (mmp.mapImage != null && ( mapPos.y > 0 || mapPos.x > 0 || mapPos.y+mmp.mapImage.getHeight()<this.height	|| mapPos.x+mmp.mapImage.getWidth()<this.width));
+		if (forceMapLoad || wantMapTest|| screenNotCompletlyCovered) 	{ // if force || want || map doesn't cover the scree completly
+			//Vm.debug("Screen not completly covered by map");
+			if (forceMapLoad || (java.lang.Math.abs(lastCompareX-mapPos.x) > this.width/10 || java.lang.Math.abs(lastCompareY-mapPos.y) > this.height/10)) {
+				// more then 1/10 of screen moved since last time we tried to find a better map
+				lastCompareX = mapPos.x;
+				lastCompareY = mapPos.y;
+				setBestMap(lat, lon, screenNotCompletlyCovered);
+				forceMapLoad = false;
 			}
 		}
 	}
 
+
 	int mapChangeModus;
 	float scaleWanted;
 	boolean wantMapTest = true; // if true updateposition calls setBestMap regulary even if the currentmap covers the whole screen
 	public final static int NORMAL_KEEP_RESOLUTION = 1; // keeps the choosen resolution as long as a map is available that overlaps with the screen and with the PosCircle - it changes the resolution if no such map is available. It wil cahnge back to the wanted scale as soon as a map becomes available (through movement of the GPS-receiver)
 	public final static int HIGHEST_RESOLUTION = 2;
 	public final static int HIGHEST_RESOLUTION_GPS_DEST = 3;
+	boolean inBestMap = false; // to avoid multi-threading problems
 
 	/**
 	 * loads the best map for lat/lon according to mapChangeModus
@@ -712,8 +718,12 @@
 	 * 
 	 * @param lat
 	 * @param lon
+	 * @param loadIfSameScale false: will not change the map if the better map has the same scale as the current - this is used not to change the map if it covers already the screen completely
+	 * true: willchange the map, regardless of change in scale
 	 */
-	public void setBestMap(double lat, double lon) {
+	public void setBestMap(double lat, double lon, boolean loadIfSameScale) {
+		if (inBestMap) return;                  // TODO zoomlevel ber?cksichtigen
+		inBestMap = true;
 		Object [] s = getRectForMapChange(lat, lon);
 		CWPoint cll = (CWPoint) s[0]; 
 		Rect screen = (Rect) s[1]; 
@@ -734,22 +744,28 @@
 		default: (new MessageBox("Error", "Programmfehler: \nillegal mapChangeModus: " + mapChangeModus, MessageBox.OKB)).execute(); break;
 		}
 		if ( newmap != null && (currentMap == null || currentMap.mapName != newmap.mapName) ) {
-			setMap(newmap, lat, lon); // TODO handling, wenn newmap == null
+			if (loadIfSameScale || !MapsList.scaleEquals(currentMap, newmap) ) setMap(newmap, lat, lon); 
 			Vm.debug("better map found");
+			inBestMap = false;
 			return;
 		}
 		if (currentMap == null && newmap == null) {
 			(new MessageBox("Information", "F?r die aktuelle Position steht keine Karte zur Verf?ung, bitte w?hlen Sie eine manuell", MessageBox.OKB)).execute();
 			posCircleLat = lat;
 			posCircleLon = lon; // choosemap calls setmap with posCircle-coos
-			mmp.chooseMap(); 
+			while (currentMap == null) {
+				mmp.chooseMap(); // force the user to select a scale // TODO empty maps on top?
+				if (currentMap == null) (new MessageBox("Error", "Moving map cannot run without a map - please select one", MessageBox.OKB)).execute();
+			}
 		}
+		inBestMap = false;
 	}
 
 	public void setResModus (int modus) {
+		if (mapChangeModus == modus) return;
 		mapChangeModus = modus;
 		if (modus == NORMAL_KEEP_RESOLUTION) scaleWanted = currentMap.scale;
-		else setBestMap(posCircleLat, posCircleLon);
+		else setBestMap(posCircleLat, posCircleLon, true);
 	}
 	/**
 	 * method to get a point on the screen which must be included in the map
@@ -813,7 +829,7 @@
 		GpsStatus = status;
 		ignoreGps = false;
 		switch (status) {
-		case noGPS: 	{ posCircle.change(null); ignoreGps = true; break; }
+		case noGPS: 	{ posCircle.change(null); /*ignoreGps = true; */ break; }
 		case gotFix:    { posCircle.change(statusImageHaveSignal); break; }
 		case lostFix:   { posCircle.change(statusImageNoSignal); break; }
 		case noGPSData: { posCircle.change(statusImageNoGps); break; }
@@ -1123,15 +1139,15 @@
 	public boolean imageBeginDragged(AniImage which,Point pos) {
 		if (mm.zoomingMode == true) { // zoom
 //			saveMapLoc = pos;
-	//		saveGpsIgnoreStatus = mm.ignoreGps;
-		//	mm.ignoreGps = true;
+			//		saveGpsIgnoreStatus = mm.ignoreGps;
+			//	mm.ignoreGps = true;
 			return false;
 		}
 		// move (drag) map
 		//if (!(which == null || which == mapImage || which instanceof TrackOverlay || which == mm.directionArrows) ) return false;
 		saveGpsIgnoreStatus = mm.ignoreGps; 
 		mm.ignoreGps = true;
-		paintingZoomArea = true;
+		//paintingZoomArea = true;
 		saveMapLoc = pos;
 		bringMapToTop();
 		if (mapImage.isOnScreen() && !mapImage.hidden ) return super.imageBeginDragged(mapImage, pos);
@@ -1186,7 +1202,7 @@
 			top -= 2;
 			if (top < 0) top = 0;
 			if (left < 0) left = 0;
-			this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth)+2, java.lang.Math.abs(lastZoomHeight)+2));
+			this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth)+4, java.lang.Math.abs(lastZoomHeight)+4));
 			lastZoomWidth = ev.x - saveMapLoc.x;
 			lastZoomHeight =  ev.y - saveMapLoc.y;
 			if (lastZoomWidth < 0) left = saveMapLoc.x + lastZoomWidth;
@@ -1331,10 +1347,8 @@
 	}
 
 	public void snapToGps() {
-		if (mm.gotoPanel.serThread == null || !mm.gotoPanel.serThread.isAlive()) {
+		if (mm.gotoPanel.serThread == null || !mm.gotoPanel.serThread.isAlive()) 
 			mm.gotoPanel.startGps();
-			mm.addTrack(mm.gotoPanel.currTrack); // use new track when gps now started
-		} 
 		mm.SnapToGps();
 	}
 



From salzkammergut at mail.berlios.de  Sun Feb  4 09:34:11 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 4 Feb 2007 09:34:11 +0100
Subject: [Cachewolf-svn] r501 - trunk/src/CacheWolf
Message-ID: <200702040834.l148YBRi008449@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-04 09:34:03 +0100 (Sun, 04 Feb 2007)
New Revision: 501

Modified:
   trunk/src/CacheWolf/CacheHolder.java
Log:
CacheHolder: Feld pos mit CWPoint initialisiert damit nicht immer auf pos==null abgefragt werden muss
(Vorbereitung fuer Behebung diverser Bugs die aus der noch nicht vollstaendig umgesetzten Einfuehrung von pos resultieren)

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-02-04 03:35:52 UTC (rev 500)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-02-04 08:34:03 UTC (rev 501)
@@ -23,7 +23,7 @@
   public String CacheName = new String();
   public String CacheOwner = new String();
   public String LatLon = new String();
-  public CWPoint pos = null;
+  public CWPoint pos = new CWPoint();
   public String DateHidden = new String();
   public String LastUpdate = new String();
   public String Hints = new String();



From salzkammergut at mail.berlios.de  Sun Feb  4 10:15:26 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 4 Feb 2007 10:15:26 +0100
Subject: [Cachewolf-svn] r502 - trunk/src/CacheWolf
Message-ID: <200702040915.l149FQQU009920@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-04 10:15:20 +0100 (Sun, 04 Feb 2007)
New Revision: 502

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/CalcPanel.java
   trunk/src/CacheWolf/GPXImporter.java
   trunk/src/CacheWolf/LOCXMLImporter.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/SpiderGC.java
Log:
Bugfix: "pos" und "LatLon" gleichzeitig aktualisieren

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-02-04 08:34:03 UTC (rev 501)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-02-04 09:15:20 UTC (rev 502)
@@ -106,6 +106,7 @@
 	  
 	  //coords
 	  this.LatLon = newCh.LatLon;
+	  this.pos.set(newCh.pos);
 
 	  // check only length of the description to see, if there was an update
 	  if (this.LongDescription.length() != newCh.LongDescription.length()){

Modified: trunk/src/CacheWolf/CalcPanel.java
===================================================================
--- trunk/src/CacheWolf/CalcPanel.java	2007-02-04 08:34:03 UTC (rev 501)
+++ trunk/src/CacheWolf/CalcPanel.java	2007-02-04 09:15:20 UTC (rev 502)
@@ -160,6 +160,7 @@
 				readFields(coordInp, bd, currFormat);
 				coordOut = coordInp.project(bd.degrees, bd.distance);
 				ch.LatLon = coordOut.toString();
+				ch.pos.set(coordOut);
 				detP.newWaypoint(ch, mainT);
 			}
 			

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2007-02-04 08:34:03 UTC (rev 501)
+++ trunk/src/CacheWolf/GPXImporter.java	2007-02-04 09:15:20 UTC (rev 502)
@@ -154,6 +154,7 @@
 		if (name.equals("wpt")) {
 			holder = new CacheHolder();
 			holder.LatLon = latdeg2min(atts.getValue("lat")) + " " +londeg2min(atts.getValue("lon"));
+			holder.pos.set(Common.parseDouble(atts.getValue("lat")),Common.parseDouble(atts.getValue("lon")));
 			inWpt = true;
 			inLogs = false;
 			inBug = false;

Modified: trunk/src/CacheWolf/LOCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/LOCXMLImporter.java	2007-02-04 08:34:03 UTC (rev 501)
+++ trunk/src/CacheWolf/LOCXMLImporter.java	2007-02-04 09:15:20 UTC (rev 502)
@@ -91,6 +91,7 @@
 		}
 		if (name.equals("coord")){
 			holder.LatLon = GPXImporter.latdeg2min(atts.getValue("lat")) + " " + GPXImporter.londeg2min(atts.getValue("lon"));
+			holder.pos.set(Common.parseDouble(atts.getValue("lat")),Common.parseDouble(atts.getValue("lon")));
 			return;
 		}
 

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-02-04 08:34:03 UTC (rev 501)
+++ trunk/src/CacheWolf/MainTab.java	2007-02-04 09:15:20 UTC (rev 502)
@@ -118,7 +118,8 @@
 					  ch.is_black = detP.blackStatus;
 					  ch.wayPoint = detP.wayPoint.getText();
 					  ch.CacheName = detP.wayName.getText();
-					  ch.LatLon = new CWPoint(detP.btnWayLoc.getText(),CWPoint.CW).toString();
+					  ch.pos.set(detP.btnWayLoc.getText(),CWPoint.CW);
+					  ch.LatLon = ch.pos.toString();
 					  ch.DateHidden = detP.wayHidden.getText();
 					  ch.CacheOwner = detP.wayOwner.getText();
 					  if(pref.myAlias.equals(ch.CacheOwner)) ch.is_owned = true;

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-02-04 08:34:03 UTC (rev 501)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-02-04 09:15:20 UTC (rev 502)
@@ -386,6 +386,7 @@
 		}
 		if(name.equals("latitude")) {
 			holder.LatLon = GPXImporter.latdeg2min(strData) + " " + holder.LatLon;
+			holder.pos.set(holder.LatLon);
 			return;
 		}
 		if(name.equals("difficulty")) {

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-02-04 08:34:03 UTC (rev 501)
+++ trunk/src/CacheWolf/Parser.java	2007-02-04 09:15:20 UTC (rev 502)
@@ -208,9 +208,9 @@
 			if (idx!=-1) { // Found it!
 				CacheHolder ch=(CacheHolder)Global.getProfile().cacheDB.get(idx);
 				// Check whether coordinates are valid
-				cwPt.set(ch.LatLon);
+				cwPt.set(ch.pos);
 				if (cwPt.isValid() ) 
-					return ch.LatLon;
+					return cwPt.toString();
 				else
 					return ""; // Convert invalid coordinates (N 0 0.0 E 0 0.0) into empty string
 			}
@@ -463,7 +463,9 @@
     		int i=Global.getProfile().getCacheIndex(waypointName);
     		if (i<0) err(MyLocale.getMsg(1714,"Goto: Waypoint does not exist: ")+waypointName);
     		cwPt.set(coord);
-    		((CacheHolder)Global.getProfile().cacheDB.get(i)).LatLon=cwPt.toString(CWPoint.CW);
+    		CacheHolder ch=((CacheHolder)Global.getProfile().cacheDB.get(i));
+    		ch.LatLon=cwPt.toString(CWPoint.CW);
+    		ch.pos.set(cwPt);
     	}
     }
     
@@ -682,6 +684,7 @@
 				cwPt.set(coord);
 				if (cwPt.isValid() || coord.equals("")) { // Can clear coord with empty string
 					ch.LatLon=cwPt.toString(CWPoint.CW);
+					ch.pos.set(cwPt);
 				    return;
 				} else
 					err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coord);

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-02-04 08:34:03 UTC (rev 501)
+++ trunk/src/CacheWolf/Profile.java	2007-02-04 09:15:20 UTC (rev 502)
@@ -35,7 +35,7 @@
 	/** Distance for opencaching caches */
 	public String distOC = new String();
 	
-	public final static String FILTERTYPE="11111111110";
+	public final static String FILTERTYPE="11111111111000000";
 	public final static String FILTERROSE="1111111111111111";
 	public final static String FILTERVAR="11111111";
 	public String filterType = new String(FILTERTYPE);
@@ -107,12 +107,13 @@
 				ch = (CacheHolder)cacheDB.get(i);
 				////Vm.debug("Saving: " + ch.CacheName);
 				if(ch.wayPoint.length()>0 && ch.LongDescription.equals("An Error Has Occured") == false){
-					if (ch.pos==null) {
+/* pos must always be set, so this is no longer needed
+ 					if (ch.pos==null) {
 						ParseLatLon pl=new ParseLatLon(ch.LatLon);
 						pl.parse();
 						ch.pos=new CWPoint(pl.lat2,pl.lon2);
 					}
-					detfile.print("    <CACHE name = \""+SafeXML.clean(ch.CacheName)+"\" owner = \""+SafeXML.clean(ch.CacheOwner)+
+*/					detfile.print("    <CACHE name = \""+SafeXML.clean(ch.CacheName)+"\" owner = \""+SafeXML.clean(ch.CacheOwner)+
 							//"\" lat = \""+ SafeXML.clean(ch.LatLon) +
 							"\" lat = \""+ ch.pos.latDec + "\" lon = \""+ch.pos.lonDec+
 							"\" hidden = \""+ch.DateHidden+"\" wayp = \""+SafeXML.clean(ch.wayPoint)+"\" status = \""+ch.CacheStatus+"\" type = \""+ch.type+"\" dif = \""+ch.hard+"\" terrain = \"" + ch.terrain + "\" dirty = \"" + ch.dirty + "\" size = \""+ch.CacheSize+"\" online = \"" + Convert.toString(ch.is_available) + "\" archived = \"" + Convert.toString(ch.is_archived) + "\" has_bug = \"" + Convert.toString(ch.has_bug) + "\" black = \"" + Convert.toString(ch.is_black) + "\" owned = \"" + Convert.toString(ch.is_owned) + "\" found = \"" + Convert.toString(ch.is_found) + "\" is_new = \"" + Convert.toString(ch.is_new) +"\" is_log_update = \"" + Convert.toString(ch.is_log_update) + "\" is_update = \"" + Convert.toString(ch.is_update) + "\" is_HTML = \"" + Convert.toString(ch.is_HTML) + "\" DNFLOGS = \"" + ch.noFindLogs + "\" ocCacheID = \"" + ch.ocCacheID + "\" />\n");
@@ -155,8 +156,10 @@
 						double lon=Convert.parseDouble(ex.findNext().replace(notDecSep,decSep));
 						ch.pos=new CWPoint(lat,lon);
 						ch.LatLon=ch.pos.toString();
-					} else
+					} else {
 						ch.LatLon = SafeXML.cleanback(ex.findNext());
+						ch.pos.set(ch.LatLon,CWPoint.CW);
+					}
 					ch.DateHidden = ex.findNext();
 					ch.wayPoint = SafeXML.cleanback(ex.findNext());
 					ch.CacheStatus = ex.findNext();
@@ -283,15 +286,12 @@
 			CWPoint fromPoint = new CWPoint(Global.getPref().curCentrePt); // Clone current centre to be sure
 			int anz = cacheDB.getCount();
 			CacheHolder ch;
-			CWPoint toPoint = new CWPoint();
+			CWPoint toPoint;
 			// Jetzt durch die CacheDaten schleifen
 			while(--anz >= 0){
 				ch = (CacheHolder)cacheDB.get(anz); // This returns a pointer to the CacheHolder object
 				if(ch.LatLon.length()>4){
-					if (ch.pos == null) { // only calculate once
-						toPoint.set(ch.LatLon, CWPoint.CW); // Fast parse with traditional parse algorithm
-						ch.pos = new CWPoint(toPoint);
-					} else toPoint = ch.pos;
+					toPoint = ch.pos;
 					ch.kilom = fromPoint.getDistance(toPoint);
 					ch.degrees = fromPoint.getBearing(toPoint);
 					ch.bearing = CWPoint.getDirection(ch.degrees);

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-02-04 08:34:03 UTC (rev 501)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-02-04 09:15:20 UTC (rev 502)
@@ -142,6 +142,7 @@
 		ch.CacheLogs = getLogs(start, ch);
 		pref.log("Found logs");
 		ch.LatLon = getLatLon(start);
+		ch.pos.set(ch.LatLon);
 		//Vm.debug("LatLon: " + ch.LatLon);
 		pref.log("Trying description");
 		ch.LongDescription = getLongDesc(start);
@@ -317,6 +318,7 @@
 					ch.CacheLogs = getLogs(start, ch);
 					pref.log("Found logs");
 					ch.LatLon = getLatLon(start);
+					ch.pos.set(ch.LatLon); // Slow parse no problem
 					//Vm.debug("LatLon: " + ch.LatLon);
 					pref.log("Trying description");
 					ch.LongDescription = getLongDesc(start);
@@ -436,6 +438,7 @@
 				cx.CacheName = nameRex.stringMatched(1);
 				if(koordRex.didMatch()) cx.LatLon = koordRex.stringMatched(1); 
 				else cx.LatLon = "N 00? 00.000 E 000? 00.000"; 
+				cx.pos.set(cx.LatLon);
 				if(typeRex.didMatch()) cx.type = CacheType.typeText2Number("Waypoint|"+typeRex.stringMatched(1));
 				
 				//Vm.debug("Name: " + nameRex.stringMatched(1));



From salzkammergut at mail.berlios.de  Sun Feb  4 12:18:10 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 4 Feb 2007 12:18:10 +0100
Subject: [Cachewolf-svn] r503 - trunk/src/CacheWolf
Message-ID: <200702041118.l14BIAc0015397@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-04 12:18:04 +0100 (Sun, 04 Feb 2007)
New Revision: 503

Modified:
   trunk/src/CacheWolf/SpiderGC.java
   trunk/src/CacheWolf/myTableControl.java
Log:
SpiderGC: Bugfix. SpiderSingle prueft ob Addi Wpt schon existiert und macht ggf. ein Update
Es werden nur die Addis aktualisiert, die angehakt sind, so kann ein unbeabsichtigtes Ueberschreiben vermieden werden

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-02-04 09:15:20 UTC (rev 502)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-02-04 11:18:04 UTC (rev 503)
@@ -112,8 +112,9 @@
 	 * It assumes a login has already been performed!
 	 */
 	public void spiderSingle(int number){
+		CacheHolder ch = (CacheHolder)cacheDB.get(number);
+		if (ch.isAddiWpt()) return;  // No point spidering an addi waypoint, comes with parent
 		Vm.showWait(true);
-		CacheHolder ch = (CacheHolder)cacheDB.get(number);
 		String notes = new String();
 		String start = new String();
 		try{
@@ -416,7 +417,6 @@
 	}
 	
 	public void getAddWaypoints(String doc, CacheHolder ch){
-		CacheHolder cx = new CacheHolder();
 		Extractor exWayBlock = new Extractor(doc, "<strong>Additional Waypoints</strong><br>", "</table>", 0, false);
 		String wayBlock = new String();
 		String rowBlock = new String();
@@ -431,6 +431,7 @@
 			rowBlock = exRowBlock.findNext();
 			rowBlock = exRowBlock.findNext();
 			while(exRowBlock.endOfSearch()==false){
+				CacheHolder cx = new CacheHolder();
 				
 				nameRex.search(rowBlock);
 				koordRex.search(rowBlock);
@@ -458,10 +459,12 @@
 				counter++;
 				cx.LongDescription = descRex.stringMatched(1); 
 				//Vm.debug(descRex.stringMatched(1));
-				
-				cacheDB.add(cx);
+				int idx=profile.getCacheIndex(cx.wayPoint);
+				if (idx<0)
+					cacheDB.add(cx);
+				else if (((CacheHolder) cacheDB.get(idx)).is_Checked) // Only spider addi waypoints that are ticked
+					((CacheHolder) cacheDB.get(idx)).update(cx);
 				cx.saveCacheDetails(profile.dataDir);
-				cx = new CacheHolder();
 				
 				rowBlock = exRowBlock.findNext();
 			}

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-02-04 09:15:20 UTC (rev 502)
+++ trunk/src/CacheWolf/myTableControl.java	2007-02-04 11:18:04 UTC (rev 503)
@@ -90,16 +90,25 @@
 			Vm.showWait(true);
 			spider.login();
 			boolean alreadySaid = false;
+			boolean alreadySaid2 = false;
 			for(int i = 0; i <	db.size(); i++){
 				ch = (CacheHolder)db.get(i);
 				if(ch.is_Checked == true) {
-					if ( (ch.wayPoint.length() > 1 && ch.wayPoint.substring(0,2).equalsIgnoreCase("GC"))
-							|| (ch.mainCache != null &&	ch.mainCache.wayPoint.length() > 1 	&& ch.mainCache.wayPoint.substring(0,2).equalsIgnoreCase("GC")) ) 
+					if ( (ch.wayPoint.length() > 1 && ch.wayPoint.substring(0,2).equalsIgnoreCase("GC")))
+// Notiz: Wenn es ein addi Wpt ist, sollte eigentlich der Maincache gespidert werden
+// Alter code pr?ft aber nur ob ein Maincache von GC existiert und versucht dann den addi direkt zu spidern, was nicht funktioniert
+// TODO: Diese Meldungen vor dem Einloggen darstellen						
 					{
 						spider.spiderSingle(i);
-					} else if (!alreadySaid) {
+					} else if (ch.isAddiWpt() && !ch.mainCache.is_Checked) { // Is the father ticked?
+						if (!alreadySaid2) {
+							alreadySaid2=true;
+							(new MessageBox("Information","Hilfswegpunkte k?nnnen nicht direkt gespidert werden\nBitte zus?tzlich den Vater anhaken", MessageBox.OKB)).exec();
+						}
+					} else if (ch.mainCache != null &&	ch.mainCache.wayPoint.length() > 1 	&& !ch.mainCache.wayPoint.substring(0,2).equalsIgnoreCase("GC") && 
+							   !alreadySaid) {
 						alreadySaid = true;
-						(new MessageBox("Information","Diese Funktion steht gegenw?rtig nur f?r Geocaching.com zur Verf?gung", MessageBox.OKB)).exec();
+						(new MessageBox("Information",ch.wayPoint+">"+ch.mainCache.wayPoint+": Diese Funktion steht gegenw?rtig nur f?r Geocaching.com zur Verf?gung", MessageBox.OKB)).exec();
 					}
 				}
 			}



From pfeffer at mail.berlios.de  Sun Feb  4 14:23:51 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 4 Feb 2007 14:23:51 +0100
Subject: [Cachewolf-svn] r504 - trunk/src/CacheWolf
Message-ID: <200702041323.l14DNpTi002459@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-04 14:23:47 +0100 (Sun, 04 Feb 2007)
New Revision: 504

Modified:
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: ready to test: Anklicken und rechter Mausklich nicht mehr so empfindlich gegen Bewegung w?\195?\164hrend des Dr?\195?\188ckens

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-04 11:18:04 UTC (rev 503)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-04 13:23:47 UTC (rev 504)
@@ -104,6 +104,7 @@
 		setGpsStatus(noGPS);
 		posCircle.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(posCircle);
+		mmp.startDragResolution = 5;
 		mapsloaded = false;
 		posCircleLat = -361;
 		posCircleLon = -361; // make them invalid



From salzkammergut at mail.berlios.de  Sun Feb  4 16:23:54 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 4 Feb 2007 16:23:54 +0100
Subject: [Cachewolf-svn] r505 - in trunk: resources src/CacheWolf
Message-ID: <200702041523.l14FNsDr010188@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-04 16:23:46 +0100 (Sun, 04 Feb 2007)
New Revision: 505

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/FilterScreen.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/TablePanel.java
Log:
Ueberarbeiteter Filter. Filtert jetzt nach Addi Wpt Type

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-02-04 13:23:47 UTC (rev 504)
+++ trunk/resources/cachewolf.Languages.cfg	2007-02-04 15:23:46 UTC (rev 505)
@@ -157,6 +157,9 @@
 		723=Typen
 		724=Beh%e4lter
 		725=Hinweis: Filter sind additiv, activ = gr%fcn
+		726=Zus%e4tzliche Wegpunkte
+		727=Beh%e4lter
+		728=Zus. WegPkt
 		800=Erstelle Liste
 		801=suche...
 		802=Caches identifiziert. Suche weiter...
@@ -197,6 +200,10 @@
 		1019=Diesen als Zentrum setzen
 		1020=Im Browser online %f6ffnen
 		1021=Beschreibung %f6ffnen
+		1022=Alle mit H?kchen markierten Caches l%f6schen?
+		1023=Diese Funktion steht gegenw%e4rtig nur f?r Geocaching.com zur Verf%fcgung
+		1024=Entfernungen in der Listenansicht~vom aktuellen Standpunkt aus~neu berechnet
+		1025=Kann Zentrum nicht setzen (GPS-Position unzul%e4ssig)
 		1100=Profile
 		1101=Profil 1
 		1102=Profil 2
@@ -470,6 +477,9 @@
 		723=Types
 		724=Container
 		725=Note: Filters are additive, active filter=green
+		726=Additional waypoints
+		727=Cache container
+		728=Add. Waypt
 		800=Creating list
 		801=searching...
 		802=Caches identified. searching...
@@ -510,6 +520,10 @@
 		1019=Set this as center
 		1020=Open online in Browser
 		1021=Open cache description
+		1022=Delete all caches that have a tick?
+		1023=This function is currently only available for geocaching.com
+		1024=Distances in list view recalculated~from current position
+		1025=Cannot set centre (Invalid GPS position)
 		1100=Profiles
 		1101=Profile 1
 		1102=Profile 2

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2007-02-04 13:23:47 UTC (rev 504)
+++ trunk/src/CacheWolf/Filter.java	2007-02-04 15:23:46 UTC (rev 505)
@@ -12,78 +12,86 @@
 */
 public class Filter{
 	
-	public static final int SMALLER = -1;
-	public static final int EQUAL = -1;
-	public static final int GREATER = 1;
-	public static final int FOUND = 2;
-	public static final int NOTFOUND = 3;
+	private static final int SMALLER = -1;
+	private static final int EQUAL = -1;
+	private static final int GREATER = 1;
 
-	public static final int TRADITIONAL = 1;
-	public static final int MULTI = 2;
-	public static final int VIRTUAL = 4;
-	public static final int LETTER = 8;
-	public static final int EVENT = 16;
-	public static final int WEBCAM = 32;
-	public static final int MYSTERY = 64;
-	public static final int LOCLESS = 128;
-	public static final int ADDIWPT = 256;
-	public static final int MEGA = 512;
-	public static final int EARTH = 1024;
+	private static final int TRADITIONAL = 1;
+	private static final int MULTI = 2;
+	private static final int VIRTUAL = 4;
+	private static final int LETTER = 8;
+	private static final int EVENT = 16;
+	private static final int WEBCAM = 32;
+	private static final int MYSTERY = 64;
+	private static final int LOCLESS = 128;
+	private static final int CUSTOM = 256;
+	private static final int MEGA = 512;
+	private static final int EARTH = 1024;
+	private static final int PARKING = 2048;
+	private static final int STAGE = 4096;
+	private static final int QUESTION = 8192;
+	private static final int FINAL = 16384;
+	private static final int TRAILHEAD = 32768;
+	private static final int REFERENCE = 65536;
+	private static final int TYPE_ALL=TRADITIONAL|MULTI|VIRTUAL|LETTER|EVENT|WEBCAM|MYSTERY|LOCLESS|CUSTOM
+	                                  |MEGA|EARTH|PARKING|STAGE|QUESTION|FINAL|TRAILHEAD|REFERENCE;
+
+	private static final int N = 1;
+	private static final int NNE = 2;
+	private static final int NE = 4;
+	private static final int ENE = 8;
+	private static final int E = 16;
+	private static final int ESE = 32;
+	private static final int SE = 64;
+	private static final int SSE = 128;
+	private static final int SSW = 256;
+	private static final int SW = 512;
+	private static final int WSW = 1024;
+	private static final int W = 2048;
+	private static final int WNW = 4096;
+	private static final int NW = 8192;
+	private static final int NNW = 16384;
+	private static final int S = 32768;
+	private static final int ROSE_ALL= N|NNE|NE|ENE|E|ESE|SE|SSE|SSW|SW|WSW|W|WNW|NW|NNW|S;
+
+	private static final int MICRO=1; 
+	private static final int SMALL=2;	
+	private static final int REGULAR=4;	
+	private static final int LARGE=8;	
+	private static final int VERYLARGE=16;	
+	private static final int OTHER=32;	
+	private static final int SIZE_ALL=MICRO|SMALL|REGULAR|LARGE|VERYLARGE|OTHER;
 	
-	// End of type declares
-	public static final int N = 1;
-	public static final int NNE = 2;
-	public static final int NE = 4;
-	public static final int ENE = 8;
-	public static final int E = 16;
-	public static final int ESE = 32;
-	public static final int SE = 64;
-	public static final int SSE = 128;
-	public static final int SSW = 256;
-	public static final int SW = 512;
-	public static final int WSW = 1024;
-	public static final int W = 2048;
-	public static final int WNW = 4096;
-	public static final int NW = 8192;
-	public static final int NNW = 16384;
-	public static final int S = 32768;
-	//end of direction declares
+	private int distdirec = 0;
+	private int diffdirec = 0;
+	private int terrdirec = 0;
 	
-	
-	
-	public String dist = new String();
-	public File routeFile;
-	public int distdirec = 0;
-	public String diff = new String();
-	public int diffdirec = 0;
-	public String terr = new String();
-	public int terrdirec = 0;
-	
-	public String days = new String();
-	public int daysdirec = 0;
-	public String by = new String();
 	String[] byVec;
 	
-	public String type = new String();
-	public String bearing = new String();
 	
-	public int roseMatchPattern = 0;
-	public int typeMatchPattern = 0;
+	private int roseMatchPattern;
+	private boolean hasRoseMatchPattern;
+	private int typeMatchPattern;
+	private boolean hasTypeMatchPattern;
+	private int sizeMatchPattern;
+	private boolean hasSizeMatchPattern;
 	
-	public boolean foundByMe;
-	public boolean notFoundByMe;
+	private boolean foundByMe;
+	private boolean notFoundByMe;
 	
-	public boolean ownedByMe;
-	public boolean notOwnedByMe;
+	private boolean ownedByMe;
+	private boolean notOwnedByMe;
+
+	double fscDist;
+	double fscTerr;
+	double fscDiff;
 	
-	//private boolean is_changed;
-	public int filterKriteria = 0;
 	
-	public boolean archived = false;
-	public boolean notArchived = false;
+	private boolean archived = false;
+	private boolean notArchived = false;
 	
-	public boolean available=false;
-	public boolean notAvailable = false;
+	private boolean available=false;
+	private boolean notAvailable = false;
 	double pi180=java.lang.Math.PI / 180.0;
 	
 	/**
@@ -91,7 +99,8 @@
 	*	We use a regex method to allow for different formats of waypoints:
 	*	possible is currently: DD MM.mmm
 	*/
-	public void doFilterRoute(Vector cacheDB, String dir, double distance){
+	public void doFilterRoute(File routeFile, double distance){
+		Vector cacheDB=Global.getProfile().cacheDB;
 		//load file into a vector:
 		Vector wayPoints = new Vector();
 		Regex rex = new Regex("(N|S).*?([0-9]{1,2}).*?([0-9]{1,3})(,|.)([0-9]{1,3}).*?(E|W).*?([0-9]{1,2}).*?([0-9]{1,3})(,|.)([0-9]{1,3})");
@@ -223,18 +232,89 @@
 	}
 	
 	/**
+	 * Set the filter from the filter data stored in the profile
+	 * (the filterscreen also updates the profile)
+	 */
+	public void setFilter() {
+		Profile profile=Global.getProfile();
+		archived     = profile.filterVar.charAt(0) == '1';
+		available    = profile.filterVar.charAt(1) == '1';
+		foundByMe    = profile.filterVar.charAt(2) == '1';
+		ownedByMe    = profile.filterVar.charAt(3) == '1';
+		notArchived  = profile.filterVar.charAt(4) == '1';
+		notAvailable = profile.filterVar.charAt(5) == '1';
+		notFoundByMe = profile.filterVar.charAt(6) == '1';
+		notOwnedByMe = profile.filterVar.charAt(7) == '1';
+		typeMatchPattern=0;
+		String filterType=profile.filterType;
+		if (filterType.charAt(0) == '1') typeMatchPattern|=TRADITIONAL;
+		if (filterType.charAt(1) == '1') typeMatchPattern|=MULTI;
+		if (filterType.charAt(2) == '1') typeMatchPattern|=VIRTUAL;
+		if (filterType.charAt(3) == '1') typeMatchPattern|=LETTER;
+		if (filterType.charAt(4) == '1') typeMatchPattern|=EVENT;
+		if (filterType.charAt(5) == '1') typeMatchPattern|=WEBCAM;
+		if (filterType.charAt(6) == '1') typeMatchPattern|=MYSTERY;
+		if (filterType.charAt(7) == '1') typeMatchPattern|=EARTH;
+		if (filterType.charAt(8) == '1') typeMatchPattern|=LOCLESS;
+		if (filterType.charAt(9) == '1') typeMatchPattern|=MEGA;
+		if (filterType.charAt(10) == '1') typeMatchPattern|=CUSTOM;
+		if (filterType.charAt(11) == '1') typeMatchPattern|=PARKING;
+		if (filterType.charAt(12) == '1') typeMatchPattern|=STAGE;
+		if (filterType.charAt(13) == '1') typeMatchPattern|=QUESTION;
+		if (filterType.charAt(14) == '1') typeMatchPattern|=FINAL;
+		if (filterType.charAt(15) == '1') typeMatchPattern|=TRAILHEAD;
+		if (filterType.charAt(16) == '1') typeMatchPattern|=REFERENCE;
+		hasTypeMatchPattern= typeMatchPattern!=TYPE_ALL;
+		roseMatchPattern=0;
+		String filterRose=profile.filterRose;
+		if (filterRose.charAt(0) == '1') roseMatchPattern|=NW;
+		if (filterRose.charAt(1) == '1') roseMatchPattern|=NNW;
+		if (filterRose.charAt(2) == '1') roseMatchPattern|=N;
+		if (filterRose.charAt(3) == '1') roseMatchPattern|=NNE;
+		if (filterRose.charAt(4) == '1') roseMatchPattern|=NE;
+		if (filterRose.charAt(5) == '1') roseMatchPattern|=ENE;
+		if (filterRose.charAt(6) == '1') roseMatchPattern|=E;
+		if (filterRose.charAt(7) == '1') roseMatchPattern|=ESE;
+		if (filterRose.charAt(8) == '1') roseMatchPattern|=SE;
+		if (filterRose.charAt(9) == '1') roseMatchPattern|=SSE;
+		if (filterRose.charAt(10) == '1') roseMatchPattern|=S;
+		if (filterRose.charAt(11) == '1') roseMatchPattern|=SSW;
+		if (filterRose.charAt(12) == '1') roseMatchPattern|=SW;
+		if (filterRose.charAt(13) == '1') roseMatchPattern|=WSW;
+		if (filterRose.charAt(14) == '1') roseMatchPattern|=W;
+		if (filterRose.charAt(15) == '1') roseMatchPattern|=WNW;
+		hasRoseMatchPattern=roseMatchPattern!=ROSE_ALL;
+		sizeMatchPattern=0;
+		String filterSize=profile.filterSize;
+		if (filterSize.charAt(0) == '1') sizeMatchPattern|=MICRO;
+		if (filterSize.charAt(1) == '1') sizeMatchPattern|=SMALL;
+		if (filterSize.charAt(2) == '1') sizeMatchPattern|=REGULAR;
+		if (filterSize.charAt(3) == '1') sizeMatchPattern|=LARGE;
+		if (filterSize.charAt(4) == '1') sizeMatchPattern|=VERYLARGE;
+		if (filterSize.charAt(5) == '1') sizeMatchPattern|=OTHER;
+		hasSizeMatchPattern=sizeMatchPattern!=SIZE_ALL;
+		distdirec = profile.filterDist.charAt(0) == 'L' ? SMALLER : GREATER; 
+		fscDist = Common.parseDouble(profile.filterDist.substring(1));  // Distance
+		diffdirec = profile.filterDiff.charAt(0) == 'L' ? SMALLER : 
+					(profile.filterDiff.charAt(0) == '=' ? EQUAL : GREATER );
+		fscDiff = Common.parseDouble(profile.filterDiff.substring(1));  // Difficulty
+		terrdirec = profile.filterTerr.charAt(0) == 'L' ? SMALLER : 
+				(profile.filterTerr.charAt(0) == '=' ? EQUAL : GREATER );
+		fscTerr = Common.parseDouble(profile.filterTerr.substring(1));  // Terrain
+	}
+	
+	/**
 	*	Apply the filter. Caches that match a criteria are flagged
 	*	is_filtered = true. The table model is responsible for displaying or
 	*	not displaying a cache that is filtered.
 	*/
-	public void doFilter(Vector cacheDB, String dir){
+	public void doFilter(){
+		Vector cacheDB=Global.getProfile().cacheDB;
 		CacheHolder ch;
 		int cacheTypePattern;
 		int cacheRosePattern;
+		int cacheSizePattern;
 		// Values from filterscreen are parsed outside the main filter loop (fsc=FilterSCreen)
-		double fscDist=Common.parseDouble(dist);  // Distance
-		double fscTerr=Common.parseDouble(terr);  // Terrain
-		double fscDiff=Common.parseDouble(diff);  // Difficulty
 		double dummyd1;
 		//Loop db and match once against type pattern and once against rose pattern
 		//Default is_filtered = false, means will be displayed!
@@ -249,21 +329,28 @@
 			///////////////////////////////
 			// Filter criterium 1: Cache type
 			///////////////////////////////
-			cacheTypePattern = 0;
-			// As each cache can only have one type, we can use else if and set the type
-			if(ch.type.equals("2")) cacheTypePattern = TRADITIONAL;
-			else if(ch.type.equals("3")) cacheTypePattern = MULTI;
-			else if(ch.type.equals("4")) cacheTypePattern = VIRTUAL;
-			else if(ch.type.equals("5")) cacheTypePattern = LETTER;
-			else if(ch.type.equals("6")|| ch.type.equals("453")) cacheTypePattern = EVENT;
-			else if(ch.type.equals("8")) cacheTypePattern = MYSTERY;
-			else if(ch.type.equals("11")) cacheTypePattern = WEBCAM;
-			else if(ch.type.equals("12")) cacheTypePattern = LOCLESS;
-			else if(ch.type.equals("137"))cacheTypePattern = EARTH;
-			else if(ch.type.equals("453"))cacheTypePattern = MEGA;
-			if (CacheType.isAddiWpt(ch.type)) cacheTypePattern |= ADDIWPT;
-			if ((cacheTypePattern & typeMatchPattern) == 0) { ch.is_filtered=true; continue; }
-			
+			if (hasTypeMatchPattern) { // Only do the checks if we have a filter
+				cacheTypePattern = 0;
+				// As each cache can only have one type, we can use else if and set the type
+				if (ch.type.equals("0")) cacheTypePattern = CUSTOM;
+				else if(ch.type.equals("2")) cacheTypePattern = TRADITIONAL;
+				else if(ch.type.equals("3")) cacheTypePattern = MULTI;
+				else if(ch.type.equals("4")) cacheTypePattern = VIRTUAL;
+				else if(ch.type.equals("5")) cacheTypePattern = LETTER;
+				else if(ch.type.equals("6")) cacheTypePattern = EVENT;
+				else if(ch.type.equals("8")) cacheTypePattern = MYSTERY;
+				else if(ch.type.equals("11")) cacheTypePattern = WEBCAM;
+				else if(ch.type.equals("12")) cacheTypePattern = LOCLESS;
+				else if(ch.type.equals("137"))cacheTypePattern = EARTH;
+				else if(ch.type.equals("453"))cacheTypePattern = MEGA;
+				else if(ch.type.equals("50"))cacheTypePattern = PARKING;
+				else if(ch.type.equals("51"))cacheTypePattern = STAGE;
+				else if(ch.type.equals("52"))cacheTypePattern = QUESTION;
+				else if(ch.type.equals("53"))cacheTypePattern = FINAL;
+				else if(ch.type.equals("54"))cacheTypePattern = TRAILHEAD;
+				else if(ch.type.equals("55"))cacheTypePattern = REFERENCE;
+				if ((cacheTypePattern & typeMatchPattern) == 0) { ch.is_filtered=true; continue; }
+			}			
 			///////////////////////////////
 			// Filter criterium 2: Bearing from centre
 			///////////////////////////////
@@ -271,29 +358,30 @@
 			// By using else if we can reduce the number of comparisons from 16 to just over 8
 			// By first checking the first letter, we can reduce the average number further to
 			// just under 5
-			if (ch.bearing.startsWith("N")) {
-				if(ch.bearing.equals("NW")) cacheRosePattern = NW;
-				else if(ch.bearing.equals("NNW")) cacheRosePattern = NNW;
-				else if(ch.bearing.equals("N")) cacheRosePattern = N;
-				else if(ch.bearing.equals("NNE")) cacheRosePattern = NNE;
-				else cacheRosePattern = NE;
-			} else if (ch.bearing.startsWith("E")) {
-				if(ch.bearing.equals("ENE")) cacheRosePattern = ENE;
-				else if(ch.bearing.equals("E")) cacheRosePattern = E;
-				else cacheRosePattern = ESE;
-			} else if (ch.bearing.startsWith("S")) {
-				if(ch.bearing.equals("SW")) cacheRosePattern = SW;
-				else if(ch.bearing.equals("SSW")) cacheRosePattern = SSW;
-				else if(ch.bearing.equals("S")) cacheRosePattern = S;
-				else if(ch.bearing.equals("SSE")) cacheRosePattern = SSE;
-				else cacheRosePattern = SE;
-			} else {
-				if(ch.bearing.equals("WNW")) cacheRosePattern = WNW;
-				else if(ch.bearing.equals("W")) cacheRosePattern = W;
-				else cacheRosePattern = WSW;
-			}
-			if ((cacheRosePattern & roseMatchPattern) == 0) { ch.is_filtered=true; continue; }
-			
+			if (hasRoseMatchPattern) {
+				if (ch.bearing.startsWith("N")) {
+					if(ch.bearing.equals("NW")) cacheRosePattern = NW;
+					else if(ch.bearing.equals("NNW")) cacheRosePattern = NNW;
+					else if(ch.bearing.equals("N")) cacheRosePattern = N;
+					else if(ch.bearing.equals("NNE")) cacheRosePattern = NNE;
+					else cacheRosePattern = NE;
+				} else if (ch.bearing.startsWith("E")) {
+					if(ch.bearing.equals("ENE")) cacheRosePattern = ENE;
+					else if(ch.bearing.equals("E")) cacheRosePattern = E;
+					else cacheRosePattern = ESE;
+				} else if (ch.bearing.startsWith("S")) {
+					if(ch.bearing.equals("SW")) cacheRosePattern = SW;
+					else if(ch.bearing.equals("SSW")) cacheRosePattern = SSW;
+					else if(ch.bearing.equals("S")) cacheRosePattern = S;
+					else if(ch.bearing.equals("SSE")) cacheRosePattern = SSE;
+					else cacheRosePattern = SE;
+				} else {
+					if(ch.bearing.equals("WNW")) cacheRosePattern = WNW;
+					else if(ch.bearing.equals("W")) cacheRosePattern = W;
+					else cacheRosePattern = WSW;
+				}
+				if ((cacheRosePattern & roseMatchPattern) == 0) { ch.is_filtered=true; continue; }
+			}			
 			///////////////////////////////
 			// Filter criterium 3: Distance
 			///////////////////////////////
@@ -320,12 +408,16 @@
 				if(terrdirec == EQUAL && dummyd1 != fscTerr) { ch.is_filtered=true; continue; }
 				if(terrdirec == GREATER &&  dummyd1 < fscTerr) { ch.is_filtered=true; continue; }
 			}
+//Vm.debug(ch.wayPoint+" Found"+ch.is_found+"  FoundyMe="+foundByMe+"   notFoundByMe="+notFoundByMe);
+//Vm.debug(ch.wayPoint+" Owned"+ch.is_owned+"  OwnedByMe="+ownedByMe+"   notOwnedByMe="+notOwnedByMe);
+//Vm.debug(ch.wayPoint+" Archived"+ch.is_archived+"  Archived="+archived+"   notArchived="+notArchived);
+//Vm.debug(ch.wayPoint+" Available"+ch.is_available+"  Available="+available+"   notAvailable="+notAvailable);
+//Vm.debug("Blacklisted: "+ch.is_black);
 			///////////////////////////////
 			// Filter criterium 6: Found by me
 			///////////////////////////////
 			if((ch.is_found && !foundByMe) ||
 			   (!ch.is_found && !notFoundByMe)){ ch.is_filtered=true; continue; }
-
 			///////////////////////////////
 			// Filter criterium 7: Owned by me
 			///////////////////////////////
@@ -343,6 +435,19 @@
 			///////////////////////////////
 			if((ch.is_available && !available) ||
 			   (!ch.is_available && !notAvailable)) { ch.is_filtered=true; continue; }
+			///////////////////////////////
+			// Filter criterium 10: Size
+			///////////////////////////////
+			if (hasSizeMatchPattern) {
+				cacheSizePattern=0;
+				if (ch.CacheSize.startsWith("M")) cacheSizePattern = MICRO;
+				else if (ch.CacheSize.startsWith("S")) cacheSizePattern = SMALL;
+				else if (ch.CacheSize.startsWith("R")) cacheSizePattern = REGULAR;
+				else if (ch.CacheSize.startsWith("L")) cacheSizePattern = LARGE;
+				else if (ch.CacheSize.startsWith("V")) cacheSizePattern = VERYLARGE;
+				else cacheSizePattern = OTHER;
+				if ((cacheSizePattern & sizeMatchPattern) == 0) { ch.is_filtered=true; continue; }
+			}
 			
 		} // for
 	}
@@ -365,7 +470,7 @@
 		CacheHolder ch;
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
 			ch = (CacheHolder)cacheDB.get(i);
-			ch.is_filtered=ch.is_black; // Always filter blacklisted caches
+			ch.is_filtered=ch.is_black || CacheType.isAddiWpt(ch.type); // Always filter blacklisted caches
 		}
 		Profile prof=Global.getProfile();
 		prof.filterType = new String(Profile.FILTERTYPE);

Modified: trunk/src/CacheWolf/FilterScreen.java
===================================================================
--- trunk/src/CacheWolf/FilterScreen.java	2007-02-04 13:23:47 UTC (rev 504)
+++ trunk/src/CacheWolf/FilterScreen.java	2007-02-04 15:23:46 UTC (rev 505)
@@ -14,32 +14,67 @@
 public class FilterScreen extends Form{
 	private static final Color COLOR_FILTERINACTIVE=new Color(190,190,190);
 	private static final Color COLOR_FILTERACTIVE=new Color(0,255,0);
+	private static final Color COLOR_FILTERALL=new Color(255,0,0); // Red
     	
-	mButton btCancel, btApply,btRoute,btArea;
+	private mButton btnCancel, btnApply,btnRoute,
+					btnBearing,btnTypes,btnAttributes,btnRatings,btnContainer,btnSearch,btnAddi;
 	
-	mChoice distChc, difChc, terrChc, lastChc;
-	mCheckBox foundChk, notFoundChk, tradChk, virtualChk, eventChk, earthChk, megaChk;
-	mCheckBox ownedChk, notOwnedChk, multiChk, letterChk, webcamChk, mysteryChk,addiWptChk, loclessChk;
-	mInput distIn, lastIn, foundIn, terrIn, difIn;
-	Vector cacheDB;
-	mCheckBox archivedChk,notArchivedChk, availableChk,notAvailableChk;
-	mCheckBox NW, NNW , N , NNE, NE;
-	mCheckBox ENE, E, ESE, SE, SSE, S;
-	mCheckBox SSW, SW, WSW, W, WNW, chkDeselect,chkSelect;
-	String dir = new String();
+	private mChoice chcDist, chcDiff, chcTerr;
+	private mCheckBox chkFound, chkNotFound, chkTrad, chkVirtual, chkEvent, chkEarth, chkMega,
+					  chkOwned, chkNotOwned, chkMulti, chkLetter, chkWebcam, chkMystery, chkLocless,
+	                  chkCustom,chkParking,	chkStage, chkQuestion, chkFinal, chkTrailhead, chkReference,
+					  chkMicro,chkSmall,chkRegular,chkLarge,chkVeryLarge,chkOther,
+	                  chkArchived,chkNotArchived, chkAvailable,chkNotAvailable,
+					  chkNW, chkNNW , chkN , chkNNE, chkNE, chkENE, chkE, chkESE, chkSE, chkSSE, chkS,
+					  chkSSW, chkSW, chkWSW, chkW, chkWNW, chkDeselect,chkSelect;
 	
-	CellPanel content = new CellPanel();
-	CellPanel pnlBearDist=new CellPanel();
-	CellPanel pnlAttributes=new CellPanel();
-	CellPanel pnlRatings=new CellPanel();
-	CellPanel pnlCacheTypes=new CellPanel();
-	CellPanel pnlContainer=new CellPanel();
-	CellPanel pnlSearch=new CellPanel();
-	CellPanel roseP = new CellPanel();
-	CardPanel cp=new CardPanel();
-	CellPanel pnlButtons=new CellPanel();
-	mButton btnBearing,btnTypes,btnAttributes,btnRatings,btnContainer,btnSearch;
+	private mInput inpDist, inpTerr, inpDiff;
+	
+	private CellPanel pnlBearDist=new CellPanel();
+	private CellPanel pnlAttributes=new CellPanel();
+	private CellPanel pnlRatings=new CellPanel();
+	private CellPanel pnlCacheTypes=new CellPanel();
+	private CellPanel pnlContainer=new CellPanel();
+	private CellPanel pnlSearch=new CellPanel();
+	private CellPanel pnlRose = new CellPanel();
+	private CellPanel pnlButtons=new CellPanel();
+	private CellPanel pnlAddi=new CellPanel();
+	private CardPanel cp=new CardPanel();
 
+	// A subclassed checkbox with a "third" state (=grey background).
+	// If all addi wpts are false or all addi wpts are true, the background is white
+	// If the addi wpt filter is a mixture of true/false, the bg is grey
+	// Thus the addi filter can be set in one of two ways: Using the single checkbox with all the other
+	// attributes, or using the multiple checkboxes for each addi waypoint type
+	private class myChkBox extends mCheckBox {
+		Color bgColor=Color.White;
+		myChkBox(String s) {super(s); }
+		public void doPaintSquare(Graphics g) {
+			int h = height;
+			g.setColor(bgColor);
+			int bx = text.length() == 0 ? 0 : 2;
+			int by = text.length() == 0 ? 0 : (h-boxWidth)/2+1;
+			g.fillRect(bx+2,by+2,boxWidth-4,boxWidth-4);
+			if (state || pressState){
+				Color c = Color.LightGray;
+				if (!pressState){
+					if (!state) 
+						c=bgColor;
+					else 
+						c=Color.Black;
+				}
+				Pen oldpen = g.setPen(new Pen(c,Pen.SOLID,2));
+				g.drawLine(bx+4,by+boxWidth-5,bx+boxWidth-5,by+4);
+				g.drawLine(bx+4,by+boxWidth-5,bx+4,by+boxWidth-10);
+//				g.drawLine(bx+3,by+3,bx+boxWidth-5,by+boxWidth-5);
+//				g.drawLine(bx+3,by+boxWidth-5,bx+boxWidth-5,by+3);
+				g.setPen(oldpen);
+			}
+			g.draw3DRect(new Rect(bx,by,boxWidth,boxWidth),	ButtonObject.checkboxEdge,true,null,Color.DarkGray);
+		}		
+	}
+	private myChkBox addiWptChk;
+	
 	private mButton addImg(String imgName) {
 		mButton mb=new mButton(new mImage(imgName)); mb.borderWidth=0; mb.modify(NotEditable|PreferredSizeOnly,0);
 		return mb;
@@ -50,7 +85,6 @@
 		lblTitle.backGround=new Color(127,127,127); 
 		lblTitle.foreGround=Color.White; 
 		lblTitle.setTag(INSETS,new Insets(2,0,4,0));
-		
 	}
 	
 	public FilterScreen() {
@@ -61,32 +95,32 @@
 		//////////////////////////
 		addTitle(pnlBearDist,MyLocale.getMsg(714,"Bearings & Distance"));
 		pnlBearDist.addNext(new mLabel(MyLocale.getMsg(701,"Distance: ")),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		pnlBearDist.addNext(distChc = new mChoice(new String[]{"<=", ">="},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		pnlBearDist.addLast(distIn = new mInput(),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlBearDist.addNext(chcDist = new mChoice(new String[]{"<=", ">="},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlBearDist.addLast(inpDist = new mInput(),CellConstants.DONTSTRETCH, CellConstants.FILL);
 		pnlBearDist.addLast(new mLabel(""));
-		roseP.addNext(NW = new mCheckBox("NW"),CellConstants.HSTRETCH, CellConstants.FILL);
-		roseP.addNext(NNW = new mCheckBox("NNW"),CellConstants.HSTRETCH, CellConstants.FILL);
-		roseP.addNext(N = new mCheckBox("N"),CellConstants.HSTRETCH, CellConstants.FILL);
-		roseP.addLast(NNE = new mCheckBox("NNE"),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkNW = new mCheckBox("NW"),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkNNW = new mCheckBox("NNW"),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkN = new mCheckBox("N"),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addLast(chkNNE = new mCheckBox("NNE"),CellConstants.HSTRETCH, CellConstants.FILL);
 		
-		roseP.addNext(NE = new mCheckBox("NE"),CellConstants.HSTRETCH, CellConstants.FILL);
-		roseP.addNext(ENE = new mCheckBox("ENE"),CellConstants.HSTRETCH, CellConstants.FILL);
-		roseP.addNext(E = new mCheckBox("E "),CellConstants.HSTRETCH, CellConstants.FILL);
-		roseP.addLast(ESE = new mCheckBox("ESE"),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkNE = new mCheckBox("NE"),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkENE = new mCheckBox("ENE"),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkE = new mCheckBox("E "),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addLast(chkESE = new mCheckBox("ESE"),CellConstants.HSTRETCH, CellConstants.FILL);
 
-		roseP.addNext(SE = new mCheckBox("SE"),CellConstants.HSTRETCH, CellConstants.FILL);
-		roseP.addNext(SSE = new mCheckBox("SSE"),CellConstants.HSTRETCH, CellConstants.FILL);
-		roseP.addNext(S = new mCheckBox("S"),CellConstants.HSTRETCH, CellConstants.FILL);
-		roseP.addLast(SSW = new mCheckBox("SSW"),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkSE = new mCheckBox("SE"),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkSSE = new mCheckBox("SSE"),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkS = new mCheckBox("S"),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addLast(chkSSW = new mCheckBox("SSW"),CellConstants.HSTRETCH, CellConstants.FILL);
 
-		roseP.addNext(SW = new mCheckBox("SW"),CellConstants.HSTRETCH, CellConstants.FILL);
-		roseP.addNext(WSW = new mCheckBox("WSW"),CellConstants.HSTRETCH, CellConstants.FILL);
-		roseP.addNext(W = new mCheckBox("W "),CellConstants.HSTRETCH, CellConstants.FILL);
-		roseP.addLast(WNW = new mCheckBox("WNW"),CellConstants.HSTRETCH, CellConstants.FILL);
-		roseP.addNext(chkDeselect=new mCheckBox(MyLocale.getMsg(716,"Deselect all")));
+		pnlRose.addNext(chkSW = new mCheckBox("SW"),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkWSW = new mCheckBox("WSW"),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkW = new mCheckBox("W "),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addLast(chkWNW = new mCheckBox("WNW"),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkDeselect=new mCheckBox(MyLocale.getMsg(716,"Deselect all")));
 		chkDeselect.setTag(SPAN,new Dimension(2,1));
-		roseP.addLast(chkSelect=new mCheckBox(MyLocale.getMsg(717,"Select all")));
-		pnlBearDist.addLast(roseP, CellConstants.STRETCH,CellConstants.FILL);
+		pnlRose.addLast(chkSelect=new mCheckBox(MyLocale.getMsg(717,"Select all")));
+		pnlBearDist.addLast(pnlRose, CellConstants.STRETCH,CellConstants.FILL);
 		
 		//////////////////////////
 		// Panel 2 - Cache attributes
@@ -95,31 +129,31 @@
 		mLabel lblTitleAtt; 
 		pnlAttributes.addLast(lblTitleAtt=new mLabel(MyLocale.getMsg(715,"Show all caches with status:")),HSTRETCH,FILL);
 		lblTitleAtt.setTag(SPAN,new Dimension(2,1));
-		pnlAttributes.addNext(archivedChk = new mCheckBox(MyLocale.getMsg(710,"Archived")), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		pnlAttributes.addLast(notArchivedChk = new mCheckBox("Nicht archiviert"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addNext(chkArchived = new mCheckBox(MyLocale.getMsg(710,"Archived")), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addLast(chkNotArchived = new mCheckBox("Nicht archiviert"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
-		pnlAttributes.addNext(availableChk = new mCheckBox("Suchbar"), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		pnlAttributes.addLast(notAvailableChk = new mCheckBox(MyLocale.getMsg(711,"Not available")), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addNext(chkAvailable = new mCheckBox("Suchbar"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addLast(chkNotAvailable = new mCheckBox(MyLocale.getMsg(711,"Not available")), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
-		pnlAttributes.addNext(foundChk = new mCheckBox(MyLocale.getMsg(703,"Found")), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		pnlAttributes.addLast(notFoundChk = new mCheckBox("Noch nicht gefunden"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addNext(chkFound = new mCheckBox(MyLocale.getMsg(703,"Found")), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addLast(chkNotFound = new mCheckBox("Noch nicht gefunden"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
-		pnlAttributes.addNext(ownedChk = new mCheckBox(MyLocale.getMsg(707,"Owned")), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		pnlAttributes.addLast(notOwnedChk = new mCheckBox("Anderer Besitzer"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addNext(chkOwned = new mCheckBox(MyLocale.getMsg(707,"Owned")), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addLast(chkNotOwned = new mCheckBox("Anderer Besitzer"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 
 		//////////////////////////
 		// Panel 3 - Cache ratings
 		//////////////////////////
 		addTitle(pnlRatings,MyLocale.getMsg(718,"Cache ratings"));
 		pnlRatings.addNext(new mLabel(MyLocale.getMsg(702,"Difficulty: ")),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		pnlRatings.addNext(difChc = new mChoice(new String[]{"<=","=", ">="},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlRatings.addNext(chcDiff = new mChoice(new String[]{"<=","=", ">="},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		//pnlRatings.addLast(difIn = new mChoice(new String[]{"1.0", "1.5", "2.0", "2.5", "3.0", "3.5", "4.0", "4.5", "5.0"},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		pnlRatings.addLast(difIn = new mInput(),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlRatings.addLast(inpDiff = new mInput(),CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
 		pnlRatings.addNext(new mLabel("Terrain: "),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		pnlRatings.addNext(terrChc = new mChoice(new String[]{"<=", "=", ">="},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlRatings.addNext(chcTerr = new mChoice(new String[]{"<=", "=", ">="},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		//pnlRatings.addLast(terrIn = new mChoice(new String[]{"1.0", "1.5", "2.0", "2.5", "3.0", "3.5", "4.0", "4.5", "5.0"},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		pnlRatings.addLast(terrIn = new mInput(),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlRatings.addLast(inpTerr = new mInput(),CellConstants.DONTSTRETCH, CellConstants.FILL);
 
 		//////////////////////////
 		// Panel 4 - Cache types
@@ -127,61 +161,79 @@
 		
 		addTitle(pnlCacheTypes,MyLocale.getMsg(719,"Cache types"));
 		pnlCacheTypes.addNext(addImg("2.png"));
-		pnlCacheTypes.addNext(tradChk = new mCheckBox("Traditonal"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlCacheTypes.addNext(chkTrad = new mCheckBox("Traditonal"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
 		pnlCacheTypes.addNext(addImg("3.png"));
-		pnlCacheTypes.addLast(multiChk = new mCheckBox("Multi"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlCacheTypes.addLast(chkMulti = new mCheckBox("Multi"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
 		pnlCacheTypes.addNext(addImg("4.png"));
-		pnlCacheTypes.addNext(virtualChk = new mCheckBox("Virtual"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlCacheTypes.addNext(chkVirtual = new mCheckBox("Virtual"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
 		pnlCacheTypes.addNext(addImg("5.png"));
-		pnlCacheTypes.addLast(letterChk = new mCheckBox("Letterbox"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlCacheTypes.addLast(chkLetter = new mCheckBox("Letterbox"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
 		pnlCacheTypes.addNext(addImg("6.png"));
-		pnlCacheTypes.addNext(eventChk = new mCheckBox("Event"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlCacheTypes.addNext(chkEvent = new mCheckBox("Event"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
 		pnlCacheTypes.addNext(addImg("11.png"));
-		pnlCacheTypes.addLast(webcamChk = new mCheckBox("Webcam"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlCacheTypes.addLast(chkWebcam = new mCheckBox("Webcam"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
 		pnlCacheTypes.addNext(addImg("8.png"));
-		pnlCacheTypes.addNext(mysteryChk = new mCheckBox("Mystery"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlCacheTypes.addNext(chkMystery = new mCheckBox("Mystery"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
 		pnlCacheTypes.addNext(addImg("137.png"));
-		pnlCacheTypes.addLast(earthChk = new mCheckBox("Earth"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlCacheTypes.addLast(chkEarth = new mCheckBox("Earth"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
 		pnlCacheTypes.addNext(addImg("12.png"));
-		pnlCacheTypes.addNext(loclessChk = new mCheckBox("Locationless"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlCacheTypes.addNext(chkLocless = new mCheckBox("Locationless"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
 		pnlCacheTypes.addNext(addImg("453.png"));
-		pnlCacheTypes.addLast(megaChk = new mCheckBox("Mega-Ev."), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlCacheTypes.addLast(chkMega = new mCheckBox("Mega-Ev."), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
+		//pnlCacheTypes.addLast(addiWptChk = new mCheckBox("Add. Wpt"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		//pnlCacheTypes.addLast(new mLabel(""));
+		pnlCacheTypes.addNext(addImg("0.png"));
+		pnlCacheTypes.addNext(chkCustom = new mCheckBox("Custom"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
 		pnlCacheTypes.addNext(addImg("110.png"));
-		pnlCacheTypes.addLast(addiWptChk = new mCheckBox("Add. Wpt"), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		pnlCacheTypes.addLast(new mLabel(""));
+		pnlCacheTypes.addLast(addiWptChk = new myChkBox("Add. Wpt"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 
+		//addiWptChk.modify(0,NotAnEditor);
 		//////////////////////////
-		// Panel 5 - Cache container
+		// Panel 5 - Addi waypoints
 		//////////////////////////
-		addTitle(pnlContainer,MyLocale.getMsg(720,"Cache container"));
-		pnlContainer.addLast(new mLabel("To be implemented"));
+		addTitle(pnlAddi,MyLocale.getMsg(726,"Additional waypoints"));
+		pnlAddi.addNext(addImg("pkg.png"));
+		pnlAddi.addNext(chkParking = new mCheckBox("Parking"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAddi.addNext(addImg("stage.png"));
+		pnlAddi.addLast(chkStage = new mCheckBox("Stage"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAddi.addNext(addImg("puzzle.png"));
+		pnlAddi.addNext(chkQuestion = new mCheckBox("Question"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAddi.addNext(addImg("flag.png"));
+		pnlAddi.addLast(chkFinal = new mCheckBox("Final"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAddi.addNext(addImg("trailhead.png"));
+		pnlAddi.addNext(chkTrailhead = new mCheckBox("Trailhead"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAddi.addNext(addImg("waypoint.png"));
+		pnlAddi.addLast(chkReference = new mCheckBox("Reference"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+        pnlAddi.addLast(new mLabel(""),VSTRETCH,FILL);		
+
+		//////////////////////////
+		// Panel 6 - Cache container
+		//////////////////////////
+		addTitle(pnlContainer,MyLocale.getMsg(727,"Cache container"));
+		pnlContainer.addLast(chkMicro=new mCheckBox("Micro"));
+		pnlContainer.addLast(chkSmall=new mCheckBox("Small"));
+		pnlContainer.addLast(chkRegular=new mCheckBox("Regular"));
+		pnlContainer.addLast(chkLarge=new mCheckBox("Large"));
+		pnlContainer.addLast(chkVeryLarge=new mCheckBox("Very Large"));
+		pnlContainer.addLast(chkOther=new mCheckBox("Other"));
 		
 		//////////////////////////
-		// Panel 6 - Search
+		// Panel 7 - Search
 		//////////////////////////
 		addTitle(pnlSearch,"Search");
 		pnlSearch.addLast(new mLabel("To be implemented"));
 		
-		lastChc = new mChoice(new String[]{MyLocale.getMsg(703,"Found"), MyLocale.getMsg(704,"Not found")},0);
-		lastIn = new mInput();
-		foundIn = new mInput();
-/*		content.addNext(lastChc,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		content.addNext(new mLabel(MyLocale.getMsg(705," last ")),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		content.addLast(lastIn,CellConstants.DONTSTRETCH, CellConstants.FILL);
-		
-		content.addNext(new mLabel(MyLocale.getMsg(706,"Found by: ")),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		content.addLast(foundIn,CellConstants.DONTSTRETCH, CellConstants.FILL);
-*/		
 		Frame frmScreen=new Frame();
 		mLabel lblInfo; 
 		frmScreen.addLast(lblInfo=new mLabel(MyLocale.getMsg(725,"Note: Filters are additive, active filter=green"))).setTag(SPAN,new Dimension(2,1));
@@ -195,7 +247,8 @@
 		pnlButtons.addLast(btnAttributes=new mButton(MyLocale.getMsg(720,"Attributes")));
 		pnlButtons.addLast(btnRatings=new mButton(MyLocale.getMsg(722,"Ratings")));
 		pnlButtons.addLast(btnTypes=new mButton(MyLocale.getMsg(723,"Types"))); 
-		pnlButtons.addLast(btnContainer=new mButton(MyLocale.getMsg(724,"Container"))); btnContainer.modify(Disabled,0);
+		pnlButtons.addLast(btnAddi=new mButton("Addi Wpt")); 
+		pnlButtons.addLast(btnContainer=new mButton(MyLocale.getMsg(724,"Container")));
 		pnlButtons.addLast(btnSearch=new mButton("Search")); btnSearch.modify(Disabled,0);
 		addNext(pnlButtons,HSTRETCH,FILL);
 
@@ -203,108 +256,99 @@
 		cp.addItem(pnlAttributes,"Att",null);
 		cp.addItem(pnlRatings,"DT",null); 
 		cp.addItem(pnlCacheTypes,"Type",null);
+		cp.addItem(pnlAddi,"Addi",null);
 		cp.addItem(pnlContainer,"Size",null);
 		cp.addItem(pnlSearch,"Search",null);
 		addLast(cp);
 
 		CellPanel btPanel = new CellPanel();
-		btPanel.addNext(btCancel = new mButton(MyLocale.getMsg(708,"Cancel")),CellConstants.STRETCH, CellConstants.FILL);
-		btPanel.addNext(btApply = new mButton(MyLocale.getMsg(709,"Apply")),CellConstants.STRETCH, CellConstants.FILL);
-		btPanel.addLast(btRoute = new mButton("Route"),CellConstants.STRETCH, CellConstants.FILL);
+		btPanel.addNext(btnCancel = new mButton(MyLocale.getMsg(708,"Cancel")),CellConstants.STRETCH, CellConstants.FILL);
+		btPanel.addNext(btnApply = new mButton(MyLocale.getMsg(709,"Apply")),CellConstants.STRETCH, CellConstants.FILL);
+		btPanel.addLast(btnRoute = new mButton("Route"),CellConstants.STRETCH, CellConstants.FILL);
 		addLast(btPanel.setTag(Control.SPAN, new Dimension(3,1)), CellConstants.STRETCH, CellConstants.FILL);
 		setPreferredSize(240,240);
 		
 	}
 	
 	
-	public void setData(Vector DB, String d){
-		dir = d;
-		cacheDB = DB;
+	public void setData(){
 		Profile prof=Global.getProfile();
 
 		//////////////////////////
 		// Panel 1 - Bearing & Distance
 		//////////////////////////
 		if (prof.filterDist.length()>1) {
-			if (prof.filterDist.charAt(0)=='<')
-				distChc.select(0);
+			if (prof.filterDist.charAt(0)=='L')
+				chcDist.select(0);
 			else
-				distChc.select(1);
-			distIn.setText(prof.filterDist.substring(1));
+				chcDist.select(1);
+			inpDist.setText(prof.filterDist.substring(1));
 		} else {
-			distChc.select(0);
-			distIn.setText("");
+			chcDist.select(0);
+			inpDist.setText("");
 		}
 		// If filter has been corrupted, pad it to 11 characters
 		String fltRose=prof.filterRose;
-		if (fltRose.length()<16) { 
-			fltRose=(fltRose+"1111111111111111").substring(0,16); 
-			prof.filterRose=fltRose; 
-		}  
-		NW.state   = fltRose.charAt(0) == '1';
-		NNW.state  = fltRose.charAt(1) == '1';
-		N.state    = fltRose.charAt(2) == '1';
-		NNE.state  = fltRose.charAt(3) == '1';
+		chkNW.state   = fltRose.charAt(0) == '1';
+		chkNNW.state  = fltRose.charAt(1) == '1';
+		chkN.state    = fltRose.charAt(2) == '1';
+		chkNNE.state  = fltRose.charAt(3) == '1';
 		
-		NE.state   = fltRose.charAt(4) == '1';
-		ENE.state  = fltRose.charAt(5) == '1';
-		E.state    = fltRose.charAt(6) == '1';
-		ESE.state  = fltRose.charAt(7) == '1';
+		chkNE.state   = fltRose.charAt(4) == '1';
+		chkENE.state  = fltRose.charAt(5) == '1';
+		chkE.state    = fltRose.charAt(6) == '1';
+		chkESE.state  = fltRose.charAt(7) == '1';
 
-		SE.state   = fltRose.charAt(8) == '1';
-		SSE.state  = fltRose.charAt(9) == '1';
-		S.state    = fltRose.charAt(10) == '1';
-		SSW.state  = fltRose.charAt(11) == '1';
+		chkSE.state   = fltRose.charAt(8) == '1';
+		chkSSE.state  = fltRose.charAt(9) == '1';
+		chkS.state    = fltRose.charAt(10) == '1';
+		chkSSW.state  = fltRose.charAt(11) == '1';
 
-		SW.state   = fltRose.charAt(12) == '1';
-		WSW.state  = fltRose.charAt(13) == '1';
-		W.state    = fltRose.charAt(14) == '1';
-		WNW.state  = fltRose.charAt(15) == '1';
+		chkSW.state   = fltRose.charAt(12) == '1';
+		chkWSW.state  = fltRose.charAt(13) == '1';
+		chkW.state    = fltRose.charAt(14) == '1';
+		chkWNW.state  = fltRose.charAt(15) == '1';
 		
 		//////////////////////////
 		// Panel 2 - Cache attributes
 		//////////////////////////
 		String fltVar=prof.filterVar;
-		if (fltVar.length()<8) { 
-			fltVar=(fltVar+"11111111").substring(0,8); 
-			prof.filterVar=fltVar; 
-		}  
-		archivedChk.state      = fltVar.charAt(0) == '1';
-		availableChk.state     = fltVar.charAt(1) == '1';
-		foundChk.state         = fltVar.charAt(2) == '1';
-		ownedChk.state         = fltVar.charAt(3) == '1';
-		notArchivedChk.state   = fltVar.charAt(4) == '1';
-		notAvailableChk.state  = fltVar.charAt(5) == '1';
-		notFoundChk.state      = fltVar.charAt(6) == '1';
-		notOwnedChk.state      = fltVar.charAt(7) == '1';
+		chkArchived.state      = fltVar.charAt(0) == '1';
+		chkAvailable.state     = fltVar.charAt(1) == '1';
+		chkFound.state         = fltVar.charAt(2) == '1';
+		chkOwned.state         = fltVar.charAt(3) == '1';
+		chkNotArchived.state   = fltVar.charAt(4) == '1';
+		chkNotAvailable.state  = fltVar.charAt(5) == '1';
+		chkNotFound.state      = fltVar.charAt(6) == '1';
+		chkNotOwned.state      = fltVar.charAt(7) == '1';
 
 		//////////////////////////
 		// Panel 3 - Cache ratings
 		//////////////////////////
 		if (prof.filterDiff.length()>1) {
-			if (prof.filterDiff.charAt(0)=='<')
-				difChc.select(0);
+			if (prof.filterDiff.charAt(0)=='L')
+				chcDiff.select(0);
 			else if (prof.filterDiff.charAt(0)=='=')
-				difChc.select(1);
+				chcDiff.select(1);
 			else
-				difChc.select(2);
-			difIn.setText(prof.filterDiff.substring(1));
+				chcDiff.select(2);
+			inpDiff.setText(prof.filterDiff.substring(1));
 		} else {
-			difChc.select(0);
-			difIn.setText("");
+			chcDiff.select(0);
+			inpDiff.setText("");
 		}
 
 		if (prof.filterTerr.length()>1) {
-			if (prof.filterTerr.charAt(0)=='<')
-				terrChc.select(0);
+			if (prof.filterTerr.charAt(0)=='L')
+				chcTerr.select(0);
 			else if (prof.filterTerr.charAt(0)=='=')
-				terrChc.select(1);
+				chcTerr.select(1);
 			else
-				terrChc.select(2);
-			terrIn.setText(prof.filterTerr.substring(1));
+				chcTerr.select(2);
+			inpTerr.setText(prof.filterTerr.substring(1));
 		} else {
-			terrChc.select(0);
-			terrIn.setText("");
+			chcTerr.select(0);
+			inpTerr.setText("");
 		}
 
 
@@ -312,30 +356,44 @@
 		// Panel 4 - Cache types
 		//////////////////////////
 		
-		// If filter has been corrupted, pad it to 11 characters
 		String fltType=prof.filterType;
-		if (fltType.length()<11) { 
-			fltType=(fltType+"11111111111").substring(0,11); 
-			prof.filterType=fltType; 
-		}  
-		tradChk.state    = fltType.charAt(0) == '1';
-		multiChk.state   = fltType.charAt(1) == '1';
-		virtualChk.state = fltType.charAt(2) == '1';
-		letterChk.state  = fltType.charAt(3) == '1';
-		eventChk.state   = fltType.charAt(4) == '1';
-		webcamChk.state  = fltType.charAt(5) == '1';
-		mysteryChk.state = fltType.charAt(6) == '1';
-		earthChk.state   = fltType.charAt(7) == '1';
-		loclessChk.state = fltType.charAt(8) == '1';
-		megaChk.state    = fltType.charAt(9) == '1';
-		addiWptChk.state = fltType.charAt(10) == '1';
+		chkTrad.state       = fltType.charAt(0) == '1';
+		chkMulti.state      = fltType.charAt(1) == '1';
+		chkVirtual.state    = fltType.charAt(2) == '1';
+		chkLetter.state     = fltType.charAt(3) == '1';
+		chkEvent.state      = fltType.charAt(4) == '1';
+		chkWebcam.state     = fltType.charAt(5) == '1';
+		chkMystery.state    = fltType.charAt(6) == '1';
+		chkEarth.state      = fltType.charAt(7) == '1';
+		chkLocless.state    = fltType.charAt(8) == '1';
+		chkMega.state       = fltType.charAt(9) == '1';
+		chkCustom.state     = fltType.charAt(10) == '1';
+		// Note addiWptState is set by setColors
+		
+		//////////////////////////
+		// Panel 5 - Additional waypoints
+		//////////////////////////
+		chkParking.state    = fltType.charAt(11) == '1';	
+		chkStage.state      = fltType.charAt(12) == '1'; 
+		chkQuestion.state   = fltType.charAt(13) == '1'; 
+		chkFinal.state      = fltType.charAt(14) == '1'; 
+		chkTrailhead.state  = fltType.charAt(15) == '1'; 
+		chkReference.state  = fltType.charAt(16) == '1';
+		addiWptChk.state= !fltType.substring(11,17).equals("000000");
 
 		//////////////////////////
-		// Panel 5 - Cache container
+		// Panel 6 - Cache container
 		//////////////////////////
+		String fltSize=prof.filterSize;
+		chkMicro.state      = fltSize.charAt(0) == '1';
+		chkSmall.state      = fltSize.charAt(1) == '1';
+		chkRegular.state    = fltSize.charAt(2) == '1';
+		chkLarge.state      = fltSize.charAt(3) == '1';
+		chkVeryLarge.state  = fltSize.charAt(4) == '1';
+		chkOther.state      = fltSize.charAt(5) == '1';
 		
 		//////////////////////////
-		// Panel 6 - Search
+		// Panel 7 - Search
 		//////////////////////////
 		
 		// Adjust colors of buttons depending on which filters are active
@@ -345,43 +403,94 @@
 	// Set the colors of the filter buttons according to which filters are active
 	private void setColors() {
 		// Panel 1 - Bearing & Distance
-		if (distIn.getText().length()>0 || 
-			  !(NW.getState() && NNW.getState() && N.getState() && NNE.getState() &&
-				NE.getState() && ENE.getState() && E.getState() && ESE.getState() &&
-				SE.getState() && SSE.getState() && S.getState() && SSW.getState() &&
-				SW.getState() && WSW.getState() && W.getState() && WNW.getState()))
+		if (inpDist.getText().length()>0 || 
+			  !(chkNW.state && chkNNW.state && chkN.state && chkNNE.state &&
+				chkNE.state && chkENE.state && chkE.state && chkESE.state &&
+				chkSE.state && chkSSE.state && chkS.state && chkSSW.state &&
+				chkSW.state && chkWSW.state && chkW.state && chkWNW.state))
 			btnBearing.backGround=COLOR_FILTERACTIVE;
 		else
 			btnBearing.backGround=COLOR_FILTERINACTIVE;
+		if (  !(chkNW.state || chkNNW.state || chkN.state || chkNNE.state ||
+				chkNE.state || chkENE.state || chkE.state || chkESE.state ||
+				chkSE.state || chkSSE.state || chkS.state || chkSSW.state ||
+				chkSW.state || chkWSW.state || chkW.state || chkWNW.state))
+			btnBearing.backGround=COLOR_FILTERALL;
 		btnBearing.repaint();
 		
 		// Panel 2 - Cache attributes
-		if (!( archivedChk.getState()    && availableChk.getState()    && foundChk.getState()    && ownedChk.getState() &&
-			   notArchivedChk.getState() && notAvailableChk.getState() && notFoundChk.getState() && notOwnedChk.getState()))
+		if (!( chkArchived.state    && chkAvailable.state    && chkFound.state    && chkOwned.state &&
+			   chkNotArchived.state && chkNotAvailable.state && chkNotFound.state && chkNotOwned.state))
 			btnAttributes.backGround=COLOR_FILTERACTIVE;
 		else
 			btnAttributes.backGround=COLOR_FILTERINACTIVE;
+		if ((chkArchived.state==false && chkNotArchived.state==false) || 
+			    (chkAvailable.state==false && chkNotAvailable.state==false) ||
+			    (chkFound.state==false && chkNotFound.state==false) ||
+			    (chkOwned.state==false && chkNotOwned.state==false)) 
+			btnAttributes.backGround=COLOR_FILTERALL;
 		btnAttributes.repaint();
 		
 		// Panel 3 - Cache ratings
-		if (difIn.getText().length()>0 || terrIn.getText().length()>0)
+		if (inpDiff.getText().length()>0 || inpTerr.getText().length()>0)
 			btnRatings.backGround=COLOR_FILTERACTIVE;
 		else
 			btnRatings.backGround=COLOR_FILTERINACTIVE;
 		btnRatings.repaint();
 
+		// Panel 5 - Addi Waypoints
+		if (chkParking.state || chkStage.state || chkQuestion.state || 
+			chkFinal.state || chkTrailhead.state || chkReference.state )
+			btnAddi.backGround=COLOR_FILTERACTIVE;
+		else
+			btnAddi.backGround=COLOR_FILTERINACTIVE;
+		btnAddi.repaint();
+
 		// Panel 4 - Cache types
-		if (!(tradChk.getState() && multiChk.getState() && 	virtualChk.getState() && letterChk.getState() &&
-		      eventChk.getState() && webcamChk.getState() && mysteryChk.getState() && earthChk.getState() &&
-		      loclessChk.getState() && megaChk.getState() && !addiWptChk.getState())) 
+		if (!(chkTrad.state && chkMulti.state && 	chkVirtual.state && chkLetter.state &&
+		      chkEvent.state && chkWebcam.state && chkMystery.state && chkEarth.state &&
+		      chkLocless.state && chkMega.state && chkCustom.state) ) 
 			btnTypes.backGround=COLOR_FILTERACTIVE;
 		else
 			btnTypes.backGround=COLOR_FILTERINACTIVE;
+		if (!(chkTrad.state || chkMulti.state || 	chkVirtual.state || chkLetter.state ||
+			      chkEvent.state || chkWebcam.state || chkMystery.state || chkEarth.state ||
+			      chkLocless.state || chkMega.state || chkCustom.state || chkParking.state 
+			      || chkStage.state || chkQuestion.state || 
+					chkFinal.state || chkTrailhead.state || chkReference.state )) 
+			btnTypes.backGround=COLOR_FILTERALL;
 		btnTypes.repaint();
 
-		// Panel 5 - Cache container
-
-		// Panel 6 - Search
+		// Panel 5 - Addi Waypoints
+		if (chkParking.state || chkStage.state || chkQuestion.state || 
+			chkFinal.state || chkTrailhead.state || chkReference.state ) { // At least one tick
+			btnAddi.backGround=COLOR_FILTERACTIVE;
+			addiWptChk.state=true;
+			if (chkParking.state && chkStage.state &&  chkQuestion.state && 
+				chkFinal.state && chkTrailhead.state && chkReference.state ) { // All ticked?
+				addiWptChk.bgColor=Color.White;
+			} else {	
+				addiWptChk.bgColor=Color.LightGray;
+			}
+		} else { // All not ticked
+			btnAddi.backGround=COLOR_FILTERINACTIVE;
+			addiWptChk.bgColor=Color.White;
+			addiWptChk.state=false;
+		}
+		btnAddi.repaint();
+			
+		// Panel 6 - Cache container
+		if (!(chkMicro.state && chkSmall.state && chkRegular.state && 
+			  chkLarge.state && chkVeryLarge.state && chkOther.state))
+			  btnContainer.backGround=COLOR_FILTERACTIVE;
+		else
+			  btnContainer.backGround=COLOR_FILTERINACTIVE;
+		if (!(chkMicro.state || chkSmall.state || chkRegular.state || 
+				  chkLarge.state || chkVeryLarge.state || chkOther.state))
+			  btnContainer.backGround=COLOR_FILTERALL;
+		btnContainer.repaint();
+			
+		// Panel 7 - Search
 		
 	}
 	
@@ -391,13 +500,13 @@
 	*/
 	public void onEvent(Event ev){
 		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if (ev.target == btCancel){
+			if (ev.target == btnCancel){
 				this.close(0);
 			}
-			else if (ev.target == btRoute){
+			else if (ev.target == btnRoute){
 				
 				File datei;
-				FileChooser fc = new FileChooser(FileChooser.OPEN, dir);
+				FileChooser fc = new FileChooser(FileChooser.OPEN, Global.getProfile().dataDir);
 				fc.setTitle(MyLocale.getMsg(712,"Select route file"));
 				if(fc.execute() != FormBase.IDCANCEL) {
 					datei = fc.getChosenFile();
@@ -405,178 +514,141 @@
 					inf.execute();
 					Vm.showWait(true);
 					Filter flt = new Filter();
-					flt.routeFile = datei;
-					flt.doFilterRoute(cacheDB, dir, Convert.toDouble(inf.feedback.getText()));
+					flt.doFilterRoute(datei, Convert.toDouble(inf.feedback.getText()));
 				}
 				Vm.showWait(false);
 				this.close(0);
 				
 			}
-			else if (ev.target == btApply){
+			else if (ev.target == btnApply){
 				Vm.showWait(true);
 				//Save filter required
-				Filter flt = new Filter();
-				flt.foundByMe = foundChk.getState();
-				flt.notFoundByMe = notFoundChk.getState();
-				flt.ownedByMe = ownedChk.getState();
-				flt.notOwnedByMe = notOwnedChk.getState();
+				Profile pfl = Global.getProfile();
+				pfl.filterVar = (chkArchived.state    ? "1" : "0") +
+							(chkAvailable.state   ? "1" : "0") +
+							(chkFound.state       ? "1" : "0") +
+							(chkOwned.state       ? "1" : "0") +
+							(chkNotArchived.state ? "1" : "0") +
+							(chkNotAvailable.state? "1" : "0") +
+							(chkNotFound.state    ? "1" : "0") +
+							(chkNotOwned.state    ? "1" : "0");							
+				pfl.filterType =(chkTrad.state    ? "1" : "0") +
+								(chkMulti.state   ? "1" : "0") +
+								(chkVirtual.state ? "1" : "0") +
+								(chkLetter.state  ? "1" : "0") +
+								(chkEvent.state   ? "1" : "0") + 
+								(chkWebcam.state  ? "1" : "0") +
+								(chkMystery.state ? "1" : "0") +
+								(chkEarth.state   ? "1" : "0") +
+								(chkLocless.state ? "1" : "0") +
+								(chkMega.state    ? "1" : "0") +
+								(chkCustom.state  ? "1" : "0") +
+								(chkParking.state ? "1" : "0") +
+								(chkStage.state   ? "1" : "0") +
+								(chkQuestion.state? "1" : "0") +
+								(chkFinal.state   ? "1" : "0") +
+								(chkTrailhead.state ? "1" : "0") +
+								(chkReference.state ? "1" : "0");
 				
-				flt.dist = distIn.getText();
-				flt.diff = difIn.getText();
-				flt.terr = terrIn.getText();
-				flt.days = lastIn.getText();
-				flt.by = foundIn.getText();
-				flt.available = availableChk.getState();
-				flt.notAvailable = notAvailableChk.getState();
-				flt.archived = archivedChk.getState();
-				flt.notArchived = notArchivedChk.getState();
-				String filterType;
-				String filterVar;
-				String filterRose;
-				filterVar = (archivedChk.getState()    ? "1" : "0") +
-							(availableChk.getState()   ? "1" : "0") +
-							(foundChk.getState()       ? "1" : "0") +
-							(ownedChk.getState()       ? "1" : "0") +
-							(notArchivedChk.getState() ? "1" : "0") +
-							(notAvailableChk.getState()? "1" : "0") +
-							(notFoundChk.getState()    ? "1" : "0") +
-							(notOwnedChk.getState()    ? "1" : "0");							
-							
-				int typeMatchPattern = 0;
-				if(tradChk.getState()) typeMatchPattern |= Filter.TRADITIONAL;
-				if(multiChk.getState()) typeMatchPattern |= Filter.MULTI;
-				if(virtualChk.getState()) typeMatchPattern |= Filter.VIRTUAL;
-				if(letterChk.getState()) typeMatchPattern |= Filter.LETTER;
-				if(eventChk.getState()) typeMatchPattern |= Filter.EVENT;
-				if(webcamChk.getState()) typeMatchPattern |= Filter.WEBCAM;
-				if(mysteryChk.getState()) typeMatchPattern |= Filter.MYSTERY;
-				if(loclessChk.getState()) typeMatchPattern |= Filter.LOCLESS;
-				if(addiWptChk.getState()) typeMatchPattern |= Filter.ADDIWPT;
-				if(earthChk.getState()) typeMatchPattern |= Filter.EARTH;
-				if(megaChk.getState()) typeMatchPattern |= Filter.MEGA;
-				flt.typeMatchPattern = typeMatchPattern;
-				filterType = 	(tradChk.getState()    ? "1" : "0") +
-								(multiChk.getState()   ? "1" : "0") +
-								(virtualChk.getState() ? "1" : "0") +
-								(letterChk.getState()  ? "1" : "0") +
-								(eventChk.getState()   ? "1" : "0") + 
-								(webcamChk.getState()  ? "1" : "0") +
-								(mysteryChk.getState() ? "1" : "0") +
-								(earthChk.getState()   ? "1" : "0") +
-								(loclessChk.getState() ? "1" : "0") +
-								(megaChk.getState()    ? "1" : "0") +
-								(addiWptChk.getState() ? "1" : "0");
+				pfl.filterRose = (chkNW.state  ? "1":"0")+
+							 (chkNNW.state ? "1":"0")+
+							 (chkN.state   ? "1":"0")+
+							 (chkNNE.state ? "1":"0")+
+							 (chkNE.state  ? "1":"0")+
+							 (chkENE.state ? "1":"0")+
+							 (chkE.state   ? "1":"0")+
+							 (chkESE.state ? "1":"0")+
+							 (chkSE.state  ? "1":"0")+
+							 (chkSSE.state ? "1":"0")+
+							 (chkS.state   ? "1":"0")+
+							 (chkSSW.state ? "1":"0")+
+							 (chkSW.state  ? "1":"0")+
+							 (chkWSW.state ? "1":"0")+
+							 (chkW.state   ? "1":"0")+
+							 (chkWNW.state ? "1":"0");
+				pfl.filterSize =(chkMicro.state ? "1" : "0")+
+							(chkSmall.state ? "1" : "0")+
+							(chkRegular.state ? "1" : "0")+
+							(chkLarge.state ? "1" : "0")+
+							(chkVeryLarge.state ? "1" : "0")+
+							(chkOther.state ? "1" : "0");
 				
-				int roseMatchPattern = 0;
-				if(N.getState())   roseMatchPattern |= Filter.N;
-				if(NNE.getState()) roseMatchPattern |= Filter.NNE;
-				if(NE.getState())  roseMatchPattern |= Filter.NE;
-				if(ENE.getState()) roseMatchPattern |= Filter.ENE;
-				if(E.getState())   roseMatchPattern |= Filter.E;
-				if(ESE.getState()) roseMatchPattern |= Filter.ESE;
-				if(SE.getState())  roseMatchPattern |= Filter.SE;
-				if(SSE.getState()) roseMatchPattern |= Filter.SSE;
-				if(SSW.getState()) roseMatchPattern |= Filter.SSW;
-				if(SW.getState())  roseMatchPattern |= Filter.SW;
-				if(WSW.getState()) roseMatchPattern |= Filter.WSW;
-				if(W.getState())   roseMatchPattern |= Filter.W;
-				if(WNW.getState()) roseMatchPattern |= Filter.WNW;
-				if(NW.getState())  roseMatchPattern |= Filter.NW;
-				if(NNW.getState()) roseMatchPattern |= Filter.NNW;
-				if(S.getState())   roseMatchPattern |= Filter.S;
-				flt.roseMatchPattern = roseMatchPattern;
-				filterRose = (NW.getState()  ? "1":"0")+
-							 (NNW.getState() ? "1":"0")+
-							 (N.getState()   ? "1":"0")+
-							 (NNE.getState() ? "1":"0")+
-							 (NE.getState()  ? "1":"0")+
-							 (ENE.getState() ? "1":"0")+
-							 (E.getState()   ? "1":"0")+
-							 (ESE.getState() ? "1":"0")+
-							 (SE.getState()  ? "1":"0")+
-							 (SSE.getState() ? "1":"0")+
-							 (S.getState()   ? "1":"0")+
-							 (SSW.getState() ? "1":"0")+
-							 (SW.getState()  ? "1":"0")+
-							 (WSW.getState() ? "1":"0")+
-							 (W.getState()   ? "1":"0")+
-							 (WNW.getState() ? "1":"0");
-				
-				Profile pfl = Global.getProfile();
-				if(distChc.selectedIndex == 0) { 
-					flt.distdirec = Filter.SMALLER;
-					pfl.filterDist="<"+flt.dist;
+				if(chcDist.selectedIndex == 0) { 
+					pfl.filterDist="L"+inpDist.getText();
 				} else { 
-					flt.distdirec = Filter.GREATER;
-					pfl.filterDist=">"+flt.dist;
+					pfl.filterDist="G"+inpDist.getText();
 				}
 					
-				if(difChc.selectedIndex == 0) { 
-					flt.diffdirec = Filter.SMALLER;
-					pfl.filterDiff="<"+flt.diff;
-				} else if(difChc.selectedIndex == 1) { 
-					flt.diffdirec = Filter.EQUAL;
-					pfl.filterDiff="="+flt.diff;
+				if(chcDiff.selectedIndex == 0) { 
+					pfl.filterDiff="L"+inpDiff.getText();
+				} else if(chcDiff.selectedIndex == 1) { 
+					pfl.filterDiff="="+inpDiff.getText();
 				} else {	
-					flt.diffdirec = Filter.GREATER;
-					pfl.filterDiff=">"+flt.diff;
+					pfl.filterDiff="G"+inpDiff.getText();
 				}	
 					
-				if(terrChc.selectedIndex == 0) { 
-					flt.terrdirec = Filter.SMALLER;
-					pfl.filterTerr="<"+flt.terr;
-				} else if(terrChc.selectedIndex == 1){ 
-					flt.terrdirec = Filter.EQUAL;
-					pfl.filterTerr="="+flt.terr;
+				if(chcTerr.selectedIndex == 0) { 
+					pfl.filterTerr="L"+inpTerr.getText();
+				} else if(chcTerr.selectedIndex == 1){ 
+					pfl.filterTerr="="+inpTerr.getText();
 				} else { 
-					flt.terrdirec = Filter.GREATER;
-					pfl.filterTerr=">"+flt.terr;
+					pfl.filterTerr="G"+inpTerr.getText();
 				}
-				
-				if(lastChc.selectedIndex == 0) 
+/*				if(lastChc.selectedIndex == 0) 
 					flt.daysdirec = Filter.FOUND;
 				else 
 					flt.daysdirec = Filter.NOTFOUND;
-
+*/
 				// Need to think about saving it here. If yes, we also need to save filter when we clear it.
 				// Maybe better to auto-save index upon exit
 				//InfoBox infB = new InfoBox("Info",MyLocale.getMsg(713,"Saving filter"));
 				//infB.exec();
-				pfl.filterRose = filterRose;
-				pfl.filterType = filterType;
-				pfl.filterVar = filterVar;
 				//pfl.saveIndex(Global.getPref());
 				//infB.close(0);
-				flt.doFilter(cacheDB, dir);
+				Filter flt = new Filter();
+				flt.setFilter();
+				flt.doFilter();
 				Global.mainTab.tbP.tc.scrollToVisible(0,0);
 				Vm.showWait(false);
 				//Tabelle neu zeichnen lassen!
 				this.close(0);
-			}
-			else if (ev.target == btnBearing) cp.select(0);
+			} else if (ev.target == addiWptChk) { // Set all addi filters to value of main addi filter
+				chkParking.setState(addiWptChk.state);
+				chkStage.setState(addiWptChk.state);
+				chkQuestion.setState(addiWptChk.state);
+				chkFinal.setState(addiWptChk.state);
+				chkTrailhead.setState(addiWptChk.state);
+				chkReference.setState(addiWptChk.state);
+				addiWptChk.bgColor=Color.White;
+				addiWptChk.repaint();
+			} else if (ev.target == btnBearing) cp.select(0);
 			else if (ev.target == btnAttributes) cp.select(1);
 			else if (ev.target == btnRatings)cp.select(2);
 			else if (ev.target == btnTypes)cp.select(3);
-			else if (ev.target == btnContainer)cp.select(4);
-			else if (ev.target == btnSearch)cp.select(5);
+			else if (ev.target == btnAddi)cp.select(4);
+			else if (ev.target == btnContainer)cp.select(5);
+			else if (ev.target == btnSearch)cp.select(6);
 			else if (ev.target == chkDeselect) {
-				NW.state= NNW.state  = N.state    = NNE.state  = 
-				NE.state   = ENE.state  = E.state    = ESE.state  = 
-				SE.state   = SSE.state  = S.state    = SSW.state  = 
-				SW.state   = WSW.state  = W.state    = WNW.state = false; 
+				chkNW.state= chkNNW.state  = chkN.state    = chkNNE.state  = 
+				chkNE.state   = chkENE.state  = chkE.state    = chkESE.state  = 
+				chkSE.state   = chkSSE.state  = chkS.state    = chkSSW.state  = 
+				chkSW.state   = chkWSW.state  = chkW.state    = chkWNW.state = false; 
 				chkDeselect.state=false;
 				repaint();
 					
 			} else if (ev.target == chkSelect) {
-				NW.state= NNW.state  = N.state    = NNE.state  = 
-				NE.state   = ENE.state  = E.state    = ESE.state  = 
-				SE.state   = SSE.state  = S.state    = SSW.state  = 
-				SW.state   = WSW.state  = W.state    = WNW.state = true; 
+				chkNW.state= chkNNW.state  = chkN.state    = chkNNE.state  = 
+				chkNE.state   = chkENE.state  = chkE.state    = chkESE.state  = 
+				chkSE.state   = chkSSE.state  = chkS.state    = chkSSW.state  = 
+				chkSW.state   = chkWSW.state  = chkW.state    = chkWNW.state = true; 
 				chkSelect.state=false;
 				repaint();	
 			}
 		}
-		if (ev instanceof DataChangeEvent )	setColors();
+		if (ev instanceof DataChangeEvent )	{ 
+			setColors();
+		}
 
 	}
+
 }

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-02-04 13:23:47 UTC (rev 504)
+++ trunk/src/CacheWolf/MainMenu.java	2007-02-04 15:23:46 UTC (rev 505)
@@ -260,7 +260,7 @@
 				tbp.resetModel();
 			}
 			if(mev.selectedItem == filtCreate){
-				scnFilter.setData(cacheDB, pref.baseDir);
+				scnFilter.setData();
 				scnFilter.execute(father.getFrame(), Gui.CENTER_FRAME);
 				tbp.refreshTable();
 			}

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-02-04 13:23:47 UTC (rev 504)
+++ trunk/src/CacheWolf/TablePanel.java	2007-02-04 15:23:46 UTC (rev 505)
@@ -108,6 +108,9 @@
 	public void resetModel() {
 		myMod.numRows = cacheDB.size();
 		Global.getProfile().updateBearingDistance();
+		Filter flt = new Filter();
+		flt.setFilter();
+		flt.doFilter();
 		myMod.updateRows();
 		tc.update(true);
 		if (statBar!=null) statBar.updateDisplay();



From salzkammergut at mail.berlios.de  Sun Feb  4 19:00:58 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 4 Feb 2007 19:00:58 +0100
Subject: [Cachewolf-svn] r506 - trunk/src/CacheWolf
Message-ID: <200702041800.l14I0w32006088@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-04 19:00:27 +0100 (Sun, 04 Feb 2007)
New Revision: 506

Modified:
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/FilterScreen.java
   trunk/src/CacheWolf/GPXImporter.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/Profile.java
Log:
Blacklistfilter
Die Blacklist wird jetzt ueber eine Toggle im Menue Filter umgeschalten.
Der Filter funktioniert ganz gleich egal ob die Blacklist selektiert oder deselektiert ist.
+Nachtrag zum Filter Update (Profile)

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2007-02-04 15:23:46 UTC (rev 505)
+++ trunk/src/CacheWolf/Filter.java	2007-02-04 18:00:27 UTC (rev 506)
@@ -13,7 +13,7 @@
 public class Filter{
 	
 	private static final int SMALLER = -1;
-	private static final int EQUAL = -1;
+	private static final int EQUAL = 0;
 	private static final int GREATER = 1;
 
 	private static final int TRADITIONAL = 1;
@@ -219,19 +219,6 @@
 	}
 	
 	/**
-	 * Filters the cachelist for those caches marked is_black == true.
-	 * Only caches matching are then displayed in the table
-	 * @param cacheDB
-	 */
-	public void showBlacklist(Vector cacheDB){
-		CacheHolder ch;
-		for(int i = cacheDB.size()-1; i >=0 ; i--){
-			ch = (CacheHolder)cacheDB.get(i);
-			ch.is_filtered=!ch.is_black;
-		}
-	}
-	
-	/**
 	 * Set the filter from the filter data stored in the profile
 	 * (the filterscreen also updates the profile)
 	 */
@@ -314,6 +301,7 @@
 		int cacheTypePattern;
 		int cacheRosePattern;
 		int cacheSizePattern;
+		boolean showBlackListed=Global.getPref().showBlacklisted;
 		// Values from filterscreen are parsed outside the main filter loop (fsc=FilterSCreen)
 		double dummyd1;
 		//Loop db and match once against type pattern and once against rose pattern
@@ -325,7 +313,7 @@
 		// A cache is only displayed (i.e. is_filtered = false) if it meets all 9 filter criteria
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
 			ch = (CacheHolder)cacheDB.get(i);
-			ch.is_filtered = false;
+			ch.is_filtered = ch.is_black^showBlackListed;
 			///////////////////////////////
 			// Filter criterium 1: Cache type
 			///////////////////////////////
@@ -455,22 +443,29 @@
 	/**
 	*	Invert is_filtered flag on all caches
 	*/
-	public void invertFilter(Vector cacheDB){
+	public void invertFilter(){
+		Vector cacheDB=Global.getProfile().cacheDB;
 		CacheHolder ch;
+		boolean showBlackListed=Global.getPref().showBlacklisted;
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
 			ch = (CacheHolder)cacheDB.get(i);
-			ch.is_filtered=!ch.is_filtered; // skg: More efficient
+			if (ch.is_black==showBlackListed)
+				ch.is_filtered=!ch.is_filtered; // Only invert those that would be shown under blacklist filter
+			else
+				ch.is_filtered=true; // Hide all those that have the wrong is_black status
 		}
 	}
 	
 	/**
 	*	Clear the is_filtered flag from the cache database.
 	*/
-	public void clearFilter(Vector cacheDB){
+	public void clearFilter(){
+		Vector cacheDB=Global.getProfile().cacheDB;
 		CacheHolder ch;
+		boolean showBlackListed=Global.getPref().showBlacklisted;
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
 			ch = (CacheHolder)cacheDB.get(i);
-			ch.is_filtered=ch.is_black || CacheType.isAddiWpt(ch.type); // Always filter blacklisted caches
+			ch.is_filtered=(ch.is_black^showBlackListed) || CacheType.isAddiWpt(ch.type); // Always filter blacklisted caches
 		}
 		Profile prof=Global.getProfile();
 		prof.filterType = new String(Profile.FILTERTYPE);

Modified: trunk/src/CacheWolf/FilterScreen.java
===================================================================
--- trunk/src/CacheWolf/FilterScreen.java	2007-02-04 15:23:46 UTC (rev 505)
+++ trunk/src/CacheWolf/FilterScreen.java	2007-02-04 18:00:27 UTC (rev 506)
@@ -267,7 +267,7 @@
 		btPanel.addLast(btnRoute = new mButton("Route"),CellConstants.STRETCH, CellConstants.FILL);
 		addLast(btPanel.setTag(Control.SPAN, new Dimension(3,1)), CellConstants.STRETCH, CellConstants.FILL);
 		setPreferredSize(240,240);
-		
+		cp.select(3);
 	}
 	
 	

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2007-02-04 15:23:46 UTC (rev 505)
+++ trunk/src/CacheWolf/GPXImporter.java	2007-02-04 18:00:27 UTC (rev 506)
@@ -84,7 +84,7 @@
 */	
 	public void doIt(int how){
 		Filter flt = new Filter();
-		flt.clearFilter(cacheDB);
+		flt.clearFilter();
 		try{
 			ewe.io.Reader r;
 			String file;

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-02-04 15:23:46 UTC (rev 505)
+++ trunk/src/CacheWolf/MainMenu.java	2007-02-04 18:00:27 UTC (rev 506)
@@ -106,25 +106,27 @@
 		///////////////////////////////////////////////////////////////////////
 		// Create the "Filter" pulldown menu
 		///////////////////////////////////////////////////////////////////////
-		MenuItem[] filterMenuItems=new MenuItem[6];
+		MenuItem[] filterMenuItems=new MenuItem[7];
 		filterMenuItems[0] = filtCreate  = new MenuItem(MyLocale.getMsg(114,"Create")); 
 		filterMenuItems[1] = filtInvert  = new MenuItem(MyLocale.getMsg(115,"Invert")); 
 		filterMenuItems[2] = filtClear   = new MenuItem(MyLocale.getMsg(116,"Clear"));
-		filterMenuItems[3] = filtBlack   = new MenuItem(MyLocale.getMsg(161,"Show Blacklist"));
-		filterMenuItems[4] = new MenuItem("-");
-		filterMenuItems[5] = filtSelected = new MenuItem(MyLocale.getMsg(160,"Selected"));
+		filterMenuItems[3] = mnuSeparator;
+		filterMenuItems[4] = filtBlack   = new MenuItem(MyLocale.getMsg(161,"Show Blacklist"));
+		filterMenuItems[5] = mnuSeparator;
+		filterMenuItems[6] = filtSelected = new MenuItem(MyLocale.getMsg(160,"Selected"));
 		
 		///////////////////////////////////////////////////////////////////////
 		// Create a combined "Filter and Search" pulldown menu for devices with small screens
 		///////////////////////////////////////////////////////////////////////
-		MenuItem[] filterAndSearchMenuItems=new MenuItem[7];
+		MenuItem[] filterAndSearchMenuItems=new MenuItem[8];
 		filterAndSearchMenuItems[0]=filtCreate;
 		filterAndSearchMenuItems[1]=filtInvert;
 		filterAndSearchMenuItems[2]=filtClear;
-		filterAndSearchMenuItems[3]=filtBlack;
-		filterAndSearchMenuItems[4]=mnuSeparator;
-		filterAndSearchMenuItems[5]=search;
-		filterAndSearchMenuItems[6]=searchClr;
+		filterAndSearchMenuItems[3]=mnuSeparator;
+		filterAndSearchMenuItems[4]=filtBlack;
+		filterAndSearchMenuItems[5]=mnuSeparator;
+		filterAndSearchMenuItems[6]=search;
+		filterAndSearchMenuItems[7]=searchClr;
 		
 		// Depending on screen width display either filter and searach menus or the combined menu 
 		if (MyLocale.getScreenWidth()>300) {
@@ -195,6 +197,8 @@
 					pref.lastProfile=profile.name=f.profileDir;
 					pref.savePreferences(); // Remember that this was the last profile used
 					profile.dataDir=pref.baseDir+f.profileDir+"/";
+					pref.showBlacklisted=false;
+					filtBlack.modifiers&=~MenuItem.Checked;
 					tbp.refreshTable();
 				}
 				f.close(0);
@@ -204,6 +208,8 @@
 					profile.cacheDB.clear();
 					profile.readIndex();
 					pref.curCentrePt.set(profile.centre);
+					filtBlack.modifiers&=~MenuItem.Checked;
+					pref.showBlacklisted=false;
 					tbp.resetModel();
 					Global.mainTab.tbP.gotoFirstLine();
 				}
@@ -252,11 +258,15 @@
 						}
 					}
 				}
+				pref.showBlacklisted=false;
+				filtBlack.modifiers&=~MenuItem.Checked;
 				tbp.resetModel();
 			}
 			if(mev.selectedItem == loadOC){
 				OCXMLImporter oc = new OCXMLImporter(pref,profile);
 				oc.doIt();
+				pref.showBlacklisted=false;
+				filtBlack.modifiers&=~MenuItem.Checked;
 				tbp.resetModel();
 			}
 			if(mev.selectedItem == filtCreate){
@@ -266,12 +276,14 @@
 			}
 			if(mev.selectedItem == filtInvert){
 				Filter flt = new Filter();
-				flt.invertFilter(cacheDB);
+				flt.invertFilter();
 				tbp.refreshTable();
 			}
 			if(mev.selectedItem == filtBlack){
+				filtBlack.modifiers^=MenuItem.Checked;
+				pref.showBlacklisted=!pref.showBlacklisted;
 				Filter flt = new Filter();
-				flt.showBlacklist(cacheDB);
+				flt.clearFilter();
 				tbp.refreshTable();
 			}
 			if(mev.selectedItem == exportGPS){
@@ -310,17 +322,16 @@
 			}
 			if(mev.selectedItem == filtClear){
 				Filter flt = new Filter();
-				flt.clearFilter(cacheDB);
+				flt.clearFilter();
 				tbp.refreshTable();
 			}
 			
 			if(mev.selectedItem == filtSelected){
 				CacheHolder ch;
-				for(int i = 0; i <	cacheDB.size(); i++){
+				for(int i = cacheDB.size()-1; i>=0; i--){
 					ch = (CacheHolder)cacheDB.get(i);
-					ch.is_filtered = false;
-					if(ch.is_Checked == true) ch.is_filtered = true;
-					cacheDB.set(i, ch);
+					ch.is_filtered = ch.is_Checked;
+					//cacheDB.set(i, ch);
 				}
 				tbp.refreshTable();
 			}

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-02-04 15:23:46 UTC (rev 505)
+++ trunk/src/CacheWolf/Preferences.java	2007-02-04 18:00:27 UTC (rev 506)
@@ -43,6 +43,8 @@
 	public boolean showDeletedImages=true; /* Used in ImagePanel */
 	public boolean solverIgnoreCase=false;
 
+	/** Toggle for showing blacklisted caches. Can be toggled through the Filter menu */
+	public boolean showBlacklisted=false;
 	public int myAppHeight = 0;
 	public int myAppWidth = 0;
 	//public int nLogs = 5;

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-02-04 15:23:46 UTC (rev 505)
+++ trunk/src/CacheWolf/Profile.java	2007-02-04 18:00:27 UTC (rev 506)
@@ -38,8 +38,10 @@
 	public final static String FILTERTYPE="11111111111000000";
 	public final static String FILTERROSE="1111111111111111";
 	public final static String FILTERVAR="11111111";
+	public final static String FILTERSIZE="111111";
 	public String filterType = new String(FILTERTYPE);
 	public String filterRose = new String(FILTERROSE);
+	public String filterSize = new String(FILTERSIZE);
 	//filter settings for archived ... owner (section) in filterscreen
 	public String filterVar = new String(FILTERVAR);
 	public String filterDist=new String("");
@@ -101,7 +103,7 @@
 			
 			detfile.print("    <FILTER rose = \""+filterRose+"\" type = \""+filterType+
 					 "\" var = \""+filterVar+"\" dist = \""+filterDist.replace('"',' ')+"\" diff = \""+
-					 filterDiff+"\" terr = \""+filterTerr+"\" />\n");
+					 filterDiff+"\" terr = \""+filterTerr+"\" size = \""+filterSize+"\" />\n");
 			detfile.print("    <SYNCOC date = \""+last_sync_opencaching+"\" dist = \""+distOC+"\"/>\n");
 			for(int i = 0; i<cacheDB.size();i++){
 				ch = (CacheHolder)cacheDB.get(i);
@@ -214,13 +216,14 @@
 					filterDist = ex.findNext();
 					filterDiff = ex.findNext();
 					filterTerr = ex.findNext();
+					filterSize = ex.findNext();
 //					 Bilbowolf: Pattern for storing filter <FILTER type="01001101" rose = "010010101" var = "0101" dist = "<12" diff = ">13" terr = "<1"/>
 				}
 			}
 			in.close();
 			// Build references between caches and addi wpts
 			buildReferences();
-			
+			normalizeFilters();
 		} catch (FileNotFoundException e) {
 			Vm.debug("index.xml not found"); // Normal when profile is opened for first time
 			//e.printStackTrace();
@@ -339,4 +342,27 @@
 					}// if
 			   }// for
 		   }
+		   
+    /** Ensure that all filters have the proper length so that the 'charAt' access in the filter
+     * do not cause nullPointer Exceptions
+     */
+    private void normalizeFilters() {
+		if (filterRose.length()<16) { 
+			filterRose=(filterRose+"1111111111111111").substring(0,16); 
+		}  
+		if (filterVar.length()<8) { 
+			filterVar=(filterVar+"11111111").substring(0,8); 
+		}  
+		if (filterType.length()<16) { 
+			filterType=(filterType+"11111111111111111").substring(0,11);
+			filterType=(filterType+"000000").substring(0,17);
+		} 
+		if (filterSize.length()<6) {
+			filterSize=(filterSize+"111111").substring(0,6);
+		}
+		if (filterDist.length()==0) filterDist="L";
+		if (filterDiff.length()==0) filterDiff="L";
+		if (filterTerr.length()==0) filterTerr="L";
+    }
+		   
 }



From salzkammergut at mail.berlios.de  Sun Feb  4 19:07:03 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 4 Feb 2007 19:07:03 +0100
Subject: [Cachewolf-svn] r507 - trunk/src/CacheWolf
Message-ID: <200702041807.l14I73rP011074@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-04 19:06:57 +0100 (Sun, 04 Feb 2007)
New Revision: 507

Modified:
   trunk/src/CacheWolf/MainForm.java
Log:
MainForm: Im Profil gespeicherten Filter beim Start sofort anwenden

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-02-04 18:00:27 UTC (rev 506)
+++ trunk/src/CacheWolf/MainForm.java	2007-02-04 18:06:57 UTC (rev 507)
@@ -62,6 +62,9 @@
 			profile.readIndex();
 			pref.curCentrePt.set(profile.centre);
 			profile.updateBearingDistance();
+			Filter flt=new Filter();
+			flt.setFilter();
+			flt.doFilter();
 		} catch (Exception e){
 			if(pref.debug == true) Vm.debug("MainForm:: Exception:: " + e.toString());
 		}



From admin at berlios.de  Sun Feb  4 20:46:04 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 4 Feb 2007 20:46:04 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #10238] MovingMap: Distanzangabe ist kaum
	lesbar
Message-ID: <200702041946.l14Jk4tk002296@unicorn.berlios.de>

Bug #10238, was updated on 2007-Feb-04 20:46
Here is a current snapshot of the bug.

Project: CacheWolf
Category: None
Status: Open
Resolution: None
Bug Group: None
Priority: 1
Submitted by: mik77
Assigned to : mik77
Summary: MovingMap: Distanzangabe ist kaum lesbar

Details: Die Distanzangabe ist je nach dahinterligender Karte kaum zu lesen.

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10238&group_id=2211


From mik77 at mail.berlios.de  Sun Feb  4 20:48:57 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sun, 4 Feb 2007 20:48:57 +0100
Subject: [Cachewolf-svn] r508 - trunk/src/CacheWolf
Message-ID: <200702041948.l14Jmvqt007336@sheep.berlios.de>

Author: mik77
Date: 2007-02-04 20:48:51 +0100 (Sun, 04 Feb 2007)
New Revision: 508

Modified:
   trunk/src/CacheWolf/MapInfoObject.java
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap:
[ Bug #10238 ] Distanzangabe verkleinert und auf wei?\195?\159em Grund in die linke untere Ecke verlagert
Bonus: Ma?\195?\159stabsanzeige in der rechten unteren Ecke.

Modified: trunk/src/CacheWolf/MapInfoObject.java
===================================================================
--- trunk/src/CacheWolf/MapInfoObject.java	2007-02-04 18:06:57 UTC (rev 507)
+++ trunk/src/CacheWolf/MapInfoObject.java	2007-02-04 19:48:51 UTC (rev 508)
@@ -30,7 +30,7 @@
 	public double transLatX, transLatY, transLonX, transLonY; // this are needed for the inervers calculation from lat/lon to x/y
 	public CWPoint center = new CWPoint();
 	public float sizeKm = 0; // diagonale
-	public float scale; // in meters per pixel, note: it is assumed that this scale identifying the scale of the map
+	public float scale; // in meters per pixel, note: it is assumed that this scale identifying the scale of the map, automatically adjusted when zooming
 	public float zoomFactor = 1; // if the image is zoomed, direct after laoding always 1
 	public Point shift = new Point (0,0);
 	public CWPoint OrigUpperLeft; // this is only valid after zooming 

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-04 18:06:57 UTC (rev 507)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-04 19:48:51 UTC (rev 508)
@@ -46,6 +46,8 @@
 	AniImage buttonImageZoom1to1 = new AniImage("zoom1to1.png");
 	AniImage DistanceImage;
 	Graphics DistanceImageGraphics;
+	AniImage ScaleImage;
+	Graphics ScaleImageGraphics;
 	MapImage posCircle = new MapImage("position_green.png");
 	int posCircleX = 0, posCircleY = 0, lastCompareX = Integer.MAX_VALUE, lastCompareY = Integer.MAX_VALUE;
 	double posCircleLat, posCircleLon;
@@ -93,13 +95,21 @@
 		mmp.addImage(buttonImageLens);
 		buttonImageZoom1to1.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(buttonImageZoom1to1);
+		//target distance
 		//Label distLbl = new mLabel("Distance: ----,-- km");
 		DistanceImage = new AniImage();
-		DistanceImage.setImage(new Image(120, 20), Color.White); // consider the size of the font used
+		DistanceImage.setImage(new Image(120, 15), Color.White); // consider the size of the font used
 		DistanceImageGraphics = new Graphics(DistanceImage.image);
-		DistanceImageGraphics.setFont(new Font("Helvetica", Font.BOLD, 16));
+		DistanceImageGraphics.setFont(new Font("Helvetica", Font.PLAIN, 13));
 		DistanceImage.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(DistanceImage);
+		//scale
+		ScaleImage = new AniImage();
+		ScaleImage.setImage(new Image(120, 15), Color.White); // consider the size of the font used
+		ScaleImageGraphics = new Graphics(ScaleImage.image);
+		ScaleImageGraphics.setFont(new Font("Helvetica", Font.PLAIN, 13));
+		ScaleImage.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(ScaleImage);
 		//resizeTo(pref.myAppWidth, pref.myAppWidth); // is necessary to initialize mapImage.screenSize
 		setGpsStatus(noGPS);
 		posCircle.properties = AniImage.AlwaysOnTop;
@@ -127,7 +137,8 @@
 		buttonImageZoom1to1.setLocation(w - buttonImageZoom1to1.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 - buttonImageZoom1to1.getHeight() -10);
 		buttonImageLens.setLocation(w - buttonImageLens.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 );
 		buttonImageLensActivated.setLocation(w - buttonImageLens.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 );
-		DistanceImage.setLocation(w/2 - DistanceImage.location.width/2, h - DistanceImage.location.height -10);
+		DistanceImage.setLocation(0, h - DistanceImage.getHeight());
+		ScaleImage.setLocation(w - ScaleImage.getWidth(), h - ScaleImage.getHeight());
 		if (mmp.mapImage != null) mmp.mapImage.move(mmp.mapImage.locAlways.x, mmp.mapImage.locAlways.y); // this is necessary to make a new decision if it is still on the screen (and actually mor important because MapImage only now gets to know the screen size) 
 		if (posCircle != null) posCircle.move(posCircle.locAlways.x, posCircle.locAlways.y); // this is necessary to make a new decision if it is still on the screen (and actually mor important because MapImage only now gets to know the screen size) 
 		if (tracks != null) addOverlaySet();
@@ -162,23 +173,72 @@
 		loadingMapList = false;
 	}
 
+	public void updateScale() {
+		ScaleImageGraphics.setColor(ScaleImage.transparentColor);
+		ScaleImageGraphics.fillRect(0, 0, ScaleImage.location.width,ScaleImage.location.height);
+		
+		if (currentMap != null)
+		{
+			float lineLengthMeters = 40 * currentMap.scale;
+			float digits = (float)java.lang.Math.floor( java.lang.Math.log(lineLengthMeters) / java.lang.Math.log(10.0) );
+			lineLengthMeters = (float)java.lang.Math.ceil( lineLengthMeters / (float)java.lang.Math.pow(10, digits) ) * (float)java.lang.Math.pow(10, digits);
+			int lineLengthPixels = (int)java.lang.Math.round( lineLengthMeters / currentMap.scale );
+
+			String lineLengthString;
+			int backgroundStartX = 0;
+			if (lineLengthMeters < 1000)
+			{
+				lineLengthString = Convert.toString((int) lineLengthMeters) + "m";
+				backgroundStartX = ScaleImage.location.width - lineLengthPixels - ( ((int)digits+1) * 6 ) - 14;
+			}
+			else
+			{
+				lineLengthString = Convert.toString((int) lineLengthMeters / 1000) + "km";
+				backgroundStartX = ScaleImage.location.width - lineLengthPixels - ( ((int)digits-2) * 6 ) - 19;
+			}
+			
+			ScaleImageGraphics.setColor(new Color(250,250,250));
+			ScaleImageGraphics.fillRect(backgroundStartX, 0, ScaleImage.location.width - backgroundStartX ,ScaleImage.location.height);
+
+			ScaleImageGraphics.setPen(new Pen(Color.DarkBlue,Pen.SOLID,3));
+			ScaleImageGraphics.drawLine(backgroundStartX + 2, ScaleImage.location.height / 2, backgroundStartX+2+lineLengthPixels, ScaleImage.location.height / 2);
+			ScaleImageGraphics.setColor(Color.DarkBlue);
+			ScaleImageGraphics.drawText(lineLengthString , backgroundStartX + lineLengthPixels + 5, 0);
+		}
+		
+		ScaleImageGraphics.drawImage(ScaleImage.image,null,Color.LightBlue,0,0,ScaleImage.location.width,ScaleImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+		ScaleImageGraphics.drawImage(ScaleImage.image,null,Color.White,0,0,ScaleImage.location.width,ScaleImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
+	}
+	
 	public void updateDistance() {
 		DistanceImageGraphics.setColor(DistanceImage.transparentColor);
 		DistanceImageGraphics.fillRect(0, 0, DistanceImage.location.width,DistanceImage.location.height);
-		if (gotoPos == null || posCircleLat < -360) return;
-		ewe.sys.Double dd = new ewe.sys.Double();
-		dd.set((new CWPoint(gotoPos.lat, gotoPos.lon).getDistance(posCircleLat, posCircleLon)));
-		String d; 
-		if (dd.value < 1) {
-			dd.value = dd.value * 1000; 
-			dd.decimalPlaces = 0;
-			d = "Distance: " + dd.toString() + "m";} 
-		else {
-			dd.decimalPlaces = 2;
-			d = "Distance: " + dd.toString() + "km";
+		if (gotoPos != null && posCircleLat >= -360)
+		{
+			ewe.sys.Double dd = new ewe.sys.Double();
+			dd.set((new CWPoint(gotoPos.lat, gotoPos.lon).getDistance(posCircleLat, posCircleLon)));
+			String d;
+			int backgroundWidth = DistanceImage.location.width;
+			if (dd.value < 1) {
+				dd.value = dd.value * 1000; 
+				dd.decimalPlaces = 0;
+				d = "Dist: " + dd.toString() + "m";
+				int digits = (int)java.lang.Math.floor( java.lang.Math.log(dd.value) / java.lang.Math.log(10.0) );
+				backgroundWidth = 6 * (digits + 1) + 36;
+				} 
+			else {
+				dd.decimalPlaces = 2;
+				d = "Dist: " + dd.toString() + "km";
+				int digits = (int)java.lang.Math.floor( java.lang.Math.log(dd.value) / java.lang.Math.log(10.0) );
+				backgroundWidth = 6 * (digits + 3) + 45;
+			}
+			
+			DistanceImageGraphics.setColor(new Color(250,250,250));
+			DistanceImageGraphics.fillRect(0, 0, backgroundWidth ,DistanceImage.location.height);
+
+			DistanceImageGraphics.setColor(Color.DarkBlue);
+			DistanceImageGraphics.drawText(d, 2, 0);
 		}
-		DistanceImageGraphics.setColor(Color.DarkBlue);
-		DistanceImageGraphics.drawText(d, 0, 0);
 		DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.LightBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
 		DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.White,0,0,DistanceImage.location.width,DistanceImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
 	}
@@ -900,6 +960,7 @@
 			updateOnlyPosition(lat, lon, false);
 			forceMapLoad = false;
 			directionArrows.setMap(currentMap);
+			updateScale();
 			inf.close(0);  // this doesn't work in a ticked-thread in the ewe-vm. That's why i made a new mThread in gotoPanel for ticked
 			Vm.showWait(false);
 			ignoreGps = saveIgnoreStatus;
@@ -1069,6 +1130,7 @@
 		Vm.getUsedMemory(true); // call garbage collection
 		setCenterOfScreen(center);
 		addOverlaySet();
+		updateScale();
 		this.repaintNow();
 		Vm.showWait(this, false);
 		ignoreGps = savegpsstatus;



From admin at berlios.de  Sun Feb  4 20:49:47 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 4 Feb 2007 20:49:47 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #10238] MovingMap: Distanzangabe ist kaum
	lesbar
Message-ID: <200702041949.l14JnlhL002474@unicorn.berlios.de>

Bug #10238, was updated on 2007-Feb-04 20:46
Here is a current snapshot of the bug.

Project: CacheWolf
Category: None
Status: Open
Resolution: None
Bug Group: Ready to test
Priority: 1
Submitted by: mik77
Assigned to : mik77
Summary: MovingMap: Distanzangabe ist kaum lesbar

Details: Die Distanzangabe ist je nach dahinterligender Karte kaum zu lesen.

Follow-Ups:

Date: 2007-Feb-04 20:49
By: mik77

Comment:
Gefixt in Revision 508.
In die linke untere Ecke verschoben, verkleinert und auf hellen Hintergrund gelegt.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10238&group_id=2211


From salzkammergut at mail.berlios.de  Sun Feb  4 21:25:13 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 4 Feb 2007 21:25:13 +0100
Subject: [Cachewolf-svn] r509 - trunk/src/CacheWolf
Message-ID: <200702042025.l14KPDj8011729@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-04 21:25:08 +0100 (Sun, 04 Feb 2007)
New Revision: 509

Modified:
   trunk/src/CacheWolf/TablePanel.java
   trunk/src/CacheWolf/myTableControl.java
Log:
MyTableControl Bugfix + Aufraeumen
- Kontextmenue wird nicht angezeigt wenn cacheDB.size()=0
- Beim Loeschen von Caches ueber das Kontextmenue werden jetzt die zugehoerigen Dateien geloescht
Kontextmenue von TablePanel nach MyTableControl

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-02-04 19:48:51 UTC (rev 508)
+++ trunk/src/CacheWolf/TablePanel.java	2007-02-04 20:25:08 UTC (rev 509)
@@ -16,57 +16,19 @@
 	
 	myTableControl tc;
 	myTableModel myMod;
-	int selectedCache;
+	int selectedCache=0;
 	Preferences pref;
 	Vector cacheDB;
-	GotoPanel myGotoPanel;
 	MainTab myMaintab;
 	StatusBar statBar;
 	
-	public TablePanel(Preferences p, Profile profile, StatusBar statBar){
+	public TablePanel(Preferences p, Profile profileXX, StatusBar statBar){
+		pref = Global.getPref();
+		Profile profile=Global.getProfile();
 		this.statBar = statBar;
 		cacheDB = profile.cacheDB;
-		pref = p;
-/*
-		String [] spName = {" ","?",MyLocale.getMsg(1000,"D"),"T",MyLocale.getMsg(1002,"Waypoint"),"Name",MyLocale.getMsg(1004,"Location"),MyLocale.getMsg(1005,"Owner"),MyLocale.getMsg(1006,"Hidden"),MyLocale.getMsg(1007,"Status"),MyLocale.getMsg(1008,"Dist"),MyLocale.getMsg(1009,"Bear")};
-		String[] jester;
-		int colWidth[];
-		int colnum = 0;
-		
-		for(int i = 0; i<=11; i++){
-			if(pref.tablePrefs[i] == 1) colnum++;
-		}
-		jester = new String[colnum];
-		colWidth = new int[colnum];
-		
-		int ji = 0;
-		for(int i = 0; i<=11;i++){
-			if(pref.tablePrefs[i] == 1){
-				jester[ji] = spName[i];
-				colWidth[ji] = pref.tableWidth[i];
-				ji++;
-			}
-		}
-*/		
-		addLast(new ScrollBarPanel(tc = new myTableControl()));
+		addLast(new ScrollBarPanel(tc = new myTableControl(this)));
 		if (statBar!=null) addLast(statBar,CellConstants.DONTSTRETCH, CellConstants.FILL);
-		Menu m = new Menu(new String[]{
-				MyLocale.getMsg(1021,"Open desription"),
-				MyLocale.getMsg(1010,"Goto"),
-				MyLocale.getMsg(1019,"enter"),
-				MyLocale.getMsg(1020,"open in $browser online"),
-				"-",
-				MyLocale.getMsg(1011,"Filter"),
-				MyLocale.getMsg(1012,"Delete"),
-				MyLocale.getMsg(1014,"Update"),
-				"-",
-				MyLocale.getMsg(1015,"Select all"),
-				MyLocale.getMsg(1016,"De-select all")},MyLocale.getMsg(1013,"With selection"));
-		tc.setMenu(m);
-		tc.profile=profile;
-		tc.db = cacheDB;
-		tc.pref = p;
-		tc.tbp = this;
 		myMod = new myTableModel(tc, getFontMetrics());
 		myMod.hasRowHeaders = false;
 		myMod.hasColumnHeaders  = true;
@@ -77,11 +39,16 @@
 		tc.scrollToVisible(0,0);
 	}
 	
+	/** @deprecated */
 	public void setPanels(GotoPanel gp, MainTab mt) {
-		myGotoPanel = gp;
 		myMaintab = mt;
 	}
+
+	public void setSelectedCache(int row){
+		selectedCache=row;
+	}
 	
+	
 	public int getSelectedCache(){
 		return selectedCache;
 	}
@@ -111,11 +78,12 @@
 		Filter flt = new Filter();
 		flt.setFilter();
 		flt.doFilter();
-		myMod.updateRows();
-		tc.update(true);
-		if (statBar!=null) statBar.updateDisplay();
+		refreshTable();
+		selectedCache=0;
 	}
 	
+	/** Move all filtered caches to the end of the table and redesplay table */
+	//TODO Add a sort here to restore the sort after a filter
 	public void refreshTable(){
 		myMod.updateRows();
 		tc.update(true);
@@ -124,38 +92,14 @@
 	
 	public void onEvent(Event ev)
 	{
-		////Vm.debug(ev.toString());
-		if(ev instanceof PenEvent){
-			if(ev.type == PenEvent.RIGHT_BUTTON){
-				Vm.debug("Right mouse button pressed");
-			}
-		}
 		if(ev instanceof TableEvent){
 			Point a = new Point();
 			Point dest = new Point();
 			a = tc.getSelectedCell(dest);
-			try{
+			try {
 				selectedCache = a.y;
-					}catch(NullPointerException npe){
-			}
+			} catch(NullPointerException npe){}
 		}
-		/* Not needed because myTableModel contains code to handle click on checkBox image
-		if(ev instanceof ControlEvent && ev.target instanceof mCheckBox){
-			mCheckBox m = new mCheckBox();
-			m = (mCheckBox)ev.target;
-			CacheHolder ch = new CacheHolder();
-			String tag = new String();
-			tag = (String)m.getTag(0, "nix");
-			for(int i = 0; i<cacheDB.size();i++){
-				ch = (CacheHolder)cacheDB.get(i);
-				if(ch.wayPoint.equals(tag)){
-					ch.is_Checked = m.getState();
-					cacheDB.set(i, ch);
-				}
-			}
-		} */
 	  super.onEvent(ev); //Make sure you call this.
 	}
 }
-
-

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-02-04 19:48:51 UTC (rev 508)
+++ trunk/src/CacheWolf/myTableControl.java	2007-02-04 20:25:08 UTC (rev 509)
@@ -7,158 +7,174 @@
 import ewe.util.*;
 
 /**
-*	This class is not required?!
+*	Implements the user interaction of the list view. Works together with myTableModel and TablePanel
 */
 public class myTableControl extends TableControl{
 
+	public Preferences pref;
 	public Profile profile;
-	public Vector db;
-	public Preferences pref;
+	public Vector cacheDB;
 	public TablePanel tbp;
-	public MainTab mainTabs;
 	
+	myTableControl(TablePanel tablePanel) {
+		Menu m = new Menu(new String[]{
+				MyLocale.getMsg(1021,"Open description"),
+				MyLocale.getMsg(1010,"Goto"),
+				MyLocale.getMsg(1019,"enter"),
+				MyLocale.getMsg(1020,"open in $browser online"),
+				"-",
+				MyLocale.getMsg(1011,"Filter"),
+				MyLocale.getMsg(1012,"Delete"),
+				MyLocale.getMsg(1014,"Update"),
+				"-",
+				MyLocale.getMsg(1015,"Select all"),
+				MyLocale.getMsg(1016,"De-select all")},
+				MyLocale.getMsg(1013,"With selection"));
+		setMenu(m);
+		profile=Global.getProfile();
+		cacheDB = profile.cacheDB;
+		pref = Global.getPref();
+		tbp =tablePanel;
+	}
+	
 	public void penRightReleased(Point p){
-		menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
+		if (cacheDB.size()>0) // No context menu when DB is empty
+		   menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
 	}
 	public void penHeld(Point p){
-		menuState.doShowMenu(p,true,null); 
+		if (cacheDB.size()>0) // No context menu when DB is empty
+		   menuState.doShowMenu(p,true,null); 
 	}
 	
 	public void onKeyEvent(KeyEvent ev) {
 		if (ev.type == KeyEvent.KEY_PRESS && ev.target == this){
-			if ( (ev.modifiers & IKeys.CONTROL) > 0 && ev.key == 'a'-'a'+1){ // <ctrl-a> gives 1, <ctrl-b> == 2
+			if ( (ev.modifiers & IKeys.CONTROL) > 0 && ev.key == 1){ // <ctrl-a> gives 1, <ctrl-b> == 2
 				// select all on <ctrl-a>
-				selectAll();
+				setSelectForAll(true);
 				ev.consumed = true;
 			}
 		}
 		super.onKeyEvent(ev);
 	}
 		
-		public void selectAll() {
-			CacheHolder ch;
-			for(int i = 0; i <	db.size(); i++){
-				ch = (CacheHolder)db.get(i);
-				if (ch.is_filtered == false) ch.is_Checked = true;
-				//db.set(i, ch);
-			}
-			tbp.myMod.cacheSelectionChanged = true;
-			tbp.refreshTable();
+	/** Set all caches either as selected or as deselected, depending on argument */
+	private void setSelectForAll(boolean selectStatus) {
+		CacheHolder ch;
+		for(int i = cacheDB.size()-1; i >=	0; i--){
+			ch = (CacheHolder)cacheDB.get(i);
+			if (ch.is_filtered == false) ch.is_Checked = selectStatus;
 		}
+		tbp.myMod.cacheSelectionChanged = true;
+		tbp.refreshTable();
+	}
 	
 	
 	public void popupMenuEvent(Object selectedItem){
 		CacheHolder ch;
 		
 		if (selectedItem.toString().equals(MyLocale.getMsg(1015,"Select all"))){
-			selectAll();
+			setSelectForAll(true);
 		}
 		
 		if (selectedItem.toString().equals(MyLocale.getMsg(1016,"De-select all"))){
-			for(int i = 0; i <	db.size(); i++){
-				ch = (CacheHolder)db.get(i);
-				if (ch.is_filtered == false) ch.is_Checked = false;
-				//db.set(i, ch);
-			}
-			tbp.myMod.cacheSelectionChanged = true;
-			tbp.refreshTable();
+			setSelectForAll(false);
 		}
 		
 		if (selectedItem.toString().equals(MyLocale.getMsg(1011,"Filter"))){
-			for(int i = 0; i <	db.size(); i++){
-				ch = (CacheHolder)db.get(i);
-				ch.is_filtered = true;
-				if(ch.is_Checked == true) ch.is_filtered = false;
-				//db.set(i, ch);
+			for(int i = cacheDB.size()-1; i >=0; i--){
+				ch = (CacheHolder)cacheDB.get(i);
+				ch.is_filtered = !ch.is_Checked;
 			}
 			tbp.refreshTable();
 		}
 		if (selectedItem.toString().equals(MyLocale.getMsg(1012,"Delete"))){
-			if ((new MessageBox("Warnung", "Alle mit H?ckchen markierten Caches l?schen?", MessageBox.YESB | MessageBox.NOB)).execute() != Form.IDYES) return;
-			for(int i = 0; i <	db.size(); i++){
-				ch = (CacheHolder)db.get(i);
-				if(ch.is_Checked == true) {
-					db.remove(ch);
-					i--;
+			if ((new MessageBox(MyLocale.getMsg(144,"Warnung"),MyLocale.getMsg(1022, "Delete all caches that have a tick?"), MessageBox.YESB | MessageBox.NOB)).execute() != Form.IDYES) return;
+				DataMover dm=new DataMover();
+				for(int i = cacheDB.size()-1; i >=0; i--){
+					ch = (CacheHolder)cacheDB.get(i);
+					if(ch.is_Checked == true) {
+						dm.deleteCacheFiles(ch.wayPoint,profile.dataDir);
+						cacheDB.remove(ch);
+						i--;
+					}
 				}
-			}
 			tbp.refreshTable();
 		}
 		
 		if (selectedItem.toString().equals(MyLocale.getMsg(1014,"Update"))){
-			SpiderGC spider = new SpiderGC(pref, profile);
-			Vm.showWait(true);
-			spider.login();
-			boolean alreadySaid = false;
-			boolean alreadySaid2 = false;
-			for(int i = 0; i <	db.size(); i++){
-				ch = (CacheHolder)db.get(i);
-				if(ch.is_Checked == true) {
-					if ( (ch.wayPoint.length() > 1 && ch.wayPoint.substring(0,2).equalsIgnoreCase("GC")))
-// Notiz: Wenn es ein addi Wpt ist, sollte eigentlich der Maincache gespidert werden
-// Alter code pr?ft aber nur ob ein Maincache von GC existiert und versucht dann den addi direkt zu spidern, was nicht funktioniert
-// TODO: Diese Meldungen vor dem Einloggen darstellen						
-					{
-						spider.spiderSingle(i);
-					} else if (ch.isAddiWpt() && !ch.mainCache.is_Checked) { // Is the father ticked?
-						if (!alreadySaid2) {
-							alreadySaid2=true;
-							(new MessageBox("Information","Hilfswegpunkte k?nnnen nicht direkt gespidert werden\nBitte zus?tzlich den Vater anhaken", MessageBox.OKB)).exec();
-						}
-					} else if (ch.mainCache != null &&	ch.mainCache.wayPoint.length() > 1 	&& !ch.mainCache.wayPoint.substring(0,2).equalsIgnoreCase("GC") && 
-							   !alreadySaid) {
-						alreadySaid = true;
-						(new MessageBox("Information",ch.wayPoint+">"+ch.mainCache.wayPoint+": Diese Funktion steht gegenw?rtig nur f?r Geocaching.com zur Verf?gung", MessageBox.OKB)).exec();
-					}
-				}
-			}
-			tbp.refreshTable();
-			Vm.showWait(false);
+            SpiderGC spider = new SpiderGC(pref, profile);
+            Vm.showWait(true);
+            spider.login();
+            boolean alreadySaid = false;
+            boolean alreadySaid2 = false;
+            for(int i = 0; i <	cacheDB.size(); i++){
+                    ch = (CacheHolder)cacheDB.get(i);
+                    if(ch.is_Checked == true) {
+                            if ( (ch.wayPoint.length() > 1 && ch.wayPoint.substring(0,2).equalsIgnoreCase("GC")))
+//Notiz: Wenn es ein addi Wpt ist, sollte eigentlich der Maincache gespidert werden
+//Alter code pr?ft aber nur ob ein Maincache von GC existiert und versucht dann den addi direkt zu spidern, was nicht funktioniert
+//TODO: Diese Meldungen vor dem Einloggen darstellen						
+		{
+                                    spider.spiderSingle(i);
+                            } else if (ch.isAddiWpt() && !ch.mainCache.is_Checked) { // Is the father ticked?
+                            		if (!alreadySaid2) {
+                                            alreadySaid2=true;
+                                            (new MessageBox("Information","Hilfswegpunkte k?nnnen nicht direkt gespidert werden\nBitte zus?tzlich den Vater anhaken", MessageBox.OKB)).exec();
+                                    }
+                            } else if (ch.mainCache != null &&	ch.mainCache.wayPoint.length() > 1 	&& !ch.mainCache.wayPoint.substring(0,2).equalsIgnoreCase("GC") && 
+                                               !alreadySaid) {
+                                    alreadySaid = true;
+                                    (new MessageBox("Information",ch.wayPoint+">"+ch.mainCache.wayPoint+": Diese Funktion steht gegenw?rtig nur f?r Geocaching.com zur Verf?gung", MessageBox.OKB)).exec();
+                            }
+                    }
+            }
+            tbp.refreshTable();
+            Vm.showWait(false);
 		}
 		if (selectedItem.toString().equals(MyLocale.getMsg(1019,"Center"))){
-			CacheHolder thisCache = (CacheHolder)tbp.cacheDB.get(tbp.getSelectedCache());
+			CacheHolder thisCache = (CacheHolder)cacheDB.get(tbp.getSelectedCache());
 			CWPoint cp=new CWPoint(thisCache.LatLon);
 			if (!cp.isValid()){
-				MessageBox tmpMB = new MessageBox(MyLocale.getMsg(312,"Error"), MyLocale.getMsg(4111,"Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"), MessageBox.OKB);
+				MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(4111,"Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"), MessageBox.OKB);
 				tmpMB.exec();
 			} else {				
 				pref.curCentrePt.set(cp);
-				profile.updateBearingDistance();
+				Global.mainTab.updateBearDist(); // Update the distances with a warning message
 				tbp.refreshTable();
 				(new MessageBox("Info", "Entfernungen in der Listenansicht \nvom aktuellen Standpunkt aus \nneu berechnet", MessageBox.OKB)).execute();
 			}
 		}
 		
 		if (selectedItem.toString().equals(MyLocale.getMsg(1010,"Goto"))){
-			ch = (CacheHolder)tbp.cacheDB.get(tbp.getSelectedCache());
-			tbp.myGotoPanel.setDestinationAndSwitch((ch.LatLon));
+			ch = (CacheHolder)cacheDB.get(tbp.getSelectedCache());
+			Global.mainTab.gotoPoint(ch.LatLon);
 		}
 		if (selectedItem.toString().equalsIgnoreCase(MyLocale.getMsg(1020,"Open online in Browser"))){
-			ch = (CacheHolder)tbp.cacheDB.get(tbp.getSelectedCache());
+			ch = (CacheHolder)cacheDB.get(tbp.getSelectedCache());
 			try{
 				ch.readCache(profile.dataDir);
-			}catch(IOException ex){	(new MessageBox("Error", "Cannot read cache data\n"+ex.toString()+"\n in cache: "+ch.wayPoint,MessageBox.OKB)).execute(); }
+			}catch(IOException ex){	(new MessageBox(MyLocale.getMsg(321,"Error"), "Cannot read cache data\n"+ex.toString()+"\nCache: "+ch.wayPoint,MessageBox.OKB)).execute(); }
 			try {
-				String cmd = "\""+pref.browser+ "\" " + ch.URL;
+				String cmd = "\""+pref.browser+ "\" \"" + ch.URL+"\"";
 				Vm.exec(cmd);
 			} catch (IOException ex) {
 				(new MessageBox("Error", "Cannot start browser!\n"+ex.toString()+"\nThe are two possible reasons:\n * path to internet browser in \npreferences not correct\n * An bug in ewe VM, please be \npatient for an update",MessageBox.OKB)).execute();
 			}
 		}
 		if (selectedItem.toString().equalsIgnoreCase(MyLocale.getMsg(1021,"Open description"))){
-			openCacheDesc();
+			penDoubleClicked(null);
 		}
 
 	}
 	
+	public void penDoubleClicked(Point where) {
+		//Global.mainTab.select(Global.mainTab.descP);
+		openCacheDesc();
+	}
+
 	void openCacheDesc() {
-//		Point a = new Point();
-		//	Point dest = new Point();
-			//a = getSelectedCell(dest);
 			CacheHolder ch;
 			ch = (CacheHolder)tbp.cacheDB.get(tbp.getSelectedCache());
-
-		//	ch = (CacheHolder)db.get(a.y);
 			try{
 				ch.readCache(profile.dataDir);
 			}catch(IOException ex){	
@@ -168,7 +184,4 @@
 		
 	}
 	
-	public void  penDoubleClicked(Point where) {
-		openCacheDesc();
-	}
 }



From salzkammergut at mail.berlios.de  Sun Feb  4 22:42:05 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 4 Feb 2007 22:42:05 +0100
Subject: [Cachewolf-svn] r510 - trunk/src/CacheWolf
Message-ID: <200702042142.l14Lg5IG017222@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-04 22:42:00 +0100 (Sun, 04 Feb 2007)
New Revision: 510

Modified:
   trunk/src/CacheWolf/myTableModel.java
Log:
MyTableModel: Addis ohne Hauptcache behalten

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-02-04 20:25:08 UTC (rev 509)
+++ trunk/src/CacheWolf/myTableModel.java	2007-02-04 21:42:00 UTC (rev 510)
@@ -144,11 +144,17 @@
 			ch = (CacheHolder) cacheDB.get(i);
 			if (ch.is_filtered) {
 				filteredDB.add(ch);
-			} else {
-				if (ch.isAddiWpt()){
+			} else { // point is not filtered
+				if (ch.isAddiWpt()){ // unfiltered Addi Wpt
 					// check if main wpt is filtered
-					if(ch.mainCache != null) if (ch.mainCache.is_filtered) sortDB.add(ch);
-				} else {
+					if(ch.mainCache != null) { // parent exists
+						if (ch.mainCache.is_filtered) 
+							sortDB.add(ch); // Unfiltered Addi Wpt with filtered Main Wpt, show it on its own
+						// else Main cache is not filtered, Addi will be added below main cache further down
+					} else { //Addi without main Cache
+						sortDB.add(ch);
+					}
+				} else { // Main Wpt, not filtered. Check for Addis
 					sortDB.add(ch);
 					if (ch.hasAddiWpt()){
 						for (int j=0; j<ch.addiWpts.getCount();j++){



From salzkammergut at mail.berlios.de  Sun Feb  4 23:46:07 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 4 Feb 2007 23:46:07 +0100
Subject: [Cachewolf-svn] r511 - trunk/src/CacheWolf
Message-ID: <200702042246.l14Mk7kE021526@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-04 23:46:00 +0100 (Sun, 04 Feb 2007)
New Revision: 511

Modified:
   trunk/src/CacheWolf/Profile.java
Log:
Profile: Bugfix normalizeFilters wurde bei fehlendem index.xml nicht ausgefuehrt


Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-02-04 21:42:00 UTC (rev 510)
+++ trunk/src/CacheWolf/Profile.java	2007-02-04 22:46:00 UTC (rev 511)
@@ -223,7 +223,6 @@
 			in.close();
 			// Build references between caches and addi wpts
 			buildReferences();
-			normalizeFilters();
 		} catch (FileNotFoundException e) {
 			Vm.debug("index.xml not found"); // Normal when profile is opened for first time
 			//e.printStackTrace();
@@ -231,6 +230,7 @@
 			Vm.debug("Problem reading index.xml "+e.toString()); 
 			e.printStackTrace();
 		}
+		normalizeFilters();
 	}
 	
 	public int getCacheIndex(String wp){
@@ -245,6 +245,25 @@
 		return retval;
 	}
 
+	/** Get a unique name for a new waypoint */
+	//TODO Make more efficient
+	public String getNewWayPointName(){
+		String strWp=null;
+		long  lgWp=1;
+        if (cacheDB.size()==0 )
+        	return "CW0000";
+		//Create new waypoint,look if not in db
+		for(int i = 0;i < cacheDB.size();i++){
+			strWp = "CW" + MyLocale.formatLong(lgWp, "0000");
+			if(((CacheHolder)cacheDB.get(i)).wayPoint.indexOf(strWp) >=0 ){
+				//waypoint exists in database
+				lgWp++;
+				i = -1; // Because i++ will be executed next, so we start the loop with 0
+			}
+		}
+		return strWp;
+	}
+	
 	public String toString() {
 		return "Profile: Name="+name+"\nCentre="+centre.toString()+"\ndataDir="+dataDir+"\nlastSyncOC="+
 		     last_sync_opencaching+"\ndistOC="+distOC;



From salzkammergut at mail.berlios.de  Mon Feb  5 00:35:28 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Mon, 5 Feb 2007 00:35:28 +0100
Subject: [Cachewolf-svn] r512 - trunk/src/CacheWolf
Message-ID: <200702042335.l14NZSKV005656@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-05 00:35:16 +0100 (Mon, 05 Feb 2007)
New Revision: 512

Modified:
   trunk/src/CacheWolf/CalcPanel.java
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/myTableControl.java
   trunk/src/CacheWolf/myTableModel.java
Log:
MainTab/DetailsPanel: Bugfix (diverse nullPointerExceptions) und Vereinfachung
Neuangelegte Wegpunkte werden sofort gespeichert
TODO: Weitere Verbesserungen DetailsPanel fuer Addi Behandlung

Modified: trunk/src/CacheWolf/CalcPanel.java
===================================================================
--- trunk/src/CacheWolf/CalcPanel.java	2007-02-04 22:46:00 UTC (rev 511)
+++ trunk/src/CacheWolf/CalcPanel.java	2007-02-04 23:35:16 UTC (rev 512)
@@ -44,7 +44,6 @@
 	// Needed for creation of new waypoint
 	Vector cacheDB;
 	MainTab mainT;
-	DetailsPanel detP;
 	Preferences pref;
 	Profile profile;
 	// different panels to avoid spanning
@@ -55,8 +54,13 @@
 	int currFormat;
 	mButton btnChangeLatLon;
 	
-	public CalcPanel()
-	{
+	public CalcPanel()	{
+		pref = Global.getPref();
+		profile=Global.getProfile();
+		mainT = Global.mainTab;
+		cacheDB = profile.cacheDB;
+		
+		
 		TopP.addNext(chkDD =new mCheckBox("d.d?"),CellConstants.DONTSTRETCH, CellConstants.WEST);
 		TopP.addNext(chkDMM =new mCheckBox("d?m.m\'"),CellConstants.DONTSTRETCH, CellConstants.WEST);
 		TopP.addNext(chkDMS =new mCheckBox("d?m\'s\""),CellConstants.DONTSTRETCH,CellConstants.WEST);
@@ -113,13 +117,8 @@
 		return;
 	}
 	
-	public void setFields(CacheHolder ch, MainTab mt,DetailsPanel dp, Preferences p, Profile prof){
-		pref = p;
-		profile=prof;
-		mainT = mt;
-		detP = dp;
-		cacheDB = profile.cacheDB;
-		
+	// ch must be not null
+	public void setFields(CacheHolder ch){
 		currFormat = CWPoint.DMM;
 		if (ch.LatLon.length()== 0) coordInp.set(0,0);
 		else coordInp.set(ch.LatLon, CWPoint.CW);
@@ -161,7 +160,7 @@
 				coordOut = coordInp.project(bd.degrees, bd.distance);
 				ch.LatLon = coordOut.toString();
 				ch.pos.set(coordOut);
-				detP.newWaypoint(ch, mainT);
+				mainT.newWaypoint(ch);
 			}
 			
 			if (ev.target == btnGoto){

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-02-04 22:46:00 UTC (rev 511)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-02-04 23:35:16 UTC (rev 512)
@@ -9,122 +9,117 @@
 /**
 *	Class to create the panel to show the cache details.<br>
 *	Also allows for creation of a custom waypoint.<br>
-*	Class ID = 300
+*
+*   
 */
 public class DetailsPanel extends CellPanel{
-	mInput wayPoint = new mInput();
-	mInput wayName = new mInput();
+	mInput inpWaypoint = new mInput();
+	mInput inpName = new mInput();
 	mButton btnWayLoc = new mButton();
-	mInput wayHidden = new mInput();
-	mInput wayOwner = new mInput();
-	//mInput wayStatus = new mInput();
-	
-	mButton btnDelete,btnCenter, addDateTime;
-	mChoice wayType = new mChoice(new String[]{"Custom", "Traditional", "Multi", "Virtual", "Letterbox", "Event", "Mega Event", "Mystery", "Webcam", "Locationless", "CITO", "Earthcache", "Parking", "Stage", "Question", "Final","Trailhead","Reference"},0);
-	mChoice waySize = new mChoice(new String[]{"", "Micro", "Small", "Regular", "Large","Other","Very Large","None"},0);
-	mComboBox wayStatus = new mComboBox(new String[]{"", MyLocale.getMsg(313,"Flag 1"), MyLocale.getMsg(314,"Flag 2"), MyLocale.getMsg(315,"Flag 3"), MyLocale.getMsg(316,"Flag 4"), MyLocale.getMsg(317,"Search"), MyLocale.getMsg(318,"Found"), MyLocale.getMsg(319,"Not Found"), MyLocale.getMsg(320,"Owner")},0);
-	mButton btCrWp, showBug, showMap, btnGoto, addPicture, btnBlack, btNotes;
+	mInput inpHidden = new mInput();
+	mInput inpOwner = new mInput();
+	mButton btnDelete,btnCenter, btnAddDateTime;
+	mChoice chcType = new mChoice(new String[]{"Custom", "Traditional", "Multi", "Virtual", "Letterbox", "Event", "Mega Event", "Mystery", "Webcam", "Locationless", "CITO", "Earthcache", "Parking", "Stage", "Question", "Final","Trailhead","Reference"},0);
+	mChoice chcSize = new mChoice(new String[]{"", "Micro", "Small", "Regular", "Large","Other","Very Large","None"},0);
+	mComboBox chcStatus = new mComboBox(new String[]{"", MyLocale.getMsg(313,"Flag 1"), MyLocale.getMsg(314,"Flag 2"), MyLocale.getMsg(315,"Flag 3"), MyLocale.getMsg(316,"Flag 4"), MyLocale.getMsg(317,"Search"), MyLocale.getMsg(318,"Found"), MyLocale.getMsg(319,"Not Found"), MyLocale.getMsg(320,"Owner")},0);
+	mButton btnNewWpt, btnShowBug, btnShowMap, btnGoto, btnAddPicture, btnBlack, btnNotes, btnSave, btnCancel;
 	Vector cacheDB;
 	CacheHolder thisCache;
-	CellPanel toolP = new CellPanel();
-	public boolean dirty_notes = false;
-	public boolean dirty_details = false;
-	public boolean dirty_newOrDelete = false;
-	public boolean dirty_delete = false;
-	public boolean dirty_status = false;
-	boolean newWp = false;
-	public boolean blackStatus = false;
-	MainTab mainT;
+	CellPanel pnlTools = new CellPanel(); 
+	
+	private boolean dirty_notes = false;
+	private boolean dirty_details = false;
+	private boolean blackStatus = false;
 	Preferences pref; // Test
 	Profile profile;
 	mImage mIsBlack;
 	mImage mNoBlack;
 	
 	public DetailsPanel(){
-		//String welcomeMessage = MyLocale.getMsg(1,"how about that?");
-		
-		toolP.addNext(btCrWp = new mButton(MyLocale.getMsg(311,"Create Waypoint")),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		toolP.addNext(btnGoto = new mButton("Goto"),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		pref = Global.getPref();
+		profile=Global.getProfile();
+		cacheDB = profile.cacheDB;
+		////////////////////
+		// Tools
+		////////////////////
+		pnlTools.addNext(btnNewWpt = new mButton(MyLocale.getMsg(311,"Create Waypoint")),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		pnlTools.addNext(btnGoto = new mButton("Goto"),CellConstants.DONTSTRETCH, CellConstants.WEST);
 		mImage mI = new mImage("bug.gif");
 		mImage mI2 = new mImage("globe_small.gif");
 		
 		mImage mI4 = new mImage("images.gif");
 		mNoBlack = new mImage("no_black.png");
 		mIsBlack = new mImage("is_black.png");
-		showBug = new mButton((IImage)mI);
-		showMap = new mButton((IImage)mI2);
+		btnShowBug = new mButton((IImage)mI);
+		btnShowMap = new mButton((IImage)mI2);
 		
-		addDateTime = new mButton((IImage)new mImage("date_time.png"));
-		addPicture = new mButton((IImage)mI4);
+		btnAddDateTime = new mButton((IImage)new mImage("date_time.png"));
+		btnAddPicture = new mButton((IImage)mI4);
 		btnBlack = new mButton((IImage)mNoBlack);
-		toolP.addNext(showBug,CellConstants.DONTSTRETCH, CellConstants.WEST);
-		showBug.modify(Control.Disabled,0);
-		toolP.addNext(showMap,CellConstants.DONTSTRETCH, CellConstants.WEST);
-		toolP.addNext(addPicture,CellConstants.DONTSTRETCH, CellConstants.WEST);
-		toolP.addNext(btnBlack,CellConstants.DONTSTRETCH, CellConstants.WEST);
-		toolP.addLast(addDateTime,CellConstants.DONTSTRETCH, CellConstants.WEST);
+		pnlTools.addNext(btnShowBug,CellConstants.DONTSTRETCH, CellConstants.WEST);
+		btnShowBug.modify(Control.Disabled,0);
+		pnlTools.addNext(btnShowMap,CellConstants.DONTSTRETCH, CellConstants.WEST);
+		pnlTools.addNext(btnAddPicture,CellConstants.DONTSTRETCH, CellConstants.WEST);
+		pnlTools.addNext(btnBlack,CellConstants.DONTSTRETCH, CellConstants.WEST);
+		pnlTools.addLast(btnAddDateTime,CellConstants.DONTSTRETCH, CellConstants.WEST);
 		//showMap.modify(Control.Disabled,0);
-		this.addLast(toolP,CellConstants.DONTSTRETCH, CellConstants.WEST).setTag(SPAN,new Dimension(3,1));;
+		this.addLast(pnlTools,CellConstants.DONTSTRETCH, CellConstants.WEST).setTag(SPAN,new Dimension(3,1));;
 		
+		////////////////////
+		// Main body of screen
+		////////////////////
+
 		this.addNext(new mLabel(MyLocale.getMsg(300,"Type:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTHWEST));
-		this.addLast(wayType,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		this.addLast(chcType,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		this.addNext(new mLabel(MyLocale.getMsg(301,"Size:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		this.addLast(waySize,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		this.addLast(chcSize,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		
 		this.addNext(new mLabel(MyLocale.getMsg(302,"Waypoint:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		this.addLast(wayPoint.setTag(Control.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		this.addLast(inpWaypoint.setTag(Control.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		
 		this.addNext(new mLabel(MyLocale.getMsg(303,"Name:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		this.addLast(wayName.setTag(Control.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		this.addLast(inpName.setTag(Control.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		
 		this.addNext(new mLabel(MyLocale.getMsg(304,"Location:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		this.addLast(btnWayLoc.setTag(Control.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		
 		this.addNext(new mLabel(MyLocale.getMsg(305,"Hidden on:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		this.addLast(wayHidden.setTag(Control.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		this.addLast(inpHidden.setTag(Control.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		
 		this.addNext(new mLabel(MyLocale.getMsg(306,"Owner:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		this.addLast(wayOwner.setTag(Control.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		this.addLast(inpOwner.setTag(Control.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		
 		this.addNext(new mLabel(MyLocale.getMsg(307,"Status:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		this.addLast(wayStatus.setTag(Control.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		this.addLast(chcStatus.setTag(Control.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		
-		btNotes = new mButton("Notes");
-		this.addLast(btNotes.setTag(Control.SPAN, new Dimension(3,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		btnNotes = new mButton("Notes");
+		this.addLast(btnNotes.setTag(Control.SPAN, new Dimension(3,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		//this.addNext(new mLabel(MyLocale.getMsg(308,"Notes:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		//this.addLast(btnCenter = new mButton(MyLocale.getMsg(309,"Make Center")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 //		this.addLast(btnDelete = new mButton(MyLocale.getMsg(310,"Delete")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		
 	}
 	
+	public boolean isDirty() {
+		return dirty_notes || dirty_details;
+	}
+	
+	
 	/**
 	*	Set the values to display.
 	*/
-	public void setDetails(CacheHolder ch, MainTab mt){
-		if (this.newWp){
-			this.newWp = false;
-			btCrWp.setText(MyLocale.getMsg(312,"Save"));
-			return;
-		}
-		else {
-			btCrWp.setText(MyLocale.getMsg(311,"Create Waypoint"));
-		}
-		pref = Global.getPref();
-		profile=Global.getProfile();
-		mainT = mt;
-		cacheDB = profile.cacheDB;
+	public void setDetails(CacheHolder ch){
 		thisCache = ch;
 		dirty_notes = false;
 		dirty_details = false;
-		dirty_newOrDelete = false; // Cache has been created/deleted but not saved
-		wayPoint.setText(ch.wayPoint);
-		wayName.setText(ch.CacheName);
+		inpWaypoint.setText(ch.wayPoint);
+		inpName.setText(ch.CacheName);
 	    btnWayLoc.setText(ch.pos.toString());
-		wayHidden.setText(ch.DateHidden);
-		wayOwner.setText(ch.CacheOwner);
-		wayStatus.setText(ch.CacheStatus);
+		inpHidden.setText(ch.DateHidden);
+		inpOwner.setText(ch.CacheOwner);
+		chcStatus.setText(ch.CacheStatus);
 		
-		wayType.setInt(transType(ch.type));
+		chcType.setInt(transType(ch.type));
 		if(ch.is_black){
 			btnBlack.image = mIsBlack;
 		} else {
@@ -133,57 +128,25 @@
 		blackStatus=ch.is_black; 
 		btnBlack.repaintNow();
 		if(ch.has_bug == true) {
-			showBug.modify(Control.Disabled,1);
+			btnShowBug.modify(Control.Disabled,1);
 		} else {
-			showBug.modify(Control.Disabled,0);
+			btnShowBug.modify(Control.Disabled,0);
 		}
-		showBug.repaintNow();
-		if(ch.CacheSize.equals("Micro")) waySize.setInt(1);
-		if(ch.CacheSize.equals("Small")) waySize.setInt(2);
-		if(ch.CacheSize.equals("Regular")) waySize.setInt(3);
-		if(ch.CacheSize.equals("Large")) waySize.setInt(4);
-		if(ch.CacheSize.equals("Other")) waySize.setInt(5);
-		if(ch.CacheSize.equals("Very Large")) waySize.setInt(6);
-		if(ch.CacheSize.equals("None")) waySize.setInt(7);
-		if(ch.CacheSize.equals("Not chosen")) waySize.setInt(7);
+		btnShowBug.repaintNow();
+		if(ch.CacheSize.equals("Micro")) chcSize.setInt(1);
+		if(ch.CacheSize.equals("Small")) chcSize.setInt(2);
+		if(ch.CacheSize.equals("Regular")) chcSize.setInt(3);
+		if(ch.CacheSize.equals("Large")) chcSize.setInt(4);
+		if(ch.CacheSize.equals("Other")) chcSize.setInt(5);
+		if(ch.CacheSize.equals("Very Large")) chcSize.setInt(6);
+		if(ch.CacheSize.equals("None")) chcSize.setInt(7);
+		if(ch.CacheSize.equals("Not chosen")) chcSize.setInt(7);
 
-		if(ch.is_found == true) wayStatus.setText(MyLocale.getMsg(318,"Found"));
+		if(ch.is_found == true) chcStatus.setText(MyLocale.getMsg(318,"Found"));
 	}
 	
-	private String getNewWayPointName(Vector DB){
-		String strWp=null;
-		long  lgWp=1;
-		//Create new waypoint,look if not in db
-		for(int i = 0;i < DB.size();i++){
-			strWp = "CW" + MyLocale.formatLong(lgWp, "0000");
-			if(((CacheHolder)DB.get(i)).wayPoint.indexOf(strWp) >=0 ){
-				//waypoint exists in database
-				lgWp++;
-				i = -1; // Because i++ will be executed next, so we start the loop with 0
-			}
-		}
-		return strWp;
-	}
 	
 	/**
-	 * this is called from goto / MovingMap and so on to 
-	 * offer the user the possibility of entering an new waypoint
-	 * at a given position
-	 * 
-	 * @param ch
-	 * @param mt
-	 */
-	public void newWaypoint(CacheHolder ch, MainTab mt){
-		this.profile = Global.getProfile();
-		ch.wayPoint = getNewWayPointName(profile.cacheDB);
-		ch.type = "0";
-		ch.CacheSize = "None";
-		setDetails(ch, mt);
-		this.newWp = true;
-		cacheDB.add(thisCache);
-		mt.select(this);
-	}
-	/**
 	*	Translate the cache type to the value in the cache type dropdown
 	*	control.
 	*/
@@ -252,50 +215,20 @@
 		return ret;
 	}
 	
-	private void saveWpt() {
-		//Vm.debug("Sollte speichern");
-		//CacheHolder ch = new CacheHolder();
-		thisCache.wayPoint = wayPoint.getText();
-		thisCache.CacheName = wayName.getText();
-		thisCache.pos = new CWPoint(btnWayLoc.getText(),CWPoint.REGEX);
-		thisCache.LatLon = thisCache.pos.toString();
-		thisCache.DateHidden = wayHidden.getText();
-		thisCache.CacheOwner = wayOwner.getText();
-		thisCache.CacheStatus = wayStatus.getText();
-		thisCache.type = transSelect(wayType.getInt());
-		//cacheDB.add(ch);
-		
-		if(thisCache.CacheNotes.length()>0){
-			thisCache.saveCacheDetails(profile.dataDir);
-		}
-		
-		profile.buildReferences();
-		dirty_newOrDelete = true;
-		mainT.selectAndActive(cacheDB.size()-1);
-	}
-	
 	/**
 	*	Method to react to a user input.
 	*/
 	public void onEvent(Event ev){
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.FOCUS_OUT){
-			dirty_status = true;
+		if (ev instanceof DataChangeEvent ) {
+			dirty_details = true;
 		}
-		/**
-		*	User changed status.
-		*/
-		/**
-		*	User wishes to either delete a cache or to set the cache as
-		*	a center location.<br>
-		*	Also possible: the user created a custom waypoint.
-		*/
 		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			
-			if(ev.target == btNotes){
+			if(ev.target == btnNotes){
+				dirty_notes=true;
 				NotesScreen nsc = new NotesScreen(thisCache);
 				nsc.execute(this.getFrame(), Gui.CENTER_FRAME);
 			}
-			if(ev.target == showMap){
+			else if(ev.target == btnShowMap){
 				try {
 					MapDetailForm mdf = new MapDetailForm(thisCache.wayPoint, pref, profile);
 					mdf.execute();
@@ -304,21 +237,22 @@
 					tmp.exec();
 				}
 			}
-			if(ev.target == showBug){
+			else if(ev.target == btnShowBug){
 				InfoScreen is = new InfoScreen(thisCache.Bugs, "Travelbugs", false, pref);
 				is.execute();
 			}
-			if (ev.target == btnCenter){
+			else if (ev.target == btnCenter){
 				CWPoint cp=new CWPoint(thisCache.LatLon);
 				if (!cp.isValid()){
 					MessageBox tmpMB = new MessageBox(MyLocale.getMsg(312,"Error"), MyLocale.getMsg(4111,"Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"), MessageBox.OKB);
 					tmpMB.exec();
 				} else {				
 					pref.curCentrePt.set(cp);
-					mainT.updateBearDist();
+					Global.mainTab.updateBearDist();
 				}
 			}
-			if (ev.target == addDateTime){
+			else if (ev.target == btnAddDateTime){
+				dirty_notes=true;
 				String note = thisCache.CacheNotes;
 				Time dtm = new Time();
 				dtm.getTime();
@@ -329,10 +263,10 @@
 				thisCache.CacheNotes = note;
 				thisCache.saveCacheDetails( Global.getProfile().dataDir);
 			}
-			if (ev.target == addPicture){
+			else if (ev.target == btnAddPicture){
 				thisCache.addUserImage(profile);
 			}
-			if(ev.target == btnBlack){
+			else if(ev.target == btnBlack){
 				if(thisCache.is_black) {
 					thisCache.is_black = false;
 					btnBlack.image = mNoBlack;
@@ -344,41 +278,57 @@
 				blackStatus = thisCache.is_black;
 				btnBlack.repaintNow();
 			}
-			if (ev.target == btCrWp){
-				if(btCrWp.getText().equals(MyLocale.getMsg(312,"Save"))){
-					saveWpt();
-				}
-				if(btCrWp.getText().equals(MyLocale.getMsg(311,"Create Waypoint"))){
-					thisCache = new CacheHolder();
-					dirty_newOrDelete = true;
-					wayPoint.setText(getNewWayPointName(cacheDB));
-					wayName.setText("");
-					btnWayLoc.setText("N hh dd.mmm E hh dd.mmm");
-					wayHidden.setText("");
-					wayOwner.setText("");
-					wayStatus.setText("");
-					wayType.setInt(0);
-					waySize.setInt(7);
-					thisCache.wayPoint = wayPoint.getText();
-					cacheDB.add(thisCache);
-				}
-				if(btCrWp.getText().equals(MyLocale.getMsg(312,"Save"))) btCrWp.setText(MyLocale.getMsg(311,"Create Waypoint"));
-				else btCrWp.setText(MyLocale.getMsg(312,"Save"));
+			else if (ev.target == btnNewWpt){
+				Global.mainTab.newWaypoint(new CacheHolder());
 			}
-			if (ev.target == btnGoto){
+			else if (ev.target == btnGoto){
 				// TODO if something changed saveWpt();
-				mainT.gotoPoint(thisCache.LatLon);
+				Global.mainTab.gotoPoint(thisCache.LatLon);
 			}
-			if (ev.target == btnWayLoc){
+			else if (ev.target == btnWayLoc){
 				CWPoint coords = new CWPoint(btnWayLoc.getText(),CWPoint.CW);
 				CoordsScreen cs = new CoordsScreen();
 				cs.setFields(coords, CWPoint.CW);
 				if (cs.execute()== CoordsScreen.IDOK){
 					coords = cs.getCoords();
+					thisCache.pos.set(coords);
 					btnWayLoc.setText(coords.toString());
 				}
 			}
-
+			ev.consumed=true;
 		}
 	}
+	
+	public void saveDirtyWaypoint() {
+		CacheHolder ch;
+		  ch = (CacheHolder)cacheDB.get(Global.mainTab.tbP.getSelectedCache());
+		  ch.CacheStatus = chcStatus.getText();
+		  ch.is_found = ch.CacheStatus.equals(MyLocale.getMsg(318,"Found"));
+		  ch.is_black = blackStatus;
+		  ch.wayPoint = inpWaypoint.getText().trim();
+		  ch.CacheName = inpName.getText().trim();
+		  ch.LatLon = new CWPoint(btnWayLoc.getText(),CWPoint.CW).toString();
+		  ch.DateHidden = inpHidden.getText().trim();
+		  ch.CacheOwner = inpOwner.getText().trim();
+		  ch.is_owned = pref.myAlias.equals(ch.CacheOwner);
+		  ch.type = transSelect(chcType.getInt());
+		  if (CacheType.isAddiWpt(ch.type)) 
+			  profile.buildReferences();
+		  // set status also on addi wpts
+		  if (ch.hasAddiWpt()){
+			  CacheHolder addiWpt;
+			  for (int i=0;i<ch.addiWpts.getCount();i++){
+				  addiWpt = (CacheHolder)ch.addiWpts.get(i);
+				  addiWpt.CacheStatus = ch.CacheStatus;
+				  addiWpt.is_found = ch.is_found;
+				  addiWpt.is_owned = ch.is_owned;
+			  }
+		  }
+		  if (dirty_notes) ch.saveCacheDetails(profile.dataDir);
+		  dirty_notes=false;
+		  dirty_details=false;
+		  
+		  Global.mainTab.tbP.refreshTable();
+		  ////Vm.debug("New status updated!");
+	}
 }

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-02-04 22:46:00 UTC (rev 511)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-02-04 23:35:16 UTC (rev 512)
@@ -616,7 +616,7 @@
 				CacheHolder ch = new CacheHolder();
 				ch.LatLon = gpsPosition.toString();
 				ch.pos = new CWPoint(gpsPosition);
-				detP.newWaypoint(ch,mainT);
+				mainT.newWaypoint(ch);
 			}
 			// change destination waypoint
 			if (ev.target == btnGoto){

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-02-04 22:46:00 UTC (rev 511)
+++ trunk/src/CacheWolf/MainMenu.java	2007-02-04 23:35:16 UTC (rev 512)
@@ -206,6 +206,7 @@
 			if(mev.selectedItem == mnuOpenProfile){
 				if (pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_FORCED_ON,false)) {
 					profile.cacheDB.clear();
+					tbp.setSelectedCache(-1);
 					profile.readIndex();
 					pref.curCentrePt.set(profile.centre);
 					filtBlack.modifiers&=~MenuItem.Checked;

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-02-04 22:46:00 UTC (rev 511)
+++ trunk/src/CacheWolf/MainTab.java	2007-02-04 23:35:16 UTC (rev 512)
@@ -1,5 +1,6 @@
 package CacheWolf;
 
+import ewe.sys.Vm;
 import ewe.ui.*;
 import ewe.fx.*;
 import ewe.util.*;
@@ -16,9 +17,9 @@
 	DescriptionPanel descP= new DescriptionPanel();
 	HintLogPanel hintLP = new HintLogPanel();
 	TablePanel tbP;
-	Vector cDB;
+	Vector cacheDB;
 	DetailsPanel detP = new DetailsPanel();
-	CalcPanel calcP = new CalcPanel();
+	CalcPanel calcP;
 	Preferences pref;
 	Profile profile;
 	GotoPanel gotoP; 
@@ -26,7 +27,7 @@
 	ImagePanel imageP;
 	SolverPanel solverP;
 	String lastselected = new String();
-	CacheHolder ch = new CacheHolder();
+	CacheHolder ch =null;
 	MainMenu mnuMain;
 	
 	public MainTab(MainMenu mainMenu,StatusBar statBar){
@@ -35,12 +36,11 @@
 		pref = Global.getPref();
 		profile=Global.getProfile();
 		if (!pref.tabsAtTop) tabLocation=SOUTH;
-		cDB = profile.cacheDB;
+		cacheDB = profile.cacheDB;
 		MyLocale.setSIPButton();
-		ch.wayPoint = "null";
 		//Don't expand tabs if the screen is very narrow, i.e. HP IPAQ 65xx, 69xx
 		if (MyLocale.getScreenWidth() <= 240) this.dontExpandTabs=true;
-
+		calcP = new CalcPanel(); // Init here so that Global.MainT is already set
 		Card c = this.addCard(tbP = new TablePanel(pref, profile, statBar), MyLocale.getMsg(1200,"List"), null);
 		
 		c = this.addCard(detP, MyLocale.getMsg(1201,"Details"), null);
@@ -80,16 +80,49 @@
 		this.selectAndExpand(0);
 	}
 	
+	/** Update the distances of all caches to the center and display a message 
+	 */
 	public void updateBearDist(){
 		tbP.pref = pref;
 		profile.updateBearingDistance();
 		tbP.refreshTable();
+		(new MessageBox(MyLocale.getMsg(327,"Information"), MyLocale.getMsg(1024,"Entfernungen in der Listenansicht \nvom aktuellen Standpunkt aus \nneu berechnet").replace('~','\n'), MessageBox.OKB)).execute();
 	}
 	
 	public void gotoPoint(String LatLon) {
 		gotoP.setDestinationAndSwitch(LatLon);
 	}
+
+	public void openDesciptionPanel(CacheHolder chi) {
+        MyLocale.setSIPOff();
+        descP.setText(chi);
+    }
 	
+	
+	/**
+	 * this is called from goto / MovingMap / CalcPanel and so on to 
+	 * offer the user the possibility of entering an new waypoint
+	 * at a given position. ch must already been preset with a valid
+	 * CacheHolder object
+	 * 
+	 * @param ch
+	 */
+	public void newWaypoint(CacheHolder ch){
+		if (detP.isDirty()) detP.saveDirtyWaypoint();
+		String waypoint= ch.wayPoint = profile.getNewWayPointName();
+		ch.type = "0";
+		ch.CacheSize = "None";
+		cacheDB.add(ch);
+		Global.mainTab.tbP.myMod.updateRows();
+		Global.mainTab.tbP.setSelectedCache(profile.getCacheIndex(waypoint));
+		//Global.mainTab.tbP.refreshTable();
+		if (this.cardPanel.selectedItem==1) { // Detailpanel already selected
+			postEvent(new MultiPanelEvent(MultiPanelEvent.SELECTED,detP,0));
+		} else	
+			select(detP);
+	}
+	
+	
 	public void onEvent(Event ev)
 		{
 		  ////Vm.debug(ev.toString());
@@ -101,130 +134,74 @@
 //				  Vm.setSIP(0);
 				  MyLocale.setSIPOff();
 			  }
-			  //if(this.getSelectedItem() == 0){
-				  //Vm.debug(Convert.toString(cDB.size()));
-				  //Vm.debug("Panel 0");
-				  if(detP.dirty_newOrDelete) {
-					  tbP.refreshTable();
-					  //Vm.debug("Panel 0.1");
-					  detP.dirty_newOrDelete = false;
-					  detP.dirty_status = false;
-				  }
-				  if(detP.dirty_status == true){ // Details were edited
-					  //Vm.debug("Panel 0.2");
-					  ch = (CacheHolder)cDB.get(tbP.getSelectedCache());
-					  ch.CacheStatus = detP.wayStatus.getText();
-					  ch.is_found = ch.CacheStatus.equals(MyLocale.getMsg(318,"Found"));
-					  ch.is_black = detP.blackStatus;
-					  ch.wayPoint = detP.wayPoint.getText();
-					  ch.CacheName = detP.wayName.getText();
-					  ch.pos.set(detP.btnWayLoc.getText(),CWPoint.CW);
-					  ch.LatLon = ch.pos.toString();
-					  ch.DateHidden = detP.wayHidden.getText();
-					  ch.CacheOwner = detP.wayOwner.getText();
-					  if(pref.myAlias.equals(ch.CacheOwner)) ch.is_owned = true;
-					  
-					  ch.type = detP.transSelect(detP.wayType.getInt());
-					  // set status also on addi wpts
-					  if (ch.hasAddiWpt()){
-						  CacheHolder addiWpt;
-						  for (int i=0;i<ch.addiWpts.getCount();i++){
-							  addiWpt = (CacheHolder)ch.addiWpts.get(i);
-							  addiWpt.CacheStatus = ch.CacheStatus;
-							  addiWpt.is_found = ch.is_found;
-							  addiWpt.is_owned = ch.is_owned;
+			  if(detP.isDirty()) {
+				  detP.saveDirtyWaypoint();
+			  }
+			  if(this.getSelectedItem() != 0){
+				  if (tbP.getSelectedCache()>=cacheDB.size())
+					  ch=null;
+				  else {
+					  ch = (CacheHolder)cacheDB.get(tbP.getSelectedCache());
+					  try {
+						  if(ch.wayPoint.equals(lastselected) == false){
+							  ch.readCache(profile.dataDir);
+							  lastselected = ch.wayPoint;
 						  }
+					  } catch(Exception e){
+						//Vm.debug("Error loading: "+ch.wayPoint);
 					  }
-					  cDB.set(tbP.getSelectedCache(), ch);
-					  detP.dirty_status = false;
-					  tbP.refreshTable();
-					  ////Vm.debug("New status updated!");
 				  }
-			  //}
-			  if(this.getSelectedItem() != 0){
-				  try{
-					  ch = (CacheHolder)cDB.get(tbP.getSelectedCache());
-					  if(ch.wayPoint.equals(lastselected) == false){
-						  //OperationTimer opt = new OperationTimer();
-						  //opt.start("Reading: ");
-						  ch.readCache(profile.dataDir);
-						  //opt.end();
-						  ////Vm.debug(opt.toString());
-						  lastselected = ch.wayPoint;
+			  }
+			  // If no cache is selected, create a new one
+			  switch (this.getSelectedItem()) {
+				  case 1:  // DetailsPanel
+					  if (ch==null) newWaypoint(ch=new CacheHolder());
+					  MyLocale.setSIPButton();
+					  detP.setDetails(ch);
+				      break;
+				  case 2: // Description Panel
+					  if (ch!=null) {
+						  MyLocale.setSIPOff();
+						  descP.setText(ch);
 					  }
-				  } catch(Exception e){
-					//Vm.debug("Error loading: "+ch.wayPoint);
-				  }
+					  break;
+				  case 3: // Picture Panel
+					  if (ch!=null) {
+						  MyLocale.setSIPOff();
+						  imageP.setImages(ch);
+					  }
+					  break;
+				  case 4:  // Log Hint Panel
+					  if (ch!=null) {
+						  MyLocale.setSIPOff();
+						  hintLP.setText(ch);
+					  }
+					  break;
+				  case 5:  // CalcPanel
+					  if (ch!=null) {
+						  MyLocale.setSIPButton();
+						  calcP.setFields(ch);
+					  }
+					  break;
+				  
+				  case 6: // GotoPanel
+					  MyLocale.setSIPButton();
+				      break;
+				  case 7:  // Solver Panel
+					  MyLocale.setSIPButton();
+					  solverP.setCh(ch);
+				      break;
+				  case 8:  // Cache Radar Panel
+					  MyLocale.setSIPOff();
+					  radarP.setParam(pref, cacheDB, ch==null?"":ch.wayPoint);
+					  radarP.drawThePanel();
+				      break;
 			  }
-			  if(this.getSelectedItem() == 1){ // DetailsPanel
-				  MyLocale.setSIPButton();
-				  detP.setDetails(ch, this);
-			  }
-			  if(this.getSelectedItem() == 2) { // Description Panel
-				  openDesciptionPanel(ch);
-			  }
-			  if(this.getSelectedItem() == 3) { // Picture Panel
-				  MyLocale.setSIPOff();
-				  imageP.setImages(ch);
-				  if(detP.dirty_newOrDelete) {
-					  tbP.refreshTable();
-					  detP.dirty_newOrDelete = false;
-				  }
-			  }
-			  if(this.getSelectedItem() == 4) { // Log Hint Panel
-				  MyLocale.setSIPOff();
-				  hintLP.setText(ch);
-				  if(detP.dirty_newOrDelete) {
-					  tbP.refreshTable();
-					  detP.dirty_newOrDelete = false;
-				  }
-			  }
-			  if(this.getSelectedItem() == 5){ // CalcPanel
-				  MyLocale.setSIPButton();
-				  calcP.setFields(ch, this, detP, pref, profile);
-				  //calcP.activateFields(CWPoint.DMM);
-				  }
-			  
-			  if(this.getSelectedItem() == 6){ // GotoPanel
-				  MyLocale.setSIPButton();
-				  }
-
-
-			  if(this.getSelectedItem() == 7) { // Solver Panel
-				  MyLocale.setSIPButton();
-				  solverP.setCh(ch);
-				  if(detP.dirty_newOrDelete) {
-					  tbP.refreshTable();
-					  detP.dirty_newOrDelete = false;
-				  }
-			  }
-			  if(this.getSelectedItem() == 8) { // Cache Radar Panel
-				  MyLocale.setSIPOff();
-				  if(detP.dirty_newOrDelete) {
-					  //tbP.refreshTable();
-					  detP.dirty_newOrDelete = false;
-				  }
-				  radarP.setParam(pref, cDB, ch.wayPoint);
-				  radarP.drawThePanel();
-			  }
-		  }
-		  
-		  super.onEvent(ev); //Make sure you call this.
 		}
-		
-		/*
-		public void resizeTo(int w, int h){
-			//super.resizeTo(w,h);
-			////Vm.debug(Convert.toString(w));
-		}
-		*/
-	public void openDesciptionPanel(CacheHolder chi) {
-		MyLocale.setSIPOff();
-		descP.setText(chi);
-		if(detP.dirty_newOrDelete) {
-			tbP.refreshTable();
-			detP.dirty_newOrDelete = false;
-		}
+		  super.onEvent(ev); //Make sure you call this.
 	}
+
+	
+	
 }
 

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-04 22:46:00 UTC (rev 511)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-04 23:35:16 UTC (rev 512)
@@ -1542,7 +1542,7 @@
 						mm.postEvent(close);
 						CacheHolder newWP = new CacheHolder();
 						newWP.pos = mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y);
-						mm.gotoPanel.mainT.detP.newWaypoint(newWP, mm.gotoPanel.mainT);
+						mm.gotoPanel.mainT.newWaypoint(newWP);
 
 					}
 

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-02-04 22:46:00 UTC (rev 511)
+++ trunk/src/CacheWolf/myTableControl.java	2007-02-04 23:35:16 UTC (rev 512)
@@ -168,20 +168,8 @@
 	}
 	
 	public void penDoubleClicked(Point where) {
-		//Global.mainTab.select(Global.mainTab.descP);
-		openCacheDesc();
+		Global.mainTab.select(Global.mainTab.descP);
 	}
 
-	void openCacheDesc() {
-			CacheHolder ch;
-			ch = (CacheHolder)tbp.cacheDB.get(tbp.getSelectedCache());
-			try{
-				ch.readCache(profile.dataDir);
-			}catch(IOException ex){	
-				(new MessageBox("Error", "Cannot read cache data\n"+ex.toString()+"\n in cache: "+ch.wayPoint,MessageBox.OKB)).execute(); 
-			}
-			tbp.myMaintab.select(tbp.myMaintab.descP);
-		
-	}
 	
 }

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-02-04 22:46:00 UTC (rev 511)
+++ trunk/src/CacheWolf/myTableModel.java	2007-02-04 23:35:16 UTC (rev 512)
@@ -322,7 +322,7 @@
 					}
 					
 				}
-				updateRows();
+				//updateRows();
 				// Don't consume the event. Why ?
 			}
 			if(cell.y == -1){



From pfeffer at mail.berlios.de  Mon Feb  5 03:46:19 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Mon, 5 Feb 2007 03:46:19 +0100
Subject: [Cachewolf-svn] r513 - in trunk: resources src/CacheWolf
Message-ID: <200702050246.l152kJxH016874@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-05 03:46:11 +0100 (Mon, 05 Feb 2007)
New Revision: 513

Added:
   trunk/resources/mark_cache.png
   trunk/src/CacheWolf/Navigate.java
Modified:
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/myTableModel.java
Log:
MovingMap / Goto: einige Code umstrukturierungen
DetailsPanel: gr?\195?\188ne Weltkugel ?\195?\182ffnet jetzt kalibrierte Karte und markiiert den gew?\195?\164hlten Cache mit einem blauen Rechteck
MovingMap: manuelle Ma?\195?\159stabswahl, wurde recht schnell wieder automatisch ?\195?\188berschrieben
MovingMap: jetz sollte die Karte auch bei langsamen Bewegungen upgedated werden

Added: trunk/resources/mark_cache.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/mark_cache.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-02-04 23:35:16 UTC (rev 512)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-02-05 02:46:11 UTC (rev 513)
@@ -229,14 +229,15 @@
 				nsc.execute(this.getFrame(), Gui.CENTER_FRAME);
 			}
 			else if(ev.target == btnShowMap){
-				try {
+				Global.mainTab.SwitchToMovingMap(thisCache.pos);
+/*				try {
 					MapDetailForm mdf = new MapDetailForm(thisCache.wayPoint, pref, profile);
 					mdf.execute();
 				} catch (IllegalArgumentException e) {
 					MessageBox tmp = new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(322,"Kann Bild/Karte nicht finden")+": "+e.getMessage(), MessageBox.OKB);
 					tmp.exec();
 				}
-			}
+	*/		}
 			else if(ev.target == btnShowBug){
 				InfoScreen is = new InfoScreen(thisCache.Bugs, "Travelbugs", false, pref);
 				is.execute();

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-02-04 23:35:16 UTC (rev 512)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-02-05 02:46:11 UTC (rev 513)
@@ -14,104 +14,7 @@
 import ewe.sys.Double;
 
 
-/**
- * Thread for reading data from COM-port
- *
- */
-class SerialThread extends mThread{
-	SerialPort comSp;   
-	byte[] comBuff = new byte[1024];  
-	int comLength = 0;
-	CWGPSPoint myGPS;
-	boolean run, tcpForward;
-	Socket tcpConn;
-	String lastError = new String();
 
-	public SerialThread(SerialPortOptions spo, CWGPSPoint GPSPoint, String forwardIP) throws IOException {
-		try{
-			comSp = new SerialPort(spo);
-		} catch (IOException e) {
-			throw new IOException(spo.portName);
-		} // catch (UnsatisfiedLinkError e) {} // TODO in original java-vm 
-		if (forwardIP.length()>0) { 
-			try {
-				tcpConn = new Socket(forwardIP, 23);
-				tcpForward = true;
-			} catch (ewe.net.UnknownHostException e) { tcpForward = false; lastError = e.getMessage();
-			} catch (IOException e) { tcpForward = false; lastError = e.getMessage(); 
-			}
-		}
-		myGPS = GPSPoint;
-	}
-
-	public void run() {
-		int noData = 0;
-		int notinterpreted = 0;
-		run = true;
-		while (run){
-			try {
-				sleep(1000);
-				//Vm.debug("Loop? " + noData);
-				noData++;
-				if (noData > 5) { myGPS.noDataError(); }
-			} catch (InterruptedException e) {}
-			if (comSp != null)	{
-				comLength = comSp.nonBlockingRead(comBuff, 0 ,comBuff.length);
-				//Vm.debug("Length: " + comBuff.length);
-				if (comLength > 0)	{
-					noData = 0;
-					String str = mString.fromAscii(comBuff, 0, comLength); 
-					if (tcpForward) {
-						try {
-							tcpConn.write(comBuff, 0, comLength);
-						} catch (IOException e) { tcpForward = false; }
-					}
-					//Vm.debug(str);
-					if (myGPS.examine(str)) notinterpreted = 0; else notinterpreted++;
-					if (notinterpreted > 22) myGPS.noInterpretableData();
-				}
-			}
-		} // while
-		myGPS.noData();
-		tcpConn.close();
-	}
-
-	public void stop() {
-		run = false;
-		if (comSp != null) comSp.close();
-	}
-}
-
-/** 
- * Class for creating a new mThread to create timer ticks to be able to do form.close in the ticked-thread. 
- * Using the Vm.requestTimer-Method causes "ewe.sys.EventDirectionException: This task cannot be done within 
- * a Timer Tick." in the ewe-vm when form.close is called.  
- */
-
-class UpdateThread extends mThread {
-	public boolean run;
-	public int calldelay;
-	public GotoPanel ticked;
-
-	public UpdateThread (GotoPanel gp, int cd) {
-		ticked = gp;
-		calldelay = cd;
-	}
-
-	public void run () {
-		run = true;
-		while (run) {
-			try { sleep (calldelay);} catch (InterruptedException e) {}
-			ticked.ticked();
-		}
-	}
-
-	public void stop() {
-		run = false;
-	}
-}
-
-
 /**
  *	Class to create the panel which handles the connection to the GPS-device<br>
  *	Displays: current position,speed and bearing; relation to destination waypoint<br>
@@ -121,9 +24,9 @@
 
 public class GotoPanel extends CellPanel {
 
-	public CWGPSPoint gpsPosition = new CWGPSPoint();
-	public CWPoint toPoint = new CWPoint();
-
+	//public CWGPSPoint gpsPosition = new CWGPSPoint();
+	//public CWPoint toPoint = new CWPoint();
+	public Navigate myNavigation;
 	mButton btnGPS, btnCenter,btnSave;
 	mButton btnGoto, btnMap;
 	mCheckBox chkDMM, chkDMS, chkDD, chkUTM;
@@ -151,9 +54,6 @@
 	CellPanel GotoP = new CellPanel();
 	CellPanel LogP = new CellPanel();
 
-	SerialThread serThread;
-	UpdateThread tickerThread;
-
 	ImageControl icRose;
 	GotoRose compassRose;
 
@@ -167,12 +67,6 @@
 	GotoRose rose;
 	int ticker = 0;
 
-	boolean mapsLoaded = false;
-	public boolean runMovingMap = false;
-	MovingMap mmp;
-	Track currTrack;
-	Color trackColor = RED;
-
 	/**
 	 * Create GotoPanel 
 	 * @param Preferences 	global preferences
@@ -180,12 +74,12 @@
 	 * @param DetailsPanel 	reference to DetailsPanel
 	 * @param Vector		cacheDB
 	 */
-	public GotoPanel(Preferences p, Profile prof, MainTab mt, DetailsPanel dp)
-	{
-		pref = p;
-		profile=prof;
-		mainT = mt;
-		detP = dp;
+	public GotoPanel(Navigate nav) {
+		myNavigation = nav;
+		pref = Global.getPref();
+		profile=Global.getProfile();
+		mainT = Global.mainTab;
+		detP = mainT.detP;
 		cacheDB = profile.cacheDB;
 
 		// Button
@@ -210,7 +104,7 @@
 		//Coords
 		CoordsP.addNext(lblGPS = new mLabel("GPS: "),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		lblGPS.backGround = RED;
-		CoordsP.addLast(lblPosition = new mLabel(gpsPosition.toString(currFormat)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		CoordsP.addLast(lblPosition = new mLabel(myNavigation.gpsPos.toString(currFormat)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		CoordsP.addNext(lblDST = new mLabel(MyLocale.getMsg(1500,"DST:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		lblDST.backGround = BLUE;
 		CoordsP.addLast(btnGoto = new mButton(getGotoBtnText()),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
@@ -228,13 +122,13 @@
 
 		//GotoP.addNext(lblSatsText = new mLabel("Sats: "),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		//lblSatsText.font = BOLD;
-		GotoP.addLast(lblSats = new mLabel("Sats: " + Convert.toString(gpsPosition.getSats())),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		GotoP.addLast(lblSats = new mLabel("Sats: " + Convert.toString(myNavigation.gpsPos.getSats())),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		lblSats.font = BOLD;
-		GotoP.addLast(lblHDOP = new mLabel("HDOP: " + Convert.toString(gpsPosition.getHDOP())),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		GotoP.addLast(lblHDOP = new mLabel("HDOP: " + Convert.toString(myNavigation.gpsPos.getHDOP())),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		lblHDOP.font = BOLD;
 
 
-		GotoP.addLast(lblSpeed = new mLabel(Convert.toString(gpsPosition.getSpeed())),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		GotoP.addLast(lblSpeed = new mLabel(Convert.toString(myNavigation.gpsPos.getSpeed())),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		lblSpeed.font = BOLD;
 
 		GotoP.addLast(lblBearMov = new mLabel("0"),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
@@ -312,28 +206,23 @@
 	 * @param dest destination
 	 */ 
 	public void setDestination(CWPoint dest){
-		toPoint.set(dest);
-		if (!toPoint.isValid()) (new MessageBox("Error", "coordinates are out of range: \n"+"latitude: "+toPoint.latDec+"\n longditue: "+toPoint.lonDec, MessageBox.OKB)).execute();
+		myNavigation.setDestination(dest);
+		if (!myNavigation.destination.isValid()) (new MessageBox("Error", "Coordinates are out of range: \n"+"latitude: "+myNavigation.destination.latDec+"\n longditue: "+myNavigation.destination.lonDec, MessageBox.OKB)).execute();
+		
+	}
+	
+	public void destChanged() { // called from myNavigate
 		btnGoto.setText(getGotoBtnText());
-		if (mmp != null) { 
-			mmp.setGotoPosition(dest.latDec, dest.lonDec);
-			mmp.repaintNow();
-		}
 		updateDistance();
 	}
 	
-	public void setDestination(String LatLon) {
-		toPoint.set(LatLon);
-		setDestination(toPoint);
-	}
 
 	/**
 	 * set the coords of the destination and switch to gotoPanel  
 	 * @param LatLon destination
 	 */ 
 	public void setDestinationAndSwitch(String LatLon) {
-		toPoint.set(LatLon,CWPoint.CW);
-		setDestination(toPoint);
+		myNavigation.setDestination(LatLon);
 		mainT.select(this);
 	}
 	
@@ -345,8 +234,8 @@
 	public void updateDistance() {
 		//update distance
 		Double tmp = new Double();
-		if (gpsPosition.isValid() && toPoint.isValid() ) {
-			tmp.set(gpsPosition.getDistance(toPoint));
+		if (myNavigation.gpsPos.isValid() && myNavigation.destination.isValid() ) {
+			tmp.set(myNavigation.gpsPos.getDistance(myNavigation.destination));
 			if (tmp.value >= 1){
 				lblDist.setText(MyLocale.formatDouble(tmp,"0.000")+ " km");
 			}
@@ -357,7 +246,7 @@
 		}
 		else lblDist.setText("--- km");
 		// update goto-bearing
-		tmp.set(gpsPosition.getBearing(toPoint));
+		tmp.set(myNavigation.gpsPos.getBearing(myNavigation.destination));
 		if (tmp.value <= 360) 
 			lblBearWayP.setText(tmp.toString(0,0,0) + " Grad");
 		else lblBearWayP.setText("---" + " Grad");
@@ -367,42 +256,22 @@
 	/**
 	 * method which is called if a timer is set up  
 	 */ 
-	public void ticked() {
+	public void updateGps(int fix) {
 		Double bearMov = new Double();
 		Double speed = new Double();
 		Double sunAzimut = new Double();
 		Vm.debug("ticked: voher");
-
-		//		Vm.debug("ticked");
-		int fix = gpsPosition.getFix();
-		lblSats.setText("Sats: " + Convert.toString(gpsPosition.getSats()));
-		lblHDOP.setText("HDOP: " + Convert.toString(gpsPosition.getHDOP()));
-		// display values only, if signal good
-		if ((fix > 0) && (gpsPosition.getSats()>= 0)) {
-			//gpsPosition.printAll();
-			//Vm.debug("currTrack.add: voher");
-			if (currTrack == null) currTrack = new Track(trackColor);
-			try {
-				currTrack.add(gpsPosition);
-			} catch (IndexOutOfBoundsException e) { // track full -> create a new one
-				currTrack = new Track(trackColor); 
-				currTrack.add(gpsPosition);
-				if (mmp != null) mmp.addTrack(currTrack); // TODO maybe gotoPanel should also hold a list of Tracks, because otherwise they will be destroyed if not saved in mmp before
-			}
+		lblSats.setText("Sats: " + Convert.toString(myNavigation.gpsPos.getSats()));
+		lblHDOP.setText("HDOP: " + Convert.toString(myNavigation.gpsPos.getHDOP()));
+		if ((fix > 0) && (myNavigation.gpsPos.getSats()>= 0)) {
+			// display values only, if signal good
 			//Vm.debug("currTrack.add: nachher");
-			lblPosition.setText(gpsPosition.toString(currFormat));
-			speed.set(gpsPosition.getSpeed());
+			lblPosition.setText(myNavigation.gpsPos.toString(currFormat));
+			speed.set(myNavigation.gpsPos.getSpeed());
 			lblSpeed.setText(MyLocale.formatDouble(speed,"0.0") + " km/h");
-			try { 
-				sunAzimut.set(getSunAzimut(gpsPosition.Time, gpsPosition.Date, gpsPosition.latDec, gpsPosition.lonDec));
-				lblSunAzimut.setText(MyLocale.formatDouble(sunAzimut,"0.0") + " Grad");
-			} catch (NumberFormatException e) { 
-				// irgendeine Info zu Berechnung des Sonnenaziumt fehlt (insbesondere Datum und Uhrzeit sind nicht unbedingt gleichzeitig verf?gbar wenn es einen Fix gibt)
-				sunAzimut.set(500); // any value out of range (bigger than 360) will prevent drawArrows from drawing it 
-				lblSunAzimut.setText("---");
-			}//sunAzimut.set(getSunAzimut("141303","130906", 50.744, 7.0935));
-
-			bearMov.set(gpsPosition.getBear());
+			sunAzimut.set((double)myNavigation.sunAzimut);
+			lblSunAzimut.setText(MyLocale.formatDouble(sunAzimut,"0.0") + " Grad");
+			bearMov.set(myNavigation.gpsPos.getBear());
 			lblBearMov.setText(bearMov.toString(0,0,0) + " Grad");
 			compassRose.setSunMoveDirections((float)sunAzimut.value, (float)bearMov.value);
 			updateDistance();
@@ -411,145 +280,58 @@
 		}
 
 		// receiving data, but signal ist not good
-		if ((fix == 0) && (gpsPosition.getSats()>= 0)) {
+		if ((fix == 0) && (myNavigation.gpsPos.getSats()>= 0)) {
 			lblSats.backGround = YELLOW;
 		}
 		// receiving no data
 		if (fix == -1) {
 			if (lblSats.backGround != RED) (new MessageBox("Error", "No data from GPS\nConnection to serial port closed",MessageBox.OKB)).exec();
 			lblSats.backGround = RED;
-			stopGPS();
+			myNavigation.stopGps();
 		}
 		// cannot interprete data
 		if (fix == -2) {
-			if (lblSats.backGround != RED) (new MessageBox("Error", "Cannot interpret data from GPS\n possible reasons:\n wrong Port,\n wrong Baudrate,\n not NMEA-Protocol\nConnection to serial port closed\nLast String tried to interprete:\n "+gpsPosition.lastStrExamined, MessageBox.OKB)).exec();
+			if (lblSats.backGround != RED) (new MessageBox("Error", "Cannot interpret data from GPS\n possible reasons:\n wrong Port,\n wrong Baudrate,\n not NMEA-Protocol\nConnection to serial port closed\nLast String tried to interprete:\n "+myNavigation.gpsPos.lastStrExamined, MessageBox.OKB)).exec();
 			lblSats.backGround = RED;
-			stopGPS();
+			myNavigation.stopGps(); // TODO automatic in myNavigate?
 		}
-
-		// In moving map mode
-		if (mmp != null && runMovingMap ) { // neccessary in case of multi-threaded Java-VM: ticked could be called during load of mmp 
-			if ((fix > 0) && (gpsPosition.getSats()>= 0)) {
-				mmp.directionArrows.setDirections(-361 /*(float)bearWayP.value*/, (float)sunAzimut.value, -361 /*(float)bearMov.value*/);
-				mmp.setGpsStatus(MovingMap.gotFix);
-				mmp.updatePosition(gpsPosition.latDec, gpsPosition.lonDec);
-				mmp.ShowLastAddedPoint(currTrack);
-			}
-			if ((fix == 0) && (gpsPosition.getSats()== 0)) {
-				mmp.setGpsStatus(MovingMap.lostFix);
-			}
-			if (fix < 0 ) {
-				mmp.setGpsStatus(MovingMap.noGPSData);
-			}
-		}
 	}
 
-	public void startDisplayTimer() {
-		tickerThread = new UpdateThread(this, 1000);
-		tickerThread.start();
+	public void gpsStarted() {
+		chkLog.modify(ControlConstants.Disabled,0);
+		btnGPS.setText("Stop");
 	}
-
-	public void stopDisplayTimer(){
-		if (tickerThread != null) tickerThread.stop();
+	
+	public void startGps() {
+		myNavigation.setRawLogging(chkLog.getState(), Convert.toInt(inpLogSeconds.getText()));
+		myNavigation.startGps();
 	}
 
-	/**
-	 * @param utc in the format as it comes from gps DDMMYY
-	 * @param datum in the format as it comes from gps HHMMSS
-	 * @param lat in degrees in WGS84
-	 * @param lon in degrees in WGS84
-	 * @return Azimut of the sun in degrees from north
-	 * @throws NumberFormatException when utc / datum could not be interpreted
-	 */
-	public double getSunAzimut (String utc, String datum, double lat, double lon) {
-		//	(new MessageBox("test", "utc:"+utc+" datum: "+datum+", lat: "+lat+", len: "+lon, MessageBox.OKB)).exec();
-		try {
-			int tag, monat, jahr, stunde, minute, sekunde;
-			tag = Convert.parseInt(datum.substring(0, 2));
-			monat = Convert.parseInt(datum.substring(2, 4));
-			jahr = Convert.parseInt(datum.substring(4, 6)) + 2000;
-			stunde=Convert.parseInt(utc.substring(0, 2));
-			minute=Convert.parseInt(utc.substring(2, 4));
-			sekunde=Convert.parseInt(utc.substring(4, 6)); // Kommastellen werden abgeschnitten
-			// julianisches "Datum" jd berechnen (see http://de.wikipedia.org/wiki/Julianisches_Datum )
-			if (monat<2) {jahr--; monat+=12;} // verlegung des Jahres Endes auf Feb macht Berechnung von SChaltjahren einfacher
-			double a = (int)java.lang.Math.floor((double)jahr/100.); // Alle hundert Jahre kein Schlatjahr (abrunden)
-			double b = 2 - a + java.lang.Math.floor((double)a/4.);
-			double jd = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) + (double)tag + (double)stunde/24 + (double)minute/1440 + (double)sekunde/86400 + b - 1524.5;
-			double jd0 = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) +(double)tag + b - 1524.5;
-			// Ekliptikalkoordinaten der Sonne berechnen (see http://de.wikipedia.org/wiki/Sonnenstand )
-			double n = jd - 2451545.0;
-			double l = 280.46 + 0.9856474 * n;
-			double g = 357.528 + 0.9856003 * n;
-			double d = l + 1.915*java.lang.Math.sin(g/180*java.lang.Math.PI) + 0.02 * java.lang.Math.sin(2*g/180*java.lang.Math.PI);
-			// Rektaszension alpha und Deklination delta der Sonne berechnen
-			double e = 23.439 -0.0000004 * n;
-			double alphaNenner = java.lang.Math.cos(d/180*java.lang.Math.PI);
-			double alpha = 180/java.lang.Math.PI*java.lang.Math.atan(java.lang.Math.cos(e/180*java.lang.Math.PI)*java.lang.Math.sin(d/180*java.lang.Math.PI)/alphaNenner);
-			double delta = 180/java.lang.Math.PI*java.lang.Math.asin(java.lang.Math.sin(e/180*java.lang.Math.PI)*java.lang.Math.sin(d/180*java.lang.Math.PI) );
-			if (alphaNenner<0) {alpha +=180;}
-			// Azimut
-			double t0 = (jd0 - 2451545.)/36525.; // schon in t0 bzw jd0 richtig berechnet?
-			double thetaHG = 6.697376 + 2400.05134 * t0 + 1.002738 * ((double)stunde + (double)minute/60.);
-			double theta = thetaHG * 15. + lon;
-			double azimutNenner = java.lang.Math.cos((theta-alpha)/180*java.lang.Math.PI)*java.lang.Math.sin(lat/180*java.lang.Math.PI)-
-			java.lang.Math.tan(delta/180*java.lang.Math.PI)*java.lang.Math.cos(lat/180*java.lang.Math.PI);
-			double azimut = java.lang.Math.atan(java.lang.Math.sin((theta-alpha)/180*java.lang.Math.PI)/
-					azimutNenner);
-			azimut = azimut * 180. / java.lang.Math.PI;
-			if (azimutNenner<0) azimut +=180.;
-			// null = Sueden auf Null = Norden umrechnen
-			azimut +=180.;
-			if (azimut >360.) azimut -=360.;
-			return azimut;
-		} catch (IndexOutOfBoundsException e) {
-			// wird von substring geworfen wenn datum / utc nicht genug Ziffern haben
-			// NumberFormatException wird au?erdem von Convert.ParseInt direkt geworfen wenn
-			// nicht in Int konvertiert werden kann
-			throw new NumberFormatException();
-		}
-	}
-
-	private void stopGPS() {
-		serThread.stop();
-		stopDisplayTimer();
+	public void gpsStoped() {
 		btnGPS.setText("Start");
-		gpsPosition.stopLog();
 		lblSats.backGround = this.backGround;
-		if (mmp != null) mmp.setGpsStatus(MovingMap.noGPS);
-		this.repaintNow(); // without this the change in the background color will not be displayed
 		chkLog.modify(0,ControlConstants.Disabled);
+		this.repaintNow(); // without this the change in the background color will not be displayed
 	}
 
-	public void startGps() {
-		if (serThread != null) if (serThread.isAlive()) return;
-		try {
-			serThread = new SerialThread(pref.mySPO, gpsPosition, (pref.forwardGPS ? pref.forwardGpsHost : ""));
-			if (pref.forwardGPS && !serThread.tcpForward) {
-				(new MessageBox("Warning", "Ignoring error:\n could not forward GPS data to host:\n"+pref.forwardGpsHost+"\n"+serThread.lastError+"\nstop and start GPS to retry",MessageBox.OKB)).exec();
-			}
-			if (gpsPosition.latDec == 0 && gpsPosition.lonDec == 0) {
-				gpsPosition.latDec = toPoint.latDec; // setze Zielpunkt als Ausgangspunkt
-				gpsPosition.lonDec = toPoint.lonDec;
-			}
-			serThread.start();
-			startDisplayTimer();
-			if (chkLog.getState()){
-				gpsPosition.startLog(profile.dataDir, Convert.toInt(inpLogSeconds.getText()), CWGPSPoint.LOGALL);
-			}
-			chkLog.modify(ControlConstants.Disabled,0);
-			btnGPS.setText("Stop");
-		} catch (IOException e) {
-			(new MessageBox("Error", "Could not connect to GPS-receiver.\n Error while opening serial Port " + e.getMessage()+"\npossible reasons:\n Another (GPS-)program is blocking the port\nwrong port\nOn Loox: active infra-red port is blocking GPS", MessageBox.OKB)).execute(); 
-		}
-		currTrack = new Track(RED); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
-	}
 	
 	private String getGotoBtnText() {
-		if (toPoint == null) return "not set";
-		else return toPoint.toString(currFormat);
+		if (myNavigation.destination == null) return "not set";
+		else return myNavigation.destination.toString(currFormat);
 	}
-
+	
+	public void switchToMovingMap() {
+		CWPoint centerTo;
+		if (myNavigation.isGpsPosValid()) centerTo = new CWPoint(myNavigation.gpsPos); // set gps-pos if gps is on
+		else {
+			// setze Zielpunkt als Ausgangspunkt, wenn GPS aus ist und lade entsprechende Karte
+			centerTo = new CWPoint(myNavigation.destination);
+			if (myNavigation.destination.isValid())	centerTo = new CWPoint(myNavigation.destination);
+			else centerTo = new CWPoint(pref.curCentrePt); // if not goto-point defined move map to centere point
+		}  
+		mainT.SwitchToMovingMap(centerTo);
+	}
+	
 	/**
 	 * Eventhandler
 	 */
@@ -560,68 +342,39 @@
 			// display coords in another format
 			if (ev.target == chkFormat){
 				currFormat = chkFormat.getSelectedIndex();
-				lblPosition.setText(gpsPosition.toString(currFormat));
+				lblPosition.setText(myNavigation.gpsPos.toString(currFormat));
 				btnGoto.setText(getGotoBtnText());
 			}
 
 			// start/stop GPS connection
 			if (ev.target == btnGPS){
 				if (btnGPS.getText().equals("Start")) startGps();
-				else stopGPS();
+				else myNavigation.stopGps();
 			}
 
 			// set current position as center and recalculate distance of caches in MainTab 
 			if (ev.target == btnCenter){
 				Vm.showWait(true);
-				pref.curCentrePt.set(gpsPosition);
+				pref.curCentrePt.set(myNavigation.gpsPos);
 				mainT.updateBearDist();
 				Vm.showWait(false);
 				(new MessageBox("Info", "Entfernungen in der Listenansicht \nvom aktuellen Standpunkt aus \nneu berechnet", MessageBox.OKB)).execute();
 			}
 			//Start moving map
 			if (ev.target == btnMap){
-				runMovingMap = true;
-				boolean runbefore=false;
-				if (mmp == null) mmp = new MovingMap(pref, this, cacheDB);
-				else runbefore = true;
-				if (serThread == null || !serThread.isAlive() || !gpsPosition.isValid()) {
-					// setze Zielpunkt als Ausgangspunkt, wenn GPS aus ist und lade entsprechende Karte
-					mmp.ignoreGps = false;
-					if (toPoint.isValid())	mmp.updatePosition(toPoint.latDec, toPoint.lonDec);
-					else mmp.updatePosition(Global.getPref().curCentrePt.latDec, Global.getPref().curCentrePt.lonDec); // if not goto-point defined move map to centere point
-					mmp.ignoreGps = true;
-				} else mmp.updatePosition(gpsPosition.latDec, gpsPosition.lonDec); // set gps-pos if gps is on 
-				if (currTrack != null) mmp.addTrack(currTrack);
-				if (runbefore) mmp.addOverlaySet(); // draw new trackpoints but only do so if OverlaySet needs to be updated, otherwise it is anyway newly created
-				if (toPoint.isValid()) mmp.setGotoPosition(toPoint.latDec, toPoint.lonDec);
-				else mmp.removeGotoPosition();
-				// update cache symbols in map
-				if (mainT.tbP.myMod.cacheSelectionChanged) {
-					mainT.tbP.myMod.cacheSelectionChanged = false;
-					mmp.removeAllMapSymbolsButGoto();
-					CacheHolder ch;
-					for (int i=cacheDB.size()-1; i>=0; i--) {
-						ch = (CacheHolder) cacheDB.get(i);
-						if (ch.is_Checked) {
-							//CWPoint tmpll = new CWPoint(ch.LatLon);
-							int ct = Convert.parseInt(ch.type);
-							mmp.addSymbol(ch.CacheName, ch, myTableModel.cacheImages[ct], ch.pos.latDec, ch.pos.lonDec);
-						}
-					}
-				}
-				mmp.myExec();
+				switchToMovingMap();
 			} 
 			// create new waypoint with current GPS-position
 			if (ev.target == btnSave){
 				CacheHolder ch = new CacheHolder();
-				ch.LatLon = gpsPosition.toString();
-				ch.pos = new CWPoint(gpsPosition);
+				ch.LatLon = myNavigation.gpsPos.toString();
+				ch.pos = new CWPoint(myNavigation.gpsPos);
 				mainT.newWaypoint(ch);
 			}
 			// change destination waypoint
 			if (ev.target == btnGoto){
 				CoordsScreen cs = new CoordsScreen();
-				if (toPoint.isValid())	cs.setFields(toPoint, currFormat);
+				if (myNavigation.destination.isValid())	cs.setFields(myNavigation.destination, currFormat);
 				else cs.setFields(new CWPoint(0,0), currFormat);
 				if (cs.execute() == CoordsScreen.IDOK)
 					setDestination(cs.getCoords());

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-02-04 23:35:16 UTC (rev 512)
+++ trunk/src/CacheWolf/MainTab.java	2007-02-05 02:46:11 UTC (rev 513)
@@ -1,18 +1,16 @@
 package CacheWolf;
 
-import ewe.sys.Vm;
 import ewe.ui.*;
 import ewe.fx.*;
 import ewe.util.*;
-//import ewe.sys.*;
 
 /**
-*	This class creates the tabbed panel and sets the tabs to the respective
-*	other panels. Important is to have a look at the event handler!<br>
-*	Class ID = 1200
-*	@see MainForm
-*	@see MainMenu
-*/
+ *	This class creates the tabbed panel and sets the tabs to the respective
+ *	other panels. Important is to have a look at the event handler!<br>
+ *	Class ID = 1200
+ *	@see MainForm
+ *	@see MainMenu
+ */
 public class MainTab extends mTabbedPanel {
 	DescriptionPanel descP= new DescriptionPanel();
 	HintLogPanel hintLP = new HintLogPanel();
@@ -29,7 +27,9 @@
 	String lastselected = new String();
 	CacheHolder ch =null;
 	MainMenu mnuMain;
-	
+	MovingMap mm;
+	Navigate nav;
+
 	public MainTab(MainMenu mainMenu,StatusBar statBar){
 		Global.mainTab=this;
 		mnuMain=mainMenu;
@@ -42,44 +42,46 @@
 		if (MyLocale.getScreenWidth() <= 240) this.dontExpandTabs=true;
 		calcP = new CalcPanel(); // Init here so that Global.MainT is already set
 		Card c = this.addCard(tbP = new TablePanel(pref, profile, statBar), MyLocale.getMsg(1200,"List"), null);
-		
+
 		c = this.addCard(detP, MyLocale.getMsg(1201,"Details"), null);
 		c.iconize(new Image("details.gif"),true);
-		
+
 		c = this.addCard(descP, MyLocale.getMsg(1202,"Description"), null);
 		c.iconize(new Image("descr.gif"),true);
-		
+
 		c = this.addCard(new ScrollBarPanel(imageP = new ImagePanel()), MyLocale.getMsg(1203,"Images"), null);
 		c.iconize(new Image("images.gif"),true);
-		
+
 		c = this.addCard(hintLP, MyLocale.getMsg(1204,"Hints & Logs"), null);
 		c.iconize(new Image("more.gif"),true);
 
 		c = this.addCard(calcP, MyLocale.getMsg(1206,"Calc"), null);
 		c.iconize(new Image("ewe/HandHeld.bmp"),true);
-		
-		c = this.addCard(gotoP = new GotoPanel(pref, profile, this, detP), "Goto", null);
+
+		nav = new Navigate();
+		c = this.addCard(gotoP = new GotoPanel(nav), "Goto", null);
 		c.iconize(new Image("goto.gif"),true);
 		tbP.setPanels(gotoP, this);
-		
+		nav.setGotoPanel(gotoP);
+
 		c = this.addCard(solverP = new SolverPanel(pref, profile), MyLocale.getMsg(1205,"Solver"), null);
 		c.iconize(new Image("solver.gif"),true);
-		
+
 		c = this.addCard(radarP, "Radar", null);
 		radarP.setMainTab(this);
 		c.iconize(new Image("radar.gif"),true);
 		mnuMain.allowProfileChange(true);
 	}
-	
+
 	public TablePanel getTablePanel(){
 		return tbP;
 	}
-	
+
 	public void selectAndActive(int rownum){
 		tbP.selectAndActive(rownum);
 		this.selectAndExpand(0);
 	}
-	
+
 	/** Update the distances of all caches to the center and display a message 
 	 */
 	public void updateBearDist(){
@@ -88,7 +90,7 @@
 		tbP.refreshTable();
 		(new MessageBox(MyLocale.getMsg(327,"Information"), MyLocale.getMsg(1024,"Entfernungen in der Listenansicht \nvom aktuellen Standpunkt aus \nneu berechnet").replace('~','\n'), MessageBox.OKB)).execute();
 	}
-	
+
 	public void gotoPoint(String LatLon) {
 		gotoP.setDestinationAndSwitch(LatLon);
 	}
@@ -201,7 +203,15 @@
 		  super.onEvent(ev); //Make sure you call this.
 	}
 
-	
-	
+	public void SwitchToMovingMap(CWPoint centerTo) {
+		if (mm == null) {
+			mm = new MovingMap(nav, profile.cacheDB);
+			nav.setMovingMap(mm);
+		}
+		//mm.ignoreGps = false; // TODO genauer nachdenken multi-threading: wenn er grad eine Karte l?dt o.?., dann funktioniert folgender Befehl nicht
+		mm.updatePosition(centerTo.latDec, centerTo.lonDec);
+		mm.myExec();
+	}
 }
 
+

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-04 23:35:16 UTC (rev 512)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-05 02:46:11 UTC (rev 513)
@@ -12,7 +12,7 @@
 /**
  *	Class to handle a moving map.
  */
-public class MovingMap extends Form {
+public class MovingMap extends Form implements TimerProc {
 	final static int gotFix = 4; //green
 	final static int lostFix = 3; //yellow
 	final static int noGPSData = 2; // red
@@ -25,13 +25,14 @@
 	MovingMapPanel mmp;
 	MapsList maps;
 	Vector symbols;
-	GotoPanel gotoPanel;
 	Vector cacheDB;
 	TrackOverlay[] TrackOverlays;
 	CWPoint TrackOverlaySetCenterTopLeft;
 	Vector tracks;
 	MapInfoObject currentMap = null;
 	String mapPath;
+	Navigate myNavigation;
+	boolean running = false;
 
 	MapImage mapImage1to1;
 	ArrowsOnMap directionArrows = new ArrowsOnMap();
@@ -49,6 +50,7 @@
 	AniImage ScaleImage;
 	Graphics ScaleImageGraphics;
 	MapImage posCircle = new MapImage("position_green.png");
+	public static final String MARK_CACHE_IMAGE = "mark_cache.png";
 	int posCircleX = 0, posCircleY = 0, lastCompareX = Integer.MAX_VALUE, lastCompareY = Integer.MAX_VALUE;
 	double posCircleLat, posCircleLon;
 
@@ -61,10 +63,10 @@
 	boolean zoomingMode = false;
 	boolean mapsloaded = false;
 
-	public MovingMap(Preferences pref, GotoPanel gP, Vector cacheDB){
+	public MovingMap(Navigate nav, Vector cacheDB){
 		this.cacheDB = cacheDB;
-		this.gotoPanel = gP;
-		this.pref = pref;
+		this.myNavigation = nav;
+		this.pref = Global.getPref();
 		if (pref.myAppHeight <= 640 && pref.myAppWidth <= 640)	this.windowFlagsToSet = Window.FLAG_FULL_SCREEN;
 		this.windowFlagsToClear = Window.FLAG_HAS_TITLE | Window.BDR_NOBORDER;
 		this.hasTopBar = false;
@@ -249,11 +251,38 @@
 	}
 
 	public final FormFrame myExec() {
-		//addOverlaySet(); // neccessary to draw points which were added when the MovingMap was not running, so that these pixels are not stored in the not-immediately-drawing-work-around
-		// doShowExec(null,null,true,Gui.NEW_WINDOW & ~Form.PageHigher);
+		// update cache symbols in map
+		running = true;
+		MainTab mainT = Global.mainTab;
+		if (mainT.tbP.myMod.cacheSelectionChanged) {
+			mainT.tbP.myMod.cacheSelectionChanged = false;
+			removeAllMapSymbolsButGoto();
+			CacheHolder ch;
+			for (int i=cacheDB.size()-1; i>=0; i--) {
+				ch = (CacheHolder) cacheDB.get(i);
+				if (ch.is_Checked || ch == mainT.ch) { // ch == Global.mainTab.ch: always show the gray marked cache
+					int ct = Convert.parseInt(ch.type);
+					addSymbol(ch.CacheName, ch, myTableModel.cacheImages[ct], ch.pos.latDec, ch.pos.lonDec);
+				}
+			}
+		}
+		if (mainT.ch != null) setMarkedCache(mainT.ch);
+		destChanged(myNavigation.destination);
+		addTrack(myNavigation.curTrack);
+		if (tracks != null && tracks.size() > 0 && ((Track)tracks.get(0)).num > 0) 
+			addOverlaySet(); // show points wich where added when MavingMap was not running
 		FormFrame ret = exec();
 		return ret;
 	}
+	
+	CacheHolder markedCache = null;
+	public void setMarkedCache(CacheHolder ch) {
+		if (ch == markedCache) return;
+		if (markedCache != null) removeMapSymbol("selectedCache");
+		markedCache = ch;
+		if (markedCache != null) addSymbol("selectedCache", MARK_CACHE_IMAGE, ch.pos.latDec, ch.pos.lonDec);
+	}
+	
 	public void addTrack(Track tr) {
 		if (tr == null) return;
 		if (tracks == null) tracks = new Vector();
@@ -662,9 +691,11 @@
 		mmp.addImage(ms);
 	}
 
-	public void setGotoPosition(double lat, double lon) {
+	public void destChanged(CWPoint d) {
+		if(!running || d.equals(gotoPos)) return;
 		removeGotoPosition();
-		gotoPos = addSymbol("goto", "goto_map.png", lat, lon);
+		if (d == null || !d.isValid() ) return;
+		gotoPos = addSymbol("goto", "goto_map.png", d.latDec, d.lonDec);
 		updateDistance();
 		forceMapLoad = true;
 		updatePosition(posCircleLat, posCircleLon);
@@ -681,6 +712,9 @@
 
 	public void removeAllMapSymbolsButGoto(){
 		if (symbols == null) return;
+		for (int i = symbols.size()-1; i >= 0; i--) {
+			mmp.removeImage((MapSymbol)symbols.get(i));
+		}
 		symbols.removeAllElements();
 		if (gotoPos != null) symbols.add(gotoPos);
 	}
@@ -698,7 +732,7 @@
 	public int findMapSymbol(String name) {
 		if (symbols == null) return -1;
 		MapSymbol ms;
-		for (int i = 0; i < symbols.size(); i++) {
+		for (int i = symbols.size() -1; i >= 0 ; i--) {
 			ms= (MapSymbol)symbols.get(i);
 			if (ms.name == name) return i;
 		}
@@ -711,21 +745,20 @@
 	 * @param  
 	 */
 	public void updateOnlyPosition(double lat, double lon, boolean updateOverlay){
-		Point mapPos = new Point(0,0);
-		Point oldMapPos = getMapPositionOnScreen();
+		//Point oldMapPos = getMapPositionOnScreen();
 		posCircleLat = lat;
 		posCircleLon = lon;
-		mapPos = getMapPositionOnScreen();
+		Point mapPos = getMapPositionOnScreen();
 		//Vm.debug("mapx = " + mapx);
 		//Vm.debug("mapy = " + mapy);
-		if (forceMapLoad || (java.lang.Math.abs(oldMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(oldMapPos.y - mapPos.y) > 1)) {
-			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x, mapPos.y);
-			updateSymbolPositions();
-			updateDistance();
-			if (updateOverlay ) updateOverlayPos(); // && TrackOverlays != null
-			//}
-			mmp.repaintNow(); // TODO test if the "if" above can be used: i guess it can be used as long as the posCircle doesn't move autonom without a mapmove
-		}
+		//if (forceMapLoad || (java.lang.Math.abs(oldMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(oldMapPos.y - mapPos.y) > 1)) { // TODO make the speed improvement work: this if doesn't work in case of a series of changes less than 1 px 
+		if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x, mapPos.y);
+		updateSymbolPositions();
+		updateDistance();
+		if (updateOverlay ) updateOverlayPos(); // && TrackOverlays != null
+		//}
+		mmp.repaintNow(); 
+		//}
 		//Vm.debug("update only position");			
 	}
 	/**
@@ -759,6 +792,26 @@
 		}
 	}
 
+	public void updateGps(int fix) {
+		if (!running) return;
+		// runMovingMap neccessary in case of multi-threaded Java-VM: ticked could be called during load of mmp 
+		if ((fix > 0) && (myNavigation.gpsPos.getSats()>= 0)) { // TODO is getSats really necessary?
+			directionArrows.setDirections(-361 /*(float)bearWayP.value*/, myNavigation.sunAzimut, -361 /*(float)bearMov.value*/);
+			setGpsStatus(MovingMap.gotFix);
+			updatePosition(myNavigation.gpsPos.latDec, myNavigation.gpsPos.lonDec);
+			ShowLastAddedPoint(myNavigation.curTrack);
+		}
+		if (fix == 0 && myNavigation.gpsPos.getSats()== 0) 	setGpsStatus(MovingMap.lostFix);
+		if (fix < 0 )	setGpsStatus(MovingMap.noGPSData);
+	}
+	
+	public void gpsStarted() {
+		addTrack(myNavigation.curTrack);
+		addOverlaySet();
+	}
+	public void gpsStoped() {
+		setGpsStatus(MovingMap.noGPS);
+	}
 
 	int mapChangeModus;
 	float scaleWanted;
@@ -823,10 +876,10 @@
 	}
 
 	public void setResModus (int modus) {
+		scaleWanted = currentMap.scale;
 		if (mapChangeModus == modus) return;
 		mapChangeModus = modus;
-		if (modus == NORMAL_KEEP_RESOLUTION) scaleWanted = currentMap.scale;
-		else setBestMap(posCircleLat, posCircleLon, true);
+		if (modus != NORMAL_KEEP_RESOLUTION) setBestMap(posCircleLat, posCircleLon, true);
 	}
 	/**
 	 * method to get a point on the screen which must be included in the map
@@ -869,7 +922,13 @@
 		Rect screen = (Rect) s[1]; 
 		//Rect screen = new Rect(posCircleX, posCircleY, (width != 0 ? width : pref.myAppWidth), (height != 0 ? height : pref.myAppHeight));
 		MapInfoObject m = maps.getMapChangeResolution(cll.latDec, cll.lonDec, screen, currentMap.scale, !betterOverview);
-		if (m != null) setMap(m, posCircleLat, posCircleLon);
+		if (m != null) {
+			boolean saveGpsIgnStatus = ignoreGps;
+			ignoreGps = true;
+			setMap(m, posCircleLat, posCircleLon);
+			setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+			ignoreGps = saveGpsIgnStatus;
+		}
 		else (new MessageBox("Error", "No "+ (betterOverview ? "less" : "more") + " deteiled map available", MessageBox.OKB)).execute();
 	}
 
@@ -882,7 +941,11 @@
 			Rect screen = (Rect) s[1]; 
 			newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, Float.MAX_VALUE -1, false);
 		}
+		boolean saveGpsIgnStatus = ignoreGps;
+		ignoreGps = true;
 		setMap(newmap, posCircleLat, posCircleLon);
+		setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+		ignoreGps = saveGpsIgnStatus;
 	}
 
 	public void setGpsStatus (int status) {
@@ -1125,7 +1188,7 @@
 			}
 		} else // no map image loaded 
 		{ currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y); }
-
+		scaleWanted = currentMap.scale;
 		destroyOverlaySet();
 		Vm.getUsedMemory(true); // call garbage collection
 		setCenterOfScreen(center);
@@ -1146,7 +1209,7 @@
 	 */
 	public void onEvent(Event ev){
 		if(ev instanceof FormEvent && (ev.type == FormEvent.CLOSED )){
-			gotoPanel.runMovingMap = false;
+			running = false;
 		}  
 		if(ev instanceof KeyEvent && ev.target == this && ((KeyEvent)ev).key == IKeys.ESCAPE) {
 			this.close(0);
@@ -1320,7 +1383,7 @@
 
 	public void chooseMap() {
 		CWPoint gpspos;
-		if (mm.gotoPanel.gpsPosition.Fix > 0) gpspos = new CWPoint(mm.gotoPanel.gpsPosition.latDec, mm.gotoPanel.gpsPosition.lonDec);
+		if (mm.myNavigation.gpsPos.Fix > 0) gpspos = new CWPoint(mm.myNavigation.gpsPos.latDec, mm.myNavigation.gpsPos.lonDec);
 		else gpspos = null;
 		ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos(), mm.currentMap);
 		if(l.execute() == FormBase.IDOK){
@@ -1410,8 +1473,7 @@
 	}
 
 	public void snapToGps() {
-		if (mm.gotoPanel.serThread == null || !mm.gotoPanel.serThread.isAlive()) 
-			mm.gotoPanel.startGps();
+		mm.myNavigation.startGps();
 		mm.SnapToGps();
 	}
 
@@ -1484,17 +1546,14 @@
 						// manually change map resolution
 						if (action == moreDetailsMI) {
 							mapsMenu.close();
-							mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
 							mm.loadMoreDetailedMap(false);
 						} 
 						if (action == moreOverviewMI) {
 							mapsMenu.close();
-							mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
 							mm.loadMoreDetailedMap(true);
 						}
 						if (action == AllCachesResMI) {
 							mapsMenu.close();
-							mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
 							mm.loadMapForAllCaches();
 						}
 						// moveto position
@@ -1521,7 +1580,7 @@
 					MenuItem action = (MenuItem) kontextMenu.getSelectedItem(); 
 					if (action == gotoMenuItem) {
 						kontextMenu.close();
-						mm.gotoPanel.setDestination(mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y));	
+						mm.myNavigation.setDestination(mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y));	
 					}
 					if (action == openCacheDescMenuItem) {
 						//mm.onEvent(new FormEvent(FormEvent.CLOSED, mm));
@@ -1530,9 +1589,10 @@
 						close.target = mm;
 						close.type = WindowEvent.CLOSE;
 						mm.postEvent(close);
-						mm.gotoPanel.mainT.tbP.selectAndActive(mm.cacheDB.find(clickedCache));
-						mm.gotoPanel.mainT.select(mm.gotoPanel.mainT.descP);
-						mm.gotoPanel.mainT.openDesciptionPanel(clickedCache);
+						MainTab mainT = Global.mainTab;
+						mainT.tbP.selectAndActive(mm.cacheDB.find(clickedCache));
+						mainT.select(Global.mainTab.descP);
+						mainT.openDesciptionPanel(clickedCache);
 					}
 					if (action == newWayPointMenuItem) {
 						kontextMenu.close();
@@ -1542,8 +1602,7 @@
 						mm.postEvent(close);
 						CacheHolder newWP = new CacheHolder();
 						newWP.pos = mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y);
-						mm.gotoPanel.mainT.newWaypoint(newWP);
-
+						Global.mainTab.newWaypoint(newWP);
 					}
 
 				}

Added: trunk/src/CacheWolf/Navigate.java
===================================================================
--- trunk/src/CacheWolf/Navigate.java	2007-02-04 23:35:16 UTC (rev 512)
+++ trunk/src/CacheWolf/Navigate.java	2007-02-05 02:46:11 UTC (rev 513)
@@ -0,0 +1,276 @@
+package CacheWolf;
+
+import ewe.fx.Color;
+import ewe.io.IOException;
+import ewe.io.SerialPort;
+import ewe.io.SerialPortOptions;
+import ewe.net.Socket;
+import ewe.sys.Convert;
+import ewe.sys.mThread;
+import ewe.ui.MessageBox;
+import ewe.util.mString;
+
+public class Navigate {
+	public CWPoint destination = new CWPoint();
+	public CWGPSPoint gpsPos = new CWGPSPoint();
+	public Track curTrack = null;
+	Color trackColor = new Color(255,0,0); // red
+	public float sunAzimut = -361;
+
+	public GotoPanel gotoPanel = null;
+	public MovingMap movingMap = null;
+	public SerialThread serThread = null;
+	public Preferences pref = Global.getPref();
+	public UpdateThread tickerThread;
+	boolean lograw = false;
+	int logIntervall = 10;
+
+	public void setGotoPanel(GotoPanel gp) {
+		gotoPanel = gp;
+	}
+	public void setMovingMap (MovingMap mm) {
+		movingMap = mm;
+	}
+
+	public void startGps() {
+		if (serThread != null) if (serThread.isAlive()) return;
+		try {
+			serThread = new SerialThread(pref.mySPO, gpsPos, (pref.forwardGPS ? pref.forwardGpsHost : ""));
+			if (pref.forwardGPS && !serThread.tcpForward) {
+				(new MessageBox("Warning", "Ignoring error:\n could not forward GPS data to host:\n"+pref.forwardGpsHost+"\n"+serThread.lastError+"\nstop and start GPS to retry",MessageBox.OKB)).exec();
+			}
+			if (gpsPos.latDec == 0 && gpsPos.lonDec == 0) { // TODO use isValid() // TODO raus damit?
+				gpsPos.latDec = destination.latDec; // setze Zielpunkt als Ausgangspunkt
+				gpsPos.lonDec = destination.lonDec;
+			}
+			serThread.start();
+			startDisplayTimer();
+			if (lograw)	gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
+			if (gotoPanel != null) gotoPanel.gpsStarted();
+			if (movingMap != null) movingMap.gpsStarted();
+		} catch (IOException e) {
+			(new MessageBox("Error", "Could not connect to GPS-receiver.\n Error while opening serial Port " + e.getMessage()+"\npossible reasons:\n Another (GPS-)program is blocking the port\nwrong port\nOn Loox: active infra-red port is blocking GPS", MessageBox.OKB)).execute(); 
+		}
+		curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
+	}
+
+	public void setRawLogging(boolean on, int intervall) {
+		lograw = on;
+		logIntervall = intervall; // TODO switch on and off during serthread running
+	}
+	public void startDisplayTimer() {
+		tickerThread = new UpdateThread(this, 1000);
+		tickerThread.start();
+	}
+
+	public void stopDisplayTimer(){
+		if (tickerThread != null) tickerThread.stop();
+	}
+	
+	public void stopGps() {
+		serThread.stop();
+		stopDisplayTimer();
+		gpsPos.stopLog();
+		if (gotoPanel != null) gotoPanel.gpsStoped();
+		if (movingMap != null) movingMap.gpsStoped();
+	}
+	
+	public boolean isGpsPosValid() {
+		return 	serThread != null && serThread.isAlive() && gpsPos.isValid() ; // && gpsPos.getfiex();
+
+	}
+
+
+	public void setDestination(String LatLon) { 
+		setDestination(new CWPoint(LatLon));
+	}
+
+
+	public void setDestination(CWPoint d) {
+		destination = new CWPoint (d);
+		if (gotoPanel != null) gotoPanel.destChanged();
+		if (movingMap != null) { // TODO make movingmap the same as gotopanel
+			movingMap.destChanged(gpsPos);
+			movingMap.repaintNow();
+		}
+	}
+	public void ticked() {
+		int fix = gpsPos.getFix();
+		if (fix > 0 && (gpsPos.getSats()>= 0)) {
+			//gpsPosition.printAll();
+			//Vm.debug("currTrack.add: voher");
+			if (curTrack == null) curTrack = new Track(trackColor);
+			try {
+				curTrack.add(gpsPos);
+			} catch (IndexOutOfBoundsException e) { // track full -> create a new one
+				curTrack = new Track(trackColor); 
+				curTrack.add(gpsPos);
+				if (movingMap != null) movingMap.addTrack(curTrack); // TODO maybe gotoPanel should also hold a list of Tracks, because otherwise they will be destroyed if not saved in mmp before
+			}
+			try {
+				sunAzimut = getSunAzimut(gpsPos.Time, gpsPos.Date, gpsPos.latDec, gpsPos.lonDec);
+			} catch (NumberFormatException e) { // irgendeine Info zu Berechnung des Sonnenaziumt fehlt (insbesondere Datum und Uhrzeit sind nicht unbedingt gleichzeitig verf?gbar wenn es einen Fix gibt)
+				sunAzimut = -361; // any value out of range (bigger than 360) will prevent drawArrows from drawing it 
+			}
+
+		} else {
+			sunAzimut = -361;
+		}
+		gotoPanel.updateGps(fix);
+		if (movingMap != null) movingMap.updateGps(fix);
+	}
+
+	/**
+	 * @param utc in the format as it comes from gps DDMMYY
+	 * @param datum in the format as it comes from gps HHMMSS
+	 * @param lat in degrees in WGS84
+	 * @param lon in degrees in WGS84
+	 * @return Azimut of the sun in degrees from north
+	 * @throws NumberFormatException when utc / datum could not be interpreted
+	 */
+	public static float getSunAzimut (String utc, String datum, double lat, double lon) {
+		//	(new MessageBox("test", "utc:"+utc+" datum: "+datum+", lat: "+lat+", len: "+lon, MessageBox.OKB)).exec();
+		try {
+			int tag, monat, jahr, stunde, minute, sekunde;
+			tag = Convert.parseInt(datum.substring(0, 2));
+			monat = Convert.parseInt(datum.substring(2, 4));
+			jahr = Convert.parseInt(datum.substring(4, 6)) + 2000;
+			stunde=Convert.parseInt(utc.substring(0, 2));
+			minute=Convert.parseInt(utc.substring(2, 4));
+			sekunde=Convert.parseInt(utc.substring(4, 6)); // Kommastellen werden abgeschnitten
+			// julianisches "Datum" jd berechnen (see http://de.wikipedia.org/wiki/Julianisches_Datum )
+			if (monat<2) {jahr--; monat+=12;} // verlegung des Jahres Endes auf Feb macht Berechnung von SChaltjahren einfacher
+			double a = (int)java.lang.Math.floor((double)jahr/100.); // Alle hundert Jahre kein Schlatjahr (abrunden)
+			double b = 2 - a + java.lang.Math.floor((double)a/4.);
+			double jd = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) + (double)tag + (double)stunde/24 + (double)minute/1440 + (double)sekunde/86400 + b - 1524.5;
+			double jd0 = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) +(double)tag + b - 1524.5;
+			// Ekliptikalkoordinaten der Sonne berechnen (see http://de.wikipedia.org/wiki/Sonnenstand )
+			double n = jd - 2451545.0;
+			double l = 280.46 + 0.9856474 * n;
+			double g = 357.528 + 0.9856003 * n;
+			double d = l + 1.915*java.lang.Math.sin(g/180*java.lang.Math.PI) + 0.02 * java.lang.Math.sin(2*g/180*java.lang.Math.PI);
+			// Rektaszension alpha und Deklination delta der Sonne berechnen
+			double e = 23.439 -0.0000004 * n;
+			double alphaNenner = java.lang.Math.cos(d/180*java.lang.Math.PI);
+			double alpha = 180/java.lang.Math.PI*java.lang.Math.atan(java.lang.Math.cos(e/180*java.lang.Math.PI)*java.lang.Math.sin(d/180*java.lang.Math.PI)/alphaNenner);
+			double delta = 180/java.lang.Math.PI*java.lang.Math.asin(java.lang.Math.sin(e/180*java.lang.Math.PI)*java.lang.Math.sin(d/180*java.lang.Math.PI) );
+			if (alphaNenner<0) {alpha +=180;}
+			// Azimut
+			double t0 = (jd0 - 2451545.)/36525.; // schon in t0 bzw jd0 richtig berechnet?
+			double thetaHG = 6.697376 + 2400.05134 * t0 + 1.002738 * ((double)stunde + (double)minute/60.);
+			double theta = thetaHG * 15. + lon;
+			double azimutNenner = java.lang.Math.cos((theta-alpha)/180*java.lang.Math.PI)*java.lang.Math.sin(lat/180*java.lang.Math.PI)-
+			java.lang.Math.tan(delta/180*java.lang.Math.PI)*java.lang.Math.cos(lat/180*java.lang.Math.PI);
+			float azimut = (float) java.lang.Math.atan(java.lang.Math.sin((theta-alpha)/180*java.lang.Math.PI)/
+					azimutNenner);
+			azimut = (float) (azimut * 180f / java.lang.Math.PI);
+			if (azimutNenner<0) azimut +=180.;
+			// null = Sueden auf Null = Norden umrechnen
+			azimut +=180.;
+			if (azimut >360.) azimut -=360.;
+			return azimut;
+		} catch (IndexOutOfBoundsException e) {
+			// wird von substring geworfen wenn datum / utc nicht genug Ziffern haben
+			// NumberFormatException wird au?erdem von Convert.ParseInt direkt geworfen wenn
+			// nicht in Int konvertiert werden kann
+			throw new NumberFormatException();
+		}
+	}
+}
+/**
+ * Thread for reading data from COM-port
+ *
+ */
+class SerialThread extends mThread{
+	SerialPort comSp;   
+	byte[] comBuff = new byte[1024];  
+	int comLength = 0;
+	CWGPSPoint myGPS;
+	boolean run, tcpForward;
+	Socket tcpConn;
+	String lastError = new String();
+
+	public SerialThread(SerialPortOptions spo, CWGPSPoint GPSPoint, String forwardIP) throws IOException {
+		try{
+			comSp = new SerialPort(spo);
+		} catch (IOException e) {
+			throw new IOException(spo.portName);
+		} // catch (UnsatisfiedLinkError e) {} // TODO in original java-vm 
+		if (forwardIP.length()>0) { 
+			try {
+				tcpConn = new Socket(forwardIP, 23);
+				tcpForward = true;
+			} catch (ewe.net.UnknownHostException e) { tcpForward = false; lastError = e.getMessage();
+			} catch (IOException e) { tcpForward = false; lastError = e.getMessage(); 
+			}
+		}
+		myGPS = GPSPoint;
+	}
+
+	public void run() {
+		int noData = 0;
+		int notinterpreted = 0;
+		run = true;
+		while (run){
+			try {
+				sleep(1000);
+				//Vm.debug("Loop? " + noData);
+				noData++;
+				if (noData > 5) { myGPS.noDataError(); }
+			} catch (InterruptedException e) {}
+			if (comSp != null)	{
+				comLength = comSp.nonBlockingRead(comBuff, 0 ,comBuff.length);
+				//Vm.debug("Length: " + comBuff.length);
+				if (comLength > 0)	{
+					noData = 0;
+					String str = mString.fromAscii(comBuff, 0, comLength); 
+					if (tcpForward) {
+						try {
+							tcpConn.write(comBuff, 0, comLength);
+						} catch (IOException e) { tcpForward = false; }
+					}
+					//Vm.debug(str);
+					if (myGPS.examine(str)) notinterpreted = 0; else notinterpreted++;
+					if (notinterpreted > 22) myGPS.noInterpretableData();
+				}
+			}
+		} // while
+		myGPS.noData();
+		tcpConn.close();
+	}
+
+	public void stop() {
+		run = false;
+		if (comSp != null) comSp.close();
+	}
+}
+
+/** 
+ * Class for creating a new mThread to create timer ticks to be able to do form.close in the ticked-thread. 
+ * Using the Vm.requestTimer-Method causes "ewe.sys.EventDirectionException: This task cannot be done within 
+ * a Timer Tick." in the ewe-vm when form.close is called.  
+ */
+
+class UpdateThread extends mThread {
+	public boolean run;
+	public int calldelay;
+	public Navigate ticked;
+
+	public UpdateThread (Navigate gp, int cd) {
+		ticked = gp;
+		calldelay = cd;
+	}
+
+	public void run () {
+		run = true;
+		while (run) {
+			try { sleep (calldelay);} catch (InterruptedException e) {}
+			ticked.ticked();
+		}
+	}
+
+	public void stop() {
+		run = false;
+	}
+}
+

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-02-04 23:35:16 UTC (rev 512)
+++ trunk/src/CacheWolf/Parser.java	2007-02-05 02:46:11 UTC (rev 513)
@@ -368,7 +368,7 @@
     }
     
     private String funcCp(){
-    	return Global.mainTab.gotoP.gpsPosition.toString();
+    	return Global.mainTab.nav.gpsPos.toString();
     }
     
     private double funcCrossTotal(int nargs) throws Exception {
@@ -452,13 +452,13 @@
     /** Implements a goto command goto(coordinate,optionalWaypointName).
      */
     private void funcGoto(int nargs) throws Exception {
-    	GotoPanel gotoP=Global.mainTab.gotoP;
+    	Navigate nav=Global.mainTab.nav;
 		String waypointName=null;
         if (nargs==2) waypointName=popCalcStackAsString();  
 		String coord=popCalcStackAsString();
 		if (!isValidCoord(coord)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coord);
 		// Don't want to switch to goto panel, just set the values
-		gotoP.setDestination(coord);
+		nav.setDestination(coord);
 		if (nargs==2) { // Now set the value of the addi waypoint (it must exist already)
     		int i=Global.getProfile().getCacheIndex(waypointName);
     		if (i<0) err(MyLocale.getMsg(1714,"Goto: Waypoint does not exist: ")+waypointName);

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-02-04 23:35:16 UTC (rev 512)
+++ trunk/src/CacheWolf/myTableModel.java	2007-02-05 02:46:11 UTC (rev 513)
@@ -16,7 +16,7 @@
 */
 public class myTableModel extends TableModel{
 	
-	public boolean cacheSelectionChanged = false;
+	public boolean cacheSelectionChanged = true;
 	Vector cacheDB;
 	String[] colName;
 	static Image cacheImages[] = new Image[454];



From pfeffer at mail.berlios.de  Mon Feb  5 04:43:21 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Mon, 5 Feb 2007 04:43:21 +0100
Subject: [Cachewolf-svn] r514 - trunk/src/CacheWolf
Message-ID: <200702050343.l153hLjU019767@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-05 04:43:15 +0100 (Mon, 05 Feb 2007)
New Revision: 514

Modified:
   trunk/src/CacheWolf/MapLoaderGui.java
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: es war noch ein Fehler im Aufruf vom DetailsPanel
MovingMap / MapLoader: wenn neu Karten geladen werden, l?\195?\164dt die MovingMap die Liste der Karten automatisch neu

Modified: trunk/src/CacheWolf/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/MapLoaderGui.java	2007-02-05 02:46:11 UTC (rev 513)
+++ trunk/src/CacheWolf/MapLoaderGui.java	2007-02-05 03:43:15 UTC (rev 514)
@@ -104,7 +104,6 @@
 		okBPerCache.setHotKey(0, IKeys.ENTER);
 		pnlPerCache.addLast(okBPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
 
-
 		mTab.addCard(pnlPerCache, MyLocale.getMsg(1805, "Per cache"), MyLocale.getMsg(1805, "Per Cache"));
 		this.addLast(mTab);
 	}
@@ -168,6 +167,7 @@
 		Vm.showWait(false);
 		ml.setProgressInfoBox(null);
 		progressBox.close(0);
+		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
 		(new MessageBox("Expedia maps", "Downloaded and calibrated the maps successfully", MessageBox.OKB)).execute();
 	}
 

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-05 02:46:11 UTC (rev 513)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-05 03:43:15 UTC (rev 514)
@@ -260,13 +260,13 @@
 			CacheHolder ch;
 			for (int i=cacheDB.size()-1; i>=0; i--) {
 				ch = (CacheHolder) cacheDB.get(i);
-				if (ch.is_Checked || ch == mainT.ch) { // ch == Global.mainTab.ch: always show the gray marked cache
+				if (ch.is_Checked && ch != mainT.ch) { // ch == Global.mainTab.ch: always show the gray marked cache
 					int ct = Convert.parseInt(ch.type);
 					addSymbol(ch.CacheName, ch, myTableModel.cacheImages[ct], ch.pos.latDec, ch.pos.lonDec);
 				}
 			}
 		}
-		if (mainT.ch != null) setMarkedCache(mainT.ch);
+		setMarkedCache(mainT.ch);
 		destChanged(myNavigation.destination);
 		addTrack(myNavigation.curTrack);
 		if (tracks != null && tracks.size() > 0 && ((Track)tracks.get(0)).num > 0) 
@@ -278,9 +278,16 @@
 	CacheHolder markedCache = null;
 	public void setMarkedCache(CacheHolder ch) {
 		if (ch == markedCache) return;
-		if (markedCache != null) removeMapSymbol("selectedCache");
+		if (markedCache != null) {
+			removeMapSymbol("selectedCache");
+			if (!markedCache.is_Checked) removeMapSymbol(markedCache);
+		}
+		if (ch != null) {
+			addSymbol("selectedCache", MARK_CACHE_IMAGE, ch.pos.latDec, ch.pos.lonDec);
+			int ct = Convert.parseInt(ch.type);
+			addSymbolIfNecessary(ch.CacheName, ch, myTableModel.cacheImages[ct], ch.pos.latDec, ch.pos.lonDec);
+		}
 		markedCache = ch;
-		if (markedCache != null) addSymbol("selectedCache", MARK_CACHE_IMAGE, ch.pos.latDec, ch.pos.lonDec);
 	}
 	
 	public void addTrack(Track tr) {
@@ -681,6 +688,13 @@
 		mmp.addImage(ms);
 		return ms;
 	}
+	
+	public void addSymbolIfNecessary(String name, Object mapObject, Image imSymb, double lat, double lon) {
+		if (findMapSymbol(name) >= 0) return;
+		else addSymbol(name, mapObject, imSymb, lat, lon);
+		
+	}
+		
 	public void addSymbol(String name, Object mapObject, Image imSymb, double lat, double lon) {
 		if (symbols==null) symbols=new Vector();
 		MapSymbol ms = new MapSymbol(name, mapObject, imSymb, lat, lon);
@@ -724,6 +738,12 @@
 		if (symbNr != -1) removeMapSymbol(symbNr);
 	}
 
+	public void removeMapSymbol(Object obj) {
+		int symbNr = findMapSymbol(obj);
+		if (symbNr != -1) removeMapSymbol(symbNr);
+	}
+
+
 	public void removeMapSymbol(int SymNr) {
 		mmp.removeImage(((MapSymbol)symbols.get(SymNr)));
 		symbols.removeElementAt(SymNr);
@@ -738,6 +758,16 @@
 		}
 		return -1;
 	}
+	
+	public int findMapSymbol(Object obj) {
+		if (symbols == null) return -1;
+		MapSymbol ms;
+		for (int i = symbols.size() -1; i >= 0 ; i--) {
+			ms= (MapSymbol)symbols.get(i);
+			if (ms.mapObject == obj) return i;
+		}
+		return -1;
+	}
 
 	/**
 	 * Move the map so that the posCircle is at lat/lon
@@ -869,7 +899,7 @@
 			posCircleLon = lon; // choosemap calls setmap with posCircle-coos
 			while (currentMap == null) {
 				mmp.chooseMap(); // force the user to select a scale // TODO empty maps on top?
-				if (currentMap == null) (new MessageBox("Error", "Moving map cannot run without a map - please select one", MessageBox.OKB)).execute();
+				if (currentMap == null) (new MessageBox("Error", "Moving map cannot run without a map - please select one. \n You can select an empty map", MessageBox.OKB)).execute();
 			}
 		}
 		inBestMap = false;



From bilbowolf at mail.berlios.de  Mon Feb  5 05:38:02 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Mon, 5 Feb 2007 05:38:02 +0100
Subject: [Cachewolf-svn] r515 - trunk/src/CacheWolf
Message-ID: <200702050438.l154c2gK021600@sheep.berlios.de>

Author: bilbowolf
Date: 2007-02-05 05:38:01 +0100 (Mon, 05 Feb 2007)
New Revision: 515

Modified:
   trunk/src/CacheWolf/Version.java
Log:


Modified: trunk/src/CacheWolf/Version.java
===================================================================
--- trunk/src/CacheWolf/Version.java	2007-02-05 03:43:15 UTC (rev 514)
+++ trunk/src/CacheWolf/Version.java	2007-02-05 04:38:01 UTC (rev 515)
@@ -10,7 +10,7 @@
 	static final String VER_MAJOR = "";
 	static final String VER_MINOR = "";
 	static final String VER_BUILD = " RC ";
-	static final String VER_SVN ="$LastChangedRevision$";  // the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
+	static final String VER_SVN ="$LastChangedRevision$";  //the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
 	
 	/**
 	 * @return



From salzkammergut at mail.berlios.de  Mon Feb  5 19:03:27 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Mon, 5 Feb 2007 19:03:27 +0100
Subject: [Cachewolf-svn] r516 - trunk/src/CacheWolf
Message-ID: <200702051803.l15I3R4v006136@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-05 19:03:21 +0100 (Mon, 05 Feb 2007)
New Revision: 516

Modified:
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/FilterScreen.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/SearchCache.java
   trunk/src/CacheWolf/StatusBar.java
Log:
Filter/Suche Fix und Verbesserung:
Suche arbeitet jetzt auf die gefilterten (=sichtbaren) Datensaetze.
Suche aufheben, stellt den Filterzustand vor der Suche (=gefiltert/nicht gefiltert/invertiert) wieder her
+Filter hat einen neuen Punkt "Anwenden", der den letzten Filter noch einmal ausfuehrt
+Im Statuspanel wird angezeigt wenn ein Filter aktiv ist 
   (um zu vielen Rueckfragen vorzubeugen weil beim Profil laden der Filter automatisch angewendet wird)

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2007-02-05 04:38:01 UTC (rev 515)
+++ trunk/src/CacheWolf/Filter.java	2007-02-05 18:03:21 UTC (rev 516)
@@ -438,6 +438,7 @@
 			}
 			
 		} // for
+		Global.getPref().filterActive=true;
 	}
 	
 	/**
@@ -454,6 +455,7 @@
 			else
 				ch.is_filtered=true; // Hide all those that have the wrong is_black status
 		}
+		Global.getPref().filterInverted=true;
 	}
 	
 	/**
@@ -467,14 +469,18 @@
 			ch = (CacheHolder)cacheDB.get(i);
 			ch.is_filtered=(ch.is_black^showBlackListed) || CacheType.isAddiWpt(ch.type); // Always filter blacklisted caches
 		}
+		Global.getPref().filterActive=false;
+		Global.getPref().filterInverted=false;
+/*
 		Profile prof=Global.getProfile();
 		prof.filterType = new String(Profile.FILTERTYPE);
 		prof.filterRose = new String(Profile.FILTERROSE);
 		prof.filterVar = new String(Profile.FILTERVAR);
-		prof.filterDist="";
-		prof.filterDiff="";
-		prof.filterTerr="";
-		
+		prof.filterSize = new String(Profile.FILTERSIZE);
+		prof.filterDist="L";
+		prof.filterDiff="L";
+		prof.filterTerr="L";
+*/		
 	}
 }
 

Modified: trunk/src/CacheWolf/FilterScreen.java
===================================================================
--- trunk/src/CacheWolf/FilterScreen.java	2007-02-05 04:38:01 UTC (rev 515)
+++ trunk/src/CacheWolf/FilterScreen.java	2007-02-05 18:03:21 UTC (rev 516)
@@ -249,7 +249,8 @@
 		pnlButtons.addLast(btnTypes=new mButton(MyLocale.getMsg(723,"Types"))); 
 		pnlButtons.addLast(btnAddi=new mButton("Addi Wpt")); 
 		pnlButtons.addLast(btnContainer=new mButton(MyLocale.getMsg(724,"Container")));
-		pnlButtons.addLast(btnSearch=new mButton("Search")); btnSearch.modify(Disabled,0);
+		// Search ist f?r 0.9n noch deaktiviert
+		//pnlButtons.addLast(btnSearch=new mButton("Search")); btnSearch.modify(Disabled,0);
 		addNext(pnlButtons,HSTRETCH,FILL);
 
 		cp.addItem(pnlBearDist,"Bear",null);

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-02-05 04:38:01 UTC (rev 515)
+++ trunk/src/CacheWolf/MainMenu.java	2007-02-05 18:03:21 UTC (rev 516)
@@ -26,7 +26,7 @@
 	private MenuItem about, wolflang, sysinfo, legend;
 	private MenuItem exportpcx5, exporthtml, exporttop50, exportGPX, exportASC, exportTomTom, exportMSARCSV;
 	private MenuItem exportOZI, exportKML, exportTPL;
-	private MenuItem filtCreate, filtClear, filtInvert, filtSelected, filtBlack;
+	private MenuItem filtCreate, filtClear, filtInvert, filtSelected, filtBlack, filtApply;
 	private MenuItem exportGPS, exportCacheMate,mnuSeparator;
 	private MenuItem orgCopy, orgMove, orgDelete;
 	private MenuItem mnuNewProfile, mnuOpenProfile, mnuEditProfile;
@@ -106,27 +106,30 @@
 		///////////////////////////////////////////////////////////////////////
 		// Create the "Filter" pulldown menu
 		///////////////////////////////////////////////////////////////////////
-		MenuItem[] filterMenuItems=new MenuItem[7];
-		filterMenuItems[0] = filtCreate  = new MenuItem(MyLocale.getMsg(114,"Create")); 
-		filterMenuItems[1] = filtInvert  = new MenuItem(MyLocale.getMsg(115,"Invert")); 
-		filterMenuItems[2] = filtClear   = new MenuItem(MyLocale.getMsg(116,"Clear"));
-		filterMenuItems[3] = mnuSeparator;
-		filterMenuItems[4] = filtBlack   = new MenuItem(MyLocale.getMsg(161,"Show Blacklist"));
-		filterMenuItems[5] = mnuSeparator;
-		filterMenuItems[6] = filtSelected = new MenuItem(MyLocale.getMsg(160,"Selected"));
+		MenuItem[] filterMenuItems=new MenuItem[8];
+		filterMenuItems[0] = filtApply  = new MenuItem(MyLocale.getMsg(709,"Apply")); 
+		filterMenuItems[1] = filtCreate  = new MenuItem(MyLocale.getMsg(114,"Create")); 
+		filterMenuItems[2] = filtInvert  = new MenuItem(MyLocale.getMsg(115,"Invert")); 
+		filterMenuItems[3] = filtClear   = new MenuItem(MyLocale.getMsg(116,"Clear"));
+		filterMenuItems[4] = mnuSeparator;
+		filterMenuItems[5] = filtBlack   = new MenuItem(MyLocale.getMsg(161,"Show Blacklist"));
+		filterMenuItems[6] = mnuSeparator;
+		filterMenuItems[7] = filtSelected = new MenuItem(MyLocale.getMsg(160,"Selected"));
 		
 		///////////////////////////////////////////////////////////////////////
 		// Create a combined "Filter and Search" pulldown menu for devices with small screens
 		///////////////////////////////////////////////////////////////////////
-		MenuItem[] filterAndSearchMenuItems=new MenuItem[8];
-		filterAndSearchMenuItems[0]=filtCreate;
-		filterAndSearchMenuItems[1]=filtInvert;
-		filterAndSearchMenuItems[2]=filtClear;
-		filterAndSearchMenuItems[3]=mnuSeparator;
-		filterAndSearchMenuItems[4]=filtBlack;
-		filterAndSearchMenuItems[5]=mnuSeparator;
-		filterAndSearchMenuItems[6]=search;
-		filterAndSearchMenuItems[7]=searchClr;
+		MenuItem[] filterAndSearchMenuItems=new MenuItem[10];
+		filterAndSearchMenuItems[0]=filtApply;
+		filterAndSearchMenuItems[1]=filtCreate;
+		filterAndSearchMenuItems[2]=filtInvert;
+		filterAndSearchMenuItems[3]=filtClear;
+		filterAndSearchMenuItems[4]=mnuSeparator;
+		filterAndSearchMenuItems[5]=filtBlack;
+		filterAndSearchMenuItems[6]=filtSelected;
+		filterAndSearchMenuItems[7]=mnuSeparator;
+		filterAndSearchMenuItems[8]=search;
+		filterAndSearchMenuItems[9]=searchClr;
 		
 		// Depending on screen width display either filter and searach menus or the combined menu 
 		if (MyLocale.getScreenWidth()>300) {
@@ -270,6 +273,12 @@
 				filtBlack.modifiers&=~MenuItem.Checked;
 				tbp.resetModel();
 			}
+			if(mev.selectedItem == filtApply){
+				Filter flt = new Filter();
+				flt.setFilter();
+				flt.doFilter();
+				tbp.refreshTable();
+			}
 			if(mev.selectedItem == filtCreate){
 				scnFilter.setData();
 				scnFilter.execute(father.getFrame(), Gui.CENTER_FRAME);

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-02-05 04:38:01 UTC (rev 515)
+++ trunk/src/CacheWolf/MainTab.java	2007-02-05 18:03:21 UTC (rev 516)
@@ -27,6 +27,7 @@
 	String lastselected = new String();
 	CacheHolder ch =null;
 	MainMenu mnuMain;
+	StatusBar statBar;
 	MovingMap mm;
 	Navigate nav;
 
@@ -37,6 +38,7 @@
 		profile=Global.getProfile();
 		if (!pref.tabsAtTop) tabLocation=SOUTH;
 		cacheDB = profile.cacheDB;
+		this.statBar=statBar;
 		MyLocale.setSIPButton();
 		//Don't expand tabs if the screen is very narrow, i.e. HP IPAQ 65xx, 69xx
 		if (MyLocale.getScreenWidth() <= 240) this.dontExpandTabs=true;
@@ -153,7 +155,8 @@
 						//Vm.debug("Error loading: "+ch.wayPoint);
 					  }
 				  }
-			  }
+			  } else statBar.updateDisplay();
+				  
 			  // If no cache is selected, create a new one
 			  switch (this.getSelectedItem()) {
 				  case 1:  // DetailsPanel

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-02-05 04:38:01 UTC (rev 515)
+++ trunk/src/CacheWolf/Preferences.java	2007-02-05 18:03:21 UTC (rev 516)
@@ -45,6 +45,10 @@
 
 	/** Toggle for showing blacklisted caches. Can be toggled through the Filter menu */
 	public boolean showBlacklisted=false;
+	/** Indicator whether a filter is active. Used in status bar to indicate filter status */
+	public boolean filterActive=false;
+	/** Indicator whether a filter is inverted */
+	public boolean filterInverted=false;
 	public int myAppHeight = 0;
 	public int myAppWidth = 0;
 	//public int nLogs = 5;

Modified: trunk/src/CacheWolf/SearchCache.java
===================================================================
--- trunk/src/CacheWolf/SearchCache.java	2007-02-05 04:38:01 UTC (rev 515)
+++ trunk/src/CacheWolf/SearchCache.java	2007-02-05 18:03:21 UTC (rev 516)
@@ -19,43 +19,43 @@
 	/**
 	* Method to iterate through the cache database.
 	* Each cache where the search string is found (in waypoint
-	* and / or cache name) is flagged as matching
+	* and / or cache name) is flagged as matching. The search only
+	* acts on the filtered (=visible) set of caches
 	*/
 	public void search(String searchStr){
 		if(searchStr.length()>0){
 			searchStr = searchStr.toUpperCase();
-			CacheHolder ch = new CacheHolder();
+			CacheHolder ch;
 			//Search through complete database
 			//Mark finds by setting is_flaged
 			//TableModel will be responsible for displaying
 			//marked caches.
 			for(int i = 0;i < cacheDB.size();i++){
 				ch = (CacheHolder)cacheDB.get(i);
-				ch.is_filtered = true;
-				if(ch.wayPoint.indexOf(searchStr) >=0 ){
-					ch.is_flaged = true;
-					ch.is_filtered = false;
-				}
-				if((ch.CacheName.toUpperCase()).indexOf(searchStr) >=0){
-					ch.is_flaged = true;
-					ch.is_filtered = false;
-				}
-				cacheDB.set(i, ch);
+				if (ch.is_filtered) break; // Reached end of visible records
+				if(ch.wayPoint.indexOf(searchStr) <0 && 
+				   ch.CacheName.toUpperCase().indexOf(searchStr) <0){
+					ch.is_flaged = false;
+					ch.is_filtered = true;
+				} else
+					ch.is_flaged=true;
 			} // for
 		} // if
 	}
 	
 	/**
 	* Method to remove the flag from all caches in the 
-	* cache database.
+	* cache database. Restore to the state of the filter
 	*/
 	public void clearSearch(){
-		CacheHolder ch = new CacheHolder();
-		for(int i = 0;i < cacheDB.size();i++){
-			ch = (CacheHolder)cacheDB.get(i);
-			ch.is_flaged = false;
-			ch.is_filtered = false;
-			cacheDB.set(i,ch);
+		Filter flt=new Filter();
+		if (Global.getPref().filterActive) {
+			flt.setFilter();
+			flt.doFilter();
+		} else {
+			flt.clearFilter();
 		}
+		if (Global.getPref().filterInverted) 
+			flt.invertFilter();
 	}
 }

Modified: trunk/src/CacheWolf/StatusBar.java
===================================================================
--- trunk/src/CacheWolf/StatusBar.java	2007-02-05 04:38:01 UTC (rev 515)
+++ trunk/src/CacheWolf/StatusBar.java	2007-02-05 18:03:21 UTC (rev 516)
@@ -1,5 +1,6 @@
 package CacheWolf;
 
+import ewe.sys.Vm;
 import ewe.ui.*;
 import ewe.util.*;
 
@@ -10,26 +11,36 @@
  */
 public class StatusBar extends CellPanel{
 	DBStats stats;
-	mLabel disp;
+	mLabel disp,lblFlt,lblCenter;
 	Preferences pref;
 	
 	public StatusBar(Preferences p, Vector db){
 		pref=p;
 		stats = new DBStats(db);
-		this.addLast(disp = new mLabel(""),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		addNext(disp = new mLabel(""),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		addNext(lblFlt= new mLabel("Flt"),CellConstants.DONTSTRETCH, CellConstants.DONTFILL); lblFlt.backGround=new ewe.fx.Color(0,255,0);
+		addLast(lblCenter=new mLabel(""),CellConstants.STRETCH, WEST|CellConstants.FILL);
 		updateDisplay();
 	}
 	
 	public void updateDisplay(){
-		String dspString;
-		dspString = MyLocale.getMsg(4500,"Tot:") + " " + stats.total() + " " +
+		String strStatus, strCenter="";
+		strStatus = MyLocale.getMsg(4500,"Tot:") + " " + stats.total() + " " +
 					MyLocale.getMsg(4501,"Dsp:") + " " + stats.visible() + " " +
 					MyLocale.getMsg(4502,"Fnd:") + " " + stats.totalFound() + "  ";
+		disp.setText(strStatus);
+		// Indicate that a filter is active in the status line
+		Profile prof=Global.getProfile();
+		if (Global.getPref().filterActive)
+			lblFlt.modify(0,Invisible); // Set the filter to "invisible"
+		else
+			lblFlt.modify(Invisible,0); // Make filter visible
 		// Current centre can only be displayed if screen is big
 		// Otherwise it forces a scrollbar
 		if (MyLocale.getScreenWidth()>=320) 
-			dspString+="  \u00a4 " + pref.curCentrePt.toString();
+			strCenter="  \u00a4 " + pref.curCentrePt.toString();
 		
-		disp.setText(dspString);
+		lblCenter.setText(strCenter);
+		repaint();
 	}
 }



From salzkammergut at mail.berlios.de  Mon Feb  5 19:09:22 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Mon, 5 Feb 2007 19:09:22 +0100
Subject: [Cachewolf-svn] r517 - trunk/resources
Message-ID: <200702051809.l15I9MsE010124@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-05 19:09:17 +0100 (Mon, 05 Feb 2007)
New Revision: 517

Modified:
   trunk/resources/cachewolf.Languages.cfg
Log:
Languages.cfg: Einige uebersehene ae's und ue's konvertiert

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-02-05 18:03:21 UTC (rev 516)
+++ trunk/resources/cachewolf.Languages.cfg	2007-02-05 18:09:17 UTC (rev 517)
@@ -200,8 +200,8 @@
 		1019=Diesen als Zentrum setzen
 		1020=Im Browser online %f6ffnen
 		1021=Beschreibung %f6ffnen
-		1022=Alle mit H?kchen markierten Caches l%f6schen?
-		1023=Diese Funktion steht gegenw%e4rtig nur f?r Geocaching.com zur Verf%fcgung
+		1022=Alle mit H%e4kchen markierten Caches l%f6schen?
+		1023=Diese Funktion steht gegenw%e4rtig nur f%fcr Geocaching.com zur Verf%fcgung
 		1024=Entfernungen in der Listenansicht~vom aktuellen Standpunkt aus~neu berechnet
 		1025=Kann Zentrum nicht setzen (GPS-Position unzul%e4ssig)
 		1100=Profile
@@ -274,7 +274,7 @@
 		1707=Gefunden: 
 		1708=Funktionsname nicht eindeutig: 
 		1709=Unbekannte Funktion: 
-		1710=Kann leere Zeichenkette nicht z?hlen
+		1710=Kann leere Zeichenkette nicht z%e4hlen
 		1711=Ersatzzeichenketten m%fcssen gleiche L%e4nge haben
 		1712=Unzul%e4ssige Koordinate: 
 		1713=Falsches Koordinatenformat. Erlaubt sind CW/DD/DMM/DMS/UTM



From pfeffer at mail.berlios.de  Mon Feb  5 19:14:44 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Mon, 5 Feb 2007 19:14:44 +0100
Subject: [Cachewolf-svn] r518 - trunk/src/CacheWolf
Message-ID: <200702051814.l15IEi7Q014704@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-05 19:14:38 +0100 (Mon, 05 Feb 2007)
New Revision: 518

Modified:
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/Navigate.java
Log:
MovingMap: Bug fixed: nach einer der letzten Updates hat Kontextmen?\195?\188 "goto here" den GPS-Punkt anstelle des Punktes in der Karts als Goto-Punkt gesetzt

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-05 18:09:17 UTC (rev 517)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-05 18:14:38 UTC (rev 518)
@@ -1521,6 +1521,7 @@
 				if (clickedCache != null) openCacheDescMenuItem = new MenuItem("Open '"+clickedCache.CacheName+"'$o"); // clickedCache == null can happen if clicked on the goto-symbol
 				kontextMenu.addItem(openCacheDescMenuItem);
 			}
+			saveMapLoc = p;
 			kontextMenu.exec(this, new Point(p.x, p.y), this);
 		}
 	}

Modified: trunk/src/CacheWolf/Navigate.java
===================================================================
--- trunk/src/CacheWolf/Navigate.java	2007-02-05 18:09:17 UTC (rev 517)
+++ trunk/src/CacheWolf/Navigate.java	2007-02-05 18:14:38 UTC (rev 518)
@@ -90,7 +90,7 @@
 		destination = new CWPoint (d);
 		if (gotoPanel != null) gotoPanel.destChanged();
 		if (movingMap != null) { // TODO make movingmap the same as gotopanel
-			movingMap.destChanged(gpsPos);
+			movingMap.destChanged(destination);
 			movingMap.repaintNow();
 		}
 	}



From salzkammergut at mail.berlios.de  Mon Feb  5 19:19:00 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Mon, 5 Feb 2007 19:19:00 +0100
Subject: [Cachewolf-svn] r519 - trunk/src/CacheWolf
Message-ID: <200702051819.l15IJ0rX030853@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-05 19:18:57 +0100 (Mon, 05 Feb 2007)
New Revision: 519

Modified:
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/myTableControl.java
Log:
Bugfix: Die Meldung beim Berechnen der Entfernung zum neuen Zentrum wurde doppelt ausgegeben

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-02-05 18:14:38 UTC (rev 518)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-02-05 18:18:57 UTC (rev 519)
@@ -358,7 +358,6 @@
 				pref.curCentrePt.set(myNavigation.gpsPos);
 				mainT.updateBearDist();
 				Vm.showWait(false);
-				(new MessageBox("Info", "Entfernungen in der Listenansicht \nvom aktuellen Standpunkt aus \nneu berechnet", MessageBox.OKB)).execute();
 			}
 			//Start moving map
 			if (ev.target == btnMap){

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-02-05 18:14:38 UTC (rev 518)
+++ trunk/src/CacheWolf/myTableControl.java	2007-02-05 18:18:57 UTC (rev 519)
@@ -141,7 +141,6 @@
 				pref.curCentrePt.set(cp);
 				Global.mainTab.updateBearDist(); // Update the distances with a warning message
 				tbp.refreshTable();
-				(new MessageBox("Info", "Entfernungen in der Listenansicht \nvom aktuellen Standpunkt aus \nneu berechnet", MessageBox.OKB)).execute();
 			}
 		}
 		



From salzkammergut at mail.berlios.de  Mon Feb  5 19:24:02 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Mon, 5 Feb 2007 19:24:02 +0100
Subject: [Cachewolf-svn] r520 - trunk/src/CacheWolf
Message-ID: <200702051824.l15IO2pj031121@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-05 19:23:59 +0100 (Mon, 05 Feb 2007)
New Revision: 520

Modified:
   trunk/src/CacheWolf/SearchCache.java
Log:
SearchCache: Bugfix (beim Aufheben der Suche wurde is_flaged nicht geloescht)

Modified: trunk/src/CacheWolf/SearchCache.java
===================================================================
--- trunk/src/CacheWolf/SearchCache.java	2007-02-05 18:18:57 UTC (rev 519)
+++ trunk/src/CacheWolf/SearchCache.java	2007-02-05 18:23:59 UTC (rev 520)
@@ -57,5 +57,8 @@
 		}
 		if (Global.getPref().filterInverted) 
 			flt.invertFilter();
+		for(int i = cacheDB.size()-1;i >=0;i--){
+			((CacheHolder)cacheDB.get(i)).is_flaged=false;
+		}
 	}
 }



From salzkammergut at mail.berlios.de  Mon Feb  5 19:46:13 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Mon, 5 Feb 2007 19:46:13 +0100
Subject: [Cachewolf-svn] r521 - trunk/src/CacheWolf
Message-ID: <200702051846.l15IkDJO032384@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-05 19:46:10 +0100 (Mon, 05 Feb 2007)
New Revision: 521

Modified:
   trunk/src/CacheWolf/myInteractivePanel.java
Log:
myInteractivePanel: Beim laengeren Anklicken eines Caches (bzw. bei Mouseover am PC) wird auch der Cachename angezeigt

Modified: trunk/src/CacheWolf/myInteractivePanel.java
===================================================================
--- trunk/src/CacheWolf/myInteractivePanel.java	2007-02-05 18:23:59 UTC (rev 520)
+++ trunk/src/CacheWolf/myInteractivePanel.java	2007-02-05 18:46:10 UTC (rev 521)
@@ -17,7 +17,7 @@
 	boolean penMoving = false;
 	int x1,y1,x2,y2 = 0;
 	static Color RED = new Color(255,0,0);
-	Font font = new Font("Verdana", Font.BOLD, 10);
+	Font font = new Font("gui", Font.BOLD, 10);
 	FontMetrics fm = getFontMetrics();
 	long timePenOn=0;
 	AniImage imgInfo;
@@ -50,17 +50,24 @@
 	}
 	public boolean imageMovedOn(AniImage which) {
 		timePenOn=Vm.getTimeStampLong();
+		setFont(font);
 		RadarPanelImage imgRP=(RadarPanelImage) which;
 		ewe.util.Vector cacheDB=Global.getProfile().cacheDB;
 		CacheHolder ch=(CacheHolder) cacheDB.get(imgRP.rownum);
 		String s=ch.wayPoint+"  "+ch.CacheSize+" / "+strDifficulty+"="+ch.hard+"  "+strTerrain+"="+ch.terrain;
-		int tw;
-		Image img = new Image(tw=fm.getTextWidth(s)+2,fm.getHeight()+2);
+		String s1=ch.CacheName;
+		if (s1.length()>40) s1=s1.substring(0,40);
+		int tw=fm.getTextWidth(s)+2;
+		int tw1=fm.getTextWidth(s1)+2;
+		if (tw1>tw) tw=tw1;
+		int h=fm.getHeight();
+		Image img = new Image(tw,h+h);
 		Graphics g = new Graphics(img);
 		g.setColor(new Color(0,0,255));
-		g.fillRect(0,0,tw, fm.getHeight()+2);
+		g.fillRect(0,0,tw, h+h);
 		g.setColor(Color.White);
 		g.drawText(s, 1,1);
+		g.drawText(s1,1,h);
 		imgInfo = new AniImage(img);
 		Rect r=getVisibleArea(null);
 		imgInfo.setLocation(r.x,r.y); // Place the info at top left corner



From kalli at mail.berlios.de  Mon Feb  5 19:48:04 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Mon, 5 Feb 2007 19:48:04 +0100
Subject: [Cachewolf-svn] r522 - trunk/src/CacheWolf
Message-ID: <200702051848.l15Im4G5032454@sheep.berlios.de>

Author: kalli
Date: 2007-02-05 19:48:00 +0100 (Mon, 05 Feb 2007)
New Revision: 522

Modified:
   trunk/src/CacheWolf/Profile.java
Log:
Schleifendurchlaufrichtung fuer buildReference geaendert, damit addi wpts in der richtigen Reihenfolge auftauchen. Sollte genauso performant sein.

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-02-05 18:46:10 UTC (rev 521)
+++ trunk/src/CacheWolf/Profile.java	2007-02-05 18:48:00 UTC (rev 522)
@@ -343,7 +343,8 @@
 					dbIndex.put((String)ch.wayPoint, new Integer(i));
 			   }
 			   // Build refeneces
-			   for(int i = cacheDB.size() -1; i >= 0;i--){
+			   int max = cacheDB.size();
+			   for(int i =  0; i < max ;i++){
 					ch = (CacheHolder)cacheDB.get(i);
 					if (ch.isAddiWpt()) {
 						//search main cache



From salzkammergut at mail.berlios.de  Mon Feb  5 21:53:53 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Mon, 5 Feb 2007 21:53:53 +0100
Subject: [Cachewolf-svn] r523 - trunk/src/CacheWolf
Message-ID: <200702052053.l15KrrLD011071@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-05 21:53:47 +0100 (Mon, 05 Feb 2007)
New Revision: 523

Modified:
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/NewProfileForm.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/ProfilesForm.java
   trunk/src/CacheWolf/SearchCache.java
   trunk/src/CacheWolf/StatusBar.java
Log:
Filter: Bugfix Filteranzeige beim Laden eines leeren Profils bzw. Erstellen eines neuen Profils
Refactoring von filterActive, filterInverted und showBlacklisted von Preferences nach Filter

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2007-02-05 18:48:00 UTC (rev 522)
+++ trunk/src/CacheWolf/Filter.java	2007-02-05 20:53:47 UTC (rev 523)
@@ -11,6 +11,12 @@
 *   @author BilboWolf (optimiert von salzkammergut)
 */
 public class Filter{
+	/** Toggle for showing blacklisted caches. Can be toggled through the Filter menu */
+	public static boolean showBlacklisted=false;
+	/** Indicator whether a filter is inverted */
+	public static boolean filterInverted=false;
+	/** Indicator whether a filter is active. Used in status bar to indicate filter status */
+	public static boolean filterActive=false;
 	
 	private static final int SMALLER = -1;
 	private static final int EQUAL = 0;
@@ -297,11 +303,11 @@
 	*/
 	public void doFilter(){
 		Vector cacheDB=Global.getProfile().cacheDB;
+		if (cacheDB.size()==0) return;
 		CacheHolder ch;
 		int cacheTypePattern;
 		int cacheRosePattern;
 		int cacheSizePattern;
-		boolean showBlackListed=Global.getPref().showBlacklisted;
 		// Values from filterscreen are parsed outside the main filter loop (fsc=FilterSCreen)
 		double dummyd1;
 		//Loop db and match once against type pattern and once against rose pattern
@@ -313,7 +319,7 @@
 		// A cache is only displayed (i.e. is_filtered = false) if it meets all 9 filter criteria
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
 			ch = (CacheHolder)cacheDB.get(i);
-			ch.is_filtered = ch.is_black^showBlackListed;
+			ch.is_filtered = ch.is_black^showBlacklisted;
 			///////////////////////////////
 			// Filter criterium 1: Cache type
 			///////////////////////////////
@@ -438,7 +444,7 @@
 			}
 			
 		} // for
-		Global.getPref().filterActive=true;
+		if (hasFilter())filterActive=true;
 	}
 	
 	/**
@@ -447,7 +453,8 @@
 	public void invertFilter(){
 		Vector cacheDB=Global.getProfile().cacheDB;
 		CacheHolder ch;
-		boolean showBlackListed=Global.getPref().showBlacklisted;
+		if (cacheDB.size()==0) return;
+		boolean showBlackListed=Filter.showBlacklisted;
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
 			ch = (CacheHolder)cacheDB.get(i);
 			if (ch.is_black==showBlackListed)
@@ -455,7 +462,7 @@
 			else
 				ch.is_filtered=true; // Hide all those that have the wrong is_black status
 		}
-		Global.getPref().filterInverted=true;
+		filterInverted=true;
 	}
 	
 	/**
@@ -464,23 +471,24 @@
 	public void clearFilter(){
 		Vector cacheDB=Global.getProfile().cacheDB;
 		CacheHolder ch;
-		boolean showBlackListed=Global.getPref().showBlacklisted;
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
 			ch = (CacheHolder)cacheDB.get(i);
-			ch.is_filtered=(ch.is_black^showBlackListed) || CacheType.isAddiWpt(ch.type); // Always filter blacklisted caches
+			ch.is_filtered=(ch.is_black^showBlacklisted) || CacheType.isAddiWpt(ch.type); // Always filter blacklisted caches
 		}
-		Global.getPref().filterActive=false;
-		Global.getPref().filterInverted=false;
-/*
+		filterActive=false;
+		filterInverted=false;
+	}
+
+	public boolean hasFilter() {
 		Profile prof=Global.getProfile();
-		prof.filterType = new String(Profile.FILTERTYPE);
-		prof.filterRose = new String(Profile.FILTERROSE);
-		prof.filterVar = new String(Profile.FILTERVAR);
-		prof.filterSize = new String(Profile.FILTERSIZE);
-		prof.filterDist="L";
-		prof.filterDiff="L";
-		prof.filterTerr="L";
-*/		
+		return !(prof.filterType.equals(Profile.FILTERTYPE) &&
+		    prof.filterRose.equals(Profile.FILTERROSE) &&
+		    prof.filterVar.equals(Profile.FILTERVAR) &&
+		    prof.filterSize.equals(Profile.FILTERSIZE) &&
+		    prof.filterDist.equals("L") &&
+		    prof.filterDiff.equals("L") &&
+		    prof.filterTerr.equals("L"));
 	}
+
 }
 

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-02-05 18:48:00 UTC (rev 522)
+++ trunk/src/CacheWolf/MainMenu.java	2007-02-05 20:53:47 UTC (rev 523)
@@ -200,7 +200,7 @@
 					pref.lastProfile=profile.name=f.profileDir;
 					pref.savePreferences(); // Remember that this was the last profile used
 					profile.dataDir=pref.baseDir+f.profileDir+"/";
-					pref.showBlacklisted=false;
+					Filter.showBlacklisted=false;
 					filtBlack.modifiers&=~MenuItem.Checked;
 					tbp.refreshTable();
 				}
@@ -213,7 +213,7 @@
 					profile.readIndex();
 					pref.curCentrePt.set(profile.centre);
 					filtBlack.modifiers&=~MenuItem.Checked;
-					pref.showBlacklisted=false;
+					Filter.showBlacklisted=false;
 					tbp.resetModel();
 					Global.mainTab.tbP.gotoFirstLine();
 				}
@@ -262,14 +262,14 @@
 						}
 					}
 				}
-				pref.showBlacklisted=false;
+				Filter.showBlacklisted=false;
 				filtBlack.modifiers&=~MenuItem.Checked;
 				tbp.resetModel();
 			}
 			if(mev.selectedItem == loadOC){
 				OCXMLImporter oc = new OCXMLImporter(pref,profile);
 				oc.doIt();
-				pref.showBlacklisted=false;
+				Filter.showBlacklisted=false;
 				filtBlack.modifiers&=~MenuItem.Checked;
 				tbp.resetModel();
 			}
@@ -291,7 +291,7 @@
 			}
 			if(mev.selectedItem == filtBlack){
 				filtBlack.modifiers^=MenuItem.Checked;
-				pref.showBlacklisted=!pref.showBlacklisted;
+				Filter.showBlacklisted=!Filter.showBlacklisted;
 				Filter flt = new Filter();
 				flt.clearFilter();
 				tbp.refreshTable();

Modified: trunk/src/CacheWolf/NewProfileForm.java
===================================================================
--- trunk/src/CacheWolf/NewProfileForm.java	2007-02-05 18:48:00 UTC (rev 522)
+++ trunk/src/CacheWolf/NewProfileForm.java	2007-02-05 20:53:47 UTC (rev 523)
@@ -35,16 +35,18 @@
 				profileDir=inpDir.getDisplayText();
 				File f=new File(baseDir+profileDir);
 				if (f.exists()) {
-					MessageBox mb=new MessageBox(MyLocale.getMsg(321,"Error"),MyLocale.getMsg(1114,"Directory exists already."),IDOK);
+					MessageBox mb=new MessageBox(MyLocale.getMsg(321,"Error"),MyLocale.getMsg(1114,"Directory exists already."),MBOK);
 					mb.execute();
 					profileDir="";
 				} else {
 					if (profileDir.indexOf("/")>=0 || profileDir.indexOf("\\")>=0 || !f.createDir()) {
-						MessageBox mb=new MessageBox(MyLocale.getMsg(321,"Error"),MyLocale.getMsg(1113,"Cannot create directory"),IDOK);
+						MessageBox mb=new MessageBox(MyLocale.getMsg(321,"Error"),MyLocale.getMsg(1113,"Cannot create directory"),MBOK);
 						mb.execute();
 						profileDir="";
 						this.close(-1);
 					}
+					Filter.filterActive=false;
+					Filter.filterInverted=false;
 					this.close(0);
 				}
 			}

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-02-05 18:48:00 UTC (rev 522)
+++ trunk/src/CacheWolf/Preferences.java	2007-02-05 20:53:47 UTC (rev 523)
@@ -43,12 +43,6 @@
 	public boolean showDeletedImages=true; /* Used in ImagePanel */
 	public boolean solverIgnoreCase=false;
 
-	/** Toggle for showing blacklisted caches. Can be toggled through the Filter menu */
-	public boolean showBlacklisted=false;
-	/** Indicator whether a filter is active. Used in status bar to indicate filter status */
-	public boolean filterActive=false;
-	/** Indicator whether a filter is inverted */
-	public boolean filterInverted=false;
 	public int myAppHeight = 0;
 	public int myAppWidth = 0;
 	//public int nLogs = 5;

Modified: trunk/src/CacheWolf/ProfilesForm.java
===================================================================
--- trunk/src/CacheWolf/ProfilesForm.java	2007-02-05 18:48:00 UTC (rev 522)
+++ trunk/src/CacheWolf/ProfilesForm.java	2007-02-05 20:53:47 UTC (rev 523)
@@ -122,6 +122,8 @@
 				close(-1);
 			}
 			if (ev.target == btnOK || ev.target == choice){
+				Filter.filterActive=false;
+				Filter.filterInverted=false;
 				newSelectedProfile=choice.getSelectedItem().toString();
 				close(1);
 			}

Modified: trunk/src/CacheWolf/SearchCache.java
===================================================================
--- trunk/src/CacheWolf/SearchCache.java	2007-02-05 18:48:00 UTC (rev 522)
+++ trunk/src/CacheWolf/SearchCache.java	2007-02-05 20:53:47 UTC (rev 523)
@@ -49,13 +49,13 @@
 	*/
 	public void clearSearch(){
 		Filter flt=new Filter();
-		if (Global.getPref().filterActive) {
+		if (Filter.filterActive) {
 			flt.setFilter();
 			flt.doFilter();
 		} else {
 			flt.clearFilter();
 		}
-		if (Global.getPref().filterInverted) 
+		if (Filter.filterInverted) 
 			flt.invertFilter();
 		for(int i = cacheDB.size()-1;i >=0;i--){
 			((CacheHolder)cacheDB.get(i)).is_flaged=false;

Modified: trunk/src/CacheWolf/StatusBar.java
===================================================================
--- trunk/src/CacheWolf/StatusBar.java	2007-02-05 18:48:00 UTC (rev 522)
+++ trunk/src/CacheWolf/StatusBar.java	2007-02-05 20:53:47 UTC (rev 523)
@@ -30,8 +30,7 @@
 					MyLocale.getMsg(4502,"Fnd:") + " " + stats.totalFound() + "  ";
 		disp.setText(strStatus);
 		// Indicate that a filter is active in the status line
-		Profile prof=Global.getProfile();
-		if (Global.getPref().filterActive)
+		if (Filter.filterActive)
 			lblFlt.modify(0,Invisible); // Set the filter to "invisible"
 		else
 			lblFlt.modify(Invisible,0); // Make filter visible



From salzkammergut at mail.berlios.de  Mon Feb  5 22:39:12 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Mon, 5 Feb 2007 22:39:12 +0100
Subject: [Cachewolf-svn] r524 - in trunk: resources src/CacheWolf
Message-ID: <200702052139.l15LdCsj014404@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-05 22:39:07 +0100 (Mon, 05 Feb 2007)
New Revision: 524

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/FilterScreen.java
Log:
FilterScreen: Einige noch fehlende Texte internationalisiert

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-02-05 20:53:47 UTC (rev 523)
+++ trunk/resources/cachewolf.Languages.cfg	2007-02-05 21:39:07 UTC (rev 524)
@@ -156,10 +156,15 @@
 		722=Bewertung
 		723=Typen
 		724=Beh%e4lter
-		725=Hinweis: Filter sind additiv, activ = gr%fcn
+		725=Hinweis: Filter sind additiv, aktiv = gr%fcn
 		726=Zus%e4tzliche Wegpunkte
 		727=Beh%e4lter
 		728=Zus. WegPkt
+		729=Nicht archiviert
+		730=Suchbar
+		731=Noch nicht gefunden
+		732=Anderer Besitzer
+		733=Addi Wpt
 		800=Erstelle Liste
 		801=suche...
 		802=Caches identifiziert. Suche weiter...
@@ -480,6 +485,10 @@
 		726=Additional waypoints
 		727=Cache container
 		728=Add. Waypt
+		729=Not archived
+		730=Available
+		731=Not yet found
+		732=Other owner
 		800=Creating list
 		801=searching...
 		802=Caches identified. searching...

Modified: trunk/src/CacheWolf/FilterScreen.java
===================================================================
--- trunk/src/CacheWolf/FilterScreen.java	2007-02-05 20:53:47 UTC (rev 523)
+++ trunk/src/CacheWolf/FilterScreen.java	2007-02-05 21:39:07 UTC (rev 524)
@@ -130,16 +130,16 @@
 		pnlAttributes.addLast(lblTitleAtt=new mLabel(MyLocale.getMsg(715,"Show all caches with status:")),HSTRETCH,FILL);
 		lblTitleAtt.setTag(SPAN,new Dimension(2,1));
 		pnlAttributes.addNext(chkArchived = new mCheckBox(MyLocale.getMsg(710,"Archived")), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		pnlAttributes.addLast(chkNotArchived = new mCheckBox("Nicht archiviert"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addLast(chkNotArchived = new mCheckBox(MyLocale.getMsg(729,"Nicht archiviert")), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
-		pnlAttributes.addNext(chkAvailable = new mCheckBox("Suchbar"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addNext(chkAvailable = new mCheckBox(MyLocale.getMsg(730,"Suchbar")), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		pnlAttributes.addLast(chkNotAvailable = new mCheckBox(MyLocale.getMsg(711,"Not available")), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
 		pnlAttributes.addNext(chkFound = new mCheckBox(MyLocale.getMsg(703,"Found")), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		pnlAttributes.addLast(chkNotFound = new mCheckBox("Noch nicht gefunden"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addLast(chkNotFound = new mCheckBox(MyLocale.getMsg(731,"Noch nicht gefunden")), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
 		pnlAttributes.addNext(chkOwned = new mCheckBox(MyLocale.getMsg(707,"Owned")), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		pnlAttributes.addLast(chkNotOwned = new mCheckBox("Anderer Besitzer"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addLast(chkNotOwned = new mCheckBox(MyLocale.getMsg(732,"Anderer Besitzer")), CellConstants.DONTSTRETCH, CellConstants.FILL);
 
 		//////////////////////////
 		// Panel 3 - Cache ratings
@@ -247,7 +247,7 @@
 		pnlButtons.addLast(btnAttributes=new mButton(MyLocale.getMsg(720,"Attributes")));
 		pnlButtons.addLast(btnRatings=new mButton(MyLocale.getMsg(722,"Ratings")));
 		pnlButtons.addLast(btnTypes=new mButton(MyLocale.getMsg(723,"Types"))); 
-		pnlButtons.addLast(btnAddi=new mButton("Addi Wpt")); 
+		pnlButtons.addLast(btnAddi=new mButton(MyLocale.getMsg(733,"Add. Wpt"))); 
 		pnlButtons.addLast(btnContainer=new mButton(MyLocale.getMsg(724,"Container")));
 		// Search ist f?r 0.9n noch deaktiviert
 		//pnlButtons.addLast(btnSearch=new mButton("Search")); btnSearch.modify(Disabled,0);



From pfeffer at mail.berlios.de  Tue Feb  6 00:36:13 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Tue, 6 Feb 2007 00:36:13 +0100
Subject: [Cachewolf-svn] r525 - trunk/src/CacheWolf
Message-ID: <200702052336.l15NaDqh002836@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-06 00:36:06 +0100 (Tue, 06 Feb 2007)
New Revision: 525

Modified:
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MapLoaderGui.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/Navigate.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/myTableControl.java
   trunk/src/CacheWolf/myTableModel.java
Log:
MapLoader: zeigt beim Download pro Cache jetz die richtige gesmatzahl an (vorher 0)
MovingMap: Bug fixed: Goto-Position setzen, setzte falschen Punkt (war durch schnellfehlerbeheung heute nachmittag entstanden
MovingMap: angezeigte caches werden nach Profilwechsel aktualisiert

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-02-05 21:39:07 UTC (rev 524)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-02-05 23:36:06 UTC (rev 525)
@@ -211,7 +211,7 @@
 		
 	}
 	
-	public void destChanged() { // called from myNavigate
+	public void destChanged(CWPoint d) { // called from myNavigate
 		btnGoto.setText(getGotoBtnText());
 		updateDistance();
 	}

Modified: trunk/src/CacheWolf/MapLoaderGui.java
===================================================================
--- trunk/src/CacheWolf/MapLoaderGui.java	2007-02-05 21:39:07 UTC (rev 524)
+++ trunk/src/CacheWolf/MapLoaderGui.java	2007-02-05 23:36:06 UTC (rev 525)
@@ -147,8 +147,10 @@
 			ml.downlaodTiles(mapsDir);
 		} else { // per cache
 			CacheHolder ch; 
-			CWPoint tmpca=new CWPoint();
+			CWPoint tmpca = new CWPoint();
 			int numdownloaded = 0;
+			Global.getProfile().getSourroundingArea(onlySelected); // calculate numCachesInArea
+			int numCaches = Global.getProfile().numCachesInArea;
 			for (int i=cacheDB.size()-1; i >= 0; i--) {
 				ch = (CacheHolder) cacheDB.get(i);
 				if (!this.onlySelected || ch.is_Checked) {

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-05 21:39:07 UTC (rev 524)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-05 23:36:06 UTC (rev 525)
@@ -254,8 +254,8 @@
 		// update cache symbols in map
 		running = true;
 		MainTab mainT = Global.mainTab;
-		if (mainT.tbP.myMod.cacheSelectionChanged) {
-			mainT.tbP.myMod.cacheSelectionChanged = false;
+		if (Global.getProfile().selectionChanged) {
+			Global.getProfile().selectionChanged = false;
 			removeAllMapSymbolsButGoto();
 			CacheHolder ch;
 			for (int i=cacheDB.size()-1; i>=0; i--) {
@@ -837,7 +837,7 @@
 	
 	public void gpsStarted() {
 		addTrack(myNavigation.curTrack);
-		addOverlaySet();
+		//addOverlaySet();
 	}
 	public void gpsStoped() {
 		setGpsStatus(MovingMap.noGPS);
@@ -964,6 +964,10 @@
 
 	public void loadMapForAllCaches(){
 		Area sur = Global.getProfile().getSourroundingArea(true);
+		if (sur == null) {
+			(new MessageBox("Error", "Keine  Caches mit H?ckchen ausgew?hlt", MessageBox.OKB)).execute();
+			return;
+		}
 		MapInfoObject newmap = maps.getMapForArea(sur.topleft, sur.buttomright);
 		if (newmap == null ) { // no map that includs all caches is available -> load map with lowest resolution
 			Object [] s = getRectForMapChange(posCircleLat, posCircleLon);
@@ -1303,7 +1307,6 @@
 		//if (!(which == null || which == mapImage || which instanceof TrackOverlay || which == mm.directionArrows) ) return false;
 		saveGpsIgnoreStatus = mm.ignoreGps; 
 		mm.ignoreGps = true;
-		//paintingZoomArea = true;
 		saveMapLoc = pos;
 		bringMapToTop();
 		if (mapImage.isOnScreen() && !mapImage.hidden ) return super.imageBeginDragged(mapImage, pos);
@@ -1521,7 +1524,6 @@
 				if (clickedCache != null) openCacheDescMenuItem = new MenuItem("Open '"+clickedCache.CacheName+"'$o"); // clickedCache == null can happen if clicked on the goto-symbol
 				kontextMenu.addItem(openCacheDescMenuItem);
 			}
-			saveMapLoc = p;
 			kontextMenu.exec(this, new Point(p.x, p.y), this);
 		}
 	}

Modified: trunk/src/CacheWolf/Navigate.java
===================================================================
--- trunk/src/CacheWolf/Navigate.java	2007-02-05 21:39:07 UTC (rev 524)
+++ trunk/src/CacheWolf/Navigate.java	2007-02-05 23:36:06 UTC (rev 525)
@@ -45,13 +45,13 @@
 			}
 			serThread.start();
 			startDisplayTimer();
+			curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
 			if (lograw)	gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
 			if (gotoPanel != null) gotoPanel.gpsStarted();
 			if (movingMap != null) movingMap.gpsStarted();
 		} catch (IOException e) {
 			(new MessageBox("Error", "Could not connect to GPS-receiver.\n Error while opening serial Port " + e.getMessage()+"\npossible reasons:\n Another (GPS-)program is blocking the port\nwrong port\nOn Loox: active infra-red port is blocking GPS", MessageBox.OKB)).execute(); 
 		}
-		curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
 	}
 
 	public void setRawLogging(boolean on, int intervall) {
@@ -88,11 +88,8 @@
 
 	public void setDestination(CWPoint d) {
 		destination = new CWPoint (d);
-		if (gotoPanel != null) gotoPanel.destChanged();
-		if (movingMap != null) { // TODO make movingmap the same as gotopanel
-			movingMap.destChanged(destination);
-			movingMap.repaintNow();
-		}
+		if (gotoPanel != null) gotoPanel.destChanged(destination);
+		if (movingMap != null) movingMap.destChanged(destination);
 	}
 	public void ticked() {
 		int fix = gpsPos.getFix();

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-02-05 21:39:07 UTC (rev 524)
+++ trunk/src/CacheWolf/Profile.java	2007-02-05 23:36:06 UTC (rev 525)
@@ -18,7 +18,7 @@
  *
  */
 public class Profile {
-	
+
 	/** The list of caches (CacheHolder objects). A pointer to this object exists in many classes in parallel to
 	 *  this object, i.e. the respective class contains both a {@link Profile} object and a cacheDB Vector. 
 	 */
@@ -34,7 +34,7 @@
 	public String last_sync_opencaching = new String();
 	/** Distance for opencaching caches */
 	public String distOC = new String();
-	
+
 	public final static String FILTERTYPE="11111111111000000";
 	public final static String FILTERROSE="1111111111111111";
 	public final static String FILTERVAR="11111111";
@@ -47,17 +47,19 @@
 	public String filterDist=new String("");
 	public String filterDiff=new String("");
 	public String filterTerr=new String("");
-	
+
+	public boolean selectionChanged = true; // ("H?ckchen") used by movingMap to get to knao if it should update the caches in the map 
+
 	//TODO Add other settings, such as max. number of logs to spider
 	//TODO Add settings for the preferred mapper to allow for maps other than expedia and other resolutions
-	
+
 	/**
 	 * Constructor for a profile
 	 *
 	 */
 	public Profile(){
 	}
-	
+
 	public void clearProfile() {
 		cacheDB.clear();
 		centre.set(0,0);
@@ -66,33 +68,33 @@
 		last_sync_opencaching = "";
 		distOC = "";
 	}
-	
-	
+
+
 	/**
-	*	Method to save the index.xml file that holds the total information
-	*	on available caches in the database. The database is nothing else
-	*	than the collection of caches in a directory.
-	*   
-	*   Not sure whether we need to keep 'pref' in method signature. May eventually remove it. 
-	*/
+	 *	Method to save the index.xml file that holds the total information
+	 *	on available caches in the database. The database is nothing else
+	 *	than the collection of caches in a directory.
+	 *   
+	 *   Not sure whether we need to keep 'pref' in method signature. May eventually remove it. 
+	 */
 	public void saveIndex(Preferences pref){
 		PrintWriter detfile;
 		CacheHolder ch;
 		try{
-		  detfile = new PrintWriter(new BufferedWriter(new FileWriter(dataDir + "index.xml")));
+			detfile = new PrintWriter(new BufferedWriter(new FileWriter(dataDir + "index.xml")));
 		} catch (Exception e) {
-		  Vm.debug("Problem creating index file "+e.toString()+"\nFilename="+dataDir + "index.xml");
+			Vm.debug("Problem creating index file "+e.toString()+"\nFilename="+dataDir + "index.xml");
 			return;
 		}
 		CWPoint savedCentre=centre;
 		if (centre==null || !centre.isValid() || (savedCentre.latDec==0.0 && savedCentre.lonDec==0.0)) savedCentre=pref.curCentrePt;
-		
+
 		try{
 			detfile.print("<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n");
 			detfile.print("<CACHELIST format=\"decimal\">\n");
 			if (savedCentre.isValid())
 //				detfile.print("    <CENTRE lat=\""+savedCentre.getNSLetter() + " " + savedCentre.getLatDeg(CWPoint.CW) + "&deg; " + savedCentre.getLatMin(CWPoint.CW)+ "\" "+
-//				                        "long=\""+savedCentre.getEWLetter() + " " + savedCentre.getLonDeg(CWPoint.CW) + "&deg; " + savedCentre.getLonMin(CWPoint.CW)+"\"/>\n");
+//				"long=\""+savedCentre.getEWLetter() + " " + savedCentre.getLonDeg(CWPoint.CW) + "&deg; " + savedCentre.getLonMin(CWPoint.CW)+"\"/>\n");
 				detfile.print("    <CENTRE lat=\""+savedCentre.latDec+"\" lon=\""+savedCentre.lonDec+"\"/>\n");
 			if(last_sync_opencaching == null || last_sync_opencaching.endsWith("null") || last_sync_opencaching.equals("")){
 				last_sync_opencaching = "20050801000000";
@@ -100,25 +102,25 @@
 			if(distOC == null || distOC.endsWith("null") || distOC.equals("")){
 				distOC = "0";
 			}
-			
+
 			detfile.print("    <FILTER rose = \""+filterRose+"\" type = \""+filterType+
-					 "\" var = \""+filterVar+"\" dist = \""+filterDist.replace('"',' ')+"\" diff = \""+
-					 filterDiff+"\" terr = \""+filterTerr+"\" size = \""+filterSize+"\" />\n");
+					"\" var = \""+filterVar+"\" dist = \""+filterDist.replace('"',' ')+"\" diff = \""+
+					filterDiff+"\" terr = \""+filterTerr+"\" size = \""+filterSize+"\" />\n");
 			detfile.print("    <SYNCOC date = \""+last_sync_opencaching+"\" dist = \""+distOC+"\"/>\n");
 			for(int i = 0; i<cacheDB.size();i++){
 				ch = (CacheHolder)cacheDB.get(i);
 				////Vm.debug("Saving: " + ch.CacheName);
 				if(ch.wayPoint.length()>0 && ch.LongDescription.equals("An Error Has Occured") == false){
-/* pos must always be set, so this is no longer needed
+					/* pos must always be set, so this is no longer needed
  					if (ch.pos==null) {
 						ParseLatLon pl=new ParseLatLon(ch.LatLon);
 						pl.parse();
 						ch.pos=new CWPoint(pl.lat2,pl.lon2);
 					}
-*/					detfile.print("    <CACHE name = \""+SafeXML.clean(ch.CacheName)+"\" owner = \""+SafeXML.clean(ch.CacheOwner)+
-							//"\" lat = \""+ SafeXML.clean(ch.LatLon) +
-							"\" lat = \""+ ch.pos.latDec + "\" lon = \""+ch.pos.lonDec+
-							"\" hidden = \""+ch.DateHidden+"\" wayp = \""+SafeXML.clean(ch.wayPoint)+"\" status = \""+ch.CacheStatus+"\" type = \""+ch.type+"\" dif = \""+ch.hard+"\" terrain = \"" + ch.terrain + "\" dirty = \"" + ch.dirty + "\" size = \""+ch.CacheSize+"\" online = \"" + Convert.toString(ch.is_available) + "\" archived = \"" + Convert.toString(ch.is_archived) + "\" has_bug = \"" + Convert.toString(ch.has_bug) + "\" black = \"" + Convert.toString(ch.is_black) + "\" owned = \"" + Convert.toString(ch.is_owned) + "\" found = \"" + Convert.toString(ch.is_found) + "\" is_new = \"" + Convert.toString(ch.is_new) +"\" is_log_update = \"" + Convert.toString(ch.is_log_update) + "\" is_update = \"" + Convert.toString(ch.is_update) + "\" is_HTML = \"" + Convert.toString(ch.is_HTML) + "\" DNFLOGS = \"" + ch.noFindLogs + "\" ocCacheID = \"" + ch.ocCacheID + "\" />\n");
+					 */					detfile.print("    <CACHE name = \""+SafeXML.clean(ch.CacheName)+"\" owner = \""+SafeXML.clean(ch.CacheOwner)+
+							 //"\" lat = \""+ SafeXML.clean(ch.LatLon) +
+							 "\" lat = \""+ ch.pos.latDec + "\" lon = \""+ch.pos.lonDec+
+							 "\" hidden = \""+ch.DateHidden+"\" wayp = \""+SafeXML.clean(ch.wayPoint)+"\" status = \""+ch.CacheStatus+"\" type = \""+ch.type+"\" dif = \""+ch.hard+"\" terrain = \"" + ch.terrain + "\" dirty = \"" + ch.dirty + "\" size = \""+ch.CacheSize+"\" online = \"" + Convert.toString(ch.is_available) + "\" archived = \"" + Convert.toString(ch.is_archived) + "\" has_bug = \"" + Convert.toString(ch.has_bug) + "\" black = \"" + Convert.toString(ch.is_black) + "\" owned = \"" + Convert.toString(ch.is_owned) + "\" found = \"" + Convert.toString(ch.is_found) + "\" is_new = \"" + Convert.toString(ch.is_new) +"\" is_log_update = \"" + Convert.toString(ch.is_log_update) + "\" is_update = \"" + Convert.toString(ch.is_update) + "\" is_HTML = \"" + Convert.toString(ch.is_HTML) + "\" DNFLOGS = \"" + ch.noFindLogs + "\" ocCacheID = \"" + ch.ocCacheID + "\" />\n");
 				}
 			}
 			detfile.print("</CACHELIST>\n");
@@ -128,16 +130,17 @@
 			Vm.debug("Problem writing to index file "+e.toString());
 		}
 	}
-	
-	
-	
+
+
+
 	/**
-	*	Method to read the index.xml file that holds the total information
-	*	on available caches in the database. The database in nothing else
-	*	than the collection of caches in a directory.
-	*/
+	 *	Method to read the index.xml file that holds the total information
+	 *	on available caches in the database. The database in nothing else
+	 *	than the collection of caches in a directory.
+	 */
 	public void readIndex(){
 		try {
+			selectionChanged = true;
 			boolean fmtDec=false;
 			char decSep=MyLocale.getDigSeparator().charAt(0);
 			char notDecSep=decSep=='.'?',':'.';
@@ -180,7 +183,7 @@
 					ch.is_new = ex.findNext().equals("true") ? true : false;
 					ch.is_log_update = ex.findNext().equals("true") ? true : false;
 					ch.is_update = ex.findNext().equals("true") ? true : false;
-					  // for backwards compatibility set value to true, if it is not in the file
+					// for backwards compatibility set value to true, if it is not in the file
 					ch.is_HTML = ex.findNext().equals("false") ? false : true;
 					ch.noFindLogs = Convert.toInt(ex.findNext());
 					ch.ocCacheID = ex.findNext();
@@ -217,7 +220,7 @@
 					filterDiff = ex.findNext();
 					filterTerr = ex.findNext();
 					filterSize = ex.findNext();
-//					 Bilbowolf: Pattern for storing filter <FILTER type="01001101" rose = "010010101" var = "0101" dist = "<12" diff = ">13" terr = "<1"/>
+//					Bilbowolf: Pattern for storing filter <FILTER type="01001101" rose = "010010101" var = "0101" dist = "<12" diff = ">13" terr = "<1"/>
 				}
 			}
 			in.close();
@@ -232,7 +235,7 @@
 		}
 		normalizeFilters();
 	}
-	
+
 	public int getCacheIndex(String wp){
 		int retval = -1;
 		CacheHolder ch;
@@ -250,8 +253,8 @@
 	public String getNewWayPointName(){
 		String strWp=null;
 		long  lgWp=1;
-        if (cacheDB.size()==0 )
-        	return "CW0000";
+		if (cacheDB.size()==0 )
+			return "CW0000";
 		//Create new waypoint,look if not in db
 		for(int i = 0;i < cacheDB.size();i++){
 			strWp = "CW" + MyLocale.formatLong(lgWp, "0000");
@@ -263,18 +266,30 @@
 		}
 		return strWp;
 	}
-	
+
 	public String toString() {
 		return "Profile: Name="+name+"\nCentre="+centre.toString()+"\ndataDir="+dataDir+"\nlastSyncOC="+
-		     last_sync_opencaching+"\ndistOC="+distOC;
+		last_sync_opencaching+"\ndistOC="+distOC;
 	}
+
+	public void setSelectForAll(boolean selectStatus) {
+		selectionChanged = true;
+		CacheHolder ch;
+		for(int i = cacheDB.size()-1; i >=	0; i--){
+			ch = (CacheHolder)cacheDB.get(i);
+			if (ch.is_filtered == false) ch.is_Checked = selectStatus;
+		}
+	} 
+
+
+	int numCachesInArea; // only valid after calling getSourroundingArea
 	public Area getSourroundingArea(boolean onlyOfSelected) {
 		if (cacheDB == null || cacheDB.size() == 0) return null;
 		CacheHolder ch;
 		CWPoint topleft = null;
 		CWPoint buttomright = null;
 		CWPoint tmpca = new CWPoint();
-		int numCaches = 0;
+		numCachesInArea = 0;
 		for (int i=cacheDB.size()-1; i >= 0; i--) {
 			ch = (CacheHolder) cacheDB.get(i);
 			if (!onlyOfSelected || ch.is_Checked) {
@@ -289,7 +304,7 @@
 					if (topleft.lonDec > ch.pos.lonDec) topleft.lonDec = ch.pos.lonDec;
 					if (buttomright.latDec > ch.pos.latDec) buttomright.latDec = ch.pos.latDec;
 					if (buttomright.lonDec < ch.pos.lonDec) buttomright.lonDec = ch.pos.lonDec;
-					numCaches++;
+					numCachesInArea++;
 				}
 			}
 		}
@@ -299,74 +314,74 @@
 	}
 
 	/**
-		*	Method to calculate bearing and distance of a cache in the index
-		*	list.
-		*	@see	CacheHolder
-		*	@see	Extractor
-		*/
-		public void updateBearingDistance(){
-			CWPoint fromPoint = new CWPoint(Global.getPref().curCentrePt); // Clone current centre to be sure
-			int anz = cacheDB.getCount();
-			CacheHolder ch;
-			CWPoint toPoint;
-			// Jetzt durch die CacheDaten schleifen
-			while(--anz >= 0){
-				ch = (CacheHolder)cacheDB.get(anz); // This returns a pointer to the CacheHolder object
-				if(ch.LatLon.length()>4){
-					toPoint = ch.pos;
-					ch.kilom = fromPoint.getDistance(toPoint);
-					ch.degrees = fromPoint.getBearing(toPoint);
-					ch.bearing = CWPoint.getDirection(ch.degrees);
-					ch.distance = MyLocale.formatDouble(ch.kilom,"0.00");
-					ch.distance = ch.distance + " km";
-				}
+	 *	Method to calculate bearing and distance of a cache in the index
+	 *	list.
+	 *	@see	CacheHolder
+	 *	@see	Extractor
+	 */
+	public void updateBearingDistance(){
+		CWPoint fromPoint = new CWPoint(Global.getPref().curCentrePt); // Clone current centre to be sure
+		int anz = cacheDB.getCount();
+		CacheHolder ch;
+		CWPoint toPoint;
+		// Jetzt durch die CacheDaten schleifen
+		while(--anz >= 0){
+			ch = (CacheHolder)cacheDB.get(anz); // This returns a pointer to the CacheHolder object
+			if(ch.LatLon.length()>4){
+				toPoint = ch.pos;
+				ch.kilom = fromPoint.getDistance(toPoint);
+				ch.degrees = fromPoint.getBearing(toPoint);
+				ch.bearing = CWPoint.getDirection(ch.degrees);
+				ch.distance = MyLocale.formatDouble(ch.kilom,"0.00");
+				ch.distance = ch.distance + " km";
 			}
-			// The following call is not very clean as it mixes UI with base classes
-			// However, calling it from here allows us to recenter the
-			// radar panel with only one call
-			if (Global.mainTab!=null) Global.mainTab.radarP.recenterRadar();
-		} //updateBearingDistance
+		}
+		// The following call is not very clean as it mixes UI with base classes
+		// However, calling it from here allows us to recenter the
+		// radar panel with only one call
+		if (Global.mainTab!=null) Global.mainTab.radarP.recenterRadar();
+	} //updateBearingDistance
 
-		/**
-		 * Method to build the reference between addi wpt
-		 * and main cache.
-		 */
-		   public void buildReferences(){
-			   CacheHolder ch, mainCh;
-			   Hashtable dbIndex = new Hashtable((int)(cacheDB.size()/0.75f + 1), 0.75f); // initialize so that von rehashing is neccessary
-			   Integer index;
-			   // Build index for faster search and clear all references
-			   for(int i = cacheDB.size() -1; i >= 0;i--){
-					ch = (CacheHolder)cacheDB.get(i);
-					ch.addiWpts.clear();
-					ch.mainCache = null; 
-					dbIndex.put((String)ch.wayPoint, new Integer(i));
-			   }
-			   // Build refeneces
-			   int max = cacheDB.size();
-			   for(int i =  0; i < max ;i++){
-					ch = (CacheHolder)cacheDB.get(i);
-					if (ch.isAddiWpt()) {
-						//search main cache
-						if (ch.wayPoint.length() == 5){
-							index = (Integer) dbIndex.get("GC"+ ch.wayPoint.substring(1));
-						} 
-						else {
-							index = (Integer) dbIndex.get("GC"+ ch.wayPoint.substring(2));
-						}
-						if (index != null) {
-							mainCh = (CacheHolder) cacheDB.get(index.intValue());
-							mainCh.addiWpts.add(ch);
-							ch.mainCache = mainCh;
-						}// if
-					}// if
-			   }// for
-		   }
-		   
-    /** Ensure that all filters have the proper length so that the 'charAt' access in the filter
-     * do not cause nullPointer Exceptions
-     */
-    private void normalizeFilters() {
+	/**
+	 * Method to build the reference between addi wpt
+	 * and main cache.
+	 */
+	public void buildReferences(){
+		CacheHolder ch, mainCh;
+		Hashtable dbIndex = new Hashtable((int)(cacheDB.size()/0.75f + 1), 0.75f); // initialize so that von rehashing is neccessary
+		Integer index;
+		// Build index for faster search and clear all references
+		for(int i = cacheDB.size() -1; i >= 0;i--){
+			ch = (CacheHolder)cacheDB.get(i);
+			ch.addiWpts.clear();
+			ch.mainCache = null; 
+			dbIndex.put((String)ch.wayPoint, new Integer(i));
+		}
+		// Build refeneces
+		int max = cacheDB.size();
+		for(int i =  0; i < max ;i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			if (ch.isAddiWpt()) {
+				//search main cache
+				if (ch.wayPoint.length() == 5){
+					index = (Integer) dbIndex.get("GC"+ ch.wayPoint.substring(1));
+				} 
+				else {
+					index = (Integer) dbIndex.get("GC"+ ch.wayPoint.substring(2));
+				}
+				if (index != null) {
+					mainCh = (CacheHolder) cacheDB.get(index.intValue());
+					mainCh.addiWpts.add(ch);
+					ch.mainCache = mainCh;
+				}// if
+			}// if
+		}// for
+	}
+
+	/** Ensure that all filters have the proper length so that the 'charAt' access in the filter
+	 * do not cause nullPointer Exceptions
+	 */
+	private void normalizeFilters() {
 		if (filterRose.length()<16) { 
 			filterRose=(filterRose+"1111111111111111").substring(0,16); 
 		}  
@@ -383,6 +398,6 @@
 		if (filterDist.length()==0) filterDist="L";
 		if (filterDiff.length()==0) filterDiff="L";
 		if (filterTerr.length()==0) filterTerr="L";
-    }
-		   
+	}
+
 }

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-02-05 21:39:07 UTC (rev 524)
+++ trunk/src/CacheWolf/myTableControl.java	2007-02-05 23:36:06 UTC (rev 525)
@@ -59,16 +59,10 @@
 		
 	/** Set all caches either as selected or as deselected, depending on argument */
 	private void setSelectForAll(boolean selectStatus) {
-		CacheHolder ch;
-		for(int i = cacheDB.size()-1; i >=	0; i--){
-			ch = (CacheHolder)cacheDB.get(i);
-			if (ch.is_filtered == false) ch.is_Checked = selectStatus;
-		}
-		tbp.myMod.cacheSelectionChanged = true;
+		Global.getProfile().setSelectForAll(selectStatus);
 		tbp.refreshTable();
 	}
 	
-	
 	public void popupMenuEvent(Object selectedItem){
 		CacheHolder ch;
 		

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-02-05 21:39:07 UTC (rev 524)
+++ trunk/src/CacheWolf/myTableModel.java	2007-02-05 23:36:06 UTC (rev 525)
@@ -16,7 +16,6 @@
 */
 public class myTableModel extends TableModel{
 	
-	public boolean cacheSelectionChanged = true;
 	Vector cacheDB;
 	String[] colName;
 	static Image cacheImages[] = new Image[454];
@@ -306,7 +305,7 @@
 		try{
 			// Check whether the click is on the checkbox image
 			if (cell.y>=0 && cell.x==0) {
-				cacheSelectionChanged = true;
+				Global.getProfile().selectionChanged = true;
 				CacheHolder ch = (CacheHolder)cacheDB.get(cell.y);
 				ch.is_Checked= !ch.is_Checked;
 				// set the ceckbox also for addi wpts



From pfeffer at mail.berlios.de  Tue Feb  6 00:39:02 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Tue, 6 Feb 2007 00:39:02 +0100
Subject: [Cachewolf-svn] r526 - trunk/src/CacheWolf
Message-ID: <200702052339.l15Nd2Gs010366@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-06 00:38:46 +0100 (Tue, 06 Feb 2007)
New Revision: 526

Modified:
   trunk/src/CacheWolf/OCXMLImporterScreen.java
Log:
Kartendownload-Option aus GC-Spider und OC-Download entfernt

Modified: trunk/src/CacheWolf/OCXMLImporterScreen.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporterScreen.java	2007-02-05 23:36:06 UTC (rev 525)
+++ trunk/src/CacheWolf/OCXMLImporterScreen.java	2007-02-05 23:38:46 UTC (rev 526)
@@ -36,12 +36,12 @@
 		imagesCheckBox.setText(MyLocale.getMsg(1602,"Download Images"));
 		imagesCheckBox.setState(true); // @ToDo: aus Prefs
 		this.addLast(imagesCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
-		
+/*		
 		mapsCheckBox = new mCheckBox();
 		mapsCheckBox.setText(MyLocale.getMsg(1603,"Download Maps"));
 		mapsCheckBox.setState(true); // @ToDo: aus Prefs
 		this.addLast(mapsCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
-		
+	*/	
 		if(options == ALL){
 			missingCheckBox = new mCheckBox();
 			missingCheckBox.setText(MyLocale.getMsg(1606,"Alle erneut downloaden"));



From bilbowolf at mail.berlios.de  Tue Feb  6 07:53:07 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Tue, 6 Feb 2007 07:53:07 +0100
Subject: [Cachewolf-svn] r527 - trunk/src/CacheWolf
Message-ID: <200702060653.l166r7IQ004509@sheep.berlios.de>

Author: bilbowolf
Date: 2007-02-06 07:53:05 +0100 (Tue, 06 Feb 2007)
New Revision: 527

Modified:
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/MapLoader.java
   trunk/src/CacheWolf/SpiderGC.java
Log:


Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-02-05 23:38:46 UTC (rev 526)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-02-06 06:53:05 UTC (rev 527)
@@ -34,6 +34,7 @@
 	Profile profile;
 	mImage mIsBlack;
 	mImage mNoBlack;
+	mImage mI, mI_no;
 	
 	public DetailsPanel(){
 		pref = Global.getPref();
@@ -42,15 +43,16 @@
 		////////////////////
 		// Tools
 		////////////////////
-		pnlTools.addNext(btnNewWpt = new mButton(MyLocale.getMsg(311,"Create Waypoint")),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		pnlTools.addLast(btnNewWpt = new mButton(MyLocale.getMsg(311,"Create Waypoint")),CellConstants.DONTSTRETCH, CellConstants.WEST);
 		pnlTools.addNext(btnGoto = new mButton("Goto"),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		mImage mI = new mImage("bug.gif");
+		mI = new mImage("bug.gif");
+		mI_no = new mImage("bug_no.gif");
 		mImage mI2 = new mImage("globe_small.gif");
 		
 		mImage mI4 = new mImage("images.gif");
 		mNoBlack = new mImage("no_black.png");
 		mIsBlack = new mImage("is_black.png");
-		btnShowBug = new mButton((IImage)mI);
+		btnShowBug = new mButton((IImage)mI_no);
 		btnShowMap = new mButton((IImage)mI2);
 		
 		btnAddDateTime = new mButton((IImage)new mImage("date_time.png"));
@@ -81,7 +83,7 @@
 		this.addLast(inpName.setTag(Control.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		
 		this.addNext(new mLabel(MyLocale.getMsg(304,"Location:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		this.addLast(btnWayLoc.setTag(Control.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		this.addLast(btnWayLoc.setTag(Control.SPAN, new Dimension(2,1)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		
 		this.addNext(new mLabel(MyLocale.getMsg(305,"Hidden on:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		this.addLast(inpHidden.setTag(Control.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
@@ -129,8 +131,10 @@
 		btnBlack.repaintNow();
 		if(ch.has_bug == true) {
 			btnShowBug.modify(Control.Disabled,1);
+			btnShowBug.image = mI;
 		} else {
 			btnShowBug.modify(Control.Disabled,0);
+			btnShowBug.image = mI_no;
 		}
 		btnShowBug.repaintNow();
 		if(ch.CacheSize.equals("Micro")) chcSize.setInt(1);

Modified: trunk/src/CacheWolf/MapLoader.java
===================================================================
--- trunk/src/CacheWolf/MapLoader.java	2007-02-05 23:38:46 UTC (rev 526)
+++ trunk/src/CacheWolf/MapLoader.java	2007-02-06 06:53:05 UTC (rev 527)
@@ -122,9 +122,11 @@
 		}
 	}
 	
+	/*
 	public void loadTo(String a, String b) {
 		//loadTo(a, b, "50.74", "7.095");
 	}
+	*/
 
 	public void setProgressInfoBox (InfoBox progrssInfoboxi) {
 		progressInfobox = progrssInfoboxi;

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-02-05 23:38:46 UTC (rev 526)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-02-06 06:53:05 UTC (rev 527)
@@ -112,6 +112,7 @@
 	 * It assumes a login has already been performed!
 	 */
 	public void spiderSingle(int number){
+
 		CacheHolder ch = (CacheHolder)cacheDB.get(number);
 		if (ch.isAddiWpt()) return;  // No point spidering an addi waypoint, comes with parent
 		Vm.showWait(true);
@@ -137,53 +138,51 @@
 		ch.is_new = false;
 		ch.is_update = true;
 		ch.is_HTML = true;
-		//Vm.debug(ch.wayPoint);
+		Vm.debug(ch.wayPoint);
 		if(start.indexOf("This cache is temporarily unavailable") >= 0) ch.is_available = false;
 		pref.log("Trying logs");
 		ch.CacheLogs = getLogs(start, ch);
 		pref.log("Found logs");
 		ch.LatLon = getLatLon(start);
 		ch.pos.set(ch.LatLon);
-		//Vm.debug("LatLon: " + ch.LatLon);
+		Vm.debug("LatLon: " + ch.LatLon);
 		pref.log("Trying description");
 		ch.LongDescription = getLongDesc(start);
 		pref.log("Got description");
 		pref.log("Getting cache name");
 		ch.CacheName = SafeXML.cleanback(getName(start));
 		pref.log("Got cache name");
-		//Vm.debug("Name: " + ch.CacheName);
+		Vm.debug("Name: " + ch.CacheName);
 		pref.log("Trying owner");
 		ch.CacheOwner = SafeXML.cleanback(getOwner(start));
-		if(ch.CacheOwner.equals(pref.myAlias)) ch.is_owned = true;
+		if(ch.CacheOwner.equals(pref.myAlias + " ")) ch.is_owned = true;
 		pref.log("Got owner");
-		//Vm.debug("Owner: " + ch.CacheOwner);
+		Vm.debug("Owner: " + ch.CacheOwner);
 		pref.log("Trying date hidden");
 		ch.DateHidden = getDateHidden(start);
 		pref.log("Got date hidden");
-		//Vm.debug("Hidden: " + ch.DateHidden);
+		Vm.debug("Hidden: " + ch.DateHidden);
 		pref.log("Trying hints");
 		ch.Hints = getHints(start);
 		pref.log("Got hints");
-		//Vm.debug("Hints: " + ch.Hints);
-		
-		
-		//Vm.debug("Got the hints");
+		Vm.debug("Hints: " + ch.Hints);
+		Vm.debug("Got the hints");
 		pref.log("Trying size");
 		ch.CacheSize = getSize(start);
 		pref.log("Got size");
-		//Vm.debug("Size: " + ch.CacheSize);
+		Vm.debug("Size: " + ch.CacheSize);
 		pref.log("Trying difficulty");
 		ch.hard = getDiff(start);
 		pref.log("Got difficulty");
-		//Vm.debug("Hard: " + ch.hard);
+		Vm.debug("Hard: " + ch.hard);
 		pref.log("Trying terrain");
 		ch.terrain = getTerr(start);
 		pref.log("Got terrain");
-		//Vm.debug("Terr: " + ch.terrain);
+		Vm.debug("Terr: " + ch.terrain);
 		pref.log("Trying cache type");
 		ch.type = getType(start);
 		pref.log("Got cache type");
-		//Vm.debug("Type: " + ch.type);
+		Vm.debug("Type: " + ch.type);
 		pref.log("Trying images");
 		getImages(start, ch);
 		pref.log("Got images");
@@ -191,10 +190,13 @@
 		getMaps(ch);
 		pref.log("Got maps");
 		pref.log("Getting additional waypoints");
+
 		getAddWaypoints(start, ch);
+
 		pref.log("Got additional waypoints");
 		ch.CacheNotes = notes;
 		ch.saveCacheDetails(profile.dataDir);
+		
 		cacheDB.set(number, ch);
 		profile.saveIndex(pref);
 		infB.close(0);
@@ -218,6 +220,7 @@
 		}
 		
 		OCXMLImporterScreen options = new OCXMLImporterScreen("Spider Options", OCXMLImporterScreen.IMAGESANDMAPS);
+		options.distanceInput.setText("");
 		if (options.execute() == OCXMLImporterScreen.IDCANCEL) {Vm.showWait(false);	return; }
 		String dist = options.distanceInput.getText();
 		if (dist.length()== 0) return;
@@ -231,7 +234,7 @@
 		infB.exec();
 		//Get first page
 		try{
-			pref.log("Fetching first list page: http://www.geocaching.com/seek/nearest.aspx?lat=" + origin.getLatDeg(CWPoint.DD) + "&lon=" +origin.getLonDeg(CWPoint.DD) + "&f=1");
+			pref.log("Fetching first list page: http://www.geocaching.com/seek/nearest.aspx?lat=" + origin.getLatDeg(CWPoint.DD) + "&lon=" +origin.getLonDeg(CWPoint.DD));
 			start = fetch("http://www.geocaching.com/seek/nearest.aspx?lat=" + origin.getLatDeg(CWPoint.DD) + "&lon=" +origin.getLonDeg(CWPoint.DD));
 			pref.log("First page: " + start);
 		}catch(Exception ex){
@@ -330,6 +333,7 @@
 					//Vm.debug("Name: " + ch.CacheName);
 					pref.log("Trying owner");
 					ch.CacheOwner = SafeXML.cleanback(getOwner(start));
+					if(ch.CacheOwner.equals(pref.myAlias+" ")) ch.is_owned = true;
 					pref.log("Got owner");
 					//Vm.debug("Owner: " + ch.CacheOwner);
 					pref.log("Trying date hidden");
@@ -426,7 +430,7 @@
 		Regex descRex = new Regex("colspan=\"4\">(.*)</td>");
 		Regex typeRex = new Regex("</a> \\((.*)\\)</td>");
 		int counter = 0;
-		if(exWayBlock.endOfSearch() == false){
+		if(exWayBlock.endOfSearch() == false && wayBlock.indexOf("No additional waypoints to display.")<0){
 			Extractor exRowBlock = new Extractor(wayBlock, "<tr", "</tr>", 0, false);
 			rowBlock = exRowBlock.findNext();
 			rowBlock = exRowBlock.findNext();



From bilbowolf at mail.berlios.de  Tue Feb  6 08:02:35 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Tue, 6 Feb 2007 08:02:35 +0100
Subject: [Cachewolf-svn] r528 - trunk/src/CacheWolf
Message-ID: <200702060702.l1672Zwx004932@sheep.berlios.de>

Author: bilbowolf
Date: 2007-02-06 08:02:32 +0100 (Tue, 06 Feb 2007)
New Revision: 528

Modified:
   trunk/src/CacheWolf/GPXImporter.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/SpiderGC.java
   trunk/src/CacheWolf/Version.java
Log:


Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2007-02-06 06:53:05 UTC (rev 527)
+++ trunk/src/CacheWolf/GPXImporter.java	2007-02-06 07:02:32 UTC (rev 528)
@@ -275,8 +275,8 @@
 								ParseLatLon pll = new ParseLatLon(holder.LatLon,".");
 								pll.parse();
 								MapLoader mpl = new MapLoader(pref.myproxy, pref.myproxyport);
-								mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map.gif", "3");
-								mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map_2.gif", "10");
+								//mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map.gif", "3");
+								//mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map_2.gif", "10");
 							}
 						}
 					if(holder.wayPoint.startsWith("GC")) {

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-02-06 06:53:05 UTC (rev 527)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-02-06 07:02:32 UTC (rev 528)
@@ -353,12 +353,14 @@
 				}
 				if (!fileExits(filename)){
 					inf.setInfo(MyLocale.getMsg(1609,"Importing Cache:")+" " + numCacheImported + "\n"+MyLocale.getMsg(1610,"Downloading missing map")+" 1");
-					mpl.loadTo(filename, "3"); }
+					//mpl.loadTo(filename, "3"); 
+					}
 				//filename = profile.dataDir + "/" + holder.wayPoint + "_map_2.gif";
 				filename = Global.getPref().baseDir + "/maps/expedia/" + holder.wayPoint + "_map_2.gif";
 				if (!fileExits(filename)){
 					inf.setInfo(MyLocale.getMsg(1609,"Importing Cache: ")+" " + numCacheImported + "\n"+MyLocale.getMsg(1610,"Downloading missing map")+" 2");
-					mpl.loadTo(filename, "10"); }
+					//mpl.loadTo(filename, "10"); 
+					}
 			}
 			// save all
 			holder.saveCacheDetails(profile.dataDir);

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-02-06 06:53:05 UTC (rev 527)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-02-06 07:02:32 UTC (rev 528)
@@ -415,8 +415,8 @@
 			ParseLatLon pll = new ParseLatLon(holder.LatLon,".");
 			pll.parse();
 			MapLoader mpl = new MapLoader(pref.myproxy, pref.myproxyport);
-			mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map.gif", "3");
-			mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map_2.gif", "10");
+			//mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map.gif", "3");
+			//mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map_2.gif", "10");
 		}
 	}
 	

Modified: trunk/src/CacheWolf/Version.java
===================================================================
--- trunk/src/CacheWolf/Version.java	2007-02-06 06:53:05 UTC (rev 527)
+++ trunk/src/CacheWolf/Version.java	2007-02-06 07:02:32 UTC (rev 528)
@@ -10,7 +10,7 @@
 	static final String VER_MAJOR = "";
 	static final String VER_MINOR = "";
 	static final String VER_BUILD = " RC ";
-	static final String VER_SVN ="$LastChangedRevision$";  //the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
+	static final String VER_SVN ="$LastChangedRevision$";  // the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
 	
 	/**
 	 * @return



From pfeffer at mail.berlios.de  Tue Feb  6 21:06:51 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Tue, 6 Feb 2007 21:06:51 +0100
Subject: [Cachewolf-svn] r529 - trunk/src/CacheWolf
Message-ID: <200702062006.l16K6pYO019872@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-06 21:06:47 +0100 (Tue, 06 Feb 2007)
New Revision: 529

Modified:
   trunk/src/CacheWolf/GPXImporter.java
   trunk/src/CacheWolf/OCXMLImporterScreen.java
   trunk/src/CacheWolf/SpiderGC.java
Log:
fixed: NullPointerException bei GCspider

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2007-02-06 07:02:32 UTC (rev 528)
+++ trunk/src/CacheWolf/GPXImporter.java	2007-02-06 20:06:47 UTC (rev 529)
@@ -95,7 +95,7 @@
 			if (options.execute() == OCXMLImporterScreen.IDCANCEL) {	return; }
 			//String dist = options.distanceInput.getText();
 			//if (dist.length()== 0) return;
-			getMaps = options.mapsCheckBox.getState();
+			//getMaps = options.mapsCheckBox.getState();
 			boolean getImages = options.imagesCheckBox.getState();
 			doSpider = false;
 			if(getImages){doSpider = true;}

Modified: trunk/src/CacheWolf/OCXMLImporterScreen.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporterScreen.java	2007-02-06 07:02:32 UTC (rev 528)
+++ trunk/src/CacheWolf/OCXMLImporterScreen.java	2007-02-06 20:06:47 UTC (rev 529)
@@ -16,7 +16,7 @@
 	mButton cancelB, okB;
 	Preferences pref;
 	mInput distanceInput;
-	mCheckBox imagesCheckBox, mapsCheckBox, missingCheckBox;
+	mCheckBox imagesCheckBox, /*mapsCheckBox, */ missingCheckBox;
 	mLabel distLbl;
 	static int IMAGESANDMAPS = 0;
 	static int ALL = 1;
@@ -64,10 +64,9 @@
 			}
 			if (ev.target == okB){
 				    // distOC wird hier noch nicht in Pref eingetragen, damit noch gepr?ft werden kann, ob es gr??er oder kleiner ist als vorher
-					pref.downloadMapsOC = mapsCheckBox.state;
 					pref.downloadPicsOC = imagesCheckBox.state;
 					if (missingCheckBox!=null) pref.downloadmissingOC = missingCheckBox.state;
-					// @todo: sofort speichern?
+					// TODO: sofort speichern?
 				this.close(Form.IDOK);
 				}
 		}

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-02-06 07:02:32 UTC (rev 528)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-02-06 20:06:47 UTC (rev 529)
@@ -187,7 +187,7 @@
 		getImages(start, ch);
 		pref.log("Got images");
 		pref.log("Trying maps");
-		getMaps(ch);
+		//getMaps(ch);
 		pref.log("Got maps");
 		pref.log("Getting additional waypoints");
 
@@ -225,7 +225,7 @@
 		String dist = options.distanceInput.getText();
 		if (dist.length()== 0) return;
 		distance = Convert.toDouble(dist);
-		boolean getMaps = options.mapsCheckBox.getState();
+		//boolean getMaps = options.mapsCheckBox.getState();
 		boolean getImages = options.imagesCheckBox.getState();
 		options.close(0);
 		
@@ -366,11 +366,11 @@
 						getImages(start, ch);
 						pref.log("Got images");
 					}
-					if(getMaps){
+	/*				if(getMaps){
 						pref.log("Trying maps");
 						getMaps(ch);
 						pref.log("Got maps");
-					}
+					} */
 					pref.log("Getting additional waypoints");
 					getAddWaypoints(start, ch);
 					pref.log("Got additional waypoints");
@@ -410,6 +410,7 @@
 		} else return -1;
 	}
 	
+	/* wird nicht mehr gebraucht.
 	public void getMaps(CacheHolder holder){
 		if(holder.LatLon.length() > 4){
 			ParseLatLon pll = new ParseLatLon(holder.LatLon,".");
@@ -419,7 +420,7 @@
 			//mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map_2.gif", "10");
 		}
 	}
-	
+	*/
 	public void getAddWaypoints(String doc, CacheHolder ch){
 		Extractor exWayBlock = new Extractor(doc, "<strong>Additional Waypoints</strong><br>", "</table>", 0, false);
 		String wayBlock = new String();



From pfeffer at mail.berlios.de  Wed Feb  7 03:57:10 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 7 Feb 2007 03:57:10 +0100
Subject: [Cachewolf-svn] r530 - trunk/src/CacheWolf
Message-ID: <200702070257.l172vA3U029950@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-07 03:57:01 +0100 (Wed, 07 Feb 2007)
New Revision: 530

Modified:
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/Map.java
   trunk/src/CacheWolf/MapInfoObject.java
   trunk/src/CacheWolf/MapsList.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/SelectMap.java
Log:
MovingMap: fixed: nach ein paar Mal zoomen umd Kartenwechsel konnte es passieren, dass Karte und Track und Caches nicht mehr zusammen passten (damit gleichzeitig sollte auch nicht mehr die Karte durch das GPS-Sipgal zur?\195?\188ck geschaltet werden, sondern nur noch, wenn eine bessere Karte verf?\195?\188gbar ist)
MovingMap: Aufruf ?\195?\188ber Detailspanel schaltet Verbindung das Moven der Map aus und zentriert automatisch auf den gew?\195?\164hlten Wegpunkt
MovingMap: das Verzeichnis maps/standard wird nicht mehr erstellt, wenn die MovingMap aufgerufen wird, sondern nurnoch beim Kartenimport (noch ungetestet, bitte testen!)

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-02-06 20:06:47 UTC (rev 529)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-02-07 02:57:01 UTC (rev 530)
@@ -233,7 +233,7 @@
 				nsc.execute(this.getFrame(), Gui.CENTER_FRAME);
 			}
 			else if(ev.target == btnShowMap){
-				Global.mainTab.SwitchToMovingMap(thisCache.pos);
+				Global.mainTab.SwitchToMovingMap(thisCache.pos, true);
 /*				try {
 					MapDetailForm mdf = new MapDetailForm(thisCache.wayPoint, pref, profile);
 					mdf.execute();

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-02-06 20:06:47 UTC (rev 529)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-02-07 02:57:01 UTC (rev 530)
@@ -329,7 +329,7 @@
 			if (myNavigation.destination.isValid())	centerTo = new CWPoint(myNavigation.destination);
 			else centerTo = new CWPoint(pref.curCentrePt); // if not goto-point defined move map to centere point
 		}  
-		mainT.SwitchToMovingMap(centerTo);
+		mainT.SwitchToMovingMap(centerTo, false);
 	}
 	
 	/**

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-02-06 20:06:47 UTC (rev 529)
+++ trunk/src/CacheWolf/MainTab.java	2007-02-07 02:57:01 UTC (rev 530)
@@ -98,11 +98,11 @@
 	}
 
 	public void openDesciptionPanel(CacheHolder chi) {
-        MyLocale.setSIPOff();
-        descP.setText(chi);
-    }
-	
-	
+		MyLocale.setSIPOff();
+		descP.setText(chi);
+	}
+
+
 	/**
 	 * this is called from goto / MovingMap / CalcPanel and so on to 
 	 * offer the user the possibility of entering an new waypoint
@@ -125,95 +125,112 @@
 		} else	
 			select(detP);
 	}
-	
-	
+
+
 	public void onEvent(Event ev)
-		{
-		  ////Vm.debug(ev.toString());
-		  if(ev instanceof MultiPanelEvent){
-			  mnuMain.allowProfileChange(false);	  
-			  if(this.getSelectedItem() == 0){
-				  mnuMain.allowProfileChange(true);	  
-//				  Vm.setParameter(Vm.SET_ALWAYS_SHOW_SIP_BUTTON,0);
-//				  Vm.setSIP(0);
-				  MyLocale.setSIPOff();
-			  }
-			  if(detP.isDirty()) {
-				  detP.saveDirtyWaypoint();
-			  }
-			  if(this.getSelectedItem() != 0){
-				  if (tbP.getSelectedCache()>=cacheDB.size())
-					  ch=null;
-				  else {
-					  ch = (CacheHolder)cacheDB.get(tbP.getSelectedCache());
-					  try {
-						  if(ch.wayPoint.equals(lastselected) == false){
-							  ch.readCache(profile.dataDir);
-							  lastselected = ch.wayPoint;
-						  }
-					  } catch(Exception e){
+	{
+		////Vm.debug(ev.toString());
+		if(ev instanceof MultiPanelEvent){
+			mnuMain.allowProfileChange(false);	  
+			if(this.getSelectedItem() == 0){
+				mnuMain.allowProfileChange(true);	  
+//				Vm.setParameter(Vm.SET_ALWAYS_SHOW_SIP_BUTTON,0);
+//				Vm.setSIP(0);
+				MyLocale.setSIPOff();
+			}
+			if(detP.isDirty()) {
+				detP.saveDirtyWaypoint();
+			}
+			if(this.getSelectedItem() != 0){
+				if (tbP.getSelectedCache()>=cacheDB.size())
+					ch=null;
+				else {
+					ch = (CacheHolder)cacheDB.get(tbP.getSelectedCache());
+					try {
+						if(ch.wayPoint.equals(lastselected) == false){
+							ch.readCache(profile.dataDir);
+							lastselected = ch.wayPoint;
+						}
+					} catch(Exception e){
 						//Vm.debug("Error loading: "+ch.wayPoint);
-					  }
-				  }
-			  } else statBar.updateDisplay();
-				  
-			  // If no cache is selected, create a new one
-			  switch (this.getSelectedItem()) {
-				  case 1:  // DetailsPanel
-					  if (ch==null) newWaypoint(ch=new CacheHolder());
-					  MyLocale.setSIPButton();
-					  detP.setDetails(ch);
-				      break;
-				  case 2: // Description Panel
-					  if (ch!=null) {
-						  MyLocale.setSIPOff();
-						  descP.setText(ch);
-					  }
-					  break;
-				  case 3: // Picture Panel
-					  if (ch!=null) {
-						  MyLocale.setSIPOff();
-						  imageP.setImages(ch);
-					  }
-					  break;
-				  case 4:  // Log Hint Panel
-					  if (ch!=null) {
-						  MyLocale.setSIPOff();
-						  hintLP.setText(ch);
-					  }
-					  break;
-				  case 5:  // CalcPanel
-					  if (ch!=null) {
-						  MyLocale.setSIPButton();
-						  calcP.setFields(ch);
-					  }
-					  break;
-				  
-				  case 6: // GotoPanel
-					  MyLocale.setSIPButton();
-				      break;
-				  case 7:  // Solver Panel
-					  MyLocale.setSIPButton();
-					  solverP.setCh(ch);
-				      break;
-				  case 8:  // Cache Radar Panel
-					  MyLocale.setSIPOff();
-					  radarP.setParam(pref, cacheDB, ch==null?"":ch.wayPoint);
-					  radarP.drawThePanel();
-				      break;
-			  }
+					}
+				}
+			} else statBar.updateDisplay();
+
+			// If no cache is selected, create a new one
+			switch (this.getSelectedItem()) {
+			case 1:  // DetailsPanel
+				if (ch==null) newWaypoint(ch=new CacheHolder());
+				MyLocale.setSIPButton();
+				detP.setDetails(ch);
+				break;
+			case 2: // Description Panel
+				if (ch!=null) {
+					MyLocale.setSIPOff();
+					descP.setText(ch);
+				}
+				break;
+			case 3: // Picture Panel
+				if (ch!=null) {
+					MyLocale.setSIPOff();
+					imageP.setImages(ch);
+				}
+				break;
+			case 4:  // Log Hint Panel
+				if (ch!=null) {
+					MyLocale.setSIPOff();
+					hintLP.setText(ch);
+				}
+				break;
+			case 5:  // CalcPanel
+				if (ch!=null) {
+					MyLocale.setSIPButton();
+					calcP.setFields(ch);
+				}
+				break;
+
+			case 6: // GotoPanel
+				MyLocale.setSIPButton();
+				break;
+			case 7:  // Solver Panel
+				MyLocale.setSIPButton();
+				solverP.setCh(ch);
+				break;
+			case 8:  // Cache Radar Panel
+				MyLocale.setSIPOff();
+				radarP.setParam(pref, cacheDB, ch==null?"":ch.wayPoint);
+				radarP.drawThePanel();
+				break;
+			}
 		}
-		  super.onEvent(ev); //Make sure you call this.
+		super.onEvent(ev); //Make sure you call this.
 	}
 
-	public void SwitchToMovingMap(CWPoint centerTo) {
+	/**
+	 * sets posCircle Lat/Lon to centerTo
+	 * 
+	 * @param centerTo true: centers centerTo on the screen and disconnects MovingMap from GPS if Gps-pos is not on the loaded map
+	 * @param forceCenter
+	 */
+	public void SwitchToMovingMap(CWPoint centerTo, boolean forceCenter) {
 		if (mm == null) {
 			mm = new MovingMap(nav, profile.cacheDB);
 			nav.setMovingMap(mm);
-		}
-		//mm.ignoreGps = false; // TODO genauer nachdenken multi-threading: wenn er grad eine Karte l?dt o.?., dann funktioniert folgender Befehl nicht
+		} 
+		if (forceCenter) mm.setGpsStatus(MovingMap.noGPS); // disconnect movingMap from GPS TODO only if GPS-pos is not on the screen
 		mm.updatePosition(centerTo.latDec, centerTo.lonDec);
 		mm.myExec();
+		if (forceCenter) {
+			while (MapImage.screenDim.width == 0) { try {ewe.sys.mThread.sleep(100);} catch (InterruptedException e) {} } // wait until the window size of the moving map is known note: ewe.sys.sleep() will pause the whole vm - no other thread will run
+			mm.setCenterOfScreen(centerTo, true); // this can only be executed if mm knows its window size that's why myExec must be executed before
+/*			if(!mm.posCircle.isOnScreen()) { // TODO this doesn't work because lat lon is set to the wished pos and not to gps anymore
+				mm.setGpsStatus(MovingMap.noGPS); // disconnect movingMap from GPS if GPS-pos is not on the screen
+				mm.setResModus(MovingMap.HIGHEST_RESOLUTION);
+				mm.updatePosition(centerTo.latDec, centerTo.lonDec);
+				mm.setCenterOfScreen(centerTo, true); 
+			}
+*/			//TODO what to do, if there is a map at centerTo, but it is not loaded because of mapSwitchMode == dest & cuurpos und daf?r gibt es keine Karte 
+		}
 	}
 }
 

Modified: trunk/src/CacheWolf/Map.java
===================================================================
--- trunk/src/CacheWolf/Map.java	2007-02-06 20:06:47 UTC (rev 529)
+++ trunk/src/CacheWolf/Map.java	2007-02-07 02:57:01 UTC (rev 530)
@@ -35,7 +35,7 @@
 	 */
 	public Map(Preferences pref){
 		this.pref = pref;
-		mapsPath = pref.getMapManuallySavePath()+"/"; //File.getProgramDirectory() + "/maps/";
+		mapsPath = pref.getMapManuallySavePath(true)+"/"; //File.getProgramDirectory() + "/maps/";
 	}
 
 	/**
@@ -66,7 +66,7 @@
 		//this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
 		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
 		thisMap = mapToLoad;
-		mapsPath = pref.getMapManuallySavePath()+"/"; //File.getProgramDirectory() + "/maps/"; // TDO veraltet
+		mapsPath = pref.getMapManuallySavePath(true)+"/"; //File.getProgramDirectory() + "/maps/"; // TDO veraltet
 		try {
 			wfl.loadwfl(mapsPath, thisMap);
 		}catch(FileNotFoundException ex){

Modified: trunk/src/CacheWolf/MapInfoObject.java
===================================================================
--- trunk/src/CacheWolf/MapInfoObject.java	2007-02-06 20:06:47 UTC (rev 529)
+++ trunk/src/CacheWolf/MapInfoObject.java	2007-02-07 02:57:01 UTC (rev 530)
@@ -39,7 +39,7 @@
 	public String fileName = new String();
 	public String mapName = new String();
 	//private Character digSep = new Character(' ');
-	private String digSep = new String();
+	static private String digSep = MyLocale.getDigSeparator();
 	/*
 	 * loads an .wfl file
 	 * throws FileNotFoundException and IOException (data out of range)
@@ -49,17 +49,34 @@
 	 */	
 
 	public MapInfoObject() {
-		digSep = MyLocale.getDigSeparator();
 		//double testA = Convert.toDouble("1,50") + Convert.toDouble("3,00");
 		//if(testA == 4.5) digSep = ","; else digSep = ".";
 	}
+	
+	public MapInfoObject(MapInfoObject map) {
+		mapName = map.mapName;
+		affine[0] = map.affine[0];
+		affine[1] = map.affine[1];
+		affine[2] = map.affine[2];
+		affine[3] = map.affine[3];
+		affine[4] = map.affine[4];
+		affine[5] = map.affine[5];
+		lowlat = map.lowlat;
+		lowlon = map.lowlon;
+		OrigUpperLeft = new CWPoint (map.OrigUpperLeft);
+		zoomFactor = map.zoomFactor;
+		shift.set(map.shift);
+		fileName = new String(map.fileName);
+		fileNameWFL = new String(map.fileNameWFL);
+		mapName = new String(mapName);
+		doCalculations();
+	}
 
 	/*
 	 * constructes an MapInfoObject without an associated map
 	 * but with 1 Pixel = scale meters
 	 */
 	public MapInfoObject(double scalei, double lat) {
-		digSep = MyLocale.getDigSeparator();
 		mapName="empty 1 Pixel = "+scalei+"meters";
 		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
 		double pixel2deg = meters2deg * scalei;
@@ -81,7 +98,6 @@
 	 * @param name path and filename of .wfl file without the extension (it is needed because the image will be searched in the same directory)
 	 */
 	public MapInfoObject(double scalei, CWPoint center, int width, int hight, String name) {
-		digSep = MyLocale.getDigSeparator();
 		mapName = name+".wfl";
 
 		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));

Modified: trunk/src/CacheWolf/MapsList.java
===================================================================
--- trunk/src/CacheWolf/MapsList.java	2007-02-06 20:06:47 UTC (rev 529)
+++ trunk/src/CacheWolf/MapsList.java	2007-02-07 02:57:01 UTC (rev 530)
@@ -70,7 +70,7 @@
 	/**
 	 * find the best map for lat/lon in the list of maps
 	 * currently the best map is the one, whose center is nearest to lat/lon
-	 * and in Area with ist scale nearest to scale.
+	 * and in Area with its scale nearest to scale.
 	 * it always return a map (if the list is not empty) 
 	 * even if the map is not inbound
 	 * lat/lon
@@ -100,9 +100,9 @@
 			if (screenArea.isOverlapping(mi.getArea()) ) { // is on screen
 				if (!forceScale || (forceScale && java.lang.Math.abs(mi.scale - scale) > scaleTolerance)) { // different scale?
 					if (!forceScale && (mi.inBound(lat, lon) && (bestMap == null || (java.lang.Math.abs(mi.scale-scale) + scaleTolerance < java.lang.Math.abs(bestMap.scale-scale))))) 
-						better = true; // inbound and higher resolution -> better
+						better = true; // inbound and resolution nearer at wanted resolution -> better
 					else {
-						if ( bestMap == null || (java.lang.Math.abs(mi.scale-scale) < java.lang.Math.abs(bestMap.scale-scale) + scaleTolerance)) {
+						if ( bestMap == null || (java.lang.Math.abs(mi.scale - scale) < java.lang.Math.abs(bestMap.scale - scale) + scaleTolerance)) {
 							latNearer = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm < minDistLat ;
 							lonNearer = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm < minDistLon;
 							if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
@@ -122,7 +122,8 @@
 				}
 			}
 		}
-		return bestMap;
+		if (bestMap == null) return null;
+		return new MapInfoObject(bestMap); // return a copy of the MapInfoObject so that zooming won't change the MapInfoObject in the list 
 	}
 	/*
 	public MapInfoObject getBestMapNotStrictScale(double lat, double lon, Area screen, float scale) {
@@ -140,7 +141,6 @@
 	 * if topleft is really topleft or if it is buttomright is not relevant.  
 	 */
 	
-	// TODO if more than one map contains both -> select the best one of them
 	public MapInfoObject getMapForArea(CWPoint topleft, CWPoint bottomright){
 		MapInfoObject mi;
 		MapInfoObject fittingmap = null;
@@ -174,14 +174,15 @@
 				}
 			}
 		} // for
-		return fittingmap;
+		if (fittingmap == null) return null;
+		return new MapInfoObject(fittingmap);
 	}
 
 	/**
 	 * 
 	 * @param lat a point to be inside the map
 	 * @param lon
-	 * @param screen
+	 * @param screen: width, height of the screen. The map must overlap the screen. xy: where is lat/lon on screen
 	 * @param curScale reference scale to be changed
 	 * @param moreDetails true: find map with more details == higher resolustion = lower scale / false find map with less details = better overview
 	 * @return
@@ -229,7 +230,8 @@
 				}
 			}
 		}
-		return bestMap;
+		if (bestMap == null) return null;
+		return new MapInfoObject(bestMap);
 	}
 	/**
 	 * returns an area in lat/lon of the screen
@@ -255,6 +257,9 @@
 	public static boolean scaleEquals(MapInfoObject a, MapInfoObject b) {
 		return java.lang.Math.abs(a.scale - b.scale) < scaleTolerance; 
 	}
+	public static boolean scaleEquals(float s, MapInfoObject b) {
+		return java.lang.Math.abs(s - b.scale) < scaleTolerance; 
+	}
 
 	/** for determining if a new map should be downloaded
 	public boolean isInAmap(CWPoint topleft, CWPoint buttomright) {

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-06 20:06:47 UTC (rev 529)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-07 02:57:01 UTC (rev 530)
@@ -12,7 +12,7 @@
 /**
  *	Class to handle a moving map.
  */
-public class MovingMap extends Form implements TimerProc {
+public class MovingMap extends Form {
 	final static int gotFix = 4; //green
 	final static int lostFix = 3; //yellow
 	final static int noGPSData = 2; // red
@@ -54,8 +54,8 @@
 	int posCircleX = 0, posCircleY = 0, lastCompareX = Integer.MAX_VALUE, lastCompareY = Integer.MAX_VALUE;
 	double posCircleLat, posCircleLon;
 
-	boolean ignoreGps = false;
-	boolean ignoreGpsStatutsChanges = false;
+	boolean dontUpdatePos = false; // this is only internaly used to avoid multi-threading problems
+	boolean ignoreGps = false; // ignores updateGps-calls if true
 	boolean autoSelectMap = true;
 	boolean forceMapLoad = true; // only needed to force updateposition to try to load the best map again after OutOfMemoryError after an repeated click on snap-to-gps
 	boolean mapHidden = false;
@@ -160,15 +160,15 @@
 		resetCenterOfMap();
 		InfoBox inf = new InfoBox("Info", "Loading list of maps...");
 		inf.exec();
-		boolean saveGpsIgnoreStatus = ignoreGps;
-		ignoreGps = true;
+		boolean saveGpsIgnoreStatus = dontUpdatePos;
+		dontUpdatePos = true;
 		maps = new MapsList(mapsPath); // this actually loads the maps
 		if (maps.isEmpty()) {
 			(new MessageBox(MyLocale.getMsg(327, "Information"), MyLocale.getMsg(326, "Es steht keine kalibrierte Karte zur Verf?gung \n Bitte w?hlen Sie einen Ma?stab,\n in dem der Track und die markierten Caches angezeigt werden sollen"), MessageBox.OKB)).execute();
 			noMapsAvailable = true;
 		} else noMapsAvailable = false;
 		maps.addEmptyMaps(lat);
-		ignoreGps = saveGpsIgnoreStatus;
+		dontUpdatePos = saveGpsIgnoreStatus;
 		inf.close(0);
 		Vm.showWait(this, false);
 		this.mapsloaded = true;
@@ -337,8 +337,8 @@
 			TrackOverlays = new TrackOverlay[9];
 			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
 		}
-		boolean saveGPSIgnoreStatus = ignoreGps; // avoid multi-threading problems
-		ignoreGps = true;
+		boolean saveGPSIgnoreStatus = dontUpdatePos; // avoid multi-threading problems
+		dontUpdatePos = true;
 		Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft.latDec, TrackOverlaySetCenterTopLeft.lonDec); // TrackOverlay[4] == center of Trackoverlays 
 		//upperleftOf4.x = (upperleftOf4.x + 1* width) % (width * 2) - 1 * width;
 		//upperleftOf4.y = (upperleftOf4.y + 1* height) % (height * 2) - 1 * height;
@@ -357,7 +357,7 @@
 		}
 		updateOverlayOnlyPos();
 		if (mmp.mapImage != null) mmp.images.moveToBack(mmp.mapImage);
-		ignoreGps = saveGPSIgnoreStatus;
+		dontUpdatePos = saveGPSIgnoreStatus;
 	}
 
 	private void destroyOverlay(int ov) {
@@ -579,20 +579,20 @@
 		posCircle.setLocation(posCircleX-posCircle.getWidth()/2, posCircleY-posCircle.getHeight()/2);
 	}
 
-	public void movePosCircleToLatLon(CWPoint p) {
-		moveScreenXYtoLatLon(new Point(posCircleX, posCircleY), p);
+	public void movePosCircleToLatLon(CWPoint p, boolean repaint) {
+		moveScreenXYtoLatLon(new Point(posCircleX, posCircleY), p, repaint);
 	}
 
-	public void setCenterOfScreen (CWPoint c) {
-		moveScreenXYtoLatLon(new Point (this.width/2, this.height/2), c);
+	public void setCenterOfScreen (CWPoint c, boolean repaint) {
+		moveScreenXYtoLatLon(new Point (this.width/2, this.height/2), c, repaint);
 	}
 
-	public void moveScreenXYtoLatLon(Point s, CWPoint c) {
+	public void moveScreenXYtoLatLon(Point s, CWPoint c, boolean repaint) {
 		Point mappos = getMapPositionOnScreen();
 		Point onscreenpos = getXYonScreen(c.latDec, c.lonDec);
 		if (mmp != null && mmp.mapImage != null) mmp.mapImage.move(mappos.x - onscreenpos.x + s.x, mappos.y - onscreenpos.y + s.y);
 		mapMoved(s.x - onscreenpos.x, s.y - onscreenpos.y);
-
+		if (repaint) mmp.repaintNow();
 	}
 
 	/** call this if the map moved on the screen (by dragging)
@@ -682,7 +682,7 @@
 		MapSymbol ms = new MapSymbol(name, filename, lat, lon);
 		ms.loadImage();
 		ms.properties |= AniImage.AlwaysOnTop;
-		Point pOnScreen=getXYonScreen(lat, lon);
+		Point pOnScreen = getXYonScreen(lat, lon);
 		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
 		symbols.add(ms);
 		mmp.addImage(ms);
@@ -795,7 +795,7 @@
 	 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
 	 */
 	public void updatePosition(double lat, double lon){
-		if (ignoreGps || loadingMapList) return; // avoid multi-threading problems
+		if (dontUpdatePos || loadingMapList) return; // avoid multi-threading problems
 		Vm.debug("updatepors, lat: "+lat+" lon: "+lon);
 		if (!mapsloaded) {
 			loadMaps(mapPath, lat);
@@ -823,7 +823,7 @@
 	}
 
 	public void updateGps(int fix) {
-		if (!running) return;
+		if (!running || ignoreGps) return;
 		// runMovingMap neccessary in case of multi-threaded Java-VM: ticked could be called during load of mmp 
 		if ((fix > 0) && (myNavigation.gpsPos.getSats()>= 0)) { // TODO is getSats really necessary?
 			directionArrows.setDirections(-361 /*(float)bearWayP.value*/, myNavigation.sunAzimut, -361 /*(float)bearMov.value*/);
@@ -837,7 +837,6 @@
 	
 	public void gpsStarted() {
 		addTrack(myNavigation.curTrack);
-		//addOverlaySet();
 	}
 	public void gpsStoped() {
 		setGpsStatus(MovingMap.noGPS);
@@ -866,7 +865,7 @@
 	 * true: willchange the map, regardless of change in scale
 	 */
 	public void setBestMap(double lat, double lon, boolean loadIfSameScale) {
-		if (inBestMap) return;                  // TODO zoomlevel ber?cksichtigen
+		if (inBestMap) return;
 		inBestMap = true;
 		Object [] s = getRectForMapChange(lat, lon);
 		CWPoint cll = (CWPoint) s[0]; 
@@ -882,21 +881,24 @@
 			break;
 		case HIGHEST_RESOLUTION: newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 0.000001f, false); break;
 		case HIGHEST_RESOLUTION_GPS_DEST: 
-			if (gotoPos!= null) newmap = maps.getMapForArea(new CWPoint(posCircleLat, posCircleLon), new CWPoint(gotoPos.lat, gotoPos.lon));
+			if (gotoPos!= null && GpsStatus != noGPS) newmap = maps.getMapForArea(new CWPoint(posCircleLat, posCircleLon), new CWPoint(gotoPos.lat, gotoPos.lon)); // TODO use home-coos if no gps? - consider start from details panel and from gotopanel
 			else newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 0.000001f, false); 
 			break;
 		default: (new MessageBox("Error", "Programmfehler: \nillegal mapChangeModus: " + mapChangeModus, MessageBox.OKB)).execute(); break;
 		}
-		if ( newmap != null && (currentMap == null || currentMap.mapName != newmap.mapName) ) {
-			if (loadIfSameScale || !MapsList.scaleEquals(currentMap, newmap) ) setMap(newmap, lat, lon); 
-			Vm.debug("better map found");
+		if ( newmap != null && (currentMap == null || !currentMap.mapName.equals(newmap.mapName)) ) {
+			if (loadIfSameScale || !MapsList.scaleEquals(currentMap.scale / currentMap.zoomFactor, newmap) ) {
+				Vm.debug("better map found");
+				setMap(newmap, lat, lon);
+				moveScreenXYtoLatLon(new Point(screen.x, screen.y), cll, true);
+			}
 			inBestMap = false;
 			return;
 		}
 		if (currentMap == null && newmap == null) {
 			(new MessageBox("Information", "F?r die aktuelle Position steht keine Karte zur Verf?ung, bitte w?hlen Sie eine manuell", MessageBox.OKB)).execute();
-			posCircleLat = lat;
-			posCircleLon = lon; // choosemap calls setmap with posCircle-coos
+			posCircleLat = cll.latDec;
+			posCircleLon = cll.lonDec; // choosemap calls setmap with posCircle-coos
 			while (currentMap == null) {
 				mmp.chooseMap(); // force the user to select a scale // TODO empty maps on top?
 				if (currentMap == null) (new MessageBox("Error", "Moving map cannot run without a map - please select one. \n You can select an empty map", MessageBox.OKB)).execute();
@@ -928,13 +930,13 @@
 		CWPoint cll;
 		if (posCircleX >= 0 && posCircleX <= w && posCircleY >= 0 && posCircleY <= h) {
 			x = posCircleX; // posCircle is inside the screen
-			y = posCircleY;
+			y = posCircleY; // TODO eigentlich interessiert, ob nach dem evtl. Kartenwechsel PosCircle on Screen ist. So wie es jetzt ist, kann 2mal der gleiche Aufruf zum laden unterschiedlicher Karten f?hren, wenn voher PosCircle nicht auf dem SChirm war, nach dem ersten Laden aber schon.
 			cll = new CWPoint(lat, lon);
 		} else { // when posCircle out of screen - use center of screen as point which as to be included in the map
 			cll = ScreenXY2LatLon(w/2, h/2);
 			x = w/2;
 			y = h/2;
-		}
+		} 
 		Object[] ret = new Object[2];
 		ret[0] = cll;
 		ret[1] = new Rect(x, y, w, h);
@@ -951,13 +953,13 @@
 		CWPoint cll = (CWPoint) s[0]; 
 		Rect screen = (Rect) s[1]; 
 		//Rect screen = new Rect(posCircleX, posCircleY, (width != 0 ? width : pref.myAppWidth), (height != 0 ? height : pref.myAppHeight));
-		MapInfoObject m = maps.getMapChangeResolution(cll.latDec, cll.lonDec, screen, currentMap.scale, !betterOverview);
+		MapInfoObject m = maps.getMapChangeResolution(cll.latDec, cll.lonDec, screen, currentMap.scale / currentMap.zoomFactor, !betterOverview);
 		if (m != null) {
-			boolean saveGpsIgnStatus = ignoreGps;
-			ignoreGps = true;
+			boolean saveGpsIgnStatus = dontUpdatePos;
+			dontUpdatePos = true;
 			setMap(m, posCircleLat, posCircleLon);
 			setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
-			ignoreGps = saveGpsIgnStatus;
+			dontUpdatePos = saveGpsIgnStatus;
 		}
 		else (new MessageBox("Error", "No "+ (betterOverview ? "less" : "more") + " deteiled map available", MessageBox.OKB)).execute();
 	}
@@ -975,19 +977,20 @@
 			Rect screen = (Rect) s[1]; 
 			newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, Float.MAX_VALUE -1, false);
 		}
-		boolean saveGpsIgnStatus = ignoreGps;
-		ignoreGps = true;
+		boolean saveGpsIgnStatus = dontUpdatePos;
+		dontUpdatePos = true;
 		setMap(newmap, posCircleLat, posCircleLon);
 		setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
-		ignoreGps = saveGpsIgnStatus;
+		dontUpdatePos = saveGpsIgnStatus;
 	}
 
 	public void setGpsStatus (int status) {
-		if ((status == GpsStatus) || ignoreGpsStatutsChanges) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
+		if (status == GpsStatus) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
 		GpsStatus = status;
+		dontUpdatePos = false;
 		ignoreGps = false;
 		switch (status) {
-		case noGPS: 	{ posCircle.change(null); /*ignoreGps = true; */ break; }
+		case noGPS: 	{ posCircle.change(null); ignoreGps = true; break; }
 		case gotFix:    { posCircle.change(statusImageHaveSignal); break; }
 		case lostFix:   { posCircle.change(statusImageNoSignal); break; }
 		case noGPSData: { posCircle.change(statusImageNoGps); break; }
@@ -997,8 +1000,8 @@
 
 	public void SnapToGps() {
 		resetCenterOfMap();
+		dontUpdatePos = false;
 		ignoreGps = false;
-		ignoreGpsStatutsChanges = false;
 		lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
 		lastCompareY = Integer.MAX_VALUE;
 		autoSelectMap = true;
@@ -1014,14 +1017,14 @@
 	 * @param lon -361: don't adust to lat/lon
 	 */
 	public void setMap(MapInfoObject newmap, double lat, double lon) {
-		if (currentMap != null && newmap.mapName == currentMap.mapName && !forceMapLoad) {
+		if (currentMap != null && newmap.mapName.equals(currentMap.mapName) && !forceMapLoad) { // note: newmap.mapName == currentMap.mapName won't work because they are different String containing the same text 
 			updateOnlyPosition(lat, lon, true); 
 			return;
 		}
 		Vm.showWait(true);
 		boolean saveIgnoreStatus;
-		saveIgnoreStatus = ignoreGps;
-		ignoreGps = true;  // make updatePosition ignore calls during loading new map
+		saveIgnoreStatus = dontUpdatePos;
+		dontUpdatePos = true;  // make updatePosition ignore calls during loading new map
 		InfoBox inf;
 		inf = new InfoBox("Info", "Loading map...");
 		inf.show();
@@ -1060,7 +1063,7 @@
 			updateScale();
 			inf.close(0);  // this doesn't work in a ticked-thread in the ewe-vm. That's why i made a new mThread in gotoPanel for ticked
 			Vm.showWait(false);
-			ignoreGps = saveIgnoreStatus;
+			dontUpdatePos = saveIgnoreStatus;
 		} catch (IllegalArgumentException e) { // thrown by new AniImage() in ewe-vm if file not found;
 			if (mmp.mapImage != null) {
 				mmp.removeImage(mmp.mapImage); 
@@ -1072,7 +1075,7 @@
 			inf.close(0);
 			Vm.showWait(false);
 			(new MessageBox("Error", "Could not load map: "+ newmap.getImageFilename(), MessageBox.OKB)).execute();
-			ignoreGps = saveIgnoreStatus;
+			dontUpdatePos = saveIgnoreStatus;
 		} catch (OutOfMemoryError e) {
 			if (mmp.mapImage != null) {
 				mmp.removeImage(mmp.mapImage); 
@@ -1084,7 +1087,7 @@
 			inf.close(0);
 			Vm.showWait(false);
 			(new MessageBox("Error", "Not enough memory to load map: "+ newmap.getImageFilename()+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
-			ignoreGps = saveIgnoreStatus;
+			dontUpdatePos = saveIgnoreStatus;
 		}catch (SystemResourceException e) {
 			if (mmp.mapImage != null) {
 				mmp.removeImage(mmp.mapImage); 
@@ -1096,7 +1099,7 @@
 			inf.close(0);
 			Vm.showWait(false);
 			(new MessageBox("Error", "Not enough ressources to load map: "+ newmap.getImageFilename()+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
-			ignoreGps = saveIgnoreStatus;
+			dontUpdatePos = saveIgnoreStatus;
 		}
 	}
 
@@ -1186,9 +1189,9 @@
 	 */		
 	public void zoomFromUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
 		Vm.showWait(this, true);
-		boolean savegpsstatus = ignoreGps;
+		boolean savegpsstatus = dontUpdatePos;
 		if (mapImage1to1 != null) {
-			ignoreGps = true; // avoid multi-thread problems
+			dontUpdatePos = true; // avoid multi-thread problems
 			int saveprop = AniImage.IsMoveable;
 			MapImage tmp = null; // = mmp.mapImage;
 			if (mmp.mapImage != null) {
@@ -1222,15 +1225,15 @@
 			}
 		} else // no map image loaded 
 		{ currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y); }
-		scaleWanted = currentMap.scale;
+		// scaleWanted = currentMap.scale; use this if you want to change automatically to a map scale that best fits the zooming
 		destroyOverlaySet();
 		Vm.getUsedMemory(true); // call garbage collection
-		setCenterOfScreen(center);
+		setCenterOfScreen(center, false);
 		addOverlaySet();
 		updateScale();
 		this.repaintNow();
 		Vm.showWait(this, false);
-		ignoreGps = savegpsstatus;
+		dontUpdatePos = savegpsstatus;
 	}
 
 	/*	public void gotFocus(int how) {
@@ -1305,8 +1308,8 @@
 		}
 		// move (drag) map
 		//if (!(which == null || which == mapImage || which instanceof TrackOverlay || which == mm.directionArrows) ) return false;
-		saveGpsIgnoreStatus = mm.ignoreGps; 
-		mm.ignoreGps = true;
+		saveGpsIgnoreStatus = mm.dontUpdatePos; 
+		mm.dontUpdatePos = true;
 		saveMapLoc = pos;
 		bringMapToTop();
 		if (mapImage.isOnScreen() && !mapImage.hidden ) return super.imageBeginDragged(mapImage, pos);
@@ -1318,7 +1321,7 @@
 		bringMaptoBack();
 		if (dc.image == null) moveMap(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
 		else mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
-		mm.ignoreGps = saveGpsIgnoreStatus;
+		mm.dontUpdatePos = saveGpsIgnoreStatus;
 		this.repaintNow();
 		return ret;
 	}
@@ -1328,8 +1331,8 @@
 			saveMapLoc = new Point (ev.x, ev.y);
 		}
 		if (mm.zoomingMode && ev.type == PenEvent.PEN_DOWN) {
-			saveGpsIgnoreStatus = mm.ignoreGps;
-			mm.ignoreGps = true;
+			saveGpsIgnoreStatus = mm.dontUpdatePos;
+			mm.dontUpdatePos = true;
 			saveMapLoc = new Point (ev.x, ev.y);
 			paintingZoomArea = true;
 			mm.zoomingMode = true;
@@ -1340,7 +1343,7 @@
 		if (mm.zoomingMode && ev.type == PenEvent.PEN_UP ) {
 			paintingZoomArea = false;
 			mm.zoomingMode = false;
-			mm.ignoreGps = saveGpsIgnoreStatus;
+			mm.dontUpdatePos = saveGpsIgnoreStatus;
 			removeImage(mm.buttonImageLensActivated);
 			addImage(mm.buttonImageLens);
 			if (java.lang.Math.abs(lastZoomWidth) < 15 || java.lang.Math.abs(lastZoomHeight) < 15)  {
@@ -1425,16 +1428,14 @@
 			if (l.selectedMap.inBound(mm.posCircleLat, mm.posCircleLon) || l.selectedMap.getImageFilename().length()==0) {
 				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon);
 				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
-				mm.ignoreGpsStatutsChanges = false;
+				mm.ignoreGps = false;
 			} else {
-				mm.ignoreGpsStatutsChanges = false;
 				mm.setGpsStatus(MovingMap.noGPS);
-				mm.ignoreGpsStatutsChanges = true;
+				mm.ignoreGps = true;
 				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon); 
 				if (mm.currentMap.fileNameWFL.length() > 0)
-					mm.setCenterOfScreen(l.selectedMap.center); // if map has an image
+					mm.setCenterOfScreen(l.selectedMap.center, true); // if map has an image
 				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
-				mm.repaintNow();
 				//Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
 				//double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4]; 
 				//mm.posCircleX = 0; // place map to the upper left corner of windows
@@ -1494,6 +1495,8 @@
 		}
 		if (which == mm.buttonImageLens) {
 			mm.setZoomingMode();
+			lastZoomWidth = 0;
+			lastZoomHeight = 0;
 		}
 		if (which == mm.buttonImageZoom1to1) {
 			mm.zoom1to1();
@@ -1592,13 +1595,11 @@
 						// moveto position
 						if (action == moveToCenterMI) {
 							mapsMenu.close();
-							mm.setCenterOfScreen(Global.getPref().curCentrePt);
-							mm.repaintNow();
+							mm.setCenterOfScreen(Global.getPref().curCentrePt, true);
 						}
 						if (action == moveToDestMI) {
 							mapsMenu.close();
-							mm.setCenterOfScreen(new CWPoint(mm.gotoPos.lat, mm.gotoPos.lon));
-							mm.repaintNow();
+							mm.setCenterOfScreen(new CWPoint(mm.gotoPos.lat, mm.gotoPos.lon), true);
 						}
 						if (action == moveToGpsMI) {
 							mapsMenu.close();
@@ -1678,7 +1679,7 @@
 					list.addItem(i + ": " + map.mapName);
 					row++;
 					inList[i] = true;
-					if (map == curMap) { oldmap = row; curMapFound = true; }
+					if (map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
 				} else inList[i] = false;
 			}
 		}
@@ -1688,13 +1689,13 @@
 			for(int i = 0; i<maps.size();i++){
 				map = new MapInfoObject();
 				map = (MapInfoObject)maps.get(i);
-				if (map == curMap) oldmap = i;
+				if (map.mapName.equals(curMap.mapName)) oldmap = i;
 				if (map.inBound(Gps.latDec, Gps.lonDec) == true) 
 				{
 					list.addItem(i + ": " + map.mapName);
 					row++;
 					inList[i] = true;
-					if (!curMapFound  && map == curMap) { oldmap = row; curMapFound = true; }
+					if (!curMapFound  && map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
 				}
 			}
 		}
@@ -1708,7 +1709,7 @@
 					list.addItem(i + ": " + map.mapName);
 					row++;
 					inList[i] = true;
-					if (!curMapFound  && map == curMap) { oldmap = row; curMapFound = true; }
+					if (!curMapFound  && map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
 				}
 			}
 		}
@@ -1720,7 +1721,7 @@
 			if(!inList[i]) {
 				list.addItem(i + ": " + map.mapName);
 				row++;
-				if (!curMapFound  && map == curMap) { oldmap = row; curMapFound = true; }
+				if (!curMapFound  && map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
 			}
 		}
 		list.selectItem(oldmap, true);

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-02-06 20:06:47 UTC (rev 529)
+++ trunk/src/CacheWolf/Preferences.java	2007-02-07 02:57:01 UTC (rev 530)
@@ -135,16 +135,16 @@
 	public String getMapLoadPath() {
 		// here could also a list of map-types displayed...
 		// standard dir
-		File t = new File(getMapManuallySavePath());
+		File t = new File(getMapManuallySavePath(false));
 		String[] f = t.list("*.wfl", File.LIST_ALWAYS_INCLUDE_DIRECTORIES | File.LIST_FILES_ONLY);
 		if (f != null && f.length > 0) return  baseDir + mapsPath;
 		f = t.list("*.wfl", File.LIST_DIRECTORIES_ONLY | File.LIST_ALWAYS_INCLUDE_DIRECTORIES);
 		if (f != null && f.length > 0) { // see if in a subdir of <baseDir>/maps/standard are .wfl files
 			String[] f2;
 			for (int i = 0; i< f.length; i++) {
-				t.set(null, getMapManuallySavePath()+"/"+f[i]);
+				t.set(null, getMapManuallySavePath(false)+"/"+f[i]);
 				f2 = t.list("*.wfl", File.LIST_FILES_ONLY);
-				if (f2 != null && f2.length > 0) return  getMapManuallySavePath();
+				if (f2 != null && f2.length > 0) return  getMapManuallySavePath(false);
 			}
 		}
 		// lagacy dir 
@@ -153,7 +153,7 @@
 		if (f != null && f.length > 0) {
 			MessageBox inf = new MessageBox("Information", "The directory for calibrated maps \nhas moved in this program version\n to '<profiles directory>/maps/standard'\n Do you want to move your calibrated maps there now?", MessageBox.YESB | MessageBox.NOB);
 			if (inf.execute() == MessageBox.IDYES) {
-				String sp = getMapManuallySavePath();
+				String sp = getMapManuallySavePath(false);
 				File spF = new File(sp);
 				if (!spF.exists()) spF.mkdirs();
 				String image;
@@ -182,9 +182,9 @@
 	 * @return the path where manually imported maps should be stored
 	 * this should be adjustable in preferences...
 	 */
-	public String getMapManuallySavePath() {
+	public String getMapManuallySavePath(boolean create) {
 		String mapsDir = baseDir + mapsPath;
-		if (!(new File(mapsDir).isDirectory())) { // dir exists? 
+		if (create && !(new File(mapsDir).isDirectory())) { // dir exists? 
 			if (new File(mapsDir).mkdirs() == false) {// dir creation failed?
 				(new MessageBox("Error", "Error: cannot create maps directory: \n"+mapsDir, MessageBox.OKB)).exec();
 				return null;

Modified: trunk/src/CacheWolf/SelectMap.java
===================================================================
--- trunk/src/CacheWolf/SelectMap.java	2007-02-06 20:06:47 UTC (rev 529)
+++ trunk/src/CacheWolf/SelectMap.java	2007-02-07 02:57:01 UTC (rev 530)
@@ -24,7 +24,7 @@
 	public boolean worldfileexists = false;
 	
 	public SelectMap(){
-		mapsPath = Global.getPref().getMapManuallySavePath()+"/"; //  File.getProgramDirectory() + "/maps/";
+		mapsPath = Global.getPref().getMapManuallySavePath(false)+"/"; //  File.getProgramDirectory() + "/maps/";
 		top = new ScrollBarPanel(CMaps);
 		bot = new ScrollBarPanel(nonCMaps);
 		this.title = (String)lr.get(4101,"Maps");
@@ -41,7 +41,7 @@
 			File checkWFL;
 			Extractor ext;
 			String rawFileName = new String();
-			dateien = files.list("*.png", File.LIST_FILES_ONLY);
+			dateien = files.list("*.png,*.jpg,*.gif,*.bmp", File.LIST_FILES_ONLY);
 			for(int i = 0; i < dateien.length;i++){
 				ext = new Extractor(dateien[i], "", ".", 0, true);
 				rawFileName = ext.findNext();



From bilbowolf at mail.berlios.de  Wed Feb  7 08:10:43 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Wed, 7 Feb 2007 08:10:43 +0100
Subject: [Cachewolf-svn] r531 - trunk/src/CacheWolf
Message-ID: <200702070710.l177Ah1j016108@sheep.berlios.de>

Author: bilbowolf
Date: 2007-02-07 08:10:41 +0100 (Wed, 07 Feb 2007)
New Revision: 531

Modified:
   trunk/src/CacheWolf/DataMover.java
   trunk/src/CacheWolf/GPXImporter.java
   trunk/src/CacheWolf/LOCXMLImporter.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/SpiderGC.java
Log:


Modified: trunk/src/CacheWolf/DataMover.java
===================================================================
--- trunk/src/CacheWolf/DataMover.java	2007-02-07 02:57:01 UTC (rev 530)
+++ trunk/src/CacheWolf/DataMover.java	2007-02-07 07:10:41 UTC (rev 531)
@@ -39,7 +39,7 @@
 			}//if srcHolder...
 		}//for ... i < srcDB ...
 		// write indexfiles
-		profile.saveIndex(pref);
+		profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
 	}
 
 	public void copyCaches(){
@@ -86,7 +86,7 @@
 			}//if srcHolder...
 		}//for ... i < srcDB ...
 		// write indexfiles
-		dstProfile.saveIndex(pref);
+		dstProfile.saveIndex(pref, Profile.NO_SHOW_PROGRESS_BAR);
 	}
 	
 	public void moveCaches() {
@@ -136,8 +136,8 @@
 			}//if srcHolder...
 		}//for ... i < srcDB ...
 		// write indexfiles
-		dstProfile.saveIndex(pref);
-		profile.saveIndex(pref);
+		dstProfile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
+		profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
 	}
 
 	public void deleteCacheFiles(String wpt, String dir){

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2007-02-07 02:57:01 UTC (rev 530)
+++ trunk/src/CacheWolf/GPXImporter.java	2007-02-07 07:10:41 UTC (rev 531)
@@ -134,7 +134,7 @@
 					infB.close(0);
 				}
 				// save Index 
-				profile.saveIndex(pref);
+				profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
 				infB.close(0);
 			}
 				Vm.showWait(false);

Modified: trunk/src/CacheWolf/LOCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/LOCXMLImporter.java	2007-02-07 02:57:01 UTC (rev 530)
+++ trunk/src/CacheWolf/LOCXMLImporter.java	2007-02-07 07:10:41 UTC (rev 531)
@@ -69,7 +69,7 @@
 						parse(r);
 						r.close();
 			// save Index 
-			profile.saveIndex(pref);
+			profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
 			Vm.showWait(false);
 		}catch(Exception e){
 			//Vm.debug(e.toString());
@@ -118,7 +118,7 @@
 			}
 			// save all
 			holder.saveCacheDetails(profile.dataDir);
-			profile.saveIndex(pref);
+			profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
 			return;
 		}
 

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-02-07 02:57:01 UTC (rev 530)
+++ trunk/src/CacheWolf/MainMenu.java	2007-02-07 07:10:41 UTC (rev 531)
@@ -408,7 +408,7 @@
 			}
 			
 			if(mev.selectedItem == orgCopy){
-				profile.saveIndex(pref);
+				profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
 
 				DataMover dm = new DataMover();
 				dm.copyCaches();
@@ -416,7 +416,7 @@
 			}
 
 			if(mev.selectedItem == orgMove){
-				profile.saveIndex(pref);
+				profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
 
 				DataMover dm = new DataMover();
 				dm.moveCaches();
@@ -424,7 +424,7 @@
 			}
 			
 			if(mev.selectedItem == orgDelete){
-				profile.saveIndex(pref);
+				profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
 
 				DataMover dm = new DataMover();
 				dm.deleteCaches();
@@ -432,12 +432,12 @@
 			}
 			
 			if(mev.selectedItem == savenoxit){
-				profile.saveIndex(pref);
+				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
 				tbp.saveColWith(pref);
 			}
 			
 			if(mev.selectedItem == savenexit){
-				profile.saveIndex(pref);
+				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
 				tbp.saveColWith(pref);
 				ewe.sys.Vm.exit(0);
 			}

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-02-07 02:57:01 UTC (rev 530)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-02-07 07:10:41 UTC (rev 531)
@@ -175,7 +175,7 @@
 		if (success) {
 			profile.last_sync_opencaching = dateOfthisSync.format("yyyyMMddHHmmss");
 			//pref.savePreferences();
-			profile.saveIndex(pref);
+			profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
 			finalMessage=MyLocale.getMsg(1607,"Update from opencaching successful");
 		}
 		inf.close(0);
@@ -364,7 +364,7 @@
 			}
 			// save all
 			holder.saveCacheDetails(profile.dataDir);
-			profile.saveIndex(pref);
+			profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
 			return;
 		}
 		if(name.equals("id")){

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-02-07 02:57:01 UTC (rev 530)
+++ trunk/src/CacheWolf/Profile.java	2007-02-07 07:10:41 UTC (rev 531)
@@ -7,7 +7,9 @@
 import ewe.io.IOException;
 import ewe.io.PrintWriter;
 import ewe.sys.Convert;
+import ewe.sys.Handle;
 import ewe.sys.Vm;
+import ewe.ui.ProgressBarForm;
 import ewe.util.Hashtable;
 import ewe.util.Vector;
 
@@ -34,7 +36,10 @@
 	public String last_sync_opencaching = new String();
 	/** Distance for opencaching caches */
 	public String distOC = new String();
-
+	
+	public final static boolean SHOW_PROGRESS_BAR = true;
+	public final static boolean NO_SHOW_PROGRESS_BAR = false;
+	
 	public final static String FILTERTYPE="11111111111000000";
 	public final static String FILTERROSE="1111111111111111";
 	public final static String FILTERVAR="11111111";
@@ -77,7 +82,14 @@
 	 *   
 	 *   Not sure whether we need to keep 'pref' in method signature. May eventually remove it. 
 	 */
-	public void saveIndex(Preferences pref){
+	public void saveIndex(Preferences pref, boolean showprogress){
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+		if(showprogress){
+			pbf.showMainTask = false;
+			pbf.setTask(h,"Saving Index");
+			pbf.exec();
+		}
 		PrintWriter detfile;
 		CacheHolder ch;
 		try{
@@ -108,6 +120,10 @@
 					filterDiff+"\" terr = \""+filterTerr+"\" size = \""+filterSize+"\" />\n");
 			detfile.print("    <SYNCOC date = \""+last_sync_opencaching+"\" dist = \""+distOC+"\"/>\n");
 			for(int i = 0; i<cacheDB.size();i++){
+				if(showprogress){
+					h.progress = (float)i/(float)cacheDB.size();
+					h.changed();
+				}
 				ch = (CacheHolder)cacheDB.get(i);
 				////Vm.debug("Saving: " + ch.CacheName);
 				if(ch.wayPoint.length()>0 && ch.LongDescription.equals("An Error Has Occured") == false){
@@ -126,8 +142,11 @@
 			detfile.print("</CACHELIST>\n");
 			detfile.close();
 			buildReferences();
+			if(showprogress) pbf.exit(0);
 		}catch(Exception e){
 			Vm.debug("Problem writing to index file "+e.toString());
+			detfile.close();
+			if(showprogress) pbf.exit(0);
 		}
 	}
 

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-02-07 02:57:01 UTC (rev 530)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-02-07 07:10:41 UTC (rev 531)
@@ -198,7 +198,7 @@
 		ch.saveCacheDetails(profile.dataDir);
 		
 		cacheDB.set(number, ch);
-		profile.saveIndex(pref);
+		profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
 		infB.close(0);
 		Vm.showWait(false);
 	}
@@ -376,7 +376,7 @@
 					pref.log("Got additional waypoints");
 					ch.saveCacheDetails(profile.dataDir);
 					cacheDB.add(ch);
-					profile.saveIndex(pref);
+					profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
 				}catch(Exception ex){
 					pref.log("There was an error in the last step:");
 					pref.log("Cache was: " + wpt);
@@ -387,7 +387,7 @@
 				}
 			}
 		}
-		profile.saveIndex(pref);
+		profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
 		infB.close(0);
 		Vm.showWait(false);
 		/*



From bilbowolf at mail.berlios.de  Wed Feb  7 08:11:15 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Wed, 7 Feb 2007 08:11:15 +0100
Subject: [Cachewolf-svn] r532 - trunk/src/CacheWolf
Message-ID: <200702070711.l177BFQ1016168@sheep.berlios.de>

Author: bilbowolf
Date: 2007-02-07 08:11:14 +0100 (Wed, 07 Feb 2007)
New Revision: 532

Modified:
   trunk/src/CacheWolf/Version.java
Log:


Modified: trunk/src/CacheWolf/Version.java
===================================================================
--- trunk/src/CacheWolf/Version.java	2007-02-07 07:10:41 UTC (rev 531)
+++ trunk/src/CacheWolf/Version.java	2007-02-07 07:11:14 UTC (rev 532)
@@ -10,7 +10,7 @@
 	static final String VER_MAJOR = "";
 	static final String VER_MINOR = "";
 	static final String VER_BUILD = " RC ";
-	static final String VER_SVN ="$LastChangedRevision$";  // the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
+	static final String VER_SVN ="$LastChangedRevision$";  //the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
 	
 	/**
 	 * @return



From kalli at mail.berlios.de  Wed Feb  7 20:42:15 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Wed, 7 Feb 2007 20:42:15 +0100
Subject: [Cachewolf-svn] r533 - trunk/src/CacheWolf
Message-ID: <200702071942.l17JgFlS026732@sheep.berlios.de>

Author: kalli
Date: 2007-02-07 20:41:53 +0100 (Wed, 07 Feb 2007)
New Revision: 533

Modified:
   trunk/src/CacheWolf/MyComparer.java
   trunk/src/CacheWolf/Profile.java
Log:
Addi wpts werden jetzt nach waypoint sortiert

Modified: trunk/src/CacheWolf/MyComparer.java
===================================================================
--- trunk/src/CacheWolf/MyComparer.java	2007-02-07 07:11:14 UTC (rev 532)
+++ trunk/src/CacheWolf/MyComparer.java	2007-02-07 19:41:53 UTC (rev 533)
@@ -49,18 +49,8 @@
 					str02 = oo2.terrain;
 				}
 				if(compareWhat.equals(nmWay)){
-					if (CacheType.isAddiWpt(oo1.type) && oo1.wayPoint.length()>1){
-						str01 = "GC" + oo1.wayPoint.substring(2);
-					}
-					else {
-						str01 = oo1.wayPoint;
-					}
-					if (CacheType.isAddiWpt(oo2.type) && oo2.wayPoint.length()>1){
-						str02 = "GC" + oo2.wayPoint.substring(2);
-					}
-					else {
-						str02 = oo2.wayPoint;
-					}
+					str01 = oo1.wayPoint;
+					str02 = oo2.wayPoint;
 				}
 				if(compareWhat.equals(nmName)){
 					str01 = oo1.CacheName;

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-02-07 07:11:14 UTC (rev 532)
+++ trunk/src/CacheWolf/Profile.java	2007-02-07 19:41:53 UTC (rev 533)
@@ -8,6 +8,8 @@
 import ewe.io.PrintWriter;
 import ewe.sys.Convert;
 import ewe.sys.Handle;
+import ewe.sys.LocalResource;
+import ewe.sys.Locale;
 import ewe.sys.Vm;
 import ewe.ui.ProgressBarForm;
 import ewe.util.Hashtable;
@@ -368,6 +370,9 @@
 	public void buildReferences(){
 		CacheHolder ch, mainCh;
 		Hashtable dbIndex = new Hashtable((int)(cacheDB.size()/0.75f + 1), 0.75f); // initialize so that von rehashing is neccessary
+		Locale l = Vm.getLocale();
+		LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
+
 		Integer index;
 		// Build index for faster search and clear all references
 		for(int i = cacheDB.size() -1; i >= 0;i--){
@@ -395,6 +400,14 @@
 				}// if
 			}// if
 		}// for
+		// sort addi wpts
+		for(int i =  0; i < max ;i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			if (ch.hasAddiWpt() && (ch.addiWpts.size()> 1)){
+				ch.addiWpts.sort(new MyComparer((String)lr.get(1002,"Waypoint")), false);
+			}
+		}
+	
 	}
 
 	/** Ensure that all filters have the proper length so that the 'charAt' access in the filter



From salzkammergut at mail.berlios.de  Wed Feb  7 20:58:21 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Wed, 7 Feb 2007 20:58:21 +0100
Subject: [Cachewolf-svn] r534 - trunk/src/CacheWolf
Message-ID: <200702071958.l17JwLL9028168@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-07 20:58:15 +0100 (Wed, 07 Feb 2007)
New Revision: 534

Modified:
   trunk/src/CacheWolf/DetailsPanel.java
Log:
DetailsPanel: Bugfix
Beim Eingeben von Koordinaten in einen neuen Wegpunkt wurden diese nicht sofort in LatLon gespeichert

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-02-07 19:41:53 UTC (rev 533)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-02-07 19:58:15 UTC (rev 534)
@@ -298,6 +298,7 @@
 					coords = cs.getCoords();
 					thisCache.pos.set(coords);
 					btnWayLoc.setText(coords.toString());
+					thisCache.LatLon=coords.toString();
 				}
 			}
 			ev.consumed=true;



From salzkammergut at mail.berlios.de  Wed Feb  7 21:46:58 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Wed, 7 Feb 2007 21:46:58 +0100
Subject: [Cachewolf-svn] r535 - trunk/src/CacheWolf
Message-ID: <200702072046.l17Kkwns031721@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-07 21:46:48 +0100 (Wed, 07 Feb 2007)
New Revision: 535

Modified:
   trunk/src/CacheWolf/MainMenu.java
Log:
Blacklist: Beim Ein/aus-schalten wird der Status des Filters beibehalten, d.h. gefiltert/invertiert wird sofort auf die neue Selektion durchgef?\195?\188hrt
Vorschlag: 2cachefix im Thread 528

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-02-07 19:58:15 UTC (rev 534)
+++ trunk/src/CacheWolf/MainMenu.java	2007-02-07 20:46:48 UTC (rev 535)
@@ -119,7 +119,7 @@
 		///////////////////////////////////////////////////////////////////////
 		// Create a combined "Filter and Search" pulldown menu for devices with small screens
 		///////////////////////////////////////////////////////////////////////
-		MenuItem[] filterAndSearchMenuItems=new MenuItem[10];
+		MenuItem[] filterAndSearchMenuItems=new MenuItem[11];
 		filterAndSearchMenuItems[0]=filtApply;
 		filterAndSearchMenuItems[1]=filtCreate;
 		filterAndSearchMenuItems[2]=filtInvert;
@@ -128,8 +128,9 @@
 		filterAndSearchMenuItems[5]=filtBlack;
 		filterAndSearchMenuItems[6]=filtSelected;
 		filterAndSearchMenuItems[7]=mnuSeparator;
-		filterAndSearchMenuItems[8]=search;
-		filterAndSearchMenuItems[9]=searchClr;
+		filterAndSearchMenuItems[8]=mnuSeparator;
+		filterAndSearchMenuItems[9]=search;
+		filterAndSearchMenuItems[10]=searchClr;
 		
 		// Depending on screen width display either filter and searach menus or the combined menu 
 		if (MyLocale.getScreenWidth()>300) {
@@ -292,8 +293,8 @@
 			if(mev.selectedItem == filtBlack){
 				filtBlack.modifiers^=MenuItem.Checked;
 				Filter.showBlacklisted=!Filter.showBlacklisted;
-				Filter flt = new Filter();
-				flt.clearFilter();
+				SearchCache ssc = new SearchCache(cacheDB);
+				ssc.clearSearch();// Clear search & restore filter status
 				tbp.refreshTable();
 			}
 			if(mev.selectedItem == exportGPS){



From bilbowolf at mail.berlios.de  Thu Feb  8 07:05:30 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Thu, 8 Feb 2007 07:05:30 +0100
Subject: [Cachewolf-svn] r536 - trunk/src/CacheWolf
Message-ID: <200702080605.l1865UHF027788@sheep.berlios.de>

Author: bilbowolf
Date: 2007-02-08 07:05:26 +0100 (Thu, 08 Feb 2007)
New Revision: 536

Modified:
   trunk/src/CacheWolf/SpiderGC.java
   trunk/src/CacheWolf/Version.java
Log:


Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-02-07 20:46:48 UTC (rev 535)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-02-08 06:05:26 UTC (rev 536)
@@ -186,9 +186,9 @@
 		pref.log("Trying images");
 		getImages(start, ch);
 		pref.log("Got images");
-		pref.log("Trying maps");
+		//pref.log("Trying maps");
 		//getMaps(ch);
-		pref.log("Got maps");
+		//pref.log("Got maps");
 		pref.log("Getting additional waypoints");
 
 		getAddWaypoints(start, ch);
@@ -276,7 +276,7 @@
 			if(found_on_page < 20) distance = 0;
 			if(distance > 0){
 				page_number++;
-				if(page_number >= 15) page_number = 4;
+				if(page_number >= 15) page_number = 5;
 				doc = URL.encodeURL("__VIEWSTATE",false) +"="+ URL.encodeURL(viewstate,false);
 				doc += "&" + URL.encodeURL("lat",false) +"="+ URL.encodeURL(origin.getLatDeg(CWPoint.DD),false);
 				doc += "&" + URL.encodeURL("lon",false) +"="+ URL.encodeURL(origin.getLonDeg(CWPoint.DD),false);

Modified: trunk/src/CacheWolf/Version.java
===================================================================
--- trunk/src/CacheWolf/Version.java	2007-02-07 20:46:48 UTC (rev 535)
+++ trunk/src/CacheWolf/Version.java	2007-02-08 06:05:26 UTC (rev 536)
@@ -10,7 +10,7 @@
 	static final String VER_MAJOR = "";
 	static final String VER_MINOR = "";
 	static final String VER_BUILD = " RC ";
-	static final String VER_SVN ="$LastChangedRevision$";  //the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
+	static final String VER_SVN ="$LastChangedRevision$";  // the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
 	
 	/**
 	 * @return



From pfeffer at mail.berlios.de  Thu Feb  8 20:58:06 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 8 Feb 2007 20:58:06 +0100
Subject: [Cachewolf-svn] r537 - trunk/src/CacheWolf
Message-ID: <200702081958.l18Jw6kX030151@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-08 20:58:03 +0100 (Thu, 08 Feb 2007)
New Revision: 537

Modified:
   trunk/src/CacheWolf/SelectMap.java
Log:
Bug fiexed: Karten manuell kalibrieren: Es wurden keine zu kalibrierenden Karten in der Liste angezeigt.

Modified: trunk/src/CacheWolf/SelectMap.java
===================================================================
--- trunk/src/CacheWolf/SelectMap.java	2007-02-08 06:05:26 UTC (rev 536)
+++ trunk/src/CacheWolf/SelectMap.java	2007-02-08 19:58:03 UTC (rev 537)
@@ -41,7 +41,7 @@
 			File checkWFL;
 			Extractor ext;
 			String rawFileName = new String();
-			dateien = files.list("*.png,*.jpg,*.gif,*.bmp", File.LIST_FILES_ONLY);
+			dateien = files.listMultiple("*.png,*.jpg,*.gif,*.bmp", File.LIST_FILES_ONLY);
 			for(int i = 0; i < dateien.length;i++){
 				ext = new Extractor(dateien[i], "", ".", 0, true);
 				rawFileName = ext.findNext();



From salzkammergut at mail.berlios.de  Thu Feb  8 21:05:37 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Thu, 8 Feb 2007 21:05:37 +0100
Subject: [Cachewolf-svn] r538 - trunk/src/CacheWolf
Message-ID: <200702082005.l18K5bQr030561@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-08 21:05:31 +0100 (Thu, 08 Feb 2007)
New Revision: 538

Modified:
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: Kontextmenue "Neuer Wegpunkt" setzte LatLon nicht und in Listenansicht wurden die Koordinaten nicht dargestellt

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-08 19:58:03 UTC (rev 537)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-08 20:05:31 UTC (rev 538)
@@ -1631,11 +1631,12 @@
 					if (action == newWayPointMenuItem) {
 						kontextMenu.close();
 						WindowEvent close = new WindowEvent();
-						close.target = mm;
+						close.target = mm; 
 						close.type = WindowEvent.CLOSE;
 						mm.postEvent(close);
 						CacheHolder newWP = new CacheHolder();
 						newWP.pos = mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y);
+						newWP.LatLon=newWP.pos.toString(); 
 						Global.mainTab.newWaypoint(newWP);
 					}
 



From pfeffer at mail.berlios.de  Fri Feb  9 03:11:16 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Fri, 9 Feb 2007 03:11:16 +0100
Subject: [Cachewolf-svn] r539 - trunk/src/CacheWolf
Message-ID: <200702090211.l192BGYj002411@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-09 03:11:15 +0100 (Fri, 09 Feb 2007)
New Revision: 539

Modified:
   trunk/src/CacheWolf/Map.java
   trunk/src/CacheWolf/MovingMap.java
Log:
(Patente, Urheberrechte)Bug fixed: MovingMap: NullPointerExpection, wenn die Liste mit Maps ge?\195?\182ffnet wurde (weil am aktuellen Standort keine Karte zur Verf?\195?\188gung steht) und vorher noch keine Karte gew?\195?\164hlt war. (Grund: die vorher benutzte Karte wird vorselektoiert)

Modified: trunk/src/CacheWolf/Map.java
===================================================================
--- trunk/src/CacheWolf/Map.java	2007-02-08 20:05:31 UTC (rev 538)
+++ trunk/src/CacheWolf/Map.java	2007-02-09 02:11:15 UTC (rev 539)
@@ -215,7 +215,7 @@
 		byte[] buf;
 		int len;
 		String[] parts;
-		filestemp = inDir.list("*.png", File.LIST_FILES_ONLY);
+		filestemp = inDir.list("*.png", File.LIST_FILES_ONLY); // TODO listmultiple verwenden
 		files = new Vector(filestemp);
 		filestemp = inDir.list("*.jpg", File.LIST_FILES_ONLY);
 		files.addAll(filestemp);

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-08 20:05:31 UTC (rev 538)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-09 02:11:15 UTC (rev 539)
@@ -1669,6 +1669,7 @@
 		boolean curMapFound = false;
 		boolean[] inList = new boolean[maps.size()];
 		int row = -1;
+		if (curMap == null) curMapFound = true;
 		if (gotopos != null && Gps != null) {
 			list.addItem("--- Karten von akt. Position und Ziel ---");
 			row++;
@@ -1680,7 +1681,7 @@
 					list.addItem(i + ": " + map.mapName);
 					row++;
 					inList[i] = true;
-					if (map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+					if (!curMapFound && map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
 				} else inList[i] = false;
 			}
 		}



From admin at berlios.de  Fri Feb  9 11:34:05 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 9 Feb 2007 01:34:05 -0900 (AKST)
Subject: [Cachewolf-svn] [Bug #9930] SpiderGC: <Enter> im Passworteingabe
Message-ID: <200702091034.l19AY5ie000198@unicorn.berlios.de>

Bug #9930, was updated on 2007-Jan-10 13:39
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: None
Bug Group: Ready to test
Priority: 1
Submitted by: pfeffer
Assigned to : cw-tester
Summary: SpiderGC: <Enter> im Passworteingabe

Details: beim SpiderGC <Enter> im Passworteingabe bewirkte abbruch, jetzt sind <enter> und <ESC> f?r die Richtigen Buttons aktiviert

Follow-Ups:

Date: 2007-Jan-22 03:25
By: cw-tester

Comment:
ist OK!!
-------------------------------------------------------

Date: 2007-Jan-10 14:45
By: pfeffer

Comment:
erledigt mit svn: 378
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9930&group_id=2211


From admin at berlios.de  Fri Feb  9 11:35:32 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 9 Feb 2007 01:35:32 -0900 (AKST)
Subject: [Cachewolf-svn] [Bug #9930] SpiderGC: <Enter> im Passworteingabe
Message-ID: <200702091035.l19AZWi3002460@unicorn.berlios.de>

Bug #9930, was updated on 2007-Jan-10 13:39
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: None
Bug Group: Ready to test
Priority: 1
Submitted by: pfeffer
Assigned to : pfeffer
Summary: SpiderGC: <Enter> im Passworteingabe

Details: beim SpiderGC <Enter> im Passworteingabe bewirkte abbruch, jetzt sind <enter> und <ESC> f?r die Richtigen Buttons aktiviert

Follow-Ups:

Date: 2007-Feb-09 01:35
By: cw-tester

Comment:
Bei <enter> wird ins n?chste Eingabefeld gesprungen. Ist das Absicht? Normalerweise sollte Anwenden ausgef?hrt werden
-------------------------------------------------------

Date: 2007-Jan-22 03:25
By: cw-tester

Comment:
ist OK!!
-------------------------------------------------------

Date: 2007-Jan-10 14:45
By: pfeffer

Comment:
erledigt mit svn: 378
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9930&group_id=2211


From admin at berlios.de  Fri Feb  9 11:36:35 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 9 Feb 2007 01:36:35 -0900 (AKST)
Subject: [Bug #9980] Kontextmenü Alle wählen/ alle abwählen
Message-ID: <200702091036.l19AaZhA003803@unicorn.berlios.de>

Bug #9980, was updated on 2007-Jan-14 10:00
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9m
Status: Open
Resolution: Fixed
Bug Group: Ready to test
Priority: 5
Submitted by: cw-tester
Assigned to : cw-tester
Summary: Kontextmen? Alle w?hlen/ alle abw?hlen

Details: wenn ich in der Listansicht eine Anzahl Caches mittels der suchenfunktion selektiert habe und dann ?ber das Kontextmen? 'alle w?hlen' anklicke werden alle Caches markiert. Auch die nicht mehr sichbaren. Wenn ich nun die markierten l?sche, sind alle weg. Ob das selbe Ergebnis auch f?r das vorherige Filtern gilt, kann ich erst sagen, wenn diese Funktion wieder geht.

Auf jeden Fall ist das ein unerw?nschtes Ergebnis. Alle Befehle sollten nur auf die in der Liste sichtbaren Caches angewendet werden.


Follow-Ups:

Date: 2007-Feb-09 01:36
By: cw-tester

Comment:
Funktioniert!!
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9980&group_id=2211


From admin at berlios.de  Fri Feb  9 11:41:48 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 9 Feb 2007 01:41:48 -0900 (AKST)
Subject: [Cachewolf-svn] [Bug #10090] Darstellung der gefundenen Caches
Message-ID: <200702091041.l19AfmZh010422@unicorn.berlios.de>

Bug #10090, was updated on 2007-Jan-22 03:45
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: Fixed
Bug Group: Ready to test
Priority: 5
Submitted by: cw-tester
Assigned to : cw-tester
Summary: Darstellung der gefundenen Caches

Details: Wenn ich eine GPX.Datei lade werden die gefundenen Caches gr?n dargestellt. Der Status ist aber leer. Erst wenn ich in Details gehe schaltet der Status auf gefunden.

Follow-Ups:

Date: 2007-Feb-09 01:41
By: cw-tester

Comment:
OK!!
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10090&group_id=2211


From admin at berlios.de  Fri Feb  9 13:28:02 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 9 Feb 2007 13:28:02 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #9930] SpiderGC: <Enter> im Passworteingabe
Message-ID: <200702091228.l19CS2PG012690@unicorn.berlios.de>

Bug #9930, was updated on 2007-Jan-10 23:39
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Closed
Resolution: None
Bug Group: Ready to test
Priority: 1
Submitted by: pfeffer
Assigned to : pfeffer
Summary: SpiderGC: <Enter> im Passworteingabe

Details: beim SpiderGC <Enter> im Passworteingabe bewirkte abbruch, jetzt sind <enter> und <ESC> f?r die Richtigen Buttons aktiviert

Follow-Ups:

Date: 2007-Feb-09 11:35
By: cw-tester

Comment:
Bei <enter> wird ins n?chste Eingabefeld gesprungen. Ist das Absicht? Normalerweise sollte Anwenden ausgef?hrt werden
-------------------------------------------------------

Date: 2007-Jan-22 13:25
By: cw-tester

Comment:
ist OK!!
-------------------------------------------------------

Date: 2007-Jan-11 00:45
By: pfeffer

Comment:
erledigt mit svn: 378
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9930&group_id=2211


From admin at berlios.de  Fri Feb  9 13:28:30 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 9 Feb 2007 13:28:30 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #10238] MovingMap: Distanzangabe ist kaum
	lesbar
Message-ID: <200702091228.l19CSU2h014247@unicorn.berlios.de>

Bug #10238, was updated on 2007-Feb-04 20:46
Here is a current snapshot of the bug.

Project: CacheWolf
Category: None
Status: Closed
Resolution: None
Bug Group: None
Priority: 1
Submitted by: mik77
Assigned to : mik77
Summary: MovingMap: Distanzangabe ist kaum lesbar

Details: Die Distanzangabe ist je nach dahinterligender Karte kaum zu lesen.

Follow-Ups:

Date: 2007-Feb-09 13:28
By: pfeffer

Comment:
funktioniert gut.
-------------------------------------------------------

Date: 2007-Feb-04 20:49
By: mik77

Comment:
Gefixt in Revision 508.
In die linke untere Ecke verschoben, verkleinert und auf hellen Hintergrund gelegt.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10238&group_id=2211


From admin at berlios.de  Fri Feb  9 13:29:08 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 9 Feb 2007 13:29:08 +0100 (CET)
Subject: [Bug #9980] Kontextmenü Alle wählen/ alle abwählen
Message-ID: <200702091229.l19CT81u016596@unicorn.berlios.de>

Bug #9980, was updated on 2007-Jan-14 20:00
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9m
Status: Closed
Resolution: Fixed
Bug Group: None
Priority: 5
Submitted by: cw-tester
Assigned to : cw-tester
Summary: Kontextmen? Alle w?hlen/ alle abw?hlen

Details: wenn ich in der Listansicht eine Anzahl Caches mittels der suchenfunktion selektiert habe und dann ?ber das Kontextmen? 'alle w?hlen' anklicke werden alle Caches markiert. Auch die nicht mehr sichbaren. Wenn ich nun die markierten l?sche, sind alle weg. Ob das selbe Ergebnis auch f?r das vorherige Filtern gilt, kann ich erst sagen, wenn diese Funktion wieder geht.

Auf jeden Fall ist das ein unerw?nschtes Ergebnis. Alle Befehle sollten nur auf die in der Liste sichtbaren Caches angewendet werden.


Follow-Ups:

Date: 2007-Feb-09 11:36
By: cw-tester

Comment:
Funktioniert!!
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9980&group_id=2211


From pfeffer at mail.berlios.de  Fri Feb  9 17:24:06 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Fri, 9 Feb 2007 17:24:06 +0100
Subject: [Cachewolf-svn] r540 - trunk/src/CacheWolf
Message-ID: <200702091624.l19GO6MW002607@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-09 17:24:01 +0100 (Fri, 09 Feb 2007)
New Revision: 540

Modified:
   trunk/src/CacheWolf/Map.java
Log:
MapImport/MovingMap: Nach MapImport sollte nun auch ohne Neustart und ohne erneute manuelle  Auswahl des Kartenverzeichnisses die neuen Karten geladen werden.

Modified: trunk/src/CacheWolf/Map.java
===================================================================
--- trunk/src/CacheWolf/Map.java	2007-02-09 02:11:15 UTC (rev 539)
+++ trunk/src/CacheWolf/Map.java	2007-02-09 16:24:01 UTC (rev 540)
@@ -351,6 +351,7 @@
 		Vm.showWait(this, false);
 		inf.addText("\ndone.");
 		//inf.addOkButton(); doesn't work
+		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
 		return Form.IDOK;
 	}
 
@@ -371,6 +372,7 @@
 					try {
 						retry = false;
 						wfl.saveWFL(mapsPath, thisMap);
+						if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
 					} catch (IOException e) {
 						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(321, "Error writing file ") + e.getMessage()+MyLocale.getMsg(324, " - retry?"), MessageBox.YESB | MessageBox.NOB);
 						if (tmpMB.execute() == MessageBox.IDYES) retry = true;



From salzkammergut at mail.berlios.de  Fri Feb  9 17:24:44 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Fri, 9 Feb 2007 17:24:44 +0100
Subject: [Cachewolf-svn] r541 - trunk/src/CacheWolf
Message-ID: <200702091624.l19GOiNV002685@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-09 17:24:39 +0100 (Fri, 09 Feb 2007)
New Revision: 541

Modified:
   trunk/src/CacheWolf/myTableControl.java
Log:
myTableControl: Bugfix. Beim Loeschen von Caches aus dem Kontextmenue wurde nur jeder zweite Cache geloescht


Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-02-09 16:24:01 UTC (rev 540)
+++ trunk/src/CacheWolf/myTableControl.java	2007-02-09 16:24:39 UTC (rev 541)
@@ -89,7 +89,7 @@
 					if(ch.is_Checked == true) {
 						dm.deleteCacheFiles(ch.wayPoint,profile.dataDir);
 						cacheDB.remove(ch);
-						i--;
+						i++;
 					}
 				}
 			tbp.refreshTable();



From salzkammergut at mail.berlios.de  Fri Feb  9 18:43:15 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Fri, 9 Feb 2007 18:43:15 +0100
Subject: [Cachewolf-svn] r542 - trunk/src/CacheWolf
Message-ID: <200702091743.l19HhFZ1001879@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-09 18:43:04 +0100 (Fri, 09 Feb 2007)
New Revision: 542

Modified:
   trunk/src/CacheWolf/StatusBar.java
Log:
StatusBar: Bugfix. Wenn nach einem leeren Profil ein Profil mit vielen Caches geoeffnet wurde,
wurde die Groesse des Statusfeldes nicht angepasst und es wurde von anderen Feldern ueberschrieben

Modified: trunk/src/CacheWolf/StatusBar.java
===================================================================
--- trunk/src/CacheWolf/StatusBar.java	2007-02-09 16:24:39 UTC (rev 541)
+++ trunk/src/CacheWolf/StatusBar.java	2007-02-09 17:43:04 UTC (rev 542)
@@ -40,6 +40,6 @@
 			strCenter="  \u00a4 " + pref.curCentrePt.toString();
 		
 		lblCenter.setText(strCenter);
-		repaint();
+		relayout(true); // in case the numbers increased and need more space
 	}
 }



From salzkammergut at mail.berlios.de  Fri Feb  9 19:21:04 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Fri, 9 Feb 2007 19:21:04 +0100
Subject: [Cachewolf-svn] r543 - trunk/src/CacheWolf
Message-ID: <200702091821.l19IL40j020172@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-09 19:21:00 +0100 (Fri, 09 Feb 2007)
New Revision: 543

Modified:
   trunk/src/CacheWolf/Preferences.java
Log:
Preferences: Bugfix NullPointerException bei nicht existierendem Basisverzeichnis
Zwei neue "log" Aufrufe zur verbesserten Analyse von Exceptions am PDA


Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-02-09 17:43:04 UTC (rev 542)
+++ trunk/src/CacheWolf/Preferences.java	2007-02-09 18:21:00 UTC (rev 543)
@@ -198,7 +198,7 @@
 	 */
 	public String getMapExpediaSavePath() {
 		String subdir = Global.getProfile().dataDir.substring(Global.getPref().baseDir.length());
-		String mapsDir = Global.getPref().baseDir + "/maps/expedia/" + subdir;
+		String mapsDir = Global.getPref().baseDir + "maps/expedia/" + subdir;
 		if (!(new File(mapsDir).isDirectory())) { // dir exists? 
 			if (new File(mapsDir).mkdirs() == false) // dir creation failed?
 			{(new MessageBox("Error", "Error: cannot create maps directory: \n"+new File(mapsDir).getParentFile(), MessageBox.OKB)).exec();
@@ -209,18 +209,10 @@
 	}
 
 	public String getMapExpediaLoadPath() {
-		return Global.getPref().baseDir + "/maps/expedia";
+		return Global.getPref().baseDir + "maps/expedia"; // baseDir has trailing /
 	}
 
 	/**
-	 * Returns true if coordinates have been set.
-	 * Does not validate! if coordinates are real.
-	 */
-	public boolean existCenter(){
-		return curCentrePt.latDec!=0.0 && curCentrePt.lonDec!=0.0; // TODO: use cusCentrePt.isValid() 
-	}
-
-	/**
 	 * Method to open and parse the pref.xml file. Results are stored in the
 	 * public variables of this class.
 	 */
@@ -233,9 +225,9 @@
 			r.close();
 		}catch(Exception e){
 			if (e instanceof NullPointerException)
-				Vm.debug("NullPointerException in Element "+lastName +". Wrong attribute?");
+				log("Error reading pref.xml: NullPointerException in Element "+lastName +". Wrong attribute?",e,true);
 			else 
-				Vm.debug(e.toString());
+				log("Error reading pref.xml: ", e);
 		}
 	}
 
@@ -248,12 +240,14 @@
 
 	public boolean selectProfile(Profile prof, int showProfileSelector, boolean hasNewButton) {
 		// If datadir is empty, ask for one
-		if (baseDir.length()==0) {
-			FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT,null);
-			fc.title = "Select base directory for cache data";
-			// If no base directory given, terminate
-			if (fc.execute() == FileChooser.IDCANCEL) ewe.sys.Vm.exit(0);
-			baseDir = fc.getChosenFile().toString();
+		if (baseDir.length()==0 || !(new File(baseDir)).exists()) {
+			do {
+				FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT,baseDir);
+				fc.title = "Select base directory for cache data";
+				// If no base directory given, terminate
+				if (fc.execute() == FileChooser.IDCANCEL) ewe.sys.Vm.exit(0);
+				baseDir = fc.getChosenFile().toString();
+			}while (!(new File(baseDir)).exists());
 		}
 		baseDir=baseDir.replace('\\','/');
 		if (!baseDir.endsWith("/")) baseDir+="/";
@@ -471,6 +465,7 @@
 		if (name.equals("solver")) {
 			solverIgnoreCase=Boolean.valueOf(atts.getValue("ignorevariablecase")).booleanValue();
 		}
+		if (name.equals("debug")) debug=Boolean.valueOf(atts.getValue("value")).booleanValue();
 	}
 
 	public void characters( char ch[], int start, int length )
@@ -551,18 +546,31 @@
 			outp.print("	<profile2 name = \""+profiles[1]+"\" lat = \""+ lats[1] +"\" lon = \""+ longs[1] +"\" dir = \""+ profdirs[1] +"\" lastsyncoc= \"" + lastSyncOC[1] + "\" lastdistoc= \"" + lastDistOC[1] + "\" />\n");
 			outp.print("	<profile3 name = \""+profiles[2]+"\" lat = \""+ lats[2] +"\" lon = \""+ longs[2] +"\" dir = \""+ profdirs[2] +"\" lastsyncoc= \"" + lastSyncOC[2] + "\" lastdistoc= \"" + lastDistOC[2] + "\" />\n");
 			outp.print("	<profile4 name = \""+profiles[3]+"\" lat = \""+ lats[3] +"\" lon = \""+ longs[3] +"\" dir = \""+ profdirs[3] +"\" lastsyncoc= \"" + lastSyncOC[3] + "\" lastdistoc= \"" + lastDistOC[3] + "\" />\n");
+			if (debug) outp.print("    <debug value=\"true\" />\n"); // Keep the debug switch if it is set
 			outp.print("</preferences>");
 			outp.close();
 		} catch (Exception e) {
-			Vm.debug("Problem saving: " +datei);
-			Vm.debug("Error: " +e.toString());
+			log("Problem saving: " +datei,e,true);
 		}
 	}
 
 	/**
+	 * Method to delete an existing log file. Called on every SpiderGC.
+	 * The log file is also cleared when Preferences is created and the filesize > 60KB
+	 */
+	public void logInit(){
+		File logFile = new File(LOGFILENAME);
+		logFile.delete();
+	}
+	
+	/**
 	 * Method to log messages to a file called log.txt
 	 * It will always append to an existing file.
-	 * @param text
+	 * To show the message on the console, the global variable debug must be set.
+	 * This can be done by adding
+	 * <pre><debug value="true"></pre>
+	 * to the pref.xml file
+	 * @param text to log
 	 */
 	public void log(String text){
 		Time dtm = new Time();
@@ -579,15 +587,39 @@
 		}finally{
 			strout.close();
 		}
+		if (debug) Vm.debug(text);
 	}
 
-	/**
-	 * Method to delete an existing log file. Something like a "reset".
-	 * Should be used "from time to time" to make sure the log file does not grow
-	 * to a huge size! Called on every SpiderGC
+	/** Log an exception to the log file with or without a stack trace
+	 * 
+	 * @param text Optional message (Can be empty string)
+	 * @param e The exception
+	 * @param withStackTrace If true and the debug switch is true, the stack trace is appended to the log
+	 * The debug switch can be set by including the line <i>&lt;debug value="true"&gt;&lt;/debug&gt;</i> in the pref.xml file
+	 * or by manually setting it (i.e. in BE versions or RC versions) by including the line
+	 * <pre>Global.getPref().debug=true;</pre>
+	 * in Version.getRelease()
 	 */
-	public void logInit(){
-		File logFile = new File(LOGFILENAME);
-		logFile.delete();
+	public void log(String text,Exception e, boolean withStackTrace) {
+		String msg;
+		if (text.equals("")) msg=text; else msg=text+"\n";
+		if (e!=null) {
+			if (withStackTrace && debug) 
+				msg+=ewe.sys.Vm.getAStackTrace(e);
+			else
+				msg+=e.toString();
+		}
+		log(msg);
 	}
+	
+	/** Log an exception to the log file without a stack trace, i.e.
+	 * where a stack trace is not needed because the location/cause of the error is clear 
+	 * 
+	 * @param message Optional message (Can be empty string)
+	 * @param e The exception
+	 */
+	public void log(String message,Exception e) {
+		log (message,e,false);
+	}
+		
 }



From salzkammergut at mail.berlios.de  Fri Feb  9 20:59:44 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Fri, 9 Feb 2007 20:59:44 +0100
Subject: [Cachewolf-svn] r544 - trunk/src/CacheWolf
Message-ID: <200702091959.l19Jxipp024774@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-09 20:59:32 +0100 (Fri, 09 Feb 2007)
New Revision: 544

Modified:
   trunk/src/CacheWolf/HintLogPanel.java
Log:
HintLogPanel: Bugfix: Cache GCP0T6 bewirkt einen Crash in der Ewe Vm im HtmlDisplay.
Genauere Analyse mu?\195?\159 noch durchgefuehrt werden, derzeit nur Schadensbegrenzung

Modified: trunk/src/CacheWolf/HintLogPanel.java
===================================================================
--- trunk/src/CacheWolf/HintLogPanel.java	2007-02-09 18:21:00 UTC (rev 543)
+++ trunk/src/CacheWolf/HintLogPanel.java	2007-02-09 19:59:32 UTC (rev 544)
@@ -87,7 +87,15 @@
 			htmlTxtImage.free();
 			}
 		logs.resizeTo(width, 50);
-		logs.setHtml(dummy.toString());
+		// The cache GCP0T6 crashes the HtmlDisplay
+		// As a temporary fix
+		try {
+			logs.setHtml(dummy.toString());
+		} catch (Exception e) {
+			logs=new HtmlDisplay();
+			Global.getPref().log("Error rendering HTML",e,true);
+			logs.setPlainText("Ewe VM: Internal error displaying logs");
+		}
 		int h = logs.getLineHeight() * logs.getNumLines();
 		htmlTxtImage = new AniImage(new Image(width, h));
 		htmlTxtImage.setLocation(0, 0);



From salzkammergut at mail.berlios.de  Fri Feb  9 21:17:24 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Fri, 9 Feb 2007 21:17:24 +0100
Subject: [Cachewolf-svn] r545 - in trunk: resources src/CacheWolf
Message-ID: <200702092017.l19KHO1s025774@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-09 21:17:21 +0100 (Fri, 09 Feb 2007)
New Revision: 545

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/CWPoint.java
Log:
CWPoint: Deutsche Meldung fuer "Not set"

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-02-09 19:59:32 UTC (rev 544)
+++ trunk/resources/cachewolf.Languages.cfg	2007-02-09 20:17:21 UTC (rev 545)
@@ -185,6 +185,7 @@
 		950=Transfer
 		951=Zu GPS %fcbertragen
 		952=Umwandeln ...
+		999=Nicht gesetzt
 		1000=D
 		1001=T
 		1002=Wegpunkt
@@ -238,6 +239,7 @@
 		1204=Hint & Logs
 		1205=L%f6ser
 		1206=Rechner
+		1207=%C6nderungen im Profil Speichern?
 		1300=Letzte Einstellung
 		1301=Profil ausw%e4hlen:
 		1400=Zone
@@ -509,6 +511,7 @@
 		950=Transfer
 		951=Sending to GPS
 		952=Converting...
+		999=Not set
 		1000=D
 		1001=T
 		1002=Waypoint
@@ -562,6 +565,7 @@
 		1204=Hint & Logs
 		1205=Solver
 		1206=Calc
+		1207=Your profile has unsaved changes. Do you want to save?
 		1300=Last Setting
 		1301=Select Profile:
 		1400=Zone

Modified: trunk/src/CacheWolf/CWPoint.java
===================================================================
--- trunk/src/CacheWolf/CWPoint.java	2007-02-09 19:59:32 UTC (rev 544)
+++ trunk/src/CacheWolf/CWPoint.java	2007-02-09 20:17:21 UTC (rev 545)
@@ -550,7 +550,7 @@
 	 * @return  string representation of CWPoint 
 	 */	
 	public String toString(int format){
-		if (!isValid()) return "not set";
+		if (!isValid()) return MyLocale.getMsg(999,"not set");
 		switch (format) {
 		case DD:	return getNSLetter() + " " + STRreplace.replace(getLatDeg(format),"-","") + "? "
 						+  getEWLetter() + " " + STRreplace.replace(getLonDeg(format),"-","")+ "?";



From salzkammergut at mail.berlios.de  Fri Feb  9 21:19:43 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Fri, 9 Feb 2007 21:19:43 +0100
Subject: [Cachewolf-svn] r546 - trunk/src/CacheWolf
Message-ID: <200702092019.l19KJhR8025877@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-09 21:19:35 +0100 (Fri, 09 Feb 2007)
New Revision: 546

Modified:
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/MainForm.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/ProfileDataForm.java
   trunk/src/CacheWolf/myTableControl.java
Log:
Filter: Bugfix. Wurde bei leerem Profil nicht richtig initialisiert
Bei Aenderungen am Profil kommt jetzt vor dem Beenden bzw. Laden eines neuen Profils eine Warnmeldung

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-02-09 20:17:21 UTC (rev 545)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-02-09 20:19:35 UTC (rev 546)
@@ -225,6 +225,7 @@
 	public void onEvent(Event ev){
 		if (ev instanceof DataChangeEvent ) {
 			dirty_details = true;
+			profile.hasUnsavedChanges=true;
 		}
 		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
 			if(ev.target == btnNotes){

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-02-09 20:17:21 UTC (rev 545)
+++ trunk/src/CacheWolf/MainForm.java	2007-02-09 20:19:35 UTC (rev 546)
@@ -36,6 +36,11 @@
 		if (pref.hasCloseButton) super.checkButtons();
 	} 
 
+	protected boolean canExit(int exitCode) {
+		mTab.saveUnsavedChanges(true);
+		return true;
+	}
+	
 	public void doIt(){
 		this.title = "CacheWolf " + Version.getRelease();
 		this.exitSystemOnClose = true;

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-02-09 20:17:21 UTC (rev 545)
+++ trunk/src/CacheWolf/MainMenu.java	2007-02-09 20:19:35 UTC (rev 546)
@@ -179,6 +179,7 @@
 		Preferences pref=Global.getPref();
 		Profile profile=Global.getProfile();
 		Vector cacheDB=profile.cacheDB;
+		Global.mainTab.updatePendingChanges();
 		if (ev instanceof MenuEvent){ //&& ev.type == MenuEvent.PRESSED
 			MenuEvent mev = (MenuEvent)ev;
 			if(mev.selectedItem == wolflang){
@@ -194,6 +195,7 @@
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
 			if(mev.selectedItem == mnuNewProfile){
+				Global.mainTab.saveUnsavedChanges(true);
 				NewProfileForm f=new NewProfileForm(pref.baseDir);
 			    int code=f.execute(getFrame(), Gui.CENTER_FRAME);
 				if (code==0) { 
@@ -208,7 +210,8 @@
 				f.close(0);
 			}
 			if(mev.selectedItem == mnuOpenProfile){
-				if (pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_FORCED_ON,false)) {
+					Global.mainTab.saveUnsavedChanges(true);
+					if (pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_FORCED_ON,false)) {
 					profile.cacheDB.clear();
 					tbp.setSelectedCache(-1);
 					profile.readIndex();
@@ -480,6 +483,7 @@
 				tbp.resetModel();
 			}
 			if(mev.selectedItem == exit){
+				Global.mainTab.saveUnsavedChanges(true);
 				ewe.sys.Vm.exit(0);
 			}
 			if(mev.selectedItem == sysinfo){

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-02-09 20:17:21 UTC (rev 545)
+++ trunk/src/CacheWolf/MainTab.java	2007-02-09 20:19:35 UTC (rev 546)
@@ -138,9 +138,7 @@
 //				Vm.setSIP(0);
 				MyLocale.setSIPOff();
 			}
-			if(detP.isDirty()) {
-				detP.saveDirtyWaypoint();
-			}
+			updatePendingChanges();
 			if(this.getSelectedItem() != 0){
 				if (tbP.getSelectedCache()>=cacheDB.size())
 					ch=null;
@@ -232,6 +230,32 @@
 */			//TODO what to do, if there is a map at centerTo, but it is not loaded because of mapSwitchMode == dest & cuurpos und daf?r gibt es keine Karte 
 		}
 	}
+	
+	/** Save any changes from DetailsPanel before operating on the database */
+	public void updatePendingChanges() {
+		if(detP.isDirty()) {
+			detP.saveDirtyWaypoint();
+		}
+	}
+	
+	/** Save the index file and any pending change in DetailsPanel
+	 * 
+	 * @param askForConfirmation If true, the save can be cancelled by user
+	 */
+	public void saveUnsavedChanges(boolean askForConfirmation) {
+		boolean saveIndex=!askForConfirmation; // Definitely save it if no confirmation needed
+		updatePendingChanges(); // Updated the cacheDB with pending changes from DetailsPanel
+		if (askForConfirmation) { // Don't know whether to save, have to ask
+			if (profile.hasUnsavedChanges &&     // Only ask if there were changes 
+				(new MessageBox(MyLocale.getMsg(144,"Warnung"),MyLocale.getMsg(1207,"Your profile has unsaved changes. Do you want to save?"),MessageBox.DEFOKB|MessageBox.NOB)).execute()==MessageBox.IDOK) {
+				saveIndex=true; 
+			}
+		}
+		if (saveIndex) profile.saveIndex(Global.getPref(),false);
+	}
+
+
+	
 }
 
 

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-02-09 20:17:21 UTC (rev 545)
+++ trunk/src/CacheWolf/Profile.java	2007-02-09 20:19:35 UTC (rev 546)
@@ -11,6 +11,7 @@
 import ewe.sys.LocalResource;
 import ewe.sys.Locale;
 import ewe.sys.Vm;
+import ewe.ui.*;
 import ewe.ui.ProgressBarForm;
 import ewe.util.Hashtable;
 import ewe.util.Vector;
@@ -51,12 +52,16 @@
 	public String filterSize = new String(FILTERSIZE);
 	//filter settings for archived ... owner (section) in filterscreen
 	public String filterVar = new String(FILTERVAR);
-	public String filterDist=new String("");
-	public String filterDiff=new String("");
-	public String filterTerr=new String("");
+	public String filterDist=new String("L");
+	public String filterDiff=new String("L");
+	public String filterTerr=new String("L");
 
 	public boolean selectionChanged = true; // ("H?ckchen") used by movingMap to get to knao if it should update the caches in the map 
-
+	/** True if the profile has been modified and not saved
+	 * The following modifications set this flag: New profile centre, Change of waypoint data 
+	 */
+	public boolean hasUnsavedChanges = false;
+	
 	//TODO Add other settings, such as max. number of logs to spider
 	//TODO Add settings for the preferred mapper to allow for maps other than expedia and other resolutions
 
@@ -74,6 +79,7 @@
 		dataDir="";  
 		last_sync_opencaching = "";
 		distOC = "";
+		hasUnsavedChanges=false;
 	}
 
 
@@ -150,10 +156,9 @@
 			detfile.close();
 			if(showprogress) pbf.exit(0);
 		}
+		hasUnsavedChanges=false;
 	}
 
-
-
 	/**
 	 *	Method to read the index.xml file that holds the total information
 	 *	on available caches in the database. The database in nothing else
@@ -255,6 +260,7 @@
 			e.printStackTrace();
 		}
 		normalizeFilters();
+		hasUnsavedChanges=false;
 	}
 
 	public int getCacheIndex(String wp){
@@ -370,8 +376,6 @@
 	public void buildReferences(){
 		CacheHolder ch, mainCh;
 		Hashtable dbIndex = new Hashtable((int)(cacheDB.size()/0.75f + 1), 0.75f); // initialize so that von rehashing is neccessary
-		Locale l = Vm.getLocale();
-		LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
 
 		Integer index;
 		// Build index for faster search and clear all references
@@ -404,7 +408,7 @@
 		for(int i =  0; i < max ;i++){
 			ch = (CacheHolder)cacheDB.get(i);
 			if (ch.hasAddiWpt() && (ch.addiWpts.size()> 1)){
-				ch.addiWpts.sort(new MyComparer((String)lr.get(1002,"Waypoint")), false);
+				ch.addiWpts.sort(new MyComparer(MyLocale.getMsg(1002,"Waypoint")), false);
 			}
 		}
 	

Modified: trunk/src/CacheWolf/ProfileDataForm.java
===================================================================
--- trunk/src/CacheWolf/ProfileDataForm.java	2007-02-09 20:17:21 UTC (rev 545)
+++ trunk/src/CacheWolf/ProfileDataForm.java	2007-02-09 20:19:35 UTC (rev 546)
@@ -75,11 +75,13 @@
 				if (cs.execute()== CoordsScreen.IDOK){
 					profile.centre.set(cs.getCoords());
 					btnProfileCentre.setText(profile.centre.toString());
+					profile.hasUnsavedChanges=true;
 				}
 			}
 			if (ev.target == btnCur2Prof){
 				profile.centre.set(pref.curCentrePt);
 				btnProfileCentre.setText(profile.centre.toString());
+				profile.hasUnsavedChanges=true;
 			}
 			if (ev.target == btnProf2Cur){
 				pref.curCentrePt.set(profile.centre);

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-02-09 20:17:21 UTC (rev 545)
+++ trunk/src/CacheWolf/myTableControl.java	2007-02-09 20:19:35 UTC (rev 546)
@@ -92,6 +92,7 @@
 						i++;
 					}
 				}
+			profile.hasUnsavedChanges=true;	
 			tbp.refreshTable();
 		}
 		
@@ -122,6 +123,7 @@
                             }
                     }
             }
+			profile.hasUnsavedChanges=true;	
             tbp.refreshTable();
             Vm.showWait(false);
 		}



From admin at berlios.de  Fri Feb  9 21:42:36 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 9 Feb 2007 21:42:36 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #10123] caches verwalten - move
Message-ID: <200702092042.l19KgaRW024142@unicorn.berlios.de>

Bug #10123, was updated on 2007-Jan-25 16:29
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: Fixed
Bug Group: None
Priority: 5
Submitted by: albsucher
Assigned to : salzkammergut
Summary: caches verwalten - move

Details: Evt. User-Error aber:
auf meinem PDA markiere ich caches inder Liste (vorne Haken rein), dann will ich sie verschieben. Dann scheint er noch was zu machen und dann kommt der mir schon unverst?ndliche Dialog "Weiter?" - danach ist Sense=Absturz!
Mach ich was verkehrt oder wie?
Was ich tun wilL: meine gefundenen und/oder eigenen Caches in ein eigenes (sogar vorher angelegtes) Verzeichnis verschieben. 

ich hoff ich hab mich da vest?ndlich genug ausgedr?ckt...

Follow-Ups:

Date: 2007-Feb-09 21:42
By: salzkammergut

Comment:
Erledigt
-------------------------------------------------------

Date: 2007-Feb-01 23:39
By: salzkammergut

Comment:
Kannst Du das mal mit der RC testen. Im Datamover war ein Bug, den habe ich schon vor ca. 1 Woche gefixt.
-------------------------------------------------------

Date: 2007-Jan-31 22:21
By: albsucher

Comment:
Nein, ich habe vorher nichts gefiltert.
meien Absicht war, die von mir gefundenen caches in ein anderes Verzeichnis zu verschieben. dazu hab ich in der Listenansicht einfach mal ein paar markiert und wollte einen move machen...
-------------------------------------------------------

Date: 2007-Jan-31 21:07
By: kalli

Comment:
Hast Du die Liste nach dem Markieren gefiltert? Das Verschieben wirkt auf alle angezeigten Caches!

Der Dialog, den Du siehst, ist die Sicherheitsabfrage. Vielleicht gibts auf dem PDA ein Problem mit der Menge der Caches beim Verschieben, mit Massendaten habe ich das auf dem PDA noch nicht getestet.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10123&group_id=2211


From admin at berlios.de  Fri Feb  9 21:43:13 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 9 Feb 2007 21:43:13 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #10123] caches verwalten - move
Message-ID: <200702092043.l19KhDhr024966@unicorn.berlios.de>

Bug #10123, was updated on 2007-Jan-25 16:29
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Open
Resolution: Fixed
Bug Group: None
Priority: 5
Submitted by: albsucher
Assigned to : salzkammergut
Summary: caches verwalten - move

Details: Evt. User-Error aber:
auf meinem PDA markiere ich caches inder Liste (vorne Haken rein), dann will ich sie verschieben. Dann scheint er noch was zu machen und dann kommt der mir schon unverst?ndliche Dialog "Weiter?" - danach ist Sense=Absturz!
Mach ich was verkehrt oder wie?
Was ich tun wilL: meine gefundenen und/oder eigenen Caches in ein eigenes (sogar vorher angelegtes) Verzeichnis verschieben. 

ich hoff ich hab mich da vest?ndlich genug ausgedr?ckt...

Follow-Ups:

Date: 2007-Feb-09 21:43
By: salzkammergut

Comment:
Erledigt
-------------------------------------------------------

Date: 2007-Feb-09 21:42
By: salzkammergut

Comment:
Erledigt
-------------------------------------------------------

Date: 2007-Feb-01 23:39
By: salzkammergut

Comment:
Kannst Du das mal mit der RC testen. Im Datamover war ein Bug, den habe ich schon vor ca. 1 Woche gefixt.
-------------------------------------------------------

Date: 2007-Jan-31 22:21
By: albsucher

Comment:
Nein, ich habe vorher nichts gefiltert.
meien Absicht war, die von mir gefundenen caches in ein anderes Verzeichnis zu verschieben. dazu hab ich in der Listenansicht einfach mal ein paar markiert und wollte einen move machen...
-------------------------------------------------------

Date: 2007-Jan-31 21:07
By: kalli

Comment:
Hast Du die Liste nach dem Markieren gefiltert? Das Verschieben wirkt auf alle angezeigten Caches!

Der Dialog, den Du siehst, ist die Sicherheitsabfrage. Vielleicht gibts auf dem PDA ein Problem mit der Menge der Caches beim Verschieben, mit Massendaten habe ich das auf dem PDA noch nicht getestet.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10123&group_id=2211


From admin at berlios.de  Fri Feb  9 21:44:14 2007
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 9 Feb 2007 21:44:14 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #10123] caches verwalten - move
Message-ID: <200702092044.l19KiEGo026039@unicorn.berlios.de>

Bug #10123, was updated on 2007-Jan-25 16:29
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Closed
Resolution: Fixed
Bug Group: None
Priority: 5
Submitted by: albsucher
Assigned to : salzkammergut
Summary: caches verwalten - move

Details: Evt. User-Error aber:
auf meinem PDA markiere ich caches inder Liste (vorne Haken rein), dann will ich sie verschieben. Dann scheint er noch was zu machen und dann kommt der mir schon unverst?ndliche Dialog "Weiter?" - danach ist Sense=Absturz!
Mach ich was verkehrt oder wie?
Was ich tun wilL: meine gefundenen und/oder eigenen Caches in ein eigenes (sogar vorher angelegtes) Verzeichnis verschieben. 

ich hoff ich hab mich da vest?ndlich genug ausgedr?ckt...

Follow-Ups:

Date: 2007-Feb-09 21:43
By: salzkammergut

Comment:
Erledigt
-------------------------------------------------------

Date: 2007-Feb-09 21:42
By: salzkammergut

Comment:
Erledigt
-------------------------------------------------------

Date: 2007-Feb-01 23:39
By: salzkammergut

Comment:
Kannst Du das mal mit der RC testen. Im Datamover war ein Bug, den habe ich schon vor ca. 1 Woche gefixt.
-------------------------------------------------------

Date: 2007-Jan-31 22:21
By: albsucher

Comment:
Nein, ich habe vorher nichts gefiltert.
meien Absicht war, die von mir gefundenen caches in ein anderes Verzeichnis zu verschieben. dazu hab ich in der Listenansicht einfach mal ein paar markiert und wollte einen move machen...
-------------------------------------------------------

Date: 2007-Jan-31 21:07
By: kalli

Comment:
Hast Du die Liste nach dem Markieren gefiltert? Das Verschieben wirkt auf alle angezeigten Caches!

Der Dialog, den Du siehst, ist die Sicherheitsabfrage. Vielleicht gibts auf dem PDA ein Problem mit der Menge der Caches beim Verschieben, mit Massendaten habe ich das auf dem PDA noch nicht getestet.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10123&group_id=2211


From admin at berlios.de  Sat Feb 10 16:06:18 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sat, 10 Feb 2007 16:06:18 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #9836] Koordinaten beim Spidern von addi wpts
Message-ID: <200702101506.l1AF6Ilg012249@unicorn.berlios.de>

Bug #9836, was updated on 2006-Dec-28 18:50
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Closed
Resolution: Fixed
Bug Group: Ready to test
Priority: 5
Submitted by: kalli
Assigned to : albsucher
Summary: Koordinaten beim Spidern von addi wpts

Details: siehe http://www.geoclub.de/ftopic13172.html.


Follow-Ups:

Date: 2007-Jan-10 23:35
By: pfeffer

Comment:
bei mir gibt's bei GCMZE (hat 1 addiWP) beim ersten spidern keine Probleme. Wenn ich aber per rechtsklickt auf dem Haupt WP aktualisiere, kommt:
----
java.lang.NullPointerException
	at CacheWolf.SpiderGC.spiderSingle(SpiderGC.java:155)
---
Gru?,
   Pfeffer.
-------------------------------------------------------

Date: 2006-Dec-28 19:50
By: kalli

Comment:
Kann nur durch Spidern getestet werden. Da Albsucher die addi wpts so liebt, habe ich es mal ihm zum Testen zugewiesen :-)
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9836&group_id=2211


From admin at berlios.de  Sat Feb 10 16:06:48 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sat, 10 Feb 2007 16:06:48 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #9809] Cachetyp Mega-Event fehlt
Message-ID: <200702101506.l1AF6mCn012826@unicorn.berlios.de>

Bug #9809, was updated on 2006-Dec-23 08:32
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Closed
Resolution: Fixed
Bug Group: Ready to test
Priority: 5
Submitted by: kalli
Assigned to : none
Summary: Cachetyp Mega-Event fehlt

Details: siehe http://www.geoclub.de/ftopic13095.html

Follow-Ups:

Date: 2006-Dec-24 08:33
By: kalli

Comment:
Getestet mit GCZQ0V
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9809&group_id=2211


From admin at berlios.de  Sat Feb 10 16:07:16 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sat, 10 Feb 2007 16:07:16 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #10090] Darstellung der gefundenen Caches
Message-ID: <200702101507.l1AF7G3v013498@unicorn.berlios.de>

Bug #10090, was updated on 2007-Jan-22 13:45
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9n
Status: Closed
Resolution: Fixed
Bug Group: Ready to test
Priority: 5
Submitted by: cw-tester
Assigned to : cw-tester
Summary: Darstellung der gefundenen Caches

Details: Wenn ich eine GPX.Datei lade werden die gefundenen Caches gr?n dargestellt. Der Status ist aber leer. Erst wenn ich in Details gehe schaltet der Status auf gefunden.

Follow-Ups:

Date: 2007-Feb-09 11:41
By: cw-tester

Comment:
OK!!
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=10090&group_id=2211


From admin at berlios.de  Sat Feb 10 16:07:53 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sat, 10 Feb 2007 16:07:53 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #9753] cachenamen
Message-ID: <200702101507.l1AF7rvA014353@unicorn.berlios.de>

Bug #9753, was updated on 2006-Dec-17 22:21
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9m
Status: Closed
Resolution: Fixed
Bug Group: Ready to test
Priority: 5
Submitted by: greiol
Assigned to : none
Summary: cachenamen

Details: cw erkennt beim import eines caches nicht, wenn sich der cachename ge?ndert hat.

Follow-Ups:

Date: 2006-Dec-23 08:31
By: kalli

Comment:
Ist erledigt, habs mit einer modifizierten GPX-Datei getestet.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9753&group_id=2211


From pfeffer at mail.berlios.de  Sat Feb 10 16:25:18 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sat, 10 Feb 2007 16:25:18 +0100
Subject: [Cachewolf-svn] r547 - trunk/src/CacheWolf
Message-ID: <200702101525.l1AFPICC019169@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-10 16:25:16 +0100 (Sat, 10 Feb 2007)
New Revision: 547

Modified:
   trunk/src/CacheWolf/GPXImporter.java
Log:
ImportGPX: Warnmeldung, wenn versucht wird, mit GPX von Opencaching Bilder heruterzuladen

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2007-02-09 20:19:35 UTC (rev 546)
+++ trunk/src/CacheWolf/GPXImporter.java	2007-02-10 15:25:16 UTC (rev 547)
@@ -5,6 +5,7 @@
 import ewe.io.*;
 import ewe.sys.*;
 import ewe.sys.Double;
+import ewe.ui.MessageBox;
 import ewe.util.*;
 import ewe.net.*;
 import ewe.util.zip.*;
@@ -149,6 +150,7 @@
 			// check for opencaching
 			if (atts.getValue("creator").indexOf("opencaching")> 0) fromOC = true;
 			else fromOC = false;
+			if (fromOC && doSpider) (new MessageBox("Warnung", "GPX-Dateien von Opencaching enthalten keine Informationen zu Bildern, sie werden nicht heruntergeladen. Am besten Caches von Opencaching holen per Men? /Anwendung/Download von Opencaching", MessageBox.OKB)).execute();
 			zaehlerGel = 0;
 		}
 		if (name.equals("wpt")) {
@@ -274,7 +276,7 @@
 							if(getMaps){
 								ParseLatLon pll = new ParseLatLon(holder.LatLon,".");
 								pll.parse();
-								MapLoader mpl = new MapLoader(pref.myproxy, pref.myproxyport);
+								//MapLoader mpl = new MapLoader(pref.myproxy, pref.myproxyport);
 								//mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map.gif", "3");
 								//mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map_2.gif", "10");
 							}



From mik77 at mail.berlios.de  Sat Feb 10 17:55:42 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sat, 10 Feb 2007 17:55:42 +0100
Subject: [Cachewolf-svn] r548 - trunk/src/CacheWolf
Message-ID: <200702101655.l1AGtg6Q022793@sheep.berlios.de>

Author: mik77
Date: 2007-02-10 17:55:38 +0100 (Sat, 10 Feb 2007)
New Revision: 548

Modified:
   trunk/src/CacheWolf/MovingMap.java
Log:
Map-Update wieder nur, wenn sich die Karte bewegt.

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-10 15:25:16 UTC (rev 547)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-10 16:55:38 UTC (rev 548)
@@ -62,6 +62,9 @@
 	boolean noMapsAvailable;
 	boolean zoomingMode = false;
 	boolean mapsloaded = false;
+	
+	Point lastRepaintMapPos = null;
+	double lastDistance = -1;
 
 	public MovingMap(Navigate nav, Vector cacheDB){
 		this.cacheDB = cacheDB;
@@ -120,9 +123,11 @@
 		mapsloaded = false;
 		posCircleLat = -361;
 		posCircleLon = -361; // make them invalid
-		updateDistance(); // fill Rect with transparent color
+		//updateDistance(); // fill Rect with transparent color
 		scaleWanted = 1;
 		mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
+		
+		lastRepaintMapPos = new Point(pref.myAppWidth +1, pref.myAppHeight +1);
 	}
 
 	public void resizeTo(int w,int h) {
@@ -212,37 +217,54 @@
 		ScaleImageGraphics.drawImage(ScaleImage.image,null,Color.White,0,0,ScaleImage.location.width,ScaleImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
 	}
 	
-	public void updateDistance() {
+	public void updateDistance(boolean repaint) {
 		DistanceImageGraphics.setColor(DistanceImage.transparentColor);
 		DistanceImageGraphics.fillRect(0, 0, DistanceImage.location.width,DistanceImage.location.height);
 		if (gotoPos != null && posCircleLat >= -360)
 		{
-			ewe.sys.Double dd = new ewe.sys.Double();
-			dd.set((new CWPoint(gotoPos.lat, gotoPos.lon).getDistance(posCircleLat, posCircleLon)));
-			String d;
-			int backgroundWidth = DistanceImage.location.width;
-			if (dd.value < 1) {
-				dd.value = dd.value * 1000; 
-				dd.decimalPlaces = 0;
-				d = "Dist: " + dd.toString() + "m";
-				int digits = (int)java.lang.Math.floor( java.lang.Math.log(dd.value) / java.lang.Math.log(10.0) );
-				backgroundWidth = 6 * (digits + 1) + 36;
+			double currentDistance = (new CWPoint(gotoPos.lat, gotoPos.lon).getDistance(posCircleLat, posCircleLon));
+			if (currentDistance != lastDistance)
+			{
+				lastDistance = currentDistance;
+				ewe.sys.Double dd = new ewe.sys.Double();
+				dd.set(currentDistance);
+				String d;
+				int backgroundWidth = DistanceImage.location.width;
+				if (dd.value < 1) {
+					dd.value = dd.value * 1000; 
+					dd.decimalPlaces = 0;
+					d = "Dist: " + dd.toString() + "m";
+					int digits = (int)java.lang.Math.floor( java.lang.Math.log(dd.value) / java.lang.Math.log(10.0) );
+					digits = java.lang.Math.max(0, digits);
+					backgroundWidth = 6 * (digits + 1) + 36;
 				} 
-			else {
-				dd.decimalPlaces = 2;
-				d = "Dist: " + dd.toString() + "km";
-				int digits = (int)java.lang.Math.floor( java.lang.Math.log(dd.value) / java.lang.Math.log(10.0) );
-				backgroundWidth = 6 * (digits + 3) + 45;
+				else {
+					dd.decimalPlaces = 2;
+					d = "Dist: " + dd.toString() + "km";
+					int digits = (int)java.lang.Math.floor( java.lang.Math.log(dd.value) / java.lang.Math.log(10.0) );
+					digits = java.lang.Math.max(0, digits);
+					backgroundWidth = 6 * (digits + 3) + 45;
+				}
+
+				DistanceImageGraphics.setColor(new Color(250,250,250));
+				DistanceImageGraphics.fillRect(0, 0, backgroundWidth ,DistanceImage.location.height);
+
+				DistanceImageGraphics.setColor(Color.DarkBlue);
+				DistanceImageGraphics.drawText(d, 2, 0);
+				
+				DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.LightBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+				DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.White,0,0,DistanceImage.location.width,DistanceImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
+				if (repaint)
+				{
+					DistanceImage.refreshNow();
+				}
 			}
-			
-			DistanceImageGraphics.setColor(new Color(250,250,250));
-			DistanceImageGraphics.fillRect(0, 0, backgroundWidth ,DistanceImage.location.height);
-
-			DistanceImageGraphics.setColor(Color.DarkBlue);
-			DistanceImageGraphics.drawText(d, 2, 0);
 		}
-		DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.LightBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
-		DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.White,0,0,DistanceImage.location.width,DistanceImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
+		else
+		{
+			DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.LightBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+			DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.White,0,0,DistanceImage.location.width,DistanceImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
+		}
 	}
 
 	public void forceMapLoad() {
@@ -710,7 +732,7 @@
 		removeGotoPosition();
 		if (d == null || !d.isValid() ) return;
 		gotoPos = addSymbol("goto", "goto_map.png", d.latDec, d.lonDec);
-		updateDistance();
+		//updateDistance();
 		forceMapLoad = true;
 		updatePosition(posCircleLat, posCircleLon);
 	}
@@ -781,14 +803,19 @@
 		Point mapPos = getMapPositionOnScreen();
 		//Vm.debug("mapx = " + mapx);
 		//Vm.debug("mapy = " + mapy);
-		//if (forceMapLoad || (java.lang.Math.abs(oldMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(oldMapPos.y - mapPos.y) > 1)) { // TODO make the speed improvement work: this if doesn't work in case of a series of changes less than 1 px 
-		if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x, mapPos.y);
-		updateSymbolPositions();
-		updateDistance();
-		if (updateOverlay ) updateOverlayPos(); // && TrackOverlays != null
-		//}
-		mmp.repaintNow(); 
-		//}
+		if (forceMapLoad || (java.lang.Math.abs(lastRepaintMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(lastRepaintMapPos.y - mapPos.y) > 1)) 
+		{
+			lastRepaintMapPos = mapPos;
+			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x, mapPos.y);
+			updateSymbolPositions();
+			updateDistance(false);
+			if (updateOverlay ) updateOverlayPos(); // && TrackOverlays != null
+			mmp.repaintNow(); 
+		}
+		else
+		{
+			updateDistance(true);
+		}
 		//Vm.debug("update only position");			
 	}
 	/**
@@ -826,7 +853,8 @@
 		if (!running || ignoreGps) return;
 		// runMovingMap neccessary in case of multi-threaded Java-VM: ticked could be called during load of mmp 
 		if ((fix > 0) && (myNavigation.gpsPos.getSats()>= 0)) { // TODO is getSats really necessary?
-			directionArrows.setDirections(-361 /*(float)bearWayP.value*/, myNavigation.sunAzimut, -361 /*(float)bearMov.value*/);
+			directionArrows.setDirections(-361/*(float)myNavigation.gpsPos.getBearing(myNavigation.destination)*/,
+					myNavigation.sunAzimut, -361/*(float)myNavigation.gpsPos.getBear()*/);
 			setGpsStatus(MovingMap.gotFix);
 			updatePosition(myNavigation.gpsPos.latDec, myNavigation.gpsPos.lonDec);
 			ShowLastAddedPoint(myNavigation.curTrack);



From mik77 at mail.berlios.de  Sat Feb 10 18:37:49 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sat, 10 Feb 2007 18:37:49 +0100
Subject: [Cachewolf-svn] r549 - trunk/resources
Message-ID: <200702101737.l1AHbnOK012255@sheep.berlios.de>

Author: mik77
Date: 2007-02-10 18:37:41 +0100 (Sat, 10 Feb 2007)
New Revision: 549

Modified:
   trunk/resources/mark_cache.png
Log:
Markierung vergr?\195?\182?\195?\159ert, so dass sie um die cachesymbole passt.

Modified: trunk/resources/mark_cache.png
===================================================================
(Binary files differ)



From pfeffer at mail.berlios.de  Sat Feb 10 18:42:28 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sat, 10 Feb 2007 18:42:28 +0100
Subject: [Cachewolf-svn] r550 - trunk/src/CacheWolf
Message-ID: <200702101742.l1AHgS0d019634@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-10 18:42:09 +0100 (Sat, 10 Feb 2007)
New Revision: 550

Modified:
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/MapsList.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/Navigate.java
Log:
MovingMap: Bug fixed: Es gab beim Aufruf der MovingMap eine NullPointerException, wenn GPS lief, aber keine Karte f?\195?\188r die aktuelle Position zurverf?\195?\188gungs steht
MovingMap: Bug fixed: Wenn GPS lief, bevor MovingMap gestartet wurde, wurde GPS-Pos erst angeziebt nach Druck auf "snapToGps"
MovingMap: zus?\195?\164tzliche Debugausgabe f?\195?\188r Problem von Moorteufel

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-02-10 17:37:41 UTC (rev 549)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-02-10 17:42:09 UTC (rev 550)
@@ -235,7 +235,7 @@
 		//update distance
 		Double tmp = new Double();
 		if (myNavigation.gpsPos.isValid() && myNavigation.destination.isValid() ) {
-			tmp.set(myNavigation.gpsPos.getDistance(myNavigation.destination));
+			tmp.set(myNavigation.gpsPos.getDistance(myNavigation.destination)); // TODO distance in navigate.java berechnen
 			if (tmp.value >= 1){
 				lblDist.setText(MyLocale.formatDouble(tmp,"0.000")+ " km");
 			}

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-02-10 17:37:41 UTC (rev 549)
+++ trunk/src/CacheWolf/MainTab.java	2007-02-10 17:42:09 UTC (rev 550)
@@ -214,6 +214,7 @@
 		if (mm == null) {
 			mm = new MovingMap(nav, profile.cacheDB);
 			nav.setMovingMap(mm);
+			if (nav.gpsRunning) mm.gpsStarted();
 		} 
 		if (forceCenter) mm.setGpsStatus(MovingMap.noGPS); // disconnect movingMap from GPS TODO only if GPS-pos is not on the screen
 		mm.updatePosition(centerTo.latDec, centerTo.lonDec);

Modified: trunk/src/CacheWolf/MapsList.java
===================================================================
--- trunk/src/CacheWolf/MapsList.java	2007-02-10 17:37:41 UTC (rev 549)
+++ trunk/src/CacheWolf/MapsList.java	2007-02-10 17:42:09 UTC (rev 550)
@@ -37,6 +37,7 @@
 		MessageBox f = null;
 		for (int j = dirs.size()-1; j >= 0; j--) {
 			files = new File(mapsPath+"/"+dirs.get(j));
+			ewe.sys.Vm.debug("mapd-Dirs:"+files);
 			dateien = files.list("*.wfl", File.LIST_FILES_ONLY);
 			for(int i = 0; i < dateien.length;i++){
 				rawFileName = dateien[i].substring(0, dateien[i].lastIndexOf("."));

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-10 17:37:41 UTC (rev 549)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-10 17:42:09 UTC (rev 550)
@@ -865,6 +865,7 @@
 	
 	public void gpsStarted() {
 		addTrack(myNavigation.curTrack);
+		ignoreGps = false;
 	}
 	public void gpsStoped() {
 		setGpsStatus(MovingMap.noGPS);
@@ -1719,7 +1720,6 @@
 			for(int i = 0; i<maps.size();i++){
 				map = new MapInfoObject();
 				map = (MapInfoObject)maps.get(i);
-				if (map.mapName.equals(curMap.mapName)) oldmap = i;
 				if (map.inBound(Gps.latDec, Gps.lonDec) == true) 
 				{
 					list.addItem(i + ": " + map.mapName);

Modified: trunk/src/CacheWolf/Navigate.java
===================================================================
--- trunk/src/CacheWolf/Navigate.java	2007-02-10 17:37:41 UTC (rev 549)
+++ trunk/src/CacheWolf/Navigate.java	2007-02-10 17:42:09 UTC (rev 550)
@@ -22,6 +22,7 @@
 	public SerialThread serThread = null;
 	public Preferences pref = Global.getPref();
 	public UpdateThread tickerThread;
+	public boolean gpsRunning = false;
 	boolean lograw = false;
 	int logIntervall = 10;
 
@@ -33,7 +34,7 @@
 	}
 
 	public void startGps() {
-		if (serThread != null) if (serThread.isAlive()) return;
+		if (serThread != null) if (serThread.isAlive()) return; // TODO use gpsRunning
 		try {
 			serThread = new SerialThread(pref.mySPO, gpsPos, (pref.forwardGPS ? pref.forwardGpsHost : ""));
 			if (pref.forwardGPS && !serThread.tcpForward) {
@@ -45,6 +46,7 @@
 			}
 			serThread.start();
 			startDisplayTimer();
+			gpsRunning = true;
 			curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
 			if (lograw)	gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
 			if (gotoPanel != null) gotoPanel.gpsStarted();
@@ -71,6 +73,7 @@
 		serThread.stop();
 		stopDisplayTimer();
 		gpsPos.stopLog();
+		gpsRunning = false;
 		if (gotoPanel != null) gotoPanel.gpsStoped();
 		if (movingMap != null) movingMap.gpsStoped();
 	}



From pfeffer at mail.berlios.de  Sat Feb 10 18:50:30 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sat, 10 Feb 2007 18:50:30 +0100
Subject: [Cachewolf-svn] r551 - trunk/src/CacheWolf
Message-ID: <200702101750.l1AHoUHN029696@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-10 18:50:26 +0100 (Sat, 10 Feb 2007)
New Revision: 551

Modified:
   trunk/src/CacheWolf/TrackOverlay.java
Log:
MovingMap: hellblaue Linien, die zu Debug-zwecken da waren, entfernt

Modified: trunk/src/CacheWolf/TrackOverlay.java
===================================================================
--- trunk/src/CacheWolf/TrackOverlay.java	2007-02-10 17:42:09 UTC (rev 550)
+++ trunk/src/CacheWolf/TrackOverlay.java	2007-02-10 17:50:26 UTC (rev 551)
@@ -40,8 +40,9 @@
 
 	
 	public void paintTracks() {
-		draw.setPen(new Pen(Color.LightBlue,Pen.SOLID,1));
-		draw.fillRect(1, 1, image.getWidth()-1, image.getHeight()-1);
+	// for debugging TrackOverlayPositions
+	// draw.setPen(new Pen(Color.LightBlue,Pen.SOLID,1));
+	//	draw.fillRect(1, 1, image.getWidth()-1, image.getHeight()-1);
 		if (tracks == null || tracks.size() == 0) return;
 		int tri, i;
 		Track tr;



From salzkammergut at mail.berlios.de  Sun Feb 11 12:07:17 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 11 Feb 2007 12:07:17 +0100
Subject: [Cachewolf-svn] r552 - trunk/src/CacheWolf
Message-ID: <200702111107.l1BB7Ht5003501@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-11 12:07:12 +0100 (Sun, 11 Feb 2007)
New Revision: 552

Modified:
   trunk/src/CacheWolf/myTableControl.java
Log:
myTableControl: Bug beim L?\195?\182schen von markierten Caches behoben

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-02-10 17:50:26 UTC (rev 551)
+++ trunk/src/CacheWolf/myTableControl.java	2007-02-11 11:07:12 UTC (rev 552)
@@ -89,10 +89,9 @@
 					if(ch.is_Checked == true) {
 						dm.deleteCacheFiles(ch.wayPoint,profile.dataDir);
 						cacheDB.remove(ch);
-						i++;
 					}
 				}
-			profile.hasUnsavedChanges=true;	
+			profile.saveIndex(pref,true);	
 			tbp.refreshTable();
 		}
 		



From pfeffer at mail.berlios.de  Sun Feb 11 12:21:09 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 11 Feb 2007 12:21:09 +0100
Subject: [Cachewolf-svn] r553 - trunk/resources
Message-ID: <200702111121.l1BBL9w6003926@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-11 12:21:07 +0100 (Sun, 11 Feb 2007)
New Revision: 553

Modified:
   trunk/resources/cachewolf.Languages.cfg
Log:
Groesses ?\195?\156 zu kleinem gemacht in Pr?\195?\164ferenzen

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-02-11 11:07:12 UTC (rev 552)
+++ trunk/resources/cachewolf.Languages.cfg	2007-02-11 11:21:07 UTC (rev 553)
@@ -41,7 +41,7 @@
 		145=Cachedaten ALLER ANGEZEIGTEN Caches werden gel%f6scht!  Weiter? 
 		146=Cachedaten ALLER ANGEZEIGTEN Caches werden kopiert!  Weiter? 
 		147=Cachedaten ALLER ANGEZEIGTEN Caches werden verschoben!  Weiter? 
-		148=Zielverzeichnis waehlen 
+		148=Zielverzeichnis w%e4hlen 
 		149=Karten
 		150=Importieren
 		151=Kalibrieren
@@ -101,7 +101,7 @@
 		600=Pr%e4ferenzen
 		601=Dein Alias:
 		602=Heimatkoordinaten:
-		603=Verzeichnis f%dcr Profile
+		603=Verzeichnis f%fcr Profile
 		604=Suchen
 		605=Tabellenspalten:
 		606=Schwierigkeit



From salzkammergut at mail.berlios.de  Sun Feb 11 12:49:59 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 11 Feb 2007 12:49:59 +0100
Subject: [Cachewolf-svn] r554 - trunk/src/CacheWolf
Message-ID: <200702111149.l1BBnx5H009258@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-11 12:49:50 +0100 (Sun, 11 Feb 2007)
New Revision: 554

Modified:
   trunk/src/CacheWolf/DataMover.java
Log:
DataMover: Bugfix bei Bearbeitung von Blacklist Caches

Modified: trunk/src/CacheWolf/DataMover.java
===================================================================
--- trunk/src/CacheWolf/DataMover.java	2007-02-11 11:21:07 UTC (rev 553)
+++ trunk/src/CacheWolf/DataMover.java	2007-02-11 11:49:50 UTC (rev 554)
@@ -32,7 +32,7 @@
 		// Loop through database
 		for(int i = 0; i<srcDB.size(); i++){
 			CacheHolder srcHolder=(CacheHolder)srcDB.get(i);
-			if(srcHolder.isVisible()){
+			if(srcHolder.is_filtered==false){
 				deleteCacheFiles(srcHolder.wayPoint, profile.dataDir);
 				srcDB.removeElementAt(i);
 				i--;
@@ -68,7 +68,7 @@
 		// Loop through database
 		for(int i = 0; i<srcDB.size(); i++){
 			CacheHolder srcHolder=(CacheHolder)srcDB.get(i);
-			if(srcHolder.isVisible()){
+			if(srcHolder.is_filtered==false){
 				// does cache exists in destDB ?
 				dstPos = dstProfile.getCacheIndex(srcHolder.wayPoint);
 				if (dstPos >= 0){
@@ -114,7 +114,7 @@
 		// Loop through database
 		for(int i = 0; i<srcDB.size(); i++){
 			CacheHolder srcHolder=(CacheHolder)srcDB.get(i);
-			if(srcHolder.isVisible()){
+			if(srcHolder.is_filtered==false){
 				// does cache exists in destDB ?
 				dstPos = dstProfile.getCacheIndex(srcHolder.wayPoint);
 				if (dstPos >= 0){



From salzkammergut at mail.berlios.de  Sun Feb 11 13:03:01 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 11 Feb 2007 13:03:01 +0100
Subject: [Cachewolf-svn] r555 - trunk/src/CacheWolf
Message-ID: <200702111203.l1BC31bl026139@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-11 13:02:51 +0100 (Sun, 11 Feb 2007)
New Revision: 555

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/Profile.java
Log:
Distanz zum Zentrum: Bugfix.

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-02-11 11:49:50 UTC (rev 554)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-02-11 12:02:51 UTC (rev 555)
@@ -439,9 +439,16 @@
 	   else return false;
    }
    
-   /** A cache is visible if it is not blacklisted and not filtered */
-   public boolean isVisible() {
-	   return !is_black && !is_filtered;
+   public void calcDistance(CWPoint toPoint) {	
+	   if(pos.isValid()){
+			kilom = pos.getDistance(toPoint);
+			degrees = pos.getBearing(toPoint);
+			bearing = CWPoint.getDirection(degrees);
+			distance = MyLocale.formatDouble(kilom,"0.00")+" km";
+	   } else {
+		   distance = "?";
+		   bearing = "?";
+	   }
    }
-  
+   
 }
\ No newline at end of file

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-02-11 11:49:50 UTC (rev 554)
+++ trunk/src/CacheWolf/Profile.java	2007-02-11 12:02:51 UTC (rev 555)
@@ -347,21 +347,13 @@
 	 *	@see	Extractor
 	 */
 	public void updateBearingDistance(){
-		CWPoint fromPoint = new CWPoint(Global.getPref().curCentrePt); // Clone current centre to be sure
+		CWPoint centerPoint = new CWPoint(Global.getPref().curCentrePt); // Clone current centre to be sure
 		int anz = cacheDB.getCount();
 		CacheHolder ch;
-		CWPoint toPoint;
 		// Jetzt durch die CacheDaten schleifen
 		while(--anz >= 0){
 			ch = (CacheHolder)cacheDB.get(anz); // This returns a pointer to the CacheHolder object
-			if(ch.LatLon.length()>4){
-				toPoint = ch.pos;
-				ch.kilom = fromPoint.getDistance(toPoint);
-				ch.degrees = fromPoint.getBearing(toPoint);
-				ch.bearing = CWPoint.getDirection(ch.degrees);
-				ch.distance = MyLocale.formatDouble(ch.kilom,"0.00");
-				ch.distance = ch.distance + " km";
-			}
+			ch.calcDistance(centerPoint);
 		}
 		// The following call is not very clean as it mixes UI with base classes
 		// However, calling it from here allows us to recenter the



From salzkammergut at mail.berlios.de  Sun Feb 11 15:10:52 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 11 Feb 2007 15:10:52 +0100
Subject: [Cachewolf-svn] r556 - trunk/src/CacheWolf
Message-ID: <200702111410.l1BEAq1l021775@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-11 15:10:45 +0100 (Sun, 11 Feb 2007)
New Revision: 556

Modified:
   trunk/src/CacheWolf/CacheHolder.java
Log:
CacheHolder Bugfix

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-02-11 12:02:51 UTC (rev 555)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-02-11 14:10:45 UTC (rev 556)
@@ -446,7 +446,7 @@
 			bearing = CWPoint.getDirection(degrees);
 			distance = MyLocale.formatDouble(kilom,"0.00")+" km";
 	   } else {
-		   distance = "?";
+		   distance = "? km";
 		   bearing = "?";
 	   }
    }



From salzkammergut at mail.berlios.de  Sun Feb 11 17:43:08 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 11 Feb 2007 17:43:08 +0100
Subject: [Cachewolf-svn] r557 - trunk/docs
Message-ID: <200702111643.l1BGh8wX029261@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-11 17:43:05 +0100 (Sun, 11 Feb 2007)
New Revision: 557

Modified:
   trunk/docs/Sonderzeichen_in_languages.cfg.txt
Log:
Sonderzeichen in languages.cfg: Bugfix und Erweiterung
AE war falsch umgesetzt

Modified: trunk/docs/Sonderzeichen_in_languages.cfg.txt
===================================================================
--- trunk/docs/Sonderzeichen_in_languages.cfg.txt	2007-02-11 14:10:45 UTC (rev 556)
+++ trunk/docs/Sonderzeichen_in_languages.cfg.txt	2007-02-11 16:43:05 UTC (rev 557)
@@ -1,3 +1,7 @@
+Zeichen sind als "Quoted printable" kodiert mit einem % Zeichen
+Siehe auch http://de.wikipedia.org/wiki/Quoted-printable
+und http://www.cs.tut.fi/~jkorpela/chars.html
+
 Leertaste: +
 ? %e4
 ? %f6 
@@ -3,5 +7,6 @@
 ? %fc 
 ? %df
-? %c6
+? %c4
 ? %d6
 ? %dc
+\n %0a
\ No newline at end of file



From salzkammergut at mail.berlios.de  Sun Feb 11 17:52:28 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 11 Feb 2007 17:52:28 +0100
Subject: [Cachewolf-svn] r558 - trunk/src/CacheWolf
Message-ID: <200702111652.l1BGqSZl029713@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-11 17:52:24 +0100 (Sun, 11 Feb 2007)
New Revision: 558

Modified:
   trunk/src/CacheWolf/CacheHolder.java
Log:
CacheHolder: Optimierung und fix (LatLon mit "nicht gesetzt") initialisiert 

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-02-11 16:43:05 UTC (rev 557)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-02-11 16:52:24 UTC (rev 558)
@@ -17,28 +17,31 @@
 *	
 */
 public class CacheHolder {
-  public String UUID = new String();
-  public String wayPoint = new String();
-  public String LongDescription = new String();
-  public String CacheName = new String();
-  public String CacheOwner = new String();
-  public String LatLon = new String();
+  private String NODISTANCE="? km";
+  private String NOBEARING="?";
+  private String EMPTY=""; // Needs less Memory than using 'new String()'
+  //public String UUID = EMPTY;
+  public String wayPoint = EMPTY;
+  public String LongDescription = EMPTY;
+  public String CacheName = EMPTY;
+  public String CacheOwner = EMPTY;
   public CWPoint pos = new CWPoint();
-  public String DateHidden = new String();
-  public String LastUpdate = new String();
-  public String Hints = new String();
+  public String LatLon = pos.toString();
+  public String DateHidden = EMPTY;
+  public String LastUpdate = EMPTY;
+  public String Hints = EMPTY;
   public Vector CacheLogs = new Vector(0);
-  public String CacheNotes = new String();
-  public String CacheStatus = new String("");
-  public String CacheSize = new String("None");
-  public String distance = new String();
-  public String bearing = new String();
+  public String CacheNotes = EMPTY;
+  public String CacheStatus = EMPTY;
+  public String CacheSize = "None";
+  public String distance = NODISTANCE;
+  public String bearing = NOBEARING;
   public double degrees = 0;
   public double kilom = 0;
-  public String hard = new String();
-  public String terrain =new String();
-  public String type = new String("0");
-  public String dirty = new String();
+  public String hard = EMPTY;
+  public String terrain = EMPTY;
+  public String type = "0";
+  public String dirty = EMPTY;
   public Vector Images = new Vector();
   public Vector ImagesText = new Vector();
   public Vector LogImages = new Vector();
@@ -47,9 +50,9 @@
   public Vector UserImagesText = new Vector();
   public Vector attributes = new Vector();
   public Vector CacheIcons = new Vector();
-  public String Bugs = new String();
-  public String URL = new String();
-  public String ocCacheID = new String();
+  public String Bugs = EMPTY;
+  public String URL = EMPTY;
+  public String ocCacheID = EMPTY;
   public int noFindLogs = 0;
   public boolean is_archived = false;
   public boolean is_available = true;
@@ -126,7 +129,7 @@
 	  //<img src='icon_smile.gif'>&nbsp;2005-10-30 by Schatzpirat</strong><br>
 	  //get Date of latest log in old cachedata
 	  Extractor extOldDate;
-	  String oldLogDate = new String();
+	  String oldLogDate = EMPTY;
 	  if(this.CacheLogs.size()>0){
 		extOldDate = new Extractor((String) this.CacheLogs.get(0), ";"," by", 0, true);
 		oldLogDate= new String(extOldDate.findNext());
@@ -136,7 +139,7 @@
 	  
 	  //Vm.debug("made it to here!");
 	  int currLog = newCh.CacheLogs.size()-1;
-	  String newLogDate = new String();
+	  String newLogDate = EMPTY;
 	  while (currLog >= 0 ){
 		  Extractor extNewDate = new Extractor((String) newCh.CacheLogs.get(currLog), ";"," by", 0, true);
 		  newLogDate = extNewDate.findNext();
@@ -151,7 +154,7 @@
 	  }//while
    	 //Check for number sukzessive DNF logs
 	 int z = 0;
-	 String loganal = new String();
+	 String loganal = EMPTY;
 	 // Vm.debug("Checking size: ");
 	 //int sz = newCh.CacheLogs.size();
 	 //Vm.debug("log size: " + sz);
@@ -348,7 +351,7 @@
 		try{
 		  detfile = new PrintWriter(new BufferedWriter(new FileWriter(dir + wayPoint + ".xml")));
 		} catch (Exception e) {
-			Vm.debug("Problem opening details file");
+			Global.getPref().log("Problem opening details file",e,true);
 			return;
 		}
 		try{
@@ -446,8 +449,8 @@
 			bearing = CWPoint.getDirection(degrees);
 			distance = MyLocale.formatDouble(kilom,"0.00")+" km";
 	   } else {
-		   distance = "? km";
-		   bearing = "?";
+		   distance = NODISTANCE;
+		   bearing = NOBEARING;
 	   }
    }
    



From salzkammergut at mail.berlios.de  Sun Feb 11 20:08:36 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 11 Feb 2007 20:08:36 +0100
Subject: [Cachewolf-svn] r559 - trunk/resources
Message-ID: <200702111908.l1BJ8aQ9014606@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-11 20:08:33 +0100 (Sun, 11 Feb 2007)
New Revision: 559

Modified:
   trunk/resources/cachewolf.Languages.cfg
Log:
Nachtrag zu vorheriger Revision

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-02-11 16:52:24 UTC (rev 558)
+++ trunk/resources/cachewolf.Languages.cfg	2007-02-11 19:08:33 UTC (rev 559)
@@ -143,7 +143,7 @@
 		709=Anwenden
 		710=Archiviert
 		711=Nicht suchbar
-		712=Route Datei waehlen
+		712=Route Datei w%e4hlen
 		713=Speicher Filter
 		714=Richtung & Entfernung
 		715=Zeige alle Caches mit Status
@@ -165,6 +165,8 @@
 		731=Noch nicht gefunden
 		732=Anderer Besitzer
 		733=Addi Wpt
+		734=Kein Hauptwegpunkt gefunden zu
+		735=Addi Waypoints m%fcssen das Format xxYYYY haben, wobei xx beliebige Zeichen und YYYY die Zeichen des Hauptcaches nach dem GC sind
 		800=Erstelle Liste
 		801=suche...
 		802=Caches identifiziert. Suche weiter...
@@ -223,7 +225,7 @@
 		1110=Bearbeiten
 		1111=Neues Profil anlegen
 		1112=Profilname
-		1113=Kann Verzeichnis nicht erstellen
+		1113=Kann Verzeichnis nicht erstellen (Es darf kein vom Betriebssystem verbotenen Zeichen beinhalten)
 		1114=Verzeichnis existiert bereits
 		1115=Zentrum
 		1116=Aktuell
@@ -239,7 +241,7 @@
 		1204=Hint & Logs
 		1205=L%f6ser
 		1206=Rechner
-		1207=%C6nderungen im Profil Speichern?
+		1207=%c4nderungen im Profil Speichern?
 		1300=Letzte Einstellung
 		1301=Profil ausw%e4hlen:
 		1400=Zone
@@ -491,6 +493,9 @@
 		730=Available
 		731=Not yet found
 		732=Other owner
+		733=Addi Wpt
+		734=No main waypoint found for
+		735=Addi Waypoints must have the format xxYYYY, where xx are any 2 chars and YYYY are the main cache's chars after the GC
 		800=Creating list
 		801=searching...
 		802=Caches identified. searching...
@@ -549,7 +554,7 @@
 		1110=Edit
 		1111=Create new profile:
 		1112=New profile name
-		1113=Cannot create directory
+		1113=Cannot create directory (must not contain caracters forbidden by operating system)
 		1114=Directory exists already.
 		1115=Centre
 		1116=Current



From salzkammergut at mail.berlios.de  Sun Feb 11 20:32:01 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 11 Feb 2007 20:32:01 +0100
Subject: [Cachewolf-svn] r560 - trunk/src/CacheWolf
Message-ID: <200702111932.l1BJW17F016305@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-11 20:31:58 +0100 (Sun, 11 Feb 2007)
New Revision: 560

Modified:
   trunk/src/CacheWolf/DetailsPanel.java
Log:
DetailsPanel: Bugfix: Leere oder kurze Waypoints verursachten IndexOutOfBounds Exceptions bei diversen substring Operations
Feature: Distanz zum Zentrum wird sofort aktualisiert +
Ausfuehrliche Warnung wenn zum Addi Wpt kein Master gefunden wird


Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-02-11 19:08:33 UTC (rev 559)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-02-11 19:31:58 UTC (rev 560)
@@ -296,10 +296,14 @@
 				CoordsScreen cs = new CoordsScreen();
 				cs.setFields(coords, CWPoint.CW);
 				if (cs.execute()== CoordsScreen.IDOK){
+					dirty_details=true;
 					coords = cs.getCoords();
 					thisCache.pos.set(coords);
 					btnWayLoc.setText(coords.toString());
 					thisCache.LatLon=coords.toString();
+					// If the current center is valid, calculate the distance and bearing to it
+					CWPoint center=Global.getPref().curCentrePt;
+					if (center.isValid()) thisCache.calcDistance(center);
 				}
 			}
 			ev.consumed=true;
@@ -313,14 +317,32 @@
 		  ch.is_found = ch.CacheStatus.equals(MyLocale.getMsg(318,"Found"));
 		  ch.is_black = blackStatus;
 		  ch.wayPoint = inpWaypoint.getText().trim();
+		  // If the waypoint does not have a name, give it one
+		  if (ch.wayPoint.equals("")) { 
+			  ch.wayPoint=profile.getNewWayPointName();
+		  }
+		  //Don't allow single letter names=> Problems in updateBearingDistance
+		  // This is a hack but faster than slowing down the loop in updateBearingDistance
+		  if (ch.wayPoint.length()<2) ch.wayPoint+=" ";
 		  ch.CacheName = inpName.getText().trim();
-		  ch.LatLon = new CWPoint(btnWayLoc.getText(),CWPoint.CW).toString();
+		  ch.LatLon = ch.pos.toString();
 		  ch.DateHidden = inpHidden.getText().trim();
 		  ch.CacheOwner = inpOwner.getText().trim();
-		  ch.is_owned = pref.myAlias.equals(ch.CacheOwner);
+		  // Avoid setting is_owned if alias is empty and username is empty
+		  ch.is_owned = (!pref.myAlias.equals("") && pref.myAlias.equals(ch.CacheOwner)) || 
+				        (!pref.myAlias2.equals("") && pref.myAlias2.equals(ch.CacheOwner));
 		  ch.type = transSelect(chcType.getInt());
-		  if (CacheType.isAddiWpt(ch.type)) 
+		  if (CacheType.isAddiWpt(ch.type)) {
+			  int idx;
+			  if (ch.wayPoint.length()<5)
+				  idx=-1;
+			  else
+				  idx=profile.getCacheIndex("GC"+ ch.wayPoint.substring(ch.wayPoint.length() == 5?1:2));
+			  if (idx<0) (new MessageBox(MyLocale.getMsg(144,"Warning"),
+					  MyLocale.getMsg(734,"No main cache found for addi waypoint ")+" "+ch.wayPoint+
+					  "\n"+MyLocale.getMsg(735,"Addi Waypoints must have the format xxYYYY, where xx are any 2 chars and YYYY are the main cache's chars after the GC"),FormBase.OKB)).execute();
 			  profile.buildReferences();
+		  }
 		  // set status also on addi wpts
 		  if (ch.hasAddiWpt()){
 			  CacheHolder addiWpt;



From salzkammergut at mail.berlios.de  Sun Feb 11 20:34:15 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 11 Feb 2007 20:34:15 +0100
Subject: [Cachewolf-svn] r561 - trunk/src/CacheWolf
Message-ID: <200702111934.l1BJYFvG016493@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-11 20:34:09 +0100 (Sun, 11 Feb 2007)
New Revision: 561

Modified:
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/TablePanel.java
   trunk/src/CacheWolf/myTableModel.java
Log:
Bugfix: Die Selektion in der Listenansicht war nicht synchron mit den anderen Ansichten nach Ausfuehren von
Sort/Filter oder Suche. MainMenu aufgeraeumt, myTableModel aufgeraumt.

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-02-11 19:31:58 UTC (rev 560)
+++ trunk/src/CacheWolf/MainMenu.java	2007-02-11 19:34:09 UTC (rev 561)
@@ -182,18 +182,9 @@
 		Global.mainTab.updatePendingChanges();
 		if (ev instanceof MenuEvent){ //&& ev.type == MenuEvent.PRESSED
 			MenuEvent mev = (MenuEvent)ev;
-			if(mev.selectedItem == wolflang){
-				InfoScreen is = new InfoScreen(File.getProgramDirectory() + "/" + "wolflang.html", MyLocale.getMsg(118,"WolfLanguage"), true, pref);
-				is.execute(father.getFrame(), Gui.CENTER_FRAME);
-			}
-			if(mev.selectedItem == about){
-				InfoScreen is = new InfoScreen(File.getProgramDirectory() + "/" + "info.html", MyLocale.getMsg(117,"About"),true, pref);
-				is.execute(father.getFrame(), Gui.CENTER_FRAME);
-			}
-			if(mev.selectedItem == legend){
-				InfoScreen is = new InfoScreen(File.getProgramDirectory() + "/" + "legende.html", MyLocale.getMsg(155,"Legend"),true, pref);
-				is.execute(father.getFrame(), Gui.CENTER_FRAME);
-			}
+			///////////////////////////////////////////////////////////////////////
+			// subMenu for profiles, part of "Application" menu 
+			///////////////////////////////////////////////////////////////////////
 			if(mev.selectedItem == mnuNewProfile){
 				Global.mainTab.saveUnsavedChanges(true);
 				NewProfileForm f=new NewProfileForm(pref.baseDir);
@@ -213,13 +204,11 @@
 					Global.mainTab.saveUnsavedChanges(true);
 					if (pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_FORCED_ON,false)) {
 					profile.cacheDB.clear();
-					tbp.setSelectedCache(-1);
 					profile.readIndex();
 					pref.curCentrePt.set(profile.centre);
 					filtBlack.modifiers&=~MenuItem.Checked;
 					Filter.showBlacklisted=false;
 					tbp.resetModel();
-					Global.mainTab.tbP.gotoFirstLine();
 				}
 			}
 			if(mev.selectedItem == mnuEditProfile){
@@ -228,16 +217,123 @@
 			    tbp.refreshTable();
 				f.close(0);
 			}
+			///////////////////////////////////////////////////////////////////////
+			// subMenu for export, part of "Application" menu 
+			///////////////////////////////////////////////////////////////////////
+			if(mev.selectedItem == exporthtml){
+				HTMLExporter htm = new HTMLExporter(pref, profile);
+				htm.doIt();
+			}
+			if(mev.selectedItem == exportpcx5){
+				PCX5Exporter pcx = new PCX5Exporter( pref, profile);
+				pcx.doIt(PCX5Exporter.MODE_ASK);
+			} 
+			if(mev.selectedItem == exporttop50){
+				OVLExporter ovl = new OVLExporter(pref, profile);
+				ovl.doIt();
+			}
+			if(mev.selectedItem == exportGPX){
+				GPXExporter htm = new GPXExporter(pref, profile);
+				htm.doIt(1);
+			}
+			if(mev.selectedItem == exportASC){
+				ASCExporter asc = new ASCExporter(pref,profile);
+				asc.doIt();
+			}
+			if(mev.selectedItem == exportTomTom){
+				TomTomExporter tt = new TomTomExporter();
+				tt.doIt();
+			}
+			if(mev.selectedItem == exportMSARCSV){
+				MSARCSVExporter msar = new MSARCSVExporter(pref,profile);
+				msar.doIt();
+			}
+			if(mev.selectedItem == exportGPS){
+				Vm.showWait(true);
+				LocExporter loc = new LocExporter();
+				String tmpFileName = File.getProgramDirectory() + "/temp.loc";
+				loc.setTmpFileName(tmpFileName);
+				loc.doIt(LocExporter.MODE_AUTO);
+				ProgressBarForm.display(MyLocale.getMsg(950,"Transfer"),MyLocale.getMsg(951,"Sending to GPS"), null);
+				try{
+					ewe.sys.Process p = Vm.exec("gpsbabel -i geo -f \""+ tmpFileName +"\" -o garmin -F " + pref.garminConn +":");
+					Vm.debug("gpsbabel -i geo -f  \""+ tmpFileName +"\" -o garmin -F " + pref.garminConn +":");
+					p.waitFor();
+				}catch(IOException ioex){};
+				ProgressBarForm.clear();
+				Vm.showWait(false);
+			}
+			if(mev.selectedItem == exportCacheMate){
+				Vm.showWait(true);
+				GPXExporter htm = new GPXExporter( pref, profile);
+				htm.doIt(0);
+				ProgressBarForm.display("CMCONVERT", MyLocale.getMsg(952,"Converting..."), null);
+				String cwd = new String();
+				cwd = File.getProgramDirectory() + "/temp.gpx";
+				// add surrounding "
+				cwd = "\"" + cwd + "\"";
+				try{
+					//Vm.debug(File.getProgramDirectory() + "/cmconvert/cmconvert " + cwd);
+					ewe.sys.Process p = Vm.exec(File.getProgramDirectory() + "/cmconvert/cmconvert " + cwd);
+					p.waitFor();
+				}catch(IOException ioex){
+					//Vm.debug("Scheint ein Problem zu geben");
+				};
+				ProgressBarForm.clear();
+				Vm.showWait(false);
+			}
+			if(mev.selectedItem == exportOZI){
+				OziExporter ozi = new OziExporter( pref, profile);
+				ozi.doIt();
+			}
+			if(mev.selectedItem == exportKML){
+				KMLExporter kml = new KMLExporter( pref, profile);
+				kml.doIt();
+			}
+			if(mev.selectedItem == exportTPL){
+				FileChooser fc = new FileChooser(FileChooser.OPEN, File.getProgramDirectory());
+				fc.addMask("*.tpl");
+				fc.setTitle(MyLocale.getMsg(910,"Select Template file"));
+				if(fc.execute() != FileChooser.IDCANCEL){
+					TPLExporter tpl = new TPLExporter( pref,profile, fc.getChosenFile().toString());
+					tpl.doIt();
+				}
+			}
+			///////////////////////////////////////////////////////////////////////
+			// subMenu for maps, part of "Application" menu 
+			///////////////////////////////////////////////////////////////////////
+			if(mev.selectedItem == downloadmap){
+				MapLoaderGui mLG = new MapLoaderGui(cacheDB);
+				mLG.exec(); // .execute doesn't work because the tcp-socket uses another thread which cannot be startet if here .execute() is used!
+			}
+			if(mev.selectedItem == importmap){
+
+				Map map = new Map(pref);
+				map.importMap();
+			}
+			if(mev.selectedItem == kalibmap){
+				SelectMap sM = new SelectMap();
+				sM.execute();
+				if((sM.getSelectedMap()).length()>0){
+					try {
+						Map map = new Map(pref, sM.getSelectedMap(),sM.worldfileexists);
+						map.execute(null, Gui.CENTER_FRAME);
+					} catch (java.lang.OutOfMemoryError e) {
+						MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, "Error"), MyLocale.getMsg(156,"Out of memory error, map to big"), MessageBox.OKB);
+						tmpMB.exec();
+					}
+				}
+			}
+			///////////////////////////////////////////////////////////////////////
+			// "Application" pulldown menu
+			///////////////////////////////////////////////////////////////////////
 			if(mev.selectedItem == preferences){
-				tbp.saveColWith(pref);
+				tbp.saveColWidth(pref);
 				PreferencesScreen pfs = new PreferencesScreen(pref);
 				pfs.execute(father.getFrame(), Gui.CENTER_FRAME);
 				pref.readPrefFile();
 			}
 			if(mev.selectedItem == loadcaches){
-				//LoadScreen lsc = new LoadScreen(cacheDB, myPreferences);
-				//lsc.execute(father.getFrame(), Gui.CENTER_FRAME);
-				//Vm.debug("Sending repaint!");
 				FileChooser fc = new FileChooser(FileChooser.OPEN|FileChooser.MULTI_SELECT, pref.baseDir);
 				fc.addMask("*.gpx,*.zip,*.loc");
 				fc.setTitle(MyLocale.getMsg(909,"Select file(s)"));
@@ -277,6 +373,45 @@
 				filtBlack.modifiers&=~MenuItem.Checked;
 				tbp.resetModel();
 			}
+			if(mev.selectedItem == spider){
+				SpiderGC spGC = new SpiderGC(pref, profile);
+				spGC.doIt();
+				tbp.resetModel();
+			}
+			if(mev.selectedItem == savenoxit){
+				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+				tbp.saveColWidth(pref);
+			}
+			
+			if(mev.selectedItem == savenexit){
+				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+				tbp.saveColWidth(pref);
+				ewe.sys.Vm.exit(0);
+			}
+			if(mev.selectedItem == exit){
+				Global.mainTab.saveUnsavedChanges(true);
+				ewe.sys.Vm.exit(0);
+			}
+
+			///////////////////////////////////////////////////////////////////////
+			// "Search" pulldown menu
+			///////////////////////////////////////////////////////////////////////
+			if(mev.selectedItem == search){
+				String srch = new InputBox(MyLocale.getMsg(119,"Search for:")).input("",10);
+				if (srch != null) {
+					SearchCache ssc = new SearchCache(cacheDB);
+					ssc.search(srch);
+					tbp.refreshTable();
+				}
+			}
+			if(mev.selectedItem == searchClr){
+				SearchCache ssc = new SearchCache(cacheDB);
+				ssc.clearSearch();
+				tbp.refreshTable();		
+			}
+			///////////////////////////////////////////////////////////////////////
+			// "Filter" pulldown menu
+			///////////////////////////////////////////////////////////////////////
 			if(mev.selectedItem == filtApply){
 				Filter flt = new Filter();
 				flt.setFilter();
@@ -293,6 +428,11 @@
 				flt.invertFilter();
 				tbp.refreshTable();
 			}
+			if(mev.selectedItem == filtClear){
+				Filter flt = new Filter();
+				flt.clearFilter();
+				tbp.refreshTable();
+			}
 			if(mev.selectedItem == filtBlack){
 				filtBlack.modifiers^=MenuItem.Checked;
 				Filter.showBlacklisted=!Filter.showBlacklisted;
@@ -300,46 +440,6 @@
 				ssc.clearSearch();// Clear search & restore filter status
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == exportGPS){
-				Vm.showWait(true);
-				LocExporter loc = new LocExporter();
-				String tmpFileName = File.getProgramDirectory() + "/temp.loc";
-				loc.setTmpFileName(tmpFileName);
-				loc.doIt(LocExporter.MODE_AUTO);
-				ProgressBarForm.display(MyLocale.getMsg(950,"Transfer"),MyLocale.getMsg(951,"Sending to GPS"), null);
-				try{
-					ewe.sys.Process p = Vm.exec("gpsbabel -i geo -f \""+ tmpFileName +"\" -o garmin -F " + pref.garminConn +":");
-					Vm.debug("gpsbabel -i geo -f  \""+ tmpFileName +"\" -o garmin -F " + pref.garminConn +":");
-					p.waitFor();
-				}catch(IOException ioex){};
-				ProgressBarForm.clear();
-				Vm.showWait(false);
-			}
-			if(mev.selectedItem == exportCacheMate){
-				Vm.showWait(true);
-				GPXExporter htm = new GPXExporter( pref, profile);
-				htm.doIt(0);
-				ProgressBarForm.display("CMCONVERT", MyLocale.getMsg(952,"Converting..."), null);
-				String cwd = new String();
-				cwd = File.getProgramDirectory() + "/temp.gpx";
-				// add surrounding "
-				cwd = "\"" + cwd + "\"";
-				try{
-					//Vm.debug(File.getProgramDirectory() + "/cmconvert/cmconvert " + cwd);
-					ewe.sys.Process p = Vm.exec(File.getProgramDirectory() + "/cmconvert/cmconvert " + cwd);
-					p.waitFor();
-				}catch(IOException ioex){
-					//Vm.debug("Scheint ein Problem zu geben");
-				};
-				ProgressBarForm.clear();
-				Vm.showWait(false);
-			}
-			if(mev.selectedItem == filtClear){
-				Filter flt = new Filter();
-				flt.clearFilter();
-				tbp.refreshTable();
-			}
-			
 			if(mev.selectedItem == filtSelected){
 				CacheHolder ch;
 				for(int i = cacheDB.size()-1; i>=0; i--){
@@ -349,71 +449,11 @@
 				}
 				tbp.refreshTable();
 			}
-			
-			if(mev.selectedItem == exportpcx5){
-				PCX5Exporter pcx = new PCX5Exporter( pref, profile);
-				pcx.doIt(PCX5Exporter.MODE_ASK);
-			} 
-			if(mev.selectedItem == exporttop50){
-				OVLExporter ovl = new OVLExporter(pref, profile);
-				ovl.doIt();
-			}
-			if(mev.selectedItem == exporthtml){
-				HTMLExporter htm = new HTMLExporter(pref, profile);
-				htm.doIt();
-			}
-			if(mev.selectedItem == exportGPX){
-				GPXExporter htm = new GPXExporter(pref, profile);
-				htm.doIt(1);
-			}
-			if(mev.selectedItem == exportASC){
-				ASCExporter asc = new ASCExporter(pref,profile);
-				asc.doIt();
-			}
-			if(mev.selectedItem == exportTomTom){
-				TomTomExporter tt = new TomTomExporter();
-				tt.doIt();
-			}
-			if(mev.selectedItem == exportMSARCSV){
-				MSARCSVExporter msar = new MSARCSVExporter(pref,profile);
-				msar.doIt();
-			}
-			if(mev.selectedItem == search){
-				String srch = new InputBox(MyLocale.getMsg(119,"Search for:")).input("",10);
-				if (srch != null) {
-					SearchCache ssc = new SearchCache(cacheDB);
-					ssc.search(srch);
-					tbp.refreshTable();
-				}
-			}
-			if(mev.selectedItem == exportOZI){
-				OziExporter ozi = new OziExporter( pref, profile);
-				ozi.doIt();
-			}
-			if(mev.selectedItem == exportKML){
-				KMLExporter kml = new KMLExporter( pref, profile);
-				kml.doIt();
-			}
-
-			if(mev.selectedItem == exportTPL){
-				FileChooser fc = new FileChooser(FileChooser.OPEN, File.getProgramDirectory());
-				fc.addMask("*.tpl");
-				fc.setTitle(MyLocale.getMsg(910,"Select Template file"));
-				if(fc.execute() != FileChooser.IDCANCEL){
-					TPLExporter tpl = new TPLExporter( pref,profile, fc.getChosenFile().toString());
-					tpl.doIt();
-				}
-			}
-
-			if(mev.selectedItem == searchClr){
-				SearchCache ssc = new SearchCache(cacheDB);
-				ssc.clearSearch();
-				tbp.refreshTable();		
-			}
-			
+			///////////////////////////////////////////////////////////////////////
+			// "Organize" pulldown menu
+			///////////////////////////////////////////////////////////////////////
 			if(mev.selectedItem == orgCopy){
 				profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
-
 				DataMover dm = new DataMover();
 				dm.copyCaches();
 				tbp.refreshTable();
@@ -421,7 +461,6 @@
 
 			if(mev.selectedItem == orgMove){
 				profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
-
 				DataMover dm = new DataMover();
 				dm.moveCaches();
 				tbp.refreshTable();
@@ -429,63 +468,25 @@
 			
 			if(mev.selectedItem == orgDelete){
 				profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
-
 				DataMover dm = new DataMover();
 				dm.deleteCaches();
 				tbp.refreshTable();
 			}
-			
-			if(mev.selectedItem == savenoxit){
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
-				tbp.saveColWith(pref);
+			///////////////////////////////////////////////////////////////////////
+			// "About" pulldown menu
+			///////////////////////////////////////////////////////////////////////
+			if(mev.selectedItem == about){
+				InfoScreen is = new InfoScreen(File.getProgramDirectory() + "/" + "info.html", MyLocale.getMsg(117,"About"),true, pref);
+				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
-			
-			if(mev.selectedItem == savenexit){
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
-				tbp.saveColWith(pref);
-				ewe.sys.Vm.exit(0);
+			if(mev.selectedItem == legend){
+				InfoScreen is = new InfoScreen(File.getProgramDirectory() + "/" + "legende.html", MyLocale.getMsg(155,"Legend"),true, pref);
+				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
-			if(mev.selectedItem == downloadmap){
-				MapLoaderGui mLG = new MapLoaderGui(cacheDB);
-				mLG.exec(); // .execute doesn't work because the tcp-socket uses another thread which cannot be startet if here .execute() is used!
+			if(mev.selectedItem == wolflang){
+				InfoScreen is = new InfoScreen(File.getProgramDirectory() + "/" + "wolflang.html", MyLocale.getMsg(118,"WolfLanguage"), true, pref);
+				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
-			if(mev.selectedItem == kalibmap){
-				SelectMap sM = new SelectMap();
-				sM.execute();
-				if((sM.getSelectedMap()).length()>0){
-					try {
-						Map map = new Map(pref, sM.getSelectedMap(),sM.worldfileexists);
-						map.execute(null, Gui.CENTER_FRAME);
-					} catch (java.lang.OutOfMemoryError e) {
-						MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, "Error"), MyLocale.getMsg(156,"Out of memory error, map to big"), MessageBox.OKB);
-						tmpMB.exec();
-					}
-				}
-			}
-			if(mev.selectedItem == importmap){
-
-				Map map = new Map(pref);
-				map.importMap();
-			}
-			if(mev.selectedItem == chkVersion){
-				Version vers = new Version();
-				if(vers.newVersionAvailable(pref)){
-					InfoBox inf = new InfoBox("New Version", "New version\navailable.");// TODO Internationalisation when code has been written
-					inf.execute();
-				} else {
-					InfoBox inf = new InfoBox("Version Check", "You are at\nthe current version.");// TODO Internationalisation when code has been written
-					inf.execute();
-				}
-			}
-			if(mev.selectedItem == spider){
-				SpiderGC spGC = new SpiderGC(pref, profile);
-				spGC.doIt();
-				tbp.resetModel();
-			}
-			if(mev.selectedItem == exit){
-				Global.mainTab.saveUnsavedChanges(true);
-				ewe.sys.Vm.exit(0);
-			}
 			if(mev.selectedItem == sysinfo){
 				//Vm.debug("Checking system...");
 				String sysstring = new String();
@@ -504,6 +505,17 @@
 				InfoScreen is = new InfoScreen(sysstring, "System", false,pref);
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
+			if(mev.selectedItem == chkVersion){
+				Version vers = new Version();
+				if(vers.newVersionAvailable(pref)){
+					InfoBox inf = new InfoBox("New Version", "New version\navailable.");// TODO Internationalisation when code has been written
+					inf.execute();
+				} else {
+					InfoBox inf = new InfoBox("Version Check", "You are at\nthe current version.");// TODO Internationalisation when code has been written
+					inf.execute();
+				}
+			}
+
 		}
 	}
 }

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-02-11 19:31:58 UTC (rev 560)
+++ trunk/src/CacheWolf/MainTab.java	2007-02-11 19:34:09 UTC (rev 561)
@@ -1,5 +1,6 @@
 package CacheWolf;
 
+import ewe.sys.Vm;
 import ewe.ui.*;
 import ewe.fx.*;
 import ewe.util.*;
@@ -63,7 +64,6 @@
 		nav = new Navigate();
 		c = this.addCard(gotoP = new GotoPanel(nav), "Goto", null);
 		c.iconize(new Image("goto.gif"),true);
-		tbP.setPanels(gotoP, this);
 		nav.setGotoPanel(gotoP);
 
 		c = this.addCard(solverP = new SolverPanel(pref, profile), MyLocale.getMsg(1205,"Solver"), null);
@@ -113,17 +113,20 @@
 	 */
 	public void newWaypoint(CacheHolder ch){
 		if (detP.isDirty()) detP.saveDirtyWaypoint();
+		Global.getProfile().hasUnsavedChanges=true;
 		String waypoint= ch.wayPoint = profile.getNewWayPointName();
 		ch.type = "0";
 		ch.CacheSize = "None";
 		cacheDB.add(ch);
 		Global.mainTab.tbP.myMod.updateRows();
-		Global.mainTab.tbP.setSelectedCache(profile.getCacheIndex(waypoint));
+		Global.mainTab.tbP.selectRow(profile.getCacheIndex(waypoint));
 		//Global.mainTab.tbP.refreshTable();
 		if (this.cardPanel.selectedItem==1) { // Detailpanel already selected
 			postEvent(new MultiPanelEvent(MultiPanelEvent.SELECTED,detP,0));
 		} else	
 			select(detP);
+		Global.mainTab.tbP.refreshTable();
+	
 	}
 
 
@@ -140,7 +143,7 @@
 			}
 			updatePendingChanges();
 			if(this.getSelectedItem() != 0){
-				if (tbP.getSelectedCache()>=cacheDB.size())
+				if (tbP.getSelectedCache()>=cacheDB.size() || tbP.getSelectedCache()<0)
 					ch=null;
 				else {
 					ch = (CacheHolder)cacheDB.get(tbP.getSelectedCache());
@@ -254,9 +257,6 @@
 		}
 		if (saveIndex) profile.saveIndex(Global.getPref(),false);
 	}
-
-
-	
 }
 
 

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-02-11 19:31:58 UTC (rev 560)
+++ trunk/src/CacheWolf/TablePanel.java	2007-02-11 19:34:09 UTC (rev 561)
@@ -8,19 +8,25 @@
 /**
 *	Class to display the cache database in a table.
 *	Class ID = 1000
-*   Changes:
-*     20061124 salzkammergut: Bugfix 9529, Conversion to Mylocale
-*     20061212 salzkammergut: Commented out line 186ff (eventually to be removed)
 */
 public class TablePanel extends CellPanel{
 	
 	myTableControl tc;
 	myTableModel myMod;
-	int selectedCache=0;
 	Preferences pref;
 	Vector cacheDB;
 	MainTab myMaintab;
 	StatusBar statBar;
+	/** We keep track of the currently selected cache in two variables(for speed)
+	 * selectedIdx is the index in cacheDB, selectedch is the actual cache
+	 * selectedIdx=-1 if no caches are visible (i.e. database empty or filtered). In 
+	 * this case selectedch is "null".
+	 * Otherwise selectedIdx points to a visible cache.
+	 * When the cacheDB is reorganized (by sort/filter/search), the selected cache
+	 * may end up at a new index.
+	 */
+	int selectedIdx=0;
+	CacheHolder selectedCh;
 	
 	public TablePanel(Preferences p, Profile profileXX, StatusBar statBar){
 		pref = Global.getPref();
@@ -35,27 +41,45 @@
 		tc.setTableModel(myMod);
 	}
 	
-	public void gotoFirstLine() {
-		tc.scrollToVisible(0,0);
+	public void setSelectedCache(int row){
+		selectedCh=null;
+		if (row>=0)  {
+			selectedCh=(CacheHolder) cacheDB.get(row);
+		} 		
+		selectedIdx=row;
+	
 	}
 	
-	/** @deprecated */
-	public void setPanels(GotoPanel gp, MainTab mt) {
-		myMaintab = mt;
+	/** Mark the row as selected so that myTableModel can color it grey */
+	public void selectRow(int row) {
+		setSelectedCache(row);
+		tc.clearSelectedCells(null);
+		for(int i= 0; i < myMod.MAXCOLUMNS; i++){
+			tc.addToSelection(row,i); 
+		}
 	}
-
-	public void setSelectedCache(int row){
-		selectedCache=row;
-	}
 	
-	
+	/** Returns the index of the currently selected cache or -1 of the cache is no longer visible
+	 * due to a sort/filter or search operation
+	 * @return index of selected cache (-1 if not visible)
+	 */
 	public int getSelectedCache(){
-		return selectedCache;
+		// If cacheDB is empty return -1, cannot select a cache
+		if (cacheDB.size()==0) return -1;
+		// If cacheDB has entries, but all are filtered, return -1
+		if (((CacheHolder)cacheDB.get(0)).is_filtered) return -1;
+		// Now we have at least one visible cache
+		// We had a previously selected cache, check whether it is now filtered
+		if (selectedCh==null || selectedCh.is_filtered) return 0; // Return first visible cache
+		// Check whether the order of the list has changed because of sort/filter/search operations
+		if (cacheDB.get(selectedIdx)==selectedCh) return selectedIdx;
+		// The position has changed, return the new position
+		return cacheDB.find(selectedCh);
 	}
 	
-	public void saveColWith(Preferences pref){
+	public void saveColWidth(Preferences pref){
 		int j=0;
-		for (int i = 0; i<=11; i++){
+		for (int i = 0; i<myMod.MAXCOLUMNS; i++){
 			if(pref.tablePrefs[i] == 1){
 				pref.tableWidth[i] = myMod.getColWidth(j++);
 			}
@@ -65,41 +89,27 @@
 	
 	public void selectAndActive(int rownum){
 		tc.scrollToVisible(rownum, 0);
-		tc.clearSelectedCells(new Vector());
-		selectedCache = rownum;
-		for(int i= 0; i < 11; i++){
-			tc.addToSelection(rownum,i); 
-		}
+		selectRow(rownum);  // color it in grey
 	}
 	
 	public void resetModel() {
+		setSelectedCache(-1);
 		myMod.numRows = cacheDB.size();
 		Global.getProfile().updateBearingDistance();
 		Filter flt = new Filter();
 		flt.setFilter();
 		flt.doFilter();
 		refreshTable();
-		selectedCache=0;
 	}
 	
 	/** Move all filtered caches to the end of the table and redesplay table */
 	//TODO Add a sort here to restore the sort after a filter
 	public void refreshTable(){
 		myMod.updateRows();
-		tc.update(true);
+		// Check whether the currently selected cache is still visible
+		Global.mainTab.tbP.selectRow(getSelectedCache());
+		tc.update(true); // Update and repaint
 		if (statBar!=null) statBar.updateDisplay();
 	}
 	
-	public void onEvent(Event ev)
-	{
-		if(ev instanceof TableEvent){
-			Point a = new Point();
-			Point dest = new Point();
-			a = tc.getSelectedCell(dest);
-			try {
-				selectedCache = a.y;
-			} catch(NullPointerException npe){}
-		}
-	  super.onEvent(ev); //Make sure you call this.
-	}
 }

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-02-11 19:31:58 UTC (rev 560)
+++ trunk/src/CacheWolf/myTableModel.java	2007-02-11 19:34:09 UTC (rev 561)
@@ -16,45 +16,39 @@
 */
 public class myTableModel extends TableModel{
 	
+	public static final int MAXCOLUMNS=12;
+	// Colors for Cache status (BG unless otherwise stated)
+	private static final Color COLOR_FLAGED		= new Color(255,255,0);
+	private static final Color COLOR_FOUND		= new Color(152,251,152);
+	private static final Color COLOR_OWNED		= new Color(135,206,235);
+	private static final Color COLOR_AVAILABLE	= new Color(255,69,0);
+	private static final Color COLOR_ARCHIVED	= new Color(139,37,0);
+	private static final Color COLOR_SELECTED	= new Color(198,198,198);
+	private static final Color COLOR_ARCHFND_FG	= new Color(255,0,0); // Archived && Found
+	private static final Color COLOR_ARCHFND_BG	= new Color(152,251,152);	
 	Vector cacheDB;
 	String[] colName;
+	int[] colWidth;
+	int [] colID; // The number of the column in the original sequence in the prefs file
+	int usedColumns; // Columns actually used (<=MAXCOLUMNS)
 	static Image cacheImages[] = new Image[454];
 	static Image noFindLogs[] = new Image[4];
-	int[] breiten;
 	Image red, blue, green, yellow;
 	mImage bug;
 	myTableControl tcControl;
 	boolean sortAsc = false;
 	FontMetrics fm;
-	String nmCheck, nmQuest, nmD,nmT,nmWay,nmName,nmLoc,nmOwn,nmHid,nmStat,nmDist,nmBear = new String();
 	Image checkboxTicked,checkboxUnticked;
-	static Color RED = new Color(255,0,0);
 	
 	public myTableModel(myTableControl tc, FontMetrics fm){
 		super();
-		nmCheck = " ";
-		nmQuest = "?";
-		nmD = MyLocale.getMsg(1000,"D");
-		nmT = MyLocale.getMsg(1001,"T");
-		nmWay = MyLocale.getMsg(1002,"Waypoint");
-		nmName = MyLocale.getMsg(1003,"Name");
-		nmLoc = MyLocale.getMsg(1004,"Location");
-		nmOwn = MyLocale.getMsg(1005,"Owner");
-		nmHid = MyLocale.getMsg(1006,"Hidden");
-		nmStat = MyLocale.getMsg(1007,"Status");
-		nmDist = MyLocale.getMsg(1008,"Dist");
-		nmBear = MyLocale.getMsg(1009,"Bear");
+		cacheDB = Global.getProfile().cacheDB;
 		fm = this.fm;
 		tcControl = tc;
 		setColumnNamesAndWidths(); 
-		cacheDB = Global.getProfile().cacheDB;
 		this.numRows = cacheDB.size();
 		Dimension selrow = new Dimension(-1,1);
 		this.cursorSize = selrow;
-		//colName = new String[colNs.length];
-		//colName = colNs;
-		//breiten = new int[colWidth.length];
-		//breiten = colWidth;
 		cacheImages[0] = new Image("0.png");
 		//cacheImages[1] = new Image();
 		cacheImages[2] = new Image("2.png");
@@ -101,37 +95,26 @@
 	 */
 	public void setColumnNamesAndWidths() {
 		String [] spName = {" ","?",MyLocale.getMsg(1000,"D"),"T",MyLocale.getMsg(1002,"Waypoint"),"Name",MyLocale.getMsg(1004,"Location"),MyLocale.getMsg(1005,"Owner"),MyLocale.getMsg(1006,"Hidden"),MyLocale.getMsg(1007,"Status"),MyLocale.getMsg(1008,"Dist"),MyLocale.getMsg(1009,"Bear")};
-		String[] jester;
-		int colWidth[];
-		int colnum = 0;
+		// [0]TickBox, [1]Type, [2]Distance, [3]Terrain, [4]waypoint, [5]name, [6]coordinates, 
+		// [7]owner, [8]datehidden, [9]status, [10]distance, [11]bearing
 		Preferences pref=Global.getPref();
+		colName=new String[MAXCOLUMNS]; // Always dimension to max columns, a few columns could be wasted
+		colWidth=new int[MAXCOLUMNS];
+		colID=new int[MAXCOLUMNS];
 		
-		for(int i = 0; i<=11; i++){
-			if(pref.tablePrefs[i] == 1) colnum++;
-		}
-		jester = new String[colnum];
-		colWidth = new int[colnum];
-		
-		int ji = 0;
-		for(int i = 0; i<=11;i++){
+		usedColumns = 0;
+		for(int i = 0; i<MAXCOLUMNS;i++){
 			if(pref.tablePrefs[i] == 1){
-				jester[ji] = spName[i];
-				colWidth[ji] = pref.tableWidth[i];
-				ji++;
+				colName[usedColumns] = spName[i];
+				colWidth[usedColumns] = pref.tableWidth[i];
+				colID[usedColumns]=i;
+				usedColumns++;
 			}
 		}
-		colName = jester;
-		breiten = colWidth;
-		this.numCols = colName.length;
+		this.numCols = usedColumns;
 		clearCellAdjustments();
-		//remapColumns(null);
 	}
 	
-	//RBpublic void setVector(Vector DB){
-	//	cacheDB = DB;
-	//	this.numRows = cacheDB.size();
-	//}
-	
 	public void updateRows(){
 		Vector sortDB = new Vector();
 		Vector filteredDB = new Vector();
@@ -139,7 +122,8 @@
 		// sort cacheDB:
 		// - addi wpts are listet behind the main cache
 		// - filtered caches are moved to the end
-		for (int i=0; i<cacheDB.size(); i++){
+		int size=cacheDB.size();
+		for (int i=0; i<size; i++){
 			ch = (CacheHolder) cacheDB.get(i);
 			if (ch.is_filtered) {
 				filteredDB.add(ch);
@@ -176,52 +160,36 @@
 	* cache list, depending on different flags set to the cache.
 	*/
 	public TableCellAttributes getCellAttributes(int row,int col,boolean  isSelected, TableCellAttributes ta){
-		try{
-			ta = super.getCellAttributes(row, col, isSelected, ta);
-			ta.alignment = ta.LEFT;
-			ta.anchor = ta.LEFT;
-			if(row >= 0){ 
-				CacheHolder ch = (CacheHolder)cacheDB.get(row);
-				// Color code:
-				// red := flagged
-				if(ch.is_flaged == true) ta.fillColor = new Color(255,255,0);
-				// green := found
-				if(ch.is_found == true) ta.fillColor = new Color(152,251,152);
-				// blue := owner
-				if(ch.is_owned == true) ta.fillColor = new Color(135,206,235);
-				if(ch.is_available == false) ta.fillColor = new Color(255,69,0);
-				if(ch.is_archived == true) ta.fillColor = new Color(139,37,0);
-				if(ch.is_available == false && ch.is_found == true){
-					//Green background
-					ta.fillColor = new Color(152,251,152);
-					//Change font color to red
-					ta.foreground = new Color(255,0,0);
-				}
-				// yellow := new
-				// check DateHidden ? <7 days : new!
-				// orange := updated (logs?)
-				// grey := selected
-				if(isSelected == true) ta.fillColor = new Color(198,198,198);
+		ta = super.getCellAttributes(row, col, isSelected, ta);
+		ta.alignment = ta.LEFT;
+		ta.anchor = ta.LEFT;
+		if(row >= 0){ 
+			CacheHolder ch = (CacheHolder)cacheDB.get(row);
+			if(isSelected == true) ta.fillColor = COLOR_SELECTED;
+			else if(ch.is_available == false && ch.is_found == true){
+				ta.fillColor = COLOR_ARCHFND_BG;   // Green BG
+				ta.foreground = COLOR_ARCHFND_FG;  // Red FG
 			}
-		}catch(NumberFormatException nfe){}
-		catch(IndexOutOfBoundsException abe){}
+			else if(ch.is_archived == true) ta.fillColor = COLOR_ARCHIVED;
+			else if(ch.is_available == false) ta.fillColor = COLOR_AVAILABLE;
+			else if(ch.is_owned == true) ta.fillColor = COLOR_OWNED;
+			else if(ch.is_found == true) ta.fillColor = COLOR_FOUND;
+			else if(ch.is_flaged == true) ta.fillColor = COLOR_FLAGED;
+		}
 		return ta;
 	}
-	
-	
-	public int calculateColWidth(int col){
-		//Vm.debug("myTableModel:: Calculating col width" + col);
-		int retval = 50;
-		if(col == -1) retval = 0;
-		try{
-			if(col >= 0) retval = breiten[col];
-		}catch(Exception ex){}
-		return retval;
-	}
-	
+
 	public int calculateRowHeight(int row){
 		return 18;
 	}
+
+	public int calculateColWidth(int col){
+		if(col == -1) 
+        	return 0;
+        else if (col<usedColumns)
+        	return colWidth[col];
+        else return 0;
+	}
 	
 	/**
 	 * Need to override this method with a null return to avoid
@@ -234,75 +202,67 @@
 	}
 
 	public Object getCellData(int row, int col){
-		IconAndText wpVal = new IconAndText(); //(IImage)bug, "Test Me", fm);
-		Object rettext = new Object();
-			if(row == -1) {
-				rettext = (String)colName[col];
-			}
-			if(row >= 0 ){
-				try{
-					CacheHolder ch = (CacheHolder)cacheDB.get(row);
-					//Vm.debug(String.valueOf(row));
-					//Vm.debug(String.valueOf(cols[col]));
-					if(ch.is_filtered == false){
-						try{
-							if(colName[col].equals(nmCheck)) {
-/* Replaced mCheckBox with two images: One showing the unticked box, one showing the ticked box
-  								mCheckBox m = new mCheckBox();
-								m.setTag(0, ch.wayPoint);
-								if(ch.is_Checked == true) m.setState(true);
-								else m.setState(false);
-								rettext = m;*/
-								if (ch.is_Checked) rettext=checkboxTicked; 
-								else rettext=checkboxUnticked;
-							}
-							if(colName[col].equals(nmQuest)) rettext = (IImage) cacheImages[Convert.parseInt(ch.type)];
-							if(colName[col].equals(nmD)) rettext = (String)ch.hard;
-							if(colName[col].equals(nmT)) rettext = (String)ch.terrain;
-							if(colName[col].equals(nmWay)){
-								rettext = (String)ch.wayPoint;
-								if(ch.is_log_update == true) wpVal = new IconAndText((IImage)blue, ch.wayPoint, fm);
-								if(ch.is_update == true) wpVal = new IconAndText((IImage)red, ch.wayPoint, fm);
-								if(ch.is_new == true) wpVal = new IconAndText((IImage)yellow, ch.wayPoint, fm);
-								if(ch.is_log_update == false &&
-								   ch.is_update == false &&
-								   ch.is_new == false) rettext = (String)ch.wayPoint;
-								else rettext = wpVal;
-							}
-							if(colName[col].equals(nmName)) {
-								rettext = (String)ch.CacheName;
-								wpVal = new IconAndText();
-								if(ch.has_bug == true){
-									wpVal.addColumn((IImage)bug);
-								}
-								if(ch.noFindLogs > 0){
-									if (ch.noFindLogs > noFindLogs.length) wpVal.addColumn((IImage)noFindLogs[noFindLogs.length-1]);
-									else wpVal.addColumn((IImage)noFindLogs[ch.noFindLogs-1]);
-								}
-								wpVal.addColumn(rettext);
-								rettext = wpVal;
-							}
-							if(colName[col].equals(nmLoc)) {
-								rettext = (String)ch.LatLon;
-							}
-							if(colName[col].equals(nmOwn)) rettext = (String)ch.CacheOwner;
-							if(colName[col].equals(nmHid)) rettext = (String)ch.DateHidden;
-							if(colName[col].equals(nmStat)) rettext = (String)ch.CacheStatus;
-							if(colName[col].equals(nmDist)) rettext = (String)ch.distance;
-							if(colName[col].equals(nmBear)) rettext = (String)ch.bearing;
-						}catch(NumberFormatException nfe){}
-					}
-				}catch(ArrayIndexOutOfBoundsException abe){
-					rettext = "bug in progam, please report";
+		if(row == -1) {
+			return (String)colName[col];
+		} else {
+			CacheHolder ch = (CacheHolder)cacheDB.get(row);
+			if(ch.is_filtered == false){
+				switch(colID[col]) { // Faster than using column names
+					case 0: // Checkbox
+						if (ch.is_Checked) 
+							return checkboxTicked; 
+						else 
+							return checkboxUnticked;
+					case 1: // Type
+						try {
+							return (IImage) cacheImages[Convert.parseInt(ch.type)];
+						} catch (NumberFormatException e) { return "?";}
+					case 2: // Difficulty;
+						return (String)ch.hard;
+					case 3: // Terrain
+						return (String)ch.terrain;
+					case 4: // Waypoint
+						if(ch.is_log_update) return new IconAndText((IImage)blue, ch.wayPoint, fm);
+						if(ch.is_update    ) return new IconAndText((IImage)red, ch.wayPoint, fm);
+						if(ch.is_new       ) return new IconAndText((IImage)yellow, ch.wayPoint, fm);
+						return (String)ch.wayPoint;
+					case 5: // Cachename
+						// Fast return for majority of case
+						if (ch.has_bug == false && ch.noFindLogs==0) return (String)ch.CacheName; 
+						// Now need more checks
+						IconAndText wpVal = new IconAndText();
+						if(ch.has_bug == true) wpVal.addColumn((IImage)bug);
+						if(ch.noFindLogs > 0){
+							if (ch.noFindLogs > noFindLogs.length) 
+								wpVal.addColumn((IImage)noFindLogs[noFindLogs.length-1]);
+							else 
+								wpVal.addColumn((IImage)noFindLogs[ch.noFindLogs-1]);
+						}
+						wpVal.addColumn((String)ch.CacheName);
+						return wpVal;
+					case 6: // Location
+						return (String)ch.LatLon;
+					case 7: // Owner
+						return (String)ch.CacheOwner;
+					case 8: // Date hidden
+						return (String)ch.DateHidden;
+					case 9: // Status
+						return (String)ch.CacheStatus;
+					case 10: // Distance
+						return (String)ch.distance;
+					case 11: // Bearing
+						return (String)ch.bearing;
 				}
 			}
-		return rettext;
+		}
+		return null;
 	}
 	
 	public boolean penPressed(Point onTable,Point cell){
 		boolean retval = false;
 		// Table header hit
 		try{
+			if (cell.y>=0) Global.mainTab.tbP.setSelectedCache(cell.y);
 			// Check whether the click is on the checkbox image
 			if (cell.y>=0 && cell.x==0) {
 				Global.getProfile().selectionChanged = true;
@@ -312,7 +272,8 @@
 				if (ch.hasAddiWpt()){
 					CacheHolder addiWpt;
 					int off = 1;
-					for (int i=0;i<ch.addiWpts.getCount();i++){
+					int addiCount=ch.addiWpts.getCount();
+					for (int i=0;i<addiCount;i++){
 						addiWpt = (CacheHolder)ch.addiWpts.get(i);
 						addiWpt.is_Checked = ch.is_Checked;
 						if (!addiWpt.is_filtered){
@@ -321,57 +282,31 @@
 					}
 					
 				}
-				//updateRows();
-				// Don't consume the event. Why ?
 			}
-			if(cell.y == -1){
-				if(sortAsc == false) sortAsc = true;
-				else sortAsc = false;
-				retval = true;
-				if(colName[cell.x].equals(nmDist) == false){
-					CacheHolder ch = new CacheHolder();
-					Vm.showWait(true);
-					Point a = new Point();
-					a = tcControl.getSelectedCell(a);
-					if(!(a == null)) ch = (CacheHolder)cacheDB.get(a.y);
+			if(cell.y == -1){ // Hit a header => sort the table accordingly
+				sortAsc=!sortAsc;
+				CacheHolder ch=null;
+				Vm.showWait(true);
+				Point a = tcControl.getSelectedCell(null);
+				if(a != null) ch = (CacheHolder)cacheDB.get(a.y);
+				if(colID[cell.x]!=10)
 					cacheDB.sort(new MyComparer(colName[cell.x]), sortAsc);
-					updateRows();
-					if(!(a == null)){
-						int rownum = Global.getProfile().getCacheIndex(ch.wayPoint);
-						if(rownum >= 0){
-							tcControl.scrollToVisible(rownum, 0);
-							tcControl.clearSelectedCells(new Vector());
-							for(int i= 0; i < 11; i++){
-								tcControl.addToSelection(rownum,i); 
-							}
-						}
-					}
-					Vm.showWait(false);
-				}
-				if(colName[cell.x].equals(nmDist)) {
-					CacheHolder ch = new CacheHolder();
-					Vm.showWait(true);
-					Point a = new Point();
-					Point dest = new Point();
-					a = tcControl.getSelectedCell(dest);
-					if(!(a == null)) ch = (CacheHolder)cacheDB.get(a.y);
+				else // Distance sort
 					cacheDB.sort(new DistComparer(), sortAsc);
-					updateRows();
-					if(!(a == null)){
-						int rownum = Global.getProfile().getCacheIndex(ch.wayPoint);
-						if(rownum >= 0){
-							tcControl.scrollToVisible(rownum, 0);
-							tcControl.clearSelectedCells(new Vector());
-							for(int i= 0; i < 11; i++){
-								tcControl.addToSelection(rownum,i); 
-							}
+				updateRows();
+				if(a != null){
+					int rownum = Global.getProfile().getCacheIndex(ch.wayPoint);
+					if(rownum >= 0){
+						tcControl.scrollToVisible(rownum, 0);
+						tcControl.clearSelectedCells(new Vector());
+						for(int i= 0; i < MAXCOLUMNS; i++){
+							tcControl.addToSelection(rownum,i); 
 						}
 					}
-					Vm.showWait(false);
 				}
-				updateRows();
+				Vm.showWait(false);
 				tcControl.update(true);
-				
+				retval = true;
 			}
 		}catch(NullPointerException npex){}
 		return retval;



From salzkammergut at mail.berlios.de  Sun Feb 11 22:06:30 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 11 Feb 2007 22:06:30 +0100
Subject: [Cachewolf-svn] r562 - trunk/src/CacheWolf
Message-ID: <200702112106.l1BL6ULl021640@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-11 22:06:18 +0100 (Sun, 11 Feb 2007)
New Revision: 562

Removed:
   trunk/src/CacheWolf/DistComparer.java
Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/MyComparer.java
   trunk/src/CacheWolf/myTableModel.java
Log:
MyComparer: Bugfix Datumssortierung
DistComparer in MyComparer integriert
Wesentlich schneller durch Setzen eines Sortierfeldes VOR dem Sortieren


Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-02-11 19:34:09 UTC (rev 561)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-02-11 21:06:18 UTC (rev 562)
@@ -70,6 +70,7 @@
   public boolean is_Checked = false;
   public Vector addiWpts = new Vector();
   public CacheHolder mainCache;
+  public String sort;
     
   
   /**

Deleted: trunk/src/CacheWolf/DistComparer.java
===================================================================
--- trunk/src/CacheWolf/DistComparer.java	2007-02-11 19:34:09 UTC (rev 561)
+++ trunk/src/CacheWolf/DistComparer.java	2007-02-11 21:06:18 UTC (rev 562)
@@ -1,41 +0,0 @@
-package CacheWolf;
-import ewe.util.*;
-import ewe.sys.*;
-
-/**
-*	This class handles sorting of caches according to distance.
-*	All other sorts are handled by MyComparer.
-*	@see MyComparer
-*/
-public class DistComparer implements Comparer{
-	Locale l = Vm.getLocale();
-	
-	public int compare(Object o1, Object o2){
-		int ret = 0;
-		CacheHolder oo1 = (CacheHolder)o1;
-		CacheHolder oo2 = (CacheHolder)o2;
-		if(oo1.is_filtered == false && oo2.is_filtered == false){
-			String strA = new String();
-			String strB = new String();
-			if (oo1.distance.length()>2)strA = oo1.distance.substring(0,oo1.distance.length()-3); //Bugfix 9531 if added
-			if (oo2.distance.length()>2)strB = oo2.distance.substring(0,oo2.distance.length()-3); //Bugfix 9531 if added
-			/*
-			if(l.getString(Locale.LANGUAGE_SHORT ,0,0).equals("DE")){
-				//Vm.debug(strA);
-				strA = strA.replace(',', '.');
-				strB = strB.replace(',', '.');
-			}*/
-			double A = Common.parseDouble(strA);
-			double B = Common.parseDouble(strB);
-			if(A >= B) ret =  -1;
-			if(A < B) ret =  1;
-			return ret;
-		} else {
-			int retval = 0;
-			if(oo1.is_filtered == false && oo2.is_filtered == true) retval = -1;
-			if(oo1.is_filtered == true && oo2.is_filtered == false) retval = 1;
-			
-			return retval;
-		}
-	}
-}

Modified: trunk/src/CacheWolf/MyComparer.java
===================================================================
--- trunk/src/CacheWolf/MyComparer.java	2007-02-11 19:34:09 UTC (rev 561)
+++ trunk/src/CacheWolf/MyComparer.java	2007-02-11 21:06:18 UTC (rev 562)
@@ -10,93 +10,102 @@
 */
 public class MyComparer implements Comparer{
 	String compareWhat;
-	Locale l = Vm.getLocale();
-	LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
 	String nmQuest, nmD,nmT,nmWay,nmName,nmLoc,nmOwn,nmHid,nmStat,nmDist,nmBear = new String();
+	int visibleSize;
+	Vector cacheDB;
 	
 	public MyComparer(String what){
 		compareWhat = what;
 		nmQuest = "?";
-		nmD = (String)lr.get(1000,"D");
-		nmT = (String)lr.get(1001,"T");
-		nmWay = (String)lr.get(1002,"Waypoint");
-		nmName = (String)lr.get(1003,"Name");
-		nmLoc = (String)lr.get(1004,"Location");
-		nmOwn = (String)lr.get(1005,"Owner");
-		nmHid = (String)lr.get(1006,"Hidden");
-		nmStat = (String)lr.get(1007,"Status");
-		nmDist = (String)lr.get(1008,"Dist");
-		nmBear = (String)lr.get(1009,"Bear");
+		nmD = MyLocale.getMsg(1000,"D");
+		nmT = MyLocale.getMsg(1001,"T");
+		nmWay = MyLocale.getMsg(1002,"Waypoint");
+		nmName = MyLocale.getMsg(1003,"Name");
+		nmLoc = MyLocale.getMsg(1004,"Location");
+		nmOwn = MyLocale.getMsg(1005,"Owner");
+		nmHid = MyLocale.getMsg(1006,"Hidden");
+		nmStat = MyLocale.getMsg(1007,"Status");
+		nmDist = MyLocale.getMsg(1008,"Dist");
+		nmBear = MyLocale.getMsg(1009,"Bear");
+		visibleSize=Global.mainTab.tbP.myMod.numRows;
+		cacheDB=Global.getProfile().cacheDB;
+		if (visibleSize<2) return;
+		if (what.equals(nmQuest)) {
+			for (int i=0; i<visibleSize; i++) {
+				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				ch.sort=ch.type;
+			}
+		} else if (what.equals(nmD)) {
+			for (int i=0; i<visibleSize; i++) {
+				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				ch.sort=ch.hard;
+			}
+		} else if (what.equals(nmT)) {
+			for (int i=0; i<visibleSize; i++) {
+				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				ch.sort=ch.terrain;
+			}
+		} else if (what.equals(nmWay)) {
+			for (int i=0; i<visibleSize; i++) {
+				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				ch.sort=ch.wayPoint;
+			}
+		} else if (what.equals(nmName)) {
+			for (int i=0; i<visibleSize; i++) {
+				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				ch.sort=ch.CacheName;
+			}
+		} else if (what.equals(nmLoc)) {
+			for (int i=0; i<visibleSize; i++) {
+				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				ch.sort=ch.LatLon;
+			}
+		} else if (what.equals(nmOwn)) {
+			for (int i=0; i<visibleSize; i++) {
+				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				ch.sort=ch.CacheOwner;
+			}
+		} else if (what.equals(nmHid)) {
+			for (int i=0; i<visibleSize; i++) {
+				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				// Dates are in format M/D/Y
+				int p1,p2=-1;
+				p1=ch.DateHidden.indexOf("/");
+				if (p1>0) p2=ch.DateHidden.indexOf("/",p1+1);
+				if (p1>0 && p2>0) {
+					ch.sort=ch.DateHidden.substring(p2+1)+
+					        (p1==1?"0":"")+ch.DateHidden.substring(0,p1)+
+					        (p1+2==p2?"0":"")+ch.DateHidden.substring(p1+1,p2);
+				} else
+					ch.sort="";
+			}
+		} else if (what.equals(nmStat)) {
+			for (int i=0; i<visibleSize; i++) {
+				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				ch.sort=ch.CacheStatus;
+			}
+		} else if (what.equals(nmDist)) {
+			for (int i=0; i<visibleSize; i++) {
+				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				int p=ch.distance.indexOf(",");
+				if (p<0) p=ch.distance.indexOf(".");
+				if (p>=0 && p<=5)
+					ch.sort="00000".substring(0,5-p)+ch.distance;
+				else
+					ch.sort=ch.distance;
+			}
+		} else if (what.equals(nmBear)) {
+			for (int i=0; i<visibleSize; i++) {
+				CacheHolder ch=(CacheHolder) cacheDB.get(i);
+				ch.sort=ch.bearing;
+			}
+			
+		}
 	}
 	
 	public int compare(Object o1, Object o2){
 		CacheHolder oo1 = (CacheHolder)o1;
 		CacheHolder oo2 = (CacheHolder)o2;
-		if(oo1.is_filtered == false && oo2.is_filtered == false){
-			String str01 = new String();
-			String str02 = new String();
-			try{
-				if(compareWhat.equals(nmQuest)){
-					str01 = oo1.type;
-					str02 = oo2.type;
-				}
-				if(compareWhat.equals(nmD)){
-					str01 = oo1.hard;
-					str02 = oo2.hard;
-				}
-				if(compareWhat.equals(nmT)){
-					str01 = oo1.terrain;
-					str02 = oo2.terrain;
-				}
-				if(compareWhat.equals(nmWay)){
-					str01 = oo1.wayPoint;
-					str02 = oo2.wayPoint;
-				}
-				if(compareWhat.equals(nmName)){
-					str01 = oo1.CacheName;
-					str02 = oo2.CacheName;
-				}
-				if(compareWhat.equals(nmLoc)){
-					str01 = oo1.LatLon;
-					str02 = oo2.LatLon;
-				}
-				if(compareWhat.equals(nmOwn)){
-					str01 = oo1.CacheOwner;
-					str02 = oo2.CacheOwner;
-				}
-				if(compareWhat.equals(nmHid)){
-					if (oo1.DateHidden.length() > 9) {
-						str01 = oo1.DateHidden.substring(6,10);   // year
-						str01 += oo1.DateHidden.substring(0,2);   // month
-						str01 += oo1.DateHidden.substring(3,5); } // day 
-					if (oo2.DateHidden.length() > 9) {
-						str02 = oo2.DateHidden.substring(6,10);   // year
-						str02 += oo2.DateHidden.substring(0,2);   // month
-						str02 += oo2.DateHidden.substring(3,5); } // day
-				}
-				if(compareWhat.equals(nmStat)){
-					str01 = oo1.CacheStatus;
-					str02 = oo2.CacheStatus;
-				}
-				if(compareWhat.equals(nmBear)){
-					str01 = oo1.bearing;
-					str02 = oo2.bearing;
-				}
-				if(compareWhat.equals("filter")){
-					str01 = Convert.toString(oo1.is_filtered);
-					str02 = Convert.toString(oo2.is_filtered);
-				}
-				return str01.toLowerCase().compareTo(str02.toLowerCase());
-			} catch (IndexOutOfBoundsException e ) { // sollte eigentlich nicht vorkommen k?nnte auftreten von substring
-				return str01.toLowerCase().compareTo(str02.toLowerCase());
-			}
-
-		} else{
-			int retval = 0;
-			if(oo1.is_filtered == false && oo2.is_filtered == true) retval = -1;
-			if(oo1.is_filtered == true && oo2.is_filtered == false) retval = 1;
-
-			return retval;
-		}
+		return oo1.sort.compareTo(oo2.sort);
 	}
 }

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-02-11 19:34:09 UTC (rev 561)
+++ trunk/src/CacheWolf/myTableModel.java	2007-02-11 21:06:18 UTC (rev 562)
@@ -289,10 +289,7 @@
 				Vm.showWait(true);
 				Point a = tcControl.getSelectedCell(null);
 				if(a != null) ch = (CacheHolder)cacheDB.get(a.y);
-				if(colID[cell.x]!=10)
-					cacheDB.sort(new MyComparer(colName[cell.x]), sortAsc);
-				else // Distance sort
-					cacheDB.sort(new DistComparer(), sortAsc);
+				cacheDB.sort(new MyComparer(colName[cell.x]), sortAsc);
 				updateRows();
 				if(a != null){
 					int rownum = Global.getProfile().getCacheIndex(ch.wayPoint);



From pfeffer at mail.berlios.de  Sun Feb 11 22:09:09 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 11 Feb 2007 22:09:09 +0100
Subject: [Cachewolf-svn] r563 - trunk/src/CacheWolf
Message-ID: <200702112109.l1BL99ck021832@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-11 22:09:06 +0100 (Sun, 11 Feb 2007)
New Revision: 563

Modified:
   trunk/src/CacheWolf/InfoBox.java
   trunk/src/CacheWolf/OCXMLImporter.java
Log:
Download von Opencaching: Warnungen werden nun in einer Liste angezeigt, nicht mehr f?\195?\188r jede ein extra Fenster
Download von Opencaching: Code zum Download von Karten vollst?\195?\164ndig auskommentiert

Modified: trunk/src/CacheWolf/InfoBox.java
===================================================================
--- trunk/src/CacheWolf/InfoBox.java	2007-02-11 21:06:18 UTC (rev 562)
+++ trunk/src/CacheWolf/InfoBox.java	2007-02-11 21:09:06 UTC (rev 563)
@@ -3,77 +3,114 @@
 import ewe.sys.*;
 
 public class InfoBox extends Form{
-	Locale l = Vm.getLocale();
-	LocalResource lr = l.getLocalResource("cachewolf.Languages",true);
-	MessageArea msgArea;
+	TextMessage msgArea;
 	mCheckBox mCB;
+	TextMessage warnings;
 	public boolean mCB_state = false;
 	mButton mB = new mButton("OK");
 	mButton mC = new mButton("Cancel");
 	mInput feedback = new mInput();
 	public final static int CHECKBOX = 1;
 	public final static int INPUT = 2;
+	public final static int DISPLAY_ONLY = 3;
+	public final static int PROGRESS_WITH_WARNINGS = 4;
 	private int type = 0;
-		
+
 	public InfoBox(String title, String info){
-		this.setPreferredSize(170,50);
+		this(title, info, DISPLAY_ONLY);
+
+		/*this.setPreferredSize(170,50);
 		this.title = title;
-		this.addLast(msgArea = new MessageArea(""), CellConstants.STRETCH, CellConstants.FILL);
+		msgArea = new MessageArea(""), CellConstants.STRETCH, CellConstants.FILL)
+		this.addLast(scP = new ScrollBarPanel(msgArea));
 		msgArea.setText(info);
 		mB.setHotKey(0, IKeys.ACTION);
 		mB.setHotKey(0, IKeys.ENTER);
 		//mB.set(Control.Invisible, true);
 		//this.addLast(mB, CellConstants.STRETCH, CellConstants.FILL);
+		 */
+	}
 
-	}
-	
 	public String getInput(){
 		return feedback.getText();
 	}
-	
+
 	public void addText(String t) {
 		msgArea.setText(msgArea.text + t);
 		this.repaintNow();
 	}
-	
+
 	public InfoBox(String title, String info, int ty){
+		this(title, info, ty, true);
+	}
+
+	public InfoBox(String title, String info, int ty, boolean autoWrap) {
 		type = ty;
-		this.setPreferredSize(150,50);
+		this.setPreferredSize(150,80);
 		this.title = title;
-		if(type == CHECKBOX){
+		switch (type) {
+		case CHECKBOX: 
 			mCB = new mCheckBox(info);
 			this.addLast(mCB, CellConstants.STRETCH, CellConstants.FILL);
-		}
-		if(type == INPUT){
+			break;
+		case INPUT:
 			mLabel mL = new mLabel(info);
 			this.addNext(mL, CellConstants.STRETCH, CellConstants.FILL);
 			this.addLast(feedback, CellConstants.STRETCH, CellConstants.FILL);
+			break;
+		case DISPLAY_ONLY:
+			msgArea = new TextMessage(info);
+			msgArea.autoWrap = autoWrap;
+			this.addLast(msgArea.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
+			break;
+		case PROGRESS_WITH_WARNINGS:
+			msgArea = new TextMessage(info);
+			msgArea.autoWrap = autoWrap;
+			msgArea.setPreferredSize(150, 80);
+			this.addLast(msgArea.getScrollablePanel(), CellConstants.HEXPAND | CellConstants.HGROW, CellConstants.HEXPAND | CellConstants.HGROW);
+			warnings = new TextMessage("");
+			warnings.autoWrap = autoWrap;
+			this.addLast(warnings.getScrollablePanel(), CellConstants.HEXPAND | CellConstants.VEXPAND |CellConstants.VGROW, CellConstants.HEXPAND | CellConstants.VEXPAND |CellConstants.VGROW);
+			mB.set(Control.Disabled, true);
+			mB.setPreferredSize(40, 20);
+			addLast(mB, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+			break;
 		}
 		mC.setHotKey(0, IKeys.ESCAPE);
-		this.addNext(mC, CellConstants.STRETCH, CellConstants.FILL);
 		mB.setHotKey(0, IKeys.ACTION);
 		mB.setHotKey(0, IKeys.ENTER);
-		this.addLast(mB, CellConstants.STRETCH, CellConstants.FILL);
+		if (ty == CHECKBOX || ty == INPUT) {
+			this.addNext(mC, CellConstants.STRETCH, CellConstants.FILL);
+			this.addLast(mB, CellConstants.STRETCH, CellConstants.FILL);
+		}
 	}
-	
+
 	public void setInfo(String info){
 		msgArea.setText(info);
 		this.repaintNow();
 	}
-	
-/*	public void addOkButton() { unfortunately this doesn't work
+
+	public void addWarning (String w) {
+		warnings.setText(warnings.text + w);
+	}
+	public void addOkButton() { //unfortunately this doesn't work
+		mB.set(Control.Disabled, false);
+		//addNext(mB);
+		//relayout(true);
 		//mB.set(Control.Invisible, false);
 		this.repaintNow();
 	}
-*/
+
 	public void onEvent(Event ev){
-		if(ev.target == mB){
-			if(type == CHECKBOX) mCB_state = mCB.getState();
-			this.close(Form.IDOK);
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
+			if(ev.target == mB){
+				if(type == CHECKBOX) mCB_state = mCB.getState();
+				this.close(Form.IDOK);
+			}
+			if(ev.target == mC){
+				this.close(Form.IDCANCEL);
+			}
 		}
-		if(ev.target == mC){
-			this.close(Form.IDCANCEL);
-		}
 		super.onEvent(ev);
 	}
 }
\ No newline at end of file

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-02-11 21:06:18 UTC (rev 562)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-02-11 21:09:06 UTC (rev 563)
@@ -31,6 +31,7 @@
 	boolean debugGPX = false;
 	Vector cacheDB;
 	InfoBox inf;
+	String Warnings = new String();
 	CacheHolder holder;
 	Preferences pref;
 	Profile profile;
@@ -119,8 +120,9 @@
 			url +="&charset=utf-8";
 			url +="&cdata=0";
 			url +="&session=0";
-			inf = new InfoBox("Opencaching download", MyLocale.getMsg(1608,"downloading data\n from opencaching"));
-			inf.setPreferredSize(210, 120);
+			inf = new InfoBox("Opencaching download", MyLocale.getMsg(1608,"downloading data\n from opencaching"), InfoBox.PROGRESS_WITH_WARNINGS, false);
+			inf.setPreferredSize(220, 300);
+			inf.relayout(false);
 			inf.exec();
 			//Vm.debug(url);
 			//get file
@@ -148,25 +150,25 @@
 			}
 			zif.close();
 		}catch (ZipException e){
-			finalMessage=MyLocale.getMsg(1614,"Error while unzipping udpate file");
+			finalMessage = MyLocale.getMsg(1614,"Error while unzipping udpate file");
 			success = false;
 		}catch (IOException e){
-			if (e.getMessage().equalsIgnoreCase("no updates available")) { finalMessage="No updates available"; success = false; }
+			if (e.getMessage().equalsIgnoreCase("no updates available")) { finalMessage = "No updates available"; success = false; }
 			else {
 			if (e.getMessage().equalsIgnoreCase("could not connect") ||
 					e.getMessage().equalsIgnoreCase("unkown host")) { // is there a better way to find out what happened?
-				finalMessage=MyLocale.getMsg(1616,"Error: could not download udpate file from opencaching.de");
+				finalMessage = MyLocale.getMsg(1616,"Error: could not download udpate file from opencaching.de");
 			} else { finalMessage = "IOException: "+e.getMessage(); }
 			success = false;
 			}
 		}catch (IllegalArgumentException e) {
-			finalMessage=MyLocale.getMsg(1621,"Error parsing update file\n this is likely a bug in opencaching.de\nplease try again later\n, state:")+" "+state+", waypoint: "+ holder.wayPoint;
+			finalMessage = MyLocale.getMsg(1621,"Error parsing update file\n this is likely a bug in opencaching.de\nplease try again later\n, state:")+" "+state+", waypoint: "+ holder.wayPoint;
 			success = false;
 			Vm.debug("Parse error: " + state + " " + holder.wayPoint);
 			e.printStackTrace();
 		}catch (Exception e){ // here schould be used the correct exepion
-			if (holder != null)	finalMessage=MyLocale.getMsg(1615,"Error parsing update file, state:")+" "+state+", waypoint: "+ holder.wayPoint;
-			else finalMessage=MyLocale.getMsg(1615,"Error parsing update file, state:")+" "+state+", waypoint: <unkown>";
+			if (holder != null)	finalMessage = MyLocale.getMsg(1615,"Error parsing update file, state:")+" "+state+", waypoint: "+ holder.wayPoint;
+			else finalMessage = MyLocale.getMsg(1615,"Error parsing update file, state:")+" "+state+", waypoint: <unkown>";
 			success = false;
 			Vm.debug("Parse error: " + state + " " + holder.wayPoint);
 			e.printStackTrace();
@@ -176,11 +178,13 @@
 			profile.last_sync_opencaching = dateOfthisSync.format("yyyyMMddHHmmss");
 			//pref.savePreferences();
 			profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
-			finalMessage=MyLocale.getMsg(1607,"Update from opencaching successful");
+			finalMessage = MyLocale.getMsg(1607,"Update from opencaching successful");
 		}
-		inf.close(0);
-		MessageBox mb = new MessageBox("Opencaching",finalMessage,MessageBox.OKB);
-		mb.execute();
+		inf.setInfo(finalMessage);
+		inf.addOkButton();
+		//inf.close(0);
+//		MessageBox mb = new MessageBox("Opencaching",finalMessage,MessageBox.OKB);
+	//	mb.execute();
 	}
 	
 	public void startElement(String name, AttributeList atts){
@@ -275,7 +279,7 @@
 
 	}
 	private void startCacheDesc(String name, AttributeList atts){
-		inf.setInfo(MyLocale.getMsg(1611,"Importing cache description:")+" " + numDescImported);
+		inf.setInfo(MyLocale.getMsg(1611,"Importing cache description:")+" " + numDescImported + Warnings);
 		if (name.equals("cachedesc")){
 			ignoreDesc = false;
 		}
@@ -292,12 +296,12 @@
 	
 	private void startPicture(String name, AttributeList atts){
 		if(name.equals("picture")){
-			inf.setInfo(MyLocale.getMsg(1613,"Pictures:")+" " + ++picCnt);
+			inf.setInfo(MyLocale.getMsg(1613,"Pictures:")+" " + ++picCnt + Warnings);
 		}
 	}
 
 	private void startCacheLog(String name, AttributeList atts){
-		inf.setInfo(MyLocale.getMsg(1612,"Importing Cachlog:")+" " + numLogImported);
+		inf.setInfo(MyLocale.getMsg(1612,"Importing Cachlog:")+" " + numLogImported + Warnings);
 		if (name.equals("logtype")){
 			if(atts.getValue("id").equals("1")) logIcon = GPXImporter.typeText2Image("Found");
 			if(atts.getValue("id").equals("2")) {
@@ -337,12 +341,13 @@
 				holder.Images.clear();
 				holder.ImagesText.clear();
 			}
-			if(holder.LatLon.length() > 1 && holder.is_archived == false &&
+/*			if(holder.LatLon.length() > 1 && holder.is_archived == false &&
 					pref.downloadMapsOC){
 				
 				ParseLatLon pll = new ParseLatLon(holder.LatLon,".");
 				pll.parse();
-				MapLoader mpl = new MapLoader(pref.myproxy, pref.myproxyport);
+				
+ 				MapLoader mpl = new MapLoader(pref.myproxy, pref.myproxyport);
 				// MapLoader tests itself if the file already exists and doesnt download if so.
 				String filename = Global.getPref().baseDir + "/maps/expedia/" + holder.wayPoint + "_map.gif";
 				if (!(new File(filename).getParentFile().isDirectory())) { // dir exists? 
@@ -361,7 +366,8 @@
 					inf.setInfo(MyLocale.getMsg(1609,"Importing Cache: ")+" " + numCacheImported + "\n"+MyLocale.getMsg(1610,"Downloading missing map")+" 2");
 					//mpl.loadTo(filename, "10"); 
 					}
-			}
+			} */
+
 			// save all
 			holder.saveCacheDetails(profile.dataDir);
 			profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
@@ -429,7 +435,7 @@
 							(new MessageBox(MyLocale.getMsg(144, "Warning"),MyLocale.getMsg(1617, "Ignoriere Fehler in html-Cache-Description: \"<img\" without \"src=\" in cache "+holder.wayPoint), MessageBox.OKB)).exec();
 							continue;
 						}
-						inf.setInfo(MyLocale.getMsg(1611,"Importing cache description:")+" " + numDescImported + "\n"+MyLocale.getMsg(1620, "downloading embedded images: ") + numDownloaded++);
+						inf.setInfo(MyLocale.getMsg(1611,"Importing cache description:")+" " + numDescImported + "\n"+MyLocale.getMsg(1620, "downloading embedded images: ") + numDownloaded++ + Warnings);
 						if (imgRegexAlt.search(imgTag)) {
 							imgAltText=imgRegexAlt.stringMatched(1);
 							if (imgAltText==null)	imgAltText=imgRegexAlt.stringMatched(2);
@@ -488,12 +494,13 @@
 				}
 			}
 		} catch (IOException e) {
-			String ErrMessage = new String ("Ignoring IOException: "+e.getMessage())+ "\nwhile downloading picture:"+fileName+"\nfrom URL:"+fetchURL+"\nin cache: "+holder.wayPoint; 
+			String ErrMessage = new String (MyLocale.getMsg(1618,"Ignoring error in cache: ") + holder.wayPoint + ": ignoring IOException: "+e.getMessage()+ " while downloading picture:"+fileName+" from URL:"+fetchURL); 
 			if (e.getMessage().toLowerCase().equalsIgnoreCase("could not connect") ||
 					e.getMessage().equalsIgnoreCase("unkown host")) { // is there a better way to find out what happened?
-				ErrMessage=MyLocale.getMsg(1618,"Ignoring error in cache ")+holder.wayPoint+MyLocale.getMsg(1619,": could not download image from URL: ")+fetchURL;
+				ErrMessage = MyLocale.getMsg(1618,"Ignoring error in cache: ")+holder.wayPoint+MyLocale.getMsg(1619,": could not download image from URL: ")+fetchURL;
 			} 
-			(new MessageBox(MyLocale.getMsg(144, "Warning"), ErrMessage, MessageBox.OKB)).exec();
+			inf.addWarning("\n"+ErrMessage);
+			//(new MessageBox(MyLocale.getMsg(144, "Warning"), ErrMessage, MessageBox.OKB)).exec();
 			Vm.debug("Could not load Image " + fetchURL);
 			e.printStackTrace();
 		}



From pfeffer at mail.berlios.de  Sun Feb 11 22:33:51 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 11 Feb 2007 22:33:51 +0100
Subject: [Cachewolf-svn] r564 - trunk/src/CacheWolf
Message-ID: <200702112133.l1BLXp2M023153@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-11 22:33:45 +0100 (Sun, 11 Feb 2007)
New Revision: 564

Modified:
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/OCXMLImporter.java
Log:
Download von Opencaching: Anzeige des Cachenamens in Fehler
MovingMap: in bestimmten F?\195?\164llen wurde die Karte ?\195?\188ber Detailspanel nicht angezeigt

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-02-11 21:09:06 UTC (rev 563)
+++ trunk/src/CacheWolf/MainTab.java	2007-02-11 21:33:45 UTC (rev 564)
@@ -224,7 +224,8 @@
 		mm.myExec();
 		if (forceCenter) {
 			while (MapImage.screenDim.width == 0) { try {ewe.sys.mThread.sleep(100);} catch (InterruptedException e) {} } // wait until the window size of the moving map is known note: ewe.sys.sleep() will pause the whole vm - no other thread will run
-			mm.setCenterOfScreen(centerTo, true); // this can only be executed if mm knows its window size that's why myExec must be executed before
+			mm.setCenterOfScreen(centerTo, false); // this can only be executed if mm knows its window size that's why myExec must be executed before
+			mm.updatePosition(centerTo.latDec, centerTo.lonDec);
 /*			if(!mm.posCircle.isOnScreen()) { // TODO this doesn't work because lat lon is set to the wished pos and not to gps anymore
 				mm.setGpsStatus(MovingMap.noGPS); // disconnect movingMap from GPS if GPS-pos is not on the screen
 				mm.setResModus(MovingMap.HIGHEST_RESOLUTION);

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-02-11 21:09:06 UTC (rev 563)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-02-11 21:33:45 UTC (rev 564)
@@ -478,7 +478,7 @@
 		}
 	}
 	
-	private void getPic(String fetchURL, String picDesc){
+	private void getPic(String fetchURL, String picDesc){ // TODO handling of relativ URLs
 		String fileName = holder.wayPoint + "_" + fetchURL.substring(fetchURL.lastIndexOf("/")+1);
 		fileName = Common.ClearForFileName(fileName);
 		// add title
@@ -497,7 +497,7 @@
 			String ErrMessage = new String (MyLocale.getMsg(1618,"Ignoring error in cache: ") + holder.wayPoint + ": ignoring IOException: "+e.getMessage()+ " while downloading picture:"+fileName+" from URL:"+fetchURL); 
 			if (e.getMessage().toLowerCase().equalsIgnoreCase("could not connect") ||
 					e.getMessage().equalsIgnoreCase("unkown host")) { // is there a better way to find out what happened?
-				ErrMessage = MyLocale.getMsg(1618,"Ignoring error in cache: ")+holder.wayPoint+MyLocale.getMsg(1619,": could not download image from URL: ")+fetchURL;
+				ErrMessage = MyLocale.getMsg(1618,"Ignoring error in cache: ")+holder.CacheName + " ("+holder.wayPoint+")"+MyLocale.getMsg(1619,": could not download image from URL: ")+fetchURL;
 			} 
 			inf.addWarning("\n"+ErrMessage);
 			//(new MessageBox(MyLocale.getMsg(144, "Warning"), ErrMessage, MessageBox.OKB)).exec();



From salzkammergut at mail.berlios.de  Sun Feb 11 23:14:19 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 11 Feb 2007 23:14:19 +0100
Subject: [Cachewolf-svn] r565 - trunk/src/CacheWolf
Message-ID: <200702112214.l1BMEJjb024546@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-11 23:14:15 +0100 (Sun, 11 Feb 2007)
New Revision: 565

Modified:
   trunk/src/CacheWolf/MyComparer.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/myTableModel.java
Log:
Nachtrag zum Sortierer (Bugfix zum Bugfix)

Modified: trunk/src/CacheWolf/MyComparer.java
===================================================================
--- trunk/src/CacheWolf/MyComparer.java	2007-02-11 21:33:45 UTC (rev 564)
+++ trunk/src/CacheWolf/MyComparer.java	2007-02-11 22:14:15 UTC (rev 565)
@@ -14,7 +14,7 @@
 	int visibleSize;
 	Vector cacheDB;
 	
-	public MyComparer(String what){
+	public MyComparer(Vector cacheDB, String what, int visibleSize){
 		compareWhat = what;
 		nmQuest = "?";
 		nmD = MyLocale.getMsg(1000,"D");
@@ -27,9 +27,12 @@
 		nmStat = MyLocale.getMsg(1007,"Status");
 		nmDist = MyLocale.getMsg(1008,"Dist");
 		nmBear = MyLocale.getMsg(1009,"Bear");
-		visibleSize=Global.mainTab.tbP.myMod.numRows;
-		cacheDB=Global.getProfile().cacheDB;
+		//visibleSize=Global.mainTab.tbP.myMod.numRows;
 		if (visibleSize<2) return;
+		for (int i=visibleSize; i<cacheDB.size(); i++) {
+			CacheHolder ch=(CacheHolder) cacheDB.get(i);
+			ch.sort="\uFFFF";
+		}
 		if (what.equals(nmQuest)) {
 			for (int i=0; i<visibleSize; i++) {
 				CacheHolder ch=(CacheHolder) cacheDB.get(i);
@@ -63,7 +66,7 @@
 		} else if (what.equals(nmOwn)) {
 			for (int i=0; i<visibleSize; i++) {
 				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=ch.CacheOwner;
+				ch.sort=ch.CacheOwner.toLowerCase();
 			}
 		} else if (what.equals(nmHid)) {
 			for (int i=0; i<visibleSize; i++) {

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-02-11 21:33:45 UTC (rev 564)
+++ trunk/src/CacheWolf/Profile.java	2007-02-11 22:14:15 UTC (rev 565)
@@ -400,7 +400,7 @@
 		for(int i =  0; i < max ;i++){
 			ch = (CacheHolder)cacheDB.get(i);
 			if (ch.hasAddiWpt() && (ch.addiWpts.size()> 1)){
-				ch.addiWpts.sort(new MyComparer(MyLocale.getMsg(1002,"Waypoint")), false);
+				ch.addiWpts.sort(new MyComparer(ch.addiWpts,MyLocale.getMsg(1002,"Waypoint"),ch.addiWpts.size()), false);
 			}
 		}
 	

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-02-11 21:33:45 UTC (rev 564)
+++ trunk/src/CacheWolf/myTableModel.java	2007-02-11 22:14:15 UTC (rev 565)
@@ -289,7 +289,7 @@
 				Vm.showWait(true);
 				Point a = tcControl.getSelectedCell(null);
 				if(a != null) ch = (CacheHolder)cacheDB.get(a.y);
-				cacheDB.sort(new MyComparer(colName[cell.x]), sortAsc);
+				cacheDB.sort(new MyComparer(cacheDB, colName[cell.x],numRows), sortAsc);
 				updateRows();
 				if(a != null){
 					int rownum = Global.getProfile().getCacheIndex(ch.wayPoint);



From pfeffer at mail.berlios.de  Mon Feb 12 00:17:35 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Mon, 12 Feb 2007 00:17:35 +0100
Subject: [Cachewolf-svn] r566 - trunk/src/CacheWolf
Message-ID: <200702112317.l1BNHZDh027471@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-12 00:17:32 +0100 (Mon, 12 Feb 2007)
New Revision: 566

Modified:
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/SpiderGC.java
Log:
SpiderGC: Bug fixed: nicht gesetzte Addi-WayPoints bekommen jetz 361/91 statt 0/0
Download von Opencaching: Bug fixed: relativer Pfad bei Bildern wird richtig aufgel?\195?\182st, wenn relativ zu www.opencaching.de
MovingMap: Bug fixed: Aufruf aus DetailsPanel bei nicht gesetzten Koos nicht m?\195?\182glich.

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-02-11 22:14:15 UTC (rev 565)
+++ trunk/src/CacheWolf/MainTab.java	2007-02-11 23:17:32 UTC (rev 566)
@@ -126,7 +126,7 @@
 		} else	
 			select(detP);
 		Global.mainTab.tbP.refreshTable();
-	
+
 	}
 
 
@@ -214,6 +214,10 @@
 	 * @param forceCenter
 	 */
 	public void SwitchToMovingMap(CWPoint centerTo, boolean forceCenter) {
+		if (!centerTo.isValid()) {
+			(new MessageBox("Error", "No valid coordinates", MessageBox.OKB)).execute();
+			return;
+		}
 		if (mm == null) {
 			mm = new MovingMap(nav, profile.cacheDB);
 			nav.setMovingMap(mm);
@@ -223,26 +227,28 @@
 		mm.updatePosition(centerTo.latDec, centerTo.lonDec);
 		mm.myExec();
 		if (forceCenter) {
-			while (MapImage.screenDim.width == 0) { try {ewe.sys.mThread.sleep(100);} catch (InterruptedException e) {} } // wait until the window size of the moving map is known note: ewe.sys.sleep() will pause the whole vm - no other thread will run
-			mm.setCenterOfScreen(centerTo, false); // this can only be executed if mm knows its window size that's why myExec must be executed before
-			mm.updatePosition(centerTo.latDec, centerTo.lonDec);
-/*			if(!mm.posCircle.isOnScreen()) { // TODO this doesn't work because lat lon is set to the wished pos and not to gps anymore
+			try {
+				while (MapImage.screenDim.width == 0) { ewe.sys.mThread.sleep(100);} // wait until the window size of the moving map is known note: ewe.sys.sleep() will pause the whole vm - no other thread will run 
+				mm.setCenterOfScreen(centerTo, false); // this can only be executed if mm knows its window size that's why myExec must be executed before
+				mm.updatePosition(centerTo.latDec, centerTo.lonDec);
+				/*			if(!mm.posCircle.isOnScreen()) { // TODO this doesn't work because lat lon is set to the wished pos and not to gps anymore
 				mm.setGpsStatus(MovingMap.noGPS); // disconnect movingMap from GPS if GPS-pos is not on the screen
 				mm.setResModus(MovingMap.HIGHEST_RESOLUTION);
 				mm.updatePosition(centerTo.latDec, centerTo.lonDec);
 				mm.setCenterOfScreen(centerTo, true); 
 			}
-*/			//TODO what to do, if there is a map at centerTo, but it is not loaded because of mapSwitchMode == dest & cuurpos und daf?r gibt es keine Karte 
+				 */			//TODO what to do, if there is a map at centerTo, but it is not loaded because of mapSwitchMode == dest & cuurpos und daf?r gibt es keine Karte 
+			}catch (InterruptedException e) { (new MessageBox("Error", "This must not happen please report to pfeffer how to produce this error message", MessageBox.OKB)).execute(); } 
 		}
 	}
-	
+
 	/** Save any changes from DetailsPanel before operating on the database */
 	public void updatePendingChanges() {
 		if(detP.isDirty()) {
 			detP.saveDirtyWaypoint();
 		}
 	}
-	
+
 	/** Save the index file and any pending change in DetailsPanel
 	 * 
 	 * @param askForConfirmation If true, the save can be cancelled by user
@@ -252,7 +258,7 @@
 		updatePendingChanges(); // Updated the cacheDB with pending changes from DetailsPanel
 		if (askForConfirmation) { // Don't know whether to save, have to ask
 			if (profile.hasUnsavedChanges &&     // Only ask if there were changes 
-				(new MessageBox(MyLocale.getMsg(144,"Warnung"),MyLocale.getMsg(1207,"Your profile has unsaved changes. Do you want to save?"),MessageBox.DEFOKB|MessageBox.NOB)).execute()==MessageBox.IDOK) {
+					(new MessageBox(MyLocale.getMsg(144,"Warnung"),MyLocale.getMsg(1207,"Your profile has unsaved changes. Do you want to save?"),MessageBox.DEFOKB|MessageBox.NOB)).execute()==MessageBox.IDOK) {
 				saveIndex=true; 
 			}
 		}

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-02-11 22:14:15 UTC (rev 565)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-02-11 23:17:32 UTC (rev 566)
@@ -25,6 +25,7 @@
 	static protected final int STAT_CACHE_LOG = 3;
 	static protected final int STAT_PICTURE = 4;
 	
+	final static String OPENCACHING_HOST = "www.opencaching.de";
 	int state = STAT_INIT;
 	int numCacheImported, numDescImported, numLogImported= 0;
 	
@@ -46,7 +47,7 @@
 	String picUrl = new String();
 	String picTitle =  new String();
 	String picID = new String();
-	String ocSeekUrl = new String("http://www.opencaching.de/viewcache.php?cacheid=");
+	String ocSeekUrl = new String("http://"+OPENCACHING_HOST+"/viewcache.php?cacheid=");
 	String cacheID = new String();
 	
 	String logData, logIcon, logDate, logFinder;
@@ -107,7 +108,7 @@
 			}	
 			picCnt = 0;
 			//Build url
-			url ="http://www.opencaching.de/xml/ocxml11.php?";
+			url ="http://+" + OPENCACHING_HOST + "/xml/ocxml11.php?";
 			url += "modifiedsince=" + lastS;
 			url +="&cache=1";
 			url +="&cachedesc=1";
@@ -479,6 +480,7 @@
 	}
 	
 	private void getPic(String fetchURL, String picDesc){ // TODO handling of relativ URLs
+		if (!fetchURL.startsWith("http://")) fetchURL = "http://" + OPENCACHING_HOST + "/"+fetchURL; // TODO this is not quite correct: actually the "base" URL must be known... but anyway a different baseURL should not happen very often  - it doesn't in my area
 		String fileName = holder.wayPoint + "_" + fetchURL.substring(fetchURL.lastIndexOf("/")+1);
 		fileName = Common.ClearForFileName(fileName);
 		// add title

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-02-11 22:14:15 UTC (rev 565)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-02-11 23:17:32 UTC (rev 566)
@@ -443,7 +443,7 @@
 				typeRex.search(rowBlock);
 				cx.CacheName = nameRex.stringMatched(1);
 				if(koordRex.didMatch()) cx.LatLon = koordRex.stringMatched(1); 
-				else cx.LatLon = "N 00? 00.000 E 000? 00.000"; 
+				else cx.LatLon = "---"; 
 				cx.pos.set(cx.LatLon);
 				if(typeRex.didMatch()) cx.type = CacheType.typeText2Number("Waypoint|"+typeRex.stringMatched(1));
 				



From pfeffer at mail.berlios.de  Mon Feb 12 00:52:57 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Mon, 12 Feb 2007 00:52:57 +0100
Subject: [Cachewolf-svn] r567 - trunk/src/CacheWolf
Message-ID: <200702112352.l1BNqvPE001113@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-12 00:52:51 +0100 (Mon, 12 Feb 2007)
New Revision: 567

Modified:
   trunk/src/CacheWolf/InfoBox.java
Log:
InfoBox sieht jetzt wieder so aus, wie vor den commits von mir: wieder alles zentriert

Modified: trunk/src/CacheWolf/InfoBox.java
===================================================================
--- trunk/src/CacheWolf/InfoBox.java	2007-02-11 23:17:32 UTC (rev 566)
+++ trunk/src/CacheWolf/InfoBox.java	2007-02-11 23:52:51 UTC (rev 567)
@@ -42,11 +42,13 @@
 
 	public InfoBox(String title, String info, int ty){
 		this(title, info, ty, true);
+		this.setPreferredSize(170, 50);
+		relayout(false);
 	}
 
 	public InfoBox(String title, String info, int ty, boolean autoWrap) {
 		type = ty;
-		this.setPreferredSize(150,80);
+		this.setPreferredSize(150,50);
 		this.title = title;
 		switch (type) {
 		case CHECKBOX: 
@@ -61,12 +63,14 @@
 		case DISPLAY_ONLY:
 			msgArea = new TextMessage(info);
 			msgArea.autoWrap = autoWrap;
+			msgArea.alignment = Gui.CENTER;
+			msgArea.anchor = Gui.CENTER;
 			this.addLast(msgArea.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
 			break;
 		case PROGRESS_WITH_WARNINGS:
 			msgArea = new TextMessage(info);
 			msgArea.autoWrap = autoWrap;
-			msgArea.setPreferredSize(150, 80);
+			msgArea.setPreferredSize(150, 50);
 			this.addLast(msgArea.getScrollablePanel(), CellConstants.HEXPAND | CellConstants.HGROW, CellConstants.HEXPAND | CellConstants.HGROW);
 			warnings = new TextMessage("");
 			warnings.autoWrap = autoWrap;



From pfeffer at mail.berlios.de  Mon Feb 12 01:24:36 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Mon, 12 Feb 2007 01:24:36 +0100
Subject: [Cachewolf-svn] r568 - trunk/src/CacheWolf
Message-ID: <200702120024.l1C0OasJ008530@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-12 01:24:34 +0100 (Mon, 12 Feb 2007)
New Revision: 568

Modified:
   trunk/src/CacheWolf/InfoBox.java
   trunk/src/CacheWolf/OCXMLImporter.java
Log:
Opencaching-Download: Bug-fixed, den ich vorher durch Tippfehler eingebaut hatte

Modified: trunk/src/CacheWolf/InfoBox.java
===================================================================
--- trunk/src/CacheWolf/InfoBox.java	2007-02-11 23:52:51 UTC (rev 567)
+++ trunk/src/CacheWolf/InfoBox.java	2007-02-12 00:24:34 UTC (rev 568)
@@ -70,6 +70,8 @@
 		case PROGRESS_WITH_WARNINGS:
 			msgArea = new TextMessage(info);
 			msgArea.autoWrap = autoWrap;
+			msgArea.alignment = Gui.CENTER;
+			msgArea.anchor = Gui.CENTER;
 			msgArea.setPreferredSize(150, 50);
 			this.addLast(msgArea.getScrollablePanel(), CellConstants.HEXPAND | CellConstants.HGROW, CellConstants.HEXPAND | CellConstants.HGROW);
 			warnings = new TextMessage("");

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-02-11 23:52:51 UTC (rev 567)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-02-12 00:24:34 UTC (rev 568)
@@ -108,7 +108,7 @@
 			}	
 			picCnt = 0;
 			//Build url
-			url ="http://+" + OPENCACHING_HOST + "/xml/ocxml11.php?";
+			url ="http://" + OPENCACHING_HOST + "/xml/ocxml11.php?";
 			url += "modifiedsince=" + lastS;
 			url +="&cache=1";
 			url +="&cachedesc=1";



From pfeffer at mail.berlios.de  Mon Feb 12 02:48:57 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Mon, 12 Feb 2007 02:48:57 +0100
Subject: [Cachewolf-svn] r569 - trunk/src/CacheWolf
Message-ID: <200702120148.l1C1mvXG014636@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-12 02:48:54 +0100 (Mon, 12 Feb 2007)
New Revision: 569

Modified:
   trunk/src/CacheWolf/NewProfileForm.java
   trunk/src/CacheWolf/OCXMLImporter.java
Log:
Opencaching-Download: Bug fixed: nur noch wirklich gefundene fuehren zu gruener gefundenen Markierung, nicht mehr unabhaengig vom Typ des Logeintrage
New Profile: Hotkeys gesetzt

Modified: trunk/src/CacheWolf/NewProfileForm.java
===================================================================
--- trunk/src/CacheWolf/NewProfileForm.java	2007-02-12 00:24:34 UTC (rev 568)
+++ trunk/src/CacheWolf/NewProfileForm.java	2007-02-12 01:48:54 UTC (rev 569)
@@ -4,6 +4,8 @@
 import ewe.ui.ControlEvent;
 import ewe.ui.Event;
 import ewe.ui.Form;
+import ewe.ui.IKeys;
+import ewe.ui.KeyEvent;
 import ewe.ui.MessageBox;
 import ewe.ui.mButton;
 import ewe.ui.mInput;
@@ -20,8 +22,12 @@
 		//profile=prof;
         title = MyLocale.getMsg(1111,"Create new profile:");
 		addLast(inpDir=new mInput(MyLocale.getMsg(1112,"New profile name")),HSTRETCH,HFILL|LEFT);
-		addNext(btnCancel=new mButton(MyLocale.getMsg(708,"Cancel")),HSTRETCH,LEFT);
-		addLast(btnOK=new mButton(MyLocale.getMsg(1605,"OK")),HSTRETCH,HFILL|RIGHT);
+		btnCancel = new mButton(MyLocale.getMsg(708,"Cancel"));
+		btnCancel.setHotKey(0, IKeys.ESCAPE);
+		addNext(btnCancel,HSTRETCH,LEFT);
+		btnOK = new mButton(MyLocale.getMsg(1605,"OK"));
+		btnOK.setHotKey(0, IKeys.ENTER);
+		addLast(btnOK,HSTRETCH,HFILL|RIGHT);
 		this.setPreferredSize(240,50);
 		this.baseDir=baseDir;
 	}

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-02-12 00:24:34 UTC (rev 568)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-02-12 01:48:54 UTC (rev 569)
@@ -12,27 +12,26 @@
 import ewe.net.*;
 
 /**
-*	Class to import Data from opencaching.de. 
-*	It uses the lastmodified parameter to identify new or changed caches.
-*	See here: http://www.opencaching.com/phpBB2/viewtopic.php?t=281 (out-dated)
-*   See here: http://www.opencaching.de/doc/xml/xml11.htm and http://develforum.opencaching.de/viewtopic.php?t=135&postdays=0&postorder=asc&start=0
-*	for more information.
-*/
+ *	Class to import Data from opencaching.de. 
+ *	It uses the lastmodified parameter to identify new or changed caches.
+ *	See here: http://www.opencaching.com/phpBB2/viewtopic.php?t=281 (out-dated)
+ *   See here: http://www.opencaching.de/doc/xml/xml11.htm and http://develforum.opencaching.de/viewtopic.php?t=135&postdays=0&postorder=asc&start=0
+ *	for more information.
+ */
 public class OCXMLImporter extends MinML {
 	static protected final int STAT_INIT = 0;
 	static protected final int STAT_CACHE = 1;
 	static protected final int STAT_CACHE_DESC = 2;
 	static protected final int STAT_CACHE_LOG = 3;
 	static protected final int STAT_PICTURE = 4;
-	
+
 	final static String OPENCACHING_HOST = "www.opencaching.de";
 	int state = STAT_INIT;
 	int numCacheImported, numDescImported, numLogImported= 0;
-	
+
 	boolean debugGPX = false;
 	Vector cacheDB;
 	InfoBox inf;
-	String Warnings = new String();
 	CacheHolder holder;
 	Preferences pref;
 	Profile profile;
@@ -43,24 +42,25 @@
 	boolean ignoreDesc = false;
 	Hashtable DBindexWpt = new Hashtable();
 	Hashtable DBindexID = new Hashtable();
-	
+
 	String picUrl = new String();
 	String picTitle =  new String();
 	String picID = new String();
 	String ocSeekUrl = new String("http://"+OPENCACHING_HOST+"/viewcache.php?cacheid=");
 	String cacheID = new String();
-	
+
 	String logData, logIcon, logDate, logFinder;
+	int logtype;
 	String user;
-	
 
+
 	public OCXMLImporter(Preferences p,Profile prof)
 	{
 		pref = p;
 		profile=prof;
 		cacheDB = profile.cacheDB;
 		if(profile.last_sync_opencaching == null ||
-			profile.last_sync_opencaching.length() < 12){
+				profile.last_sync_opencaching.length() < 12){
 			profile.last_sync_opencaching = "20050801000000";
 			incUpdate = false;
 		}
@@ -71,9 +71,9 @@
 			DBindexWpt.put((String)ch.wayPoint, new Integer(i));
 			DBindexID.put((String)ch.ocCacheID, new Integer(i));
 		}//for
-		
+
 	}
-	
+
 	public void doIt(){
 		String finalMessage = new String();
 		boolean success=true;
@@ -81,18 +81,18 @@
 			BufferedReader r;
 			String file = new String();
 			String url = new String();
-			
+
 			String lastS =  profile.last_sync_opencaching;
 			CWPoint center = pref.curCentrePt; // No need to clone curCentrePt as center is only read
 
 			OCXMLImporterScreen importOpt = new OCXMLImporterScreen( MyLocale.getMsg(1600, "Opencaching.de Download"),OCXMLImporterScreen.ALL);
 			if (importOpt.execute() == OCXMLImporterScreen.IDCANCEL) {	return; }
-    		Vm.showWait(true);
+			Vm.showWait(true);
 			String dist = importOpt.distanceInput.getText();
 			if (dist.length()== 0) return;
 			//check, if distance is greater than before
 			if (Convert.toInt(dist) > Convert.toInt(profile.distOC) ||
-			  pref.downloadmissingOC  ){
+					pref.downloadmissingOC  ){
 				// resysnc
 				lastS = "20050801000000";
 				incUpdate = false;
@@ -129,11 +129,11 @@
 			//get file
 			file = fetch(url, "dummy");
 			//file = "628-0-1.zip";
-			
+
 			//parse
 			File tmpFile = new File(profile.dataDir + file);
 			if (tmpFile.getLength() == 0 ) throw new IOException("no updates available");
-			
+
 			ZipFile zif = new ZipFile (profile.dataDir + file);
 			ZipEntry zipEnt;
 			Enumeration zipEnum = zif.entries();
@@ -156,11 +156,11 @@
 		}catch (IOException e){
 			if (e.getMessage().equalsIgnoreCase("no updates available")) { finalMessage = "No updates available"; success = false; }
 			else {
-			if (e.getMessage().equalsIgnoreCase("could not connect") ||
-					e.getMessage().equalsIgnoreCase("unkown host")) { // is there a better way to find out what happened?
-				finalMessage = MyLocale.getMsg(1616,"Error: could not download udpate file from opencaching.de");
-			} else { finalMessage = "IOException: "+e.getMessage(); }
-			success = false;
+				if (e.getMessage().equalsIgnoreCase("could not connect") ||
+						e.getMessage().equalsIgnoreCase("unkown host")) { // is there a better way to find out what happened?
+					finalMessage = MyLocale.getMsg(1616,"Error: could not download udpate file from opencaching.de");
+				} else { finalMessage = "IOException: "+e.getMessage(); }
+				success = false;
 			}
 		}catch (IllegalArgumentException e) {
 			finalMessage = MyLocale.getMsg(1621,"Error parsing update file\n this is likely a bug in opencaching.de\nplease try again later\n, state:")+" "+state+", waypoint: "+ holder.wayPoint;
@@ -185,9 +185,9 @@
 		inf.addOkButton();
 		//inf.close(0);
 //		MessageBox mb = new MessageBox("Opencaching",finalMessage,MessageBox.OKB);
-	//	mb.execute();
+		//	mb.execute();
 	}
-	
+
 	public void startElement(String name, AttributeList atts){
 		if (debugGPX){
 			for (int i = 0; i < atts.getLength(); i++) {
@@ -212,28 +212,28 @@
 		// look for changes in the state
 		if (name.equals("cache")) 		{ state = STAT_CACHE; numCacheImported++;}
 		if (name.equals("cachedesc")) 	{ state = STAT_CACHE_DESC; numDescImported++;}
-		if (name.equals("cachelog")) 	{ state = STAT_CACHE_LOG; numLogImported++;}
+		if (name.equals("cachelog")) 	{ state = STAT_CACHE_LOG; numLogImported++; logtype = 0;}
 		if (name.equals("picture")) 	{ state = STAT_PICTURE; }
 
 		//examine data
 		switch (state) {
-			case STAT_CACHE: startCache(name, atts); break;
-			case STAT_CACHE_DESC: startCacheDesc(name, atts); break; 
-			case STAT_CACHE_LOG: startCacheLog(name, atts); break;
-			case STAT_PICTURE: startPicture(name,atts); break;
+		case STAT_CACHE: startCache(name, atts); break;
+		case STAT_CACHE_DESC: startCacheDesc(name, atts); break; 
+		case STAT_CACHE_LOG: startCacheLog(name, atts); break;
+		case STAT_PICTURE: startPicture(name,atts); break;
 		}
-		
+
 	}
-	
+
 	public void endElement(String name){
 		//examine data
 		switch (state) {
-			case STAT_CACHE: endCache(name); break;
-			case STAT_CACHE_DESC: endCacheDesc(name);break;
-			case STAT_CACHE_LOG: endCacheLog(name); break;
-			case STAT_PICTURE: endPicture(name); break;
+		case STAT_CACHE: endCache(name); break;
+		case STAT_CACHE_DESC: endCacheDesc(name);break;
+		case STAT_CACHE_LOG: endCacheLog(name); break;
+		case STAT_PICTURE: endPicture(name); break;
 		}
-		
+
 		// look for changes in the state
 		if (name.equals("cache")) 		state = STAT_INIT;
 		if (name.equals("cachedesc")) 	state = STAT_INIT;
@@ -271,7 +271,7 @@
 			holder.CacheSize = transSize(atts.getValue("id"));
 			return;
 		}
-		
+
 		if(name.equals("waypoints")){
 			holder.wayPoint = atts.getValue("oc");
 			if (holder.wayPoint.length()==0) throw new IllegalArgumentException("empty waypointname"); // this should not happen - it is likey a bug in opencaching.de / it happens on 27-12-2006 on cache OC143E
@@ -280,11 +280,11 @@
 
 	}
 	private void startCacheDesc(String name, AttributeList atts){
-		inf.setInfo(MyLocale.getMsg(1611,"Importing cache description:")+" " + numDescImported + Warnings);
+		inf.setInfo(MyLocale.getMsg(1611,"Importing cache description:")+" " + numDescImported);
 		if (name.equals("cachedesc")){
 			ignoreDesc = false;
 		}
-		
+
 		if (name.equals("desc")){
 			holder.is_HTML = atts.getValue("html").equals("1")?true:false;
 		}
@@ -294,22 +294,30 @@
 			else ignoreDesc = false;
 		}
 	}
-	
+
 	private void startPicture(String name, AttributeList atts){
 		if(name.equals("picture")){
-			inf.setInfo(MyLocale.getMsg(1613,"Pictures:")+" " + ++picCnt + Warnings);
+			inf.setInfo(MyLocale.getMsg(1613,"Pictures:")+" " + ++picCnt);
 		}
 	}
 
 	private void startCacheLog(String name, AttributeList atts){
-		inf.setInfo(MyLocale.getMsg(1612,"Importing Cachlog:")+" " + numLogImported + Warnings);
+		inf.setInfo(MyLocale.getMsg(1612,"Importing Cachlog:")+" " + numLogImported);
 		if (name.equals("logtype")){
-			if(atts.getValue("id").equals("1")) logIcon = GPXImporter.typeText2Image("Found");
-			if(atts.getValue("id").equals("2")) {
-				logIcon = GPXImporter.typeText2Image("Not Found");
-				holder.noFindLogs += 1;
+			logtype = Convert.toInt(atts.getValue("id"));
+			switch (logtype) {
+			case 1: 
+				logIcon = GPXImporter.typeText2Image("Found"); 
+				if (logFinder.equalsIgnoreCase(user)) { // see also endCacheLog
+					holder.is_found = true;
+					holder.CacheStatus = MyLocale.getMsg(318,"Found");
+				}
+				break;
+			case 2:	logIcon = GPXImporter.typeText2Image("Not Found"); 
+			holder.noFindLogs += 1;
+			break;
+			case 3: logIcon = GPXImporter.typeText2Image("Note");
 			}
-			if(atts.getValue("id").equals("3")) logIcon = GPXImporter.typeText2Image("Note");
 			return;
 		}
 
@@ -318,7 +326,7 @@
 		File myfile = new File(filename);
 		return myfile.exists();
 	}
-	
+
 	private void endCache(String name){
 		if (name.equals("cache")){
 			int index;
@@ -342,12 +350,12 @@
 				holder.Images.clear();
 				holder.ImagesText.clear();
 			}
-/*			if(holder.LatLon.length() > 1 && holder.is_archived == false &&
+			/*			if(holder.LatLon.length() > 1 && holder.is_archived == false &&
 					pref.downloadMapsOC){
-				
+
 				ParseLatLon pll = new ParseLatLon(holder.LatLon,".");
 				pll.parse();
-				
+
  				MapLoader mpl = new MapLoader(pref.myproxy, pref.myproxyport);
 				// MapLoader tests itself if the file already exists and doesnt download if so.
 				String filename = Global.getPref().baseDir + "/maps/expedia/" + holder.wayPoint + "_map.gif";
@@ -436,7 +444,7 @@
 							(new MessageBox(MyLocale.getMsg(144, "Warning"),MyLocale.getMsg(1617, "Ignoriere Fehler in html-Cache-Description: \"<img\" without \"src=\" in cache "+holder.wayPoint), MessageBox.OKB)).exec();
 							continue;
 						}
-						inf.setInfo(MyLocale.getMsg(1611,"Importing cache description:")+" " + numDescImported + "\n"+MyLocale.getMsg(1620, "downloading embedded images: ") + numDownloaded++ + Warnings);
+						inf.setInfo(MyLocale.getMsg(1611,"Importing cache description:")+" " + numDescImported + "\n"+MyLocale.getMsg(1620, "downloading embedded images: ") + numDownloaded++);
 						if (imgRegexAlt.search(imgTag)) {
 							imgAltText=imgRegexAlt.stringMatched(1);
 							if (imgAltText==null)	imgAltText=imgRegexAlt.stringMatched(2);
@@ -461,12 +469,12 @@
 				holder.is_update = true;
 				return;
 			}
-	
+
 			if (name.equals("shortdesc")){
 				holder.LongDescription = strData;
 				return;
 			}
-			
+
 			if (name.equals("desc")){
 				if (holder.is_HTML)	holder.LongDescription +=SafeXML.cleanback(strData);
 				else holder.LongDescription +=strData;
@@ -478,7 +486,7 @@
 			}
 		}
 	}
-	
+
 	private void getPic(String fetchURL, String picDesc){ // TODO handling of relativ URLs
 		if (!fetchURL.startsWith("http://")) fetchURL = "http://" + OPENCACHING_HOST + "/"+fetchURL; // TODO this is not quite correct: actually the "base" URL must be known... but anyway a different baseURL should not happen very often  - it doesn't in my area
 		String fileName = holder.wayPoint + "_" + fetchURL.substring(fetchURL.lastIndexOf("/")+1);
@@ -508,15 +516,15 @@
 		}
 
 	}
-	
 
+
 	private void endPicture(String name){
 
 		if(name.equals("id")){
 			picID = strData;
 			return;
 		}
-		
+
 		if (name.equals("url")){
 			picUrl = strData;
 			return;
@@ -550,15 +558,15 @@
 			holder = getHolder(strData);
 			return;
 		}
-		
+
 		if (name.equals("date"))  {
 			logDate = new String(strData);
 			return;
 		}
 		if (name.equals("userid")){
 			logFinder = new String(strData);
-			if(logFinder.toLowerCase().compareTo(user) == 0){
-				holder.is_found = true;
+			if(logFinder.toLowerCase().compareTo(user) == 0 && logtype == 1){
+				holder.is_found = true; // see startCacheLog - in the current .xml this is set by startCacheLog but we sequence in the xml from opencaching might change, so I leave this also here
 				holder.CacheStatus = MyLocale.getMsg(318,"Found");
 			}
 			return;
@@ -567,62 +575,62 @@
 			logData = new String(strData);
 			return;
 		}
-		
+
 	}
-	
+
 	private String fetch(String addr, String fileName ) throws IOException
-	   	{
-			final int maxRedirections = 5;
-			//Vm.debug(address);
-			HttpConnection conn = null;
-			Socket sock = null;
-			int i=-1;
-			String address = new String(addr);
-			while (address != null && i <= maxRedirections ) { // allow max 5 redirections (http 302 location)
-				i++;
-				if(pref.myproxy.length() > 0){
-					conn = new HttpConnection(pref.myproxy, Convert.parseInt(pref.myproxyport), address);
-					Vm.debug("Proxy here: " + address);
-				} else {
-					conn = new HttpConnection(address);
-				}
-				conn.setRequestorProperty("USER_AGENT", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0");
-				conn.setRequestorProperty("Connection", "close");
-				conn.documentIsEncoded = true;
-				sock = conn.connect();
-				address = conn.getRedirectTo();
-				if (address != null){
-					if (holder != null) fileName = holder.wayPoint + "_" + Common.ClearForFileName(address.substring(address.lastIndexOf("/")+1));
-					else fileName = Common.ClearForFileName(address.substring(address.lastIndexOf("/")+1));
-				}
+	{
+		final int maxRedirections = 5;
+		//Vm.debug(address);
+		HttpConnection conn = null;
+		Socket sock = null;
+		int i=-1;
+		String address = new String(addr);
+		while (address != null && i <= maxRedirections ) { // allow max 5 redirections (http 302 location)
+			i++;
+			if(pref.myproxy.length() > 0){
+				conn = new HttpConnection(pref.myproxy, Convert.parseInt(pref.myproxyport), address);
+				Vm.debug("Proxy here: " + address);
+			} else {
+				conn = new HttpConnection(address);
 			}
-			if (i > maxRedirections) throw new IOException("too many http redirections while trying to fetch: "+addr + " only "+maxRedirections+" are allowed");
-			//Vm.debug("Redirect: " + redirect);
-			ByteArray daten = conn.readData(sock);
-			
-			//save file
-			//Vm.debug("Save: " + myPref.mydatadir + fileName);
-			//Vm.debug("Daten: " + daten.length);
-			BufferedOutputStream outp =  new BufferedOutputStream(new FileOutputStream(profile.dataDir + fileName));
-			outp.write(daten.toBytes());
-			outp.close();
-			sock.close();
-			return fileName;
+			conn.setRequestorProperty("USER_AGENT", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0");
+			conn.setRequestorProperty("Connection", "close");
+			conn.documentIsEncoded = true;
+			sock = conn.connect();
+			address = conn.getRedirectTo();
+			if (address != null){
+				if (holder != null) fileName = holder.wayPoint + "_" + Common.ClearForFileName(address.substring(address.lastIndexOf("/")+1));
+				else fileName = Common.ClearForFileName(address.substring(address.lastIndexOf("/")+1));
+			}
 		}
-		
-			
+		if (i > maxRedirections) throw new IOException("too many http redirections while trying to fetch: "+addr + " only "+maxRedirections+" are allowed");
+		//Vm.debug("Redirect: " + redirect);
+		ByteArray daten = conn.readData(sock);
+
+		//save file
+		//Vm.debug("Save: " + myPref.mydatadir + fileName);
+		//Vm.debug("Daten: " + daten.length);
+		BufferedOutputStream outp =  new BufferedOutputStream(new FileOutputStream(profile.dataDir + fileName));
+		outp.write(daten.toBytes());
+		outp.close();
+		sock.close();
+		return fileName;
+	}
+
+
 	/**
-	*	Method to translate opencaching size types to geocaching types.
-	*	Required to be "backwards" compatible :-(
-	*	OC	GC	Comment	Rule
-	*	1	5	other size	1->5
-	*	2 	1	micro		2->1
-	*	3 	2	small		3->2
-	*	4	3	normal		4->3
-	*	5 	4	large		5->4
-	*	6	6	very large	6->6
-	*	7	7	no container	7->7
-	*/
+	 *	Method to translate opencaching size types to geocaching types.
+	 *	Required to be "backwards" compatible :-(
+	 *	OC	GC	Comment	Rule
+	 *	1	5	other size	1->5
+	 *	2 	1	micro		2->1
+	 *	3 	2	small		3->2
+	 *	4	3	normal		4->3
+	 *	5 	4	large		5->4
+	 *	6	6	very large	6->6
+	 *	7	7	no container	7->7
+	 */
 	private String transSize(String type){
 		if(type.equals("1")) return "Other";
 		if(type.equals("2")) return "Micro";
@@ -633,22 +641,22 @@
 		if(type.equals("7")) return "None";
 		return "0";
 	}
-	
+
 	/**
-	* Method to iterate through cache database and look for waypoint.
-	* Returns value >= 0 if waypoint is found, else -1
-	*/
+	 * Method to iterate through cache database and look for waypoint.
+	 * Returns value >= 0 if waypoint is found, else -1
+	 */
 	private int searchWpt(String wpt){
 		Integer INTR = (Integer)DBindexWpt.get(wpt);
 		if(INTR != null){
 			return INTR.intValue();
 		} else return -1;
 	}
-	
+
 	/**
-	* Method to iterate through cache database and look for cacheID.
-	* Returns value >= 0 if cacheID is found, else -1
-	*/
+	 * Method to iterate through cache database and look for cacheID.
+	 * Returns value >= 0 if cacheID is found, else -1
+	 */
 	private int searchID(String cacheID){
 		Integer INTR = (Integer)DBindexID.get(cacheID);
 		if(INTR != null){
@@ -660,7 +668,7 @@
 	private CacheHolder getHolder(String CacheID){
 		int index;
 		CacheHolder ch;
-		
+
 		index = searchID(CacheID);
 		if (index == -1){
 			ch = new CacheHolder();
@@ -674,5 +682,5 @@
 		return ch;
 	}
 
-	
+
 }
\ No newline at end of file



From admin at berlios.de  Mon Feb 12 02:54:08 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 12 Feb 2007 02:54:08 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #9979] Spider arbeitet fehlerhaft
Message-ID: <200702120154.l1C1s8V9024082@unicorn.berlios.de>

Bug #9979, was updated on 2007-Jan-14 19:36
Here is a current snapshot of the bug.

Project: CacheWolf
Category: None
Status: Open
Resolution: None
Bug Group: Ready to test
Priority: 5
Submitted by: cw-tester
Assigned to : bilbowolf
Summary: Spider arbeitet fehlerhaft

Details: Sowohl bei OC als auch GC wird fehlerhaft gespidert.
Der eingegebene Radius wird nicht eingehalten. Als Ergebnis wirden mehr Caches gespidert als gew?nscht.
Dar?ber hinaus werden einige Add-WP mit den Koordinaten N 00? 00.000 E 00? 00.000. Eine Systematik kann ich nicht erkennen.

Follow-Ups:

Date: 2007-Feb-12 02:54
By: pfeffer

Comment:
die Koordinaten mit lat/lon = 0/0 habe ich grad behoben (SVN 566)
Bei Opencaching wird nicht wirklich in einem Kreis herum alle caches geholt, sondern in einem Rechteck um den angegebenen Punkt herum. Dadurch sind Cache, die in den Ecken liegen etwas weiter weg als wenn es ein Kreis w?re.
Vermutlich ist der Rechen- und Programmieraufwand bei Opencaching.de daf?r zu gro? und es lohnt nicht wirklich, das auf einen Kreis einzuschr?nken, oder?

Gru?,
   Pfeffer.
-------------------------------------------------------

Date: 2007-Jan-15 21:42
By: bilbowolf

Comment:
Dass einige Addi WP mit "0" Koord angezeigt werden ist einfach. Diese haben einfach keine Koordinaten...

Oder habe ich was falsch verstanden.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9979&group_id=2211


From admin at berlios.de  Mon Feb 12 02:55:25 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 12 Feb 2007 02:55:25 +0100 (CET)
Subject: [Cachewolf-svn] [Bug #9752] sonderzeichen
Message-ID: <200702120155.l1C1tPkg026276@unicorn.berlios.de>

Bug #9752, was updated on 2006-Dec-17 22:21
Here is a current snapshot of the bug.

Project: CacheWolf
Category: 0.9m
Status: Open
Resolution: None
Bug Group: Ready to test
Priority: 5
Submitted by: greiol
Assigned to : none
Summary: sonderzeichen

Details: 0.9m schafft es bei (leider unregelm??ig) cachnamen zu verst?mmeln, die "sonderzeichen" enthalten. klassiker sind die umlaute sowie ' & < und > . irgendwann, beim xten import eines gpx files wird zerst?ckelt. leider ist es noch nicht einmal immer das erste oder das letzte dieser zeichen wobei diese positionen schon recht h?ufig betroffen sind.

Follow-Ups:

Date: 2007-Feb-12 02:55
By: pfeffer

Comment:
d?rften l?ngst keine Probleme mehr machen
-------------------------------------------------------

Date: 2007-Jan-06 16:40
By: greiol

Comment:
fangen wir mal mit was einfachem und sauber reproduzierbaren an.

ein gepx das diese caches enth?lt:
http://www.geocaching.com/seek/nearest.aspx?key=gc+by+emzett
-------------------------------------------------------

Date: 2007-Jan-06 16:17
By: greiol

Comment:
"beim xten import eines gpx files"
-------------------------------------------------------

Date: 2007-Jan-06 16:10
By: salzkammergut

Comment:
Wo genau werden Cachenamen verst?mmelt?

Beim Spidern?
Beim Einlesen von GPX Dateien?
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=9752&group_id=2211


From admin at berlios.de  Mon Feb 12 02:58:10 2007
From: admin at berlios.de (admin at berlios.de)
Date: Mon, 12 Feb 2007 02:58:10 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2731] MovingMap: Karten laden
Message-ID: <200702120158.l1C1wAvm029925@unicorn.berlios.de>

Feature Request #2731, was updated on 2006-Sep-30 19:36
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2731&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: MovingMap: Karten laden 

By: pfeffer
Date: 2006-Dec-03 15:50

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1) Gecko/20061010 Firefox/2.0

in der Liste wird nun angezeigt, welche Karten
a) den Gotopunkt und die GPS-Pos enthalten
b) die GPS-Pos enthalten
c)  den GFotoPunkt enthalten
d) alle anderen Karten

----------------------------------------------------------------------

By: pfeffer
Date: 2006-Dec-02 03:31

Message:
Logged In: YES 
user_id=30639
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1) Gecko/20061010 Firefox/2.0

so, diesen Komplex habe ich etwas anders erledigt:
CW w?hlt immer automatisch eine Karte.
Bei GPS-Empfang die Karte, deren Mittelpunkt am n?chsten zum
GPS-Punkt liegt.
Wenn der GPS-Empfang nicht l?uft, dann zeigt CW stattdessen
die Karte, auf der der GOTO-Punkt zu sehen ist.

Mit klick links oben in der MovinMap auf die gelben Streifen
kann auch manuell eine Karte gew?hlt werden.

Gru?,
  Pfeffer.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2731&group_id=2211


From salzkammergut at mail.berlios.de  Mon Feb 12 18:56:11 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Mon, 12 Feb 2007 18:56:11 +0100
Subject: [Cachewolf-svn] r570 - trunk/src/CacheWolf
Message-ID: <200702121756.l1CHuB8b009087@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-12 18:56:01 +0100 (Mon, 12 Feb 2007)
New Revision: 570

Modified:
   trunk/src/CacheWolf/RadarPanel.java
Log:
RadarPanel: Fix. Blendet jetzt nur "is_filtered" Caches aus (keine "is_blacklist")
Dadurch koennen auch Blacklistcaches im Radar dargestellt werden

Modified: trunk/src/CacheWolf/RadarPanel.java
===================================================================
--- trunk/src/CacheWolf/RadarPanel.java	2007-02-12 01:48:54 UTC (rev 569)
+++ trunk/src/CacheWolf/RadarPanel.java	2007-02-12 17:56:01 UTC (rev 570)
@@ -129,7 +129,7 @@
 		double pi180=java.lang.Math.PI / 180.0;
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
 			holder = (CacheHolder)cacheDB.get(i);
-			if(!holder.is_black && !holder.is_filtered) {
+			if(!holder.is_filtered) {
 				degrees = holder.degrees * pi180;
 				x =new Float(holder.kilom/scale *  java.lang.Math.sin(degrees)).intValue();
 				y = -new Float(holder.kilom/scale *  java.lang.Math.cos(degrees)).intValue();



From salzkammergut at mail.berlios.de  Mon Feb 12 19:18:17 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Mon, 12 Feb 2007 19:18:17 +0100
Subject: [Cachewolf-svn] r571 - trunk/src/CacheWolf
Message-ID: <200702121818.l1CIIHwF011503@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-12 19:17:59 +0100 (Mon, 12 Feb 2007)
New Revision: 571

Modified:
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/myTableControl.java
Log:
Bugfix: Die Filter im Kontextmenue der Listenansicht und im Filtermenue ("Selektierte") sind jetzt inkremental, d.h.
sie bewahren den is_filtered Zustand fuer alle Caches die markiert bzw. nichtmarkiert sind.
So kann man sich eine beliebige eigene Auswahl zusammenfiltern


Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-02-12 17:56:01 UTC (rev 570)
+++ trunk/src/CacheWolf/MainMenu.java	2007-02-12 18:17:59 UTC (rev 571)
@@ -112,9 +112,9 @@
 		filterMenuItems[2] = filtInvert  = new MenuItem(MyLocale.getMsg(115,"Invert")); 
 		filterMenuItems[3] = filtClear   = new MenuItem(MyLocale.getMsg(116,"Clear"));
 		filterMenuItems[4] = mnuSeparator;
-		filterMenuItems[5] = filtBlack   = new MenuItem(MyLocale.getMsg(161,"Show Blacklist"));
+		filterMenuItems[5] = filtSelected = new MenuItem(MyLocale.getMsg(160,"Selected"));
 		filterMenuItems[6] = mnuSeparator;
-		filterMenuItems[7] = filtSelected = new MenuItem(MyLocale.getMsg(160,"Selected"));
+		filterMenuItems[7] = filtBlack   = new MenuItem(MyLocale.getMsg(161,"Show Blacklist"));
 		
 		///////////////////////////////////////////////////////////////////////
 		// Create a combined "Filter and Search" pulldown menu for devices with small screens
@@ -125,9 +125,9 @@
 		filterAndSearchMenuItems[2]=filtInvert;
 		filterAndSearchMenuItems[3]=filtClear;
 		filterAndSearchMenuItems[4]=mnuSeparator;
-		filterAndSearchMenuItems[5]=filtBlack;
-		filterAndSearchMenuItems[6]=filtSelected;
-		filterAndSearchMenuItems[7]=mnuSeparator;
+		filterAndSearchMenuItems[5]=filtSelected;
+		filterAndSearchMenuItems[6]=mnuSeparator;
+		filterAndSearchMenuItems[7]=filtBlack;
 		filterAndSearchMenuItems[8]=mnuSeparator;
 		filterAndSearchMenuItems[9]=search;
 		filterAndSearchMenuItems[10]=searchClr;
@@ -433,6 +433,16 @@
 				flt.clearFilter();
 				tbp.refreshTable();
 			}
+			if(mev.selectedItem == filtSelected){ // incremental filter
+				CacheHolder ch;
+				for(int i = cacheDB.size()-1; i>=0; i--){
+					ch = (CacheHolder)cacheDB.get(i);
+					// This is an incremental filter, i.e. it keeps the existing filter
+					// status and only adds the marked caches to the filtered set
+					ch.is_filtered = ch.is_Checked || ch.is_filtered;
+				}
+				tbp.refreshTable();
+			}
 			if(mev.selectedItem == filtBlack){
 				filtBlack.modifiers^=MenuItem.Checked;
 				Filter.showBlacklisted=!Filter.showBlacklisted;
@@ -440,15 +450,6 @@
 				ssc.clearSearch();// Clear search & restore filter status
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == filtSelected){
-				CacheHolder ch;
-				for(int i = cacheDB.size()-1; i>=0; i--){
-					ch = (CacheHolder)cacheDB.get(i);
-					ch.is_filtered = ch.is_Checked;
-					//cacheDB.set(i, ch);
-				}
-				tbp.refreshTable();
-			}
 			///////////////////////////////////////////////////////////////////////
 			// "Organize" pulldown menu
 			///////////////////////////////////////////////////////////////////////

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-02-12 17:56:01 UTC (rev 570)
+++ trunk/src/CacheWolf/myTableControl.java	2007-02-12 18:17:59 UTC (rev 571)
@@ -77,7 +77,9 @@
 		if (selectedItem.toString().equals(MyLocale.getMsg(1011,"Filter"))){
 			for(int i = cacheDB.size()-1; i >=0; i--){
 				ch = (CacheHolder)cacheDB.get(i);
-				ch.is_filtered = !ch.is_Checked;
+				// incremental filter. Keeps status of all marked caches and
+				// adds unmarked caches to filtered list
+				ch.is_filtered = !ch.is_Checked || ch.is_filtered;
 			}
 			tbp.refreshTable();
 		}



From salzkammergut at mail.berlios.de  Mon Feb 12 22:27:50 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Mon, 12 Feb 2007 22:27:50 +0100
Subject: [Cachewolf-svn] r572 - trunk/src/CacheWolf
Message-ID: <200702122127.l1CLRoKn023653@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-12 22:27:45 +0100 (Mon, 12 Feb 2007)
New Revision: 572

Modified:
   trunk/src/CacheWolf/Profile.java
Log:
Profile: Addi-Wpts Sortierung optimiert+andere kleine Optimierungen

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-02-12 18:17:59 UTC (rev 571)
+++ trunk/src/CacheWolf/Profile.java	2007-02-12 21:27:45 UTC (rev 572)
@@ -127,21 +127,16 @@
 					"\" var = \""+filterVar+"\" dist = \""+filterDist.replace('"',' ')+"\" diff = \""+
 					filterDiff+"\" terr = \""+filterTerr+"\" size = \""+filterSize+"\" />\n");
 			detfile.print("    <SYNCOC date = \""+last_sync_opencaching+"\" dist = \""+distOC+"\"/>\n");
-			for(int i = 0; i<cacheDB.size();i++){
+			int size=cacheDB.size();
+			for(int i = 0; i<size;i++){
 				if(showprogress){
-					h.progress = (float)i/(float)cacheDB.size();
+					h.progress = (float)i/(float)size;
 					h.changed();
 				}
 				ch = (CacheHolder)cacheDB.get(i);
 				////Vm.debug("Saving: " + ch.CacheName);
 				if(ch.wayPoint.length()>0 && ch.LongDescription.equals("An Error Has Occured") == false){
-					/* pos must always be set, so this is no longer needed
- 					if (ch.pos==null) {
-						ParseLatLon pl=new ParseLatLon(ch.LatLon);
-						pl.parse();
-						ch.pos=new CWPoint(pl.lat2,pl.lon2);
-					}
-					 */					detfile.print("    <CACHE name = \""+SafeXML.clean(ch.CacheName)+"\" owner = \""+SafeXML.clean(ch.CacheOwner)+
+					detfile.print("    <CACHE name = \""+SafeXML.clean(ch.CacheName)+"\" owner = \""+SafeXML.clean(ch.CacheOwner)+
 							 //"\" lat = \""+ SafeXML.clean(ch.LatLon) +
 							 "\" lat = \""+ ch.pos.latDec + "\" lon = \""+ch.pos.lonDec+
 							 "\" hidden = \""+ch.DateHidden+"\" wayp = \""+SafeXML.clean(ch.wayPoint)+"\" status = \""+ch.CacheStatus+"\" type = \""+ch.type+"\" dif = \""+ch.hard+"\" terrain = \"" + ch.terrain + "\" dirty = \"" + ch.dirty + "\" size = \""+ch.CacheSize+"\" online = \"" + Convert.toString(ch.is_available) + "\" archived = \"" + Convert.toString(ch.is_archived) + "\" has_bug = \"" + Convert.toString(ch.has_bug) + "\" black = \"" + Convert.toString(ch.is_black) + "\" owned = \"" + Convert.toString(ch.is_owned) + "\" found = \"" + Convert.toString(ch.is_found) + "\" is_new = \"" + Convert.toString(ch.is_new) +"\" is_log_update = \"" + Convert.toString(ch.is_log_update) + "\" is_update = \"" + Convert.toString(ch.is_update) + "\" is_HTML = \"" + Convert.toString(ch.is_HTML) + "\" DNFLOGS = \"" + ch.noFindLogs + "\" ocCacheID = \"" + ch.ocCacheID + "\" />\n");
@@ -149,7 +144,7 @@
 			}
 			detfile.print("</CACHELIST>\n");
 			detfile.close();
-			buildReferences();
+			buildReferences(); //TODO Why is this needed here?
 			if(showprogress) pbf.exit(0);
 		}catch(Exception e){
 			Vm.debug("Problem writing to index file "+e.toString());
@@ -253,11 +248,10 @@
 			// Build references between caches and addi wpts
 			buildReferences();
 		} catch (FileNotFoundException e) {
-			Vm.debug("index.xml not found"); // Normal when profile is opened for first time
+			Global.getPref().log("index.xml not found in directory "+dataDir); // Normal when profile is opened for first time
 			//e.printStackTrace();
 		} catch (IOException e){
-			Vm.debug("Problem reading index.xml "+e.toString()); 
-			e.printStackTrace();
+			Global.getPref().log("Problem reading index.xml in dir: "+dataDir,e,true); 
 		}
 		normalizeFilters();
 		hasUnsavedChanges=false;
@@ -314,7 +308,7 @@
 		if (cacheDB == null || cacheDB.size() == 0) return null;
 		CacheHolder ch;
 		CWPoint topleft = null;
-		CWPoint buttomright = null;
+		CWPoint bottomright = null;
 		CWPoint tmpca = new CWPoint();
 		numCachesInArea = 0;
 		for (int i=cacheDB.size()-1; i >= 0; i--) {
@@ -326,17 +320,17 @@
 				}
 				if (ch.pos.isValid() && ch.pos.latDec != 0 && ch.pos.lonDec != 0 ){ // TODO != 0 sollte rausgenommen werden sobald in der Liste vern?nftig mit nicht gesetzten pos umgegangen wird
 					if (topleft == null) topleft = new CWPoint(ch.pos);
-					if (buttomright == null) buttomright = new CWPoint(ch.pos);
+					if (bottomright == null) bottomright = new CWPoint(ch.pos);
 					if (topleft.latDec < ch.pos.latDec) topleft.latDec = ch.pos.latDec;
 					if (topleft.lonDec > ch.pos.lonDec) topleft.lonDec = ch.pos.lonDec;
-					if (buttomright.latDec > ch.pos.latDec) buttomright.latDec = ch.pos.latDec;
-					if (buttomright.lonDec < ch.pos.lonDec) buttomright.lonDec = ch.pos.lonDec;
+					if (bottomright.latDec > ch.pos.latDec) bottomright.latDec = ch.pos.latDec;
+					if (bottomright.lonDec < ch.pos.lonDec) bottomright.lonDec = ch.pos.lonDec;
 					numCachesInArea++;
 				}
 			}
 		}
-		if (topleft != null && buttomright != null) 
-			return new Area(topleft, buttomright);
+		if (topleft != null && bottomright != null) 
+			return new Area(topleft, bottomright);
 		else return null;
 	}
 
@@ -374,10 +368,11 @@
 		for(int i = cacheDB.size() -1; i >= 0;i--){
 			ch = (CacheHolder)cacheDB.get(i);
 			ch.addiWpts.clear();
-			ch.mainCache = null; 
-			dbIndex.put((String)ch.wayPoint, new Integer(i));
+			ch.mainCache = null;
+			if (ch.wayPoint.startsWith("GC")) // Only put potential master caches into the index
+				dbIndex.put((String)ch.wayPoint, new Integer(i));
 		}
-		// Build refeneces
+		// Build references
 		int max = cacheDB.size();
 		for(int i =  0; i < max ;i++){
 			ch = (CacheHolder)cacheDB.get(i);
@@ -400,7 +395,13 @@
 		for(int i =  0; i < max ;i++){
 			ch = (CacheHolder)cacheDB.get(i);
 			if (ch.hasAddiWpt() && (ch.addiWpts.size()> 1)){
-				ch.addiWpts.sort(new MyComparer(ch.addiWpts,MyLocale.getMsg(1002,"Waypoint"),ch.addiWpts.size()), false);
+				//ch.addiWpts.sort(new MyComparer(ch.addiWpts,MyLocale.getMsg(1002,"Waypoint"),ch.addiWpts.size()), false);
+				ch.addiWpts.sort(
+					new ewe.util.Comparer() {	
+						public int compare(Object o1, Object o2){
+							return ((CacheHolder) o1).wayPoint.compareTo(((CacheHolder)o2).wayPoint);
+						}
+					},false );
 			}
 		}
 	



From salzkammergut at mail.berlios.de  Tue Feb 13 00:34:04 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Tue, 13 Feb 2007 00:34:04 +0100
Subject: [Cachewolf-svn] r573 - trunk/src/CacheWolf
Message-ID: <200702122334.l1CNY4fu009968@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-13 00:33:56 +0100 (Tue, 13 Feb 2007)
New Revision: 573

Modified:
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/TablePanel.java
Log:
MainMenu: Beim Laden des Profils den Ladeanzeiger wie beim erstmaligen Laden implementiert
Fix: TablePanel: Nach Laden von neuem Profil in die erste Zeile scrollen.

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-02-12 21:27:45 UTC (rev 572)
+++ trunk/src/CacheWolf/MainMenu.java	2007-02-12 23:33:56 UTC (rev 573)
@@ -203,12 +203,17 @@
 			if(mev.selectedItem == mnuOpenProfile){
 					Global.mainTab.saveUnsavedChanges(true);
 					if (pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_FORCED_ON,false)) {
-					profile.cacheDB.clear();
-					profile.readIndex();
-					pref.curCentrePt.set(profile.centre);
-					filtBlack.modifiers&=~MenuItem.Checked;
-					Filter.showBlacklisted=false;
-					tbp.resetModel();
+						tbp.myMod.numRows=0;
+						profile.cacheDB.clear();
+						InfoBox infB = new InfoBox("CacheWolf",MyLocale.getMsg(5000,"Loading Cache-List"));
+						infB.exec();
+						infB.waitUntilPainted(1000);
+						profile.readIndex();
+						pref.curCentrePt.set(profile.centre);
+						filtBlack.modifiers&=~MenuItem.Checked;
+						Filter.showBlacklisted=false;
+						infB.close(0);
+						tbp.resetModel();
 				}
 			}
 			if(mev.selectedItem == mnuEditProfile){

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-02-12 21:27:45 UTC (rev 572)
+++ trunk/src/CacheWolf/TablePanel.java	2007-02-12 23:33:56 UTC (rev 573)
@@ -100,6 +100,7 @@
 		flt.setFilter();
 		flt.doFilter();
 		refreshTable();
+		tc.scrollToVisible(0,0);
 	}
 	
 	/** Move all filtered caches to the end of the table and redesplay table */



From pfeffer at mail.berlios.de  Tue Feb 13 16:08:47 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Tue, 13 Feb 2007 16:08:47 +0100
Subject: [Cachewolf-svn] r574 - trunk/src/CacheWolf
Message-ID: <200702131508.l1DF8lMC021653@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-13 16:08:17 +0100 (Tue, 13 Feb 2007)
New Revision: 574

Modified:
   trunk/src/CacheWolf/HintLogPanel.java
Log:
Logs: Text kann nicht mehr links/rechts verschoben werden. Auch nicht mehr ?\195?\188ber die Grenzen hinaus. Au?\195?\159erdem zeigt der Scrollbalken jetz immer die korrekte Position an.

Modified: trunk/src/CacheWolf/HintLogPanel.java
===================================================================
--- trunk/src/CacheWolf/HintLogPanel.java	2007-02-12 23:33:56 UTC (rev 573)
+++ trunk/src/CacheWolf/HintLogPanel.java	2007-02-13 15:08:17 UTC (rev 574)
@@ -3,21 +3,24 @@
 import ewe.ui.*;
 import ewe.fx.Dimension;
 import ewe.fx.Graphics;
+import ewe.fx.Point;
 import ewe.fx.mImage;
 import ewe.graphics.AniImage;
+import ewe.graphics.ImageDragContext;
 import ewe.graphics.InteractivePanel;
+import ewe.graphics.ReactiveImage;
 import ewe.sys.*;
 import ewe.fx.Image;
 import ewe.fx.Rect;
 
 /**
-*	Class to create the panel that holds hints and logs.
-*	It holds a method to cryt and decrypt hints.
-*	Two buttons allow for navigation through the logs. 5 logs are displayed at
-*   together. This was implemented to allow for better performance on the
-*	PocketPC. This number can be changed in the preferences.
-*	Class ID=400
-*/
+ *	Class to create the panel that holds hints and logs.
+ *	It holds a method to cryt and decrypt hints.
+ *	Two buttons allow for navigation through the logs. 5 logs are displayed at
+ *   together. This was implemented to allow for better performance on the
+ *	PocketPC. This number can be changed in the preferences.
+ *	Class ID=400
+ */
 public class HintLogPanel extends CellPanel{
 	int crntLogPosition = 0;
 	CacheHolder cache;
@@ -26,7 +29,7 @@
 	//mTextPad logs = new mTextPad();
 	HtmlDisplay logs = new HtmlDisplay();
 	AniImage htmlTxtImage;
-	InteractivePanel htmlImagDisp = new InteractivePanel();
+	fastScrollText htmlImagDisp = new fastScrollText();
 	mButton decodeButton = new mButton("Decode");
 	mButton moreBt = new mButton(">>");
 	mButton prevBt = new mButton("<<");
@@ -45,16 +48,16 @@
 		decodeButton.setMinimumSize(MyLocale.getScreenWidth()*2/3,10);
 		hintpane.addLast(moreBt,CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.EAST));
 		hint.modify(Control.NotEditable,0);
-		
+
 		ScrollBarPanel sbplog = new ScrollBarPanel((ScrollClient)htmlImagDisp, ScrollBarPanel.NeverShowHorizontalScrollers);
 		//logpane.addLast(sbplog,CellConstants.STRETCH, CellConstants.FILL);
-		Rect r = new Rect(new Dimension (Global.getPref().myAppWidth, 20));
+		Rect r = new Rect(new Dimension (Global.getPref().myAppWidth-sbplog.vbar.getRect().width, 20));
 		htmlImagDisp.virtualSize = r;
 		htmlImagDisp.checkScrolls();
 		logpane.addLast(sbplog.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
 		this.addLast(split);
 	}
-	
+
 	public void setText(CacheHolder cache){
 		this.cache = cache;
 		if(!cache.Hints.equals("null")) 
@@ -66,11 +69,11 @@
 		moreBt.modify(0,Control.Disabled);
 		prevBt.modify(0,Control.Disabled);
 //		if (Gui.screenIs(Gui.PDA_SCREEN) && Vm.isMobile()) {
-//			Vm.setSIP(0);
+//		Vm.setSIP(0);
 //		}
 		////Vm.debug("In log: " + cache.CacheLogs);
 	}
-	
+
 	void setLogs(int crntLogPosition) {
 		Vm.showWait(true);
 		StringBuffer dummy = new StringBuffer(DEFAULT_STRINGBUFFER_SIZE);
@@ -85,7 +88,7 @@
 		if (htmlTxtImage != null) {
 			htmlImagDisp.removeImage(htmlTxtImage);
 			htmlTxtImage.free();
-			}
+		}
 		logs.resizeTo(width, 50);
 		// The cache GCP0T6 crashes the HtmlDisplay
 		// As a temporary fix
@@ -112,12 +115,13 @@
 		repaintNow();
 		Vm.showWait(false);
 	}
+
 	/**
-	* Method that handles user input on this panel.
-	* It handles decryption of hints and navigation through
-	* the logs (always 5 at a time). Navigation of logs is required
-	* for performance reasons on the pocketpc.
-	*/
+	 * Method that handles user input on this panel.
+	 * It handles decryption of hints and navigation through
+	 * the logs (always 5 at a time). Navigation of logs is required
+	 * for performance reasons on the pocketpc.
+	 */
 	public void onEvent(Event ev){
 		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
 			int minLogs = java.lang.Math.min(Global.getPref().logsPerPage, cache.CacheLogs.size());
@@ -150,3 +154,66 @@
 		}
 	}
 }
+
+class fastScrollText extends InteractivePanel { // TODO extend this class in a way that text can be marked and copied
+	public boolean scrollVertical = true;
+	public boolean scrollHorizontal = false;
+	public boolean imageNotDragged(ImageDragContext drag,Point where) {
+		if (drag == null || drag.image == null) return super.imageNotDragged(drag, where);
+		Rect r = getDim(null);
+		if (drag.image.location.y <= 0 ){
+			drag.image.move(0, drag.image.location.y);
+		} else {
+			drag.image.move(0, 0);
+		}
+		return	super.imageNotDragged(drag, where);
+	}
+	
+	// I copied it here because the original has a bug when scrolling
+	// added the support for scrolling / draggin only vertically
+	// the return value is never used
+//	============================================================
+	public boolean imageDragged(ImageDragContext dc,Point where)
+//	============================================================
+	{
+		ReactiveImage ri = null;
+		if (dc.image instanceof ReactiveImage) ri = (ReactiveImage)dc.image;
+		dc.curPoint = new Point(where.x,where.y);
+		AniImage moving = dc.image;
+		Rect r = getDim(null);
+		boolean didAutoScroll = false;
+		Point to = new Point(where.x-dc.start.x,where.y-dc.start.y);
+		if (!scrollHorizontal) to.x = 0;
+		if (!scrollVertical) to.y = 0;
+		//if (origin.y - to.y < 0 || origin.y - to.y + r.height > moving.location.height) return true; 
+		if (moving == null) { // this is not used only copied
+			if (!dragBackground) return true;
+			int dx = dc.start.x-where.x, dy = dc.start.y-where.y;
+			if (where.x < origin.x || where.x >= origin.x+r.width || where.y < origin.y || where.y >= origin.y+r.height && autoScrolling){
+				if (where.x <= origin.x) dx = scrollStep;
+				if (where.x >= origin.x+r.width) dx = -scrollStep;
+				if (where.y <= origin.y) dy = scrollStep;
+				if (where.y >= origin.y+r.height) dy = -scrollStep; // here +/- is wrong in InteractivePanel.java
+				dc.start.x = where.x; dc.start.y = where.y;
+			}
+			//dc.start.move(where.x,where.y);
+			if (dx != 0 || dy != 0) scroll(dx,dy);
+			refresh();
+			return true;
+		}else if (true || where.x < origin.x || where.x >= origin.x+r.width || where.y < origin.y || where.y >= origin.y+r.height){
+	 			if (autoScrolling) {
+					didAutoScroll = true;
+					scroll(-to.x,-to.y);
+			}
+		}
+/*		if (moving.canGo(to)) {
+			moving.move(to.x,to.y);
+			draggingImage(dc);
+			if (ri != null) ri.dragEvent(this,ri.Drag,dc);
+		}
+	*/	checkTouching(dc,false);
+		if (didAutoScroll) refresh();
+		else refresh(dc.image,null);//updateImage(dc.image);
+		return(true);
+	}
+}



From pfeffer at mail.berlios.de  Tue Feb 13 16:36:16 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Tue, 13 Feb 2007 16:36:16 +0100
Subject: [Cachewolf-svn] r575 - trunk/src/CacheWolf
Message-ID: <200702131536.l1DFaGTO023987@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-13 16:36:12 +0100 (Tue, 13 Feb 2007)
New Revision: 575

Modified:
   trunk/src/CacheWolf/MainTab.java
Log:
MovingMap: Fehlermeldung f?\195?\188r einen Fehler, der eigentlich nicht auftreten kann. Aber vermutlich bei Salzkammergut mal auftrat.

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-02-13 15:08:17 UTC (rev 574)
+++ trunk/src/CacheWolf/MainTab.java	2007-02-13 15:36:12 UTC (rev 575)
@@ -228,7 +228,9 @@
 		mm.myExec();
 		if (forceCenter) {
 			try {
-				while (MapImage.screenDim.width == 0) { ewe.sys.mThread.sleep(100);} // wait until the window size of the moving map is known note: ewe.sys.sleep() will pause the whole vm - no other thread will run 
+				int i = 0;
+				while (MapImage.screenDim.width == 0 && i < 10*60) { i++; ewe.sys.mThread.sleep(100);} // wait until the window size of the moving map is known note: ewe.sys.sleep() will pause the whole vm - no other thread will run
+				if (i >= 10*60) {(new MessageBox("Error", "MovingMap cannot be displaed - this is most likely a bug - plaese report it on www.geoclub.de", MessageBox.OKB)).execute(); return;}
 				mm.setCenterOfScreen(centerTo, false); // this can only be executed if mm knows its window size that's why myExec must be executed before
 				mm.updatePosition(centerTo.latDec, centerTo.lonDec);
 				/*			if(!mm.posCircle.isOnScreen()) { // TODO this doesn't work because lat lon is set to the wished pos and not to gps anymore



From salzkammergut at mail.berlios.de  Tue Feb 13 18:57:31 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Tue, 13 Feb 2007 18:57:31 +0100
Subject: [Cachewolf-svn] r576 - trunk/src/CacheWolf
Message-ID: <200702131757.l1DHvVc3012558@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-13 18:57:21 +0100 (Tue, 13 Feb 2007)
New Revision: 576

Modified:
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/FilterScreen.java
   trunk/src/CacheWolf/Profile.java
Log:
Filter: Standardeinstellung jetzt: Anzeige der Addis. Auch bei Filter loeschen werden jetzt die Addis angezeigt

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2007-02-13 15:36:12 UTC (rev 575)
+++ trunk/src/CacheWolf/Filter.java	2007-02-13 17:57:21 UTC (rev 576)
@@ -304,6 +304,10 @@
 	public void doFilter(){
 		Vector cacheDB=Global.getProfile().cacheDB;
 		if (cacheDB.size()==0) return;
+		if (!hasFilter()) { // If the filter was completely reset, we can just clear it
+			clearFilter();
+			return;
+		}
 		CacheHolder ch;
 		int cacheTypePattern;
 		int cacheRosePattern;
@@ -444,7 +448,7 @@
 			}
 			
 		} // for
-		if (hasFilter())filterActive=true;
+		filterActive=true;
 	}
 	
 	/**
@@ -473,7 +477,7 @@
 		CacheHolder ch;
 		for(int i = cacheDB.size()-1; i >=0 ; i--){
 			ch = (CacheHolder)cacheDB.get(i);
-			ch.is_filtered=(ch.is_black^showBlacklisted) || CacheType.isAddiWpt(ch.type); // Always filter blacklisted caches
+			ch.is_filtered=(ch.is_black^showBlacklisted) ; // Always filter blacklisted caches
 		}
 		filterActive=false;
 		filterInverted=false;

Modified: trunk/src/CacheWolf/FilterScreen.java
===================================================================
--- trunk/src/CacheWolf/FilterScreen.java	2007-02-13 15:36:12 UTC (rev 575)
+++ trunk/src/CacheWolf/FilterScreen.java	2007-02-13 17:57:21 UTC (rev 576)
@@ -288,7 +288,6 @@
 			chcDist.select(0);
 			inpDist.setText("");
 		}
-		// If filter has been corrupted, pad it to 11 characters
 		String fltRose=prof.filterRose;
 		chkNW.state   = fltRose.charAt(0) == '1';
 		chkNNW.state  = fltRose.charAt(1) == '1';
@@ -441,16 +440,29 @@
 
 		// Panel 5 - Addi Waypoints
 		if (chkParking.state || chkStage.state || chkQuestion.state || 
-			chkFinal.state || chkTrailhead.state || chkReference.state )
+			chkFinal.state || chkTrailhead.state || chkReference.state ) { // At least one tick
 			btnAddi.backGround=COLOR_FILTERACTIVE;
-		else
-			btnAddi.backGround=COLOR_FILTERINACTIVE;
+			addiWptChk.state=true;
+			if (chkParking.state && chkStage.state &&  chkQuestion.state && 
+				chkFinal.state && chkTrailhead.state && chkReference.state ) { // All ticked?
+				addiWptChk.bgColor=Color.White;
+				btnAddi.backGround=COLOR_FILTERINACTIVE;
+			} else {	
+				addiWptChk.bgColor=Color.LightGray;
+			}
+		} else { // All not ticked
+			btnAddi.backGround=COLOR_FILTERACTIVE;
+			addiWptChk.bgColor=Color.White;
+			addiWptChk.state=false;
+		}
 		btnAddi.repaint();
 
 		// Panel 4 - Cache types
+		boolean allAddis=(chkParking.state && chkStage.state &&  chkQuestion.state && 
+		chkFinal.state && chkTrailhead.state && chkReference.state) ;
 		if (!(chkTrad.state && chkMulti.state && 	chkVirtual.state && chkLetter.state &&
 		      chkEvent.state && chkWebcam.state && chkMystery.state && chkEarth.state &&
-		      chkLocless.state && chkMega.state && chkCustom.state) ) 
+		      chkLocless.state && chkMega.state && chkCustom.state && allAddis) ) 
 			btnTypes.backGround=COLOR_FILTERACTIVE;
 		else
 			btnTypes.backGround=COLOR_FILTERINACTIVE;
@@ -462,23 +474,6 @@
 			btnTypes.backGround=COLOR_FILTERALL;
 		btnTypes.repaint();
 
-		// Panel 5 - Addi Waypoints
-		if (chkParking.state || chkStage.state || chkQuestion.state || 
-			chkFinal.state || chkTrailhead.state || chkReference.state ) { // At least one tick
-			btnAddi.backGround=COLOR_FILTERACTIVE;
-			addiWptChk.state=true;
-			if (chkParking.state && chkStage.state &&  chkQuestion.state && 
-				chkFinal.state && chkTrailhead.state && chkReference.state ) { // All ticked?
-				addiWptChk.bgColor=Color.White;
-			} else {	
-				addiWptChk.bgColor=Color.LightGray;
-			}
-		} else { // All not ticked
-			btnAddi.backGround=COLOR_FILTERINACTIVE;
-			addiWptChk.bgColor=Color.White;
-			addiWptChk.state=false;
-		}
-		btnAddi.repaint();
 			
 		// Panel 6 - Cache container
 		if (!(chkMicro.state && chkSmall.state && chkRegular.state && 
@@ -595,17 +590,6 @@
 				} else { 
 					pfl.filterTerr="G"+inpTerr.getText();
 				}
-/*				if(lastChc.selectedIndex == 0) 
-					flt.daysdirec = Filter.FOUND;
-				else 
-					flt.daysdirec = Filter.NOTFOUND;
-*/
-				// Need to think about saving it here. If yes, we also need to save filter when we clear it.
-				// Maybe better to auto-save index upon exit
-				//InfoBox infB = new InfoBox("Info",MyLocale.getMsg(713,"Saving filter"));
-				//infB.exec();
-				//pfl.saveIndex(Global.getPref());
-				//infB.close(0);
 				Filter flt = new Filter();
 				flt.setFilter();
 				flt.doFilter();

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-02-13 15:36:12 UTC (rev 575)
+++ trunk/src/CacheWolf/Profile.java	2007-02-13 17:57:21 UTC (rev 576)
@@ -43,7 +43,7 @@
 	public final static boolean SHOW_PROGRESS_BAR = true;
 	public final static boolean NO_SHOW_PROGRESS_BAR = false;
 	
-	public final static String FILTERTYPE="11111111111000000";
+	public final static String FILTERTYPE="11111111111111111";
 	public final static String FILTERROSE="1111111111111111";
 	public final static String FILTERVAR="11111111";
 	public final static String FILTERSIZE="111111";
@@ -417,9 +417,8 @@
 		if (filterVar.length()<8) { 
 			filterVar=(filterVar+"11111111").substring(0,8); 
 		}  
-		if (filterType.length()<16) { 
-			filterType=(filterType+"11111111111111111").substring(0,11);
-			filterType=(filterType+"000000").substring(0,17);
+		if (filterType.length()<17) { 
+			filterType=(filterType+"11111111111111111111111").substring(0,17);
 		} 
 		if (filterSize.length()<6) {
 			filterSize=(filterSize+"111111").substring(0,6);



From pfeffer at mail.berlios.de  Tue Feb 13 20:14:31 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Tue, 13 Feb 2007 20:14:31 +0100
Subject: [Cachewolf-svn] r577 - trunk/src/CacheWolf
Message-ID: <200702131914.l1DJEVsf018765@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-13 20:14:23 +0100 (Tue, 13 Feb 2007)
New Revision: 577

Modified:
   trunk/src/CacheWolf/HintLogPanel.java
   trunk/src/CacheWolf/myTableControl.java
Log:
Liste: Pos1, Ende, Bild-hoch und -runtertasten funktionieren
Logs: beim Anzeigen der n?\195?\164schten /vorherigen Logs wird immer an den Anfang gescrollt

Modified: trunk/src/CacheWolf/HintLogPanel.java
===================================================================
--- trunk/src/CacheWolf/HintLogPanel.java	2007-02-13 17:57:21 UTC (rev 576)
+++ trunk/src/CacheWolf/HintLogPanel.java	2007-02-13 19:14:23 UTC (rev 577)
@@ -109,6 +109,7 @@
 		htmlImagDisp.addImage(htmlTxtImage);
 		Rect r = new Rect(new Dimension (width, h));
 		htmlImagDisp.virtualSize = r;
+		htmlImagDisp.origin = new Point();
 		htmlImagDisp.checkScrolls();
 
 		htmlImagDisp.repaintNow();

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-02-13 17:57:21 UTC (rev 576)
+++ trunk/src/CacheWolf/myTableControl.java	2007-02-13 19:14:23 UTC (rev 577)
@@ -7,15 +7,15 @@
 import ewe.util.*;
 
 /**
-*	Implements the user interaction of the list view. Works together with myTableModel and TablePanel
-*/
+ *	Implements the user interaction of the list view. Works together with myTableModel and TablePanel
+ */
 public class myTableControl extends TableControl{
 
 	public Preferences pref;
 	public Profile profile;
 	public Vector cacheDB;
 	public TablePanel tbp;
-	
+
 	myTableControl(TablePanel tablePanel) {
 		Menu m = new Menu(new String[]{
 				MyLocale.getMsg(1021,"Open description"),
@@ -36,16 +36,16 @@
 		pref = Global.getPref();
 		tbp =tablePanel;
 	}
-	
+
 	public void penRightReleased(Point p){
 		if (cacheDB.size()>0) // No context menu when DB is empty
-		   menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
+			menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
 	}
 	public void penHeld(Point p){
 		if (cacheDB.size()>0) // No context menu when DB is empty
-		   menuState.doShowMenu(p,true,null); 
+			menuState.doShowMenu(p,true,null); 
 	}
-	
+
 	public void onKeyEvent(KeyEvent ev) {
 		if (ev.type == KeyEvent.KEY_PRESS && ev.target == this){
 			if ( (ev.modifiers & IKeys.CONTROL) > 0 && ev.key == 1){ // <ctrl-a> gives 1, <ctrl-b> == 2
@@ -53,27 +53,31 @@
 				setSelectForAll(true);
 				ev.consumed = true;
 			}
+			if (ev.key == IKeys.HOME) cursorTo(0,cursor.x+listMode,true);
+			if (ev.key == IKeys.END) cursorTo(model.numRows-1,cursor.x+listMode,true);
+			if (ev.key == IKeys.PAGE_DOWN)cursorTo(java.lang.Math.min(cursor.y+ getOnScreen(null).height, model.numRows),cursor.x+listMode,true);
+			if (ev.key == IKeys.PAGE_UP) cursorTo(java.lang.Math.max(cursor.y-getOnScreen(null).height, 0),cursor.x+listMode,true);
 		}
 		super.onKeyEvent(ev);
 	}
-		
+
 	/** Set all caches either as selected or as deselected, depending on argument */
 	private void setSelectForAll(boolean selectStatus) {
 		Global.getProfile().setSelectForAll(selectStatus);
 		tbp.refreshTable();
 	}
-	
+
 	public void popupMenuEvent(Object selectedItem){
 		CacheHolder ch;
-		
+
 		if (selectedItem.toString().equals(MyLocale.getMsg(1015,"Select all"))){
 			setSelectForAll(true);
 		}
-		
+
 		if (selectedItem.toString().equals(MyLocale.getMsg(1016,"De-select all"))){
 			setSelectForAll(false);
 		}
-		
+
 		if (selectedItem.toString().equals(MyLocale.getMsg(1011,"Filter"))){
 			for(int i = cacheDB.size()-1; i >=0; i--){
 				ch = (CacheHolder)cacheDB.get(i);
@@ -85,48 +89,48 @@
 		}
 		if (selectedItem.toString().equals(MyLocale.getMsg(1012,"Delete"))){
 			if ((new MessageBox(MyLocale.getMsg(144,"Warnung"),MyLocale.getMsg(1022, "Delete all caches that have a tick?"), MessageBox.YESB | MessageBox.NOB)).execute() != Form.IDYES) return;
-				DataMover dm=new DataMover();
-				for(int i = cacheDB.size()-1; i >=0; i--){
-					ch = (CacheHolder)cacheDB.get(i);
-					if(ch.is_Checked == true) {
-						dm.deleteCacheFiles(ch.wayPoint,profile.dataDir);
-						cacheDB.remove(ch);
-					}
+			DataMover dm=new DataMover();
+			for(int i = cacheDB.size()-1; i >=0; i--){
+				ch = (CacheHolder)cacheDB.get(i);
+				if(ch.is_Checked == true) {
+					dm.deleteCacheFiles(ch.wayPoint,profile.dataDir);
+					cacheDB.remove(ch);
 				}
+			}
 			profile.saveIndex(pref,true);	
 			tbp.refreshTable();
 		}
-		
+
 		if (selectedItem.toString().equals(MyLocale.getMsg(1014,"Update"))){
-            SpiderGC spider = new SpiderGC(pref, profile);
-            Vm.showWait(true);
-            spider.login();
-            boolean alreadySaid = false;
-            boolean alreadySaid2 = false;
-            for(int i = 0; i <	cacheDB.size(); i++){
-                    ch = (CacheHolder)cacheDB.get(i);
-                    if(ch.is_Checked == true) {
-                            if ( (ch.wayPoint.length() > 1 && ch.wayPoint.substring(0,2).equalsIgnoreCase("GC")))
-//Notiz: Wenn es ein addi Wpt ist, sollte eigentlich der Maincache gespidert werden
-//Alter code pr?ft aber nur ob ein Maincache von GC existiert und versucht dann den addi direkt zu spidern, was nicht funktioniert
-//TODO: Diese Meldungen vor dem Einloggen darstellen						
-		{
-                                    spider.spiderSingle(i);
-                            } else if (ch.isAddiWpt() && !ch.mainCache.is_Checked) { // Is the father ticked?
-                            		if (!alreadySaid2) {
-                                            alreadySaid2=true;
-                                            (new MessageBox("Information","Hilfswegpunkte k?nnnen nicht direkt gespidert werden\nBitte zus?tzlich den Vater anhaken", MessageBox.OKB)).exec();
-                                    }
-                            } else if (ch.mainCache != null &&	ch.mainCache.wayPoint.length() > 1 	&& !ch.mainCache.wayPoint.substring(0,2).equalsIgnoreCase("GC") && 
-                                               !alreadySaid) {
-                                    alreadySaid = true;
-                                    (new MessageBox("Information",ch.wayPoint+">"+ch.mainCache.wayPoint+": Diese Funktion steht gegenw?rtig nur f?r Geocaching.com zur Verf?gung", MessageBox.OKB)).exec();
-                            }
-                    }
-            }
+			SpiderGC spider = new SpiderGC(pref, profile);
+			Vm.showWait(true);
+			spider.login();
+			boolean alreadySaid = false;
+			boolean alreadySaid2 = false;
+			for(int i = 0; i <	cacheDB.size(); i++){
+				ch = (CacheHolder)cacheDB.get(i);
+				if(ch.is_Checked == true) {
+					if ( (ch.wayPoint.length() > 1 && ch.wayPoint.substring(0,2).equalsIgnoreCase("GC")))
+//						Notiz: Wenn es ein addi Wpt ist, sollte eigentlich der Maincache gespidert werden
+//						Alter code pr?ft aber nur ob ein Maincache von GC existiert und versucht dann den addi direkt zu spidern, was nicht funktioniert
+//						TODO: Diese Meldungen vor dem Einloggen darstellen						
+					{
+						spider.spiderSingle(i);
+					} else if (ch.isAddiWpt() && !ch.mainCache.is_Checked) { // Is the father ticked?
+						if (!alreadySaid2) {
+							alreadySaid2=true;
+							(new MessageBox("Information","Hilfswegpunkte k?nnnen nicht direkt gespidert werden\nBitte zus?tzlich den Vater anhaken", MessageBox.OKB)).exec();
+						}
+					} else if (ch.mainCache != null &&	ch.mainCache.wayPoint.length() > 1 	&& !ch.mainCache.wayPoint.substring(0,2).equalsIgnoreCase("GC") && 
+							!alreadySaid) {
+						alreadySaid = true;
+						(new MessageBox("Information",ch.wayPoint+">"+ch.mainCache.wayPoint+": Diese Funktion steht gegenw?rtig nur f?r Geocaching.com zur Verf?gung", MessageBox.OKB)).exec();
+					}
+				}
+			}
 			profile.hasUnsavedChanges=true;	
-            tbp.refreshTable();
-            Vm.showWait(false);
+			tbp.refreshTable();
+			Vm.showWait(false);
 		}
 		if (selectedItem.toString().equals(MyLocale.getMsg(1019,"Center"))){
 			CacheHolder thisCache = (CacheHolder)cacheDB.get(tbp.getSelectedCache());
@@ -140,7 +144,7 @@
 				tbp.refreshTable();
 			}
 		}
-		
+
 		if (selectedItem.toString().equals(MyLocale.getMsg(1010,"Goto"))){
 			ch = (CacheHolder)cacheDB.get(tbp.getSelectedCache());
 			Global.mainTab.gotoPoint(ch.LatLon);
@@ -162,10 +166,10 @@
 		}
 
 	}
-	
+
 	public void penDoubleClicked(Point where) {
 		Global.mainTab.select(Global.mainTab.descP);
 	}
 
-	
+
 }



From kalli at mail.berlios.de  Tue Feb 13 21:48:09 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Tue, 13 Feb 2007 21:48:09 +0100
Subject: [Cachewolf-svn] r578 - trunk/src/CacheWolf
Message-ID: <200702132048.l1DKm9Fe025515@sheep.berlios.de>

Author: kalli
Date: 2007-02-13 21:48:03 +0100 (Tue, 13 Feb 2007)
New Revision: 578

Modified:
   trunk/src/CacheWolf/CacheHolder.java
Log:
Bug mit "umgedrehtem" Radar gefixt.

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-02-13 19:14:23 UTC (rev 577)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-02-13 20:48:03 UTC (rev 578)
@@ -446,7 +446,7 @@
    public void calcDistance(CWPoint toPoint) {	
 	   if(pos.isValid()){
 			kilom = pos.getDistance(toPoint);
-			degrees = pos.getBearing(toPoint);
+			degrees = toPoint.getBearing(pos);
 			bearing = CWPoint.getDirection(degrees);
 			distance = MyLocale.formatDouble(kilom,"0.00")+" km";
 	   } else {



From pfeffer at mail.berlios.de  Wed Feb 14 00:26:16 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 14 Feb 2007 00:26:16 +0100
Subject: [Cachewolf-svn] r579 - trunk/src/CacheWolf
Message-ID: <200702132326.l1DNQGCO005907@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-14 00:26:13 +0100 (Wed, 14 Feb 2007)
New Revision: 579

Modified:
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/Navigate.java
Log:
MovingMap: zus?\195?\164tzliche Fehlermeldung, wenn MovingMap start nicht klappt
Profil laden: zeigt Wartesymbol beim Laden

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-02-13 20:48:03 UTC (rev 578)
+++ trunk/src/CacheWolf/MainMenu.java	2007-02-13 23:26:13 UTC (rev 579)
@@ -208,7 +208,9 @@
 						InfoBox infB = new InfoBox("CacheWolf",MyLocale.getMsg(5000,"Loading Cache-List"));
 						infB.exec();
 						infB.waitUntilPainted(1000);
+						Vm.showWait(infB, true);
 						profile.readIndex();
+						Vm.showWait(infB, false);
 						pref.curCentrePt.set(profile.centre);
 						filtBlack.modifiers&=~MenuItem.Checked;
 						Filter.showBlacklisted=false;

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-02-13 20:48:03 UTC (rev 578)
+++ trunk/src/CacheWolf/MainTab.java	2007-02-13 23:26:13 UTC (rev 579)
@@ -214,34 +214,39 @@
 	 * @param forceCenter
 	 */
 	public void SwitchToMovingMap(CWPoint centerTo, boolean forceCenter) {
-		if (!centerTo.isValid()) {
-			(new MessageBox("Error", "No valid coordinates", MessageBox.OKB)).execute();
-			return;
-		}
-		if (mm == null) {
-			mm = new MovingMap(nav, profile.cacheDB);
-			nav.setMovingMap(mm);
-			if (nav.gpsRunning) mm.gpsStarted();
-		} 
-		if (forceCenter) mm.setGpsStatus(MovingMap.noGPS); // disconnect movingMap from GPS TODO only if GPS-pos is not on the screen
-		mm.updatePosition(centerTo.latDec, centerTo.lonDec);
-		mm.myExec();
-		if (forceCenter) {
-			try {
-				int i = 0;
-				while (MapImage.screenDim.width == 0 && i < 10*60) { i++; ewe.sys.mThread.sleep(100);} // wait until the window size of the moving map is known note: ewe.sys.sleep() will pause the whole vm - no other thread will run
-				if (i >= 10*60) {(new MessageBox("Error", "MovingMap cannot be displaed - this is most likely a bug - plaese report it on www.geoclub.de", MessageBox.OKB)).execute(); return;}
-				mm.setCenterOfScreen(centerTo, false); // this can only be executed if mm knows its window size that's why myExec must be executed before
-				mm.updatePosition(centerTo.latDec, centerTo.lonDec);
-				/*			if(!mm.posCircle.isOnScreen()) { // TODO this doesn't work because lat lon is set to the wished pos and not to gps anymore
+		try {
+			if (!centerTo.isValid()) {
+				(new MessageBox("Error", "No valid coordinates", MessageBox.OKB)).execute();
+				return;
+			}
+			if (mm == null) {
+				mm = new MovingMap(nav, profile.cacheDB);
+				nav.setMovingMap(mm);
+			} 
+			if (forceCenter) mm.setGpsStatus(MovingMap.noGPS); // disconnect movingMap from GPS TODO only if GPS-pos is not on the screen
+			mm.updatePosition(centerTo.latDec, centerTo.lonDec);
+			mm.myExec();
+			if (forceCenter) {
+				try {
+					int i = 0;
+					while (MapImage.screenDim.width == 0 && i < 10*60) { i++; ewe.sys.mThread.sleep(100);} // wait until the window size of the moving map is known note: ewe.sys.sleep() will pause the whole vm - no other thread will run
+					if (i >= 10*60) {(new MessageBox("Error", "MovingMap cannot be displaed - this is most likely a bug - plaese report it on www.geoclub.de", MessageBox.OKB)).execute(); return;}
+					mm.setCenterOfScreen(centerTo, false); // this can only be executed if mm knows its window size that's why myExec must be executed before
+					mm.updatePosition(centerTo.latDec, centerTo.lonDec);
+					/*			if(!mm.posCircle.isOnScreen()) { // TODO this doesn't work because lat lon is set to the wished pos and not to gps anymore
 				mm.setGpsStatus(MovingMap.noGPS); // disconnect movingMap from GPS if GPS-pos is not on the screen
 				mm.setResModus(MovingMap.HIGHEST_RESOLUTION);
 				mm.updatePosition(centerTo.latDec, centerTo.lonDec);
 				mm.setCenterOfScreen(centerTo, true); 
 			}
-				 */			//TODO what to do, if there is a map at centerTo, but it is not loaded because of mapSwitchMode == dest & cuurpos und daf?r gibt es keine Karte 
-			}catch (InterruptedException e) { (new MessageBox("Error", "This must not happen please report to pfeffer how to produce this error message", MessageBox.OKB)).execute(); } 
-		}
+					 */			//TODO what to do, if there is a map at centerTo, but it is not loaded because of mapSwitchMode == dest & cuurpos und daf?r gibt es keine Karte 
+				}catch (InterruptedException e) {
+					Global.getPref().log("Error starting mavoing map (1): " + e.getMessage(), e, true);
+					(new MessageBox("Error", "This must not happen please report to pfeffer how to produce this error message", MessageBox.OKB)).execute(); } 
+			}
+		} catch (Exception e) { 
+			Global.getPref().log("Error starting mavoing map (2): " + e.getMessage(), e, true);
+			(new MessageBox("Error", "Error starting mavoing map: " + e.getMessage(), MessageBox.OKB)).execute(); }
 	}
 
 	/** Save any changes from DetailsPanel before operating on the database */

Modified: trunk/src/CacheWolf/Navigate.java
===================================================================
--- trunk/src/CacheWolf/Navigate.java	2007-02-13 20:48:03 UTC (rev 578)
+++ trunk/src/CacheWolf/Navigate.java	2007-02-13 23:26:13 UTC (rev 579)
@@ -31,6 +31,7 @@
 	}
 	public void setMovingMap (MovingMap mm) {
 		movingMap = mm;
+		if (gpsRunning) mm.gpsStarted();
 	}
 
 	public void startGps() {



From pfeffer at mail.berlios.de  Wed Feb 14 01:26:47 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 14 Feb 2007 01:26:47 +0100
Subject: [Cachewolf-svn] r580 - trunk
Message-ID: <200702140026.l1E0QlQb020147@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-14 01:26:46 +0100 (Wed, 14 Feb 2007)
New Revision: 580

Modified:
   trunk/cwberlios.jnf
Log:
.tpl-dateien einschlie?\195?\159en

Modified: trunk/cwberlios.jnf
===================================================================
--- trunk/cwberlios.jnf	2007-02-13 23:26:13 UTC (rev 579)
+++ trunk/cwberlios.jnf	2007-02-14 00:26:46 UTC (rev 580)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B12M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2%252526%25253DPocketPC%25252B2003%252526%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&createWithPnf=true&eweInfo=outputFile%3D./work/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/exp/%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253De!
 xp/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources%252526mask%25253D*.gif;*.png%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./lib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources/%252526mask%25253Dcachewolf.Languages.cfg%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D_config/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources%252526mask%25253D*.html%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useR!
 esources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%2!
 53D/Xmx%
252B12M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=(Default)
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B12M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2%252526%25253DPocketPC%25252B2003%252526%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253DPocketPC%25252B-%25252BMIPS%252526%25253DPocketPC%25252B-%25252BSH3%252526%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&createWithPnf=true&eweInfo=outputFile%3D./work/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources%252526!
 mask%25253D*.gif;*.png;*.ico;*.tp;*.zip;*.html%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources/%252526mask%25253Dcachewolf.Languages.cfg%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D_config/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./lib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B12M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26ad!
 dInstallFile%3Dfalse%26usePool%3Dtrue%26useClassPool%3Dfalse&i!
 con=(Def
ault)



From pfeffer at mail.berlios.de  Wed Feb 14 02:21:27 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 14 Feb 2007 02:21:27 +0100
Subject: [Cachewolf-svn] r581 - trunk/src/CacheWolf
Message-ID: <200702140121.l1E1LRxD025099@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-14 02:21:24 +0100 (Wed, 14 Feb 2007)
New Revision: 581

Modified:
   trunk/src/CacheWolf/MyComparer.java
   trunk/src/CacheWolf/myTableModel.java
Log:
Liste: beim ersten Klick auf die Spalten?\195?\188berschrift wird immer aufsteigend sortiert
Liste: ignoriere Gro?\195?\159/Kleinschreibung in Sortierung nach Cachename und nach Wegpunkt

Modified: trunk/src/CacheWolf/MyComparer.java
===================================================================
--- trunk/src/CacheWolf/MyComparer.java	2007-02-14 00:26:46 UTC (rev 580)
+++ trunk/src/CacheWolf/MyComparer.java	2007-02-14 01:21:24 UTC (rev 581)
@@ -51,12 +51,12 @@
 		} else if (what.equals(nmWay)) {
 			for (int i=0; i<visibleSize; i++) {
 				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=ch.wayPoint;
+				ch.sort=ch.wayPoint.toUpperCase();
 			}
 		} else if (what.equals(nmName)) {
 			for (int i=0; i<visibleSize; i++) {
 				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=ch.CacheName;
+				ch.sort=ch.CacheName.toLowerCase();
 			}
 		} else if (what.equals(nmLoc)) {
 			for (int i=0; i<visibleSize; i++) {

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-02-14 00:26:46 UTC (rev 580)
+++ trunk/src/CacheWolf/myTableModel.java	2007-02-14 01:21:24 UTC (rev 581)
@@ -37,6 +37,7 @@
 	mImage bug;
 	myTableControl tcControl;
 	boolean sortAsc = false;
+	int sortedBy = -1;
 	FontMetrics fm;
 	Image checkboxTicked,checkboxUnticked;
 	
@@ -284,11 +285,13 @@
 				}
 			}
 			if(cell.y == -1){ // Hit a header => sort the table accordingly
-				sortAsc=!sortAsc;
 				CacheHolder ch=null;
 				Vm.showWait(true);
 				Point a = tcControl.getSelectedCell(null);
 				if(a != null) ch = (CacheHolder)cacheDB.get(a.y);
+				if (cell.x == sortedBy) sortAsc=!sortAsc;
+				else sortAsc = false;
+				sortedBy = cell.x;
 				cacheDB.sort(new MyComparer(cacheDB, colName[cell.x],numRows), sortAsc);
 				updateRows();
 				if(a != null){



From pfeffer at mail.berlios.de  Wed Feb 14 04:10:12 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 14 Feb 2007 04:10:12 +0100
Subject: [Cachewolf-svn] r582 - trunk/src/CacheWolf
Message-ID: <200702140310.l1E3ACp7030741@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-14 04:10:06 +0100 (Wed, 14 Feb 2007)
New Revision: 582

Modified:
   trunk/src/CacheWolf/DescriptionPanel.java
   trunk/src/CacheWolf/HintLogPanel.java
   trunk/src/CacheWolf/myTableControl.java
Log:
Logs: Scrolling mit Tasten (hoch-runter und Bild hoch/runter)

Modified: trunk/src/CacheWolf/DescriptionPanel.java
===================================================================
--- trunk/src/CacheWolf/DescriptionPanel.java	2007-02-14 01:21:24 UTC (rev 581)
+++ trunk/src/CacheWolf/DescriptionPanel.java	2007-02-14 03:10:06 UTC (rev 582)
@@ -8,7 +8,6 @@
 *	This class shows the long description on a cache.
 */
 public class DescriptionPanel extends CellPanel{
-	mTextPad myPad = new mTextPad();
 	HtmlDisplay disp = new HtmlDisplay();
 	mButton btnPlus, btnMinus;
 	CacheHolder currCache;

Modified: trunk/src/CacheWolf/HintLogPanel.java
===================================================================
--- trunk/src/CacheWolf/HintLogPanel.java	2007-02-14 01:21:24 UTC (rev 581)
+++ trunk/src/CacheWolf/HintLogPanel.java	2007-02-14 03:10:06 UTC (rev 582)
@@ -172,13 +172,12 @@
 	
 	// I copied it here because the original has a bug when scrolling
 	// added the support for scrolling / draggin only vertically
+	// rewrite to support for images bigger than the canvas
 	// the return value is never used
 //	============================================================
 	public boolean imageDragged(ImageDragContext dc,Point where)
 //	============================================================
 	{
-		ReactiveImage ri = null;
-		if (dc.image instanceof ReactiveImage) ri = (ReactiveImage)dc.image;
 		dc.curPoint = new Point(where.x,where.y);
 		AniImage moving = dc.image;
 		Rect r = getDim(null);
@@ -217,4 +216,27 @@
 		else refresh(dc.image,null);//updateImage(dc.image);
 		return(true);
 	}
+	public void onKeyEvent(KeyEvent ev) {
+		if (ev.type == KeyEvent.KEY_PRESS) {
+			if (ev.key == IKeys.DOWN) {
+				 doScroll(IScroll.Vertical, IScroll.ScrollHigher, 1);
+				 refresh();
+			}
+			if (ev.key == IKeys.UP) {
+				 doScroll(IScroll.Vertical, IScroll.ScrollLower, 1);
+				 refresh();
+			}
+			if (ev.key == IKeys.PAGE_DOWN) {
+				 doScroll(IScroll.Vertical, IScroll.PageHigher, 1);
+				 refresh();
+			}
+			if (ev.key == IKeys.PAGE_UP) {
+				 doScroll(IScroll.Vertical, IScroll.PageLower, 1);
+				 refresh();
+			}
+		}
+	}
+
+	
+	
 }

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-02-14 01:21:24 UTC (rev 581)
+++ trunk/src/CacheWolf/myTableControl.java	2007-02-14 03:10:06 UTC (rev 582)
@@ -55,8 +55,8 @@
 			}
 			if (ev.key == IKeys.HOME) cursorTo(0,cursor.x+listMode,true);
 			if (ev.key == IKeys.END) cursorTo(model.numRows-1,cursor.x+listMode,true);
-			if (ev.key == IKeys.PAGE_DOWN)cursorTo(java.lang.Math.min(cursor.y+ getOnScreen(null).height, model.numRows),cursor.x+listMode,true);
-			if (ev.key == IKeys.PAGE_UP) cursorTo(java.lang.Math.max(cursor.y-getOnScreen(null).height, 0),cursor.x+listMode,true);
+			if (ev.key == IKeys.PAGE_DOWN) cursorTo(java.lang.Math.min(cursor.y+ getOnScreen(null).height-1, model.numRows-1),cursor.x+listMode,true); // I don't know why this doesn't work: tbp.doScroll(IScroll.Vertical, IScroll.PageHigher, 1);
+			if (ev.key == IKeys.PAGE_UP) cursorTo(java.lang.Math.max(cursor.y-getOnScreen(null).height+1, 0),cursor.x+listMode,true);
 		}
 		super.onKeyEvent(ev);
 	}



From pfeffer at mail.berlios.de  Wed Feb 14 04:13:52 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 14 Feb 2007 04:13:52 +0100
Subject: [Cachewolf-svn] r583 - trunk/src/CacheWolf
Message-ID: <200702140313.l1E3DqkO030857@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-14 04:13:50 +0100 (Wed, 14 Feb 2007)
New Revision: 583

Added:
   trunk/src/CacheWolf/AreaList.java
Modified:
   trunk/src/CacheWolf/myTableControl.java
Log:
Liste: neben Doppelklick ?\195?\182ffnet auch Enter die Details

Added: trunk/src/CacheWolf/AreaList.java
===================================================================
--- trunk/src/CacheWolf/AreaList.java	2007-02-14 03:10:06 UTC (rev 582)
+++ trunk/src/CacheWolf/AreaList.java	2007-02-14 03:13:50 UTC (rev 583)
@@ -0,0 +1,72 @@
+package CacheWolf;
+
+
+/**
+ * Class for handling a list of areas covered by a list of maps.
+ * this is needed to determine if a new map should be downloaded or
+ * if a map for the requested area already exists
+ * 
+ * @author pfeffer
+ *
+ public class AreaList extends ewe.util.LinkedListElement { // in java since v1.2 I would use java.util.TreeSet
+/*
+	 public AreaList(int s) {super(s);}
+
+	 public void addArea(CWPoint topleft, CWPoint buttomright) {
+		 Area tp = getArea(topleft);
+		 if (tp != null && tp.isInBound(buttomright)) return; // area already completly in list
+		 int edge = tp.getEdge(topleft, buttomright);
+		 switch (edge) {
+		 case Area.AT_TOP_EDGE: tp.topleft.latDec = topleft.latDec; break;
+		 case Area.AT_RIGHT_EDGE: tp.buttomright.lonDec = buttomright.lonDec; break;
+		 case Area.AT_BUTTOM_EDGE: tp.buttomright.latDec = buttomright.latDec; break;
+		 case Area.AT_LEFT_EDGE: tp.topleft.lonDec = topleft.lonDec; break;
+		 case Area.NOT_ON_EDGE: addAreaUnconditionally(new Area(topleft, buttomright));
+		 }
+	 }
+
+	 public boolean AreaIsCovered(CWPoint topleft, CWPoint buttomright) {
+		 Area tp = getArea(topleft);
+		 if (tp != null && tp.isInBound(buttomright)) return true; // area already completly in list
+		 else return false;
+
+	 }
+
+	 public void addArea(Area a) {
+		 addArea(a.topleft, a.buttomright);
+	 }
+
+	 public static AreaList joinAreas(AreaList al){
+		 AreaList ret = null;
+		 while (!al.equals(ret)) {
+			 ret = new AreaList(al.size());
+			 for (int i=al.size()-1; i >= 0; i--) {
+				 ret.addArea((Area)al.get(i));
+			 }
+		 }
+		 return ret;
+	 }
+
+	 public boolean equals(AreaList al){
+		 if (size() != al.size()) return false;
+		 for (int i = size()-1; i >= 0; i--) {
+			 if (!( ((Area)get(i)).equals((Area)al.get(i)) )) return false;
+		 }
+		 return true;
+	 }
+
+	 private void addAreaUnconditionally(Area a) {
+		 add(a); // TODO insert at the correct / sorted position
+	 }
+
+	 public Area getArea(CWPoint p) {
+		 Area ret;
+		 for (int i=size()-1; i>=0; i--) {
+			 ret = ((Area)get(i));
+			 if(ret.isInBound(p)) return ret; 
+		 }
+		 return null;
+	 }
+
+ }
+*/

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-02-14 03:10:06 UTC (rev 582)
+++ trunk/src/CacheWolf/myTableControl.java	2007-02-14 03:13:50 UTC (rev 583)
@@ -57,6 +57,8 @@
 			if (ev.key == IKeys.END) cursorTo(model.numRows-1,cursor.x+listMode,true);
 			if (ev.key == IKeys.PAGE_DOWN) cursorTo(java.lang.Math.min(cursor.y+ getOnScreen(null).height-1, model.numRows-1),cursor.x+listMode,true); // I don't know why this doesn't work: tbp.doScroll(IScroll.Vertical, IScroll.PageHigher, 1);
 			if (ev.key == IKeys.PAGE_UP) cursorTo(java.lang.Math.max(cursor.y-getOnScreen(null).height+1, 0),cursor.x+listMode,true);
+			if (ev.key == IKeys.ACTION || ev.key == IKeys.ENTER) Global.mainTab.select(Global.mainTab.descP);
+
 		}
 		super.onKeyEvent(ev);
 	}



From pfeffer at mail.berlios.de  Wed Feb 14 13:41:56 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 14 Feb 2007 13:41:56 +0100
Subject: [Cachewolf-svn] r584 - trunk/src/CacheWolf
Message-ID: <200702141241.l1ECfujR020465@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-14 13:41:51 +0100 (Wed, 14 Feb 2007)
New Revision: 584

Modified:
   trunk/src/CacheWolf/CWPoint.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/TrackPoint.java
Log:
MovingMap: Bug fixed: kleine Geschwindigkeitsverbesserung

Modified: trunk/src/CacheWolf/CWPoint.java
===================================================================
--- trunk/src/CacheWolf/CWPoint.java	2007-02-14 03:13:50 UTC (rev 583)
+++ trunk/src/CacheWolf/CWPoint.java	2007-02-14 12:41:51 UTC (rev 584)
@@ -124,8 +124,10 @@
 	public CWPoint(String coord) {
 		set(coord);
 	}
+	public boolean equals (CWPoint p) {
+		return super.equals(p);
+	}
 
-
 	/**
 	 * Set lat and lon 
 	 * @param lat Latitude as decimal

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-14 03:13:50 UTC (rev 583)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-14 12:41:51 UTC (rev 584)
@@ -728,11 +728,12 @@
 	}
 
 	public void destChanged(CWPoint d) {
-		if(!running || d.equals(gotoPos)) return;
+		if(!running || (d == null && gotoPos == null) || 
+				(d != null && gotoPos != null && d.latDec == gotoPos.lat && d.lonDec == gotoPos.lon)) return;
 		removeGotoPosition();
 		if (d == null || !d.isValid() ) return;
 		gotoPos = addSymbol("goto", "goto_map.png", d.latDec, d.lonDec);
-		//updateDistance();
+		//updateDistance(); - this is called from updatePosition
 		forceMapLoad = true;
 		updatePosition(posCircleLat, posCircleLon);
 	}

Modified: trunk/src/CacheWolf/TrackPoint.java
===================================================================
--- trunk/src/CacheWolf/TrackPoint.java	2007-02-14 03:13:50 UTC (rev 583)
+++ trunk/src/CacheWolf/TrackPoint.java	2007-02-14 12:41:51 UTC (rev 584)
@@ -31,6 +31,9 @@
 		latDec = lat;
 		lonDec = lon;
 	}
+	public boolean equals(TrackPoint tp) {
+		return latDec == tp.latDec && lonDec == tp.lonDec;
+	}
 
 }
 



From salzkammergut at mail.berlios.de  Wed Feb 14 18:58:42 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Wed, 14 Feb 2007 18:58:42 +0100
Subject: [Cachewolf-svn] r585 - trunk/src/CacheWolf
Message-ID: <200702141758.l1EHwgia029689@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-14 18:58:39 +0100 (Wed, 14 Feb 2007)
New Revision: 585

Modified:
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/ProfilesForm.java
Log:
CW Erstinstallation: Im Profilauswahldialog erscheinen jetzt nicht mehr die alten Profile mit "null" Eintraegen
Wenn ein Profil nicht exisitiert, wird der Profilauswahldialog geoeffnet
Wenn keine Profile im Basisverzeichnis gefunden werden, muss eines erstellt oder abgebrochen werden


Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-02-14 12:41:51 UTC (rev 584)
+++ trunk/src/CacheWolf/Preferences.java	2007-02-14 17:58:39 UTC (rev 585)
@@ -25,21 +25,21 @@
 	 *  for spidering */
 	public CWPoint curCentrePt=new CWPoint();
 	/** Name of last used profile */
-	public String lastProfile=new String(); 
+	public String lastProfile=""; 
 	/** If true, the last profile is reloaded automatically without a dialogue */
 	public boolean autoReloadLastProfile=false; 
 	/** The base directory contains one subdirectory for each profile*/
-	public String baseDir = new String();  // TODO Set this initially to mydataDir ??
+	public String baseDir = "";  // TODO Set this initially to mydataDir ??
 
-	public String myproxy = new String();    
-	public String myproxyport = new String();
+	public String myproxy = "";    
+	public String myproxyport = "";
 	/** This is the login alias for geocaching.com and opencaching.de */
-	public String myAlias = new String();
+	public String myAlias = "";
 	/** This is an alternative alias used to identify found caches (i.e. if using multiple IDs) 
 	 *  It is currently not used yet */
-	public String myAlias2 = new String();
+	public String myAlias2 = "";
 	/** The path to the browser */
-	public String browser = new String();
+	public String browser = "";
 	public boolean showDeletedImages=true; /* Used in ImagePanel */
 	public boolean solverIgnoreCase=false;
 
@@ -49,12 +49,12 @@
 	public boolean dirty = false;
 
 	public int currProfile = 0;
-	public String profiles[] = new String[4];
-	public String profdirs[] = new String[4];
-	public String lats[] = new String[4];
-	public String longs[] = new String[4];
-	public String lastSyncOC[] = new String[4];
-	public String lastDistOC[] = new String[4];
+	public String profiles[] = {"","","",""};
+	public String profdirs[] = {"","","",""};
+	public String lats[] = {"","","",""};
+	public String longs[] = {"","","",""};
+	public String lastSyncOC[] = {"","","",""};
+	public String lastDistOC[] = {"","","",""};
 	public String garminConn="com1";  // The type of connection which GPSBABEL uses: com1 OR usb.
 	// These settings govern where the menu and the tabs are displayed and whether the statusbas is shown
 	public boolean menuAtTop=true;
@@ -84,7 +84,7 @@
 	private StringBuffer collectElement=null; 
 	private String lastName; // The string to the last XML that was processed
 
-	private final String LOGFILENAME="log.txt";
+	private final String LOGFILENAME=File.getProgramDirectory()+"/log.txt";
 	// The following declarations may eventually be moved to a separate class
 	/** The actual directory of a profile, for new profiles this is a direct child of baseDir */
 	//TODO Find all references amd move to profile.dataDir
@@ -186,7 +186,7 @@
 		String mapsDir = baseDir + mapsPath;
 		if (create && !(new File(mapsDir).isDirectory())) { // dir exists? 
 			if (new File(mapsDir).mkdirs() == false) {// dir creation failed?
-				(new MessageBox("Error", "Error: cannot create maps directory: \n"+mapsDir, MessageBox.OKB)).exec();
+				(new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(172,"Error: cannot create maps directory: \n")+mapsDir, MessageBox.OKB)).exec();
 				return null;
 			}
 		}
@@ -201,7 +201,7 @@
 		String mapsDir = Global.getPref().baseDir + "maps/expedia/" + subdir;
 		if (!(new File(mapsDir).isDirectory())) { // dir exists? 
 			if (new File(mapsDir).mkdirs() == false) // dir creation failed?
-			{(new MessageBox("Error", "Error: cannot create maps directory: \n"+new File(mapsDir).getParentFile(), MessageBox.OKB)).exec();
+			{(new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(172,"Error: cannot create maps directory: \n")+new File(mapsDir).getParentFile(), MessageBox.OKB)).exec();
 			return null;
 			}
 		}
@@ -243,7 +243,7 @@
 		if (baseDir.length()==0 || !(new File(baseDir)).exists()) {
 			do {
 				FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT,baseDir);
-				fc.title = "Select base directory for cache data";
+				fc.title = MyLocale.getMsg(170,"Select base directory for cache data");
 				// If no base directory given, terminate
 				if (fc.execute() == FileChooser.IDCANCEL) ewe.sys.Vm.exit(0);
 				baseDir = fc.getChosenFile().toString();
@@ -252,16 +252,23 @@
 		baseDir=baseDir.replace('\\','/');
 		if (!baseDir.endsWith("/")) baseDir+="/";
 		//Vm.showWait(false);
-		if((showProfileSelector==PROFILE_SELECTOR_FORCED_ON) || 
-				(showProfileSelector==PROFILE_SELECTOR_ONOROFF && !autoReloadLastProfile)){ // Ask for the profile
-			ProfilesForm f = new ProfilesForm(baseDir,profiles,lastProfile,hasNewButton);
-			int code = f.execute();
-			// If no profile chosen (includes a new one), terminate
-			if (code==-1) return false; // Cancel pressed
-			prof.clearProfile();
-			curCentrePt.set(0,0); // No centre yet
-			lastProfile=f.newSelectedProfile;
-		} 
+		boolean profileExists=true;  // Assume that the profile exists
+		do {	
+			if(!profileExists || (showProfileSelector==PROFILE_SELECTOR_FORCED_ON) || 
+					(showProfileSelector==PROFILE_SELECTOR_ONOROFF && !autoReloadLastProfile)){ // Ask for the profile
+				ProfilesForm f = new ProfilesForm(baseDir,profiles,lastProfile,!profileExists || hasNewButton);
+				int code = f.execute();
+				// If no profile chosen (includes a new one), terminate
+				if (code==-1) return false; // Cancel pressed
+				prof.clearProfile();
+				curCentrePt.set(0,0); // No centre yet
+				lastProfile=f.newSelectedProfile;
+			}
+			profileExists=(new File(baseDir+lastProfile)).exists();
+			if (!profileExists) (new MessageBox(MyLocale.getMsg(144,"Warning"),
+					           MyLocale.getMsg(171,"Profile does not exist: ")+lastProfile,MessageBox.MBOK)).execute();
+		} while (profileExists==false);
+		// Now we are sure that baseDir exists and basDir+profile exists
 		prof.name=lastProfile;
 		currProfile=-1;
 		if (lastProfile.equals(profiles[0])) openOldProfile(prof, 0);

Modified: trunk/src/CacheWolf/ProfilesForm.java
===================================================================
--- trunk/src/CacheWolf/ProfilesForm.java	2007-02-14 12:41:51 UTC (rev 584)
+++ trunk/src/CacheWolf/ProfilesForm.java	2007-02-14 17:58:39 UTC (rev 585)
@@ -92,6 +92,7 @@
 		addLast(spMList);
 		addNext(btnCancel = new mButton(MyLocale.getMsg(1604,"Cancel")),DONTSTRETCH,DONTFILL|LEFT);
 		addNext(btnOK = new mButton(MyLocale.getMsg(1605,"OK")),DONTSTRETCH,HFILL|RIGHT);
+		if (choice.getListItems().length==0) btnOK.modify(Disabled,0);
 		btnOK.setHotKey(0, IKeys.ENTER);
 		btnCancel.setHotKey(0, IKeys.ESCAPE);
 		this.baseDir=baseDir;
@@ -124,8 +125,10 @@
 			if (ev.target == btnOK || ev.target == choice){
 				Filter.filterActive=false;
 				Filter.filterInverted=false;
-				newSelectedProfile=choice.getSelectedItem().toString();
-				close(1);
+				if (choice.getSelectedItem()!=null) {
+					newSelectedProfile=choice.getSelectedItem().toString();
+					close(1);
+				}
 			}
 			if (ev.target == btnNew){
 				newSelectedProfile=createNewProfile();



From salzkammergut at mail.berlios.de  Wed Feb 14 19:01:06 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Wed, 14 Feb 2007 19:01:06 +0100
Subject: [Cachewolf-svn] r586 - trunk/resources
Message-ID: <200702141801.l1EI16NS000671@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-14 19:01:04 +0100 (Wed, 14 Feb 2007)
New Revision: 586

Modified:
   trunk/resources/cachewolf.Languages.cfg
Log:
Nachtrag zu vorheriger Revision (Internationalisierung von Preferences)

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-02-14 17:58:39 UTC (rev 585)
+++ trunk/resources/cachewolf.Languages.cfg	2007-02-14 18:01:04 UTC (rev 586)
@@ -56,6 +56,9 @@
 		160=Selektierte
 		161=Zeige Blacklist
 		162=kalibrierte herunterladen
+		170=Basisverzeichnis f%fc die Profile w%e4hlen
+		171=Profil existiert nicht:+
+		172=Kann das Kartenverzeichnis nicht erstellen:%0a
 		200=Details
 		201=Beschreibung
 		202=Bilder
@@ -89,13 +92,19 @@
 		323=Fehler beim Schreiben der Datei
 		324= - neu versuchen?
 		325=Zuwenige Referenzpunkte, Karte nicht kalibriert
-		326=Es steht keine kalibrierte Karte zur Verf%fcgung \n Bitte w%e4hlen Sie einen Ma%dfstab,\n in dem der Track und die markierten Caches angezeigt werden sollen
+		326=Es steht keine kalibrierte Karte zur Verf%fcgung %0a Bitte w%e4hlen Sie einen Ma%dfstab,%0a in dem der Track und die markierten Caches angezeigt werden sollen
 		327=Information
 		340=Cachebilder:
 		341=Eigene Bilder:
 		342=Gel%f6scht
 		343=Nicht genug Speicher um Bild zu laden
 		344=Datei l%f6schen
+		345=Gehe zu diesen Koordinaten
+		346=Zeige Travelbugs
+		347=Zeige Karte
+		348=Eigene Bilder hinzuf%fcgen
+		349=Blacklist-Status umschalten
+		350=Zeitstempel zu Notizen hinzuf%fcgen
 		400=Dekodieren
 		500=Umschalten
 		600=Pr%e4ferenzen
@@ -272,7 +281,7 @@
 		1618=Ignoriere Fehler in Cache:+
 		1619=: konnte Bild von folgender URL nicht downloaden:+
 		1620=download eingebundener Bilder:+
-		1621=Fehler beim Interpretieren\n der Update-Datei,\nDies ist vermutlich ein Fehler bei Opencaching.de\nSp%e4ter erneut versuchen\n Status:
+		1621=Fehler beim Interpretieren%0a der Update-Datei,%0aDies ist vermutlich ein Fehler bei Opencaching.de%0aSp%e4ter erneut versuchen%0a Status:
 		1700=Fehler in Zeile: 
 		1701=Spalte: 
 		1702=Variable nicht definiert: 
@@ -384,6 +393,9 @@
 		159=Filter
 		161=Show Blacklist
 		162=Download calibrated
+		170=Select base directory for cache data
+		171=Profile does not exist:+
+		172=Error: cannot create maps directory:%0a
 		200=Details
 		201=Description
 		202=Images
@@ -418,13 +430,19 @@
 		323=Fehler beim Schreiben der Datei
 		324= - retry?
 		325=Not enough reference points, map not calibrated
-		326=No calibrated map available. \n Please select a scale to display the track and caches.
+		326=No calibrated map available. %0a Please select a scale to display the track and caches.
 		327=Information
 		340=Cache Images:
 		341=User Images:
 		342=Deleted
 		343=Not enough free memory to load cache image
 		344=Delete image
+		345=Go to these coordinates
+		346=Show travelbugs
+		347=Show map
+		348=Add user pictures
+		349=Toggle Blacklist status
+		350=Add timestamp to notes
 		400=Dekode
 		500=Switch
 		600=Preferences
@@ -601,7 +619,7 @@
 		1618=Ignoring error in Cache:+
 		1619=: could not download image from URL:+
 		1620=downloading embedded images:+
-		1621=Error while interpreting data\n from Opencaching.de,\nThis is most probaly a bug at Opencaching.de\nRetry later\n Status:
+		1621=Error while interpreting data%0a from Opencaching.de,%0aThis is most probaly a bug at Opencaching.de%0aRetry later%0a Status:
 		1700=Error on line: 
 		1701= position: 
 		1702=Variable not defined: 



From salzkammergut at mail.berlios.de  Wed Feb 14 20:16:26 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Wed, 14 Feb 2007 20:16:26 +0100
Subject: [Cachewolf-svn] r587 - in trunk: resources src/CacheWolf
Message-ID: <200702141916.l1EJGQLO028085@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-14 20:16:22 +0100 (Wed, 14 Feb 2007)
New Revision: 587

Added:
   trunk/resources/filter.png
Modified:
   trunk/src/CacheWolf/StatusBar.java
Log:
Statusbar mit Klickbarem Filter ein/aus.
Filter ist jetzt ein Icon, nicht mehr "Flt"

Added: trunk/resources/filter.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/filter.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/src/CacheWolf/StatusBar.java
===================================================================
--- trunk/src/CacheWolf/StatusBar.java	2007-02-14 18:01:04 UTC (rev 586)
+++ trunk/src/CacheWolf/StatusBar.java	2007-02-14 19:16:22 UTC (rev 587)
@@ -3,6 +3,7 @@
 import ewe.sys.Vm;
 import ewe.ui.*;
 import ewe.util.*;
+import ewe.fx.*;
 
 /**
  * Class ID = 4500
@@ -13,13 +14,22 @@
 	DBStats stats;
 	mLabel disp,lblFlt,lblCenter;
 	Preferences pref;
+	mButton btnFlt;
+	mImage imgFlt;
 	
 	public StatusBar(Preferences p, Vector db){
 		pref=p;
 		stats = new DBStats(db);
 		addNext(disp = new mLabel(""),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		addNext(lblFlt= new mLabel("Flt"),CellConstants.DONTSTRETCH, CellConstants.DONTFILL); lblFlt.backGround=new ewe.fx.Color(0,255,0);
+		disp.setToolTip("Total # of caches (GC&OC)\nTotal # visible\nTotal # found");
+		addNext(btnFlt= new mButton(imgFlt=new mImage("filter.png")),CellConstants.DONTSTRETCH, CellConstants.DONTFILL); 
+		btnFlt.backGround=new ewe.fx.Color(0,255,0); 
+		btnFlt.setPreferredSize(20,13);
+		btnFlt.borderWidth=0; imgFlt.transparentColor=Color.White;
+		btnFlt.setToolTip("Filter status");
+//		addNext(lblFlt= new mLabel("Flt"),CellConstants.DONTSTRETCH, CellConstants.DONTFILL); lblFlt.backGround=new ewe.fx.Color(0,255,0);
 		addLast(lblCenter=new mLabel(""),CellConstants.STRETCH, WEST|CellConstants.FILL);
+		lblCenter.setToolTip("Current center");
 		updateDisplay();
 	}
 	
@@ -31,9 +41,9 @@
 		disp.setText(strStatus);
 		// Indicate that a filter is active in the status line
 		if (Filter.filterActive)
-			lblFlt.modify(0,Invisible); // Set the filter to "invisible"
+			btnFlt.backGround=new Color(0,255,0);
 		else
-			lblFlt.modify(Invisible,0); // Make filter visible
+			btnFlt.backGround=null;
 		// Current centre can only be displayed if screen is big
 		// Otherwise it forces a scrollbar
 		if (MyLocale.getScreenWidth()>=320) 
@@ -42,4 +52,20 @@
 		lblCenter.setText(strCenter);
 		relayout(true); // in case the numbers increased and need more space
 	}
+	
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
+			if (ev.target == btnFlt){
+				Filter flt = new Filter();
+				if (Filter.filterActive) {
+					flt.clearFilter();
+				} else {
+					flt.setFilter();
+					flt.doFilter();
+				}
+				Global.mainTab.tbP.refreshTable();
+			}
+		}
+		super.onEvent(ev);
+	}
 }



From salzkammergut at mail.berlios.de  Wed Feb 14 21:40:19 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Wed, 14 Feb 2007 21:40:19 +0100
Subject: [Cachewolf-svn] r588 - in trunk: resources src/CacheWolf
Message-ID: <200702142040.l1EKeJvQ003585@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-14 21:40:10 +0100 (Wed, 14 Feb 2007)
New Revision: 588

Added:
   trunk/resources/goto.png
   trunk/resources/newwpt.png
Modified:
   trunk/src/CacheWolf/DetailsPanel.java
Log:
DetailsPanel Layoutverbesserungen
Alle Icons gleich gro?\195?\159, am PC werden (deutsche) Tooltips angezeigt
Die Blacklistbuttons zeigen jetzt wirkliche Kreise und keine Quadrate
Texte durch Icons ersetzt, alle jetzt in einer Zeile

Added: trunk/resources/goto.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/goto.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/newwpt.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/newwpt.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-02-14 19:16:22 UTC (rev 587)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-02-14 20:40:10 UTC (rev 588)
@@ -32,9 +32,10 @@
 	private boolean blackStatus = false;
 	Preferences pref; // Test
 	Profile profile;
-	mImage mIsBlack;
-	mImage mNoBlack;
-	mImage mI, mI_no;
+	mImage imgBlack;
+	mImage imgBlackNo;
+	mImage imgShowBug, imgShowBugNo,imgNewWpt,imgGoto;
+	mImage imgShowMaps,imgAddImages;
 	
 	public DetailsPanel(){
 		pref = Global.getPref();
@@ -43,28 +44,37 @@
 		////////////////////
 		// Tools
 		////////////////////
-		pnlTools.addLast(btnNewWpt = new mButton(MyLocale.getMsg(311,"Create Waypoint")),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		pnlTools.addNext(btnGoto = new mButton("Goto"),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		mI = new mImage("bug.gif");
-		mI_no = new mImage("bug_no.gif");
-		mImage mI2 = new mImage("globe_small.gif");
-		
-		mImage mI4 = new mImage("images.gif");
-		mNoBlack = new mImage("no_black.png");
-		mIsBlack = new mImage("is_black.png");
-		btnShowBug = new mButton((IImage)mI_no);
-		btnShowMap = new mButton((IImage)mI2);
-		
-		btnAddDateTime = new mButton((IImage)new mImage("date_time.png"));
-		btnAddPicture = new mButton((IImage)mI4);
-		btnBlack = new mButton((IImage)mNoBlack);
-		pnlTools.addNext(btnShowBug,CellConstants.DONTSTRETCH, CellConstants.WEST);
+		// Button 1: New Waypoint
+		pnlTools.addNext(btnNewWpt = new mButton(imgNewWpt=new mImage("newwpt.png"))); 
+		btnNewWpt.setToolTip(MyLocale.getMsg(311,"Create Waypoint"));
+		PenEvent.wantPenMoved(btnNewWpt,PenEvent.WANT_PEN_MOVED_ONOFF,true);
+		imgNewWpt.transparentColor=new Color(255,0,0);
+		// Button 2: Goto
+		pnlTools.addNext(btnGoto = new mButton(imgGoto=new mImage("goto.png")));//Goto.gif funzt manchmal nicht
+		imgGoto.transparentColor=Color.White;
+		btnGoto.setToolTip(MyLocale.getMsg(345,"Goto these coordinates"));
+		// Button 3: Travelbugs
+		imgShowBug = new mImage("bug.gif");
+		imgShowBugNo = new mImage("bug_no.gif");
+		pnlTools.addNext(btnShowBug = new mButton(imgShowBugNo)); 
 		btnShowBug.modify(Control.Disabled,0);
-		pnlTools.addNext(btnShowMap,CellConstants.DONTSTRETCH, CellConstants.WEST);
-		pnlTools.addNext(btnAddPicture,CellConstants.DONTSTRETCH, CellConstants.WEST);
-		pnlTools.addNext(btnBlack,CellConstants.DONTSTRETCH, CellConstants.WEST);
-		pnlTools.addLast(btnAddDateTime,CellConstants.DONTSTRETCH, CellConstants.WEST);
+		btnShowBug.setToolTip(MyLocale.getMsg(346,"Show travelbugs"));
+		// Button 4: Show Map
+		pnlTools.addNext(btnShowMap = new mButton(imgShowMaps = new mImage("globe_small.gif"))); 
+		btnShowMap.setToolTip(MyLocale.getMsg(347,"Show map"));
+		// Button 5: Add images
+		pnlTools.addNext(btnAddPicture = new mButton(imgAddImages = new mImage("images.gif"))); 
+		btnAddPicture.setToolTip(MyLocale.getMsg(348,"Add user pictures"));
+		// Button 6: Toggle blacklist status
+		imgBlackNo = new mImage("no_black.png"); imgBlackNo.transparentColor=Color.Black;
+		imgBlack = new mImage("is_black.png"); imgBlack.transparentColor=Color.White;
+		pnlTools.addNext(btnBlack=new mButton(imgBlackNo)); 
+		btnBlack.setToolTip(MyLocale.getMsg(349,"Toggle Blacklist status"));
+		// Button 7: Date/time stamp
+		pnlTools.addLast(btnAddDateTime = new mButton(new mImage("date_time.png"))); 
+		btnAddDateTime.setToolTip(MyLocale.getMsg(350,"Add timestamp to notes"));
 		//showMap.modify(Control.Disabled,0);
+		pnlTools.stretchFirstRow=true;
 		this.addLast(pnlTools,CellConstants.DONTSTRETCH, CellConstants.WEST).setTag(SPAN,new Dimension(3,1));;
 		
 		////////////////////
@@ -123,18 +133,18 @@
 		
 		chcType.setInt(transType(ch.type));
 		if(ch.is_black){
-			btnBlack.image = mIsBlack;
+			btnBlack.image = imgBlack;
 		} else {
-			btnBlack.image = mNoBlack;
+			btnBlack.image = imgBlackNo;
 		}
 		blackStatus=ch.is_black; 
 		btnBlack.repaintNow();
 		if(ch.has_bug == true) {
 			btnShowBug.modify(Control.Disabled,1);
-			btnShowBug.image = mI;
+			btnShowBug.image = imgShowBug;
 		} else {
 			btnShowBug.modify(Control.Disabled,0);
-			btnShowBug.image = mI_no;
+			btnShowBug.image = imgShowBugNo;
 		}
 		btnShowBug.repaintNow();
 		if(ch.CacheSize.equals("Micro")) chcSize.setInt(1);
@@ -275,11 +285,11 @@
 			else if(ev.target == btnBlack){
 				if(thisCache.is_black) {
 					thisCache.is_black = false;
-					btnBlack.image = mNoBlack;
+					btnBlack.image = imgBlackNo;
 				}
 				else {
 					thisCache.is_black = true;
-					btnBlack.image = mIsBlack;
+					btnBlack.image = imgBlack;
 				}
 				blackStatus = thisCache.is_black;
 				btnBlack.repaintNow();



From bilbowolf at mail.berlios.de  Wed Feb 14 21:55:26 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Wed, 14 Feb 2007 21:55:26 +0100
Subject: [Cachewolf-svn] r589 - in trunk: resources src/CacheWolf
Message-ID: <200702142055.l1EKtQnY005519@sheep.berlios.de>

Author: bilbowolf
Date: 2007-02-14 21:55:19 +0100 (Wed, 14 Feb 2007)
New Revision: 589

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/OCXMLImporterScreen.java
   trunk/src/CacheWolf/SpiderGC.java
Log:
1. DNF markierung funktioniert beim spidern
2. Gefundene webcam caches werden erkannt
3. Archivierte caches werden korrect aktualisiert
4. log updates und beschr. updates werden beim spidern korrekt erkannt

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-02-14 20:40:10 UTC (rev 588)
+++ trunk/resources/cachewolf.Languages.cfg	2007-02-14 20:55:19 UTC (rev 589)
@@ -282,6 +282,7 @@
 		1619=: konnte Bild von folgender URL nicht downloaden:+
 		1620=download eingebundener Bilder:+
 		1621=Fehler beim Interpretieren%0a der Update-Datei,%0aDies ist vermutlich ein Fehler bei Opencaching.de%0aSp%e4ter erneut versuchen%0a Status:
+		1622=Gefundene caches laden
 		1700=Fehler in Zeile: 
 		1701=Spalte: 
 		1702=Variable nicht definiert: 

Modified: trunk/src/CacheWolf/OCXMLImporterScreen.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporterScreen.java	2007-02-14 20:40:10 UTC (rev 588)
+++ trunk/src/CacheWolf/OCXMLImporterScreen.java	2007-02-14 20:55:19 UTC (rev 589)
@@ -16,10 +16,11 @@
 	mButton cancelB, okB;
 	Preferences pref;
 	mInput distanceInput;
-	mCheckBox imagesCheckBox, /*mapsCheckBox, */ missingCheckBox;
+	mCheckBox imagesCheckBox, /*mapsCheckBox, */ missingCheckBox, foundCheckBox;
 	mLabel distLbl;
 	static int IMAGESANDMAPS = 0;
 	static int ALL = 1;
+	static int INCLUDEFOUND = 2;
 	
 	public OCXMLImporterScreen(String title, int options) {
 		super();
@@ -36,6 +37,11 @@
 		imagesCheckBox.setText(MyLocale.getMsg(1602,"Download Images"));
 		imagesCheckBox.setState(true); // @ToDo: aus Prefs
 		this.addLast(imagesCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+		if(options == INCLUDEFOUND){
+			foundCheckBox = new mCheckBox();
+			foundCheckBox.setText(MyLocale.getMsg(1622,"Include found caches"));
+			foundCheckBox.setState(false);
+		}
 /*		
 		mapsCheckBox = new mCheckBox();
 		mapsCheckBox.setText(MyLocale.getMsg(1603,"Download Maps"));

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-02-14 20:40:10 UTC (rev 588)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-02-14 20:55:19 UTC (rev 589)
@@ -118,6 +118,7 @@
 		Vm.showWait(true);
 		String notes = new String();
 		String start = new String();
+		String origLong = new String();
 		try{
 			ch.readCache(profile.dataDir);
 		}catch(IOException ioex){
@@ -133,56 +134,65 @@
 			start = fetch(doc);
 		}catch(Exception ex){
 			pref.log("Could not fetch " + ch.wayPoint);
-			Vm.debug("Couldn't get cache detail page");
+			//Vm.debug("Couldn't get cache detail page");
 		}
 		ch.is_new = false;
-		ch.is_update = true;
+		ch.is_update = false;
 		ch.is_HTML = true;
-		Vm.debug(ch.wayPoint);
+		ch.is_available = true;
+		ch.is_archived = false;
+		//Vm.debug(ch.wayPoint);
+		
 		if(start.indexOf("This cache is temporarily unavailable") >= 0) ch.is_available = false;
+		if(start.indexOf("This cache has been archived") >= 0) ch.is_archived = true;
 		pref.log("Trying logs");
+		int logsz = ch.CacheLogs.size();
 		ch.CacheLogs = getLogs(start, ch);
+		ch.is_log_update = false;
+		if(ch.CacheLogs.size()>logsz) ch.is_log_update = true;
 		pref.log("Found logs");
 		ch.LatLon = getLatLon(start);
 		ch.pos.set(ch.LatLon);
-		Vm.debug("LatLon: " + ch.LatLon);
+		//Vm.debug("LatLon: " + ch.LatLon);
 		pref.log("Trying description");
+		origLong = ch.LongDescription;
 		ch.LongDescription = getLongDesc(start);
+		if(!ch.LongDescription.equals(origLong)) ch.is_update = true;
 		pref.log("Got description");
 		pref.log("Getting cache name");
 		ch.CacheName = SafeXML.cleanback(getName(start));
 		pref.log("Got cache name");
-		Vm.debug("Name: " + ch.CacheName);
+		//Vm.debug("Name: " + ch.CacheName);
 		pref.log("Trying owner");
 		ch.CacheOwner = SafeXML.cleanback(getOwner(start));
 		if(ch.CacheOwner.equals(pref.myAlias + " ")) ch.is_owned = true;
 		pref.log("Got owner");
-		Vm.debug("Owner: " + ch.CacheOwner);
+		//Vm.debug("Owner: " + ch.CacheOwner);
 		pref.log("Trying date hidden");
 		ch.DateHidden = getDateHidden(start);
 		pref.log("Got date hidden");
-		Vm.debug("Hidden: " + ch.DateHidden);
+		//Vm.debug("Hidden: " + ch.DateHidden);
 		pref.log("Trying hints");
 		ch.Hints = getHints(start);
 		pref.log("Got hints");
-		Vm.debug("Hints: " + ch.Hints);
-		Vm.debug("Got the hints");
+		//Vm.debug("Hints: " + ch.Hints);
+		//Vm.debug("Got the hints");
 		pref.log("Trying size");
 		ch.CacheSize = getSize(start);
 		pref.log("Got size");
-		Vm.debug("Size: " + ch.CacheSize);
+		//Vm.debug("Size: " + ch.CacheSize);
 		pref.log("Trying difficulty");
 		ch.hard = getDiff(start);
 		pref.log("Got difficulty");
-		Vm.debug("Hard: " + ch.hard);
+		//Vm.debug("Hard: " + ch.hard);
 		pref.log("Trying terrain");
 		ch.terrain = getTerr(start);
 		pref.log("Got terrain");
-		Vm.debug("Terr: " + ch.terrain);
+		//Vm.debug("Terr: " + ch.terrain);
 		pref.log("Trying cache type");
 		ch.type = getType(start);
 		pref.log("Got cache type");
-		Vm.debug("Type: " + ch.type);
+		//Vm.debug("Type: " + ch.type);
 		pref.log("Trying images");
 		getImages(start, ch);
 		pref.log("Got images");
@@ -219,13 +229,14 @@
 			return;
 		}
 		
-		OCXMLImporterScreen options = new OCXMLImporterScreen("Spider Options", OCXMLImporterScreen.IMAGESANDMAPS);
+		OCXMLImporterScreen options = new OCXMLImporterScreen("Spider Options", OCXMLImporterScreen.INCLUDEFOUND);
 		options.distanceInput.setText("");
 		if (options.execute() == OCXMLImporterScreen.IDCANCEL) {Vm.showWait(false);	return; }
 		String dist = options.distanceInput.getText();
 		if (dist.length()== 0) return;
 		distance = Convert.toDouble(dist);
 		//boolean getMaps = options.mapsCheckBox.getState();
+		boolean getFound = options.foundCheckBox.getState();
 		boolean getImages = options.imagesCheckBox.getState();
 		options.close(0);
 		
@@ -234,7 +245,9 @@
 		infB.exec();
 		//Get first page
 		try{
-			pref.log("Fetching first list page: http://www.geocaching.com/seek/nearest.aspx?lat=" + origin.getLatDeg(CWPoint.DD) + "&lon=" +origin.getLonDeg(CWPoint.DD));
+			String ln = new String("Fetching first list page: http://www.geocaching.com/seek/nearest.aspx?lat=" + origin.getLatDeg(CWPoint.DD) + "&lon=" +origin.getLonDeg(CWPoint.DD));
+			if(getFound) ln = ln + "&f=1";
+			pref.log("First page: " + start);
 			start = fetch("http://www.geocaching.com/seek/nearest.aspx?lat=" + origin.getLatDeg(CWPoint.DD) + "&lon=" +origin.getLonDeg(CWPoint.DD));
 			pref.log("First page: " + start);
 		}catch(Exception ex){
@@ -314,8 +327,11 @@
 				}
 				ch.is_new = true;
 				ch.is_HTML = true;
+				ch.is_available = true;
+				ch.is_archived = false;
 				ch.wayPoint = wpt;
 				if(start.indexOf("This cache is temporarily unavailable") >= 0) ch.is_available = false;
+				if(start.indexOf("This cache has been archived") >= 0) ch.is_archived = true;
 				//Vm.debug(ch.wayPoint);
 				try{
 					pref.log("Trying logs");
@@ -326,6 +342,7 @@
 					//Vm.debug("LatLon: " + ch.LatLon);
 					pref.log("Trying description");
 					ch.LongDescription = getLongDesc(start);
+					
 					pref.log("Got description");
 					pref.log("Getting cache name");
 					ch.CacheName = SafeXML.cleanback(getName(start));
@@ -718,7 +735,7 @@
 			//Vm.debug("--------------------------------------------");
 			icon = exIcon.findNext();
 			name = exName.findNext();
-			if(icon.equals("icon_smile.gif") && name.equals(pref.myAlias)) {
+			if((icon.equals("icon_smile.gif") || icon.equals("icon_camera.gif")) && name.equals(pref.myAlias)) {
 				ch.is_found = true;
 				ch.CacheStatus = MyLocale.getMsg(318,"Found");
 			}
@@ -732,6 +749,15 @@
 			exDate.setSource(singleLog);
 			exLog.setSource(singleLog);
 		}
+		int z = 0;
+		String loganal = new String();
+		while(z < ch.CacheLogs.size() && z < 5){
+			loganal = (String)ch.CacheLogs.get(z);
+			if(loganal.indexOf("icon_sad")>0) {
+				z++;
+			}else break;
+		}
+		ch.noFindLogs = z;
 		return reslts;
 	}
 	



From salzkammergut at mail.berlios.de  Wed Feb 14 22:14:31 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Wed, 14 Feb 2007 22:14:31 +0100
Subject: [Cachewolf-svn] r590 - trunk/resources
Message-ID: <200702142114.l1ELEVaN008197@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-14 22:14:07 +0100 (Wed, 14 Feb 2007)
New Revision: 590

Modified:
   trunk/resources/no_black.png
Log:
Nachtrag zur DetailsPanelaenderung (danke Mik)

Modified: trunk/resources/no_black.png
===================================================================
(Binary files differ)



From salzkammergut at mail.berlios.de  Wed Feb 14 22:18:51 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Wed, 14 Feb 2007 22:18:51 +0100
Subject: [Cachewolf-svn] r591 - trunk/src/CacheWolf
Message-ID: <200702142118.l1ELIpGG009102@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-14 22:18:41 +0100 (Wed, 14 Feb 2007)
New Revision: 591

Modified:
   trunk/src/CacheWolf/DataMover.java
   trunk/src/CacheWolf/MainForm.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/Profile.java
Log:
Filter: Der Filterstatus (aktiv und/oder invertiert) wird beim Lesen des Profils wieder hergestellt
Die Blacklist wird immer deaktiviert.

Modified: trunk/src/CacheWolf/DataMover.java
===================================================================
--- trunk/src/CacheWolf/DataMover.java	2007-02-14 21:14:07 UTC (rev 590)
+++ trunk/src/CacheWolf/DataMover.java	2007-02-14 21:18:41 UTC (rev 591)
@@ -85,8 +85,8 @@
 				}
 			}//if srcHolder...
 		}//for ... i < srcDB ...
-		// write indexfiles
-		dstProfile.saveIndex(pref, Profile.NO_SHOW_PROGRESS_BAR);
+		// write indexfiles and keep the filter status
+		dstProfile.saveIndex(pref, Profile.NO_SHOW_PROGRESS_BAR,dstProfile.filterActive,dstProfile.filterInverted);
 	}
 	
 	public void moveCaches() {
@@ -136,7 +136,7 @@
 			}//if srcHolder...
 		}//for ... i < srcDB ...
 		// write indexfiles
-		dstProfile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
+		dstProfile.saveIndex(pref, Profile.NO_SHOW_PROGRESS_BAR,dstProfile.filterActive,dstProfile.filterInverted);
 		profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
 	}
 

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-02-14 21:14:07 UTC (rev 590)
+++ trunk/src/CacheWolf/MainForm.java	2007-02-14 21:18:41 UTC (rev 591)
@@ -67,9 +67,7 @@
 			profile.readIndex();
 			pref.curCentrePt.set(profile.centre);
 			profile.updateBearingDistance();
-			Filter flt=new Filter();
-			flt.setFilter();
-			flt.doFilter();
+			profile.restoreFilter();
 		} catch (Exception e){
 			if(pref.debug == true) Vm.debug("MainForm:: Exception:: " + e.toString());
 		}

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-02-14 21:14:07 UTC (rev 590)
+++ trunk/src/CacheWolf/MainMenu.java	2007-02-14 21:18:41 UTC (rev 591)
@@ -215,6 +215,7 @@
 						filtBlack.modifiers&=~MenuItem.Checked;
 						Filter.showBlacklisted=false;
 						infB.close(0);
+						profile.restoreFilter(); // Restore the isActive & isInverted status of the filter
 						tbp.resetModel();
 				}
 			}
@@ -497,19 +498,20 @@
 			}
 			if(mev.selectedItem == sysinfo){
 				//Vm.debug("Checking system...");
-				String sysstring = new String();
+				String sysstring;
 				Rect s = (Rect)Window.getGuiInfo(Window.INFO_SCREEN_RECT,null,new Rect(),0);
 				Font f = mApp.guiFont;
-				sysstring += "Platform: " + Vm.getPlatform() + "<br>";
-				sysstring += "Locale lang is: " + MyLocale.getLocaleLanguage() + "<br>";
-				sysstring += "Locale country is: " + MyLocale.getLocaleCountry() + "<br>";
-				sysstring += "Decimal seperator is: \"" + pref.digSeparator + "\"<br>";
-				sysstring += "Device is PDA: " + Vm.isMobile()+ "<br>";
-				sysstring += "Screen: " + MyLocale.getScreenWidth() + " x " + MyLocale.getScreenHeight() + "<br>";
-				sysstring += "Font size: " + f.getSize() + "<br>";
-				sysstring += "Entries in DB: " +cacheDB.size() + "<br>";
-				sysstring += "File seperator is: \"" + Vm.getProperty("file.separator","def")+ "\"<br>";
-				sysstring += "Programme directory is " + File.getProgramDirectory()+"<br>";
+				sysstring =  "Profile: " + profile.dataDir + "<br>" +
+							 "Platform: " + Vm.getPlatform() + "<br>" +
+							 "Locale lang is: " + MyLocale.getLocaleLanguage() + "<br>" +
+							 "Locale country is: " + MyLocale.getLocaleCountry() + "<br>"+
+							 "Decimal separator is: \"" + pref.digSeparator + "\"<br>" +
+							 "Device is PDA: " + Vm.isMobile()+ "<br>" +
+							 "Screen: " + MyLocale.getScreenWidth() + " x " + MyLocale.getScreenHeight() + "<br>"+
+							 "Font size: " + f.getSize() + "<br>" +
+							 "Entries in DB: " +cacheDB.size() + "<br>"+
+							 "File separator is: \"" + Vm.getProperty("file.separator","def")+ "\"<br>"+
+							 "Programme directory is " + File.getProgramDirectory()+"<br>";
 				InfoScreen is = new InfoScreen(sysstring, "System", false,pref);
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-02-14 21:14:07 UTC (rev 590)
+++ trunk/src/CacheWolf/Profile.java	2007-02-14 21:18:41 UTC (rev 591)
@@ -55,6 +55,9 @@
 	public String filterDist=new String("L");
 	public String filterDiff=new String("L");
 	public String filterTerr=new String("L");
+	// Saved filterstatus - is only refreshed from class Filter when Profile is saved
+	public boolean filterActive=false;
+	public boolean filterInverted=false;
 
 	public boolean selectionChanged = true; // ("H?ckchen") used by movingMap to get to knao if it should update the caches in the map 
 	/** True if the profile has been modified and not saved
@@ -82,15 +85,21 @@
 		hasUnsavedChanges=false;
 	}
 
-
 	/**
 	 *	Method to save the index.xml file that holds the total information
 	 *	on available caches in the database. The database is nothing else
 	 *	than the collection of caches in a directory.
 	 *   
 	 *   Not sure whether we need to keep 'pref' in method signature. May eventually remove it. 
+	 *   
+	 *   Saves the index with the filter settings from Filter
 	 */
 	public void saveIndex(Preferences pref, boolean showprogress){
+		saveIndex(pref,showprogress, Filter.filterActive,Filter.filterInverted);
+	}
+
+	/** Save index with filter settings given */ 
+	public void saveIndex(Preferences pref, boolean showprogress, boolean saveFilterActive, boolean saveFilterInverted){
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
 		if(showprogress){
@@ -123,7 +132,8 @@
 				distOC = "0";
 			}
 
-			detfile.print("    <FILTER rose = \""+filterRose+"\" type = \""+filterType+
+			detfile.print("    <FILTER status = \""+(saveFilterActive?"T":"F")+(saveFilterInverted?"T":"F")+ 
+					"\" rose = \""+filterRose+"\" type = \""+filterType+
 					"\" var = \""+filterVar+"\" dist = \""+filterDist.replace('"',' ')+"\" diff = \""+
 					filterDiff+"\" terr = \""+filterTerr+"\" size = \""+filterSize+"\" />\n");
 			detfile.print("    <SYNCOC date = \""+last_sync_opencaching+"\" dist = \""+distOC+"\"/>\n");
@@ -234,7 +244,13 @@
 					distOC=text.substring(start,text.indexOf("\"",start));
 				} else if (text.indexOf("<FILTER")>=0){
 					ex.setSource(text);
-					filterRose = ex.findNext();
+					String temp=ex.findNext(); // Filter status is now first, need to deal with old versions which don't have filter status
+					if (temp.length()==2) {
+						filterActive=temp.charAt(0)=='T';
+						filterInverted=temp.charAt(1)=='T';
+						filterRose = ex.findNext();
+					} else 
+						filterRose = temp;
 					filterType = ex.findNext();
 					filterVar = ex.findNext();
 					filterDist = ex.findNext();
@@ -256,6 +272,20 @@
 		normalizeFilters();
 		hasUnsavedChanges=false;
 	}
+	
+	/** Restore the filter to the values stored in this profile 
+	 *  Called from Main Form and MainMenu 
+	 *  The values of Filter.isActive and Filter.isInactive are set by the filter 
+	 **/
+	void restoreFilter() {
+		Filter flt=new Filter();
+		if (filterActive) {
+			flt.setFilter();
+			flt.doFilter();
+		}
+		if (filterInverted) 
+			flt.invertFilter();
+	}
 
 	public int getCacheIndex(String wp){
 		int retval = -1;



From bilbowolf at mail.berlios.de  Wed Feb 14 23:48:13 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Wed, 14 Feb 2007 23:48:13 +0100
Subject: [Cachewolf-svn] r592 - in trunk: resources src/CacheWolf
Message-ID: <200702142248.l1EMmDeo016131@sheep.berlios.de>

Author: bilbowolf
Date: 2007-02-14 23:48:11 +0100 (Wed, 14 Feb 2007)
New Revision: 592

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/OCXMLImporterScreen.java
Log:
Option gefundene Caches beim spider von gc.com anzuw?\195?\164hlen

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-02-14 21:18:41 UTC (rev 591)
+++ trunk/resources/cachewolf.Languages.cfg	2007-02-14 22:48:11 UTC (rev 592)
@@ -282,7 +282,7 @@
 		1619=: konnte Bild von folgender URL nicht downloaden:+
 		1620=download eingebundener Bilder:+
 		1621=Fehler beim Interpretieren%0a der Update-Datei,%0aDies ist vermutlich ein Fehler bei Opencaching.de%0aSp%e4ter erneut versuchen%0a Status:
-		1622=Gefundene caches laden
+		1622=Gefundene Caches laden
 		1700=Fehler in Zeile: 
 		1701=Spalte: 
 		1702=Variable nicht definiert: 

Modified: trunk/src/CacheWolf/OCXMLImporterScreen.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporterScreen.java	2007-02-14 21:18:41 UTC (rev 591)
+++ trunk/src/CacheWolf/OCXMLImporterScreen.java	2007-02-14 22:48:11 UTC (rev 592)
@@ -41,6 +41,7 @@
 			foundCheckBox = new mCheckBox();
 			foundCheckBox.setText(MyLocale.getMsg(1622,"Include found caches"));
 			foundCheckBox.setState(false);
+			this.addLast(foundCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
 		}
 /*		
 		mapsCheckBox = new mCheckBox();



From bilbowolf at mail.berlios.de  Wed Feb 14 23:54:18 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Wed, 14 Feb 2007 23:54:18 +0100
Subject: [Cachewolf-svn] r593 - trunk/src/CacheWolf
Message-ID: <200702142254.l1EMsI0M016356@sheep.berlios.de>

Author: bilbowolf
Date: 2007-02-14 23:54:15 +0100 (Wed, 14 Feb 2007)
New Revision: 593

Modified:
   trunk/src/CacheWolf/Version.java
Log:
Brauche neue Versionsnummer

Modified: trunk/src/CacheWolf/Version.java
===================================================================
--- trunk/src/CacheWolf/Version.java	2007-02-14 22:48:11 UTC (rev 592)
+++ trunk/src/CacheWolf/Version.java	2007-02-14 22:54:15 UTC (rev 593)
@@ -10,7 +10,7 @@
 	static final String VER_MAJOR = "";
 	static final String VER_MINOR = "";
 	static final String VER_BUILD = " RC ";
-	static final String VER_SVN ="$LastChangedRevision$";  // the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
+	static final String VER_SVN ="$LastChangedRevision$";  //the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
 	
 	/**
 	 * @return



From pfeffer at mail.berlios.de  Thu Feb 15 17:44:09 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 15 Feb 2007 17:44:09 +0100
Subject: [Cachewolf-svn] r594 - trunk/src/CacheWolf
Message-ID: <200702151644.l1FGi9H9013007@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-15 17:43:46 +0100 (Thu, 15 Feb 2007)
New Revision: 594

Modified:
   trunk/src/CacheWolf/SelectMap.java
Log:
KartenImport: Probleme mit mehreren . im Dateinamen beseitigt

Modified: trunk/src/CacheWolf/SelectMap.java
===================================================================
--- trunk/src/CacheWolf/SelectMap.java	2007-02-14 22:54:15 UTC (rev 593)
+++ trunk/src/CacheWolf/SelectMap.java	2007-02-15 16:43:46 UTC (rev 594)
@@ -39,12 +39,10 @@
 		try{
 			File files = new File(mapsPath);
 			File checkWFL;
-			Extractor ext;
 			String rawFileName = new String();
 			dateien = files.listMultiple("*.png,*.jpg,*.gif,*.bmp", File.LIST_FILES_ONLY);
 			for(int i = 0; i < dateien.length;i++){
-				ext = new Extractor(dateien[i], "", ".", 0, true);
-				rawFileName = ext.findNext();
+				rawFileName = dateien[i].substring(0, dateien[i].lastIndexOf("."));
 				checkWFL = new File(mapsPath + rawFileName + ".wfl");
 				
 				if(checkWFL.exists()){



From pfeffer at mail.berlios.de  Thu Feb 15 18:19:11 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 15 Feb 2007 18:19:11 +0100
Subject: [Cachewolf-svn] r595 - trunk/src/CacheWolf
Message-ID: <200702151719.l1FHJBsM021024@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-15 18:19:09 +0100 (Thu, 15 Feb 2007)
New Revision: 595

Modified:
   trunk/src/CacheWolf/MapLoader.java
Log:
Download kalibrierter Karten: kein "," mehr im Dateinamen

Modified: trunk/src/CacheWolf/MapLoader.java
===================================================================
--- trunk/src/CacheWolf/MapLoader.java	2007-02-15 16:43:46 UTC (rev 594)
+++ trunk/src/CacheWolf/MapLoader.java	2007-02-15 17:19:09 UTC (rev 595)
@@ -150,7 +150,7 @@
 		lonD.decimalPlaces = 4;
 		latD.set(lat);
 		lonD.set(lon);
-		return "expedia_alti"+alti+"_lat"+latD.toString().replace(',', '.')+"_lon"+lonD.toString()+".gif";
+		return "expedia_alti"+alti+"_lat"+latD.toString().replace(',', '.')+"_lon"+lonD.toString().replace(',', '.')+".gif";
 	}
 	
 	public void downloadMap(double lat, double lon, int alti, int PixelWidth, int PixelHeight, String path){



From bilbowolf at mail.berlios.de  Thu Feb 15 23:38:20 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Thu, 15 Feb 2007 23:38:20 +0100
Subject: [Cachewolf-svn] r596 - trunk/src/CacheWolf
Message-ID: <200702152238.l1FMcKWW019320@sheep.berlios.de>

Author: bilbowolf
Date: 2007-02-15 23:38:18 +0100 (Thu, 15 Feb 2007)
New Revision: 596

Modified:
   trunk/src/CacheWolf/SpiderGC.java
   trunk/src/CacheWolf/myTableModel.java
Log:
1) DNF im spider korrigiert
2) Punktreihenfolge ge?\195?\164ndert

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-02-15 17:19:09 UTC (rev 595)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-02-15 22:38:18 UTC (rev 596)
@@ -148,6 +148,15 @@
 		pref.log("Trying logs");
 		int logsz = ch.CacheLogs.size();
 		ch.CacheLogs = getLogs(start, ch);
+		int z = 0;
+		String loganal = new String();
+		while(z < ch.CacheLogs.size() && z < 5){
+			loganal = (String)ch.CacheLogs.get(z);
+			if(loganal.indexOf("icon_sad")>0) {
+				z++;
+			}else break;
+		}
+		ch.noFindLogs = z;
 		ch.is_log_update = false;
 		if(ch.CacheLogs.size()>logsz) ch.is_log_update = true;
 		pref.log("Found logs");
@@ -336,6 +345,15 @@
 				try{
 					pref.log("Trying logs");
 					ch.CacheLogs = getLogs(start, ch);
+					int z = 0;
+					String loganal = new String();
+					while(z < ch.CacheLogs.size() && z < 5){
+						loganal = (String)ch.CacheLogs.get(z);
+						if(loganal.indexOf("icon_sad")>0) {
+							z++;
+						}else break;
+					}
+					ch.noFindLogs = z;
 					pref.log("Found logs");
 					ch.LatLon = getLatLon(start);
 					ch.pos.set(ch.LatLon); // Slow parse no problem
@@ -427,17 +445,10 @@
 		} else return -1;
 	}
 	
-	/* wird nicht mehr gebraucht.
-	public void getMaps(CacheHolder holder){
-		if(holder.LatLon.length() > 4){
-			ParseLatLon pll = new ParseLatLon(holder.LatLon,".");
-			pll.parse();
-			MapLoader mpl = new MapLoader(pref.myproxy, pref.myproxyport);
-			//mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map.gif", "3");
-			//mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map_2.gif", "10");
-		}
+	public void getBugs(){	
+		
 	}
-	*/
+	
 	public void getAddWaypoints(String doc, CacheHolder ch){
 		Extractor exWayBlock = new Extractor(doc, "<strong>Additional Waypoints</strong><br>", "</table>", 0, false);
 		String wayBlock = new String();
@@ -463,25 +474,14 @@
 				else cx.LatLon = "---"; 
 				cx.pos.set(cx.LatLon);
 				if(typeRex.didMatch()) cx.type = CacheType.typeText2Number("Waypoint|"+typeRex.stringMatched(1));
-				
-				//Vm.debug("Name: " + nameRex.stringMatched(1));
-				//Vm.debug("K: " + koordRex.stringMatched(1));
-				/*
-				if(koordRex.didMatch()) cx.LatLon = koordRex.stringMatched(0);
-				if(typeRex.didMatch()) cx.type = CacheType.typeText2Number("Waypoint|"+typeRex.stringMatched(0));
-				cx.wayPoint = Convert.toString(counter) + ch.wayPoint.substring(2,5);
 				rowBlock = exRowBlock.findNext();
-				cx.LongDescription = noteRex.stringMatched(0);
-				
-				
-				*/
-				rowBlock = exRowBlock.findNext();
 				descRex.search(rowBlock);
 				cx.wayPoint = MyLocale.formatLong(counter, "00") + ch.wayPoint.substring(2);
 				counter++;
 				cx.LongDescription = descRex.stringMatched(1); 
 				//Vm.debug(descRex.stringMatched(1));
 				int idx=profile.getCacheIndex(cx.wayPoint);
+				cx.is_found = ch.is_found;
 				if (idx<0)
 					cacheDB.add(cx);
 				else if (((CacheHolder) cacheDB.get(idx)).is_Checked) // Only spider addi waypoints that are ticked
@@ -749,15 +749,6 @@
 			exDate.setSource(singleLog);
 			exLog.setSource(singleLog);
 		}
-		int z = 0;
-		String loganal = new String();
-		while(z < ch.CacheLogs.size() && z < 5){
-			loganal = (String)ch.CacheLogs.get(z);
-			if(loganal.indexOf("icon_sad")>0) {
-				z++;
-			}else break;
-		}
-		ch.noFindLogs = z;
 		return reslts;
 	}
 	

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-02-15 17:19:09 UTC (rev 595)
+++ trunk/src/CacheWolf/myTableModel.java	2007-02-15 22:38:18 UTC (rev 596)
@@ -223,9 +223,9 @@
 					case 3: // Terrain
 						return (String)ch.terrain;
 					case 4: // Waypoint
-						if(ch.is_log_update) return new IconAndText((IImage)blue, ch.wayPoint, fm);
 						if(ch.is_update    ) return new IconAndText((IImage)red, ch.wayPoint, fm);
 						if(ch.is_new       ) return new IconAndText((IImage)yellow, ch.wayPoint, fm);
+						if(ch.is_log_update) return new IconAndText((IImage)blue, ch.wayPoint, fm);
 						return (String)ch.wayPoint;
 					case 5: // Cachename
 						// Fast return for majority of case



From pfeffer at mail.berlios.de  Fri Feb 16 03:23:30 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Fri, 16 Feb 2007 03:23:30 +0100
Subject: [Cachewolf-svn] r597 - trunk/src/CacheWolf
Message-ID: <200702160223.l1G2NUh4011120@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-16 03:23:25 +0100 (Fri, 16 Feb 2007)
New Revision: 597

Modified:
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/TablePanel.java
   trunk/src/CacheWolf/myTableControl.java
   trunk/src/CacheWolf/myTableModel.java
Log:
Liste: Auswahl mit Pfeiltasten und Maus auch nach Umsortierung synchron
Liste: ein kleines bisschen aufger?\195?\164umt, muss noch weiter gemacht werden

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-02-15 22:38:18 UTC (rev 596)
+++ trunk/src/CacheWolf/MainTab.java	2007-02-16 02:23:25 UTC (rev 597)
@@ -80,7 +80,7 @@
 	}
 
 	public void selectAndActive(int rownum){
-		tbP.selectAndActive(rownum);
+		tbP.selectRow(rownum);
 		this.selectAndExpand(0);
 	}
 
@@ -93,12 +93,17 @@
 		(new MessageBox(MyLocale.getMsg(327,"Information"), MyLocale.getMsg(1024,"Entfernungen in der Listenansicht \nvom aktuellen Standpunkt aus \nneu berechnet").replace('~','\n'), MessageBox.OKB)).execute();
 	}
 
-	public void gotoPoint(String LatLon) {
-		gotoP.setDestinationAndSwitch(LatLon);
+	public void gotoPoint(String LatLon) { // TODO ?bergabe nicht als String
+		gotoP.setDestinationAndSwitch(LatLon); 
 	}
 
 	public void openDesciptionPanel(CacheHolder chi) {
 		MyLocale.setSIPOff();
+		int row = profile.getCacheIndex(chi.wayPoint);
+		tbP.selectRow(row);
+		//tbP.tc.scrollToVisible(row, 0);
+		//tbP.selectRow(row);
+		select(descP);
 		descP.setText(chi);
 	}
 
@@ -118,14 +123,14 @@
 		ch.type = "0";
 		ch.CacheSize = "None";
 		cacheDB.add(ch);
-		Global.mainTab.tbP.myMod.updateRows();
-		Global.mainTab.tbP.selectRow(profile.getCacheIndex(waypoint));
+		tbP.myMod.updateRows();
+		tbP.selectRow(profile.getCacheIndex(waypoint));
 		//Global.mainTab.tbP.refreshTable();
 		if (this.cardPanel.selectedItem==1) { // Detailpanel already selected
 			postEvent(new MultiPanelEvent(MultiPanelEvent.SELECTED,detP,0));
 		} else	
 			select(detP);
-		Global.mainTab.tbP.refreshTable();
+		tbP.refreshTable();
 
 	}
 

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-15 22:38:18 UTC (rev 596)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-16 02:23:25 UTC (rev 597)
@@ -1654,8 +1654,6 @@
 						close.type = WindowEvent.CLOSE;
 						mm.postEvent(close);
 						MainTab mainT = Global.mainTab;
-						mainT.tbP.selectAndActive(mm.cacheDB.find(clickedCache));
-						mainT.select(Global.mainTab.descP);
 						mainT.openDesciptionPanel(clickedCache);
 					}
 					if (action == newWayPointMenuItem) {

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-02-15 22:38:18 UTC (rev 596)
+++ trunk/src/CacheWolf/TablePanel.java	2007-02-16 02:23:25 UTC (rev 597)
@@ -41,7 +41,7 @@
 		tc.setTableModel(myMod);
 	}
 	
-	public void setSelectedCache(int row){
+	public void setSelectedCache(int row){ // TODO as far as i know selectedCh can be removed at all, use tc.cursor.y instead
 		selectedCh=null;
 		if (row>=0)  {
 			selectedCh=(CacheHolder) cacheDB.get(row);
@@ -53,10 +53,11 @@
 	/** Mark the row as selected so that myTableModel can color it grey */
 	public void selectRow(int row) {
 		setSelectedCache(row);
-		tc.clearSelectedCells(null);
+	/*	tc.clearSelectedCells(null);
 		for(int i= 0; i < myMod.MAXCOLUMNS; i++){
 			tc.addToSelection(row,i); 
 		}
+	*/	tc.cursorTo(row, tc.cursor.x+tc.listMode, true);
 	}
 	
 	/** Returns the index of the currently selected cache or -1 of the cache is no longer visible
@@ -87,10 +88,12 @@
 		pref.savePreferences();
 	}
 	
+	/*
 	public void selectAndActive(int rownum){
-		tc.scrollToVisible(rownum, 0);
+		//		tc.scrollToVisible(rownum, 0);
 		selectRow(rownum);  // color it in grey
 	}
+	*/
 	
 	public void resetModel() {
 		setSelectedCache(-1);
@@ -108,7 +111,7 @@
 	public void refreshTable(){
 		myMod.updateRows();
 		// Check whether the currently selected cache is still visible
-		Global.mainTab.tbP.selectRow(getSelectedCache());
+		selectRow(getSelectedCache());
 		tc.update(true); // Update and repaint
 		if (statBar!=null) statBar.updateDisplay();
 	}

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-02-15 22:38:18 UTC (rev 596)
+++ trunk/src/CacheWolf/myTableControl.java	2007-02-16 02:23:25 UTC (rev 597)
@@ -35,6 +35,7 @@
 		cacheDB = profile.cacheDB;
 		pref = Global.getPref();
 		tbp =tablePanel;
+		allowDragSelection = false; // allow only one row to be selected at one time
 	}
 
 	public void penRightReleased(Point p){

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-02-15 22:38:18 UTC (rev 596)
+++ trunk/src/CacheWolf/myTableModel.java	2007-02-16 02:23:25 UTC (rev 597)
@@ -216,14 +216,14 @@
 							return checkboxUnticked;
 					case 1: // Type
 						try {
-							return (IImage) cacheImages[Convert.parseInt(ch.type)];
+							return (IImage) cacheImages[Convert.parseInt(ch.type)]; // TODO save in cacheholder as int
 						} catch (NumberFormatException e) { return "?";}
 					case 2: // Difficulty;
 						return (String)ch.hard;
 					case 3: // Terrain
 						return (String)ch.terrain;
 					case 4: // Waypoint
-						if(ch.is_update    ) return new IconAndText((IImage)red, ch.wayPoint, fm);
+						if(ch.is_update    ) return new IconAndText((IImage)red, ch.wayPoint, fm); // TODO this is for sure quite inefficient, better store it, don't create always new when the table is refreshed or only scrolled
 						if(ch.is_new       ) return new IconAndText((IImage)yellow, ch.wayPoint, fm);
 						if(ch.is_log_update) return new IconAndText((IImage)blue, ch.wayPoint, fm);
 						return (String)ch.wayPoint;
@@ -297,12 +297,13 @@
 				if(a != null){
 					int rownum = Global.getProfile().getCacheIndex(ch.wayPoint);
 					if(rownum >= 0){
-						tcControl.scrollToVisible(rownum, 0);
+						tcControl.cursorTo(rownum, 0, true);
+	/*					tcControl.scrollToVisible(rownum, 0);
 						tcControl.clearSelectedCells(new Vector());
 						for(int i= 0; i < MAXCOLUMNS; i++){
 							tcControl.addToSelection(rownum,i); 
 						}
-					}
+		*/			}
 				}
 				Vm.showWait(false);
 				tcControl.update(true);



From pfeffer at mail.berlios.de  Fri Feb 16 03:34:53 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Fri, 16 Feb 2007 03:34:53 +0100
Subject: [Cachewolf-svn] r598 - trunk/src/CacheWolf
Message-ID: <200702160234.l1G2Yr8C011766@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-16 03:34:51 +0100 (Fri, 16 Feb 2007)
New Revision: 598

Modified:
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: Auswahl-ListBox der manuellen Kartenwahl nach SKG Wunsch auf PDA vergr?\195?\182?\195?\159ert 

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-16 02:23:25 UTC (rev 597)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-16 02:34:51 UTC (rev 598)
@@ -1689,7 +1689,8 @@
 	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos, MapInfoObject curMap){
 		this.title = "Maps";
 		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else 
-		this.setPreferredSize(MyLocale.getScreenWidth()*3/4, MyLocale.getScreenHeight()*3/4);
+		// set width to screenwidth *3/4 but to at least 240 if the screen is big engough for 240px width
+		this.setPreferredSize(java.lang.Math.max(MyLocale.getScreenWidth()*3/4, java.lang.Math.min(240, MyLocale.getScreenWidth()) ), MyLocale.getScreenHeight()*3/4);
 		this.maps = maps;
 		MapInfoObject map;
 		ScrollBarPanel scb;



From bilbowolf at mail.berlios.de  Fri Feb 16 12:23:54 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Fri, 16 Feb 2007 12:23:54 +0100
Subject: [Cachewolf-svn] r599 - trunk/src/CacheWolf
Message-ID: <200702161123.l1GBNs54014087@sheep.berlios.de>

Author: bilbowolf
Date: 2007-02-16 12:23:52 +0100 (Fri, 16 Feb 2007)
New Revision: 599

Modified:
   trunk/src/CacheWolf/Extractor.java
   trunk/src/CacheWolf/SpiderGC.java
Log:
dnf und bugs funktionieren nun beim spider

Modified: trunk/src/CacheWolf/Extractor.java
===================================================================
--- trunk/src/CacheWolf/Extractor.java	2007-02-16 02:34:51 UTC (rev 598)
+++ trunk/src/CacheWolf/Extractor.java	2007-02-16 11:23:52 UTC (rev 599)
@@ -13,7 +13,8 @@
 		String end;
 		String tst;
 		boolean betweenonly;
-		
+		public static boolean INCLUDESTARTEND = false;
+		public static boolean EXCLUDESTARTEND = true;
 		/**
 		*	Create an extractor.
 		*	sTxt = The string to search through.<br>

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-02-16 02:34:51 UTC (rev 598)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-02-16 11:23:52 UTC (rev 599)
@@ -197,6 +197,8 @@
 		pref.log("Trying terrain");
 		ch.terrain = getTerr(start);
 		pref.log("Got terrain");
+		ch.Bugs = getBugs(start);
+		if(ch.Bugs.length()>0) ch.has_bug = true; else ch.has_bug = false;
 		//Vm.debug("Terr: " + ch.terrain);
 		pref.log("Trying cache type");
 		ch.type = getType(start);
@@ -401,11 +403,8 @@
 						getImages(start, ch);
 						pref.log("Got images");
 					}
-	/*				if(getMaps){
-						pref.log("Trying maps");
-						getMaps(ch);
-						pref.log("Got maps");
-					} */
+					ch.Bugs = getBugs(start);
+					if(ch.Bugs.length()>0) ch.has_bug = true; else ch.has_bug = false;
 					pref.log("Getting additional waypoints");
 					getAddWaypoints(start, ch);
 					pref.log("Got additional waypoints");
@@ -445,8 +444,20 @@
 		} else return -1;
 	}
 	
-	public void getBugs(){	
-		
+	public String getBugs(String doc){	
+		Extractor exBlock = new Extractor(doc, "Inventory","What is a Travel Bug?",0,Extractor.EXCLUDESTARTEND);
+		String bugBlock = exBlock.findNext();
+		Vm.debug("Bugblock: "+bugBlock);
+		Extractor exBug = new Extractor(bugBlock, "'>", "</a></strong></td>",0,Extractor.EXCLUDESTARTEND);
+		String bug = new String();
+		String result = new String();
+		while(exBug.endOfSearch() == false){
+			bug= exBug.findNext();
+			if(bug.length()>0) result = result + "<b>Name:</b> "+ bug + "<br><hr>";
+			Vm.debug("B: " + bug);
+			Vm.debug("End? " + exBug.endOfSearch());
+		}
+		return result;
 	}
 	
 	public void getAddWaypoints(String doc, CacheHolder ch){



From bilbowolf at mail.berlios.de  Fri Feb 16 16:25:53 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Fri, 16 Feb 2007 16:25:53 +0100
Subject: [Cachewolf-svn] r600 - in trunk: resources src/CacheWolf
Message-ID: <200702161525.l1GFPrTa008482@sheep.berlios.de>

Author: bilbowolf
Date: 2007-02-16 16:25:49 +0100 (Fri, 16 Feb 2007)
New Revision: 600

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/OCXMLImporterScreen.java
   trunk/src/CacheWolf/SpiderGC.java
Log:
Gefunden beim spidern nicht laden korrigiert

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-02-16 11:23:52 UTC (rev 599)
+++ trunk/resources/cachewolf.Languages.cfg	2007-02-16 15:25:49 UTC (rev 600)
@@ -282,7 +282,7 @@
 		1619=: konnte Bild von folgender URL nicht downloaden:+
 		1620=download eingebundener Bilder:+
 		1621=Fehler beim Interpretieren%0a der Update-Datei,%0aDies ist vermutlich ein Fehler bei Opencaching.de%0aSp%e4ter erneut versuchen%0a Status:
-		1622=Gefundene Caches laden
+		1622=Gefundene Caches nicht laden
 		1700=Fehler in Zeile: 
 		1701=Spalte: 
 		1702=Variable nicht definiert: 

Modified: trunk/src/CacheWolf/OCXMLImporterScreen.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporterScreen.java	2007-02-16 11:23:52 UTC (rev 599)
+++ trunk/src/CacheWolf/OCXMLImporterScreen.java	2007-02-16 15:25:49 UTC (rev 600)
@@ -39,8 +39,8 @@
 		this.addLast(imagesCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
 		if(options == INCLUDEFOUND){
 			foundCheckBox = new mCheckBox();
-			foundCheckBox.setText(MyLocale.getMsg(1622,"Include found caches"));
-			foundCheckBox.setState(false);
+			foundCheckBox.setText(MyLocale.getMsg(1622,"Exclude found caches"));
+			foundCheckBox.setState(true);
 			this.addLast(foundCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
 		}
 /*		

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-02-16 11:23:52 UTC (rev 599)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-02-16 15:25:49 UTC (rev 600)
@@ -248,6 +248,7 @@
 		distance = Convert.toDouble(dist);
 		//boolean getMaps = options.mapsCheckBox.getState();
 		boolean getFound = options.foundCheckBox.getState();
+		Vm.debug("Get found? "+getFound);
 		boolean getImages = options.imagesCheckBox.getState();
 		options.close(0);
 		
@@ -256,11 +257,10 @@
 		infB.exec();
 		//Get first page
 		try{
-			String ln = new String("Fetching first list page: http://www.geocaching.com/seek/nearest.aspx?lat=" + origin.getLatDeg(CWPoint.DD) + "&lon=" +origin.getLonDeg(CWPoint.DD));
+			String ln = new String("http://www.geocaching.com/seek/nearest.aspx?lat=" + origin.getLatDeg(CWPoint.DD) + "&lon=" +origin.getLonDeg(CWPoint.DD));
 			if(getFound) ln = ln + "&f=1";
+			start = fetch(ln);
 			pref.log("First page: " + start);
-			start = fetch("http://www.geocaching.com/seek/nearest.aspx?lat=" + origin.getLatDeg(CWPoint.DD) + "&lon=" +origin.getLonDeg(CWPoint.DD));
-			pref.log("First page: " + start);
 		}catch(Exception ex){
 			pref.log("Error fetching first list page");
 			Vm.debug("Could not get list");



From pfeffer at mail.berlios.de  Fri Feb 16 18:43:26 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Fri, 16 Feb 2007 18:43:26 +0100
Subject: [Cachewolf-svn] r601 - trunk/src/CacheWolf
Message-ID: <200702161743.l1GHhQbI013686@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-16 18:43:15 +0100 (Fri, 16 Feb 2007)
New Revision: 601

Modified:
   trunk/src/CacheWolf/Profile.java
Log:
MapLoading: schlie?\195?\159t AddiWPs aus, die mehr als 1000km vom Main-Cache entfernt liegen

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-02-16 15:25:49 UTC (rev 600)
+++ trunk/src/CacheWolf/Profile.java	2007-02-16 17:43:15 UTC (rev 601)
@@ -39,10 +39,10 @@
 	public String last_sync_opencaching = new String();
 	/** Distance for opencaching caches */
 	public String distOC = new String();
-	
+
 	public final static boolean SHOW_PROGRESS_BAR = true;
 	public final static boolean NO_SHOW_PROGRESS_BAR = false;
-	
+
 	public final static String FILTERTYPE="11111111111111111";
 	public final static String FILTERROSE="1111111111111111";
 	public final static String FILTERVAR="11111111";
@@ -64,7 +64,7 @@
 	 * The following modifications set this flag: New profile centre, Change of waypoint data 
 	 */
 	public boolean hasUnsavedChanges = false;
-	
+
 	//TODO Add other settings, such as max. number of logs to spider
 	//TODO Add settings for the preferred mapper to allow for maps other than expedia and other resolutions
 
@@ -77,7 +77,7 @@
 
 	public void clearProfile() {
 		cacheDB.clear();
-		centre.set(0,0);
+		centre.set(-361,-361);
 		name="";
 		dataDir="";  
 		last_sync_opencaching = "";
@@ -147,9 +147,9 @@
 				////Vm.debug("Saving: " + ch.CacheName);
 				if(ch.wayPoint.length()>0 && ch.LongDescription.equals("An Error Has Occured") == false){
 					detfile.print("    <CACHE name = \""+SafeXML.clean(ch.CacheName)+"\" owner = \""+SafeXML.clean(ch.CacheOwner)+
-							 //"\" lat = \""+ SafeXML.clean(ch.LatLon) +
-							 "\" lat = \""+ ch.pos.latDec + "\" lon = \""+ch.pos.lonDec+
-							 "\" hidden = \""+ch.DateHidden+"\" wayp = \""+SafeXML.clean(ch.wayPoint)+"\" status = \""+ch.CacheStatus+"\" type = \""+ch.type+"\" dif = \""+ch.hard+"\" terrain = \"" + ch.terrain + "\" dirty = \"" + ch.dirty + "\" size = \""+ch.CacheSize+"\" online = \"" + Convert.toString(ch.is_available) + "\" archived = \"" + Convert.toString(ch.is_archived) + "\" has_bug = \"" + Convert.toString(ch.has_bug) + "\" black = \"" + Convert.toString(ch.is_black) + "\" owned = \"" + Convert.toString(ch.is_owned) + "\" found = \"" + Convert.toString(ch.is_found) + "\" is_new = \"" + Convert.toString(ch.is_new) +"\" is_log_update = \"" + Convert.toString(ch.is_log_update) + "\" is_update = \"" + Convert.toString(ch.is_update) + "\" is_HTML = \"" + Convert.toString(ch.is_HTML) + "\" DNFLOGS = \"" + ch.noFindLogs + "\" ocCacheID = \"" + ch.ocCacheID + "\" />\n");
+							//"\" lat = \""+ SafeXML.clean(ch.LatLon) +
+							"\" lat = \""+ ch.pos.latDec + "\" lon = \""+ch.pos.lonDec+
+							"\" hidden = \""+ch.DateHidden+"\" wayp = \""+SafeXML.clean(ch.wayPoint)+"\" status = \""+ch.CacheStatus+"\" type = \""+ch.type+"\" dif = \""+ch.hard+"\" terrain = \"" + ch.terrain + "\" dirty = \"" + ch.dirty + "\" size = \""+ch.CacheSize+"\" online = \"" + Convert.toString(ch.is_available) + "\" archived = \"" + Convert.toString(ch.is_archived) + "\" has_bug = \"" + Convert.toString(ch.has_bug) + "\" black = \"" + Convert.toString(ch.is_black) + "\" owned = \"" + Convert.toString(ch.is_owned) + "\" found = \"" + Convert.toString(ch.is_found) + "\" is_new = \"" + Convert.toString(ch.is_new) +"\" is_log_update = \"" + Convert.toString(ch.is_log_update) + "\" is_update = \"" + Convert.toString(ch.is_update) + "\" is_HTML = \"" + Convert.toString(ch.is_HTML) + "\" DNFLOGS = \"" + ch.noFindLogs + "\" ocCacheID = \"" + ch.ocCacheID + "\" />\n");
 				}
 			}
 			detfile.print("</CACHELIST>\n");
@@ -272,7 +272,7 @@
 		normalizeFilters();
 		hasUnsavedChanges=false;
 	}
-	
+
 	/** Restore the filter to the values stored in this profile 
 	 *  Called from Main Form and MainMenu 
 	 *  The values of Filter.isActive and Filter.isInactive are set by the filter 
@@ -341,6 +341,7 @@
 		CWPoint bottomright = null;
 		CWPoint tmpca = new CWPoint();
 		numCachesInArea = 0;
+		boolean isAddi = false;
 		for (int i=cacheDB.size()-1; i >= 0; i--) {
 			ch = (CacheHolder) cacheDB.get(i);
 			if (!onlyOfSelected || ch.is_Checked) {
@@ -349,13 +350,16 @@
 					ch.pos = new CWPoint(tmpca);
 				}
 				if (ch.pos.isValid() && ch.pos.latDec != 0 && ch.pos.lonDec != 0 ){ // TODO != 0 sollte rausgenommen werden sobald in der Liste vern?nftig mit nicht gesetzten pos umgegangen wird
-					if (topleft == null) topleft = new CWPoint(ch.pos);
-					if (bottomright == null) bottomright = new CWPoint(ch.pos);
-					if (topleft.latDec < ch.pos.latDec) topleft.latDec = ch.pos.latDec;
-					if (topleft.lonDec > ch.pos.lonDec) topleft.lonDec = ch.pos.lonDec;
-					if (bottomright.latDec > ch.pos.latDec) bottomright.latDec = ch.pos.latDec;
-					if (bottomright.lonDec < ch.pos.lonDec) bottomright.lonDec = ch.pos.lonDec;
-					numCachesInArea++;
+					isAddi = ch.isAddiWpt();
+				if (!isAddi || (isAddi && ch.pos.getDistance(ch.mainCache.pos) < 1000)) { // test for plausiblity of coordinates of Additional Waypoints: more then 1000 km away from main Waypoint is unplausible -> ignore it
+						if (topleft == null) topleft = new CWPoint(ch.pos);
+						if (bottomright == null) bottomright = new CWPoint(ch.pos);
+						if (topleft.latDec < ch.pos.latDec) topleft.latDec = ch.pos.latDec;
+						if (topleft.lonDec > ch.pos.lonDec) topleft.lonDec = ch.pos.lonDec;
+						if (bottomright.latDec > ch.pos.latDec) bottomright.latDec = ch.pos.latDec;
+						if (bottomright.lonDec < ch.pos.lonDec) bottomright.lonDec = ch.pos.lonDec;
+						numCachesInArea++;
+					}
 				}
 			}
 		}
@@ -427,14 +431,14 @@
 			if (ch.hasAddiWpt() && (ch.addiWpts.size()> 1)){
 				//ch.addiWpts.sort(new MyComparer(ch.addiWpts,MyLocale.getMsg(1002,"Waypoint"),ch.addiWpts.size()), false);
 				ch.addiWpts.sort(
-					new ewe.util.Comparer() {	
-						public int compare(Object o1, Object o2){
-							return ((CacheHolder) o1).wayPoint.compareTo(((CacheHolder)o2).wayPoint);
-						}
-					},false );
+						new ewe.util.Comparer() {	
+							public int compare(Object o1, Object o2){
+								return ((CacheHolder) o1).wayPoint.compareTo(((CacheHolder)o2).wayPoint);
+							}
+						},false );
 			}
 		}
-	
+
 	}
 
 	/** Ensure that all filters have the proper length so that the 'charAt' access in the filter



From pfeffer at mail.berlios.de  Fri Feb 16 19:04:36 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Fri, 16 Feb 2007 19:04:36 +0100
Subject: [Cachewolf-svn] r602 - trunk/src/CacheWolf
Message-ID: <200702161804.l1GI4a0S008787@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-16 19:04:28 +0100 (Fri, 16 Feb 2007)
New Revision: 602

Modified:
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/SpiderGC.java
Log:
Neue Fehlermeldung, wenn Zetrumskoos nicht gesetzt sind beim Download von OC und beim Spidern von GC. K?\195?\182nnte evtl. wieder entfernt werden, wenn beim Anlegen eine Profils die Angabe von Zentrumskoos erzwungen wird.

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-02-16 17:43:15 UTC (rev 601)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-02-16 18:04:28 UTC (rev 602)
@@ -84,7 +84,10 @@
 
 			String lastS =  profile.last_sync_opencaching;
 			CWPoint center = pref.curCentrePt; // No need to clone curCentrePt as center is only read
-
+			if (!center.isValid()) {
+				(new MessageBox("Error", "Coordinates for center must be set", MessageBox.OKB)).execute();
+				return;
+			}
 			OCXMLImporterScreen importOpt = new OCXMLImporterScreen( MyLocale.getMsg(1600, "Opencaching.de Download"),OCXMLImporterScreen.ALL);
 			if (importOpt.execute() == OCXMLImporterScreen.IDCANCEL) {	return; }
 			Vm.showWait(true);

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-02-16 17:43:15 UTC (rev 601)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-02-16 18:04:28 UTC (rev 602)
@@ -228,9 +228,13 @@
 	*	Method to start the spider for a search around the center coordinates
 	*/
 	public void doIt(){
+		CWPoint origin = pref.curCentrePt; // No need to copy curCentrePt as it is only read and not written
+		if (!origin.isValid()) {
+			(new MessageBox("Error", "Coordinates for center must be set", MessageBox.OKB)).execute();
+			return;
+		}
 		Vm.showWait(true);
 		String start = new String();
-		CWPoint origin = pref.curCentrePt; // No need to copy curCentrePt as it is only read and not written
 		Regex rex = new Regex("name=\"__VIEWSTATE\" value=\"(.*)\" />");
 		String doc = new String();
 		



From salzkammergut at mail.berlios.de  Fri Feb 16 20:27:19 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Fri, 16 Feb 2007 20:27:19 +0100
Subject: [Cachewolf-svn] r603 - in trunk: resources src/CacheWolf
Message-ID: <200702161927.l1GJRJjW004309@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-16 20:27:14 +0100 (Fri, 16 Feb 2007)
New Revision: 603

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/SolverPanel.java
Log:
Solver: Internationalisierung und Bugfix
Bei Aenderung von Cache-Koordinaten werden auch die Richtung und Distanz zum Zentrum gesetzt

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-02-16 18:04:28 UTC (rev 602)
+++ trunk/resources/cachewolf.Languages.cfg	2007-02-16 19:27:14 UTC (rev 603)
@@ -314,7 +314,12 @@
 		1730=Fehlendes " am Ende der Zeichenkette
 		1731=Nicht erlaubtes Formatierungzeichen
 		1732=Nicht erlaubtes Zeichen
-		1733=Befehl eingeben		
+		1733=Befehl eingeben
+		1734=Ausgabebereich l%f6schen
+		1735=Rechne!
+		1736=Laden
+		1737=Speichern
+		1738=Speichern als	
 		1800=Georeferenzierte Karten herunterladen
 		1801=Kacheln herunterladen
 		2000=GPX Export
@@ -652,7 +657,12 @@
 		1730=Unterminated string
 		1731=Invalid format character
 		1732=Invalid character
-		1733=Input command		
+		1733=Input command	
+		1734=Clear output
+		1735=Solve!
+		1736=Load
+		1737=Save
+		1738=SaveAs	
 		1800=Download georeferenced maps
 		1801=Download tiles
 		2000=GPX Export

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-02-16 18:04:28 UTC (rev 602)
+++ trunk/src/CacheWolf/Parser.java	2007-02-16 19:27:14 UTC (rev 603)
@@ -102,7 +102,7 @@
     	new fnType("crosstotal","ct",6),
     	new fnType("ct","ct",2),
      	new fnType("curpos","cp",1),
-     	new fnType("distance","distance",2),
+     	new fnType("distance","distance",4),
      	new fnType("encode","encode",8),
     	new fnType("format","format",6),
     	new fnType("goto","goto",6),
@@ -393,9 +393,10 @@
     private double funcDistance() throws Exception {
     	String coordB=popCalcStackAsString();
     	String coordA=popCalcStackAsString();
+		// Attention: isValidCoord has sideeffect of setting cwPt
+    	if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordA);
+		if (!isValidCoord(coordB)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordB);
     	cwPt.set(coordA);
-		if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordA);
-		if (!isValidCoord(coordB)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordB);
     	return cwPt.getDistance(new CWPoint(coordB));
     }
     
@@ -403,10 +404,10 @@
     private double funcBearing() throws Exception {
     	String coordB=popCalcStackAsString();
     	String coordA=popCalcStackAsString();
-    	cwPt.set(coordA);
-		if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordA);
+ 		if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordA);
 		if (!isValidCoord(coordB)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordB);
-    	return cwPt.getBearing(new CWPoint(coordB));
+	   	cwPt.set(coordA);
+	   	return cwPt.getBearing(new CWPoint(coordB));
     }
     /**
      * Encode a string by replacing all characters in a string with their corresponding characters in
@@ -466,6 +467,7 @@
     		CacheHolder ch=((CacheHolder)Global.getProfile().cacheDB.get(i));
     		ch.LatLon=cwPt.toString(CWPoint.CW);
     		ch.pos.set(cwPt);
+    		ch.calcDistance(Global.getPref().curCentrePt); // Update distance/bearing 
     	}
     }
     
@@ -685,6 +687,7 @@
 				if (cwPt.isValid() || coord.equals("")) { // Can clear coord with empty string
 					ch.LatLon=cwPt.toString(CWPoint.CW);
 					ch.pos.set(cwPt);
+					ch.calcDistance(Global.getPref().curCentrePt); // Update distance and bearing
 				    return;
 				} else
 					err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coord);

Modified: trunk/src/CacheWolf/SolverPanel.java
===================================================================
--- trunk/src/CacheWolf/SolverPanel.java	2007-02-16 18:04:28 UTC (rev 602)
+++ trunk/src/CacheWolf/SolverPanel.java	2007-02-16 19:27:14 UTC (rev 603)
@@ -32,7 +32,7 @@
 		OutputPanel() {
 			this.modify(Control.NotEditable,0);
 			//this.modifiers=this.modifiers|WantHoldDown; 
-			setMenu(mnuContext=getClipboardMenu(new Menu(new MenuItem[]{ mnuClr=new MenuItem("Clear output") },"")));
+			setMenu(mnuContext=getClipboardMenu(new Menu(new MenuItem[]{ mnuClr=new MenuItem(MyLocale.getMsg(1734,"Clear output")) },"")));
 		} 
 		public void penRightReleased(Point p){
 			setMenu(mnuContext);
@@ -71,10 +71,10 @@
 		split.setSplitter(PanelSplitter.AFTER|PanelSplitter.HIDDEN,PanelSplitter.BEFORE|PanelSplitter.HIDDEN,0);
 
 		programPanel.addLast(new ScrollBarPanel(mText = new InputPanel()));
-		programPanel.addNext(mBtSolve= new mButton("Solve!"),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		programPanel.addNext(btnLoad= new mButton("Load"),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		programPanel.addNext(btnSave= new mButton("Save"),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		programPanel.addLast(btnSaveAs= new mButton("SaveAs"),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		programPanel.addNext(mBtSolve= new mButton(MyLocale.getMsg(1735,"Solve!")),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		programPanel.addNext(btnLoad= new mButton(MyLocale.getMsg(1736,"Load")),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		programPanel.addNext(btnSave= new mButton(MyLocale.getMsg(1737,"Save")),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		programPanel.addLast(btnSaveAs= new mButton(MyLocale.getMsg(1738,"SaveAs")),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		outputPanel.addLast(new ScrollBarPanel(mOutput = new OutputPanel()));
 
 		this.addLast(split);



From bilbowolf at mail.berlios.de  Sat Feb 17 08:57:04 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Sat, 17 Feb 2007 08:57:04 +0100
Subject: [Cachewolf-svn] r604 - trunk/src/CacheWolf
Message-ID: <200702170757.l1H7v48H032112@sheep.berlios.de>

Author: bilbowolf
Date: 2007-02-17 08:57:03 +0100 (Sat, 17 Feb 2007)
New Revision: 604

Modified:
   trunk/src/CacheWolf/Filter.java
   trunk/src/CacheWolf/FilterScreen.java
   trunk/src/CacheWolf/Profile.java
Log:
CITO wird nun korrekt vom Filter erkannt.

Modified: trunk/src/CacheWolf/Filter.java
===================================================================
--- trunk/src/CacheWolf/Filter.java	2007-02-16 19:27:14 UTC (rev 603)
+++ trunk/src/CacheWolf/Filter.java	2007-02-17 07:57:03 UTC (rev 604)
@@ -39,8 +39,9 @@
 	private static final int FINAL = 16384;
 	private static final int TRAILHEAD = 32768;
 	private static final int REFERENCE = 65536;
+	private static final int CITO = 131072;
 	private static final int TYPE_ALL=TRADITIONAL|MULTI|VIRTUAL|LETTER|EVENT|WEBCAM|MYSTERY|LOCLESS|CUSTOM
-	                                  |MEGA|EARTH|PARKING|STAGE|QUESTION|FINAL|TRAILHEAD|REFERENCE;
+	                                  |MEGA|EARTH|PARKING|STAGE|QUESTION|FINAL|TRAILHEAD|REFERENCE|CITO;
 
 	private static final int N = 1;
 	private static final int NNE = 2;
@@ -257,6 +258,7 @@
 		if (filterType.charAt(14) == '1') typeMatchPattern|=FINAL;
 		if (filterType.charAt(15) == '1') typeMatchPattern|=TRAILHEAD;
 		if (filterType.charAt(16) == '1') typeMatchPattern|=REFERENCE;
+		if (filterType.charAt(17) == '1') typeMatchPattern|=CITO;
 		hasTypeMatchPattern= typeMatchPattern!=TYPE_ALL;
 		roseMatchPattern=0;
 		String filterRose=profile.filterRose;
@@ -347,6 +349,7 @@
 				else if(ch.type.equals("53"))cacheTypePattern = FINAL;
 				else if(ch.type.equals("54"))cacheTypePattern = TRAILHEAD;
 				else if(ch.type.equals("55"))cacheTypePattern = REFERENCE;
+				else if(ch.type.equals("13"))cacheTypePattern = CITO;
 				if ((cacheTypePattern & typeMatchPattern) == 0) { ch.is_filtered=true; continue; }
 			}			
 			///////////////////////////////

Modified: trunk/src/CacheWolf/FilterScreen.java
===================================================================
--- trunk/src/CacheWolf/FilterScreen.java	2007-02-16 19:27:14 UTC (rev 603)
+++ trunk/src/CacheWolf/FilterScreen.java	2007-02-17 07:57:03 UTC (rev 604)
@@ -23,7 +23,7 @@
 	private mCheckBox chkFound, chkNotFound, chkTrad, chkVirtual, chkEvent, chkEarth, chkMega,
 					  chkOwned, chkNotOwned, chkMulti, chkLetter, chkWebcam, chkMystery, chkLocless,
 	                  chkCustom,chkParking,	chkStage, chkQuestion, chkFinal, chkTrailhead, chkReference,
-					  chkMicro,chkSmall,chkRegular,chkLarge,chkVeryLarge,chkOther,
+					  chkMicro,chkSmall,chkRegular,chkLarge,chkVeryLarge,chkOther,chkCito,
 	                  chkArchived,chkNotArchived, chkAvailable,chkNotAvailable,
 					  chkNW, chkNNW , chkN , chkNNE, chkNE, chkENE, chkE, chkESE, chkSE, chkSSE, chkS,
 					  chkSSW, chkSW, chkWSW, chkW, chkWNW, chkDeselect,chkSelect;
@@ -190,13 +190,16 @@
 		pnlCacheTypes.addNext(addImg("453.png"));
 		pnlCacheTypes.addLast(chkMega = new mCheckBox("Mega-Ev."), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		
+		pnlCacheTypes.addNext(addImg("13.png"));
+		pnlCacheTypes.addNext(chkCito = new mCheckBox("Cito-Ev."), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		
 		//pnlCacheTypes.addLast(addiWptChk = new mCheckBox("Add. Wpt"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		//pnlCacheTypes.addLast(new mLabel(""));
 		pnlCacheTypes.addNext(addImg("0.png"));
-		pnlCacheTypes.addNext(chkCustom = new mCheckBox("Custom"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlCacheTypes.addLast(chkCustom = new mCheckBox("Custom"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 
 		pnlCacheTypes.addNext(addImg("110.png"));
-		pnlCacheTypes.addLast(addiWptChk = new myChkBox("Add. Wpt"), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlCacheTypes.addNext(addiWptChk = new myChkBox("Add. Wpt"), CellConstants.DONTSTRETCH, CellConstants.FILL);
 
 		//addiWptChk.modify(0,NotAnEditor);
 		//////////////////////////
@@ -368,6 +371,8 @@
 		chkLocless.state    = fltType.charAt(8) == '1';
 		chkMega.state       = fltType.charAt(9) == '1';
 		chkCustom.state     = fltType.charAt(10) == '1';
+		chkCito.state       = fltType.charAt(17) == '1';
+		
 		// Note addiWptState is set by setColors
 		
 		//////////////////////////
@@ -462,7 +467,7 @@
 		chkFinal.state && chkTrailhead.state && chkReference.state) ;
 		if (!(chkTrad.state && chkMulti.state && 	chkVirtual.state && chkLetter.state &&
 		      chkEvent.state && chkWebcam.state && chkMystery.state && chkEarth.state &&
-		      chkLocless.state && chkMega.state && chkCustom.state && allAddis) ) 
+		      chkLocless.state && chkMega.state && chkCito.state && chkCustom.state && allAddis) ) 
 			btnTypes.backGround=COLOR_FILTERACTIVE;
 		else
 			btnTypes.backGround=COLOR_FILTERINACTIVE;
@@ -470,7 +475,7 @@
 			      chkEvent.state || chkWebcam.state || chkMystery.state || chkEarth.state ||
 			      chkLocless.state || chkMega.state || chkCustom.state || chkParking.state 
 			      || chkStage.state || chkQuestion.state || 
-					chkFinal.state || chkTrailhead.state || chkReference.state )) 
+					chkFinal.state || chkTrailhead.state || chkCito.state || chkReference.state )) 
 			btnTypes.backGround=COLOR_FILTERALL;
 		btnTypes.repaint();
 
@@ -544,7 +549,8 @@
 								(chkQuestion.state? "1" : "0") +
 								(chkFinal.state   ? "1" : "0") +
 								(chkTrailhead.state ? "1" : "0") +
-								(chkReference.state ? "1" : "0");
+								(chkReference.state ? "1" : "0")+
+								(chkCito.state ? "1" : "0");
 				
 				pfl.filterRose = (chkNW.state  ? "1":"0")+
 							 (chkNNW.state ? "1":"0")+

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-02-16 19:27:14 UTC (rev 603)
+++ trunk/src/CacheWolf/Profile.java	2007-02-17 07:57:03 UTC (rev 604)
@@ -43,7 +43,7 @@
 	public final static boolean SHOW_PROGRESS_BAR = true;
 	public final static boolean NO_SHOW_PROGRESS_BAR = false;
 
-	public final static String FILTERTYPE="11111111111111111";
+	public final static String FILTERTYPE="111111111111111111";
 	public final static String FILTERROSE="1111111111111111";
 	public final static String FILTERVAR="11111111";
 	public final static String FILTERSIZE="111111";
@@ -252,12 +252,14 @@
 					} else 
 						filterRose = temp;
 					filterType = ex.findNext();
+					//Need this to stay "downward" compatible. New type introduced
+					if(filterType.length()<=17) filterType = filterType + "1";
+					Vm.debug("fil len: " +filterType.length());
 					filterVar = ex.findNext();
 					filterDist = ex.findNext();
 					filterDiff = ex.findNext();
 					filterTerr = ex.findNext();
 					filterSize = ex.findNext();
-//					Bilbowolf: Pattern for storing filter <FILTER type="01001101" rose = "010010101" var = "0101" dist = "<12" diff = ">13" terr = "<1"/>
 				}
 			}
 			in.close();



From admin at berlios.de  Sat Feb 17 13:51:57 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sat, 17 Feb 2007 13:51:57 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #2990] Import von anderen Kalibrirungsfiles
Message-ID: <200702171251.l1HCpvYo026079@unicorn.berlios.de>

Feature Request #2990, was updated on 2006-Dec-22 17:41
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2990&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Import von anderen Kalibrirungsfiles

By: kalli
Date: 2006-Dec-22 17:41

Message:
Logged In: YES 
user_id=24621
Browser: Mozilla/5.0 (compatible; Konqueror/3.5; Linux) KHTML/3.5.2 (like Gecko) Kubuntu 6.06 Dapper

Nach dem Tod von NHTop50Trans tauchen ?fters 
Fragen nach dem Import von anderen Formaten 
auf. Vielleicht sollte man hier gleich eine saubere 
Importschnittstelle definieren, die zum einen das 
Dateiformat automatisch erkennt (meist gibt es 
einen Header) und dann die entprechende 
Importmethode aufruft. als Ergebnis kommt dann 
eh ein .wfl-File raus.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=2990&group_id=2211


From kalli at mail.berlios.de  Sat Feb 17 15:04:35 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Sat, 17 Feb 2007 15:04:35 +0100
Subject: [Cachewolf-svn] r605 - trunk
Message-ID: <200702171404.l1HE4Zs6029041@sheep.berlios.de>

Author: kalli
Date: 2007-02-17 15:04:11 +0100 (Sat, 17 Feb 2007)
New Revision: 605

Modified:
   trunk/cwberlios.jnf
Log:
bin/exp/*.class war nicht drin

Modified: trunk/cwberlios.jnf
===================================================================
--- trunk/cwberlios.jnf	2007-02-17 07:57:03 UTC (rev 604)
+++ trunk/cwberlios.jnf	2007-02-17 14:04:11 UTC (rev 605)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B12M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2%252526%25253DPocketPC%25252B2003%252526%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253DPocketPC%25252B-%25252BMIPS%252526%25253DPocketPC%25252B-%25252BSH3%252526%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&createWithPnf=true&eweInfo=outputFile%3D./work/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources%252526!
 mask%25253D*.gif;*.png;*.ico;*.tp;*.zip;*.html%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources/%252526mask%25253Dcachewolf.Languages.cfg%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D_config/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./lib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B12M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26ad!
 dInstallFile%3Dfalse%26usePool%3Dtrue%26useClassPool%3Dfalse&i!
 con=(Def
ault)
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B12M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2%252526%25253DPocketPC%25252B2003%252526%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253DPocketPC%25252B-%25252BMIPS%252526%25253DPocketPC%25252B-%25252BSH3%252526%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&createWithPnf=true&eweInfo=outputFile%3D./work/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/exp%252526ma!
 sk%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253Dexp/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources%252526mask%25253D*.gif;*.png;*.ico;*.tp;*.zip;*.html%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources/%252526mask%25253Dcachewolf.Languages.cfg%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D_config/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./lib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfals!
 e%2526vmOptions%253D/Xmx%252B12M%26install%3Dtitle%253D%2526ca!
 tegory%2
53DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dtrue%26useClassPool%3Dfalse&icon=(Default)



From salzkammergut at mail.berlios.de  Sat Feb 17 20:25:05 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 17 Feb 2007 20:25:05 +0100
Subject: [Cachewolf-svn] r606 - trunk/src/CacheWolf
Message-ID: <200702171925.l1HJP50c025676@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-17 20:24:51 +0100 (Sat, 17 Feb 2007)
New Revision: 606

Modified:
   trunk/src/CacheWolf/Profile.java
Log:
Profile: Kleiner Update von normalizeFilter

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-02-17 14:04:11 UTC (rev 605)
+++ trunk/src/CacheWolf/Profile.java	2007-02-17 19:24:51 UTC (rev 606)
@@ -43,6 +43,8 @@
 	public final static boolean SHOW_PROGRESS_BAR = true;
 	public final static boolean NO_SHOW_PROGRESS_BAR = false;
 
+	// When extending the filter check "normalizeFilters"
+	// which ensures backward compatibility. Normally no change should be needed
 	public final static String FILTERTYPE="111111111111111111";
 	public final static String FILTERROSE="1111111111111111";
 	public final static String FILTERVAR="11111111";
@@ -253,8 +255,9 @@
 						filterRose = temp;
 					filterType = ex.findNext();
 					//Need this to stay "downward" compatible. New type introduced
-					if(filterType.length()<=17) filterType = filterType + "1";
-					Vm.debug("fil len: " +filterType.length());
+					//if(filterType.length()<=17) filterType = filterType + "1";
+					//Vm.debug("fil len: " +filterType.length());
+					//This is handled by "normalizeFilters" which is called at the end.
 					filterVar = ex.findNext();
 					filterDist = ex.findNext();
 					filterDiff = ex.findNext();
@@ -447,17 +450,18 @@
 	 * do not cause nullPointer Exceptions
 	 */
 	private void normalizeFilters() {
-		if (filterRose.length()<16) { 
-			filterRose=(filterRose+"1111111111111111").substring(0,16); 
+		String manyOnes="11111111111111111111111111111";
+		if (filterRose.length()<FILTERROSE.length()) { 
+			filterRose=(filterRose+manyOnes).substring(0,FILTERROSE.length()); 
 		}  
-		if (filterVar.length()<8) { 
-			filterVar=(filterVar+"11111111").substring(0,8); 
+		if (filterVar.length()<FILTERVAR.length()) { 
+			filterVar=(filterVar+manyOnes).substring(0,FILTERVAR.length()); 
 		}  
-		if (filterType.length()<17) { 
-			filterType=(filterType+"11111111111111111111111").substring(0,17);
+		if (filterType.length()<FILTERTYPE.length()) { 
+			filterType=(filterType+manyOnes).substring(0,FILTERTYPE.length());
 		} 
-		if (filterSize.length()<6) {
-			filterSize=(filterSize+"111111").substring(0,6);
+		if (filterSize.length()<FILTERSIZE.length()) {
+			filterSize=(filterSize+manyOnes).substring(0,FILTERSIZE.length());
 		}
 		if (filterDist.length()==0) filterDist="L";
 		if (filterDiff.length()==0) filterDiff="L";



From salzkammergut at mail.berlios.de  Sun Feb 18 21:04:54 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 18 Feb 2007 21:04:54 +0100
Subject: [Cachewolf-svn] r607 - trunk/src/CacheWolf
Message-ID: <200702182004.l1IK4sPX029229@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-18 21:04:46 +0100 (Sun, 18 Feb 2007)
New Revision: 607

Modified:
   trunk/src/CacheWolf/SpiderGC.java
Log:
SpiderGC: Addis werden jetzt nur aktualisiert wenn sie angehakt sind UND sichtbar sind (also nicht gefiltert)
Dadurch wird vermieden, da?\195?\159 wenn Addis gefiltert sind und der Hauptpunkt angehakt wird, da?\195?\159 exisitierende Koordinaten versehentlich ueberschrieben werden.

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-02-17 19:24:51 UTC (rev 606)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-02-18 20:04:46 UTC (rev 607)
@@ -498,8 +498,9 @@
 				int idx=profile.getCacheIndex(cx.wayPoint);
 				cx.is_found = ch.is_found;
 				if (idx<0)
-					cacheDB.add(cx);
-				else if (((CacheHolder) cacheDB.get(idx)).is_Checked) // Only spider addi waypoints that are ticked
+					cacheDB.add(cx); // Addi is not in database
+				else if (((CacheHolder) cacheDB.get(idx)).is_Checked && // Only re-spider existing addi waypoints that are ticked
+						!((CacheHolder) cacheDB.get(idx)).is_filtered) // and are visible (i.e.  not filtered)
 					((CacheHolder) cacheDB.get(idx)).update(cx);
 				cx.saveCacheDetails(profile.dataDir);
 				



From admin at berlios.de  Sun Feb 18 21:27:37 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 18 Feb 2007 21:27:37 +0100 (CET)
Subject: [Feature #1969] Filter nach Cachegröße
Message-ID: <200702182027.l1IKRbdR024947@unicorn.berlios.de>

Feature Request #1969, was updated on 2006-Mar-16 08:04
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=1969&group_id=2211

Category: 0.9n
Status: Closed
Priority: 5
Summary: Filter nach Cachegr??e

By: kalli
Date: 2006-Mar-16 08:04

Message:
Logged In: YES 
user_id=24621
Browser: Opera/8.50 (Windows NT 5.1; U; de)

Filter nach Cachegr??e

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=1969&group_id=2211


From admin at berlios.de  Sun Feb 18 21:37:03 2007
From: admin at berlios.de (admin at berlios.de)
Date: Sun, 18 Feb 2007 21:37:03 +0100 (CET)
Subject: [Cachewolf-svn] [Feature #3164] PQ "my Founds" richtig verarbeiten
Message-ID: <200702182037.l1IKb3bh005996@unicorn.berlios.de>

Feature Request #3164, was updated on 2007-Feb-18 21:37
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3164&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: PQ "my Founds" richtig verarbeiten

By: kalli
Date: 2007-Feb-18 21:37

Message:
Logged In: YES 
user_id=24621
Browser: Opera/9.00 (Windows NT 5.1; U; de)

Eigenes Men?, mit dem die PQ mit den eignenen 
Founds eingelesen wird. Es werden die Caches und 
addi wpts als gefunden markiert, die schon in der 
DB drin sind.

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3164&group_id=2211


From salzkammergut at mail.berlios.de  Sun Feb 18 22:35:45 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 18 Feb 2007 22:35:45 +0100
Subject: [Cachewolf-svn] r608 - trunk/src/CacheWolf
Message-ID: <200702182135.l1ILZjAp003683@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-18 22:35:40 +0100 (Sun, 18 Feb 2007)
New Revision: 608

Modified:
   trunk/src/CacheWolf/SpiderGC.java
Log:
SpiderGC: Beim Laden der Travelbugs wir auch deren derzeitiges Ziel geholt, damit man schon im Vorfeld pruefen kann ob man den Bug transportieren moechte

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-02-18 20:04:46 UTC (rev 607)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-02-18 21:35:40 UTC (rev 608)
@@ -47,6 +47,7 @@
 	Vector cacheDB;
 	Vector cachesToLoad = new Vector();
 	Hashtable indexDB = new Hashtable();
+	InfoBox infB;
 	
 	/**
 	 * Method to login the user to gc.com
@@ -125,7 +126,7 @@
 			pref.log("Could not load " + ch.wayPoint + "file in spiderSingle");
 		}
 		notes = ch.CacheNotes;
-		InfoBox infB = new InfoBox("Info", "Loading");
+		infB = new InfoBox("Info", "Loading");
 		infB.setInfo("Loading: " + ch.wayPoint);
 		infB.show();
 		String doc = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + ch.wayPoint +"&log=y";
@@ -257,7 +258,7 @@
 		options.close(0);
 		
 		
-		InfoBox infB = new InfoBox("Status", "Fetching first page...");
+		infB = new InfoBox("Status", "Fetching first page...");
 		infB.exec();
 		//Get first page
 		try{
@@ -449,18 +450,36 @@
 	}
 	
 	public String getBugs(String doc){	
-		Extractor exBlock = new Extractor(doc, "Inventory","What is a Travel Bug?",0,Extractor.EXCLUDESTARTEND);
+		Extractor exBlock = new Extractor(doc, ">&nbsp;Inventory</td>","What is a Travel Bug?",0,Extractor.EXCLUDESTARTEND);
 		String bugBlock = exBlock.findNext();
 		Vm.debug("Bugblock: "+bugBlock);
-		Extractor exBug = new Extractor(bugBlock, "'>", "</a></strong></td>",0,Extractor.EXCLUDESTARTEND);
-		String bug = new String();
-		String result = new String();
+		Extractor exBug = new Extractor(bugBlock, "<a href='", "</a></strong></td>",0,Extractor.EXCLUDESTARTEND);
+		String link,bug,linkPlusBug,bugDetails;
+		String result = "";
+		String oldInfoBox=infB.getInfo();
 		while(exBug.endOfSearch() == false){
-			bug= exBug.findNext();
-			if(bug.length()>0) result = result + "<b>Name:</b> "+ bug + "<br><hr>";
-			Vm.debug("B: " + bug);
-			Vm.debug("End? " + exBug.endOfSearch());
+			linkPlusBug= exBug.findNext();
+			int idx=linkPlusBug.indexOf("'>");
+			if (idx<0) break; // No link/bug pair found
+			link=linkPlusBug.substring(0,idx);
+			bug=linkPlusBug.substring(idx+2);
+			if(bug.length()>0) { // Found a bug, get its details
+				result = result + "<b>Name:</b> "+ bug + "<br>";
+				try{
+					infB.setInfo(oldInfoBox+"\nGetting bug: "+bug);
+					pref.log("Fetching bug details: "+bug);
+					bugDetails = fetch(link);
+				}catch(Exception ex){
+					pref.log("Could not fetch bug details");
+					bugDetails="";
+				}
+				Extractor exDetails = new Extractor(bugDetails, "<span id=\"BugDetail_BugGoal\">", "</span>",0,Extractor.EXCLUDESTARTEND);
+				result+=exDetails.findNext()+"<hr>";
+			}
+			//Vm.debug("B: " + bug);
+			//Vm.debug("End? " + exBug.endOfSearch());
 		}
+		infB.setInfo(oldInfoBox);
 		return result;
 	}
 	



From salzkammergut at mail.berlios.de  Sun Feb 18 23:07:42 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 18 Feb 2007 23:07:42 +0100
Subject: [Cachewolf-svn] r609 - trunk/src/CacheWolf
Message-ID: <200702182207.l1IM7gB8006316@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-18 23:07:39 +0100 (Sun, 18 Feb 2007)
New Revision: 609

Modified:
   trunk/src/CacheWolf/InfoBox.java
   trunk/src/CacheWolf/SpiderGC.java
Log:
SpiderGC: Bilderspider robuster bei .php Bildern usw.
Nachtrag Infobox zu vorheriger Rev

Modified: trunk/src/CacheWolf/InfoBox.java
===================================================================
--- trunk/src/CacheWolf/InfoBox.java	2007-02-18 21:35:40 UTC (rev 608)
+++ trunk/src/CacheWolf/InfoBox.java	2007-02-18 22:07:39 UTC (rev 609)
@@ -96,6 +96,10 @@
 		this.repaintNow();
 	}
 
+	public String getInfo(){
+		return msgArea.getText();
+	}
+
 	public void addWarning (String w) {
 		warnings.setText(warnings.text + w);
 	}

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-02-18 21:35:40 UTC (rev 608)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-02-18 22:07:39 UTC (rev 609)
@@ -504,9 +504,9 @@
 				koordRex.search(rowBlock);
 				typeRex.search(rowBlock);
 				cx.CacheName = nameRex.stringMatched(1);
-				if(koordRex.didMatch()) cx.LatLon = koordRex.stringMatched(1); 
-				else cx.LatLon = "---"; 
-				cx.pos.set(cx.LatLon);
+				if(koordRex.didMatch()) cx.pos.set(koordRex.stringMatched(1)); 
+				cx.LatLon = ch.pos.toString(); 
+				//cx.pos.set(cx.LatLon);
 				if(typeRex.didMatch()) cx.type = CacheType.typeText2Number("Waypoint|"+typeRex.stringMatched(1));
 				rowBlock = exRowBlock.findNext();
 				descRex.search(rowBlock);
@@ -530,9 +530,9 @@
 	
 	public void getImages(String doc, CacheHolder ch){
 		int imgCounter = 0;
-		String imgName = new String();
-		String imgType = new String();
-		String imgUrl = new String();
+		String imgName;
+		String imgType;
+		String imgUrl;
 		//In the long description
 		String longDesc = new String();
 		longDesc = getLongDesc(doc);
@@ -545,7 +545,7 @@
 		//longDesc = STRreplace.replace(longDesc, " ", "");
 		Extractor exImgBlock = new Extractor(longDesc, "<IMG", ">", 0, false);
 		//Vm.debug("In getImages: Have longDesc" + longDesc);
-		String tst = new String();
+		String tst;
 		tst = exImgBlock.findNext();
 		//Vm.debug("Test: \n" + tst);
 		Extractor exImgSrc = new Extractor(tst, "http://", "\"", 0, true);
@@ -555,8 +555,8 @@
 			if(imgUrl.length()>0){
 				imgUrl = "http://" + imgUrl;
 				try{
-					imgType = imgUrl.substring(imgUrl.lastIndexOf("."));
-					if(!imgType.equals("com") && !imgType.equals("php") && !imgType.equals("exe")){
+					imgType = imgUrl.substring(imgUrl.lastIndexOf(".")).toLowerCase();
+					if(!imgType.startsWith("com") && !imgType.startsWith("php") && !imgType.startsWith("exe")){
 						imgName = ch.wayPoint + "_" + Convert.toString(imgCounter);
 						pref.log("Loading image: " + imgUrl);
 						spiderImage(imgUrl, imgName+imgType);
@@ -584,8 +584,8 @@
 			if(imgUrl.length()>0){
 				imgUrl = "http://" + imgUrl;
 				try{
-					imgType = imgUrl.substring(imgUrl.lastIndexOf("."));
-					if(!imgType.equals("com") && !imgType.equals("php") && !imgType.equals("exe")){
+					imgType = imgUrl.substring(imgUrl.lastIndexOf(".")).toLowerCase();
+					if(!imgType.startsWith("com") && !imgType.startsWith("php") && !imgType.startsWith("exe")){
 						imgName = ch.wayPoint + "_" + Convert.toString(imgCounter);
 						spiderImage(imgUrl, imgName+imgType);
 						imgCounter++;



From salzkammergut at mail.berlios.de  Mon Feb 19 00:27:17 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Mon, 19 Feb 2007 00:27:17 +0100
Subject: [Cachewolf-svn] r610 - trunk/src/CacheWolf
Message-ID: <200702182327.l1INRHpd012181@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-19 00:27:14 +0100 (Mon, 19 Feb 2007)
New Revision: 610

Modified:
   trunk/src/CacheWolf/SpiderGC.java
Log:
SpiderGC: Ownername wird um Leerzeichen befreit (konsistent mit DetailsPanel)
Bei pruefen ob Owner bzw. gefunden wird auch das zweite alias ueberprueft

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-02-18 22:07:39 UTC (rev 609)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-02-18 23:27:14 UTC (rev 610)
@@ -174,8 +174,8 @@
 		pref.log("Got cache name");
 		//Vm.debug("Name: " + ch.CacheName);
 		pref.log("Trying owner");
-		ch.CacheOwner = SafeXML.cleanback(getOwner(start));
-		if(ch.CacheOwner.equals(pref.myAlias + " ")) ch.is_owned = true;
+		ch.CacheOwner = SafeXML.cleanback(getOwner(start)).trim();
+		if(ch.CacheOwner.equals(pref.myAlias) || (pref.myAlias2.length()>0 && ch.CacheOwner.equals(pref.myAlias2))) ch.is_owned = true;
 		pref.log("Got owner");
 		//Vm.debug("Owner: " + ch.CacheOwner);
 		pref.log("Trying date hidden");
@@ -374,8 +374,8 @@
 					pref.log("Got cache name");
 					//Vm.debug("Name: " + ch.CacheName);
 					pref.log("Trying owner");
-					ch.CacheOwner = SafeXML.cleanback(getOwner(start));
-					if(ch.CacheOwner.equals(pref.myAlias+" ")) ch.is_owned = true;
+					ch.CacheOwner = SafeXML.cleanback(getOwner(start)).trim();
+					if(ch.CacheOwner.equals(pref.myAlias) || (pref.myAlias2.length()>0 && ch.CacheOwner.equals(pref.myAlias2))) ch.is_owned = true;
 					pref.log("Got owner");
 					//Vm.debug("Owner: " + ch.CacheOwner);
 					pref.log("Trying date hidden");
@@ -770,7 +770,8 @@
 			//Vm.debug("--------------------------------------------");
 			icon = exIcon.findNext();
 			name = exName.findNext();
-			if((icon.equals("icon_smile.gif") || icon.equals("icon_camera.gif")) && name.equals(pref.myAlias)) {
+			if((icon.equals("icon_smile.gif") || icon.equals("icon_camera.gif")) && 
+				(name.equals(pref.myAlias) || (pref.myAlias2.length()>0 && name.equals(pref.myAlias2))) )  {
 				ch.is_found = true;
 				ch.CacheStatus = MyLocale.getMsg(318,"Found");
 			}



From kalli at mail.berlios.de  Mon Feb 19 19:25:27 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Mon, 19 Feb 2007 19:25:27 +0100
Subject: [Cachewolf-svn] r611 - trunk/resources
Message-ID: <200702191825.l1JIPRlW010115@sheep.berlios.de>

Author: kalli
Date: 2007-02-19 19:25:20 +0100 (Mon, 19 Feb 2007)
New Revision: 611

Modified:
   trunk/resources/POIIcons.zip
Log:
GC-Trailhead.bmp hinzugefuegt

Modified: trunk/resources/POIIcons.zip
===================================================================
(Binary files differ)



From bilbowolf at mail.berlios.de  Tue Feb 20 07:58:59 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Tue, 20 Feb 2007 07:58:59 +0100
Subject: [Cachewolf-svn] r612 - trunk/src/CacheWolf
Message-ID: <200702200658.l1K6wxSD023049@sheep.berlios.de>

Author: bilbowolf
Date: 2007-02-20 07:58:57 +0100 (Tue, 20 Feb 2007)
New Revision: 612

Modified:
   trunk/src/CacheWolf/Version.java
Log:


Modified: trunk/src/CacheWolf/Version.java
===================================================================
--- trunk/src/CacheWolf/Version.java	2007-02-19 18:25:20 UTC (rev 611)
+++ trunk/src/CacheWolf/Version.java	2007-02-20 06:58:57 UTC (rev 612)
@@ -10,7 +10,7 @@
 	static final String VER_MAJOR = "";
 	static final String VER_MINOR = "";
 	static final String VER_BUILD = " RC ";
-	static final String VER_SVN ="$LastChangedRevision$";  //the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
+	static final String VER_SVN ="$LastChangedRevision$";  // the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
 	
 	/**
 	 * @return



From admin at berlios.de  Wed Feb 21 20:34:43 2007
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 21 Feb 2007 10:34:43 -0900 (AKST)
Subject: [Feature #1973] Export über GPSBabel zu PalmDocs
Message-ID: <200702211934.l1LJYh3t016745@unicorn.berlios.de>

Feature Request #1973, was updated on 2006-Mar-16 11:17
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=1973&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Export ?ber GPSBabel zu PalmDocs

By: cw-tester
Date: 2007-Feb-21 10:34

Message:
Logged In: YES 
user_id=30505
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.0.3705; .NET CLR 1.1.4322; Media Center PC 4.0; .NET CLR 2.0.50727)

Hallo Bilbowolf,

kann man GPSBabel in CW integrieren??
Mich w?rde ein Export der Caches zu MagellanMapsend 
interessieren. Das mache ich immer ?ber GPSBabel

----------------------------------------------------------------------

By: bilbowolf
Date: 2006-Mar-16 11:17

Message:
Logged In: YES 
user_id=10718
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.1) Gecko/20060111 Firefox/1.5.0.1

Export ?ber GPSBabel zu PalmDocs

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=1973&group_id=2211


From admin at berlios.de  Wed Feb 21 21:16:20 2007
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 21 Feb 2007 21:16:20 +0100 (CET)
Subject: [Feature #1973] Export über GPSBabel zu PalmDocs
Message-ID: <200702212016.l1LKGKWG001025@unicorn.berlios.de>

Feature Request #1973, was updated on 2006-Mar-16 21:17
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=1973&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Export ?ber GPSBabel zu PalmDocs

By: kalli
Date: 2007-Feb-21 21:16

Message:
Logged In: YES 
user_id=24621
Browser: Opera/9.00 (Windows NT 5.1; U; de)

Der Export zu Garmin funktioniert schon ?ber GPSBabel. 
Der Men?punkt wird allerdings nur dann angezeigt, 
wenn gpsbabel.exe im Programmverzeichnis von CW 
liegt. GPSBabel wird wie folgt aufgerufen (Auszug aus 
dem java-Code):
gpsbabel -i geo -f \"+ tmpFileName +"\ -o garmin -F " 
+ pref.garminConn + ":"

tmpFileName ist der Name einer tempor?ren .loc-Datei, 
garminConn ist der Port aus den Preferenzen (nicht der 
GPSPort des evtl. im PDA eingebauten GPS).

Welche Parameter brauchst Du den f?r deinen Aufruf?


----------------------------------------------------------------------

By: cw-tester
Date: 2007-Feb-21 20:34

Message:
Logged In: YES 
user_id=30505
Browser: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.0.3705; .NET CLR 1.1.4322; Media Center PC 4.0; .NET CLR 2.0.50727)

Hallo Bilbowolf,

kann man GPSBabel in CW integrieren??
Mich w?rde ein Export der Caches zu MagellanMapsend 
interessieren. Das mache ich immer ?ber GPSBabel

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=1973&group_id=2211


From pfeffer at mail.berlios.de  Thu Feb 22 02:10:48 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 22 Feb 2007 02:10:48 +0100
Subject: [Cachewolf-svn] r613 - trunk/src/CacheWolf
Message-ID: <200702220110.l1M1Amm9022531@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-22 02:10:43 +0100 (Thu, 22 Feb 2007)
New Revision: 613

Modified:
   trunk/src/CacheWolf/GPSPortOptions.java
Log:
GPS-Options: NullPointerException entsteht nicht mehr, wenn ung?\195?\188ltige Portangabe

Modified: trunk/src/CacheWolf/GPSPortOptions.java
===================================================================
--- trunk/src/CacheWolf/GPSPortOptions.java	2007-02-20 06:58:57 UTC (rev 612)
+++ trunk/src/CacheWolf/GPSPortOptions.java	2007-02-22 01:10:43 UTC (rev 613)
@@ -71,7 +71,7 @@
 
 	public void stop() {
 		run = false;
-		comSp.close();
+		if (comSp != null) comSp.close(); //compSp == null can happen if a exception occured
 	}
 }
 



From admin at berlios.de  Thu Feb 22 11:41:12 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 22 Feb 2007 01:41:12 -0900 (AKST)
Subject: [Feature #1973] Export über GPSBabel zu PalmDocs
Message-ID: <200702221041.l1MAfCsu001002@unicorn.berlios.de>

Feature Request #1973, was updated on 2006-Mar-16 11:17
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=1973&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Export ?ber GPSBabel zu PalmDocs

By: cw-tester
Date: 2007-Feb-22 01:41

Message:
Logged In: YES 
user_id=30505
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Also bei mir wird dieser Befehl abgesetzt:

gpsbabel.exe -p "" -w -i gpx -f
"I:\WP\Test\TestZubeh?r\GC101CJ.gpx" -o mapsend -F
"d:	emp\Test.wpt"

----------------------------------------------------------------------

By: kalli
Date: 2007-Feb-21 11:16

Message:
Logged In: YES 
user_id=24621
Browser: Opera/9.00 (Windows NT 5.1; U; de)

Der Export zu Garmin funktioniert schon ?ber GPSBabel. 
Der Men?punkt wird allerdings nur dann angezeigt, 
wenn gpsbabel.exe im Programmverzeichnis von CW 
liegt. GPSBabel wird wie folgt aufgerufen (Auszug aus 
dem java-Code):
gpsbabel -i geo -f \"+ tmpFileName +"\ -o garmin -F " 
+ pref.garminConn + ":"

tmpFileName ist der Name einer tempor?ren .loc-Datei, 
garminConn ist der Port aus den Preferenzen (nicht der 
GPSPort des evtl. im PDA eingebauten GPS).

Welche Parameter brauchst Du den f?r deinen Aufruf?


----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=1973&group_id=2211


From admin at berlios.de  Thu Feb 22 12:27:53 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 22 Feb 2007 02:27:53 -0900 (AKST)
Subject: [Feature #3171] Linkshänder und die Stiftbedienung...
Message-ID: <200702221127.l1MBRrGk024106@unicorn.berlios.de>

Feature Request #3171, was updated on 2007-Feb-22 02:27
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3171&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Linksh?nder und die Stiftbedienung...

By: cw-tester
Date: 2007-Feb-22 02:27

Message:
Logged In: YES 
user_id=30505
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Ist es m?glich, die Scroll-Leiste von der rechten
Bildschirmseite auf die linke Seite zu verlegen?

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=3171&group_id=2211


From admin at berlios.de  Thu Feb 22 12:43:59 2007
From: admin at berlios.de (admin at berlios.de)
Date: Thu, 22 Feb 2007 02:43:59 -0900 (AKST)
Subject: [Feature #1973] Export über GPSBabel zu PalmDocs
Message-ID: <200702221143.l1MBhxVh012559@unicorn.berlios.de>

Feature Request #1973, was updated on 2006-Mar-16 11:17
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=1973&group_id=2211

Category: None
Status: Open
Priority: 5
Summary: Export ?ber GPSBabel zu PalmDocs

By: cw-tester
Date: 2007-Feb-22 02:43

Message:
Logged In: YES 
user_id=30505
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Also bei mir wird dieser Befehl abgesetzt:

gpsbabel.exe -p "" -w -i gpx -f
"I:\WP\Test\TestZubeh?r\GC101CJ.gpx" -o mapsend -F
"d:	emp\Test.wpt"

----------------------------------------------------------------------

By: cw-tester
Date: 2007-Feb-22 01:41

Message:
Logged In: YES 
user_id=30505
Browser: Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1

Also bei mir wird dieser Befehl abgesetzt:

gpsbabel.exe -p "" -w -i gpx -f
"I:\WP\Test\TestZubeh?r\GC101CJ.gpx" -o mapsend -F
"d:	emp\Test.wpt"

----------------------------------------------------------------------
You can respond by visiting: 
http://developer.berlios.de/feature/?func=detailfeature&feature_id=1973&group_id=2211


From bilbowolf at mail.berlios.de  Thu Feb 22 21:08:31 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Thu, 22 Feb 2007 21:08:31 +0100
Subject: [Cachewolf-svn] r615 - trunk/src/CacheWolf
Message-ID: <200702222008.l1MK8VJW013787@sheep.berlios.de>

Author: bilbowolf
Date: 2007-02-22 21:08:28 +0100 (Thu, 22 Feb 2007)
New Revision: 615

Modified:
   trunk/src/CacheWolf/MainForm.java
   trunk/src/CacheWolf/TablePanel.java
Log:
Flackern in der Listenansicht behoben

Modified: trunk/src/CacheWolf/MainForm.java
===================================================================
--- trunk/src/CacheWolf/MainForm.java	2007-02-22 10:32:20 UTC (rev 614)
+++ trunk/src/CacheWolf/MainForm.java	2007-02-22 20:08:28 UTC (rev 615)
@@ -113,8 +113,9 @@
 	
 	public void onEvent(Event ev){ // Preferences have been changed by PreferencesScreen
 		if(pref.dirty == true){
-			mTab.getTablePanel().myMod.setColumnNamesAndWidths();	
-		    mTab.getTablePanel().refreshTable();
+			mTab.getTablePanel().myMod.setColumnNamesAndWidths();
+			mTab.getTablePanel().refreshControl();
+		    //mTab.getTablePanel().refreshTable();
 			pref.dirty = false;
 		}
 		super.onEvent(ev);

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-02-22 10:32:20 UTC (rev 614)
+++ trunk/src/CacheWolf/TablePanel.java	2007-02-22 20:08:28 UTC (rev 615)
@@ -106,6 +106,14 @@
 		tc.scrollToVisible(0,0);
 	}
 	
+	/**
+	 * Similar to refreshTable but not so "heavy".
+	 * Is used when user changes settings in preferences.
+	 */
+	public void refreshControl(){
+		tc.update(true);
+	}
+	
 	/** Move all filtered caches to the end of the table and redesplay table */
 	//TODO Add a sort here to restore the sort after a filter
 	public void refreshTable(){



From bilbowolf at mail.berlios.de  Thu Feb 22 22:07:44 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Thu, 22 Feb 2007 22:07:44 +0100
Subject: [Cachewolf-svn] r616 - trunk/src/CacheWolf
Message-ID: <200702222107.l1ML7in5020457@sheep.berlios.de>

Author: bilbowolf
Date: 2007-02-22 22:07:38 +0100 (Thu, 22 Feb 2007)
New Revision: 616

Modified:
   trunk/src/CacheWolf/Version.java
Log:
Neue Versionsnummer

Modified: trunk/src/CacheWolf/Version.java
===================================================================
--- trunk/src/CacheWolf/Version.java	2007-02-22 20:08:28 UTC (rev 615)
+++ trunk/src/CacheWolf/Version.java	2007-02-22 21:07:38 UTC (rev 616)
@@ -10,7 +10,7 @@
 	static final String VER_MAJOR = "";
 	static final String VER_MINOR = "";
 	static final String VER_BUILD = " RC ";
-	static final String VER_SVN ="$LastChangedRevision$";  // the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
+	static final String VER_SVN ="$LastChangedRevision$";  //the  number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
 	
 	/**
 	 * @return



From salzkammergut at mail.berlios.de  Thu Feb 22 22:19:01 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Thu, 22 Feb 2007 22:19:01 +0100
Subject: [Cachewolf-svn] r617 - trunk/src/CacheWolf
Message-ID: <200702222119.l1MLJ1Bs021787@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-22 22:18:55 +0100 (Thu, 22 Feb 2007)
New Revision: 617

Modified:
   trunk/src/CacheWolf/InfoBox.java
   trunk/src/CacheWolf/SpiderGC.java
   trunk/src/CacheWolf/myTableControl.java
Log:
SpiderGC: Abbrechen des Spiders durch Schliessen der Infobox jetzt moeglich

Modified: trunk/src/CacheWolf/InfoBox.java
===================================================================
--- trunk/src/CacheWolf/InfoBox.java	2007-02-22 21:07:38 UTC (rev 616)
+++ trunk/src/CacheWolf/InfoBox.java	2007-02-22 21:18:55 UTC (rev 617)
@@ -15,6 +15,11 @@
 	public final static int DISPLAY_ONLY = 3;
 	public final static int PROGRESS_WITH_WARNINGS = 4;
 	private int type = 0;
+	/** This variable is set to true if the user closed the Info window by
+	 *  clicking the "close" button. It can be used to check if a lengthy task needs to be
+	 *  aborted (i.e. spidering)
+	 */
+	public boolean isClosed=false;
 
 	public InfoBox(String title, String info){
 		this(title, info, DISPLAY_ONLY);
@@ -123,4 +128,10 @@
 		}
 		super.onEvent(ev);
 	}
+	
+	protected boolean canExit(int exitCode) {
+		isClosed=true;
+		return true;
+	}
+	
 }
\ No newline at end of file

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-02-22 21:07:38 UTC (rev 616)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-02-22 21:18:55 UTC (rev 617)
@@ -38,10 +38,10 @@
 public class SpiderGC{
 	private static Preferences pref;
 	private Profile profile;
-	static String viewstate = new String();
-	static String passwort = new String();
-	static String cookieID = new String();
-	static String cookieSession = new String();
+	static String viewstate = "";
+	static String passwort = "";
+	static String cookieID = "";
+	static String cookieSession = "";
 	static double distance = 0;
 	Regex inRex = new Regex();
 	Vector cacheDB;
@@ -56,70 +56,77 @@
 	public int login(){
 		pref.logInit();
 		//Access the page once to get a viewstate
-		String start = new String();
-		String doc = new String();
+		String start = "";
+		String doc = "";
 		//Get password
 		InfoBox infB = new InfoBox("Password", "Enter password:", InfoBox.INPUT);
 		int code = infB.execute();
-		if(code == Form.IDOK){
-			passwort = infB.getInput();
-		} else return code;
+		passwort = infB.getInput();
 		infB.close(0);
+		if(code != Form.IDOK)
+			return code;
 		infB = new InfoBox("Status", "Logging in...");
 		infB.exec();
 		try{
 			pref.log("Fetching login page");
 			start = fetch("http://www.geocaching.com/login/Default.aspx");
 		}catch(Exception ex){
-			Vm.debug("Could not fetch: gc.com start page");
+			pref.log("Could not fetch: gc.com start page",ex);
 		}
-		Regex rexCookieID = new Regex("Set-Cookie: userid=(.*?);.*");
-		Regex rex = new Regex("name=\"__VIEWSTATE\" value=\"(.*)\" />");
-		Regex rexCookieSession = new Regex("Set-Cookie: ASP.NET_SessionId=(.*?);.*");
-		rex.search(start);
-		if(rex.didMatch()){
+		if (!infB.isClosed) {
+			Regex rexCookieID = new Regex("Set-Cookie: userid=(.*?);.*");
+			Regex rex = new Regex("name=\"__VIEWSTATE\" value=\"(.*)\" />");
+			Regex rexCookieSession = new Regex("Set-Cookie: ASP.NET_SessionId=(.*?);.*");
+			rex.search(start);
+			if(rex.didMatch()){
+				viewstate = rex.stringMatched(1);
+				//Vm.debug("ViewState: " + viewstate);
+			}
+			//Ok now login!
+			try{
+				pref.log("Logging in");
+				doc = URL.encodeURL("__VIEWSTATE",false) +"="+ URL.encodeURL(viewstate,false);
+				doc += "&" + URL.encodeURL("myUsername",false) +"="+ URL.encodeURL(pref.myAlias,false);
+				doc += "&" + URL.encodeURL("myPassword",false) +"="+ URL.encodeURL(passwort,false);
+				doc += "&" + URL.encodeURL("cookie",false) +"="+ URL.encodeURL("on",false);
+				doc += "&" + URL.encodeURL("Button1",false) +"="+ URL.encodeURL("Login",false);
+				start = fetch_post("http://www.geocaching.com/login/Default.aspx", doc, "/login/default.aspx");
+				pref.log("Login successfull");
+			}catch(Exception ex){
+				Vm.debug("Could not login: gc.com start page");
+				pref.log("Login failed.");
+			}
+			
+			rex.search(start);
 			viewstate = rex.stringMatched(1);
-			//Vm.debug("ViewState: " + viewstate);
+			rexCookieID.search(start);
+			cookieID = rexCookieID.stringMatched(1);
+			//Vm.debug(cookieID);
+			rexCookieSession.search(start);
+			cookieSession = rexCookieSession.stringMatched(1);
+			//Vm.debug(cookieSession);
 		}
-		//Ok now login!
-		try{
-			pref.log("Logging in");
-			doc = URL.encodeURL("__VIEWSTATE",false) +"="+ URL.encodeURL(viewstate,false);
-			doc += "&" + URL.encodeURL("myUsername",false) +"="+ URL.encodeURL(pref.myAlias,false);
-			doc += "&" + URL.encodeURL("myPassword",false) +"="+ URL.encodeURL(passwort,false);
-			doc += "&" + URL.encodeURL("cookie",false) +"="+ URL.encodeURL("on",false);
-			doc += "&" + URL.encodeURL("Button1",false) +"="+ URL.encodeURL("Login",false);
-			start = fetch_post("http://www.geocaching.com/login/Default.aspx", doc, "/login/default.aspx");
-			pref.log("Login successfull");
-		}catch(Exception ex){
-			Vm.debug("Could not login: gc.com start page");
-			pref.log("Login failed.");
-		}
-		
-		rex.search(start);
-		viewstate = rex.stringMatched(1);
-		rexCookieID.search(start);
-		cookieID = rexCookieID.stringMatched(1);
-		//Vm.debug(cookieID);
-		rexCookieSession.search(start);
-		cookieSession = rexCookieSession.stringMatched(1);
-		//Vm.debug(cookieSession);
+		boolean loginAborted=infB.isClosed;
 		infB.close(0);
-		return Form.IDOK;
+		if (loginAborted)
+			return Form.IDCANCEL;
+		else
+			return Form.IDOK;
 	}
 	
 	/**
 	 * Method to spider a single cache.
 	 * It assumes a login has already been performed!
+	 * @return True if spider was successful, false if spider was cancelled by closing the infobox
 	 */
-	public void spiderSingle(int number){
+	public boolean spiderSingle(int number){
 
 		CacheHolder ch = (CacheHolder)cacheDB.get(number);
-		if (ch.isAddiWpt()) return;  // No point spidering an addi waypoint, comes with parent
-		Vm.showWait(true);
-		String notes = new String();
-		String start = new String();
-		String origLong = new String();
+		if (ch.isAddiWpt()) return false;  // No point spidering an addi waypoint, comes with parent
+		//Vm.showWait(true); Already done in myTableControl
+		String notes = "";
+		String start = "";
+		String origLong = "";
 		try{
 			ch.readCache(profile.dataDir);
 		}catch(IOException ioex){
@@ -128,7 +135,7 @@
 		notes = ch.CacheNotes;
 		infB = new InfoBox("Info", "Loading");
 		infB.setInfo("Loading: " + ch.wayPoint);
-		infB.show();
+		infB.exec();
 		String doc = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + ch.wayPoint +"&log=y";
 		try{
 			pref.log("Fetching: " + ch.wayPoint);
@@ -137,92 +144,98 @@
 			pref.log("Could not fetch " + ch.wayPoint);
 			//Vm.debug("Couldn't get cache detail page");
 		}
-		ch.is_new = false;
-		ch.is_update = false;
-		ch.is_HTML = true;
-		ch.is_available = true;
-		ch.is_archived = false;
-		//Vm.debug(ch.wayPoint);
-		
-		if(start.indexOf("This cache is temporarily unavailable") >= 0) ch.is_available = false;
-		if(start.indexOf("This cache has been archived") >= 0) ch.is_archived = true;
-		pref.log("Trying logs");
-		int logsz = ch.CacheLogs.size();
-		ch.CacheLogs = getLogs(start, ch);
-		int z = 0;
-		String loganal = new String();
-		while(z < ch.CacheLogs.size() && z < 5){
-			loganal = (String)ch.CacheLogs.get(z);
-			if(loganal.indexOf("icon_sad")>0) {
-				z++;
-			}else break;
+		if (!infB.isClosed) { // Only analyse the cache data if user has not closed the progress window
+			ch.is_new = false;
+			ch.is_update = false;
+			ch.is_HTML = true;
+			ch.is_available = true;
+			ch.is_archived = false;
+			//Vm.debug(ch.wayPoint);
+			
+			if(start.indexOf("This cache is temporarily unavailable") >= 0) ch.is_available = false;
+			if(start.indexOf("This cache has been archived") >= 0) ch.is_archived = true;
+			pref.log("Trying logs");
+			int logsz = ch.CacheLogs.size();
+			ch.CacheLogs = getLogs(start, ch);
+			int z = 0;
+			String loganal = "";
+			while(z < ch.CacheLogs.size() && z < 5){
+				loganal = (String)ch.CacheLogs.get(z);
+				if(loganal.indexOf("icon_sad")>0) {
+					z++;
+				}else break;
+			}
+			ch.noFindLogs = z;
+			ch.is_log_update = false;
+			if(ch.CacheLogs.size()>logsz) ch.is_log_update = true;
+			pref.log("Found logs");
+			ch.LatLon = getLatLon(start);
+			ch.pos.set(ch.LatLon);
+			//Vm.debug("LatLon: " + ch.LatLon);
+			pref.log("Trying description");
+			origLong = ch.LongDescription;
+			ch.LongDescription = getLongDesc(start);
+			if(!ch.LongDescription.equals(origLong)) ch.is_update = true;
+			pref.log("Got description");
+			pref.log("Getting cache name");
+			ch.CacheName = SafeXML.cleanback(getName(start));
+			pref.log("Got cache name");
+			//Vm.debug("Name: " + ch.CacheName);
+			pref.log("Trying owner");
+			ch.CacheOwner = SafeXML.cleanback(getOwner(start)).trim();
+			if(ch.CacheOwner.equals(pref.myAlias) || (pref.myAlias2.length()>0 && ch.CacheOwner.equals(pref.myAlias2))) ch.is_owned = true;
+			pref.log("Got owner");
+			//Vm.debug("Owner: " + ch.CacheOwner);
+			pref.log("Trying date hidden");
+			ch.DateHidden = getDateHidden(start);
+			pref.log("Got date hidden");
+			//Vm.debug("Hidden: " + ch.DateHidden);
+			pref.log("Trying hints");
+			ch.Hints = getHints(start);
+			pref.log("Got hints");
+			//Vm.debug("Hints: " + ch.Hints);
+			//Vm.debug("Got the hints");
+			pref.log("Trying size");
+			ch.CacheSize = getSize(start);
+			pref.log("Got size");
+			//Vm.debug("Size: " + ch.CacheSize);
+			pref.log("Trying difficulty");
+			ch.hard = getDiff(start);
+			pref.log("Got difficulty");
+			//Vm.debug("Hard: " + ch.hard);
+			pref.log("Trying terrain");
+			ch.terrain = getTerr(start);
+			pref.log("Got terrain");
+			if (!infB.isClosed) ch.Bugs = getBugs(start);
+			if(ch.Bugs.length()>0) ch.has_bug = true; else ch.has_bug = false;
+			//Vm.debug("Terr: " + ch.terrain);
+			pref.log("Trying cache type");
+			ch.type = getType(start);
+			pref.log("Got cache type");
+			//Vm.debug("Type: " + ch.type);
+			pref.log("Trying images");
+			getImages(start, ch);
+			pref.log("Got images");
+			//pref.log("Trying maps");
+			//getMaps(ch);
+			//pref.log("Got maps");
+			pref.log("Getting additional waypoints");
+	
+			getAddWaypoints(start, ch);
+	
+			pref.log("Got additional waypoints");
+			ch.CacheNotes = notes;
+			if (!infB.isClosed) {
+				ch.saveCacheDetails(profile.dataDir);
+				
+				cacheDB.set(number, ch);
+			}
 		}
-		ch.noFindLogs = z;
-		ch.is_log_update = false;
-		if(ch.CacheLogs.size()>logsz) ch.is_log_update = true;
-		pref.log("Found logs");
-		ch.LatLon = getLatLon(start);
-		ch.pos.set(ch.LatLon);
-		//Vm.debug("LatLon: " + ch.LatLon);
-		pref.log("Trying description");
-		origLong = ch.LongDescription;
-		ch.LongDescription = getLongDesc(start);
-		if(!ch.LongDescription.equals(origLong)) ch.is_update = true;
-		pref.log("Got description");
-		pref.log("Getting cache name");
-		ch.CacheName = SafeXML.cleanback(getName(start));
-		pref.log("Got cache name");
-		//Vm.debug("Name: " + ch.CacheName);
-		pref.log("Trying owner");
-		ch.CacheOwner = SafeXML.cleanback(getOwner(start)).trim();
-		if(ch.CacheOwner.equals(pref.myAlias) || (pref.myAlias2.length()>0 && ch.CacheOwner.equals(pref.myAlias2))) ch.is_owned = true;
-		pref.log("Got owner");
-		//Vm.debug("Owner: " + ch.CacheOwner);
-		pref.log("Trying date hidden");
-		ch.DateHidden = getDateHidden(start);
-		pref.log("Got date hidden");
-		//Vm.debug("Hidden: " + ch.DateHidden);
-		pref.log("Trying hints");
-		ch.Hints = getHints(start);
-		pref.log("Got hints");
-		//Vm.debug("Hints: " + ch.Hints);
-		//Vm.debug("Got the hints");
-		pref.log("Trying size");
-		ch.CacheSize = getSize(start);
-		pref.log("Got size");
-		//Vm.debug("Size: " + ch.CacheSize);
-		pref.log("Trying difficulty");
-		ch.hard = getDiff(start);
-		pref.log("Got difficulty");
-		//Vm.debug("Hard: " + ch.hard);
-		pref.log("Trying terrain");
-		ch.terrain = getTerr(start);
-		pref.log("Got terrain");
-		ch.Bugs = getBugs(start);
-		if(ch.Bugs.length()>0) ch.has_bug = true; else ch.has_bug = false;
-		//Vm.debug("Terr: " + ch.terrain);
-		pref.log("Trying cache type");
-		ch.type = getType(start);
-		pref.log("Got cache type");
-		//Vm.debug("Type: " + ch.type);
-		pref.log("Trying images");
-		getImages(start, ch);
-		pref.log("Got images");
-		//pref.log("Trying maps");
-		//getMaps(ch);
-		//pref.log("Got maps");
-		pref.log("Getting additional waypoints");
-
-		getAddWaypoints(start, ch);
-
-		pref.log("Got additional waypoints");
-		ch.CacheNotes = notes;
-		ch.saveCacheDetails(profile.dataDir);
-		
-		cacheDB.set(number, ch);
-		profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
+		profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR); //TODO This could be done at the end in the context menu
+		boolean ret=!infB.isClosed; // If the infoBox was closed before getting here, we return false
 		infB.close(0);
-		Vm.showWait(false);
+		//Vm.showWait(false); In myTableControl
+		return ret;
 	}
 	
 	/**
@@ -235,9 +248,9 @@
 			return;
 		}
 		Vm.showWait(true);
-		String start = new String();
+		String start = "";
 		Regex rex = new Regex("name=\"__VIEWSTATE\" value=\"(.*)\" />");
-		String doc = new String();
+		String doc = "";
 		
 		int ok = login();
 		if(ok == Form.IDCANCEL) {
@@ -270,13 +283,14 @@
 			pref.log("Error fetching first list page");
 			Vm.debug("Could not get list");
 		}
-		String dummy = new String();
-		//String lineBlck = new String();
+		String dummy = "";
+		//String lineBlck = "";
 		int page_number = 4;		
 		Regex rexLine = new Regex("<tr bgcolor=((?s).*?)</tr>");
 		int found_on_page = 0;
 		//Loop till maximum distance has been found or no more caches are in the list
 		while(distance > 0){
+			if (infB.isClosed) break;
 			rex.search(start);
 			viewstate = rex.stringMatched(1);
 			//Vm.debug("In loop");
@@ -323,11 +337,12 @@
 			found_on_page = 0;
 		}
 		pref.log("Found " + cachesToLoad.size() + " caches");
-		infB.setInfo("Found " + cachesToLoad.size() + " caches");
+		if (!infB.isClosed) infB.setInfo("Found " + cachesToLoad.size() + " caches");
 		// Now ready to spider each cache
-		String wpt = new String();
+		String wpt = "";
 		CacheHolder ch;
 		for(int i = 0; i<cachesToLoad.size(); i++){
+			if (infB.isClosed) break;
 			ch = new CacheHolder();
 			wpt = (String)cachesToLoad.get(i);
 			// Get only caches not already available in the DB
@@ -353,7 +368,7 @@
 					pref.log("Trying logs");
 					ch.CacheLogs = getLogs(start, ch);
 					int z = 0;
-					String loganal = new String();
+					String loganal = "";
 					while(z < ch.CacheLogs.size() && z < 5){
 						loganal = (String)ch.CacheLogs.get(z);
 						if(loganal.indexOf("icon_sad")>0) {
@@ -408,6 +423,7 @@
 						getImages(start, ch);
 						pref.log("Got images");
 					}
+					if (infB.isClosed) break;
 					ch.Bugs = getBugs(start);
 					if(ch.Bugs.length()>0) ch.has_bug = true; else ch.has_bug = false;
 					pref.log("Getting additional waypoints");
@@ -458,6 +474,7 @@
 		String result = "";
 		String oldInfoBox=infB.getInfo();
 		while(exBug.endOfSearch() == false){
+			if (infB.isClosed) break; // Allow user to cancel by closing progress form
 			linkPlusBug= exBug.findNext();
 			int idx=linkPlusBug.indexOf("'>");
 			if (idx<0) break; // No link/bug pair found
@@ -485,8 +502,8 @@
 	
 	public void getAddWaypoints(String doc, CacheHolder ch){
 		Extractor exWayBlock = new Extractor(doc, "<strong>Additional Waypoints</strong><br>", "</table>", 0, false);
-		String wayBlock = new String();
-		String rowBlock = new String();
+		String wayBlock = "";
+		String rowBlock = "";
 		wayBlock = exWayBlock.findNext();
 		Regex nameRex = new Regex("&RefDS=1\">(.*)</a>");
 		Regex koordRex = new Regex("align=\"left\">([NSns] [0-9]{1,2}..[0-9]{1,2}.[0-9]{1,3} [EWew] [0-9]{1,3}..[0-9]{1,2}.[0-9]{1,3})</td>");
@@ -534,7 +551,7 @@
 		String imgType;
 		String imgUrl;
 		//In the long description
-		String longDesc = new String();
+		String longDesc = "";
 		longDesc = getLongDesc(doc);
 		longDesc = STRreplace.replace(longDesc, "img", "IMG");
 		longDesc = STRreplace.replace(longDesc, "src", "SRC");
@@ -566,7 +583,7 @@
 					}
 				} catch (IndexOutOfBoundsException e) { 
 					Vm.debug("IndexOutOfBoundsException not in image span"+e.toString()+"imgURL:"+imgUrl);
-					pref.log("Problem loading image");
+					pref.log("Problem loading image. imgURL:"+imgUrl);
 				}
 				}
 			exImgSrc.setSource(exImgBlock.findNext());
@@ -593,7 +610,7 @@
 						ch.ImagesText.add(exImgName.findNext());
 					}
 				} catch (IndexOutOfBoundsException e) { 
-					Vm.debug("IndexOutOfBoundsException in image span"+e.toString()+"imgURL:"+imgUrl); 
+					pref.log("IndexOutOfBoundsException in image span. imgURL:"+imgUrl,e); 
 				}
 			}
 		}
@@ -607,7 +624,7 @@
 		//int bytes_read;
 		//byte[] buffer = new byte[9000];
 		ByteArray daten;
-		String datei = new String();
+		String datei = "";
 		datei = profile.dataDir + target;
 		if(pref.myproxy.length()>0){
 			connImg = new HttpConnection(pref.myproxy, Convert.parseInt(pref.myproxyport), quelle);
@@ -699,7 +716,7 @@
 	}
 	
 	private String getLongDesc(String doc){
-		String res = new String();
+		String res = "";
 		inRex = new Regex("<span id=\"ShortDescription\">((?s).*?)</span>");
 		Regex rex2 = new Regex("<span id=\"LongDescription\">((?s).*?)<strong>Additional Hints");
 		inRex.search(doc);
@@ -729,8 +746,8 @@
 	}
 	
 	private Vector getLogs(String doc, CacheHolder ch){
-		String icon = new String();
-		String name = new String();
+		String icon = "";
+		String name = "";
 		Vector reslts = new Vector();
 		Regex block = new Regex("<span id=\"CacheLogs\">((?s).*?)</span>");
 		block.search(doc);
@@ -749,12 +766,12 @@
 			inRex.searchFrom(doc, inRex.matchedTo());
 		}
 		*/
-		String singleLog = new String();
+		String singleLog = "";
 		Extractor exSingleLog = new Extractor(doc, "<STRONG>", "[<A href=", 0, false); // maybe here is some change neccessary because findnext now gives the whole endstring back??? 
 		singleLog = exSingleLog.findNext();
 		Extractor exIcon = new Extractor(singleLog, "http://www.geocaching.com/images/icons/", "' align='abs", 0, true);
 		Extractor exNameTemp = new Extractor(singleLog, "<A HREF=\"", "/A>", 0 , true);
-		String nameTemp = new String();
+		String nameTemp = "";
 		nameTemp = exNameTemp.findNext();
 		Extractor exName = new Extractor(nameTemp, ">", "<", 0 , true);
 		Extractor exDate = new Extractor(singleLog, "align='absmiddle'>&nbsp;", " by <", 0 , true);
@@ -846,8 +863,8 @@
 	private static String fetch_post(String address, String document, String path) throws IOException 
 	   	{
 			
-			//String line = new String();
-			String totline = new String();
+			//String line = "";
+			String totline = "";
 			if(pref.myproxy.length()==0){
 				try {
 					/*

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-02-22 21:07:38 UTC (rev 616)
+++ trunk/src/CacheWolf/myTableControl.java	2007-02-22 21:18:55 UTC (rev 617)
@@ -107,32 +107,33 @@
 		if (selectedItem.toString().equals(MyLocale.getMsg(1014,"Update"))){
 			SpiderGC spider = new SpiderGC(pref, profile);
 			Vm.showWait(true);
-			spider.login();
-			boolean alreadySaid = false;
-			boolean alreadySaid2 = false;
-			for(int i = 0; i <	cacheDB.size(); i++){
-				ch = (CacheHolder)cacheDB.get(i);
-				if(ch.is_Checked == true) {
-					if ( (ch.wayPoint.length() > 1 && ch.wayPoint.substring(0,2).equalsIgnoreCase("GC")))
-//						Notiz: Wenn es ein addi Wpt ist, sollte eigentlich der Maincache gespidert werden
-//						Alter code pr?ft aber nur ob ein Maincache von GC existiert und versucht dann den addi direkt zu spidern, was nicht funktioniert
-//						TODO: Diese Meldungen vor dem Einloggen darstellen						
-					{
-						spider.spiderSingle(i);
-					} else if (ch.isAddiWpt() && !ch.mainCache.is_Checked) { // Is the father ticked?
-						if (!alreadySaid2) {
-							alreadySaid2=true;
-							(new MessageBox("Information","Hilfswegpunkte k?nnnen nicht direkt gespidert werden\nBitte zus?tzlich den Vater anhaken", MessageBox.OKB)).exec();
+			if (spider.login()==Form.IDOK) {
+				boolean alreadySaid = false;
+				boolean alreadySaid2 = false;
+				for(int i = 0; i <	cacheDB.size(); i++){
+					ch = (CacheHolder)cacheDB.get(i);
+					if(ch.is_Checked == true) {
+						if ( (ch.wayPoint.length() > 1 && ch.wayPoint.substring(0,2).equalsIgnoreCase("GC")))
+	//						Notiz: Wenn es ein addi Wpt ist, sollte eigentlich der Maincache gespidert werden
+	//						Alter code pr?ft aber nur ob ein Maincache von GC existiert und versucht dann den addi direkt zu spidern, was nicht funktioniert
+	//						TODO: Diese Meldungen vor dem Einloggen darstellen						
+						{
+							if (!spider.spiderSingle(i)) break;
+						} else if (ch.isAddiWpt() && !ch.mainCache.is_Checked) { // Is the father ticked?
+							if (!alreadySaid2) {
+								alreadySaid2=true;
+								(new MessageBox("Information","Hilfswegpunkte k?nnnen nicht direkt gespidert werden\nBitte zus?tzlich den Vater anhaken", MessageBox.OKB)).exec();
+							}
+						} else if (ch.mainCache != null &&	ch.mainCache.wayPoint.length() > 1 	&& !ch.mainCache.wayPoint.substring(0,2).equalsIgnoreCase("GC") && 
+								!alreadySaid) {
+							alreadySaid = true;
+							(new MessageBox("Information",ch.wayPoint+">"+ch.mainCache.wayPoint+": Diese Funktion steht gegenw?rtig nur f?r Geocaching.com zur Verf?gung", MessageBox.OKB)).exec();
 						}
-					} else if (ch.mainCache != null &&	ch.mainCache.wayPoint.length() > 1 	&& !ch.mainCache.wayPoint.substring(0,2).equalsIgnoreCase("GC") && 
-							!alreadySaid) {
-						alreadySaid = true;
-						(new MessageBox("Information",ch.wayPoint+">"+ch.mainCache.wayPoint+": Diese Funktion steht gegenw?rtig nur f?r Geocaching.com zur Verf?gung", MessageBox.OKB)).exec();
 					}
 				}
+				profile.hasUnsavedChanges=true;	
+				tbp.refreshTable();
 			}
-			profile.hasUnsavedChanges=true;	
-			tbp.refreshTable();
 			Vm.showWait(false);
 		}
 		if (selectedItem.toString().equals(MyLocale.getMsg(1019,"Center"))){



From kalli at mail.berlios.de  Thu Feb 22 22:37:46 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Thu, 22 Feb 2007 22:37:46 +0100
Subject: [Cachewolf-svn] r618 - trunk/src/CacheWolf
Message-ID: <200702222137.l1MLbkQn025479@sheep.berlios.de>

Author: kalli
Date: 2007-02-22 22:37:41 +0100 (Thu, 22 Feb 2007)
New Revision: 618

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/Profile.java
Log:
Addi wpts erben Attribute vom Main Cache
Main Cache vererbt Attribute an addi wpts

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-02-22 21:18:55 UTC (rev 617)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-02-22 21:37:41 UTC (rev 618)
@@ -87,7 +87,10 @@
 	  if (this.is_owned == false) this.is_owned = newCh.is_owned;
 	  // update is_found if not already found
 	  if (this.is_found == false) this.is_found = newCh.is_found;
+	  // no else, because status can change.
+	  if (this.is_found == true) this.CacheStatus = MyLocale.getMsg(318,"Found");
 	  
+	  
 	  this.is_new = false;
 	  this.is_update = false;
 	  this.is_log_update = false;
@@ -454,5 +457,26 @@
 		   bearing = NOBEARING;
 	   }
    }
+
+   public void setAttributesFromMainCache(CacheHolder mainCh){
+	   this.CacheOwner = mainCh.CacheOwner;
+	   this.CacheStatus = mainCh.CacheStatus;
+	   this.is_archived = mainCh.is_archived;
+	   this.is_available = mainCh.is_available;
+	   this.is_black = mainCh.is_black;
+	   this.is_owned = mainCh.is_owned;
+	   this.is_new = mainCh.is_new;
+	   this.is_found = mainCh.is_found;
+   }
    
+   public void setAttributesToAddiWpts(){
+	   if (this.hasAddiWpt()){
+		   CacheHolder addiWpt;
+		   for (int i= this.addiWpts.getCount() - 1;  i>=0; i--){
+			    addiWpt = (CacheHolder) this.addiWpts.get(i);
+			    addiWpt.setAttributesFromMainCache(this);
+		   }
+	   }
+   }
+   
 }
\ No newline at end of file

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-02-22 21:18:55 UTC (rev 617)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-02-22 21:37:41 UTC (rev 618)
@@ -354,15 +354,7 @@
 			  profile.buildReferences();
 		  }
 		  // set status also on addi wpts
-		  if (ch.hasAddiWpt()){
-			  CacheHolder addiWpt;
-			  for (int i=0;i<ch.addiWpts.getCount();i++){
-				  addiWpt = (CacheHolder)ch.addiWpts.get(i);
-				  addiWpt.CacheStatus = ch.CacheStatus;
-				  addiWpt.is_found = ch.is_found;
-				  addiWpt.is_owned = ch.is_owned;
-			  }
-		  }
+		  ch.setAttributesToAddiWpts();
 		  if (dirty_notes) ch.saveCacheDetails(profile.dataDir);
 		  dirty_notes=false;
 		  dirty_details=false;

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-02-22 21:18:55 UTC (rev 617)
+++ trunk/src/CacheWolf/Profile.java	2007-02-22 21:37:41 UTC (rev 618)
@@ -427,6 +427,7 @@
 					mainCh = (CacheHolder) cacheDB.get(index.intValue());
 					mainCh.addiWpts.add(ch);
 					ch.mainCache = mainCh;
+					ch.setAttributesFromMainCache(mainCh);
 				}// if
 			}// if
 		}// for



From kalli at mail.berlios.de  Thu Feb 22 22:53:51 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Thu, 22 Feb 2007 22:53:51 +0100
Subject: [Cachewolf-svn] r619 - trunk/src/CacheWolf
Message-ID: <200702222153.l1MLrphX029908@sheep.berlios.de>

Author: kalli
Date: 2007-02-22 22:53:47 +0100 (Thu, 22 Feb 2007)
New Revision: 619

Modified:
   trunk/src/CacheWolf/DetailsPanel.java
Log:
Vererbung wird auch beim Setzen des MainCaches auf die Blacklist aufgerufen.

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-02-22 21:37:41 UTC (rev 618)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-02-22 21:53:47 UTC (rev 619)
@@ -292,6 +292,7 @@
 					btnBlack.image = imgBlack;
 				}
 				blackStatus = thisCache.is_black;
+				thisCache.setAttributesToAddiWpts();
 				btnBlack.repaintNow();
 			}
 			else if (ev.target == btnNewWpt){



From pfeffer at mail.berlios.de  Fri Feb 23 13:27:15 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Fri, 23 Feb 2007 13:27:15 +0100
Subject: [Cachewolf-svn] r620 - trunk/src/CacheWolf
Message-ID: <200702231227.l1NCRFR5000567@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-23 13:27:07 +0100 (Fri, 23 Feb 2007)
New Revision: 620

Modified:
   trunk/src/CacheWolf/CWGPSPoint.java
Log:
GPS: Absicherung bei unvollst?\195?\164ndigen Daten verbessert und Exception-Log

Modified: trunk/src/CacheWolf/CWGPSPoint.java
===================================================================
--- trunk/src/CacheWolf/CWGPSPoint.java	2007-02-22 21:53:47 UTC (rev 619)
+++ trunk/src/CacheWolf/CWGPSPoint.java	2007-02-23 12:27:07 UTC (rev 620)
@@ -6,6 +6,7 @@
  */
 package CacheWolf;
 import ewe.sys.*;
+import ewe.ui.ExecTransfer;
 import ewe.io.*;
 
 
@@ -19,7 +20,7 @@
 	static protected final int LOGNMEA = 0x01;
 	static protected final int LOGRAW  = 0x02;
 	static protected final int LOGALL  = LOGNMEA|LOGRAW;
-	
+
 	double Speed; //Speed
 	double Bear;	//Bearing
 	String Time; //Time
@@ -28,7 +29,7 @@
 	int numSat; //Satellites in use, -1 indicates no data, -2 that data could not be interpreted
 	double HDOP; // Horizontal dilution of precision
 	double Alt; //Altitude
-	
+
 	//Logging
 	int logTimer = 0;
 	int logFlag = 0;
@@ -36,8 +37,8 @@
 	boolean doLogging = false;
 	FileWriter logFile;
 	String lastStrExamined = new String();
-	
-	
+
+
 	public CWGPSPoint()
 	{
 		super();
@@ -50,23 +51,23 @@
 		this.Alt = 0;
 		this.HDOP = 0;
 	}
-	
-	
+
+
 	public double getSpeed(){
 		return this.Speed;
 	}
-	
+
 	public double getBear (){
 		return this.Bear;
 	}
 	public String getTime(){
 		return this.Time;
 	}
-	
+
 	public int getFix(){
 		return this.Fix;
 	}
-	
+
 	/**
 	 * this method should be called, if COM-Port is closed
 	 */
@@ -74,7 +75,7 @@
 		this.Fix = 0;
 		this.numSat = 0;
 	}
-	
+
 	/**
 	 * this method should be called, if not data is coming from COM-Port but is expected to come
 	 */
@@ -82,7 +83,7 @@
 		this.Fix = -1;
 		this.numSat = -1;
 	}
-	
+
 	/**
 	 * this method should be called, if examine returns for several calls that it couldn't interprete the data
 	 */
@@ -90,14 +91,14 @@
 		this.Fix = -2;
 		this.numSat = -2;
 	}
-	
+
 	public void ticked(int timerId, int elapsed){
 		if (timerId == logTimer) {
 			writeLog = true;
 		}
-		
+
 	}
-	
+
 	/**
 	 * 
 	 * @param logFileDir directory for logfile
@@ -124,7 +125,7 @@
 		doLogging = true;
 		return 0;
 	}
-	
+
 	public void stopLog() {
 		writeLog = false;
 
@@ -140,156 +141,162 @@
 		doLogging = false;
 	}
 
-	
+
 	public int getSats(){
 		return this.numSat;
 	}
-	
+
 	public double getAlt(){
 		return this.Alt;
 	}
-	
+
 	public double getHDOP(){
 		return this.HDOP;
 	}
-	
+
 	/**
 	 * 
 	 * @param NMEA	string with data to examine
 	 * @return true if some data could be interpreted false otherwise
 	 */
 	public boolean examine(String NMEA){ 
-		int i, start, end;
-		String latDeg="0", latMin="0", latNS="N"; 
-		String lonDeg="0", lonMin="0", lonEW="E";
-		String currToken;
-		end = 0;
 		boolean interpreted = false;
-		lastStrExamined = NMEA;
-		//Vm.debug(NMEA);
-		if (writeLog && (logFlag & LOGRAW) > 0){ 
-			try {
-				logFile.write(NMEA);
-				writeLog = false;
-			} catch (IOException e) {}
-		}
-		while(true){
-			start = NMEA.indexOf("$GP", end);  
-			if (start == -1) return interpreted;  
-			end = NMEA.indexOf("*", start);  
-			if ((end == -1)||(end+3 > NMEA.length())) return interpreted;  
+		try {
+			int i, start, end;
+			String latDeg="0", latMin="0", latNS="N"; 
+			String lonDeg="0", lonMin="0", lonEW="E";
+			String currToken;
+			end = 0;
+			lastStrExamined = NMEA;
+			//Vm.debug(NMEA);
+			if (writeLog && (logFlag & LOGRAW) > 0){ 
+				try {
+					logFile.write(NMEA);
+					writeLog = false;
+				} catch (IOException e) {}
+			}
+			while(true){
+				start = NMEA.indexOf("$GP", end);  
+				if (start == -1) return interpreted;  
+				end = NMEA.indexOf("*", start);  
+				if ((end == -1)||(end+3 > NMEA.length())) return interpreted;  
 
-			
-			//Vm.debug(NMEA.substring(start,end+3));
-			if ((end - start) < 15 || !checkSumOK(NMEA.substring(start,end+3))){
-				//Vm.debug("checksum wrong");
-				continue;
-			}
-			Extractor ex = new Extractor ("," + NMEA.substring(start,end), ",",",",0,true);
-			currToken = ex.findNext();
-			if (currToken.equals("$GPGGA")){
-				//Vm.debug("In $GPGGA");
-				i = 0;
-				while(ex.endOfSearch() != true){
-					currToken = ex.findNext();
-					i++;
-					if (currToken.length()==0) continue; // sometimes there are 2 colons directly one after the other like ",," (e.g. loox)
-					switch (i){
+
+				//Vm.debug(NMEA.substring(start,end+3));
+				if ((end - start) < 15 || !checkSumOK(NMEA.substring(start,end+3))){
+					//Vm.debug("checksum wrong");
+					continue;
+				}
+				Extractor ex = new Extractor ("," + NMEA.substring(start,end), ",",",",0,true);
+				currToken = ex.findNext();
+				if (currToken.equals("$GPGGA")){
+					//Vm.debug("In $GPGGA");
+					i = 0;
+					while(ex.endOfSearch() != true){
+						currToken = ex.findNext();
+						i++;
+						if (currToken.length()==0) continue; // sometimes there are 2 colons directly one after the other like ",," (e.g. loox)
+						switch (i){
 						case 1: this.Time = currToken; break;
 						case 2: try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {}
-								try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {}
-								break;
+						try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+						break;
 						case 3: latNS = currToken;
-								break;
-								
+						break;
+
 						case 4: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {}
-								try {lonMin = currToken.substring(3,currToken.length()); interpreted = true; } catch (IndexOutOfBoundsException e) {}
-								break;
+						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true; } catch (IndexOutOfBoundsException e) {}
+						break;
 						case 5: lonEW = currToken;
-								break;
+						break;
 						case 6: this.Fix = Convert.toInt(currToken); interpreted = true; break;
 						case 7: this.numSat = Convert.toInt(currToken); interpreted = true; break;
 						case 8: try {this.HDOP = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} break;
 						case 9: try {this.Alt = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} break;
-					} // switch
-				} // while
-				this.set(latNS, latDeg, latMin, "0", lonEW, lonDeg, lonMin, "0", CWPoint.DMM);
-								
-			} // if
-		
-			if (currToken.equals("$GPVTG")){
-				i = 0;
-				while(ex.endOfSearch() != true){
-					currToken = ex.findNext();
-					i++;
-					if (currToken.length()==0) continue;
-					switch (i){
+						} // switch
+					} // while
+					this.set(latNS, latDeg, latMin, "0", lonEW, lonDeg, lonMin, "0", CWPoint.DMM);
+
+				} // if
+
+				if (currToken.equals("$GPVTG")){
+					i = 0;
+					while(ex.endOfSearch() != true){
+						currToken = ex.findNext();
+						i++;
+						if (currToken.length()==0) continue;
+						switch (i){
 						case 1: try { this.Bear =Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {}
-								if (this.Bear > 360) Vm.debug("Error bear VTG");
-								break;
+						if (this.Bear > 360) Vm.debug("Error bear VTG");
+						break;
 						case 7: try { this.Speed = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} 
-								break;
-					} // switch
-				} // while
-			} // if
-			
-			if (currToken.equals("$GPRMC")){
-				//Vm.debug("In $GPRMC");
-				i = 0;
-				String status = "V";
-				while(ex.endOfSearch() != true){
-					currToken = ex.findNext();
-					i++;
-					if (currToken.length()==0) continue;
-					//Vm.debug("zz: " + i);
-					//Vm.debug(currToken);
-					switch (i){
+						break;
+						} // switch
+					} // while
+				} // if
+
+				if (currToken.equals("$GPRMC")){
+					//Vm.debug("In $GPRMC");
+					i = 0;
+					String status = "V";
+					while(ex.endOfSearch() != true){
+						currToken = ex.findNext();
+						i++;
+						if (currToken.length()==0) continue;
+						//Vm.debug("zz: " + i);
+						//Vm.debug(currToken);
+						switch (i){
 						case 1: this.Time = currToken; interpreted = true; break;
 						case 2: status = currToken; 
-								if (status.equals("A")) this.Fix = 1;
-								else this.Fix = 0;
-								interpreted = true;
-								break;
+						if (status.equals("A")) this.Fix = 1;
+						else this.Fix = 0;
+						interpreted = true;
+						break;
 						case 3: 	//Vm.debug("Here--->");
-								try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {}
-								//Vm.debug(":" + latDeg);
-								try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {}
-								//Vm.debug(":" + latMin);
-								break;
+							try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+							//Vm.debug(":" + latDeg);
+							try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+							//Vm.debug(":" + latMin);
+							break;
 						case 4: latNS = currToken; interpreted = true;
-								break;
+						break;
 						case 5: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {}
-								try {lonMin = currToken.substring(3,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {}
-								break;
+						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+						break;
 						case 6: lonEW = currToken;
-								interpreted = true;
-								break;
+						interpreted = true;
+						break;
 						case 7: if (status.equals("A")){
-									try {this.Speed = Common.parseDouble(currToken)*1.854;
-										interpreted = true; } catch (NumberFormatException e) { }
-								}
-								break;
+							try {this.Speed = Common.parseDouble(currToken)*1.854;
+							interpreted = true; } catch (NumberFormatException e) { }
+						}
+						break;
 						case 8: if (status.equals("A") && currToken.length()> 0){
-									try {this.Bear = Common.parseDouble(currToken);
-									interpreted = true; } catch (NumberFormatException e) { }
-								}
-								break;
+							try {this.Bear = Common.parseDouble(currToken);
+							interpreted = true; } catch (NumberFormatException e) { }
+						}
+						break;
 						case 9: if (status.equals("A") && currToken.length()> 0){
-									try {this.Date = currToken;
-									interpreted = true; } catch (NumberFormatException e) { }
-								}
-								break;
-					} // switch
-				} // while
-				if (status.equals("A")){
-					this.set(latNS, latDeg, latMin, "0",
-							 lonEW, lonDeg, lonMin, "0", CWPoint.DMM);				
-				}
-			} // if
-		//Vm.debug("End of examine");
-		} //while
+							try {this.Date = currToken;
+							interpreted = true; } catch (NumberFormatException e) { }
+						}
+						break;
+						} // switch
+					} // while
+					if (status.equals("A")){
+						this.set(latNS, latDeg, latMin, "0",
+								lonEW, lonDeg, lonMin, "0", CWPoint.DMM);				
+					}
+				} // if
+				//Vm.debug("End of examine");
+			} //while
+		} catch (Exception e) {
+			Global.getPref().log("Exception in examine in CWGPSPoint", e, true);
+			e.printStackTrace();
+			return interpreted;
+		}
 	}
-	
+
 	private boolean checkSumOK(String nmea){
 		int startPos = 1; // begin after $
 		int endPos = nmea.length() - 3;// without * an two checksum chars
@@ -300,12 +307,15 @@
 		}
 		//Vm.debug(nmea.substring(3,6)+" Checksum: " + nmea.substring(endPos+1) + " Calculated: " + Convert.intToHexString(checkSum));
 		try { return (checkSum == Byte.parseByte(nmea.substring(endPos+1),16));
-		} catch (IndexOutOfBoundsException e) {return false;
+		} catch (IndexOutOfBoundsException e) {
+			return false;
+		} catch (NumberFormatException e) {
+			return false;
 		}
 	}
 
-	  
-	
+
+
 	public void printAll(){
 		Vm.debug("Latitude:  " + this.getLatDeg(DD));
 		Vm.debug("Longitude: " + this.getLonDeg(DD));
@@ -319,4 +329,4 @@
 		Vm.debug("----------------");
 	}
 }
-	
+



From pfeffer at mail.berlios.de  Fri Feb 23 15:34:18 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Fri, 23 Feb 2007 15:34:18 +0100
Subject: [Cachewolf-svn] r621 - trunk/src/CacheWolf
Message-ID: <200702231434.l1NEYI2Y012871@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-23 15:34:14 +0100 (Fri, 23 Feb 2007)
New Revision: 621

Modified:
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/TrackOverlay.java
Log:
MovingMap: Umstellung auf Transparenzmaske anstelle einer transparenten Farbe, ich hoffe, damit loest sich das Problem von Kalli und BilboWolf mit dem bei ihnen undurchsichtigen TrackOverlay. Allerdings: in Java-Vm ist dieses Verfahren sehr, sehr speicher fressend. In der ewe-Vm hingegen nicht. Es ist dort sogar schneller.
MovingMap: schnellere TrackOverlays dadurch, dass pixel-cache geleert wird, wenn fuer die letzten 60 GPS-Pos-Updates (d.h. im Moment 60 Sekunden) keine Pixel auf dem jeweiligen TrackOverlay lag

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-23 12:27:07 UTC (rev 620)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-23 14:34:14 UTC (rev 621)
@@ -76,7 +76,7 @@
 		this.noBorder = true;
 		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
 		this.title = "Moving Map";
-		this.backGround = Color.Black;
+		this.backGround = new Color(254,254,254); // background must not be black because black is interpreted as transparent and transparent images above (eg trackoverlay) want be drawn in windows-VM, so be care, don|t use white either
 		this.mapPath = Global.getPref().getMapLoadPath();
 
 		mmp = new MovingMapPanel(this);
@@ -1529,7 +1529,7 @@
 			lastZoomHeight = 0;
 		}
 		if (which == mm.buttonImageZoom1to1) {
-			mm.zoom1to1();
+			mm.zoom1to1(); 
 		}
 		if (which == mm.bottonImageClose) {
 			WindowEvent tmp = new WindowEvent();
@@ -1897,8 +1897,10 @@
 
 	public void doDraw(Graphics g,int options) {
 		if (map == null) return;
-		if (!dirsChanged) {
-			g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
+		drawArrows(g);
+		return;
+/*		if (!dirsChanged) {
+			g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height); // the transparency with a transparent color doesn't work in ewe-vm for pocketpc, it works in java-vm, ewe-vm on pocketpc2003 
 			return;
 		}
 		dirsChanged = false;
@@ -1909,7 +1911,7 @@
 		drawArrows(draw);
 		draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw 
 		g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
-	}
+*/	}
 
 	private void drawArrows(Graphics g){
 
@@ -1955,26 +1957,19 @@
 class MapImage extends AniImage {
 	public Point locAlways = new Point(); // contains the theoretical location even if it the location is out of the screen. If the image is on the screen, it contains the same as location
 	static Dimension screenDim;
-	public int widthi;
-	public int heighti;
 	boolean hidden = false;
 	public MapImage() {
 		super();
-		widthi = getWidth();
-		heighti = getHeight();
+		if (screenDim == null) screenDim = new Dimension(0,0);
 	}
 
 	public MapImage(String f) {
 		super(f);
-		widthi = getWidth(); // this is necessary becaus width is not directly accessable from here and an function call each time the pos ist updated shall be avoided becaus of performance reasons
-		heighti = getHeight();
 		if (screenDim == null) screenDim = new Dimension(0,0);
 	}
 
 	public MapImage(mImage im) {
 		super(im);
-		widthi = getWidth();
-		heighti = getHeight();
 		if (screenDim == null) screenDim = new Dimension(0,0);
 	}
 
@@ -1984,8 +1979,6 @@
 
 	public void setImage(Image im, Color c) {
 		super.setImage(im, c);
-		widthi = getWidth();
-		heighti = getHeight();
 		if (screenDim == null) screenDim = new Dimension(0,0);
 	}
 
@@ -2014,8 +2007,8 @@
 	}
 
 	public boolean isOnScreen() { 
-		if ( (locAlways.x + widthi > 0 && locAlways.x < screenDim.width) && 
-				(locAlways.y + heighti > 0 && locAlways.y < screenDim.height) ) return true;
+		if ( (locAlways.x + location.width > 0 && locAlways.x < screenDim.width) && 
+				(locAlways.y + location.height > 0 && locAlways.y < screenDim.height) ) return true;
 		else return false;
 	}
 

Modified: trunk/src/CacheWolf/TrackOverlay.java
===================================================================
--- trunk/src/CacheWolf/TrackOverlay.java	2007-02-23 12:27:07 UTC (rev 620)
+++ trunk/src/CacheWolf/TrackOverlay.java	2007-02-23 14:34:14 UTC (rev 621)
@@ -4,11 +4,13 @@
 
 import ewe.fx.Color;
 import ewe.fx.Graphics;
+import ewe.fx.IImage;
 import ewe.fx.Image;
 import ewe.fx.Pen;
 import ewe.graphics.AniImage;
 import ewe.sys.Convert;
 import ewe.fx.Point;
+import ewe.fx.Mask;
 
 import ewe.util.Vector;
 
@@ -17,6 +19,7 @@
 	TrackPoint topLeft;
 	TrackPoint bottomRight;
 	Graphics draw;
+	Graphics drawMask;
 	int test;
 	MapInfoObject trans; 
 	Vector tracks;
@@ -25,24 +28,53 @@
 	public Color trackPixelsColor[] = null;
 	public int numPixels = 0;
 	final static int maxPixelsInCache = 100;
-	final static Color transparentColor = Color.White;
+	final static Color transparentColorForOverlay = Color.White; // onlz for use when transparent color is used
 	public TrackOverlay (TrackPoint topLefti, int widthi, int highti, MapInfoObject transi) {
+		super();
 		topLeft = new TrackPoint(topLefti);
 		trans = transi;
 		bottomRight = calcLatLonInImage(widthi, highti);
-		setImage(new Image(widthi, highti), transparentColor);
+		Image maski = new Image(widthi, highti);
+		drawMask = new Graphics(maski);
+		drawMask.setColor(Color.White);
+		drawMask.fillRect(0, 0, maski.getWidth(), maski.getHeight());
+		setImage(new Image(widthi, highti), maski); // java-vm: transparency with a mask is very memory consuming, but transparency with a mask is much faster in ewe-vm and doesn't consume more memory than a transparency color
+		maski.free(); //setimage produces an inverted copy of the mask
+		maski = null;
 		//properties = AlwaysOnTop; // arrows are above, so dont set it.
 		draw = new Graphics(image);
 		draw.setDrawOp(Graphics.DRAW_OVER);
-		draw.setColor(transparentColor);
+		draw.setColor(Color.White);
 		draw.fillRect(0, 0, widthi, highti);
+		//int[] markImage = {0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000};
+		//int[] markMaskOpaque = {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff};
+		//mask.setPixels( markMaskOpaque, 0, 50, 50, 2, 2, 0);
+		//draw.fillRectRGB(50, 50, 52, 52, 0x00ff0000); // fillRectRGB has a Bug - it never returns - use fillRect instead
+		//image.setPixels(markImage, 0, 50, 50, 2, 2, 0); // out of an to me unkwon reason this doesn't work here, but it does in painttracks
 	}
+	public void imageSet()
+//	==================================================================
+	{
+		IImage i = drawable;
+		if (i == null) i = image;
+		if (i != null){
+			location.width = i.getWidth();
+			location.height = i.getHeight();
+		}
+		if (image != null && image != sourceImage) image.freeze();
+//		if (mask != null && mask != sourceMask) mask.freeze(); // dont freeze the mask, it could change. Anyway momentanously it doesnt change, because when the image contains non-white in the opaque areas, it will be opaque without changing the mask
+		properties &= ~HasChanged;
+	}
 
 	
 	public void paintTracks() {
 	// for debugging TrackOverlayPositions
 	// draw.setPen(new Pen(Color.LightBlue,Pen.SOLID,1));
-	//	draw.fillRect(1, 1, image.getWidth()-1, image.getHeight()-1);
+	// draw.fillRect(1, 1, image.getWidth()-1, image.getHeight()-1);
+		//draw.setColor(255,0,0);
+		//draw.setPen(new Pen(new Color(255,0,0),Pen.SOLID,3));
+		//draw.fillRect(50, 50, 4, 4); // fillRectRGB has a Bug - it never returns - use fillRect instead
+
 		if (tracks == null || tracks.size() == 0) return;
 		int tri, i;
 		Track tr;
@@ -57,9 +89,15 @@
 		}
 	}
 
-		
-	public void paintPoint(Color f, double lat, double lon){
-		if (lat<bottomRight.latDec || lat > topLeft.latDec || lon<topLeft.lonDec || lon>bottomRight.lonDec) return;
+		/**
+		 * 
+		 * @param f
+		 * @param lat
+		 * @param lon
+		 * @return true if point was on this overlay
+		 */
+	public boolean paintPoint(Color f, double lat, double lon){
+		if (lat<bottomRight.latDec || lat > topLeft.latDec || lon<topLeft.lonDec || lon>bottomRight.lonDec) return false;
 		//ewe.sys.Vm.debug("showlastaddedpoint, lat: "+lat+"   lon: "+lon);
 		double b[] = new double[2];
 		int x, y;
@@ -70,6 +108,7 @@
 		//draw.drawLine(x, y, x, y);
 		//ewe.sys.Vm.debug("showlastaddedpoint, x: "+x+"   y: "+y+"loc.x: "+location.x+"  loc.y:"+location.y);
 		draw.fillRect(x-1, y-1, 3, 3);
+		//drawMask.fillRect(x-1, y-1, 3, 3);
 		/*	if (image.bufferedImage != null) { // funktioniert gut, allerdings nur in der java-VM wenn ewe.fx.Image.bufferedImage als public definiert
 			int yd;
 			for  (int xd=-1; xd<=1; xd++) {
@@ -80,14 +119,24 @@
 		if (imageChangesDontShow) {
 			try {addPixelIfNeccessary(x, y, f); }
 			catch (IndexOutOfBoundsException e) // thrown when there are more than pixels stored than possible
-			{   
-				draw.drawImage(image,null,Color.DarkBlue,0,0,location.width,location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
-				draw.drawImage(image,null,transparentColor,0,0,location.width,location.height);
-				removeAllPixels();
-			}
+			{ fixate();  }
 		}
+		return true;
 	}
 	
+	/**
+	 * this method forces ewe to transfer the drawn points
+	 * from _awtImage to bufferedImage, which is drawn to the screen
+	 *
+	 */
+	private void fixate() {
+		if (numPixels == 0) return;
+		//	draw.drawImage(image,null,Color.DarkBlue,0,0,location.width,location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+		draw.drawImage(image, null, Color.Pink, 0, 0, 1, 1); // width and height is anyway ignored, evtl. testen,  
+		imageChangesDontShow = false;
+		removeAllPixels();
+	}
+	
 	private void removeAllPixels() {
 		numPixels = 0;
 		trackPixels = null;
@@ -129,12 +178,21 @@
 		}
 		addPixel(x, y, f);
 	}
+	
+	public static final int FIXATE_IF_NO_PIXELS_NUM = 60;
+	private int notOnThisOverlaySince = 0;
+	
+	public void paintLastAddedPoint(Track tr) { 
+		draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
+		if (paintPoint(tr.trackColor, tr.TrackPoints[tr.num-1].latDec, tr.TrackPoints[tr.num-1].lonDec)) notOnThisOverlaySince = 0;
+		else notOnThisOverlaySince++;
+		if (notOnThisOverlaySince > FIXATE_IF_NO_PIXELS_NUM) { // zur Performanceverbesserung: wenn in den letzten 60 Updates keines mehr f?r dieses Overlay dabei war, Overlay Pixels fest schreiben, damit doDraw entlastet wird.
+			fixate();
+			notOnThisOverlaySince = 0;
+		}
 
-	public void paintLastAddedPoint(Track tr) { // TODO zuer Performanceverbesserung: wenn in den letzten 60 Updates keines mer f?r dieses Overlay dabei war, Overlay Pixels fest schreiben, damit doDraw entlastet wird.
-		draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
-		paintPoint(tr.trackColor, tr.TrackPoints[tr.num-1].latDec, tr.TrackPoints[tr.num-1].lonDec);
 	}
-
+	
 	public void doDraw(Graphics g,int options) { // this is automatically called when the image need to be (re-)drawn on the screen
 		super.doDraw(g, options);
 		imageChangesDontShow = true; // g.drawImage (in super) copies _awtImage into bufferedImage, any later changes to _awtImage dont show up until the mask or the image has changed - unfortunately bufferedImage is not accessable from outside
@@ -168,6 +226,10 @@
  *  
  *  Zur Not w?re auch denkbar, doDraw zu ?berschreiben, um bei jedem Aufruf alle 
  *  Trackpoints neu zu zeichnen.
+ *  Work-Aorund: draw.drawImage(image,null,Color.Pink,0,0,1,1); bewirkt, dass awtImage ins
+ *  bufferedImage kopiert wird. Dabei wird die transparentColor (in mImage) nicht ge?ndert
+ *  und beim Aufruf von doDraw wird wieder die urspr?ngliche transparentColor verwendet
+ *  
  */
 // was alles nicht funktioniert:
 //drawmask.setDrawOp(Graphics.DRAW_OVER);



From pfeffer at mail.berlios.de  Fri Feb 23 16:52:00 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Fri, 23 Feb 2007 16:52:00 +0100
Subject: [Cachewolf-svn] r622 - trunk/src/CacheWolf
Message-ID: <200702231552.l1NFq046018877@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-23 16:51:51 +0100 (Fri, 23 Feb 2007)
New Revision: 622

Modified:
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: Wenn keine Karte verf?\195?\188gbar ist, die GPS-Pos und Goto-Pos enth?\195?\164lt, wird jetzt nicht mehr keine Karte geladen, sondern die Karte mit dem gr?\195?\182?\195?\159ten ?\195?\156berblick

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-23 14:34:14 UTC (rev 621)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-23 15:51:51 UTC (rev 622)
@@ -911,7 +911,11 @@
 			break;
 		case HIGHEST_RESOLUTION: newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 0.000001f, false); break;
 		case HIGHEST_RESOLUTION_GPS_DEST: 
-			if (gotoPos!= null && GpsStatus != noGPS) newmap = maps.getMapForArea(new CWPoint(posCircleLat, posCircleLon), new CWPoint(gotoPos.lat, gotoPos.lon)); // TODO use home-coos if no gps? - consider start from details panel and from gotopanel
+			if (gotoPos!= null && GpsStatus != noGPS && posCircleLat>= -90 && posCircleLat <= 90 && posCircleLon >= -360 && posCircleLon <= 360) {
+				newmap = maps.getMapForArea(new CWPoint(posCircleLat, posCircleLon), new CWPoint(gotoPos.lat, gotoPos.lon)); // TODO use home-coos if no gps? - consider start from details panel and from gotopanel
+				if (newmap == null) newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 10000000000000000000000000000000000f, false); // use map with most available overview if no map containing PosCircle and GotoPos is available
+			}
+			//	either Goto-Pos or GPS-Pos not set
 			else newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 0.000001f, false); 
 			break;
 		default: (new MessageBox("Error", "Programmfehler: \nillegal mapChangeModus: " + mapChangeModus, MessageBox.OKB)).execute(); break;
@@ -926,7 +930,7 @@
 			return;
 		}
 		if (currentMap == null && newmap == null) {
-			(new MessageBox("Information", "F?r die aktuelle Position steht keine Karte zur Verf?ung, bitte w?hlen Sie eine manuell", MessageBox.OKB)).execute();
+			(new MessageBox("Information", "F?r die aktuelle Position steht keine Karte zur Verf?ng, bitte w?hlen Sie eine manuell", MessageBox.OKB)).execute();
 			posCircleLat = cll.latDec;
 			posCircleLon = cll.lonDec; // choosemap calls setmap with posCircle-coos
 			while (currentMap == null) {



From salzkammergut at mail.berlios.de  Sat Feb 24 09:18:31 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 24 Feb 2007 09:18:31 +0100
Subject: [Cachewolf-svn] r623 - trunk/src/CacheWolf
Message-ID: <200702240818.l1O8IV9j023197@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-24 09:18:26 +0100 (Sat, 24 Feb 2007)
New Revision: 623

Modified:
   trunk/src/CacheWolf/Parser.java
Log:
Parser: Bugfix bei mehrfachen crosstotals

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-02-23 15:51:51 UTC (rev 622)
+++ trunk/src/CacheWolf/Parser.java	2007-02-24 08:18:26 UTC (rev 623)
@@ -377,7 +377,7 @@
 		double a=java.lang.Math.abs(popCalcStackAsNumber(0));
 		if (cycles<0) cycles=1;
     	if (cycles>5) cycles=5;
-    	while (a>10 && cycles-->0) {
+    	while (a>=10 && cycles-->0) {
 	    	// Cross total = Quersumme berechnen
 			String aString = Convert.toString(a); // 
 			// bei 1.8e2 nur 1.8 verwenden 



From salzkammergut at mail.berlios.de  Sat Feb 24 15:19:53 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 24 Feb 2007 15:19:53 +0100
Subject: [Cachewolf-svn] r624 - trunk/src/CacheWolf
Message-ID: <200702241419.l1OEJrc4021829@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-24 15:19:50 +0100 (Sat, 24 Feb 2007)
New Revision: 624

Modified:
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/Tokenizer.java
Log:
Parser: Befehl zum Anzeigen der lokalen Variablen (?) und Bugfix bei Gross-/Kleinschreibung von Variablennamen

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-02-24 08:18:26 UTC (rev 623)
+++ trunk/src/CacheWolf/Parser.java	2007-02-24 14:19:50 UTC (rev 624)
@@ -165,11 +165,11 @@
     }
     
     /** Shows global symbols */
-    private void showGlobals() throws Exception {
+    private void showVars(boolean globals) throws Exception {
     	Iterator it=symbolTable.entries();
     	while (it.hasNext()) {
     		String varName=((String)((ewe.util.Map.MapEntry) it.next()).getKey());
-    		if (varName.startsWith("$")) {
+    		if (globals == varName.startsWith("$")) {
     			String value=(String) getVariable(varName);
     			if (java.lang.Double.isNaN(toNumber(value)))
     				messageStack.add(varName+" = \""+STRreplace.replace(value.toString(),"\"","\"\"")+"\"");
@@ -183,8 +183,9 @@
     private void clearLocalSymbols() {
     	Iterator it=symbolTable.entries();
     	while (it.hasNext()) {
-    		if (((String)((ewe.util.Map.MapEntry) it.next()).getKey()).startsWith("$")) 
-    			symbolTable.remove(it);
+    		ewe.util.Map.MapEntry sym=(ewe.util.Map.MapEntry) it.next();
+    		if (!((String)sym.getKey()).startsWith("$")) 
+    			symbolTable.remove(sym.getKey());
     	}
     }
     
@@ -220,7 +221,7 @@
 			// If it is a global variable, add it with a default value
 			if (varName.startsWith("$")) {
 				result="";
-				symbolTable.put(varName,"");
+				symbolTable.put(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName,"");
 			} else
 				err (MyLocale.getMsg(1702,"Variable not defined: ")+varName);
 		}
@@ -397,7 +398,7 @@
     	if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordA);
 		if (!isValidCoord(coordB)) err(MyLocale.getMsg(1712,"Invalid coordinate: ")+coordB);
     	cwPt.set(coordA);
-    	return cwPt.getDistance(new CWPoint(coordB));
+    	return cwPt.getDistance(new CWPoint(coordB))*1000.0;
     }
     
     /** Calculate brearing from one point to the next */
@@ -609,9 +610,12 @@
 
 	private void parseSimpleCommand() throws Exception{
 		if (thisToken.tt==TokenObj.TT_STOP) throw new Exception("STOP");  // Terminate without error message
-		if (thisToken.token.equals("$")) {
-			showGlobals();
+		if (thisToken.token.equals("$")) { // Show all global variables
+			showVars(true);
 			getToken();
+		} else if (thisToken.token.equals("?")) { // Show all local variables
+			showVars(false);
+			getToken();
 		} else if (thisToken.tt==TokenObj.TT_VARIABLE && lookAheadToken().tt==TokenObj.TT_EQ) 
 			parseAssign();
 		else 
@@ -694,7 +698,7 @@
 			}
 			// Name starts with $ but is not a waypoint, fall through and set it as global variable
 		}
-		symbolTable.put(varName, popCalcStackAsString());
+		symbolTable.put(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName, popCalcStackAsString());
 	}
 	
 	private void parseStringExp()throws Exception {

Modified: trunk/src/CacheWolf/Tokenizer.java
===================================================================
--- trunk/src/CacheWolf/Tokenizer.java	2007-02-24 08:18:26 UTC (rev 623)
+++ trunk/src/CacheWolf/Tokenizer.java	2007-02-24 14:19:50 UTC (rev 624)
@@ -47,7 +47,7 @@
 	}
 	
 	private boolean isSymbol(char c){
-		return "!<>(){}*/,;^+-=".indexOf(look)!=-1;
+		return "?!<>(){}*/,;^+-=".indexOf(c)!=-1;
 	}
 
 	private boolean getChar(){



From salzkammergut at mail.berlios.de  Sat Feb 24 17:42:43 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 24 Feb 2007 17:42:43 +0100
Subject: [Cachewolf-svn] r625 - trunk/src/CacheWolf
Message-ID: <200702241642.l1OGgh3H030598@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-24 17:42:39 +0100 (Sat, 24 Feb 2007)
New Revision: 625

Modified:
   trunk/src/CacheWolf/SpiderGC.java
Log:
SpiderGC: Bugfix Koordinaten von Addi Waypoints: LatLon wurde vom Hauptwegpunkt uebernommen

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-02-24 14:19:50 UTC (rev 624)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-02-24 16:42:39 UTC (rev 625)
@@ -522,7 +522,7 @@
 				typeRex.search(rowBlock);
 				cx.CacheName = nameRex.stringMatched(1);
 				if(koordRex.didMatch()) cx.pos.set(koordRex.stringMatched(1)); 
-				cx.LatLon = ch.pos.toString(); 
+				cx.LatLon = cx.pos.toString(); 
 				//cx.pos.set(cx.LatLon);
 				if(typeRex.didMatch()) cx.type = CacheType.typeText2Number("Waypoint|"+typeRex.stringMatched(1));
 				rowBlock = exRowBlock.findNext();



From salzkammergut at mail.berlios.de  Sat Feb 24 18:10:28 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 24 Feb 2007 18:10:28 +0100
Subject: [Cachewolf-svn] r626 - in trunk: resources src/CacheWolf
Message-ID: <200702241710.l1OHASBE031952@sheep.berlios.de>

Author: salzkammergut
Date: 2007-02-24 18:10:22 +0100 (Sat, 24 Feb 2007)
New Revision: 626

Modified:
   trunk/resources/wolflang.html
   trunk/src/CacheWolf/Parser.java
Log:
Parser: Neuer Befehl skeleton erzeugt einen Rahmen fuer Multis
(im Beispiel auf cachewolf.de erklaert)

Modified: trunk/resources/wolflang.html
===================================================================
--- trunk/resources/wolflang.html	2007-02-24 16:42:39 UTC (rev 625)
+++ trunk/resources/wolflang.html	2007-02-24 17:10:22 UTC (rev 626)
@@ -10,6 +10,8 @@
 <i> Example: a = 2</i><br>
 <i> Example: $a = 2; b="abc"</i><br>
 $a is global variable.<br>
+Format numerical expression:<br>
+Example: 3.14159:000.00:<br>
 <br>
 <u><b> Showing values</b></u><br>
  "some text" " more text":<br>
@@ -48,6 +50,8 @@
 project(coordinate,angle,distance)<br>
 goto(coordinate)<br>
 goto(coordinate,waypointname)<br><br>
+<b><u>Generate program for Multis</u></b><br>
+skeleton(waypointname)<br><br>
 <b><u>IF THEN ENDIF</u></b><br>
 IF condition THEN statement; statement .... ENDIF<br><br>
 </font>

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-02-24 16:42:39 UTC (rev 625)
+++ trunk/src/CacheWolf/Parser.java	2007-02-24 17:10:22 UTC (rev 626)
@@ -123,6 +123,7 @@
     	new fnType("rot13","rot13",2),
     	new fnType("show","show",2),
     	new fnType("sin","sin",2),
+    	new fnType("skeleton","skeleton",2),
     	new fnType("sqrt","sqrt",2),
     	new fnType("sval","sval",2),
     	new fnType("tolowercase","lc",2),
@@ -557,6 +558,36 @@
     	return res;
     }
     
+    /** Create a skeleton for multis */
+    private void funcSkeleton(String waypointName) throws Exception {
+   		int i=Global.getProfile().getCacheIndex(waypointName);
+		if (i<0) err(MyLocale.getMsg(1714,"Goto: Waypoint does not exist: ")+waypointName);
+   	    CacheHolder ch=(CacheHolder)Global.getProfile().cacheDB.get(i);
+		CacheHolder addiWpt;
+		StringBuffer op=new StringBuffer(1000);
+   	    if (ch.hasAddiWpt()){
+			for (int j=0; j<ch.addiWpts.getCount();j++){
+				addiWpt = (CacheHolder)ch.addiWpts.get(j);
+				op.append("IF $");
+				op.append(addiWpt.wayPoint);
+				op.append("=\"\" THEN\n   $");
+				op.append(addiWpt.wayPoint);
+				op.append("=\"\" # Pos=");
+				op.append(addiWpt.pos.toString());
+				op.append("\n   \"Punkt ");
+				op.append(addiWpt.wayPoint.substring(0,2));
+				op.append(" [");
+				op.append(addiWpt.CacheName);
+				op.append("] = \" $");
+				op.append(addiWpt.wayPoint);
+				op.append("\n   goto($");
+				op.append(addiWpt.wayPoint);
+				op.append("); STOP\nENDIF\n");
+			}
+			Global.mainTab.solverP.mText.appendText(op.toString(),true);
+		}// if hasAddiWpt
+    }
+    
     private double funcSqrt() throws Exception {
     	double a=popCalcStackAsNumber(0);
     	if (a<0) err(MyLocale.getMsg(1720,"Cannot calculate square root of a negative number"));
@@ -604,7 +635,6 @@
 			else 
 				parseSimpleCommand();
 			checkNextSymIs(";");
-			while (calcStack.size()>0) messageStack.add(popCalcStackAsString());
 		}
 	}
 
@@ -618,8 +648,10 @@
 			getToken();
 		} else if (thisToken.tt==TokenObj.TT_VARIABLE && lookAheadToken().tt==TokenObj.TT_EQ) 
 			parseAssign();
-		else 
-			parseStringExp();		
+		else {
+			parseStringExp();
+			while (calcStack.size()>0) messageStack.add(popCalcStackAsString());
+		}
 	}
 	
 	private void parseIf() throws Exception{
@@ -860,6 +892,7 @@
 //	    else if (funcDef.alias.equals("rs")) funcRequireSemicolon(nargs);
 	    else if (funcDef.alias.equals("show"));
 	    else if (funcDef.alias.equals("sin")) calcStack.add(new java.lang.Double(java.lang.Math.sin(popCalcStackAsNumber(0))));
+	    else if (funcDef.alias.equals("skeleton")) funcSkeleton(popCalcStackAsString());
 	    else if (funcDef.alias.equals("sqrt")) calcStack.add(new java.lang.Double(funcSqrt())); 
 	    else if (funcDef.alias.equals("sval")) calcStack.add(funcSval(popCalcStackAsString()));
 	    else if (funcDef.alias.equals("tan")) calcStack.add(new java.lang.Double(java.lang.Math.tan(popCalcStackAsNumber(0))));



From pfeffer at mail.berlios.de  Sun Feb 25 02:08:46 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 25 Feb 2007 02:08:46 +0100
Subject: [Cachewolf-svn] r627 - trunk/src/CacheWolf
Message-ID: <200702250108.l1P18k5Z018118@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-25 02:08:44 +0100 (Sun, 25 Feb 2007)
New Revision: 627

Modified:
   trunk/src/CacheWolf/MapsList.java
Log:
MovingMap: Bug fixed: wenn Karten mit unterschiedlicher Aufl?\195?\182sung f?\195?\188r den aktuellen Bildschirmausschnitt zur Verf?\195?\188gung stehen und die Methode "highest resolution"  gew?\195?\164hlt war, wurde die Karte mit der h?\195?\182heren Aufl?\195?\182sung geladen, auch wenn sie die aktuelle Position nicht enthielt. Vielen Dank an Kalli f?\195?\188r das gute Testmaterial!

Modified: trunk/src/CacheWolf/MapsList.java
===================================================================
--- trunk/src/CacheWolf/MapsList.java	2007-02-24 17:10:22 UTC (rev 626)
+++ trunk/src/CacheWolf/MapsList.java	2007-02-25 01:08:44 UTC (rev 627)
@@ -72,7 +72,7 @@
 	 * find the best map for lat/lon in the list of maps
 	 * currently the best map is the one, whose center is nearest to lat/lon
 	 * and in Area with its scale nearest to scale.
-	 * it always return a map (if the list is not empty) 
+	 * it always returns a map (if the list is not empty) 
 	 * even if the map is not inbound
 	 * lat/lon
 	 * @param lat
@@ -100,8 +100,8 @@
 			}
 			if (screenArea.isOverlapping(mi.getArea()) ) { // is on screen
 				if (!forceScale || (forceScale && java.lang.Math.abs(mi.scale - scale) > scaleTolerance)) { // different scale?
-					if (!forceScale && (mi.inBound(lat, lon) && (bestMap == null || (java.lang.Math.abs(mi.scale-scale) + scaleTolerance < java.lang.Math.abs(bestMap.scale-scale))))) 
-						better = true; // inbound and resolution nearer at wanted resolution -> better
+					if (!forceScale && (mi.inBound(lat, lon) && (bestMap == null || (java.lang.Math.abs(mi.scale-scale) + scaleTolerance < java.lang.Math.abs(bestMap.scale-scale)) || !bestMap.inBound(lat, lon)))) 
+						better = true; // inbound and resolution nearer at wanted resolution or old one is on screen but lat/long not inbound-> better
 					else {
 						if ( bestMap == null || (java.lang.Math.abs(mi.scale - scale) < java.lang.Math.abs(bestMap.scale - scale) + scaleTolerance)) {
 							latNearer = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm < minDistLat ;
@@ -202,7 +202,7 @@
 		for (int i=size()-1; i >= 0 ;i--) { 
 			better = false;
 			mi = (MapInfoObject)get(i);
-			if (mi.fileNameWFL == "") continue; // exclude "maps" without image
+			if (mi.fileNameWFL == "") continue; // exclude "maps" without image // TODO make this a boolean in MapInfoObject
 			if (screenArea == null || java.lang.Math.abs(mi.scale - lastscale) > scaleTolerance) {
 				screenArea = getAreaForScreen(screen, lat, lon, mi.scale, mi);
 				lastscale = mi.scale;



From kalli at mail.berlios.de  Sun Feb 25 10:22:39 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Sun, 25 Feb 2007 10:22:39 +0100
Subject: [Cachewolf-svn] r628 - trunk/src/CacheWolf
Message-ID: <200702250922.l1P9MdUC019767@sheep.berlios.de>

Author: kalli
Date: 2007-02-25 10:22:37 +0100 (Sun, 25 Feb 2007)
New Revision: 628

Modified:
   trunk/src/CacheWolf/Map.java
Log:
Groesse des Images wird jetzt aus der .map-Datei gelesen.

Modified: trunk/src/CacheWolf/Map.java
===================================================================
--- trunk/src/CacheWolf/Map.java	2007-02-25 01:08:44 UTC (rev 627)
+++ trunk/src/CacheWolf/Map.java	2007-02-25 09:22:37 UTC (rev 628)
@@ -279,8 +279,8 @@
 							gcp3.bitMapY = Convert.toInt(parts[3]);
 							if(gcp3.bitMapX == 0) gcp3.bitMapX = 1;
 							if(gcp3.bitMapY == 0) gcp3.bitMapY = 1;
-							imageWidth = gcp3.bitMapX;
-							imageHeight = gcp3.bitMapY;
+							//imageWidth = gcp3.bitMapX;
+							//imageHeight = gcp3.bitMapY;
 
 							line = inMap.readLine();
 							parts = mString.split(line, ',');
@@ -332,6 +332,15 @@
 							gcpG.bitMapX = gcp4.bitMapX;
 							gcpG.bitMapY = gcp4.bitMapY;
 							addGCP(gcpG);
+							
+							// get dimensions of image
+							while ( (line = inMap.readLine()) != null){
+								if (line.startsWith("IWH")){
+									parts = mString.split(line, ',');
+									imageWidth = Convert.toInt(parts[2]);
+									imageHeight = Convert.toInt(parts[3]);
+								}
+							}
 
 							evalGCP();
 							//Vm.debug("Saving .map file to: " + mapsPath + "/" + rawFileName + ".wfl");



From pfeffer at mail.berlios.de  Sun Feb 25 14:14:02 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 25 Feb 2007 14:14:02 +0100
Subject: [Cachewolf-svn] r629 - trunk/src/CacheWolf
Message-ID: <200702251314.l1PDE2nS021752@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-25 14:13:58 +0100 (Sun, 25 Feb 2007)
New Revision: 629

Modified:
   trunk/src/CacheWolf/InfoBox.java
   trunk/src/CacheWolf/Map.java
   trunk/src/CacheWolf/TrackOverlay.java
Log:
MapImport: Groesse der Bilddatei aus der Bilddatei selbst auslesen und ordentliche Fehlerausgabe beim Map-Import

Modified: trunk/src/CacheWolf/InfoBox.java
===================================================================
--- trunk/src/CacheWolf/InfoBox.java	2007-02-25 09:22:37 UTC (rev 628)
+++ trunk/src/CacheWolf/InfoBox.java	2007-02-25 13:13:58 UTC (rev 629)
@@ -100,7 +100,10 @@
 		msgArea.setText(info);
 		this.repaintNow();
 	}
-
+	
+	public void setInfoHeight(int heighti) {
+		msgArea.setPreferredSize(getPreferredSize(null).width, heighti);
+	}
 	public String getInfo(){
 		return msgArea.getText();
 	}

Modified: trunk/src/CacheWolf/Map.java
===================================================================
--- trunk/src/CacheWolf/Map.java	2007-02-25 09:22:37 UTC (rev 628)
+++ trunk/src/CacheWolf/Map.java	2007-02-25 13:13:58 UTC (rev 629)
@@ -7,6 +7,7 @@
 import ewe.ui.*;
 import ewe.graphics.*;
 import ewe.fx.*;
+
 import com.stevesoft.ewe_pat.*;
 
 /**
@@ -197,7 +198,10 @@
 		if(tmp != FileChooser.IDYES) return Form.IDCANCEL;
 		File inDir = fc.getChosenFile();
 		File mapFile;
-		InfoBox inf = new InfoBox("Info", MyLocale.getMsg(4109,"Loading maps...            \n")); 
+		InfoBox inf = new InfoBox("Info", MyLocale.getMsg(4109,"Loading maps...            \n"), InfoBox.PROGRESS_WITH_WARNINGS, false); 
+		inf.setPreferredSize(220, 300);
+		inf.setInfoHeight(100);
+		inf.relayout(false);
 		Vm.showWait(this, true);
 		inf.exec();
 
@@ -209,8 +213,8 @@
 		Vector files;
 		String [] filestemp;
 		String line = new String();
-		InputStream in;
-		OutputStream out;
+		InputStream in = null;
+		OutputStream out = null;
 		FileReader inMap;
 		byte[] buf;
 		int len;
@@ -225,29 +229,50 @@
 		files.addAll(filestemp);
 
 		String currfile = null;
-		for(int i = files.size() -1 ; i >= 0;i--){
+		String curInFullPath;
+		String curOutFullPath;
+		int num = files.size();
+		for(int i =  num -1 ; i >= 0;i--){
 			currfile = (String) files.get(i);
-			inf.setInfo(MyLocale.getMsg(4110,"Loading:\n")+ " " + currfile);
+			inf.setInfo(MyLocale.getMsg(4110,"Loading: ")+ "\n" + currfile + "\n("+(num-i)+"/"+num+")");
 			//Copy the file
 			//Vm.debug("Copy: " + inDir.getFullPath() + "/" +files[i]);
 			//Vm.debug("to: " + mapsPath + files[i]);
+			curInFullPath = inDir.getFullPath() + "/" +currfile;
+			curOutFullPath = mapsPath + currfile;
+			boolean imageerror = false;
 			try {
-				in = new FileInputStream(inDir.getFullPath() + "/" +currfile);
-				out = new FileOutputStream(mapsPath + currfile);
-				buf = new byte[1024];
+				in = new FileInputStream(curInFullPath);
+				buf = new byte[1024*10];
+				boolean first = true;
+				ByteArray header = new ByteArray(buf);
 				while ((len = in.read(buf)) > 0) {
+					if (first) {
+						first = false;
+						header.copyFrom(buf, 0, len);
+						ImageInfo tmpII = Image.getImageInfo(header,null);
+						imageWidth = tmpII.width;
+						imageHeight = tmpII.height;
+						out = new FileOutputStream(curOutFullPath); // only create outfile if geImageInfo didn't throw an exception so do it only here not directly after opening input stream
+					}
 					out.write(buf, 0, len);
 				}
-				in.close();
-				out.close();
 			} catch(IOException ex){
-				inf.addText(": IO-Error while copying image \n" + ex.getMessage());
+				imageerror = true;
+				inf.addWarning("\nIO-Error while copying image from: " + curInFullPath + " to: " + curOutFullPath + " error: " + ex.getMessage());
+			} catch (IllegalArgumentException e) { // thrown from Image.getImageInfo when it could not interprete the header (e.g. bmp with 32 bits per pixel)
+				imageerror = true;
+				inf.addWarning("\nError: could not decode image: " + curInFullPath + " - image not copied");
+			} finally {
+				try {
+					if (in != null) in.close();
+					if (out  != null) out.close(); 
+				} catch (Throwable e) {}
 			}
-
 			//Check for a .map file
 			rawFileName = currfile.substring(0, currfile.lastIndexOf("."));
 			mapFile = new File(inDir.getFullPath() + "/" + rawFileName + ".map");
-			if(mapFile.exists()){
+			if(!imageerror && mapFile.exists()){
 				GCPoint gcp1 = new GCPoint();
 				GCPoint gcp2 = new GCPoint();
 				GCPoint gcp3 = new GCPoint();
@@ -351,14 +376,17 @@
 					} // while
 					if (inMap != null)	inMap.close();
 				} catch(IllegalArgumentException ex){ // is thrown from Convert.toDouble and saveWFL if affine[0-5]==0 NumberFormatException is a subclass of IllegalArgumentExepction
-					inf.addText("\nError while importing .map-file: "+ex.getMessage());
+					inf.addWarning("\nError while importing .map-file: "+ex.getMessage());
 				} catch(IOException ex){
-					inf.addText("IO-Error while reading or writing calibration file\n" + ex.getMessage());
+					inf.addWarning("\nIO-Error while reading or writing calibration file\n" + ex.getMessage());
 				} 
-			} // if map file.exists
+			} else { // if map file.exists
+				if (!imageerror) inf.addWarning("\nNo calibration file found for: " + currfile + " - you can calibrate it manually");
+			}
 		} // for file
 		Vm.showWait(this, false);
 		inf.addText("\ndone.");
+		inf.addOkButton();
 		//inf.addOkButton(); doesn't work
 		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
 		return Form.IDOK;

Modified: trunk/src/CacheWolf/TrackOverlay.java
===================================================================
--- trunk/src/CacheWolf/TrackOverlay.java	2007-02-25 09:22:37 UTC (rev 628)
+++ trunk/src/CacheWolf/TrackOverlay.java	2007-02-25 13:13:58 UTC (rev 629)
@@ -266,6 +266,21 @@
 // imageMayChange = true; // hilft auch nicht :-(
 
 /*
+ * In der ewe-VM f?r PocketPC-ARM funktioniert die Festlegung einer 
+ * transparenten Farbe nicht (Hintergrund wird wei? statt durchsichtig)
+ * deswegen (und weil in ewe-VM effizienter) Umstellung auf Transparenzmaske
+ * statt transparenter Farbe
+ * TODO Dies ist in Java-VM allerdings extrem Speicher fressend -> evtl abfragen 
+static int fixMask(WObject image,WObject col,int isMask):
+	in Maske: 0 an durchsichtiger Stelle, sonst ff
+	in Image: ffffff an durchsichtiger Stelle
+
+	in java-VM
+	in Maske: ffffffff in image.mask, wenn nicht durchsichtig
+	          ff000000 an durchsichtiger Stelle
+	image.doCheckMask erzeugt ein Image mit 0 an den durchsichtigen Stellen, die dadurch definiert sind, dass im image 0xffffff und in (mask & 0xffffff == 0) steht.
+*/
+/*
  * this class is only needed to have a fast access to the list of pixels
  * which are added but aniimage.draw will not lead to a change on the screen
  * so that these pixels will be drawn seperately by doDraw



From pfeffer at mail.berlios.de  Sun Feb 25 17:11:34 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 25 Feb 2007 17:11:34 +0100
Subject: [Cachewolf-svn] r630 - trunk/src/CacheWolf
Message-ID: <200702251611.l1PGBYIq003372@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-25 17:11:28 +0100 (Sun, 25 Feb 2007)
New Revision: 630

Modified:
   trunk/src/CacheWolf/MapsList.java
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: Umstellung der Fehlertoleranz beim Ma?\195?\159stab der Karten von absolute 0,01 Meter pro Pixel auf 15%. D.h. Maps mit weniger als 15% Abweichung des Ma?\195?\159stabes werden so behandelt als h?\195?\164tten sie den gleichen Ma?\195?\159stab. Dies ist notwendig geworden, weil GlopusMapManager  erstaunlich gro?\195?\159e Unterschiede in den Ma?\195?\159st?\195?\164ben prduziert (1,5% Abweichung, bei NH-TOP-Trans waren es weniger als 1 Promille). Tolerant auf 15% erh?\195?\182ht, damit auch manuell kalibriete Karten, die den gleichen Ma?\195?\159stab haben wegen leichter Abweichungen bei der Kalibrierung dennoch als Karten gleichen Ma?\195?\159stabs angesehen werden

Modified: trunk/src/CacheWolf/MapsList.java
===================================================================
--- trunk/src/CacheWolf/MapsList.java	2007-02-25 13:13:58 UTC (rev 629)
+++ trunk/src/CacheWolf/MapsList.java	2007-02-25 16:11:28 UTC (rev 630)
@@ -15,7 +15,7 @@
  *
  */
 public class MapsList extends Vector {
-	public static float scaleTolerance = 0.01f; // absolute deviations from this factor are seen to have the same scale
+	public static float scaleTolerance = 1.15f; // absolute deviations from this factor are seen to have the same scale
 	public Hashtable scales2Area;
 
 	/**
@@ -94,16 +94,16 @@
 		for (int i=size()-1; i >= 0 ;i--) { 
 			better = false;
 			mi = (MapInfoObject)get(i);
-			if (screenArea == null || java.lang.Math.abs(mi.scale - lastscale) > scaleTolerance) {
+			if (screenArea == null || !scaleEquals(lastscale, mi) ) {
 				screenArea = getAreaForScreen(screen, lat, lon, mi.scale, mi);
 				lastscale = mi.scale;
 			}
 			if (screenArea.isOverlapping(mi.getArea()) ) { // is on screen
-				if (!forceScale || (forceScale && java.lang.Math.abs(mi.scale - scale) > scaleTolerance)) { // different scale?
-					if (!forceScale && (mi.inBound(lat, lon) && (bestMap == null || (java.lang.Math.abs(mi.scale-scale) + scaleTolerance < java.lang.Math.abs(bestMap.scale-scale)) || !bestMap.inBound(lat, lon)))) 
+				if (!forceScale || (forceScale && !scaleEquals(scale, mi))) { // different scale?
+					if (!forceScale && (mi.inBound(lat, lon) && (bestMap == null || scaleNearer(mi.scale, bestMap.scale, scale) || !bestMap.inBound(lat, lon)))) 
 						better = true; // inbound and resolution nearer at wanted resolution or old one is on screen but lat/long not inbound-> better
 					else {
-						if ( bestMap == null || (java.lang.Math.abs(mi.scale - scale) < java.lang.Math.abs(bestMap.scale - scale) + scaleTolerance)) {
+						if ( bestMap == null || scaleNearerOrEuqal(mi.scale, bestMap.scale, scale)) {
 							latNearer = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm < minDistLat ;
 							lonNearer = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm < minDistLon;
 							if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
@@ -153,10 +153,10 @@
 			better = false;
 			mi = (MapInfoObject)get(i);
 			if (mi.inBound(topleft) && mi.inBound(bottomright)) { // both points are inside the map
-				if (fittingmap == null || fittingmap.scale > mi.scale + scaleTolerance) {
+				if (fittingmap == null || fittingmap.scale > mi.scale * scaleTolerance) {
 					better = true; // mi map has a better (lower) scale than the last knwon good map
 				} else {
-					if (fittingmap != null && java.lang.Math.abs(mi.scale - fittingmap.scale) < scaleTolerance) { // same scale as bestmap till now -> test if its center is nearer to the gps-point = topleft
+					if (fittingmap != null && scaleEquals(mi, fittingmap)) { // same scale as bestmap till now -> test if its center is nearer to the gps-point = topleft
 						latNearer = java.lang.Math.abs(topleft.latDec- mi.center.latDec)/mi.sizeKm < minDistLat ;
 						lonNearer = java.lang.Math.abs(topleft.lonDec - mi.center.lonDec)/mi.sizeKm < minDistLon;
 						if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
@@ -203,15 +203,15 @@
 			better = false;
 			mi = (MapInfoObject)get(i);
 			if (mi.fileNameWFL == "") continue; // exclude "maps" without image // TODO make this a boolean in MapInfoObject
-			if (screenArea == null || java.lang.Math.abs(mi.scale - lastscale) > scaleTolerance) {
+			if (screenArea == null || !scaleEquals(lastscale, mi)) {
 				screenArea = getAreaForScreen(screen, lat, lon, mi.scale, mi);
 				lastscale = mi.scale;
 			}
 			if (screenArea.isOverlapping(mi.getArea())) { // is on screen
-				if (bestMap == null || java.lang.Math.abs(mi.scale - bestMap.scale) > scaleTolerance) { // different scale then known bestMap?
-					if (mi.inBound(lat, lon) && (      // more details                                 // less details than bestmap
-							(moreDetails && (curScale > mi.scale + scaleTolerance) && (bestMap == null || mi.scale-scaleTolerance > bestMap.scale) ) // higher resolution wanted and mi has higher res and a lower res than bestmap, because we dont want to overjump one resolution step
-							|| (!moreDetails && (curScale < mi.scale - scaleTolerance) && (bestMap == null || mi.scale + scaleTolerance < bestMap.scale) ) // lower resolution wanted and mi has lower res and a higher res than bestmap, because we dont want to overjump one resolution step
+				if (bestMap == null || !scaleEquals(mi, bestMap)) { // different scale than known bestMap?
+					if (mi.inBound(lat, lon) && (      // more details wanted and this map has more details?                                // less details than bestmap
+							(moreDetails && (curScale > mi.scale * scaleTolerance) && (bestMap == null || mi.scale > bestMap.scale * scaleTolerance ) ) // higher resolution wanted and mi has higher res and a lower res than bestmap, because we dont want to overjump one resolution step
+							|| (!moreDetails && (curScale *  scaleTolerance < mi.scale) && (bestMap == null || mi.scale * scaleTolerance < bestMap.scale) ) // lower resolution wanted and mi has lower res and a higher res than bestmap, because we dont want to overjump one resolution step
 					) )	better = true;	// inbound and higher resolution if higher res wanted -> better
 				} else { // same scale as bestmap -> look if naerer 
 					latNearer = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm < minDistLat ;
@@ -256,12 +256,59 @@
 		return ret; 
 	}
 	public static boolean scaleEquals(MapInfoObject a, MapInfoObject b) {
-		return java.lang.Math.abs(a.scale - b.scale) < scaleTolerance; 
+		//return java.lang.Math.abs(a.scale - b.scale) < scaleTolerance;
+		return a.scale/b.scale < scaleTolerance || b.scale/a.scale < scaleTolerance;
 	}
 	public static boolean scaleEquals(float s, MapInfoObject b) {
-		return java.lang.Math.abs(s - b.scale) < scaleTolerance; 
+		//return java.lang.Math.abs(s - b.scale) < scaleTolerance;
+		return s/b.scale < scaleTolerance || b.scale/s < scaleTolerance;
 	}
+	
+	/**
+	 * 
+	 * @param test
+	 * @param old
+	 * @param wanted
+	 * @return true if test is nearer to wanted than old, false if the change in the scale is lower than scaleTolerance
+	 */
+	public static boolean scaleNearer(float test, float old, float wanted) {
+		float testa, wanta, wantb, olda;
+		if (test > wanted) { // ensure that first term is greater than 1
+			testa = test;
+			wanta = wanted;
+		} else {
+			testa = wanted;
+			wanta = test;
+		}
+		if (old > wanted) { // ensure that second term is greater than 1 
+			olda = old;
+			wantb = wanted;
+		} else {
+			olda = wanted;
+			wantb = old;
+		}
+		return testa/wanta * scaleTolerance < olda/wantb; 
+	}
 
+	public static boolean scaleNearerOrEuqal(float test, float old, float wanted) {
+		float testa, wanta, wantb, olda;
+		if (test > wanted) { // ensure that first term is greater than 1
+			testa = test;
+			wanta = wanted;
+		} else {
+			testa = wanted;
+			wanta = test;
+		}
+		if (old > wanted) { // ensure that second term is greater than 1 
+			olda = old;
+			wantb = wanted;
+		} else {
+			olda = wanted;
+			wantb = old;
+		}
+		return testa/wanta < olda/wantb * scaleTolerance ; 
+	}
+
 	/** for determining if a new map should be downloaded
 	public boolean isInAmap(CWPoint topleft, CWPoint buttomright) {
 		if (!latRangeList.isInRange(topleft.latDec) || !latRangeList.isInRange(buttomright.latDec)) ||

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-25 13:13:58 UTC (rev 629)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-25 16:11:28 UTC (rev 630)
@@ -907,7 +907,7 @@
 		case NORMAL_KEEP_RESOLUTION: 
 			newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, scaleWanted, false);
 			if (newmap == null) newmap = currentMap;
-			if (java.lang.Math.abs(newmap.scale - scaleWanted) < maps.scaleTolerance) wantMapTest = false;
+			if (MapsList.scaleEquals(scaleWanted, newmap)) wantMapTest = false;
 			break;
 		case HIGHEST_RESOLUTION: newmap = maps.getBestMap(cll.latDec, cll.lonDec, screen, 0.000001f, false); break;
 		case HIGHEST_RESOLUTION_GPS_DEST: 



From pfeffer at mail.berlios.de  Sun Feb 25 18:05:33 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 25 Feb 2007 18:05:33 +0100
Subject: [Cachewolf-svn] r631 - trunk/src/CacheWolf
Message-ID: <200702251705.l1PH5XW6010943@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-25 18:05:31 +0100 (Sun, 25 Feb 2007)
New Revision: 631

Modified:
   trunk/src/CacheWolf/TrackOverlay.java
Log:
TrackOverlay: erkennt jetzt automatisch, ob in java-VM, dann wird eine transp?\195?\188arente Farbe benutzt, sonst eine Transparenzmaske. Das ist notwendig, weil die transparente Farbe in der ewe-VM f?\195?\188r PocketPC-ARM nicht funktioniert und eine Transparenzmaske in der java-VM extrem ineffizient ist (frisst zuviel SPeicher)

Modified: trunk/src/CacheWolf/TrackOverlay.java
===================================================================
--- trunk/src/CacheWolf/TrackOverlay.java	2007-02-25 16:11:28 UTC (rev 630)
+++ trunk/src/CacheWolf/TrackOverlay.java	2007-02-25 17:05:31 UTC (rev 631)
@@ -28,23 +28,31 @@
 	public Color trackPixelsColor[] = null;
 	public int numPixels = 0;
 	final static int maxPixelsInCache = 100;
-	final static Color transparentColorForOverlay = Color.White; // onlz for use when transparent color is used
+	final static Color transparentColorForOverlay = Color.White; // only for use when transparent color is used
+	static boolean useTransparentColor;
 	public TrackOverlay (TrackPoint topLefti, int widthi, int highti, MapInfoObject transi) {
 		super();
 		topLeft = new TrackPoint(topLefti);
 		trans = transi;
 		bottomRight = calcLatLonInImage(widthi, highti);
-		Image maski = new Image(widthi, highti);
-		drawMask = new Graphics(maski);
-		drawMask.setColor(Color.White);
-		drawMask.fillRect(0, 0, maski.getWidth(), maski.getHeight());
-		setImage(new Image(widthi, highti), maski); // java-vm: transparency with a mask is very memory consuming, but transparency with a mask is much faster in ewe-vm and doesn't consume more memory than a transparency color
-		maski.free(); //setimage produces an inverted copy of the mask
-		maski = null;
+		if (ewe.sys.Vm.getPlatform().equalsIgnoreCase("java")) {
+			useTransparentColor = true; 
+			setImage(new Image(widthi, highti), transparentColorForOverlay); // java-vm: transparency with a mask is very memory consuming, but transparency with a mask is much faster in ewe-vm and doesn't consume more memory than a transparency color (ewe 1.49)
+		} else {
+			useTransparentColor = false; // momentanously this it not used, but this is only because ewe treats areas as opaque which has a non white color in the image, so that the mask doesn't need to be changed
+			Image maski = new Image(widthi, highti);
+			drawMask = new Graphics(maski);
+			drawMask.setColor(Color.White);
+			drawMask.fillRect(0, 0, maski.getWidth(), maski.getHeight());
+			setImage(new Image(widthi, highti), maski); // java-vm: transparency with a mask is very memory consuming, but transparency with a mask is much faster in ewe-vm and doesn't consume more memory than a transparency color (ewe 1.49)
+			maski.free(); //setimage produces an inverted copy of the mask
+			maski = null;
+		}
 		//properties = AlwaysOnTop; // arrows are above, so dont set it.
 		draw = new Graphics(image);
 		draw.setDrawOp(Graphics.DRAW_OVER);
-		draw.setColor(Color.White);
+		if (useTransparentColor) draw.setColor(transparentColorForOverlay);
+		else draw.setColor(Color.White);
 		draw.fillRect(0, 0, widthi, highti);
 		//int[] markImage = {0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000};
 		//int[] markMaskOpaque = {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff};
@@ -66,7 +74,7 @@
 		properties &= ~HasChanged;
 	}
 
-	
+
 	public void paintTracks() {
 	// for debugging TrackOverlayPositions
 	// draw.setPen(new Pen(Color.LightBlue,Pen.SOLID,1));
@@ -80,7 +88,8 @@
 		Track tr;
 		for (tri=tracks.size()-1; tri >= 0; tri--) {
 			tr = (Track)tracks.get(tri);
-			draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
+			//draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
+			draw.setColor(tr.trackColor);
 			if (tr.num > 0) {
 				for (i=0; i < tr.num; i++) {
 					paintPoint(tr.trackColor, tr.TrackPoints[i].latDec, tr.TrackPoints[i].lonDec);
@@ -89,13 +98,13 @@
 		}
 	}
 
-		/**
-		 * 
-		 * @param f
-		 * @param lat
-		 * @param lon
-		 * @return true if point was on this overlay
-		 */
+	/**
+	 * 
+	 * @param f
+	 * @param lat
+	 * @param lon
+	 * @return true if point was on this overlay
+	 */
 	public boolean paintPoint(Color f, double lat, double lon){
 		if (lat<bottomRight.latDec || lat > topLeft.latDec || lon<topLeft.lonDec || lon>bottomRight.lonDec) return false;
 		//ewe.sys.Vm.debug("showlastaddedpoint, lat: "+lat+"   lon: "+lon);
@@ -123,7 +132,7 @@
 		}
 		return true;
 	}
-	
+
 	/**
 	 * this method forces ewe to transfer the drawn points
 	 * from _awtImage to bufferedImage, which is drawn to the screen
@@ -136,7 +145,7 @@
 		imageChangesDontShow = false;
 		removeAllPixels();
 	}
-	
+
 	private void removeAllPixels() {
 		numPixels = 0;
 		trackPixels = null;
@@ -173,17 +182,18 @@
 			int ll =(numPixels<30 ? 0 : numPixels-30); // look in the last 50 added Pixels if the same Pixel is already in the list (for performance reasons dont look in the whole list)
 			for (int i=numPixels-1; i>=ll; i--) {
 				if (trackPixels[i].x == x && trackPixels[i].y == y && f.equals(trackPixelsColor[i])) 
-					{ return; } 
+				{ return; } 
 			}
 		}
 		addPixel(x, y, f);
 	}
-	
+
 	public static final int FIXATE_IF_NO_PIXELS_NUM = 60;
 	private int notOnThisOverlaySince = 0;
-	
+
 	public void paintLastAddedPoint(Track tr) { 
-		draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
+		//draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
+		draw.setColor(tr.trackColor);
 		if (paintPoint(tr.trackColor, tr.TrackPoints[tr.num-1].latDec, tr.TrackPoints[tr.num-1].lonDec)) notOnThisOverlaySince = 0;
 		else notOnThisOverlaySince++;
 		if (notOnThisOverlaySince > FIXATE_IF_NO_PIXELS_NUM) { // zur Performanceverbesserung: wenn in den letzten 60 Updates keines mehr f?r dieses Overlay dabei war, Overlay Pixels fest schreiben, damit doDraw entlastet wird.
@@ -192,7 +202,7 @@
 		}
 
 	}
-	
+
 	public void doDraw(Graphics g,int options) { // this is automatically called when the image need to be (re-)drawn on the screen
 		super.doDraw(g, options);
 		imageChangesDontShow = true; // g.drawImage (in super) copies _awtImage into bufferedImage, any later changes to _awtImage dont show up until the mask or the image has changed - unfortunately bufferedImage is not accessable from outside
@@ -231,19 +241,19 @@
  *  und beim Aufruf von doDraw wird wieder die urspr?ngliche transparentColor verwendet
  *  
  */
-// was alles nicht funktioniert:
+//was alles nicht funktioniert:
 //drawmask.setDrawOp(Graphics.DRAW_OVER);
-//	drawmask.drawRect(x-1, y-1, 2, 2, 1);
+//drawmask.drawRect(x-1, y-1, 2, 2, 1);
 //this.setImage(image, mask);
-// n?chster Versuch: image.bufferedImage in ewe.fx.Image public definieren !!!
+//n?chster Versuch: image.bufferedImage in ewe.fx.Image public definieren !!!
 //image.rgb
-//	draw._g.surfaceData.bufImg.raster.data[y*this.location.width + x] = -65536; := image._awtImage
-//	((Image)image).eImage(colorOrMask)._awtImage.raster.data[0]=0;
-//	image
-//	((BufferedImage)(image).se.^.bufferedImage.raster.data[y*this.location.width + x]=-65536; //was dort steht wird tats?chlich angezeigt, allerdings kann ich es nicht direkt setzen :-(
+//draw._g.surfaceData.bufImg.raster.data[y*this.location.width + x] = -65536; := image._awtImage
+//((Image)image).eImage(colorOrMask)._awtImage.raster.data[0]=0;
+//image
+//((BufferedImage)(image).se.^.bufferedImage.raster.data[y*this.location.width + x]=-65536; //was dort steht wird tats?chlich angezeigt, allerdings kann ich es nicht direkt setzen :-(
 //int[] markPixels = new int[4];
 //for (int i = 0; i<markPixels.length; i++) { markPixels[i] = -65536; }
-// image.transparent = null; hilft auhc nicht
+//image.transparent = null; hilft auhc nicht
 //image.mask = null;
 //image.bufferedImage = null;
 //image.setPixels(markPixels, 0 , x-20, y, 2, 2, 0); // dadrin sollte bufferedImage = null gesetzt werden, wird es aber nicht :-(
@@ -251,7 +261,7 @@
 //Image mark = new Image(2,2);
 //new Graphics(mark).drawImage(image, null, transparentColor, x-40, y, 2, 2);
 //mark.draw(draw, x-50, y, Graphics.DRAW_OVER); // options (Graphics.DRAW_OVER) are ignored anyway
-// image.bufferedImage = null; // this solves the problem
+//image.bufferedImage = null; // this solves the problem
 //toCursor(null);
 //this.draw(draw);
 //image=(BufferedImage)this.toNativeImage(transparentColor);
@@ -261,9 +271,9 @@
 //ewe.ui.PenEvent.refreshTip(draw.surface);
 //draw.setPixelRGB(x, y, -65536);
 //this.changed(); hilft auch nicht
-// this.refresh(); // hilft nicht :-(
-//	lastDrawn.x = lastDrawn.x -10; hilft auch nicht
-// imageMayChange = true; // hilft auch nicht :-(
+//this.refresh(); // hilft nicht :-(
+//lastDrawn.x = lastDrawn.x -10; hilft auch nicht
+//imageMayChange = true; // hilft auch nicht :-(
 
 /*
  * In der ewe-VM f?r PocketPC-ARM funktioniert die Festlegung einer 
@@ -279,7 +289,7 @@
 	in Maske: ffffffff in image.mask, wenn nicht durchsichtig
 	          ff000000 an durchsichtiger Stelle
 	image.doCheckMask erzeugt ein Image mit 0 an den durchsichtigen Stellen, die dadurch definiert sind, dass im image 0xffffff und in (mask & 0xffffff == 0) steht.
-*/
+ */
 /*
  * this class is only needed to have a fast access to the list of pixels
  * which are added but aniimage.draw will not lead to a change on the screen



From pfeffer at mail.berlios.de  Mon Feb 26 01:35:07 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Mon, 26 Feb 2007 01:35:07 +0100
Subject: [Cachewolf-svn] r632 - in trunk: resources src/CacheWolf
Message-ID: <200702260035.l1Q0Z77J006466@sheep.berlios.de>

Author: pfeffer
Date: 2007-02-26 01:35:03 +0100 (Mon, 26 Feb 2007)
New Revision: 632

Modified:
   trunk/resources/goto_map.png
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MapsList.java
   trunk/src/CacheWolf/MovingMap.java
   trunk/src/CacheWolf/TrackOverlay.java
Log:
GotoPanel und MovingMap: Farben geaendert wie abgesprochen
MovingMap: Bug fixed, der durch Umstellung auf prozentuale Toleranz des Massstabes entstanden war

Modified: trunk/resources/goto_map.png
===================================================================
(Binary files differ)

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-02-25 17:05:31 UTC (rev 631)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-02-26 00:35:03 UTC (rev 632)
@@ -60,7 +60,7 @@
 	final static Color RED = new Color(255,0,0);
 	final static Color YELLOW = new Color(255,255,0);
 	final static Color GREEN = new Color(0,255,0);
-	final static Color BLUE = new Color(0,255,255);
+	final static Color BLUE = new Color(0,0,255);
 
 	final static Font BOLD = new Font("Arial", Font.BOLD, 14);
 
@@ -106,7 +106,7 @@
 		lblGPS.backGround = RED;
 		CoordsP.addLast(lblPosition = new mLabel(myNavigation.gpsPos.toString(currFormat)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		CoordsP.addNext(lblDST = new mLabel(MyLocale.getMsg(1500,"DST:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		lblDST.backGround = BLUE;
+		lblDST.backGround = new Color(0,0,255);
 		CoordsP.addLast(btnGoto = new mButton(getGotoBtnText()),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 
 		//Rose for bearing
@@ -122,9 +122,9 @@
 
 		//GotoP.addNext(lblSatsText = new mLabel("Sats: "),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		//lblSatsText.font = BOLD;
-		GotoP.addLast(lblSats = new mLabel("Sats: " + Convert.toString(myNavigation.gpsPos.getSats())),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		GotoP.addLast(lblSats = new mLabel("Sats:    " + Convert.toString(myNavigation.gpsPos.getSats())),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		lblSats.font = BOLD;
-		GotoP.addLast(lblHDOP = new mLabel("HDOP: " + Convert.toString(myNavigation.gpsPos.getHDOP())),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		GotoP.addLast(lblHDOP = new mLabel("HDOP:    " + Convert.toString(myNavigation.gpsPos.getHDOP())),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		lblHDOP.font = BOLD;
 
 
@@ -136,7 +136,7 @@
 
 		//things about destination
 		GotoP.addLast(lblWayP = new mLabel("WayPoint"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		lblWayP.backGround = BLUE;
+		lblWayP.backGround = Color.DarkBlue;
 		lblWayP.font = BOLD;
 		GotoP.addLast(lblBearWayP = new mLabel("0"),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		lblBearWayP.font = BOLD;
@@ -270,7 +270,8 @@
 			speed.set(myNavigation.gpsPos.getSpeed());
 			lblSpeed.setText(MyLocale.formatDouble(speed,"0.0") + " km/h");
 			sunAzimut.set((double)myNavigation.sunAzimut);
-			lblSunAzimut.setText(MyLocale.formatDouble(sunAzimut,"0.0") + " Grad");
+			if (sunAzimut.value >= -360) lblSunAzimut.setText(MyLocale.formatDouble(sunAzimut,"0.0") + " Grad");
+			else lblSunAzimut.setText("--- Grad");
 			bearMov.set(myNavigation.gpsPos.getBear());
 			lblBearMov.setText(bearMov.toString(0,0,0) + " Grad");
 			compassRose.setSunMoveDirections((float)sunAzimut.value, (float)bearMov.value);
@@ -430,7 +431,7 @@
 		if (g != null) {
 			// draw only valid arrows
 			if (moveDir < 360 && moveDir > -360) drawArrow(g, moveDir, RED);
-			if (gotoDir < 360 && gotoDir > -360) drawArrow(g, gotoDir, BLUE);
+			if (gotoDir < 360 && gotoDir > -360) drawArrow(g, gotoDir, Color.DarkBlue);
 			if (sunDir < 360 && sunDir> -360) drawArrow(g, sunDir, YELLOW);
 		}
 	}

Modified: trunk/src/CacheWolf/MapsList.java
===================================================================
--- trunk/src/CacheWolf/MapsList.java	2007-02-25 17:05:31 UTC (rev 631)
+++ trunk/src/CacheWolf/MapsList.java	2007-02-26 00:35:03 UTC (rev 632)
@@ -257,11 +257,13 @@
 	}
 	public static boolean scaleEquals(MapInfoObject a, MapInfoObject b) {
 		//return java.lang.Math.abs(a.scale - b.scale) < scaleTolerance;
-		return a.scale/b.scale < scaleTolerance || b.scale/a.scale < scaleTolerance;
+		if (a.scale > b.scale) return a.scale / b.scale < scaleTolerance; 
+		else return b.scale / a.scale < scaleTolerance;
 	}
 	public static boolean scaleEquals(float s, MapInfoObject b) {
 		//return java.lang.Math.abs(s - b.scale) < scaleTolerance;
-		return s/b.scale < scaleTolerance || b.scale/s < scaleTolerance;
+		if (s > b.scale) return s / b.scale < scaleTolerance;
+		else return b.scale / s < scaleTolerance;
 	}
 	
 	/**

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-02-25 17:05:31 UTC (rev 631)
+++ trunk/src/CacheWolf/MovingMap.java	2007-02-26 00:35:03 UTC (rev 632)
@@ -282,7 +282,7 @@
 			CacheHolder ch;
 			for (int i=cacheDB.size()-1; i>=0; i--) {
 				ch = (CacheHolder) cacheDB.get(i);
-				if (ch.is_Checked && ch != mainT.ch) { // ch == Global.mainTab.ch: always show the gray marked cache
+				if (ch.is_Checked && ch != mainT.ch) {
 					int ct = Convert.parseInt(ch.type);
 					addSymbol(ch.CacheName, ch, myTableModel.cacheImages[ct], ch.pos.latDec, ch.pos.lonDec);
 				}
@@ -292,7 +292,7 @@
 		destChanged(myNavigation.destination);
 		addTrack(myNavigation.curTrack);
 		if (tracks != null && tracks.size() > 0 && ((Track)tracks.get(0)).num > 0) 
-			addOverlaySet(); // show points wich where added when MavingMap was not running
+			addOverlaySet(); // show points which where added when MavingMap was not running
 		FormFrame ret = exec();
 		return ret;
 	}
@@ -854,8 +854,8 @@
 		if (!running || ignoreGps) return;
 		// runMovingMap neccessary in case of multi-threaded Java-VM: ticked could be called during load of mmp 
 		if ((fix > 0) && (myNavigation.gpsPos.getSats()>= 0)) { // TODO is getSats really necessary?
-			directionArrows.setDirections(-361/*(float)myNavigation.gpsPos.getBearing(myNavigation.destination)*/,
-					myNavigation.sunAzimut, -361/*(float)myNavigation.gpsPos.getBear()*/);
+			directionArrows.setDirections((float)myNavigation.gpsPos.getBearing(myNavigation.destination),
+					myNavigation.sunAzimut, (float)myNavigation.gpsPos.getBear());
 			setGpsStatus(MovingMap.gotFix);
 			updatePosition(myNavigation.gpsPos.latDec, myNavigation.gpsPos.lonDec);
 			ShowLastAddedPoint(myNavigation.curTrack);
@@ -1854,12 +1854,17 @@
 	int minY;
 	Graphics draw;
 	private MapInfoObject map=null;
-	public boolean dirsChanged = true;
 
-	final static Color RED = new Color(255,0,0);
-	final static Color YELLOW = new Color(255,255,0);
-	final static Color GREEN = new Color(0,255,0);
-	final static Color BLUE = new Color(0,255,255);
+	final static Color moveDirColor = new Color(255,0,0); // RED 
+	final static Color sunDirColor = new Color(255,255,0); // Yellow
+	//final static Color GREEN = new Color(0,255,0);
+	final static Color gotoDirColor = new Color(0,0,128); // dark blue
+	final static Color northDirColor = new Color(0,0,255); // Blue
+	Point[] sunDirArrow = null;
+	Point[] gotoDirArrow = null;
+	Point[] moveDirArrow = null;
+	Point[] northDirArrow = null;
+	
 	/**
 	 * @param gd goto direction
 	 * @param sd sun direction
@@ -1877,6 +1882,7 @@
 	}
 	public void setMap(MapInfoObject m) {
 		map = m;
+		makeArrows();
 	}
 
 	public void setDirections(float gd, float sd, float md ) {
@@ -1884,11 +1890,11 @@
 				|| java.lang.Math.abs(sunDir - sd) > 1
 				|| java.lang.Math.abs(moveDir - md) > 1)
 		{
-			dirsChanged = true;
+			//dirsChanged = false;
 			gotoDir = gd;
 			sunDir = sd;
 			moveDir = md;
-			refresh();
+			makeArrows();
 		}
 	}
 
@@ -1900,7 +1906,7 @@
 	 */
 
 	public void doDraw(Graphics g,int options) {
-		if (map == null) return;
+		if (map == null || g == null) return;
 		drawArrows(g);
 		return;
 /*		if (!dirsChanged) {
@@ -1917,39 +1923,60 @@
 		g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
 */	}
 
-	private void drawArrows(Graphics g){
-
-		if (g != null) {
+	private void makeArrows(){
 			// draw only valid arrows
-			if (moveDir < 360 && moveDir > -360) drawArrow(g, moveDir, RED);
-			if (gotoDir < 360 && gotoDir > -360) drawArrow(g, gotoDir, BLUE);
-			if (sunDir < 360 && sunDir> -360) drawArrow(g, sunDir, YELLOW);
-			drawArrow(g, 0, Color.DarkBlue); // north direction
+			if (moveDir < 360 && moveDir > -360) {
+				if (moveDirArrow == null) moveDirArrow = new Point[2];
+				makeArrow(moveDirArrow, moveDir);
+			} else moveDirArrow = null;
+			if (gotoDir < 360 && gotoDir > -360) {
+				if (gotoDirArrow == null) gotoDirArrow = new Point[2];
+				makeArrow(gotoDirArrow, gotoDir);
+			} else gotoDirArrow = null;
+			if (sunDir < 360 && sunDir> -360) {
+				if (sunDirArrow == null ) sunDirArrow = new Point[2];
+				makeArrow(sunDirArrow, sunDir);
+			} else sunDirArrow = null;
+			if (java.lang.Math.abs(map.rotationRad) > 1.5 / 180 * java.lang.Math.PI)	{ // show northth arrow only if it has more than 1.5 degree deviation from vertical direction
+				if (northDirArrow == null) northDirArrow = new Point[2];
+				makeArrow(northDirArrow, 0); // north direction
+			} else northDirArrow = null;
 		}
-	}
 
 	/**
-	 * draw single arrow 
+	 * make (calculate) Pixel array for a single arrow 
 	 * @param g handle for drawing
 	 * @param angle angle of arrow
 	 * @param col color of arrow
 	 */
-	private void drawArrow(Graphics g, float angle, Color col) {
+	private void makeArrow(Point[] arrow, float angle) {
+		if (map == null) return;
 		float angleRad;
-		int x, y, centerX = location.width/2, centerY = location.height/2;
-
+		int centerX = location.width/2, centerY = location.height/2;
+		if (arrow[0] == null) arrow[0] = new Point();
+		if (arrow[1] == null) arrow[1] = new Point();
+		arrow[0].x = centerX;
+		arrow[0].y = centerY;
 		angleRad = angle * (float)java.lang.Math.PI / 180 + map.rotationRad;
-		x = centerX + new Float(centerX * java.lang.Math.sin(angleRad)).intValue();
-		y = centerY - new Float(centerY * java.lang.Math.cos(angleRad)).intValue();
+		arrow[1].x = centerX + new Float(centerX * java.lang.Math.sin(angleRad)).intValue();
+		arrow[1].y = centerY - new Float(centerY * java.lang.Math.cos(angleRad)).intValue();
 		//	g.setPen(new Pen(Color.Black,Pen.SOLID,7));
 		//	g.drawLine(centerX,centerY,x,y);
+	}
+
+	public void drawArrows(Graphics g) {
+		drawArrow(g, sunDirArrow, sunDirColor);
+		drawArrow(g, moveDirArrow, moveDirColor);
+		drawArrow(g, gotoDirArrow, gotoDirColor);
+		drawArrow(g, northDirArrow, northDirColor);
+	}
+	
+	public void drawArrow(Graphics g, Point[] arrow, Color col) {
+		if (arrow == null) return;
 		g.setPen(new Pen(col,Pen.SOLID,3));
-		g.drawLine(centerX,centerY,x,y);
-		if (y < minY) minY = y;
-		if (centerY < minY) minY = centerY;
+		g.drawLine(arrow[0].x, arrow[0].y, arrow[1].x,arrow[1].y);
 	}
 }
-
 /** 
  * class that can be used with any x and any y
  * it will save taht location and make itself automatically

Modified: trunk/src/CacheWolf/TrackOverlay.java
===================================================================
--- trunk/src/CacheWolf/TrackOverlay.java	2007-02-25 17:05:31 UTC (rev 631)
+++ trunk/src/CacheWolf/TrackOverlay.java	2007-02-26 00:35:03 UTC (rev 632)
@@ -39,7 +39,7 @@
 			useTransparentColor = true; 
 			setImage(new Image(widthi, highti), transparentColorForOverlay); // java-vm: transparency with a mask is very memory consuming, but transparency with a mask is much faster in ewe-vm and doesn't consume more memory than a transparency color (ewe 1.49)
 		} else {
-			useTransparentColor = false; // momentanously this it not used, but this is only because ewe treats areas as opaque which has a non white color in the image, so that the mask doesn't need to be changed
+			useTransparentColor = false; // // momentanously this it not used, but this is only because ewe treats areas as opaque which has a non white color in the image, so that the mask doesn't need to be changed
 			Image maski = new Image(widthi, highti);
 			drawMask = new Graphics(maski);
 			drawMask.setColor(Color.White);
@@ -97,6 +97,7 @@
 			}
 		}
 	}
+	
 
 	/**
 	 * 



