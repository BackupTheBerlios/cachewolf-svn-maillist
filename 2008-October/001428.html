<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r1534 - trunk/src/CacheWolf/navi
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1534%20-%20trunk/src/CacheWolf/navi&In-Reply-To=%3C200810070935.m979Zr3F004471%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="001429.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r1534 - trunk/src/CacheWolf/navi</H1>
    <B>pfeffer at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1534%20-%20trunk/src/CacheWolf/navi&In-Reply-To=%3C200810070935.m979Zr3F004471%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r1534 - trunk/src/CacheWolf/navi">pfeffer at mail.berlios.de
       </A><BR>
    <I>Tue Oct  7 11:35:53 CEST 2008</I>
    <P><UL>
        
        <LI>Next message: <A HREF="001429.html">[Cachewolf-svn] r1535 - trunk/src/CacheWolf/navi
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1428">[ date ]</a>
              <a href="thread.html#1428">[ thread ]</a>
              <a href="subject.html#1428">[ subject ]</a>
              <a href="author.html#1428">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: pfeffer
Date: 2008-10-07 11:35:40 +0200 (Tue, 07 Oct 2008)
New Revision: 1534

Modified:
   trunk/src/CacheWolf/navi/MapsList.java
Log:
Maps: temporarly added debug messages into log file to find the cause of the problem described in <A HREF="http://www.geoclub.de/viewtopic.php?f=40&amp;t=27219&amp;start=10">http://www.geoclub.de/viewtopic.php?f=40&amp;t=27219&amp;start=10</A> : the &lt;map-type&gt;-dir must be selected, otherwise the maps are not found by cachewolf on PDA

Modified: trunk/src/CacheWolf/navi/MapsList.java
===================================================================
--- trunk/src/CacheWolf/navi/MapsList.java	2008-07-25 20:53:17 UTC (rev 1533)
+++ trunk/src/CacheWolf/navi/MapsList.java	2008-10-07 09:35:40 UTC (rev 1534)
@@ -25,14 +25,15 @@
 	public static float scaleTolerance = 1.15f; // absolute deviations from this factor are seen to have the same scale
 
 	/**
-	 * loads alle the maps in mapsPath in all subDirs but not recursive, only one level 
+	 * loads alle the maps in mapsPath in all subDirs but not recursive, only one level
 	 * @param mapsPath
 	 */
 	public MapsList(String mapsPath) {
 		super(); // forget already loaded maps
-		//if (mmp.mapImage != null) 
+		//if (mmp.mapImage != null)
 		String dateien[];
 		FileBugfix files = new FileBugfix(mapsPath);
+		Global.getPref().log(&quot;0: &quot; + mapsPath + &quot; : &quot; + files.toString());
 		String rawFileName = new String();
 		String[] dirstmp = files.list(null, FileBase.LIST_DIRECTORIES_ONLY);
 		Vector dirs;
@@ -40,14 +41,14 @@
 		else dirs = new Vector();
 		dirs.add(&quot;.&quot;); // include the mapsPath itself
 		MapListEntry tempMIO;
-		MessageBox f = null; 
+		MessageBox f = null;
 		// sort(new StandardComparer(), false);
 
-		
+
 		for (int j = 0; j &lt; dirs.size(); j++) {
-			files = new FileBugfix(mapsPath+&quot;/&quot;+dirs.get(j));
+			files = new FileBugfix(new String(mapsPath+&quot;/&quot;+dirs.get(j)).replace('\\', '/')); // on some PDAs
 			//ewe.sys.Vm.debug(&quot;mapd-Dirs:&quot;+files);
-			
+			Global.getPref().log(&quot;1: &quot; + files.toString());
 			//add subdirectories
 			if (!dirs.get(j).equals(&quot;.&quot;)) {
 				dirstmp = files.list(null, FileBase.LIST_DIRECTORIES_ONLY);
@@ -67,11 +68,12 @@
 					if (dirs.get(j).equals(&quot;.&quot;)) // the notation dir/./filename doesn't work on all platforms anyhow
 						tempMIO = new MapListEntry(mapsPath+&quot;/&quot;, rawFileName);
 					else tempMIO = new MapListEntry(mapsPath+&quot;/&quot;+dirs.get(j)+&quot;/&quot;, rawFileName);
+					Global.getPref().log(&quot;2: &quot; + tempMIO.path + &quot; : &quot; + tempMIO.filename);
 					if (tempMIO.sortEntryBBox != null) add(tempMIO);
 					//ewe.sys.Vm.debug(tempMIO.getEasyFindString() + tempMIO.mapName);
-				}catch(Exception ex){ // TODO exception ist, glaub ich evtl &#252;berfl&#252;ssig 
+				}catch(Exception ex){ // TODO exception ist, glaub ich evtl &#252;berfl&#252;ssig
 					if (f == null) (f=new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(4700, &quot;Ignoring error while \n reading calibration file \n&quot;)+ex.toString(), FormBase.OKB)).exec();
-				} /* catch(ArithmeticException ex){ // affine contain not allowed values 
+				} /* catch(ArithmeticException ex){ // affine contain not allowed values
 					if (f == null) (f=new MessageBox(&quot;Warning&quot;, &quot;Ignoring error while \n reading calibration file \n&quot;+ex.toString(), MessageBox.OKB)).exec();
 				} */
 			}
@@ -80,10 +82,10 @@
 	}
 
 	public void addEmptyMaps(double lat) {
-		MapListEntry tempMIO; 
+		MapListEntry tempMIO;
 		tempMIO = new MapListEntry(1.0, lat);
 		add(tempMIO);
-		tempMIO = new MapListEntry(5.0, lat); // this one ( the 4th last) is automatically used when no real map is available, see MovingMap.setBestMap 
+		tempMIO = new MapListEntry(5.0, lat); // this one ( the 4th last) is automatically used when no real map is available, see MovingMap.setBestMap
 		add(tempMIO);
 		tempMIO = new MapListEntry(50.0, lat);
 		add(tempMIO);
@@ -92,7 +94,7 @@
 		tempMIO = new MapListEntry(1000.0, lat);
 		add(tempMIO);
 	}
-     
+
 	/* diese Routine wird gegenw&#228;rtig f&#252;r 3 ZWecke verwendet:
 	 * a) normal - keep given resolution --&gt; L&#246;sung: &#252;bergebene scale nutzen f&#252;r screen
 	 * b) highest res: Ziel: Karte mit h&#246;chster Aufl&#246;sung, die im screen ist und m&#246;glichst nah an lat/lon -&gt; ich muss aufl&#246;sung noch in Dateinamen schreiben
@@ -127,9 +129,9 @@
 		int testkw = 0;
 		for (int i=size()-1; i &gt;= 0 ;i--) {
 			if (!showprogress &amp;&amp; ((i &amp; 31) == 0) &amp;&amp; (new Time().getTime()-start  &gt; 100) ) { // reason for (i &amp; 7 == 0): test time only after i is incremented 15 times
-				showprogress = true;      
+				showprogress = true;
 				progressBox = new InfoBox(MyLocale.getMsg(327,&quot;Info&quot;), MyLocale.getMsg(4701,&quot;Searching for best map&quot;));
-				progressBox.exec(); 
+				progressBox.exec();
 				progressBox.waitUntilPainted(100);
 				ewe.sys.Vm.showWait(true);
 			}
@@ -146,7 +148,7 @@
 			}
 			if (screenArea.isOverlapping(mi) ) { // is on screen
 				if (!forceScale || (forceScale &amp;&amp; !scaleEquals(scale, mi))) { // different scale?
-					if (!forceScale &amp;&amp; (mi.isInBound(ll) &amp;&amp; (bestMap == null || scaleNearer(mi.scale, bestMap.scale, scale) || !bestMap.isInBound(ll)))) 
+					if (!forceScale &amp;&amp; (mi.isInBound(ll) &amp;&amp; (bestMap == null || scaleNearer(mi.scale, bestMap.scale, scale) || !bestMap.isInBound(ll))))
 						better = true; // inbound and resolution nearer at wanted resolution or old one is on screen but lat/long not inbound-&gt; better
 					else {
 						if ( bestMap == null || scaleNearerOrEuqal(mi.scale, bestMap.scale, scale)) {
@@ -154,7 +156,7 @@
 							lonNearer = java.lang.Math.abs(ll.lonDec - mi.center.lonDec)/mi.sizeKm &lt; minDistLon;
 							if ( latNearer &amp;&amp; lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
 							else {
-								if ( (latNearer || lonNearer )) { 
+								if ( (latNearer || lonNearer )) {
 									if (bestMap == null || mi.center.getDistanceRad(ll) &lt; bestMap.center.getDistanceRad(ll) ) better = true;
 								}
 							}
@@ -174,7 +176,7 @@
 			ewe.sys.Vm.showWait(false);
 		}
 		if (bestMap == null) return null;
-		return new MapInfoObject(bestMap); // return a copy of the MapInfoObject so that zooming won't change the MapInfoObject in the list 
+		return new MapInfoObject(bestMap); // return a copy of the MapInfoObject so that zooming won't change the MapInfoObject in the list
 	}
 	/*
 	public MapInfoObject getBestMapNotStrictSciale(double lat, double lon, Area screen, float scale) {
@@ -182,14 +184,14 @@
 		if (ret == null) ret = getBestMap(lat, lon, screen, scale, false);
 		return ret;
 	}
-	 */ 
+	 */
 	/**
-	 * @return a map which includs topleft and bottomright, 
+	 * @return a map which includs topleft and bottomright,
 	 * if no map includes both it returns null
 	 * @param if more than one map includes topleft and bottomright than the one will
 	 * be returned which has its center nearest to topleft. If you have gps-pos and goto-pos
 	 * as topleft and buttomright use gps as topleft.
-	 * if topleft is really topleft or if it is buttomright is not relevant.  
+	 * if topleft is really topleft or if it is buttomright is not relevant.
 	 */
 
 	public MapInfoObject getMapForArea(CWPoint topleft, CWPoint bottomright){
@@ -206,9 +208,9 @@
 		double minDistLon = 10000000000000000000000.0;
 		for (int i=size() -1; i&gt;=0 ;i--) {
 			if (!showprogress &amp;&amp; ((i &amp; 31) == 0) &amp;&amp; (new Time().getTime()-start  &gt; 100) ) { // reason for (i &amp; 7 == 0): test time only after i is incremented 15 times
-				showprogress = true;      
+				showprogress = true;
 				progressBox = new InfoBox(MyLocale.getMsg(327,&quot;Info&quot;), MyLocale.getMsg(4701,&quot;Searching for best map&quot;));
-				progressBox.exec(); 
+				progressBox.exec();
 				progressBox.waitUntilPainted(100);
 				ewe.sys.Vm.showWait(true);
 			}
@@ -227,7 +229,7 @@
 						lonNearer = java.lang.Math.abs(topleft.lonDec - mi.center.lonDec)/mi.sizeKm &lt; minDistLon;
 						if ( latNearer &amp;&amp; lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
 						else {
-							if ( (latNearer || lonNearer )) { 
+							if ( (latNearer || lonNearer )) {
 								if (mi.center.getDistanceRad(topleft) &lt; fittingmap.center.getDistanceRad(topleft) ) better = true;
 							}
 						}
@@ -250,7 +252,7 @@
 	}
 
 	/**
-	 * 
+	 *
 	 * @param lat a point to be inside the map
 	 * @param lon
 	 * @param screen: width, height of the screen. The map must overlap the screen. xy: where is lat/lon on screen
@@ -273,11 +275,11 @@
 		Area screenArea = null; // getAreaForScreen(screen, lat, lon, bestMap.scale, bestMap);
 		float lastscale = -1;
 		String cmp = &quot;FF1&quot;+Area.getEasyFindString(ll, 30);
-		for (int i=size()-1; i &gt;= 0 ;i--) { 
+		for (int i=size()-1; i &gt;= 0 ;i--) {
 			if (!showprogress &amp;&amp; ((i &amp; 31) == 0) &amp;&amp; (new Time().getTime()-start  &gt; 100) ) { // reason for (i &amp; 7 == 0): test time only after i is incremented 15 times
-				showprogress = true;      
+				showprogress = true;
 				progressBox = new InfoBox(MyLocale.getMsg(327,&quot;Info&quot;), MyLocale.getMsg(4701,&quot;Searching for best map&quot;));
-				progressBox.exec(); 
+				progressBox.exec();
 				progressBox.waitUntilPainted(100);
 				ewe.sys.Vm.showWait(true);
 			}
@@ -298,12 +300,12 @@
 							(moreDetails &amp;&amp; (curScale &gt; mi.scale * scaleTolerance) &amp;&amp; (bestMap == null || mi.scale &gt; bestMap.scale * scaleTolerance ) ) // higher resolution wanted and mi has higher res and a lower res than bestmap, because we dont want to overjump one resolution step
 							|| (!moreDetails &amp;&amp; (curScale *  scaleTolerance &lt; mi.scale) &amp;&amp; (bestMap == null || mi.scale * scaleTolerance &lt; bestMap.scale) ) // lower resolution wanted and mi has lower res and a higher res than bestmap, because we dont want to overjump one resolution step
 					) )	better = true;	// inbound and higher resolution if higher res wanted -&gt; better
-				} else { // same scale as bestmap -&gt; look if naerer 
+				} else { // same scale as bestmap -&gt; look if naerer
 					latNearer = java.lang.Math.abs(ll.latDec - mi.center.latDec)/mi.sizeKm &lt; minDistLat ;
 					lonNearer = java.lang.Math.abs(ll.lonDec - mi.center.lonDec)/mi.sizeKm &lt; minDistLon;
 					if ( latNearer &amp;&amp; lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
 					else {
-						if ( (latNearer || lonNearer )) { 
+						if ( (latNearer || lonNearer )) {
 							if (bestMap == null || mi.center.getDistanceRad(ll) &lt; bestMap.center.getDistanceRad(ll) ) better = true;
 						}
 					}
@@ -337,11 +339,11 @@
 		Point xy = map.calcMapXY(ll);
 		Point topleft = new Point(xy.x - a.x, xy.y - a.y);
 		ret = new Area(map.calcLatLon(topleft), map.calcLatLon(topleft.x+a.width, topleft.y+a.height));
-		return ret; 
+		return ret;
 	}
 	public static boolean scaleEquals(MapInfoObject a, MapInfoObject b) {
 		//return java.lang.Math.abs(a.scale - b.scale) &lt; scaleTolerance;
-		if (a.scale &gt; b.scale) return a.scale / b.scale &lt; scaleTolerance; 
+		if (a.scale &gt; b.scale) return a.scale / b.scale &lt; scaleTolerance;
 		else return b.scale / a.scale &lt; scaleTolerance;
 	}
 	public static boolean scaleEquals(float s, MapInfoObject b) {
@@ -351,7 +353,7 @@
 	}
 
 	/**
-	 * 
+	 *
 	 * @param test
 	 * @param old
 	 * @param wanted
@@ -366,14 +368,14 @@
 			testa = wanted;
 			wanta = test;
 		}
-		if (old &gt; wanted) { // ensure that second term is greater than 1 
+		if (old &gt; wanted) { // ensure that second term is greater than 1
 			olda = old;
 			wantb = wanted;
 		} else {
 			olda = wanted;
 			wantb = old;
 		}
-		return testa/wanta * scaleTolerance &lt; olda/wantb; 
+		return testa/wanta * scaleTolerance &lt; olda/wantb;
 	}
 
 	public static boolean scaleNearerOrEuqal(float test, float old, float wanted) {
@@ -385,16 +387,16 @@
 			testa = wanted;
 			wanta = test;
 		}
-		if (old &gt; wanted) { // ensure that second term is greater than 1 
+		if (old &gt; wanted) { // ensure that second term is greater than 1
 			olda = old;
 			wantb = wanted;
 		} else {
 			olda = wanted;
 			wantb = old;
 		}
-		return testa/wanta &lt; olda/wantb * scaleTolerance ; 
+		return testa/wanta &lt; olda/wantb * scaleTolerance ;
 	}
-	
+
 	/* may be the following code is used same time later to further enhance the speed of finding the best map
 	public int getQuickMap(String search){
 		boolean found = false; // TODO unfertig
@@ -436,7 +438,7 @@
 		/*
 		try {map = new MapInfoObject(path, filename); } catch (Exception e) {
 		}
-		
+
 		ewe.sys.Vm.debug(&quot;centerID: &quot;+map.getCenterID());
 		ewe.sys.Vm.debug(&quot;PxID: &quot;+map.getPxSizeID());
 		ewe.sys.Vm.debug(&quot;scaleID: &quot;+map.getScaleID()+&quot;scale: &quot;+map.scale);
@@ -450,7 +452,7 @@
 				sortEntryBBox = &quot;FF1&quot;+map.getEasyFindString();
 				ewe.sys.Vm.debug(sortEntryBBox + &quot;: &quot;+filename);
 				if (rename == 0) { // never asked before
-					if ( (new MessageBox(MyLocale.getMsg(4702,&quot;Optimisation&quot;), MyLocale.getMsg(4703,&quot;Cachewolf can make loading maps much faster by adding a identification mark to the filename. Do you want me to do this now?\n It can take several minutes&quot;), 
+					if ( (new MessageBox(MyLocale.getMsg(4702,&quot;Optimisation&quot;), MyLocale.getMsg(4703,&quot;Cachewolf can make loading maps much faster by adding a identification mark to the filename. Do you want me to do this now?\n It can take several minutes&quot;),
 							FormBase.YESB | FormBase.NOB)).execute() == FormBase.IDYES)
 					{
 						renameProgressInfoB = new InfoBox(MyLocale.getMsg(327,&quot;Info&quot;), MyLocale.getMsg(4704,&quot;\nRenaming file:&quot;)+&quot;    \n&quot;);
@@ -490,24 +492,24 @@
 			}
 		}
 	}
-	
+
 	public MapListEntry(double scale, double lat) {
 		map = new MapInfoObject(scale, lat);
 		filename = map.mapName;
 		sortEntryBBox = &quot;FF1&quot;;
 	}
-	
+
 	public MapInfoObject getMap() throws IOException {
 		if (map == null) map = new MapInfoObject(path, filename);
 		return map;
 	}
-	
+
 	public static void loadingFinished() {
 		if (renameProgressInfoB != null) renameProgressInfoB.close(0);
 		renameProgressInfoB = null;
 		rename = 0;
 	}
-	
+
 	/*
 	// this maybe needed some time later to further enhance the speed of finding the best map
 	public int compareTo(Object other) {


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="001429.html">[Cachewolf-svn] r1535 - trunk/src/CacheWolf/navi
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1428">[ date ]</a>
              <a href="thread.html#1428">[ thread ]</a>
              <a href="subject.html#1428">[ subject ]</a>
              <a href="author.html#1428">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
