<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r1564 - in	experiments/engywuck/hist-test/src/cachewolf: . imp utils
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1564%20-%20in%0A%09experiments/engywuck/hist-test/src/cachewolf%3A%20.%20imp%20utils&In-Reply-To=%3C200810261434.m9QEYvZZ010085%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001457.html">
   <LINK REL="Next"  HREF="001459.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r1564 - in	experiments/engywuck/hist-test/src/cachewolf: . imp utils</H1>
    <B>engywuck at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1564%20-%20in%0A%09experiments/engywuck/hist-test/src/cachewolf%3A%20.%20imp%20utils&In-Reply-To=%3C200810261434.m9QEYvZZ010085%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r1564 - in	experiments/engywuck/hist-test/src/cachewolf: . imp utils">engywuck at mail.berlios.de
       </A><BR>
    <I>Sun Oct 26 15:34:57 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001457.html">[Cachewolf-svn] r1563 - in	experiments/engywuck/hist-test/src/cachewolf: . utils
</A></li>
        <LI>Next message: <A HREF="001459.html">[Cachewolf-svn] r1565 - in	experiments/engywuck/hist-test/src/cachewolf: . exp imp navi utils
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1458">[ date ]</a>
              <a href="thread.html#1458">[ thread ]</a>
              <a href="subject.html#1458">[ subject ]</a>
              <a href="author.html#1458">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: engywuck
Date: 2008-10-26 15:34:32 +0100 (Sun, 26 Oct 2008)
New Revision: 1564

Added:
   experiments/engywuck/hist-test/src/cachewolf/CenterScreen.java
   experiments/engywuck/hist-test/src/cachewolf/ImageDetailScreen.java
   experiments/engywuck/hist-test/src/cachewolf/InfoHtmlScreen.java
   experiments/engywuck/hist-test/src/cachewolf/RebuildIndex.java
   experiments/engywuck/hist-test/src/cachewolf/imp/GPXImporter.java
   experiments/engywuck/hist-test/src/cachewolf/imp/LOCXMLImporter.java
   experiments/engywuck/hist-test/src/cachewolf/imp/OCXMLImporter.java
   experiments/engywuck/hist-test/src/cachewolf/imp/OCXMLImporterScreen.java
   experiments/engywuck/hist-test/src/cachewolf/imp/SpiderGC.java
Removed:
   experiments/engywuck/hist-test/src/cachewolf/DBStats.java
   experiments/engywuck/hist-test/src/cachewolf/GPXImporter.java
   experiments/engywuck/hist-test/src/cachewolf/ImageDetailForm.java
   experiments/engywuck/hist-test/src/cachewolf/ImageInteractivePanel.java
   experiments/engywuck/hist-test/src/cachewolf/ImagePanelImage.java
   experiments/engywuck/hist-test/src/cachewolf/InfoScreen.java
   experiments/engywuck/hist-test/src/cachewolf/LOCXMLImporter.java
   experiments/engywuck/hist-test/src/cachewolf/MyComparer.java
   experiments/engywuck/hist-test/src/cachewolf/NotesScreen.java
   experiments/engywuck/hist-test/src/cachewolf/OCXMLImporter.java
   experiments/engywuck/hist-test/src/cachewolf/OCXMLImporterScreen.java
   experiments/engywuck/hist-test/src/cachewolf/ProfileDataForm.java
   experiments/engywuck/hist-test/src/cachewolf/RadarPanelImage.java
   experiments/engywuck/hist-test/src/cachewolf/Rebuild.java
   experiments/engywuck/hist-test/src/cachewolf/Reducer.java
   experiments/engywuck/hist-test/src/cachewolf/SpiderGC.java
   experiments/engywuck/hist-test/src/cachewolf/TokenObj.java
   experiments/engywuck/hist-test/src/cachewolf/Tokenizer.java
   experiments/engywuck/hist-test/src/cachewolf/myInteractivePanel.java
   experiments/engywuck/hist-test/src/cachewolf/myTableControl.java
   experiments/engywuck/hist-test/src/cachewolf/myTableModel.java
   experiments/engywuck/hist-test/src/cachewolf/utils/CWWrapper.java
   experiments/engywuck/hist-test/src/cachewolf/utils/FileBugfix.java
   experiments/engywuck/hist-test/src/cachewolf/utils/MessageBoxFixed.java
Log:
Again some moving and renaming.

Copied: experiments/engywuck/hist-test/src/cachewolf/CenterScreen.java (from rev 1559, experiments/engywuck/hist-test/src/cachewolf/ProfileDataForm.java)


Property changes on: experiments/engywuck/hist-test/src/cachewolf/CenterScreen.java
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: experiments/engywuck/hist-test/src/cachewolf/DBStats.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/DBStats.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/DBStats.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,72 +0,0 @@
-package CacheWolf;
-import ewe.util.*;
-
-/**
- * @author Marc
- * Use this class to obtain statistics or information on a cache database.
- */
-public class DBStats {
-	Vector cacheDB = new Vector();
-	
-	public DBStats(Vector db){
-		cacheDB = db;
-	}
-	
-	/**
-	 * Method to get the number of caches displayed in the list.
-	 * It will count waypoints only that start with
-	 * GC,or
-	 * OC
-	 * @return
-	 */
-	public int visible(){
-		CacheHolder holder;
-		int counter = 0;
-		for(int i = 0; i&lt;cacheDB.size();i++){
-			holder = (CacheHolder)cacheDB.get(i);
-			if(holder.is_black == false &amp;&amp; holder.is_filtered == false){
-				if(holder.wayPoint.startsWith(&quot;GC&quot;) || holder.wayPoint.startsWith(&quot;OC&quot;)) counter++;
-			}
-		}
-		return counter;
-	}
-	
-	/**
-	 * Method to get the number of caches available for display
-	 * @return
-	 */
-	public int total(){
-		CacheHolder holder;
-		int counter = 0;
-		for(int i = 0; i&lt;cacheDB.size();i++){
-			holder = (CacheHolder)cacheDB.get(i);
-			if(holder.is_black == false){
-				if(holder.wayPoint.startsWith(&quot;GC&quot;) || holder.wayPoint.startsWith(&quot;OC&quot;)) counter++;
-			}
-		}
-		return counter;
-	}
-	
-	public int totalFound(){
-		CacheHolder holder;
-		int counter = 0;
-		for(int i = 0; i&lt;cacheDB.size();i++){
-			holder = (CacheHolder)cacheDB.get(i);
-			if(holder.is_found == true) {
-				if(holder.wayPoint.startsWith(&quot;GC&quot;) || holder.wayPoint.startsWith(&quot;OC&quot;)) counter++;
-			}
-		}
-		return counter;
-	}
-}
-
-// TODO ASCExporter.java
-//TODO GPXExporter.java
-//TODO HTMLExporter.java
-//TODO KMLExporter.java
-//TODO MSARCSVExporter.java
-//TODO OVLExporter.java
-//TODO OziExporter.java
-//TODO PCX5Exporter.java
-//TODO TomTomASCExporter.ja
-//TODO TomTomOV2Exporter.ja
\ No newline at end of file

Deleted: experiments/engywuck/hist-test/src/cachewolf/GPXImporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/GPXImporter.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/GPXImporter.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,563 +0,0 @@
-package CacheWolf;
-
-import ewesoft.xml.*;
-import ewesoft.xml.sax.*;
-import ewe.sys.*;
-import ewe.ui.FormBase;
-import ewe.ui.MessageBox;
-import ewe.util.*;
-import ewe.util.zip.*;
-
-/**
-*	Class to import Data from an GPX File. If cache data exists, the data from 
-*	the GPX-File is ignored.
-*	Class ID = 4000
-*/
-public class GPXImporter extends MinML {
-	
-	static Preferences pref;
-	Profile profile;
-	Vector cacheDB;
-	CacheHolderDetail chD;
-	String strData, saveDir, logData, logIcon, logDate, logFinder;
-	boolean inWpt, inCache, inLogs, inBug;
-	public XMLElement document;
-	private Vector files = new Vector();
-	private boolean debugGPX = false; 
-	InfoBox infB;
-	boolean spiderOK = true;
-	boolean doSpider = false;
-	boolean fromOC = false;
-	boolean fromTC = false;
-	boolean nameFound = false;
-	int zaehlerGel = 0;
-	Hashtable DBindex = new Hashtable();
-	public static final int DOIT_ASK = 0;
-	public static final int DOIT_NOSPOILER = 1;
-	public static final int DOIT_WITHSPOILER = 2;
-	boolean getMaps = false;
-	SpiderGC imgSpider;
-	StringBuffer strBuf;
-	
-	public GPXImporter(Preferences p, Profile prof, String f )
-	{
-		profile=prof;
-		pref = p;
-		cacheDB = profile.cacheDB;
-		//file = f;
-		files.add(f);
-		saveDir = profile.dataDir;
-		//msgA = msgArea;
-		inWpt = false;
-		inCache = false;
-		inLogs = false;
-		inBug =false;
-		//index db for faster search
-		CacheHolder ch;
-		for(int i = 0; i&lt;cacheDB.size();i++){
-			ch = (CacheHolder)cacheDB.get(i);
-			DBindex.put(ch.wayPoint, new Integer(i));
-		}//for
-	}
-/*	skg: This Constructor is not referenced, therefore commented out 
-	public GPXImporter(Vector DB, String[] f,String d, Preferences p)
-	{
-		pref = p;
-		cacheDB = DB;
-		saveDir = pref.mydatadir;
-		for (int i=0;i&lt;f.length;i++){
-			files.add(d + &quot;/&quot; + f[i]);
-		}
-		
-		//msgA = msgArea;
-		inWpt = false;
-		inCache = false;
-		inLogs = false;
-		inBug =false;
-		strData = new String();
-		//index db for faster search
-		CacheHolder ch;
-		for(int i = 0; i&lt;cacheDB.size();i++){
-			ch = (CacheHolder)cacheDB.get(i);
-			DBindex.put((String)ch.wayPoint, new Integer(i));
-		}//for
-	}
-*/	
-	public void doIt(int how){
-		Filter flt = new Filter();
-		boolean wasFiltered = (profile.filterActive==Filter.FILTER_ACTIVE);
-		flt.clearFilter();
-		try{
-			ewe.io.Reader r;
-			String file;
-			
-			OCXMLImporterScreen options = new OCXMLImporterScreen(&quot;Spider Options&quot;, OCXMLImporterScreen.IMAGES);
-			if (options.execute() == FormBase.IDCANCEL) {	return; }
-			//String dist = options.distanceInput.getText();
-			//if (dist.length()== 0) return;
-			//getMaps = options.mapsCheckBox.getState();
-			boolean getImages = options.imagesCheckBox.getState();
-			doSpider = false;
-			if(getImages){
-				doSpider = true;
-				imgSpider = new SpiderGC(pref, profile, false);
-			}
-			options.close(0);
-			
-			//Vm.debug(&quot;State of: &quot; + doSpider);
-			Vm.showWait(true);
-			for (int i=0; i&lt;files.size();i++){
-				//Test for zip.file
-				file = (String)files.get(i);
-				if (file.indexOf(&quot;.zip&quot;) &gt; 0){
-					ZipFile zif = new ZipFile (file);
-					ZipEntry zipEnt;
-					Enumeration zipEnum = zif.entries();
-					// there could be more than one file in the archive
-					while (zipEnum.hasMoreElements())
-					{
-						zipEnt = (ZipEntry) zipEnum.nextElement();
-						// skip over PRC-files
-						if (zipEnt.getName().endsWith(&quot;gpx&quot;)){
-							r = new ewe.io.InputStreamReader(zif.getInputStream(zipEnt));
-							infB = new InfoBox(zipEnt.toString(),(MyLocale.getMsg(4000,&quot;Loaded caches: &quot;) + zaehlerGel));
-							infB.exec();
-							parse(r);
-							r.close();
-							infB.close(0);
-						}
-					}
-				}
-				else {
-					r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(file));
-					infB = new InfoBox(&quot;Info&quot;,(MyLocale.getMsg(4000,&quot;Loaded caches: &quot;) + zaehlerGel));
-					infB.show();
-					parse(r);
-					r.close();
-					infB.close(0);
-				}
-				// save Index 
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
-				infB.close(0);
-			}
-				Vm.showWait(false);
-			}catch(Exception e){
-				e.printStackTrace();
-				Vm.showWait(false);
-			}
-		if(wasFiltered){
-			flt.setFilter();
-			flt.doFilter();
-		}
-	}
-	public void startElement(String name, AttributeList atts){
-		strBuf=new StringBuffer(300);
-		if (name.equals(&quot;gpx&quot;)){
-			// check for opencaching
-			if (atts.getValue(&quot;creator&quot;).indexOf(&quot;opencaching&quot;)&gt; 0) fromOC = true;
-			else fromOC = false;
-			if (atts.getValue(&quot;creator&quot;).startsWith(&quot;TerraCaching&quot;)) fromTC = true;
-			else fromTC = false;
-
-			if (fromOC &amp;&amp; doSpider) (new MessageBox(&quot;Warnung&quot;, MyLocale.getMsg(4001, &quot;GPX files from opencaching don't contain information of images, they cannot be laoded. Best you get caches from opencaching by menu /Application/Import/Download from Opencaching&quot;), FormBase.OKB)).execute();
-			zaehlerGel = 0;
-		}
-		if (name.equals(&quot;wpt&quot;)) {
-			chD = new CacheHolderDetail();
-			chD.pos.set(Common.parseDouble(atts.getValue(&quot;lat&quot;)),Common.parseDouble(atts.getValue(&quot;lon&quot;)));
-			chD.LatLon=chD.pos.toString();
-			inWpt = true;
-			inLogs = false;
-			inBug = false;
-			nameFound = false;
-			zaehlerGel++;
-			infB.setInfo(MyLocale.getMsg(4000,&quot;Loaded caches: &quot;) + zaehlerGel);
-			return;
-		}
-		
-		if (name.equals(&quot;link&quot;)&amp;&amp; inWpt){
-			chD.URL = atts.getValue(&quot;href&quot;);
-			return;
-		}
-
-		if (name.equals(&quot;groundspeak:cache&quot;)) {
-			inCache = true;
-			if (atts.getValue(&quot;available&quot;).equals(&quot;True&quot;))
-				chD.is_available = true;
-			else 
-				chD.is_available = false;
-			if (atts.getValue(&quot;archived&quot;).equals(&quot;True&quot;))
-				chD.is_archived = true;
-			else
-				chD.is_archived = false;
-			return;
-		}
-
-		if (name.equals(&quot;geocache&quot;)) {
-			inCache=true;
-			// get status
-			String status = new String(atts.getValue(&quot;status&quot;));
-			chD.is_available = false;
-			chD.is_archived = false;
-			if (status.equals(&quot;Available&quot;)) chD.is_available = true;
-			if (status.equals(&quot;Unavailable&quot;)) chD.is_available = false;
-			if (status.equals(&quot;Draft&quot;)) chD.is_available = false;
-			if (status.equals(&quot;Archived&quot;)) chD.is_archived = true;
-			return;
-		}
-		
-		if (name.equals(&quot;terra:terracache&quot;)) {
-			inCache=true;
-		}
-
-		
-		if (name.equals(&quot;groundspeak:long_description&quot;)) {
-			if (atts.getValue(&quot;html&quot;).toLowerCase().equals(&quot;true&quot;))
-				chD.is_HTML= true;
-			else 
-				chD.is_HTML = false;
-			
-		}
-		if (name.equals(&quot;description&quot;) || name.equals(&quot;terra:description&quot;) ) {
-			//set HTML always to true if from oc.de or TC
-			chD.is_HTML= true;
-		}
-
-		if (name.equals(&quot;groundspeak:logs&quot;) || name.equals(&quot;log&quot;) || name.equals(&quot;terra:logs&quot;)) {
-			inLogs = true;
-			return;
-		}
-		if (name.equals(&quot;groundspeak:travelbugs&quot;)) {
-			inBug = true;
-			return;
-		}
-		if (debugGPX){
-			for (int i = 0; i &lt; atts.getLength(); i++) {
-				Vm.debug(&quot;Type: &quot; + atts.getType(i) + &quot; Name: &quot; + atts.getName(i)+ &quot; Value: &quot;+atts.getValue(i));
-			}
-		}
-	}
-	
-	public void endElement(String name){
-		strData=strBuf.toString();
-		//Vm.debug(&quot;Ende: &quot; + name);
-		
-		// logs
-		if (inLogs){
-			if (name.equals(&quot;groundspeak:date&quot;)|| name.equals(&quot;time&quot;)|| name.equals(&quot;terra:date&quot;))  {
-				logDate = new String(strData.substring(0,10));
-				return;
-			}
-			if (name.equals(&quot;groundspeak:type&quot;) || name.equals(&quot;type&quot;) || name.equals(&quot;terra:type&quot;)){
-				logIcon = new String(typeText2Image(strData));
-				return;
-			}
-			if (name.equals(&quot;groundspeak:finder&quot;)|| name.equals(&quot;geocacher&quot;)|| name.equals(&quot;terra:user&quot;)){
-				logFinder = new String(strData);
-				return;
-			}
-			if (name.equals(&quot;groundspeak:text&quot;) || name.equals(&quot;text&quot;) || name.equals(&quot;terra:entry&quot;)){ 
-				logData = new String(strData);
-				return;
-			}
-			if (name.equals(&quot;groundspeak:log&quot;) || name.equals(&quot;log&quot;) || name.equals(&quot;terra:log&quot;) ) {
-				chD.CacheLogs.add(new Log(logIcon,logDate,logFinder,logData));
-				if(logIcon.equals(&quot;icon_smile.gif&quot;) &amp;&amp; 
-						  (logFinder.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; logFinder.equalsIgnoreCase(pref.myAlias2)))) {
-							chD.CacheStatus=logDate;
-							chD.is_found=true;
-				}
-				return;
-			}
-		}
-		
-		if (name.equals(&quot;wpt&quot;)){
-			// Add cache Data only, if waypoint not already in database
-			//if (searchWpt(cacheDB, holder.wayPoint)== -1){
-			int index=searchWpt(chD.wayPoint);
-			//Vm.debug(&quot;here ?!?!?&quot;);
-			//Vm.debug(&quot;chould be new!!!!&quot;);
-			if (index == -1){
-				chD.noFindLogs=chD.CacheLogs.countNotFoundLogs();
-				chD.is_new = true;
-				cacheDB.add(new CacheHolder(chD));
-				// don't spider additional waypoints, so check
-				// if waypoint starts with &quot;GC&quot;
-				if(doSpider == true) {
-					if(spiderOK == true &amp;&amp; chD.is_archived == false){
-							if(chD.LatLon.length() &gt; 1){
-							if(getMaps){
-								ParseLatLon pll = new ParseLatLon(chD.LatLon,&quot;.&quot;);
-								pll.parse();
-								//MapLoader mpl = new MapLoader(pref.myproxy, pref.myproxyport);
-								//mpl.loadTo(profile.dataDir + &quot;/&quot; + holder.wayPoint + &quot;_map.gif&quot;, &quot;3&quot;);
-								//mpl.loadTo(profile.dataDir + &quot;/&quot; + holder.wayPoint + &quot;_map_2.gif&quot;, &quot;10&quot;);
-							}
-						}
-					if(chD.wayPoint.startsWith(&quot;GC&quot;)|| fromTC) {
-						//spiderImages();
-						spiderImagesUsingSpider();
-						//Rename image sources
-						String text;
-						String orig;
-						String imgName;
-						orig = chD.LongDescription;
-						Extractor ex = new Extractor(orig, &quot;&lt;img src=\&quot;&quot;, &quot;&gt;&quot;, 0, false);
-						text = ex.findNext();
-						int num = 0;
-						while(ex.endOfSearch() == false &amp;&amp; spiderOK == true){
-							//Vm.debug(&quot;Replacing: &quot; + text);
-							if (num &gt;= chD.ImagesText.getCount())break;
-							imgName = (String)chD.ImagesText.get(num);
-							chD.LongDescription = replace(chD.LongDescription, text, &quot;[[Image: &quot; + imgName + &quot;]]&quot;);
-							num++;
-							text = ex.findNext();
-						}
-					}
-						
-					}
-				}
-				chD.saveCacheDetails(saveDir);
-				//crw.saveIndex(cacheDB,saveDir);
-			}
-			//Update cache data
-			else {
-				//Vm.debug(&quot;it is not new!&quot;);
-				CacheHolderDetail oldCh= new CacheHolderDetail((CacheHolder) cacheDB.get(index));
-				try {
-					//Vm.debug(&quot;Try to load&quot;);
-					oldCh.readCache(saveDir);
-					//Vm.debug(&quot;Done loading&quot;);
-				} catch (Exception e) {Vm.debug(&quot;Could not open file: &quot; + e.toString());};
-				oldCh.update(chD);
-				oldCh.saveCacheDetails(saveDir);
-				cacheDB.set(index, new CacheHolder(oldCh));
-				//crw.saveIndex(cacheDB,saveDir);
-			}
-			
-			inWpt = false;
-			return;
-		}
-		if (name.equals(&quot;sym&quot;)&amp;&amp; strData.endsWith(&quot;Found&quot;)) {
-			chD.is_found = true;
-			chD.CacheStatus = MyLocale.getMsg(318,&quot;Found&quot;);
-			return;
-		}
-		if (name.equals(&quot;groundspeak:travelbugs&quot;)) {
-			inBug = false;
-			return;
-		}
-
-		if (name.equals(&quot;groundspeak:name&quot;)&amp;&amp; inBug) {
-			Travelbug tb=new Travelbug(strData);
-			chD.Travelbugs.add(tb);
-			//holder.Bugs += &quot;&lt;b&gt;Name:&lt;/b&gt; &quot; + strData + &quot;&lt;br&gt;&lt;hr&gt;&quot;;
-			chD.has_bug = true;
-			return;
-		}
-		
-		if (name.equals(&quot;time&quot;) &amp;&amp; inWpt) {
-			//String Date = new String();
-			//Date = strData.substring(5,7); // month
-			//Date += &quot;/&quot; + strData.substring(8,10); // day
-			//Date += &quot;/&quot; + strData.substring(0,4); // year
-			chD.DateHidden = strData.substring(0,10); //Date;
-			return;
-		}
-		// cache information
-		if (name.equals(&quot;groundspeak:cache&quot;) || name.equals(&quot;geocache&quot;)|| name.equals(&quot;terra:terracache&quot;)) {
-			inCache = false;
-		}
-		
-		if (name.equals(&quot;name&quot;) &amp;&amp; inWpt &amp;&amp; !inCache) {
-			chD.wayPoint = strData;
-			//msgA.setText(&quot;import &quot; + strData);
-			return;
-		}
-		//Vm.debug(&quot;Check: &quot; + inWpt + &quot; / &quot; + fromOC);
-		//if (name.equals(&quot;desc&quot;) &amp;&amp; inWpt &amp;&amp; fromOC) {
-		// fill name with contents of &lt;desc&gt;, in case of gc.com the name is
-		// later replaced by the contents of &lt;groundspeak:name&gt; which is shorter
-		if (name.equals(&quot;desc&quot;)&amp;&amp; inWpt ) {
-			chD.CacheName = strData;
-			//Vm.debug(&quot;CacheName: &quot; + strData);
-			//msgA.setText(&quot;import &quot; + strData);
-			return;
-		}
-		if (name.equals(&quot;url&quot;)&amp;&amp; inWpt){
-			chD.URL = strData;
-			return;
-		}
-		
-		// Text for additional waypoints, no HTML
-		if (name.equals(&quot;cmt&quot;)&amp;&amp; inWpt){
-			chD.LongDescription = strData;
-			chD.is_HTML = false;
-			return;
-		}
-		
-		// aditional wapypoint
-		if (name.equals(&quot;type&quot;)&amp;&amp; inWpt &amp;&amp; !inCache &amp;&amp; strData.startsWith(&quot;Waypoint&quot;)){
-			chD.type= CacheType.typeText2Number(strData);
-			chD.CacheSize = &quot;None&quot;;
-		}
-
-		
-		if ((name.equals(&quot;groundspeak:name&quot;)|| name.equals(&quot;terra:name&quot;)) &amp;&amp; inCache) {
-			chD.CacheName = strData;
-			return;
-		}
-		if (name.equals(&quot;groundspeak:owner&quot;) || name.equals(&quot;owner&quot;)||name.equals(&quot;terra:owner&quot;)) {
-			chD.CacheOwner = strData;
-			if(pref.myAlias.equals(strData)) chD.is_owned = true;
-			return;
-		}
-		if (name.equals(&quot;groundspeak:difficulty&quot;) || name.equals(&quot;difficulty&quot;) || name.equals(&quot;terra:mental_challenge&quot;)) {
-			chD.hard = strData.replace('.',',');
-			return;
-		}
-		if (name.equals(&quot;groundspeak:terrain&quot;)|| name.equals(&quot;terrain&quot;)|| name.equals(&quot;terra:physical_challenge&quot;)) {
-			chD.terrain = strData.replace('.',',');
-			return;
-		}
-		if ((name.equals(&quot;groundspeak:type&quot;) || name.equals(&quot;type&quot;)|| name.equals(&quot;terra:style&quot;))&amp;&amp; inCache){
-			chD.type= CacheType.typeText2Number(strData);
-			return;
-		}
-		if (name.equals(&quot;groundspeak:container&quot;)|| name.equals(&quot;container&quot;)){
-			chD.CacheSize = strData;
-			return;
-		}
-		
-		if (name.equals(&quot;terra:size&quot;)){
-			chD.CacheSize = TCSizetoText(strData);
-		}
-
-		if (name.equals(&quot;groundspeak:short_description&quot;)|| name.equals(&quot;summary&quot;)) {
-			if (chD.is_HTML)	chD.LongDescription =SafeXML.cleanback(strData)+&quot;&lt;br&gt;&quot;; // &lt;br&gt; needed because we also use a &lt;br&gt; in SpiderGC. Without it the comparison in ch.update fails
-			else chD.LongDescription =strData+&quot;\n&quot;;
-			return;
-		}
-
-		if (name.equals(&quot;groundspeak:long_description&quot;)|| name.equals(&quot;description&quot;)|| name.equals(&quot;terra:description&quot;)) {
-			if (chD.is_HTML)	chD.LongDescription +=SafeXML.cleanback(strData);
-			else chD.LongDescription +=strData;
-			return;
-		}
-		if (name.equals(&quot;groundspeak:encoded_hints&quot;) || name.equals(&quot;hints&quot;)) {
-			chD.Hints = Common.rot13(strData);
-			return;
-		}
-		
-		if (name.equals(&quot;terra:hint&quot;)) {
-			// remove &quot;&lt;br&gt;&lt;br&gt;&quot; from the end
-			int indexTrash = strData.indexOf(&quot;&lt;br&gt;&lt;br&gt;&quot;);
-			if (indexTrash &gt; 0)	chD.Hints = Common.rot13(strData.substring(0,indexTrash));
-			return;
-		}
-
-
-	}
-	public void characters(char[] ch,int start,int length){
-		strBuf.append(ch,start,length);
-		if (debugGPX) Vm.debug(&quot;Char: &quot; + strBuf.toString());
-	}
-	
-
-	public static String typeText2Image(String typeText){
-		if (typeText.equals(&quot;Found it&quot;)||typeText.equals(&quot;Found&quot;)||typeText.equals(&quot;find&quot;)) return &quot;icon_smile.gif&quot;;
-		if (typeText.equals(&quot;Didn't find it&quot;)||typeText.equals(&quot;Not Found&quot;)||typeText.equals(&quot;no_find&quot;)) return &quot;icon_sad.gif&quot;;
-		if (typeText.equals(&quot;Write note&quot;)||typeText.equals(&quot;Note&quot;)||typeText.equals(&quot;note&quot;)
-			||typeText.equals(&quot;Not Attempted&quot;)||typeText.equals(&quot;Other&quot;)) return &quot;icon_note.gif&quot;;
-		if (typeText.equals(&quot;Enable Listing&quot;)) return &quot;icon_enabled.gif&quot;;
-		if (typeText.equals(&quot;Temporarily Disable Listing&quot;)) return &quot;icon_disabled.gif&quot;;
-		if (typeText.equals(&quot;Webcam Photo Taken&quot;)) return &quot;11.png&quot;;
-		if (typeText.equals(&quot;Attended&quot;)) return &quot;icon_attended.gif&quot;;
-		if (typeText.equals(&quot;Publish Listing&quot;)) return &quot;green.png&quot;;
-		if (typeText.equals(&quot;Will Attend&quot;)) return &quot;icon_rsvp.gif&quot;;
-		if (typeText.equals(&quot;Post Reviewer Note&quot;)) return &quot;big_smile.gif&quot;;
-		if (typeText.equals(&quot;Unarchive&quot;)) return &quot;traffic_cone.gif&quot;;
-		if (typeText.equals(&quot;Archive (show)&quot;)) return &quot;traffic_cone.gif&quot;;
-		if (typeText.equals(&quot;Owner Maintenance&quot;)) return &quot;icon_maint.gif&quot;;
-		if (typeText.equals(&quot;Needs Maintenance&quot;)) return &quot;icon_needsmaint.gif&quot;;
-		if (typeText.equals(&quot;Update Coordinates&quot;)) return &quot;coord_update.gif&quot;;
-		//Vm.debug(&quot;Unknown Log Type:&quot; + typeText);
-		return typeText;
-	}
-	
-	public static String TCSizetoText(String size){
-		if (size.equals(&quot;1&quot;)) return &quot;Micro&quot;;
-		if (size.equals(&quot;2&quot;)) return &quot;Medium&quot;;
-		if (size.equals(&quot;3&quot;)) return &quot;Regular&quot;;
-		if (size.equals(&quot;4&quot;)) return &quot;Large&quot;;
-		if (size.equals(&quot;5&quot;)) return &quot;Very Large&quot;;
-
-		return &quot;None&quot;;
-	}
-
-	/**
-	* Method to iterate through cache database and look for waypoint.
-	* Returns value &gt;= 0 if waypoint is found, else -1
-	*/
-	/*
-	private int searchWpt(Vector db, String wpt){
-		if(wpt.length()&gt;0){
-			wpt = wpt.toUpperCase();
-			CacheHolder ch = new CacheHolder();
-			//Search through complete database
-			for(int i = 0;i &lt; db.size();i++){
-				ch = (CacheHolder)db.get(i);
-				if(ch.wayPoint.indexOf(wpt) &gt;=0 ){
-					return i;
-				}
-			} // for
-		} // if
-		return -1;
-	}
-	*/
-	
-	private int searchWpt(String wpt){
-		Integer INTR = (Integer)DBindex.get(wpt);
-		if(INTR != null){
-			return INTR.intValue();
-		} else return -1;
-	}
-	private void spiderImagesUsingSpider(){
-		String addr;
-		String cacheText;
-		
-		// just to be sure to have a spider object
-		if (imgSpider == null) imgSpider = new SpiderGC(pref, profile, false);
-		
-		if (fromTC) {
-				imgSpider.getImages(chD.LongDescription, chD);
-		}
-		else {
-			addr = &quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot; + chD.wayPoint ;
-			//Vm.debug(addr + &quot;|&quot;);
-			cacheText = SpiderGC.fetch(addr);
-			imgSpider.getImages(cacheText, chD);
-		}
-	}
-	
-	public static String replace(String source, String pattern, String replace){
-		if (source!=null)
-		{
-			final int len = pattern.length();
-			StringBuffer sb = new StringBuffer();
-			int found = -1;
-			int start = 0;
-		
-			while( (found = source.indexOf(pattern, start) ) != -1) {
-			    sb.append(source.substring(start, found));
-			    sb.append(replace);
-			    start = found + len;
-			}
-		
-			sb.append(source.substring(start));
-		
-			return sb.toString();
-		}
-		else return &quot;&quot;;
-	}
-}

Deleted: experiments/engywuck/hist-test/src/cachewolf/ImageDetailForm.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/ImageDetailForm.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/ImageDetailForm.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,29 +0,0 @@
-package CacheWolf;
-import ewe.ui.*;
-
-
-/**
-* Class creates a view on the image scaled
-* to the application size, but only if the image is larger than
-* the available app size.
-*/
-public class ImageDetailForm extends Form{
-	ImageInteractivePanel ipp = new ImageInteractivePanel();
-	ScrollBarPanel scp;
-	
-	public ImageDetailForm(String imgLoc, Preferences p){
-		scp = new MyScrollBarPanel(ipp);
-		ipp.setImage(imgLoc);
-		this.title = &quot;Image&quot;;
-		this.setPreferredSize(p.myAppWidth, p.myAppHeight);
-		this.addLast(scp, CellConstants.STRETCH, CellConstants.FILL);
-	}
-	
-	public void onEvent(Event ev) {
-		if (ev instanceof ControlEvent &amp;&amp; ev.type==ControlEvent.EXITED) {
-			ev.consumed=true;
-			this.close(0);
-		} else super.onEvent(ev);
-	}
-}
-

Copied: experiments/engywuck/hist-test/src/cachewolf/ImageDetailScreen.java (from rev 1559, experiments/engywuck/hist-test/src/cachewolf/ImageDetailForm.java)


Property changes on: experiments/engywuck/hist-test/src/cachewolf/ImageDetailScreen.java
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: experiments/engywuck/hist-test/src/cachewolf/ImageInteractivePanel.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/ImageInteractivePanel.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/ImageInteractivePanel.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,94 +0,0 @@
-package CacheWolf;
-import ewe.graphics.*;
-import ewe.fx.*;
-import ewe.ui.*;
-
-/**
-*	This class handles the resizing im images
-*/
-public class ImageInteractivePanel extends InteractivePanel{
-	int state = -1; // 0 = nothing, -1 = scaled to window, 1 = scaled to original size
-	ScrollBarPanel scp;
-	String imgLoc = new String();
-	AniImage pic = null;
-	private Menu mClose = new Menu(new String[]{
-			&quot;Close&quot;},&quot;&quot;);
-	public ImageInteractivePanel() {
-		super();
-		this.setMenu(mClose);
-	}
-	
-	public void resizeTo(int w, int h) {
-		this.width = w;
-		this.height = h;
-		if (state == -1) fitImageToWindow();
-		virtualSize = new Rect(0, 0, java.lang.Math.max(w, pic.getWidth()), java.lang.Math.max(h, pic.getHeight()));
-		checkScrolls();
-		super.resizeTo(w, h);
-	}
-	
-	public void setImage(String filename) {
-		imgLoc = filename;
-		mImage mI = new mImage(imgLoc);
-		if (pic != null) {
-			this.removeImage(pic);
-			pic.freeSource();
-			pic.free();
-		}
-		pic = new AniImage(mI);
-		pic.setLocation(0, 0);
-		mI.freeSource();
-		// mI.free(); this works in the java-VM, but it will delete the image in the ewe-vm --&gt; leave it commeted out
-		this.addImage(pic);
-		virtualSize = new Rect(pic.getSize(null));
-		checkScrolls();
-	}
-	
-	public void fitImageToWindow() {
-		Rect s = this.parent.getRect();
-		int ww = pic.getWidth();
-		int wh = pic.getHeight();
-		double scale =  java.lang.Math.max((double)ww/(double)s.width, (double)wh/(double)s.height);
-		if (scale != 1){
-			this.removeImage(pic);
-			AniImage tmp = new AniImage(pic.scale((int)(ww/scale), (int)(wh/scale),null,0));
-			pic.freeSource();
-			pic.free();
-			pic = tmp;
-			pic.setLocation(0, 0);
-			this.addImage(pic);
-			virtualSize = new Rect(pic.getSize(null));
-			checkScrolls();
-		}
-		
-	}
-	
-	public void imageClicked(AniImage which, Point pos){
-		state = -state;
-		if(state == 1){
-			setImage(imgLoc);
-			this.repaintNow();
-		}
-		if(state == -1){
-			fitImageToWindow();
-			this.repaintNow();
-		}
-	}
-	public void penRightReleased(Point p){
-			menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
-	}
-	public void penHeld(Point p){
-			menuState.doShowMenu(p,true,null); 
-	}
-	public void popupMenuEvent(Object selectedItem){
-		postEvent(new ControlEvent(ControlEvent.EXITED,this));
-	}
-	public void formClosing() {
-		super.formClosing();
-		if (pic != null) {
-			pic.freeSource();
-			pic.free();
-		}
-		
-	}
-}

Deleted: experiments/engywuck/hist-test/src/cachewolf/ImagePanelImage.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/ImagePanelImage.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/ImagePanelImage.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,17 +0,0 @@
-package CacheWolf;
-import ewe.graphics.*;
-import ewe.fx.*;
-
-/**
-* The ImagePanelImage extends AniImage by a fileName.
-* This is an easy way to identify the image clicked,
-* what is needed to display the full image from the
-* thumbnail.
-*/
-public class ImagePanelImage extends AniImage{
-	public String fileName = new String();
-	public String imageText = null;
-	public ImagePanelImage(mImage i){
-		super(i);
-	}
-}

Copied: experiments/engywuck/hist-test/src/cachewolf/InfoHtmlScreen.java (from rev 1559, experiments/engywuck/hist-test/src/cachewolf/InfoScreen.java)


Property changes on: experiments/engywuck/hist-test/src/cachewolf/InfoHtmlScreen.java
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: experiments/engywuck/hist-test/src/cachewolf/InfoScreen.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/InfoScreen.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/InfoScreen.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,46 +0,0 @@
-package CacheWolf;
-
-import ewe.ui.*;
-import ewe.io.*;
-
-/**
-*	This class displays an information screen. It loads the html text to display
-*	from a file that is given upon creation of this class. It offers
-*	a cancel button enabling the user to close the screen and return to
-*	wherever the user was before
-*	Class ID = 3000
-*/
-public class InfoScreen extends Form {
-	
-	HtmlDisplay disp = new HtmlDisplay();
-	mButton btCancel;
-	Preferences pref;
-	
-	public InfoScreen(String datei, String tit, boolean readFromFile, Preferences p){
-		pref = p;
-		String text = new String();
-		this.setTitle(tit);
-		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
-		if(readFromFile == true){
-			try{
-				FileReader in = new FileReader(datei);
-				text = in.readAll();
-				in.close();
-			}catch(Exception ex){
-				//Vm.debug(&quot;Error! Could not open &quot; + datei);
-			}
-		} else text = datei;
-		disp.setHtml(text);
-		ScrollBarPanel sbp = new MyScrollBarPanel(disp, ScrollablePanel.NeverShowHorizontalScrollers);
-		this.addLast(sbp);
-		this.addLast(btCancel = new mButton(MyLocale.getMsg(3000,&quot;Close&quot;)),CellConstants.DONTSTRETCH, CellConstants.FILL);
-	}
-	
-	public void onEvent(Event ev){
-		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
-			if (ev.target == btCancel){
-				this.close(0);
-			}
-		}
-	}
-}

Deleted: experiments/engywuck/hist-test/src/cachewolf/LOCXMLImporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/LOCXMLImporter.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/LOCXMLImporter.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,171 +0,0 @@
-    /*
-    CacheWolf is a software for PocketPC, Win and Linux that 
-    enables paperless caching. 
-    It supports the sites geocaching.com and opencaching.de
-    
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
-
-package CacheWolf;
-
-import ewe.sys.Vm;
-import ewe.util.*;
-import ewe.io.*;
-import ewesoft.xml.MinML;
-import ewesoft.xml.sax.AttributeList;
-
-/**
- * @author Kalle
- *
- */
-public class LOCXMLImporter extends MinML {
-	boolean debugXML = false;
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-	String file;
-	CacheHolderDetail holder;
-
-	Hashtable DBindexWpt = new Hashtable();
-	String strData = new String();
-
-	
-	public LOCXMLImporter ( Preferences pf, Profile prof, String f ){
-		pref = pf;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-		file = f;
-		CacheHolder ch;
-		for(int i = 0; i&lt;cacheDB.size();i++){
-			ch = (CacheHolder)cacheDB.get(i);
-			DBindexWpt.put(ch.wayPoint, new Integer(i));
-		}//for
-	}
-	
-	public void doIt() {
-		try{
-			Reader r;
-			Vm.showWait(true);
-			//Test for zip.file
-						r = new FileReader(file);
-						parse(r);
-						r.close();
-			// save Index 
-			profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
-			Vm.showWait(false);
-		}catch(Exception e){
-			//Vm.debug(e.toString());
-			Vm.showWait(false);
-		}
-		
-	}
-	
-	public void startElement(String name, AttributeList atts){
-		if (debugXML){
-			for (int i = 0; i &lt; atts.getLength(); i++) {
-				Vm.debug(&quot; Name: &quot; + atts.getName(i)+ &quot; Value: &quot;+atts.getValue(i));
-			}
-		}
-		strData =&quot;&quot;;
-		if (name.equals(&quot;name&quot;)){
-			holder = getHolder(atts.getValue(&quot;id&quot;));
-			return;
-		}
-		if (name.equals(&quot;coord&quot;)){
-			holder.pos.set(Common.parseDouble(atts.getValue(&quot;lat&quot;)),Common.parseDouble(atts.getValue(&quot;lon&quot;)));
-			holder.LatLon = holder.pos.toString();
-			return;
-		}
-
-		
-	}
-	
-	public void endElement(String name){
-		if (name.equals(&quot;name&quot;)){
-			holder.CacheName = strData;
-		}
-
-		if (name.equals(&quot;waypoint&quot;)){
-			int index;
-			index = searchWpt(holder.wayPoint);
-			if (index == -1){
-				holder.is_new = true;
-				cacheDB.add(new CacheHolder(holder));
-				DBindexWpt.put(holder.wayPoint, new Integer(cacheDB.size()-1));
-			}
-			// update (overwrite) data
-			else {
-				holder.is_new = false;
-				cacheDB.set(index, new CacheHolder(holder));
-			}
-			// save all  (after each cache???)
-			holder.saveCacheDetails(profile.dataDir);
-			profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
-			return;
-		}
-
-		if (name.equals(&quot;link&quot;)){
-			holder.URL = strData;
-			return;
-		}
-
-
-
-	}
-	
-
-	public void characters(char[] ch,int start,int length){
-		String chars = new String(ch,start,length);
-		strData += chars;
-		if (debugXML) Vm.debug(strData);
-	}
-
-	
-	/**
-	* Method to iterate through cache database and look for waypoint.
-	* Returns value &gt;= 0 if waypoint is found, else -1
-	*/
-	private int searchWpt(String wpt){
-		Integer INTR = (Integer)DBindexWpt.get(wpt);
-		if(INTR != null){
-			return INTR.intValue();
-		} else return -1;
-	}
-
-	private CacheHolderDetail getHolder(String wpt){// See also OCXMLImporter
-		int index;
-		CacheHolderDetail ch;
-		
-		index = searchWpt(wpt);
-		if (index == -1){
-			ch = new CacheHolderDetail();
-			ch.wayPoint = wpt;
-			return ch;
-		}
-		ch = new CacheHolderDetail((CacheHolder) cacheDB.get(index));
-		try {
-			ch.readCache(profile.dataDir);
-		} catch (Exception e) {Vm.debug(&quot;Could not open file: &quot; + e.toString());};
-		return ch;
-	}
-
-
-}

Deleted: experiments/engywuck/hist-test/src/cachewolf/MyComparer.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/MyComparer.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/MyComparer.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,118 +0,0 @@
-package CacheWolf;
-import ewe.util.*;
-
-/**
-*	This class handles the sorting for most of the sorting tasks. If a cache is 
-*	to be displayed in the table or not is handled in the table model
-*	@see MyTableModel
-*	@see DistComparer
-*/
-public class MyComparer implements Comparer{
-	Vector cacheDB;
-	
-	public MyComparer(Vector cacheDB, int colToCompare, int visibleSize){
-		//visibleSize=Global.mainTab.tbP.myMod.numRows;
-		if (visibleSize&lt;2) return;
-		for (int i=visibleSize; i&lt;cacheDB.size(); i++) {
-			CacheHolder ch=(CacheHolder) cacheDB.get(i);
-			ch.sort=&quot;\uFFFF&quot;;
-		}
-		if (colToCompare==1) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=ch.type;
-			}
-		} else if (colToCompare==2) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=ch.hard;
-			}
-		} else if (colToCompare==3) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=ch.terrain;
-			}
-		} else if (colToCompare==4) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=ch.wayPoint.toUpperCase();
-			}
-		} else if (colToCompare==5) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=ch.CacheName.toLowerCase();
-			}
-		} else if (colToCompare==6) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=ch.LatLon;
-			}
-		} else if (colToCompare==7) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=ch.CacheOwner.toLowerCase();
-			}
-		} else if (colToCompare==8) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=ch.DateHidden;
-			}
-		} else if (colToCompare==9) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=ch.CacheStatus;
-			}
-		} else if (colToCompare==10) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				int p=ch.distance.indexOf(&quot;,&quot;);
-				if (p&lt;0) p=ch.distance.indexOf(&quot;.&quot;);
-				if (p&gt;=0 &amp;&amp; p&lt;=5)
-					ch.sort=&quot;00000&quot;.substring(0,5-p)+ch.distance;
-				else
-					ch.sort=ch.distance;
-			}
-		} else if (colToCompare==11) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				ch.sort=ch.bearing;
-			}
-			
-		} else if (colToCompare==12) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				if (ch.CacheSize.length()==0) ch.sort=&quot;?&quot;;
-				else switch (ch.CacheSize.charAt(0)) {
-					case 'M': ch.sort=&quot;1&quot;; break;
-					case 'S': ch.sort=&quot;2&quot;; break;
-					case 'R': ch.sort=&quot;3&quot;; break;
-					case 'L': ch.sort=&quot;4&quot;; break; 
-					case 'V': ch.sort=&quot;5&quot;; break;
-					default: ch.sort=&quot;?&quot;;
-				}
-			}
-		} else if (colToCompare==13) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				if (ch.wayPoint.startsWith(&quot;OC&quot;))
-					ch.sort=MyLocale.formatLong(ch.numRecommended,&quot;00000&quot;);
-				else
-					ch.sort=&quot;\uFFFF&quot;;
-			}			
-		} else if (colToCompare==14) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=(CacheHolder) cacheDB.get(i);
-				if (ch.wayPoint.startsWith(&quot;OC&quot;))
-					ch.sort=MyLocale.formatLong(ch.recommendationScore,&quot;00000&quot;);
-				else
-					ch.sort=&quot;\uFFFF&quot;;
-			}			
-		}
-	}
-	
-	public int compare(Object o1, Object o2){
-		CacheHolder oo1 = (CacheHolder)o1;
-		CacheHolder oo2 = (CacheHolder)o2;
-		return oo1.sort.compareTo(oo2.sort);
-	}
-}

Deleted: experiments/engywuck/hist-test/src/cachewolf/NotesScreen.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/NotesScreen.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/NotesScreen.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,73 +0,0 @@
-package CacheWolf;
-import ewe.ui.*;
-import ewe.fx.*;
-import ewe.sys.*;
-
-/**
-*	This class displays a form to show and edit notes for a cache.
-*	Class ID=
-*/
-public class NotesScreen extends Form{
-	mTextPad wayNotes = new mTextPad();
-	CacheHolderDetail thisCache = null;
-	mButton addDateTime;
-	mButton btSave = new mButton(MyLocale.getMsg(127,&quot;Save&quot;));
-	mButton cancelBtn = new mButton(&quot;Cancel&quot;);
-	ScrollBarPanel sbp = new MyScrollBarPanel(wayNotes);
-	
-	public NotesScreen(CacheHolderDetail ch){
-		int sw = MyLocale.getScreenWidth();
-		String imagesize = &quot;&quot;;
-		if (Vm.isMobile() &amp;&amp; sw &gt;= 400) imagesize=&quot;_vga&quot;;
-		addDateTime = new mButton(new mImage(&quot;date_time&quot;+imagesize+&quot;.gif&quot;));
-		
-		this.title = &quot;Notes&quot;;
-		setPreferredSize(Global.getPref().myAppWidth, Global.getPref().myAppHeight);
-		this.resizeOnSIP = true;
-		thisCache = ch;
-		wayNotes.setText(thisCache.CacheNotes);
-		addLast(sbp.setTag(CellConstants.SPAN, new Dimension(3,1)),CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
-		titleControls=new CellPanel();
-		titleControls.addNext(addDateTime,CellConstants.HSTRETCH,CellConstants.HFILL);
-		titleControls.addNext(cancelBtn,CellConstants.HSTRETCH,CellConstants.HFILL);
-		titleControls.addLast(btSave,CellConstants.HSTRETCH,CellConstants.HFILL);
-	}
-	
-	public void onEvent(Event ev){
-		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
-			if (ev.target == addDateTime){
-				String note = wayNotes.getText();
-				Time dtm = new Time();
-				dtm.getTime();
-				dtm.setFormat(&quot;E dd.MM.yyyy '/' HH:mm&quot;);
-				if(note.length() &gt; 0)	note = note + &quot;\n&quot; + dtm.toString();
-				else 	note = note + dtm.toString();
-				note = note + &quot;\n&quot;;
-				wayNotes.setText(note);
-			}
-			if(ev.target == btSave){
-				thisCache.CacheNotes = wayNotes.getText();
-				thisCache.saveCacheDetails( Global.getProfile().dataDir);
-				this.close(0);
-			}
-			if(ev.target == cancelBtn){
-				if ( (!thisCache.CacheNotes.equals(wayNotes.getText())) ) {
-					if ( (new MessageBox(&quot;Warning&quot;, &quot;You will loose any changes made to the notes. Do you want to continue?&quot;
-							, FormBase.YESB|FormBase.NOB)).execute() == FormBase.IDYES) {
-						this.close(0);
-					}
-				} else this.close(0); // no changes -&gt; exit without asking
-			} 
-			if(ev.target == titleOK){
-				if ( (!thisCache.CacheNotes.equals(wayNotes.getText())) ) {
-					if ( (new MessageBox(&quot;Warning&quot;, &quot;Save changes made to the notes?&quot;
-							, FormBase.YESB|FormBase.NOB)).execute() == FormBase.IDYES) {
-						thisCache.CacheNotes = wayNotes.getText();
-						thisCache.saveCacheDetails( Global.getProfile().dataDir);
-					}
-				}
-			}
-		}
-		super.onEvent(ev);
-	}
-}

Deleted: experiments/engywuck/hist-test/src/cachewolf/OCXMLImporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/OCXMLImporter.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/OCXMLImporter.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,755 +0,0 @@
-package CacheWolf;
-
-import utils.FileBugfix;
-
-import com.stevesoft.ewe_pat.Regex;
-
-import ewesoft.xml.*;
-import ewesoft.xml.sax.*;
-import ewe.io.*;
-import ewe.sys.*;
-import ewe.ui.FormBase;
-import ewe.ui.MessageBox;
-import ewe.util.*;
-import ewe.util.zip.*;
-import ewe.net.*;
-import ewe.sys.Double;
-
-/**
- *	Class to import Data from opencaching.de. 
- *	It uses the lastmodified parameter to identify new or changed caches.
- *	See here: <A HREF="http://www.opencaching.com/phpBB2/viewtopic.php?t=281">http://www.opencaching.com/phpBB2/viewtopic.php?t=281</A> (out-dated)
- *   See here: <A HREF="http://www.opencaching.de/doc/xml/xml11.htm">http://www.opencaching.de/doc/xml/xml11.htm</A> and <A HREF="http://develforum.opencaching.de/viewtopic.php?t=135&amp;postdays=0&amp;postorder=asc&amp;start=0">http://develforum.opencaching.de/viewtopic.php?t=135&amp;postdays=0&amp;postorder=asc&amp;start=0</A>
- *	for more information.
- */
-public class OCXMLImporter extends MinML {
-	static protected final int STAT_INIT = 0;
-	static protected final int STAT_CACHE = 1;
-	static protected final int STAT_CACHE_DESC = 2;
-	static protected final int STAT_CACHE_LOG = 3;
-	static protected final int STAT_PICTURE = 4;
-
-	final static String OPENCACHING_HOST = &quot;www.opencaching.de&quot;;
-	int state = STAT_INIT;
-	int numCacheImported, numDescImported, numLogImported= 0;
-
-	boolean debugGPX = false;
-	Vector cacheDB;
-	InfoBox inf;
-	CacheHolder ch;
-	CacheHolderDetail chD;
-	Preferences pref;
-	Profile profile;
-	Time dateOfthisSync;
-	String strData = new String();
-	int picCnt;
-	boolean incUpdate = true; // complete or incremental Update
-	boolean ignoreDesc = false;
-	boolean askForOptions = true;
-	Hashtable DBindexWpt = new Hashtable();
-	Hashtable DBindexID = new Hashtable();
-
-	String picUrl = new String();
-	String picTitle =  new String();
-	String picID = new String();
-	String ocSeekUrl = new String(&quot;<A HREF="http://">http://</A>&quot;+OPENCACHING_HOST+&quot;/viewcache.php?cacheid=&quot;);
-	String cacheID = new String();
-
-	String logData, logIcon, logDate, logFinder;
-	boolean loggerRecommended;
-	int logtype;
-	String user;
-	double longitude;
-
-
-	public OCXMLImporter(Preferences p,Profile prof)
-	{
-		pref = p;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-		if(profile.last_sync_opencaching == null ||
-				profile.last_sync_opencaching.length() &lt; 12){
-			profile.last_sync_opencaching = &quot;20050801000000&quot;;
-			incUpdate = false;
-		}
-		user = p.myAlias.toLowerCase();
-		for(int i = 0; i&lt;cacheDB.size();i++){
-			ch = (CacheHolder)cacheDB.get(i);
-			DBindexWpt.put(ch.wayPoint, new Integer(i));
-			if (!ch.ocCacheID.equals(&quot;&quot;))
-				DBindexID.put(ch.ocCacheID, new Integer(i));
-		}//for
-
-	}
-
-	/** true, if not the last syncdate shall be used, but the caches shall be reloaded
-	 * only used in syncSingle */
-	boolean reload;
-	/**
-	 * 
-	 * @param number
-	 * @param infB
-	 * @return true, if some change was made to the cacheDB
-	 */
-	public boolean syncSingle(int number, InfoBox infB) {
-		ch = (CacheHolder)cacheDB.get(number);
-		chD= null; //new CacheHolderDetail(ch); //TODO is this still correct? use getDetails ?
-
-		if (infB.isClosed) {
-			if (askForOptions) return false; 
-			else return true;
-		}
-		if (askForOptions) {
-			OCXMLImporterScreen importOpt = new OCXMLImporterScreen( MyLocale.getMsg(1600, &quot;Opencaching.de Download&quot;),OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.ALL);
-			if (importOpt.execute() == FormBase.IDCANCEL) {	return false; }
-			askForOptions = false;
-			reload = importOpt.missingCheckBox.getState();
-		}
-
-		// this is only a dummy-InfoBox for capturing the output
-		inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
-//		inf.setPreferredSize(220, 300);
-//		inf.relayout(false);
-//		inf.exec();
-
-		String lastS; 
-		if (reload)  lastS = &quot;20050801000000&quot;;
-		else {
-			if (ch.lastSyncOC.length() &lt; 14) lastS = &quot;20050801000000&quot;;
-			else lastS = ch.lastSyncOC;
-		}
-		dateOfthisSync = new Time();
-		dateOfthisSync.parse(lastS, &quot;yyyyMMddHHmmss&quot;);
-	
-
-		String url = new String();
-		picCnt = 0;
-		//Build url
-		url = &quot;<A HREF="http://">http://</A>&quot; + OPENCACHING_HOST + &quot;/xml/ocxml11.php?&quot;
-			+ &quot;modifiedsince=&quot; + lastS
-			+ &quot;&amp;cache=1&quot;
-			+ &quot;&amp;cachedesc=1&quot;;
-		if (pref.downloadPicsOC) url += &quot;&amp;picture=1&quot;;
-		else url += &quot;&amp;picture=0&quot;;
-		url += &quot;&amp;cachelog=1&quot;
-			+ &quot;&amp;removedobject=0&quot;
-			+ &quot;&amp;wp=&quot; + ch.wayPoint
-			+ &quot;&amp;charset=utf-8&quot;
-			+ &quot;&amp;cdata=0&quot;
-			+ &quot;&amp;session=0&quot;;
-		syncOC(url);
-		inf.close(0);
-		return true;
-	}
-
-	public void doIt(){
-		boolean success=true;
-		String finalMessage;
-
-		
-		String url = new String();
-
-		String lastS =  profile.last_sync_opencaching;
-		CWPoint centre = pref.curCentrePt; // No need to clone curCentrePt as centre is only read
-		if (!centre.isValid()) {
-			(new MessageBox(&quot;Error&quot;, &quot;Coordinates for centre must be set&quot;, FormBase.OKB)).execute();
-			return;
-		}
-		OCXMLImporterScreen importOpt = new OCXMLImporterScreen( MyLocale.getMsg(1600, &quot;Opencaching.de Download&quot;),
-																 OCXMLImporterScreen.ALL | OCXMLImporterScreen.DIST | OCXMLImporterScreen.IMAGES);
-		if (importOpt.execute() == FormBase.IDCANCEL) {	return; }
-		Vm.showWait(true);
-		String dist = importOpt.distanceInput.getText();
-		if (dist.length()== 0) return;
-		
-		Double distDouble = new Double();
-		distDouble.value = Common.parseDouble(dist);
-		dist = distDouble.toString(0, 1, 0).replace(',', '.');
-		//check, if distance is greater than before
-		if (Convert.toInt(dist) &gt; Convert.toInt(profile.distOC) ||
-				pref.downloadmissingOC  ){
-			// resysnc
-			lastS = &quot;20050801000000&quot;;
-			incUpdate = false;
-		}
-		profile.distOC = dist;
-		// Clear status of caches in db
-		for(int i = cacheDB.size()-1; i&gt;=0 ;i--){
-			ch = (CacheHolder)cacheDB.get(i);
-			ch.is_update = false;
-			ch.is_new = false;
-			ch.is_log_update = false;
-		}	
-		picCnt = 0;
-		//Build url
-		url = &quot;<A HREF="http://">http://</A>&quot; + OPENCACHING_HOST + &quot;/xml/ocxml11.php?&quot;
-			+ &quot;modifiedsince=&quot; + lastS
-			+ &quot;&amp;cache=1&quot;
-			+ &quot;&amp;cachedesc=1&quot;;
-		if (pref.downloadPicsOC) url += &quot;&amp;picture=1&quot;;
-		else url += &quot;&amp;picture=0&quot;;
-		url += &quot;&amp;cachelog=1&quot;
-			+ &quot;&amp;removedobject=0&quot;
-			+ &quot;&amp;lat=&quot; + centre.getLatDeg(CWPoint.DD)
-			+ &quot;&amp;lon=&quot; + centre.getLonDeg(CWPoint.DD)
-			+ &quot;&amp;distance=&quot; + dist
-			+ &quot;&amp;charset=utf-8&quot;
-			+ &quot;&amp;cdata=0&quot;
-			+ &quot;&amp;session=0&quot;;
-		inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
-		inf.setPreferredSize(220, 300);
-		inf.relayout(false);
-		inf.exec();
-
-		success = syncOC(url);
-		Vm.showWait(false);
-		if (success) {
-			profile.last_sync_opencaching = dateOfthisSync.format(&quot;yyyyMMddHHmmss&quot;);
-			//pref.savePreferences();
-			finalMessage = MyLocale.getMsg(1607,&quot;Update from opencaching successful&quot;); 
-			inf.addWarning(&quot;\nNumber of&quot;+
-			&quot;\n...caches new/updated: &quot; + numCacheImported +
-			&quot;\n...cache descriptions new/updated: &quot; + numDescImported +
-			&quot;\n...logs new/updated: &quot; + numLogImported);
-			inf.setInfo(finalMessage);
-		}
-		inf.addOkButton();
-	}
-	
-	private boolean syncOC(String url) {
-		String finalMessage = new String();
-		boolean success=true;
-		File tmpFile = null;
-		BufferedReader r;
-		String file = new String();
-
-		//inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
-		
-		picCnt = 0;
-		try{
-			chD = null;
-			file = fetch(url, &quot;dummy&quot;);
-
-			//parse
-			tmpFile = new FileBugfix(profile.dataDir + file);
-			if (tmpFile.getLength() == 0 ) {
-				throw new IOException(&quot;no updates available&quot;);
-			}
-
-			ZipFile zif = new ZipFile (profile.dataDir + file);
-			ZipEntry zipEnt;
-			Enumeration zipEnum = zif.entries();
-			inf.setInfo(&quot;...unzipping update file&quot;); 
-			while (zipEnum.hasMoreElements())
-			{
-				zipEnt = (ZipEntry) zipEnum.nextElement();
-				// skip over PRC-files and empty files
-				if (zipEnt.getSize()&gt; 0 &amp;&amp; zipEnt.getName().endsWith(&quot;xml&quot;)){
-					r = new BufferedReader (new InputStreamReader(zif.getInputStream(zipEnt), IO.JAVA_UTF8_CODEC));
-					parse(r);
-					r.close();
-				}
-			}
-			zif.close();
-		}catch (ZipException e){
-			finalMessage = MyLocale.getMsg(1614,&quot;Error while unzipping udpate file&quot;);
-			success = false;
-		}catch (IOException e){
-			if (e.getMessage().equalsIgnoreCase(&quot;no updates available&quot;)) { finalMessage = &quot;No updates available&quot;; success = false; }
-			else {
-				if (e.getMessage().equalsIgnoreCase(&quot;could not connect&quot;) ||
-						e.getMessage().equalsIgnoreCase(&quot;unkown host&quot;)) { // is there a better way to find out what happened?
-					finalMessage = MyLocale.getMsg(1616,&quot;Error: could not download udpate file from opencaching.de&quot;);
-				} else { finalMessage = &quot;IOException: &quot;+e.getMessage(); }
-				success = false;
-			}
-		}catch (IllegalArgumentException e) {
-			finalMessage = MyLocale.getMsg(1621,&quot;Error parsing update file\n this is likely a bug in opencaching.de\nplease try again later\n, state:&quot;)+&quot; &quot;+state+&quot;, waypoint: &quot;+ chD.wayPoint;
-			success = false;
-			Vm.debug(&quot;Parse error: &quot; + state + &quot; &quot; + chD.wayPoint);
-			e.printStackTrace();
-		}catch (Exception e){ // here schould be used the correct exepion
-			if (chD != null)	finalMessage = MyLocale.getMsg(1615,&quot;Error parsing update file, state:&quot;)+&quot; &quot;+state+&quot;, waypoint: &quot;+ chD.wayPoint;
-			else finalMessage = MyLocale.getMsg(1615,&quot;Error parsing update file, state:&quot;)+&quot; &quot;+state+&quot;, waypoint: &lt;unkown&gt;&quot;;
-			success = false;
-			Vm.debug(&quot;Parse error: &quot; + state + &quot; Exception:&quot; + e.toString()+&quot;   &quot;+chD.ocCacheID);
-			e.printStackTrace();
-		} finally {
-			if (tmpFile != null) tmpFile.delete();
-		}
-		/*
-		for (int i=cacheDB.size()-1; i &gt;=0; i--) {
-			ch = (CacheHolder)cacheDB.get(i);
-			if (ch.wayPoint.toUpperCase().startsWith(&quot;OC&quot;)) { //TODO only handle changed caches
-				ch.calcRecommendationScore();
-			}
-		} */
-		profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
-		inf.setInfo(finalMessage);
-
-		return success;
-	}
-
-	public void startElement(String name, AttributeList atts){
-		if (debugGPX){
-			for (int i = 0; i &lt; atts.getLength(); i++) {
-				Vm.debug(&quot; Name: &quot; + atts.getName(i)+ &quot; Value: &quot;+atts.getValue(i));
-			}
-		}
-		strData =&quot;&quot;;
-
-		if (name.equals(&quot;oc11xml&quot;)){
-			Time lastSync = new Time();
-			try {
-				lastSync.parse(atts.getValue(&quot;date&quot;),&quot;yyyy-MM-dd HH:mm:ss&quot;);
-			}catch (IllegalArgumentException e){ // TODO Fehler werfen
-				Vm.debug(e.toString());
-			}
-			// reduce time at 1 second to avoid sync problems
-			lastSync.setTime(lastSync.getTime() - 1000);
-			dateOfthisSync = lastSync;
-			state = STAT_INIT;
-		}
-
-		// look for changes in the state
-		if (name.equals(&quot;cache&quot;)) 		{ state = STAT_CACHE; numCacheImported++;}
-		if (name.equals(&quot;cachedesc&quot;)) 	{ state = STAT_CACHE_DESC; numDescImported++;}
-		if (name.equals(&quot;cachelog&quot;)) 	{ state = STAT_CACHE_LOG; numLogImported++; logtype = 0;}
-		if (name.equals(&quot;picture&quot;)) 	{ state = STAT_PICTURE; }
-
-		//examine data
-		switch (state) {
-		case STAT_CACHE: startCache(name, atts); break;
-		case STAT_CACHE_DESC: startCacheDesc(name, atts); break; 
-		case STAT_CACHE_LOG: startCacheLog(name, atts); break;
-		case STAT_PICTURE: startPicture(name,atts); break;
-		}
-
-	}
-
-	public void endElement(String name){
-		//examine data
-		switch (state) {
-		case STAT_CACHE: endCache(name); break;
-		case STAT_CACHE_DESC: endCacheDesc(name);break;
-		case STAT_CACHE_LOG: endCacheLog(name); break;
-		case STAT_PICTURE: endPicture(name); break;
-		}
-
-		// look for changes in the state
-		if (name.equals(&quot;cache&quot;)) 		state = STAT_INIT;
-		if (name.equals(&quot;cachedesc&quot;)) 	state = STAT_INIT;
-		if (name.equals(&quot;cachelog&quot;)) 	state = STAT_INIT;
-		if (name.equals(&quot;picture&quot;)) 	state = STAT_INIT;
-
-	}
-
-	public void characters(char[] ch,int start,int length){
-		String chars = new String(ch,start,length);
-		strData += chars;
-		if (debugGPX) Vm.debug(strData);
-	}
-
-	private void startCache(String name, AttributeList atts){
-		inf.setInfo(MyLocale.getMsg(1609,&quot;Importing Cache:&quot;)+&quot; &quot; + numCacheImported + &quot;\n&quot;);
-		if(name.equals(&quot;id&quot;)){
-			cacheID = atts.getValue(&quot;id&quot;);
-		}
-		if(name.equals(&quot;type&quot;)){
-			chD.type = CacheType.transOCType(atts.getValue(&quot;id&quot;));
-			return;
-		}
-		if(name.equals(&quot;status&quot;)){
-			if(atts.getValue(&quot;id&quot;).equals(&quot;1&quot;)) chD.is_available = true;
-			if(atts.getValue(&quot;id&quot;).equals(&quot;2&quot;)) chD.is_available = false;
-			if(atts.getValue(&quot;id&quot;).equals(&quot;3&quot;)) {
-				chD.is_archived = true;
-				chD.is_available = false;
-			}
-			if(atts.getValue(&quot;id&quot;).equals(&quot;4&quot;)) chD.is_available = false;
-			return;
-		}
-		if(name.equals(&quot;size&quot;)){
-			chD.CacheSize = transSize(atts.getValue(&quot;id&quot;));
-			return;
-		}
-
-		if(name.equals(&quot;waypoints&quot;)){
-			chD.wayPoint = atts.getValue(&quot;oc&quot;);
-			if (chD.wayPoint.length()==0) throw new IllegalArgumentException(&quot;empty waypointname&quot;); // this should not happen - it is likey a bug in opencaching.de / it happens on 27-12-2006 on cache OC143E
-			return;
-		}
-
-	}
-	private void startCacheDesc(String name, AttributeList atts){
-		inf.setInfo(MyLocale.getMsg(1611,&quot;Importing cache description:&quot;)+&quot; &quot; + numDescImported);
-		if (name.equals(&quot;cachedesc&quot;)){
-			ignoreDesc = false;
-		}
-
-		if (name.equals(&quot;desc&quot;)){
-			chD.is_HTML = atts.getValue(&quot;html&quot;).equals(&quot;1&quot;)?true:false;
-		}
-
-		if (name.equals(&quot;language&quot;) &amp;&amp; !atts.getValue(&quot;id&quot;).equals(&quot;DE&quot;)){
-			if (chD.LongDescription.length()&gt; 0) ignoreDesc = true; // TODO &quot;DE&quot; in preferences adjustable
-			else ignoreDesc = false;
-		}
-	}
-
-	private void startPicture(String name, AttributeList atts){
-		if(name.equals(&quot;picture&quot;)){
-			inf.setInfo(MyLocale.getMsg(1613,&quot;Pictures:&quot;)+&quot; &quot; + ++picCnt);
-		}
-	}
-
-	private void startCacheLog(String name, AttributeList atts){
-		inf.setInfo(MyLocale.getMsg(1612,&quot;Importing Cachlog:&quot;)+&quot; &quot; + numLogImported);
-		if (name.equals(&quot;logtype&quot;)){
-			logtype = Convert.toInt(atts.getValue(&quot;id&quot;));
-			switch (logtype) {
-			case 1: 
-				logIcon = GPXImporter.typeText2Image(&quot;Found&quot;); 
-				if (logFinder.equalsIgnoreCase(user) || logFinder.equalsIgnoreCase(pref.myAlias2)) { // see also endCacheLog
-					chD.is_found = true; 
-					chD.CacheStatus = MyLocale.getMsg(318,&quot;Found&quot;);
-				}
-				break;
-			case 2:	logIcon = GPXImporter.typeText2Image(&quot;Not Found&quot;); 
-			chD.noFindLogs += 1;
-			break;
-			case 3: logIcon = GPXImporter.typeText2Image(&quot;Note&quot;);
-			}
-			loggerRecommended = atts.getValue(&quot;recommended&quot;).equals(&quot;1&quot;);
-			return;
-		}
-
-	}
-
-	private void endCache(String name){
-		if (name.equals(&quot;cache&quot;)){
-			chD.lastSyncOC = dateOfthisSync.format(&quot;yyyyMMddHHmmss&quot;);
-			int index;
-			index = searchWpt(chD.wayPoint);
-			if (index == -1){
-				chD.is_new = true;
-				CacheHolder ch = new CacheHolder(chD);
-				ch.details = chD;
-				cacheDB.add(ch);
-				ch.detailsAdded();
-				Integer indexInt = new Integer(cacheDB.size()-1);
-				DBindexWpt.put(chD.wayPoint, indexInt);
-				DBindexID.put(chD.ocCacheID, indexInt);
-			}
-			// update (overwrite) data
-			else {
-				chD.is_new = false;
-				cacheDB.set(index, new CacheHolder(chD));
-				// save ocCacheID, in case, the previous data is from GPX
-				DBindexID.put(chD.ocCacheID, new Integer(index));
-			}
-			// clear data (picture, logs) if we do a complete Update
-			if (incUpdate == false){
-				chD.CacheLogs.clear();
-				chD.Images.clear();
-				chD.ImagesText.clear();
-				chD.ImagesInfo.clear();
-			}
-
-			// save all
-			chD.hasUnsavedChanges = true; // this makes CachHolder save the details in case that they are unloaded from memory
-			// chD.saveCacheDetails(profile.dataDir); 
-			// profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR); // this is done after .xml is completly processed
-			return;
-		}
-		if(name.equals(&quot;id&quot;)){ // &lt;/id&gt;
-			chD = getHolder(strData); // Allocate a new CacheHolder object
-			chD.ocCacheID=strData;
-			chD.URL = ocSeekUrl + cacheID;
-			return;
-		}
-
-		if(name.equals(&quot;name&quot;)){
-			chD.CacheName = strData;
-			return;
-		}
-		if(name.equals(&quot;userid&quot;)) {
-			chD.CacheOwner = strData;
-			if(chD.CacheOwner.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; chD.CacheOwner.equalsIgnoreCase(pref.myAlias2))) chD.is_owned = true;
-			return;
-		}
-
-		if(name.equals(&quot;longitude&quot;)){
-			longitude = Common.parseDouble(strData);
-			return;
-		}
-		if(name.equals(&quot;latitude&quot;)) {
-			chD.pos.set(Common.parseDouble(strData),longitude);
-			chD.LatLon = chD.pos.toString();
-			return;
-		}
-		if(name.equals(&quot;difficulty&quot;)) {
-			chD.hard = strData;
-			return;
-		}
-		if(name.equals(&quot;terrain&quot;)) {
-			chD.terrain = strData;
-			return;
-		}
-		if(name.equals(&quot;datehidden&quot;)) {
-			chD.DateHidden = strData.substring(0,10); //Date;
-			return;
-		}
-	}
-
-	private void endCacheDesc(String name){
-
-		if (!ignoreDesc){
-			if (name.equals(&quot;cachedesc&quot;)){
-				if (pref.downloadPicsOC &amp;&amp; chD.is_HTML) {
-					String fetchUrl, imgTag, imgAltText;
-					Regex imgRegexUrl = new Regex(&quot;(&lt;img[^&gt;]*src=[\&quot;\']([^&gt;^\&quot;^\']*)[^&gt;]*&gt;|&lt;img[^&gt;]*src=([^&gt;^\&quot;^\'^ ]*)[^&gt;]*&gt;)&quot;); //  Ergebnis enth&#228;lt keine Anf&#252;hrungszeichen
-					Regex imgRegexAlt = new Regex(&quot;(?:alt=[\&quot;\']([^&gt;^\&quot;^\']*)|alt=([^&gt;^\&quot;^\'^ ]*))&quot;); // get alternative text for Pic
-					imgRegexAlt.setIgnoreCase(true);
-					imgRegexUrl.setIgnoreCase(true);
-					int descIndex=0;
-					int numDownloaded=1;
-					while (imgRegexUrl.searchFrom(chD.LongDescription, descIndex)) { // &quot;img&quot; found
-						imgTag=imgRegexUrl.stringMatched(1); // (1) enth&#228;lt das gesamte &lt;img ...&gt;-tag
-						fetchUrl=imgRegexUrl.stringMatched(2); // URL in Anf&#252;hrungszeichen in (2) falls ohne in (3) Ergebnis ist auf jeden Fall ohne Anf&#252;hrungszeichen 
-						if (fetchUrl==null) { fetchUrl=imgRegexUrl.stringMatched(3); }
-						if (fetchUrl==null) { // TODO Fehler ausgeben: nicht abgedeckt ist der Fall, dass in einem Cache Links auf Bilder mit unterschiedlichen URL, aber gleichem Dateinamen sind.
-							inf.addWarning(MyLocale.getMsg(1617, &quot;Ignoriere Fehler in html-Cache-Description: \&quot;&lt;img\&quot; without \&quot;src=\&quot; in cache &quot;+chD.wayPoint));
-							continue;
-						}
-						inf.setInfo(MyLocale.getMsg(1611,&quot;Importing cache description:&quot;)+&quot; &quot; + numDescImported + &quot;\n&quot;+MyLocale.getMsg(1620, &quot;downloading embedded images: &quot;) + numDownloaded++);
-						if (imgRegexAlt.search(imgTag)) {
-							imgAltText=imgRegexAlt.stringMatched(1);
-							if (imgAltText==null)	imgAltText=imgRegexAlt.stringMatched(2);
-							// kein alternativer Text als Bild&#252;berschrift -&gt; Dateiname
-						} else { 
-							if (fetchUrl.toLowerCase().indexOf(&quot;opencaching.de&quot;) &gt; 0 || fetchUrl.toLowerCase().indexOf(&quot;geocaching.com&quot;) &gt; 0) //wenn von Opencaching oder geocaching ist Dateiname doch nicht so toll, weil nur aus Nummer bestehend 
-								imgAltText = new String(&quot;No image title&quot;);
-							else imgAltText = fetchUrl.substring(fetchUrl.lastIndexOf(&quot;/&quot;)+1);
-						}
-						descIndex = imgRegexUrl.matchedTo();
-						getPic(fetchUrl, imgAltText);
-					}
-				}
-				chD.hasUnsavedChanges = true; //saveCacheDetails(profile.dataDir);
-				return;
-			}
-
-
-			if (name.equals(&quot;cacheid&quot;)){
-				// load cachedata
-				chD = getHolder(strData);
-				chD.is_update = true;
-				return;
-			}
-
-			if (name.equals(&quot;shortdesc&quot;)){
-				chD.LongDescription = strData;
-				return;
-			}
-
-			if (name.equals(&quot;desc&quot;)){ // &lt;/desc&gt;
-				if (chD.is_HTML)	chD.LongDescription +=SafeXML.cleanback(strData);
-				else chD.LongDescription +=strData;
-				return;
-			}
-			if (name.equals(&quot;hint&quot;)){
-				chD.Hints = Common.rot13(strData);
-				return;
-			}
-		}
-	}
-
-	private String createPicFilename(String fetchURL) {
-		String fileName = chD.wayPoint + &quot;_&quot; + fetchURL.substring(fetchURL.lastIndexOf(&quot;/&quot;)+1);
-		return Common.ClearForFileName(fileName);
-	}
-	
-	private void getPic(String fetchURL, String picDesc) { // TODO handling of relativ URLs
-		try {
-			if (!fetchURL.startsWith(&quot;<A HREF="http://">http://</A>&quot;)) fetchURL = new URL(new URL(&quot;<A HREF="http://">http://</A>&quot; + OPENCACHING_HOST+&quot;/&quot;), fetchURL).toString(); // TODO this is not quite correct: actually the &quot;base&quot; URL must be known... but anyway a different baseURL should not happen very often  - it doesn't in my area
-			String fileName = createPicFilename(fetchURL);
-			// add title
-			chD.ImagesText.add(picDesc);
-			chD.ImagesInfo.add(null); // need to stay in sync with ImagesText
-			try {
-				File ftest = new File(profile.dataDir + fileName);
-				if (ftest.exists()){
-					chD.Images.add(fileName);
-				}
-				else {
-					if (pref.downloadPicsOC) {
-						chD.Images.add(fetch(fetchURL, fileName));
-					}
-				}
-			} catch (IOException e) {
-				String ErrMessage = new String (MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;) + chD.wayPoint + &quot;: ignoring IOException: &quot;+e.getMessage()+ &quot; while downloading picture:&quot;+fileName+&quot; from URL:&quot;+fetchURL); 
-				if (e.getMessage().toLowerCase().equalsIgnoreCase(&quot;could not connect&quot;) ||
-						e.getMessage().equalsIgnoreCase(&quot;unkown host&quot;)) { // is there a better way to find out what happened?
-					ErrMessage = MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;)+chD.CacheName + &quot; (&quot;+chD.wayPoint+&quot;)&quot;+MyLocale.getMsg(1619,&quot;: could not download image from URL: &quot;)+fetchURL;
-				} 
-				inf.addWarning(&quot;\n&quot;+ErrMessage);
-				//(new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), ErrMessage, MessageBox.OKB)).exec();
-				pref.log(ErrMessage);
-				e.printStackTrace();
-			}
-		} catch (MalformedURLException e) {
-			String ErrMessage = new String (MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;) + chD.wayPoint + &quot;: ignoring MalformedUrlException: &quot; + e.getMessage()+ &quot; while downloading from URL:&quot; + fetchURL); 
-			inf.addWarning(&quot;\n&quot;+ErrMessage);
-			pref.log(ErrMessage);
-		}
-
-	}
-
-
-	private void endPicture(String name){
-
-		if(name.equals(&quot;id&quot;)){
-			picID = strData;
-			return;
-		}
-
-		if (name.equals(&quot;url&quot;)){
-			picUrl = strData;
-			return;
-		}
-		if (name.equals(&quot;title&quot;)){
-			picTitle = strData;
-			return;
-		}
-		if(name.equals(&quot;object&quot;)){
-			// get cachedata
-			chD = getHolder(strData);
-			return;
-		}
-		if(name.equals(&quot;picture&quot;)){ 
-			//String fileName = holder.wayPoint + &quot;_&quot; + picUrl.substring(picUrl.lastIndexOf(&quot;/&quot;)+1);
-			getPic(picUrl,picTitle);
-			chD.hasUnsavedChanges = true; //saveCacheDetails(profile.dataDir);
-			return;
-		}
-	}
-
-	private void endCacheLog(String name){
-		if (name.equals(&quot;cachelog&quot;)){ // &lt;/cachelog&gt;
-			chD.CacheLogs.merge(new Log(logIcon, logDate, logFinder, logData, loggerRecommended));
-			chD.hasUnsavedChanges = true; //chD.saveCacheDetails(profile.dataDir);
-			return;
-		}
-
-		if (name.equals(&quot;cacheid&quot;)){ // &lt;/cacheid&gt;
-			// load cachedata
-			chD = getHolder(strData);
-			return;
-		}
-
-		if (name.equals(&quot;date&quot;))  {
-			logDate = new String(strData);
-			if (chD.is_found) {
-				chD.CacheStatus=strData.substring(0,10);
-			}
-			return;
-		}
-		if (name.equals(&quot;userid&quot;)){
-			logFinder = new String(strData);
-			if((logFinder.toLowerCase().compareTo(user) == 0 || logFinder.equalsIgnoreCase(pref.myAlias2)) &amp;&amp; logtype == 1){
-				chD.is_found = true; // see startCacheLog - in the current .xml this is set by startCacheLog but we sequence in the xml from opencaching might change, so I leave this also here
-				chD.CacheStatus = MyLocale.getMsg(318,&quot;Found&quot;);
-			}
-			return;
-		}
-		if (name.equals(&quot;text&quot;)){ 
-			logData = new String(strData);
-			return;
-		}
-
-	}
-
-	private String fetch(String addr, String fileName ) throws IOException
-	{
-		//Vm.debug(&quot;Redirect: &quot; + redirect);
-		CharArray realurl = new CharArray();
-		ByteArray daten = UrlFetcher.fetchByteArray(addr, realurl);
-		String address = realurl.toString();
-		if (chD != null) fileName = chD.wayPoint + &quot;_&quot; + Common.ClearForFileName(address.substring(address.lastIndexOf(&quot;/&quot;)+1));
-		// else fileName = Common.ClearForFileName(address.substring(address.lastIndexOf(&quot;/&quot;)+1));
-
-		//save file
-		//Vm.debug(&quot;Save: &quot; + myPref.mydatadir + fileName);
-		//Vm.debug(&quot;Daten: &quot; + daten.length);
-		FileOutputStream outp =  new FileOutputStream(profile.dataDir + fileName);
-		outp.write(daten.toBytes());
-		outp.close();
-		return fileName;
-	}
-
-
-	/**
-	 *	Method to translate opencaching size types to geocaching types.
-	 *	Required to be &quot;backwards&quot; compatible :-(
-	 *	OC	GC	Comment	Rule
-	 *	1	5	other size	1-&gt;5
-	 *	2 	1	micro		2-&gt;1
-	 *	3 	2	small		3-&gt;2
-	 *	4	3	normal		4-&gt;3
-	 *	5 	4	large		5-&gt;4
-	 *	6	6	very large	6-&gt;6
-	 *	7	7	no container	7-&gt;7
-	 */
-	private String transSize(String type){
-		if(type.equals(&quot;1&quot;)) return &quot;Other&quot;;
-		if(type.equals(&quot;2&quot;)) return &quot;Micro&quot;;
-		if(type.equals(&quot;3&quot;)) return &quot;Small&quot;;
-		if(type.equals(&quot;4&quot;)) return &quot;Regular&quot;;
-		if(type.equals(&quot;5&quot;)) return &quot;Large&quot;;
-		if(type.equals(&quot;6&quot;)) return &quot;Very Large&quot;;
-		if(type.equals(&quot;7&quot;)) return &quot;None&quot;;
-		return &quot;0&quot;;
-	}
-
-	/**
-	 * Method to iterate through cache database and look for waypoint.
-	 * Returns value &gt;= 0 if waypoint is found, else -1
-	 */
-	private int searchWpt(String wpt){
-		Integer INTR = (Integer)DBindexWpt.get(wpt);
-		if(INTR != null){
-			return INTR.intValue();
-		} else return -1;
-	}
-
-	/**
-	 * Method to iterate through cache database and look for cacheID.
-	 * Returns value &gt;= 0 if cacheID is found, else -1
-	 */
-	private int searchID(String cacheID){
-		Integer INTR = (Integer)DBindexID.get(cacheID);
-		if(INTR != null){
-			return INTR.intValue();
-		} else return -1;
-	}
-
-
-	private CacheHolderDetail getHolder(String wpt){// See also LOCXMLImporter
-		int index;
-		
-		index = searchWpt(wpt);
-		if (index ==-1) index = searchID(wpt);
-		if (index == -1) {
-			chD = new CacheHolderDetail();
-			return chD;
-		}
-		chD = ((CacheHolder) cacheDB.get(index)).getCacheDetails(true);
-/*		try {
-			chD.readCache(profile.dataDir);
-		} catch (Exception e) {Vm.debug(&quot;Could not open file: &quot; + e.toString());};
-	*/	return chD;
-	}
-
-
-}
\ No newline at end of file

Deleted: experiments/engywuck/hist-test/src/cachewolf/OCXMLImporterScreen.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/OCXMLImporterScreen.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/OCXMLImporterScreen.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,96 +0,0 @@
-/**
- * 
- */
-package CacheWolf;
-
-import ewe.ui.*;
-
-/**
- * @author pfeffer
- * This Class is the Dialog for Download from Opencaching.de 
- * is called from OCXMLImporter
- * 20061209 Bugfix: Checking for uninitialised missingCheckBox
- */
-public class OCXMLImporterScreen extends Form {
-	mButton cancelB, okB;
-	Preferences pref;
-	mInput distanceInput;
-	mCheckBox imagesCheckBox, /*mapsCheckBox, */ missingCheckBox, foundCheckBox;
-	mLabel distLbl;
-	mLabel distUnit;
-	static int DIST = 1;
-	static int IMAGES = 2;
-	static int ALL = 4;
-	static int INCLUDEFOUND = 8;
-	static int ISGC = 16;
-
-	
-	public OCXMLImporterScreen(String title, int options) {
-		super();
-		pref = Global.getPref(); // myPreferences sollte sp&#228;ter auch diese Einstellungen speichern
-		
-		this.title = title;
-		if ((options &amp; DIST) &gt; 0) {
-			this.addNext(distLbl = new mLabel(MyLocale.getMsg(1601,&quot;Distance:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			distanceInput = new mInput();
-			String dist1;
-			String dist2;
-			if ((options &amp; ISGC) &gt; 0) {
-				dist1 = Global.getProfile().distGC;
-				dist2 = Global.getProfile().distOC;
-			} else {
-				dist1 = Global.getProfile().distOC;
-				dist2 = Global.getProfile().distGC;
-			}
-			if ( dist1.equals(&quot;&quot;) || dist1.equals(&quot;0&quot;) || dist1.equals(&quot;0.0&quot;) ) {
-				dist1 = dist2;
-			}
-			distanceInput.setText(dist1);
-			this.addNext(distanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			this.addLast(distUnit = new mLabel(&quot; km&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		}
-
-		if ((options &amp; IMAGES) &gt; 0) {
-			imagesCheckBox = new mCheckBox();
-			imagesCheckBox.setText(MyLocale.getMsg(1602,&quot;Download Images&quot;));
-			imagesCheckBox.setState(true); // @ToDo: aus Prefs
-			this.addLast(imagesCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
-		}
-		if((options &amp; INCLUDEFOUND) &gt; 0){
-			foundCheckBox = new mCheckBox();
-			foundCheckBox.setText(MyLocale.getMsg(1622,&quot;Exclude found caches&quot;));
-			foundCheckBox.setState(true);
-			this.addLast(foundCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
-		}
-
-		if((options &amp; ALL) &gt; 0){
-			missingCheckBox = new mCheckBox();
-			missingCheckBox.setText(MyLocale.getMsg(1606,&quot;Alle erneut downloaden&quot;));
-			missingCheckBox.setState(false); // @ToDo: aus Prefs
-			this.addLast(missingCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
-		}
-
-		cancelB = new mButton(MyLocale.getMsg(1604,&quot;Cancel&quot;));
-		cancelB.setHotKey(0, IKeys.ESCAPE);
-		this.addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		okB = new mButton(MyLocale.getMsg(1605,&quot;OK&quot;));
-		okB.setHotKey(0, IKeys.ACTION);
-		okB.setHotKey(0, IKeys.ENTER);
-		this.addLast(okB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-	}
-	public void onEvent(Event ev){
-		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelB){
-				this.close(FormBase.IDCANCEL);
-			}
-			if (ev.target == okB){
-				    // distOC wird hier noch nicht in Pref eingetragen, damit noch gepr&#252;ft werden kann, ob es gr&#246;&#223;er oder kleiner ist als vorher
-					if (imagesCheckBox!=null) pref.downloadPicsOC = imagesCheckBox.state;
-					if (missingCheckBox!=null) pref.downloadmissingOC = missingCheckBox.state;
-					// TODO: sofort speichern?
-				this.close(FormBase.IDOK);
-				}
-		}
-		super.onEvent(ev);
-	}
-}

Deleted: experiments/engywuck/hist-test/src/cachewolf/ProfileDataForm.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/ProfileDataForm.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/ProfileDataForm.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,88 +0,0 @@
-package CacheWolf;
-
-
-import ewe.ui.*;
-
-/**
-*	This form displays profile specific data.
-*	It allows the copying of the current centre to the profile centre
-*/
-public class ProfileDataForm extends Form {
-
-	private mButton btnOK, btnCurrentCentre, btnProfileCentre, btnCur2Prof, btnProf2Cur;
-	Preferences pref;
-	Profile profile;
-	CellPanel content = new CellPanel();
-
-	/**
-	*/
-	public ProfileDataForm(Preferences p, Profile prof){
-		super();
-		pref=p;
-		profile=prof;
-		
-    	resizable =  false;
-		content.setText(MyLocale.getMsg(1115,&quot;Centre&quot;));
-		content.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_RECT;
-	    //defaultTags.set(this.INSETS,new Insets(2,2,2,2));		
-		title = MyLocale.getMsg(1118,&quot;Profile&quot;)+&quot;: &quot;+profile.name;
-		content.addNext(new mLabel(MyLocale.getMsg(1116,&quot;Current&quot;)));
-		content.addLast(btnCurrentCentre=new mButton(pref.curCentrePt.toString()),HSTRETCH,HFILL|LEFT);
-		content.addNext(new mLabel(&quot;      &quot;),HSTRETCH,HFILL);
-		content.addNext(btnCur2Prof=new mButton(&quot;   v   &quot;),DONTSTRETCH,DONTFILL|LEFT);
-		content.addNext(new mLabel(MyLocale.getMsg(1117,&quot;copy&quot;)));
-		content.addLast(btnProf2Cur=new mButton(&quot;   ^   &quot;),DONTSTRETCH,DONTFILL|RIGHT);
-		content.addNext(new mLabel(MyLocale.getMsg(1118,&quot;Profile&quot;)));
-		content.addLast(btnProfileCentre=new mButton(profile.centre.toString()),HSTRETCH,HFILL|LEFT);
-		addLast(content,HSTRETCH,HFILL);
-		addLast(new mLabel(&quot;&quot;),VSTRETCH,FILL);
-		//addNext(btnCancel = new mButton(MyLocale.getMsg(1604,&quot;Cancel&quot;)),DONTSTRETCH,DONTFILL|LEFT);
-		addLast(btnOK = new mButton(&quot;OK&quot;),DONTSTRETCH,HFILL|RIGHT);
-	}
-	
-	/**
-	*	The event handler to react to a users selection.
-	*	A return value is created and passed back to the calling form
-	*	while it closes itself.
-	*/
-	public void onEvent(Event ev){
-		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
-			/*if (ev.target == btnCancel){
-				close(-1);
-			}*/
-			if (ev.target == btnOK){
-				close(1);
-			}
-			if (ev.target == btnCurrentCentre){
-				CoordsScreen cs = new CoordsScreen();
-				cs.setFields(pref.curCentrePt, CWPoint.CW);
-				if (cs.execute()== FormBase.IDOK){
-					pref.curCentrePt.set(cs.getCoords());
-					btnCurrentCentre.setText(pref.curCentrePt.toString());
-					Global.getProfile().updateBearingDistance();
-				}
-			}
-			if (ev.target == btnProfileCentre){
-				CoordsScreen cs = new CoordsScreen();
-				cs.setFields(profile.centre, CWPoint.CW);
-				if (cs.execute()== FormBase.IDOK){
-					profile.centre.set(cs.getCoords());
-					btnProfileCentre.setText(profile.centre.toString());
-					profile.hasUnsavedChanges=true;
-				}
-			}
-			if (ev.target == btnCur2Prof){
-				profile.centre.set(pref.curCentrePt);
-				btnProfileCentre.setText(profile.centre.toString());
-				profile.hasUnsavedChanges=true;
-			}
-			if (ev.target == btnProf2Cur){
-				pref.curCentrePt.set(profile.centre);
-				btnCurrentCentre.setText(pref.curCentrePt.toString());
-				Global.getProfile().updateBearingDistance();
-			}
-		}
-		super.onEvent(ev);
-	}
-
-}

Deleted: experiments/engywuck/hist-test/src/cachewolf/RadarPanelImage.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/RadarPanelImage.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/RadarPanelImage.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,21 +0,0 @@
-package CacheWolf;
-import ewe.graphics.*;
-import ewe.fx.*;
-
-/**
-* The ImagePanelImage extends AniImage by a fileName.
-* This is an easy way to identify the image clicked,
-* what is needed to display the full image from the
-* thumbnail.
-*/
-public class RadarPanelImage extends AniImage{
-	public String wayPoint = new String();
-	public int rownum;
-	
-	public RadarPanelImage(mImage i){
-		super(i);
-	}
-	public RadarPanelImage(Image i){
-		super(i);
-	}
-}

Deleted: experiments/engywuck/hist-test/src/cachewolf/Rebuild.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/Rebuild.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/Rebuild.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,107 +0,0 @@
-package CacheWolf;
-
-import ewe.io.FileReader;
-import ewe.sys.Handle;
-import ewe.ui.FormBase;
-import ewe.ui.MessageBox;
-import ewe.ui.ProgressBarForm;
-import utils.FileBugfix;
-
-public class Rebuild {
-	String [] xmlFiles;
-	
-	public Rebuild() {}
-	
-	public void rebuild() {	
-		int i;
-		Profile prof=Global.getProfile();
-		
-		myProgressBarForm pbf = new myProgressBarForm();
-		Handle h = new Handle();
-		pbf.setTask(h,MyLocale.getMsg(209,&quot;Rebuilding index&quot;));
-		pbf.exec();
-
-		FileBugfix file=new FileBugfix(Global.getProfile().dataDir);
-		xmlFiles=file.list(&quot;*.xml&quot;,0);
-		int orphans=0; // xml Files without entry in database
-		int nAdded=0;  // caches added to database
-		for (i=0; i&lt;xmlFiles.length; i++) {
-			int pos=xmlFiles[i].lastIndexOf('.');
-			if (pos&lt;0) continue;
-			String wayPoint=xmlFiles[i].substring(0,pos).toUpperCase();
-			if (wayPoint.equalsIgnoreCase(&quot;index&quot;) || 			// Check for index.xml and index.bak
-				prof.getCacheIndex(wayPoint)&gt;=0)		// Check for waypoints already in database 
-				xmlFiles[i]=null;   				// Remove existing caches or index.xml
-			else {
-				//ewe.sys.Vm.debug(&quot;Orphan: &quot;+wayPoint);
-				orphans++;
-			}
-		}
-		if (orphans&gt;0) { // At least one cache not in database
-			int nProcessed=0;
-			// Now do the actual work
-			for(i = 0; i&lt;xmlFiles.length; i++){
-				if (xmlFiles[i]!=null) {
-					h.progress = ((float)nProcessed++)/(float)(orphans);
-					h.changed();
-					String details=getCacheDetails(prof.dataDir+xmlFiles[i]);
-					if (details!=null) { // In older Versions of CW the &lt;CACHE... /&gt; line was not stored in the cache.xml
-						CacheHolder ch=new CacheHolder(details);
-						prof.cacheDB.add(ch);
-						nAdded++;
-						xmlFiles[i]=null;
-					} else Global.getPref().log(&quot;File &quot;+xmlFiles[i]+&quot; not in index.xml&quot;);
-				}
-				if (pbf.isClosed) break;
-			}
-			(new MessageBox(MyLocale.getMsg(327, &quot;Information&quot;), 
-					  MyLocale.getMsg(210,&quot;Caches nicht in index.xml: &quot;)+orphans+
-					  MyLocale.getMsg(211,&quot;\nDavon hinzugef&#252;gt: &quot;)+nAdded
-					, FormBase.OKB)).execute();
-			prof.buildReferences();
-			prof.saveIndex(Global.getPref(),true);
-		}
-		if (orphans!=nAdded &amp;&amp; (new MessageBox(MyLocale.getMsg(327, &quot;Information&quot;),
-					MyLocale.getMsg(212,&quot;Delete all .xml files not in index.xml and associated pictures&quot;), 
-					FormBase.YESB | FormBase.NOB)).execute()==FormBase.YESB) {
-			h = new Handle();
-			pbf.setTask(h,MyLocale.getMsg(213,&quot;Deleting orphans&quot;));
-			DataMover dm=new DataMover();
-			int nDeleted=0;
-			for (i=0; i&lt;xmlFiles.length; i++) {
-				if (xmlFiles[i]!=null){	
-					h.progress = ((float)nDeleted++)/(float)(orphans-nAdded);
-					h.changed();
-					String wayPoint=xmlFiles[i].substring(0,xmlFiles[i].indexOf('.'));
-					dm.deleteCacheFiles(wayPoint,prof.dataDir);
-				}
-			}
-		}
-		pbf.exit(0);
-	}
-
-	private String getCacheDetails(String xmlFile) {
-		try {
-			FileReader in = new FileReader(xmlFile);
-			String text= in.readAll();
-			in.close();
-			int start,end;
-			// Check that we have not accidentally listed another xml file in the directory
-			if (text.indexOf(&quot;&lt;CACHEDETAILS&gt;&quot;)&lt;0 || (start=text.indexOf(&quot;&lt;CACHE &quot;))&lt;0) return null;
-			end=text.indexOf(&quot;/&gt;&quot;,start);
-			return text.substring(start,end+2);
-		} catch (Exception ex) {
-			return null;
-		}
-	}
-
-	class myProgressBarForm extends ProgressBarForm {
-		 boolean isClosed=false;
-		 protected boolean canExit(int exitCode) {
-			isClosed=true;
-			return true;
-		 }
-	 }
-	 
-	
-}

Copied: experiments/engywuck/hist-test/src/cachewolf/RebuildIndex.java (from rev 1559, experiments/engywuck/hist-test/src/cachewolf/Rebuild.java)


Property changes on: experiments/engywuck/hist-test/src/cachewolf/RebuildIndex.java
___________________________________________________________________
Name: svn:keywords
   + LastChangedRevision
Name: svn:mergeinfo
   + 

Deleted: experiments/engywuck/hist-test/src/cachewolf/Reducer.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/Reducer.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/Reducer.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,55 +0,0 @@
-package CacheWolf;
-import ewe.util.*;
-
-/**
-*	Class to reduce a string to its main components,
-*	so that a human may still understand what it means.
-*	This is usefull for displaying cache names in a GPSR
-*	or for POIs in a navigation software.
-*
-*	The idea is:
-*	1) Throw out all 3 letter words,
-*	2) Remove all vowels from a word, except if it is
-*      the first letter of a word
-*	3) Remove all Whitespace
-*	4) If requested truncate the string to a given number of
-*	   characters.
-*/
-public class Reducer{
-	
-	public static String convert(String origStr, boolean trun, int len){
-		String[] parts = mString.split(origStr, ' ');
-		String dummy = new String();
-		String finalStr = new String();
-		for(int i = 0; i &lt; parts.length; i++){
-			if(parts[i].length() != 3){
-				dummy = removeVow(parts[i]);
-				finalStr = finalStr + dummy;
-			}
-		}//for
-		//Vm.debug(Convert.toString(trun));
-		if(trun == true){
-			finalStr = finalStr + &quot;                                         &quot;;
-			finalStr = finalStr.substring(0,len);
-			//Vm.debug(finalStr);
-		}
-		return finalStr;
-	}
-	
-	private static String removeVow(String str){
-		String dummy = str.substring(1);
-		dummy = STRreplace.replace(dummy,&quot;a&quot;, &quot;&quot;);
-		dummy = STRreplace.replace(dummy,&quot;e&quot;, &quot;&quot;);
-		dummy = STRreplace.replace(dummy,&quot;i&quot;, &quot;&quot;);
-		dummy = STRreplace.replace(dummy,&quot;o&quot;, &quot;&quot;);
-		dummy = STRreplace.replace(dummy,&quot;u&quot;, &quot;&quot;);
-		dummy = STRreplace.replace(dummy,&quot;A&quot;, &quot;&quot;);
-		dummy = STRreplace.replace(dummy,&quot;E&quot;, &quot;&quot;);
-		dummy = STRreplace.replace(dummy,&quot;I&quot;, &quot;&quot;);
-		dummy = STRreplace.replace(dummy,&quot;O&quot;, &quot;&quot;);
-		dummy = STRreplace.replace(dummy,&quot;U&quot;, &quot;&quot;);
-		dummy = STRreplace.replace(dummy,&quot;,&quot;,&quot;&quot;);
-		dummy = str.substring(0,1) + dummy;
-		return dummy;
-	}
-}

Deleted: experiments/engywuck/hist-test/src/cachewolf/SpiderGC.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/SpiderGC.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/SpiderGC.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,1481 +0,0 @@
-/*
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
-
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-		<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation version 2 of the License.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
-
-package CacheWolf;
-import ewe.net.*;
-import ewe.io.*;
-import ewe.sys.*;
-import ewe.sys.Double;
-import ewe.util.*;
-import com.stevesoft.ewe_pat.*;
-import ewe.ui.*;
-import ewe.data.Property;
-import ewe.data.PropertyList;
-
-/**
-*	Class to spider caches from gc.com
-*/
-public class SpiderGC{
-
-	/**
-	 * The maximum number of logs that will be stored
-	 */
-	public static int MAXLOGS=250; // Can be pre-set from preferences
-	public static String passwort = &quot;&quot;; // Can be pre-set from preferences
-	public static boolean loggedIn = false;
-
-	private static int ERR_LOGIN = -10;
-	private static Preferences pref;
-	private Profile profile;
-	private static String viewstate = &quot;&quot;;
-	private static String eventvalidation = &quot;&quot;;
-	private static String cookieID = &quot;&quot;;
-	private static String cookieSession = &quot;&quot;;
-	private static double distance = 0;
-	private Regex inRex = new Regex();
-	private Vector cacheDB;
-	private Vector cachesToLoad = new Vector();
-	private Hashtable indexDB;
-	private InfoBox infB;
-	private static myProperties p=null;
-
-	public SpiderGC(Preferences prf, Profile profile, boolean bypass){
-		this.profile=profile;
-		this.cacheDB = profile.cacheDB;
-		pref = prf;
-		if (p==null) {
-			pref.logInit();
-			p=new myProperties();
-		}
-		MAXLOGS=pref.maxLogsToSpider;
-	}
-
-	/**
-	 * Method to login the user to gc.com
-	 * It will request a password and use the alias defined in preferences
-	 * If the login page cannot be fetched, the password is cleared.
-	 * If the login fails, an appropriate message is displayed.
-	 */
-	public int login(){
-		loggedIn = false;
-		String start,loginPage,loginSuccess,nextPage;
-		try {
-			loginPage=p.getProp(&quot;loginPage&quot;);
-			loginSuccess=p.getProp(&quot;loginSuccess&quot;);
-			nextPage=p.getProp(&quot;nextPage&quot;);
-		} catch (Exception ex) { // Tag not found in spider.def
-			return ERR_LOGIN;
-		}
-		//Get password
-		InfoBox infB = new InfoBox(MyLocale.getMsg(5506,&quot;Password&quot;), MyLocale.getMsg(5505,&quot;Enter Password&quot;), InfoBox.INPUT);
-		infB.feedback.setText(passwort); // Remember the PWD for next time
-		infB.feedback.isPassword=true;
-		int code = infB.execute();
-		passwort = infB.getInput();
-		infB.close(0);
-		if(code != FormBase.IDOK) return code;
-
-		// Now start the login proper
-		infB = new InfoBox(MyLocale.getMsg(5507,&quot;Status&quot;), MyLocale.getMsg(5508,&quot;Logging in...&quot;));
-		infB.exec();
-		try{
-			pref.log(&quot;[login]:Fetching login page&quot;);
-			//Access the page once to get a viewstate
-			start = fetch(loginPage);   //<A HREF="http://www.geocaching.com/login/Default.aspx">http://www.geocaching.com/login/Default.aspx</A>
-			if (start.equals(&quot;&quot;)) {
-				infB.close(0);
-				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5499,&quot;Error loading login page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
-				pref.log(&quot;[login]:Could not fetch: gc.com login page&quot;);
-				return ERR_LOGIN;
-			}
-		} catch(Exception ex){
-			infB.close(0);
-			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5499,&quot;Error loading login page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
-			pref.log(&quot;[login]:Could not fetch: gc.com login page&quot;,ex);
-			return ERR_LOGIN;
-		}
-		if (!infB.isClosed) { // If user has not aborted, we continue
-			Regex rexCookieID = new Regex(&quot;(?i)Set-Cookie: userid=(.*?);.*&quot;);
-			Regex rexViewstate = new Regex(&quot;id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
-			Regex rexEventvalidation = new Regex(&quot;id=\&quot;__EVENTVALIDATION\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
-			Regex rexCookieSession = new Regex(&quot;(?i)Set-Cookie: ASP.NET_SessionId=(.*?);.*&quot;);
-			rexViewstate.search(start);
-			if(rexViewstate.didMatch()){
-				viewstate = rexViewstate.stringMatched(1);
-				//Vm.debug(&quot;ViewState: &quot; + viewstate);
-			} else
-				pref.log(&quot;[login]:Viewstate not found before login&quot;);
-			
-			if(start.indexOf(loginSuccess) &gt; 0)
-				pref.log(&quot;[login]:Already logged in&quot;);
-			else {
-				rexEventvalidation.search(start);
-				if(rexEventvalidation.didMatch()){
-					eventvalidation = rexEventvalidation.stringMatched(1);
-					//Vm.debug(&quot;EVENTVALIDATION: &quot; + eventvalidation);
-				} else
-					pref.log(&quot;[login]:Eventvalidation not found before login&quot;);
-				//Ok now login!
-				try{
-					pref.log(&quot;[login]:Logging in as &quot;+pref.myAlias);
-					StringBuffer sb=new StringBuffer(1000);
-					sb.append(URL.encodeURL(&quot;__VIEWSTATE&quot;,false));	sb.append(&quot;=&quot;); sb.append(URL.encodeURL(viewstate,false));
-					sb.append(&quot;&amp;&quot;); sb.append(URL.encodeURL(&quot;myUsername&quot;,false));
-					sb.append(&quot;=&quot;); sb.append(encodeUTF8URL(Utils.encodeJavaUtf8String(pref.myAlias)));
-					sb.append(&quot;&amp;&quot;); sb.append(URL.encodeURL(&quot;myPassword&quot;,false));
-					sb.append(&quot;=&quot;); sb.append(encodeUTF8URL(Utils.encodeJavaUtf8String(passwort)));
-					sb.append(&quot;&amp;&quot;); sb.append(URL.encodeURL(&quot;cookie&quot;,false));
-					sb.append(&quot;=&quot;); sb.append(URL.encodeURL(&quot;on&quot;,false));
-					sb.append(&quot;&amp;&quot;); sb.append(URL.encodeURL(&quot;Button1&quot;,false));
-					sb.append(&quot;=&quot;); sb.append(URL.encodeURL(&quot;Login&quot;,false));
-					sb.append(&quot;&amp;&quot;); sb.append(URL.encodeURL(&quot;__EVENTVALIDATION&quot;,false));
-					sb.append(&quot;=&quot;); sb.append(URL.encodeURL(eventvalidation,false));
-					start = fetch_post(loginPage, sb.toString(), nextPage);  // /login/default.aspx
-					if(start.indexOf(loginSuccess) &gt; 0)
-						pref.log(&quot;[login]:Login successful&quot;);
-					else {
-						pref.log(&quot;[login]:Login failed. Wrong Account or Password?&quot;);
-						if (pref.debug) {
-							pref.log(&quot;[login.LoginUrl]:&quot;+sb.toString());
-							pref.log(&quot;[login.Answer]:&quot;+start);
-						}
-						infB.close(0);
-						(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5501,&quot;Login failed! Wrong account or password?&quot;), FormBase.OKB)).execute();
-						return ERR_LOGIN;
-					}
-				}catch(Exception ex){
-					pref.log(&quot;[login]:Login failed with exception.&quot;, ex);
-					infB.close(0);
-					(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5501,&quot;Login failed. Error loading page after login.&quot;), FormBase.OKB)).execute();
-					return ERR_LOGIN;
-				}
-			}
-
-			rexViewstate.search(start);
-			if (!rexViewstate.didMatch()) {
-				pref.log(&quot;[login]:Viewstate not found&quot;);
-			}
-			viewstate = rexViewstate.stringMatched(1);
-			rexCookieID.search(start);
-			if (!rexCookieID.didMatch()) {
-				pref.log(&quot;[login]:CookieID not found. Using old one.&quot;);
-			} else
-				cookieID = rexCookieID.stringMatched(1);
-			//Vm.debug(cookieID);
-			rexCookieSession.search(start);
-			if (!rexCookieSession.didMatch()) {
-				pref.log(&quot;[login]:CookieSession not found. Using old one.&quot;);
-				//cookieSession=&quot;&quot;;
-			} else
-				cookieSession = rexCookieSession.stringMatched(1);
-			//Vm.debug(&quot;cookieSession = &quot; + cookieSession);
-		}
-		boolean loginAborted=infB.isClosed;
-		infB.close(0);
-		if (loginAborted)
-			return FormBase.IDCANCEL;
-		else {
-			loggedIn = true;
-			return FormBase.IDOK;
-		}
-	}
-
-	/**
-	 * Method to spider a single cache.
-	 * It assumes a login has already been performed!
-	 * @return 1 if spider was successful, -1 if spider was cancelled by closing the infobox, 0 error, but continue with next cache
-	 */
-	public int spiderSingle(int number, InfoBox infB, boolean forceLogin){
-		int ret=-1;
-		this.infB = infB;
-		CacheHolder ch = (CacheHolder)cacheDB.get(number);
-		if (ch.isAddiWpt()) return -1;  // No point re-spidering an addi waypoint, comes with parent
-
-		// check if we need to login
-		if (!loggedIn || forceLogin){
-			if (this.login()!=FormBase.IDOK) return -1;
-			// loggedIn is already set by this.login()
-		}
-		CacheHolderDetail chD=ch.getCacheDetails(true); //new CacheHolderDetail(ch);
-		try{
-/*			// Get all existing details of the cache
-			try {
-				chD.readCache(profile.dataDir);
-			} catch (IOException ioex) {
-				pref.log(&quot;No .XML file found for cache &quot;+chD.wayPoint);
-			};
-*/			// Read the cache data from GC.COM and compare to old data
-			boolean loadAllLogs = (MAXLOGS &gt; 5);
-			ret=getCacheByWaypointName(chD,true,true,false,loadAllLogs);
-			// Save the spidered data
-			if (ret == 1) {
-				pref.log(&quot;Saving to:&quot; + profile.dataDir);
-				chD.saveCacheDetails(profile.dataDir);
-				((CacheHolder) cacheDB.get(number)).update(chD);
-			}
-		}catch(Exception ex){
-			pref.log(&quot;Error spidering &quot; + chD.wayPoint + &quot; in spiderSingle&quot;);
-		}
-		return ret;
-	} // spiderSingle
-
-	/**
-	 * Fetch the coordinates of a waypoint from GC
-	 * @param wayPoint the name of the waypoint
-	 * @return the cache coordinates
-	 */
-	public String getCacheCoordinates(String wayPoint) {
-		String completeWebPage;
-		// Check whether spider definitions could be loaded, if not issue appropriate message and terminate
-		// Try to login. If login fails, issue appropriate message and terminate
-		if (!loggedIn || Global.getPref().forceLogin) {
-			if (login()!=FormBase.IDOK) {
-				return &quot;&quot;;
-			}
-		}
-		InfoBox infB = new InfoBox(&quot;Info&quot;, &quot;Loading&quot;, InfoBox.PROGRESS_WITH_WARNINGS);
-		infB.exec();
-		try{
-			String doc = p.getProp(&quot;waypoint&quot;) + wayPoint;
-			pref.log(&quot;Fetching: &quot; + wayPoint);
-			completeWebPage = fetch(doc);
-		}catch(Exception ex){
-			infB.close(0);
-			pref.log(&quot;Could not fetch &quot; + wayPoint,ex);
-			return &quot;&quot;;
-		}
-		infB.close(0);
-		try {
-			return getLatLon(completeWebPage);
-		} catch (Exception ex) {
-			return &quot;????&quot;;
-		}
-	}
-
-	/**
-	*	Method to start the spider for a search around the centre coordinates
-	*/
-	public void doIt(){
-		String postStr, dummy, ln, wpt;
-		Regex lineRex;
-		CacheHolderDetail chD;
-		CWPoint origin = pref.curCentrePt; // No need to copy curCentrePt as it is only read and not written
-		if (!origin.isValid()) {
-			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5509,&quot;Coordinates for centre must be set&quot;), FormBase.OKB)).execute();
-			return;
-		}
-		if (System.getProperty(&quot;os.name&quot;)!=null)pref.log(&quot;Operating system: &quot;+System.getProperty(&quot;os.name&quot;)+&quot;/&quot;+System.getProperty(&quot;os.arch&quot;));
-		if (System.getProperty(&quot;java.vendor&quot;)!=null)pref.log(&quot;Java: &quot;+System.getProperty(&quot;java.vendor&quot;)+&quot;/&quot;+System.getProperty(&quot;java.version&quot;));
-		// Prepare an index of caches for faster searching
-		indexDB = new Hashtable(cacheDB.size());
-		CacheHolder ch;
-		//index the database for faster searching!
-		for(int i = 0; i&lt;cacheDB.size();i++){
-			ch = (CacheHolder)cacheDB.get(i);
-			indexDB.put(ch.wayPoint, new Integer(i));
-			ch.is_new = false;
-		}
-		String start = &quot;&quot;;
-		Regex rexViewstate = new Regex(&quot;id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*)\&quot; /&gt;&quot;);
-		Regex rexEventvalidation = new Regex(&quot;id=\&quot;__EVENTVALIDATION\&quot; value=\&quot;(.*)\&quot; /&gt;&quot;);
-		String doc = &quot;&quot;;
-
-		if (!loggedIn || Global.getPref().forceLogin) {
-			if(login() != FormBase.IDOK) return;
-		}
-
-		OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(5510,&quot;Spider Options&quot;),	OCXMLImporterScreen.INCLUDEFOUND | OCXMLImporterScreen.DIST| OCXMLImporterScreen.IMAGES| OCXMLImporterScreen.ISGC);
-		if (options.execute() == FormBase.IDCANCEL) {return; }
-		String dist = options.distanceInput.getText();
-		if (dist.length()== 0) return;
-		distance = Common.parseDouble(dist);
-		
-		//save last radius to profile
-		Double distDouble = new Double();
-		distDouble.value = distance;
-		dist = distDouble.toString(0, 1, 0).replace(',', '.');
-		profile.distGC = dist;
-
-		boolean doNotgetFound = options.foundCheckBox.getState();
-		boolean getImages = options.imagesCheckBox.getState();
-		options.close(0);
-
-		//=======
-		// Prepare list of all caches that are to be spidered
-		//=======
-		Vm.showWait(true);
-		infB = new InfoBox(&quot;Status&quot;, MyLocale.getMsg(5502,&quot;Fetching first page...&quot;));
-		infB.exec();
-		//Get first page
-		try{
-			ln = p.getProp(&quot;firstPage&quot;) + origin.getLatDeg(CWPoint.DD) + p.getProp(&quot;firstPage2&quot;) +origin.getLonDeg(CWPoint.DD);
-			if(doNotgetFound) ln = ln + &quot;&amp;f=1&quot;;
-			pref.log(&quot;Getting first page: &quot;+ln);
-			start = fetch(ln);
-			pref.log(&quot;Got first page&quot;);
-		}catch(Exception ex){
-			pref.log(&quot;Error fetching first list page&quot;,ex,true);
-			Vm.showWait(false);
-			infB.close(0);
-			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5503,&quot;Error fetching first list page.&quot;), FormBase.OKB)).execute();
-			return;
-		}
-		dummy = &quot;&quot;;
-		//String lineBlck = &quot;&quot;;
-		int page_number = 4;
-		try  {
-			lineRex = new Regex(p.getProp(&quot;lineRex&quot;)); //&quot;&lt;tr bgcolor=((?s).*?)&lt;/tr&gt;&quot;
-		} catch (Exception ex) {
-			infB.close(0);
-			Vm.showWait(false);
-			return;
-		}
-		int found_on_page = 0;
-		try {
-			//Loop till maximum distance has been found or no more caches are in the list
-			while(distance &gt; 0){
-				if (infB.isClosed) break;
-		
-				rexViewstate.search(start);
-				if(rexViewstate.didMatch()){
-					viewstate = rexViewstate.stringMatched(1);
-					//Vm.debug(&quot;ViewState: &quot; + viewstate);
-				} else {
-					viewstate = &quot;&quot;;
-					pref.log(&quot;Viewstate not found&quot;);
-				}
-				
-				rexEventvalidation.search(start);
-				if(rexEventvalidation.didMatch()){
-					eventvalidation = rexEventvalidation.stringMatched(1);
-					//Vm.debug(&quot;EVENTVALIDATION: &quot; + eventvalidation);
-				} else {
-					eventvalidation = &quot;&quot;;
-					pref.log(&quot;Eventvalidation not found&quot;);					
-				}
-
-				//Vm.debug(&quot;In loop&quot;);
-				Regex listBlockRex = new Regex(p.getProp(&quot;listBlockRex&quot;)); // &quot;&lt;table id=\&quot;dlResults\&quot;((?s).*?)&lt;/table&gt;&quot;
-				listBlockRex.search(start);
-				dummy = listBlockRex.stringMatched(1);
-				try{
-					lineRex.search(dummy);
-				}catch(NullPointerException nex){}
-				while(lineRex.didMatch()){
-					//Vm.debug(getDist(lineRex.stringMatched(1)) + &quot; / &quot; +getWP(lineRex.stringMatched(1)));
-					found_on_page++;
-					if(getDist(lineRex.stringMatched(1)) &lt;= distance){
-						String waypoint=getWP(lineRex.stringMatched(1));
-						Integer nr;
-						if((nr=(Integer)indexDB.get(waypoint)) == null){
-							cachesToLoad.add(waypoint);
-						} else {
-							pref.log(waypoint+&quot; already in DB&quot;);
-							ch=(CacheHolder) cacheDB.get(nr.intValue());
-							// If the &lt;strike&gt; tag is used, the cache is marked as unavailable or archived
-							boolean is_archived_GC=lineRex.stringMatched(1).indexOf(&quot;&lt;strike&gt;&lt;font color=\&quot;red\&quot;&gt;&quot;)!=-1;
-							boolean is_available_GC=lineRex.stringMatched(1).indexOf(&quot;&lt;strike&gt;&quot;)==-1;
-							if (ch.is_archived!=is_archived_GC) { // Update the database with the cache status
-								pref.log(&quot;Updating status of &quot;+waypoint+&quot; to &quot;+(is_archived_GC?&quot;archived&quot;:&quot;not archived&quot;));
-								ch.is_archived=is_archived_GC;
-								chD=ch.getCacheDetails(true,false);
-								ch.detailsAdded();
-							} else if (ch.is_available!=is_available_GC) { // Update the database with the cache status
-								pref.log(&quot;Updating status of &quot;+waypoint+&quot; to &quot;+(is_available_GC?&quot;available&quot;:&quot;not available&quot;));
-								ch.is_available=is_available_GC;
-								chD=ch.getCacheDetails(true,false);
-								ch.detailsAdded();
-							}
-						}
-					} else distance = 0;
-					lineRex.searchFrom(dummy, lineRex.matchedTo());
-				}
-				infB.setInfo(MyLocale.getMsg(5511,&quot;Found &quot;) + cachesToLoad.size() + MyLocale.getMsg(5512,&quot; caches&quot;));
-				if(found_on_page &lt; 20) distance = 0;
-				postStr = p.getProp(&quot;firstLine&quot;) + origin.getLatDeg(CWPoint.DD) + &quot;&amp;&quot; + origin.getLonDeg(CWPoint.DD);
-				if(doNotgetFound) postStr = postStr + p.getProp(&quot;showOnlyFound&quot;);
-				if(distance &gt; 0){
-					page_number++;
-					if(page_number &gt;= 15) page_number = 5;
-					String strNextPage;
-					if (page_number &lt; 10) {
-						strNextPage = &quot;ctl00$ContentBody$pgrTop$ctl0&quot; + page_number;
-					} else {
-						strNextPage = &quot;ctl00$ContentBody$pgrTop$ctl&quot; + page_number;
-					}
-					doc = URL.encodeURL(&quot;__EVENTTARGET&quot;,false) +&quot;=&quot;+ URL.encodeURL(strNextPage,false)
-					    + &quot;&amp;&quot; + URL.encodeURL(&quot;__EVENTARGUMENT&quot;,false) +&quot;=&quot;+ URL.encodeURL(&quot;&quot;,false)
-					    + &quot;&amp;&quot; + URL.encodeURL(&quot;__VIEWSTATE&quot;,false) +&quot;=&quot;+ URL.encodeURL(viewstate,false)
-					    + &quot;&amp;&quot; + URL.encodeURL(&quot;__EVENTVALIDATION&quot;,false) +&quot;=&quot;+ URL.encodeURL(eventvalidation,false);
-					try{
-						start = &quot;&quot;;
-						pref.log(&quot;Fetching next list page:&quot; + doc);
-						start = fetch_post(postStr, doc, p.getProp(&quot;nextListPage&quot;));
-					}catch(Exception ex){
-						//Vm.debug(&quot;Couldn't get the next page&quot;);
-						pref.log(&quot;Error getting next page&quot;);
-					}finally{
-					}
-				}
-				//Vm.debug(&quot;Distance is now: &quot; + distance);
-				found_on_page = 0;
-			}
-		} catch (Exception ex) { // Some tag missing from spider.def
-			infB.close(0);
-			Vm.showWait(false);
-			return;
-		}
-		pref.log(&quot;Found &quot; + cachesToLoad.size() + &quot; caches&quot;);
-		if (!infB.isClosed) infB.setInfo(MyLocale.getMsg(5511,&quot;Found &quot;) + cachesToLoad.size() + MyLocale.getMsg(5512,&quot; caches&quot;));
-
-		//=======
-		// Now ready to spider each cache in the list
-		//=======
-		boolean loadAllLogs = (MAXLOGS &gt; 5);
-
-		int spiderErrors = 0;
-		for(int i = 0; i&lt;cachesToLoad.size(); i++){
-			if (infB.isClosed) break;
-
-			wpt = (String)cachesToLoad.get(i);
-			// Get only caches not already available in the DB
-			if(searchWpt(wpt) == -1){
-				infB.setInfo(MyLocale.getMsg(5513,&quot;Loading: &quot;) + wpt +&quot; (&quot; + (i+1) + &quot; / &quot; + cachesToLoad.size() + &quot;)&quot;);
-				chD = new CacheHolderDetail();
-				chD.wayPoint=wpt;
-				int test = getCacheByWaypointName(chD,false,getImages,doNotgetFound,loadAllLogs);
-				if (test == -1) {
-					break;
-				} else if (test == 0) {
-					spiderErrors++;
-				} else {
-					if (!chD.is_found || !doNotgetFound ) {
-						chD.saveCacheDetails(profile.dataDir);
-						cacheDB.add(new CacheHolder(chD)); 
-					}
-				}
-			}
-		}
-		infB.close(0);
-		Vm.showWait(false);
-		if ( spiderErrors &gt; 0) {
-			new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;),spiderErrors + MyLocale.getMsg(5516,&quot; cache descriptions%0acould not be loaded.&quot;),FormBase.DEFOKB).execute();
-		}
-		Global.getProfile().saveIndex(Global.getPref(),true);
-	}
-
-	/**
-	 * Read a complete cachepage from geocaching.com including all logs. This is used both when
-	 * updating already existing caches (via spiderSingle) and when spidering around a centre. It
-	 * is also used when reading a GPX file and fetching the images.
-	 *
-	 * This is the workhorse function of the spider.
-	 *
-	 * @param CacheHolderDetail chD The element wayPoint must be set to the name of a waypoint
-	 * @param boolean isUpdate True if an existing cache is being updated, false if it is a new cache
-	 * @param boolean fetchImages True if the pictures are to be fetched
-	 * @param boolean doNotGetFound True if the cache is not to be spidered if it has already been found
-	 * @param boolean fetchAllLogs True if all logs are to be fetched (by adding option '&amp;logs=y' to command line).
-	 *     This is normally false when spidering from GPXImport as the logs are part of the GPX file, and true otherwise
-	 * @return -1 if the infoBox was closed (cancel spidering), 0 if there was an error (continue with next cache), 1 if everything ok
-	 */
-	private int getCacheByWaypointName(CacheHolderDetail chD, boolean isUpdate, boolean fetchImages, boolean doNotGetFound, boolean fetchAllLogs) {
-		int ret = 1;
-		while (true) {
-			String completeWebPage;
-			int spiderTrys=0;
-			int MAX_SPIDER_TRYS=3;
-			while (spiderTrys++&lt;MAX_SPIDER_TRYS) {
-				ret = 1;
-				try{
-					String doc = p.getProp(&quot;getPageByName&quot;) + chD.wayPoint +(fetchAllLogs?p.getProp(&quot;fetchAllLogs&quot;):&quot;&quot;);
-					pref.log(&quot;Fetching: &quot; + chD.wayPoint);
-					completeWebPage = fetch(doc);
-					if	( completeWebPage.equals(&quot;&quot;)) {
-						pref.log(&quot;Could not fetch &quot; + chD.wayPoint);
-						if (!infB.isClosed) {
-							continue;
-						} else {
-							chD.is_incomplete = true;
-							return -1;
-						}
-					}
-				}catch(Exception ex){
-					pref.log(&quot;Could not fetch &quot; + chD.wayPoint,ex);
-					if (!infB.isClosed) {
-						continue;
-					} else {
-						chD.is_incomplete = true;
-						return -1;
-					}
-				}
-				// Only analyse the cache data and fetch pictures if user has not closed the progress window
-				if (!infB.isClosed) {
-					try{
-						chD.is_new = !isUpdate;
-						chD.is_update = false;
-						chD.is_log_update=false;
-						chD.is_HTML = true;
-						chD.is_available = true;
-						chD.is_archived = false;
-						chD.is_incomplete = true;
-						// Save size of logs to be able to check whether any new logs were added
-						//int logsz = chD.CacheLogs.size();
-						//chD.CacheLogs.clear();
-						chD.addiWpts.clear();
-						chD.Images.clear();
-						chD.ImagesText.clear();
-						chD.ImagesInfo.clear();
-
-						if(completeWebPage.indexOf(p.getProp(&quot;cacheUnavailable&quot;)) &gt;= 0) chD.is_available = false;
-						if(completeWebPage.indexOf(p.getProp(&quot;cacheArchived&quot;)) &gt;= 0) chD.is_archived = true;
-						//==========
-						// General Cache Data
-						//==========
-						chD.setLatLon(getLatLon(completeWebPage));
-						pref.log(&quot;LatLon: &quot; + chD.LatLon);
-						if (pref.debug) pref.log(&quot;chD.pos: &quot; + chD.pos.toString());
-						if (chD.LatLon.equals(&quot;???&quot;)) {
-							pref.log(&quot;&gt;&gt;&gt;&gt; Failed to spider Cache. Retry.&quot;);
-							ret = 0;
-							continue; // Restart the spider
-						}
-						pref.log(&quot;Trying description&quot;);
-						chD.setLongDescription(getLongDesc(completeWebPage));
-						pref.log(&quot;Got description&quot;);
-
-						pref.log(&quot;Getting cache name&quot;);
-						chD.CacheName = SafeXML.cleanback(getName(completeWebPage));
-						if (pref.debug) pref.log(&quot;Name: &quot; + chD.CacheName); else pref.log(&quot;Got name&quot;);
-
-						pref.log(&quot;Trying owner&quot;);
-						chD.CacheOwner = SafeXML.cleanback(getOwner(completeWebPage)).trim();
-						if(chD.CacheOwner.equals(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; chD.CacheOwner.equals(pref.myAlias2))) chD.is_owned = true;
-						if (pref.debug) pref.log(&quot;Owner: &quot; + chD.CacheOwner +&quot;; is_owned = &quot;+chD.is_owned+&quot;;  alias1,2 = [&quot;+pref.myAlias+&quot;|&quot;+pref.myAlias2+&quot;]&quot;);
-						else pref.log(&quot;Got owner&quot;);
-
-
-						pref.log(&quot;Trying date hidden&quot;);
-						chD.DateHidden = DateFormat.MDY2YMD(getDateHidden(completeWebPage));
-						if (pref.debug) pref.log(&quot;Hidden: &quot; + chD.DateHidden);
-						else pref.log(&quot;Got date hidden&quot;);
-
-						pref.log(&quot;Trying hints&quot;);
-						chD.setHints(getHints(completeWebPage));
-						if (pref.debug) pref.log(&quot;Hints: &quot; + chD.Hints);
-						else pref.log(&quot;Got hints&quot;);
-
-						pref.log(&quot;Trying size&quot;);
-						chD.CacheSize = getSize(completeWebPage);
-						if (pref.debug) pref.log(&quot;Size: &quot; + chD.CacheSize);
-						else pref.log(&quot;Got size&quot;);
-
-						pref.log(&quot;Trying difficulty&quot;);
-						chD.hard = getDiff(completeWebPage);
-						if (pref.debug) pref.log(&quot;Hard: &quot; + chD.hard);
-						else pref.log(&quot;Got difficulty&quot;);
-
-						pref.log(&quot;Trying terrain&quot;);
-						chD.terrain = getTerr(completeWebPage);
-						if (pref.debug) pref.log(&quot;Terr: &quot; + chD.terrain);
-						else pref.log(&quot;Got terrain&quot;);
-
-						pref.log(&quot;Trying cache type&quot;);
-						chD.type = getType(completeWebPage);
-						if (pref.debug) pref.log(&quot;Type: &quot; + chD.type);
-						else pref.log(&quot;Got cache type&quot;);
-
-						//==========
-						// Logs
-						//==========
-						pref.log(&quot;Trying logs&quot;);
-						chD.setCacheLogs(getLogs(completeWebPage, chD));
-						pref.log(&quot;Found logs&quot;);
-
-						// If the switch is set to not store found caches and we found the cache =&gt; return
-						if (chD.is_found &amp;&amp; doNotGetFound) {
-							if (infB.isClosed) {
-								return -1;
-							} else {
-								return 1;
-							}
-						}
-
-						//==========
-						// Bugs
-						//==========
-						// As there may be several bugs, we check whether the user has aborted
-						if (!infB.isClosed) getBugs(chD,completeWebPage);
-						chD.has_bug = chD.Travelbugs.size()&gt;0;
-
-						//==========
-						// Images
-						//==========
-						if(fetchImages){
-							pref.log(&quot;Trying images&quot;);
-							getImages(completeWebPage, chD);
-							pref.log(&quot;Got images&quot;);
-						}
-						//==========
-						// Addi waypoints
-						//==========
-
-						pref.log(&quot;Getting additional waypoints&quot;);
-						getAddWaypoints(completeWebPage, chD.wayPoint, chD.is_found);
-						pref.log(&quot;Got additional waypoints&quot;);
-
-						//==========
-						// Attributes
-						//==========
-						pref.log(&quot;Getting attributes&quot;);
-						getAttributes(completeWebPage, chD);
-						pref.log(&quot;Got attributes&quot;);
-						if (chD.is_new) chD.is_update=false;
-						chD.is_incomplete = false;
-						break;
-					}catch(Exception ex){
-						pref.log(&quot;Error reading cache: &quot;+chD.wayPoint);
-						pref.log(&quot;Exception in getCacheByWaypointName: &quot;,ex);
-					}
-					finally{}
-				} else {
-					break;
-				}
-			} // spiderTrys
-			if ( ( spiderTrys &gt;= MAX_SPIDER_TRYS ) &amp;&amp; ( ret == 1 ) ) {
-				pref.log(&quot;&gt;&gt;&gt; Failed to spider cache. Number of retrys exhausted.&quot;);
-				int decision = (new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;),MyLocale.getMsg(5515,&quot;Failed to load cache.%0aPleas check your internet connection.%0aRetry?&quot;),FormBase.DEFOKB|FormBase.NOB|FormBase.CANCELB)).execute();
-				if ( decision == FormBase.IDOK ) {
-					continue;						
-				} else if ( decision == FormBase.IDNO ){
-					ret = 0;
-				} else {
-					ret = -1;
-				}
-			}
-			break;
-		}//while(true)
-		if (infB.isClosed) {// If the infoBox was closed before getting here, we return -1
-			return -1;
-		}
-		return ret;
-	} // getCacheByWaypointName
-
-	/**
-	 * Check whether a waypoint is in the database
-	 * @param wpt Name of waypoint to check
-	 * @return index of waypoint in database, -1 if it does not exist
-	 */
-	private int searchWpt(String wpt){
-		Integer INTR = (Integer)indexDB.get(wpt);
-		if(INTR != null){
-			return INTR.intValue();
-		} else return -1;
-	}
-
-	/**
-	 * Get the Distance to the centre
-	 * @param doc A previously fetched cachepage
-	 * @return Distance
-	 */
-	private double getDist(String doc) throws Exception {
-		inRex = new Regex(p.getProp(&quot;distRex&quot;));
-		inRex.search(doc);
-		if(doc.indexOf(&quot;Here&quot;) &gt;= 0) return(0);
-		if (!inRex.didMatch()) return 0;
-		if(MyLocale.getDigSeparator().equals(&quot;,&quot;)) return Convert.toDouble(inRex.stringMatched(1).replace('.',','));
-		return Convert.toDouble(inRex.stringMatched(1));
-	}
-
-	/**
-	 * Get the waypoint name
-	 * @param doc A previously fetched cachepage
-	 * @return Name of waypoint to add to list
-	 */
-	private String getWP(String doc) throws Exception {
-		inRex = new Regex(p.getProp(&quot;waypointRex&quot;));
-		inRex.search(doc);
-		if (!inRex.didMatch()) return &quot;???&quot;;
-		return &quot;GC&quot;+inRex.stringMatched(1);
-	}
-
-	/**
-	 * Get the coordinates of the cache
-	 * @param doc A previously fetched cachepage
-	 * @return Cache coordinates
-	 */
-	private String getLatLon(String doc) throws Exception{
-		inRex = new Regex(p.getProp(&quot;latLonRex&quot;));
-		inRex.search(doc);
-		if (!inRex.didMatch()) return &quot;???&quot;;
-		return inRex.stringMatched(1);
-	}
-
-	/**
-	 * Get the long description
-	 * @param doc A previously fetched cachepage
-	 * @return the long description
-	 */
-	private String getLongDesc(String doc) throws Exception{
-		String res = &quot;&quot;;
-		inRex = new Regex(p.getProp(&quot;shortDescRex&quot;));
-		Regex rex2 = new Regex(p.getProp(&quot;longDescRex&quot;));
-		inRex.search(doc);
-		rex2.search(doc);
-		res = ((inRex.stringMatched(1)==null)?&quot;&quot;:inRex.stringMatched(1)) + &quot;&lt;br&gt;&quot;;
-		res += rex2.stringMatched(1);
-		return res; // SafeXML.cleanback(res);
-	}
-
-	/**
-	 * Get the cache name
-	 * @param doc A previously fetched cachepage
-	 * @return the name of the cache
-	 */
-	private String getName(String doc) throws Exception{
-		inRex = new Regex(p.getProp(&quot;cacheNameRex&quot;));
-		inRex.search(doc);
-		if (!inRex.didMatch()) return &quot;???&quot;;
-		return inRex.stringMatched(1);
-	}
-
-	/**
-	 * Get the cache owner
-	 * @param doc A previously fetched cachepage
-	 * @return the cache owner
-	 */
-	private String getOwner(String doc) throws Exception{
-		inRex = new Regex(p.getProp(&quot;cacheOwnerRex&quot;));
-		inRex.search(doc);
-		if (!inRex.didMatch()) return &quot;???&quot;;
-		return inRex.stringMatched(1);
-	}
-
-	/**
-	 * Get the date when the cache was hidden
-	 * @param doc A previously fetched cachepage
-	 * @return Hidden date
-	 */
-	private String getDateHidden(String doc) throws Exception{
-		inRex = new Regex(p.getProp(&quot;dateHiddenRex&quot;));
-		inRex.search(doc);
-		if (!inRex.didMatch()) return &quot;???&quot;;
-		return inRex.stringMatched(1);
-	}
-
-	/**
-	 * Get the hints
-	 * @param doc A previously fetched cachepage
-	 * @return Cachehints
-	 */
-	private String getHints(String doc) throws Exception{
-		inRex = new Regex(p.getProp(&quot;hintsRex&quot;));
-		inRex.search(doc);
-		if (!inRex.didMatch()) return &quot;&quot;;
-		return inRex.stringMatched(1);
-	}
-
-	/**
-	 * Get the cache size
-	 * @param doc A previously fetched cachepage
-	 * @return Cache size
-	 */
-	private String getSize(String doc) throws Exception{
-		inRex = new Regex(p.getProp(&quot;sizeRex&quot;));
-		inRex.search(doc);
-		if(inRex.didMatch()) return inRex.stringMatched(1);
-		else return &quot;None&quot;;
-	}
-
-	/**
-	 * Get the Difficulty
-	 * @param doc A previously fetched cachepage
-	 * @return The cache difficulty
-	 */
-	private String getDiff(String doc) throws Exception{
-		inRex = new Regex(p.getProp(&quot;difficultyRex&quot;));
-		inRex.search(doc);
-		if(inRex.didMatch()) return inRex.stringMatched(1);
-		else return &quot;&quot;;
-	}
-
-	/**
-	 * Get the terrain rating
-	 * @param doc A previously fetched cachepage
-	 * @return Terrain rating
-	 */
-	private String getTerr(String doc) throws Exception{
-		inRex = new Regex(p.getProp(&quot;terrainRex&quot;));
-		inRex.search(doc);
-		if(inRex.didMatch()) return inRex.stringMatched(1);
-		else return &quot;&quot;;
-	}
-
-	/**
-	 * Get the waypoint type
-	 * @param doc A previously fetched cachepage
-	 * @return the waypoint type (Tradi, Multi, etc.)
-	 */
-	private String getType(String doc) throws Exception{
-		inRex = new Regex(p.getProp(&quot;cacheTypeRex&quot;));
-		inRex.search(doc);
-		if(inRex.didMatch()) return inRex.stringMatched(1);
-		else return &quot;&quot;;
-	}
-
-	/**
-	 * Get the logs
-	 * @param doc A previously fetched cachepage
-	 * @param chD Cache Details
-	 * @return A HTML string containing the logs
-	 */
-	private LogList getLogs(String doc, CacheHolderDetail chD) throws Exception{
-		String icon = &quot;&quot;;
-		String name = &quot;&quot;;
-		LogList reslts = new LogList();
-		Regex blockRex = new Regex(p.getProp(&quot;blockRex&quot;));
-		blockRex.search(doc);
-		doc = blockRex.stringMatched(1);
-		String singleLog = &quot;&quot;;
-		Extractor exSingleLog = new Extractor(doc,p.getProp(&quot;singleLogExStart&quot;), p.getProp(&quot;singleLogExEnd&quot;), 0, false); // maybe here is some change neccessary because findnext now gives the whole endstring back???
-		singleLog = exSingleLog.findNext();
-		Extractor exIcon = new Extractor(singleLog,p.getProp(&quot;iconExStart&quot;), p.getProp(&quot;iconExEnd&quot;), 0, true);
-		Extractor exNameTemp = new Extractor(singleLog,p.getProp(&quot;nameTempExStart&quot;), p.getProp(&quot;nameTempExEnd&quot;), 0 , true);
-		String nameTemp = &quot;&quot;;
-		nameTemp = exNameTemp.findNext();
-		Extractor exName = new Extractor(nameTemp, p.getProp(&quot;nameExStart&quot;), p.getProp(&quot;nameExEnd&quot;), 0 , true);
-		Extractor exDate = new Extractor(singleLog,p.getProp(&quot;dateExStart&quot;), p.getProp(&quot;dateExEnd&quot;), 0 , true);
-		Extractor exLog = new Extractor(singleLog, p.getProp(&quot;logExStart&quot;), p.getProp(&quot;logExEnd&quot;), 0, true);
-		//Vm.debug(&quot;Log Block: &quot; + singleLog);
-		int nLogs=0;
-		while(exSingleLog.endOfSearch() == false){
-			nLogs++;
-			//Vm.debug(&quot;--------------------------------------------&quot;);
-			//Vm.debug(&quot;Log Block: &quot; + singleLog);
-			//Vm.debug(&quot;Icon: &quot;+exIcon.findNext());
-			//Vm.debug(exName.findNext());
-			//Vm.debug(exDate.findNext());
-			//Vm.debug(exLog.findNext());
-			//Vm.debug(&quot;--------------------------------------------&quot;);
-			icon = exIcon.findNext();
-			name = exName.findNext();
-			String d=DateFormat.logdate2YMD(exDate.findNext());
-			if((icon.equals(p.getProp(&quot;icon_smile&quot;)) || icon.equals(p.getProp(&quot;icon_camera&quot;)) || icon.equals(p.getProp(&quot;icon_attended&quot;))) &amp;&amp;
-				(name.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; name.equalsIgnoreCase(pref.myAlias2))) )  {
-				chD.is_found = true;
-				chD.CacheStatus = d;
-			}
-			if (nLogs&lt;=MAXLOGS) reslts.add(new Log(icon,d,name,exLog.findNext()));
-
-			singleLog = exSingleLog.findNext();
-			exIcon.setSource(singleLog);
-			exNameTemp.setSource(singleLog);
-			nameTemp = exNameTemp.findNext();
-			exName.setSource(nameTemp);
-			exDate.setSource(singleLog);
-			exLog.setSource(singleLog);
-			// We cannot simply stop if we have reached MAXLOGS just in case we are waiting for
-			// a log by our alias that happened earlier.
-			if (nLogs&gt;=MAXLOGS &amp;&amp; chD.is_found) break;
-		}
-		if (nLogs&gt;MAXLOGS) {
-			reslts.add(Log.maxLog());
-			pref.log(&quot;Too many logs. MAXLOGS reached (&quot;+MAXLOGS+&quot;)&quot;);
-		} else
-			pref.log(nLogs+&quot; logs found&quot;);
-		return reslts;
-	}
-
-	/**
-	 * Read the travelbug names from a previously fetched Cache page and then
-	 * read the travelbug purpose for each travelbug
-	 * @param doc The previously fetched cachepage
-	 * @return A HTML formatted string with bug names and there purpose
-	 */
-	public void getBugs(CacheHolderDetail chD, String doc) throws Exception{
-		Extractor exBlock = new Extractor(doc,p.getProp(&quot;blockExStart&quot;),p.getProp(&quot;blockExEnd&quot;) ,0,Extractor.EXCLUDESTARTEND);
-		String bugBlock = exBlock.findNext();
-		//Vm.debug(&quot;Bugblock: &quot;+bugBlock);
-		Extractor exBug = new Extractor(bugBlock,p.getProp(&quot;bugExStart&quot;),p.getProp(&quot;bugExEnd&quot;),0,Extractor.EXCLUDESTARTEND);
-		String link,bug,linkPlusBug,bugDetails;
-		String oldInfoBox=infB.getInfo();
-		chD.Travelbugs.clear();
-		while(exBug.endOfSearch() == false){
-			if (infB.isClosed) break; // Allow user to cancel by closing progress form
-			linkPlusBug= exBug.findNext();
-			int idx=linkPlusBug.indexOf(&quot;'&gt;&quot;);
-			if (idx&lt;0) break; // No link/bug pair found
-			link=linkPlusBug.substring(0,idx);
-			bug=linkPlusBug.substring(idx+2);
-			if(bug.length()&gt;0) { // Found a bug, get its details
-				Travelbug tb=new Travelbug(bug);
-				try{
-					infB.setInfo(oldInfoBox+MyLocale.getMsg(5514,&quot;\nGetting bug: &quot;)+SafeXML.cleanback(bug));
-					pref.log(&quot;Fetching bug details: &quot;+bug);
-					bugDetails = fetch(link);
-					Extractor exDetails = new Extractor(bugDetails,p.getProp(&quot;bugDetailsStart&quot;),p.getProp(&quot;bugDetailsEnd&quot;),0,Extractor.EXCLUDESTARTEND);
-					tb.setMission(exDetails.findNext());
-					Extractor exGuid = new Extractor(bugDetails,&quot;details.aspx?guid=&quot;,&quot;\&quot; id=\&quot;aspnetForm&quot;,0,Extractor.EXCLUDESTARTEND); // TODO Replace with spider.def see also further down
-					tb.setGuid(exGuid.findNext());
-					chD.Travelbugs.add(tb);
-				}catch(Exception ex){
-					pref.log(&quot;Could not fetch bug details&quot;);
-				}
-			}
-			//Vm.debug(&quot;B: &quot; + bug);
-			//Vm.debug(&quot;End? &quot; + exBug.endOfSearch());
-		}
-		infB.setInfo(oldInfoBox);
-	}
-
-	/**
-	 * Get the images for a previously fetched cache page. Images are extracted
-	 * from two areas: The long description and the pictures section (including
-	 * the spoiler)
-	 * @param doc The previously fetched cachepage
-	 * @param chD The Cachedetails
-	 */
-	public void getImages(String doc, CacheHolderDetail chD){
-		int imgCounter = 0;
-		String imgName, oldImgName, imgType, imgUrl, imgComment;
-		Vector spideredUrls=new Vector(15);
-		Extractor exImgBlock,exImgComment;
-		int idxUrl; // Index of already spidered Url in list of spideredUrls
-		//========
-		//In the long description
-		//========
-		String longDesc = &quot;&quot;;
-		try {
-			if (chD.wayPoint.startsWith(&quot;TC&quot;)) longDesc = doc;
-			else
-				longDesc = getLongDesc(doc);
-			longDesc = STRreplace.replace(longDesc, &quot;&lt;img&quot;, &quot;&lt;IMG&quot;);
-			longDesc = STRreplace.replace(longDesc, &quot;src=&quot;, &quot;SRC=&quot;);
-			longDesc = STRreplace.replace(longDesc, &quot;'&quot;, &quot;\&quot;&quot;);
-			exImgBlock = new Extractor(longDesc,p.getProp(&quot;imgBlockExStart&quot;),p.getProp(&quot;imgBlockExEnd&quot;), 0, false);
-		} catch (Exception ex) {//Missing property in spider.def
-			return;
-		}
-		//Vm.debug(&quot;In getImages: Have longDesc&quot; + longDesc);
-		String tst;
-		tst = exImgBlock.findNext();
-		//Vm.debug(&quot;Test: \n&quot; + tst);
-		Extractor exImgSrc = new Extractor(tst, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
-		while(exImgBlock.endOfSearch() == false){
-			imgUrl = exImgSrc.findNext();
-			//Vm.debug(&quot;Img Url: &quot; +imgUrl);
-			if(imgUrl.length()&gt;0){
-				imgUrl = &quot;<A HREF="http://">http://</A>&quot; + imgUrl;
-				try{
-					imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).substring(0,4).trim();
-					// imgType is now max 4 chars, starting with .
-					if(imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)){
-						// Check whether image was already spidered for this cache
-						idxUrl=spideredUrls.find(imgUrl);
-						imgName = chD.wayPoint + &quot;_&quot; + Convert.toString(imgCounter);
-						if (idxUrl&lt;0) { // New image
-							pref.log(&quot;Loading image: &quot; + imgUrl+&quot; as &quot;+imgName);
-							spiderImage(imgUrl, imgName+imgType);
-							chD.Images.add(imgName+imgType);
-							spideredUrls.add(imgUrl);
-						} else { // Image already spidered as wayPoint_'idxUrl'
-							pref.log(&quot;Already loaded image: &quot; + imgUrl);
-							oldImgName = chD.wayPoint + &quot;_&quot; + Convert.toString(idxUrl);
-							chD.Images.add(oldImgName+imgType); // Store name of old image as image to load
-						}
-						chD.ImagesText.add(imgName); // Keep the image name
-						chD.ImagesInfo.add(null); // Need to stay in synch with ImagesText
-						imgCounter++;
-					}
-				} catch (IndexOutOfBoundsException e) {
-					//Vm.debug(&quot;IndexOutOfBoundsException not in image span&quot;+e.toString()+&quot;imgURL:&quot;+imgUrl);
-					pref.log(&quot;Problem loading image. imgURL:&quot;+imgUrl);
-				}
-				}
-			exImgSrc.setSource(exImgBlock.findNext());
-		}
-		//========
-		//In the image span
-		//========
-		Extractor spanBlock,exImgName;
-		try {
-			spanBlock = new Extractor(doc,p.getProp(&quot;imgSpanExStart&quot;),p.getProp(&quot;imgSpanExEnd&quot;), 0 , true);
-			tst = spanBlock.findNext();
-			exImgName = new Extractor(tst,p.getProp(&quot;imgNameExStart&quot;),p.getProp(&quot;imgNameExEnd&quot;), 0 , true);
-			exImgSrc = new Extractor(tst,p.getProp(&quot;imgSrcExStart&quot;),p.getProp(&quot;imgSrcExEnd&quot;), 0, true);
-			exImgComment = new Extractor(tst,p.getProp(&quot;imgCommentExStart&quot;),p.getProp(&quot;imgCommentExEnd&quot;), 0, true);
-		} catch (Exception ex) { // Missing property in spider .def
-			return;
-		}
-		while(exImgSrc.endOfSearch() == false){
-			imgUrl = exImgSrc.findNext();
-			imgComment = exImgComment.findNext(); 
-			//Vm.debug(&quot;Img Url: &quot; +imgUrl);
-			if(imgUrl.length()&gt;0){
-				imgUrl = &quot;<A HREF="http://">http://</A>&quot; + imgUrl;
-				try{
-					imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).substring(0,4).trim();
-					// imgType is now max 4 chars, starting with .
-					if(imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)){
-						// Check whether image was already spidered for this cache
-						idxUrl=spideredUrls.find(imgUrl);
-						imgName = chD.wayPoint + &quot;_&quot; + Convert.toString(imgCounter);
-						if (idxUrl&lt;0) { // New image
-							pref.log(&quot;Loading image: &quot; + imgUrl);
-							spiderImage(imgUrl, imgName+imgType);
-							chD.Images.add(imgName+imgType);
-						} else { // Image already spidered as wayPoint_ 'idxUrl'
-							pref.log(&quot;Already loaded image: &quot; + imgUrl);
-							oldImgName = chD.wayPoint + &quot;_&quot; + Convert.toString(idxUrl);
-							chD.Images.add(oldImgName+imgType); // Store name of old image as image to load
-						}
-						chD.ImagesText.add(exImgName.findNext()); // Keep the image description
-						while (imgComment.startsWith(&quot;&lt;br /&gt;&quot;)) imgComment=imgComment.substring(6);
-						while (imgComment.endsWith(&quot;&lt;br /&gt;&quot;)) imgComment=imgComment.substring(0,imgComment.length()-6);
-						if (imgComment.length()==0)
-							chD.ImagesInfo.add(null);
-						else
-							chD.ImagesInfo.add(imgComment);
-						imgCounter++;
-					}
-				} catch (IndexOutOfBoundsException e) {
-					pref.log(&quot;IndexOutOfBoundsException in image span. imgURL:&quot;+imgUrl,e);
-				}
-			}
-		}
-		//========
-		//Final sweep to check for images in hrefs
-		//========
-		Extractor exFinal = new Extractor(longDesc, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
-		while(exFinal.endOfSearch() == false){
-			imgUrl = exFinal.findNext();
-			if(imgUrl.length()&gt;0){
-				imgUrl = &quot;<A HREF="http://">http://</A>&quot; + imgUrl;
-				try{
-					imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).substring(0,4).trim();
-					// imgType is now max 4 chars, starting with . Delete characters in URL after the image extension
-					imgUrl=imgUrl.substring(0,imgUrl.lastIndexOf(&quot;.&quot;)+imgType.length());
-					if( imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.bmp&quot;) || imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.gif&quot;)){
-						// Check whether image was already spidered for this cache
-						idxUrl=spideredUrls.find(imgUrl);
-						if (idxUrl&lt;0) { // New image
-							imgName = chD.wayPoint + &quot;_&quot; + Convert.toString(imgCounter);
-							pref.log(&quot;Loading image: &quot; + imgUrl+&quot; as &quot;+imgName);
-							spiderImage(imgUrl, imgName+imgType);
-							chD.Images.add(imgName+imgType);
-							spideredUrls.add(imgUrl);
-							chD.ImagesText.add(imgName); // Keep the image name
-							chD.ImagesInfo.add(null);
-							imgCounter++;
-						}
-					}
-				} catch (IndexOutOfBoundsException e) {
-					pref.log(&quot;Problem loading image. imgURL:&quot;+imgUrl);
-				}
-			}
-		}
-	}
-
-	
-	/**
-	 * Read an image from the server
-	 * @param imgUrl The Url of the image
-	 * @param target The bytes of the image
-	 */
-	private void spiderImage(String imgUrl, String target){ // TODO implement a fetch(URL, filename) in HttpConnection and use that one
-		HttpConnection connImg;
-		Socket sockImg;
-		//InputStream is;
-		FileOutputStream fos;
-		//int bytes_read;
-		//byte[] buffer = new byte[9000];
-		ByteArray daten;
-		String datei = &quot;&quot;;
-		datei = profile.dataDir + target;
-		connImg = new HttpConnection(imgUrl);
-		if (imgUrl.indexOf('%')&gt;=0) connImg.documentIsEncoded=true;
-		connImg.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
-		//connImg.setRequestorProperty(&quot;User-Agent&quot;,&quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.12) Gecko/20080201 Firefox/2.0.0.12&quot;);
-		//connImg.setRequestorProperty(&quot;Accept&quot;,&quot;text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5&quot;);
-		try{
-			pref.log(&quot;Trying to fetch image from: &quot; + imgUrl);
-			String redirect=null;
-			do {
-				sockImg = connImg.connect();
-				redirect=connImg.getRedirectTo();
-				if (redirect!=null) {
-					connImg=connImg.getRedirectedConnection(redirect);
-					pref.log(&quot;Redirect to &quot;+redirect);
-				}
-			} while(redirect!=null); // TODO this can end up in an endless loop if trying to load from a malicous site 
-			daten = connImg.readData(sockImg);
-			fos = new FileOutputStream(new File(datei));
-			fos.write(daten.toBytes());
-			fos.close();
-			sockImg.close();
-		} catch (UnknownHostException e) {
-			pref.log(&quot;Host not there...&quot;);
-		}catch(IOException ioex){
-			pref.log(&quot;File not found!&quot;);
-		} catch (Exception ex){
-			pref.log(&quot;Some other problem while fetching image&quot;,ex);
-		} finally {
-			//Continue with the spider
-		}
-	}
-
-	/**
-	 * Read all additional waypoints from a previously fetched cachepage.
-	 * @param doc The previously fetched cachepage
-	 * @param wayPoint The name of the cache
-	 * @param is_found Found status of the cached (is inherited by the additional waypoints)
-	 */
-	public void getAddWaypoints(String doc, String wayPoint, boolean is_found) throws Exception{
-		Extractor exWayBlock = new Extractor(doc,p.getProp(&quot;wayBlockExStart&quot;),p.getProp(&quot;wayBlockExEnd&quot;), 0, false);
-		String wayBlock = &quot;&quot;;
-		String rowBlock = &quot;&quot;;
-		wayBlock = exWayBlock.findNext();
-		Regex nameRex = new Regex(p.getProp(&quot;nameRex&quot;));
-		Regex koordRex = new Regex(p.getProp(&quot;koordRex&quot;));
-		Regex descRex = new Regex(p.getProp(&quot;descRex&quot;));
-		Regex typeRex = new Regex(p.getProp(&quot;typeRex&quot;));
-		int counter = 0;
-		if(exWayBlock.endOfSearch() == false &amp;&amp; wayBlock.indexOf(&quot;No additional waypoints to display.&quot;)&lt;0){
-			Extractor exRowBlock = new Extractor(wayBlock,p.getProp(&quot;rowBlockExStart&quot;),p.getProp(&quot;rowBlockExEnd&quot;), 0, false);
-			rowBlock = exRowBlock.findNext();
-			rowBlock = exRowBlock.findNext();
-			while(exRowBlock.endOfSearch()==false){
-				CacheHolderDetail cxD = new CacheHolderDetail();
-				Extractor exPrefix=new Extractor(rowBlock,p.getProp(&quot;prefixExStart&quot;),p.getProp(&quot;prefixExEnd&quot;),0,true);
-				String prefix=exPrefix.findNext();
-				String adWayPoint;
-				if (prefix.length()==2)
-					adWayPoint=prefix+wayPoint.substring(2);
-				else	
-				    adWayPoint = MyLocale.formatLong(counter, &quot;00&quot;) + wayPoint.substring(2);
-				counter++;
-				int idx=profile.getCacheIndex(adWayPoint);
-				if (idx&gt;=0) {
-					cxD=new CacheHolderDetail((CacheHolder) cacheDB.get(idx));
-					try{ // If addi exists, try to read it to preserve the notes
-						cxD.readCache(profile.dataDir);
-					} catch (Exception ex) {};
-				} else {
-					cxD=new CacheHolderDetail(); cxD.wayPoint=adWayPoint;
-				}
-				cxD.is_update=false; cxD.is_new=false;
-				nameRex.search(rowBlock);
-				koordRex.search(rowBlock);
-				typeRex.search(rowBlock);
-				cxD.CacheName = nameRex.stringMatched(1);
-				if(koordRex.didMatch()) cxD.setLatLon(koordRex.stringMatched(1));
-				if(typeRex.didMatch()) cxD.type = CacheType.typeText2Number(&quot;Waypoint|&quot;+typeRex.stringMatched(1));
-				rowBlock = exRowBlock.findNext();
-				descRex.search(rowBlock);
-				cxD.setLongDescription(descRex.stringMatched(1));
-				cxD.is_found = is_found;
-				cxD.saveCacheDetails(profile.dataDir);
-				if (idx&lt;0){
-					cxD.is_new=true; cxD.is_update=false;
-					cacheDB.add(new CacheHolder(cxD));
-				}else {
-					CacheHolder cx=(CacheHolder) cacheDB.get(idx);
-					if (cx.is_Checked &amp;&amp; // Only re-spider existing addi waypoints that are ticked
-				 	   !cx.is_filtered) { // and are visible (i.e.  not filtered)
-					   cx.update(cxD);
-					   cx.is_Checked=true;
-					}
-				}
-				rowBlock = exRowBlock.findNext();
-			}
-		}
-	}
-
-	private void getAttributes(String doc, CacheHolderDetail chD) throws Exception {
-		Extractor attBlock = new Extractor(doc,p.getProp(&quot;attBlockExStart&quot;),p.getProp(&quot;attBlockExEnd&quot;), 0 , true);
-		String atts = attBlock.findNext();
-		Extractor attEx = new Extractor(atts,p.getProp(&quot;attExStart&quot;),p.getProp(&quot;attExEnd&quot;), 0 , true);
-		String attribute=attEx.findNext();
-		chD.attributes.clear();
-		while (attEx.endOfSearch()==false) {
-			chD.attributes.add(attribute);
-			attribute=attEx.findNext();
-		}
-		chD.attributesYes = chD.attributes.attributesYes;
-		chD.attributesNo = chD.attributes.attributesNo;
-	}
-
-
-	/**
-	*	Performs an initial fetch to a given address. In this case
-	*	it will be a gc.com address. This method is used to obtain
-	*	the result of a search for caches screen.
-	*/
-	public static String fetch(String address) {
-		CharArray c_data;
-		try{
-			HttpConnection conn;
-			if(pref.myproxy.length() &gt; 0 &amp;&amp; pref.proxyActive){
-				pref.log(&quot;[fetch]:Using proxy: &quot; + pref.myproxy + &quot; / &quot; +pref.myproxyport);
-			} 
-			conn = new HttpConnection(address);
-			conn.setRequestorProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
-			if(cookieSession.length()&gt;0){
-				conn.setRequestorProperty(&quot;Cookie&quot;, &quot;ASP.NET_SessionId=&quot;+cookieSession +&quot;; userid=&quot;+cookieID);
-				pref.log(&quot;[fetch]:Cookie Zeug: &quot; + &quot;Cookie: ASP.NET_SessionId=&quot;+cookieSession +&quot;; userid=&quot;+cookieID);
-			} else
-				pref.log(&quot;[fetch]:No Cookie found&quot;);
-			conn.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
-			conn.documentIsEncoded = true;
-			if (pref.debug) pref.log(&quot;[fetch]:Connecting&quot;);
-			Socket sock = conn.connect();
-			if (pref.debug) pref.log(&quot;[fetch]:Connect ok!&quot;);
-			ByteArray daten = conn.readData(sock);
-			if (pref.debug) pref.log(&quot;[fetch]:Read data ok&quot;);
-			JavaUtf8Codec codec = new JavaUtf8Codec();
-			c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
-			sock.close();
-			return getResponseHeaders(conn)+ c_data.toString();
-		}catch(IOException ioex){
-			pref.log(&quot;IOException in fetch&quot;, ioex);
-		}finally{
-			//continue
-		}
-		return &quot;&quot;;
-	}
-
-	/**
-	*	After a fetch to gc.com the next fetches have to use the post method.
-	*	This method does exactly that. Actually this method is generic in the sense
-	*	that it can be used to post to a URL using http post.
-	*/
-	private static String fetch_post(String address, String document, String path) {
-		HttpConnection conn;
-		try {
-			conn = new HttpConnection(address);
-			JavaUtf8Codec codec = new JavaUtf8Codec();
-			conn.documentIsEncoded = true;
-			conn.setRequestorProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
-			conn.setPostData(codec.encodeText(document.toCharArray(),0,document.length(),true,null));
-			conn.setRequestorProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
-			if(cookieSession.length()&gt;0){
-				conn.setRequestorProperty(&quot;Cookie&quot;, &quot;ASP.NET_SessionId=&quot;+cookieSession+&quot;; userid=&quot;+cookieID);
-				pref.log(&quot;[fetch]:Cookie Zeug: &quot; + &quot;Cookie: ASP.NET_SessionId=&quot;+cookieSession +&quot;; userid=&quot;+cookieID);
-			} else {
-				pref.log(&quot;[fetch]:No Cookie found&quot;);
-			}
-			conn.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
-			if (pref.debug) pref.log(&quot;[fetch]:Connecting&quot;);
-			Socket sock = conn.connect();
-			if (pref.debug) pref.log(&quot;[fetch]:Connect ok!&quot;);
-			ByteArray daten = conn.readData(sock);
-			if (pref.debug) pref.log(&quot;[fetch]:Read data ok&quot;);
-			CharArray c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
-			sock.close();
-			return getResponseHeaders(conn)+c_data.toString();
-		} catch (Exception e) {	}
-		return &quot;&quot;;
-	}
-
-	private static String getResponseHeaders(HttpConnection conn) {
-		PropertyList pl = conn.documentProperties;
-		if (pl != null) {
-			StringBuffer sb = new StringBuffer(1000);
-			boolean gotany = false;
-
-			for (int i = 0; i &lt; pl.size(); i++) {
-				Property p = (Property)pl.get(i);
-				if (p.value != null) {
-					sb.append(p.name).append(&quot;: &quot;).append(p.value).append(&quot;\r\n&quot;);
-					gotany = true;
-				}
-			}
-			if (gotany)
-				return sb.toString() + &quot;\r\n&quot;;
-		}
-		return &quot;&quot;;
-	}
-	
-	
-	final static String hex = ewe.util.TextEncoder.hex;
-
-	public String encodeUTF8URL(byte[] what) {
-		int max = what.length;
-		char [] dest = new char[6*max]; // Assume each char is a UTF char and encoded into 6 chars
-		char d = 0;
-		for (int i = 0; i&lt;max; i++){
-			char c = (char) what[i];
-			if (c &lt;= ' ' || c == '+' || c == '&amp;' || c == '%' || c == '=' ||
-				   c == '|' || c == '{' || c == '}' || c&gt;0x7f ){
-					dest[d++] = '%';
-					dest[d++] = hex.charAt((c &gt;&gt; 4) &amp; 0xf);
-					dest[d++] = hex.charAt(c &amp; 0xf);
-			} else dest[d++] = c;
-		}
-		return new String(dest,0,d);
-	}	
-
-	/**
-	 * Load the bug id for a given name. This method is not ideal, as there are
-	 * sometimes several bugs with identical names but different IDs. Normally
-	 * the bug GUID is used which can be obtained from the cache page.&lt;br&gt;
-	 * Note that each bug has both an ID and a GUID.
-	 * @param name The name (or partial name) of a travelbug
-	 * @return the id of the bug
-	 */
-	public String getBugId (String name) {
-		String bugList;
-		try{
-			//infB.setInfo(oldInfoBox+&quot;\nGetting bug: &quot;+bug);
-			pref.log(&quot;Fetching bugId: &quot;+name);
-			bugList = fetch(p.getProp(&quot;getBugByName&quot;)+STRreplace.replace(SafeXML.clean(name),&quot; &quot;,&quot;+&quot;));
-		}catch(Exception ex){
-			pref.log(&quot;Could not fetch bug list&quot;);
-			bugList=&quot;&quot;;
-		}
-		try {
-			if (bugList.equals(&quot;&quot;) || bugList.indexOf(p.getProp(&quot;bugNotFound&quot;))&gt;=0) {
-				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6020,&quot;Travelbug not found.&quot;), FormBase.OKB)).execute();
-				return &quot;&quot;;
-			}
-			if (bugList.indexOf(p.getProp(&quot;bugTotalRecords&quot;))&lt;0) {
-				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6021,&quot;More than one travelbug found. Specify name more precisely.&quot;), FormBase.OKB)).execute();
-				return &quot;&quot;;
-			}
-			Extractor exGuid = new Extractor(bugList,p.getProp(&quot;bugGuidExStart&quot;),p.getProp(&quot;bugGuidExEnd&quot;),0,Extractor.EXCLUDESTARTEND); // TODO Replace with spider.def
-			return exGuid.findNext();
-		} catch (Exception ex) {
-			return &quot;&quot;;
-		}
-	}
-
-	/**
-	 * Fetch a bug's mission for a given GUID or ID. If the guid String is longer
-	 * than 10 characters it is assumed to be a GUID, otherwise it is an ID.
-	 * @param guid the guid or id of the travelbug
-	 * @return The mission
-	 */
-	public String getBugMissionByGuid(String guid) {
-		String bugDetails;
-		try{
-			//infB.setInfo(oldInfoBox+&quot;\nGetting bug: &quot;+bug);
-			pref.log(&quot;Fetching bug detailsById: &quot;+guid);
-			if (guid.length()&gt;10)
-				bugDetails = fetch(p.getProp(&quot;getBugByGuid&quot;)+guid);
-			else
-				bugDetails = fetch(p.getProp(&quot;getBugById&quot;)+guid);
-		}catch(Exception ex){
-			pref.log(&quot;Could not fetch bug details&quot;);
-			bugDetails=&quot;&quot;;
-		}
-		try {
-			if (bugDetails.indexOf(p.getProp(&quot;bugNotFound&quot;))&gt;=0) {
-				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6020,&quot;Travelbug not found.&quot;), FormBase.OKB)).execute();
-				return &quot;&quot;;
-			}
-			Extractor exDetails = new Extractor(bugDetails,p.getProp(&quot;bugDetailsStart&quot;),p.getProp(&quot;bugDetailsEnd&quot;),0,Extractor.EXCLUDESTARTEND);
-			return exDetails.findNext();
-		} catch (Exception ex) {
-			return &quot;&quot;;
-		}
-	}
-
-	/**
-	 * Fetch a bug's mission for a given tracking number
-	 * @param trackNr the tracking number of the travelbug
-	 * @return The mission
-	 */
-	public String getBugMissionByTrackNr(String trackNr) {
-		String bugDetails;
-		try{
-			pref.log(&quot;Fetching bug detailsByTrackNr: &quot;+trackNr);
-			bugDetails = fetch(p.getProp(&quot;getBugByTrackNr&quot;)+trackNr);
-		}catch(Exception ex){
-			pref.log(&quot;Could not fetch bug details&quot;);
-			bugDetails=&quot;&quot;;
-		}
-		try {
-			if (bugDetails.indexOf(p.getProp(&quot;bugNotFound&quot;))&gt;=0) {
-//				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6020,&quot;Travelbug not found.&quot;), MessageBox.OKB)).execute();
-				return &quot;&quot;;
-			}
-			Extractor exDetails = new Extractor(bugDetails,p.getProp(&quot;bugDetailsStart&quot;),p.getProp(&quot;bugDetailsEnd&quot;),0,Extractor.EXCLUDESTARTEND);
-			return exDetails.findNext();
-		} catch (Exception ex) {
-			return &quot;&quot;;
-		}
-	}
-	
-	/**
-	 * Fetch a bug's mission and namefor a given tracking number
-	 * @param TB the travelbug
-	 * @return true if suceeded
-	 */
-	public boolean getBugMissionAndNameByTrackNr(Travelbug TB) {
-		String bugDetails;
-		String trackNr = TB.getTrackingNo();
-		try{
-			pref.log(&quot;Fetching bug detailsByTrackNr: &quot;+trackNr);
-			bugDetails = fetch(p.getProp(&quot;getBugByTrackNr&quot;)+trackNr);
-		}catch(Exception ex){
-			pref.log(&quot;Could not fetch bug details&quot;);
-			bugDetails=&quot;&quot;;
-		}
-		try {
-			if (bugDetails.indexOf(p.getProp(&quot;bugNotFound&quot;))&gt;=0) {
-//				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6020,&quot;Travelbug not found.&quot;), MessageBox.OKB)).execute();
-				return false;
-			}
-			Extractor exDetails = new Extractor(bugDetails,p.getProp(&quot;bugDetailsStart&quot;),p.getProp(&quot;bugDetailsEnd&quot;),0,Extractor.EXCLUDESTARTEND);
-			TB.setMission( exDetails.findNext() );
-			Extractor exName = new Extractor(bugDetails,p.getProp(&quot;bugNameStart&quot;),p.getProp(&quot;bugNameEnd&quot;),0,Extractor.EXCLUDESTARTEND);
-			TB.setName( exName.findNext() );
-			return true;
-		} catch (Exception ex) {
-			return false;
-		}
-	}
-
-	private class myProperties extends Properties {
-		myProperties() {
-			super();
-			try {
-				load(new FileInputStream(FileBase.getProgramDirectory()+&quot;/spider.def&quot;));
-			} catch (Exception ex) {
-				pref.log(&quot;Failed to load spider.def&quot;,ex);
-				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5504,&quot;Could not load 'spider.def'&quot;), FormBase.OKB)).execute();
-			}
-		}
-		public String getProp(String key) throws Exception {
-			String s=super.getProperty(key);
-			if (s==null) {
-				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5497,&quot;Error missing tag in spider.def&quot;) + &quot;: &quot;+key, FormBase.OKB)).execute();
-				throw new Exception(&quot;Missing tag in spider.def: &quot;+key);
-			}
-			return s;
-		}
-
-	}
-}

Deleted: experiments/engywuck/hist-test/src/cachewolf/TokenObj.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/TokenObj.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/TokenObj.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,33 +0,0 @@
-package CacheWolf;
-
-
-
-/**
-*	Class to hold a token object.
-*	@see Tokenizer
-*	@see Parser
-*/
-public class TokenObj{
-	/** Token types */
-	public static final int TT_VARIABLE=0;
-	public static final int TT_STRING=1;
-	public static final int TT_NUMBER=2;
-	public static final int TT_SYMBOL=3;
-	public static final int TT_FORMATSTR=4;
-	public static final int TT_IF=5;
-	public static final int TT_THEN=6;
-	public static final int TT_ENDIF=7;
-	public static final int TT_STOP=8;
-	public static final int TT_OPENBRACKET=9;
-	public static final int TT_CLOSEBRACKET=10;
-	public static final int TT_LT=20;   // Don't change the sequence from LT to NT 
-	public static final int TT_GT=21;
-	public static final int TT_LE=22;
-	public static final int TT_GE=23;
-	public static final int TT_EQ=24;
-	public static final int TT_NE=25;
-	
-	int tt; // Tokentype
-	String token;
-	int line, position;
-}

Deleted: experiments/engywuck/hist-test/src/cachewolf/Tokenizer.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/Tokenizer.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/Tokenizer.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,256 +0,0 @@
-package CacheWolf;
-
-
-import ewe.util.*;
-
-/**
-*	Class to tokenise (break up) the code into single tokens, so the
-*	parser my do its job.
-*	@see Parser
-*/
-public class Tokenizer{
-
-	/** Normally only a semicolon (;) can be used to separate commands. If this variable is set to true,
-	 * newlines also terminate a command. If a newline is preceded with a backslash (=line continuation character),
-	 * the newline does not terminate the command even if this variable is true.
-	 */
-	public boolean newLineIsSeparator=true;
-	/** instructions to tokenise */
-	String mySource;
-	/** source character */
-	char look;
-	/** pointer to next character to read */
-	int sourcePointer = 0;
-	/** (partial) token */
-	String currentStream;
-	Vector TokenStack = new Vector();
-	/** position of token */
-	int currentLine, currentPos;
-	TokenObj thisToken;
-	Vector messageStack;
-	
-	public Tokenizer(){
-	}
-
-    private void err(String str) throws Exception {
-    	messageStack.add(MyLocale.getMsg(1700,&quot;Error on line: &quot;) + currentLine + &quot;  &quot;+MyLocale.getMsg(1701,&quot; position: &quot;) + currentPos);
-    	messageStack.add(str);
-    	if (Global.mainTab.solverP.mText.setSelectionRange(0,currentLine-1,currentPos,currentLine-1))Global.mainTab.solverP.mText.repaintNow();
-    	throw new Exception(&quot;Error &quot;+str);
-    }
-
-	private boolean isAlpha(char c){
-		return  &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;.indexOf(c)!=-1;
-	}
-	
-	private boolean isDigit(char c){
-		return &quot;0123456789&quot;.indexOf(c)!=-1;
-	}
-	
-	private boolean isSymbol(char c){
-		return &quot;?!&lt;&gt;(){}*/,;^+-=&quot;.indexOf(c)!=-1;
-	}
-
-	/**
-	 * Convert Unicode version of special chars to normal
-	 * @param c Char to convert
-	 * @return Converted char
-	 */
-	private char standardiseSourceChar(char c) {
-		if (c=='\u00A0' || (c&gt;='\u2002' &amp;&amp; c&lt;='\u200b')) c=' ';
-		if (c&gt;='\u2010' &amp;&amp; c&lt;='\u2015') c='-';
-		if (c&gt;='\u201c' &amp;&amp; c&lt;='\u201f') c='&quot;';
-		if (c=='[') c='(';
-		if (c==']') c=')';
-		if (c=='\u00f7' || c=='\u2044') c='/';
-		if (c=='\u2024') c='.';
-		return c;
-	}
-
-	private boolean getChar(){
-		if(sourcePointer &gt;= mySource.length()) {
-			look='\n';
-			return false; 
-		}
-		look = mySource.charAt(sourcePointer++);
-		currentPos++;
-		return true;
-	}
-	
-	private char lookAhead() {
-		if(sourcePointer &gt;= mySource.length())
-			return '\n';
-		else {
-			char c=standardiseSourceChar(mySource.charAt(sourcePointer));
-			return c;
-		}
-	}
-	
-	private void backUp() {
-		sourcePointer--;
-		currentPos--;
-	}
-	
-	/** Create a new token object and remember the place where it started. 
-	 *  String tokens could span several lines, so we need to remember the starting line and position.
-	 */
-	private void startToken() {
-		thisToken = new TokenObj();
-		thisToken.line = currentLine;
-		thisToken.position = currentPos;
-	}
-	
-	/** Add the previously started token to the token stack */
-	private void emitToken(int tt){
-//		ewe.sys.Vm.debug(currentStream);
-		thisToken.token = currentStream;
-		thisToken.tt=tt;
-		TokenStack.add(thisToken);
-		currentStream = &quot;&quot;;
-	}
-
-	private void streamAlphas(){
-		startToken();
-		while(getChar()){
-			if(isAlpha(look) || isDigit(look)) 
-				currentStream += look;
-			else 
-				break;
-		} 
-		String s=currentStream.toUpperCase();
-		if (s.equals(&quot;STOP&quot;) || s.equals(&quot;ST&quot;))
-			emitToken(TokenObj.TT_STOP);
-		else if (s.equals(&quot;IF&quot;))
-			emitToken(TokenObj.TT_IF);
-		else if (s.equals(&quot;THEN&quot;))
-			emitToken(TokenObj.TT_THEN);
-		else if (s.equals(&quot;ENDIF&quot;) || s.equals(&quot;FI&quot;))
-			{ currentStream=&quot;ENDIF&quot;; emitToken(TokenObj.TT_ENDIF); }
-		else
-			emitToken(TokenObj.TT_VARIABLE);
-		// We have read one character too far, so back off
-		backUp();
-	}
-	
-	private void streamDigits(){
-		boolean foundDecSep=false; // To check that only one decimal point is allowed in a number
-		startToken();
-		while(getChar()){
-			look=standardiseSourceChar(look);
-			if(isDigit(look) || (look=='.' &amp;&amp; !foundDecSep)) {
-				currentStream += look;
-				if (look=='.') foundDecSep=true;
-			} else
-				break;
-		}
-		emitToken(TokenObj.TT_NUMBER);
-		// We have read one character too far, so back off
-		backUp();
-	}
-	
-	private void streamString() throws Exception {
-		startToken();
-		currentStream=&quot;&quot;;
-		while(getChar()){ // collect chars until next &quot;
-			if (look=='&quot;') {
-				if (lookAhead()!='&quot;') break;  // &quot; not followed by &quot; =&gt; End of string
-				// Two &quot; following each other are replaced by &quot; 
-				currentStream+=&quot;\&quot;&quot;; 
-				getChar();
-			} else if (look=='\\') {
-				if (!getChar()) break;
-				if (look=='n') currentStream += &quot;\n&quot;;
-				else currentStream += look;
-			} else currentStream += look;
-			// Need to count newlines inside a string spanning multiple lines so that we don't loose track
-			if (look=='\n') {
-				currentLine++;
-				currentPos=0;
-			}
-		} // EOT or look==&quot;
-		if (look!='&quot;') {
-			// Restore start position of string for correct indication of error
-			currentLine=thisToken.line;
-			currentPos=thisToken.position;
-			err(MyLocale.getMsg(1730,&quot;Unterminated string&quot;));
-		}
-		emitToken(TokenObj.TT_STRING);
-		
-	}
-	
-	private void streamSymbol() {
-		startToken(); 
-		// Check for == != &lt;= &gt;= &lt;&gt; &gt;&lt; 
-		if (look=='=' || look=='!' || look=='&lt;' || look=='&gt;') {
-			getChar();
-			currentStream+=look;
-			if (currentStream.equals(&quot;==&quot;))  { emitToken(TokenObj.TT_EQ); return;}
-			if (currentStream.equals(&quot;!=&quot;) || currentStream.equals(&quot;&gt;&lt;&quot;) || currentStream.equals(&quot;&lt;&gt;&quot;)) 
-											{ emitToken(TokenObj.TT_NE); ; return;}
-			if (currentStream.equals(&quot;&lt;=&quot;)) { emitToken(TokenObj.TT_LE); return; }
-			if (currentStream.equals(&quot;&gt;=&quot;)) { emitToken(TokenObj.TT_GE); return; }
-			backUp(); // Not a valid comparison symbol, forget the last character
-			currentStream=currentStream.substring(0,1);
-			if (currentStream.equals(&quot;=&quot;)) emitToken(TokenObj.TT_EQ);
-			else if (currentStream.equals(&quot;&lt;&quot;)) emitToken(TokenObj.TT_LT);
-			else if (currentStream.equals(&quot;&gt;&quot;)) emitToken(TokenObj.TT_GT);
-			else emitToken(TokenObj.TT_SYMBOL);
-		} else
-			emitToken(TokenObj.TT_SYMBOL); 		
-	}
-
-	/** Eat up all characters until next newline as we are in a comment */
-	private void eatUpComment() {
-		while (getChar() &amp;&amp; look !='\n');
-		currentStream=&quot;;&quot;; // Insert a dummy ;
-		startToken(); 
-		emitToken(TokenObj.TT_SYMBOL);
-		currentStream=&quot;&quot;;
-		currentLine++;
-		currentPos=0;
-	}
-
-	private void formatString() throws Exception {
-		currentStream=&quot;&quot;;
-		startToken();
-		while (getChar() &amp;&amp; look!=':') {
-			look=standardiseSourceChar(look);
-			currentStream += look;
-			if (look!='.' &amp;&amp; look!='0' &amp;&amp; look!='#') err(MyLocale.getMsg(1731,&quot;Invalid format character&quot;));
-		}
-		emitToken(TokenObj.TT_FORMATSTR);
-	}
-	
-	public void tokenizeSource(String src, Vector msg){
-		mySource = src+&quot;\n&quot;;
-		sourcePointer = 0;
-		TokenStack.clear();
-		messageStack=msg;
-		currentLine = 1;
-		currentPos = 0;
-		currentStream=&quot;&quot;;
-		try {
-			while(getChar()){
-				look=standardiseSourceChar(look);
-				if (look==' ') continue;
-				currentStream += look;
-				if(isAlpha(look) || look=='$') streamAlphas();
-				else if(isDigit(look)) streamDigits();
-				else if(isSymbol(look)) streamSymbol();
-				else if(look == '&quot;') streamString();  
-				else if(look == '\n') {
-					if (newLineIsSeparator &amp;&amp; !currentStream.equals(&quot;\\\n&quot;) &amp;&amp; !currentStream.equals(&quot;_\n&quot;)) { 
-						currentStream=&quot;;&quot;;
-						startToken();
-						emitToken(TokenObj.TT_SYMBOL);
-					}
-					currentStream = &quot;&quot;; currentLine++; currentPos=0; 
-				}
-				else if(look == '#') eatUpComment();	// Ignore characters until EOL
-				else if(look == ':') formatString();
-				else if (newLineIsSeparator &amp;&amp; (look=='\\' || look=='_')) ;
-				else err(MyLocale.getMsg(1732,&quot;Invalid character&quot;)); 
-			}
-		} catch (Exception e) {}
-	}
-}

Copied: experiments/engywuck/hist-test/src/cachewolf/imp/GPXImporter.java (from rev 1559, experiments/engywuck/hist-test/src/cachewolf/GPXImporter.java)


Property changes on: experiments/engywuck/hist-test/src/cachewolf/imp/GPXImporter.java
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: experiments/engywuck/hist-test/src/cachewolf/imp/LOCXMLImporter.java (from rev 1559, experiments/engywuck/hist-test/src/cachewolf/LOCXMLImporter.java)


Property changes on: experiments/engywuck/hist-test/src/cachewolf/imp/LOCXMLImporter.java
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: experiments/engywuck/hist-test/src/cachewolf/imp/OCXMLImporter.java (from rev 1559, experiments/engywuck/hist-test/src/cachewolf/OCXMLImporter.java)


Property changes on: experiments/engywuck/hist-test/src/cachewolf/imp/OCXMLImporter.java
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: experiments/engywuck/hist-test/src/cachewolf/imp/OCXMLImporterScreen.java (from rev 1559, experiments/engywuck/hist-test/src/cachewolf/OCXMLImporterScreen.java)


Property changes on: experiments/engywuck/hist-test/src/cachewolf/imp/OCXMLImporterScreen.java
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: experiments/engywuck/hist-test/src/cachewolf/imp/SpiderGC.java (from rev 1559, experiments/engywuck/hist-test/src/cachewolf/SpiderGC.java)


Property changes on: experiments/engywuck/hist-test/src/cachewolf/imp/SpiderGC.java
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: experiments/engywuck/hist-test/src/cachewolf/myInteractivePanel.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/myInteractivePanel.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/myInteractivePanel.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,195 +0,0 @@
-package CacheWolf;
-import ewe.graphics.*;
-import ewe.ui.*;
-import ewe.util.Vector;
-import ewe.sys.*;
-import ewe.fx.*;
-
-/**
-*	This class allows handling of a user click on a cache
-*	in the radar panel.
-*	@see RadarPanel
-*/
-public class myInteractivePanel extends InteractivePanel{
-
-	MainTab mt;
-	
-	boolean penMoving = false;
-	int x1,y1,x2,y2 = 0;
-	static Color RED = new Color(255,0,0);
-	Font font = new Font(&quot;gui&quot;, Font.BOLD,Global.getPref().fontSize);
-	FontMetrics fm = getFontMetrics(font);
-	long timePenOn=0;
-	AniImage imgInfo;
-	String strDifficulty=MyLocale.getMsg(1120,&quot;Diff&quot;);
-	String strTerrain=MyLocale.getMsg(1121,&quot;Terr&quot;);
-	AniImage imgDrag; // Allows the dragging of the cache into the cachelist
-	boolean canScroll=true;
-	
-	private void clearInfo() {
-		removeImage(imgInfo);
-		imgInfo=null;
-		refresh();
-		onImage=null;
-	}
-	
-	public void imageClicked(AniImage which, Point pos){
-		long timePenOff=Vm.getTimeStampLong();
-		// If the pen rested more than 500 msec, we only display the info and don't treat it as a click
-		if (timePenOff-timePenOn&lt;500 || !Vm.isMobile()) { 
-			new String();
-			if(which instanceof RadarPanelImage){
-				RadarPanelImage ich = (RadarPanelImage)which;
-				Global.mainTab.clearDetails();				
-				mt.selectAndActive(ich.rownum);
-			}
-		} else {
-			if (imgInfo!=null) clearInfo(); 
-		}
-	}
-	
-	public void setMainTab(MainTab tb){
-		mt = tb;
-	}
-	public boolean imageMovedOn(AniImage which) {
-		timePenOn=Vm.getTimeStampLong();
-		setFont(font);
-		RadarPanelImage imgRP=(RadarPanelImage) which;
-		ewe.util.Vector cacheDB=Global.getProfile().cacheDB;
-		CacheHolder ch=(CacheHolder) cacheDB.get(imgRP.rownum);
-		String s=ch.wayPoint+&quot;  &quot;+ch.CacheSize+&quot; / &quot;+strDifficulty+&quot;=&quot;+ch.hard+&quot;  &quot;+strTerrain+&quot;=&quot;+ch.terrain;
-		String s1=ch.CacheName;
-		if (s1.length()&gt;40) s1=s1.substring(0,40);
-		int tw=fm.getTextWidth(s)+2;
-		int tw1=fm.getTextWidth(s1)+2;
-		if (tw1&gt;tw) tw=tw1;
-		int h=fm.getHeight();
-		Image img = new Image(tw,h+h);
-		Graphics g = new Graphics(img);
-		g.setFont(font);
-		g.setColor(new Color(0,0,255));
-		g.fillRect(0,0,tw, h+h);
-		g.setColor(Color.White);
-		g.drawText(s, 1,1);
-		g.drawText(s1,1,h);
-		imgInfo = new AniImage(img);
-		Rect r=getVisibleArea(null);
-		imgInfo.setLocation(r.x,r.y); // Place the info at top left corner
-		imgInfo.properties = mImage.IsNotHot;
-		addImage(imgInfo);
-		refreshOnScreen(imgInfo);
-		imgDrag=which;
-	return true;
-	}
-	public boolean imageMovedOff(AniImage which) {
-		clearInfo();
-		return true;
-	}
-	public void onPenEvent(PenEvent ev) {
-		super.onPenEvent(ev);
-		if (ev.type==PenEvent.PEN_UP) {
-			clearInfo();
-			// The next line is needed due to a bug in EWE (it does not call penReleased)
-			if (isDragging) penReleased(new Point(ev.x,ev.y));
-		}
-	}
-	
-    ///////////////////////////////////////////////////
-	//  Allow the caches to be dragged into a cachelist
-    ///////////////////////////////////////////////////
-	
-	String wayPoint;
-	
-	public void startDragging(DragContext dc) {
-		if (!Global.mainForm.cacheListVisible) return;
-		Vector cacheDB=Global.getProfile().cacheDB;
-//Vm.debug(&quot;myIAP startDrag &quot;+dc.start.x+&quot;/&quot;+dc.start.y);
-		int idx=Global.getProfile().getCacheIndex(wayPoint); 
-		if (idx&gt;=0) {
-			 CacheHolder ch=(CacheHolder) cacheDB.get(idx);
-			 //wayPoint=ch.wayPoint;
-			 //Vm.debug(&quot;Waypoint : &quot;+ch.wayPoint);
-			 IconAndText icnDrag=new IconAndText();
-			 icnDrag.addColumn(CacheType.cache2Img(ch.type));
-			 icnDrag.addColumn(ch.wayPoint);
-			 dc.dragData=dc.startImageDrag(icnDrag,new Point(8,8),this);
-			 //if (dc instanceof ImageDragContext) Vm.debug(&quot;&gt;&gt;&gt;&gt;Is Image drag&quot;);
-			 canScroll=false;
-		}
-	 }
-
-	 public void stopDragging(DragContext dc) {		 
-		canScroll=true;
-	 }
-	 public void draggingStarted(ImageDragContext dc) {}
-	 public void draggingStopped(ImageDragContext dc) {}
-	 
-	 public boolean imageBeginDragged(AniImage which,Point pos) {
-		if (!Global.mainForm.cacheListVisible) return false;
-		canScroll=false;
-		clearInfo();
-		wayPoint=null;
-		AniImage dragImage=null;
-		if (which instanceof RadarPanelImage) {
-			RadarPanelImage imgRP=(RadarPanelImage) which;
-			ewe.util.Vector cacheDB=Global.getProfile().cacheDB;
-			CacheHolder ch=(CacheHolder) cacheDB.get(imgRP.rownum);
-			wayPoint=ch.wayPoint;
-			
-			int tw,th;
-			Image img = new Image(tw=fm.getTextWidth(wayPoint+15),th=fm.getHeight()&gt;15?fm.getHeight():15);
-			Graphics g = new Graphics(img);
-			g.setFont(font);
-			g.setColor(Color.White);
-			g.fillRect(0,0,tw, th);
-			g.setColor(new Color(255,0,0));
-			g.drawText(wayPoint, 15,1);
-			g.drawImage(which.image,0,0);
-			dragImage=new AniImage(img);
-			dragImage.properties|=mImage.IsMoveable;
-			dragImage.setLocation(pos.x,pos.y);
-		}
-		return super.imageBeginDragged(dragImage,pos);
-	 }
-
-	 public boolean imageDragged(ImageDragContext drag, Point pos) {
-		 	if (drag.image!=null) {
-/*			    Point p = Gui.getPosInParent(this,getWindow());
-			 	p.x += pos.x-origin.x;
-			 	p.y += pos.y-origin.y;
-			 	Control c = getWindow().findChild(p.x,p.y);
-*/
-				drag.clearPendingDrags();
-		 	}
-		 	return super.imageDragged(drag,pos);
-	 }
-	 
-	 public boolean imageNotDragged(ImageDragContext drag, Point pos) {
-		if (drag.image!=null) {
-			images.remove(drag.image);
-			drag.image=null;
-			refresh();
-		}			
-		 Point p = Gui.getPosInParent(this,getWindow());
-		 p.x += drag.curPoint.x-origin.x;
-		 p.y += drag.curPoint.y-origin.y;
-		 Control c = getWindow().findChild(p.x,p.y);
-	     if (c instanceof mList &amp;&amp; c.text.equals(&quot;CacheList&quot;)) {
-	    	 if (Global.mainForm.cacheList.addCache(wayPoint)) {
-	    		 c.repaintNow();
-	    		 ((mList) c).makeItemVisible(((mList)c).itemsSize()-1);
-	    	 }
-	     }
-		 return false; 
-	 }
-	 
-	 public boolean canScreenScroll() {
-		 return canScroll;
-	 }
-	 public boolean scroll(int dx,int dy,Point moved) {
-		 if (canScroll)
-			 return super.scroll(dx,dy,moved);
-		 else
-			 return false;
-	 }
-}

Deleted: experiments/engywuck/hist-test/src/cachewolf/myTableControl.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/myTableControl.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/myTableControl.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,381 +0,0 @@
-package CacheWolf;
-
-import utils.CWWrapper;
-import ewe.sys.*;
-import ewe.ui.*;
-import ewe.fx.*;
-import ewe.io.File;
-import ewe.io.IOException;
-import ewe.util.*;
-
-/**
- *	Implements the user interaction of the list view. Works together with myTableModel and TablePanel
- */
-public class myTableControl extends TableControl{
-
-	public Preferences pref;
-	public Profile profile;
-	public Vector cacheDB;
-	public TablePanel tbp;
-	
-	private MenuItem miOpen, miGoto, miCenter;
-	private MenuItem miOpenOnline, miOpenOffline;
-	private MenuItem miDelete, miUpdate;
-	private MenuItem miTickAll, miUntickAll;
-	private MenuItem miSeparator;
-
-	private Menu mFull;
-	private Menu mSmall;
-
-	myTableControl(TablePanel tablePanel) {
-		profile=Global.getProfile();
-		cacheDB = profile.cacheDB;
-		pref = Global.getPref();
-		tbp =tablePanel;
-		allowDragSelection = false; // allow only one row to be selected at one time
-				
-		MenuItem[] mnuFull = new MenuItem[12];
-  	mnuFull[0] = miOpen = new MenuItem(MyLocale.getMsg(1021,&quot;Open description&quot;));
-  	mnuFull[1] = miGoto = new MenuItem(MyLocale.getMsg(1010,&quot;Goto&quot;));
-  	mnuFull[2] = miCenter = new MenuItem(MyLocale.getMsg(1019,&quot;Center&quot;));
-  	mnuFull[3] = miSeparator = new MenuItem(&quot;-&quot;);
-  	mnuFull[4] = miOpenOnline = new MenuItem(MyLocale.getMsg(1020,&quot;Open in $browser online&quot;));
-  	mnuFull[5] = miOpenOffline = new MenuItem(MyLocale.getMsg(1018,&quot;Open in browser offline&quot;));
-  	mnuFull[6] = miSeparator;
-  	mnuFull[7] = miDelete = new MenuItem(MyLocale.getMsg(1012,&quot;Delete selected&quot;));
-  	mnuFull[8] = miUpdate = new MenuItem(MyLocale.getMsg(1014,&quot;Update&quot;));
-  	mnuFull[9] = miSeparator;
-  	mnuFull[10] = miTickAll = new MenuItem(MyLocale.getMsg(1015,&quot;Select all&quot;));
-  	mnuFull[11] = miUntickAll = new MenuItem(MyLocale.getMsg(1016,&quot;De-select all&quot;));	
-  	mFull = new Menu(mnuFull, MyLocale.getMsg(1013,&quot;With selection&quot;));
-
-  	MenuItem[] mnuSmall = new MenuItem[6];
-  	mnuSmall[0] = miOpen;
-  	mnuSmall[1] = miGoto;
-  	mnuSmall[2] = miCenter;
-  	mnuSmall[3] = miSeparator;
-  	mnuSmall[4] = miOpenOnline;
-  	mnuSmall[5] = miOpenOffline;
-  	mSmall = new Menu(mnuSmall, MyLocale.getMsg(1013,&quot;With selection&quot;));	
-	}
-
-	/** Full menu when listview includes checkbox */
-	public void setMenuFull() {
-		setMenu(mFull);
-//		if (!Vm.getPlatform().equals(&quot;Win32&quot;) &amp;&amp; !Vm.getPlatform().equals(&quot;Java&quot;))
-//		   ((MenuItem)mFull.items.get(5)).modifiers|=MenuItem.Disabled;
-	}
-	
-	public Menu getMenuFull() {
-		return mFull;
-	}
-
-	/** Small menu when listview does not include checkbox */
-	public void setMenuSmall() {
-		setMenu(mSmall);
-		//if (!Vm.getPlatform().equals(&quot;Win32&quot;) &amp;&amp; !Vm.getPlatform().equals(&quot;Java&quot;))
-		//	   ((MenuItem)mSmall.items.get(5)).modifiers|=MenuItem.Disabled;
-	}
-	
-	public void penRightReleased(Point p){
-		if (cacheDB.size()&gt;0) // No context menu when DB is empty
-			menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
-	}
-	public void penHeld(Point p){
-		if (cacheDB.size()&gt;0) // No context menu when DB is empty
-			menuState.doShowMenu(p,true,null); 
-	}
-
-	public void onKeyEvent(KeyEvent ev) {
-		if (ev.type == KeyEvent.KEY_PRESS &amp;&amp; ev.target == this){
-			if ( (ev.modifiers &amp; IKeys.CONTROL) &gt; 0 &amp;&amp; ev.key == 1){ // &lt;ctrl-a&gt; gives 1, &lt;ctrl-b&gt; == 2
-				// select all on &lt;ctrl-a&gt;
-				setSelectForAll(true);
-				ev.consumed = true;
-			}
-			else  {
-				Global.mainTab.clearDetails();
-				if (ev.key == IKeys.HOME) Global.mainTab.tbP.selectRow(0); //  cursorTo(0,cursor.x+listMode,true);
-				else if (ev.key == IKeys.END) Global.mainTab.tbP.selectRow(model.numRows-1); //cursorTo(model.numRows-1,cursor.x+listMode,true);
-				else if (ev.key == IKeys.PAGE_DOWN) Global.mainTab.tbP.selectRow(java.lang.Math.min(cursor.y+ getOnScreen(null).height-1, model.numRows-1)); //cursorTo(java.lang.Math.min(cursor.y+ getOnScreen(null).height-1, model.numRows-1),cursor.x+listMode,true); // I don't know why this doesn't work: tbp.doScroll(IScroll.Vertical, IScroll.PageHigher, 1);
-				else if (ev.key == IKeys.PAGE_UP) Global.mainTab.tbP.selectRow(java.lang.Math.max(cursor.y-getOnScreen(null).height+1, 0)); // cursorTo(java.lang.Math.max(cursor.y-getOnScreen(null).height+1, 0),cursor.x+listMode,true);
-				else if (ev.key == IKeys.ACTION || ev.key == IKeys.ENTER) Global.mainTab.select(Global.mainTab.descP);
-				else if (ev.key == IKeys.DOWN) Global.mainTab.tbP.selectRow(java.lang.Math.min(cursor.y+ 1, model.numRows-1)); 
-				else if (ev.key == IKeys.UP) Global.mainTab.tbP.selectRow(java.lang.Math.max(cursor.y-1, 0));
-				else if (ev.key == IKeys.LEFT &amp;&amp; Global.mainForm.cacheListVisible &amp;&amp; cursor.y&gt;=0 &amp;&amp; cursor.y&lt;tbp.myMod.numRows) Global.mainForm.cacheList.addCache(((CacheHolder)cacheDB.elementAt(cursor.y)).wayPoint); 
-				else if (ev.key == IKeys.RIGHT) {
-					CacheHolder ch;
-					ch = (CacheHolder)cacheDB.get(tbp.getSelectedCache());
-					Global.mainTab.gotoPoint(ch.pos);
-				}
-				else if (ev.key == 6 ) MainMenu.search(); // (char)6 == ctrl + f 
-				else super.onKeyEvent(ev);
-			}
-		}
-		else super.onKeyEvent(ev);
-	}
-
-	/** Set all caches either as selected or as deselected, depending on argument */
-	private void setSelectForAll(boolean selectStatus) {
-		Global.getProfile().setSelectForAll(selectStatus);
-		tbp.refreshTable();
-	}
-	
-	 
-	/** always select a whole row */
-	public boolean isSelected(int row,int col) {
-		return row==selection.y;
-	}
-	
-	public void popupMenuEvent(Object selectedItem){
-		if (selectedItem == null) return;
-		CacheHolder ch;
-		if (selectedItem == miTickAll){
-			setSelectForAll(true);
-		}
-
-		if (selectedItem == miUntickAll){
-			setSelectForAll(false);
-		}
-
-		if (selectedItem == miDelete){
-			Vm.showWait(true);
-			// Count # of caches to delete
-			int allCount=0;
-			int mainFilteredCount=0;
-			int addiFilteredCount=0;
-			int shouldDeleteCount=0;
-			boolean deleteFiltered=true;  // Bisheriges Verhalten
-			for(int i = cacheDB.size()-1; i &gt;=0; i--){
-				CacheHolder currCache = (CacheHolder)cacheDB.get(i);
-				if ( currCache.is_Checked) {
-					allCount++;
-					if (currCache.is_filtered) {
-						if (currCache.isAddiWpt()) {
-							addiFilteredCount++;
-						} else {
-							mainFilteredCount++;
-						}
-					}
-				}
-			}
-			// Warn if there are ticked but invisible caches - and ask if they should be deleted,
-			// too.
-			shouldDeleteCount = allCount;
-			if (addiFilteredCount + mainFilteredCount &gt; 0){
-				if ((new MessageBox(MyLocale.getMsg(144,&quot;Warning&quot;),
-						            MyLocale.getMsg(1029, &quot;There are caches that are ticked but invisible.\n(Main caches: &quot;) + 
-						            	mainFilteredCount + MyLocale.getMsg(1030, &quot;, additional Waypoints: &quot;) + 
-						            	addiFilteredCount+&quot;)\n&quot; + MyLocale.getMsg(1031, &quot;Delete them, too?&quot;), 
-						            	FormBase.YESB | FormBase.NOB)).execute() == FormBase.IDYES) {
-					deleteFiltered = true;
-				} else {
-					deleteFiltered = false;
-					shouldDeleteCount = allCount - mainFilteredCount - addiFilteredCount;
-				}
-			}
-			if (shouldDeleteCount&gt;0) {
-				if ((new MessageBox(MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(1022, &quot;Delete selected caches (&quot;) + shouldDeleteCount + MyLocale.getMsg(1028, &quot;) ?&quot;), FormBase.YESB | FormBase.NOB)).execute() == FormBase.IDYES) {
-					DataMover dm=new DataMover();
-					myProgressBarForm pbf = new myProgressBarForm();
-					Handle h = new Handle();
-					pbf.setTask(h,MyLocale.getMsg(1012, &quot;Delete selected&quot;));
-					pbf.exec();
-					int nDeleted=0;
-					int size=cacheDB.size();
-					for(int i = size-1; i &gt;=0; i--){// Start Counting down, as the size decreases with each deleted cache
-						ch = (CacheHolder)cacheDB.get(i);
-						if(ch.is_Checked &amp;&amp; (!ch.is_filtered || deleteFiltered)) {
-							nDeleted++;
-							h.progress = ((float)nDeleted)/(float)allCount;
-							h.changed();
-							dm.deleteCacheFiles(ch.wayPoint,profile.dataDir);
-							cacheDB.remove(ch);
-							ch.releaseCacheDetails();
-							ch=null;
-							if (pbf.isClosed) break;
-						}
-					}
-					pbf.exit(0);
-					tbp.myMod.numRows-=nDeleted;
-					profile.saveIndex(pref,true);	
-					tbp.refreshTable();
-				}
-			}
-			Vm.showWait(false);
-		}
-				
-		if (selectedItem == miUpdate){
-			MainMenu.updateSelectedCaches(tbp);
-		}
-
-		if (selectedItem == miCenter){
-			if (tbp.getSelectedCache() &lt; 0) {
-				Global.getPref().log(&quot;popupMenuEvent: getSelectedCache() &lt; 0&quot;);
-				return;
-			}
-			CacheHolder thisCache = (CacheHolder)cacheDB.get(tbp.getSelectedCache());
-			CWPoint cp=new CWPoint(thisCache.LatLon);
-			if (!cp.isValid()){
-				MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(4111,&quot;Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM&quot;), FormBase.OKB);
-				tmpMB.execute();
-			} else {				
-				pref.curCentrePt.set(cp);
-				Global.mainTab.updateBearDist(); // Update the distances with a warning message
-				//tbp.refreshTable();
-			}
-		}
-
-		if (selectedItem == miGoto){
-			ch = (CacheHolder)cacheDB.get(tbp.getSelectedCache());
-			Global.mainTab.gotoPoint(ch.pos);
-		}
-		if (selectedItem == miOpenOnline){
-			if(browserPathIsValid()){
-				ch = (CacheHolder)cacheDB.get(tbp.getSelectedCache());
-				CacheHolderDetail chD=ch.getCacheDetails(false, true);
-				try {
-					if (chD != null) {
-						CWWrapper.exec(pref.browser, chD.URL); // maybe this works on some PDAs?
-					}
-				} catch (IOException ex) {
-					(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),
-							MyLocale.getMsg(1034,&quot;Cannot start browser!&quot;) + &quot;\n&quot; + ex.toString() + &quot;\n&quot; +
-							MyLocale.getMsg(1035,&quot;Possible reason:&quot;) + &quot;\n&quot; +
-							MyLocale.getMsg(1036,&quot;A bug in ewe VM, please be&quot;) + &quot;\n&quot; +
-							MyLocale.getMsg(1037,&quot;patient for an update&quot;),FormBase.OKB)).execute();
-				}
-			}
-		}
-		if (selectedItem == miOpenOffline) {
-			if(browserPathIsValid()){
-				ShowCacheInBrowser sc=new ShowCacheInBrowser();
-				sc.showCache(((CacheHolder)cacheDB.get(tbp.getSelectedCache())).getCacheDetails(false, true));
-			}
-		}
-		if (selectedItem == miOpen){
-			penDoubleClicked(null);
-		}
-
-	}
-	
-	public boolean browserPathIsValid() {
-		if(!new File(pref.browser).exists()){
-			(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(1032,&quot;Path to browser:&quot;)+&quot;\n&quot;+pref.browser+&quot;\n&quot;+MyLocale.getMsg(1033,&quot;is incorrect!&quot;),FormBase.OKB)).execute();
-			return false;
-		}
-		else
-			return true;
-	}
-	
-	public void penDoubleClicked(Point where) {
-		Global.mainTab.select(Global.mainTab.descP);
-	}
-	
-	public void onEvent(Event ev) {
-		if (ev instanceof PenEvent &amp;&amp; (ev.type == PenEvent.PEN_DOWN) ){
-			Global.mainTab.tbP.myMod.penEventModifiers=((PenEvent)ev).modifiers;
-	    } 
-
-		super.onEvent(ev);
-	}
-    ///////////////////////////////////////////////////
-	//  Allow the caches to be dragged into a cachelist
-    ///////////////////////////////////////////////////
-	
-	IconAndText imgDrag;
-	String wayPoint;
-	int row;
-	
-	public void startDragging(DragContext dc) {
-		Vector cacheDB=Global.getProfile().cacheDB;
-		 Point p=cellAtPoint(dc.start.x,dc.start.y,null);
-		 wayPoint=null;
-		 if (p.y&gt;=0) { 
-			if (!Global.mainForm.cacheListVisible) {
-				dc.cancelled=true;
-				return;
-			}
-			 row=p.y;
-			 CacheHolder ch=(CacheHolder)cacheDB.get(p.y);
-			 wayPoint=ch.wayPoint;
-			 //Vm.debug(&quot;Waypoint : &quot;+ch.wayPoint);
-			 imgDrag=new IconAndText();
-			 imgDrag.addColumn(CacheType.cache2Img(ch.type));
-			 imgDrag.addColumn(ch.wayPoint);
-			 dc.dragData=dc.startImageDrag(imgDrag,new Point(8,8),this);
-		 } else super.startDragging(dc);
-	 }
-
-	 public void stopDragging(DragContext dc) {
-		 if (wayPoint!=null &amp;&amp; !dc.cancelled) {
-			 //Vm.debug(&quot;Stop  Dragging&quot;+dc.curPoint.x+&quot;/&quot;+dc.curPoint.y);
-			 dc.stopImageDrag(true);
-			 Point p = Gui.getPosInParent(this,getWindow());
-			 p.x += dc.curPoint.x;
-			 p.y += dc.curPoint.y;
-			 Control c = getWindow().findChild(p.x,p.y);
-		     if (c instanceof mList &amp;&amp; c.text.equals(&quot;CacheList&quot;)) {
-		    	 if (Global.mainForm.cacheList.addCache(wayPoint)) {
-		    		 c.repaintNow();
-		    		 ((mList) c).makeItemVisible(((mList)c).itemsSize()-1);
-		    	 }
-		     }
-		     Global.mainTab.tbP.selectRow(row);
-			 //Vm.debug(&quot;Control &quot;+c.toString()+&quot;/&quot;+c.text);
-		 }else super.stopDragging(dc);
-	 }
-	 
-	 public void dragged(DragContext dc) {
-	 	if (wayPoint!=null)
-		   dc.imageDrag();
-	 	else
-	 		super.dragged(dc);
-	 }
-
-	 public void cursorTo(int row,int col,boolean selectNew) {
-		if (row != -2 &amp;&amp; col != -2 &amp;&amp; !canSelect(row,col)) return;
-		cursor.set(col,row);
-		if (selectNew){
-			clearSelectedCells(oldExtendedSelection);
-			paintCells(null,oldExtendedSelection);
-			if (row != -2 &amp;&amp; col != -2){
-				if (scrollToVisible(row,col)) repaintNow();
-				addToSelection(Rect.buff.set(0,row,model.numCols,1),true);
-				//fireSelectionEvent(TableEvent.FLAG_SELECTED_BY_ARROWKEY);
-				clickedFlags = TableEvent.FLAG_SELECTED_BY_ARROWKEY;
-				if (clickMode) clicked(row,col);
-				clickedFlags = 0;
-			}
-		}
-	 }
-
-	 /**
-	  * this is only necessary to hinder the user to unselect
-	  */
-	 public void penReleased(Point p,boolean isDouble)
-	 {
-		 Point p2 = cellAtPoint(p.x,p.y,null);
-		 super.penReleased(p, isDouble);
-		 Rect sel = getSelection(null); 
-		 if ((sel.height == 0 || sel.height == 0) &amp;&amp; p2 != null) cursorTo(p2.y,p2.x, true); // if the selection is gone -&gt; reselect it 
-			 
-	 }
-
-	 class myProgressBarForm extends ProgressBarForm {
-
-		 boolean isClosed=false;
-		 
-		 protected boolean canExit(int exitCode) {
-			isClosed=true;
-			return true;
-		 }
-		 
-	 }
-	 
-	 
-
-	public Menu getMenuSmall() {
-		return mSmall;
-	}
-}

Deleted: experiments/engywuck/hist-test/src/cachewolf/myTableModel.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/myTableModel.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/myTableModel.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,381 +0,0 @@
-package CacheWolf;
-
-import ewe.ui.*;
-import ewe.sys.*;
-import ewe.util.*;
-import ewe.fx.*;
-
-
-/**
-*	Table model used to display the cache list.
-* 	Used by the table control in the first panel of
-*	CacheWolf.
-* 20061212 salzkammergut, patch to speed up scrolling, Used MyLocale
-*/
-public class myTableModel extends TableModel{
-	
-	public static final int MAXCOLUMNS=14;
-	// Colors for Cache status (BG unless otherwise stated)
-	private static final Color COLOR_FLAGED		= new Color(255,255,0);
-	private static final Color COLOR_FOUND		= new Color(152,251,152);
-	private static final Color COLOR_OWNED		= new Color(135,206,235);
-	private static final Color COLOR_AVAILABLE	= new Color(255,69,0);
-	private static final Color COLOR_ARCHIVED	= new Color(139,37,0);
-	private static final Color COLOR_SELECTED	= new Color(198,198,198);
-	private static final Color COLOR_ARCHFND_FG	= new Color(255,0,0); // Archived &amp;&amp; Found
-	private static final Color COLOR_ARCHFND_BG	= new Color(152,251,152);	
-	private Vector cacheDB;
-	/** How the columns are mapped onto the list view. If colMap[i]=j, it means that
-	 * the element j (as per the list below) is visible in column i. 
-	 * [0]TickBox, [1]Type, [2]Distance, [3]Terrain, [4]waypoint, [5]name, [6]coordinates, 
-	 * [7]owner, [8]datehidden, [9]status, [10]distance, [11]bearing, [12] Size, [13] # of OC recommend.
-	 * [14] OC index
-	 */
-	private int[] colMap;
-	/** The column widths corresponding to the list of columns above */
-	private int[] colWidth;
-	private String [] colName = {&quot; &quot;,&quot;?&quot;,MyLocale.getMsg(1000,&quot;D&quot;),MyLocale.getMsg(1001,&quot;T&quot;),
-			MyLocale.getMsg(1002,&quot;Waypoint&quot;),&quot;Name&quot;,MyLocale.getMsg(1004,&quot;Location&quot;),
-			MyLocale.getMsg(1005,&quot;Owner&quot;),MyLocale.getMsg(1006,&quot;Hidden&quot;),MyLocale.getMsg(1007,&quot;Status&quot;),
-			MyLocale.getMsg(1008,&quot;Dist&quot;),MyLocale.getMsg(1009,&quot;Bear&quot;),MyLocale.getMsg(1017,&quot;S&quot;),
-			MyLocale.getMsg(1026,&quot;#Rec&quot;),MyLocale.getMsg(1027,&quot;OC-IDX&quot;)};
-	
-	private static Image noFindLogs[] = new Image[4];
-	private mImage red, blue, yellow, skull; // green
-	private Image checkboxTicked,checkboxUnticked;
-	private mImage bug;
-	private boolean sortAsc = false;
-	private int sortedBy = -1;
-	private FontMetrics fm;
-	private mImage picSizeMicro,picSizeSmall,picSizeReg,picSizeLarge,picSizeVLarge;
-	/** This is the modifier (Shift &amp; Control key status) for Pen Events
-	 * it is set in myTableControl.onEvent */
-	public int penEventModifiers; 
-	/** The row of the last click where the shift key was pressed */
-//	private int lastRow=-1;
-	private myTableControl tcControl;
-	public boolean showExtraWptInfo=true;
-	
-	public myTableModel(myTableControl tc, FontMetrics fm){
-		super();
-		cacheDB = Global.getProfile().cacheDB;
-		fm = this.fm;
-		tcControl = tc;
-		setColumnNamesAndWidths(); 
-		this.numRows = cacheDB.size();
-		//Dimension selrow = new Dimension(-1,1);
-		//this.cursorSize = selrow;
-		noFindLogs[0] = new Image(&quot;no_1_log.png&quot;);
-		noFindLogs[1] = new Image(&quot;no_2_log.png&quot;);
-		noFindLogs[2] = new Image(&quot;no_3_log.png&quot;);
-		noFindLogs[3] = new Image(&quot;no_4_log.png&quot;);
-		red = new mImage(&quot;red.png&quot;); red.transparentColor=Color.White;
-		blue = new mImage(&quot;blue.png&quot;); blue.transparentColor=Color.White;
-		//green = new mImage(&quot;green.png&quot;);green.transparentColor=Color.White;
-		yellow = new mImage(&quot;yellow.png&quot;);yellow.transparentColor=Color.White;
-		skull = new mImage(&quot;skull.png&quot;);skull.transparentColor=Color.DarkBlue;
-		bug = new mImage(&quot;bug_table.png&quot;);bug.transparentColor=Color.DarkBlue;
-		checkboxTicked = new Image(&quot;checkboxTicked.png&quot;);
-		checkboxUnticked= new Image(&quot;checkboxUnticked.png&quot;);
-		picSizeMicro=new mImage(&quot;sizeMicro.png&quot;); picSizeMicro.transparentColor=Color.White;
-		picSizeSmall=new mImage(&quot;sizeSmall.png&quot;); picSizeSmall.transparentColor=Color.White;
-		picSizeReg=new mImage(&quot;sizeReg.png&quot;); picSizeReg.transparentColor=Color.White;
-		picSizeLarge=new mImage(&quot;sizeLarge.png&quot;); picSizeLarge.transparentColor=Color.White;
-		picSizeVLarge=new mImage(&quot;sizeVLarge.png&quot;); picSizeVLarge.transparentColor=Color.White;
-		updateRows();
-	}
-	
-	/**
-	 * Sets the column names and widths from preferences
-	 *
-	 */
-	public void setColumnNamesAndWidths() {
-		colMap=TableColumnChooser.str2Array(Global.getPref().listColMap,0,14,0, -1);
-		colWidth=TableColumnChooser.str2Array(Global.getPref().listColWidth,10,1024,50, colMap.length);
-		numCols=colMap.length;
-		clearCellAdjustments();
-		// If the displayed columns include the checkbox, we use the full menu
-		if ((&quot;,&quot;+Global.getPref().listColMap+&quot;,&quot;).indexOf(&quot;,0,&quot;)&gt;=0)
-			tcControl.setMenuFull();
-		else
-			tcControl.setMenuSmall();
-	}
-	
-	/**
-	 * Return the column widths as a comma delimited string for storing in the preferences
-	 * @return
-	 */
-	public String getColWidths() {
-		// Update the list with the current widths
-		for (int col=0; col&lt;numCols; col++) {
-			colWidth[colMap[col]]=getColWidth(col);
-		}
-		clearCellAdjustments();
-		// Convert to string
-		StringBuffer sb=new StringBuffer(40);
-		for (int i=0; i&lt;colWidth.length; i++) {
-			if (sb.length()!=0) sb.append(',');
-			sb.append(colWidth[i]);
-		}
-		return sb.toString();
-	}
-	public void updateRows(){
-		Vector sortDB = new Vector();
-		Vector filteredDB = new Vector();
-		CacheHolder ch, addiWpt;
-		// sort cacheDB:
-		// - addi wpts are listet behind the main cache
-		// - filtered caches are moved to the end
-		int size=cacheDB.size();
-		for (int i=0; i&lt;size; i++){
-			ch = (CacheHolder) cacheDB.get(i);
-			if (ch.is_filtered) {
-				filteredDB.add(ch);
-			} else { // point is not filtered
-				if (ch.isAddiWpt()){ // unfiltered Addi Wpt
-					// check if main wpt is filtered
-					if(ch.mainCache != null) { // parent exists
-						if (ch.mainCache.is_filtered) 
-							sortDB.add(ch); // Unfiltered Addi Wpt with filtered Main Wpt, show it on its own
-						// else Main cache is not filtered, Addi will be added below main cache further down
-					} else { //Addi without main Cache
-						sortDB.add(ch);
-					}
-				} else { // Main Wpt, not filtered. Check for Addis
-					sortDB.add(ch);
-					if (ch.hasAddiWpt()){
-						for (int j=0; j&lt;ch.addiWpts.getCount();j++){
-							addiWpt = (CacheHolder)ch.addiWpts.get(j);
-							if (!addiWpt.is_filtered) sortDB.add(addiWpt);
-						}
-					}// if hasAddiWpt
-				} // if AddiWpt
-			} // if filtered
-		}
-		// rebuild database
-		cacheDB.clear();
-		cacheDB.addAll(sortDB);
-		cacheDB.addAll(filteredDB);
-		this.numRows = sortDB.getCount();
-	}
-	
-	/**
-	* Method to set the row color of the table displaying the
-	* cache list, depending on different flags set to the cache.
-	*/
-	public TableCellAttributes getCellAttributes(int row,int col,boolean  isSelected, TableCellAttributes ta){
-		ta = super.getCellAttributes(row, col, isSelected, ta);
-		ta.alignment = CellConstants.LEFT;
-		ta.anchor = CellConstants.LEFT;
-		if(row &gt;= 0){ 
-			try {
-			   CacheHolder ch = (CacheHolder)cacheDB.get(row);
-				if(isSelected == true) ta.fillColor = COLOR_SELECTED;
-				else if(ch.is_available == false &amp;&amp; ch.is_found == true){
-					ta.fillColor = COLOR_ARCHFND_BG;   // Green BG
-					ta.foreground = COLOR_ARCHFND_FG;  // Red FG
-				}
-				else if(ch.is_archived == true) ta.fillColor = COLOR_ARCHIVED;
-				else if(ch.is_available == false) ta.fillColor = COLOR_AVAILABLE;
-				else if(ch.is_owned == true) ta.fillColor = COLOR_OWNED;
-				else if(ch.is_found == true) ta.fillColor = COLOR_FOUND;
-				else if(ch.is_flaged == true) ta.fillColor = COLOR_FLAGED;
-			} catch (Exception e) {};
-		} else if (row==-1 &amp;&amp; colMap[col]==0 &amp;&amp; Global.getProfile().showBlacklisted) ta.fillColor=Color.Black;
-		return ta;
-	}
-
-	public int calculateRowHeight(int row){
-		return java.lang.Math.max(18, charHeight+4);
-	}
-
-	public int calculateColWidth(int col){
-		if(col == -1) 
-        	return 0;
-        else if (col&lt;numCols)
-        	return colWidth[colMap[col]];
-        else return 0;
-	}
-	
-	/**
-	 * Need to override this method with a null return to avoid
-	 * getCellData being called twice on each access to a cell.
-	 * For further reference see the Ewe source code.
-	 * @author skg
-	 */
-	public Object getCellText(int row, int col) {
-		return null;
-	}
-
-	public Object getCellData(int row, int col){
-		if(row == -1) return colName[colMap[col]];
-		try { // Access to row can fail if many caches are deleted
-			CacheHolder ch = (CacheHolder)cacheDB.get(row);
-			if(ch.is_filtered == false){
-				switch(colMap[col]) { // Faster than using column names
-					case 0: // Checkbox
-						if (ch.is_Checked) 
-							return checkboxTicked; 
-						else 
-							return checkboxUnticked;
-					case 1: // Type
-						return CacheType.cache2Img(ch.type);
-					case 2: // Difficulty;
-						return ch.hard;
-					case 3: // Terrain
-						return ch.terrain;
-					case 4: // Waypoint
-						if (showExtraWptInfo) {
-							if(ch.is_incomplete) return new IconAndText(skull, ch.wayPoint, fm);
-							if(ch.is_new       ) return new IconAndText(yellow, ch.wayPoint, fm);
-							if(ch.is_update    ) return new IconAndText(red, ch.wayPoint, fm); // TODO this is for sure quite inefficient, better store it, don't create always new when the table is refreshed or only scrolled
-							if(ch.is_log_update) return new IconAndText(blue, ch.wayPoint, fm);
-						}
-						return ch.wayPoint;
-					case 5: // Cachename
-						// Fast return for majority of case
-						if (!showExtraWptInfo || (ch.has_bug == false &amp;&amp; ch.noFindLogs==0)) return ch.CacheName; 
-						// Now need more checks
-						IconAndText wpVal = new IconAndText();
-						if(ch.has_bug == true) wpVal.addColumn(bug);
-						if(ch.noFindLogs &gt; 0){
-							if (ch.noFindLogs &gt; noFindLogs.length) 
-								wpVal.addColumn(noFindLogs[noFindLogs.length-1]);
-							else 
-								wpVal.addColumn(noFindLogs[ch.noFindLogs-1]);
-						}
-						wpVal.addColumn(ch.CacheName);
-						return wpVal;
-					case 6: // Location
-						return ch.LatLon;
-					case 7: // Owner
-						return ch.CacheOwner;
-					case 8: // Date hidden
-						return ch.DateHidden;
-					case 9: // Status
-						return ch.CacheStatus;
-					case 10: // Distance
-						return ch.distance;
-					case 11: // Bearing
-						return ch.bearing;
-					case 12: // Size
-						if (ch.CacheSize.length()==0) return &quot;?&quot;;
-						switch (ch.CacheSize.charAt(0)) {
-							case 'M': return picSizeMicro;
-							case 'S': return picSizeSmall;
-							case 'R': return picSizeReg;
-							case 'L': return picSizeLarge;
-							case 'V': return picSizeVLarge;
-							default: return &quot;?&quot;;
-						}
-					case 13: // OC number of recommendations
-						if (ch.wayPoint.startsWith(&quot;OC&quot;))
-							return Convert.formatInt(ch.numRecommended);
-						return null;
-					case 14: // OC rating	
-						if (ch.wayPoint.startsWith(&quot;OC&quot;))
-							return Convert.formatInt(ch.recommendationScore);
-						return null;
-				} // Switch
-			} // if
-		} catch (Exception e) { return null; }
-		return null;
-	}
-	
-	public boolean penPressed(Point onTable,Point cell){
-		boolean retval = false;
-		if (cell==null) return false;
-		try{
-			// Check whether the click is on the checkbox image
-			if (cell.y&gt;=0 &amp;&amp; colMap[cell.x]==0) {
-				Global.getProfile().selectionChanged = true;
-				if ((penEventModifiers &amp; IKeys.SHIFT)&gt;0) {
-					if (tcControl.cursor.y &gt;= 0) { // Second row being marked with shift key pressed
-						if (tcControl.cursor.y&lt;cell.y)
-							toggleSelect(tcControl.cursor.y+1,cell.y,cell.x);
-						else
-							toggleSelect(cell.y,tcControl.cursor.y-1,cell.x);
-					} else { // Remember this row as start of range, but don't toggle yet
-					}
-				} else { // Single row marked
-					toggleSelect(cell.y,cell.y,cell.x);
-				}
-			}
-			if(cell.y == -1){ // Hit a header =&gt; sort the table accordingly
-				CacheHolder ch=null;
-				// cell.x is the physical column but we have to sort by the
-				// column it is mapped into
-				int mappedCol=colMap[cell.x];
-				if (mappedCol==0) { // Click on Tickbox header
-					// Hide/unhide the additional information about a waypoint such as 
-					// travelbugs/number of notfound logs/yellow circle/red circle etc.
-					// This helps on small PDA screens
-					showExtraWptInfo=!showExtraWptInfo; 
-					this.table.repaint();
-					return true;
-				}
-				Vm.showWait(true);
-				Point a = tcControl.getSelectedCell(null);
-				if((a != null) &amp;&amp; (a.y &gt;= 0) &amp;&amp; (a.y &lt; cacheDB.size())) ch = (CacheHolder)cacheDB.get(a.y);
-				if (mappedCol == sortedBy) sortAsc=!sortAsc;
-				else sortAsc = false;
-				sortedBy = mappedCol;
-				cacheDB.sort(new MyComparer(cacheDB, mappedCol,numRows), sortAsc);
-				updateRows();
-				if(a != null){
-					int rownum = Global.getProfile().getCacheIndex(ch.wayPoint);
-					if(rownum &gt;= 0){
-						tcControl.cursorTo(rownum, 0, true);
-	/*					tcControl.scrollToVisible(rownum, 0);
-						tcControl.clearSelectedCells(new Vector());
-						for(int i= 0; i &lt; MAXCOLUMNS; i++){
-							tcControl.addToSelection(rownum,i); 
-						}
-		*/			}
-				}
-				Vm.showWait(false);
-				tcControl.update(true);
-				retval = true;
-			}
-		} catch(NullPointerException npex){
-			Global.getPref().log(&quot;NPE in myTableModel.Penpressed&quot;);
-			Vm.showWait(false);
-			}
-		return retval;
-	}
-	
-	/** Toggle the select status for a group of caches
-	 * If from==to, the addi Waypoints are also toggled if the cache is a main waypoint
-	 * If from!=to, each cache is toggled irrespective of its type (main or addi)
-	 * @param from index of first cache to toggle
-	 * @param to index of last cache to toggle
-	 * @param x is column of checkbox (does not have to be 0)
-	 */
-	void toggleSelect(int from, int to, int x) {
-		CacheHolder ch;
-		boolean singleRow= from == to;
-		for (int j=from; j&lt;=to; j++) {
-			ch=(CacheHolder) cacheDB.get(j);
-			ch.is_Checked= !ch.is_Checked; 
-			tcControl.repaintCell(j, x);
-			// set the ceckbox also for addi wpts
-			if (ch.hasAddiWpt() &amp;&amp; singleRow){
-				CacheHolder addiWpt;
-				int addiCount=ch.addiWpts.getCount();
-				for (int i=0;i&lt;addiCount;i++){
-					addiWpt = (CacheHolder)ch.addiWpts.get(i);
-					addiWpt.is_Checked = ch.is_Checked;
-					if (!addiWpt.is_filtered){
-						tcControl.repaintCell(cacheDB.find(addiWpt), x);
-					}
-				}
-				
-			}
-		}		
-	}
-	public void select(int row,int col,boolean selectOn) {
-		//super.select(row, col, selectOn);
-		tcControl.cursorTo(row, col, true);
-	}
-	
-}

Deleted: experiments/engywuck/hist-test/src/cachewolf/utils/CWWrapper.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/utils/CWWrapper.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/utils/CWWrapper.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,34 +0,0 @@
-package utils;
-import ewe.sys.*;
-
-/**
- * Class built as a wrapper for the buggy^Winconsistent Vm.exec
- * in EWE Version 1.49
- * It identifies the plattform and uses a different call
- * to Vm.exec() depending on the plattform.
- * Bugs identified:
- * ewe.jar: cmd needs quoting, arg are whitespace-split
- * Unix VM: cmd must not be quoted, arg can be only one
- * Win* VM: cmd may be quoted, arg are whitespace-split
- */
-public class CWWrapper {
-	/**
-	 * Apply needed quotes around the command or the argument,
-	 * then call Vm.exec() appropriately.
-	 * @param cmd
-	 * @param arg (only one argument)
-	 * @throws ewe.io.IOException
-	 */
-	public static void exec(String cmd, String arg) throws ewe.io.IOException{
-		if (Vm.getPlatform().equals(&quot;WinCE&quot;) ||
-		    Vm.getPlatform().equals(&quot;Win32&quot;)) {
-			/* we need extra quotes here, see vm/nmwin32_c.c */
-			arg = &quot;\&quot;&quot; + arg + &quot;\&quot;&quot;;
-		} else if (Vm.getPlatform().equals(&quot;Java&quot;)) {
-			/* we need extra quotes here, see ewe/sys/Vm.java */
-			cmd = &quot;\&quot;&quot; + cmd + &quot;\&quot;&quot;;
-			arg = &quot;\&quot;&quot; + arg + &quot;\&quot;&quot;;
-		}
-		Vm.exec(cmd, arg, 0, false);
-	}
-}

Deleted: experiments/engywuck/hist-test/src/cachewolf/utils/FileBugfix.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/utils/FileBugfix.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/utils/FileBugfix.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,125 +0,0 @@
-/**
- * 
- */
-package utils;
-
-import CacheWolf.STRreplace;
-import ewe.io.*;
-import ewe.util.FileComparer;
-import ewe.util.mString;
-/**
- * @author pfeffer
- * class to fix a bug in ewe.io.File, which occurs only on some systems (e.g. linux): the mask &quot;*.xyz&quot; doesn't work
- * so I get all the files wich null in spite of the mask and filter afterwords 
- */
-public class FileBugfix extends File{
-	public FileBugfix(String path) {
-		super(STRreplace.replace(path, &quot;//&quot;, &quot;/&quot;));
-	}
-
-	public String[] list(final String mask,final int listAndSortOptions)
-	{
-		return listBugFixed(mask, listAndSortOptions);
-		/*
-		 * super.list has on some systems (linux, but also Windows Mobile 2003) a bug 
-		 * in ewe 1.49: 
-		 * when filenames contain more than one &quot;.&quot;, 
-		 * then the mask matches on these systems the first in spite of the last &quot;.&quot;
-		 * listmultiple doesn't have this bug 
-		 */
-	}
-	public String [] listMultiple(final String compositeMask,final int listAndSortOptions) {
-		/* super.listMultiple in ewe 1.49
-		 * usually works correct, but when called with Option Dirs_Only, it gives the dirs 
-		 * twice (once filtered by mask, once all)
-		 */
-		return listBugFixed (compositeMask, listAndSortOptions);
-	}
-
-	public String[] listBugFixed(final String compositeMask,final int listAndSortOptions) {
-		File ewefile = ewe.sys.Vm.newFileObject();
-		ewefile.set(null, name);
-
-		String mask = (compositeMask == null) ? &quot;*.*&quot; : compositeMask; 
-		String[] found; //the following code is mainly copoed from FileBase.listmultiple to avoid recursion it is not called
-		char c = mask.indexOf(',') == -1 ? ';' : ',';
-		String masks [] = mString.split(mask,c);
-		String dirs [] = new String[0];
-		if ((listAndSortOptions &amp; LIST_FILES_ONLY) == 0)
-			dirs = ewefile.list(null,LIST_DIRECTORIES_ONLY); // add dirs if not only asked for files
-		if ((listAndSortOptions &amp; LIST_DIRECTORIES_ONLY) == 0)
-			found = ewefile.list(null,FileBase.LIST_FILES_ONLY|listAndSortOptions); // add files if not dirs only
-		else {
-			found = dirs; // if dirs only -&gt; aplpy masks to the dirs
-			dirs = new String[0]; // this line is missing in ewe FileBase.listmultiple -&gt; doubled dirs when using listmultiple with the option dirs_only
-		}
-		if (found == null) return null;
-		ewe.util.FileComparer [] fcs = new ewe.util.FileComparer[masks.length];
-
-		for (int i = 0; i&lt;masks.length; i++)
-			fcs[i] = new FileComparer(ewefile,ewe.sys.Vm.getLocale(),listAndSortOptions,masks[i]);
-		int left = found.length;
-		for (int i = 0; i&lt;found.length; i++){
-			boolean matched = false;
-			for (int f = 0; f&lt;fcs.length; f++){
-				if (fcs[f].matches(found[i])){
-					matched = true;
-					break;
-				}
-			}
-			if (!matched) {
-				found[i] = null;
-				left--;
-			}
-		}
-		String [] isMatching = new String[dirs.length+left];
-		ewe.sys.Vm.copyArray(dirs,0,isMatching,0,dirs.length);
-		for (int i = 0, d = dirs.length; i&lt;found.length; i++)
-			if (found[i] != null)
-				isMatching[d++] = found[i];
-		found = isMatching;
-		return found;
-	}
-
-	/**
-	 * this is needed in order to be able to use the simulated 
-	 * file system _filesystem.zip when running as applet 
-	 */
-	public boolean exists() {
-		File ewefile = ewe.sys.Vm.newFileObject();
-		ewefile.set(null, name);
-		return (ewefile.exists());
-	}
-
-	public boolean isDirectory() {
-		File ewefile = ewe.sys.Vm.newFileObject();
-		ewefile.set(null, name);
-		return (ewefile.isDirectory());
-	}
-
-	public boolean createDir() {
-		File ewefile = ewe.sys.Vm.newFileObject();
-		ewefile.set(null, name);
-		return (ewefile.createDir());
-
-	}
-	public boolean delete() {
-		File ewefile = ewe.sys.Vm.newFileObject();
-		ewefile.set(null, name);
-		return (ewefile.delete());
-	}
-	public int getLength() {
-		File ewefile = ewe.sys.Vm.newFileObject();
-		ewefile.set(null, name);
-		return (ewefile.getLength());
-	}
-
-	public String getDrivePath() {
-		File ewefile = ewe.sys.Vm.newFileObject();
-		ewefile.set(null, name);
-		return (ewefile.getDrivePath());
-	}
-
-
-
-}

Deleted: experiments/engywuck/hist-test/src/cachewolf/utils/MessageBoxFixed.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/utils/MessageBoxFixed.java	2008-10-26 13:59:52 UTC (rev 1563)
+++ experiments/engywuck/hist-test/src/cachewolf/utils/MessageBoxFixed.java	2008-10-26 14:34:32 UTC (rev 1564)
@@ -1,67 +0,0 @@
-/* $Id$ */
-
-package utils;
-
-import ewe.sys.Vm;
-import ewe.sys.mThread;
-import ewe.ui.MessageBox;
-/**
- * this class can be needed, because ewe v1.49 cannot display messageBoxes
- * in some special threds &lt;br&gt;
- * &lt;br&gt; but as of CacheWolf v1.0 this class is not used &lt;br&gt;
- * &lt;br&gt; It is included in order to have it available and to include the
- * knowledge about ewe-threading problems, described in comments here &lt;br&gt;
- * This class is not mature -&gt; make it mature or use it only when
- * you get in the ewe-vm the exception: ewe.sys Event Direction Exception: This Task cannot be done within a timer tick &lt;br&gt;
- * when you use the normal MessageBox
- * @author pfeffer
- *
- */
-public class MessageBoxFixed {
-	String title, text;
-	int type;
-	int ret;
-	boolean done;
-	static int debug = 0;
-	public MessageBoxFixed(String title_, String text_, int type_) {
-		set(title_, text_, type_);
-	}
-	public void set(String title_, String text_, int type_) {
-		title = title_;
-		text = text_;
-		type = type_;
-	}
-
-	public int execute() {
-		//Vm.debug(&quot;aufruf: &quot; + debug);
-		//debug++;
-/*	// this code is a beginning of code to determine, if a new mThread is needed
- 		Vm.debug(&quot;t .&quot; + mThread.inThread());
-		MessageBox mb = new MessageBox(title,  text, type);
-		ret = mb.execute();
-*/
-		MBThread t = new MBThread();  // start a new thread is necessary because the simple ewe v1.49 threading model doesn't allow displaying of a messageBox in this kind of thread
-		t.start();
-		done = false;
-		while (!done) {
-			//Vm.debug(&quot;A&quot;);
-			//mThread.yield(100); // this seem to be without effect in ewe-vm v1.49
-			try { mThread.sleep(100); } catch (InterruptedException e) {
-		//		Vm.debug(&quot;interrupted&quot;); // never reached, even if interrupted is explicitly called
-			}
-		}
-		return ret;
-	}
-
-	class MBThread extends mThread {
-		public MessageBox mb;
-		public void run() {
-			mb = new MessageBox(title,  text, type);
-			mb.show();
-			done = false;
-			mb.waitUntilClosed();
-			done = true;
-			// interrupt(); this doesn't work at all, neither in sun-vm nor in ewe-vm v1.49
-		}
-	}
-}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001457.html">[Cachewolf-svn] r1563 - in	experiments/engywuck/hist-test/src/cachewolf: . utils
</A></li>
	<LI>Next message: <A HREF="001459.html">[Cachewolf-svn] r1565 - in	experiments/engywuck/hist-test/src/cachewolf: . exp imp navi utils
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1458">[ date ]</a>
              <a href="thread.html#1458">[ thread ]</a>
              <a href="subject.html#1458">[ subject ]</a>
              <a href="author.html#1458">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
