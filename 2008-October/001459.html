<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r1565 - in	experiments/engywuck/hist-test/src/cachewolf: . exp imp navi utils
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1565%20-%20in%0A%09experiments/engywuck/hist-test/src/cachewolf%3A%20.%20exp%20imp%20navi%20utils&In-Reply-To=%3C200810261441.m9QEfxb0010880%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001458.html">
   <LINK REL="Next"  HREF="001460.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r1565 - in	experiments/engywuck/hist-test/src/cachewolf: . exp imp navi utils</H1>
    <B>engywuck at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1565%20-%20in%0A%09experiments/engywuck/hist-test/src/cachewolf%3A%20.%20exp%20imp%20navi%20utils&In-Reply-To=%3C200810261441.m9QEfxb0010880%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r1565 - in	experiments/engywuck/hist-test/src/cachewolf: . exp imp navi utils">engywuck at mail.berlios.de
       </A><BR>
    <I>Sun Oct 26 15:41:59 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001458.html">[Cachewolf-svn] r1564 - in	experiments/engywuck/hist-test/src/cachewolf: . imp utils
</A></li>
        <LI>Next message: <A HREF="001460.html">[Cachewolf-svn] r1566 - in experiments/engywuck/hist-test/programs:	. resources
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1459">[ date ]</a>
              <a href="thread.html#1459">[ thread ]</a>
              <a href="subject.html#1459">[ subject ]</a>
              <a href="author.html#1459">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: engywuck
Date: 2008-10-26 15:40:13 +0100 (Sun, 26 Oct 2008)
New Revision: 1565

Added:
   experiments/engywuck/hist-test/src/cachewolf/URL.java
   experiments/engywuck/hist-test/src/cachewolf/URLStreamHandler.java
   experiments/engywuck/hist-test/src/cachewolf/imp/DBImporter.java
Modified:
   experiments/engywuck/hist-test/src/cachewolf/Attribute.java
   experiments/engywuck/hist-test/src/cachewolf/Attributes.java
   experiments/engywuck/hist-test/src/cachewolf/AttributesSelector.java
   experiments/engywuck/hist-test/src/cachewolf/AttributesViewer.java
   experiments/engywuck/hist-test/src/cachewolf/CWPoint.java
   experiments/engywuck/hist-test/src/cachewolf/CacheHolder.java
   experiments/engywuck/hist-test/src/cachewolf/CacheHolderDetail.java
   experiments/engywuck/hist-test/src/cachewolf/CacheList.java
   experiments/engywuck/hist-test/src/cachewolf/CacheType.java
   experiments/engywuck/hist-test/src/cachewolf/CacheWolf.java
   experiments/engywuck/hist-test/src/cachewolf/CalcPanel.java
   experiments/engywuck/hist-test/src/cachewolf/CenterScreen.java
   experiments/engywuck/hist-test/src/cachewolf/CoordsScreen.java
   experiments/engywuck/hist-test/src/cachewolf/DataMover.java
   experiments/engywuck/hist-test/src/cachewolf/DateTimeChooser.java
   experiments/engywuck/hist-test/src/cachewolf/DescriptionPanel.java
   experiments/engywuck/hist-test/src/cachewolf/DetailsPanel.java
   experiments/engywuck/hist-test/src/cachewolf/Filter.java
   experiments/engywuck/hist-test/src/cachewolf/FilterScreen.java
   experiments/engywuck/hist-test/src/cachewolf/GPSPortOptions.java
   experiments/engywuck/hist-test/src/cachewolf/Global.java
   experiments/engywuck/hist-test/src/cachewolf/HintLogPanel.java
   experiments/engywuck/hist-test/src/cachewolf/HttpConnection.java
   experiments/engywuck/hist-test/src/cachewolf/ImageDetailScreen.java
   experiments/engywuck/hist-test/src/cachewolf/ImagePanel.java
   experiments/engywuck/hist-test/src/cachewolf/InfoBox.java
   experiments/engywuck/hist-test/src/cachewolf/InfoHtmlScreen.java
   experiments/engywuck/hist-test/src/cachewolf/Log.java
   experiments/engywuck/hist-test/src/cachewolf/LogList.java
   experiments/engywuck/hist-test/src/cachewolf/MainForm.java
   experiments/engywuck/hist-test/src/cachewolf/MainMenu.java
   experiments/engywuck/hist-test/src/cachewolf/MainTab.java
   experiments/engywuck/hist-test/src/cachewolf/MyEditor.java
   experiments/engywuck/hist-test/src/cachewolf/MyLocale.java
   experiments/engywuck/hist-test/src/cachewolf/MyScrollBarPanel.java
   experiments/engywuck/hist-test/src/cachewolf/NewProfileForm.java
   experiments/engywuck/hist-test/src/cachewolf/NewProfileWizard.java
   experiments/engywuck/hist-test/src/cachewolf/Parser.java
   experiments/engywuck/hist-test/src/cachewolf/Preferences.java
   experiments/engywuck/hist-test/src/cachewolf/PreferencesScreen.java
   experiments/engywuck/hist-test/src/cachewolf/Profile.java
   experiments/engywuck/hist-test/src/cachewolf/ProfilesForm.java
   experiments/engywuck/hist-test/src/cachewolf/RadarPanel.java
   experiments/engywuck/hist-test/src/cachewolf/RebuildIndex.java
   experiments/engywuck/hist-test/src/cachewolf/SearchCache.java
   experiments/engywuck/hist-test/src/cachewolf/ShowCacheInBrowser.java
   experiments/engywuck/hist-test/src/cachewolf/SolverPanel.java
   experiments/engywuck/hist-test/src/cachewolf/StatusBar.java
   experiments/engywuck/hist-test/src/cachewolf/TableColumnChooser.java
   experiments/engywuck/hist-test/src/cachewolf/TableForm.java
   experiments/engywuck/hist-test/src/cachewolf/TablePanel.java
   experiments/engywuck/hist-test/src/cachewolf/Test.java
   experiments/engywuck/hist-test/src/cachewolf/Travelbug.java
   experiments/engywuck/hist-test/src/cachewolf/TravelbugJourney.java
   experiments/engywuck/hist-test/src/cachewolf/TravelbugJourneyList.java
   experiments/engywuck/hist-test/src/cachewolf/TravelbugJourneyScreen.java
   experiments/engywuck/hist-test/src/cachewolf/TravelbugList.java
   experiments/engywuck/hist-test/src/cachewolf/TravelbugPickup.java
   experiments/engywuck/hist-test/src/cachewolf/TravelbugScreen.java
   experiments/engywuck/hist-test/src/cachewolf/UrlFetcher.java
   experiments/engywuck/hist-test/src/cachewolf/Version.java
   experiments/engywuck/hist-test/src/cachewolf/exp/ASCExporter.java
   experiments/engywuck/hist-test/src/cachewolf/exp/DistanceComparer.java
   experiments/engywuck/hist-test/src/cachewolf/exp/ExploristExporter.java
   experiments/engywuck/hist-test/src/cachewolf/exp/Exporter.java
   experiments/engywuck/hist-test/src/cachewolf/exp/GPXExporter.java
   experiments/engywuck/hist-test/src/cachewolf/exp/HTMLExporter.java
   experiments/engywuck/hist-test/src/cachewolf/exp/KMLExporter.java
   experiments/engywuck/hist-test/src/cachewolf/exp/LocExporter.java
   experiments/engywuck/hist-test/src/cachewolf/exp/MSARCSVExporter.java
   experiments/engywuck/hist-test/src/cachewolf/exp/OVLExporter.java
   experiments/engywuck/hist-test/src/cachewolf/exp/OziExporter.java
   experiments/engywuck/hist-test/src/cachewolf/exp/PCX5Exporter.java
   experiments/engywuck/hist-test/src/cachewolf/exp/TPLExporter.java
   experiments/engywuck/hist-test/src/cachewolf/exp/TomTomExporter.java
   experiments/engywuck/hist-test/src/cachewolf/exp/TomTomExporterScreen.java
   experiments/engywuck/hist-test/src/cachewolf/imp/GPXImporter.java
   experiments/engywuck/hist-test/src/cachewolf/imp/KMLImporter.java
   experiments/engywuck/hist-test/src/cachewolf/imp/LOCXMLImporter.java
   experiments/engywuck/hist-test/src/cachewolf/imp/OCXMLImporter.java
   experiments/engywuck/hist-test/src/cachewolf/imp/OCXMLImporterScreen.java
   experiments/engywuck/hist-test/src/cachewolf/imp/SpiderGC.java
   experiments/engywuck/hist-test/src/cachewolf/navi/Area.java
   experiments/engywuck/hist-test/src/cachewolf/navi/AreaList.java
   experiments/engywuck/hist-test/src/cachewolf/navi/CWGPSPoint.java
   experiments/engywuck/hist-test/src/cachewolf/navi/Ellipsoid.java
   experiments/engywuck/hist-test/src/cachewolf/navi/GeodeticCalculator.java
   experiments/engywuck/hist-test/src/cachewolf/navi/GkPoint.java
   experiments/engywuck/hist-test/src/cachewolf/navi/GotoPanel.java
   experiments/engywuck/hist-test/src/cachewolf/navi/MapImage.java
   experiments/engywuck/hist-test/src/cachewolf/navi/MapImporter.java
   experiments/engywuck/hist-test/src/cachewolf/navi/MapInfoObject.java
   experiments/engywuck/hist-test/src/cachewolf/navi/MapLoader.java
   experiments/engywuck/hist-test/src/cachewolf/navi/MapLoaderGui.java
   experiments/engywuck/hist-test/src/cachewolf/navi/MapSymbol.java
   experiments/engywuck/hist-test/src/cachewolf/navi/MapsList.java
   experiments/engywuck/hist-test/src/cachewolf/navi/MovingMap.java
   experiments/engywuck/hist-test/src/cachewolf/navi/Navigate.java
   experiments/engywuck/hist-test/src/cachewolf/navi/SelectMap.java
   experiments/engywuck/hist-test/src/cachewolf/navi/SkyOrientation.java
   experiments/engywuck/hist-test/src/cachewolf/navi/Track.java
   experiments/engywuck/hist-test/src/cachewolf/navi/TrackOverlay.java
   experiments/engywuck/hist-test/src/cachewolf/navi/TrackPoint.java
   experiments/engywuck/hist-test/src/cachewolf/navi/TransformCoordinates.java
   experiments/engywuck/hist-test/src/cachewolf/navi/TransformCoordinatesProperties.java
   experiments/engywuck/hist-test/src/cachewolf/utils/Common.java
   experiments/engywuck/hist-test/src/cachewolf/utils/DateFormat.java
   experiments/engywuck/hist-test/src/cachewolf/utils/Extractor.java
   experiments/engywuck/hist-test/src/cachewolf/utils/Matrix.java
   experiments/engywuck/hist-test/src/cachewolf/utils/ParseLatLon.java
   experiments/engywuck/hist-test/src/cachewolf/utils/STRreplace.java
   experiments/engywuck/hist-test/src/cachewolf/utils/SafeXML.java
Log:
Replacing old source files with new (eve aware) ones. Now THAT'S a fine thing :-)

Modified: experiments/engywuck/hist-test/src/cachewolf/Attribute.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/Attribute.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/Attribute.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,7 +1,8 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.fx.mImage;
-import ewe.io.File;
+import eve.fx.Picture;
+import eve.io.File;
+import cachewolf.utils.STRreplace;
 
 /**
  * This class represents a single attribute
@@ -12,7 +13,7 @@
 	// Constructors
 	public Attribute() { attNo=0; }
 	public Attribute(String attributeName) { attNo=attName2int(attributeName); }
-	
+
 	private int attNo;
 
 	public int getAttrNr () { return attNo; }
@@ -21,7 +22,7 @@
 	 * The attribute names are identical to the image names.
 	 * Internally the first image name has number 0, the next number 1 and so on.
 	 */
-	public static final String [] attributeNames= {
+	protected static final String [] attributeNames= {
 			&quot;error.gif&quot;,			//00 Unknown attribute
 			&quot;available-no.gif&quot;, 	//01 not 24-7
 			&quot;available-yes.gif&quot;, 	//02 available 24-7
@@ -39,7 +40,7 @@
 			&quot;cliff-yes.gif&quot;, 		//14 falling-rocks nearby
 			&quot;climbing-no.gif&quot;, 		//15 no difficult climbing
 			&quot;climbing-yes.gif&quot;, 	//16 difficult climbing
-			&quot;compass-no.gif&quot;, 		//17 
+			&quot;compass-no.gif&quot;, 		//17
 			&quot;compass-yes.gif&quot;,		//18
 			&quot;cow-no.gif&quot;, 			//19
 			&quot;cow-yes.gif&quot;, 			//20 watch for livestock
@@ -109,17 +110,16 @@
 			&quot;wheelchair-yes.gif&quot;, 	//84 wheelchair accessible
 			&quot;winter-no.gif&quot;, 		//85 not available for winter
 			&quot;winter-yes.gif&quot;, 		//86 available in winter
-			&quot;firstaid-no.gif&quot;,              //87 does not need maintenance
-			&quot;firstaid-yes.gif&quot;,              //88 needs maintenance
+			&quot;firstaid-no.gif&quot;,      //87 does not need maintenance
+			&quot;firstaid-yes.gif&quot;,     //88 needs maintenance
 			&quot;flashlight-yes.gif&quot;    // 89 Flashlight required
 	};
-	private static mImage [] attributeImages=new mImage[90];
+	private static Picture [] attributeImages=new Picture[90];
 	private static String IMAGEDIR=STRreplace.replace(File.getProgramDirectory()+&quot;/attributes/&quot;, &quot;//&quot;, &quot;/&quot;);
-	
 	public static String getImageDir() {
-		return IMAGEDIR; 
+		return IMAGEDIR;
 	}
-    
+
     /**
      * Returns the image name for a give attribute number
      * @return Image Name
@@ -127,9 +127,9 @@
 	public String getImageName(){
 		if (attNo&gt;attributeNames.length)
 			return &quot;error.gif&quot;;
-		else return attributeNames[attNo];
+		return attributeNames[attNo];
 	}
-	
+
 	/**
 	 * Returns the text description of the image
 	 * @return Text description of Image
@@ -137,32 +137,32 @@
 	public String getInfo(){
 		return MyLocale.getMsg(2500+attNo,&quot;No attribute info found&quot;);
 	}
-	
+
 	/**
 	 * Returns the width of the attribute icons
-	 * @return The width of the images 
+	 * @return The width of the images
 	 */
 	public static int getImageWidth() {
 		initErrorImg();
-		return attributeImages[0].image.getWidth();
+		return attributeImages[0].getWidth();
 	}
-	
+
     /**
      * Get the image for a given attribute number. We use lazy initialisation here, i.e. the images are only
-     * loaded when they are requested. 
+     * loaded when they are requested.
      * @param attNo The attribute number
      * @return
      */
-    public mImage getImage() {
+    public Picture getImage() {
     	if (attNo&lt;0 || attNo&gt;=attributeNames.length) {
     		return attributeImages[0];
     	}
     	if (attributeImages[attNo]==null) {
-    		attributeImages[attNo]=new mImage(IMAGEDIR+attributeNames[attNo]);
+    		attributeImages[attNo]=new Picture(IMAGEDIR+attributeNames[attNo]);
     	}
     	return attributeImages[attNo];
     }
-    
+
 	/**
      * Encode an attribute name with the internal attribute number
      * @param attributeName The attribute name (=filename) to encode
@@ -177,12 +177,12 @@
     }
 
     private static void initErrorImg() {
-		if (attributeImages[0]==null) attributeImages[0]=new mImage(IMAGEDIR+&quot;error.gif&quot;);
+		if (attributeImages[0]==null) attributeImages[0]=new Picture(IMAGEDIR+&quot;error.gif&quot;);
     }
-    
+
     { // Static initialisation of error image
     	initErrorImg();
     }
 
-	
+
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/Attributes.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/Attributes.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/Attributes.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,7 +1,9 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.fx.*;
+import cachewolf.utils.Extractor;
+import eve.fx.*;
 
+
 public class Attributes {
 	public final static int MAXATTRIBS=12;
 	/**
@@ -16,7 +18,7 @@
 	public long attributesYes;
 	public long attributesNo;
 
-	public Attributes() { 
+	public Attributes() {
 	}
 
 	/**
@@ -25,7 +27,7 @@
 	 */public int getCount(){
 		return count;
 	}
-	
+
 	/**
 	 * Clear the attributes list
 	 *
@@ -35,13 +37,13 @@
 		attributesYes=0;
 		attributesNo=0;
 	}
-	
+
     ////////////////////////////////////////////////
     // Attribute set functions
     ////////////////////////////////////////////////
-	
-	public void XmlAttributesStart() {}
-	public void XmlAttributesEnd(String elem){
+
+	public void xmlAttributesStart() {}
+	public void xmlAttributesEnd(String elem){
 		clear();
 		Extractor ex=new Extractor(elem,&quot;&lt;ATT&gt;&quot;,&quot;&lt;/ATT&gt;&quot;,0,true);
 		String dummy = ex.findNext();
@@ -51,15 +53,15 @@
 		}
 	}
 
-	public void XmlAttributeStart(){}
-	public void XmlAttributeEnd(String elem){
+	public void xmlAttributeStart(){}
+	public void xmlAttributeEnd(String elem){
 		add(elem);
 	}
 
 	/*
-	 * Prepare for attributes to be written to cache.xml file 
+	 * Prepare for attributes to be written to cache.xml file
 	 */
-	public String XmlAttributesWrite(){
+	public String xmlAttributesWrite(){
 		StringBuffer sb=new StringBuffer(1000);
 		sb.append(&quot;&lt;ATTRIBUTES&gt;\n&quot;);
 		for (int i=0; i&lt;count; i++) {
@@ -70,7 +72,7 @@
 		sb.append(&quot;&lt;/ATTRIBUTES&gt;\n&quot;);
 		return sb.toString();
 	}
-	
+
 	/**
 	 * Add a new attributes
 	 * @param attributeName
@@ -86,7 +88,7 @@
 					attributesNo |= (1l &lt;&lt; ( (long)(Math.ceil(attr.getAttrNr() / 2.0) - 1.0) ) );
 			}
 		}
-	}
+    }
 
 	/**
 	 * Get the name of the i'th attribute in the list
@@ -97,13 +99,13 @@
 		if (i&gt;=0 &amp;&amp; i&lt;count) return attribs[i].getImageName();
 		return &quot;error.gif&quot;;
 	}
-	
+
 	/**
 	 * Get the image corresponding to an attribute
 	 * @param i The number of the attribute for which the image is to be retrieved
-	 * @return The mImage of the attribute
+	 * @return The Picture of the attribute
 	 */
-	public mImage getImage(int i) {
+	public Picture getImage(int i) {
 		if (i&gt;=0 &amp;&amp; i&lt;count) return attribs[i].getImage();
 		return new Attribute().getImage();
 	}

Modified: experiments/engywuck/hist-test/src/cachewolf/AttributesSelector.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/AttributesSelector.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/AttributesSelector.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,21 +1,23 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.fx.*;
-import ewe.graphics.*;
-import ewe.ui.*;
+import eve.fx.*;
+import eve.sys.*;
+import eve.ui.*;
+import eve.ui.game.*;
+import eve.ui.event.*;
 
 public class AttributesSelector extends Panel {
-	protected static int TILESIZE=22; // Here we always use the small icons thus tilesize=22
+	protected static final int TILESIZE=22; // Here we always use the small icons thus tilesize=22
 	public long selectionMaskYes = 0;
 	public long selectionMaskNo = 0;
-	protected mLabel mInfo;
+	protected Label mInfo;
 
 	public AttributesSelector() {
 		//Rect r = new Rect(0,0,TILESIZE * ICONS_PER_ROW,TILESIZE * ICONROWS); // As on GC: 6 wide, 2 high
 		iap.virtualSize = new Rect(0,0,200,200);
 		iap.setPreferredSize(170, 155);
 		addLast(iap,CellConstants.STRETCH,FILL);
-		addLast(mInfo=new mLabel(&quot;&quot;),HSTRETCH,HFILL);
+		addLast(mInfo=new Label(&quot;&quot;),HSTRETCH,HFILL);
 	}
 
 	public void setSelectionMasks(long yes, long no) {
@@ -24,19 +26,19 @@
 		showAttributePalette();
 	}
 
-	protected class attAniImage extends AniImage {
+	protected class AttAniImage extends AniImage {
 		public String info;
 		public String attrName;
 		public String value;
 		public int attrNr;
 		public long bitMask;
-		attAniImage (mImage img) {
+		AttAniImage (ImageData img) {
 			super(img);
 		}
-		attAniImage (attAniImage cp, String val) {
+		AttAniImage (AttAniImage cp, String val) {
 			//super(null);
-			mImage rawImg=new mImage(Attribute.getImageDir() + cp.attrName + val );
-			setMImage (rawImg.getHeight()!=20 ? rawImg.scale(20,20,null,Image.FOR_DISPLAY) : rawImg  );
+			PixelBuffer rawImg=new PixelBuffer(Attribute.getImageDir() + cp.attrName + val );
+			change (rawImg.getHeight()!=20 ? rawImg.scale(20,20) : rawImg  );
 			value = val;
 			info = MyLocale.getMsg( value.equals(&quot;-no.gif&quot;) ? (2500+cp.attrNr-1) : 2500+cp.attrNr,&quot;No attribute info found&quot;);
 			attrName = cp.attrName;
@@ -46,10 +48,10 @@
 		}
 	}
 	
-	protected class attInteractivePanel extends InteractivePanel {
+	protected class AttInteractivePanel extends InteractivePanel {
 				public boolean imageMovedOn(AniImage which) {
-			if (!((attAniImage)which).info.startsWith(&quot;*&quot;)) { // If text starts with * we have no explanation yet
-				mInfo.setText(((attAniImage)which).info);
+			if (!((AttAniImage)which).info.startsWith(&quot;*&quot;)) { // If text starts with * we have no explanation yet
+				mInfo.setText(((AttAniImage)which).info);
 				mInfo.repaintNow();
 			}
 			return true;
@@ -61,8 +63,8 @@
 		}
 		public boolean imagePressed(AniImage which, Point pos) {
 			if (which != null) {
-				String value = ((attAniImage)which).value;
-				long bit = ((attAniImage)which).bitMask;
+				String value = ((AttAniImage)which).value;
+				long bit = ((AttAniImage)which).bitMask;
 				if (value.equals(&quot;-non.gif&quot;)) {
 					selectionMaskYes |= bit;
 					selectionMaskNo  &amp;= ~bit;
@@ -76,7 +78,7 @@
 					selectionMaskNo  &amp;= ~bit;
 					value=&quot;-non.gif&quot;;
 				}
-				attAniImage tmpImg = new attAniImage( (attAniImage)which, value );
+				AttAniImage tmpImg = new AttAniImage( (AttAniImage)which, value );
 				removeImage(which);
 				addImage(tmpImg);
 				//System.out.println (&quot;AniImage pressed: &quot; + ((attAniImage)which).info);
@@ -86,7 +88,7 @@
 			return true;
 		}
 	}
-	protected InteractivePanel iap=new attInteractivePanel();
+	protected InteractivePanel iap=new AttInteractivePanel();
 
 	public void showAttributePalette() {
 		iap.images.clear();
@@ -105,8 +107,8 @@
 					value = &quot;-no.gif&quot;;
 				else
 					value = &quot;-non.gif&quot;;
-				mImage rawImg=new mImage(Attribute.getImageDir()+attrName+value);	
-				attAniImage img=new attAniImage(rawImg.getHeight()!=20 ? rawImg.scale(20,20,null,Image.FOR_DISPLAY) : rawImg );
+				PixelBuffer rawImg=new PixelBuffer(Attribute.getImageDir()+attrName+value);	
+				AttAniImage img=new AttAniImage((rawImg.getHeight()!=20 ? rawImg.scale(20,20) : rawImg ));
 				img.info=MyLocale.getMsg(2500+i,&quot;No attribute info found&quot;);
 				img.value=value;
 				img.attrName=attrName;

Modified: experiments/engywuck/hist-test/src/cachewolf/AttributesViewer.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/AttributesViewer.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/AttributesViewer.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,19 +1,19 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.fx.*;
-import ewe.graphics.*;
-import ewe.ui.*;
+import eve.fx.*;
+import eve.ui.*;
+import eve.ui.game.*;
 
-public class AttributesViewer extends CellPanel {
-	protected static int TILESIZE=Attribute.getImageWidth()+2;
+public class AttributesViewer extends Panel {
+	protected static final int TILESIZE=Attribute.getImageWidth()+2;
 	protected final static int ICONS_PER_ROW=MyLocale.getScreenWidth()/TILESIZE&lt;Attributes.MAXATTRIBS ? MyLocale.getScreenWidth()/TILESIZE : Attributes.MAXATTRIBS;
 	protected final static int ICONROWS=(Attributes.MAXATTRIBS+ICONS_PER_ROW-1)/ICONS_PER_ROW;
-	protected mLabel mInfo;
+	protected Label mInfo;
 
-	protected class attInteractivePanel extends InteractivePanel {
+	protected class AttInteractivePanel extends InteractivePanel {
 		public boolean imageMovedOn(AniImage which) {
-			if (!((attAniImage)which).info.startsWith(&quot;*&quot;)) { // If text starts with * we have no explanation yet
-				mInfo.setText(((attAniImage)which).info);
+			if (!((AttAniImage)which).info.startsWith(&quot;*&quot;)) { // If text starts with * we have no explanation yet
+				mInfo.setText(((AttAniImage)which).info);
 				mInfo.repaintNow();
 			}
 			return true;
@@ -25,9 +25,9 @@
 		}
 	}
 	
-	protected class attAniImage extends AniImage {
+	protected class AttAniImage extends AniImage {
 		public String info;
-		attAniImage (mImage img) {
+		AttAniImage (Picture img) {
 			super(img);
 		}
 	}
@@ -37,14 +37,14 @@
 		iap.virtualSize = r;
 		iap.setFixedSize(TILESIZE * ICONS_PER_ROW,TILESIZE * ICONROWS);
 		addLast(iap,CellConstants.HSTRETCH,CellConstants.FILL);
-		addLast(mInfo=new mLabel(&quot;&quot;),HSTRETCH,HFILL);
+		addLast(mInfo=new Label(&quot;&quot;),HSTRETCH,HFILL);
 	}
-	protected InteractivePanel iap=new attInteractivePanel();
+	protected InteractivePanel iap=new AttInteractivePanel();
 	
 	public void showImages(Attributes att) {
 		iap.images.clear();
 		for (int i=0; i&lt;att.getCount(); i++) {
-			attAniImage img=new attAniImage( att.getImage(i));
+			AttAniImage img=new AttAniImage( att.getImage(i));
 			img.info=att.getInfo(i);
 			img.location=new Rect((i % ICONS_PER_ROW)*TILESIZE,(i / ICONS_PER_ROW)*TILESIZE,TILESIZE,TILESIZE);
 			iap.addImage(img);			

Modified: experiments/engywuck/hist-test/src/cachewolf/CWPoint.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/CWPoint.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/CWPoint.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,16 +1,23 @@
-package CacheWolf;
 
-import ewe.sys.Convert;
-import CacheWolf.navi.TrackPoint;
-import CacheWolf.navi.GkPoint;
-import CacheWolf.navi.TransformCoordinates;
-import CacheWolf.navi.GeodeticCalculator;
+package cachewolf;
 
+
+import eve.sys.Convert;
+
+import cachewolf.navi.GkPoint;
+import cachewolf.navi.TrackPoint;
+import cachewolf.navi.TransformCoordinates;
+import cachewolf.utils.Common;
+import cachewolf.utils.ParseLatLon;
+import cachewolf.utils.STRreplace;
+import cachewolf.navi.GeodeticCalculator;
+
 import com.bbn.openmap.proj.coords.*;
 import com.bbn.openmap.proj.*;
 import com.bbn.openmap.*;
-import com.stevesoft.ewe_pat.Regex;
+import com.stevesoft.eve_pat.Regex;
 
+
 /**
  * Class for getting an setting coords in different formats
  * and for doing projection and calculation of bearing and
@@ -477,11 +484,7 @@
 	 */
 	public String getGKNorthing(int decimalplaces){
 		double gkNorthing = TransformCoordinates.wgs84ToGermanGk(this).getNorthing();
-		
-		ewe.sys.Double n = new ewe.sys.Double();
-		n.set(gkNorthing);
-		n.decimalPlaces = decimalplaces;
-		return n.toString().replace(',', '.');
+		return Common.doubleToString(gkNorthing,decimalplaces);
 	}
 
 	/**
@@ -489,15 +492,11 @@
 	 */
 	public String getGKEasting(int decimalplaces) {
 		double gkEasting = TransformCoordinates.wgs84ToGermanGk(this).getGkEasting(GkPoint.GERMAN_GK);
-		
-		ewe.sys.Double e = new ewe.sys.Double();
-		e.set(gkEasting);
-		e.decimalPlaces = decimalplaces;
-		return e.toString().replace(',', '.');
+		return Common.doubleToString(gkEasting,decimalplaces);
 	}
 	
 	public String getGermanGkCoordinates() {
-		return TransformCoordinates.wgs84ToGermanGk(this).toString(0, &quot;R:&quot;, &quot; H:&quot;, GkPoint.GERMAN_GK);
+		return TransformCoordinates.wgs84ToGermanGk(this).toString(0, &quot;R:&quot;, &quot; H:&quot;,GkPoint.GERMAN_GK);
 	}
 
 	public String getGermanGkCoordinates(int decimalplaces, String pref, String seperator, int region) {
@@ -616,9 +615,9 @@
 						+  getEWLetter() + &quot; &quot; + getLonDeg(format) + &quot;&#176; &quot; + getLonMin(format) + &quot;\' &quot; + getLonSec(format) + &quot;\&quot;&quot;;
 		case UTM:	return getUTMZone()  + &quot; E &quot; + getUTMEasting()+ &quot; N &quot; + getUTMNorthing();
 		case LON_LAT:
-			return Common.DoubleToString(lonDec, 8) +  &quot;,&quot; + Common.DoubleToString(latDec, 8);
+			return Common.doubleToString(lonDec, 8) +  &quot;,&quot; + Common.doubleToString(latDec, 8);
 		case LAT_LON:
-			return Common.DoubleToString(latDec, 8) +  &quot;,&quot; + Common.DoubleToString(lonDec, 8);
+			return Common.doubleToString(latDec, 8) +  &quot;,&quot; + Common.doubleToString(lonDec, 8);
 		case GK:
 			return getGermanGkCoordinates();
 		default: return &quot;Unknown Format: &quot; + format;

Modified: experiments/engywuck/hist-test/src/cachewolf/CacheHolder.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/CacheHolder.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/CacheHolder.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,18 +1,21 @@
-package CacheWolf;
+package cachewolf;
 
-import com.stevesoft.ewe_pat.Regex;
+import java.io.IOException;
+import eve.sys.Convert;
+import eve.ui.MessageBox;
+import java.util.Vector;
+import com.stevesoft.eve_pat.*;
 
-import ewe.io.IOException;
-import ewe.sys.Convert;
-import ewe.ui.FormBase;
-import ewe.ui.MessageBox;
-import ewe.util.Vector;
+import cachewolf.utils.Common;
+import cachewolf.utils.DateFormat;
+import cachewolf.utils.SafeXML;
 
+
 /**
  *	A class to hold information on a cache.&lt;br&gt;
  *	Not all attributes are filled at once. You will have to look at other
  *	classes and methods to get more information.
- *	
+ *
  */
 public class CacheHolder {
 	protected static final String NODISTANCE = &quot;? km&quot;;
@@ -20,21 +23,23 @@
 	protected static final String EMPTY = &quot;&quot;;
 
 	/** Cachestatus is Found, Not found or a date in format yyyy-mm-dd hh:mm for found date */
-	public String CacheStatus = EMPTY;
+	public String cacheStatus = EMPTY;
 	/** The name of the waypoint typicall GC.... or OC.... or CW...... (can be any characters) */
 	public String wayPoint = EMPTY;
 	/** The name of the cache (short description) */
-	public String CacheName = EMPTY;
+	public String cacheName = EMPTY;
 	/** The alias of the owner */
-	public String CacheOwner = EMPTY;
+	public String cacheOwner = EMPTY;
 	/** The coordinates of the cache */
 	public CWPoint pos = new CWPoint();
 	/** The coordinates of the cache */
-	public String LatLon = pos.toString();
+	public String latLon = pos.toString();
 	/** The date when the cache was hidden in format yyyy-mm-dd */
-	public String DateHidden = EMPTY;
+	public String dateHidden = EMPTY;
 	/** The size of the cache (as per GC cache sizes Micro, Small, ....) */
-	public String CacheSize = &quot;None&quot;;
+	public int cacheSize = 0;
+	/** The pre-defined GC cache sizes */
+	public static String[] cacheSizeList={&quot;Not Chosen&quot;,&quot;Micro&quot;,&quot;Small&quot;,&quot;Regular&quot;,&quot;Large&quot;,&quot;Very Large&quot;, &quot;Other&quot;};
 	/** The distance from the centre in km */
 	public double kilom = 0;
 	/** The formatted distance such as &quot;x.xx km&quot; */
@@ -43,12 +48,12 @@
 	public String bearing = NOBEARING;
 	/** The angle (0=North, 180=South) from the current centre to this point */
 	public double degrees = 0;
-	/** The difficulty of the cache from 1 to 5 in .5 incements */ 
+	/** The difficulty of the cache from 1 to 5 in .5 incements */
 	public String hard = EMPTY;
 	/** The terrain rating of the cache from 1 to 5 in .5 incements */
 	public String terrain = EMPTY;
 	/** The cache type (@see CacheType for translation table)  */
-	public String type = &quot;0&quot;; //TODO Should be an int
+	public int type = 0;
 	/** True if the cache has been archived */
 	public boolean is_archived = false;
 	/** True if the cache is available for searching */
@@ -70,7 +75,7 @@
 	/** True if the cache is new */
 	public boolean is_new = false;
 	/** True if the cache is part of the results of a search */
-	public boolean is_flaged = false;
+	public boolean is_flagged = false;
 	/** True if the cache has been selected using the tick box in the list view */
 	public boolean is_Checked = false;
 	/** Not used: This attribute is saved with the cache and read back but never set */
@@ -90,7 +95,7 @@
 	/** True if the cache description is stored in HTML format */
 	public boolean is_HTML = true;
 	/** List of additional waypoints associated with this waypoint */
-	public Vector addiWpts = new Vector();
+	public Vector addiWpts = null; // Don't allocate a vector unless the waypoint really has addis - this will save time and memory
 	/** in range is used by the route filter to identify caches in range of a segment*/
 	public boolean in_range = false;
 	/** If this is an additional waypoint, this links back to the main waypoint */
@@ -99,7 +104,7 @@
 	public String lastSyncOC = EMPTY;
 	public CacheHolderDetail details = null;
 	/** When sorting the cacheDB this field is used. The relevant field is copied here and
-	 *  the sort is always done on this field to speed up the sorting process 
+	 *  the sort is always done on this field to speed up the sorting process
 	 */
 	public String sort;
 	private static StringBuffer sb=new StringBuffer(530); // Used in toXML()
@@ -121,14 +126,30 @@
 		notDecSep=decSep=='.'?',':'.';
 	}
 
+	public void setCacheSize(String cacheSize) {
+		if(cacheSize.equals(&quot;Not Chosen&quot;)) this.cacheSize=0;
+		else if(cacheSize.equals(&quot;Micro&quot;)) this.cacheSize=1;
+		else if(cacheSize.equals(&quot;Small&quot;)) this.cacheSize=2;
+		else if(cacheSize.equals(&quot;Regular&quot;)) this.cacheSize=3;
+		else if(cacheSize.equals(&quot;Large&quot;)) this.cacheSize=4;
+		else if(cacheSize.equals(&quot;Very Large&quot;)) this.cacheSize=5;
+		else if(cacheSize.equals(&quot;Other&quot;)) this.cacheSize=6;
+		else this.cacheSize=0;
+	}
+
+	public String getCacheSize() {
+		return cacheSizeList[cacheSize];
+	}
+
+
 	public CacheHolder(String xmlString) {
 		int start,end;
 		try {
 			start=xmlString.indexOf('&quot;'); end=xmlString.indexOf('&quot;',start+1);
-			CacheName = SafeXML.cleanback(xmlString.substring(start+1,end));
-			
+			cacheName = SafeXML.cleanback(xmlString.substring(start+1,end));
+
 			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-            CacheOwner = SafeXML.cleanback(xmlString.substring(start+1,end));
+            cacheOwner = SafeXML.cleanback(xmlString.substring(start+1,end));
 			// Assume coordinates are in decimal format
 			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
 			double lat=Convert.parseDouble(xmlString.substring(start+1,end).replace(notDecSep,decSep));
@@ -136,21 +157,21 @@
 			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
 			double lon=Convert.parseDouble(xmlString.substring(start+1,end).replace(notDecSep,decSep));
 			pos=new CWPoint(lat,lon);
-			LatLon=pos.toString();
+			latLon=pos.toString();
 
 			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-			DateHidden = xmlString.substring(start+1,end); 
+			dateHidden = xmlString.substring(start+1,end);
 			// Convert the US format to YYYY-MM-DD if necessary
-			if (DateHidden.indexOf('/')&gt;-1) DateHidden=DateFormat.MDY2YMD(DateHidden);
+			if (dateHidden.indexOf('/')&gt;-1) dateHidden=DateFormat.MDY2YMD(dateHidden);
 
 			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
 			wayPoint = SafeXML.cleanback(xmlString.substring(start+1,end));
 
 			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-			CacheStatus = xmlString.substring(start+1,end);
+			cacheStatus = xmlString.substring(start+1,end);
 
 			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-			type = xmlString.substring(start+1,end);
+			type = Common.parseInt(xmlString.substring(start+1,end));
 
 			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
 			hard = xmlString.substring(start+1,end);
@@ -160,10 +181,10 @@
 
 			// The next item was 'dirty' but this is no longer used.
 			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-			is_filtered = xmlString.substring(start+1,end).equals(&quot;true&quot;); 
+			is_filtered = xmlString.substring(start+1,end).equals(&quot;true&quot;);
 
 			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
-			CacheSize = xmlString.substring(start+1,end);
+			setCacheSize(xmlString.substring(start+1,end));
 
 			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
 			is_available = xmlString.substring(start+1,end).equals(&quot;true&quot;);
@@ -237,10 +258,10 @@
 		this.numFoundsSinceRecommendation = ch.numFoundsSinceRecommendation;
 		this.numRecommended = ch.numRecommended;
 		if (overwrite) {
-			this.CacheStatus=ch.CacheStatus;
+			this.cacheStatus=ch.cacheStatus;
 			this.is_found = ch.is_found;
 			this.pos = ch.pos;
-			this.LatLon = ch.LatLon;
+			this.latLon = ch.latLon;
 		} else {
 			/* Here we have to distinguish several cases:
 	   this.is_found       this                ch               Update 'this'
@@ -250,22 +271,22 @@
 	   true                yyyy-mm-dd          yyyy-mm-dd       no (or yes)
 	   true                yyyy-mm-dd hh:mm    yyyy-mm-dd       no
 			 */
-			if (!this.is_found || this.CacheStatus.indexOf(&quot;:&quot;)&lt;0) {
-				this.CacheStatus=ch.CacheStatus;
+			if (!this.is_found || this.cacheStatus.indexOf(&quot;:&quot;)&lt;0) {
+				this.cacheStatus=ch.cacheStatus;
 				this.is_found = ch.is_found;
 			}
 			// Don't overwrite valid coordinates with invalid ones
 			if (ch.pos.isValid() || !this.pos.isValid()) {
 				this.pos = ch.pos;
-				this.LatLon = ch.LatLon;
+				this.latLon = ch.latLon;
 			}
 		}
 		this.wayPoint = ch.wayPoint;
-		this.CacheName = ch.CacheName;
-		this.CacheOwner = ch.CacheOwner;
+		this.cacheName = ch.cacheName;
+		this.cacheOwner = ch.cacheOwner;
 
-		this.DateHidden = ch.DateHidden;
-		this.CacheSize = ch.CacheSize;
+		this.dateHidden = ch.dateHidden;
+		this.cacheSize=ch.cacheSize;
 		this.kilom = ch.kilom;
 		this.distance = ch.distance;
 		this.bearing = ch.bearing;
@@ -284,7 +305,7 @@
 		this.addiWpts = ch.addiWpts;
 		this.mainCache=ch.mainCache;
 		this.is_new=ch.is_new;
-		this.is_flaged = ch.is_flaged;
+		this.is_flagged = ch.is_flagged;
 		this.is_Checked = ch.is_Checked;
 		//this.dirty = ch.dirty;
 		this.ocCacheID = ch.ocCacheID;
@@ -297,6 +318,44 @@
 		this.attributesYes = ch.attributesYes;
 		this.attributesNo = ch.attributesNo;
 	}
+
+	public String getStatusDate() {
+		String statusDate = &quot;&quot;;
+
+		if (is_found) {
+			Regex rexDate=new Regex(&quot;([0-9]{4}-[0-9]{2}-[0-9]{2})&quot;);
+			rexDate.search(cacheStatus);
+			if (rexDate.stringMatched(1)!= null) {
+				statusDate = rexDate.stringMatched(1);
+			}
+		}
+
+		return statusDate;
+	}
+
+	public String getStatusTime() {
+		String statusTime = &quot;&quot;;
+
+		if (is_found) {
+			Regex rexTime=new Regex(&quot;([0-9]{1,2}:[0-9]{2})&quot;);
+			rexTime.search(cacheStatus);
+			if (rexTime.stringMatched(1)!= null) {
+				statusTime = rexTime.stringMatched(1);
+			}
+			else {
+				Regex rexDate=new Regex(&quot;([0-9]{4}-[0-9]{2}-[0-9]{2})&quot;);
+				rexDate.search(cacheStatus);
+				if (rexDate.stringMatched(1)!= null) {
+					statusTime = &quot;00:00&quot;;
+				}
+			}
+		}
+		return statusTime;
+	}
+
+
+
+
 	/**
 	 * Call it only when necessary, it takes time, because all logs must be parsed
 	 *
@@ -307,10 +366,10 @@
 			if (this instanceof CacheHolderDetail)	chD = (CacheHolderDetail)this;
 			else chD = getCacheDetails(true, false);
 			if (chD != null) {
-				chD.CacheLogs.calcRecommendations();
-				recommendationScore = chD.CacheLogs.recommendationRating;
-				numFoundsSinceRecommendation = chD.CacheLogs.foundsSinceRecommendation;
-				numRecommended = chD.CacheLogs.numRecommended;
+				chD.cacheLogs.calcRecommendations();
+				recommendationScore = chD.cacheLogs.recommendationRating;
+				numFoundsSinceRecommendation = chD.cacheLogs.foundsSinceRecommendation;
+				numRecommended = chD.cacheLogs.numRecommended;
 			} else { // cache doesn't have details
 				recommendationScore = -1;
 				numFoundsSinceRecommendation = -1;
@@ -327,39 +386,39 @@
 		details.numRecommended = numRecommended;
 		}
 	}
-	
+
 	/** Return a XML string containing all the cache data for storing in index.xml */
 	public String toXML() {
-		if (this instanceof CacheHolderDetail || (details != null &amp;&amp; details.hasUnsavedChanges)) calcRecommendationScore(); 
+		if (this instanceof CacheHolderDetail || (details != null &amp;&amp; details.hasUnsavedChanges)) calcRecommendationScore();
 		sb.delete(0,sb.length());
 		sb.append(&quot;    &lt;CACHE name = \&quot;&quot;);
-		sb.append(SafeXML.clean(CacheName));
-		sb.append(&quot;\&quot; owner = \&quot;&quot;);		sb.append(SafeXML.clean(CacheOwner));
-		sb.append(&quot;\&quot; lat = \&quot;&quot;); 		sb.append(pos.latDec ); 
+		sb.append(SafeXML.clean(cacheName));
+		sb.append(&quot;\&quot; owner = \&quot;&quot;);		sb.append(SafeXML.clean(cacheOwner));
+		sb.append(&quot;\&quot; lat = \&quot;&quot;); 		sb.append(pos.latDec );
 		sb.append(&quot;\&quot; lon = \&quot;&quot;);		sb.append(pos.lonDec);
-		sb.append(&quot;\&quot; hidden = \&quot;&quot;);	sb.append(DateHidden);
+		sb.append(&quot;\&quot; hidden = \&quot;&quot;);	sb.append(dateHidden);
 		sb.append(&quot;\&quot; wayp = \&quot;&quot;);		sb.append(SafeXML.clean(wayPoint));
-		sb.append(&quot;\&quot; status = \&quot;&quot;);	sb.append(CacheStatus);
+		sb.append(&quot;\&quot; status = \&quot;&quot;);	sb.append(cacheStatus);
 		sb.append(&quot;\&quot; type = \&quot;&quot;);		sb.append(type);
 		sb.append(&quot;\&quot; dif = \&quot;&quot;);		sb.append(hard);
-		sb.append(&quot;\&quot; terrain = \&quot;&quot; );	sb.append(terrain ); 
+		sb.append(&quot;\&quot; terrain = \&quot;&quot; );	sb.append(terrain );
 		sb.append(&quot;\&quot; filtered = \&quot;&quot; ); sb.append(is_filtered); // This was 'dirty', but dirty is not used
-		sb.append(&quot;\&quot; size = \&quot;&quot;);		sb.append(CacheSize);
-		sb.append(&quot;\&quot; online = \&quot;&quot; );	sb.append(is_available); 
-		sb.append(&quot;\&quot; archived = \&quot;&quot; );	sb.append(is_archived); 
-		sb.append(&quot;\&quot; has_bug = \&quot;&quot; ); 	sb.append(has_bug); 
-		sb.append(&quot;\&quot; black = \&quot;&quot; ); 	sb.append(is_black); 
-		sb.append(&quot;\&quot; owned = \&quot;&quot; ); 	sb.append(is_owned); 
-		sb.append(&quot;\&quot; found = \&quot;&quot; ); 	sb.append(is_found); 
+		sb.append(&quot;\&quot; size = \&quot;&quot;);		sb.append(getCacheSize());
+		sb.append(&quot;\&quot; online = \&quot;&quot; );	sb.append(is_available);
+		sb.append(&quot;\&quot; archived = \&quot;&quot; );	sb.append(is_archived);
+		sb.append(&quot;\&quot; has_bug = \&quot;&quot; ); 	sb.append(has_bug);
+		sb.append(&quot;\&quot; black = \&quot;&quot; ); 	sb.append(is_black);
+		sb.append(&quot;\&quot; owned = \&quot;&quot; ); 	sb.append(is_owned);
+		sb.append(&quot;\&quot; found = \&quot;&quot; ); 	sb.append(is_found);
 		sb.append(&quot;\&quot; is_new = \&quot;&quot; );	sb.append(is_new);
-		sb.append(&quot;\&quot; is_log_update = \&quot;&quot; );sb.append(is_log_update); 
-		sb.append(&quot;\&quot; is_update = \&quot;&quot; );sb.append(is_update); 
-		sb.append(&quot;\&quot; is_HTML = \&quot;&quot; ); 	sb.append(is_HTML); 
-		sb.append(&quot;\&quot; DNFLOGS = \&quot;&quot; ); 	sb.append(noFindLogs ); 
-		sb.append(&quot;\&quot; ocCacheID = \&quot;&quot; );sb.append(ocCacheID ); 
-		sb.append(&quot;\&quot; is_INCOMPLETE = \&quot;&quot;);sb.append(is_incomplete); 
-		sb.append(&quot;\&quot; lastSyncOC = \&quot;&quot; );sb.append(lastSyncOC ); 
-		sb.append(&quot;\&quot; num_recommended = \&quot;&quot;);sb.append(Convert.formatInt(numRecommended)); 
+		sb.append(&quot;\&quot; is_log_update = \&quot;&quot; );sb.append(is_log_update);
+		sb.append(&quot;\&quot; is_update = \&quot;&quot; );sb.append(is_update);
+		sb.append(&quot;\&quot; is_HTML = \&quot;&quot; ); 	sb.append(is_HTML);
+		sb.append(&quot;\&quot; DNFLOGS = \&quot;&quot; ); 	sb.append(noFindLogs );
+		sb.append(&quot;\&quot; ocCacheID = \&quot;&quot; );sb.append(ocCacheID );
+		sb.append(&quot;\&quot; is_INCOMPLETE = \&quot;&quot;);sb.append(is_incomplete);
+		sb.append(&quot;\&quot; lastSyncOC = \&quot;&quot; );sb.append(lastSyncOC );
+		sb.append(&quot;\&quot; num_recommended = \&quot;&quot;);sb.append(Convert.formatInt(numRecommended));
 		sb.append(&quot;\&quot; num_found = \&quot;&quot; );sb.append(Convert.formatInt(numFoundsSinceRecommendation));
 		sb.append(&quot;\&quot; attributesYes = \&quot;&quot; ); sb.append(Convert.formatLong(attributesYes));
 		sb.append(&quot;\&quot; attributesNo = \&quot;&quot; ); sb.append(Convert.formatLong(attributesNo));
@@ -369,8 +428,8 @@
 
 	public void setLatLon(String latLon) {
 		latLon=latLon.trim();
-		if (!latLon.equals(LatLon.trim())) is_update=true;
-		LatLon = latLon;
+		if (!latLon.equals(this.latLon.trim())) is_update=true;
+		this.latLon = latLon;
 		pos.set(latLon);
 	}
 
@@ -379,12 +438,19 @@
 	}
 
 	public boolean hasAddiWpt() {
-		if (this.addiWpts.getCount()&gt;0) return true;
-		else return false;
+		if (addiWpts==null) return false;
+		if (this.addiWpts.size()&gt;0)
+			return true;
+		return false;
 	}
 
+	/** Allocate space for addi waypoints */
+	public void allocAddiMem() {
+		if (addiWpts==null) addiWpts=new Vector();
+	}
 
-	public void calcDistance(CWPoint toPoint) {	
+
+	public void calcDistance(CWPoint toPoint) {
 		if(pos.isValid()){
 			kilom = pos.getDistance(toPoint);
 			degrees = toPoint.getBearing(pos);
@@ -396,8 +462,8 @@
 		}
 	}
 	public void setAttributesFromMainCache(CacheHolder mainCh){
-		this.CacheOwner = mainCh.CacheOwner;
-		this.CacheStatus = mainCh.CacheStatus;
+		this.cacheOwner = mainCh.cacheOwner;
+		this.cacheStatus = mainCh.cacheStatus;
 		this.is_archived = mainCh.is_archived;
 		this.is_available = mainCh.is_available;
 		this.is_black = mainCh.is_black;
@@ -409,7 +475,7 @@
 	public void setAttributesToAddiWpts(){
 		if (this.hasAddiWpt()){
 			CacheHolder addiWpt;
-			for (int i= this.addiWpts.getCount() - 1;  i&gt;=0; i--){
+			for (int i= this.addiWpts.size() - 1;  i&gt;=0; i--){
 				addiWpt = (CacheHolder) this.addiWpts.get(i);
 				addiWpt.setAttributesFromMainCache(this);
 			}
@@ -417,7 +483,7 @@
 	}
 
 	/**
-	 * True if ch and this belong to the same main cache. 
+	 * True if ch and this belong to the same main cache.
 	 * @param ch
 	 * @return
 	 */
@@ -428,40 +494,40 @@
 		CacheHolder main1, main2;
 		if (this.isAddiWpt()) main1 = this.mainCache;  else main1 = this;
 		if (ch instanceof CacheHolderDetail) {
-			if (ch.isAddiWpt()) 
+			if (ch.isAddiWpt())
 				main2=ch.mainCache;
-			else 
+			else
 				return main1.wayPoint.equals(ch.wayPoint);
-		} else { // ch instanceof CacheHolder 
-			if (ch.isAddiWpt()) main2 = ch.mainCache; else main2 = ch; 
-		}
+			} else { // ch instanceof CacheHolder
+				if (ch.isAddiWpt()) main2 = ch.mainCache; else main2 = ch;
+			}
 		return main1 == main2;
 	}
 
-	/** 
+	/**
 	 * Call this method to get the long-description and so on.
 	 * If the according .xml-file is already read, it will return
 	 * that one, otherwise it will be loaded.
 	 * To avoid memory problems this routine loads not for more caches than maxDetails
-	 * the details. If maxdetails is reached, it will remove from RAM the details 
+	 * the details. If maxdetails is reached, it will remove from RAM the details
 	 * of the 5 caches that were loaded most long ago.
 	 */
 	public CacheHolderDetail getCacheDetails(boolean maybenew) {
 		return getCacheDetails(maybenew, true);
 	}
-	
-	/** 
+
+	/**
 	 * Call this method to get the long-description and so on.
 	 * If the according .xml-file is already read, it will return
 	 * that one, otherwise it will be loaded.
 	 * To avoid memory problems this routine loads not for more caches than maxDetails
-	 * the details. If maxdetails is reached, it will remove from RAM the details 
+	 * the details. If maxdetails is reached, it will remove from RAM the details
 	 * of the 5 caches that were loaded most long ago.
-	 * 
+	 *
 	 * @param alarmuser if true an error message will be displayed to the user, if the details could not be read
 	 * @return the respective CacheHolderDetail, null if according xml-file could not be read
 	 */
-		
+
 	public CacheHolderDetail getCacheDetails(boolean maybenew, boolean alarmuser) {
 		if (details != null) {
 			if (details.hasUnsavedChanges) this.update(details);
@@ -474,16 +540,16 @@
 		} catch (IOException e) {
 			if (maybenew) details.update(this);
 			else {
-				if (alarmuser) (new MessageBox(&quot;Error&quot;, &quot;Could not read cache details for cache: &quot;+this.wayPoint, FormBase.OKB)).execute();
+				if (alarmuser) (new MessageBox(&quot;Error&quot;, &quot;Could not read cache details for cache: &quot;+this.wayPoint, MessageBox.OKB)).execute();
 				return null;
-			} 
+			}
 		}
 		detailsAdded();
 		return details;
 	}
 
 	/**
-	 * Call this after you added the cache with details to the 
+	 * Call this after you added the cache with details to the
 	 * cacheDB &lt;br&gt; It is assumed that that details is set
 	 * for an example see OCXMLImporter.endCache()
 	 *
@@ -503,7 +569,7 @@
 		cachesWithLoadedDetails.remove(this);
 	}
 
-	//final static int maxDetails = 50; 
+	//final static int maxDetails = 50;
 	static Vector cachesWithLoadedDetails = new Vector(Global.getPref().maxDetails);
 
 	public static void removeOldestDetails() {
@@ -541,39 +607,4 @@
    Vm.debug(&quot;CacheHolder: &quot;+nObjects+&quot; objects left&quot;);
 }
 	 */
-	
-	public String GetStatusDate() {
-		String statusDate = &quot;&quot;;
-		
-		if (is_found) {
-			Regex rexDate=new Regex(&quot;([0-9]{4}-[0-9]{2}-[0-9]{2})&quot;);
-			rexDate.search(CacheStatus);
-			if (rexDate.stringMatched(1)!= null) {
-				statusDate = rexDate.stringMatched(1);
-			}
-		}
-
-		return statusDate;		
-	}
-	
-	public String GetStatusTime() {
-		String statusTime = &quot;&quot;;
-
-		if (is_found) {
-			Regex rexTime=new Regex(&quot;([0-9]{1,2}:[0-9]{2})&quot;);
-			rexTime.search(CacheStatus);
-			if (rexTime.stringMatched(1)!= null) {
-				statusTime = rexTime.stringMatched(1);
-			}
-			else {
-				Regex rexDate=new Regex(&quot;([0-9]{4}-[0-9]{2}-[0-9]{2})&quot;);
-				rexDate.search(CacheStatus);
-				if (rexDate.stringMatched(1)!= null) {
-					statusTime = &quot;00:00&quot;;
-				}
-			}
-		}
-
-		return statusTime;		
-	}
-}
+}
\ No newline at end of file

Modified: experiments/engywuck/hist-test/src/cachewolf/CacheHolderDetail.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/CacheHolderDetail.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/CacheHolderDetail.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,38 +1,38 @@
-package CacheWolf;
+package cachewolf;
 
-import utils.FileBugfix;
-import ewe.filechooser.FileChooser;
-import ewe.filechooser.FileChooserBase;
-import ewe.io.BufferedWriter;
-import ewe.io.File;
-import ewe.io.FileNotFoundException;
-import ewe.io.FileReader;
-import ewe.io.FileWriter;
-import ewe.io.IOException;
-import ewe.io.PrintWriter;
-import ewe.ui.FormBase;
-import ewe.ui.InputBox;
-import ewe.util.Vector;
+import eve.ui.filechooser.FileChooser;
+import java.io.BufferedWriter;
+import eve.io.File;
+import java.io.FileOutputStream;
+import java.io.OutputStreamWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.Vector;
 
+import cachewolf.utils.Extractor;
+
+
+import eve.ui.data.*;
+
 public class CacheHolderDetail extends CacheHolder {
-	  public String LongDescription = EMPTY;
-	  public String LastUpdate = EMPTY;
-	  public String Hints = EMPTY;
-	  public LogList CacheLogs=new LogList();
-	  public String CacheNotes = EMPTY;
-	  public Vector Images = new Vector();
-	  public Vector ImagesText = new Vector();
-	  public Vector ImagesInfo = new Vector();
-	  public Vector LogImages = new Vector();
-	  public Vector LogImagesText = new Vector();
-	  public Vector UserImages = new Vector();
-	  public Vector UserImagesText = new Vector();
+	  public String longDescription = EMPTY;
+	  public String lastUpdate = EMPTY;
+	  public String hints = EMPTY;
+	  public LogList cacheLogs=new LogList();
+	  public String cacheNotes = EMPTY;
+	  public Vector images = new Vector();
+	  public Vector imagesText = new Vector();
+	  public Vector imagesInfo = new Vector();
+	  public Vector logImages = new Vector();
+	  public Vector logImagesText = new Vector();
+	  public Vector userImages = new Vector();
+	  public Vector userImagesText = new Vector();
 	  public Attributes attributes=new Attributes();
-	  public Vector CacheIcons = new Vector();
-	  public TravelbugList Travelbugs=new TravelbugList();
+	  public Vector cacheIcons = new Vector();
+	  public TravelbugList travelbugs=new TravelbugList();
 	  //public String Bugs = EMPTY; Superceded by Travelbugs
 	  public String URL = EMPTY;
-	  public String Solver = EMPTY;
+	  public String solver = EMPTY;
 	  /** For faster cache import (from opencaching) changes are only written when the details are freed from memory 
 	   * If you want to save the changes automatically when the details are unloaded, set this to true */ 
 	  public boolean hasUnsavedChanges = false;
@@ -45,9 +45,9 @@
 	 }
 
 	 public void setLongDescription(String longDescription) {
-	 	if (LongDescription.equals(&quot;&quot;)) is_new=true;
-	 	else if (!stripControlChars(LongDescription).equals(stripControlChars(longDescription))) is_update=true;
-	 	LongDescription = longDescription;
+	 	if (this.longDescription.equals(&quot;&quot;)) is_new=true;
+	 	else if (!stripControlChars(this.longDescription).equals(stripControlChars(longDescription))) is_update=true;
+	 	this.longDescription = longDescription;
 	 }
 	 
 	 private String stripControlChars(String desc) {
@@ -60,17 +60,17 @@
 	 }
 	 
 	 public void setHints(String hints) {
-	 	if (!Hints.equals(hints)) is_update=true;
-	 	Hints = hints;
+	 	if (!this.hints.equals(hints)) is_update=true;
+	 	this.hints = hints;
 	 }
 	 
 	 public void setCacheLogs(LogList newLogs) {
 		 int size=newLogs.size();
 		 for (int i=size-1; i&gt;=0; i--) { // Loop over all new logs, must start with oldest log
-			 if (CacheLogs.merge(newLogs.getLog(i))&gt;=0) this.is_log_update=true;
+			 if (cacheLogs.merge(newLogs.getLog(i))&gt;=0) this.is_log_update=true;
 		 }
 		 //CacheLogs=logs;
-		 noFindLogs=CacheLogs.countNotFoundLogs();
+		 noFindLogs=cacheLogs.countNotFoundLogs();
 	 }
 
 	 
@@ -83,29 +83,29 @@
 	public CacheHolderDetail update(CacheHolderDetail newCh){
 		  super.update(newCh);
 		  // flags
-		  if (this.is_found == true &amp;&amp; this.CacheStatus.equals(&quot;&quot;)) this.CacheStatus = MyLocale.getMsg(318,&quot;Found&quot;);
+		  if (this.is_found == true &amp;&amp; this.cacheStatus.equals(&quot;&quot;)) this.cacheStatus = MyLocale.getMsg(318,&quot;Found&quot;);
 
 		  //travelbugs:GPX-File contains all actual travelbugs but not the missions
 		  //  we need to check whether the travelbug is already in the existing list
-		  this.has_bug = newCh.Travelbugs.size()&gt;0;
-		  for (int i=newCh.Travelbugs.size()-1; i&gt;=0; i--) {
-			 Travelbug tb=newCh.Travelbugs.getTB(i);  
-		     Travelbug oldTB=this.Travelbugs.find(tb.getName());
+		  this.has_bug = newCh.travelbugs.size()&gt;0;
+		  for (int i=newCh.travelbugs.size()-1; i&gt;=0; i--) {
+			 Travelbug tb=newCh.travelbugs.getTB(i);  
+		     Travelbug oldTB=this.travelbugs.find(tb.getName());
 		     // If the bug is already in the cache, we keep it
 		     if (oldTB!=null)
-		    	 newCh.Travelbugs.replace(i,oldTB);
+		    	 newCh.travelbugs.replace(i,oldTB);
 		    
 		  }
-		  this.Travelbugs = newCh.Travelbugs;
+		  this.travelbugs = newCh.travelbugs;
 		  
 		  // URL
 		  this.URL = newCh.URL;
 		  
-		  setLongDescription(newCh.LongDescription);
-		  setHints(newCh.Hints);
-		  setCacheLogs(newCh.CacheLogs);
+		  setLongDescription(newCh.longDescription);
+		  setHints(newCh.hints);
+		  setCacheLogs(newCh.cacheLogs);
 		  
-		  if (newCh.Solver.length()&gt;0) this.Solver=newCh.Solver;
+		  if (newCh.solver.length()&gt;0) this.solver=newCh.solver;
 	 	return this;
 	  }
 	  
@@ -118,17 +118,17 @@
 		  String imgDesc, imgDestName;
 		  
 		  //Get Image and description
-			FileChooser fc = new FileChooser(FileChooserBase.OPEN, profile.dataDir);
-			fc.setTitle(&quot;Select image file:&quot;);
-			if(fc.execute() != FormBase.IDCANCEL){
+			FileChooser fc = new FileChooser(FileChooser.OPEN, profile.dataDir);
+			fc.title=&quot;Select image file:&quot;;
+			if(fc.execute() != FileChooser.IDCANCEL){
 				imgFile = fc.getChosenFile();
 				imgDesc = new InputBox(&quot;Description&quot;).input(&quot;&quot;,10);
 				//Create Destination Filename
 				String ext = imgFile.getFileExt().substring(imgFile.getFileExt().lastIndexOf(&quot;.&quot;));
-				imgDestName = this.wayPoint + &quot;_U_&quot; + (this.UserImages.size()+1) + ext;
+				imgDestName = this.wayPoint + &quot;_U_&quot; + (this.userImages.size()+1) + ext;
 				
-				this.UserImages.add(imgDestName);
-				this.UserImagesText.add(imgDesc);
+				this.userImages.add(imgDestName);
+				this.userImagesText.add(imgDesc);
 				// Copy File
 				DataMover.copy(imgFile.getFullPath(),profile.dataDir + imgDestName);
 				// Save Data
@@ -143,84 +143,89 @@
 		*	images.
 		*/
 		public void readCache(String dir) throws IOException{
+eve.sys.Vm.debug(&quot;===chD:readDetail: &quot;+wayPoint);
 			String dummy;
-			FileReader in = null;
-			if (new FileBugfix(dir + wayPoint.toLowerCase() + &quot;.xml&quot;).exists()) in = new FileReader(dir+wayPoint.toLowerCase() + &quot;.xml&quot;);
-			if (in == null) {
-				if (new FileBugfix(dir + wayPoint + &quot;.xml&quot;).exists()) in = new FileReader(dir+wayPoint + &quot;.xml&quot;);
+			String filename=dir+wayPoint.toLowerCase()+&quot;.xml&quot;;
+			if (!new File(filename).exists()) {
+				filename=dir+wayPoint+&quot;.xml&quot;;
+				if (!new File(filename).exists()) new java.io.FileNotFoundException(dir+wayPoint.toLowerCase()+&quot;.xml&quot;);
 			}
-			if (in == null) throw new FileNotFoundException(dir+wayPoint.toLowerCase()+&quot;.xml&quot;);
-			String text= in.readAll();
+			char buf[]=new char[(int) (new File(filename)).getLength()];
+			java.io.InputStreamReader in = new java.io.InputStreamReader(new java.io.FileInputStream(filename),&quot;UTF8&quot;);
+			int len=in.read(buf);
 			in.close();
+			eve.util.CharArray ca=new eve.util.CharArray(buf); ca.setLength(len);
+			String text=(ca).toString();
 			Extractor ex = new Extractor(text, &quot;&lt;DETAILS&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/DETAILS&gt;&quot;, 0, true);		
-			LongDescription = ex.findNext();
+			longDescription = ex.findNext();
 			ex = new Extractor(text, &quot;&lt;HINTS&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/HINTS&gt;&quot;, 0, true);
-			Hints = ex.findNext();
+			hints = ex.findNext();
 			// Attributes
 			ex = new Extractor(text,&quot;&lt;ATTRIBUTES&gt;&quot;,&quot;&lt;/ATTRIBUTES&gt;&quot;,0,true);
-			attributes.XmlAttributesEnd(ex.findNext());
+			attributes.xmlAttributesEnd(ex.findNext());
 			
 			ex = new Extractor(text, &quot;&lt;LOGS&gt;&quot;,&quot;&lt;/LOGS&gt;&quot;, 0, true);
 			dummy = ex.findNext();
-			CacheLogs.clear();
+			cacheLogs.clear();
 			ex = new Extractor(dummy, &quot;&lt;LOG&gt;&quot;,&quot;&lt;/LOG&gt;&quot;, 0, true);
 			
 			dummy = ex.findNext();
 			while(ex.endOfSearch()==false){
-				CacheLogs.add(new Log(dummy));
+				cacheLogs.add(new Log(dummy));
 				dummy = ex.findNext();
 			}
 			ex = new Extractor(text, &quot;&lt;NOTES&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/NOTES&gt;&quot;, 0, true);
-			CacheNotes = ex.findNext();
-			Images.clear();
+			cacheNotes = ex.findNext();
+			images.clear();
 			ex = new Extractor(text, &quot;&lt;IMG&gt;&quot;, &quot;&lt;/IMG&gt;&quot;, 0, true);
 			dummy = ex.findNext();
 			while(ex.endOfSearch() == false){
-				Images.add(dummy);
+				images.add(dummy);
 				dummy = ex.findNext();
 			}
-			ImagesText.clear();
+			imagesText.clear();
 			ex = new Extractor(text, &quot;&lt;IMGTEXT&gt;&quot;, &quot;&lt;/IMGTEXT&gt;&quot;, 0, true);
 			dummy = ex.findNext();
 			while(ex.endOfSearch() == false){
 				int pos=dummy.indexOf(&quot;&lt;DESC&gt;&quot;);
 				if (pos&gt;0) {
-					ImagesText.add(dummy.substring(0,pos));
-					ImagesInfo.add(dummy.substring(pos+6,dummy.indexOf(&quot;&lt;/DESC&gt;&quot;)));
+					imagesText.add(dummy.substring(0,pos));
+					imagesInfo.add(dummy.substring(pos+6,dummy.indexOf(&quot;&lt;/DESC&gt;&quot;)));
 				} else {
-					ImagesText.add(dummy);
-					ImagesInfo.add(null);
+					imagesText.add(dummy);
+					imagesInfo.add(null);
 				}
 				dummy = ex.findNext();
 			}
+
 			// Logimages
-			LogImages.clear();
+			logImages.clear();
 			ex = new Extractor(text, &quot;&lt;LOGIMG&gt;&quot;, &quot;&lt;/LOGIMG&gt;&quot;, 0, true);
 			dummy = ex.findNext();
 			while(ex.endOfSearch() == false){
-				LogImages.add(dummy);
+				logImages.add(dummy);
 				dummy = ex.findNext();
 			}
-			LogImagesText.clear();
+			logImagesText.clear();
 			ex = new Extractor(text, &quot;&lt;LOGIMGTEXT&gt;&quot;, &quot;&lt;/LOGIMGTEXT&gt;&quot;, 0, true);
 			dummy = ex.findNext();
 			while(ex.endOfSearch() == false){
-				LogImagesText.add(dummy);
+				logImagesText.add(dummy);
 				dummy = ex.findNext();
 			}
 
-			UserImages.clear();
+			userImages.clear();
 			ex = new Extractor(text, &quot;&lt;USERIMG&gt;&quot;, &quot;&lt;/USERIMG&gt;&quot;, 0, true);
 			dummy = ex.findNext();
 			while(ex.endOfSearch() == false){
-				UserImages.add(dummy);
+				userImages.add(dummy);
 				dummy = ex.findNext();
 			}
-			UserImagesText.clear();
+			userImagesText.clear();
 			ex = new Extractor(text, &quot;&lt;USERIMGTEXT&gt;&quot;, &quot;&lt;/USERIMGTEXT&gt;&quot;, 0, true);
 			dummy = ex.findNext();
 			while(ex.endOfSearch() == false){
-				UserImagesText.add(dummy);
+				userImagesText.add(dummy);
 				dummy = ex.findNext();
 			}
 
@@ -229,9 +234,9 @@
 			if (ex.endOfSearch()) {
 				ex = new Extractor(text, &quot;&lt;BUGS&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/BUGS&gt;&quot;, 0, true);
 				String Bugs = ex.findNext();
-				Travelbugs.addFromHTML(Bugs);
+				travelbugs.addFromHTML(Bugs);
 			} else
-				Travelbugs.addFromXML(dummy);
+				travelbugs.addFromXML(dummy);
 			
 			ex = new Extractor(text, &quot;&lt;URL&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/URL&gt;&quot;, 0, true);
 			// if no URL is stored, set default URL (at this time only possible for gc.com)
@@ -245,7 +250,7 @@
 				}
 			}
 			ex = new Extractor(text, &quot;&lt;SOLVER&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/SOLVER&gt;&quot;, 0, true);
-			Solver=ex.findNext();
+			solver=ex.findNext();
 		}
 		
 		/**
@@ -268,7 +273,7 @@
 			}
 			//Vm.debug(&quot;Writing to: &quot; +dir + &quot;for: &quot; + wayPoint);
 			try{
-			  detfile = new PrintWriter(new BufferedWriter(new FileWriter(dir + wayPoint.toLowerCase() + &quot;.xml&quot;)));
+		        detfile = new PrintWriter(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(dir + wayPoint.toLowerCase() + &quot;.xml&quot;), &quot;UTF8&quot;)));
 			} catch (Exception e) {
 				Global.getPref().log(&quot;Problem creating details file&quot;,e,true);
 				return;
@@ -277,46 +282,40 @@
 				if(wayPoint.length()&gt;0){
 				  detfile.print(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;ISO-8859-1\&quot;?&gt;\r\n&quot;);
 				  detfile.print(&quot;&lt;CACHEDETAILS&gt;\r\n&quot;);
-				  detfile.print(&quot;&lt;DETAILS&gt;&lt;![CDATA[&quot;+LongDescription+&quot;]]&gt;&lt;/DETAILS&gt;\r\n&quot;);
-				  detfile.print(attributes.XmlAttributesWrite());
-				  detfile.print(&quot;&lt;HINTS&gt;&lt;![CDATA[&quot;+Hints+&quot;]]&gt;&lt;/HINTS&gt;\r\n&quot;);
+				  detfile.print(&quot;&lt;DETAILS&gt;&lt;![CDATA[&quot;+longDescription+&quot;]]&gt;&lt;/DETAILS&gt;\r\n&quot;);
+				  detfile.print(attributes.xmlAttributesWrite());
+				  detfile.print(&quot;&lt;HINTS&gt;&lt;![CDATA[&quot;+hints+&quot;]]&gt;&lt;/HINTS&gt;\r\n&quot;);
 				  detfile.print(&quot;&lt;LOGS&gt;\r\n&quot;);
-				  for(int i = 0; i &lt; CacheLogs.size(); i++){
-					  detfile.print(CacheLogs.getLog(i).toXML());
+				  for(int i = 0; i &lt; cacheLogs.size(); i++){
+					  detfile.print(cacheLogs.getLog(i).toXML());
 				  }
 				  detfile.print(&quot;&lt;/LOGS&gt;\r\n&quot;);
 			
-				  detfile.print(&quot;&lt;NOTES&gt;&lt;![CDATA[&quot;+CacheNotes+&quot;]]&gt;&lt;/NOTES&gt;\n&quot;);
-				  detfile.print(&quot;&lt;IMAGES&gt;\n&quot;);
-				  String stbuf = new String();
-				  for(int i = 0;i&lt;Images.size();i++){
-						stbuf = (String)Images.get(i);
-						detfile.print(&quot;    &lt;IMG&gt;&quot;+stbuf+&quot;&lt;/IMG&gt;\n&quot;);
+				  detfile.print(&quot;&lt;NOTES&gt;&lt;![CDATA[&quot;+cacheNotes+&quot;]]&gt;&lt;/NOTES&gt;\n&quot;);
+				  detfile.print(&quot;&lt;IMAGES&gt;&quot;);
+				  String stbuf;
+				  for(int i = 0;i&lt;images.size();i++){
+						detfile.print(&quot;    &lt;IMG&gt;&quot;+images.get(i)+&quot;&lt;/IMG&gt;\n&quot;);
 				  }
-				  int iis = ImagesInfo.size();
-				  for(int i = 0;i&lt;ImagesText.size();i++){
-						stbuf = (String)ImagesText.get(i);
-						if (i&lt; iis &amp;&amp; ImagesInfo.get(i) != null)
-							detfile.print(&quot;    &lt;IMGTEXT&gt;&quot;+stbuf+&quot;&lt;DESC&gt;&quot;+ImagesInfo.get(i)+&quot;&lt;/DESC&gt;&lt;/IMGTEXT&gt;\n&quot;);
+				  int iis = imagesInfo.size();
+				  for(int i = 0;i&lt;imagesText.size();i++){
+						stbuf = (String)imagesText.get(i);
+						if (i &lt; iis &amp;&amp; imagesInfo.get(i) != null)
+							detfile.print(&quot;    &lt;IMGTEXT&gt;&quot;+stbuf+&quot;&lt;DESC&gt;&quot;+imagesInfo.get(i)+&quot;&lt;/DESC&gt;&lt;/IMGTEXT&gt;\n&quot;);
 						else 
 							detfile.print(&quot;    &lt;IMGTEXT&gt;&quot;+stbuf+&quot;&lt;/IMGTEXT&gt;\n&quot;);
 				  }
-
-				  for(int i = 0;i&lt;LogImages.size();i++){
-						stbuf = (String)LogImages.get(i);
-						detfile.print(&quot;    &lt;LOGIMG&gt;&quot;+stbuf+&quot;&lt;/LOGIMG&gt;\n&quot;);
+				  for(int i = 0;i&lt;logImages.size();i++){
+						detfile.print(&quot;    &lt;LOGIMG&gt;&quot;+logImages.get(i)+&quot;&lt;/LOGIMG&gt;\n&quot;);
 				  }
-				  for(int i = 0;i&lt;LogImagesText.size();i++){
-						stbuf = (String)LogImagesText.get(i);
-						detfile.print(&quot;    &lt;LOGIMGTEXT&gt;&quot;+stbuf+&quot;&lt;/LOGIMGTEXT&gt;\n&quot;);
+				  for(int i = 0;i&lt;logImagesText.size();i++){
+						detfile.print(&quot;    &lt;LOGIMGTEXT&gt;&quot;+logImagesText.get(i)+&quot;&lt;/LOGIMGTEXT&gt;\n&quot;);
 				  }
-				  for(int i = 0;i&lt;UserImages.size();i++){
-						stbuf = (String)UserImages.get(i);
-						detfile.print(&quot;    &lt;USERIMG&gt;&quot;+stbuf+&quot;&lt;/USERIMG&gt;\n&quot;);
+				  for(int i = 0;i&lt;userImages.size();i++){
+						detfile.print(&quot;    &lt;USERIMG&gt;&quot;+userImages.get(i)+&quot;&lt;/USERIMG&gt;\n&quot;);
 				  }
-				  for(int i = 0;i&lt;UserImagesText.size();i++){
-						stbuf = (String)UserImagesText.get(i);
-						detfile.print(&quot;    &lt;USERIMGTEXT&gt;&quot;+stbuf+&quot;&lt;/USERIMGTEXT&gt;\n&quot;);
+				  for(int i = 0;i&lt;userImagesText.size();i++){
+						detfile.print(&quot;    &lt;USERIMGTEXT&gt;&quot;+userImagesText.get(i)+&quot;&lt;/USERIMGTEXT&gt;\n&quot;);
 				  }
 
 
@@ -324,9 +323,9 @@
 				  //detfile.print(&quot;&lt;BUGS&gt;&lt;![CDATA[\n&quot;);
 				  //detfile.print(Bugs+&quot;\n&quot;);
 				  //detfile.print(&quot;]]&gt;&lt;/BUGS&gt;\n&quot;);
-				  detfile.print(Travelbugs.toXML());
+				  detfile.print(travelbugs.toXML());
 				  detfile.print(&quot;&lt;URL&gt;&lt;![CDATA[&quot;+URL+&quot;]]&gt;&lt;/URL&gt;\r\n&quot;);
-				  detfile.print(&quot;&lt;SOLVER&gt;&lt;![CDATA[&quot;+Solver+&quot;]]&gt;&lt;/SOLVER&gt;\r\n&quot;);
+				  detfile.print(&quot;&lt;SOLVER&gt;&lt;![CDATA[&quot;+solver+&quot;]]&gt;&lt;/SOLVER&gt;\r\n&quot;);
 				  detfile.print(toXML()); // This will allow restoration of index.xml
 				  detfile.print(&quot;&lt;/CACHEDETAILS&gt;\n&quot;);
 				} // if length
@@ -336,7 +335,7 @@
 			try{
 			  detfile.close();
 			} catch (Exception e){
-				Global.getPref().log(&quot;Problem waypoint &quot; + wayPoint + &quot; writing to a details file: &quot; + e.getMessage());
+			  Global.getPref().log(&quot;Problem waypoint &quot; + wayPoint + &quot; writing to a details file: &quot; + e.getMessage());
 			}
 			hasUnsavedChanges = false;
 		}
@@ -349,24 +348,26 @@
 		 * @param ch cache to check
 		 * @return true if there is a relation, false otherwise
 		 */
-		public boolean belongsTo (CacheHolder ch) {
+/*		public boolean belongsTo (CacheHolder ch) {
 			
 			// avoid self referencing
 			if (this.wayPoint.equals(ch.wayPoint)) return false;
 
 			return this.wayPoint.endsWith(ch.wayPoint.substring(2));
 		}
-		
+*/		
 		/**
 		 * Return true if this cache has additional info for some pictures
 		 * @return true if cache has additional info, false otherwise
 		 */
 		public boolean hasImageInfo() {
-			for (int i=ImagesInfo.size()-1; i&gt;=0; i--)
-				if (ImagesInfo.get(i)!=null) return true;
+			for (int i=imagesInfo.size()-1; i&gt;=0; i--)
+				if (imagesInfo.get(i)!=null) return true;
 			return false;
 		}
 
+		
+
 //	   public void finalize() {
 //		   super.finalize();
 //		   Vm.debug(&quot;Destroying CacheHolder &quot;+wayPoint);

Modified: experiments/engywuck/hist-test/src/cachewolf/CacheList.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/CacheList.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/CacheList.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,63 +1,72 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.filechooser.FileChooser;
-import ewe.filechooser.FileChooserBase;
-import ewe.fx.*;
-import ewe.io.*;
-import ewe.sys.*;
-import ewe.ui.*;
-import ewe.util.*;
+import eve.ui.filechooser.FileChooser;
+import eve.fx.*;
+import eve.sys.*;
+import eve.ui.*;
+import java.util.*;
+import java.io.FileReader;
+import java.io.PrintWriter;
+import java.io.BufferedWriter;
+import eve.ui.event.KeyEvent;
+import eve.fx.gui.IKeys;
+import eve.ui.event.MenuEvent;
+import eve.ui.event.MultiPanelEvent;
+import eve.ui.event.ControlEvent;
+import java.io.BufferedReader;
+import java.io.FileWriter;
 
+
 /********************************************************
  * This class implements the core functionality of a flexible cachelist for collecting
  * &quot;Cachetours&quot;. Caches can be dragged into the list from the main list view and
  * from the radar panel view. Caches can be removed from the list by dragging them
  * out or selecting them and pressing the &quot;delete&quot; key. Within the list the selected
- * cache can be moved up/down using two buttons. The finished list can be saved and 
+ * cache can be moved up/down using two buttons. The finished list can be saved and
  * reloaded with the selected position being stored. The list can be applied as
  * a filter to the main list, thereby hiding all caches that are not in the list
- * and sorting the caches according to the list. 
+ * and sorting the caches according to the list.
  * Created by skg, Februar 2007
  ********************************************************/
 public class CacheList extends CellPanel {
-    /** The extension for cachelists (CL) */ 
-    private final String EXTENSION=&quot;CL&quot;;
-	private final String TITLE=MyLocale.getMsg(188,&quot;CACHETOUR: NEW&quot;);
+    /** The extension for cachelists (CL) */
+    private final static String EXTENSION=&quot;CL&quot;;
+	private final static String TITLE=MyLocale.getMsg(188,&quot;CACHETOUR: NEW&quot;);
 	private static int applyCount=0; // Counts the number of times we apply the list
     CacheList() {
-		this.setPreferredSize(100,-1); 
+		this.setPreferredSize(100,-1);
 		this.equalWidths=true;
-		mImage imgDown=new mImage(&quot;ewe/downarrowsmall.bmp&quot;); imgDown.transparentColor=Color.White;
-		mImage imgUp=new mImage(&quot;ewe/uparrowsmall.bmp&quot;); imgUp.transparentColor=Color.White;
+		Picture imgDown=new Picture(&quot;eve/downarrowsmall.png&quot;); //imgDown.transparentColor=Color.White;
+		Picture imgUp=new Picture(&quot;eve/uparrowsmall.png&quot;); //imgUp.transparentColor=Color.White;
 		// Title
-		lblTitle=new mLabel(TITLE);
-		lblTitle.backGround=new Color(0,0,200); lblTitle.foreGround=Color.White; 
+		lblTitle=new Label(TITLE);
+		lblTitle.backGround=new Color(0,0,200); lblTitle.foreGround=Color.White;
 		addLast(lblTitle,HSTRETCH,HFILL|HCENTER);
 		// The actual list
-		lstCaches=new myList(10,1,false); lstCaches.text=&quot;CacheList&quot;; 
+		lstCaches=new myList(10,1,false); lstCaches.text=&quot;CacheList&quot;;
 		lstCaches.addItem(MyLocale.getMsg(180,&quot;Drag caches&quot;));lstCaches.addItem(MyLocale.getMsg(181,&quot;here&quot;));
 		ScrollablePanel scp=lstCaches.getScrollablePanel();
 		addLast(scp,STRETCH,FILL); scp.setOptions(MyScrollBarPanel.NeverShowHorizontalScrollers);
 		// The buttons to move the selected cache
-		addNext(btnDown=new mButton(imgDown),HSHRINK,HFILL); btnDown.modify(Disabled,0);
-		addLast(btnUp=new mButton(imgUp),HSHRINK,HFILL); btnUp.modify(Disabled,0);
+		addNext(btnDown=new Button(imgDown),HSHRINK,HFILL); btnDown.modify(Disabled,0);
+		addLast(btnUp=new Button(imgUp),HSHRINK,HFILL); btnUp.modify(Disabled,0);
 		// Buttons to clear, load and save the list
-		CellPanel cp=new CellPanel(); cp.equalWidths=true;
-		cp.addNext(btnNew=new mButton(imgNew=new mImage(&quot;clnew.png&quot;)),HSTRETCH,HFILL);
-		imgNew.transparentColor=new Color(255,0,0); btnNew.setToolTip(MyLocale.getMsg(182,&quot;New list&quot;));
-		cp.addNext(btnLoad=new mButton(imgOpen=new mImage(&quot;clopen.png&quot;)),HSTRETCH,HFILL);
-		imgOpen.transparentColor=new Color(255,0,0);btnLoad.setToolTip(MyLocale.getMsg(183,&quot;Load list&quot;));
-		cp.addNext(btnSaveAs=new mButton(imgSaveAs=new mImage(&quot;clsaveas.png&quot;)),HSTRETCH,HFILL);
-		imgSaveAs.transparentColor=new Color(0,255,0);btnSaveAs.setToolTip(MyLocale.getMsg(184,&quot;Save as&quot;));
-		cp.addLast(btnSave=new mButton(imgSave=new mImage(&quot;clsave.png&quot;)),HSTRETCH,HFILL);
-		imgSave.transparentColor=new Color(255,0,0);btnSave.setToolTip(MyLocale.getMsg(185,&quot;Save (without confirmation)&quot;));
+		Panel cp=new Panel(); cp.equalWidths=true;
+		cp.addNext(btnNew=new Button(new Picture(&quot;clnew.png&quot;,new Color(255,0,0),0)),HSTRETCH,HFILL);
+		btnNew.setToolTip(MyLocale.getMsg(182,&quot;New list&quot;));
+		cp.addNext(btnLoad=new Button(new Picture(&quot;clopen.png&quot;,new Color(255,0,0),0)),HSTRETCH,HFILL);
+		btnLoad.setToolTip(MyLocale.getMsg(183,&quot;Load list&quot;));
+		cp.addNext(btnSaveAs=new Button(new Picture(&quot;clsaveas.png&quot;,new Color(0,255,0),0)),HSTRETCH,HFILL);
+		btnSaveAs.setToolTip(MyLocale.getMsg(184,&quot;Save as&quot;));
+		cp.addLast(btnSave=new Button(new Picture(&quot;clsave.png&quot;,new Color(255,0,0),0)),HSTRETCH,HFILL);
+		btnSave.setToolTip(MyLocale.getMsg(185,&quot;Save (without confirmation)&quot;));
 		addLast(cp,HSTRETCH,HFILL);
 		// Button to toggle whether additional waypoints are automatically dragged
 		// with the parent waypoint
-		addLast(chkAddAddis=new mCheckBox(MyLocale.getMsg(193,&quot;add Addis&quot;)),HSTRETCH,HFILL);
+		addLast(chkAddAddis=new CheckBox(MyLocale.getMsg(193,&quot;add Addis&quot;)),HSTRETCH,HFILL);
 		chkAddAddis.setToolTip(MyLocale.getMsg(186,&quot;Also drag Addi Wpts&quot;));
 		// Finally button to apply the list as a filter
-		addLast(btnFilter=new mButton(MyLocale.getMsg(189,&quot;Apply List&quot;)),HSTRETCH,HFILL);btnFilter.modify(Disabled,0);
+		addLast(btnFilter=new Button(MyLocale.getMsg(189,&quot;Apply List&quot;)),HSTRETCH,HFILL);btnFilter.modify(Disabled,0);
 		btnFilter.setToolTip(MyLocale.getMsg(190,&quot;Show only these waypoints&quot;));
 	}
     /** Flag to ensure the initial message &quot;Caches hierher ziehen&quot; is cleared
@@ -68,72 +77,74 @@
 	/** True if there are unsaved changes */
 	private boolean dirty=false;
 	// The UI elements
-	private mLabel lblTitle; 
-	private mCheckBox chkAddAddis;
-	private mButton btnDown, btnUp, btnLoad, btnNew, btnSave, btnSaveAs, btnFilter;
-    private mImage imgOpen,imgNew,imgSave,imgSaveAs;
-	/** This list mirrors the items in the list of selected caches for faster access. When the 
+	private Label lblTitle;
+	private CheckBox chkAddAddis;
+	private Button btnDown, btnUp, btnLoad, btnNew, btnSave, btnSaveAs, btnFilter;
+	/** This list mirrors the items in the list of selected caches for faster access. When the
      * list of selected caches is manipulated (btnUp, btnDown), this list is also kept up to date
      */
 	private Vector cacheList=new Vector(20);
 	/** The full filename of the current file */
 	private String currFile=null;
-	
-	private class myList extends mList {
-		myList(int rows, int columns, boolean multi) { super(rows,columns,multi); }
-		
+
+	private class myList extends eve.ui.List {
+		myList(int rows, int columns, boolean multi) {
+			super(rows,columns,multi);
+			modify(WantDrag,0);
+		}
+
 		//  Allow the caches to be dragged out of the cachelist
-		String wayPoint;
+		//String wayPoint;
 		int idx;
-		
+
 		public void startDragging(DragContext dc) {
 			 idx=getSelectedIndex(0);
 			 if (idx&gt;=0) {
 				 CacheHolder ch=(CacheHolder)cacheList.get(idx);
-				 wayPoint=ch.wayPoint;
+				 //wayPoint=ch.wayPoint;
 				 IconAndText imgDrag=new IconAndText();
-				 imgDrag.addColumn(CacheType.cache2Img(ch.type));
+				 imgDrag.addColumn( CacheType.cache2Img(ch.type));
 				 imgDrag.addColumn(ch.wayPoint);
 				 dc.dragData=dc.startImageDrag(imgDrag,new Point(8,8),this);
-			 } 
+			 }
 		}
 
 		public void dragged(DragContext dc) {
 			 	dc.imageDrag();
 		}
-		 
+
 		public void stopDragging(DragContext dc) {
 			 dc.stopImageDrag(true);
-			 Point p = Gui.getPosInParent(this,getWindow());
+			 Point p = Gui.getPosInParent(this,getWindow(),null);
 			 p.x += dc.curPoint.x;
 			 p.y += dc.curPoint.y;
 			 Control c = getWindow().findChild(p.x,p.y);
-		     if (!(c instanceof myList)) { 
+		     if (!(c instanceof myList)) {
 		    	 // target is not myList =&gt; Remove dragged cache from list
-		    	 cacheList.del(idx);
+		    	 cacheList.removeElementAt(idx);
 		    	 lstCaches.deleteItem(idx);
 		    	 repaint();
 		    	 changeUpDownButtonStatus();
 		     }
 		 }
-		
+
 		// Alternative method of deleting a cache from the list through
 		// Keyboard interface
 		public void onKeyEvent(KeyEvent ev) {
-			/* This is a bit of a hack. By default Ewe sends key events to 
+			/* This is a bit of a hack. By default eve sends key events to
 			 * this panel. So if the list has not had anything dragged into it,
 			 * we redirect the focus to the list view, assuming that that is where
 			 * the key event needs to go.
 			 */
 			if (needsInit &amp;&amp; ev.target==this) {
-				Gui.takeFocus(Global.mainTab.tbP.tc, ControlConstants.ByKeyboard);
-				ev.target=Global.mainTab.tbP.tc;
+				Gui.takeFocus(Global.mainTab.tbP.tControl, Control.ByKeyboard);
+				ev.target=Global.mainTab.tbP.tControl;
 				postEvent(ev);
 			}
 			if (ev.type == KeyEvent.KEY_PRESS &amp;&amp; ev.target == this){
 				if (ev.key == IKeys.DELETE &amp;&amp; cacheList.size()&gt;0) {
 			    	 idx=getSelectedIndex(0);
-					 cacheList.del(idx);
+					 cacheList.removeElementAt(idx);
 			    	 lstCaches.deleteItem(idx);
 			    	 repaint();
 			    	 changeUpDownButtonStatus();
@@ -141,25 +152,25 @@
 			}
 			super.onKeyEvent(ev);
 		}
-		public ScrollablePanel getScrollablePanel()
-		{
+		public ScrollablePanel getScrollablePanel() {
 			dontAutoScroll = amScrolling = true;
 			ScrollBarPanel sp = new MyScrollBarPanel(this);
 			sp.modify(0,TakeControlEvents);
 			return sp;
 		}
 
+
 	} //******************* myList
-	
+
 	/** Simple sort to ensure that the main list keeps the order of this list */
-	private class mySort implements Comparer{
+	private class mySort implements eve.util.Comparer{
 		public int compare(Object o1, Object o2){
 			CacheHolder oo1 = (CacheHolder)o1;
 			CacheHolder oo2 = (CacheHolder)o2;
 			return oo1.sort.compareTo(oo2.sort);
 		}
 	}
-	
+
 	/** Enable the up/down buttons only if at least 2 caches are in the list */
 	private void changeUpDownButtonStatus() {
 		btnUp.modify(0,Disabled);
@@ -173,20 +184,20 @@
 		if (needsInit || lstCaches.itemsSize()&lt;2) btnFilter.modify(Disabled,0);
 		btnFilter.repaintNow();
 	}
-	
+
 	public void onEvent(Event ev) {
 		if (ev instanceof MenuEvent &amp;&amp; ev.type==MenuEvent.SELECTED) {
 			if (lstCaches.itemsSize()&gt;0 &amp;&amp; !needsInit) {
 				int lstCacheIdx=lstCaches.getSelectedIndex(0);
 				CacheHolder ch=(CacheHolder)cacheList.get(lstCacheIdx);
-				int idx=Global.getProfile().cacheDB.find(ch);
+				int idx=Global.getProfile().cacheDB.indexOf(ch);
 				// Ensure that the main view is updated with the selected cache, i.e.
 				// DetailsPanel, HintLog, Pictures etc.
 				int activeTab=Global.mainTab.cardPanel.selectedItem;
-				if (activeTab==0) { 
+				if (activeTab==0) {
 					// Select the cache also in the main list view
 					Global.mainTab.tbP.selectRow(idx);
-					Global.mainTab.tbP.tc.repaint();
+					Global.mainTab.tbP.tControl.repaint();
 				} else {
 					// We need to change to the list view first to load a new cache
 					Global.mainTab.onEvent(new MultiPanelEvent(0,Global.mainTab,0));
@@ -196,26 +207,26 @@
 			}
 		}
 		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
-			if (ev.target==btnNew) { 
+			if (ev.target==btnNew) {
 				newCacheList();
 			} else if(ev.target == btnLoad){
-				FileChooser fc = new FileChooser(FileChooserBase.OPEN, Global.getProfile().dataDir);
+				FileChooser fc = new FileChooser(FileChooser.OPEN, Global.getProfile().dataDir);
 				//fc.addMask(currCh.wayPoint + &quot;.wl&quot;);
 				fc.addMask(&quot;*.&quot;+EXTENSION);
 				fc.addMask(&quot;*.*&quot;);
-				fc.setTitle(MyLocale.getMsg(191,&quot;Select File&quot;));
-				if(fc.execute() != FormBase.IDCANCEL){
+				fc.title=MyLocale.getMsg(191,&quot;Select File&quot;);
+				if(fc.execute() != FileChooser.IDCANCEL){
 					currFile = fc.getChosen();
 					readFromFile(currFile);
 				}
 			} else if((ev.target == btnSave) &amp;&amp; (currFile != null)){
 				saveToFile(currFile);
 			} else if((ev.target == btnSaveAs)||((ev.target == btnSave) &amp;&amp; (currFile == null))){
-				FileChooser fc = new FileChooser(FileChooserBase.SAVE, Global.getProfile().dataDir);
+				FileChooser fc = new FileChooser(FileChooser.SAVE, Global.getProfile().dataDir);
 				//fc.addMask(currCh.wayPoint + &quot;.wl&quot;);
 				fc.addMask(&quot;*.&quot;+EXTENSION);
-				fc.setTitle(MyLocale.getMsg(191,&quot;Select File&quot;));
-				if(fc.execute() != FormBase.IDCANCEL){
+				fc.title=MyLocale.getMsg(191,&quot;Select File&quot;);
+				if(fc.execute() != FileChooser.IDCANCEL){
 					currFile = fc.getChosen();
 					if (currFile.indexOf('.')==0 || !currFile.toUpperCase().endsWith(&quot;.&quot;+EXTENSION)) currFile+=&quot;.&quot;+EXTENSION;
 					saveToFile(currFile);
@@ -226,12 +237,12 @@
 					dirty=true;
 					// Swap items in hidden list
 					Object swap=cacheList.get(sel-1);
-					cacheList.set(sel-1,cacheList.get(sel));
-					cacheList.set(sel,swap);
+					cacheList.setElementAt(cacheList.get(sel),sel-1);
+					cacheList.setElementAt(swap,sel);
 					// Swap items in visible cachelist and repaint
 					swap=lstCaches.items.get(sel-1);
-					lstCaches.items.set(sel-1,lstCaches.items.get(sel));
-					lstCaches.items.set(sel,swap);
+					lstCaches.items.setElementAt(lstCaches.items.get(sel),sel-1);
+					lstCaches.items.setElementAt(swap,sel);
 					lstCaches.repaintDataNow();
 					lstCaches.select(sel-1);
 				}
@@ -241,12 +252,12 @@
 					dirty=true;
 					// Swap items in hidden list
 					Object swap=cacheList.get(sel+1);
-					cacheList.set(sel+1,cacheList.get(sel));
-					cacheList.set(sel,swap);
+					cacheList.setElementAt(cacheList.get(sel),sel+1);
+					cacheList.setElementAt(swap,sel);
 					// Swap items in visible cachelist and repaint
 					swap=lstCaches.items.get(sel+1);
-					lstCaches.items.set(sel+1,lstCaches.items.get(sel));
-					lstCaches.items.set(sel,swap);
+					lstCaches.items.setElementAt(lstCaches.items.get(sel),sel+1);
+					lstCaches.items.setElementAt(swap,sel);
 					lstCaches.repaintDataNow();
 					lstCaches.select(sel+1);
 				}
@@ -284,7 +295,7 @@
 				ch=null;
 				ch=(CacheHolder) cacheDB.get(idx);
 			}
-			if (ch.is_black!=Global.getProfile().showBlacklisted) 
+			if (ch.is_black!=Global.getProfile().showBlacklisted)
 				wrongBlackStatus++;
 			else {
 				ch.is_filtered=false;
@@ -292,17 +303,17 @@
 			}
 		}
 		// The sort command places all filtered caches at the end
-		cacheDB.sort(new mySort(),false);
+		eve.util.Utils.sort(new Handle(),cacheDB, new mySort(),false);
 		Global.getProfile().filterActive=Filter.FILTER_CACHELIST;
 		Global.getProfile().filterInverted=false;
 		Global.getProfile().hasUnsavedChanges=true;
 		updateScreen(cacheList.size()-wrongBlackStatus);
 		if (wrongBlackStatus&gt;0)
-			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;),MyLocale.getMsg(4600,&quot;Some cache(s) cannot be shown because of wrong blacklist status&quot;), FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;),MyLocale.getMsg(4600,&quot;Some cache(s) cannot be shown because of wrong blacklist status&quot;), MessageBox.OKB)).execute();
 
 	}
-	
-	/** Add a cache (and its addis) to the list 
+
+	/** Add a cache (and its addis) to the list
 	 * @return true if the cache is not already in lstCaches */
 	public boolean addCache(String wayPoint) {
 		// Check whether this is the first cache being added
@@ -316,35 +327,39 @@
 		// Add addis if user wants it
 		if (chkAddAddis.state &amp;&amp; ch.hasAddiWpt()) {
 			CacheHolder addiWpt;
-			for (int j=0; j&lt;ch.addiWpts.getCount();j++){
+			ch.allocAddiMem();
+			for (int j=0; j&lt;ch.addiWpts.size();j++){
 				addiWpt = (CacheHolder)ch.addiWpts.get(j);
 				if (!addiWpt.is_filtered) cachesAdded|=addCache(addiWpt);
 			}
 		}
 		// Update screen if any cache was added
-		if (cachesAdded) {	
+		if (cachesAdded) {
 			lstCaches.select(lstCaches.itemsSize()-1);
 			changeUpDownButtonStatus();
 		}
-		return cachesAdded;	
+		return cachesAdded;
 	}
 
 	/** Add a cache to the visible and invisible list */
 	private boolean addCache(CacheHolder ch) {
-		if (cacheList.find(ch)&lt;0) {
+		if (cacheList.indexOf(ch)&lt;0) {
 			// Add cache reference to hidden list
 			cacheList.add(ch);
 			// Add Cache and cache icon to visible list
-			lstCaches.addItem((new MenuItem()).iconize(ch.wayPoint+&quot;   &quot;+ch.CacheName,CacheType.cache2Img(ch.type),true));
+			lstCaches.addItem((new MenuItem()).iconize(ch.wayPoint+&quot;   &quot;+ch.cacheName,CacheType.cache2Img(ch.type),true));
 		    dirty=true;
 			return true;
-		} else
-			return false;
+		}
+		return false;
 	}
-	
+
 	void updateScreen(int numRows) {
-		Global.mainTab.tbP.myMod.numRows=numRows;
-		Global.mainTab.tbP.refreshTable(); // Update and repaint
+		Global.mainTab.tbP.tModel.numRows=numRows;
+		// Check whether the currently selected cache is still visible
+		//selectRow(getSelectedCache());
+		Global.mainTab.tbP.tControl.update(true); // Update and repaint
+		if (Global.mainTab.tbP.statBar!=null) Global.mainTab.tbP.statBar.updateDisplay();
 		int selPanel;
 		if ((selPanel=Global.mainTab.cardPanel.selectedItem)&gt;-1) {
 			if (selPanel==1) {
@@ -357,14 +372,14 @@
 	/** Check if there are any unsaved changes and ask user if he wants to save */
 	public void saveIfDirty() {
 		if (dirty) {
-			if ((new MessageBox(MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(192,&quot;Save changes&quot;),FormBase.MBYESNO)).execute()==FormBase.IDYES) {
+			if ((new MessageBox(MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(192,&quot;Save changes&quot;),MessageBox.MBYESNO)).execute()==MessageBox.IDYES) {
 				if (currFile!=null)
 					saveToFile(currFile);
 				else {
-					FileChooser fc = new FileChooser(FileChooserBase.SAVE, Global.getProfile().dataDir);
+					FileChooser fc = new FileChooser(FileChooser.SAVE, Global.getProfile().dataDir);
 					fc.addMask(&quot;*.&quot;+EXTENSION);
-					fc.setTitle(MyLocale.getMsg(191,&quot;Select File&quot;));
-					if(fc.execute() != FormBase.IDCANCEL){
+					fc.title=MyLocale.getMsg(191,&quot;Select File&quot;);
+					if(fc.execute() != FileChooser.IDCANCEL){
 						currFile = fc.getChosen();
 						saveToFile(currFile);
 					}
@@ -373,9 +388,9 @@
 		}
 		dirty=false;
 	}
-	
+
 	/** Clear the cachelist (save unsaved changes if needed) */
-	private void newCacheList() { 		
+	private void newCacheList() {
 		saveIfDirty();
 		lstCaches.items.clear();
 		cacheList.clear();
@@ -383,13 +398,13 @@
 		lblTitle.setText(TITLE);
 		currFile=null;
 	}
-	
+
 	/** Read a list of caches */
 	private void readFromFile(String fileName) {
 		if (needsInit)  {lstCaches.deleteItem(0);lstCaches.deleteItem(0);  needsInit=false; }
 		int select=-1;
 		try {
-			FileReader in = new FileReader(fileName);
+			BufferedReader in = new BufferedReader(new FileReader(fileName));
 			String wayPoint;
 			int idx;
 			Vector cacheDB=Global.getProfile().cacheDB;
@@ -414,7 +429,7 @@
 		}
 		if (select&gt;-1)
 			lstCaches.select(select);
-		else	
+		else
 		    lstCaches.select(lstCaches.itemsSize()-1);
 		lstCaches.repaint();
 		this.postEvent(new MenuEvent(MenuEvent.SELECTED,this,null));
@@ -422,7 +437,7 @@
 		setTitle(fileName);
 		dirty=false;
 	}
-	
+
 	/** Save the cachelist */
 	private void saveToFile(String fileName) {
 		int selectedIndex=lstCaches.getSelectedIndex(0);
@@ -439,7 +454,7 @@
 		setTitle(fileName);
 		dirty=false;
 	}
-	
+
 	/** Set the title */
 	private void setTitle(String fileName) {
 		String localFileName=fileName.replace('\\','/');

Modified: experiments/engywuck/hist-test/src/cachewolf/CacheType.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/CacheType.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/CacheType.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,11 +1,10 @@
 /**
- * 
+ * This class contains the waypoint types. To add a new waypoint, you only need to modify this file
  */
-package CacheWolf;
+package cachewolf;
 
-import ewe.fx.Image;
-import ewe.sys.Convert;
-import ewe.sys.Vm;
+import eve.fx.Picture;
+import eve.sys.Vm;
 
 
 /**
@@ -30,36 +29,36 @@
 */
 
 public class CacheType {
-	public static Image cacheImages[] = new Image[454]; // Images are used by TableControl
-	public static int WHERIGO=200; // The cache we mapped the wherigo to
+	public static final Picture cachePictures[] = new Picture[454]; // Pictures are used by TableControl
+	public static final int WHERIGO=200; // The cache we mapped the wherigo to
 	static {
-		cacheImages[0] = new Image(&quot;0.png&quot;);
-		//cacheImages[1] = new Image();
-		cacheImages[2] = new Image(&quot;2.png&quot;);
-		cacheImages[3] = new Image(&quot;3.png&quot;);
-		cacheImages[4] = new Image(&quot;4.png&quot;);
-		cacheImages[5] = new Image(&quot;5.png&quot;);
-		cacheImages[6] = new Image(&quot;6.png&quot;);
-		cacheImages[8] = new Image(&quot;8.png&quot;);
-		//cacheImages[9] = new Image();
-		//cacheImages[10] = new Image();
-		cacheImages[11] = new Image(&quot;11.png&quot;);
-		cacheImages[12] = new Image(&quot;12.png&quot;);
-		cacheImages[13] = new Image(&quot;13.png&quot;);
+		cachePictures[0] = new Picture(&quot;0.png&quot;);
+		//cachePictures[1] = new Picture();
+		cachePictures[2] = new Picture(&quot;2.png&quot;);
+		cachePictures[3] = new Picture(&quot;3.png&quot;);
+		cachePictures[4] = new Picture(&quot;4.png&quot;);
+		cachePictures[5] = new Picture(&quot;5.png&quot;);
+		cachePictures[6] = new Picture(&quot;6.png&quot;);
+		cachePictures[8] = new Picture(&quot;8.png&quot;);
+		//cachePictures[9] = new Picture();
+		//cachePictures[10] = new Picture();
+		cachePictures[11] = new Picture(&quot;11.png&quot;);
+		cachePictures[12] = new Picture(&quot;12.png&quot;);
+		cachePictures[13] = new Picture(&quot;13.png&quot;);
 		//additional waypoints, begin with 50
-		cacheImages[50] = new Image(&quot;pkg.png&quot;);
-		cacheImages[51] = new Image(&quot;stage.png&quot;);
-		cacheImages[52] = new Image(&quot;puzzle.png&quot;);
-		cacheImages[53] = new Image(&quot;flag.png&quot;);
-		cacheImages[54] = new Image(&quot;trailhead.png&quot;);
-		cacheImages[55] = new Image(&quot;waypoint.png&quot;);
+		cachePictures[50] = new Picture(&quot;pkg.png&quot;);
+		cachePictures[51] = new Picture(&quot;stage.png&quot;);
+		cachePictures[52] = new Picture(&quot;puzzle.png&quot;);
+		cachePictures[53] = new Picture(&quot;flag.png&quot;);
+		cachePictures[54] = new Picture(&quot;trailhead.png&quot;);
+		cachePictures[55] = new Picture(&quot;waypoint.png&quot;);
 
-		cacheImages[108] = new Image(&quot;108.png&quot;);
-		cacheImages[109] = new Image(&quot;109.png&quot;);
-		cacheImages[110] = new Image(&quot;110.png&quot;);
-		cacheImages[137] = new Image(&quot;137.png&quot;);
-		cacheImages[WHERIGO] = new Image(&quot;1858.png&quot;);  // Fudge as whereigo is really 1858
-		cacheImages[453] = new Image(&quot;453.png&quot;);
+		cachePictures[108] = new Picture(&quot;108.png&quot;);
+		cachePictures[109] = new Picture(&quot;109.png&quot;);
+		cachePictures[110] = new Picture(&quot;110.png&quot;);
+		cachePictures[137] = new Picture(&quot;137.png&quot;);
+		cachePictures[WHERIGO] = new Picture(&quot;1858.png&quot;);  // Fudge as whereigo is really 1858
+		cachePictures[453] = new Picture(&quot;453.png&quot;);
 	}
 
 	//Types from gc.com
@@ -148,43 +147,63 @@
 	static protected final String CW_PIC_TRAILHEAD = &quot;trailhead.png&quot;;
 	static protected final String CW_PIC_REFERENCE = &quot;waypoint.png&quot;;
 	
-	//fields
-	int type = 0;
+
 	
 	// array with names and types for exporters
 	public final static int WPT_TEXT = 0;
 	public final static int WPT_NUM = 1;
 
-	public static String[][] wayType = {{&quot;Custom&quot;,&quot;0&quot;},{&quot;Traditional&quot;,&quot;2&quot;},
-			{&quot;Multi&quot;,&quot;3&quot;}, {&quot;Virtual&quot;,&quot;4&quot;},
-			{&quot;Letterbox&quot;,&quot;5&quot;},{&quot;Event&quot;,&quot;6&quot;},
-			{&quot;Mega Event&quot;,&quot;453&quot;}, {&quot;Mystery&quot;,&quot;8&quot;},
-			{&quot;Webcam&quot;,&quot;11&quot;},{&quot;Locationless&quot;,&quot;12&quot;},
-			{&quot;CITO&quot;,&quot;13&quot;},{&quot;Earthcache&quot;,&quot;137&quot;},
-			{&quot;Parking&quot;,&quot;50&quot;},{&quot;Stage&quot;,&quot;51&quot;},
-			{&quot;Question&quot;,&quot;52&quot;},{&quot;Final&quot;,&quot;53&quot;},
-			{&quot;Trailhead&quot;,&quot;54&quot;},{&quot;Reference&quot;,&quot;55&quot;},{&quot;WhereIGo&quot;,&quot;1858&quot;}};
+	public static final String[] wayType = {&quot;Custom&quot;,&quot;Traditional&quot;,
+			&quot;Multi&quot;,&quot;Virtual&quot;,
+			&quot;Letterbox&quot;,&quot;Event&quot;,
+			&quot;Mega Event&quot;,&quot;Mystery&quot;,
+			&quot;Webcam&quot;,&quot;Locationless&quot;,
+			&quot;CITO&quot;,&quot;Earthcache&quot;,&quot;WhereIGo&quot;,
+			&quot;Addi: Parking&quot;,&quot;Addi: Stage&quot;,
+			&quot;Addi: Question&quot;,&quot;Addi: Final&quot;,
+			&quot;Addi: Trailhead&quot;,&quot;Addi: Reference&quot;};
+	public static final int [] wayTypeNo={0,2,3,4,5,6,453,8,11,12,13,137,1858,50,51,52,53,54,55};
+	
+	public static final String[] wayTypeList() {
+		String [] list=new String[wayType.length];
+		for (int j = 0; j &lt; wayType.length; j++) {
+			list[j]=wayType[j];
+		}
+		return list;
+	}
+	
+	/**
+	 * For a given waypoint type, return the position in waytype
+	 * @param waypointType The waypoint type (e.g. &quot;12&quot;)
+	 * @return
+	 */
+	public static int getWayTypePos(int waypointType) {
+		for (int j = 0; j &lt; wayType.length; j++) {
+			if (waypointType==wayTypeNo[j]) return j;
+		}
+		return -1;
+	}
 
-	public static String transType(String geoNum){
-		String geo = new String(&quot;Unknown&quot;);
-		if(geoNum.equals(&quot;2&quot;)) geo = &quot;Traditional Cache&quot;;
-		if(geoNum.equals(&quot;3&quot;)) geo = &quot;Multi-cache&quot;;
-		if(geoNum.equals(&quot;4&quot;)) geo = &quot;Virtual Cache&quot;;
-		if(geoNum.equals(&quot;5&quot;)) geo = &quot;Letterbox Hybrid&quot;;
-		if(geoNum.equals(&quot;6&quot;)) geo = &quot;Event Cache&quot;;
-		if(geoNum.equals(&quot;11&quot;)) geo = &quot;Webcam Cache&quot;;
-		if(geoNum.equals(&quot;8&quot;)) geo = &quot;Unknown Cache&quot;;
-		if(geoNum.equals(&quot;12&quot;)) geo = &quot;Locationless Cache&quot;;
-		if(geoNum.equals(&quot;13&quot;)) geo = &quot;Cache In Trash Out Event&quot;;
-		if(geoNum.equals(&quot;137&quot;)) geo = &quot;Earthcache&quot;;
-		if(geoNum.equals(&quot;453&quot;)) geo = &quot;Mega Event Cache&quot;;
-		if(geoNum.equals(&quot;1858&quot;)) geo = &quot;WhereIGo Cache&quot;;
-		if(geoNum.equals(&quot;50&quot;)) geo = &quot;Parking Area&quot;;
-		if(geoNum.equals(&quot;51&quot;)) geo = &quot;Stages of a Multicache&quot;;
-		if(geoNum.equals(&quot;52&quot;)) geo = &quot;Question to Answer&quot;;
-		if(geoNum.equals(&quot;53&quot;)) geo = &quot;Final Location&quot;;
-		if(geoNum.equals(&quot;54&quot;)) geo = &quot;Trailhead&quot;;
-		if(geoNum.equals(&quot;55&quot;)) geo = &quot;Reference Point&quot;;
+	public static String transType(int geoNum){
+		String geo = &quot;Unknown&quot;;
+		if(geoNum==2) geo = &quot;Traditional Cache&quot;;
+		if(geoNum==3) geo = &quot;Multi-cache&quot;;
+		if(geoNum==4) geo = &quot;Virtual Cache&quot;;
+		if(geoNum==5) geo = &quot;Letterbox Hybrid&quot;;
+		if(geoNum==6) geo = &quot;Event Cache&quot;;
+		if(geoNum==11) geo = &quot;Webcam Cache&quot;;
+		if(geoNum==8) geo = &quot;Unknown Cache&quot;;
+		if(geoNum==12) geo = &quot;Locationless Cache&quot;;
+		if(geoNum==13) geo = &quot;Cache In Trash Out Event&quot;;
+		if(geoNum==137) geo = &quot;Earthcache&quot;;
+		if(geoNum==453) geo = &quot;Mega Event Cache&quot;;
+		if(geoNum==1858) geo = &quot;WhereIGo Cache&quot;;
+		if(geoNum==50) geo = &quot;Parking Area&quot;;
+		if(geoNum==51) geo = &quot;Stages of a Multicache&quot;;
+		if(geoNum==52) geo = &quot;Question to Answer&quot;;
+		if(geoNum==53) geo = &quot;Final Location&quot;;
+		if(geoNum==54) geo = &quot;Trailhead&quot;;
+		if(geoNum==55) geo = &quot;Reference Point&quot;;
 		return geo;
 	}
 	
@@ -220,37 +239,37 @@
 		}
 	}
 
-	public static boolean isAddiWpt(String type){
-		if (type.equals(&quot;50&quot;)) return true;
-		if (type.equals(&quot;51&quot;)) return true;
-		if (type.equals(&quot;52&quot;)) return true;
-		if (type.equals(&quot;53&quot;)) return true;
-		if (type.equals(&quot;54&quot;)) return true;
-		if (type.equals(&quot;55&quot;)) return true;
+	public static boolean isAddiWpt(int type){
+		if (type==50) return true;
+		if (type==51) return true;
+		if (type==52) return true;
+		if (type==53) return true;
+		if (type==54) return true;
+		if (type==55) return true;
 		return false;
 	}
 
-	public static String typeText2Number(String typeText){
-		if (typeText.equals(&quot;Traditional Cache&quot;) || typeText.equals(&quot;Traditional&quot;)|| typeText.equals(&quot;Classic&quot;)) return &quot;2&quot;;
-		if (typeText.equals(&quot;Multi-cache&quot;) || typeText.equals(&quot;Multi&quot;) || typeText.equals(&quot;Offset&quot;)) return &quot;3&quot;;
-		if (typeText.equals(&quot;Virtual Cache&quot;) || typeText.equals(&quot;Virtual&quot;)) return &quot;4&quot;;
-		if (typeText.equals(&quot;Letterbox Hybrid&quot;)) return &quot;5&quot;;
-		if (typeText.equals(&quot;Event Cache&quot;) || typeText.equals(&quot;Event&quot;)) return &quot;6&quot;;
-		if (typeText.equals(&quot;Unknown Cache&quot;) || typeText.equals(&quot;Other&quot;) || typeText.equals(&quot;Quiz&quot;)) return &quot;8&quot;;
-		if (typeText.equals(&quot;Webcam Cache&quot;) || typeText.equals(&quot;Webcam&quot;)) return &quot;11&quot;;
-		if (typeText.equals(&quot;Locationless (Reverse) Cache&quot;)) return &quot;12&quot;;
-		if (typeText.equals(&quot;Cache In Trash Out Event&quot;)) return &quot;13&quot;;
-		if (typeText.equals(&quot;Earthcache&quot;) || typeText.equals(&quot;Earth&quot;)) return &quot;137&quot;;
-		if (typeText.equals(&quot;Mega-Event Cache&quot;)) return &quot;453&quot;;
-		if (typeText.equals(&quot;Wherigo Cache&quot;)) return &quot;1858&quot;;
-		if (typeText.equals(&quot;Waypoint|Parking Area&quot;)) return &quot;50&quot;;
-		if (typeText.equals(&quot;Waypoint|Stages of a Multicache&quot;)) return &quot;51&quot;;
-		if (typeText.equals(&quot;Waypoint|Question to Answer&quot;)) return &quot;52&quot;;
-		if (typeText.equals(&quot;Waypoint|Final Coordinates&quot;)||typeText.equals(&quot;Waypoint|Final Location&quot;)) return &quot;53&quot;;
-		if (typeText.equals(&quot;Waypoint|Trailhead&quot;)) return &quot;54&quot;;
-		if (typeText.equals(&quot;Waypoint|Reference Point&quot;)) return &quot;55&quot;;
+	public static int typeText2Number(String typeText){
+		if (typeText.equals(&quot;Traditional Cache&quot;) || typeText.equals(&quot;Traditional&quot;)|| typeText.equals(&quot;Classic&quot;)) return 2;
+		if (typeText.equals(&quot;Multi-cache&quot;) || typeText.equals(&quot;Multi&quot;) || typeText.equals(&quot;Offset&quot;)) return 3;
+		if (typeText.equals(&quot;Virtual Cache&quot;) || typeText.equals(&quot;Virtual&quot;)) return 4;
+		if (typeText.equals(&quot;Letterbox Hybrid&quot;)) return 5;
+		if (typeText.equals(&quot;Event Cache&quot;) || typeText.equals(&quot;Event&quot;)) return 6;
+		if (typeText.equals(&quot;Unknown Cache&quot;) || typeText.equals(&quot;Other&quot;) || typeText.equals(&quot;Quiz&quot;)) return 8;
+		if (typeText.equals(&quot;Webcam Cache&quot;) || typeText.equals(&quot;Webcam&quot;)) return 11;
+		if (typeText.equals(&quot;Locationless (Reverse) Cache&quot;)) return 12;
+		if (typeText.equals(&quot;Cache In Trash Out Event&quot;)) return 13;
+		if (typeText.equals(&quot;Earthcache&quot;) || typeText.equals(&quot;Earth&quot;)) return 137;
+		if (typeText.equals(&quot;Mega-Event Cache&quot;)) return 453;
+		if (typeText.equals(&quot;Wherigo Cache&quot;)) return 1858;
+		if (typeText.equals(&quot;Waypoint|Parking Area&quot;)) return 50;
+		if (typeText.equals(&quot;Waypoint|Stages of a Multicache&quot;)) return 51;
+		if (typeText.equals(&quot;Waypoint|Question to Answer&quot;)) return 52;
+		if (typeText.equals(&quot;Waypoint|Final Coordinates&quot;)||typeText.equals(&quot;Waypoint|Final Location&quot;)) return 53;
+		if (typeText.equals(&quot;Waypoint|Trailhead&quot;)) return 54;
+		if (typeText.equals(&quot;Waypoint|Reference Point&quot;)) return 55;
 		Vm.debug(&quot;Unknown Cache Type:&quot; + typeText);
-		return &quot;0&quot;;
+		return 0;
 	}
 
 	/**
@@ -268,31 +287,29 @@
 		*	9		??		Moving		9-&gt;109 (ok)
 		*	10		??		Drive-In		10-&gt;110 (ok)
 		*/
-		public static String transOCType(String type){
-			if(type.equals(&quot;1&quot;)) return &quot;8&quot;;
-			if(type.equals(&quot;2&quot;)) return &quot;2&quot;;
-			if(type.equals(&quot;3&quot;)) return &quot;3&quot;;	
-			if(type.equals(&quot;4&quot;)) return &quot;4&quot;;
-			if(type.equals(&quot;5&quot;)) return &quot;11&quot;;
-			if(type.equals(&quot;6&quot;)) return &quot;6&quot;;
-			if(type.equals(&quot;7&quot;)) return &quot;8&quot;;
-			if(type.equals(&quot;8&quot;)|| type.equals(&quot;9&quot;) ||type.equals(&quot;10&quot;)) return &quot;8&quot;;
-	/* Not supportet at the moment
-			if(type.equals(&quot;8&quot;)) return &quot;108&quot;;
-			if(type.equals(&quot;9&quot;)) return &quot;109&quot;;
-			if(type.equals(&quot;10&quot;)) return &quot;110&quot;;
+		public static int transOCType(int type){
+			if(type==1) return 8;
+			if(type==2) return 2;
+			if(type==3) return 3;	
+			if(type==4) return 4;
+			if(type==5) return 11;
+			if(type==6) return 6;
+			if(type==7) return 8;
+			if(type==8|| type==9 ||type==10) return 8;
+	/* Not supported at the moment
+			if(type8) return &quot;108&quot;;
+			if(type9) return &quot;109&quot;;
+			if(type10) return &quot;110&quot;;
 	*/
 			//no match found? return custom type!
-			return &quot;0&quot;;
+			return 0;
 		}
 
 		
-	public static Image cache2Img(String cacheType) {
-		int ct=Convert.parseInt(cacheType);
-		if (ct==1858)
-			return cacheImages[WHERIGO];
-		else	
-			return cacheImages[ct]; // TODO save in cacheholder as int
+	public static Picture cache2Img(int cacheType) {
+		if (cacheType==1858)
+			return cachePictures[WHERIGO];
+		return cachePictures[cacheType]; // TODO save in cacheholder as int
 	}
 
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/CacheWolf.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/CacheWolf.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/CacheWolf.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,82 +1,94 @@
-package CacheWolf;
+package cachewolf; // REV 1332 / 1360
 
-import ewe.ui.*;
-import ewe.sys.*;
+import eve.ui.data.*;
+import eve.ui.*;
+import eve.sys.*;
+/**
+*	This is the application starter class.
+*	It startes the eve VM and creates the main form that displays
+*	the user interface.
+*	@param 	null	no parameters required.
+*	@return null	does not return any return codes
+*	@see			MainForm
+*	@author	 Marc Schnitzler
+*	@version version of this class, Date: date of release of the version of the class
+*/
 
+
 public class CacheWolf extends Editor{
-	
-	
-	public static void main(String vmargs[])
+
+
+	public static void main(String vmArgs[])
 	{
 		//start with parameters:
 		//args[0]: spider
 		//args[1]: distance
-		ewe.sys.Vm.startEwe(vmargs);
-/*		Gui.screenIs(Gui.PDA_SCREEN);
-		Rect s = (Rect)Window.getGuiInfo(Window.INFO_SCREEN_RECT,null,new Rect(),0);
+		Application.startApplication(vmArgs);
+		Gui.screenIs(Gui.PDA_SCREEN);
+		//eve.io.File f=new eve.io.File(&quot;c:/TEMP/&quot;);
+		//String [] files=f.listMultiple(&quot;*.*;*.zip;*.pdf&quot;,eve.io.File.LIST_DIRECTORIES_ONLY);
 		//Gui.screenIs(Gui.PDA_SCREEN)
-		if (Vm.isMobile() &amp;&amp; s.height &gt;= 400) {
-			Font defaultGuiFont = mApp.findFont(&quot;gui&quot;);
-			int sz = (int)(defaultGuiFont.getSize());
-			Font newGuiFont = new Font(defaultGuiFont.getName(), defaultGuiFont.getStyle(), sz); 
-			mApp.addFont(newGuiFont, &quot;gui&quot;); 
-			mApp.fontsChanged();
-			mApp.mainApp.font = newGuiFont;
+		/*if (Device.isMobile() &amp;&amp; MyLocale.getScreenHeight() &gt;= 400) {
+			Font defaultGuiFont = Application.findFont(&quot;gui&quot;);
+			int sz = 10; //(int)(defaultGuiFont.getSize());
+			Font newGuiFont = new Font(defaultGuiFont.getName(), defaultGuiFont.getStyle(), sz);
+			Application.addFont(newGuiFont, &quot;gui&quot;);
+			Application.mainApp.font = newGuiFont;
+			Application.fontsChanged();
+
+		}*/
+		if (Gui.screenIs(Gui.PDA_SCREEN) &amp;&amp; Device.isMobile()) {
+			//TODO Vm.setSIP(Vm.SIP_LEAVE_BUTTON);
 		}
-*/		
-		if (Gui.screenIs(Gui.PDA_SCREEN) &amp;&amp; Vm.isMobile()) {
-			Vm.setSIP(Vm.SIP_LEAVE_BUTTON);
-		}
-		
-		// get program command line parameters and switches
-		String[] args = vmargs; // Vm.getProgramArguments(); &lt;-- only works in eclipse, but mixes the letters in the ewe-vm (tested in ewe-1.49 on win xp)
-		String configfile = null;
-		boolean debug = false;
-		if(args.length &gt; 0){
-			if(args[0].equals(&quot;test&quot;)){
-				Test t=new Test(); 
-				t.testAll();
-			}
-			for (int i=0; i &lt; args.length ; i++) {
-				Vm.debug(&quot;prog: &quot; + args[i]);
-				Vm.debug(&quot;vm: &quot; + vmargs[i]);
-				if (args[i] != null &amp;&amp; args[i].length() &gt; 1 &amp;&amp;
-						(args[i].startsWith(&quot;-&quot;) || args[i].startsWith(&quot;/&quot;)) ) {
-					String c = args[i].substring(1, args[i].length());
-					if (c.equalsIgnoreCase(&quot;c&quot;)) {
-						if (i &lt; args.length -1 ) {
-							configfile = args[i+1];
-							i++;
-						} else {
-							(new MessageBox(&quot;Error&quot;, MyLocale.getMsg(7200, &quot;Usage: CacheWolf [-c &lt;path to pref.xml&gt;] [-debug]&quot;), MessageBox.OKB)).execute();
-							// return usage info
-							ewe.sys.Vm.exit(1);
-						}
-					}
-					if (c.equalsIgnoreCase(&quot;debug&quot;)) {
-						//Vm.debug(&quot;d&quot;);
-						debug = true;
-					}
 
-				}
-			}
-		}
-		
-		if (debug) {
-			Vm.debug(&quot;prg-args: &quot; + args.length);
-			Vm.debug(&quot;vm-args: &quot; + vmargs.length);
-		}
-		
-		Editor mainF = new MainForm(debug, configfile);
+        // get program command line parameters and switches
+        String[] args = vmArgs; // Vm.getProgramArguments(); &lt;-- only works in eclipse, but mixes the letters in the ewe-vm (tested in ewe-1.49 on win xp)
+        String configfile = null;
+        boolean debug = false;
+        if(args.length &gt; 0){
+                if(args[0].equals(&quot;test&quot;)){
+                        Test t=new Test();
+                        t.testAll();
+                }
+                for (int i=0; i &lt; args.length ; i++) {
+                        Vm.debug(&quot;prog: &quot; + args[i]);
+                        Vm.debug(&quot;vm: &quot; + vmArgs[i]);
+                        if (args[i] != null &amp;&amp; args[i].length() &gt; 1 &amp;&amp;
+                                        (args[i].startsWith(&quot;-&quot;) || args[i].startsWith(&quot;/&quot;)) ) {
+                                String c = args[i].substring(1, args[i].length());
+                                if (c.equalsIgnoreCase(&quot;c&quot;)) {
+                                        if (i &lt; args.length -1 ) {
+                                                configfile = args[i+1];
+                                                i++;
+                                        } else {
+                                                (new MessageBox(&quot;Error&quot;, MyLocale.getMsg(7200, &quot;Usage: CacheWolf [-c &lt;path to pref.xml&gt;] [-debug]&quot;), MessageBox.OKB)).execute();
+                                                // return usage info
+                                                eve.sys.Vm.exit(1);
+                                        }
+                                }
+                                if (c.equalsIgnoreCase(&quot;debug&quot;)) {
+                                        //Vm.debug(&quot;d&quot;);
+                                        debug = true;
+                                }
+
+                        }
+                }
+        }
+        if (debug) {
+            Vm.debug(&quot;prg-args: &quot; + args.length);
+            Vm.debug(&quot;vm-args: &quot; + vmArgs.length);
+        }
+
+		MainForm mainF = new MainForm(debug,configfile);
 		Device.preventIdleState(true);
 		mainF.execute();
 		Device.preventIdleState(false);
-		ewe.sys.Vm.exit(0);
+		Application.exit(0);
 	}
-	
+
 }
 
 // for javadoc see: <A HREF="http://java.sun.com/j2se/javadoc/writingdoccomments/index.html#exampleresult">http://java.sun.com/j2se/javadoc/writingdoccomments/index.html#exampleresult</A>
 // or the local files &quot;JavaDoc&quot; directory
 // Javadoc Main Page: <A HREF="http://java.sun.com/j2se/javadoc/index.jsp">http://java.sun.com/j2se/javadoc/index.jsp</A>
-// javadoc -classpath ewe.jar -d &quot;cachewolf doc&quot; cachewolf/*.java
+// javadoc -classpath eve.jar -d &quot;cachewolf doc&quot; cachewolf/*.java

Modified: experiments/engywuck/hist-test/src/cachewolf/CalcPanel.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/CalcPanel.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/CalcPanel.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,11 +1,16 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.ui.*;
-import ewe.ui.formatted.TextDisplay;
-import ewe.util.Vector;
-import ewe.fx.Dimension;
-import ewe.fx.FontMetrics;
+import eve.ui.*;
+import eve.ui.formatted.TextDisplay;
 
+import cachewolf.utils.Common;
+
+
+import eve.fx.Dimension;
+import eve.fx.FontMetrics;
+import eve.sys.Event;
+import eve.ui.event.ControlEvent;
+
 /**
 *	Class to create the panel to do calculation with waypoints&lt;br&gt;
 *	Also allows for creation of a custom waypoint.&lt;br&gt;
@@ -18,12 +23,12 @@
 class BearingDistance {
 	public double degrees;
 	public double distance;
-	
+
 	public BearingDistance(){
 		this.degrees = 0;
 		this.distance = 0;
 	}
-	
+
 	public BearingDistance(double degrees, double distance) {
 		this.degrees = degrees;
 		this.distance = distance;
@@ -32,56 +37,48 @@
 
 public class CalcPanel extends CellPanel {
 
-	mCheckBox chkDMM, chkDMS, chkDD, chkUTM, chkGK;
+	CheckBox chkDMM, chkDMS, chkDD, chkUTM, chkGK;
 	CheckBoxGroup chkFormat = new CheckBoxGroup();
-	mChoice chcDistUnit;
-	mInput inpBearing, inpDistance, inpText;
+	Choice chcDistUnit;
+	Input inpBearing, inpDistance;
 	TextDisplay txtOutput;
-	mButton btnCalc, btnClear, btnSave, btnGoto, btnParse;
+	Button btnCalc, btnClear, btnSave, btnGoto;
 	BearingDistance bd = new BearingDistance();
 	CWPoint coordInp = new CWPoint();
 	CWPoint coordOut = new CWPoint();
 	// Needed for creation of new waypoint
-	Vector cacheDB;
 	MainTab mainT;
-	Preferences pref;
-	Profile profile;
 	// different panels to avoid spanning
 	CellPanel TopP = new CellPanel();
 	CellPanel BottomP = new CellPanel();
-	
 	String lastWaypoint = &quot;&quot;;
-	
+
 	int currFormat;
-	mButton btnChangeLatLon;
-	
+	Button btnChangeLatLon;
+
 	public CalcPanel()	{
-		pref = Global.getPref();
-		profile=Global.getProfile();
 		mainT = Global.mainTab;
-		cacheDB = profile.cacheDB;
-		
-		
-		TopP.addNext(chkDD =new mCheckBox(&quot;d.d&#176;&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		TopP.addNext(chkDMM =new mCheckBox(&quot;d&#176;m.m\'&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		TopP.addNext(chkDMS =new mCheckBox(&quot;d&#176;m\'s\&quot;&quot;),CellConstants.DONTSTRETCH,CellConstants.WEST);
-		TopP.addNext(chkUTM =new mCheckBox(&quot;UTM&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		TopP.addLast(chkGK =new mCheckBox(&quot;GK&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
 
+		TopP.addNext(chkDD =new CheckBox(&quot;d.d&#176;&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addNext(chkDMM =new CheckBox(&quot;d&#176;m.m\'&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addNext(chkDMS =new CheckBox(&quot;d&#176;m\'s\&quot;&quot;),CellConstants.DONTSTRETCH,CellConstants.WEST);
+		TopP.addNext(chkUTM =new CheckBox(&quot;UTM&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addLast(chkGK =new CheckBox(&quot;GK&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
+
 		chkDD.setGroup(chkFormat);
 		chkDMM.setGroup(chkFormat);
 		chkDMS.setGroup(chkFormat);
 		chkUTM.setGroup(chkFormat);
 		chkGK.setGroup(chkFormat);
 		chkFormat.setInt(CWPoint.DMM);
-		btnChangeLatLon=new mButton();
+		btnChangeLatLon=new Button();
 		TopP.addLast(btnChangeLatLon,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		//inpBearing and direction, unit for inpDistance
-		BottomP.addNext(new mLabel(MyLocale.getMsg(1403,&quot;Bearing&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addLast(new mLabel(MyLocale.getMsg(1404,&quot;Distance&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addNext(inpBearing = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		BottomP.addNext(new Label(MyLocale.getMsg(1403,&quot;Bearing&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		BottomP.addLast(new Label(MyLocale.getMsg(1404,&quot;Distance&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		BottomP.addNext(inpBearing = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		inpBearing.setText(&quot;0&quot;);
-		BottomP.addNext(inpDistance = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		BottomP.addNext(inpDistance = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		inpDistance.setText(&quot;0&quot;);
 		// Check for narrow screen and reduce width of fields to avoid horizontal scroll panel
 		if (MyLocale.getScreenWidth()&lt;=240) {
@@ -89,31 +86,31 @@
 			inpBearing.setPreferredSize(fm.getTextWidth(&quot;99999999&quot;),fm.getHeight()*4/3);
 			inpDistance.setPreferredSize(fm.getTextWidth(&quot;99999999&quot;),fm.getHeight()*4/3);
 		}
-		BottomP.addLast(chcDistUnit = new mChoice(new String[]{&quot;m&quot;, &quot;km&quot;, MyLocale.getMsg(1407,&quot;steps&quot;), MyLocale.getMsg(1408,&quot;feet&quot;), MyLocale.getMsg(1409,&quot;yards&quot;), MyLocale.getMsg(1410,&quot;miles&quot;)},0),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST)).setTag(CellConstants.INSETS,new ewe.fx.Insets(0,2,0,0));
+		BottomP.addLast(chcDistUnit = new Choice(new String[]{&quot;m&quot;, &quot;km&quot;,MyLocale.getMsg(1407,&quot;steps&quot;), MyLocale.getMsg(1408,&quot;feet&quot;), MyLocale.getMsg(1409,&quot;yards&quot;), MyLocale.getMsg(1410,&quot;miles&quot;)},0),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST)).setTag(CellConstants.TAG_INSETS,new eve.fx.Insets(0,2,0,0));
 		chcDistUnit.setInt(0);
-		
+
 		// Buttons for calc and save
-		BottomP.addNext(btnCalc = new mButton(&quot;Calc&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addNext(btnClear = new mButton(&quot;Clear&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addNext(btnGoto = new mButton(&quot;Goto&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addLast(btnSave = new mButton(MyLocale.getMsg(311,&quot;Create Waypoint&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		
-		// Output 
+		BottomP.addNext(btnCalc = new Button(&quot;Calc&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		BottomP.addNext(btnClear = new Button(&quot;Clear&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		BottomP.addNext(btnGoto = new Button(&quot;Goto&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		BottomP.addLast(btnSave = new Button(MyLocale.getMsg(311,&quot;Create Waypoint&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+
+		// Output
 		txtOutput = new TextDisplay(3,1); // Need to limit size for small screens
 		ScrollBarPanel sbp = new MyScrollBarPanel(txtOutput);
-		BottomP.addLast(sbp.setTag(CellConstants.SPAN, new Dimension(4,1)),CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
-		
+		BottomP.addLast(sbp.setTag(Control.TAG_SPAN, new Dimension(4,1)),CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
+
 		//add Panels
-		this.addLast(TopP,CellConstants.HSTRETCH, CellConstants.WEST);//.setTag(SPAN,new Dimension(4,1));
-		this.addLast(BottomP,CellConstants.VSTRETCH, CellConstants.VFILL|CellConstants.WEST); //.setTag(SPAN,new Dimension(4,1));
-		
+		this.addLast(TopP,CellConstants.HSTRETCH, CellConstants.WEST);//.setTag(TAG_SPAN,new Dimension(4,1));
+		this.addLast(BottomP,CellConstants.VSTRETCH, CellConstants.VFILL|CellConstants.WEST); //.setTag(TAG_SPAN,new Dimension(4,1));
+
 	}
-	
+
 	public void readFields(CWPoint coords, BearingDistance degKm, int format){
 		coords.set(btnChangeLatLon.getText());
 		currFormat = chkFormat.getSelectedIndex();
 		degKm.degrees = Common.parseDouble(inpBearing.getText());
-		
+
 		double rawDistance = Common.parseDouble(inpDistance.getText());
 		switch ( chcDistUnit.getInt() ) {
 		case 0:
@@ -147,24 +144,24 @@
 		}
 		return;
 	}
-	
+
 	// ch must be not null
 	public void setFields(CacheHolder ch){
-		if ( !ch.wayPoint.equalsIgnoreCase(lastWaypoint) ) {
-			lastWaypoint = ch.wayPoint;
-			if (ch.pos.isValid()) {
-				inpBearing.setText(&quot;0&quot;);
-				inpDistance.setText(&quot;0&quot;);
+        if ( !ch.wayPoint.equalsIgnoreCase(lastWaypoint) ) {
+            lastWaypoint = ch.wayPoint;
+            if (ch.pos.isValid()) {
+                    inpBearing.setText(&quot;0&quot;);
+                    inpDistance.setText(&quot;0&quot;);
 
-				currFormat = CWPoint.DMM;
-				if (ch.LatLon.length()== 0) coordInp.set(0,0);
-				else coordInp.set(ch.LatLon, CWPoint.CW);
-				setFields(coordInp, CWPoint.DMM);				
-			}
-		}
+                    currFormat = CWPoint.DMM;
+                    if (ch.latLon.length()== 0) coordInp.set(0,0);
+                    else coordInp.set(ch.latLon, CWPoint.CW);
+                    setFields(coordInp, CWPoint.DMM);
+            }
+    }
 	}
-	
-	
+
+
 	public void setFields(CWPoint coords, int format) {
 		if (format == CWPoint.CW) format = CWPoint.DMM;
 		btnChangeLatLon.setText(coords.toString(format));
@@ -194,12 +191,12 @@
 				CacheHolder ch = new CacheHolder();
 				readFields(coordInp, bd, currFormat);
 				coordOut = coordInp.project(bd.degrees, bd.distance);
-				ch.LatLon = coordOut.toString();
+				ch.latLon = coordOut.toString();
 				ch.pos.set(coordOut);
-				ch.type = &quot;51&quot;; // see CacheType.GC_AW_STAGE_OF_MULTI // TODO unfertig
+				ch.type = 51; // see CacheType.GC_AW_STAGE_OF_MULTI // TODO unfertig
 				mainT.newWaypoint(ch);
 			}
-			
+
 			if (ev.target == btnGoto){
 				readFields(coordInp, bd, currFormat);
 				coordOut = coordInp.project(bd.degrees, bd.distance);
@@ -209,12 +206,12 @@
 				CoordsScreen cs = new CoordsScreen();
 				readFields(coordInp, bd, currFormat);
 				cs.setFields(coordInp,currFormat);
-				if (cs.execute()== FormBase.IDOK){
+				if (cs.execute()== CoordsScreen.IDOK){
 					btnChangeLatLon.setText(cs.getCoords().toString(currFormat));
 					coordInp.set(cs.getCoords());
 				}
 			}
-			
+
 		}
 		super.onEvent(ev);
 	}

Modified: experiments/engywuck/hist-test/src/cachewolf/CenterScreen.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/CenterScreen.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/CenterScreen.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,43 +1,45 @@
-package CacheWolf;
+package cachewolf;
 
 
-import ewe.ui.*;
+import eve.ui.*;
+import eve.sys.*;
+import eve.ui.event.ControlEvent;
 
 /**
 *	This form displays profile specific data.
 *	It allows the copying of the current centre to the profile centre
 */
-public class ProfileDataForm extends Form {
+public class CenterScreen extends Form {
 
-	private mButton btnOK, btnCurrentCentre, btnProfileCentre, btnCur2Prof, btnProf2Cur;
+	private Button btnOK, btnCurrentCentre, btnProfileCentre, btnCur2Prof, btnProf2Cur;
 	Preferences pref;
 	Profile profile;
 	CellPanel content = new CellPanel();
 
 	/**
 	*/
-	public ProfileDataForm(Preferences p, Profile prof){
+	public CenterScreen(Preferences p, Profile prof){
 		super();
 		pref=p;
 		profile=prof;
 		
     	resizable =  false;
 		content.setText(MyLocale.getMsg(1115,&quot;Centre&quot;));
-		content.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_RECT;
-	    //defaultTags.set(this.INSETS,new Insets(2,2,2,2));		
+		content.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_RECT;
+	    //defaultTags.set(this.TAG_INSETS,new Insets(2,2,2,2));		
 		title = MyLocale.getMsg(1118,&quot;Profile&quot;)+&quot;: &quot;+profile.name;
-		content.addNext(new mLabel(MyLocale.getMsg(1116,&quot;Current&quot;)));
-		content.addLast(btnCurrentCentre=new mButton(pref.curCentrePt.toString()),HSTRETCH,HFILL|LEFT);
-		content.addNext(new mLabel(&quot;      &quot;),HSTRETCH,HFILL);
-		content.addNext(btnCur2Prof=new mButton(&quot;   v   &quot;),DONTSTRETCH,DONTFILL|LEFT);
-		content.addNext(new mLabel(MyLocale.getMsg(1117,&quot;copy&quot;)));
-		content.addLast(btnProf2Cur=new mButton(&quot;   ^   &quot;),DONTSTRETCH,DONTFILL|RIGHT);
-		content.addNext(new mLabel(MyLocale.getMsg(1118,&quot;Profile&quot;)));
-		content.addLast(btnProfileCentre=new mButton(profile.centre.toString()),HSTRETCH,HFILL|LEFT);
+		content.addNext(new Label(MyLocale.getMsg(1116,&quot;Current&quot;)));
+		content.addLast(btnCurrentCentre=new Button(pref.curCentrePt.toString()),HSTRETCH,HFILL|LEFT);
+		content.addNext(new Label(&quot;      &quot;),HSTRETCH,HFILL);
+		content.addNext(btnCur2Prof=new Button(&quot;   v   &quot;),DONTSTRETCH,DONTFILL|LEFT);
+		content.addNext(new Label(MyLocale.getMsg(1117,&quot;copy&quot;)));
+		content.addLast(btnProf2Cur=new Button(&quot;   ^   &quot;),DONTSTRETCH,DONTFILL|RIGHT);
+		content.addNext(new Label(MyLocale.getMsg(1118,&quot;Profile&quot;)));
+		content.addLast(btnProfileCentre=new Button(profile.centre.toString()),HSTRETCH,HFILL|LEFT);
 		addLast(content,HSTRETCH,HFILL);
-		addLast(new mLabel(&quot;&quot;),VSTRETCH,FILL);
-		//addNext(btnCancel = new mButton(MyLocale.getMsg(1604,&quot;Cancel&quot;)),DONTSTRETCH,DONTFILL|LEFT);
-		addLast(btnOK = new mButton(&quot;OK&quot;),DONTSTRETCH,HFILL|RIGHT);
+		addLast(new Label(&quot;&quot;),VSTRETCH,FILL);
+		//addNext(btnCancel = new Button(MyLocale.getMsg(1604,&quot;Cancel&quot;)),DONTSTRETCH,DONTFILL|LEFT);
+		addLast(btnOK = new Button(&quot;OK&quot;),DONTSTRETCH,HFILL|RIGHT);
 	}
 	
 	/**
@@ -56,7 +58,7 @@
 			if (ev.target == btnCurrentCentre){
 				CoordsScreen cs = new CoordsScreen();
 				cs.setFields(pref.curCentrePt, CWPoint.CW);
-				if (cs.execute()== FormBase.IDOK){
+				if (cs.execute()== CoordsScreen.IDOK){
 					pref.curCentrePt.set(cs.getCoords());
 					btnCurrentCentre.setText(pref.curCentrePt.toString());
 					Global.getProfile().updateBearingDistance();
@@ -65,7 +67,7 @@
 			if (ev.target == btnProfileCentre){
 				CoordsScreen cs = new CoordsScreen();
 				cs.setFields(profile.centre, CWPoint.CW);
-				if (cs.execute()== FormBase.IDOK){
+				if (cs.execute()== CoordsScreen.IDOK){
 					profile.centre.set(cs.getCoords());
 					btnProfileCentre.setText(profile.centre.toString());
 					profile.hasUnsavedChanges=true;

Modified: experiments/engywuck/hist-test/src/cachewolf/CoordsScreen.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/CoordsScreen.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/CoordsScreen.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,117 +1,113 @@
-package CacheWolf;
+package cachewolf;
 
-import CacheWolf.navi.Navigate;
-import ewe.ui.*;
-import ewe.fx.Dimension;
-import ewe.sys.*;
+import cachewolf.imp.SpiderGC;
+import cachewolf.navi.Navigate;
+import cachewolf.utils.STRreplace;
+import eve.ui.*;
+import eve.fx.Dimension;
+import eve.sys.*;
+import eve.ui.event.*;
+import eve.fx.gui.IKeys;
 
 /**
 *	Class for entering coordinates&lt;br&gt;
-*	Class IDs 1400 and 600 (same as calc panel and preferences screen)&lt;br&gt;
 */
 
 
 public class CoordsScreen extends Form {
 
-	mCheckBox chkDMM, chkDMS, chkDD, chkUTM, chkGK;
+	CheckBox chkDMM, chkDMS, chkDD, chkUTM, chkGK;
 	CheckBoxGroup chkFormat = new CheckBoxGroup();
-	mChoice chcNS, chcEW;
-	mInput inpNSDeg, inpNSm, inpNSs, inpEWDeg, inpEWm, inpEWs;
-	mInput inpUTMZone, inpUTMNorthing, inpUTMEasting;
-	mInput inpText;
-	mButton btnCancel, btnApply, btnCopy, btnPaste, btnParse, btnGps, btnClear;
+	Choice chcNS, chcEW;
+	Input inpNSDeg, inpNSm, inpNSs, inpEWDeg, inpEWm, inpEWs;
+	Input inpUTMZone, inpUTMNorthing, inpUTMEasting;
+	Input inpText;
+	Button btnCancel, btnApply, btnCopy, btnPaste, btnParse, btnGps, btnClear;
 	CWPoint coordInp = new CWPoint();
 	CellPanel topLinePanel = new CellPanel();
 	CellPanel mainPanel = new CellPanel();
 	int exitKeys[]={75009};
 	int currFormat;
-	
+
 	private boolean allowInvalid = false;
-	
-	public CoordsScreen(boolean allowInvalidCoords)
-	{
+
+	public CoordsScreen(boolean allowInvalidCoords){
 		allowInvalid = allowInvalidCoords;
-		
-		InitCoordsScreen();		
+		InitCoordsScreen();
 	}
-	
-	public CoordsScreen()
-	{
-		InitCoordsScreen();		
+
+	public CoordsScreen() {
+		InitCoordsScreen();
 	}
-	
-	private void InitCoordsScreen()
-	{
-		this.setTitle(&quot;&quot;);
+
+	private void InitCoordsScreen() {
+		this.title=&quot;&quot;;
 		//Radiobuttons for format
-		topLinePanel.addNext(chkDD =new mCheckBox(&quot;d.d&#176;&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		topLinePanel.addNext(chkDMM =new mCheckBox(&quot;d&#176;m.m\'&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		topLinePanel.addNext(chkDMS =new mCheckBox(&quot;d&#176;m\'s\&quot;&quot;),CellConstants.DONTSTRETCH,CellConstants.WEST);
-		topLinePanel.addNext(chkUTM =new mCheckBox(&quot;UTM&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		topLinePanel.addLast(chkGK =new mCheckBox(&quot;GK&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		topLinePanel.addNext(chkDD =new CheckBox(&quot;d.d&#176;&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		topLinePanel.addNext(chkDMM =new CheckBox(&quot;d&#176;m.m\'&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		topLinePanel.addNext(chkDMS =new CheckBox(&quot;d&#176;m\'s\&quot;&quot;),CellConstants.DONTSTRETCH,CellConstants.WEST);
+		topLinePanel.addNext(chkUTM =new CheckBox(&quot;UTM&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		topLinePanel.addLast(chkGK =new CheckBox(&quot;GK&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
 
 		chkDD.setGroup(chkFormat); chkDD.exitKeys=exitKeys;
 		chkDMM.setGroup(chkFormat);chkDMM.exitKeys=exitKeys;
 		chkDMS.setGroup(chkFormat);chkDMS.exitKeys=exitKeys;
 		chkUTM.setGroup(chkFormat);chkUTM.exitKeys=exitKeys;
 		chkGK.setGroup(chkFormat);chkGK.exitKeys=exitKeys;
-		
+
 		this.addLast(topLinePanel,CellConstants.DONTSTRETCH, CellConstants.WEST);
 
 		// Input for degrees
-		mainPanel.addNext(chcNS = new mChoice(new String[]{&quot;N&quot;, &quot;S&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(chcNS = new Choice(new String[]{&quot;N&quot;, &quot;S&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		chcNS.setInt(0);
-		mainPanel.addNext(inpNSDeg = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addNext(inpNSm = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addLast(inpNSs = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		
-		mainPanel.addNext(chcEW = new mChoice(new String[]{&quot;E&quot;, &quot;W&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(inpNSDeg = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(inpNSm = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addLast(inpNSs = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+
+		mainPanel.addNext(chcEW = new Choice(new String[]{&quot;E&quot;, &quot;W&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		chcEW.setInt(0);
-		mainPanel.addNext(inpEWDeg = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addNext(inpEWm = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addLast(inpEWs = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(inpEWDeg = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(inpEWm = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addLast(inpEWs = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 
 		// Input for UTM
-		if (allowInvalid){
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1400,&quot;Zone&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1402,&quot;Easting&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1401,&quot;Northing&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addLast(btnClear = new mButton(MyLocale.getMsg(1413,&quot;Clear&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
+		mainPanel.addNext(new Label(MyLocale.getMsg(1400,&quot;Zone&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(new Label(MyLocale.getMsg(1402,&quot;Easting&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		if (allowInvalid) {
+			mainPanel.addNext(new Label(MyLocale.getMsg(1401,&quot;Northing&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			mainPanel.addLast(btnClear = new Button(MyLocale.getMsg(1413,&quot;Clear&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
 		} else {
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1400,&quot;Zone&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1402,&quot;Easting&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addLast(new mLabel(MyLocale.getMsg(1401,&quot;Northing&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
+			mainPanel.addLast(new Label(MyLocale.getMsg(1401,&quot;Northing&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		}
-		
-		mainPanel.addNext(inpUTMZone = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addNext(inpUTMEasting = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addNext(inpUTMNorthing = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addLast(btnGps = new mButton(&quot;GPS&quot;),CellConstants.HSTRETCH, (CellConstants.HFILL));
-		
-		mainPanel.addLast(new mLabel(MyLocale.getMsg(1405,&quot;To load coordinates from GC, enter GCxxxxx below&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL)).setTag(SPAN,new Dimension(4,1));
+		mainPanel.addNext(inpUTMZone = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(inpUTMEasting = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(inpUTMNorthing = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addLast(btnGps = new Button(&quot;GPS&quot;),CellConstants.HSTRETCH, (CellConstants.HFILL));
+
+		mainPanel.addLast(new Label(MyLocale.getMsg(1405,&quot;To load coordinates from GC, enter GCxxxxx below&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL)).setTag(TAG_SPAN,new Dimension(4,1));
 			// Input for free Text
-		mainPanel.addNext(inpText = new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		mainPanel.addNext(inpText = new Input(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		inpText.toolTip=MyLocale.getMsg(1406,&quot;Enter coordinates in any format or GCxxxxx&quot;);
-		inpText.setTag(SPAN,new Dimension(3,1));
-		mainPanel.addLast(btnParse = new mButton(MyLocale.getMsg(619,&quot;Parse&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
-		
+		inpText.setTag(TAG_SPAN,new Dimension(3,1));
+		mainPanel.addLast(btnParse = new Button(MyLocale.getMsg(619,&quot;Parse&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
+
 		// Buttons for cancel and apply, copy and paste
-		btnCancel = new mButton(MyLocale.getMsg(614,&quot;Cancel&quot;));
+		btnCancel = new Button(MyLocale.getMsg(614,&quot;Cancel&quot;));
 		btnCancel.setHotKey(0, IKeys.ESCAPE);
 		mainPanel.addNext(btnCancel,CellConstants.HSTRETCH, (CellConstants.HFILL));
-		//btnCancel.setTag(SPAN,new Dimension(4,1));
-		mainPanel.addNext(btnApply = new mButton(MyLocale.getMsg(615,&quot;Apply&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
-		//btnApply.setTag(SPAN,new Dimension(4,1));
-		mainPanel.addNext(btnPaste = new mButton(MyLocale.getMsg(617,&quot;Paste&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
-		//btnParse.setTag(SPAN,new Dimension(4,1));
-		mainPanel.addLast(btnCopy = new mButton(MyLocale.getMsg(618,&quot;Copy&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
-		//btnCopy.setTag(SPAN,new Dimension(4,1));
+		//btnCancel.setTag(TAG_SPAN,new Dimension(4,1));
+		mainPanel.addNext(btnApply = new Button(MyLocale.getMsg(615,&quot;Apply&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
+		//btnApply.setTag(TAG_SPAN,new Dimension(4,1));
+		mainPanel.addNext(btnPaste = new Button(MyLocale.getMsg(617,&quot;Paste&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
+		//btnParse.setTag(TAG_SPAN,new Dimension(4,1));
+		mainPanel.addLast(btnCopy = new Button(MyLocale.getMsg(618,&quot;Copy&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
+		//btnCopy.setTag(TAG_SPAN,new Dimension(4,1));
 		chcNS.exitKeys=exitKeys; chcEW.exitKeys=exitKeys;
 		//add Panels
 		this.addLast(mainPanel,CellConstants.DONTSTRETCH, CellConstants.WEST);
-		chcNS.takeFocus(ControlConstants.ByKeyboard);
+		chcNS.takeFocus(Control.ByKeyboard);
 	}
-	
+
 	public void activateFields(int format){
 		inpEWDeg.wantReturn=false; inpEWm.wantReturn=false; inpEWs.wantReturn=false; inpUTMNorthing.wantReturn=false;
 		switch (format){
@@ -122,32 +118,32 @@
 				disable(inpUTMZone); disable(inpUTMNorthing); disable(inpUTMEasting);
 				break;
 			case CWPoint.CW:
-			case CWPoint.DMM: 	
+			case CWPoint.DMM:
 				enable(chcNS); enable(inpNSDeg); enable(inpNSm); disable(inpNSs);
 				enable(chcEW); enable(inpEWDeg); enable(inpEWm); disable(inpEWs);
 				inpEWm.wantReturn=true;
 				disable(inpUTMZone); disable(inpUTMNorthing); disable(inpUTMEasting);
 				break;
-			case CWPoint.DMS: 	
+			case CWPoint.DMS:
 				enable(chcNS); enable(inpNSDeg); enable(inpNSm); enable(inpNSs);
 				enable(chcEW); enable(inpEWDeg); enable(inpEWm); enable(inpEWs);
 				inpEWs.wantReturn=true;
 				disable(inpUTMZone); disable(inpUTMNorthing); disable(inpUTMEasting);
 				break;
-			case CWPoint.UTM: 	
+			case CWPoint.UTM:
 				disable(chcNS); disable(inpNSDeg); disable(inpNSm); disable(inpNSs);
 				disable(chcEW); disable(inpEWDeg); disable(inpEWm); disable(inpEWs);
 				enable(inpUTMZone); enable(inpUTMNorthing); enable(inpUTMEasting);
 				inpUTMNorthing.wantReturn=true;
 	 			break;
-			case CWPoint.GK: 	
+			case CWPoint.GK:
 				disable(chcNS); disable(inpNSDeg); disable(inpNSm); disable(inpNSs);
 				disable(chcEW); disable(inpEWDeg); disable(inpEWm); disable(inpEWs);
 				disable(inpUTMZone); enable(inpUTMNorthing); enable(inpUTMEasting);
 				inpUTMNorthing.wantReturn=true;
 	 			break;
 		}
-		
+
 		this.stretchLastColumn = true;
 		this.stretchLastRow = true;
 		this.repaintNow();
@@ -155,14 +151,14 @@
 
 	private void enable(Control c) {c.modify(ControlConstants.TakesKeyFocus,ControlConstants.Disabled); }
 	private void disable(Control c) {c.modify(ControlConstants.Disabled,ControlConstants.TakesKeyFocus); }
-	
+
 	public void readFields(CWPoint coords, int format){
 		String NS, EW;
 		if (format == CWPoint.UTM)
-			coords.set(inpUTMZone.getText(), 
+			coords.set(inpUTMZone.getText(),
 					   inpUTMNorthing.getText(), inpUTMEasting.getText());
 		else if (format == CWPoint.GK) {
-			coords.set(inpUTMEasting.getText(), inpUTMNorthing.getText());			
+			coords.set(inpUTMEasting.getText(), inpUTMNorthing.getText());
 		}
 		else {
 			NS = chcNS.getInt()== 0?&quot;N&quot;:&quot;S&quot;;
@@ -185,7 +181,7 @@
 			inpUTMZone.setText(&quot;&quot;);
 			if (coords.isValid()){
 				inpUTMNorthing.setText(coords.getGKNorthing(0));
-				inpUTMEasting.setText((coords.getGKEasting(0)));				
+				inpUTMEasting.setText((coords.getGKEasting(0)));
 			}
 			else {
 				inpUTMNorthing.setText(&quot;0&quot;);
@@ -195,11 +191,11 @@
 		else {
 			chcNS.setInt(coords.getNSLetter().equals(&quot;N&quot;)?0:1);
 			chcEW.setInt(coords.getEWLetter().equals(&quot;E&quot;)?0:1);
-			
+
 			inpNSDeg.setText(STRreplace.replace(coords.getLatDeg(format),&quot;-&quot;,&quot;&quot;));
 			inpNSm.setText(coords.getLatMin(format));
 			inpNSs.setText(coords.getLatSec(format));
-			
+
 			inpEWDeg.setText(STRreplace.replace(coords.getLonDeg(format),&quot;-&quot;,&quot;&quot;));
 			inpEWm.setText(coords.getLonMin(format));
 			inpEWs.setText(coords.getLonSec(format));
@@ -213,8 +209,8 @@
 	public CWPoint getCoords(){
 		return coordInp;
 	}
-	
 
+
 	public void onEvent(Event ev){
 
 		//Vm.debug(ev.toString());
@@ -223,15 +219,15 @@
 		// For input fields we use the wantReturn field
 		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.EXITED){
 			if (((ControlEvent)ev).target==chkDD || ((ControlEvent)ev).target==chkDMM ||
-			    ((ControlEvent)ev).target==chkDMS) Gui.takeFocus(chcNS,ControlConstants.ByKeyboard);	
-			if (((ControlEvent)ev).target==chkUTM) Gui.takeFocus(inpUTMZone,ControlConstants.ByKeyboard);
-			if (((ControlEvent)ev).target==chkGK) Gui.takeFocus(inpUTMEasting,ControlConstants.ByKeyboard);
-			if (((ControlEvent)ev).target==chcNS) Gui.takeFocus(inpNSDeg,ControlConstants.ByKeyboard);
-			if (((ControlEvent)ev).target==chcEW) Gui.takeFocus(inpEWDeg,ControlConstants.ByKeyboard);
+			    ((ControlEvent)ev).target==chkDMS) Gui.takeFocus(chcNS,Control.ByKeyboard);
+			if (((ControlEvent)ev).target==chkUTM) Gui.takeFocus(inpUTMZone,Control.ByKeyboard);
+			if (((ControlEvent)ev).target==chkGK) Gui.takeFocus(inpUTMEasting,Control.ByKeyboard);
+			if (((ControlEvent)ev).target==chcNS) Gui.takeFocus(inpNSDeg,Control.ByKeyboard);
+			if (((ControlEvent)ev).target==chcEW) Gui.takeFocus(inpEWDeg,Control.ByKeyboard);
 		}
 		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
 			if (((ControlEvent)ev).target==inpEWDeg || ((ControlEvent)ev).target==inpEWm ||
-					((ControlEvent)ev).target==inpEWs || ((ControlEvent)ev).target==inpUTMNorthing) Gui.takeFocus(btnApply,ControlConstants.ByKeyboard);	
+					((ControlEvent)ev).target==inpEWs || ((ControlEvent)ev).target==inpUTMNorthing) Gui.takeFocus(btnApply,Control.ByKeyboard);
 			if (ev.target == chkFormat){
 				readFields(coordInp, currFormat);
 				currFormat = chkFormat.getSelectedIndex();
@@ -247,22 +243,23 @@
 			if (ev.target == btnApply){
 				currFormat = chkFormat.getSelectedIndex();
 				readFields(coordInp, currFormat);
-				if (coordInp.isValid()) this.close(IDOK);
+				if (coordInp.isValid())
+					this.close(IDOK);
 				else {
 					if	( allowInvalid ) {
 						if ((new MessageBox(MyLocale.getMsg(144,&quot;Warnung&quot;),MyLocale.getMsg(1412,&quot;Coordinates invalid. Apply anyway?&quot;),FormBase.DEFOKB|FormBase.NOB)).execute() == FormBase.IDOK ) {
-							this.close(IDOK);						
+							this.close(IDOK);
 						}
 					} else {
-						(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(1411,&quot;Please enter valid coordinates&quot;), FormBase.OKB)).execute();						
+						(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(1411,&quot;Please enter valid coordinates&quot;), FormBase.OKB)).execute();
 					}
 				}
 			}
-			
+
 			if (ev.target == btnPaste){
-				inpText.setText(Vm.getClipboardText(&quot;&quot;));
+				inpText.setText(Vm.getClipboardText());
 			}
-			
+
 			if (ev.target == btnCopy){
 				currFormat = chkFormat.getSelectedIndex();
 				readFields(coordInp, currFormat);
@@ -276,11 +273,11 @@
 				if (inp.startsWith(&quot;GC&quot;)) {
 					SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile(), false);
 					coord = new CWPoint(spider.getCacheCoordinates(inp));
-				} else {	
+				} else {
 					coord = new CWPoint(inp);
 				}
 				if (coord.latDec == -91 &amp;&amp; coord.lonDec == -361){
-					MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(4111,&quot;Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM&quot;), FormBase.OKB);
+					MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(4111,&quot;Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM&quot;), MessageBox.OKB);
 					tmpMB.exec();
 				}else {
 					currFormat = chkFormat.getSelectedIndex();
@@ -289,7 +286,7 @@
 					this.repaintNow();
 				}
 			}
-			
+
 			if (ev.target == btnGps){
 				Navigate nav=Global.mainTab.nav;
 				if (nav.gpsPos.isValid()){
@@ -299,7 +296,6 @@
 					activateFields(currFormat);
 				}
 			}
-			
 			if (ev.target == btnClear){
 				CWPoint coord = new CWPoint(91,361);
 				currFormat = chkFormat.getSelectedIndex();
@@ -310,5 +306,5 @@
 		super.onEvent(ev);
 	}
 
-	
+
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/DataMover.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/DataMover.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/DataMover.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,51 +1,49 @@
-package CacheWolf;
+package cachewolf;
 
-import utils.FileBugfix;
-import ewe.filechooser.FileChooser;
-import ewe.filechooser.FileChooserBase;
-import ewe.io.*;
-import ewe.ui.*;
-import ewe.util.Vector;
-import ewe.sys.*;
+import eve.ui.filechooser.FileChooser;
+import java.io.*;
+import eve.ui.*;
+import java.util.Vector;
+import eve.sys.*;
 
 
 /**
 *	This class moves or copies the database files of selected caches from one directory to
-*   another. It provides also the possibility to delete cachefiles. 	
+*   another. It provides also the possibility to delete cachefiles.
 */
 public class DataMover {
 
-	Vector srcDB, dstDB;
+	Vector srcDB;
 	Preferences pref;
 	Profile profile;
-	
+
 	public DataMover(){
 		pref = Global.getPref();
 		profile=Global.getProfile();
 		srcDB = profile.cacheDB;
 	}
 	public void deleteCaches(){
-		
-		MessageBox mBox = new MessageBox (MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(145,&quot;Cachedata of ALL VISIBLE caches will be deleted! Continue?&quot;), FormBase.IDYES |FormBase.IDNO);
-		if (mBox.execute() != FormBase.IDOK){
+
+		MessageBox mBox = new MessageBox (MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(145,&quot;Cachedata of ALL VISIBLE caches will be deleted! Continue?&quot;), MessageBox.IDYES |MessageBox.IDNO);
+		if (mBox.execute() != MessageBox.IDOK){
 			return;
 		}
 		processCaches(new Deleter(MyLocale.getMsg(143, &quot;Delete&quot;)));
 		// write indexfiles
-		profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
+		profile.saveIndex(Profile.NO_SHOW_PROGRESS_BAR);
 	}
 
 	public void copyCaches(){
 		Profile dstProfile=new Profile();
-		
+
 		dstProfile.dataDir=selectTargetDir();
 		if (dstProfile.dataDir.equals(profile.dataDir) ||
 			dstProfile.dataDir.equals(&quot;&quot;)) return;
-		MessageBox mBox = new MessageBox (MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(146,&quot;Cachedata of ALL VISIBLE caches will be copied! Continue?&quot;), FormBase.IDYES |FormBase.IDNO);
-		if (mBox.execute() != FormBase.IDOK){
+		MessageBox mBox = new MessageBox (MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(146,&quot;Cachedata of ALL VISIBLE caches will be copied! Continue?&quot;), MessageBox.IDYES |MessageBox.IDNO);
+		if (mBox.execute() != MessageBox.IDOK){
 			return;
 		}
-		
+
 		// Read indexfile of destination, if one exists
 		File ftest = new File(dstProfile.dataDir + &quot;index.xml&quot;);
 		if(ftest.exists()){
@@ -53,40 +51,41 @@
 		}
 		processCaches(new Copier(MyLocale.getMsg(141, &quot;Copy&quot;),dstProfile));
 		// write indexfiles and keep the filter status
-		dstProfile.saveIndex(pref, Profile.NO_SHOW_PROGRESS_BAR);
+		dstProfile.saveIndex(Profile.NO_SHOW_PROGRESS_BAR);
 	}
-	
+
 	public void moveCaches() {
 		Profile dstProfile=new Profile();
+
 		// Select destination directory
 		dstProfile.dataDir=selectTargetDir();
 		if (dstProfile.dataDir.equals(profile.dataDir) ||
 			dstProfile.dataDir.equals(&quot;&quot;)) return;
-		
-		MessageBox mBox = new MessageBox (MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(147,&quot;Cachedata of ALL VISIBLE caches will be moved! Continue?&quot;), FormBase.IDYES |FormBase.IDNO);
-		if (mBox.execute() != FormBase.IDOK){
+
+		MessageBox mBox = new MessageBox (MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(147,&quot;Cachedata of ALL VISIBLE caches will be moved! Continue?&quot;), MessageBox.IDYES |MessageBox.IDNO);
+		if (mBox.execute() != MessageBox.IDOK){
 			return;
 		}
-		
+
 		// Read indexfile of destination, if one exists
 		File ftest = new File(dstProfile.dataDir + &quot;index.xml&quot;);
 		if(ftest.exists()){
-			dstProfile.readIndex();		
+			dstProfile.readIndex();
 		}
 		processCaches(new Mover(MyLocale.getMsg(142, &quot;Move&quot;),dstProfile));
 		// write indexfiles
-		dstProfile.saveIndex(pref, Profile.NO_SHOW_PROGRESS_BAR); 
-		profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
+		dstProfile.saveIndex(Profile.NO_SHOW_PROGRESS_BAR);
+		profile.saveIndex(Profile.NO_SHOW_PROGRESS_BAR);
 	}
-	
+
 	 /**
-	  * This function carries out the copy/delete/move with a progress bar. 
+	  * This function carries out the copy/delete/move with a progress bar.
 	  * The Executor class defines what operation is to be carried out.
 	  * @param exec
 	  */
 	 private void processCaches(Executor exec) {
-		// First empty the cache so that the correct cache details are on disk
-		CacheHolder.saveAllModifiedDetails(); 
+		 // First empty the cache so that the correct cache details are on disk
+		 CacheHolder.saveAllModifiedDetails();
 		int size=srcDB.size();
 		int count=0;
 		// Count the number of caches to move/delete/copy
@@ -97,7 +96,7 @@
 		Handle h = new Handle();
 		pbf.setTask(h,exec.title);
 		pbf.exec();
-		
+
 		int nProcessed=0;
 		// Now do the actual work
 		for(int i = size-1; i&gt;=0; i--){
@@ -112,7 +111,7 @@
 		}
 		pbf.exit(0);
 	 }
-	
+
 	 class myProgressBarForm extends ProgressBarForm {
 		 boolean isClosed=false;
 		 protected boolean canExit(int exitCode) {
@@ -120,24 +119,25 @@
 			return true;
 		 }
 	 }
-	 
+
 	//////////////////////////////////////////////////////////////////////
 	// Utility functions
 	//////////////////////////////////////////////////////////////////////
-	
+
 	public String selectTargetDir() {
 		// Select destination directory
-		FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, pref.baseDir);
-		fc.setTitle(MyLocale.getMsg(148,&quot;Select Target directory&quot;));
+		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, pref.baseDir);
+		fc.title=MyLocale.getMsg(148,&quot;Select Target directory&quot;);
 		if(fc.execute() != FormBase.IDCANCEL){
 			return fc.getChosen() + &quot;/&quot;;
 		}
-		else return &quot;&quot;;
+		return &quot;&quot;;
 	}
-	 
+
 	public void deleteCacheFiles(String wpt, String dir){
 		// delete files in dstDir to clean up trash
-		String tmp[] = new FileBugfix(dir).list(wpt + &quot;*.*&quot;, ewe.io.FileBase.LIST_FILES_ONLY);
+		//TODO Remove FileBugfix
+		String tmp[] = (new eve.io.File(dir)).list(wpt + &quot;*.*&quot;, eve.io.File.LIST_FILES_ONLY);
 		for (int i=0; i &lt; tmp.length;i++){
 			File tmpFile = new File(dir + tmp[i]);
 			tmpFile.delete();
@@ -145,16 +145,16 @@
 	}
 
 	public void moveCacheFiles(String wpt, String srcDir, String dstDir){
-		String srcFiles[] = new FileBugfix(srcDir).list(wpt + &quot;*.*&quot;, ewe.io.FileBase.LIST_FILES_ONLY);
+		String srcFiles[] = new eve.io.File(srcDir).list(wpt + &quot;*.*&quot;, eve.io.File.LIST_FILES_ONLY);
 		for (int i=0; i &lt; srcFiles.length;i++){
-			File srcFile = new File(srcDir + srcFiles[i]);
-			File dstFile = new File(dstDir + srcFiles[i]);
+			eve.io.File srcFile = new eve.io.File(srcDir + srcFiles[i]);
+			eve.io.File dstFile = new eve.io.File(dstDir + srcFiles[i]);
 			srcFile.move(dstFile);
 		}
 	}
 
 	public void copyCacheFiles(String wpt, String srcDir, String dstDir){
-		String srcFiles[] = new FileBugfix(srcDir).list(wpt + &quot;*.*&quot;, ewe.io.FileBase.LIST_FILES_ONLY);
+		String srcFiles[] = new eve.io.File(srcDir).list(wpt + &quot;*.*&quot;, eve.io.File.LIST_FILES_ONLY);
 		for (int i=0; i &lt; srcFiles.length;i++){
 			copy(srcDir + srcFiles[i],dstDir + srcFiles[i]);
 		}
@@ -163,11 +163,11 @@
 	public static void copy( String sFileSrc, String sFileDst)
 	  {
 	    try {
-			File   fSrc = new File( sFileSrc );
+			java.io.File   fSrc = new java.io.File( sFileSrc );
 		    int    len  = 32768;
 		    byte[] buff = new byte[ (int)java.lang.Math.min( len, fSrc.length() ) ];
-		    FileInputStream  fis = new FileInputStream(  fSrc );
-		    FileOutputStream fos = new FileOutputStream( sFileDst);
+		    java.io.FileInputStream  fis = new java.io.FileInputStream(  fSrc );
+		    java.io.FileOutputStream fos = new java.io.FileOutputStream( sFileDst);
 		    while( 0 &lt; (len = fis.read( buff )) )
 		      fos.write( buff, 0, len );
 		    fos.flush();
@@ -182,13 +182,13 @@
 	//////////////////////////////////////////////////////////////////////
 	// Executor
 	//////////////////////////////////////////////////////////////////////
-		
+
 	private abstract class Executor {
 		String title;
 		Profile dstProfile;
 		public void doIt(int i, CacheHolder srcHolder){}
 	}
-	 
+
 	private class Deleter extends Executor {
 		 Deleter(String title) {
 			 this.title=title;
@@ -199,7 +199,7 @@
 			srcDB.removeElementAt(i);
 		 }
 	}
-	 
+
 	private class Copier extends Executor {
 		 Copier(String title, Profile dstProfile) {
 			 this.title=title;
@@ -213,7 +213,7 @@
 				deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
 				copyCacheFiles(srcHolder.wayPoint,profile.dataDir, dstProfile.dataDir);
 				// Update database
-				dstProfile.cacheDB.set(dstPos,srcHolder);
+				dstProfile.cacheDB.setElementAt(srcHolder,dstPos);
 			}
 			else {
 				deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
@@ -221,7 +221,7 @@
 				// Update database
 				dstProfile.cacheDB.add(srcHolder);
 			}
-		 }		 
+		 }
 	}
 
 	private class Mover extends Executor {
@@ -237,7 +237,7 @@
 				deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
 				moveCacheFiles(srcHolder.wayPoint,profile.dataDir, dstProfile.dataDir);
 				// Update database
-				dstProfile.cacheDB.set(dstPos,srcHolder);
+				dstProfile.cacheDB.setElementAt(srcHolder,dstPos);
 				srcDB.removeElementAt(i);
 				i--;
 			}
@@ -249,6 +249,6 @@
 				srcDB.removeElementAt(i);
 				i--;
 			}
-		 }		 
+		 }
 	}
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/DateTimeChooser.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/DateTimeChooser.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/DateTimeChooser.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,11 +1,12 @@
-package CacheWolf;
-import ewe.ui.*;
-import ewe.fx.*;
-import ewe.sys.*;
-import ewe.util.*;
-import ewe.reflect.*;
+package cachewolf;
+import eve.ui.*;
+import eve.fx.*;
+import eve.sys.*;
+import eve.ui.data.*;
+import eve.ui.table.*;
+import eve.ui.event.*;
+import eve.sys.Vm;
 
-
 public class DateTimeChooser extends Editor {
 
 	MultiPanel panels = new CardPanel();
@@ -20,14 +21,16 @@
 	
 	public boolean autoAdvance = true;
 	public boolean didAll = false;
-	
+	private boolean hasTime; // True if the time can also be set
 	TableControl dayChooser, monthChooser, yearChooser,timeChooser;
-	public Locale locale = Vm.getLocale();
+	TableModel tmYearChooser;
+	timeChooserTableModel tmTimeChooser;
+	public eve.sys.Locale locale = Vm.getLocale();
 	
-	Control dayDisplay;
-	Control monthDisplay;
-	Control yearDisplay;
-	Control timeDisplay;
+	//Control dayDisplay;
+	//Control monthDisplay;
+	//Control yearDisplay;
+	//Control timeDisplay;
 	//Control minuteDisplay;
 
 	Time getTime() {
@@ -46,19 +49,17 @@
 		tc.setTableModel(tm);
 		tc.setClickMode(true);
 		panels.addItem(tc,name,null);
-		//tc.addListener(this);
 	}
 	
-	boolean added = false;
+
 	Control addTopData(CellPanel cp,String field) {
-		Control dl = new mButton();//DumbLabel(1,10);
+		Control dl = new Button();//DumbLabel(1,10);
 		cp.addNext(addField(dl,field),HSTRETCH,HFILL);
 		dl.addListener(this);
 		//dl.anchor = CENTER;
 		dl.modify(DrawFlat,0);
 		dl.borderStyle = BDR_OUTLINE|BF_TOP|BF_RIGHT|BF_SQUARE;
 		//if (!added) dl.borderStyle |= BF_LEFT;
-		added = true;
 		dl.borderColor = Color.Black;
 		return dl;
 	}
@@ -74,18 +75,18 @@
 	
 	public CellPanel addTopSection(CellPanel addTo,Control cp) {
 		int IconSize;
-		if (Vm.isMobile() &amp;&amp; MyLocale.getScreenWidth() &gt;= 400)
+		if (Device.isMobile() &amp;&amp; MyLocale.getScreenWidth() &gt;= 400)
 			IconSize = 20;
 		else
 			IconSize = 10;
 		addTo.modify(DrawFlat,0);
-		addTo.defaultTags.set(INSETS,new Insets(0,0,0,0));
-		mButton b = new mButton();
+		addTo.defaultTags.set(TAG_INSETS,new Insets(0,0,0,0));
+		Button b = new Button();
 		b.borderStyle = BDR_OUTLINE|BF_LEFT|BF_TOP|BF_RIGHT|BF_SQUARE;
 		b.image = new DrawnIcon(DrawnIcon.CROSS,IconSize,IconSize,new Color(0x80,0,0));
 		addTo.addNext(addField(b,&quot;reject&quot;)).setCell(DONTSTRETCH);
 		addTo.addNext(cp,HSTRETCH,HFILL);
-		b = new mButton();
+		b = new Button();
 		b.borderStyle = BDR_OUTLINE|BF_TOP|BF_RIGHT|BF_SQUARE;
 		b.image = new DrawnIcon(DrawnIcon.TICK,IconSize,IconSize,new Color(0,0x80,0));
 		addTo.addNext(addField(b,&quot;accept&quot;)).setCell(DONTSTRETCH);
@@ -94,8 +95,9 @@
 	
 	CardPanel cards = new CardPanel();
 	
-	public DateTimeChooser(Locale l) {
+	public DateTimeChooser(Locale l, boolean hasTime) {
 		if (l != null) locale = l;
+		this.hasTime=hasTime;
 		setDate(new Time());
 		addLast(cards);
 		CellPanel addTo = new CellPanel();
@@ -105,10 +107,10 @@
 		CellPanel top = new CellPanel();
 		cp.equalWidths = true;
 		firstPanel = &quot;day&quot;;
-		dayDisplay = addTopData(cp,&quot;day&quot;);
-		monthDisplay = addTopData(cp,&quot;monthName&quot;);
-		yearDisplay = addTopData(cp,&quot;year&quot;);
-		timeDisplay = addTopData(cp,&quot;time&quot;);
+		addTopData(cp,&quot;day&quot;); // dayDisplay
+		addTopData(cp,&quot;monthName&quot;); // monthDisplay
+		addTopData(cp,&quot;year&quot;); // yearDisplay
+		if (hasTime) addTopData(cp,&quot;time&quot;); // timDisplay
 		cp.endRow();
 	
 	
@@ -118,22 +120,19 @@
 		
 		addTable(dayChooser = new TableControl(),new dayChooserTableModel(locale),&quot;day&quot;);
 		addTable(monthChooser = new TableControl(),new monthChooserTableModel(locale),&quot;monthName&quot;);
-		addTable(yearChooser = new TableControl(),new yearChooserTableModel(),&quot;year&quot;);
-		addTable(timeChooser = new TableControl(),new timeChooserTableModel(),&quot;time&quot;);
-		
-		// the following is already done in addTopSection?
+		addTable(yearChooser = new TableControl(),tmYearChooser=new yearChooserTableModel(),&quot;year&quot;);
+		if (hasTime) addTable(timeChooser = new TableControl(),tmTimeChooser=new timeChooserTableModel(),&quot;time&quot;);
 /*	
-		mButton b = new mButton();
+		Button b = new Button();
 		//b.borderStyle = BDR_OUTLINE|BF_LEFT|BF_TOP|BF_RIGHT|BF_SQUARE;
 		b.image = new DrawnIcon(DrawnIcon.CROSS,10,10,new Color(0x80,0,0));
 		addField(b,&quot;reject&quot;);
 		b.image = new DrawnIcon(DrawnIcon.CROSS,10,10,new Color(0x80,0,0));
-		b = new mButton();
+		b = new Button();
 		b.image = new DrawnIcon(DrawnIcon.TICK,10,10,new Color(0,0x80,0));
 		addField(b,&quot;accept&quot;);
 */
 		newDate();
-		
 	}
 	
 	public void fieldChanged(FieldTransfer ft,Editor ed) {
@@ -159,7 +158,7 @@
 					panels.select(&quot;monthName&quot;);
 				}
 			}else if (ev.target == monthChooser){
-				month = (int)((ewe.sys.Long)(((TableEvent)ev).cellData)).value;
+				month = ((java.lang.Long)(((TableEvent)ev).cellData)).intValue();
 				newDate();
 				monthName = locale.getString(Locale.SHORT_MONTH,month,0);
 				toControls(&quot;monthName&quot;);
@@ -168,7 +167,7 @@
 					didAll = true;
 				}
 			}else if (ev.target == yearChooser){
-				String p = (String)((TableEvent)ev).cellData;
+				String p = (String) tmYearChooser.getCellData(((TableEvent)ev).row,((TableEvent)ev).col); 
 				int dec = year % 100;
 				year -= dec;
 				if (p.charAt(0) == 'C'){
@@ -185,13 +184,12 @@
 				newDate();
 				toControls(&quot;year&quot;);
 			}else if (ev.target == timeChooser){
-				timeChooserTableModel tcm = (timeChooserTableModel)timeChooser.getTableModel();
-				int newHour=tcm.getHourFor(((TableEvent)ev).row,((TableEvent)ev).col);
+				int newHour=tmTimeChooser.getHourFor(((TableEvent)ev).row,((TableEvent)ev).col);
 				if (newHour&gt;-1) hour=newHour;
-				int newMinute=tcm.getMinuteFor(((TableEvent)ev).row,((TableEvent)ev).col);
+				int newMinute=tmTimeChooser.getMinuteFor(((TableEvent)ev).row,((TableEvent)ev).col);
 				if (newMinute&gt;-1) minute=newMinute;
 				time=MyLocale.formatLong(hour,&quot;00&quot;)+&quot;:&quot;+MyLocale.formatLong(minute,&quot;00&quot;);
-				tcm.set(hour,minute);
+				tmTimeChooser.set(hour,minute);
 				timeChooser.repaintNow();
 				newDate();
 				toControls(&quot;time&quot;);
@@ -206,7 +204,7 @@
 	public void setDate(Time t) {
 		dateSet = t;
 		if (!t.isValid()) t = new Time();
-		Time.toString(t,t instanceof TimeOfDay ? t.getFormat() : locale.getString(Locale.SHORT_DATE_FORMAT,0,0),locale);
+		//Time.toString(t,t instanceof TimeOfDay ? t.getFormat() : locale.getString(Locale.SHORT_DATE_FORMAT,0,0),locale);
 		day = t.day; month = t.month; year = t.year; hour=t.hour; minute=t.minute;
 		time=MyLocale.formatLong(hour,&quot;00&quot;)+&quot;:&quot;+MyLocale.formatLong(minute,&quot;00&quot;);
 		monthName = locale.getString(Locale.SHORT_MONTH,t.month,0);
@@ -225,8 +223,10 @@
 		dcm.set(day,month,year);
 		monthChooserTableModel mcm = (monthChooserTableModel)monthChooser.getTableModel();
 		mcm.set(day,month,year);
-		timeChooserTableModel tcm = (timeChooserTableModel)timeChooser.getTableModel();
-		tcm.set(hour,minute);
+		if (hasTime) {
+			timeChooserTableModel tcm = (timeChooserTableModel)timeChooser.getTableModel();
+			tcm.set(hour,minute);
+		}
 		//dayChooser.repaintNow();
 		//monthChooser.repaintNow();
 	}
@@ -234,7 +234,7 @@
 
 
 //-------------------------------------------------------
-class monthChooserTableModel extends InputPanelTableModel {
+class monthChooserTableModel extends TableModel {
 //-------------------------------------------------------
 	int chosenMonth;
 	Locale locale = Vm.getLocale();
@@ -282,21 +282,22 @@
 		return ta;
 	}
 
-	public Object getCellText(int row,int col) {
-		return locale.getString(Locale.SHORT_MONTH,getMonthFor(row,col),0);
+	public boolean getCellText(int row,int col,eve.util.StringList strList) {
+		strList.tryAdd(locale.getString(Locale.SHORT_MONTH,getMonthFor(row,col),0));
+		return true;
 	}
 
 	public Object getCellData(int row,int col) {
 		int month = getMonthFor(row,col);
-		return new ewe.sys.Long().set(month);
+		return new java.lang.Long(month);
 	}
 }
 
 //-------------------------------------------------------
-class dayChooserTableModel extends InputPanelTableModel {
+class dayChooserTableModel extends TableModel {
 //-------------------------------------------------------
 	
-	Vector days = new Vector();
+	java.util.Vector days = new java.util.Vector();
 	Locale locale = Vm.getLocale();
 	int firstDayIndex = 0;
 	int numDays = 28;
@@ -305,11 +306,11 @@
 	
 	
 	void set(int day,int month,int year) {
-		//ewe.sys.Vm.debug(month+&quot;,&quot;+year);
+		//eve.sys.Vm.debug(month+&quot;,&quot;+year);
 		numDays = Time.numberOfDays(month,year);
 		Time t = new Time(1,month,year);
 		firstDayIndex = Time.indexOfDayInWeek(t.dayOfWeek,locale)-1;
-		//ewe.sys.Vm.debug(&quot;&quot;+firstDayIndex+&quot;, &quot;+numDays);
+		//eve.sys.Vm.debug(&quot;&quot;+firstDayIndex+&quot;, &quot;+numDays);
 		int oldDay = chosenDay;
 		chosenDay = day;
 		if (oldDay != chosenDay) refreshDay(oldDay);
@@ -362,19 +363,19 @@
 	}
 	
 	public Object getCellData(int row,int col) {
-		if (row == -1) return days.get(col);
-		else {
-			int val = getDayFor(row,col);
-			if (val == 0) return null;
-			return Convert.toString(val);
-		}
+		if (row == -1) 
+			return days.get(col);
+		int val = getDayFor(row,col);
+		if (val == 0) return null;
+		return Convert.toString(val);
+		
 	}
 	
 }
 
 
 //-------------------------------------------------------
-class yearChooserTableModel extends InputPanelTableModel {
+class yearChooserTableModel extends TableModel {
 //-------------------------------------------------------
 	
 	yearChooserTableModel() {
@@ -382,20 +383,26 @@
 		numCols = 4;
 		hasColumnHeaders = false;
 		hasRowHeaders = false;
+		fillToEqualWidths = true;
+		fillToEqualHeights = true;
 	}
-	String [] all = mString.split(&quot;19xx|7|8|9|20xx|4|5|6|21xx|1|2|3|18xx|0|C+|C-&quot;);
+	String [] all = eve.util.mString.split(&quot;19xx|7|8|9|20xx|4|5|6|21xx|1|2|3|18xx|0|C+|C-&quot;);
 
-	public Object getCellText(int row,int col) {
-		if (row &gt;= 0 &amp;&amp; col &gt;= 0) 
-			return all[col+row*4];
-		return null;
+/*	public boolean getCellText(int row,int col,eve.util.StringList sl) {
+		if (row &gt;= 0 &amp;&amp; col &gt;= 0) {
+			sl.tryAdd(all[col+row*4]);
+			return true;
+		}
+		return false;
 	}
+*/	
 	
 	public Object getCellData(int row,int col) {
-		String str = (String)getCellText(row,col);
-		if (str.length() &gt; 2) str = str.substring(0,2);
-		return str;
-	}
+		if (row &gt;= 0 &amp;&amp; col &gt;= 0) {
+			return all[col+row*4];
+		}
+		return null;
+	}	
 	
 	public TableCellAttributes getCellAttributes(int row,int col,boolean isSelected,TableCellAttributes ta) {
 		ta.flat = true;
@@ -406,7 +413,7 @@
 }
 
 //-------------------------------------------------------
-class timeChooserTableModel extends InputPanelTableModel {
+class timeChooserTableModel extends TableModel {
 //	-------------------------------------------------------
 	int chosenHour=-2,chosenMinute=-2;
 	
@@ -415,6 +422,8 @@
 		numCols = 15;
 		hasColumnHeaders = false;
 		hasRowHeaders = false;
+		fillToEqualWidths = true;
+		fillToEqualHeights = true;
 	}
 	void set(int hour,int minute) {
 		int old = chosenHour;
@@ -460,20 +469,23 @@
 	}
 
 
-	public Object getCellText(int row,int col) {
+	public boolean getCellText(int row,int col, eve.util.StringList strList) {
 		if (row &gt;= 0 &amp;&amp; col &gt;= 0) 
-			if (col&lt;4) 
-				return Convert.toString(row*4+col);
-			else if (col==4) 
-				return &quot;&quot;;
-			else 
-				return  Convert.toString(row*10+col-5);
-		return null;
+			if (col&lt;4) { 
+				strList.tryAdd(Convert.toString(row*4+col));
+				return true;
+			} else if (col==4) 
+				return false;
+			else {
+				strList.tryAdd(Convert.toString(row*10+col-5));
+				return true;
+			}
+		return false;
 	}
 
-	public Object getCellData(int row,int col) {
-		return getCellText(row,col);
-	}
+//	public Object getCellData(int row,int col) {
+//		return (String)getCellText(row,col);
+//	}
 
 	public TableCellAttributes getCellAttributes(int row,int col,boolean isSelected,TableCellAttributes ta) {
 		ta.flat = true;

Modified: experiments/engywuck/hist-test/src/cachewolf/DescriptionPanel.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/DescriptionPanel.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/DescriptionPanel.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,136 +1,122 @@
-package CacheWolf;
+package cachewolf;
 
-import com.stevesoft.ewe_pat.Regex;
+import com.stevesoft.eve_pat.Regex;
 
-import ewe.ui.*;
-import ewe.fx.*;
-import ewe.sys.*;
-import ewe.util.Vector;
+import eve.ui.*;
+import eve.ui.formatted.*;
+import eve.fx.*;
+import eve.sys.*;
+import java.util.Vector;
+import eve.ui.event.*;
 
 /**
 *	This class shows the long description on a cache.
-*  Test with GC1CC5T - Final
-*            GC19DDX - 
 */
 public class DescriptionPanel extends CellPanel{
-	HtmlDisplay disp = new HtmlDisplay();
-	mButton btnPlus, btnMinus;
+	private HtmlDisplay disp;
+	private Button btnPlus, btnMinus;
+	private Panel buttonP;
+	private String desc,newDesc;
 	CacheHolderDetail currCache;
-	
-	CellPanel buttonP = new CellPanel();
-	CellPanel descP = new CellPanel();
-	
-	private String desc;
+	private FormattedTextMaker tm;
 
 	public DescriptionPanel(){
-		buttonP.addNext(btnPlus = new mButton(&quot;+&quot;),CellConstants.HSTRETCH, (CellConstants.HFILL));
-		buttonP.addLast(btnMinus = new mButton(&quot;-&quot;),CellConstants.HSTRETCH, (CellConstants.HFILL));
-		ScrollBarPanel sbp = new MyScrollBarPanel(disp, 0);
-		//sbp.setScrollBarSize(40,40, 20);
-		descP.addLast(sbp);
-		this.addLast(descP);
+		ScrollBarPanel sbp = new MyScrollBarPanel(disp = new HtmlDisplay(), 0);
+		this.addLast(sbp);
+		buttonP = new Panel();
+		buttonP.addNext(btnPlus = new Button(&quot;+&quot;),CellConstants.HSTRETCH, CellConstants.HFILL);
+		buttonP.addLast(btnMinus = new Button(&quot;-&quot;),CellConstants.HSTRETCH, CellConstants.HFILL);
+		buttonP.equalWidths=true;
 		this.addLast(buttonP,CellConstants.HSTRETCH,CellConstants.HFILL);
 		clear();
 	}
 	
 	/**
-         * Set the text to display. Text should be HTML formated.
-         */
-    // String description = null;
-    public void setText(CacheHolderDetail cache) {
-        boolean isHtml;
-        if (currCache == cache) return;
-        int scrollto = 0;
-        if (cache == null) {
-            desc = &quot;&quot;;
-            isHtml = false;
-        } else {
-            if (cache.hasSameMainCache(currCache))
-                scrollto = disp.getTopLine();
-            isHtml = cache.is_HTML;
-            if (cache.isAddiWpt()) {
-                CacheHolderDetail mainCache = cache.mainCache.getCacheDetails(true);
-                isHtml = mainCache.is_HTML;
-                if (cache.LongDescription != null &amp;&amp; cache.LongDescription.length() &gt; 0)
-                    desc = cache.LongDescription + (isHtml ? &quot;&lt;hr&gt;\n&quot; : &quot;\n&quot;)
-                            + mainCache.LongDescription;
-                else
-                    desc = mainCache.LongDescription;
-            } else
-                // not an addi-wpt
-                desc = cache.LongDescription;
-        }
-        // HtmlDisplay does not show the &lt;sup&gt; tag correctly, so we need to replace with ^
-        if (desc.indexOf(&quot;&lt;sup&gt;&quot;)&gt;=0) {
-        	desc=STRreplace.replace(desc,&quot;&lt;sup&gt;&quot;,&quot;^(&quot;);
-        	desc=STRreplace.replace(desc, &quot;&lt;/sup&gt;&quot;,&quot;)&quot;);
-        }
-        Vm.showWait(true);
-        if (isHtml) {
-            int imageNo = 0;
-            if (Global.getPref().descShowImg) {
-                Vector Images;
-                CacheHolderDetail chDimages; // cache which supplies the images (could be main cache)
-                if (cache.isAddiWpt()) {
-                    chDimages=cache.mainCache.getCacheDetails(true);
-                } else {
-                    chDimages=cache;
-                }
-            	Images = chDimages.Images;
-                StringBuffer s = new StringBuffer(desc.length() + Images.size() * 100);
-                int start = 0;
-                int pos;
-                Regex imgRex = new Regex(&quot;src=(?:\\s*[^\&quot;|']*?)(?:\&quot;|')(.*?)(?:\&quot;|')&quot;);
-                if (Images.getCount() &gt; 0) {
-                    while (start &gt;= 0 &amp;&amp; (pos = desc.indexOf(&quot;&lt;img&quot;, start)) &gt; 0) {
-                        s.append(desc.substring(start, pos));
-                        imgRex.searchFrom(desc, pos);
-                        String imgUrl = imgRex.stringMatched(1);
-                        if (imgUrl==null) break; // Remaining pictures are from image span
-                        // Vm.debug(&quot;imgUrl &quot;+imgUrl);
-                        if (imgUrl.lastIndexOf('.') &gt; 0 &amp;&amp; imgUrl.toLowerCase().startsWith(&quot;http&quot;)) {
-                            String imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;))
-                                    .toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
-                            // If we have an image which we stored when spidering, we can display it
-        					if(imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)){
-                                s.append(&quot;&lt;img src=\&quot;&quot; +
-                                // Global.getProfile().dataDir+
-                                        Images.get(imageNo) + &quot;\&quot;&gt;&quot;);
-                                imageNo++;
-                            }
-                        }
-                        start = desc.indexOf(&quot;&gt;&quot;, pos);
-                        if (start &gt;= 0)
-                            start++;
-                        if (imageNo &gt;= Images.getCount())
-                            break;
-                    }
-                }
-                if (start &gt;= 0)
-                    s.append(desc.substring(start));
-                desc = s.toString();
-                if (imageNo&lt;Images.getCount()) {
-                    desc += getPicDesc(imageNo, chDimages);
-                }
-            }
-            //disp.setHtml(desc);
-            disp.startHtml();
-            disp.getDecoderProperties().set(&quot;documentroot&quot;, Global.getProfile().dataDir);
-            disp.addHtml(desc, new ewe.sys.Handle());
-            disp.endHtml();
-
-        } else {
-            disp.startHtml(); // To clear the old HTML display
-            disp.endHtml();
-            disp.setPlainText(desc);
-        }
-        disp.scrollTo(scrollto, false);
-        //description = desc;
-        Vm.showWait(false);
-        //}
-        currCache = cache;
-    }
+	*	Set the text to display. Text should be HTML formated.
+	*/
+	//String description = null;
+	//CacheHolderDetail chD;
 	
+	public void setText(CacheHolderDetail chD){
+		boolean isHtml=chD.is_HTML;
+		//if (currCache == cache) return;
+		int scrollto = 0;
+		if (chD.hasSameMainCache(currCache)) scrollto = disp.getTopLine();
+		//Makes no sense if (chD == null) desc = &quot;&quot;;
+		else {
+			if (chD.isAddiWpt()) {
+				CacheHolderDetail mainCache=chD.mainCache.getCacheDetails(true);
+				isHtml=mainCache.is_HTML;
+				if (chD.longDescription != null &amp;&amp; chD.longDescription.length() &gt; 0)
+					 desc = chD.longDescription + (isHtml?&quot;&lt;hr&gt;\n&quot;:&quot;\n&quot;)+mainCache.longDescription;
+				else 
+					desc = mainCache.longDescription;
+			} else // not an addi-wpt
+				desc = chD.longDescription; 
+		}
+		//if (!desc.equals(description)) {
+			//disp.getDecoderProperties().setBoolean(&quot;allowImages&quot;,true);
+			Form.showWait(); 
+			if (isHtml) {
+				int imageNo=0;
+				if (Global.getPref().descShowImg) {
+					Vector Images;
+					if (chD.isAddiWpt()) {
+						Images = chD.mainCache.getCacheDetails(true).images;
+					} else {
+						Images = chD.images;						
+					}					
+					StringBuffer s=new StringBuffer(desc.length()+Images.size()*100);
+					int start=0;
+					int pos;
+					Regex imgRex = new Regex(&quot;src=(?:\\s*[^\&quot;|']*?)(?:\&quot;|')(.*?)(?:\&quot;|')&quot;);
+					if (Images.size() &gt; 0) {
+						while (start&gt;=0 &amp;&amp; (pos=desc.indexOf(&quot;&lt;img&quot;,start))&gt;0) {
+							s.append(desc.substring(start,pos));
+							imgRex.searchFrom(desc,pos);
+							String imgUrl=imgRex.stringMatched(1);
+							//Vm.debug(&quot;imgUrl &quot;+imgUrl);
+							if (imgUrl.lastIndexOf('.')&gt;0 &amp;&amp; imgUrl.toLowerCase().startsWith(&quot;http&quot;)) {
+								String imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).substring(0,4).trim();
+								// If we have an image which we stored when spidering, we can display it
+								if(!imgType.startsWith(&quot;.com&quot;) &amp;&amp; !imgType.startsWith(&quot;.php&quot;) &amp;&amp; !imgType.startsWith(&quot;.exe&quot;)){
+									s.append(&quot;&lt;img src=\&quot;&quot;+
+											//Global.getProfile().dataDir+
+											Images.get(imageNo)+&quot;\&quot;&gt;&quot;);
+									imageNo++;
+								} // else s.append(&quot;&lt;!-- not valid image type --&gt;&quot;);
+							} // else s.append(&quot;&lt;!-- Not http --&gt;&quot;);
+							start=desc.indexOf(&quot;&gt;&quot;,pos);
+							if (start&gt;=0) start++;
+							if (imageNo &gt;= Images.size())break;
+						}
+					}
+					if (start&gt;=0) s.append(desc.substring(start));
+					newDesc=s.toString(); // Don't store in desc as this could modify chD
+				}
+				if (chD.hasImageInfo()) {
+					newDesc+=getPicDesc(imageNo,chD);
+				}
+				//disp.setHtml(desc);
+				disp.startHtml();
+				disp.getDecoderProperties().set(&quot;documentroot&quot;,Global.getProfile().dataDir);
+				disp.addHtml(newDesc,new eve.sys.Handle());
+				tm=disp.endHtml();
+				
+			}
+			else {
+				disp.startHtml(); // To clear the old HTML display
+				disp.addHtml(desc,new eve.sys.Handle());
+				tm=disp.endHtml();
+				//disp.setPlainText(desc);
+			}
+			disp.scrollTo(scrollto,false);
+			//description = desc;
+			Form.cancelWait();
+		//}
+		currCache = chD;
+	}
+	
 	/**
 	 * Get the descriptions for the pictures (if they exist)
 	 * @param imagesShown images already shown as part of long description (don't show again)
@@ -140,32 +126,35 @@
 		StringBuffer sb=new StringBuffer(1000);
 		sb.append(&quot;&lt;hr&gt;&lt;font size=\&quot;+1\&quot; color=\&quot;red\&quot;&gt;&quot;).append(MyLocale.getMsg(202,&quot;IMAGES&quot;).toUpperCase()).append(&quot;&lt;/font&gt;&quot;);
 		sb.append(&quot;&lt;br&gt;&lt;br&gt;&quot;);
-		for (int i=imagesShown; i&lt;chD.ImagesInfo.size(); i++) {
-			sb.append(chD.ImagesText.get(i)).append(&quot;&lt;br&gt;&quot;);
+		for (int i=imagesShown; i&lt;chD.imagesInfo.size(); i++) {
+			sb.append(chD.imagesText.get(i)).append(&quot;&lt;br&gt;&quot;);
 			// Show the additional text if there is one
-			if (chD.ImagesInfo.get(i)!=null) sb.append(&quot;&lt;font color='blue'&gt;&quot;).append(chD.ImagesInfo.get(i)).append(&quot;&lt;/font&gt;&quot;);
+			if (chD.imagesInfo.get(i)!=null) sb.append(&quot;&lt;font color='blue'&gt;&quot;).append(chD.imagesInfo.get(i)).append(&quot;&lt;/font&gt;&quot;);
 			// Only show the image if images are enabled
-			if (Global.getPref().descShowImg) sb.append(&quot;&lt;img src=\&quot;&quot;+chD.Images.get(i)+&quot;\&quot;&gt;&lt;br&gt;&quot;);
+			if (Global.getPref().descShowImg) sb.append(&quot;&lt;img src=\&quot;&quot;+chD.images.get(i)+&quot;\&quot;&gt;&lt;br&gt;&quot;);
 			sb.append(&quot;&lt;br&gt;&lt;br&gt;&lt;hr&gt;&quot;);
 		}
 		return sb.toString();
 	}
 	
+	
+	
 	public void clear() {
-		disp.setPlainText(&quot;loading ...&quot;);
-		currCache = null;
+		disp.startHtml(); // To clear the old HTML display
+		disp.addHtml(&quot;loading ...&quot;,new eve.sys.Handle());
+		disp.endHtml();
+		//disp.setPlainText(&quot;loading ...&quot;);
 	}
 	
-	// Probably not needed anymore (Change in Rev. 1395)
 	private void redraw() {
 		int currLine;
 
-		Vm.showWait(true);
+		Form.showWait();
 		currLine = disp.getTopLine();
-		if (currCache.is_HTML)	disp.setHtml(desc);
-		else				disp.setPlainText(currCache.LongDescription);
+		//if (currCache.is_HTML)	setText(desc);
+		//else				disp.setPlainText(currCache.longDescription);
 		disp.scrollTo(currLine,false);
-		Vm.showWait(false);
+		Form.cancelWait();
 	}
 	
 	/**
@@ -173,12 +162,16 @@
 	 */
 	public void onEvent(Event ev){
 		
+		if (ev instanceof ControlEvent &amp;&amp; ev.type==TextDisplay.LINES_SPLIT) { 
+			ev.consumed=true; return; } // LINES_SPLIT event does not have to percolate up
 		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
 			if (ev.target == btnPlus){
 				Font currFont = disp.getFont();
 				currFont = currFont.changeNameAndSize(null, currFont.getSize() + 2);
+				//tm.newFont=currFont;
 				disp.setFont(currFont);
 				disp.displayPropertiesChanged();
+				//disp.repaintNow();
 				//redraw();
 			}
 
@@ -187,6 +180,7 @@
 				currFont = currFont.changeNameAndSize(null, currFont.getSize() - 2);
 				disp.setFont(currFont);
 				disp.displayPropertiesChanged();
+				//disp.repaintNow();
 				//redraw();
 			}
 		}

Modified: experiments/engywuck/hist-test/src/cachewolf/DetailsPanel.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/DetailsPanel.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/DetailsPanel.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,155 +1,146 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.ui.*;
-import ewe.fx.*;
-import ewe.util.*;
-import ewe.sys.*;
+import eve.ui.*;
+import eve.ui.formatted.*;
+import eve.fx.*;
 
+import eve.sys.*;
+import eve.ui.event.*;
+
 /**
 *	Class to create the panel to show the cache details.&lt;br&gt;
 *	Also allows for creation of a custom waypoint.&lt;br&gt;
 *
-*   
+*
 */
 public class DetailsPanel extends CellPanel{
-	mInput inpWaypoint = new mInput();
-	mInput inpName = new mInput();
-	mButton btnWayLoc = new mButton();
-	mInput inpHidden = new mInput();
-	mInput inpOwner = new mInput();
-	mButton btnDelete,btnCenter, btnAddDateTime;
-	mChoice chcType = new mChoice(new String[]{&quot;Custom&quot;, &quot;Traditional&quot;, &quot;Multi&quot;, &quot;Virtual&quot;, &quot;Letterbox&quot;, &quot;Event&quot;, &quot;Mega Event&quot;, &quot;Mystery&quot;, &quot;Webcam&quot;, &quot;Locationless&quot;, &quot;CITO&quot;, &quot;Earthcache&quot;, &quot;wherIGo&quot;, &quot;Addi: Parking&quot;, &quot;Addi: Stage&quot;, &quot;Addi: Question&quot;, &quot;Addi: Final&quot;,&quot;Addi: Trailhead&quot;,&quot;Addi: Reference&quot;},0);
-	mChoice chcSize = new mChoice(new String[]{&quot;&quot;, &quot;Micro&quot;, &quot;Small&quot;, &quot;Regular&quot;, &quot;Large&quot;,&quot;Other&quot;,&quot;Very Large&quot;,&quot;None&quot;},0);
-	mComboBox chcStatus = new mComboBox(new String[]{&quot;&quot;, MyLocale.getMsg(313,&quot;Flag 1&quot;), MyLocale.getMsg(314,&quot;Flag 2&quot;), MyLocale.getMsg(315,&quot;Flag 3&quot;), MyLocale.getMsg(316,&quot;Flag 4&quot;), MyLocale.getMsg(317,&quot;Search&quot;), MyLocale.getMsg(318,&quot;Found&quot;), MyLocale.getMsg(319,&quot;Not Found&quot;), MyLocale.getMsg(320,&quot;Owner&quot;)},0);
-	mButton btnNewWpt, btnShowBug, btnShowMap, btnGoto, btnAddPicture, btnBlack, btnNotes, btnSave, btnCancel;
-	mButton btnFoundDate,btnHiddenDate;
-	Vector cacheDB;
+	Input inpWaypoint = new Input();
+	Input inpName = new Input();
+	Button btnWayLoc = new Button();
+	Input inpHidden = new Input();
+	Input inpOwner = new Input();
+	Button btnAddDateTime;
+	Choice chcType = new Choice(CacheType.wayTypeList(),0);
+	Choice chcSize = new Choice(CacheHolder.cacheSizeList,0);
+	ComboBox chcStatus = new ComboBox(new String[]{&quot;&quot;, MyLocale.getMsg(313,&quot;Flag 1&quot;), MyLocale.getMsg(314,&quot;Flag 2&quot;), MyLocale.getMsg(315,&quot;Flag 3&quot;), MyLocale.getMsg(316,&quot;Flag 4&quot;), MyLocale.getMsg(317,&quot;Search&quot;), MyLocale.getMsg(318,&quot;Found&quot;), MyLocale.getMsg(319,&quot;Not Found&quot;), MyLocale.getMsg(320,&quot;Owner&quot;)},0);
+	Button btnNewWpt, btnShowBug, btnShowMap, btnGoto, btnAddPicture, btnBlack, btnNotes;
+	Button btnFoundDate,btnHiddenDate;
 	CacheHolder thisCache;
-	int dbIndex = -1;
-	CellPanel pnlTools = new CellPanel(); 
+	Panel pnlTools = new Panel();
 	AttributesViewer attV;
-	mTextPad mNotes;
-	
+	TextPad mNotes;
+
 	private boolean dirty_notes = false;
 	private boolean dirty_details = false;
 	private boolean blackStatus = false;
 	private boolean blackStatusChanged=false;
 	private boolean needsTableUpdate = false;
 	private boolean isBigScreen = false;
-	
+
 	Preferences pref; // Test
 	Profile profile;
-	mImage imgBlack;
-	mImage imgBlackNo;
-	mImage imgShowBug, imgShowBugNo,imgNewWpt,imgGoto;
-	mImage imgShowMaps,imgAddImages,imgNotes;
-	mLabel lblDiff, lblTerr;
-	
+	Picture imgBlack;
+	Picture imgBlackNo;
+	Picture imgShowBug, imgShowBugNo;
+	Label lblDiff, lblTerr;
+
 	public DetailsPanel(){
 		pref = Global.getPref();
 		profile=Global.getProfile();
-		cacheDB = profile.cacheDB;
+		//cacheDB = profile.cacheDB;
 		////////////////////
 		// Tools
 		////////////////////
 		// Use larger Button-Icons on VGA-mobiles
 		int sw = MyLocale.getScreenWidth();
 		String imagesize=&quot;&quot;;
-		if (Vm.isMobile() &amp;&amp; sw &gt;= 400) imagesize=&quot;_vga&quot;;  
+		if (eve.sys.Device.isMobile() &amp;&amp; sw &gt;= 400) imagesize=&quot;_vga&quot;;
 		// Button 1: New Waypoint
-		pnlTools.addNext(btnNewWpt = new mButton(imgNewWpt=new mImage(&quot;newwpt&quot;+imagesize+&quot;.png&quot;))); 
+		pnlTools.addNext(btnNewWpt = new Button(new Picture(&quot;newwpt&quot;+imagesize+&quot;.png&quot;,new Color(255,0,0),0)));
 		btnNewWpt.setToolTip(MyLocale.getMsg(311,&quot;Create Waypoint&quot;));
 		PenEvent.wantPenMoved(btnNewWpt,PenEvent.WANT_PEN_MOVED_ONOFF,true);
-		imgNewWpt.transparentColor=new Color(255,0,0);
 		// Button 2: Goto
-		pnlTools.addNext(btnGoto = new mButton(imgGoto=new mImage(&quot;goto&quot;+imagesize+&quot;.png&quot;)));//Goto.gif funzt manchmal nicht
-		imgGoto.transparentColor=Color.White;
+		pnlTools.addNext(btnGoto = new Button(new Picture(&quot;goto&quot;+imagesize+&quot;.png&quot;,Color.White,0)));//Goto.gif funzt manchmal nicht
 		btnGoto.setToolTip(MyLocale.getMsg(345,&quot;Goto these coordinates&quot;));
 		// Button 3: Travelbugs
-		imgShowBug = new mImage(&quot;bug&quot;+imagesize+&quot;.gif&quot;);
-		imgShowBugNo = new mImage(&quot;bug_no&quot;+imagesize+&quot;.gif&quot;);
-		pnlTools.addNext(btnShowBug = new mButton(imgShowBugNo)); 
+		imgShowBug = new Picture(&quot;bug&quot;+imagesize+&quot;.gif&quot;);
+		imgShowBugNo = new Picture(&quot;bug_no&quot;+imagesize+&quot;.gif&quot;);
+		pnlTools.addNext(btnShowBug = new Button(imgShowBugNo));
 		//btnShowBug.modify(Control.Disabled,0);
 		btnShowBug.setToolTip(MyLocale.getMsg(346,&quot;Show travelbugs&quot;));
 		// Button 4: Show Map
-		pnlTools.addNext(btnShowMap = new mButton(imgShowMaps = new mImage(&quot;globe_small&quot;+imagesize+&quot;.gif&quot;))); 
+		pnlTools.addNext(btnShowMap = new Button(new Picture(&quot;globe_small&quot;+imagesize+&quot;.gif&quot;)));
 		btnShowMap.setToolTip(MyLocale.getMsg(347,&quot;Show map&quot;));
 		// Button 5: Add images
-		pnlTools.addNext(btnAddPicture = new mButton(imgAddImages = new mImage(&quot;images&quot;+imagesize+&quot;.gif&quot;))); 
+		pnlTools.addNext(btnAddPicture = new Button(new Picture(&quot;images&quot;+imagesize+&quot;.gif&quot;)));
 		btnAddPicture.setToolTip(MyLocale.getMsg(348,&quot;Add user pictures&quot;));
 		// Button 6: Toggle blacklist status
-		imgBlackNo = new mImage(&quot;no_black&quot;+imagesize+&quot;.png&quot;); imgBlackNo.transparentColor=Color.Black;
-		imgBlack = new mImage(&quot;is_black&quot;+imagesize+&quot;.png&quot;); imgBlack.transparentColor=Color.White;
-		pnlTools.addNext(btnBlack=new mButton(imgBlackNo)); 
+		imgBlackNo = new Picture(&quot;no_black&quot;+imagesize+&quot;.png&quot;,Color.Black,0);
+		imgBlack = new Picture(&quot;is_black&quot;+imagesize+&quot;.png&quot;,Color.White,0);
+		pnlTools.addNext(btnBlack=new Button(imgBlackNo));
 		btnBlack.setToolTip(MyLocale.getMsg(349,&quot;Toggle Blacklist status&quot;));
 		// Button 7: Notes
-		pnlTools.addNext(btnNotes=new mButton(imgNotes=new mImage(&quot;notes&quot;+imagesize+&quot;.gif&quot;))); imgNotes.transparentColor=Color.DarkBlue;
+		pnlTools.addNext(btnNotes=new Button(new Picture(&quot;notes&quot;+imagesize+&quot;.gif&quot;,Color.DarkBlue,0)));
 		btnNotes.setToolTip(MyLocale.getMsg(351,&quot;Add/Edit notes&quot;));
 		// Button 8: Date/time stamp
-		pnlTools.addLast(btnAddDateTime = new mButton(new mImage(&quot;date_time&quot;+imagesize+&quot;.gif&quot;))); 
+		pnlTools.addLast(btnAddDateTime = new Button(new Picture(&quot;date_time&quot;+imagesize+&quot;.png&quot;)));
 		btnAddDateTime.setToolTip(MyLocale.getMsg(350,&quot;Add timestamp to notes&quot;));
 		//showMap.modify(Control.Disabled,0);
 		pnlTools.stretchFirstRow=true;
-		this.addLast(pnlTools,CellConstants.DONTSTRETCH, CellConstants.WEST).setTag(SPAN,new Dimension(3,1));;
-		
+		this.addLast(pnlTools,CellConstants.DONTSTRETCH, CellConstants.WEST).setTag(TAG_SPAN,new Dimension(3,1));;
+
 		////////////////////
 		// Main body of screen
 		////////////////////
 
-		this.addNext(new mLabel(MyLocale.getMsg(300,&quot;Type:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTHWEST));
-		CellPanel line1Panel = new CellPanel();
+		this.addNext(new Label(MyLocale.getMsg(300,&quot;Type:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTHWEST));
+		Panel line1Panel = new Panel(); line1Panel.stretchFirstColumn=true;
 		line1Panel.addNext(chcType,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		line1Panel.addLast(lblDiff=new mLabel(MyLocale.getMsg(1000,&quot;D&quot;)+&quot;: 5.5&quot;),CellConstants.DONTSTRETCH,(CellConstants.DONTFILL|CellConstants.EAST));
-		this.addLast(line1Panel,DONTSTRETCH,HFILL).setTag(CellConstants.SPAN, new Dimension(2,1));
-		
-		this.addNext(new mLabel(MyLocale.getMsg(301,&quot;Size:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		CellPanel line2Panel = new CellPanel();
+		line1Panel.addLast(lblDiff=new Label(MyLocale.getMsg(1000,&quot;D&quot;)+&quot;: 5.5&quot;),CellConstants.DONTSTRETCH,(CellConstants.DONTFILL|CellConstants.EAST));
+		this.addLast(line1Panel,HSTRETCH,HFILL);
+
+		this.addNext(new Label(MyLocale.getMsg(301,&quot;Size:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		Panel line2Panel = new Panel(); line2Panel.stretchFirstColumn=true;
 		line2Panel.addNext(chcSize,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		line2Panel.addLast(lblTerr=new mLabel(MyLocale.getMsg(1001,&quot;T&quot;)+&quot;: 5.5&quot;),CellConstants.DONTSTRETCH,(CellConstants.DONTFILL|CellConstants.EAST));
-		this.addLast(line2Panel,DONTSTRETCH,HFILL).setTag(CellConstants.SPAN, new Dimension(2,1));
-		
-		this.addNext(new mLabel(MyLocale.getMsg(302,&quot;Waypoint:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		this.addLast(inpWaypoint.setTag(CellConstants.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		
-		this.addNext(new mLabel(MyLocale.getMsg(303,&quot;Name:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		this.addLast(inpName.setTag(CellConstants.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		
-		this.addNext(new mLabel(MyLocale.getMsg(304,&quot;Location:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		this.addLast(btnWayLoc.setTag(CellConstants.SPAN, new Dimension(2,1)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		
-		this.addNext(new mLabel(MyLocale.getMsg(307,&quot;Status:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		CellPanel cp=new CellPanel();
+		line2Panel.addLast(lblTerr=new Label(MyLocale.getMsg(1001,&quot;T&quot;)+&quot;: 5.5&quot;),CellConstants.DONTSTRETCH,(CellConstants.DONTFILL|CellConstants.EAST));
+		this.addLast(line2Panel,HSTRETCH,HFILL);
+
+		this.addNext(new Label(MyLocale.getMsg(302,&quot;Waypoint:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		this.addLast(inpWaypoint,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+
+		this.addNext(new Label(MyLocale.getMsg(303,&quot;Name:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		this.addLast(inpName,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+
+		this.addNext(new Label(MyLocale.getMsg(304,&quot;Location:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		this.addLast(btnWayLoc,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+
+		this.addNext(new Label(MyLocale.getMsg(307,&quot;Status:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		Panel cp=new Panel(); cp.stretchFirstColumn=true;
 		cp.addNext(chcStatus,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		cp.addLast(btnFoundDate=new mButton(new mImage(&quot;calendar&quot;+imagesize+&quot;.png&quot;)),DONTSTRETCH,DONTFILL);
-		this.addLast(cp,DONTSTRETCH,HFILL).setTag(CellConstants.SPAN, new Dimension(2,1));
-		
-		this.addNext(new mLabel(MyLocale.getMsg(306,&quot;Owner:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		this.addLast(inpOwner.setTag(CellConstants.SPAN, new Dimension(2,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		
-		this.addNext(new mLabel(MyLocale.getMsg(305,&quot;Hidden on:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		CellPanel ip=new CellPanel();
+		cp.addLast(btnFoundDate=new Button(new Picture(&quot;calendar&quot;+imagesize+&quot;.png&quot;)),DONTSTRETCH,DONTFILL);
+		this.addLast(cp,HSTRETCH,HFILL);
+
+		this.addNext(new Label(MyLocale.getMsg(306,&quot;Owner:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		this.addLast(inpOwner,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+
+		this.addNext(new Label(MyLocale.getMsg(305,&quot;Hidden on:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		Panel ip=new Panel(); ip.stretchFirstColumn=true;
 		ip.addNext(inpHidden,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		ip.addLast(btnHiddenDate=new mButton(new mImage(&quot;calendar&quot;+imagesize+&quot;.png&quot;)),DONTSTRETCH,DONTFILL);
-		this.addLast(ip,DONTSTRETCH,HFILL).setTag(CellConstants.SPAN, new Dimension(2,1));
+		ip.addLast(btnHiddenDate=new Button(new Picture(&quot;calendar&quot;+imagesize+&quot;.png&quot;)),DONTSTRETCH,DONTFILL);
+		this.addLast(ip,HSTRETCH,HFILL);
 		inpHidden.modifyAll(DisplayOnly,0);
-		
-		//btnNotes = new mButton(&quot;Notes&quot;);
-		//this.addLast(btnNotes.setTag(Control.SPAN, new Dimension(3,1)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		//this.addNext(new mLabel(MyLocale.getMsg(308,&quot;Notes:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		//this.addLast(btnCenter = new mButton(MyLocale.getMsg(309,&quot;Make Centre&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-//		this.addLast(btnDelete = new mButton(MyLocale.getMsg(310,&quot;Delete&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+
 		attV=new AttributesViewer();
 		this.addLast(attV);
-		
 		if ((MyLocale.getScreenWidth() &gt;= 400) &amp;&amp; (MyLocale.getScreenHeight() &gt;= 600)){
-			isBigScreen = true;  
-			this.addLast(new mLabel(MyLocale.getMsg(308,&quot;Notes:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			mNotes = new mTextPad();
+			isBigScreen = true;
+			this.addLast(new Label(MyLocale.getMsg(308,&quot;Notes:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			mNotes = new TextPad();
 			mNotes.modify(ControlConstants.NotEditable,0);
 			this.addLast(new MyScrollBarPanel(mNotes));
 		}
 	}
-	
+
 	public void clear() {
 		attV.clear();
 	}
@@ -157,19 +148,18 @@
 	public void setNeedsTableUpdate(boolean tableUpdate) {
 		needsTableUpdate = tableUpdate;
 	}
-	
 	public boolean needsTableUpdate() {
 		return needsTableUpdate;
 	}
-	
+
 	public boolean isDirty() {
 		return dirty_notes || dirty_details || needsTableUpdate;
 	}
 	public boolean hasBlackStatusChanged() {
 		return blackStatusChanged;
 	}
-	
-	
+
+
 	/**
 	* @param chD details of the cache to display
 	* @param dbindex index in cacheDB, in which changes will be saved
@@ -179,14 +169,14 @@
 		dirty_notes = false;
 		dirty_details = false;
 		inpWaypoint.setText(ch.wayPoint);
-		inpName.setText(ch.CacheName);
+		inpName.setText(ch.cacheName);
 	    btnWayLoc.setText(ch.pos.toString());
-		inpHidden.setText(ch.DateHidden);
-		inpOwner.setText(ch.CacheOwner);
-		if (ch.CacheStatus.length()&gt;=10 &amp;&amp; ch.CacheStatus.charAt(4)=='-')
-			chcStatus.setText(MyLocale.getMsg(318,&quot;Found&quot;)+&quot; &quot;+ch.CacheStatus);
+		inpHidden.setText(ch.dateHidden);
+		inpOwner.setText(ch.cacheOwner);
+		if (ch.cacheStatus.length()&gt;=10 &amp;&amp; ch.cacheStatus.charAt(4)=='-')
+			chcStatus.setText(MyLocale.getMsg(318,&quot;Found&quot;)+&quot; &quot;+ch.cacheStatus);
 		else {
-			chcStatus.setText(ch.CacheStatus);
+			chcStatus.setText(ch.cacheStatus);
 			// If the cache status contains a date, do not overwrite it with 'found' message
 			if(ch.is_found == true) chcStatus.setText(MyLocale.getMsg(318,&quot;Found&quot;));
 		}
@@ -196,7 +186,7 @@
 		} else {
 			btnBlack.image = imgBlackNo;
 		}
-		blackStatus=ch.is_black; 
+		blackStatus=ch.is_black;
 		blackStatusChanged=false;
 		btnBlack.repaintNow();
 		if (inpWaypoint.getText().length() == 0)
@@ -209,114 +199,54 @@
 			btnShowBug.image = imgShowBugNo;
 		}
 		btnShowBug.repaintNow();
-		if(ch.CacheSize.equals(&quot;Micro&quot;)) chcSize.setInt(1);
-		if(ch.CacheSize.equals(&quot;Small&quot;)) chcSize.setInt(2);
-		if(ch.CacheSize.equals(&quot;Regular&quot;)) chcSize.setInt(3);
-		if(ch.CacheSize.equals(&quot;Large&quot;)) chcSize.setInt(4);
-		if(ch.CacheSize.equals(&quot;Other&quot;)) chcSize.setInt(5);
-		if(ch.CacheSize.equals(&quot;Very Large&quot;)) chcSize.setInt(6);
-		if(ch.CacheSize.equals(&quot;None&quot;)) chcSize.setInt(7);
-		if(ch.CacheSize.equals(&quot;Not chosen&quot;)) chcSize.setInt(7);
+		chcSize.setInt(ch.cacheSize);
 		attV.showImages(ch.getCacheDetails(true).attributes);
 		lblTerr.setText((ch.terrain.length()&gt;0) ? (MyLocale.getMsg(1001,&quot;T&quot;)+&quot;: &quot;+ch.terrain) : &quot;&quot;);
-		lblDiff.setText((ch.hard.length()&gt;0)    ? (MyLocale.getMsg(1000,&quot;D&quot;)+&quot;: &quot;+ch.hard) : &quot;&quot;); 
+		lblDiff.setText((ch.hard.length()&gt;0)    ? (MyLocale.getMsg(1000,&quot;D&quot;)+&quot;: &quot;+ch.hard) : &quot;&quot;);
+		if(isBigScreen)	mNotes.setText(ch.details.cacheNotes);	}
 
-		if(isBigScreen)	mNotes.setText(ch.details.CacheNotes);
-	}
-	
-	
+
 	/**
 	*	Translate the cache type to the value in the cache type dropdown
 	*	control.
 	*/
-	private int transType(String type){
-		int c_type = 0;
-		int tt = 0;
-		tt = Convert.parseInt(type);
-		switch(tt){
-			case 0: c_type = 0; break;
-			case 2: c_type = 1; break;
-			case 3: c_type = 2; break;
-			case 4: c_type = 3; break;
-			case 5: c_type = 4; break;
-			case 6: c_type = 5; break;
-			case 453: c_type = 6;break;
-			case 8: c_type = 7; break;
-			case 11: c_type = 8; break; //Earth
-			case 12: c_type = 9; break;
-			case 13: c_type = 10; break;
-			case 137: c_type = 11;break;
-			case 1858: c_type = 12; break;
-			case 50: c_type = 13;break;
-			case 51: c_type = 14;break;
-			case 52: c_type = 15;break;
-			case 53: c_type = 16;break;
-			case 54: c_type = 17;break;
-			case 55: c_type = 18;break;
-
-			default: Vm.debug(&quot;Unknown cachetype: &quot; + type);
-					break;
-		}
+	private int transType(int type){
+		int c_type = CacheType.getWayTypePos(type);
+		if (c_type&lt;0) c_type=0;
 		return c_type;
 	}
-	
+
 	/**
 	*	Method to translate a selected cache type in the drop down control
 	*	to a &quot;true&quot; cache type.&lt;br&gt;
 	*	This transformation is required to ease the display of the cache type
 	*	icon in the table display.
 	*/
-	public String transSelect(int num){
-		String ret = new String(&quot;&quot;);
-		switch(num){
-			case 0: ret = &quot;0&quot;; break;
-			case 1: ret = &quot;2&quot;; break;
-			case 2: ret = &quot;3&quot;; break;
-			case 3: ret = &quot;4&quot;; break;
-			case 4: ret = &quot;5&quot;; break;
-			case 5: ret = &quot;6&quot;; break;
-			case 6: ret = &quot;453&quot;; break;
-			case 7: ret = &quot;8&quot;; break;
-			case 8: ret = &quot;11&quot;; break;
-			case 9: ret = &quot;12&quot;; break;
-			case 10: ret = &quot;13&quot;;break;
-			case 11: ret = &quot;137&quot;;break;
-			case 12: ret = &quot;1858&quot;; break;
-			case 13: ret = &quot;50&quot;;break;
-			case 14: ret = &quot;51&quot;;break;
-			case 15: ret = &quot;52&quot;;break;
-			case 16: ret = &quot;53&quot;;break;
-			case 17: ret = &quot;54&quot;;break;
-			case 18: ret = &quot;55&quot;;break;
-
-			default: Vm.debug(&quot;Unknown cachetype: &quot; + num);
-			break;
-
-		} //switch
-		return ret;
+	public int transSelect(int num){
+		return CacheType.wayTypeNo[num];
 	}
-	
+
 	/**
 	 * if is addi -&gt; returns the respective AddiWpt
-	 * if is main -&gt; returns the respective MainWpt 
+	 * if is main -&gt; returns the respective MainWpt
 	 *
 	 */
 	public void createWptName() {
 		String wpt = inpWaypoint.getText().toUpperCase();
-		if (CacheType.isAddiWpt(transSelect(chcType.getInt())) &amp;&amp; 
+		if (CacheType.isAddiWpt(transSelect(chcType.getInt())) &amp;&amp;
 				(Global.mainTab.mainCache.startsWith(&quot;GC&quot;)||Global.mainTab.mainCache.startsWith(&quot;OC&quot;)||Global.mainTab.mainCache.startsWith(&quot;CW&quot;)) &amp;&amp;
 				wpt.startsWith(&quot;CW&quot;)) {
 			// for what was this?:
 			Global.mainTab.lastselected=Global.mainTab.mainCache; //I don't know exactly, but it's needed for creating a series of Addis
-			
+
 			inpWaypoint.setText(Global.getProfile().getNewAddiWayPointName(Global.mainTab.mainCache));
-		} 
-		if (!CacheType.isAddiWpt(transSelect(chcType.getInt())) &amp;&amp; !(wpt.startsWith(&quot;GC&quot;) 
+		}
+		if (!CacheType.isAddiWpt(transSelect(chcType.getInt())) &amp;&amp; !(wpt.startsWith(&quot;GC&quot;)
 				|| wpt.startsWith(&quot;OC&quot;) || wpt.startsWith(&quot;CW&quot;)) ) {
 			inpWaypoint.setText(Global.getProfile().getNewWayPointName());
 		}
 	}
-	
+
 	/**
 	*	Method to react to a user input.
 	*/
@@ -327,7 +257,7 @@
 				inpWaypoint.setText(inpWaypoint.getText().toUpperCase());
 			}
 			dirty_details = true;
-			needsTableUpdate  = true;
+			needsTableUpdate = true;
 			profile.hasUnsavedChanges=true;
 			if (ev.target==chcType) {
 				createWptName();
@@ -338,10 +268,9 @@
 				dirty_notes=true; // TODO I think this is redundant, because the notes are saved seperately by the notes screen itself
 				NotesScreen nsc = new NotesScreen(thisCache.getCacheDetails(true));
 				nsc.execute(this.getFrame(), Gui.CENTER_FRAME);
-				if(isBigScreen) mNotes.setText(thisCache.getCacheDetails(true).CacheNotes);
-			}
-			else if(ev.target == btnShowMap){
-				Global.mainTab.SwitchToMovingMap(thisCache.pos, true);
+				if(isBigScreen) mNotes.setText(thisCache.getCacheDetails(true).cacheNotes);
+			} else if(ev.target == btnShowMap){
+				Global.mainTab.switchToMovingMap(thisCache.pos, true);
 /*				try {
 					MapDetailForm mdf = new MapDetailForm(thisCache.wayPoint, pref, profile);
 					mdf.execute();
@@ -349,39 +278,35 @@
 					MessageBox tmp = new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(322,&quot;Kann Bild/Karte nicht finden&quot;)+&quot;: &quot;+e.getMessage(), MessageBox.OKB);
 					tmp.exec();
 				}
-	*/		}
-			else if(ev.target == btnShowBug){
+	*/		} else if(ev.target == btnShowBug){
 				//InfoScreen is = new InfoScreen(thisCache.Travelbugs.toHtml(), &quot;Travelbugs&quot;, false, pref);
 				//is.execute();
-				TravelbugInCacheScreen ts = new TravelbugInCacheScreen(thisCache.getCacheDetails(true).Travelbugs.toHtml(), &quot;Travelbugs&quot;);
+				TravelbugInCacheScreen ts = new TravelbugInCacheScreen(thisCache.getCacheDetails(true).travelbugs.toHtml(), &quot;Travelbugs&quot;);
 				ts.execute(this.getFrame(), Gui.CENTER_FRAME);
-			}
-			else if (ev.target == btnCenter){
+			} else /* if (ev.target == btnCenter){
 				CWPoint cp=new CWPoint(thisCache.LatLon);
 				if (!cp.isValid()){
-					MessageBox tmpMB = new MessageBox(MyLocale.getMsg(312,&quot;Error&quot;), MyLocale.getMsg(4111,&quot;Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM&quot;), FormBase.OKB);
+					MessageBox tmpMB = new MessageBox(MyLocale.getMsg(312,&quot;Error&quot;), MyLocale.getMsg(4111,&quot;Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM&quot;), MessageBox.OKB);
 					tmpMB.exec();
-				} else {				
+				} else {
 					pref.curCentrePt.set(cp);
 					Global.mainTab.updateBearDist();
 				}
 			}
-			else if (ev.target == btnAddDateTime){
+			else */ if (ev.target == btnAddDateTime){
 				dirty_notes=true;
-				String note = thisCache.getCacheDetails(true).CacheNotes;
+				String note = thisCache.getCacheDetails(true).cacheNotes;
 				Time dtm = new Time();
 				dtm.getTime();
 				dtm.setFormat(&quot;E dd.MM.yyyy '/' HH:mm&quot;);
 				if(note.length() &gt; 0)	note = note + &quot;\n&quot; + dtm.toString();
 				else 	note = note + dtm.toString();
 				note = note + &quot;\n&quot;;
-				thisCache.getCacheDetails(true).CacheNotes = note;
+				thisCache.getCacheDetails(true).cacheNotes = note;
 				thisCache.getCacheDetails(true).saveCacheDetails( Global.getProfile().dataDir);
-			}
-			else if (ev.target == btnAddPicture){
+			} else if (ev.target == btnAddPicture){
 				thisCache.getCacheDetails(true).addUserImage(profile);
-			}
-			else if(ev.target == btnBlack){
+			} else if(ev.target == btnBlack){
 				if(thisCache.is_black) {
 					thisCache.is_black = false;
 					btnBlack.image = imgBlackNo;
@@ -395,37 +320,32 @@
 				btnBlack.repaintNow();
 				dirty_details=true;
 				blackStatusChanged=true;
-			}
-			else if (ev.target == btnNewWpt){
+			} else if (ev.target == btnNewWpt){
 				CacheHolder ch = new CacheHolder();
-				ch.LatLon = thisCache.LatLon;
+				ch.latLon = thisCache.latLon;
 				ch.pos = new CWPoint( thisCache.pos );
-				ch.type = &quot;51&quot;;
+				ch.type = 51;
 				Global.mainTab.newWaypoint(ch);
-			}
-			else if (ev.target == btnGoto){
+			} else if (ev.target == btnGoto){
 				// TODO if something changed saveWpt();
 				Global.mainTab.gotoPoint(thisCache.pos);
-			}
-			else if (ev.target == btnWayLoc){
+			} else if (ev.target == btnWayLoc){
 				CWPoint coords = new CWPoint(btnWayLoc.getText(),CWPoint.CW);
 				CoordsScreen cs = new CoordsScreen(true);
 				cs.setFields(coords, CWPoint.CW);
-				if (cs.execute()== FormBase.IDOK){
+				if (cs.execute()== CoordsScreen.IDOK){
 					dirty_details=true;
 					coords = cs.getCoords();
 					thisCache.pos.set(coords);
 					btnWayLoc.setText(coords.toString());
-					thisCache.LatLon=coords.toString();
+					thisCache.latLon=coords.toString();
 					// If the current centre is valid, calculate the distance and bearing to it
 					CWPoint centre=Global.getPref().curCentrePt;
 					if (centre.isValid()) thisCache.calcDistance(centre);
 				}
-			}
-			else if (ev.target==btnFoundDate) {
-				//DateChooser.dayFirst=true;
-				DateTimeChooser dc=new DateTimeChooser(Vm.getLocale());
-				dc.title=MyLocale.getMsg(328,&quot;Date found&quot;); 
+			} else if (ev.target==btnFoundDate) {
+				DateTimeChooser dc=new DateTimeChooser(Vm.getLocale(), true);
+				dc.title=MyLocale.getMsg(328,&quot;Date found&quot;);
 				dc.setPreferredSize(240,240);
 				String foundDate=chcStatus.getText();
 				if (foundDate.startsWith(MyLocale.getMsg(318,&quot;Found&quot;)+&quot; &quot;)) foundDate=foundDate.substring(MyLocale.getMsg(318,&quot;Found&quot;).length()+1);
@@ -438,16 +358,15 @@
 					} catch(IllegalArgumentException e1) {}
 				};
 				dc.reset(t);
-				if (dc.execute()==ewe.ui.FormBase.IDOK) {
+				if (dc.execute()==eve.ui.FormBase.IDOK) {
 				  chcStatus.setText(MyLocale.getMsg(318,&quot;Found&quot;)+&quot; &quot;+Convert.toString(dc.year)+&quot;-&quot;+MyLocale.formatLong(dc.month,&quot;00&quot;)+&quot;-&quot;+MyLocale.formatLong(dc.day,&quot;00&quot;)+&quot; &quot;+dc.time);
 				  dirty_details=true;
 				  profile.hasUnsavedChanges=true;
 				}
-			}
-			else if (ev.target==btnHiddenDate) {
-				DateChooser.dayFirst=true;
-				DateChooser dc=new DateChooser(Vm.getLocale());
-				dc.title=MyLocale.getMsg(329,&quot;Hidden date&quot;); 
+			} else if (ev.target==btnHiddenDate) {
+				//DateTimeChooser.dayFirst=true;
+				DateTimeChooser dc=new DateTimeChooser(Vm.getLocale(),false);
+				dc.title=MyLocale.getMsg(329,&quot;Hidden date&quot;);
 				dc.setPreferredSize(240,240);
 				if (inpHidden.getText().length()==10)
 				try {
@@ -458,7 +377,7 @@
 				} catch (NumberFormatException e) {
 					dc.reset(new Time());
 				}
-				if (dc.execute()==ewe.ui.FormBase.IDOK) {
+				if (dc.execute()==eve.ui.FormBase.IDOK) {
 				  inpHidden.setText(Convert.toString(dc.year)+&quot;-&quot;+MyLocale.formatLong(dc.month,&quot;00&quot;)+&quot;-&quot;+MyLocale.formatLong(dc.day,&quot;00&quot;));
 				  dirty_details=true;
 				  profile.hasUnsavedChanges=true;
@@ -467,49 +386,49 @@
 			ev.consumed=true;
 		}
 	}
-	
+
 	public void saveDirtyWaypoint() {
-		// We have to update two objects: thisCache (a CacheHolderDetail) which contains 
+		// We have to update two objects: thisCache (a CacheHolderDetail) which contains
 		// the full cache which will be written to the cache.xml file AND
 		// the CacheHolder object which sits in cacheDB
 		  // Strip the found message if the status contains a date
-		if (chcStatus.getText().startsWith(MyLocale.getMsg(318,&quot;Found&quot;)) &amp;&amp; 
+		if (chcStatus.getText().startsWith(MyLocale.getMsg(318,&quot;Found&quot;)) &amp;&amp;
 				  chcStatus.getText().length()&gt;=MyLocale.getMsg(318,&quot;Found&quot;).length()+11)
-			  thisCache.CacheStatus = chcStatus.getText().substring(MyLocale.getMsg(318,&quot;Found&quot;).length()+1);
-		  else	  
-			  thisCache.CacheStatus = chcStatus.getText();
+			  thisCache.cacheStatus = chcStatus.getText().substring(MyLocale.getMsg(318,&quot;Found&quot;).length()+1);
+		  else
+			  thisCache.cacheStatus = chcStatus.getText();
 		  thisCache.is_found = chcStatus.getText().startsWith(MyLocale.getMsg(318,&quot;Found&quot;));
-		  thisCache.CacheOwner = inpOwner.getText().trim();
-		  thisCache.is_owned = thisCache.CacheStatus.equals(MyLocale.getMsg(320,&quot;Owner&quot;));
+		  thisCache.cacheOwner = inpOwner.getText().trim();
+		  thisCache.is_owned = thisCache.cacheStatus.equals(MyLocale.getMsg(320,&quot;Owner&quot;));
 		  // Avoid setting is_owned if alias is empty and username is empty
 		  if(thisCache.is_owned == false){
-			  thisCache.is_owned = (!pref.myAlias.equals(&quot;&quot;) &amp;&amp; pref.myAlias.equals(thisCache.CacheOwner)) || 
-					        (!pref.myAlias2.equals(&quot;&quot;) &amp;&amp; pref.myAlias2.equals(thisCache.CacheOwner));
+			  thisCache.is_owned = (!pref.myAlias.equals(&quot;&quot;) &amp;&amp; pref.myAlias.equals(thisCache.cacheOwner)) ||
+					        (!pref.myAlias2.equals(&quot;&quot;) &amp;&amp; pref.myAlias2.equals(thisCache.cacheOwner));
 		  }
 		  thisCache.is_black = blackStatus;
 		  String oldWaypoint=thisCache.wayPoint;
 		  thisCache.wayPoint = inpWaypoint.getText().toUpperCase().trim();
-		  thisCache.CacheSize = chcSize.getText();
+		  thisCache.setCacheSize(chcSize.getText());
 		  // If the waypoint does not have a name, give it one
-		  if (thisCache.wayPoint.equals(&quot;&quot;)) { 
+		  if (thisCache.wayPoint.equals(&quot;&quot;)) {
 			  thisCache.wayPoint=profile.getNewWayPointName();
 		  }
 		  //Don't allow single letter names=&gt; Problems in updateBearingDistance
 		  // This is a hack but faster than slowing down the loop in updateBearingDistance
 		  if (thisCache.wayPoint.length()&lt;2) thisCache.wayPoint+=&quot; &quot;;
-		  thisCache.CacheName = inpName.getText().trim();
-		  thisCache.LatLon = thisCache.pos.toString();
-		  thisCache.DateHidden = inpHidden.getText().trim();
-		  String oldType=thisCache.type;
+		  thisCache.cacheName = inpName.getText().trim();
+		  thisCache.latLon = thisCache.pos.toString();
+		  thisCache.dateHidden = inpHidden.getText().trim();
+		  int oldType=thisCache.type;
 		  thisCache.type = transSelect(chcType.getInt());
 		 // thisCache.saveCacheDetails(profile.dataDir); // this is redundant, because all changes affecting the details are immediately saved
 		  // Now update the table
 		  CacheHolder ch = thisCache; // TODO variable ch is redundant
-		  
+
 	  /* The references have to be rebuilt if:
 	   *   - the cachetype changed from addi-&gt;normal or normal-&gt;addi
-	   *   - the old cachetype or the new cachetype were 'addi' and 
-	   *     the waypointname has changed 
+	   *   - the old cachetype or the new cachetype were 'addi' and
+	   *     the waypointname has changed
 	   */
 	  if (CacheType.isAddiWpt(ch.type)!=CacheType.isAddiWpt(oldType) ||
 		 ((CacheType.isAddiWpt(ch.type) || CacheType.isAddiWpt(oldType)) &amp;&amp;
@@ -529,7 +448,7 @@
 				  }
 				  profile.buildReferences(); // TODO this takes quite long -&gt; use profile.setAddiRef instead
 			  } else {
-				  profile.buildReferences(); // we have to do this to release the link between the two caches  
+				  profile.buildReferences(); // we have to do this to release the link between the two caches
 			  }
 		  }
 		  // set status also on addi wpts
@@ -539,24 +458,21 @@
 		  setNeedsTableUpdate(false);
 		  if (thisCache.details != null) thisCache.details.hasUnsavedChanges = false;
 		  thisCache.getCacheDetails(true).hasUnsavedChanges = true;
-		  
-		  // Global.mainTab.tbP.refreshTable(); this is done in mainTab.onLeavingPanel
-		  ////Vm.debug(&quot;New status updated!&quot;);
 	}
 
 	private class TravelbugInCacheScreen extends Form {
-		
+
 		private DispPanel disp = new DispPanel();
-		private mButton btCancel;
+		private Button btCancel;
 		private TravelbugJourneyList tbjList;
-		
+
 		TravelbugInCacheScreen(String text, String title) {
-			this.setTitle(title);
+			this.title=title;
 			this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
 			disp.setHtml(text);
-			ScrollBarPanel sbp = new MyScrollBarPanel(disp, ScrollablePanel.NeverShowHorizontalScrollers);
+			ScrollBarPanel sbp = new MyScrollBarPanel(disp, ScrollBarPanel.NeverShowHorizontalScrollers);
 			this.addLast(sbp);
-			this.addLast(btCancel = new mButton(MyLocale.getMsg(3000,&quot;Close&quot;)),CellConstants.DONTSTRETCH, CellConstants.FILL);
+			this.addLast(btCancel = new Button(MyLocale.getMsg(3000,&quot;Close&quot;)),CellConstants.DONTSTRETCH, CellConstants.FILL);
 		}
 
 		public void onEvent(Event ev){
@@ -576,7 +492,7 @@
 				TBMenuItems[0]= mnuPickupTB = new MenuItem(MyLocale.getMsg(6016,&quot;Pick up Travelbug&quot;));
 				TBMenuItems[1]= mnuDropTB = new MenuItem(MyLocale.getMsg(6017,&quot;Drop Travelbug&quot;));
 				mnuPopup=new Menu(TBMenuItems,&quot;&quot;);
-			} 
+			}
 			public void penRightReleased(Point p){
 				setMenu(mnuPopup);
 				doShowMenu(p); // direct call (not through doMenu) is neccesary because it will exclude the whole table
@@ -586,8 +502,8 @@
 				doShowMenu(p);
 			}
 			public void popupMenuEvent(Object selectedItem){
-				if (selectedItem==mnuPickupTB) { 
-					Travelbug tb=TravelbugPickup.pickupTravelbug(thisCache.getCacheDetails(true).Travelbugs);	
+				if (selectedItem==mnuPickupTB) {
+					Travelbug tb=TravelbugPickup.pickupTravelbug(thisCache.getCacheDetails(true).travelbugs);
 					if (tb!=null) {
 						dirty_details=true;
 						// Get the list of my travelbugs
@@ -597,9 +513,9 @@
 						tbjList.addTbPickup(tb,Global.getProfile().name,thisCache.wayPoint);
 						tbjList.saveTravelbugsFile();
 						tbjList=null;
-						setHtml(thisCache.getCacheDetails(true).Travelbugs.toHtml());
+						setHtml(thisCache.getCacheDetails(true).travelbugs.toHtml());
 						repaint();
-						thisCache.has_bug=thisCache.getCacheDetails(true).Travelbugs.size()&gt;0;						
+						thisCache.has_bug=thisCache.getCacheDetails(true).travelbugs.size()&gt;0;
 					}
 				} else if (selectedItem==mnuDropTB) {
 					tbjList=new TravelbugJourneyList();
@@ -609,19 +525,92 @@
 					tbs.execute();
 					if (tbs.selectedItem&gt;=0) {
 						Travelbug tb=tbl.getTB(tbs.selectedItem);
-						thisCache.getCacheDetails(true).Travelbugs.add(tb);
+						thisCache.getCacheDetails(true).travelbugs.add(tb);
 						tbjList.addTbDrop(tb,Global.getProfile().name,thisCache.wayPoint);
 					}
 					tbjList.saveTravelbugsFile();
 					tbjList=null;
-					thisCache.has_bug=thisCache.getCacheDetails(true).Travelbugs.size()&gt;0;
-					setHtml(thisCache.getCacheDetails(true).Travelbugs.toHtml());
+					thisCache.has_bug=thisCache.getCacheDetails(true).travelbugs.size()&gt;0;
+					setHtml(thisCache.getCacheDetails(true).travelbugs.toHtml());
 					repaint();
 					dirty_details=true;
-				} else 
+				} else
 					super.popupMenuEvent(selectedItem);
 			}
-		}	
+		}
+
+
 	}
 
+//#############################################################################
+//  NotesScreen
+//#############################################################################
+
+	/**
+	*	This class displays a form to show and edit notes for a cache.
+	*/
+	private class NotesScreen extends Form{
+		TextPad wayNotes = new TextPad();
+		CacheHolderDetail thisCache = null;
+		Button addDateTime;
+		Button btSave = new Button(MyLocale.getMsg(127,&quot;Save&quot;));
+		Button cancelBtn = new Button(&quot;Cancel&quot;);
+		ScrollBarPanel sbp = new MyScrollBarPanel(wayNotes);
+
+		public NotesScreen(CacheHolderDetail ch){
+			this.title = &quot;Notes&quot;;
+			String imagesize = &quot;&quot;;
+			if (eve.sys.Device.isMobile() &amp;&amp; MyLocale.getScreenWidth() &gt;= 400) imagesize=&quot;_vga&quot;;
+			addDateTime = new Button(new Picture(&quot;date_time&quot;+imagesize+&quot;.png&quot;));
+			setPreferredSize(Global.getPref().myAppWidth, Global.getPref().myAppHeight);
+			this.resizeOnSIP = true;
+			thisCache = ch;
+			wayNotes.setText(thisCache.cacheNotes);
+			addLast(sbp.setTag(Control.TAG_SPAN, new Dimension(3,1)),CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
+			titleControls=new CellPanel();
+			titleControls.addNext(addDateTime,CellConstants.HSTRETCH,CellConstants.HFILL);
+			titleControls.addNext(cancelBtn,CellConstants.HSTRETCH,CellConstants.HFILL);
+			titleControls.addLast(btSave,CellConstants.HSTRETCH,CellConstants.HFILL);
+		}
+
+		public void onEvent(Event ev){
+			if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+				if (ev.target == addDateTime){
+					String note = wayNotes.getText();
+					Time dtm = new Time();
+					dtm.getTime();
+					dtm.setFormat(&quot;E dd.MM.yyyy '/' HH:mm&quot;);
+					if(note.length() &gt; 0)	note = note + &quot;\n&quot; + dtm.toString();
+					else 	note = note + dtm.toString();
+					note = note + &quot;\n&quot;;
+					wayNotes.setText(note);
+				}
+				if(ev.target == btSave){
+					thisCache.cacheNotes = wayNotes.getText();
+					thisCache.saveCacheDetails( Global.getProfile().dataDir);
+					this.close(0);
+				}
+				if(ev.target == cancelBtn){
+					if ( (!thisCache.cacheNotes.equals(wayNotes.getText())) ) {
+						if ( (new MessageBox(&quot;Warning&quot;, &quot;You will loose any changes made to the notes. Do you want to continue?&quot;
+								, MessageBox.YESB|MessageBox.NOB)).execute() == MessageBox.IDYES) {
+							this.close(0);
+						}
+					} else this.close(0); // no changes -&gt; exit without asking
+				}
+				if(ev.target == titleOK){
+					if ( (!thisCache.cacheNotes.equals(wayNotes.getText())) ) {
+						if ( (new MessageBox(&quot;Warning&quot;, &quot;Save changes made to the notes?&quot;
+								, MessageBox.YESB|MessageBox.NOB)).execute() == MessageBox.IDYES) {
+							thisCache.cacheNotes = wayNotes.getText();
+							thisCache.saveCacheDetails( Global.getProfile().dataDir);
+						}
+					}
+				}
+			}
+			super.onEvent(ev);
+		}
+	}
+
+
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/Filter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/Filter.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/Filter.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,12 +1,16 @@
-package CacheWolf;
-import ewe.ui.FormBase;
-import ewe.ui.MessageBox;
-import ewe.util.*;
-import ewe.sys.*;
-import ewe.io.*;
-import com.stevesoft.ewe_pat.*;
-import CacheWolf.imp.*;
+package cachewolf;
+import eve.ui.MessageBox;
+import java.util.*;
+import eve.sys.*;
+import java.io.*;
 
+
+import cachewolf.imp.*;
+import cachewolf.utils.Common;
+import cachewolf.utils.Matrix;
+
+import com.stevesoft.eve_pat.*;
+
 /**
 *	Class that actually filters the cache database.&lt;br&gt;
 *	The class that uses this filter must set the different public variables.
@@ -17,12 +21,12 @@
 	public static final int FILTER_ACTIVE=1;
 	public static final int FILTER_CACHELIST=2;
 	public static final int FILTER_MARKED_ONLY=3;
-	
+
 	/** Indicator whether a filter is inverted */
 	//public static boolean filterInverted=false;
 	/** Indicator whether a filter is active. Used in status bar to indicate filter status */
 	//public static int filterActive=FILTER_INACTIVE;
-	
+
 	private static final int SMALLER = -1;
 	private static final int EQUAL = 0;
 	private static final int GREATER = 1;
@@ -68,41 +72,41 @@
 	private static final int S = 32768;
 	private static final int ROSE_ALL= N|NNE|NE|ENE|E|ESE|SE|SSE|SSW|SW|WSW|W|WNW|NW|NNW|S;
 
-	private static final int MICRO=1; 
-	private static final int SMALL=2;	
-	private static final int REGULAR=4;	
-	private static final int LARGE=8;	
-	private static final int VERYLARGE=16;	
-	private static final int OTHER=32;	
+	private static final int MICRO=1;
+	private static final int SMALL=2;
+	private static final int REGULAR=4;
+	private static final int LARGE=8;
+	private static final int VERYLARGE=16;
+	private static final int OTHER=32;
 	private static final int SIZE_ALL=MICRO|SMALL|REGULAR|LARGE|VERYLARGE|OTHER;
-	
+
 	private int distdirec = 0;
 	private int diffdirec = 0;
 	private int terrdirec = 0;
-	
-	String[] byVec;
-	
-	
+
+	//String[] byVec;
+
+
 	private int roseMatchPattern;
 	private boolean hasRoseMatchPattern;
 	private int typeMatchPattern;
 	private boolean hasTypeMatchPattern;
 	private int sizeMatchPattern;
 	private boolean hasSizeMatchPattern;
-	
+
 	private boolean foundByMe;
 	private boolean notFoundByMe;
-	
+
 	private boolean ownedByMe;
 	private boolean notOwnedByMe;
 
 	double fscDist;
 	double fscTerr;
 	double fscDiff;
-	
+
 	private boolean archived = false;
 	private boolean notArchived = false;
-	
+
 	private boolean available=false;
 	private boolean notAvailable = false;
 	double pi180=java.lang.Math.PI / 180.0;
@@ -110,7 +114,7 @@
 	private long attributesYesPattern = 0;
 	private long attributesNoPattern = 0;
 	private int attributesChoice = 0;
-	
+
 	/**
 	*	Apply a route filter. Each waypoint is on a seperate line.
 	*	We use a regex method to allow for different formats of waypoints:
@@ -125,14 +129,15 @@
 		CWPoint cwp, fromPoint, toPoint;
 		CacheHolder ch;
 		double lat,lon, calcDistance = 0;
+		BufferedReader in=null;
 		try{
-			if((routeFile.getFullPath()).indexOf(&quot;.kml&quot;) &gt; 0){
-				KMLImporter kml = new KMLImporter(routeFile.getFullPath());
+			if((routeFile.getAbsolutePath()).indexOf(&quot;.kml&quot;) &gt; 0){
+				KMLImporter kml = new KMLImporter(routeFile.getAbsolutePath());
 				kml.importFile();
 				wayPoints = kml.getPoints();
 			} else {
-				FileReader in = new FileReader(routeFile);
-				String line; 
+				in = new BufferedReader(new FileReader(routeFile));
+				String line;
 				while((line = in.readLine()) != null){
 					rex.search(line);
 					/*
@@ -141,7 +146,7 @@
 					Vm.debug(rex.stringMatched(2));
 					Vm.debug(rex.stringMatched(3));
 					Vm.debug(rex.stringMatched(5));
-					
+
 					Vm.debug(rex.stringMatched(6));
 					Vm.debug(rex.stringMatched(7));
 					Vm.debug(rex.stringMatched(8));
@@ -152,12 +157,12 @@
 					if(rex.didMatch()){
 						lat = Convert.toDouble(rex.stringMatched(2)) + Convert.toDouble(rex.stringMatched(3))/60 + Convert.toDouble(rex.stringMatched(5))/60000;
 						lon = Convert.toDouble(rex.stringMatched(7)) + Convert.toDouble(rex.stringMatched(8))/60 + Convert.toDouble(rex.stringMatched(10))/60000;
-					
+
 						if(rex.stringMatched(1).equals(&quot;S&quot;) || rex.stringMatched(1).equals(&quot;s&quot;)) lat = -lat;
-						if(rex.stringMatched(6).equals(&quot;W&quot;) || rex.stringMatched(6).equals(&quot;w&quot;)) lon = -lon;	
-					
+						if(rex.stringMatched(6).equals(&quot;W&quot;) || rex.stringMatched(6).equals(&quot;w&quot;)) lon = -lon;
+
 						cwp = new CWPoint(lat, lon);
-						
+
 						wayPoints.add(cwp);
 					}
 				}
@@ -170,14 +175,12 @@
 			}
 			// for each segment of the route...
 			for(int z=0;z&lt;wayPoints.size()-1;z++){
-				fromPoint = new CWPoint();
-				toPoint = new CWPoint();
 				fromPoint = (CWPoint)wayPoints.get(z);
 				toPoint = (CWPoint)wayPoints.get(z+1);
 				//... go through the current cache database
 				for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
 					ch = (CacheHolder)cacheDB.get(i);
-					cwp = new CWPoint(ch.LatLon, CWPoint.CW);
+					cwp = new CWPoint(ch.latLon, CWPoint.CW);
 					calcDistance = DistToSegment(fromPoint, toPoint, cwp);
 					calcDistance = (calcDistance*180*60)/java.lang.Math.PI;
 					calcDistance = calcDistance * 1.852;
@@ -194,21 +197,25 @@
 				if(ch.is_filtered == false &amp;&amp; ch.in_range == false) ch.is_filtered = true;
 			}
 		}catch(FileNotFoundException fnex){
-			(new MessageBox(&quot;Error&quot;, &quot;File not found&quot;, FormBase.OKB)).execute();
+			(new MessageBox(&quot;Error&quot;, &quot;File not found&quot;, MessageBox.OKB)).execute();
 		}catch(IOException ioex){
-			(new MessageBox(&quot;Error&quot;, &quot;Problem reading file!&quot;, FormBase.OKB)).execute();
+			(new MessageBox(&quot;Error&quot;, &quot;Problem reading file!&quot;, MessageBox.OKB)).execute();
+		} finally {
+			try {
+				in.close();
+			} catch (Exception ex) {}
 		}
 	}
-	
+
 	/**
 	*	Method to calculate the distance of a point to a segment
 	*/
 	private double DistToSegment(CWPoint fromPoint, CWPoint toPoint, CWPoint cwp){
-		
+
 		/*
 		double XTD = 0;
 		double dist = 0;
-		
+
 		double crs_AB = fromPoint.getBearing(toPoint);
 		crs_AB = crs_AB * java.lang.Math.PI / 180;
 		double crs_AD = fromPoint.getBearing(cwp);
@@ -242,9 +249,9 @@
 		if(dot2 &gt; 0) return Matrix.dist(X1,Y1,px,py);
 		dist = java.lang.Math.abs(dist);
 		return dist;
-		
+
 	}
-	
+
 	/**
 	 * Set the filter from the filter data stored in the profile
 	 * (the filterscreen also updates the profile)
@@ -309,19 +316,19 @@
 		if (filterSize.charAt(4) == '1') sizeMatchPattern|=VERYLARGE;
 		if (filterSize.charAt(5) == '1') sizeMatchPattern|=OTHER;
 		hasSizeMatchPattern=sizeMatchPattern!=SIZE_ALL;
-		distdirec = profile.filterDist.charAt(0) == 'L' ? SMALLER : GREATER; 
+		distdirec = profile.filterDist.charAt(0) == 'L' ? SMALLER : GREATER;
 		fscDist = Common.parseDouble(profile.filterDist.substring(1));  // Distance
-		diffdirec = profile.filterDiff.charAt(0) == 'L' ? SMALLER : 
+		diffdirec = profile.filterDiff.charAt(0) == 'L' ? SMALLER :
 					(profile.filterDiff.charAt(0) == '=' ? EQUAL : GREATER );
 		fscDiff = Common.parseDouble(profile.filterDiff.substring(1));  // Difficulty
-		terrdirec = profile.filterTerr.charAt(0) == 'L' ? SMALLER : 
+		terrdirec = profile.filterTerr.charAt(0) == 'L' ? SMALLER :
 				(profile.filterTerr.charAt(0) == '=' ? EQUAL : GREATER );
 		fscTerr = Common.parseDouble(profile.filterTerr.substring(1));  // Terrain
 		attributesYesPattern = profile.filterAttrYes;
 		attributesNoPattern = profile.filterAttrNo;
 		attributesChoice = profile.filterAttrChoice;
 	}
-	
+
 	/**
 	*	Apply the filter. Caches that match a criteria are flagged
 	*	is_filtered = true. The table model is responsible for displaying or
@@ -357,27 +364,27 @@
 			if (hasTypeMatchPattern) { // Only do the checks if we have a filter
 				cacheTypePattern = 0;
 				// As each cache can only have one type, we can use else if and set the type
-				if (ch.type.equals(&quot;0&quot;)) cacheTypePattern = CUSTOM;
-				else if(ch.type.equals(&quot;2&quot;)) cacheTypePattern = TRADITIONAL;
-				else if(ch.type.equals(&quot;3&quot;)) cacheTypePattern = MULTI;
-				else if(ch.type.equals(&quot;4&quot;)) cacheTypePattern = VIRTUAL;
-				else if(ch.type.equals(&quot;5&quot;)) cacheTypePattern = LETTER;
-				else if(ch.type.equals(&quot;6&quot;)) cacheTypePattern = EVENT;
-				else if(ch.type.equals(&quot;8&quot;)) cacheTypePattern = MYSTERY;
-				else if(ch.type.equals(&quot;11&quot;)) cacheTypePattern = WEBCAM;
-				else if(ch.type.equals(&quot;12&quot;)) cacheTypePattern = LOCLESS;
-				else if(ch.type.equals(&quot;137&quot;))cacheTypePattern = EARTH;
-				else if(ch.type.equals(&quot;453&quot;))cacheTypePattern = MEGA;
-				else if(ch.type.equals(&quot;50&quot;))cacheTypePattern = PARKING;
-				else if(ch.type.equals(&quot;51&quot;))cacheTypePattern = STAGE;
-				else if(ch.type.equals(&quot;52&quot;))cacheTypePattern = QUESTION;
-				else if(ch.type.equals(&quot;53&quot;))cacheTypePattern = FINAL;
-				else if(ch.type.equals(&quot;54&quot;))cacheTypePattern = TRAILHEAD;
-				else if(ch.type.equals(&quot;55&quot;))cacheTypePattern = REFERENCE;
-				else if(ch.type.equals(&quot;13&quot;))cacheTypePattern = CITO;
-				else if(ch.type.equals(&quot;1858&quot;))cacheTypePattern = WHERIGO;
+				if (ch.type==0) cacheTypePattern = CUSTOM;
+				else if(ch.type==2) cacheTypePattern = TRADITIONAL;
+				else if(ch.type==3) cacheTypePattern = MULTI;
+				else if(ch.type==4) cacheTypePattern = VIRTUAL;
+				else if(ch.type==5) cacheTypePattern = LETTER;
+				else if(ch.type==6) cacheTypePattern = EVENT;
+				else if(ch.type==8) cacheTypePattern = MYSTERY;
+				else if(ch.type==11) cacheTypePattern = WEBCAM;
+				else if(ch.type==12) cacheTypePattern = LOCLESS;
+				else if(ch.type==137)cacheTypePattern = EARTH;
+				else if(ch.type==453)cacheTypePattern = MEGA;
+				else if(ch.type==50)cacheTypePattern = PARKING;
+				else if(ch.type==51)cacheTypePattern = STAGE;
+				else if(ch.type==52)cacheTypePattern = QUESTION;
+				else if(ch.type==53)cacheTypePattern = FINAL;
+				else if(ch.type==54)cacheTypePattern = TRAILHEAD;
+				else if(ch.type==55)cacheTypePattern = REFERENCE;
+				else if(ch.type==13)cacheTypePattern = CITO;
+				else if(ch.type==1858)cacheTypePattern = WHERIGO;
 				if ((cacheTypePattern &amp; typeMatchPattern) == 0) { ch.is_filtered=true; continue; }
-			}			
+			}
 			///////////////////////////////
 			// Filter criterium 2: Bearing from centre
 			///////////////////////////////
@@ -408,12 +415,12 @@
 					else cacheRosePattern = WSW;
 				}
 				if ((cacheRosePattern &amp; roseMatchPattern) == 0) { ch.is_filtered=true; continue; }
-			}			
+			}
 			///////////////////////////////
 			// Filter criterium 3: Distance
 			///////////////////////////////
 			if(fscDist&gt;0.0){
-				dummyd1 = Common.parseDouble(ch.distance.substring(0,ch.distance.length()-3)); 
+				dummyd1 = Common.parseDouble(ch.distance.substring(0,ch.distance.length()-3));
 				if(distdirec == SMALLER &amp;&amp; dummyd1 &gt; fscDist)  { ch.is_filtered=true; continue; }
 				if(distdirec == GREATER &amp;&amp; dummyd1 &lt; fscDist)  { ch.is_filtered=true; continue; }
 			}
@@ -450,7 +457,7 @@
 			///////////////////////////////
 			if((ch.is_owned &amp;&amp; !ownedByMe) ||
 			   (!ch.is_owned &amp;&amp; !notOwnedByMe)) { ch.is_filtered=true; continue; }
-			
+
 			///////////////////////////////
 			// Filter criterium 8: Archived
 			///////////////////////////////
@@ -467,11 +474,11 @@
 			///////////////////////////////
 			if (hasSizeMatchPattern) {
 				cacheSizePattern=0;
-				if (ch.CacheSize.startsWith(&quot;M&quot;)) cacheSizePattern = MICRO;
-				else if (ch.CacheSize.startsWith(&quot;S&quot;)) cacheSizePattern = SMALL;
-				else if (ch.CacheSize.startsWith(&quot;R&quot;)) cacheSizePattern = REGULAR;
-				else if (ch.CacheSize.startsWith(&quot;L&quot;)) cacheSizePattern = LARGE;
-				else if (ch.CacheSize.startsWith(&quot;V&quot;)) cacheSizePattern = VERYLARGE;
+				if (ch.cacheSize==1) cacheSizePattern = MICRO;
+				else if (ch.cacheSize==2) cacheSizePattern = SMALL;
+				else if (ch.cacheSize==3) cacheSizePattern = REGULAR;
+				else if (ch.cacheSize==4) cacheSizePattern = LARGE;
+				else if (ch.cacheSize==5) cacheSizePattern = VERYLARGE;
 				else cacheSizePattern = OTHER;
 				if ((cacheSizePattern &amp; sizeMatchPattern) == 0) { ch.is_filtered=true; continue; }
 			}
@@ -509,7 +516,7 @@
 				}
 			}
 		} // for
-		// Ensure that for all main caches that are filtered, the addis are also filtered independently of 
+		// Ensure that for all main caches that are filtered, the addis are also filtered independently of
 		// the filter status of the addi
 		if ((typeMatchPattern &amp; TYPE_MAIN) != 0){ //exception: don't filter out correxpnding Addis, if only Addis are enabled
 			for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
@@ -518,13 +525,20 @@
 					// We have found an addi, filte it if its parent is filtered
 					ch.is_filtered|=ch.mainCache.is_filtered;
 				}
-			}			
+			}
 		}
+		for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+			ch = (CacheHolder)cacheDB.get(i);
+			if (ch.mainCache!=null) {
+				// We have found an addi, filte it if its parent is filtered
+				ch.is_filtered|=ch.mainCache.is_filtered;
+			}
+		}
 		Global.getProfile().filterActive=FILTER_ACTIVE;
 		Global.getProfile().filterInverted=false;
 		Global.getProfile().hasUnsavedChanges=true;
 	}
-	
+
 	/**
 	*	Invert is_filtered flag on all caches
 	*/
@@ -544,7 +558,7 @@
 		Global.getProfile().filterInverted=!Global.getProfile().filterInverted;
 		Global.getProfile().hasUnsavedChanges=true;
 	}
-	
+
 	/**
 	*	Clear the is_filtered flag from the cache database.
 	*/
@@ -576,4 +590,3 @@
 
 }
 
-

Modified: experiments/engywuck/hist-test/src/cachewolf/FilterScreen.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/FilterScreen.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/FilterScreen.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,9 +1,9 @@
-package CacheWolf;
-import ewe.ui.*;
-import ewe.io.*;
-import ewe.fx.*;
-import ewe.sys.*;
-import ewe.filechooser.*;
+package cachewolf;
+import eve.ui.*;
+import eve.ui.event.*;
+import eve.fx.*;
+import eve.sys.*;
+import eve.ui.filechooser.*;
 
 /**
 *	This class displays a form that the user uses to set the filter criteria.
@@ -13,23 +13,23 @@
 	private static final Color COLOR_FILTERINACTIVE=new Color(190,190,190);
 	private static final Color COLOR_FILTERACTIVE=new Color(0,255,0);
 	private static final Color COLOR_FILTERALL=new Color(255,0,0); // Red
-    	
-	private mButton btnCancel, btnApply,btnRoute,
-					btnBearing,btnTypes,btnAttributes,btnRatings,btnContainer,btnSearch,btnAddi, btnSelect,btnDeselect,btnCacheAttributes;
-	
-	private mChoice chcDist, chcDiff, chcTerr, chcAttrib;
-	private mCheckBox chkFound, chkNotFound, chkTrad, chkVirtual, chkEvent, chkEarth, chkMega,
+
+	private Button btnCancel, btnApply,
+					btnBearing,btnTypes,btnAttributes,btnRatings,btnContainer,btnAddi, btnSelect,btnDeselect,btnCacheAttributes;
+	//private Button btnSearch;
+	private Choice chcDist, chcDiff, chcTerr, chcAttrib;
+	private CheckBox chkFound, chkNotFound, chkTrad, chkVirtual, chkEvent, chkEarth, chkMega,
 					  chkOwned, chkNotOwned, chkMulti, chkLetter, chkWebcam, chkMystery, chkLocless,
 	                  chkCustom,chkParking,	chkStage, chkQuestion, chkFinal, chkTrailhead, chkReference,
 					  chkMicro,chkSmall,chkRegular,chkLarge,chkVeryLarge,chkOther,chkCito,
 	                  chkArchived,chkNotArchived, chkAvailable,chkNotAvailable,
 					  chkNW, chkNNW , chkN , chkNNE, chkNE, chkENE, chkE, chkESE, chkSE, chkSSE, chkS,
 					  chkSSW, chkSW, chkWSW, chkW, chkWNW,chkWherigo;
-	
-	private mInput inpDist, inpTerr, inpDiff;
 
+	private Input inpDist, inpTerr, inpDiff;
+
 	AttributesSelector attV;
-	
+
 	private CellPanel pnlBearDist=new CellPanel();
 	private CellPanel pnlAttributes=new CellPanel();
 	private CellPanel pnlRatings=new CellPanel();
@@ -37,7 +37,6 @@
 	private CellPanel pnlContainer=new CellPanel();
 	private CellPanel pnlSearch=new CellPanel();
 	private CellPanel pnlRose = new CellPanel();
-	private CellPanel pnlButtons=new CellPanel();
 	private CellPanel pnlAddi=new CellPanel();
 	private CellPanel pnlCacheAttributes=new CellPanel();
 	private CardPanel cp=new CardPanel();
@@ -47,47 +46,51 @@
 	// If the addi wpt filter is a mixture of true/false, the bg is grey
 	// Thus the addi filter can be set in one of two ways: Using the single checkbox with all the other
 	// attributes, or using the multiple checkboxes for each addi waypoint type
-	private class myChkBox extends mCheckBox {
+	private class myChkBox extends CheckBox {
 		Color bgColor=Color.White;
 		myChkBox(String s) {super(s); }
 		public void doPaintSquare(Graphics g) {
 			int h = height;
 			g.setColor(bgColor);
+			int sp = 2*boxWidth/15;
 			int bx = text.length() == 0 ? 0 : 2;
 			int by = text.length() == 0 ? 0 : (h-boxWidth)/2+1;
 			g.fillRect(bx+2,by+2,boxWidth-4,boxWidth-4);
 			if (state || pressState){
 				Color c = Color.LightGray;
 				if (!pressState){
-					if (!state) 
+					if (!state)
 						c=bgColor;
-					else 
+					else
 						c=Color.Black;
 				}
-				Pen oldpen = g.setPen(new Pen(c,Pen.SOLID,2));
+				Pen oldPen = g.getPen(Pen.getCached());
+				g.changePen(c,Pen.SOLID,sp);
+//				Pen oldpen = g.setPen(new Pen(c,Pen.SOLID,2));
 				g.drawLine(bx+4,by+boxWidth-5,bx+boxWidth-5,by+4);
 				g.drawLine(bx+4,by+boxWidth-5,bx+4,by+boxWidth-10);
 //				g.drawLine(bx+3,by+3,bx+boxWidth-5,by+boxWidth-5);
 //				g.drawLine(bx+3,by+boxWidth-5,bx+boxWidth-5,by+3);
-				g.setPen(oldpen);
+				g.set(oldPen);
+				oldPen.cache();
 			}
-			g.draw3DRect(new Rect(bx,by,boxWidth,boxWidth),	ButtonObject.checkboxEdge,true,null,Color.DarkGray);
-		}		
+			g.draw3DRect(new Rect(bx,by,boxWidth,boxWidth),	GuiStyle.checkboxEdge,true,null,Color.DarkGray);
+		}
 	}
 	private myChkBox addiWptChk;
-	
-	private mButton addImg(String imgName) {
-		mButton mb=new mButton(new mImage(imgName)); mb.borderWidth=0; mb.modify(NotEditable|PreferredSizeOnly,0);
+
+	private Button addImg(String imgName) {
+		Button mb=new Button(new Picture(imgName)); mb.borderWidth=0; mb.modify(NotEditable|PreferredSizeOnly,0);
 		return mb;
 	}
 	private void addTitle(CellPanel c, String title) {
-		mLabel lblTitle;
-		c.addLast(lblTitle=new mLabel(title),HSTRETCH,FILL|CENTER);
-		lblTitle.backGround=new Color(127,127,127); 
-		lblTitle.foreGround=Color.White; 
-		lblTitle.setTag(INSETS,new Insets(2,0,4,0));
+		Label lblTitle;
+		c.addLast(lblTitle=new Label(title),HSTRETCH,FILL|CENTER);
+		lblTitle.backGround=new Color(127,127,127);
+		lblTitle.foreGround=Color.White;
+		lblTitle.setTag(TAG_INSETS,new Insets(2,0,4,0));
 	}
-	
+
 	public FilterScreen() {
 		this.title = MyLocale.getMsg(700,&quot;Set Filter&quot;);
 
@@ -95,109 +98,109 @@
 		// Panel 1 - Bearing &amp; Distance
 		//////////////////////////
 		addTitle(pnlBearDist,MyLocale.getMsg(714,&quot;Bearings &amp; Distance&quot;));
-		pnlBearDist.addNext(new mLabel(MyLocale.getMsg(701,&quot;Distance: &quot;)),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		pnlBearDist.addNext(chcDist = new mChoice(new String[]{&quot;&lt;=&quot;, &quot;&gt;=&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		pnlBearDist.addLast(inpDist = new mInput(),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		pnlBearDist.addLast(new mLabel(&quot;&quot;));
-		pnlRose.addNext(chkNW = new mCheckBox(&quot;NW&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
-		pnlRose.addNext(chkNNW = new mCheckBox(&quot;NNW&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
-		pnlRose.addNext(chkN = new mCheckBox(&quot;N&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
-		pnlRose.addLast(chkNNE = new mCheckBox(&quot;NNE&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
-		
-		pnlRose.addNext(chkNE = new mCheckBox(&quot;NE&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
-		pnlRose.addNext(chkENE = new mCheckBox(&quot;ENE&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
-		pnlRose.addNext(chkE = new mCheckBox(&quot;E &quot;),CellConstants.HSTRETCH, CellConstants.FILL);
-		pnlRose.addLast(chkESE = new mCheckBox(&quot;ESE&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlBearDist.addNext(new Label(MyLocale.getMsg(701,&quot;Distance: &quot;)),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlBearDist.addNext(chcDist = new Choice(new String[]{&quot;&lt;=&quot;, &quot;&gt;=&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlBearDist.addLast(inpDist = new Input(),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlBearDist.addLast(new Label(&quot;&quot;));
+		pnlRose.addNext(chkNW = new CheckBox(&quot;NW&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkNNW = new CheckBox(&quot;NNW&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkN = new CheckBox(&quot;N&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addLast(chkNNE = new CheckBox(&quot;NNE&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
 
-		pnlRose.addNext(chkSE = new mCheckBox(&quot;SE&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
-		pnlRose.addNext(chkSSE = new mCheckBox(&quot;SSE&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
-		pnlRose.addNext(chkS = new mCheckBox(&quot;S&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
-		pnlRose.addLast(chkSSW = new mCheckBox(&quot;SSW&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkNE = new CheckBox(&quot;NE&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkENE = new CheckBox(&quot;ENE&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkE = new CheckBox(&quot;E &quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addLast(chkESE = new CheckBox(&quot;ESE&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
 
-		pnlRose.addNext(chkSW = new mCheckBox(&quot;SW&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
-		pnlRose.addNext(chkWSW = new mCheckBox(&quot;WSW&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
-		pnlRose.addNext(chkW = new mCheckBox(&quot;W &quot;),CellConstants.HSTRETCH, CellConstants.FILL);
-		pnlRose.addLast(chkWNW = new mCheckBox(&quot;WNW&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
-		pnlRose.addNext(btnDeselect=new mButton(MyLocale.getMsg(716,&quot;Deselect all&quot;)),CellConstants.HSTRETCH, CellConstants.FILL);
-		btnDeselect.setTag(SPAN,new Dimension(2,1));
-		pnlRose.addLast(btnSelect=new mButton(MyLocale.getMsg(717,&quot;Select all&quot;)),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkSE = new CheckBox(&quot;SE&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkSSE = new CheckBox(&quot;SSE&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkS = new CheckBox(&quot;S&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addLast(chkSSW = new CheckBox(&quot;SSW&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+
+		pnlRose.addNext(chkSW = new CheckBox(&quot;SW&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkWSW = new CheckBox(&quot;WSW&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkW = new CheckBox(&quot;W &quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addLast(chkWNW = new CheckBox(&quot;WNW&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(btnDeselect=new Button(MyLocale.getMsg(716,&quot;Deselect all&quot;)),CellConstants.HSTRETCH, CellConstants.FILL);
+		btnDeselect.setTag(TAG_SPAN,new Dimension(2,1));
+		pnlRose.addLast(btnSelect=new Button(MyLocale.getMsg(717,&quot;Select all&quot;)),CellConstants.HSTRETCH, CellConstants.FILL);
 		pnlBearDist.addLast(pnlRose, CellConstants.STRETCH,CellConstants.FILL);
-		
+
 		//////////////////////////
 		// Panel 2 - Cache attributes
 		//////////////////////////
 		addTitle(pnlAttributes,MyLocale.getMsg(720,&quot;Status&quot;));
-		mLabel lblTitleAtt; 
-		pnlAttributes.addLast(lblTitleAtt=new mLabel(MyLocale.getMsg(715,&quot;Show all caches with status:&quot;)),HSTRETCH,FILL);
-		lblTitleAtt.setTag(SPAN,new Dimension(2,1));
-		pnlAttributes.addNext(chkArchived = new mCheckBox(MyLocale.getMsg(710,&quot;Archived&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		pnlAttributes.addLast(chkNotArchived = new mCheckBox(MyLocale.getMsg(729,&quot;Nicht archiviert&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		
-		pnlAttributes.addNext(chkAvailable = new mCheckBox(MyLocale.getMsg(730,&quot;Suchbar&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		pnlAttributes.addLast(chkNotAvailable = new mCheckBox(MyLocale.getMsg(711,&quot;Not available&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		
-		pnlAttributes.addNext(chkFound = new mCheckBox(MyLocale.getMsg(703,&quot;Found&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		pnlAttributes.addLast(chkNotFound = new mCheckBox(MyLocale.getMsg(731,&quot;Noch nicht gefunden&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		
-		pnlAttributes.addNext(chkOwned = new mCheckBox(MyLocale.getMsg(707,&quot;Owned&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		pnlAttributes.addLast(chkNotOwned = new mCheckBox(MyLocale.getMsg(732,&quot;Anderer Besitzer&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		Label lblTitleAtt;
+		pnlAttributes.addLast(lblTitleAtt=new Label(MyLocale.getMsg(715,&quot;Show all caches with status:&quot;)),HSTRETCH,FILL);
+		lblTitleAtt.setTag(TAG_SPAN,new Dimension(2,1));
+		pnlAttributes.addNext(chkArchived = new CheckBox(MyLocale.getMsg(710,&quot;Archived&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addLast(chkNotArchived = new CheckBox(MyLocale.getMsg(729,&quot;Nicht archiviert&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
 
+		pnlAttributes.addNext(chkAvailable = new CheckBox(MyLocale.getMsg(730,&quot;Suchbar&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addLast(chkNotAvailable = new CheckBox(MyLocale.getMsg(711,&quot;Not available&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		pnlAttributes.addNext(chkFound = new CheckBox(MyLocale.getMsg(703,&quot;Found&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addLast(chkNotFound = new CheckBox(MyLocale.getMsg(731,&quot;Noch nicht gefunden&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		pnlAttributes.addNext(chkOwned = new CheckBox(MyLocale.getMsg(707,&quot;Owned&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addLast(chkNotOwned = new CheckBox(MyLocale.getMsg(732,&quot;Anderer Besitzer&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
 		//////////////////////////
 		// Panel 3 - Cache ratings
 		//////////////////////////
 		addTitle(pnlRatings,MyLocale.getMsg(718,&quot;Cache ratings&quot;));
-		pnlRatings.addNext(new mLabel(MyLocale.getMsg(702,&quot;Difficulty: &quot;)),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		pnlRatings.addNext(chcDiff = new mChoice(new String[]{&quot;&lt;=&quot;,&quot;=&quot;, &quot;&gt;=&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		//pnlRatings.addLast(difIn = new mChoice(new String[]{&quot;1.0&quot;, &quot;1.5&quot;, &quot;2.0&quot;, &quot;2.5&quot;, &quot;3.0&quot;, &quot;3.5&quot;, &quot;4.0&quot;, &quot;4.5&quot;, &quot;5.0&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		pnlRatings.addLast(inpDiff = new mInput(),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		
-		pnlRatings.addNext(new mLabel(&quot;Terrain: &quot;),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		pnlRatings.addNext(chcTerr = new mChoice(new String[]{&quot;&lt;=&quot;, &quot;=&quot;, &quot;&gt;=&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		//pnlRatings.addLast(terrIn = new mChoice(new String[]{&quot;1.0&quot;, &quot;1.5&quot;, &quot;2.0&quot;, &quot;2.5&quot;, &quot;3.0&quot;, &quot;3.5&quot;, &quot;4.0&quot;, &quot;4.5&quot;, &quot;5.0&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		pnlRatings.addLast(inpTerr = new mInput(),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlRatings.addNext(new Label(MyLocale.getMsg(702,&quot;Difficulty: &quot;)),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlRatings.addNext(chcDiff = new Choice(new String[]{&quot;&lt;=&quot;,&quot;=&quot;, &quot;&gt;=&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		//pnlRatings.addLast(difIn = new Choice(new String[]{&quot;1.0&quot;, &quot;1.5&quot;, &quot;2.0&quot;, &quot;2.5&quot;, &quot;3.0&quot;, &quot;3.5&quot;, &quot;4.0&quot;, &quot;4.5&quot;, &quot;5.0&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlRatings.addLast(inpDiff = new Input(),CellConstants.DONTSTRETCH, CellConstants.FILL);
 
+		pnlRatings.addNext(new Label(&quot;Terrain: &quot;),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlRatings.addNext(chcTerr = new Choice(new String[]{&quot;&lt;=&quot;, &quot;=&quot;, &quot;&gt;=&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		//pnlRatings.addLast(terrIn = new Choice(new String[]{&quot;1.0&quot;, &quot;1.5&quot;, &quot;2.0&quot;, &quot;2.5&quot;, &quot;3.0&quot;, &quot;3.5&quot;, &quot;4.0&quot;, &quot;4.5&quot;, &quot;5.0&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlRatings.addLast(inpTerr = new Input(),CellConstants.DONTSTRETCH, CellConstants.FILL);
+
 		//////////////////////////
 		// Panel 4 - Cache types
 		//////////////////////////
-		
+
 		addTitle(pnlCacheTypes,MyLocale.getMsg(719,&quot;Cache types&quot;));
 		pnlCacheTypes.addNext(addImg(&quot;2.png&quot;));
-		pnlCacheTypes.addNext(chkTrad = new mCheckBox(&quot;Traditonal&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		
+		pnlCacheTypes.addNext(chkTrad = new CheckBox(&quot;Traditonal&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
 		pnlCacheTypes.addNext(addImg(&quot;3.png&quot;));
-		pnlCacheTypes.addLast(chkMulti = new mCheckBox(&quot;Multi&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		
+		pnlCacheTypes.addLast(chkMulti = new CheckBox(&quot;Multi&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
 		pnlCacheTypes.addNext(addImg(&quot;4.png&quot;));
-		pnlCacheTypes.addNext(chkVirtual = new mCheckBox(&quot;Virtual&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		
+		pnlCacheTypes.addNext(chkVirtual = new CheckBox(&quot;Virtual&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
 		pnlCacheTypes.addNext(addImg(&quot;5.png&quot;));
-		pnlCacheTypes.addLast(chkLetter = new mCheckBox(&quot;Letterbox&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		
+		pnlCacheTypes.addLast(chkLetter = new CheckBox(&quot;Letterbox&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
 		pnlCacheTypes.addNext(addImg(&quot;6.png&quot;));
-		pnlCacheTypes.addNext(chkEvent = new mCheckBox(&quot;Event&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		
+		pnlCacheTypes.addNext(chkEvent = new CheckBox(&quot;Event&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
 		pnlCacheTypes.addNext(addImg(&quot;11.png&quot;));
-		pnlCacheTypes.addLast(chkWebcam = new mCheckBox(&quot;Webcam&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		
+		pnlCacheTypes.addLast(chkWebcam = new CheckBox(&quot;Webcam&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
 		pnlCacheTypes.addNext(addImg(&quot;8.png&quot;));
-		pnlCacheTypes.addNext(chkMystery = new mCheckBox(&quot;Mystery&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		
+		pnlCacheTypes.addNext(chkMystery = new CheckBox(&quot;Mystery&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
 		pnlCacheTypes.addNext(addImg(&quot;137.png&quot;));
-		pnlCacheTypes.addLast(chkEarth = new mCheckBox(&quot;Earth&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		
+		pnlCacheTypes.addLast(chkEarth = new CheckBox(&quot;Earth&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
 		pnlCacheTypes.addNext(addImg(&quot;12.png&quot;));
-		pnlCacheTypes.addNext(chkLocless = new mCheckBox(&quot;Locationless&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		
+		pnlCacheTypes.addNext(chkLocless = new CheckBox(&quot;Locationless&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
 		pnlCacheTypes.addNext(addImg(&quot;453.png&quot;));
-		pnlCacheTypes.addLast(chkMega = new mCheckBox(&quot;Mega-Ev.&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		
+		pnlCacheTypes.addLast(chkMega = new CheckBox(&quot;Mega-Ev.&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
 		pnlCacheTypes.addNext(addImg(&quot;13.png&quot;));
-		pnlCacheTypes.addNext(chkCito = new mCheckBox(&quot;Cito-Ev.&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		
-		//pnlCacheTypes.addLast(addiWptChk = new mCheckBox(&quot;Add. Wpt&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		//pnlCacheTypes.addLast(new mLabel(&quot;&quot;));
+		pnlCacheTypes.addNext(chkCito = new CheckBox(&quot;Cito-Ev.&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		//pnlCacheTypes.addLast(addiWptChk = new CheckBox(&quot;Add. Wpt&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		//pnlCacheTypes.addLast(new Label(&quot;&quot;));
 		pnlCacheTypes.addNext(addImg(&quot;0.png&quot;));
-		pnlCacheTypes.addLast(chkCustom = new mCheckBox(&quot;Custom&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlCacheTypes.addLast(chkCustom = new CheckBox(&quot;Custom&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
 
 		pnlCacheTypes.addNext(addImg(&quot;1858.png&quot;));
 		pnlCacheTypes.addNext(chkWherigo = new myChkBox(&quot;WherIGo&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
@@ -211,72 +214,72 @@
 		//////////////////////////
 		addTitle(pnlAddi,MyLocale.getMsg(726,&quot;Additional waypoints&quot;));
 		pnlAddi.addNext(addImg(&quot;pkg.png&quot;));
-		pnlAddi.addNext(chkParking = new mCheckBox(&quot;Parking&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAddi.addNext(chkParking = new CheckBox(&quot;Parking&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		pnlAddi.addNext(addImg(&quot;stage.png&quot;));
-		pnlAddi.addLast(chkStage = new mCheckBox(&quot;Stage&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAddi.addLast(chkStage = new CheckBox(&quot;Stage&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		pnlAddi.addNext(addImg(&quot;puzzle.png&quot;));
-		pnlAddi.addNext(chkQuestion = new mCheckBox(&quot;Question&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAddi.addNext(chkQuestion = new CheckBox(&quot;Question&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		pnlAddi.addNext(addImg(&quot;flag.png&quot;));
-		pnlAddi.addLast(chkFinal = new mCheckBox(&quot;Final&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAddi.addLast(chkFinal = new CheckBox(&quot;Final&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		pnlAddi.addNext(addImg(&quot;trailhead.png&quot;));
-		pnlAddi.addNext(chkTrailhead = new mCheckBox(&quot;Trailhead&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAddi.addNext(chkTrailhead = new CheckBox(&quot;Trailhead&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		pnlAddi.addNext(addImg(&quot;waypoint.png&quot;));
-		pnlAddi.addLast(chkReference = new mCheckBox(&quot;Reference&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
-        pnlAddi.addLast(new mLabel(&quot;&quot;),VSTRETCH,FILL);		
+		pnlAddi.addLast(chkReference = new CheckBox(&quot;Reference&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+        pnlAddi.addLast(new Label(&quot;&quot;),VSTRETCH,FILL);
 
 		//////////////////////////
 		// Panel 6 - Cache container
 		//////////////////////////
 		addTitle(pnlContainer,MyLocale.getMsg(727,&quot;Cache container&quot;));
-		pnlContainer.addLast(chkMicro=new mCheckBox(&quot;Micro&quot;));
-		pnlContainer.addLast(chkSmall=new mCheckBox(&quot;Small&quot;));
-		pnlContainer.addLast(chkRegular=new mCheckBox(&quot;Regular&quot;));
-		pnlContainer.addLast(chkLarge=new mCheckBox(&quot;Large&quot;));
-		pnlContainer.addLast(chkVeryLarge=new mCheckBox(&quot;Very Large&quot;));
-		pnlContainer.addLast(chkOther=new mCheckBox(&quot;Other&quot;));
-		
+		pnlContainer.addLast(chkMicro=new CheckBox(&quot;Micro&quot;));
+		pnlContainer.addLast(chkSmall=new CheckBox(&quot;Small&quot;));
+		pnlContainer.addLast(chkRegular=new CheckBox(&quot;Regular&quot;));
+		pnlContainer.addLast(chkLarge=new CheckBox(&quot;Large&quot;));
+		pnlContainer.addLast(chkVeryLarge=new CheckBox(&quot;Very Large&quot;));
+		pnlContainer.addLast(chkOther=new CheckBox(&quot;Other&quot;));
+
 		//////////////////////////
 		// Panel 7 - Search
 		//////////////////////////
 		addTitle(pnlSearch,&quot;Search&quot;);
-		pnlSearch.addLast(new mLabel(&quot;To be implemented&quot;));
+		pnlSearch.addLast(new Label(&quot;To be implemented&quot;));
 
 
 		//////////////////////////
 		// Panel 8 - Cache attributes
 		//////////////////////////
-		
+
 		if (MyLocale.getScreenHeight()&gt;240) addTitle(pnlCacheAttributes,MyLocale.getMsg(737,&quot;Attributes&quot;));
-		pnlCacheAttributes.addNext(new mLabel(MyLocale.getMsg(739,&quot;Filter on&quot;)+&quot;:&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
-		pnlCacheAttributes.addLast(chcAttrib = new mChoice(new String[]{MyLocale.getMsg(740,&quot;all&quot;), MyLocale.getMsg(741,&quot;one&quot;), MyLocale.getMsg(742,&quot;none&quot;)},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlCacheAttributes.addNext(new Label(MyLocale.getMsg(739,&quot;Filter on&quot;)+&quot;:&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlCacheAttributes.addLast(chcAttrib = new Choice(new String[]{MyLocale.getMsg(740,&quot;all&quot;), MyLocale.getMsg(741,&quot;one&quot;), MyLocale.getMsg(742,&quot;none&quot;)},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 
 		attV=new AttributesSelector();
-		pnlCacheAttributes.addLast(attV, CellConstants.STRETCH|CellConstants.LEFT|CellConstants.BORDER, CellConstants.STRETCH);
+		pnlCacheAttributes.addLast(attV, CellConstants.STRETCH|CellConstants.LEFT, CellConstants.STRETCH);
 		attV.setSelectionMasks( 0l, 0l );
-		
-		Frame frmScreen=new Frame();
-		mLabel lblInfo; 
-		frmScreen.addLast(lblInfo=new mLabel(MyLocale.getMsg(725,&quot;Note: Filters are additive, active filter=green&quot;))).setTag(SPAN,new Dimension(2,1));
-		lblInfo.setTag(INSETS,new Insets(0,0,2,0));
-		frmScreen.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_BOTTOM;
+
+		CellPanel frmScreen=new CellPanel();
+		Label lblInfo;
+		frmScreen.addLast(lblInfo=new Label(MyLocale.getMsg(725,&quot;Note: Filters are additive, active filter=green&quot;))).setTag(TAG_SPAN,new Dimension(2,1));
+		lblInfo.setTag(TAG_INSETS,new Insets(0,0,2,0));
+		frmScreen.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_BOTTOM;
 		this.addLast(frmScreen,HSTRETCH,HFILL);
-		
+
 		CellPanel pnlButtons=new CellPanel();
-		pnlButtons.addLast(new mLabel(&quot;Filter&quot;));
-		pnlButtons.addLast(btnBearing=new mButton(MyLocale.getMsg(721,&quot;Bearing&quot;)));
-		pnlButtons.addLast(btnAttributes=new mButton(MyLocale.getMsg(720,&quot;Attributes&quot;)));
-		pnlButtons.addLast(btnRatings=new mButton(MyLocale.getMsg(722,&quot;Ratings&quot;)));
-		pnlButtons.addLast(btnTypes=new mButton(MyLocale.getMsg(723,&quot;Types&quot;))); 
-		pnlButtons.addLast(btnAddi=new mButton(MyLocale.getMsg(733,&quot;Add. Wpt&quot;))); 
-		pnlButtons.addLast(btnContainer=new mButton(MyLocale.getMsg(724,&quot;Container&quot;)));
-		pnlButtons.addLast(btnCacheAttributes=new mButton(MyLocale.getMsg(738,&quot;Attributes&quot;)));
+		pnlButtons.addLast(new Label(&quot;Filter&quot;));
+		pnlButtons.addLast(btnBearing=new Button(MyLocale.getMsg(721,&quot;Bearing&quot;)));
+		pnlButtons.addLast(btnAttributes=new Button(MyLocale.getMsg(720,&quot;Attributes&quot;)));
+		pnlButtons.addLast(btnRatings=new Button(MyLocale.getMsg(722,&quot;Ratings&quot;)));
+		pnlButtons.addLast(btnTypes=new Button(MyLocale.getMsg(723,&quot;Types&quot;)));
+		pnlButtons.addLast(btnAddi=new Button(MyLocale.getMsg(733,&quot;Add. Wpt&quot;)));
+		pnlButtons.addLast(btnContainer=new Button(MyLocale.getMsg(724,&quot;Container&quot;)));
+		pnlButtons.addLast(btnCacheAttributes=new Button(MyLocale.getMsg(738,&quot;Attributes&quot;)));
 		// Search ist f&#252;r 0.9n noch deaktiviert
-		//pnlButtons.addLast(btnSearch=new mButton(&quot;Search&quot;)); btnSearch.modify(Disabled,0);
+		//pnlButtons.addLast(btnSearch=new Button(&quot;Search&quot;)); btnSearch.modify(Disabled,0);
 		addNext(pnlButtons,HSTRETCH,FILL);
 
 		cp.addItem(pnlBearDist,&quot;Bear&quot;,null);
 		cp.addItem(pnlAttributes,&quot;Att&quot;,null);
-		cp.addItem(pnlRatings,&quot;DT&quot;,null); 
+		cp.addItem(pnlRatings,&quot;DT&quot;,null);
 		cp.addItem(pnlCacheTypes,&quot;Type&quot;,null);
 		cp.addItem(pnlAddi,&quot;Addi&quot;,null);
 		cp.addItem(pnlContainer,&quot;Size&quot;,null);
@@ -284,12 +287,13 @@
 		cp.addItem(pnlCacheAttributes,&quot;Attr&quot;,null);
 		addLast(cp,VSTRETCH,FILL);
 
-		Panel btPanel = new Panel();
-		btPanel.addNext(btnCancel = new mButton(MyLocale.getMsg(708,&quot;Cancel&quot;)),CellConstants.STRETCH, CellConstants.FILL);
-		btPanel.addLast(btnApply = new mButton(MyLocale.getMsg(709,&quot;Apply&quot;)),CellConstants.STRETCH, CellConstants.FILL);
-//		btPanel.addLast(btnRoute = new mButton(&quot;Route&quot;),CellConstants.STRETCH, CellConstants.FILL);
-		addLast(btPanel.setTag(CellConstants.SPAN, new Dimension(3,1)), CellConstants.STRETCH, CellConstants.FILL);
-		int sw = MyLocale.getScreenWidth(); int sh = MyLocale.getScreenHeight(); 
+		CellPanel btPanel = new CellPanel();
+		btPanel.addNext(btnCancel = new Button(MyLocale.getMsg(708,&quot;Cancel&quot;)),CellConstants.STRETCH, CellConstants.FILL);
+		btPanel.addLast(btnApply = new Button(MyLocale.getMsg(709,&quot;Apply&quot;)),CellConstants.STRETCH, CellConstants.FILL);
+		//nbtPanel.addLast(btnRoute = new Button(&quot;Route&quot;),CellConstants.STRETCH, CellConstants.FILL);
+		addLast(btPanel.setTag(Control.TAG_SPAN, new Dimension(3,1)), CellConstants.STRETCH, CellConstants.FILL);
+
+		int sw = MyLocale.getScreenWidth(); int sh = MyLocale.getScreenHeight();
 		Preferences pref = Global.getPref();int fs = pref.fontSize;
 		int psx; int psy;
 		if((sw&gt;300) &amp;&amp; (sh&gt;300)){
@@ -309,8 +313,8 @@
 		}
 		cp.select(3);
 	}
-	
-	
+
+
 	public void setData(){
 		Profile prof=Global.getProfile();
 
@@ -332,7 +336,7 @@
 		chkNNW.state  = fltRose.charAt(1) == '1';
 		chkN.state    = fltRose.charAt(2) == '1';
 		chkNNE.state  = fltRose.charAt(3) == '1';
-		
+
 		chkNE.state   = fltRose.charAt(4) == '1';
 		chkENE.state  = fltRose.charAt(5) == '1';
 		chkE.state    = fltRose.charAt(6) == '1';
@@ -347,7 +351,7 @@
 		chkWSW.state  = fltRose.charAt(13) == '1';
 		chkW.state    = fltRose.charAt(14) == '1';
 		chkWNW.state  = fltRose.charAt(15) == '1';
-		
+
 		//////////////////////////
 		// Panel 2 - Cache attributes
 		//////////////////////////
@@ -394,7 +398,7 @@
 		//////////////////////////
 		// Panel 4 - Cache types
 		//////////////////////////
-		
+
 		String fltType=prof.filterType;
 		chkTrad.state       = fltType.charAt(0) == '1';
 		chkMulti.state      = fltType.charAt(1) == '1';
@@ -409,17 +413,17 @@
 		chkCustom.state     = fltType.charAt(10) == '1';
 		chkCito.state       = fltType.charAt(17) == '1';
 		chkWherigo.state    = fltType.charAt(18) == '1';
-		
+
 		// Note addiWptState is set by setColors
-		
+
 		//////////////////////////
 		// Panel 5 - Additional waypoints
 		//////////////////////////
-		chkParking.state    = fltType.charAt(11) == '1';	
-		chkStage.state      = fltType.charAt(12) == '1'; 
-		chkQuestion.state   = fltType.charAt(13) == '1'; 
-		chkFinal.state      = fltType.charAt(14) == '1'; 
-		chkTrailhead.state  = fltType.charAt(15) == '1'; 
+		chkParking.state    = fltType.charAt(11) == '1';
+		chkStage.state      = fltType.charAt(12) == '1';
+		chkQuestion.state   = fltType.charAt(13) == '1';
+		chkFinal.state      = fltType.charAt(14) == '1';
+		chkTrailhead.state  = fltType.charAt(15) == '1';
 		chkReference.state  = fltType.charAt(16) == '1';
 		addiWptChk.state= !fltType.substring(11,17).equals(&quot;000000&quot;);
 
@@ -433,7 +437,7 @@
 		chkLarge.state      = fltSize.charAt(3) == '1';
 		chkVeryLarge.state  = fltSize.charAt(4) == '1';
 		chkOther.state      = fltSize.charAt(5) == '1';
-		
+
 		//////////////////////////
 		// Panel 7 - Search
 		//////////////////////////
@@ -443,15 +447,15 @@
 		//////////////////////////
 		attV.setSelectionMasks( prof.filterAttrYes, prof.filterAttrNo );
 		chcAttrib.select(prof.filterAttrChoice);
-		
+
 		// Adjust colors of buttons depending on which filters are active
 		setColors();
 	}
-	
+
 	// Set the colors of the filter buttons according to which filters are active
 	private void setColors() {
 		// Panel 1 - Bearing &amp; Distance
-		if (inpDist.getText().length()&gt;0 || 
+		if (inpDist.getText().length()&gt;0 ||
 			  !(chkNW.state &amp;&amp; chkNNW.state &amp;&amp; chkN.state &amp;&amp; chkNNE.state &amp;&amp;
 				chkNE.state &amp;&amp; chkENE.state &amp;&amp; chkE.state &amp;&amp; chkESE.state &amp;&amp;
 				chkSE.state &amp;&amp; chkSSE.state &amp;&amp; chkS.state &amp;&amp; chkSSW.state &amp;&amp;
@@ -465,20 +469,20 @@
 				chkSW.state || chkWSW.state || chkW.state || chkWNW.state))
 			btnBearing.backGround=COLOR_FILTERALL;
 		btnBearing.repaint();
-		
+
 		// Panel 2 - Cache attributes
 		if (!( chkArchived.state    &amp;&amp; chkAvailable.state    &amp;&amp; chkFound.state    &amp;&amp; chkOwned.state &amp;&amp;
 			   chkNotArchived.state &amp;&amp; chkNotAvailable.state &amp;&amp; chkNotFound.state &amp;&amp; chkNotOwned.state))
 			btnAttributes.backGround=COLOR_FILTERACTIVE;
 		else
 			btnAttributes.backGround=COLOR_FILTERINACTIVE;
-		if ((chkArchived.state==false &amp;&amp; chkNotArchived.state==false) || 
+		if ((chkArchived.state==false &amp;&amp; chkNotArchived.state==false) ||
 			    (chkAvailable.state==false &amp;&amp; chkNotAvailable.state==false) ||
 			    (chkFound.state==false &amp;&amp; chkNotFound.state==false) ||
-			    (chkOwned.state==false &amp;&amp; chkNotOwned.state==false)) 
+			    (chkOwned.state==false &amp;&amp; chkNotOwned.state==false))
 			btnAttributes.backGround=COLOR_FILTERALL;
 		btnAttributes.repaint();
-		
+
 		// Panel 3 - Cache ratings
 		if (inpDiff.getText().length()&gt;0 || inpTerr.getText().length()&gt;0)
 			btnRatings.backGround=COLOR_FILTERACTIVE;
@@ -487,15 +491,15 @@
 		btnRatings.repaint();
 
 		// Panel 5 - Addi Waypoints
-		if (chkParking.state || chkStage.state || chkQuestion.state || 
+		if (chkParking.state || chkStage.state || chkQuestion.state ||
 			chkFinal.state || chkTrailhead.state || chkReference.state ) { // At least one tick
 			btnAddi.backGround=COLOR_FILTERACTIVE;
 			addiWptChk.state=true;
-			if (chkParking.state &amp;&amp; chkStage.state &amp;&amp;  chkQuestion.state &amp;&amp; 
+			if (chkParking.state &amp;&amp; chkStage.state &amp;&amp;  chkQuestion.state &amp;&amp;
 				chkFinal.state &amp;&amp; chkTrailhead.state &amp;&amp; chkReference.state ) { // All ticked?
 				addiWptChk.bgColor=Color.White;
 				btnAddi.backGround=COLOR_FILTERINACTIVE;
-			} else {	
+			} else {
 				addiWptChk.bgColor=Color.LightGray;
 			}
 		} else { // All not ticked
@@ -506,34 +510,34 @@
 		btnAddi.repaint();
 
 		// Panel 4 - Cache types
-		boolean allAddis=(chkParking.state &amp;&amp; chkStage.state &amp;&amp;  chkQuestion.state &amp;&amp; 
+		boolean allAddis=(chkParking.state &amp;&amp; chkStage.state &amp;&amp;  chkQuestion.state &amp;&amp;
 		chkFinal.state &amp;&amp; chkTrailhead.state &amp;&amp; chkReference.state) ;
 		if (!(chkTrad.state &amp;&amp; chkMulti.state &amp;&amp; 	chkVirtual.state &amp;&amp; chkLetter.state &amp;&amp;
 		      chkEvent.state &amp;&amp; chkWebcam.state &amp;&amp; chkMystery.state &amp;&amp; chkEarth.state &amp;&amp;
-		      chkLocless.state &amp;&amp; chkMega.state &amp;&amp; chkCito.state &amp;&amp; chkWherigo.state &amp;&amp; chkCustom.state &amp;&amp; allAddis) ) 
+		      chkLocless.state &amp;&amp; chkMega.state &amp;&amp; chkCito.state &amp;&amp; chkWherigo.state &amp;&amp; chkCustom.state &amp;&amp; allAddis) )
 			btnTypes.backGround=COLOR_FILTERACTIVE;
 		else
 			btnTypes.backGround=COLOR_FILTERINACTIVE;
 		if (!(chkTrad.state || chkMulti.state || 	chkVirtual.state || chkLetter.state ||
 			      chkEvent.state || chkWebcam.state || chkMystery.state || chkEarth.state ||
-			      chkLocless.state || chkMega.state || chkCustom.state || chkParking.state 
-			      || chkStage.state || chkQuestion.state || 
-					chkFinal.state || chkTrailhead.state || chkCito.state || chkWherigo.state || chkReference.state )) 
+			      chkLocless.state || chkMega.state || chkCustom.state || chkParking.state
+			      || chkStage.state || chkQuestion.state ||
+					chkFinal.state || chkTrailhead.state || chkCito.state || chkWherigo.state || chkReference.state ))
 			btnTypes.backGround=COLOR_FILTERALL;
 		btnTypes.repaint();
 
-			
+
 		// Panel 6 - Cache container
-		if (!(chkMicro.state &amp;&amp; chkSmall.state &amp;&amp; chkRegular.state &amp;&amp; 
+		if (!(chkMicro.state &amp;&amp; chkSmall.state &amp;&amp; chkRegular.state &amp;&amp;
 			  chkLarge.state &amp;&amp; chkVeryLarge.state &amp;&amp; chkOther.state))
 			  btnContainer.backGround=COLOR_FILTERACTIVE;
 		else
 			  btnContainer.backGround=COLOR_FILTERINACTIVE;
-		if (!(chkMicro.state || chkSmall.state || chkRegular.state || 
+		if (!(chkMicro.state || chkSmall.state || chkRegular.state ||
 				  chkLarge.state || chkVeryLarge.state || chkOther.state))
 			  btnContainer.backGround=COLOR_FILTERALL;
 		btnContainer.repaint();
-			
+
 		// Panel 7 - Search
 
 		// Panel 8 - Cache attributes
@@ -543,9 +547,9 @@
 			btnCacheAttributes.backGround=COLOR_FILTERACTIVE;
 		btnCacheAttributes.repaint();
 
-		
+
 	}
-	
+
 	/**
 	*	React to the users input, create a filter and set the variable of the filter.
 	*	@see Filter
@@ -555,25 +559,8 @@
 			if (ev.target == btnCancel){
 				this.close(0);
 			}
-			else if (ev.target == btnRoute){
-				
-				File datei;
-				FileChooser fc = new FileChooser(FileChooserBase.OPEN, Global.getProfile().dataDir);
-				fc.setTitle(MyLocale.getMsg(712,&quot;Select route file&quot;));
-				if(fc.execute() != FormBase.IDCANCEL) {
-					datei = fc.getChosenFile();
-					InfoBox inf = new InfoBox(&quot;Distance?&quot;, &quot;Dist:&quot;, InfoBox.INPUT);
-					inf.execute();
-					Vm.showWait(true);
-					Filter flt = new Filter();
-					flt.doFilterRoute(datei, Convert.toDouble(inf.feedback.getText()));
-				}
-				Vm.showWait(false);
-				this.close(0);
-				
-			}
 			else if (ev.target == btnApply){
-				Vm.showWait(true);
+				Form.showWait();
 				//Save filter required
 				Profile pfl = Global.getProfile();
 				pfl.filterVar = (chkArchived.state    ? &quot;1&quot; : &quot;0&quot;) +
@@ -583,12 +570,12 @@
 							(chkNotArchived.state ? &quot;1&quot; : &quot;0&quot;) +
 							(chkNotAvailable.state? &quot;1&quot; : &quot;0&quot;) +
 							(chkNotFound.state    ? &quot;1&quot; : &quot;0&quot;) +
-							(chkNotOwned.state    ? &quot;1&quot; : &quot;0&quot;);							
+							(chkNotOwned.state    ? &quot;1&quot; : &quot;0&quot;);
 				pfl.filterType =(chkTrad.state    ? &quot;1&quot; : &quot;0&quot;) +
 								(chkMulti.state   ? &quot;1&quot; : &quot;0&quot;) +
 								(chkVirtual.state ? &quot;1&quot; : &quot;0&quot;) +
 								(chkLetter.state  ? &quot;1&quot; : &quot;0&quot;) +
-								(chkEvent.state   ? &quot;1&quot; : &quot;0&quot;) + 
+								(chkEvent.state   ? &quot;1&quot; : &quot;0&quot;) +
 								(chkWebcam.state  ? &quot;1&quot; : &quot;0&quot;) +
 								(chkMystery.state ? &quot;1&quot; : &quot;0&quot;) +
 								(chkEarth.state   ? &quot;1&quot; : &quot;0&quot;) +
@@ -625,26 +612,26 @@
 							(chkLarge.state ? &quot;1&quot; : &quot;0&quot;)+
 							(chkVeryLarge.state ? &quot;1&quot; : &quot;0&quot;)+
 							(chkOther.state ? &quot;1&quot; : &quot;0&quot;);
-				
-				if(chcDist.selectedIndex == 0) { 
+
+				if(chcDist.selectedIndex == 0) {
 					pfl.filterDist=&quot;L&quot;+inpDist.getText();
-				} else { 
+				} else {
 					pfl.filterDist=&quot;G&quot;+inpDist.getText();
 				}
-					
-				if(chcDiff.selectedIndex == 0) { 
+
+				if(chcDiff.selectedIndex == 0) {
 					pfl.filterDiff=&quot;L&quot;+inpDiff.getText();
-				} else if(chcDiff.selectedIndex == 1) { 
+				} else if(chcDiff.selectedIndex == 1) {
 					pfl.filterDiff=&quot;=&quot;+inpDiff.getText();
-				} else {	
+				} else {
 					pfl.filterDiff=&quot;G&quot;+inpDiff.getText();
-				}	
-					
-				if(chcTerr.selectedIndex == 0) { 
+				}
+
+				if(chcTerr.selectedIndex == 0) {
 					pfl.filterTerr=&quot;L&quot;+inpTerr.getText();
-				} else if(chcTerr.selectedIndex == 1){ 
+				} else if(chcTerr.selectedIndex == 1){
 					pfl.filterTerr=&quot;=&quot;+inpTerr.getText();
-				} else { 
+				} else {
 					pfl.filterTerr=&quot;G&quot;+inpTerr.getText();
 				}
 				pfl.filterAttrYes = attV.selectionMaskYes;
@@ -653,8 +640,8 @@
 				Filter flt = new Filter();
 				flt.setFilter();
 				flt.doFilter();
-				Global.mainTab.tbP.tc.scrollToVisible(0,0);
-				Vm.showWait(false);
+				Global.mainTab.tbP.tControl.scrollToVisible(0,0);
+				Form.cancelWait();
 				//Tabelle neu zeichnen lassen!
 				this.close(0);
 			} else if (ev.target == addiWptChk) { // Set all addi filters to value of main addi filter
@@ -672,26 +659,26 @@
 			else if (ev.target == btnTypes)cp.select(3);
 			else if (ev.target == btnAddi)cp.select(4);
 			else if (ev.target == btnContainer)cp.select(5);
-			else if (ev.target == btnSearch)cp.select(6);
+//			else if (ev.target == btnSearch)cp.select(6);
 			else if (ev.target == btnCacheAttributes)cp.select(7);
 			else if (ev.target == btnDeselect) {
-				chkNW.state= chkNNW.state  = chkN.state    = chkNNE.state  = 
-				chkNE.state   = chkENE.state  = chkE.state    = chkESE.state  = 
-				chkSE.state   = chkSSE.state  = chkS.state    = chkSSW.state  = 
-				chkSW.state   = chkWSW.state  = chkW.state    = chkWNW.state = false; 
+				chkNW.state= chkNNW.state  = chkN.state    = chkNNE.state  =
+				chkNE.state   = chkENE.state  = chkE.state    = chkESE.state  =
+				chkSE.state   = chkSSE.state  = chkS.state    = chkSSW.state  =
+				chkSW.state   = chkWSW.state  = chkW.state    = chkWNW.state = false;
 				setColors();
 				repaint();
-					
+
 			} else if (ev.target == btnSelect) {
-				chkNW.state= chkNNW.state  = chkN.state    = chkNNE.state  = 
-				chkNE.state   = chkENE.state  = chkE.state    = chkESE.state  = 
-				chkSE.state   = chkSSE.state  = chkS.state    = chkSSW.state  = 
-				chkSW.state   = chkWSW.state  = chkW.state    = chkWNW.state = true; 
+				chkNW.state= chkNNW.state  = chkN.state    = chkNNE.state  =
+				chkNE.state   = chkENE.state  = chkE.state    = chkESE.state  =
+				chkSE.state   = chkSSE.state  = chkS.state    = chkSSW.state  =
+				chkSW.state   = chkWSW.state  = chkW.state    = chkWNW.state = true;
 				setColors();
-				repaint();	
+				repaint();
 			}
 		}
-		if (ev instanceof DataChangeEvent )	{ 
+		if (ev instanceof DataChangeEvent )	{
 			setColors();
 		}
 

Modified: experiments/engywuck/hist-test/src/cachewolf/GPSPortOptions.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/GPSPortOptions.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/GPSPortOptions.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,75 +1,59 @@
-    /*
-    CacheWolf is a software for PocketPC, Win and Linux that 
-    enables paperless caching. 
-    It supports the sites geocaching.com and opencaching.de
-    
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+package cachewolf;
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
+import eve.ui.*;
+import java.io.*;
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+import eve.ui.formatted.TextDisplay;
+import eve.sys.*;
+import eve.ui.data.SerialPortOptions;
+import eve.io.SerialPort;
+import eve.util.mString;
+import eve.ui.data.Editor;
+import eve.ui.data.EditorEvent;
+import java.lang.InterruptedException;
+import eve.ui.ComboBox;
+import eve.ui.Button;
+import cachewolf.utils.Common;
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
 
-package CacheWolf;
-
-import ewe.ui.*;
-import ewe.io.*;
-import ewe.ui.formatted.TextDisplay;
-import ewe.reflect.FieldTransfer;
-import ewe.reflect.Reflect;
-import ewe.sys.*;
-import ewe.util.*;
-
 /**
  * Thread for reading data from COM-port
  *
  */
 class mySerialThread extends mThread{
-	SerialPort comSp;   
-	byte[] comBuff = new byte[1024];  
+	SerialPort comSp;
+	byte[] comBuff = new byte[1024];
 	int comLength = 0;
 	TextDisplay out;
 	boolean run;
 	public String lastgot;
-	
+
 	public mySerialThread(SerialPortOptions spo, TextDisplay td) throws IOException {
 		comSp = new SerialPort(spo);
 		//comSp.setFlowControl(SerialPort.SOFTWARE_FLOW_CONTROL);
 		out = td;
 		lastgot = null;
 	}
-	
+
 	public void run() {
 		run = true;
 		while (run){
 			try {
 				sleep(200);
 			} catch (InterruptedException e) {}
-			if (comSp != null)	{  
-				comLength = comSp.nonBlockingRead(comBuff, 0 ,comBuff.length);
-				if (comLength &gt; 0)	{
-					String str = mString.fromAscii(comBuff, 0, comLength).toUpperCase();
-					lastgot = str;
-					if (out != null) out.appendText(str,true);
-				}
+			if (comSp != null)	{
+				try {
+					if (comSp.getInputStream().available() &gt; 0)	{
+						comSp.getInputStream().read(comBuff,0,comSp.getInputStream().available());
+						String str = mString.fromAscii(comBuff, 0, comLength).toUpperCase();
+						lastgot=str;
+						if (out != null) out.appendText(str,true);
+					}
+				} catch(Exception ex) {}
 			}
 		}
 	}
-	
+
 	public String nonBlockingRead() {
 		String ret = new String(lastgot); //mString.fromAscii(gpsBuff,0,gpsLen);
 		lastgot = null;
@@ -77,79 +61,85 @@
 
 	}
 
-	public boolean stop() {
+	public boolean stopThread() {
 		run = false;
-		boolean ret;
+		boolean ret=false;
 		if (comSp != null) {
-			ret = comSp.close(); //compSp == null can happen if a exception occured 
-			try { ewe.sys.mThread.sleep(500); // wait in order to give the system time to close the serial port
+			try {
+				comSp.close(); //compSp == null can happen if a exception occured
+			} catch (IOException ex) {
+				ret=true;
+			}
+			try { eve.sys.mThread.sleep(500); // wait in order to give the system time to close the serial port
 			} catch (InterruptedException e) {}
 		}
 		else ret = true;
 		return ret;
 	}
+
+
 }
 
 public class GPSPortOptions extends SerialPortOptions {
 	TextDisplay txtOutput;
-	mButton btnTest, btnUpdatePortList, btnScan;
-	public mInput inputBoxForwardHost;
-	mLabel  labelForwardHost;
-	public mCheckBox forwardGpsChkB;
-	public mInput inputBoxLogTimer;
-	mLabel  labelLogTimer;
-	public mCheckBox logGpsChkB;
+	Button btnTest, btnUpdatePortList, btnScan;
+	public Input inputBoxForwardHost;
+	Label  labelForwardHost;
+	public CheckBox forwardGpsChkB;
+	public Input inputBoxLogTimer;
+	Label  labelLogTimer;
+	public CheckBox logGpsChkB;
 	mySerialThread serThread;
 	boolean gpsRunning = false;
 	MyEditor ed = new MyEditor();
 
-	
+
 	public Editor getEditor(){
 		// The following lines are mainly copied from SerialPortOptions.
 		// Reason: We want to use MyEditor instead of the default Editor,
 		//         because the latter places the ok/cancel buttons centered.
 		// Because this is from the general SerialPortOptions class, maybe not all of the code
 		// must be necessary.
-		ed.objectClass = Reflect.getForObject(this);
+		ed.objectClass = getClass();
 		ed.sampleObject = this;
 		ed.setObject(this);
 		ed.title = MyLocale.getMsg(7100, &quot;Serial Port Options&quot;);
 		InputStack is = new InputStack();
 		ed.addLast(is).setCell(CellConstants.HSTRETCH);
 		CellPanel cp = new CellPanel();
-		ed.addField(cp.addNext(new mComboBox()).setCell(CellConstants.HSTRETCH),&quot;portName&quot;);
-		btnUpdatePortList = new mButton(MyLocale.getMsg(7101,&quot;Update Ports$u&quot;));
+		ed.addField(cp.addNext(new ComboBox()).setCell(CellConstants.HSTRETCH),&quot;portName&quot;);
+		btnUpdatePortList = new Button(MyLocale.getMsg(7101,&quot;Update Ports$u&quot;));
 		ed.addField(cp.addLast(btnUpdatePortList).setCell(CellConstants.DONTSTRETCH),&quot;update&quot;);
 		is.add(cp,&quot;Port:$p&quot;);
-		mComboBox cb = new mComboBox();
+		ComboBox cb = new ComboBox();
 		is.add(ed.addField(cb,&quot;baudRate&quot;),MyLocale.getMsg(7102,&quot;Baud:$b&quot;));
-		cb.choice.addItems(ewe.util.mString.split(&quot;110|300|1200|2400|4800|9600|19200|38400|57600|115200&quot;));
+		cb.choice.addItems(eve.util.mString.split(&quot;110|300|1200|2400|4800|9600|19200|38400|57600|115200&quot;));
 		//
 		// End of copy from SerialPortOptions.
 		//
 		ed.buttonConstraints = CellConstants.HFILL;
-		btnScan = new mButton(MyLocale.getMsg(7103,&quot;Scan$u&quot;));
+		btnScan = new Button(MyLocale.getMsg(7103,&quot;Scan$u&quot;));
 		btnScan.setCell(CellConstants.DONTSTRETCH);
 		ed.addField(ed.addNext(btnScan),&quot;scan&quot;);
-		btnTest = new mButton(MyLocale.getMsg(7104,&quot;Test$t&quot;));
+		btnTest = new Button(MyLocale.getMsg(7104,&quot;Test$t&quot;));
 		ed.addField(ed.addLast(btnTest.setCell(CellConstants.DONTSTRETCH)),&quot;test&quot;);
 		txtOutput = new TextDisplay();
 		ScrollBarPanel sbp = new MyScrollBarPanel(txtOutput);
 		sbp.setOptions(ScrollablePanel.AlwaysShowVerticalScrollers | ScrollablePanel.AlwaysShowHorizontalScrollers);
 		ed.addField(ed.addLast(sbp),&quot;out&quot;);
-		forwardGpsChkB = new mCheckBox(&quot;&quot;);
+		forwardGpsChkB = new CheckBox(&quot;&quot;);
 		ed.addField(ed.addNext(forwardGpsChkB, CellConstants.DONTSTRETCH, (CellConstants.EAST | CellConstants.DONTFILL)), &quot;forwardGpsChkB&quot;);
-		labelForwardHost = new mLabel(MyLocale.getMsg(7105, &quot;Forward GPS data to host&quot;));
+		labelForwardHost = new Label(MyLocale.getMsg(7105, &quot;Forward GPS data to host&quot;));
 		ed.addField(ed.addNext(labelForwardHost, CellConstants.DONTSTRETCH, (CellConstants.WEST | CellConstants.DONTFILL)), &quot;labelForwardIP&quot;);
-		inputBoxForwardHost = new mInput(&quot;tcpForwardHost&quot;);
+		inputBoxForwardHost = new Input(&quot;tcpForwardHost&quot;);
 		inputBoxForwardHost.setPromptControl(labelForwardHost);
 		inputBoxForwardHost.setToolTip(MyLocale.getMsg(7106, &quot;All data from GPS will be sent to TCP-port 23\n and can be redirected there to a serial port\n by HW Virtual Serial Port&quot;));
 		ed.addField(ed.addLast(inputBoxForwardHost,0 , (CellConstants.WEST | CellConstants.HFILL)), &quot;tcpForwardHost&quot;);
-		logGpsChkB = new mCheckBox(&quot;&quot;);
+		logGpsChkB = new CheckBox(&quot;&quot;);
 		ed.addField(ed.addNext(logGpsChkB, CellConstants.DONTSTRETCH, (CellConstants.EAST | CellConstants.DONTFILL)), &quot;logGpsChkB&quot;);
-		labelLogTimer = new mLabel(MyLocale.getMsg(7107, &quot;Interval in sec for logging&quot;));
+		labelLogTimer = new Label(MyLocale.getMsg(7107, &quot;Interval in sec for logging&quot;));
 		ed.addField(ed.addNext(labelLogTimer, CellConstants.DONTSTRETCH, (CellConstants.WEST | CellConstants.DONTFILL)), &quot;labelLogTimer&quot;);
-		inputBoxLogTimer = new mInput(&quot;GPSLogTimer&quot;);
+		inputBoxLogTimer = new Input(&quot;GPSLogTimer&quot;);
 		inputBoxLogTimer.setPromptControl(labelLogTimer);
 		ed.addField(ed.addLast(inputBoxLogTimer,0 , (CellConstants.WEST | CellConstants.HFILL)), &quot;GPSLogTimer&quot;);
 		this.ed.firstFocus = btnUpdatePortList;
@@ -164,7 +154,7 @@
 				txtOutput.setText(&quot;&quot;);
 				new mThread() {
 					public void run() {
-						btnTest.set(mButton.Disabled, true);
+						btnTest.set(Button.Disabled, true);
 						btnTest.repaintNow();
 						btnScan.setText(Gui.getTextFrom(MyLocale.getMsg(7119,&quot;Stop&quot;)));
 						btnScan.repaintNow();
@@ -176,10 +166,10 @@
 							interruptScan = false;
 							int i;
 							for (i=0; i&lt;ports.length; i++){
-								if (interruptScan) { 
+								if (interruptScan) {
 									txtOutput.appendText(MyLocale.getMsg(7120, &quot;Canceled&quot;), true); // MyLocale.getMsg(7109, &quot;Could not get list of available serial ports\n&quot;), true);
 									fin();
-									return; 
+									return;
 								}
 								if (!testPort(ports[i], baudRate)) 	continue;
 								else {
@@ -195,7 +185,7 @@
 					private void fin() {
 						scanRunning = false;
 						if (btnTest != null) {
-							btnTest.set(mButton.Disabled, false);
+							btnTest.set(Button.Disabled, false);
 							btnTest.repaintNow();
 						}
 						if (btnScan != null) {
@@ -213,7 +203,7 @@
 				ed_.fromControls();
 				txtOutput.setText(MyLocale.getMsg(7117, &quot;Displaying data from serial port directly:\n&quot;));
 				try {
-					btnScan.set(mButton.Disabled, true);
+					btnScan.set(Button.Disabled, true);
 					btnScan.repaintNow();
 					this.portName = Common.fixSerialPortName(portName);
 					serThread = new mySerialThread(this, txtOutput);
@@ -221,16 +211,16 @@
 					btnTest.setText(Gui.getTextFrom(MyLocale.getMsg(7118, &quot;Stop&quot;)));
 					gpsRunning = true;
 				} catch (IOException e) {
-					btnScan.set(mButton.Disabled, false);
+					btnScan.set(Button.Disabled, false);
 					btnScan.repaintNow();
 					txtOutput.appendText(MyLocale.getMsg(7108, &quot;Failed to open serial port: &quot;) + this.portName + &quot;, IOException: &quot; + e.getMessage() + &quot;\n&quot;, true);
 				}
 			}
 			else {
-				serThread.stop();
+				serThread.stopThread();
 				btnTest.setText(Gui.getTextFrom(MyLocale.getMsg(7104,&quot;Test$t&quot;)));
 				gpsRunning = false;
-				btnScan.set(mButton.Disabled, false);
+				btnScan.set(Button.Disabled, false);
 				btnScan.repaintNow();
 			}
 
@@ -238,24 +228,23 @@
 
 		super.action(field, ed_);
 	}
-	
+
 	public void fieldEvent(FieldTransfer xfer, Editor editor, Object event){
 		if ( event != null &amp;&amp; event instanceof EditorEvent) {
 			EditorEvent ev = (EditorEvent) event;
 			if (xfer.fieldName.equals(&quot;_editor_&quot;)) {
 				if (ev.type == EditorEvent.CLOSED) {
-					if (serThread != null) serThread.stop();
+					if (serThread != null) serThread.stopThread();
 				}
 			}
 			super.fieldEvent(xfer,editor,event);
 		}
 	}
-	
+
 	private boolean testPort(String port, int baud){
-		mySerialThread gpsPort; 
-		int gpsLen;
+		mySerialThread gpsPort;
 		long now;
-		
+
 		SerialPortOptions testspo= new SerialPortOptions();
 		testspo.baudRate = baud;
 		testspo.portName = Common.fixSerialPortName(port);
@@ -266,7 +255,7 @@
 			return false;
 		}
 		//if (!gpsPort.isOpen()) txtOutput.appendText(MyLocale.getMsg(7108, &quot;Failed (2) to open serial port: &quot;) + this.portName + &quot;\n&quot;, true);
- 
+
 		//try to read some data
 		now = new Time().getTime();
 		txtOutput.appendText(MyLocale.getMsg(7111, &quot;Trying &quot;) + port + MyLocale.getMsg(7112, &quot; at &quot;) + baud + &quot; Baud\n&quot;, true);
@@ -280,13 +269,13 @@
 				if (!gotdata) {
 					gotdata = true;
 					txtOutput.appendText(MyLocale.getMsg(7113, &quot; - got some data\n&quot;), true);
-					now = new Time().getTime(); // if receiced some data, give the GPS some extra time to send NMEA data (e.g. Sirf initially sends some non-NMEA text info about it self) 
+					now = new Time().getTime(); // if receiced some data, give the GPS some extra time to send NMEA data (e.g. Sirf initially sends some non-NMEA text info about it self)
 				}
 				if (gpsPort.nonBlockingRead().indexOf(&quot;$GP&quot;, 0) &gt;= 0) gpsfound = true;
 			}
-			try {ewe.sys.mThread.sleep(200); } catch (InterruptedException e) {}
+			try {eve.sys.mThread.sleep(200); } catch (InterruptedException e) {}
 		}
-		gpsPort.stop();
+		gpsPort.stopThread();
 		if (gpsfound)	 txtOutput.appendText(MyLocale.getMsg(7114, &quot; - GPS Port found\n&quot;), true);
 		else {
 			if (gotdata) txtOutput.appendText(MyLocale.getMsg(7115, &quot; - No GPS data tag found\n&quot;), true);
@@ -295,5 +284,5 @@
 		//catch (IOException io) { txtOutput.appendText(&quot;error closing serial port&quot;, true); }
 		return gpsfound;
 	}
-	
+
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/Global.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/Global.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/Global.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,5 +1,6 @@
-package CacheWolf;
+package cachewolf;
 
+
 /**
  * Global data: Preferences and Profile
  * 

Modified: experiments/engywuck/hist-test/src/cachewolf/HintLogPanel.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/HintLogPanel.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/HintLogPanel.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,17 +1,19 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.ui.*;
-import ewe.fx.Dimension;
-import ewe.fx.Graphics;
-import ewe.fx.Point;
-import ewe.fx.mImage;
-import ewe.graphics.AniImage;
-import ewe.graphics.ImageDragContext;
-import ewe.graphics.InteractivePanel;
-import ewe.sys.*;
-import ewe.fx.Image;
-import ewe.fx.Rect;
+import cachewolf.utils.Common;
+import eve.ui.*;
+import eve.fx.Point;
+import eve.sys.*;
+import eve.fx.Rect;
+import eve.ui.formatted.HtmlDisplay;
+import eve.ui.game.AniImage;
+import eve.ui.event.KeyEvent;
+import eve.ui.game.InteractivePanel;
+import eve.ui.event.ControlEvent;
+import eve.fx.gui.IKeys; 
+import eve.ui.game.ImageDragContext;
 
+
 /**
  *	Class to create the panel that holds hints and logs.
  *	It holds a method to cryt and decrypt hints.
@@ -21,17 +23,17 @@
  *	Class ID=400
  */
 public class HintLogPanel extends CellPanel{
-	int crntLogPosition = 0;
-	CacheHolderDetail currCache;
-	private final int DEFAULT_STRINGBUFFER_SIZE=8000;
-	mTextPad hint = new mTextPad();
+	private int crntLogPosition = 0;
+	private CacheHolderDetail currCache;
+	private final static int DEFAULT_STRINGBUFFER_SIZE=8000;
+	private TextPad hint = new TextPad();
 	//mTextPad logs = new mTextPad();
-	HtmlDisplay logs = new HtmlDisplay();
-	AniImage htmlTxtImage;
-	fastScrollText htmlImagDisp = new fastScrollText();
-	mButton decodeButton = new mButton(&quot;Decode&quot;);
-	mButton moreBt = new mButton(&quot;&gt;&gt;&quot;);
-	mButton prevBt = new mButton(&quot;&lt;&lt;&quot;);
+	private HtmlDisplay logs = new HtmlDisplay();
+	//AniImage htmlTxtImage;
+	//fastScrollText htmlImagDisp = new fastScrollText();
+	private Button decodeButton = new Button(&quot;Decode&quot;);
+	private Button moreBt = new Button(&quot;&gt;&gt;&quot;);
+	private Button prevBt = new Button(&quot;&lt;&lt;&quot;);
 	private MyScrollBarPanel sbplog;
 	private int lastScrollbarWidth = 0;
 	
@@ -43,61 +45,57 @@
 		int initialHintHeight=Global.getPref().initialHintHeight;
 		if (initialHintHeight&lt;0 || initialHintHeight&gt;1000) initialHintHeight=Global.getPref().DEFAULT_INITIAL_HINT_HEIGHT;
 		hintpane.setPreferredSize(100,initialHintHeight); 
-		ScrollBarPanel sbphint = new MyScrollBarPanel(hint);
+		MyScrollBarPanel sbphint = new MyScrollBarPanel(hint);
 		hintpane.addLast(sbphint,CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
 		hintpane.addNext(prevBt,CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		hintpane.addNext(decodeButton,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		decodeButton.setMinimumSize(MyLocale.getScreenWidth()*2/3,10);
 		hintpane.addLast(moreBt,CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.EAST));
-		hint.modify(ControlConstants.NotEditable,0);
+		hint.modify(Control.NotEditable,0);
 
-		sbplog = new MyScrollBarPanel(htmlImagDisp, ScrollablePanel.NeverShowHorizontalScrollers);
-		//logpane.addLast(sbplog,CellConstants.STRETCH, CellConstants.FILL);
-		Rect r = new Rect(new Dimension (Global.getPref().myAppWidth-sbplog.vbar.getRect().width, 20));
-		htmlImagDisp.virtualSize = r;
-		htmlImagDisp.checkScrolls();
-		logpane.addLast(sbplog.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
-		this.addLast(split);
+		sbplog = new MyScrollBarPanel(logs, ScrollBarPanel.NeverShowHorizontalScrollers);
+		//sbplog.stretchFirstRow=true;sbplog.stretchLastRow=false; sbplog.backGround=new eve.fx.Color(0,0,255);
+		logpane.addLast(sbplog, CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(split, CellConstants.STRETCH, CellConstants.FILL);
 		clear();
 	}
-
+	
 	public void setText(CacheHolderDetail cache){
-	        if (currCache != cache){
-	            this.currCache = cache;
-	            if(!cache.Hints.equals(&quot;null&quot;)) 
-	                hint.setText(STRreplace.replace(cache.Hints, &quot;&lt;br&gt;&quot;, &quot;\n&quot;));
-	            else
-	                hint.setText(&quot;&quot;);
-	            crntLogPosition = 0;
-	            setLogs(0);
-	            moreBt.modify(0,ControlConstants.Disabled);
-	            prevBt.modify(0,ControlConstants.Disabled);
-	        }
+		this.currCache = cache;
+		if(!cache.hints.equals(&quot;null&quot;)) 
+			hint.setText(cache.hints);
+		else
+			hint.setText(&quot;&quot;);
+		crntLogPosition = 0;
+		setLogs(0);
+		moreBt.modify(0,Control.Disabled);
+		prevBt.modify(0,Control.Disabled);
+//		if (Gui.screenIs(Gui.PDA_SCREEN) &amp;&amp; Device.isMobile()) {
+//		Vm.setSIP(0);
+//		}
+		////Vm.debug(&quot;In log: &quot; + cache.CacheLogs);
 	}
 
 	public void clear() {
-	    clearOutput();
-	    currCache = null;
-	}
-	private void clearOutput() {
-		if (htmlTxtImage != null) {
+		logs.setHtml(&quot;loading ...&quot;);
+		/*if (htmlTxtImage != null) {
 			htmlImagDisp.removeImage(htmlTxtImage);
 			htmlTxtImage.free();		
-		}
+		}*/
 	}
 	void setLogs(int crntLogPosition) {
-		Vm.showWait(true);
+		Form.showWait();
+		clear();
 		StringBuffer dummy = new StringBuffer(DEFAULT_STRINGBUFFER_SIZE);
 		int counter = 0;
-		int nLogs=currCache.CacheLogs.size();
+		int nLogs=currCache.cacheLogs.size();
 		int logsPerPage=Global.getPref().logsPerPage;
 		for(int i = crntLogPosition; i&lt;nLogs; i++){
-			dummy.append(currCache.CacheLogs.getLog(i).toHtml());
+			dummy.append(currCache.cacheLogs.getLog(i).toHtml());
 			dummy.append(&quot;&lt;/br&gt;&quot;);
 			if(++counter &gt;= logsPerPage) break;
 		}
-		clearOutput();
-		logs.resizeTo(width, 50);
+		//logs.resizeTo(width, 50);
 		// The cache GCP0T6 crashes the HtmlDisplay
 		// As a temporary fix
 		try {
@@ -105,13 +103,13 @@
 		} catch (Exception e) {
 			logs=new HtmlDisplay();
 			Global.getPref().log(&quot;Error rendering HTML&quot;,e,true);
-			logs.setPlainText(&quot;Ewe VM: Internal error displaying logs&quot;);
+			logs.setPlainText(&quot;eve VM: Internal error displaying logs&quot;);
 		}
-		int h = logs.getLineHeight() * logs.getNumLines();
+		/*int h = logs.getLineHeight() * logs.getNumLines();
 		htmlTxtImage = new AniImage(new Image(width, h));
 		htmlTxtImage.setLocation(0, 0);
-		htmlTxtImage.properties |= mImage.IsMoveable;
-		Graphics draw = new Graphics(htmlTxtImage.image);
+		htmlTxtImage.properties |= AniImage.IsMoveable;
+		Graphics draw = new Graphics((Image)htmlTxtImage.getImage());
 		logs.resizeTo(htmlTxtImage.getWidth()-lastScrollbarWidth, htmlTxtImage.getHeight());
 		logs.doPaint(draw, new Rect(0,0,htmlTxtImage.getWidth(), htmlTxtImage.getHeight()));
 		htmlImagDisp.addImage(htmlTxtImage);
@@ -127,12 +125,14 @@
 		int scrollbarWidth = sbplog.vbar.getRect().width;
 		if (scrollbarWidth != lastScrollbarWidth) { 
 		    lastScrollbarWidth = scrollbarWidth;
-    		    logs.resizeTo(htmlTxtImage.getWidth()-scrollbarWidth, htmlTxtImage.getHeight());
-    		    logs.doPaint(draw, new Rect(0,0,htmlTxtImage.getWidth(), htmlTxtImage.getHeight()));
+   		    logs.resizeTo(htmlTxtImage.getWidth()-scrollbarWidth, htmlTxtImage.getHeight());
+   		    logs.doPaint(draw, new Rect(0,0,htmlTxtImage.getWidth(), htmlTxtImage.getHeight()));
 		}
+
 		htmlImagDisp.repaintNow();
+		*/
 		repaintNow();
-		Vm.showWait(false);
+		Form.cancelWait();
 	}
 
 	/**
@@ -143,25 +143,25 @@
 	 */
 	public void onEvent(Event ev){
 		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
-			int minLogs = java.lang.Math.min(Global.getPref().logsPerPage, currCache.CacheLogs.size());
+			int minLogs = java.lang.Math.min(Global.getPref().logsPerPage, currCache.cacheLogs.size());
 			if(ev.target == moreBt){
-				prevBt.modify(0,ControlConstants.Disabled);
+				prevBt.modify(0,Control.Disabled);
 				prevBt.repaintNow();
 				crntLogPosition += minLogs;
-				if(crntLogPosition &gt;= currCache.CacheLogs.size()) {
+				if(crntLogPosition &gt;= currCache.cacheLogs.size()) {
 					//crntLogPosition = cache.CacheLogs.size()-5;
-					crntLogPosition = currCache.CacheLogs.size()- minLogs;
-					moreBt.modify(ControlConstants.Disabled,0);
+					crntLogPosition = currCache.cacheLogs.size()- minLogs;
+					moreBt.modify(Control.Disabled,0);
 					moreBt.repaintNow();
 				}
 				setLogs(crntLogPosition);
 			} // = moreBt
 			if(ev.target == prevBt){
-				moreBt.modify(0,ControlConstants.Disabled);
+				moreBt.modify(0,Control.Disabled);
 				moreBt.repaintNow();
 				crntLogPosition -= minLogs;
 				if(crntLogPosition &lt;= 0) {
-					prevBt.modify(ControlConstants.Disabled,0);
+					prevBt.modify(Control.Disabled,0);
 					prevBt.repaintNow();
 					crntLogPosition = 0;
 				}
@@ -179,7 +179,7 @@
 	public boolean scrollHorizontal = false;
 	public boolean imageNotDragged(ImageDragContext drag,Point where) {
 		if (drag == null || drag.image == null) return super.imageNotDragged(drag, where);
-		getDim(null);
+		//Rect r = getDim(null);
 		if (drag.image.location.y &lt;= 0 ){
 			drag.image.move(0, drag.image.location.y);
 		} else {

Modified: experiments/engywuck/hist-test/src/cachewolf/HttpConnection.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/HttpConnection.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/HttpConnection.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,37 +1,37 @@
-package CacheWolf;
-import ewe.data.Property;
-import ewe.data.PropertyList;
-import ewe.io.AsciiCodec;
-import ewe.io.Base64Codec;
-import ewe.io.FileBase;
-import ewe.io.IOException;
-import ewe.io.IOHandle;
-import ewe.io.IOTransfer;
-import ewe.io.InputStream;
-import ewe.io.MemoryFile;
-import ewe.io.MemoryStream;
-import ewe.io.PartialInputStream;
-import ewe.io.Stream;
-import ewe.io.StreamAdapter;
-import ewe.io.StreamUtils;
-import ewe.io.TextCodec;
-import ewe.net.MalformedURLException;
-import ewe.net.Socket;
-import ewe.net.URL;
-import ewe.sys.Convert;
-import ewe.sys.Handle;
-import ewe.sys.Vm;
-import ewe.util.ByteArray;
-import ewe.util.CharArray;
-import ewe.util.SubString;
-import ewe.util.Vector;
-import ewe.util.mString;
+package cachewolf;
 
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.Socket;
+import java.util.Vector;
+
+import cachewolf.utils.Common;
+
+import eve.net.ChunkedDataInputStream;
+import eve.data.Property;
+import eve.data.PropertyList;
+import eve.io.AsciiCodec;
+import eve.io.File;
+import eve.io.PartialInputStream;
+import eve.io.StreamUtils;
+import eve.io.TextCodec;
+import eve.sys.Convert;
+import eve.sys.Handle;
+import eve.sys.Task;
+import eve.sys.TimeOut;
+import eve.sys.Vm;
+import eve.util.ByteArray;
+import eve.util.CharArray;
+import eve.util.SubString;
+import eve.net.Net;
+import eve.net.URL;
+
+
 /**
 Use this class to create an HttpConnection with a Web Server and to read
 in the data for the connection.&lt;p&gt;
-This a a modified version of XXX. This version automatically makes use of a proxy server
-if once for all proxy is set.
 To use this do the following:
 &lt;ol&gt;
 &lt;li&gt;Create an HttpConnection object with a URL or specify the host, port and document to get.
@@ -79,7 +79,7 @@
 * initial GET/POST line. This is initially null, so you will have to create a new PropertyList
 * for it, or use one of the setRequestorProperty() or addRequestorProperty() methods.
 **/
-public ewe.data.PropertyList requestorProperties;
+public PropertyList requestorProperties;
 /**
 * This is the list of properties for the server and document. It is only valid after a connection has
 * been made since it is sent by the server to the requestor. One properties that will always be in
@@ -87,7 +87,7 @@
 * All other properties will be as specified by the server, and &lt;b&gt;the property names will be
 * converted to all lowercase letters&lt;/b&gt;.
 **/
-public ewe.data.PropertyList documentProperties;
+public PropertyList documentProperties;
 /**
 * This is the response code from the server. It is only valid after a connection has
 * been made.
@@ -111,23 +111,24 @@
 **/
 public TextCodec textCodec;
 
-Stream bytesToPost;
+InputStream bytesToPost;
 Object originalPostData;
 
-/**
- * Set these when the class is instantiated the first time.
- * afterwards you don't need to set proxy parameters anymore
- */
+	/**
+	 * Set these when the class is instantiated the first time.
+	 * afterwards you don't need to set proxy parameters anymore
+	 */
+	private static String proxy = Global.getPref().myproxy;
+	private static int proxyPort = Common.parseInt(Global.getPref().myproxyport);
+	private static boolean useProxy = Global.getPref().proxyActive;
+	
+	public static void setProxy(String proxyi, int proxyporti, boolean useproxyi) {
+		proxy = proxyi;
+		proxyPort = proxyporti;
+		useProxy = useproxyi;
+	}
 
-private static String proxy = Global.getPref().myproxy;
-private static int proxyPort = Common.parseInt(Global.getPref().myproxyport);
-private static boolean useProxy = Global.getPref().proxyActive;
 
-public static void setProxy(String proxyi, int proxyporti, boolean useproxyi) {
-	proxy = proxyi;
-	proxyPort = proxyporti;
-	useProxy = useproxyi;
-}
 
 /**
  * This returns true if post data has been set for this connection.
@@ -184,15 +185,16 @@
 public void setPostData(Object data)
 //===================================================================
 {
-	if (data instanceof Stream) bytesToPost = (Stream)data;
+	if (data instanceof InputStream) bytesToPost = (InputStream)data;
 	else if (data instanceof ByteArray) {
 		originalPostData = data;
-		bytesToPost = new MemoryFile((ByteArray)data);
+		ByteArray ba = (ByteArray)data;
+		bytesToPost = new ByteArrayInputStream(ba.data,0,ba.length);
 		getRequestorProperties().defaultTo(&quot;Content-Length&quot;,Convert.toString(((ByteArray)data).length));
 	}
 	else if (data instanceof byte[]) {
 		originalPostData = data;
-		bytesToPost = new MemoryFile(new ByteArray((byte[])data));
+		bytesToPost = new ByteArrayInputStream((byte[])data);
 		getRequestorProperties().defaultTo(&quot;Content-Length&quot;,Convert.toString(((byte[])data).length));
 	}else if (data instanceof String){
 		String s = (String)data;
@@ -205,7 +207,6 @@
 			
 		}
 	}
-	else if (data instanceof InputStream) bytesToPost = new StreamAdapter((InputStream)data);
 	if (bytesToPost != null &amp;&amp; command.equalsIgnoreCase(&quot;get&quot;))
 		command = &quot;POST&quot;;
 }
@@ -288,31 +289,31 @@
 public HttpConnection(String url)
 //===================================================================
 {
-	if (useProxy) { 
-		host = proxy;
-		port = proxyPort;
-		document = url;
-	} else {
-		url = FileBase.fixupPath(url);
-		//ewe.sys.Vm.debug(&quot;url: &quot;+url);
-		port = 80;
-		String uu = url.toLowerCase();
-		if (uu.startsWith(&quot;<A HREF="http://">http://</A>&quot;)){
-			uu = url.replace('\\','/');
-			host = uu.substring(7);
-			int first = host.indexOf('/');
-			if (first == -1) document = &quot;/&quot;;
-			else {
-				document = host.substring(first);
-				host = host.substring(0,first);
+		if (useProxy) { 
+			host = proxy;
+			port = proxyPort;
+			document = url;
+		}	else {
+			url = File.fixupPath(url);
+			//ewe.sys.Vm.debug(&quot;url: &quot;+url);
+			port = 80;
+			String uu = url.toLowerCase();
+			if (uu.startsWith(&quot;<A HREF="http://">http://</A>&quot;)){
+				uu = url.replace('\\','/');
+				host = uu.substring(7);
+				int first = host.indexOf('/');
+				if (first == -1) document = &quot;/&quot;;
+				else {
+					document = host.substring(first);
+					host = host.substring(0,first);
+				}
+				int colon = host.indexOf(':');
+				if (colon != -1){
+					port = Convert.toInt(host.substring(colon+1));
+					host = host.substring(0,colon);
+				}
 			}
-			int colon = host.indexOf(':');
-			if (colon != -1){
-				port = ewe.sys.Convert.toInt(host.substring(colon+1));
-				host = host.substring(0,colon);
-			}
 		}
-	}
 }
 
 //===================================================================
@@ -335,7 +336,7 @@
 //===================================================================
 {
 	if (documentIsEncoded) return document;
-	else return URL.encodeURL(document,false);
+	return URL.encodeURL(document,false);
 }
 //===================================================================
 Object waitOnIO(Handle h,String errorMessage) throws IOException
@@ -345,8 +346,9 @@
 		h.waitOn(Handle.Success);
 		return h.returnValue;
 	}catch(Exception e){
-		if (h.errorObject instanceof IOException) throw (IOException)h.errorObject;
-		else throw new IOException(errorMessage);
+		if (h.error instanceof IOException) 
+			throw (IOException)h.error;
+		throw new IOException(errorMessage);
 	}
 }
 public static final int SocketConnected = 0x1;
@@ -364,7 +366,7 @@
 	if (td == null) td = new AsciiCodec();
 	PropertyList pl = new PropertyList();
 	if (requestorProperties != null) pl.set(requestorProperties);
-	pl.defaultTo(&quot;Connection&quot;,&quot;close&quot;);
+	pl.defaultTo(&quot;Connection&quot;,keepAliveMode ? &quot;keep-alive&quot; : &quot;close&quot;);
 	pl.defaultTo(&quot;Host&quot;,host);
 	StringBuffer sb = new StringBuffer();
 	sb.append(command+&quot; &quot;+getEncodedDocument()+&quot; &quot;+requestVersion+&quot;\r\n&quot;);
@@ -374,15 +376,15 @@
 	}
 	sb.append(&quot;\r\n&quot;);
 	String req = sb.toString();
-	char [] rc = ewe.sys.Vm.getStringChars(req);
+	char [] rc = Vm.getStringChars(req);
 	ByteArray ba = ((TextCodec)td.getCopy()).encodeText(rc,0,rc.length,true,null);
-	sock.write(ba.data,0,ba.length);
-	sock.flush();
+	OutputStream os = sock.getOutputStream();
+	os.write(ba.data,0,ba.length);
+	os.flush();
 	//
 	if (bytesToPost != null){
-		IOTransfer iot = new IOTransfer();
-		iot.transfer(bytesToPost,sock);
-		sock.flush();
+		StreamUtils.transfer(null,bytesToPost,os);
+		os.flush();
 		bytesToPost.close();
 		/*
 		// For debugging - output eol and a blank line.
@@ -396,8 +398,9 @@
 	int lastReceived = -1;
 	//
 	ba.clear();
+	InputStream is = sock.getInputStream();
 	while(true){
-		int got = sock.read();
+		int got = is.read();
 		if (got == -1) throw new IOException(&quot;Unexpected end of stream.&quot;);
 		if (got == 10){
 			if (lastReceived == 10) break; //Got all the data now.
@@ -413,7 +416,7 @@
 	}
 	data.set(all.data,0,all.length);
 	int got = data.split('\n',lines);
-	documentProperties = new ewe.data.PropertyList();
+	documentProperties = new PropertyList();
 	if (got == 0) throw new IOException(&quot;No response&quot;);
 
 
@@ -424,7 +427,7 @@
 		if (idx != -1){
 			int id2 = response.indexOf(' ',idx+1);
 			if (id2 != -1){
-				responseCode = ewe.sys.Convert.toInt(response.substring(idx+1,id2));
+				responseCode = Convert.toInt(response.substring(idx+1,id2));
 			}
 		}
 	}
@@ -444,7 +447,7 @@
 }
 
 static final String [] encodings = {&quot;transfer-coding&quot;,&quot;transfer-encoding&quot;};
-byte [] buffer;
+//byte [] buffer;
 
 
 
@@ -479,109 +482,6 @@
 	if (responseCode &lt; 300 || responseCode &gt; 399) return null;
 	return documentProperties.getString(&quot;location&quot;,null);
 }
-//===================================================================
-int readInChunkedHeader(Socket connection,ByteArray buff,CharArray chBuff) throws IOException
-//===================================================================
-{
- 	if (buffer == null) buffer = new byte[10240];
-	if (buff == null) buff = new ByteArray();
-	buff.clear();
-	while(true){
-		int got = connection.read();
-		if (got == -1) throw new IOException();
-		if (got == '\n') break;
-		buff.append((byte)got);
-	}
-	chBuff = new AsciiCodec().decodeText(buff.data,0,buff.length,true,chBuff);
-	String s = new String(chBuff.data,0,chBuff.length);
-	String length = mString.leftOf(s,';').trim().toUpperCase();
-	int clen = 0;
-	for (int i = 0; i&lt;length.length(); i++){
-		char c = length.charAt(i);
-		clen *= 16;
-		clen += c &lt;= '9' ? c-'0' : c-'A'+10;
-	}
-	//ewe.sys.Vm.debug(&quot;Length: &quot;+length+&quot; = &quot;+clen);
-	return clen;
-}
-/*
-//===================================================================
-Handle readInSomeData(final Socket connection,final int numBytes,final ByteArray dest)
-//===================================================================
-{
-	return new ewe.sys.TaskObject(){
-		protected void doRun(){
-			try{
-				ByteArray ba = dest;
-				if (ba == null) ba = new ByteArray();
-				ba.clear();
-				int size = numBytes;
-				if (buffer == null) buffer = new byte[10240];			
-				handle.setProgress(0.0f);
-				while(size &gt; 0){
-					int toRead = size &gt; buffer.length ? buffer.length : size;
-					toRead = connection.read(buffer,0,toRead);
-					if (toRead &lt;= 0) throw new IOException();
-					ba.append(buffer,0,toRead);
-					size -= toRead;
-					handle.setProgress((float)((double)(numBytes-size)/numBytes));
-				}
-				handle.setProgress(1.0f);
-				handle.returnValue = ba;
-				handle.set(Handle.Succeeded);
-				return;
-			}catch(Exception e){
-				handle.failed(e);
-			}finally{
-				if (!keepAliveMode || ((handle.check() &amp; handle.Success) == 0))
-					connection.close();
-			}
-		}
-	}.startTask();
-}
-*/
-/*
-//===================================================================
-Handle readInChunkedData(final Socket connection)
-//===================================================================
-{
-	return new ewe.sys.TaskObject(){
-		protected void doRun(){
-			try{
-				ByteArray ba = new ByteArray();
-				while(true){
-					handle.setProgress(-1f);
-					int size = readInChunkedHeader(connection,null,null);
-					if (size == 0) break;
-					if (buffer == null) buffer = new byte[10240];			
-					while(size &gt; 0){
-						int toRead = size &gt; buffer.length ? buffer.length : size;
-						//ewe.sys.Vm.debug(&quot;Reading: &quot;+toRead);
-						toRead = connection.read(buffer,0,toRead);
-						if (toRead &lt;= 0) throw new IOException();
-						ba.append(buffer,0,toRead);
-						size -= toRead;
-						handle.setProgress(-1f);
-					}
-					//
-					// Should be a CRLF after the data.
-					//
-					while(true){
-						int got = connection.read();
-						if (got == -1) throw new IOException();
-						if (got == '\n') break;
-					}
-				}
-				handle.returnValue = ba;
-				handle.set(Handle.Succeeded);
-				return;
-			}catch(IOException e){
-				handle.failed(e);
-			}
-		}
-	}.startTask();
-}
-*/
 /**
  * Read in all the data from the Socket.
  * @param connection The socket returned by a connect() call.
@@ -590,14 +490,21 @@
 	object that holds the data read in.
  */
 //===================================================================
-public Handle readInData(final Socket connection) 
+public Handle readInData(Socket connection) 
 //===================================================================
 {
 	int length = documentProperties.getInt(&quot;content-length&quot;,-1);
 	if (length == 0)
 		return new Handle(Handle.Succeeded,new ByteArray());
-	getInputStream();
-	return StreamUtils.readAllBytes(getInputStream(),null,length,0);
+	//
+	try{
+		InputStream is = getInputStream(connection);
+		return StreamUtils.readAllBytes(is,null,length,0);
+	}catch(IOException e){
+		Handle h = new Handle();
+		h.fail(e);
+		return h;
+	}
 }
 /**
  * Read in all the data from the Socket.
@@ -616,46 +523,30 @@
 * the readInData() method.
 **/
 //===================================================================
-public InputStream getInputStream()
+public InputStream getInputStream(Socket connectedSocket) throws IOException
 //===================================================================
 {
 	//ewe.sys.Vm.debug(documentProperties.toString());
 	int length = documentProperties.getInt(&quot;content-length&quot;,-1);
-	if (&quot;chunked&quot;.equals(documentProperties.getValue(encodings,null)))
-		return new MemoryStream(true){
-			byte[] buff = new byte[10240];
-			int leftInBlock = 0;
-			ByteArray ba = new ByteArray();
-			CharArray ca = new CharArray();
-			//-------------------------------------------------------------------
-			protected boolean loadAndPutDataBlock() throws IOException
-			//-------------------------------------------------------------------
-			{
-				if (leftInBlock &lt;= 0){
-					leftInBlock = readInChunkedHeader(connectedSocket,ba,ca);
-					if (leftInBlock &lt;= 0) return false;
-				}
-				int toRead = leftInBlock;
-				if (toRead &gt; buff.length) toRead = buff.length;
-				int got = connectedSocket.read(buff,0,toRead);
-				if (got == -1) throw new IOException();
-				leftInBlock -= got;
-				putInBuffer(buff,0,got);
-				if (leftInBlock == 0){
-					while(true){
-						got = connectedSocket.read();
-						if (got == -1) throw new IOException();
-						if (got == '\n') break;
-					}
-				}
-				return true;
-			}
-		}.toInputStream();
-		//throw new IOException(&quot;Cannot get input stream from this!&quot;);
-	else return 
-		new PartialInputStream(connectedSocket,length).toInputStream();
+	if (&quot;chunked&quot;.equals(documentProperties.getValue(encodings,null))){
+		//System.out.println(&quot;Is chunked!&quot;);
+		return new ChunkedDataInputStream(connectedSocket.getInputStream(),10240);
+	}
+	//System.out.println(&quot;Is not chunked!&quot;);
+	return new PartialInputStream(connectedSocket.getInputStream(),length);
+	
 }
 /**
+* Get an InputStream to read in the data. This is a very important method as it is used by
+* the readInData() method.
+**/
+//===================================================================
+public InputStream getInputStream() throws IOException
+//===================================================================
+{
+	return getInputStream(connectedSocket);
+}
+/**
  * Read in the document body from the Socket. This method blocks until the complete
  * data is read in. readInData() is a non-blocking version.
  * @param connection The socket returned by a connect() call.
@@ -683,20 +574,20 @@
 {
 	if (documentTextDecoder == null) documentTextDecoder = new AsciiCodec();
 	final TextCodec cc = (TextCodec)documentTextDecoder.getCopy();
-	return new ewe.sys.TaskObject(){
+	return new Task(){
 		protected void doRun(){
+			Handle handle = this;
 			try{
 				Handle h = readInData(connection);
-				if (!waitOnSuccess(h,true)) return;
+				if (!waitOnSuccess(h,TimeOut.Forever,true)) return;
 				ByteArray ba = (ByteArray)h.returnValue;
 				handle.returnValue = cc.decodeText(ba.data,0,ba.length,true,null);
 				handle.set(Handle.Succeeded);
 			}catch(Exception e){
-				handle.errorObject = e;
-				handle.set(Handle.Failed);
+				fail(e);
 			}
 		}
-	}.startTask();
+	}.start();
 }
 /**
  * Read in the document body from the Socket. This method blocks until the complete
@@ -737,42 +628,49 @@
 public Handle connectAsync(final TextCodec serverTextDecoder)
 //===================================================================
 {
-	return new ewe.sys.TaskObject(){
+	return new Task(){
 		protected void doRun(){
 			while(true){
 			//
 			// Create a Socket using an IOHandle.
 			//
-			Handle sh = (openSocket != null) ? new Handle(Handle.Succeeded,openSocket) : new IOHandle();
-			Socket sock = (openSocket != null) ? openSocket : new Socket(host,port,(IOHandle)sh);
+			Handle handle = this;
 			try{
-				//
-				// Now wait until connected.
-				//
-				if (!waitOnSuccess(sh,true)) return;
-				//ewe.sys.Vm.debug(&quot;Socket connected.&quot;);
-				//
-				// Report that the socket connection was made.
-				// Now have to decode the data.
-				//
-				handle.setFlags(SocketConnected,0);
-				//
-				makeRequest(sock,serverTextDecoder);
-				//ewe.sys.Vm.debug(&quot;Request made.&quot;);
-				handle.returnValue = connectedSocket = sock;
-				handle.setFlags(Handle.Success,0);
-				return;
-			}catch(Exception e){
-				if (openSocket == null){
-					handle.failed(e);
+				Handle sh = (openSocket != null) ? new Handle(Handle.Succeeded,openSocket) : Net.newSocket(host,port); 
+				try{
+					//
+					// Now wait until connected.
+					//
+					if (!waitOnSuccess(sh,TimeOut.Forever,true)){
+						handle.fail(sh.error);
+						return;
+					}
+					//ewe.sys.Vm.debug(&quot;Socket connected.&quot;);
+					//
+					// Report that the socket connection was made.
+					// Now have to decode the data.
+					//
+					Socket sock = (Socket)sh.returnValue;
+					handle.setFlags(SocketConnected,0);
+					//
+					makeRequest(sock,serverTextDecoder);
+					//ewe.sys.Vm.debug(&quot;Request made.&quot;);
+					handle.returnValue = connectedSocket = sock;
+					handle.setFlags(Handle.Success,0);
 					return;
-				}else{
+				}catch(Exception e){
+					if (openSocket == null){
+						handle.fail(e);
+						return;
+					}
 					openSocket = null;
 					continue;
 				}
+			}catch(Exception e){
+				handle.fail(e);
 			}
 		}}
-	}.startTask();
+	}.start();
 }
 /**
  * This makes the connection, blocking the current thread.
@@ -844,4 +742,3 @@
 }
 //##################################################################
 
-

Modified: experiments/engywuck/hist-test/src/cachewolf/ImageDetailScreen.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/ImageDetailScreen.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/ImageDetailScreen.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,17 +1,22 @@
-package CacheWolf;
-import ewe.ui.*;
+package cachewolf;
+import eve.fx.*;
+import eve.ui.*;
+import eve.ui.game.AniImage;
+import eve.ui.game.InteractivePanel;
+import eve.sys.Event;
+import eve.ui.event.ControlEvent;
+import eve.fx.Fx;
 
-
 /**
 * Class creates a view on the image scaled
 * to the application size, but only if the image is larger than
 * the available app size.
 */
-public class ImageDetailForm extends Form{
+public class ImageDetailScreen extends Form{
 	ImageInteractivePanel ipp = new ImageInteractivePanel();
 	ScrollBarPanel scp;
 	
-	public ImageDetailForm(String imgLoc, Preferences p){
+	public ImageDetailScreen(String imgLoc, Preferences p){
 		scp = new MyScrollBarPanel(ipp);
 		ipp.setImage(imgLoc);
 		this.title = &quot;Image&quot;;
@@ -25,5 +30,102 @@
 			this.close(0);
 		} else super.onEvent(ev);
 	}
+
+//#####################################################################################
+//  ImageInteractivePanel	
+//#####################################################################################
+	
+	/**
+	*	This class handles the resizing im images
+	*/
+	private class ImageInteractivePanel extends InteractivePanel{
+		int state = -1; // 0 = nothing, -1 = scaled to app, 1 = scaled to original size
+		//ScrollBarPanel scp;
+		String imgLoc = &quot;&quot;;
+		AniImage pic=null;
+		
+		public ImageInteractivePanel() {
+			super();
+			this.setMenu(mClose);
+		}
+		
+		private Menu mClose = new Menu(new String[]{
+				&quot;Close&quot;},&quot;&quot;);
+		
+		public void resizeTo(int w, int h) {
+			this.width = w;
+			this.height = h;
+			if (state == -1) fitImageToWindow();
+			virtualSize = new Rect(0, 0, java.lang.Math.max(w, pic.getWidth()), java.lang.Math.max(h, pic.getHeight()));
+			checkScrolls();
+			super.resizeTo(w, h);
+		}
+
+		public void setImage(String filename) {
+			imgLoc = filename;
+			Picture mI = new Picture(imgLoc);
+			if (pic != null) {
+				this.removeImage(pic);
+				pic.freeImage();
+				pic.free();
+			}
+			pic = new AniImage(mI);
+			pic.setLocation(0, 0);
+			// mI.free(); this works in the java-VM, but it will delete the image in the ewe-vm --&gt; leave it commeted out
+			this.addImage(pic);
+			virtualSize = new Rect(pic.getSize(null));
+			checkScrolls();
+		}
+			
+		public void fitImageToWindow() {
+			Rect s = this.parent.getRect();
+			int ww = pic.getWidth();
+			int wh = pic.getHeight();
+			double scale =  java.lang.Math.max((double)ww/(double)s.width, (double)wh/(double)s.height);
+			if (scale != 1){
+				this.removeImage(pic);
+				AniImage tmp = new AniImage(Fx.scaleImage(pic.getImageData(),(int)(ww/scale), (int)(wh/scale)));
+				pic.freeImage();
+				pic.free();
+				pic = tmp;
+				pic.setLocation(0, 0);
+				this.addImage(pic);
+				virtualSize = new Rect(pic.getSize(null));
+				checkScrolls();
+			}
+		}
+			
+		
+		public void imageClicked(AniImage which, Point pos){
+			state = -state;
+			if(state == 1){
+				setImage(imgLoc);
+				this.repaintNow();
+			}
+			if(state == -1){
+				fitImageToWindow();
+				this.repaintNow();
+			}
+		}
+
+		public void penRightReleased(Point p){
+				menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
+		}
+		
+		public void penHeld(Point p){
+				menuState.doShowMenu(p,true,null); 
+		}
+		public void popupMenuEvent(Object selectedItem){
+			postEvent(new ControlEvent(ControlEvent.EXITED,this));
+		}
+		public void formClosing() {
+			super.formClosing();
+			if (pic != null) {
+				pic.freeImage();
+				pic.free();
+			}
+		}	
+	} // ImageInteractivePanel
+
 }
 

Modified: experiments/engywuck/hist-test/src/cachewolf/ImagePanel.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/ImagePanel.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/ImagePanel.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,13 +1,17 @@
-package CacheWolf;
-import utils.FileBugfix;
-import ewe.graphics.*;
-import ewe.sys.*;
-import ewe.fx.*;
-import ewe.ui.*;
-import ewe.io.*;
-import ewe.util.*;
+package cachewolf;
+import eve.sys.*;
+import eve.fx.*;
+import eve.ui.*;
+import eve.io.*;
+import java.util.*;
 
+import cachewolf.utils.SafeXML;
 
+
+import eve.ui.game.*;
+import eve.ui.event.*;
+
+
 /**
 *	Class to display the cache and log images. It creates a thumbnail view and
 *	allows the user to click on an image that will then be displayed in its original size
@@ -37,22 +41,22 @@
 	public ImagePanel(){
 	}
 	
-	static CacheHolderDetail oldCache=null;
+//	static CacheHolderDetail oldCache=null;
 	/**
 	* Method to set the individual cache images.
 	* Gets called immediatly before panel is displayed
 	* @see MainTab#onEvent(Event ev)
 	*/
 	public void setImages(CacheHolderDetail cache){
-		if (cache!=oldCache) {
+//		if (cache!=oldCache) {
 			pref = Global.getPref();
 			profile=Global.getProfile();
-			Vm.showWait(true);
+			Form.showWait();
 			clearImages();
-			thumb_size = ((pref.myAppWidth-2*padding) / 3);
+			thumb_size = (pref.myAppWidth-2*padding) / 3;
 			thumb_size = thumb_size - padding;
-			int rowCounter = cache.Images.size() + cache.UserImages.size();
-			rowCounter = (rowCounter/3)+1;
+			int rowCounter = cache.images.size() + cache.userImages.size();
+			rowCounter = rowCounter/3+1;
 			Rect r = new Rect(0, 0, pref.myAppWidth, rowCounter*thumb_size+rowCounter*padding+padding);
 			this.virtualSize = r;
 			//this.setPreferredSize(pref.myAppWidth, rowCounter*thumb_size+rowCounter*padding+40);
@@ -62,22 +66,22 @@
 			addTitle(MyLocale.getMsg(340,&quot;Cache Images:&quot;));
 			locY = 20;
 			locX = padding;
-			addImages(cache.Images,cache.ImagesText);
+			addImages(cache.images,cache.imagesText);
 			// load user images
 			if(locCounter==1 || locCounter ==2) locY = locY + thumb_size;
 			//Vm.debug(&quot;thumb_size: &quot; + Convert.toString(thumb_size));
 			//Vm.debug(&quot;locy after: &quot; + Convert.toString(locY));
-			if (cache.UserImages.getCount()&gt; 0){
+			if (cache.userImages.size()&gt; 0){
 				addTitle(MyLocale.getMsg(341,&quot;User Images:&quot;));
 				locY = locY + 20;
 				locX = padding;
 				locCounter = 0;
-				addImages(cache.UserImages,cache.UserImagesText);
+				addImages(cache.userImages,cache.userImagesText);
 			}
-			oldCache=cache;
-		} // cache!=oldCache	
+//			oldCache=cache;
+//		} // cache!=oldCache	
 		this.refresh();
-		Vm.showWait(false);
+		Form.cancelWait();
 		//this.repaintNow();
 	}
 
@@ -86,7 +90,7 @@
 	 *
 	 */
 	public void clearImages() {
-		oldCache=null;
+//		oldCache=null;
 		int lgr = images.size();
 		for(int i = 0; i&lt;lgr;i++){
 			this.removeImage((AniImage)images.get(0));
@@ -124,7 +128,7 @@
 	 */
 	private void addImages(Vector images, Vector imagesText) {
 		String location, imgText;
-		mImage mI;
+		PixelBuffer mI;
 		int scaleX, scaleY;
 		double dummyC;
 		ImagePanelImage ipi;
@@ -132,13 +136,13 @@
 		locCounter=0;
 		for(int i = 0; i&lt;images.size(); i++){
 			location = profile.dataDir + (String)images.get(i);
-			if (!(new FileBugfix(location)).exists()) {
+			if (!(new File(location)).exists()) {
 				location=NO_IMAGE;
 				if (!pref.showDeletedImages) continue; // Don't show the deleted Image if user does not want it
 			}
 			try{
-				mI = new mImage(location);
-				// actuall new mImage(location); should do the following &quot;if&quot; but it doesn't anyhow
+				mI = new PixelBuffer(location);
+				// actuall new Picture(location); should do the following &quot;if&quot; but it doesn't anyhow
 				if (mI.getWidth() &lt;= 0 || mI.getHeight() &lt;= 0 ) throw new IllegalArgumentException(location);
 				scaleX = thumb_size;
 				scaleY = thumb_size;
@@ -160,11 +164,11 @@
 					scaleX = mI.getWidth();
 					scaleY = mI.getHeight();
 				}
-				mI = mI.scale(scaleX,scaleY,null,0);
-				mI.freeSource();
-				ipi = new ImagePanelImage(mI);
-				ipi.freeSource();
-				//mI.free(); --&gt; this only works in java-VM, in ewe it will delete the image, so leave it commented out
+				mI = mI.scale(scaleX,scaleY);
+				ipi = new ImagePanelImage(mI.getImageData());
+				mI.freeImage();
+				ipi.freeImage();
+				//mI.free(); --&gt; this only works in java-VM, in ewe it will delete the image, so leave it commented out				ipi.fileName = location; // this is set only to easily identify the filename of the image clicked
 				ipi.fileName = location; // this is set only to easily identify the filename of the image clicked
 				ipi.setLocation(locX, locY);
 				addImage(ipi);
@@ -175,7 +179,7 @@
 					else
 						imgText = SafeXML.cleanback((String)imagesText.get(i));
 					if(imgText.length()==0) imgText = &quot;???&quot;;
-					AimgText = new AniImage();
+					//AimgText = new AniImage();
 					AimgText = getImageText(imgText);
 					AimgText.setLocation(locX,locY+scaleY);
 					addImage(AimgText);
@@ -192,12 +196,12 @@
 					locY = locY+thumb_size+padding;
 				}
 			}catch(IllegalArgumentException imex){ // file not found, could not decode etc.
-				MessageBox tmp = new MessageBox(MyLocale.getMsg(321,&quot;Fehler&quot;), MyLocale.getMsg(322,&quot;Kann Bild/Karte nicht laden&quot;)+&quot;:\n&quot;+imex.getMessage(), FormBase.OKB); // @todo: language support
+				MessageBox tmp = new MessageBox(MyLocale.getMsg(321,&quot;Fehler&quot;), MyLocale.getMsg(322,&quot;Kann Bild/Karte nicht laden&quot;)+&quot;:\n&quot;+imex.getMessage(), MessageBox.OKB); // @todo: language support
 				tmp.exec();
 			} catch (OutOfMemoryError e) { // TODO show an error icon in the panel instead of nothing
-				(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(343,&quot;Not enough free memory to load cache image&quot;)+&quot;:\n&quot;+location,FormBase.OKB)).exec();
+				(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(343,&quot;Not enough free memory to load cache image&quot;)+&quot;:\n&quot;+location,MessageBox.OKB)).exec();
 			} catch (SystemResourceException e) { // TODO show an error icon in the panel instead of nothing
-				(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(343,&quot;Not enough free memory to load cache image&quot;)+&quot;\n&quot;+location,FormBase.OKB)).exec();
+				(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(343,&quot;Not enough free memory to load cache image&quot;)+&quot;\n&quot;+location,MessageBox.OKB)).exec();
 			}
 		} //for
 		
@@ -228,12 +232,13 @@
 	* If right mouse key is clicked, a dialogue to delete the image wil be displayed
 	*/
 	public void imageClicked(AniImage which, Point pos){
-//		Vm.debug(&quot;Clicked&quot;+pos.x+&quot;,&quot;+pos.y+&quot; &quot;+(((Control.currentPenEvent.modifiers&amp;PenEvent.RIGHT_BUTTON)==PenEvent.RIGHT_BUTTON)?&quot;RIGHT&quot;:&quot;LEFT&quot;) );
-		if ((ControlBase.currentPenEvent.modifiers&amp;PenEvent.RIGHT_BUTTON)==PenEvent.RIGHT_BUTTON || duration&gt;LONG_PEN_DOWN_DURATION) {
+		//eve.sys.Vm.debug(&quot;Clicked&quot;+pos.x+&quot;,&quot;+pos.y+&quot; &quot;+(((eve.ui.Gui.currentPenPress().modifiers&amp;PenEvent.RIGHT_BUTTON)==PenEvent.RIGHT_BUTTON)?&quot;RIGHT&quot;:&quot;LEFT&quot;) );
+		
+		if ((Gui.currentPenPress().modifiers&amp;PenEvent.RIGHT_BUTTON)==PenEvent.RIGHT_BUTTON || duration&gt;LONG_PEN_DOWN_DURATION) {
 			// Right button pressed - delete image to conserve space
 			if (which instanceof ImagePanelImage &amp;&amp; !((ImagePanelImage)which).fileName.equals(NO_IMAGE)) {
-				MessageBox mBox = new MessageBox (MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(344,&quot;Delete image&quot;)+&quot; \&quot;&quot;+((ImagePanelImage)which).imageText+&quot;\&quot;?&quot;, FormBase.IDYES |FormBase.IDNO);
-				if (mBox.execute() == FormBase.IDOK){
+				MessageBox mBox = new MessageBox (MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(344,&quot;Delete image&quot;)+&quot; \&quot;&quot;+((ImagePanelImage)which).imageText+&quot;\&quot;?&quot;, MessageBox.IDYES |MessageBox.IDNO);
+				if (mBox.execute() == MessageBox.IDOK){
 						//Vm.debug(&quot;Deleting &quot;+((ImagePanelImage)which).fileName);
 						try {
 							File f=new File(((ImagePanelImage)which).fileName);
@@ -243,18 +248,18 @@
 				}
 			}
 		} else { 
-			String fn = new String();
+			String fn;
 			if(which instanceof ImagePanelImage){
 				ImagePanelImage ich = (ImagePanelImage)which;
 				fn = ich.fileName;
 				try {
-					ImageDetailForm iF = new ImageDetailForm(fn, pref);
+					ImageDetailScreen iF = new ImageDetailScreen(fn, pref);
 					iF.execute(null, Gui.CENTER_FRAME);
 				} catch (IllegalArgumentException e) {
-					MessageBox tmp = new MessageBox(MyLocale.getMsg(321,&quot;Fehler&quot;), MyLocale.getMsg(322,&quot;Kann Bild/Karte nicht finden&quot;), FormBase.OKB); // @todo: language support
+					MessageBox tmp = new MessageBox(MyLocale.getMsg(321,&quot;Fehler&quot;), MyLocale.getMsg(322,&quot;Kann Bild/Karte nicht finden&quot;), MessageBox.OKB); // @todo: language support
 					tmp.exec();
 				} catch (OutOfMemoryError e) {
-					(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(343,&quot;Not enough free memory to load cache image&quot;)+&quot;\n&quot;+fn,FormBase.OKB)).exec();
+					(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(343,&quot;Not enough free memory to load cache image&quot;)+&quot;\n&quot;+fn,MessageBox.OKB)).exec();
 				}
 			}
 		}
@@ -274,4 +279,19 @@
 		}
 		super.onPenEvent(ev);
 	}
+	
+	/**
+	* The ImagePanelImage extends AniImage by a fileName.
+	* This is an easy way to identify the image clicked,
+	* what is needed to display the full image from the
+	* thumbnail.
+	*/
+	private class ImagePanelImage extends AniImage{
+		public String fileName = &quot;&quot;;
+		public String imageText = null;
+		public ImagePanelImage(ImageData i){
+			super(i);
+		}
+	}
+
 }
\ No newline at end of file

Modified: experiments/engywuck/hist-test/src/cachewolf/InfoBox.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/InfoBox.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/InfoBox.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,14 +1,17 @@
-package CacheWolf;
-import ewe.ui.*;
+package cachewolf;
+import eve.ui.*;
+import eve.sys.*;
+import eve.fx.gui.*;
+import eve.ui.event.*;
 
 public class InfoBox extends Form{
 	TextMessage msgArea;
-	mCheckBox mCB;
+	CheckBox mCB;
 	TextMessage warnings;
 	public boolean mCB_state = false;
-	mButton mB = new mButton(&quot;OK&quot;);
-	mButton mC = new mButton(&quot;Cancel&quot;);
-	mInput feedback = new mInput();
+	Button mB = new Button(&quot;OK&quot;);
+	Button mC = new Button(&quot;Cancel&quot;);
+	public Input feedback = new Input();
 	public final static int CHECKBOX = 1;
 	public final static int INPUT = 2;
 	public final static int DISPLAY_ONLY = 3;
@@ -22,17 +25,6 @@
 
 	public InfoBox(String title, String info){
 		this(title, info, DISPLAY_ONLY);
-
-		/*this.setPreferredSize(170,50);
-		this.title = title;
-		msgArea = new MessageArea(&quot;&quot;), CellConstants.STRETCH, CellConstants.FILL)
-		this.addLast(scP = new ScrollBarPanel(msgArea));
-		msgArea.setText(info);
-		mB.setHotKey(0, IKeys.ACTION);
-		mB.setHotKey(0, IKeys.ENTER);
-		//mB.set(Control.Invisible, true);
-		//this.addLast(mB, CellConstants.STRETCH, CellConstants.FILL);
-		 */
 	}
 
 	public String getInput(){
@@ -46,13 +38,12 @@
 
 	public InfoBox(String title, String info, int ty){
 		this(title, info, ty, true);
-//		this.setPreferredSize(170, 50);
+		//this.setPreferredSize(170, 50);
 		relayout(false);
 	}
 
 	public InfoBox(String title, String info, int ty, boolean autoWrap) {
 		type = ty;
-//		this.setPreferredSize(150,50);
 		// Resize InfoBox with Fontsize
 		Preferences pref=Global.getPref();
 		int fs = pref.fontSize;
@@ -64,35 +55,36 @@
 		if((fs &gt; 21) &amp;&amp; (sw &gt;= 300)){psx=300;psy=110;}
 		if((fs &gt; 24) &amp;&amp; (sw &gt;= 350)){psx=350;psy=130;}
 		this.setPreferredSize(psx, psy);
+
 		this.title = title;
 		switch (type) {
 		case CHECKBOX: 
-			mCB = new mCheckBox(info);
+			mCB = new CheckBox(info);
 			this.addLast(mCB, CellConstants.STRETCH, CellConstants.FILL);
 			break;
 		case INPUT:
-			mLabel mL = new mLabel(info);
+			Label mL = new Label(info);
 			this.addNext(mL, CellConstants.STRETCH, CellConstants.FILL);
 			this.addLast(feedback, CellConstants.STRETCH, CellConstants.FILL);
 			break;
 		case DISPLAY_ONLY:
 			msgArea = new TextMessage(info);
 			msgArea.autoWrap = autoWrap;
-			msgArea.alignment = CellConstants.CENTER;
-			msgArea.anchor = CellConstants.CENTER;
+			msgArea.alignment = Gui.CENTER;
+			msgArea.anchor = Gui.CENTER;
 			this.addLast(msgArea.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
 			break;
 		case PROGRESS_WITH_WARNINGS:
 			msgArea = new TextMessage(info);
 			msgArea.autoWrap = autoWrap;
-			msgArea.alignment = CellConstants.CENTER;
-			msgArea.anchor = CellConstants.CENTER;
+			msgArea.alignment = Gui.CENTER;
+			msgArea.anchor = Gui.CENTER;
 			msgArea.setPreferredSize(psx-20, psy);
 			this.addLast(msgArea.getScrollablePanel(), CellConstants.HEXPAND | CellConstants.HGROW, CellConstants.HEXPAND | CellConstants.HGROW);
 			warnings = new TextMessage(&quot;&quot;);
 			warnings.autoWrap = autoWrap;
 			this.addLast(warnings.getScrollablePanel(), CellConstants.HEXPAND | CellConstants.VEXPAND |CellConstants.VGROW, CellConstants.HEXPAND | CellConstants.VEXPAND |CellConstants.VGROW);
-			mB.set(ControlConstants.Disabled, true);
+			mB.set(Control.Disabled, true);
 			mB.setPreferredSize(40, 20);
 			addLast(mB, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
 			break;
@@ -116,7 +108,7 @@
 	}
 	public void setInfoWidth(int widthi) {
 		msgArea.setPreferredSize(widthi,getPreferredSize(null).height);
-	}
+	}	
 	public String getInfo(){
 		return msgArea.getText();
 	}
@@ -125,7 +117,7 @@
 		warnings.setText(warnings.text + w);
 	}
 	public void addOkButton() { //unfortunately this doesn't work
-		mB.set(ControlConstants.Disabled, false);
+		mB.set(Control.Disabled, false);
 		//addNext(mB);
 		//relayout(true);
 		//mB.set(Control.Invisible, false);
@@ -136,10 +128,10 @@
 		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
 			if(ev.target == mB){
 				if(type == CHECKBOX) mCB_state = mCB.getState();
-				this.close(FormBase.IDOK);
+				this.close(Form.IDOK);
 			}
 			if(ev.target == mC){
-				this.close(FormBase.IDCANCEL);
+				this.close(Form.IDCANCEL);
 			}
 		}
 		super.onEvent(ev);

Modified: experiments/engywuck/hist-test/src/cachewolf/InfoHtmlScreen.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/InfoHtmlScreen.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/InfoHtmlScreen.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,39 +1,47 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.ui.*;
-import ewe.io.*;
+import eve.ui.*;
+import eve.io.File;
+import eve.sys.*;
+import eve.ui.formatted.HtmlDisplay;
+import eve.ui.event.ControlEvent;
 
+
 /**
 *	This class displays an information screen. It loads the html text to display
 *	from a file that is given upon creation of this class. It offers
 *	a cancel button enabling the user to close the screen and return to
 *	wherever the user was before
-*	Class ID = 3000
 */
-public class InfoScreen extends Form {
+public class InfoHtmlScreen extends Form {
 	
 	HtmlDisplay disp = new HtmlDisplay();
-	mButton btCancel;
-	Preferences pref;
+	Button btCancel;
 	
-	public InfoScreen(String datei, String tit, boolean readFromFile, Preferences p){
-		pref = p;
-		String text = new String();
-		this.setTitle(tit);
+	public InfoHtmlScreen(String datei, String tit, boolean readFromFile){
+		String text = &quot;&quot;;
+		this.title=tit;
+		Preferences pref = Global.getPref();
 		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
 		if(readFromFile == true){
 			try{
-				FileReader in = new FileReader(datei);
-				text = in.readAll();
+				char buf[]=new char[(int) (new File(datei)).getLength()];
+				java.io.InputStreamReader in = new java.io.InputStreamReader(new java.io.FileInputStream(datei),&quot;UTF8&quot;);
+				int len=in.read(buf);
 				in.close();
+				eve.util.CharArray ca=new eve.util.CharArray(buf); ca.setLength(len);
+				text=(ca).toString();
+				//BufferedReader in = new BufferedReader(new FileReader(datei));
+				//text = in.readAll();
+				//in.close();
 			}catch(Exception ex){
 				//Vm.debug(&quot;Error! Could not open &quot; + datei);
 			}
 		} else text = datei;
 		disp.setHtml(text);
-		ScrollBarPanel sbp = new MyScrollBarPanel(disp, ScrollablePanel.NeverShowHorizontalScrollers);
+		ScrollBarPanel sbp = new MyScrollBarPanel(disp, ScrollBarPanel.NeverShowHorizontalScrollers);
 		this.addLast(sbp);
-		this.addLast(btCancel = new mButton(MyLocale.getMsg(3000,&quot;Close&quot;)),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		this.addLast(btCancel = new Button(MyLocale.getMsg(3000,&quot;Close&quot;)),CellConstants.DONTSTRETCH, CellConstants.FILL);
 	}
 	
 	public void onEvent(Event ev){

Modified: experiments/engywuck/hist-test/src/cachewolf/Log.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/Log.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/Log.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,5 +1,7 @@
-package CacheWolf;
+package cachewolf;
 
+import cachewolf.imp.GPXImporter;
+
 public class Log {
 	private static String MAXLOGICON=&quot;MAXLOG&quot;;
 	private static String INVALIDLOGICON=null;
@@ -19,7 +21,7 @@
 	 * or &lt;img src='ICON'&gt;&nbsp;DATE by LOGGER&lt;br&gt;MESSAGE&lt;/pre&gt;
 	 * @param logLine
 	 */
-	Log(String logLine) {
+	public Log(String logLine) {
 //		RECOMMENDED=&quot;1&quot;&lt;img src='icon_smile.gif'&gt;&nbsp;2007-01-14 xyz&lt;br&gt;a wonderful log
 		try {
 			int ic1=logLine.indexOf(&quot;RECOMMENDED=\&quot;1\&quot;&quot;);
@@ -47,11 +49,11 @@
 		}
 	}
 	
-	Log(String icon, String date, String logger, String message) {
+	public Log(String icon, String date, String logger, String message) {
 		this(icon, date, logger, message, false);
 	}
 	
-	Log(String icon, String date, String logger, String message, boolean recommended_) {
+	public Log(String icon, String date, String logger, String message, boolean recommended_) {
 		this.icon=icon;
 		this.date=date;
 		this.logger=logger;

Modified: experiments/engywuck/hist-test/src/cachewolf/LogList.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/LogList.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/LogList.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,6 +1,6 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.util.Vector;
+import java.util.Vector;
 
 public class LogList {
 	/** The Vector containing the Log objects 
@@ -38,7 +38,7 @@
 
 	/** Replace a Log in the list */
 	public void replace(int i, Log log) {
-		logList.set(i, log);
+		logList.setElementAt(log,i);
 	}
 	
 	/** Merge a log into the list at the appropriate position
@@ -75,18 +75,17 @@
 				if (!log.getMessage().equals(newLog.getMessage())) {
 					replace(i,newLog);
 					return i;
-				} else
-					return -1; // Log already in list
+				} 
+				return -1; // Log already in list
 			}
 			i++;
 		}
 		if (i==size) {
 			add(newLog);
 			return i;
-		} else {
-			logList.insertElementAt(newLog, firstLog);
-			return firstLog;
-		}
+		} 
+		logList.insertElementAt(newLog, firstLog);
+		return firstLog;
 	}
 
 	 /**

Modified: experiments/engywuck/hist-test/src/cachewolf/MainForm.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/MainForm.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/MainForm.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,19 +1,19 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.ui.*;
-import ewe.sys.*;
-import ewe.fx.*;
+import eve.ui.*;
+import eve.sys.*;
+import eve.fx.*;
 
 /**
 *	Mainform is responsible for building the user interface.
 *	Class ID = 5000
 */
-public class MainForm extends Editor {
+public class MainForm extends Form {
 	// The next three declares are for the cachelist
 	public boolean cacheListVisible=false;
     public CacheList cacheList;
     SplittablePanel split;
-	
+
 	StatusBar statBar=null;
 	Preferences pref = Global.getPref(); // Singleton pattern
 	Profile profile = Global.getProfile();
@@ -31,84 +31,89 @@
 	public MainForm(){
 		doIt();
 	}
-	
+
 	public MainForm(boolean dbg, String pathtoprefxml){
 		pref.debug = dbg;
-		pref.setPathToConfigFile(pathtoprefxml); // in case pathtoprefxml == null the preferences will determine the path itself 
+		pref.setPathToConfigFile(pathtoprefxml); // in case pathtoprefxml == null the preferences will determine the path itself
 		doIt();
 	}
 	protected void checkButtons() {
 		if (pref.hasCloseButton) super.checkButtons();
-	} 
+	}
 
 	protected boolean canExit(int exitCode) {
 		mTab.saveUnsavedChanges(true);
 		return pref.hasCloseButton;
 	}
-	
+
 	public void doIt(){
-		//CellPanel [] p = addToolbar();
+		//*maximizeOnPDA();
+		//*Form.showWait();
+		//*pref.readPrefFile();
 		Global.mainForm=this;
 		//this.title = &quot;CacheWolf &quot; + Version.getRelease();
 		this.exitSystemOnClose = true;
 		this.resizable = true;
 		this.moveable = true;
-		this.windowFlagsToSet = WindowConstants.FLAG_MAXIMIZE_ON_PDA;
-		if(Vm.isMobile() == true) {
-			//this.windowFlagsToSet |=Window.FLAG_FULL_SCREEN;
+		this.windowFlagsToSet = Window.FLAG_MAXIMIZE_ON_PDA;
+		if (!Device.isMobile()) {
 			this.resizable = false;
 			this.moveable = false;
+			int h,w;
+			h=pref.myAppHeight;
+			if (h&gt;MyLocale.getScreenHeight()) h=MyLocale.getScreenHeight();
+			w=pref.myAppWidth;
+			if (w&gt;MyLocale.getScreenWidth()) w=MyLocale.getScreenWidth();
+			this.setPreferredSize(w,h);
 		}
-		Rect screen = ((ewe.fx.Rect) (Window.getGuiInfo(WindowConstants.INFO_SCREEN_RECT,null,new ewe.fx.Rect(),0)));
-		if ( screen.height &gt;= 600 &amp;&amp; screen.width &gt;= 800) this.setPreferredSize(800, 600);
 		this.resizeOnSIP = true;
-		InfoBox infB = null;  
+		InfoBox infB = null;
+		// Load CacheList
 		try{
 			pref.readPrefFile();
 			if (MyLocale.initErrors.length() != 0) {
 				new MessageBox(&quot;Error&quot;, MyLocale.initErrors, FormBase.OKB).execute();
 			}
 			addGuiFont();
-			if (!pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_ONOROFF, true)) 
-				ewe.sys.Vm.exit(0); // User MUST select or create a profile
-			Vm.showWait(true);
-			// Load CacheList
+			if (!pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_ONOROFF, true))
+				eve.sys.Vm.exit(0); // User MUST select or create a profile
+			Form.showWait();
 			infB = new InfoBox(&quot;CacheWolf&quot;,MyLocale.getMsg(5000,&quot;Loading Cache-List&quot;));
 			infB.exec();
-			infB.waitUntilPainted(100);
+			infB.getWindow().waitUntilPainted(100);
 			profile.readIndex();
 			pref.curCentrePt.set(profile.centre);
-			profile.updateBearingDistance();
-			boolean saveHasUnsavedChanges = profile.hasUnsavedChanges; 
-			profile.restoreFilter(); // this method sets hasUnsavedChanges to true 
-			profile.hasUnsavedChanges = saveHasUnsavedChanges ; // in case that the profile is new, it hasUnsavedChanges, so set it back
-			setTitle(&quot;Cachewolf &quot;+Version.getRelease()+&quot; - &quot;+profile.name);
+ 			profile.updateBearingDistance();
+ 			boolean saveHasUnsavedChanges = profile.hasUnsavedChanges;
+ 			profile.restoreFilter(); // this method sets hasUnsavedChanges to true
+ 			profile.hasUnsavedChanges = saveHasUnsavedChanges ; // in case that the profile is new, it hasUnsavedChanges, so set it back
+			title=&quot;Cachewolf &quot;+Version.getRelease()+&quot; - &quot;+profile.name;
 		} catch (Exception e){
 			if(pref.debug == true) Vm.debug(&quot;MainForm:: Exception:: &quot; + e.toString());
 		}
-		
-		
+
+
 		if(pref.fixSIP == true){
-			if (Gui.screenIs(Gui.PDA_SCREEN) &amp;&amp; Vm.isMobile()) {
+			if (Gui.screenIs(Gui.PDA_SCREEN) &amp;&amp; Device.isMobile()) {
 				//Vm.setSIP(Vm.SIP_LEAVE_BUTTON|Vm.SIP_ON);
-				Vm.setParameter(Vm.SET_ALWAYS_SHOW_SIP_BUTTON,1);
+				//TODO Vm.setParameter(Vm.SET_ALWAYS_SHOW_SIP_BUTTON,1);
 				Device.preventIdleState(true);
 			}
-		} else Vm.setSIP(0);
-		
-        if (pref.showStatus) statBar = new StatusBar(pref, profile.cacheDB);
+		} //TODO else Vm.setSIP(0);
+
+        if (pref.showStatus) statBar = new StatusBar();
 		mMenu = new MainMenu(this);
 		mTab = new MainTab(mMenu,statBar);
 		split=new SplittablePanel(PanelSplitter.HORIZONTAL);
 		split.theSplitter.thickness=0; split.theSplitter.modify(Invisible,0);
 		CellPanel pnlCacheList = split.getNextPanel();
-		CellPanel pnlMainTab = split.getNextPanel(); 
+		CellPanel pnlMainTab = split.getNextPanel();
 		split.setSplitter(PanelSplitter.MIN_SIZE|PanelSplitter.BEFORE,PanelSplitter.HIDDEN|PanelSplitter.BEFORE,PanelSplitter.CLOSED);
 		pnlCacheList.addLast(cacheList=new CacheList(),STRETCH,FILL);
 		pnlMainTab.addLast(mTab,STRETCH,FILL);
-		
+
 		mTab.dontAutoScroll=true;
-		
+
 		this.addLast(split,STRETCH,FILL);
 		/*
 		if (pref.menuAtTop) {
@@ -121,30 +126,31 @@
 		*/
 		mMenu.setTablePanel(mTab.getTablePanel());
 		if (infB != null) infB.close(0);
+		mTab.tbP.resetModel();
 		mTab.tbP.selectFirstRow();
 		//mTab.tbP.tc.paintSelection();
-		Vm.showWait(false);
+		Form.cancelWait();
 	}
 
-	
+
 	private void addGuiFont(){
-		Font defaultGuiFont = mApp.findFont(&quot;gui&quot;);
+		Font defaultGuiFont = Application.findFont(&quot;gui&quot;);
 		int sz = (pref.fontSize);
-		Font newGuiFont = new Font(defaultGuiFont.getName(), defaultGuiFont.getStyle(), sz); 
-		mApp.addFont(newGuiFont, &quot;gui&quot;); 
-		mApp.fontsChanged();
-		mApp.mainApp.font = newGuiFont;
+		Font newGuiFont = new Font(defaultGuiFont.getName(), defaultGuiFont.getStyle(), sz);
+		Application.addFont(newGuiFont, &quot;gui&quot;);
+		Application.mainApp.font = newGuiFont;
+		Application.fontsChanged();
 	}
-	
+
 	public void doPaint(Graphics g, Rect r){
 		pref.myAppHeight = this.height;
 		pref.myAppWidth = this.width;
 		super.doPaint(g,r);
 	}
-	
+
 	public void onEvent(Event ev){ // Preferences have been changed by PreferencesScreen
 		if(pref.dirty == true){
-			mTab.getTablePanel().myMod.setColumnNamesAndWidths();
+			mTab.getTablePanel().tModel.setColumnNamesAndWidths();
 			mTab.getTablePanel().refreshControl();
 		    //mTab.getTablePanel().refreshTable();
 			pref.dirty = false;
@@ -155,7 +161,7 @@
 	public void toggleCacheListVisible() {
 		cacheListVisible=!cacheListVisible;
 		if (cacheListVisible) {
-			// Make the splitterbar visible with a width of 6 
+			// Make the splitterbar visible with a width of 6
 			split.theSplitter.modify(0,Invisible);
 			split.theSplitter.resizeTo(6,split.theSplitter.getRect().height);
 			Global.mainForm.mMenu.cacheTour.modifiers|=MenuItem.Checked;
@@ -167,7 +173,7 @@
 		}
 		split.theSplitter.doOpenClose(cacheListVisible);
 		Global.mainForm.mMenu.repaint();
-		
+
 	}
-	
+
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/MainMenu.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/MainMenu.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/MainMenu.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,18 +1,24 @@
-package CacheWolf;
+package cachewolf;
 
-import CacheWolf.navi.MapImporter;
-import CacheWolf.navi.MapLoaderGui;
-import CacheWolf.navi.SelectMap;
-import ewe.ui.*;
-import ewe.util.Vector;
-//import ewe.util.mString;
-import ewe.fx.*;
-import ewe.sys.*;
-//import ewe.util.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-import exp.*;
+import eve.ui.*;
+import java.util.Vector;
 
+import cachewolf.exp.*;
+import cachewolf.imp.DBImporter;
+import cachewolf.imp.GPXImporter;
+import cachewolf.imp.LOCXMLImporter;
+import cachewolf.imp.OCXMLImporter;
+import cachewolf.imp.SpiderGC;
+import cachewolf.navi.MapImporter;
+import cachewolf.navi.MapLoaderGui;
+import cachewolf.navi.SelectMap;
+
+import eve.sys.*;
+import eve.io.*;
+import eve.ui.filechooser.*;
+import eve.ui.data.InputBox;
+import eve.ui.event.MenuEvent;
+
 /**
  *	This class creates the menu for cachewolf. It is also responsible
  *	for reacting to user inputs in the menu.&lt;br&gt;
@@ -23,24 +29,24 @@
  *     20061123 salzkammergut Tidied up, added MyLocale, added additional internationalisation, combine save/filter for small screens, garminConn
  */
 public class MainMenu extends MenuBar {
-	private MenuItem profiles, preferences, mnuContext,loadcaches,loadOC, /* savenexit, */ savenoxit,exit,search,searchAll,searchClr;
+	private MenuItem preferences,mnuContext,loadcaches,loadOC,/* savenexit,*/savenoxit,exit,search,searchAll,searchClr;
 	private MenuItem downloadmap, kalibmap, importmap;
-	private MenuItem spider, update, chkVersion;
+	private MenuItem spider, update, chkVersion, importDB;
 	private MenuItem about, wolflang, sysinfo, legend;
 	private MenuItem exportpcx5, exporthtml, exporttop50, exportGPX, exportASC, exportTomTom, exportMSARCSV;
 	private MenuItem exportOZI, exportKML, exportTPL, exportExplorist;
 	private MenuItem filtCreate, filtClear, filtInvert, filtSelected, filtNonSelected, filtBlack, filtApply;
-	private MenuItem exportGPS, exportCacheMate,mnuSeparator;
-	private MenuItem orgNewWP, orgCopy, orgMove, orgDelete,orgRebuild;
+	private MenuItem exportGPS, mnuSeparator;
+	private MenuItem orgNewWP,orgCopy, orgMove, orgDelete,orgRebuild;
 	public MenuItem cacheTour,orgTravelbugs, mnuForceLogin;
 	private MenuItem mnuNewProfile, mnuOpenProfile, mnuEditCenter;
 	private Form father;
 	private TablePanel tbp;
-	private FilterScreen scnFilter=new FilterScreen();
+	private FilterScreen scnFilter=null; // Lazy initialitation only if it is opened
 
 	public MainMenu(Form f){
 		father = f;
-		String cwd = FileBase.getProgramDirectory();
+		String cwd = File.getProgramDirectory();
 
 		///////////////////////////////////////////////////////////////////////
 		// subMenu for profiles, part of &quot;Application&quot; menu below
@@ -53,13 +59,14 @@
 		///////////////////////////////////////////////////////////////////////
 		// subMenu for import, part of &quot;Application&quot; menu below
 		///////////////////////////////////////////////////////////////////////
-		MenuItem[] mnuImport = new MenuItem[6];
+		MenuItem[] mnuImport = new MenuItem[7];
 		mnuImport[0] = loadcaches  = new MenuItem(MyLocale.getMsg(129,&quot;Import GPX&quot;)); //TODO internationalization
-		mnuImport[1] = loadOC      = new MenuItem(MyLocale.getMsg(130,&quot;Download von opencaching.de&quot;)); 
-		mnuImport[2] = spider      = new MenuItem(MyLocale.getMsg(131,&quot;Spider von geocaching.com&quot;)); 
+		mnuImport[1] = loadOC      = new MenuItem(MyLocale.getMsg(130,&quot;Download von opencaching.de&quot;));
+		mnuImport[2] = spider      = new MenuItem(MyLocale.getMsg(131,&quot;Spider von geocaching.com&quot;));
 		mnuImport[3] = update      = new MenuItem(MyLocale.getMsg(1014,&quot;Update cache data&quot;));
-		mnuImport[4] = mnuSeparator = new MenuItem(&quot;-&quot;); 
-		mnuImport[5] = mnuForceLogin      = new MenuItem(&quot;Always login to GC&quot;); 
+		mnuImport[4] = importDB    = new MenuItem(&quot;Import DB&quot;); //TODO Internationalisation
+		mnuImport[5] = mnuSeparator = new MenuItem(&quot;-&quot;);
+		mnuImport[6] = mnuForceLogin      = new MenuItem(&quot;Always login to GC&quot;);
 		Menu importMenu = new Menu(mnuImport, MyLocale.getMsg(175,&quot;Import&quot;));
 		if (Global.getPref().forceLogin) mnuForceLogin.modifiers^=MenuItem.Checked;
 
@@ -72,13 +79,11 @@
 		exitems[1] = exportpcx5 = new MenuItem(MyLocale.getMsg(101,&quot;to PCX5 Mapsource&quot;));
 		exitems[2] = exporttop50 = new MenuItem(MyLocale.getMsg(102,&quot;to TOP50 ASCII&quot;));
 		exitems[3] = exportGPX = new MenuItem(MyLocale.getMsg(103,&quot;to GPX&quot;));
-		exitems[4] = exportASC = new MenuItem(MyLocale.getMsg(104,&quot;to CSV&quot;));
+		exitems[4] = exportASC = new MenuItem(MyLocale.getMsg(104,&quot;to ASC&quot;));
 		exitems[5] = exportTomTom = new MenuItem(MyLocale.getMsg(105,&quot;to TomTom&quot;));
 		exitems[6] = exportMSARCSV = new MenuItem(MyLocale.getMsg(106,&quot;to MS AutoRoute CSV&quot;));
 		exitems[7] = exportGPS = new MenuItem(MyLocale.getMsg(122,&quot;to GPS&quot;));
 		if(!(new File(cwd + &quot;/gpsbabel.exe&quot;)).exists()) exitems[7].modifiers = MenuItem.Disabled;
-		//exitems[8] = exportCacheMate = new MenuItem(MyLocale.getMsg(123,&quot;to Cachemate&quot;));
-		//if(!(new File(cwd + &quot;/cmconvert/cmconvert.exe&quot;)).exists()) exitems[8].modifiers = MenuItem.Disabled;
 		exitems[8] = exportOZI = new MenuItem(MyLocale.getMsg(124,&quot;to OZI&quot;));
 		exitems[9] = exportKML = new MenuItem(MyLocale.getMsg(125,&quot;to Google Earth&quot;));
 		exitems[10] = exportExplorist = new MenuItem(MyLocale.getMsg(132,&quot;to Explorist&quot;));
@@ -100,8 +105,8 @@
 		// Create the &quot;Application&quot; pulldown menu
 		///////////////////////////////////////////////////////////////////////
 		MenuItem [] appMenuItems=new MenuItem[11];
-		appMenuItems[0] = profiles 	 = new MenuItem(MyLocale.getMsg(121,&quot;Profile&quot;), 0, profileMenu); 
-		appMenuItems[1] = preferences = new MenuItem(MyLocale.getMsg(108,&quot;Preferences&quot;)); 
+		appMenuItems[0] = new MenuItem(MyLocale.getMsg(121,&quot;Profile&quot;), 0, profileMenu);
+		appMenuItems[1] = preferences = new MenuItem(MyLocale.getMsg(108,&quot;Preferences&quot;));
 		appMenuItems[2] = mnuEditCenter = new MenuItem(MyLocale.getMsg(1110,&quot;Centre&quot;));
 		appMenuItems[3] = mnuContext = new MenuItem(MyLocale.getMsg(134,&quot;Current Cache&quot;));
 		appMenuItems[4] = mnuSeparator;
@@ -109,8 +114,8 @@
 		appMenuItems[6] = new MenuItem(MyLocale.getMsg(107,&quot;Export&quot;),0,exportMenu);
 		appMenuItems[7] = new MenuItem(MyLocale.getMsg(149,&quot;Maps&quot;),0,mapsMenu);
 		appMenuItems[8] = mnuSeparator;
-		appMenuItems[9] = savenoxit = new MenuItem(MyLocale.getMsg(127,&quot;Save&quot;)); 
-		//appMenuItems[10] = savenexit = new MenuItem(MyLocale.getMsg(110,&quot;Save &amp; Exit&quot;)); 
+		appMenuItems[9] = savenoxit = new MenuItem(MyLocale.getMsg(127,&quot;Save&quot;));
+		//appMenuItems[10] = savenexit = new MenuItem(MyLocale.getMsg(110,&quot;Save &amp; Exit&quot;));
 		appMenuItems[10] = exit = new MenuItem(MyLocale.getMsg(111,&quot;Exit&quot;));
 		this.addMenu(new PullDownMenu(MyLocale.getMsg(120,&quot;Application&quot;),new Menu(appMenuItems,null)));
 
@@ -118,7 +123,7 @@
 		// Create the &quot;Search&quot; pulldown menu
 		///////////////////////////////////////////////////////////////////////
 		MenuItem[] searchMenuItems=new MenuItem[3];
-		searchMenuItems[0] = search = new MenuItem(MyLocale.getMsg(112,&quot;Search$&quot;+(char)6)); // char 6 = ctrl +f 
+		searchMenuItems[0] = search = new MenuItem(MyLocale.getMsg(112,&quot;Search$&quot;+(char)6)); // char 6 = ctrl +f
 		searchMenuItems[1] = searchAll = new MenuItem(MyLocale.getMsg(133,&quot;Search All&quot;));
 		searchMenuItems[2] = searchClr = new MenuItem(MyLocale.getMsg(113,&quot;Clear search&quot;));
 
@@ -126,18 +131,17 @@
 		// Create the &quot;Filter&quot; pulldown menu
 		///////////////////////////////////////////////////////////////////////
 		MenuItem[] filterMenuItems=new MenuItem[9];
-		filterMenuItems[0] = filtApply  = new MenuItem(MyLocale.getMsg(709,&quot;Apply&quot;)); 
-		filterMenuItems[1] = filtCreate  = new MenuItem(MyLocale.getMsg(114,&quot;Create&quot;)); 
-		filterMenuItems[2] = filtInvert  = new MenuItem(MyLocale.getMsg(115,&quot;Invert&quot;)); 
+		filterMenuItems[0] = filtApply  = new MenuItem(MyLocale.getMsg(709,&quot;Apply&quot;));
+		filterMenuItems[1] = filtCreate  = new MenuItem(MyLocale.getMsg(114,&quot;Create&quot;));
+		filterMenuItems[2] = filtInvert  = new MenuItem(MyLocale.getMsg(115,&quot;Invert&quot;));
 		filterMenuItems[3] = filtClear   = new MenuItem(MyLocale.getMsg(116,&quot;Clear&quot;));
 		filterMenuItems[4] = mnuSeparator;
 		filterMenuItems[5] = filtSelected = new MenuItem(MyLocale.getMsg(160,&quot;Filter selected&quot;));
 		filterMenuItems[6] = filtNonSelected = new MenuItem(MyLocale.getMsg(1011,&quot;Filter out non selected&quot;));
 		filterMenuItems[7] = mnuSeparator;
 		filterMenuItems[8] = filtBlack   = new MenuItem(MyLocale.getMsg(161,&quot;Show Blacklist&quot;));
-        filtBlack.modifiers=Global.getProfile().showBlacklisted?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&amp;~MenuItem.Checked;
 		//filterMenuItems[9] = mnuSeparator;
-		//filterMenuItems[10] = cacheTour;
+		//filterMenuItems[10] = filtCacheTour = new MenuItem(MyLocale.getMsg(198,&quot;Cachetour&quot;));
 
 		///////////////////////////////////////////////////////////////////////
 		// Create a combined &quot;Filter and Search&quot; pulldown menu for devices with small screens
@@ -156,9 +160,9 @@
 		filterAndSearchMenuItems[10]=search;
 		filterAndSearchMenuItems[11]=searchClr;
 		//filterAndSearchMenuItems[12] = mnuSeparator;
-		//filterAndSearchMenuItems[13] = cacheTour;
+		//filterAndSearchMenuItems[13] = filtCacheTour;
 
-		// Depending on screen width display either filter and search menus or the combined menu 
+		// Depending on screen width display either filter and searach menus or the combined menu
 		if (MyLocale.getScreenWidth()&gt;300) {
 			this.addMenu(new PullDownMenu(MyLocale.getMsg(112,&quot;Search&quot;),new Menu(searchMenuItems,null)));
 			this.addMenu(new PullDownMenu(MyLocale.getMsg(159,&quot;Filter&quot;),new Menu(filterMenuItems,null)));
@@ -172,24 +176,24 @@
 		MenuItem[] organiseMenuItems=new MenuItem[9];
 		organiseMenuItems[0] = orgNewWP = new MenuItem(MyLocale.getMsg(214,&quot;New Waypoint&quot;));
 		organiseMenuItems[1] = mnuSeparator;
-		organiseMenuItems[2] = orgCopy  = new MenuItem(MyLocale.getMsg(141,&quot;Copy&quot;)); 
-		organiseMenuItems[3] = orgMove  = new MenuItem(MyLocale.getMsg(142,&quot;Move&quot;)); 
+		organiseMenuItems[2] = orgCopy  = new MenuItem(MyLocale.getMsg(141,&quot;Copy&quot;));
+		organiseMenuItems[3] = orgMove  = new MenuItem(MyLocale.getMsg(142,&quot;Move&quot;));
 		organiseMenuItems[4] = orgDelete   = new MenuItem(MyLocale.getMsg(143,&quot;Delete&quot;));
 		organiseMenuItems[5] = orgRebuild   = new MenuItem(MyLocale.getMsg(208,&quot;Rebuild Index&quot;));
 		organiseMenuItems[6] = mnuSeparator;
 		organiseMenuItems[7] = orgTravelbugs = new MenuItem(MyLocale.getMsg(139,&quot;Manage travelbugs&quot;));
-		cacheTour = new MenuItem(MyLocale.getMsg(198,&quot;Cachetour&quot;));
-		organiseMenuItems[8] = cacheTour;
+		organiseMenuItems[8] = cacheTour = new MenuItem(MyLocale.getMsg(198,&quot;Cachetour&quot;));
+
 		this.addMenu(new PullDownMenu(MyLocale.getMsg(140,&quot;Organise&quot;),new Menu(organiseMenuItems,null)));
 
 		///////////////////////////////////////////////////////////////////////
 		// Create the &quot;About&quot; pulldown menu
 		///////////////////////////////////////////////////////////////////////
 		MenuItem[] aboutMenuItems=new MenuItem[5];
-		aboutMenuItems[0] = about = new MenuItem(MyLocale.getMsg(117,&quot;About&quot;)); 
-		aboutMenuItems[1] = legend = new MenuItem(MyLocale.getMsg(155,&quot;Legend&quot;)); 
-		aboutMenuItems[2] = wolflang = new MenuItem(MyLocale.getMsg(118,&quot;WolfLanguage&quot;)); 
-		aboutMenuItems[3] = sysinfo = new MenuItem(MyLocale.getMsg(157,&quot;System&quot;)); 
+		aboutMenuItems[0] = about = new MenuItem(MyLocale.getMsg(117,&quot;About&quot;));
+		aboutMenuItems[1] = legend = new MenuItem(MyLocale.getMsg(155,&quot;Legend&quot;));
+		aboutMenuItems[2] = wolflang = new MenuItem(MyLocale.getMsg(118,&quot;WolfLanguage&quot;));
+		aboutMenuItems[3] = sysinfo = new MenuItem(MyLocale.getMsg(157,&quot;System&quot;));
 		aboutMenuItems[4] = chkVersion = new MenuItem(MyLocale.getMsg(158,&quot;Version Check&quot;));
 		this.addMenu(new PullDownMenu(MyLocale.getMsg(117,&quot;About&quot;),new Menu(aboutMenuItems,null)));
 	}
@@ -198,10 +202,10 @@
 		tbp = t;
 		if (mnuContext.subMenu == null) {
 			if ((&quot;,&quot;+Global.getPref().listColMap+&quot;,&quot;).indexOf(&quot;,0,&quot;)&gt;=0)
-				mnuContext.subMenu = tbp.tc.getMenuFull();
-			else
-				mnuContext.subMenu = tbp.tc.getMenuSmall();
-		}		
+				mnuContext.subMenu = tbp.tControl.getMenuFull();
+			 else
+				 mnuContext.subMenu = tbp.tControl.getMenuSmall();
+		}
 	}
 
 	public void allowProfileChange(boolean profileChangeAllowed) {
@@ -234,42 +238,43 @@
 		if (ev instanceof MenuEvent){ //&amp;&amp; ev.type == MenuEvent.PRESSED
 			MenuEvent mev = (MenuEvent)ev;
 			///////////////////////////////////////////////////////////////////////
-			// subMenu for profiles, part of &quot;Application&quot; menu 
+			// subMenu for profiles, part of &quot;Application&quot; menu
 			///////////////////////////////////////////////////////////////////////
 			if(mev.selectedItem == mnuNewProfile){
-				if (NewProfileWizard.startNewProfileWizard(getFrame()) ) {
+				if (NewProfileWizard.startNewProfileWizard(getFrame()) ) {				Global.mainTab.saveUnsavedChanges(true);
 					pref.curCentrePt = new CWPoint(profile.centre);
-		            filtBlack.modifiers=Global.getProfile().showBlacklisted?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&amp;~MenuItem.Checked;
+					filtBlack.modifiers=Global.getProfile().showBlacklisted?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&amp;~MenuItem.Checked;
 					tbp.refreshTable();
+					Global.mainForm.title=&quot;CW &quot;+Version.getRelease()+&quot; - &quot;+profile.name;
 				}
 			}
 			if(mev.selectedItem == mnuOpenProfile){
 				Global.mainTab.saveUnsavedChanges(true);
 				if (pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_FORCED_ON,false)) {
-					tbp.myMod.numRows=0;
+					tbp.tModel.numRows=0;
 					CacheHolder.removeAllDetails();
 					profile.cacheDB.clear();
 					InfoBox infB = new InfoBox(&quot;CacheWolf&quot;,MyLocale.getMsg(5000,&quot;Loading Cache-List&quot;));
 					infB.exec();
-					infB.waitUntilPainted(1000);
-					Vm.showWait(infB, true);
+					infB.getWindow().waitUntilPainted(1000);
+					Form.showWait();
 					profile.readIndex();
-					Vm.showWait(infB, false);
+					Form.cancelWait();
 					pref.curCentrePt.set(profile.centre);
-                    filtBlack.modifiers=Global.getProfile().showBlacklisted?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&amp;~MenuItem.Checked;
-					Global.mainForm.setTitle(&quot;Cachewolf &quot;+Version.getRelease()+&quot; - &quot;+profile.name);
+					filtBlack.modifiers=Global.getProfile().showBlacklisted?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&amp;~MenuItem.Checked;
+					Global.mainForm.title=&quot;CW &quot;+Version.getRelease()+&quot; - &quot;+profile.name;
 					infB.close(0);
-					tbp.resetModel();
+					tbp.resetModel(); // &amp; restore Filter
 				}
 			}
 			if(mev.selectedItem == mnuEditCenter){
-				ProfileDataForm f=new ProfileDataForm(pref,profile);
+				CenterScreen f=new CenterScreen(pref,profile);
 				f.execute(getFrame(), Gui.CENTER_FRAME);
 				tbp.refreshTable();
 				f.close(0);
 			}
 			///////////////////////////////////////////////////////////////////////
-			// subMenu for import, part of &quot;Application&quot; menu 
+			// subMenu for import, part of &quot;Application&quot; menu
 			///////////////////////////////////////////////////////////////////////
 			if(mev.selectedItem == spider){
 				SpiderGC spGC = new SpiderGC(pref, profile, true);
@@ -280,10 +285,10 @@
 				tbp.resetModel();
 			}
 			if(mev.selectedItem == loadcaches){
-				FileChooser fc = new FileChooser(FileChooserBase.OPEN|FileChooserBase.MULTI_SELECT, pref.baseDir);
+				FileChooser fc = new FileChooser(FileChooser.OPEN|FileChooser.MULTI_SELECT, pref.baseDir);
 				fc.addMask(&quot;*.gpx,*.zip,*.loc&quot;);
-				fc.setTitle(MyLocale.getMsg(909,&quot;Select file(s)&quot;));
-				if(fc.execute() != FormBase.IDCANCEL){
+				fc.title=MyLocale.getMsg(909,&quot;Select file(s)&quot;);
+				if(fc.execute() != FileChooser.IDCANCEL){
 					String dir = fc.getChosenDirectory().toString();
 					String files[] = fc.getAllChosen();
 					/*
@@ -296,10 +301,10 @@
 							else how = GPXImporter.DOIT_NOSPOILER;
 					}
 					 */
-					for (int i = 0; i &lt; files.length; i++){ 
+					for (int i = 0; i &lt; files.length; i++){
 						String file = dir + &quot;/&quot; + files[i];
 						if (file.endsWith(&quot;loc&quot;)){
-							LOCXMLImporter loc = new LOCXMLImporter(pref, profile, file);
+							LOCXMLImporter loc = new LOCXMLImporter(profile, file);
 							loc.doIt();
 						}
 						else {
@@ -308,26 +313,36 @@
 						}
 					}
 				}
-                Global.getProfile().showBlacklisted = false;
-                filtBlack.modifiers=Global.getProfile().showBlacklisted?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&amp;~MenuItem.Checked;
+				Global.getProfile().showBlacklisted=false;
+				filtBlack.modifiers&amp;=Global.getProfile().showBlacklisted?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&amp;~MenuItem.Checked;
 				tbp.resetModel();
 			}
 			if(mev.selectedItem == loadOC){
 				OCXMLImporter oc = new OCXMLImporter(pref,profile);
 				oc.doIt();
-                Global.getProfile().showBlacklisted = false;
-                filtBlack.modifiers=Global.getProfile().showBlacklisted?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&amp;~MenuItem.Checked;
+				Global.getProfile().showBlacklisted=false;
+				filtBlack.modifiers&amp;=Global.getProfile().showBlacklisted?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&amp;~MenuItem.Checked;
 				tbp.resetModel();
 			}
-			if (mev.selectedItem == update) 
+			if (mev.selectedItem == update)
 				updateSelectedCaches(tbp);
+
+			if (mev.selectedItem == importDB) {
+				FileChooser fc = new FileChooser(FileChooser.OPEN, pref.baseDir);
+				fc.addMask(&quot;*.gpx,*.zip&quot;);
+				fc.title=MyLocale.getMsg(909,&quot;Select file(s)&quot;);
+				if(fc.execute() != FileChooser.IDCANCEL){
+					DBImporter dbI=new DBImporter();
+					dbI.doIt(fc.getChosenFile().toString());
+				}
+			}
 			if(mev.selectedItem == mnuForceLogin) {
 				mnuForceLogin.modifiers^=MenuItem.Checked;
 				Global.getPref().forceLogin=(mnuForceLogin.modifiers&amp;MenuItem.Checked)!=0;
 				Global.getPref().savePreferences();
 			}
 			///////////////////////////////////////////////////////////////////////
-			// subMenu for export, part of &quot;Application&quot; menu 
+			// subMenu for export, part of &quot;Application&quot; menu
 			///////////////////////////////////////////////////////////////////////
 			if(mev.selectedItem == exporthtml){
 				HTMLExporter htm = new HTMLExporter(pref, profile);
@@ -336,7 +351,7 @@
 			if(mev.selectedItem == exportpcx5){
 				PCX5Exporter pcx = new PCX5Exporter( pref, profile);
 				pcx.doIt(PCX5Exporter.MODE_ASK);
-			} 
+			}
 			if(mev.selectedItem == exporttop50){
 				OVLExporter ovl = new OVLExporter(pref, profile);
 				ovl.doIt();
@@ -358,24 +373,23 @@
 				msar.doIt();
 			}
 			if(mev.selectedItem == exportGPS){
-				Vm.showWait(true);
+				Form.showWait();
 				LocExporter loc = new LocExporter();
-				String tmpFileName = FileBase.getProgramDirectory() + &quot;/temp.loc&quot;;
+				String tmpFileName = File.getProgramDirectory() + &quot;/temp.loc&quot;;
 				loc.setTmpFileName(tmpFileName);
 				loc.doIt(LocExporter.MODE_AUTO);
 				ProgressBarForm.display(MyLocale.getMsg(950,&quot;Transfer&quot;),MyLocale.getMsg(951,&quot;Sending to GPS&quot;), null);
 				try{
 					pref.log(&quot;gpsbabel.exe &quot;+pref.garminGPSBabelOptions+&quot; -i geo -f \&quot;&quot;+ tmpFileName +&quot;\&quot; -o garmin -F &quot; + pref.garminConn +&quot;:&quot;);
-					// this will *only* work with ewe.jar at the moment
-					ewe.sys.Process p = Vm.exec(&quot;gpsbabel.exe &quot;+pref.garminGPSBabelOptions+&quot; -i geo -f \&quot;&quot;+ tmpFileName +&quot;\&quot; -o garmin -F &quot; + pref.garminConn +&quot;:&quot;);
+					java.lang.Process p = java.lang.Runtime.getRuntime().exec(&quot;gpsbabel.exe &quot;+pref.garminGPSBabelOptions+&quot; -i geo -f \&quot;&quot;+ tmpFileName +&quot;\&quot; -o garmin -F &quot; + pref.garminConn +&quot;:&quot;);
 					p.waitFor();
-				}catch(IOException ioex){
-					Vm.showWait(false);
-					(new MessageBox(&quot;Error&quot;, &quot;Garmin export unsuccessful&quot;, FormBase.OKB)).execute();
+				}catch(Exception ioex){
+					Form.cancelWait();
+					(new MessageBox(&quot;Error&quot;, &quot;Garmin export unsuccessful&quot;, MessageBox.OKB)).execute();
 					pref.log(&quot;Error exporting to Garmin&quot;,ioex);
 				};
 				ProgressBarForm.clear();
-				Vm.showWait(false);
+				Form.cancelWait();
 			}
 			if(mev.selectedItem == exportOZI){
 				OziExporter ozi = new OziExporter( pref, profile);
@@ -386,10 +400,10 @@
 				kml.doIt();
 			}
 			if(mev.selectedItem == exportTPL){
-				FileChooser fc = new FileChooser(FileChooserBase.OPEN, FileBase.getProgramDirectory());
+				FileChooser fc = new FileChooser(FileChooser.OPEN, File.getProgramDirectory());
 				fc.addMask(&quot;*.tpl&quot;);
-				fc.setTitle(MyLocale.getMsg(910,&quot;Select Template file&quot;));
-				if(fc.execute() != FormBase.IDCANCEL){
+				fc.title=MyLocale.getMsg(910,&quot;Select Template file&quot;);
+				if(fc.execute() != FileChooser.IDCANCEL){
 					TPLExporter tpl = new TPLExporter( pref,profile, fc.getChosenFile().toString());
 					tpl.doIt();
 				}
@@ -399,7 +413,7 @@
 				mag.doIt();
 			}
 			///////////////////////////////////////////////////////////////////////
-			// subMenu for maps, part of &quot;Application&quot; menu 
+			// subMenu for maps, part of &quot;Application&quot; menu
 			///////////////////////////////////////////////////////////////////////
 			if(mev.selectedItem == downloadmap){
 				MapLoaderGui mLG = new MapLoaderGui(cacheDB);
@@ -418,7 +432,7 @@
 						MapImporter map = new MapImporter(pref, sM.getSelectedMap(),sM.worldfileexists);
 						map.execute(null, Gui.CENTER_FRAME);
 					} catch (java.lang.OutOfMemoryError e) {
-						MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, &quot;Error&quot;), MyLocale.getMsg(156,&quot;Out of memory error, map to big&quot;), FormBase.OKB);
+						MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, &quot;Error&quot;), MyLocale.getMsg(156,&quot;Out of memory error, map to big&quot;), MessageBox.OKB);
 						tmpMB.exec();
 					}
 				}
@@ -433,19 +447,20 @@
 				pref.readPrefFile();
 			}
 			if(mev.selectedItem == savenoxit){
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+				profile.saveIndex(Profile.SHOW_PROGRESS_BAR);
 				tbp.saveColWidth(pref);
 			}
-/*
-			if(mev.selectedItem == savenexit){
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+
+/*			if(mev.selectedItem == savenexit){
+				profile.saveIndex(Profile.SHOW_PROGRESS_BAR);
 				tbp.saveColWidth(pref);
-				ewe.sys.Vm.exit(0);
+				eve.sys.Vm.exit(0);
 			}
-*/
-			if(mev.selectedItem == exit){
+*/			if(mev.selectedItem == exit){
 				Global.mainTab.saveUnsavedChanges(true);
-				ewe.sys.Vm.exit(0);
+				CacheHolder.saveAllModifiedDetails();
+				tbp.saveColWidth(pref);
+				eve.sys.Vm.exit(0);
 			}
 
 			///////////////////////////////////////////////////////////////////////
@@ -457,13 +472,13 @@
 			if(mev.selectedItem == searchAll){
 				SearchCache ssc = new SearchCache(cacheDB);
 				ssc.clearSearch();
-				tbp.refreshTable();		
-                search();
+				tbp.refreshTable();
+				search();
 			}
 			if(mev.selectedItem == searchClr){
 				SearchCache ssc = new SearchCache(cacheDB);
 				ssc.clearSearch();
-				tbp.refreshTable();		
+				tbp.refreshTable();
 			}
 			///////////////////////////////////////////////////////////////////////
 			// &quot;Filter&quot; pulldown menu
@@ -475,6 +490,7 @@
 				tbp.refreshTable();
 			}
 			if(mev.selectedItem == filtCreate){
+				if (scnFilter==null) scnFilter=new FilterScreen();
 				scnFilter.setData();
 				scnFilter.execute(father.getFrame(), Gui.CENTER_FRAME);
 				tbp.refreshTable();
@@ -538,33 +554,32 @@
 			///////////////////////////////////////////////////////////////////////
 			// &quot;Organise&quot; pulldown menu
 			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == orgNewWP){
+ 			if(mev.selectedItem == orgNewWP){
 				if (Global.mainTab.tbP.getSelectedCache() &gt;= 0) Global.mainTab.lastselected = ((CacheHolder)cacheDB.get(Global.mainTab.tbP.getSelectedCache())).wayPoint;
 				Global.mainTab.newWaypoint(new CacheHolder());
-			}
-
+ 			}
 			if(mev.selectedItem == orgCopy){
-				profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
+				profile.saveIndex(Profile.NO_SHOW_PROGRESS_BAR);
 				DataMover dm = new DataMover();
 				dm.copyCaches();
 				tbp.refreshTable();
 			}
 
 			if(mev.selectedItem == orgMove){
-				profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
+				profile.saveIndex(Profile.NO_SHOW_PROGRESS_BAR);
 				DataMover dm = new DataMover();
 				dm.moveCaches();
 				tbp.refreshTable();
 			}
 
 			if(mev.selectedItem == orgDelete){
-				profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
+				profile.saveIndex(Profile.NO_SHOW_PROGRESS_BAR);
 				DataMover dm = new DataMover();
 				dm.deleteCaches();
 				tbp.refreshTable();
 			}
 			if(mev.selectedItem == orgRebuild){
-				Rebuild rb=new Rebuild();
+				RebuildIndex rb=new RebuildIndex();
 				rb.rebuild();
 				tbp.refreshTable();
 			}
@@ -576,54 +591,53 @@
 			}
 			if(mev.selectedItem == cacheTour){
 				cacheTour.modifiers^=MenuItem.Checked;
-				Global.mainForm.toggleCacheListVisible();			
+				Global.mainForm.toggleCacheListVisible();
 			}
-			
 			///////////////////////////////////////////////////////////////////////
 			// &quot;About&quot; pulldown menu
 			///////////////////////////////////////////////////////////////////////
 			if(mev.selectedItem == about){
-				InfoScreen is = new InfoScreen(FileBase.getProgramDirectory() + &quot;/&quot; + &quot;info.html&quot;, MyLocale.getMsg(117,&quot;About&quot;),true, pref);
+				InfoHtmlScreen is = new InfoHtmlScreen(File.getProgramDirectory() + &quot;/&quot; + &quot;info.html&quot;, MyLocale.getMsg(117,&quot;About&quot;),true);
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
 			if(mev.selectedItem == legend){
-				InfoScreen is = new InfoScreen(FileBase.getProgramDirectory() + &quot;/&quot; + &quot;legende.html&quot;, MyLocale.getMsg(155,&quot;Legend&quot;),true, pref);
+				InfoHtmlScreen is = new InfoHtmlScreen(File.getProgramDirectory() + &quot;/&quot; + &quot;legende.html&quot;, MyLocale.getMsg(155,&quot;Legend&quot;),true);
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
 			if(mev.selectedItem == wolflang){
-				InfoScreen is = new InfoScreen(FileBase.getProgramDirectory() + &quot;/&quot; + &quot;wolflang.html&quot;, MyLocale.getMsg(118,&quot;WolfLanguage&quot;), true, pref);
+				InfoHtmlScreen is = new InfoHtmlScreen(File.getProgramDirectory() + &quot;/&quot; + &quot;wolflang.html&quot;, MyLocale.getMsg(118,&quot;WolfLanguage&quot;), true);
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
 			if(mev.selectedItem == sysinfo){
 				//Vm.debug(&quot;Checking system...&quot;);
 				StringBuffer sb=new StringBuffer(400);
-				Font f = mApp.guiFont;
+//TODO				Rect s = (Rect)Window.getGuiInfo(Window.INFO_SCREEN_RECT,null,new Rect(),0);
+//				Font f = mApp.guiFont;
 				sb.append(&quot;Profile: &quot;); 				sb.append(profile.dataDir);
-				sb.append(&quot;&lt;br&gt;Platform: &quot;); 			sb.append(Vm.getPlatform());
-				sb.append(&quot;&lt;br&gt;Locale lang is: &quot;);		sb.append(MyLocale.getLocaleLanguage()); 
-				sb.append(&quot;&lt;br&gt;Locale country is: &quot;); 	sb.append(MyLocale.getLocaleCountry()); 
+//TODO				sb.append(&quot;&lt;br&gt;Platform: &quot;); 			sb.append(Vm.getPlatform());
+				sb.append(&quot;&lt;br&gt;Locale lang is: &quot;);		sb.append(MyLocale.getLocaleLanguage());
+				sb.append(&quot;&lt;br&gt;Locale country is: &quot;); 	sb.append(MyLocale.getLocaleCountry());
 				sb.append(&quot;&lt;br&gt;Decimal separator is: \&quot;&quot;); sb.append(MyLocale.getDigSeparator());
-				sb.append(&quot;\&quot;&lt;br&gt;Device is PDA: &quot;);		sb.append(Vm.isMobile());
-				sb.append(&quot;&lt;br&gt;Screen: &quot;);				sb.append(MyLocale.getScreenWidth()); 
-				sb.append(&quot; x &quot;);	 sb.append(MyLocale.getScreenHeight()); 
-				sb.append(&quot;&lt;br&gt;Font size: &quot;);			sb.append(f.getSize());
+				sb.append(&quot;\&quot;&lt;br&gt;Device is PDA: &quot;);		sb.append(Device.isMobile());
+				sb.append(&quot;&lt;br&gt;Screen: &quot;);				sb.append(MyLocale.getScreenWidth());
+				sb.append(&quot; x &quot;);	 sb.append(MyLocale.getScreenHeight());
+//TODO				sb.append(&quot;&lt;br&gt;Font size: &quot;);			sb.append(f.getSize());
 				sb.append(&quot;&lt;br&gt;Entries in DB: &quot;);		sb.append(cacheDB.size());
-				sb.append(&quot;&lt;br&gt;File separator is: \&quot;&quot;); sb.append(Vm.getProperty(&quot;file.separator&quot;,&quot;def&quot;)); 
-				sb.append(&quot;\&quot;&lt;br&gt;Programme directory is &quot;); sb.append(FileBase.getProgramDirectory());
+				sb.append(&quot;&lt;br&gt;File separator is: \&quot;&quot;); sb.append(Vm.getProperty(&quot;file.separator&quot;,&quot;def&quot;));
+				sb.append(&quot;\&quot;&lt;br&gt;Programme directory is &quot;); sb.append(File.getProgramDirectory());
 				sb.append(&quot;&lt;br&gt;Number of details in RAM is &quot;); sb.append(CacheHolder.cachesWithLoadedDetails.size());
 				sb.append(&quot; Max.: &quot;);					sb.append(Global.getPref().maxDetails);
 				sb.append(&quot;&lt;br&gt;CacheWolf version: &quot;);		sb.append(Version.getReleaseDetailed());
 				sb.append(&quot;&lt;br&gt;&quot;);
-				InfoScreen is = new InfoScreen(sb.toString(), &quot;System&quot;, false,pref);
+				InfoHtmlScreen is = new InfoHtmlScreen(sb.toString(), &quot;System&quot;, false);
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
 			if(mev.selectedItem == chkVersion){
-				(new MessageBox(MyLocale.getMsg(178, &quot;Version Checking&quot;), Version.getUpdateMessage(), FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(178, &quot;Version Checking&quot;), Version.getUpdateMessage(), MessageBox.OKB)).execute();
 			}
-			
-			// In case that the triggered event was due to one of the context menu items, process
+			  // In case that the triggered event was due to one of the context menu items, process
 			// the event by the context menu handler
-			tbp.tc.popupMenuEvent(mev.selectedItem);
+			tbp.tControl.popupMenuEvent(mev.selectedItem);
 		}
 	}
 
@@ -632,21 +646,21 @@
 		Profile profile=Global.getProfile();
 		Vector cacheDB=profile.cacheDB;
 		CacheHolder ch;
-		
+
 		SpiderGC spider = new SpiderGC(pref, profile, false);
 		OCXMLImporter ocSync = new OCXMLImporter(pref, profile);
 		//Vm.debug(&quot;ByPass? &quot; + profile.byPassIndexActive);
-		Vm.showWait(true);
+		Form.showWait();
 		boolean alreadySaid = false;
 		boolean alreadySaid2 = false;
 		InfoBox infB = new InfoBox(&quot;Info&quot;, &quot;Loading&quot;, InfoBox.PROGRESS_WITH_WARNINGS);
 		infB.exec();
-		
+
 		Vector cachesToUpdate = new Vector();
 		for(int i = 0; i &lt;	cacheDB.size(); i++){
 			ch = (CacheHolder)cacheDB.get(i);
 			if(ch.is_Checked == true &amp;&amp; !ch.is_filtered) {
-				if ( ch.wayPoint.length()&gt;1 &amp;&amp; (ch.wayPoint.substring(0,2).equalsIgnoreCase(&quot;GC&quot;) 
+				if ( ch.wayPoint.length()&gt;1 &amp;&amp; (ch.wayPoint.substring(0,2).equalsIgnoreCase(&quot;GC&quot;)
 						|| ch.wayPoint.substring(0,2).equalsIgnoreCase(&quot;OC&quot;)))
 //					if ( (ch.wayPoint.length() &gt; 1 &amp;&amp; ch.wayPoint.substring(0,2).equalsIgnoreCase(&quot;GC&quot;)))
 //					Notiz: Wenn es ein addi Wpt ist, sollte eigentlich der Maincache gespidert werden
@@ -662,7 +676,7 @@
 					if (!ch.isAddiWpt() &amp;&amp; !alreadySaid) {
 						alreadySaid = true;
 						(new MessageBox(MyLocale.getMsg(327,&quot;Information&quot;),
-								        ch.wayPoint+ 
+								        ch.wayPoint+
 								        MyLocale.getMsg(5002,&quot;: At the moment this function is only applicable for geocaching.com and opencaching.de.&quot;), FormBase.OKB)).execute();
 					}
 				}
@@ -686,7 +700,7 @@
 				} else if (test == 0) {
 					spiderErrors++;
 				} else {
-					profile.hasUnsavedChanges=true;	
+					profile.hasUnsavedChanges=true;
 				}
 				forceLogin=false;
 			}
@@ -694,23 +708,24 @@
 				if (!ocSync.syncSingle(i, infB)) {
 					infB.close(0);
 					break;
-				} else 
-					profile.hasUnsavedChanges=true;	
+				} else
+					profile.hasUnsavedChanges=true;
 			}
 
 //			cacheDB.clear();
 //			profile.readIndex();
 		}
 		infB.close(0);
-//		profile.hasUnsavedChanges=true;	
-		profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
-		profile.restoreFilter();
-		profile.updateBearingDistance();
-		tablePanel.refreshTable();
-		Vm.showWait(false);
+//		profile.hasUnsavedChanges=true;
+		profile.saveIndex(Profile.SHOW_PROGRESS_BAR);
+		profile.restoreFilter(true);
+		//profile.updateBearingDistance();
+		Global.mainTab.tbP.refreshTable();
+		Form.cancelWait();
 		if ( spiderErrors &gt; 0) {
 			new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;),spiderErrors + MyLocale.getMsg(5516,&quot; cache descriptions%0acould not be loaded.&quot;),FormBase.DEFOKB).execute();
-		}		
+		}
+
 	}
-	
+
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/MainTab.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/MainTab.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/MainTab.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,23 +1,26 @@
-package CacheWolf;
+package cachewolf;
 
-import CacheWolf.navi.GotoPanel;
-import CacheWolf.navi.MapImage;
-import CacheWolf.navi.MovingMap;
-import CacheWolf.navi.Navigate;
-import ewe.sys.Vm;
-import ewe.ui.*;
-import ewe.fx.*;
-import ewe.util.*;
+import eve.sys.*;
+import eve.ui.*;
+import eve.fx.*;
+import java.util.*;
 
+import cachewolf.navi.GotoPanel;
+import cachewolf.navi.MapImage;
+import cachewolf.navi.MovingMap;
+import cachewolf.navi.Navigate;
+
+import eve.ui.event.*;
+import eve.ui.table.*;
+
 /**
  *	This class creates the tabbed panel and sets the tabs to the respective
  *	other panels. Important is to have a look at the event handler!&lt;br&gt;
- *	Class ID = 1200
  *	@see MainForm
  *	@see MainMenu
  */
-public class MainTab extends mTabbedPanel {
-	DescriptionPanel descP= new DescriptionPanel();
+public class MainTab extends TabbedPanel {
+	DescriptionPanel descP=new DescriptionPanel();
 	HintLogPanel hintLP = new HintLogPanel();
 	TablePanel tbP;
 	Vector cacheDB;
@@ -39,6 +42,14 @@
 	public String mainCache=&quot;&quot;;
 	int oldCard=0;
 	boolean cacheDirty=false;
+	// These flags are set if data is put into the relevant panels
+	// They ensure that the panel is cleared, when a new cache is selected
+	boolean imagePhasData=false;
+	boolean descPhasData=false;
+	boolean detPhasData=false;
+	boolean hintLPhasData=false;
+	boolean solverPhasData=false;
+	boolean radarPhasData=false;
 	
 	public MainTab(MainMenu mainMenu,StatusBar statBar){
 		Global.mainTab=this;
@@ -48,47 +59,45 @@
 		if (!pref.tabsAtTop) tabLocation=SOUTH;
 		cacheDB = profile.cacheDB;
 		this.statBar=statBar;
-		MyLocale.setSIPButton();
+		//TODOMyLocale.setSIPButton();
 		//Don't expand tabs if the screen is very narrow, i.e. HP IPAQ 65xx, 69xx
 		int sw = MyLocale.getScreenWidth();
 		if ( sw &lt;= 240) this.dontExpandTabs=true;
 		String imagesize=&quot;&quot;;
-		if (Vm.isMobile() &amp;&amp; sw &gt;= 400) imagesize=&quot;_vga&quot;;  
+		if (Device.isMobile() &amp;&amp; sw &gt;= 400) imagesize=&quot;_vga&quot;;  
 		calcP = new CalcPanel(); // Init here so that Global.MainT is already set
-		tbP = new TablePanel(pref, profile, statBar);
+		tbP = new TablePanel(statBar);
 		Card c = this.addCard(new TableForm(tbP), MyLocale.getMsg(1200,&quot;List&quot;), null);
 		
 		c = this.addCard(detP, MyLocale.getMsg(1201,&quot;Details&quot;), null);
-		c.iconize(new Image(&quot;details&quot;+imagesize+&quot;.gif&quot;),true);
+		c.iconize(new Picture(&quot;details&quot;+imagesize+&quot;.gif&quot;),true);
 
 		c = this.addCard(descP, MyLocale.getMsg(1202,&quot;Description&quot;), null);
-		c.iconize(new Image(&quot;descr&quot;+imagesize+&quot;.gif&quot;),true);
+		c.iconize(new Picture(&quot;descr&quot;+imagesize+&quot;.gif&quot;),true);
 
 		c = this.addCard(new MyScrollBarPanel(imageP = new ImagePanel()), MyLocale.getMsg(1203,&quot;Images&quot;), null);
-		c.iconize(new Image(&quot;images&quot;+imagesize+&quot;.gif&quot;),true);
+		c.iconize(new Picture(&quot;images&quot;+imagesize+&quot;.gif&quot;),true);
 
 		c = this.addCard(hintLP, MyLocale.getMsg(1204,&quot;Hints &amp; Logs&quot;), null);
-		c.iconize(new Image(&quot;more&quot;+imagesize+&quot;.gif&quot;),true);
+		c.iconize(new Picture(&quot;more&quot;+imagesize+&quot;.gif&quot;),true);
 
-		c = this.addCard(solverP = new SolverPanel(pref, profile), MyLocale.getMsg(1205,&quot;Solver&quot;), null);
-		c.iconize(new Image(&quot;solver&quot;+imagesize+&quot;.gif&quot;),true);
+		c = this.addCard(solverP = new SolverPanel(), MyLocale.getMsg(1205,&quot;Solver&quot;), null);
+		c.iconize(new Picture(&quot;solver&quot;+imagesize+&quot;.gif&quot;),true);
 
 		c = this.addCard(calcP, MyLocale.getMsg(1206,&quot;Calc&quot;), null);
-		mImage imgCalc=new mImage(&quot;projecttab&quot;+imagesize+&quot;.gif&quot;); imgCalc.transparentColor=new Color(0,255,0);
+		Picture imgCalc=new Picture(&quot;projecttab&quot;+imagesize+&quot;.gif&quot;,new Color(0,255,0),0); 
 		c.iconize(imgCalc,true);
 
 		nav = new Navigate();
 		c = this.addCard(gotoP = new GotoPanel(nav), &quot;Goto&quot;, null);
-		c.iconize(new Image(&quot;goto&quot;+imagesize+&quot;.gif&quot;),true);
+		c.iconize(new Picture(&quot;goto&quot;+imagesize+&quot;.gif&quot;),true);
 		nav.setGotoPanel(gotoP);
 
 		c = this.addCard(radarP, &quot;Radar&quot;, null);
-		radarP.setMainTab(this);
-		c.iconize(new Image(&quot;radar&quot;+imagesize+&quot;.gif&quot;),true);
+		c.iconize(new Picture(&quot;radar&quot;+imagesize+&quot;.gif&quot;),true);
 		mnuMain.allowProfileChange(true);
-//		if (pref.noTabs) top.modify(ShrinkToNothing,0);//TODO
 	}
-
+	
 	public TablePanel getTablePanel(){
 		return tbP;
 	}
@@ -99,14 +108,17 @@
 	}
 
 	public void clearDetails() {
-		imageP.clearImages(); // Remove all images
-		descP.clear(); // write &quot;loading ...&quot;
-		detP.clear(); // Clear only the attributes
-		hintLP.clear(); // Remove the logs
-		solverP.setInstructions(&quot;loading ...&quot;);
-	}	
+		if (imagePhasData) { imageP.clearImages(); imagePhasData=false; }// Remove all images
+		if (descPhasData) { descP.clear(); descPhasData=false; }// write &quot;loading ...&quot;
+		if (detPhasData) { detP.clear(); detPhasData=false; }// Clear only the attributes
+		if (hintLPhasData) { hintLP.clear(); hintLPhasData=false; }// Remove the logs
+		if (solverPhasData) { solverP.setInstructions(&quot;loading ...&quot;); solverPhasData=false; }
+		if (radarPhasData) { radarP.removeCircle(); radarPhasData=false; }
+	}
 	
+	static int level=0;
 	public void onEvent(Event ev) {
+//eve.sys.Vm.debug(&quot;              &quot;.substring(0,level++*2)+&quot;[&quot;+ev.target.getClass().getName()+&quot;] &quot;+event2Name(ev.type));
 		// This section clears old data when a new line is selected in the table
 		if (ev instanceof TableEvent) {
 			clearDetails();
@@ -120,9 +132,10 @@
 			onEnteringPanel(((MultiPanelEvent)ev).selectedIndex);
 			oldCard=((MultiPanelEvent)ev).selectedIndex;
 		}
-		super.onEvent(ev); //Make sure you call this.
 		// If we are in Listview update status
 		if (this.getSelectedItem()==0 &amp;&amp; statBar!=null) statBar.updateDisplay();
+//eve.sys.Vm.debug(&quot;              &quot;.substring(0,--level*2)+&quot;END &quot;+&quot;[&quot;+ev.target.getClass().getName()+&quot;] &quot;+event2Name(ev.type));
+		super.onEvent(ev);
 	}
 
 	/**
@@ -136,7 +149,7 @@
 			// If it is Addi get details of main Wpt (chMain)
 			chMain=null;
 			cacheDirty=false;
-			if (tbP.getSelectedCache()&gt;=Global.mainTab.tbP.myMod.numRows || tbP.getSelectedCache()&lt;0) {
+			if (tbP.getSelectedCache()&gt;=Global.mainTab.tbP.tModel.numRows || tbP.getSelectedCache()&lt;0) {
 				ch=null; chD=null; 
 				lastselected=&quot;&quot;;
 			} else {
@@ -151,30 +164,30 @@
 				}
 			}
 		}
-		if (panelNo==1) { // Leaving the Details Panel
+		else if (panelNo==1) { // Leaving the Details Panel
 			// Update chD with Details
 			if(detP.isDirty()) {
 				cacheDirty=true;
 				boolean needTableUpdate = detP.needsTableUpdate();
 				detP.saveDirtyWaypoint();
 				if (needTableUpdate) {
-					tbP.myMod.updateRows();// This sorts the waypoint (if it is new) into the right position
+					tbP.updateRows();// This sorts the waypoint (if it is new) into the right position
 					tbP.selectRow(profile.getCacheIndex(detP.thisCache.wayPoint));
 				}
 				//was tbP.refreshTable();
-				tbP.tc.update(true); // Update and repaint
+				tbP.tControl.update(true); // Update and repaint
 				if (statBar!=null) statBar.updateDisplay();
 			}
 		}
-		if (panelNo==5) { // Leaving the Solver Panel
+		else if (panelNo==5) { // Leaving the Solver Panel
 			// Update chD or chMain with Solver
 			// If chMain is set (i.e. if it is an addi Wpt) save it immediately
 			if (chD!=null &amp;&amp; solverP.isDirty()) {
 				cacheDirty=true;
 				if (chMain==null) {
-					chD.Solver=solverP.getInstructions();
+					chD.solver=solverP.getInstructions();
 				} else {
-					chMain.Solver=solverP.getInstructions();
+					chMain.solver=solverP.getInstructions();
 					chMain.saveCacheDetails(Global.getProfile().dataDir);//Vm.debug(&quot;mainT:SaveCache &quot;+chMain.wayPoint+&quot;/S:&quot;+chMain.Solver);
 					chMain=null;
 				}
@@ -192,8 +205,8 @@
 			// If Solver or Details has changed, save Cache
 			updatePendingChanges();
 			if (detP.hasBlackStatusChanged()) {
-				// filter out caches with wrong blacklist status
-				Global.getProfile().checkBlacklistStatus();
+				// Restore the filter status (this automatically sets the status for blacklisted caches)
+				Global.getProfile().restoreFilter(true);
 				tbP.refreshTable();
 			}
 			break;
@@ -201,61 +214,72 @@
 			if (chD==null) { // Empty DB - show a dummy detail
 				newWaypoint(ch=new CacheHolder()); 
 			}
-			MyLocale.setSIPButton();
-			detP.setDetails(ch);
+			//TODO MyLocale.setSIPButton();
+			if (!detPhasData)  {
+				detP.setDetails(ch);
+				detPhasData=true;
+			}
 			break;
 		case 2: // Description Panel
-				MyLocale.setSIPOff();
-				descP.setText(chD);
+				//TODOMyLocale.setSIPOff();
+				if (!descPhasData) {
+					descP.setText(chD);
+					descPhasData=true;
+				}
 			break;
 		case 3: // Picture Panel
-			if (chD!=null) {
-				MyLocale.setSIPOff();
+			if (chD!=null &amp;&amp; !imagePhasData) {
+				//TODOMyLocale.setSIPOff();
 				if (chD.isAddiWpt()) { 
 					imageP.setImages(chD.mainCache.getCacheDetails(true));
 				} else {
 					imageP.setImages(chD);
 				}
+				imagePhasData=true;
 			}
 			break;
 		case 4:  // Log Hint Panel
-			if (chD!=null) {
-				MyLocale.setSIPOff();
+			if (chD!=null &amp;&amp; !hintLPhasData) {
+				//TODO MyLocale.setSIPOff();
 				if (chD.isAddiWpt()) { 
 					hintLP.setText(chD.mainCache.getCacheDetails(true));
 				} else {
 					hintLP.setText(chD);
 				}
+				hintLPhasData=true;
 			}
 			break;
 		case 5:  // Solver Panel
-			MyLocale.setSIPButton();
-			if (chD!=null) {
+			//TODO MyLocale.setSIPButton();
+			if (chD!=null &amp;&amp; !solverPhasData) {
 				if (chD.isAddiWpt()) { 
 					chMain=chD.mainCache.getCacheDetails(true);//new CacheHolderDetail(chD.mainCache);
 /*					try {
 						chMain.readCache(profile.dataDir); //Vm.debug(&quot;mainT:readCache &quot;+chD.wayPoint+&quot;=&gt;Main=&gt;&quot;+chMain.wayPoint+&quot;/S:&quot;+chMain.Solver);
 					} catch(Exception e){pref.log(&quot;Error reading cache .xml&quot;,e);}
-*/					solverP.setInstructions(chMain.Solver);
+*/					solverP.setInstructions(chMain.solver);
 				} else {
 					//Vm.debug(&quot;mainT: Waypoint:&quot;+chD.wayPoint);
-					solverP.setInstructions(chD.Solver);
+					solverP.setInstructions(chD.solver);
 				}
+				solverPhasData=true;
 			}
 			break;
 		case 6:  // CalcPanel
 			if (chD!=null) {
-				MyLocale.setSIPButton();
+				//TODO MyLocale.setSIPOff();
 				calcP.setFields(chD);
 			}
 			break;
 		case 7: // GotoPanel
-			MyLocale.setSIPOff();
+			//TODO MyLocale.setSIPOff();
 			break;
 		case 8:  // Cache Radar Panel
-			MyLocale.setSIPOff();
-			radarP.setParam(pref, cacheDB, chD==null?&quot;&quot;:chD.wayPoint);
-			radarP.drawThePanel();
+			//TODO MyLocale.setSIPOff();
+			if (!radarPhasData) {
+				radarP.drawCachesAndCircle();
+				radarPhasData=true;
+			}
 			break;
 		}
 	}
@@ -265,19 +289,18 @@
 	public void updateBearDist(){// Called from DetailsPanel, GotoPanel and myTableControl
 		MessageBox info = new MessageBox(MyLocale.getMsg(327,&quot;Information&quot;), MyLocale.getMsg(1024,&quot;Entfernungen in der Listenansicht \n werden neu berechnet...&quot;).replace('~','\n'), 0);
 		info.exec();
-		tbP.pref = pref;
 		profile.updateBearingDistance();
 		//tbP.refreshTable();
 		info.close(0);
-		tbP.tc.repaint();
+		//tbP.tControl.repaint();
 	}
 
-	public void gotoPoint(CWPoint where) { 
+	public void gotoPoint(CWPoint where) { // Called from CalcPanel, DetailsPanel
 		gotoP.setDestinationAndSwitch(where); 
 	}
 
 	public void openDescriptionPanel(CacheHolder chi) {
-		MyLocale.setSIPOff();
+		//TODO MyLocale.setSIPOff();
 		// To change cache we need to be in panel 0
 		onLeavingPanel(oldCard);
 		onEnteringPanel(0); oldCard=0;
@@ -301,12 +324,10 @@
 	public void newWaypoint(CacheHolder ch){
 		//When creating a new waypoint, simulate a change to the list view
 		//if we are currently NOT in the list view
-		if (oldCard != 0)
-		{
+		if (oldCard != 0) {
 			onLeavingPanel(oldCard);
 		}
 		updatePendingChanges(); // was: onEnteringPanel(0); oldCard=0;
-		
 		mainCache=lastselected;
 		int selectedIndex = profile.getCacheIndex( lastselected );
 		if (selectedIndex &gt;= 0) {
@@ -317,23 +338,22 @@
 		}
 		Global.getProfile().hasUnsavedChanges=true;
 		detP.setNeedsTableUpdate(true);
-		if (ch.type == null || ch.type.equals(&quot;&quot;)) ch.type = &quot;0&quot;;
 		if (CacheType.isAddiWpt(ch.type) &amp;&amp; mainCache!=null &amp;&amp; mainCache.length()&gt;2) {
 			ch.wayPoint = profile.getNewAddiWayPointName(mainCache);
 			profile.setAddiRef(ch);
 		} else { 
 			ch.wayPoint = profile.getNewWayPointName();
-			ch.type=&quot;0&quot;;
+			ch.type=0;
 			lastselected=ch.wayPoint;
 		}
-		ch.CacheSize = &quot;None&quot;;
+		ch.setCacheSize(&quot;None&quot;);
 		chD = ch.getCacheDetails(true);
 		this.ch = ch;
 		cacheDB.add(ch);
-		tbP.myMod.numRows++;
+		tbP.tModel.numRows++;
 		detP.setDetails(ch);
 		oldCard=1;
-		if (this.cardPanel.selectedItem != 1) select(detP);
+		if (this.cardPanel.selectedItem !=1) select(detP);
 		solverP.setInstructions(&quot;&quot;);
 		//tbP.refreshTable(); // moved this instruction to onLeavingPanel
 
@@ -346,10 +366,10 @@
 	 * @param centerTo true: centers centerTo on the screen and disconnects MovingMap from GPS if Gps-pos is not on the loaded map
 	 * @param forceCenter
 	 */
-	public void SwitchToMovingMap(CWPoint centerTo, boolean forceCenter) {
+	public void switchToMovingMap(CWPoint centerTo, boolean forceCenter) {
 		try {
 			if (!centerTo.isValid()) {
-				(new MessageBox(&quot;Error&quot;, &quot;No valid coordinates&quot;, FormBase.OKB)).execute();
+				(new MessageBox(&quot;Error&quot;, &quot;No valid coordinates&quot;, MessageBox.OKB)).execute();
 				return;
 			}
 			if (mm == null) {
@@ -362,8 +382,8 @@
 			if (forceCenter) {
 				try {
 					int i = 0;
-					while (MapImage.screenDim.width == 0 &amp;&amp; i &lt; 10*60) { i++; ewe.sys.mThread.sleep(100);} // wait until the window size of the moving map is known note: ewe.sys.sleep() will pause the whole vm - no other thread will run
-					if (i &gt;= 10*60) {(new MessageBox(&quot;Error&quot;, &quot;MovingMap cannot be displayed - this is most likely a bug - plaese report it on www.geoclub.de&quot;, FormBase.OKB)).execute(); return;}
+					while (MapImage.screenDim.width == 0 &amp;&amp; i &lt; 10*60) { i++; eve.sys.mThread.sleep(100);} // wait until the window size of the moving map is known note: eve.sys.sleep() will pause the whole vm - no other thread will run
+					if (i &gt;= 10*60) {(new MessageBox(&quot;Error&quot;, &quot;MovingMap cannot be displayed - this is most likely a bug - plaese report it on www.geoclub.de&quot;, MessageBox.OKB)).execute(); return;}
 					mm.setCenterOfScreen(centerTo, false); // this can only be executed if mm knows its window size that's why myExec must be executed before
 					mm.updatePosition(centerTo);
 					/*			if(!mm.posCircle.isOnScreen()) { // TODO this doesn't work because lat lon is set to the wished pos and not to gps anymore
@@ -373,26 +393,26 @@
 				mm.setCenterOfScreen(centerTo, true); 
 			}
 					 */			//TODO what to do, if there is a map at centerTo, but it is not loaded because of mapSwitchMode == dest &amp; cuurpos und daf&#252;r gibt es keine Karte 
-				}catch (InterruptedException e) {
+				}catch (InterruptedException e) {//TODO switch waiting indication off
 					Global.getPref().log(&quot;Error starting mavoing map (1): &quot; + e.getMessage(), e, true);
-					(new MessageBox(&quot;Error&quot;, &quot;This must not happen please report to pfeffer how to produce this error message&quot;, FormBase.OKB)).execute(); } 
+					(new MessageBox(&quot;Error&quot;, &quot;This must not happen please report to pfeffer how to produce this error message&quot;, MessageBox.OKB)).execute(); } 
 			}
-		} catch (Exception e) { // TODO swith waiting indication clock off
+		} catch (Exception e) { 
 			Global.getPref().log(&quot;Error starting moving map (2): &quot; + e.getMessage(), e, true);
-			(new MessageBox(&quot;Error&quot;, &quot;Error starting moving map: &quot; + e.getMessage(), FormBase.OKB)).execute(); }
+			(new MessageBox(&quot;Error&quot;, &quot;Error starting moving map: &quot; + e.getMessage(), MessageBox.OKB)).execute(); }
 	}
 
-	void updatePendingChanges() {
+	public void updatePendingChanges() {
 		if (cacheDirty) {
-			if (chD != null)
+			if (chD!=null)
 				chD.saveCacheDetails(Global.getProfile().dataDir);
-			cacheDirty = false;
+			cacheDirty=false;
 		}
 	}
 	
 	/** Save the index file
 	 * 
-	 * @param askForConfirmation is ignored, old: If true, the save can be cancelled by user
+	 * @param askForConfirmation If true, the save can be cancelled by user
 	 */
 	public void saveUnsavedChanges(boolean askForConfirmation) {
 		if (oldCard!=0) {
@@ -401,8 +421,8 @@
 			oldCard=0;
 		}
 		updatePendingChanges();
-		if (profile.hasUnsavedChanges) profile.saveIndex(Global.getPref(),true);
-	    this.tbP.saveColWidth(pref);
+		if (profile.hasUnsavedChanges) profile.saveIndex(true);
+		this.tbP.saveColWidth(pref);
 		Global.getPref().savePreferences();
 	}
 	
@@ -411,12 +431,36 @@
 		mnuMain.allowProfileChange(false);	  
 		if(this.getSelectedItem() == 0){// List view selected
 			mnuMain.allowProfileChange(true);	  
-			MyLocale.setSIPOff();
+			//TODO MyLocale.setSIPOff();
 		}
 	}
+	private String event2Name(int type) {//TODO Comment out
+		switch(type) {
+			case ControlEvent.PRESSED: return &quot;ControlEvent.PRESSED&quot;; 
+			case ControlEvent.FOCUS_IN: return &quot;ControlEvent.FOCUS_IN&quot;;
+			case ControlEvent.FOCUS_OUT: return &quot;ControlEvent.FOCUS_OUT&quot;;
+			case ControlEvent.TIMER: return &quot;ControlEvent.TIMER&quot;; 
+			case ControlEvent.CANCELLED: return &quot;ControlEvent.CANCELLED&quot;; 
+			case ControlEvent.EXITED: return &quot;ControlEvent.EXITED&quot;; 
+			case ControlEvent.MENU_SHOWN: return &quot;ControlEvent.MENU_SHOWN&quot;;
+			case eve.ui.formatted.TextDisplay.LINES_SPLIT: return &quot;ControlEvent.LINES_SPLIT&quot;; 
+			case ControlEvent.STRUCTURE_CHANGED: return &quot;ControlEvent.STRUCTURE_CHANGED&quot;;
+			case ControlEvent.OPERATION_CANCELLED: return &quot;ControlEvent.OPERATION_CANCELLED&quot;;
+			case ControlEvent.POPUP_CLOSED: return &quot;ControlEvent.POPUP_CLOSED&quot;;
+			case DataChangeEvent.DATA_CHANGED: return &quot;DataChangeEvent.DATA_CHANGED&quot;; 
+			case MultiPanelEvent.SELECTED: return &quot;MultiPanelEvent.SELECTED&quot;; 
+			case TableEvent.CELL_CLICKED: return &quot;TableEvent.CELL_CLICKED&quot;; 
+			case TableEvent.SELECTION_CHANGED: return &quot;TableEvent.SELECTION_CHANGED&quot;;
+			case TableEvent.CELL_DOUBLE_CLICKED:  return &quot;TableEvent.CELL_DOUBLE_CLICKED&quot;;
+			case eve.ui.data.EditorEvent.CLOSED: return &quot;EditorEvent.CLOSED&quot;; 
+			case eve.ui.data.EditorEvent.FROM_CONTROLS: return &quot;EditorEvent.FROM_CONTROLS&quot;;
+			case eve.ui.data.EditorEvent.OBJECT_SET: return &quot;EditorEvent.OBJECT_SET&quot;; 
+			case eve.ui.data.EditorEvent.SHOWN: return &quot;EditorEvent.SHOWN&quot;; 
+			case eve.ui.data.EditorEvent.TO_CONTROLS: return &quot;EditorEvent.TO_CONTROLS&quot;;
+		}
+		return Integer.toString(type);
+	}
+
 }
 // 
 
-
-
-

Modified: experiments/engywuck/hist-test/src/cachewolf/MyEditor.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/MyEditor.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/MyEditor.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,9 +1,9 @@
-package CacheWolf;
+package cachewolf;
+import eve.fx.Color;
+import eve.fx.Insets;
+import eve.ui.*;
+import eve.ui.data.Editor;
 
-import ewe.fx.Color;
-import ewe.fx.Insets;
-import ewe.ui.*;
-
 /**
  * Descendant from ewe.ui.Editor to allow more flexibility when needed
  * @author engywuck
@@ -51,9 +51,9 @@
 					sk.setKey(1, &quot;Close|&quot; + EXIT_IDCANCEL, close, null);
 				}
 			} else {
-				titleOK = new mButton(close);// getButton(&quot;OK&quot;);
+				titleOK = new Button(close);// getButton(&quot;OK&quot;);
 				titleOK.backGround = Color.DarkBlue;
-				((mButton) titleOK).insideColor = getBackground();
+				((Button) titleOK).insideColor = getBackground();
 			}
 		}
 		if (titleOK != null)

Modified: experiments/engywuck/hist-test/src/cachewolf/MyLocale.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/MyLocale.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/MyLocale.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,23 +1,24 @@
-package CacheWolf;
+package cachewolf;
 /*
  *  CacheWolf - Local settings class
- * 
+ *
  */
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import eve.io.File;
+import java.io.FileReader;
+import java.io.FileWriter;
+import eve.sys.*;
+import java.lang.Double;
+import java.lang.Long;
 
-import utils.FileBugfix;
-import ewe.fx.Rect;
-import ewe.io.File;
-import ewe.sys.*;
-import ewe.sys.Double;
-import ewe.sys.Long;
-import ewe.ui.FormBase;
-import ewe.ui.Gui;
-import ewe.ui.Window;
-import ewe.ui.WindowConstants;
+import eve.ui.Gui;
+import eve.fx.Dimension;
+import eve.ui.MessageBox;
 /**
  *  This class handles internationalisation and some other local stuff like
  *  decimal separator, screen dimensions etc.
- *  
+ *
  *  The methods are static, the class does not need initialisation.
  *
  *  @author salzkammergut
@@ -31,13 +32,13 @@
 
 	private static Locale l=null;
 	private static LocalResource lr=null;
-	private static Rect s = (Rect)Window.getGuiInfo(WindowConstants.INFO_SCREEN_RECT,null,new Rect(),0);
+	private static Dimension s = Gui.getScreenSize();
 	private static String digSeparator=null;
 	/** Read a non-standard language from the file language. If it is empty,
 	 * the default language is used.
 	 */
 	public static String language=getLanguage();
-	
+
 	public static String initErrors;
 
 	private static String getLocaleFileName(String languageshort) {
@@ -59,38 +60,38 @@
 		resourcelanguage = language_;
 	}
 
-	/** 
+	/**
 	 * This is used to determine the language file name - it is necessary because
-	 * ewe-vm v1.49 doesn't support French  
+	 * ewe-vm v1.49 doesn't support French
 	 */
-	static String resourcelanguage;
+	static String resourcelanguage; //TODO Is this necessary in EVE ?
 	static boolean inInit = false;
 
-	private static void init() throws IllegalThreadStateException {
+
+	private static void init() {
 		if (inInit) {
 			throw new IllegalThreadStateException(&quot;init may not be run twice&quot;); // this can happen, if ewe is loading another class in background, which causes a call to e.g. MyLocale.getDigSeperator (most likely in a static statement). Ewe-Vm v1.49 seems to be loading static classes ahead, causing the danger of this problem.
 		}
 		inInit = true;
 		initErrors = &quot;&quot;;
 		// the following logic priority: 1. try to use specified language (if specified), 2. try to use system language, 3. try to use english, 4. use hard coded messages
-		l = null;
 		if ( ( language.length()!=0 ) &amp;&amp; ( !language.equalsIgnoreCase(&quot;auto&quot;) ) ) { // Was a language explicitly specified?
 			setLocale(language);
-			if (! (new FileBugfix(getLocaleFileName(resourcelanguage)).exists()) ) {
+			if (! (new File(getLocaleFileName(resourcelanguage)).exists()) ) {
 				l = null; // language file not found
 				initErrors += &quot;Language &quot; + language + &quot; not found - using system language\n&quot;;// don't copy this messagebox into a language file, because it is only used if no languages file can be accessed
 			}
 		}
 		if ( l == null ) { // no language specified OR specified language not available -&gt; use system default
-			setLocale(Vm.getLocale().getString(Locale.LANGUAGE_SHORT, 0, 0)); 
+			setLocale(Vm.getLocale().getString(Locale.LANGUAGE_SHORT, 0, 0));
 			// test if a localisation file for the system language exists
-			if (!(new FileBugfix(getLocaleFileName(resourcelanguage)).exists())) {
+			if (!(new File(getLocaleFileName(resourcelanguage)).exists())) {
 				setLocale(standardLanguage);
 				initErrors += &quot;Your system language is not supported by cachewolf - using English\n You can choose a different language in the preferences\n&quot;;
 				/*       //uncomment this code to print a list of all supported languge (Locales), remark: this differs from vm to vm _and_ from OS to OS
   					 Vm.debug(&quot;gew&#228;hlte Sprache: &quot; + resourcelanguage, 0, 0);
 					 int [] all = Locale.getAllIDs(0);
-					 Locale ltmp = new Locale(); 
+					 Locale ltmp = new Locale();
 					 for (int i = 0; i&lt;all.length; i++){
 						 ltmp.set(all[i]);
 						 String lg = ltmp.getString(Locale.LANGUAGE_SHORT,0,0);
@@ -100,9 +101,9 @@
 			}
 		}
 		lr = null;
-		if (new FileBugfix(getLocaleFileName(resourcelanguage)).exists() ) {
-			ewe.io.TreeConfigFile tcf = ewe.io.TreeConfigFile.getConfigFile(getLocaleFileName(resourcelanguage));
-			if (tcf != null) {			 
+		if (new File(getLocaleFileName(resourcelanguage)).exists() ) {
+			eve.io.TreeConfigFile tcf = eve.io.TreeConfigFile.getConfigFile(getLocaleFileName(resourcelanguage));
+			if (tcf != null) {
 				lr = tcf.getLocalResourceObject(new Locale() {
 					public String getString(int what,int forValue,int options) {
 						if (what == LANGUAGE_SHORT) return resourcelanguage; // this is necessary because French cannot be set in ewe-vm v1.49
@@ -128,25 +129,25 @@
 
 	/**
 	 * Return a localised string
-	 * 
-	 * The localised strings are stored in the configuration file (relative to
-	 *  executable:&lt;br&gt;
-	 *  	_config/cachewolf.Languages.cfg
-	 * If the configuration file does not exist or a string cannot be found in
-	 * the file, the defaultValue is resurned.
-	 *   
+	 *
+     * The localised strings are stored in the configuration file (relative to
+     *  executable:&lt;br&gt;
+     *  	_config/cachewolf.Languages.cfg
+     * If the configuration file does not exist or a string cannot be found in
+     * the file, the defaultValue is resurned.
+     *
 	 * @param resourceID   The unique number of the resource
 	 * @param defaultValue The default value of the string (if not found in the config file)
-	 * @return The localised string 
+	 * @return The localised string
 	 */
 	public static String getMsg(int resourceID, String defaultValue) {
-		if (l==null) 
+		if (l==null)
 			init();
-		if (lr!=null) { 
+		if (lr!=null) {
 			String res;
 			res=(String) lr.get(resourceID,defaultValue);
-			if (res!=null) 
-				return res;
+			if (res!=null)
+			   return res;
 			//Fallthrough to default value if string does not exist in file
 		}
 		return defaultValue;
@@ -154,22 +155,22 @@
 
 	/**
 	 * Get the ISO two letter (lowercase) name of the locale language
-	 * 
+	 *
 	 * @return ISO two letter abbreviation of the locale language
 	 */
 	public static String getLocaleLanguage() {
 		if (l==null) init();
-		return l.getString(Locale.LANGUAGE_SHORT, 0, 0);		
+		return l.getString(Locale.LANGUAGE_SHORT, 0, 0);
 	}
 
 	/**
 	 * Get the three letter (uppercase) ISO country code
-	 * 
+	 *
 	 * @return The three letter (uppercase) ISO country code
 	 */
 	public static String getLocaleCountry() {
 		if (l==null) init();
-		return l.getString(Locale.COUNTRY_SHORT, 0, 0);		
+		return l.getString(Locale.COUNTRY_SHORT, 0, 0);
 	}
 
 	/**
@@ -209,104 +210,76 @@
 	 */
 	public static String formatLong(Long number, String fmt) {
 		if (l==null) init();
-		return l.format(Locale.FORMAT_PARSE_NUMBER,number,fmt);
+		return l.format(number.longValue(),fmt,0);
 	}
 
 	/**
 	 * Formats a long to a given format specifier
 	 * @param number A long containing the number to be formatted
-	 * @param fmt A string containing the format specification&lt;/br&gt; 
+	 * @param fmt A string containing the format specification&lt;/br&gt;
 	 * @return The formatted number
 	 */
 	public static String formatLong(long number, String fmt) {
-		Long L=new Long();
-		L.set(number);
+		Long L=new Long(number);
 		return formatLong(L,fmt);
 	}
 	/**
 	 * Formats a Double to a given format specifier
 	 * @param number A Double containing the number to be formatted
-	 * @param fmt A string containing the format specification&lt;/br&gt; 
+	 * @param fmt A string containing the format specification&lt;/br&gt;
 	 * @return The formatted number
 	 */
-	public static String formatDouble(ewe.sys.Double number, String fmt) {
+	public static String formatDouble(Double number, String fmt) {
 		if (l==null) init();
-		return l.format(Locale.FORMAT_PARSE_NUMBER,number,fmt);
+		return l.format(number.doubleValue(),fmt,0);
 	}
 
 	/**
 	 * Formats a Double to a given format specifier
 	 * @param number A double containing the number to be formatted
-	 * @param fmt A string containing the format specification&lt;/br&gt; 
+	 * @param fmt A string containing the format specification&lt;/br&gt;
 	 * @return The formatted number
 	 */
 	public static String formatDouble(double number, String fmt) {
-		Double d=new Double();
-		d.set(number);
+		Double d=new Double(number);
 		return formatDouble(d,fmt);
 	}
 
-	/**
-	 * This function checks whether the device supports a
-	 * supplementary input panel (SIP) and if yes, shows it.
-	 *
-	 */
-	public static void setSIPOn() {
-		if (Gui.screenIs(Gui.PDA_SCREEN) &amp;&amp; Vm.isMobile()) {
-			Vm.setSIP(Vm.SIP_ON);
-		}
-	}
 
+	/*=================================================================
+	 * During initialisation the file &quot;language&quot; in the program directory
+	 * is read to check whether the user wishes to ovverride the default
+	 * language. This language cannot be stored in the pref.xml file, due
+	 * to an initialisation conflict (pref.xml needs MyLocale). A better
+	 * solution may be to read the override language from the command line,
+	 * but I do not know how to specify command line parameters on a PDA
+	 ==================================================================*/
 	/**
-	 * This function checks whether the device supports a
-	 * supplementary input panel (SIP) and if yes, hides it and
-	 * also hides the button.
-	 *
-	 */
-	public static void setSIPOff() {
-		if (Gui.screenIs(Gui.PDA_SCREEN) &amp;&amp; Vm.isMobile()) {
-			Vm.setSIP(0);
-		}
-	}
-
-	/**
-	 * This function checks whether the device supports a
-	 * supplementary input panel (SIP) and if yes, hides it and just
-	 * shows the button.
-	 *
-	 */
-	public static void setSIPButton() {
-		if (Gui.screenIs(Gui.PDA_SCREEN) &amp;&amp; Vm.isMobile()) {
-			Vm.setSIP(Vm.SIP_LEAVE_BUTTON);
-		}
-	}
-
-	/**
-	 * Read the language from the prefs and return the specified language (or empty
+	 * Read the language file and return the specified language (or empty
 	 * string if none specified).
 	 * @return Language (e.g. DE, EN etc.) or &quot;&quot;
 	 */
 	private static String getLanguage() {
-		Preferences pref = Global.getPref();
-		if ( pref != null ) {
-			language = pref.language;
-		} else {
-			language = &quot;&quot;;
-		}
-		if (language==null) language=&quot;&quot;;
-		return language;
+        Preferences pref = Global.getPref();
+        if ( pref != null ) {
+                language = pref.language;
+        } else {
+                language = &quot;&quot;;
+        }
+        if (language==null) language=&quot;&quot;;
+        return language;
 	}
 
 	/**
-	 * Write the override language 
+	 * Write the override language
 	 * @param language The language to write
 	 */
 	public static void saveLanguage(String saveLanguage) {
-		Preferences pref = Global.getPref();
-		if ( pref != null ) {
+        Preferences pref = Global.getPref();
+        if ( pref != null ) {
 			pref.language = saveLanguage;
 			pref.savePreferences();
-		}
+        }
 	}
 
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/MyScrollBarPanel.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/MyScrollBarPanel.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/MyScrollBarPanel.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,11 +1,11 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.ui.ScrollBarPanel;
-import ewe.ui.ScrollClient;
-import ewe.ui.ScrollablePanel;
+import eve.ui.ScrollBarPanel;
+import eve.ui.ScrollClient;
+import eve.ui.ScrollablePanel;
 
 /**
- * Always use this class instead of ewe.ui.ScrollBarPanel
+ * Always use this class instead of eve.ui.ScrollBarPanel
  * as it will change it's size automatically with
  * the font size, which is entered in the preferences dialog
  * 
@@ -15,15 +15,14 @@
 public class MyScrollBarPanel extends ScrollBarPanel {
 	public MyScrollBarPanel(ScrollClient client,int options) {
 		super(client, options);
-		int s = java.lang.Math.round(Global.getPref().fontSize / 11f * 15f); // standard fontsize = 1, standard bottum size = 15
+		int s = java.lang.Math.round((Global.getPref().fontSize) / 11f * 15f); // standard fontsize = 1, standard bottum size = 15
 		setScrollBarSize(s, s, s);
 	}
 	public MyScrollBarPanel(ScrollClient client)
 	{
 		this(client,0);
 	}
-	public ScrollablePanel getScrollablePanel()
-	{
+	public ScrollablePanel getScrollablePanel() {
 		return new MyScrollBarPanel(getScrollClient());
 	}
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/NewProfileForm.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/NewProfileForm.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/NewProfileForm.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,35 +1,36 @@
-package CacheWolf;
+package cachewolf;
 
-import utils.FileBugfix;
-import ewe.io.File;
-import ewe.ui.*;
+import eve.io.File;
+import eve.ui.event.ControlEvent;
+import eve.ui.Form;
+import eve.fx.gui.IKeys;
+import eve.sys.Event;
+import eve.ui.MessageBox;
+import eve.ui.Button;
+import eve.ui.Input;
 
 public class NewProfileForm extends Form {
-	private mButton btnCancel,btnOK;
-	private mInput inpDir;
-	private TextMessage description;
+	private Button btnCancel,btnOK;
+	private Input inpDir;
 	public String profileDir;
 	private String baseDir;
 	//private Profile profile;
-	
+
 	public NewProfileForm (String baseDir) {
         super();
 		//profile=prof;
         title = MyLocale.getMsg(1111,&quot;Create new profile:&quot;);
-		addLast(inpDir=new mInput(MyLocale.getMsg(1112,&quot;New profile name&quot;)),HSTRETCH,HFILL|LEFT);
-		description = new TextMessage(MyLocale.getMsg(1123,&quot;Click 'Next' to define the center coordinates for this profile.&quot;));
-		description.setPreferredSize(240, -1);
-		addLast(description,HSTRETCH,HFILL|LEFT);
-		btnCancel = new mButton(MyLocale.getMsg(708,&quot;Cancel&quot;));
+		addLast(inpDir=new Input(MyLocale.getMsg(1112,&quot;New profile name&quot;)),HSTRETCH,HFILL|LEFT);
+		btnCancel = new Button(MyLocale.getMsg(708,&quot;Cancel&quot;));
 		btnCancel.setHotKey(0, IKeys.ESCAPE);
 		addNext(btnCancel,HSTRETCH,LEFT);
-		btnOK = new mButton(MyLocale.getMsg(1124,&quot;Next&quot;));
+		btnOK = new Button(MyLocale.getMsg(1605,&quot;OK&quot;));
 		btnOK.setHotKey(0, IKeys.ENTER);
 		addLast(btnOK,HSTRETCH,HFILL|RIGHT);
 		this.setPreferredSize(240,-1);
 		this.baseDir=baseDir;
 	}
-	
+
 	public void onEvent(Event ev){
 		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
 			if (ev.target == btnCancel){
@@ -37,27 +38,21 @@
 			}
 			if (ev.target == btnOK){
 				profileDir=inpDir.getDisplayText();
-				if (profileDir.equalsIgnoreCase(&quot;maps&quot;)) {
-					MessageBox mb=new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(1122,&quot;'maps' is reserved for the maps directory.&quot;),MBOK);
+				File f=new File(baseDir+profileDir);
+				if (f.exists()) {
+					MessageBox mb=new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(1114,&quot;Directory exists already.&quot;),MBOK);
 					mb.execute();
 					profileDir=&quot;&quot;;
 				} else {
-					File f=new FileBugfix(baseDir+profileDir);
-					if (f.exists()) {
-						MessageBox mb=new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(1114,&quot;Directory exists already.&quot;),MBOK);
+					if (profileDir.indexOf(&quot;/&quot;)&gt;=0 || profileDir.indexOf(&quot;\\&quot;)&gt;=0 || !f.createDir()) {
+						MessageBox mb=new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(1113,&quot;Cannot create directory&quot;),MBOK);
 						mb.execute();
 						profileDir=&quot;&quot;;
-					} else {
-						if (profileDir.indexOf(&quot;/&quot;)&gt;=0 || profileDir.indexOf(&quot;\\&quot;)&gt;=0 || !f.createDir()) {
-							MessageBox mb=new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(1113,&quot;Cannot create directory&quot;),MBOK);
-							mb.execute();
-							profileDir=&quot;&quot;;
-							this.close(-1);
-						}
-						Global.getProfile().filterActive=Filter.FILTER_INACTIVE;
-						Global.getProfile().filterInverted=false;
-						this.close(0);
+						this.close(-1);
 					}
+					Global.getProfile().filterActive=Filter.FILTER_INACTIVE;
+					Global.getProfile().filterInverted=false;
+					this.close(0);
 				}
 			}
 		}

Modified: experiments/engywuck/hist-test/src/cachewolf/NewProfileWizard.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/NewProfileWizard.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/NewProfileWizard.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,11 +1,11 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.ui.FormBase;
-import ewe.ui.Gui;
+import eve.ui.FormBase;
+import eve.ui.Gui;
 
 public class NewProfileWizard {
 
-	static public boolean startNewProfileWizard(ewe.ui.Frame parent) {
+	static public boolean startNewProfileWizard(eve.ui.Frame parent) {
 		if (Global.mainTab != null) Global.mainTab.saveUnsavedChanges(true);
 		Preferences pref = Global.getPref();
 		NewProfileForm f=new NewProfileForm(pref.baseDir);
@@ -23,7 +23,7 @@
 				profile.centre.set(cs.getCoords());
 				profile.hasUnsavedChanges=true;
 			}
-			Global.mainForm.setTitle(&quot;Cachewolf &quot;+Version.getRelease()+&quot; - &quot;+profile.name);
+			Global.mainForm.title=&quot;Cachewolf &quot;+Version.getRelease()+&quot; - &quot;+profile.name;
 		}
 		f.close(0);
 		return (code == 0);

Modified: experiments/engywuck/hist-test/src/cachewolf/Parser.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/Parser.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/Parser.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,5 +1,5 @@
 /* A parser that parses the following grammar:
-  EBNF Meta-Symbols: 
+  EBNF Meta-Symbols:
     {xx}        xx can occur any number of times incl 0
     [xx]        xx or empty
     |           or
@@ -8,9 +8,9 @@
 command -&gt; if |
            simplecommand
 
-simplecommand -&gt; &quot;stop&quot; | &quot;st&quot; | 
+simplecommand -&gt; &quot;stop&quot; | &quot;st&quot; |
 		   assign
-           stringexp | 
+           stringexp |
 
 if -&gt; &quot;IF&quot; stringexpr compop stringexpr &quot;THEN&quot; simplecommand { &quot;;&quot; simplecommand } &quot;ENDIF&quot;          // Nested IF's not allowed
 
@@ -22,39 +22,43 @@
 
 expr -&gt; [&quot;+&quot; | &quot;-&quot;] tailexp [ formatstring ]
 
-tailexp -&gt; term { (&quot;+&quot; | &quot;-&quot;) term } 
-		 
+tailexp -&gt; term { (&quot;+&quot; | &quot;-&quot;) term }
+
 term -&gt; factor { (&quot;*&quot; | &quot;/&quot;) factor }
 
 factor -&gt; expfactor { &quot;^&quot; expfactor }
 
-expfactor -&gt; ident | 
-          number | 
+expfactor -&gt; ident |
+          number |
           &quot;(&quot; stringexpr &quot;)&quot; |
           function &quot;(&quot; stringexpr { &quot;,&quot; stringexpr }&quot;)&quot;
-          
-function -&gt; &quot;sin&quot; | &quot;cos&quot; | &quot;tan&quot; | &quot;asin&quot; | &quot;acos&quot; | &quot;atan&quot; | &quot;goto&quot; | &quot;project&quot; | &quot;show&quot;  | &quot;crosstotal&quot; | 
-            &quot;rot13&quot; | &quot;len&quot; | &quot;mid&quot;         
 
+function -&gt; &quot;sin&quot; | &quot;cos&quot; | &quot;tan&quot; | &quot;asin&quot; | &quot;acos&quot; | &quot;atan&quot; | &quot;goto&quot; | &quot;project&quot; | &quot;show&quot;  | &quot;crosstotal&quot; |
+            &quot;rot13&quot; | &quot;len&quot; | &quot;mid&quot;
+
 ident -&gt; valid identifier
 number -&gt; valid number
 
 
 */
 
-package CacheWolf;
+package cachewolf;
 
-import ewe.util.*;
-import CacheWolf.navi.Navigate;
+import java.util.*;
 
-import com.stevesoft.ewe_pat.*;
-import ewe.sys.*;
+import cachewolf.navi.Navigate;
+import cachewolf.utils.Common;
+import cachewolf.utils.STRreplace;
+
+import com.stevesoft.eve_pat.*;
+import eve.sys.*;
 import java.lang.Double;
 
 
+
 /**
 *	The wolf language parser. New version - January 2007
-*   
+*
 *   New features:
 *   - Improved error handling
 *   - Strings and doubles can be freely mixed as appropriate. Depending on context a conversion is performed,
@@ -70,16 +74,16 @@
 *   	- Command terminator ; no longer compulsory (only between multiple commands on same line)
 *   - New functions can easily be added
 *   - Can select whether variable names are case sensitive
-*   
+*
 *   To add a new function:
 *     1) Add its name and alias and allowed number of args to array functions
 *     2) Add a new private method in the &quot;functions&quot; section
-*     3) Add call to private method in executeFunction 
+*     3) Add call to private method in executeFunction
 *   @author salzkammergut Januay 2007
-*/ 
+*/
 public class Parser{
 
-	private class fnType { 
+	private static class fnType {
 		public String funcName; 	 // the function name in the user input
 		public String alias;         // the funcName is mapped to this alias
 		public int nargs;            // bitmap for number of args, i.e. 14 = 1 or 2 or 3 args; 5 = 0 or 2 args
@@ -92,7 +96,7 @@
 		}
 	}
     fnType[] functions=new fnType[]{ // in alphabetical order
-    	new fnType(&quot;abs&quot;,&quot;abs&quot;,2),	
+    	new fnType(&quot;abs&quot;,&quot;abs&quot;,2),
     	new fnType(&quot;acos&quot;,&quot;acos&quot;,2),
     	new fnType(&quot;asin&quot;,&quot;asin&quot;,2),
     	new fnType(&quot;atan&quot;,&quot;atan&quot;,2),
@@ -119,6 +123,8 @@
     	new fnType(&quot;instr&quot;,&quot;instr&quot;,12),
     	new fnType(&quot;lcase&quot;,&quot;lc&quot;,2),
     	new fnType(&quot;length&quot;,&quot;len&quot;,2),
+    	new fnType(&quot;ln&quot;,&quot;ln&quot;,2),
+    	new fnType(&quot;log&quot;,&quot;log&quot;,2),
     	new fnType(&quot;mid&quot;,&quot;mid&quot;,12),
      	new fnType(&quot;pc&quot;,&quot;pz&quot;,3),
      	new fnType(&quot;profilecenter&quot;,&quot;pz&quot;,3),
@@ -145,28 +151,28 @@
     	new fnType(&quot;val&quot;,&quot;val&quot;,2),
      	new fnType(&quot;zentrum&quot;,&quot;center&quot;,3)
      	    	};
-	private static int scanpos = 0;
+	private int scanpos = 0;
 	CWPoint cwPt=new CWPoint();
 	Vector calcStack=new Vector();
 	Hashtable symbolTable = new Hashtable(50);
 	TokenObj thisToken = new TokenObj();
 	Vector tokenStack;
 	Vector messageStack;
-	
+
 	public Parser(){
 	}
 
 ///////////////////////////////////////////
 //  Utility functions
 ///////////////////////////////////////////
-	
+
 	/* All errors are handled via function 'err'. Rather than creating many different Exceptions,
 	 * only the standard Exception is used. err raises this exception and thereby causes the stack to be
 	 * unwound until 'parse' eventually catches the exception and returns to SolverPanel, which displays
 	 * the messageStack containing the error message.
 	 */
-	
-	/** 
+
+	/**
      * Add an error message to the message stack and raise an Exception.
     */
 	private void err(String str) throws Exception {
@@ -176,16 +182,16 @@
     	if (Global.mainTab.solverP.mText.setSelectionRange(0,thisToken.line-1,thisToken.position+thisToken.token.length()-1,thisToken.line-1))Global.mainTab.solverP.mText.repaintNow();
     	throw new Exception(&quot;Error &quot;+str);
     }
-    
+
     /** Shows global symbols */
     private void showVars(boolean globals) throws Exception {
-    	Iterator it=symbolTable.entries();
-    	while (it.hasNext()) {
-    		String varName=((String)((ewe.util.Map.MapEntry) it.next()).getKey());
+    	Enumeration en=symbolTable.keys();
+    	while (en.hasMoreElements()) {
+    		String varName=(String)en.nextElement();
     		if (globals == varName.startsWith(&quot;$&quot;)) {
     			String value=(String) getVariable(varName);
     			if (java.lang.Double.isNaN(toNumber(value)))
-    				messageStack.add(varName+&quot; = \&quot;&quot;+STRreplace.replace(value.toString(),&quot;\&quot;&quot;,&quot;\&quot;\&quot;&quot;)+&quot;\&quot;&quot;);
+    				messageStack.add(varName+&quot; = \&quot;&quot;+STRreplace.replace(value,&quot;\&quot;&quot;,&quot;\&quot;\&quot;&quot;)+&quot;\&quot;&quot;);
     			else
     				messageStack.add(varName+&quot; = &quot;+value);
     		}
@@ -194,31 +200,31 @@
 
 	/** Clears the symbol table of all non-global symbols (those not starting with $) */
     private void clearLocalSymbols() {
-    	Iterator it=symbolTable.entries();
-    	while (it.hasNext()) {
-    		ewe.util.Map.MapEntry sym=(ewe.util.Map.MapEntry) it.next();
-    		if (!((String)sym.getKey()).startsWith(&quot;$&quot;)) 
-    			symbolTable.remove(sym.getKey());
+    	Enumeration en=symbolTable.keys();
+    	while (en.hasMoreElements()) {
+    		String varName=(String)en.nextElement();
+    		if (!(varName.startsWith(&quot;$&quot;)))
+    			symbolTable.remove(varName);
     	}
     	Double pi=new Double(java.lang.Math.PI);
     	symbolTable.put(&quot;PI&quot;,pi);
     	symbolTable.put(&quot;pi&quot;,pi); // To make it easier for the user we also add a lowercase version of pi
     }
-    
+
 	private boolean isVariable(String varName) {
-		return varName.startsWith(&quot;$&quot;) ||  // Global variables exist per default 
+		return varName.startsWith(&quot;$&quot;) ||  // Global variables exist per default
 		       symbolTable.containsKey(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
 	}
-	
+
 	private boolean isInteger(double d) {
 		return java.lang.Math.ceil(d)==d &amp;&amp; java.lang.Math.floor(d)==d;
 	}
-	
+
     private boolean isValidCoord(String coord) {
     	cwPt.set(coord);
     	return cwPt.isValid();
     }
-    
+
 	private Object getVariable(String varName) throws Exception {
 		if (varName.startsWith(&quot;$&quot;)) { // Potential coordinate
 			int idx=Global.getProfile().getCacheIndex(varName.substring(1));
@@ -226,10 +232,9 @@
 				CacheHolder ch=(CacheHolder)Global.getProfile().cacheDB.get(idx);
 				// Check whether coordinates are valid
 				cwPt.set(ch.pos);
-				if (cwPt.isValid() ) 
+				if (cwPt.isValid() )
 					return cwPt.toString();
-				else
-					return &quot;&quot;; // Convert invalid coordinates (N 0 0.0 E 0 0.0) into empty string
+				return &quot;&quot;; // Convert invalid coordinates (N 0 0.0 E 0 0.0) into empty string
 			}
 		}
 		Object result = symbolTable.get(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
@@ -243,10 +248,10 @@
 		}
 		return result;
 	}
-	
+
 	private double toNumber(String str) {
 		try {
-			if (MyLocale.getDigSeparator().equals(&quot;,&quot;))	
+			if (MyLocale.getDigSeparator().equals(&quot;,&quot;))
 				str = str.replace('.', ',');
 			else
 				str = str.replace(',','.');
@@ -255,50 +260,50 @@
 			 return java.lang.Double.NaN;
 		}
 	}
-	
+
 	private Double getNumber(String str) throws Exception {
 		double ret=toNumber(str);
 		if (java.lang.Double.isNaN(ret))
 			err(MyLocale.getMsg(1703,&quot;Not a valid number: &quot;) + str);
 		return new java.lang.Double(ret);
 	}
-	
+
 	/** Get the top element of the calculation stack and try and convert it to a number if it is a string */
 	private double popCalcStackAsNumber(double defaultForEmptyString) throws Exception {
 		double num;
 		if (calcStack.get(calcStack.size()-1) instanceof String) {
 			if (((String)calcStack.get(calcStack.size()-1)).equals(&quot;&quot;))
 				num=defaultForEmptyString;
-			else	
+			else
 				num = getNumber((String)calcStack.get(calcStack.size()-1)).doubleValue();
 		} else {
 			num = ((java.lang.Double)calcStack.get(calcStack.size()-1)).doubleValue();
 		}
 		calcStack.removeElementAt(calcStack.size()-1);
-		return num;	
+		return num;
 	}
-	
-	private String popCalcStackAsString() {
-		String s;
-		if (calcStack.get(calcStack.size()-1) instanceof Double) {
-			java.lang.Double D=((java.lang.Double)calcStack.get(calcStack.size()-1));
-			// Double.toString() formats numbers &gt; 1E7 and &lt; 1E-3 with exponential notation
-			// For large integers we therefore use Longs  
-			double d=D.doubleValue();
-			// If the double is an integer and within range of longs, use Long
-			if (java.lang.Math.floor(d)==d &amp;&amp; d&lt;java.lang.Long.MAX_VALUE &amp;&amp; d&gt;java.lang.Long.MIN_VALUE) {
-				java.lang.Long L=new java.lang.Long((long)d);
-				s=L.toString();
-			} else { // Use the default Double format
-				s = D.toString().replace(',','.'); // always show numbers with decimal point;
-				if (s.endsWith(&quot;.0&quot;)) s=s.substring(0,s.length()-2);
-			}
-		} else
-			s = (String)calcStack.get(calcStack.size()-1);
-		calcStack.removeElementAt(calcStack.size()-1);
-		return s;	
-	}
-	
+
+    private String popCalcStackAsString() {
+        String s;
+        if (calcStack.get(calcStack.size()-1) instanceof Double) {
+                java.lang.Double D=((java.lang.Double)calcStack.get(calcStack.size()-1));
+                // Double.toString() formats numbers &gt; 1E7 and &lt; 1E-3 with exponential notation
+                // For large integers we therefore use Longs
+                double d=D.doubleValue();
+                // If the double is an integer and within range of longs, use Long
+                if (java.lang.Math.floor(d)==d &amp;&amp; d&lt;java.lang.Long.MAX_VALUE &amp;&amp; d&gt;java.lang.Long.MIN_VALUE) {
+                        java.lang.Long L=new java.lang.Long((long)d);
+                        s=L.toString();
+                } else { // Use the default Double format
+                        s = D.toString().replace(',','.'); // always show numbers with decimal point;
+                        if (s.endsWith(&quot;.0&quot;)) s=s.substring(0,s.length()-2);
+                }
+        } else
+                s = (String)calcStack.get(calcStack.size()-1);
+        calcStack.removeElementAt(calcStack.size()-1);
+        return s;
+    }
+
 	private void getToken() throws Exception {
 		if(scanpos &lt; tokenStack.size()){
 			thisToken = (TokenObj)tokenStack.get(scanpos);
@@ -306,18 +311,18 @@
 			scanpos++;
 		} else err(MyLocale.getMsg(1704,&quot;Unexpected end of source&quot;));
 	}
-	
+
 	private TokenObj peekToken() {
 		if(scanpos &lt; tokenStack.size()){
 			return (TokenObj)tokenStack.get(scanpos);
-		} else
-			return new TokenObj();
+		}
+		return new TokenObj();
 	}
 
 	private void getNextTokenOtherThanSemi() throws Exception {
 		do {
 			getToken();
-		} while (thisToken.token.equals(&quot;;&quot;));	
+		} while (thisToken.token.equals(&quot;;&quot;));
 	}
 
 	private void skipPastEndif(TokenObj ifToken) throws Exception {
@@ -335,14 +340,13 @@
 	private TokenObj lookAheadToken() {
 		return (TokenObj)tokenStack.get(scanpos);
 	}
-	
+
 	private boolean checkNextSymIs(String str) throws Exception {
 		if(thisToken.token.toUpperCase().equals(str)){
 			return true;
-		} else {
-			err(MyLocale.getMsg(1706,&quot;Expected &quot;) + str + &quot;  &quot;+MyLocale.getMsg(1707,&quot;Found: &quot;)+thisToken.token);
-			return false; //Dummy as err does not return
 		}
+		err(MyLocale.getMsg(1706,&quot;Expected &quot;) + str + &quot;  &quot;+MyLocale.getMsg(1707,&quot;Found: &quot;)+thisToken.token);
+		return false; //Dummy as err does not return
 	}
 
 	private fnType getFunctionDefinition(String str) throws Exception {
@@ -364,23 +368,21 @@
 ///////////////////////////////////////////
 //  FUNCTIONS
 ///////////////////////////////////////////
-	
+
 	/** If we are in DEGree mode, convert the argument to RADiants, if not leave it unchanged */
 	private double makeRadiant(double arg) {
 		if (Global.getPref().solverDegMode)
 			return arg*java.lang.Math.PI/180.0;
-		else
-			return arg;
+		return arg;
 	}
-	
+
 	/** If we are in DEGree mode, convert the argument to degrees */
 	private double makeDegree(double arg) {
 		if (Global.getPref().solverDegMode)
 			return arg/java.lang.Math.PI*180.0;
-		else
-			return arg;
+		return arg;
 	}
-    
+
     /** Calculate brearing from one point to the next */
     private double funcBearing() throws Exception {
     	String coordB=popCalcStackAsString();
@@ -404,21 +406,21 @@
 			Global.getProfile().updateBearingDistance();
 		}
 	}
-	
+
 	/** Clear Screen */
 	private void funcCls() {
 		// OutputPanel is private, so need to cast to base class
-		((ewe.ui.mTextPad) Global.mainTab.solverP.mOutput).setText(&quot;&quot;);
+		Global.mainTab.solverP.clearOutput();
 	}
-	
+
 	private int funcCountChar(String s, char c) {
     	int count=0;
     	for (int i=0; i&lt;s.length(); i++)
     		if (s.charAt(i)==c) count++;
     	return count;
     }
-    
-    /** count(string1,string2) 
+
+    /** count(string1,string2)
      * */
     private void funcCount()throws Exception {
        	String s2=popCalcStackAsString();
@@ -432,48 +434,48 @@
     			res+=s2.charAt(i)+&quot;=&quot;+funcCountChar(s1,s2.charAt(i))+&quot; &quot;;
     		}
     		calcStack.add(res);
-    	} 
+    	}
     }
-    
+
     private String funcCp(){
     	return Global.mainTab.nav.gpsPos.toString();
     }
-    
+
     /**
      *  Crosstotal: Works for both strings and numbers. For strings any non-numeric character is ignored
      *  Warning: When the number is non-integer or &gt; 9223372036854775807, it is formatted using the E
-     *  notation, i.e. x.xxxxxxEyy. In this case the exponent yy is also included in the crosstotal 
+     *  notation, i.e. x.xxxxxxEyy. In this case the exponent yy is also included in the crosstotal
      */
     private double funcCrossTotal(int nargs) throws Exception {
-    	int cycles=1;
-		if (nargs==2) cycles=(int)popCalcStackAsNumber(1);
-		String aString=popCalcStackAsString().replace('-','0').trim();
-		double a=0;
-		if (cycles&lt;0) cycles=1;
-    	if (cycles&gt;5) cycles=5;
-    	while (cycles--&gt;0) {
-	    	// Cross total = Quersumme berechnen
-			a=0;
-			for (int i=0; i&lt;aString.length(); i++) {
-			   if (aString.charAt(i)&gt;='0' &amp;&amp; aString.charAt(i)&lt;='9')
-			      a += aString.charAt(i)-'0';
-			}
-			aString=Convert.toString(a);
-    	} 
-    	return a;
+        int cycles=1;
+                if (nargs==2) cycles=(int)popCalcStackAsNumber(1);
+                String aString=popCalcStackAsString().replace('-','0').trim();
+                double a=0;
+                if (cycles&lt;0) cycles=1;
+        if (cycles&gt;5) cycles=5;
+        while (cycles--&gt;0) {
+                // Cross total = Quersumme berechnen
+                        a=0;
+                        for (int i=0; i&lt;aString.length(); i++) {
+                           if (aString.charAt(i)&gt;='0' &amp;&amp; aString.charAt(i)&lt;='9')
+                              a += aString.charAt(i)-'0';
+                        }
+                        aString=Convert.toString(a);
+        }
+        return a;
     }
-    
+
     private void funcDeg(boolean arg) {
     	Global.getPref().solverDegMode=arg;
     	Global.mainTab.solverP.showSolverMode();
     }
-    
+
     /** Convert degrees into Radiants */
     private double funcDeg2Rad() throws Exception {
     	double a=popCalcStackAsNumber(0);
     	return a/180.0*java.lang.Math.PI;
     }
-    	
+
     	/** Calculate distance between 2 points */
     private double funcDistance() throws Exception {
     	String coordB=popCalcStackAsString();
@@ -484,7 +486,7 @@
     	cwPt.set(coordA);
     	return cwPt.getDistance(new CWPoint(coordB))*1000.0;
     }
-    
+
     /**
      * Encode a string by replacing all characters in a string with their corresponding characters in
      * another string
@@ -500,13 +502,13 @@
     		int pos;
     		if ((pos=oldChars.indexOf(s.charAt(i)))!=-1) {
     			encodedStr+=newChars.charAt(pos);
-    		} else 
+    		} else
     			encodedStr+=s.charAt(i);
     	}
     	 return encodedStr;
     }
-    
-    /** Format a valid coordinate 
+
+    /** Format a valid coordinate
      *  If called with one args, format the argument on the stack to CW standard
      *  The optional second argument is one of these strings &quot;UTM&quot;,&quot;DMS&quot;,&quot;DD&quot;,&quot;DMM&quot; or &quot;CW&quot;
      * @param nargs 1 or 2 args
@@ -525,13 +527,13 @@
     	else if (!fmtStr.equals(&quot;cw&quot;)) err(MyLocale.getMsg(1713,&quot;Invalid coordinate format. Allowed are CW/DD/DMM/DMS/UTM&quot;));
     	return cwPt.toString(fmt);
     }
-    
+
     /** Implements a goto command goto(coordinate,optionalWaypointName).
      */
     private void funcGoto(int nargs) throws Exception {
     	Navigate nav=Global.mainTab.nav;
 		String waypointName=null;
-        if (nargs==2) waypointName=popCalcStackAsString();  
+        if (nargs==2) waypointName=popCalcStackAsString();
 		String coord=popCalcStackAsString();
 		if (!isValidCoord(coord)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coord);
 		// Don't want to switch to goto panel, just set the values
@@ -541,23 +543,23 @@
     		if (i&lt;0) err(MyLocale.getMsg(1714,&quot;Goto: Waypoint does not exist: &quot;)+waypointName);
     		cwPt.set(coord);
     		CacheHolder ch=((CacheHolder)Global.getProfile().cacheDB.get(i));
-    		ch.LatLon=cwPt.toString(CWPoint.CW);
+    		ch.latLon=cwPt.toString(CWPoint.CW);
     		ch.pos.set(cwPt);
-    		ch.calcDistance(Global.getPref().curCentrePt); // Update distance/bearing 
+    		ch.calcDistance(Global.getPref().curCentrePt); // Update distance/bearing
     	    Global.getProfile().selectionChanged=true; // Tell moving map to updated displayed waypoints
     	}
     }
-    
+
     /** Display or change the case sensitivity of variable names */
     private void funcIgnoreVariableCase(int nargs) throws Exception {
-    	if (nargs==0) 
+    	if (nargs==0)
     		calcStack.add(&quot;&quot;+Global.getPref().solverIgnoreCase);
     	else {
     		Global.getPref().solverIgnoreCase=(popCalcStackAsNumber(0)!=0)?true:false;
     	}
     }
-    
-    /** VB instr function 
+
+    /** VB instr function
      * instr([start],string1,string2)
      * */
     private int funcInstr(int nargs) throws Exception {
@@ -567,14 +569,25 @@
     	if (nargs==3) start=(int) popCalcStackAsNumber(1);
     	if (start&gt;s1.length()) err(MyLocale.getMsg(1715,&quot;instr: Start position not in string&quot;));
     	if(s2.equals(&quot;&quot;)) {
-    		if (s1.equals(&quot;&quot;)) 
+    		if (s1.equals(&quot;&quot;))
     			return 0;
-    		else
-    			return 1;
+    		return 1;
     	}
     	return s1.indexOf(s2,start-1)+1;
     }
 
+    private double funcLn() throws Exception {
+    	double a=popCalcStackAsNumber(0);
+    	if (a&lt;0) err(MyLocale.getMsg(99999,&quot;Cannot calculate log of a negative number&quot;)); //TODO
+    	return java.lang.Math.log(a);
+    }
+
+    private double funcLog() throws Exception {
+    	double a=popCalcStackAsNumber(0);
+    	if (a&lt;0) err(MyLocale.getMsg(99999,&quot;Cannot calculate log of a negative number&quot;)); //TODO
+    	return java.lang.Math.log(a)/java.lang.Math.log(10.0);
+    }
+
     /** MID function as in Basic */
     private String funcMid(int nargs) throws Exception {
     	if (nargs==2) {
@@ -583,17 +596,16 @@
     		if (!isInteger(start)) err(MyLocale.getMsg(1716,&quot;mid: Integer argument expected&quot;));
     		if (start&lt;1 || start&gt;s.length()) err(MyLocale.getMsg(1717,&quot;mid: Argument out of range&quot;));
     		return s.substring((int)start-1);
-    	} else {
-        	double len=popCalcStackAsNumber(0);
-        	double start=popCalcStackAsNumber(0);
-    		String s=popCalcStackAsString();
-    		if (!isInteger(start) || !isInteger(len)) err(MyLocale.getMsg(1716,&quot;mid: Integer argument expected&quot;));
-    		int end=(int)(start+len-1);
-    		if (start&gt;s.length() || start&lt;1 || end&gt;s.length()) err(MyLocale.getMsg(1717,&quot;mid: Argument out of range&quot;));
-    		return s.substring((int)start-1,end);
     	}
+    	double len=popCalcStackAsNumber(0);
+    	double start=popCalcStackAsNumber(0);
+		String s=popCalcStackAsString();
+		if (!isInteger(start) || !isInteger(len)) err(MyLocale.getMsg(1716,&quot;mid: Integer argument expected&quot;));
+		int end=(int)(start+len-1);
+		if (start&gt;s.length() || start&lt;1 || end&gt;s.length()) err(MyLocale.getMsg(1717,&quot;mid: Argument out of range&quot;));
+		return s.substring((int)start-1,end);
     }
- 
+
 	/** Get or set the profile centre */
 	private void funcPz(int nargs) throws Exception {
 		if (nargs==0) {
@@ -604,16 +616,16 @@
 			Global.getProfile().centre.set(coordA);
 		}
 	}
-    
+
     /** Project a waypoint at some angle and some distance */
     private String funcProject() throws Exception {
     	double distance=popCalcStackAsNumber(0);
     	if (distance&lt;0) err(MyLocale.getMsg(1718,&quot;Cannot project a negative distance&quot;));
     	double degrees=popCalcStackAsNumber(0);
     	// If we are not in degree mode, arg is in radiants ==&gt; convert it
-    	if (!Global.getPref().solverDegMode) degrees=degrees * 180.0 / java.lang.Math.PI; 
-    	if (degrees&lt;0 || degrees&gt;360) 
-    		if (Global.getPref().solverDegMode) 
+    	if (!Global.getPref().solverDegMode) degrees=degrees * 180.0 / java.lang.Math.PI;
+    	if (degrees&lt;0 || degrees&gt;360)
+    		if (Global.getPref().solverDegMode)
     			err(MyLocale.getMsg(1719,&quot;Projection degrees must be in interval [0;360]&quot;));
     		else
     			err(MyLocale.getMsg(1739,&quot;Projection degrees must be in interval [0;2*PI]&quot;));
@@ -628,7 +640,7 @@
     	double a=popCalcStackAsNumber(0);
     	return a*180.0/java.lang.Math.PI;
     }
-    
+
     /** Replace all occurrences of a string with another string */
     private String funcReplace() throws Exception {
     	String replaceWith=popCalcStackAsString();
@@ -637,20 +649,20 @@
         if (whatToReplace.equals(&quot;&quot;)) return s;
         return STRreplace.replace(s,whatToReplace,replaceWith);
     }
-    
+
     /** Reverse a string */
     private String funcReverse(String s) {
     	String res=&quot;&quot;;
     	for (int i=s.length()-1; i&gt;=0; i--) res+=s.charAt(i);
     	return res;
     }
-    
+
     /** Create a skeleton for multis. This function can be called in three ways:&lt;br&gt;
-     *  &lt;pre&gt;sk()                Create skeleton for current cache (must have addi wpts) 
-     *  sk(number)          Create skeleton for number variables 
+     *  &lt;pre&gt;sk()                Create skeleton for current cache (must have addi wpts)
+     *  sk(number)          Create skeleton for number variables
      */
     private void funcSkeleton(int nargs) throws Exception {
-   		String waypointName=Global.mainTab.lastselected;
+    	String waypointName=Global.mainTab.lastselected;
     	int ci=Global.getProfile().getCacheIndex(waypointName);
     	if (ci&lt;0) return;
     	// If it is an addi, find its main cache
@@ -677,10 +689,10 @@
 				String stage=MyLocale.formatLong(i,&quot;00&quot;);
 				String stageWpt=&quot;$&quot;+stage+waypointName.substring(2);
 				String stageName = &quot;Stage &quot;+(i+1);
-				String type = &quot;51&quot;;
+				int type = 51;
 				if (i == nStages - 1) {
 					stageName = &quot;Final&quot;;
-					type = &quot;53&quot;;
+					type = 53;
 				}
 				didCreateWp|=createWptIfNeeded(stage+waypointName.substring(2), stageName, type);
 				op.append(&quot;IF &quot;+stageWpt+&quot;=\&quot;\&quot; THEN\n&quot;);
@@ -688,11 +700,12 @@
 				op.append(&quot;  \&quot;&quot;+stageName+&quot; = \&quot; &quot;+stageWpt+&quot;\n&quot;);
 				op.append(&quot;  goto(&quot;+stageWpt+&quot;); STOP\n&quot;);
 				op.append(&quot;ENDIF\n&quot;);
-			}		
+			}
 			Global.mainTab.solverP.mText.appendText(op.toString(),true);
 			if (didCreateWp) {
-		    	Global.mainTab.updatePendingChanges();
-				Global.mainTab.tbP.refreshTable();
+				Global.getProfile().buildReferences();
+				Global.mainTab.updatePendingChanges();
+				Global.mainTab.tbP.updateRows();
 			}
     	} else {
 	    	int i=Global.getProfile().getCacheIndex(waypointName);
@@ -701,7 +714,7 @@
 			CacheHolder addiWpt;
 	   	    if (ch.hasAddiWpt()){
 	   	    	op.append(&quot;cls()\n&quot;);
-				for (int j=0; j&lt;ch.addiWpts.getCount();j++){
+				for (int j=0; j&lt;ch.addiWpts.size();j++){
 					addiWpt = (CacheHolder)ch.addiWpts.get(j);
 					op.append(&quot;IF $&quot;);
 					op.append(addiWpt.wayPoint);
@@ -712,15 +725,15 @@
 					op.append(&quot;\n   \&quot;Punkt &quot;);
 					op.append(addiWpt.wayPoint.substring(0,2));
 					op.append(&quot; [&quot;);
-					op.append(addiWpt.CacheName);
+					op.append(addiWpt.cacheName);
 					op.append(&quot;] = \&quot; $&quot;);
 					op.append(addiWpt.wayPoint);
 					CacheHolderDetail chD=new CacheHolderDetail(addiWpt);
 					try {
 						chD.readCache(Global.getProfile().dataDir);
 					} catch( Exception ex) {};
-					if (chD.LongDescription.trim().length()&gt;0)
-						op.append(&quot;\n   \&quot;&quot;+STRreplace.replace(chD.LongDescription,&quot;\&quot;&quot;,&quot;\&quot;\&quot;&quot;)+&quot;\&quot;&quot;);
+					if (chD.longDescription.trim().length()&gt;0)
+						op.append(&quot;\n   \&quot;&quot;+STRreplace.replace(chD.longDescription,&quot;\&quot;&quot;,&quot;\&quot;\&quot;&quot;)+&quot;\&quot;&quot;);
 					op.append(&quot;\n   goto($&quot;);
 					op.append(addiWpt.wayPoint);
 					op.append(&quot;); STOP\nENDIF\n\n&quot;);
@@ -729,25 +742,25 @@
 			}// if hasAddiWpt
     	}
     }
-    
+
     private double funcSqrt() throws Exception {
     	double a=popCalcStackAsNumber(0);
     	if (a&lt;0) err(MyLocale.getMsg(1720,&quot;Cannot calculate square root of a negative number&quot;));
     	return java.lang.Math.sqrt(a);
     }
-    
+
     /** Replace each character by its number A=1, B=2 etc. and put result into a string */
     private String funcSval(String s) {
        	s=s.toLowerCase();
     	String res=&quot;&quot;;
        	for (int i=0; i&lt;s.length(); i++) {
     		int pos=&quot;abcdefghijklmnopqrstuvwxyz&quot;.indexOf(s.charAt(i));
-    		if (pos&gt;=0) 
+    		if (pos&gt;=0)
     			res+=(res==&quot;&quot;?&quot;&quot;:&quot; &quot;)+MyLocale.formatLong(pos+1,&quot;00&quot;);
     	}
     	return res;
     }
-    
+
     /** Replace each character by its number A=1, B=2 etc. and sum them */
     private double funcVal(String s) {
     	s=s.toLowerCase();
@@ -757,24 +770,24 @@
     	}
     	return sum;
     }
-    
+
 ///////////////////////////////////////////
 //  PARSER
 ///////////////////////////////////////////
-   
-    
+
+
     /** The following methods implement a recursive descent parser.
      * Each method is called with 'thisToken' containing a valid token. It must return with 'thisToken' again containing
      * a valid token.
      */
- 
+
 	private void parseCommand()  throws Exception {
 		while(scanpos &lt; tokenStack.size()) {
 			getToken();
 			if (thisToken.token.equals(&quot;;&quot;)) continue;  // skip an empty command
-			if (thisToken.tt==TokenObj.TT_IF) 
+			if (thisToken.tt==TokenObj.TT_IF)
 				parseIf();
-			else 
+			else
 				parseSimpleCommand();
 			checkNextSymIs(&quot;;&quot;);
 		}
@@ -788,14 +801,14 @@
 		} else if (thisToken.token.equals(&quot;?&quot;)) { // Show all local variables
 			showVars(false);
 			getToken();
-		} else if (thisToken.tt==TokenObj.TT_VARIABLE &amp;&amp; lookAheadToken().tt==TokenObj.TT_EQ) 
+		} else if (thisToken.tt==TokenObj.TT_VARIABLE &amp;&amp; lookAheadToken().tt==TokenObj.TT_EQ)
 			parseAssign();
 		else {
 			parseStringExp();
 			while (calcStack.size()&gt;0) messageStack.add(popCalcStackAsString());
 		}
 	}
-	
+
 	private void parseIf() throws Exception{
 		int compOp;
 		boolean compRes=false;
@@ -810,7 +823,7 @@
 				if (varName.startsWith(&quot;$&quot;)) { // Could be a cachename
 					varName=varName.substring(1);
 					compRes=Global.getProfile().getCacheIndex(varName)!=-1;
-				} else 
+				} else
 					compRes=false;
 			} else // Found the variable, it must have a value
 				compRes=true;
@@ -869,12 +882,12 @@
 		} else // comparison failed
 			skipPastEndif(ifToken);
 	}
-	
+
 	private void parseAssign() throws Exception  {
 		String varName=new String(thisToken.token);
 		getToken(); //=
 		getToken();
-		// Assigns of the format A=; are ignored so that they can stay as placeholders and 
+		// Assigns of the format A=; are ignored so that they can stay as placeholders and
 		// we can fill the data progressively during a multicache
 		if (thisToken.tt==TokenObj.TT_ENDIF || thisToken.token.equals(&quot;;&quot;)) return;
 		parseStringExp();
@@ -886,19 +899,19 @@
 				String coord=popCalcStackAsString();
 				cwPt.set(coord);
 				if (cwPt.isValid() || coord.equals(&quot;&quot;)) { // Can clear coord with empty string
-					ch.LatLon=cwPt.toString(CWPoint.CW);
+					ch.latLon=cwPt.toString(CWPoint.CW);
 					ch.pos.set(cwPt);
 					ch.calcDistance(Global.getPref().curCentrePt); // Update distance and bearing
 		    	    Global.getProfile().selectionChanged=true; // Tell moving map to updated displayed waypoints
 				    return;
-				} else
-					err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coord);
+				}
+				err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coord);
 			}
 			// Name starts with $ but is not a waypoint, fall through and set it as global variable
 		}
 		symbolTable.put(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName, popCalcStackAsString());
 	}
-	
+
 	private void parseStringExp()throws Exception {
 		if (thisToken.tt==TokenObj.TT_STRING) {
 			calcStack.add(thisToken.token);
@@ -907,8 +920,8 @@
 			parseExp();
 		}
 		//calcStack.add(popCalcStackAsString());
-		while (thisToken.tt==TokenObj.TT_STRING || 
-			   thisToken.tt==TokenObj.TT_NUMBER || 
+		while (thisToken.tt==TokenObj.TT_STRING ||
+			   thisToken.tt==TokenObj.TT_NUMBER ||
 			   thisToken.tt==TokenObj.TT_VARIABLE ||
 			   thisToken.tt==TokenObj.TT_SYMBOL &amp;&amp; thisToken.token.equals(&quot;(&quot;)) {
 			if (thisToken.tt==TokenObj.TT_STRING) {
@@ -922,7 +935,7 @@
 			calcStack.add(a+b);
 		}
 	}
-	
+
 	private void parseExp()throws Exception {
 		char unaryOp='+';
 		if (thisToken.token.equals(&quot;+&quot;) || thisToken.token.equals(&quot;-&quot;) ) {
@@ -954,7 +967,7 @@
 			getToken();
 		}
 	}
-	
+
 	private void parseTerm() throws Exception{
 		parseFactor();
 		while (thisToken.token.equals(&quot;*&quot;) || thisToken.token.equals(&quot;/&quot;) ) {
@@ -966,13 +979,13 @@
 			if (op=='*')
 				calcStack.add(new java.lang.Double(a*b));
 			else
-				if (b==0.0) 
+				if (b==0.0)
 					err(MyLocale.getMsg(1729,&quot;Division by 0&quot;));
-				else 
+				else
 					calcStack.add(new java.lang.Double(a/b));
 		}
 	}
-	
+
 	private void parseFactor() throws Exception{
 		parseExpFactor();
 		while (thisToken.token.equals(&quot;^&quot;)) {
@@ -990,10 +1003,10 @@
 			if (isVariable(thisToken.token))
 				calcStack.add(getVariable(thisToken.token));
 			else if (!lookAheadToken().token.equals(&quot;(&quot;)) err(MyLocale.getMsg(1724,&quot;Variable not set: &quot;)+thisToken.token);
-			    else {// Must be a function definition
+			else {// Must be a function definition
 				funcDef=getFunctionDefinition(thisToken.token); // Does not return if function not defined or ambiguous
 				parseFunction(funcDef);
-			    } 
+			}
 		} else if (thisToken.tt==TokenObj.TT_NUMBER) {
 			calcStack.add(getNumber(thisToken.token));
 		} else if (thisToken.tt==TokenObj.TT_STRING) {
@@ -1006,7 +1019,7 @@
 		else err(MyLocale.getMsg(1725,&quot;Unexpected character(s): &quot;)+thisToken.token);
 		getToken();
 	}
-	
+
 	private void parseFunction(fnType funcDef) throws Exception {
 		String funcName=new String(thisToken.token);
         int nargs=0;
@@ -1019,7 +1032,7 @@
 			while (thisToken.token.equals(&quot;,&quot;)) {
 				if (nargs==4) err(MyLocale.getMsg(1726,&quot;Too many arguments for function &quot;)+funcName);
 				getToken();
-				parseStringExp(); 
+				parseStringExp();
 				nargs++;
 			}
 			checkNextSymIs(&quot;)&quot;);
@@ -1027,7 +1040,7 @@
 		//getToken(); done in parseFactor
 		executeFunction(funcName,nargs,funcDef);
 	}
-	
+
 	private void executeFunction(String funcName, int nargs, fnType funcDef) throws Exception {
 		if (!funcDef.nargsValid(nargs)) err(MyLocale.getMsg(1727,&quot;Invalid number of arguments&quot;));
 	         if (funcDef.alias.equals(&quot;asin&quot;)) calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.asin(popCalcStackAsNumber(0)))));
@@ -1039,10 +1052,10 @@
 	    else if (funcDef.alias.equals(&quot;cls&quot;)) funcCls();
 	    else if (funcDef.alias.equals(&quot;cos&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.cos(makeRadiant(popCalcStackAsNumber(0)))));
 	    else if (funcDef.alias.equals(&quot;count&quot;)) funcCount();
-	    else if (funcDef.alias.equals(&quot;cp&quot;)) calcStack.add(funcCp());     
+	    else if (funcDef.alias.equals(&quot;cp&quot;)) calcStack.add(funcCp());
 	    else if (funcDef.alias.equals(&quot;ct&quot;)) calcStack.add(new java.lang.Double(funcCrossTotal(nargs)));
-	    else if (funcDef.alias.equals(&quot;deg&quot;)) funcDeg(true);     
-	    else if (funcDef.alias.equals(&quot;deg2rad&quot;)) calcStack.add(new java.lang.Double(funcDeg2Rad())); 
+	    else if (funcDef.alias.equals(&quot;deg&quot;)) funcDeg(true);
+	    else if (funcDef.alias.equals(&quot;deg2rad&quot;)) calcStack.add(new java.lang.Double(funcDeg2Rad()));
 	    else if (funcDef.alias.equals(&quot;distance&quot;)) calcStack.add(new java.lang.Double(funcDistance()));
 	    else if (funcDef.alias.equals(&quot;encode&quot;)) calcStack.add(funcEncode());
 	    else if (funcDef.alias.equals(&quot;format&quot;)) calcStack.add(funcFormat(nargs));
@@ -1051,11 +1064,13 @@
 	    else if (funcDef.alias.equals(&quot;instr&quot;)) calcStack.add(new Double(funcInstr(nargs)));
 	    else if (funcDef.alias.equals(&quot;lc&quot;)) calcStack.add(popCalcStackAsString().toLowerCase());
 	    else if (funcDef.alias.equals(&quot;len&quot;)) calcStack.add(new Double(popCalcStackAsString().length()));
+	    else if (funcDef.alias.equals(&quot;ln&quot;)) calcStack.add(new java.lang.Double(funcLn()));
+	    else if (funcDef.alias.equals(&quot;log&quot;)) calcStack.add(new java.lang.Double(funcLog()));
 	    else if (funcDef.alias.equals(&quot;mid&quot;)) calcStack.add(funcMid(nargs));
-	    else if (funcDef.alias.equals(&quot;project&quot;)) calcStack.add(funcProject());     
-	    else if (funcDef.alias.equals(&quot;pz&quot;)) funcPz(nargs);     
-	    else if (funcDef.alias.equals(&quot;rad&quot;)) funcDeg(false);     
-	    else if (funcDef.alias.equals(&quot;rad2deg&quot;)) calcStack.add(new java.lang.Double(funcRad2Deg())); 
+	    else if (funcDef.alias.equals(&quot;project&quot;)) calcStack.add(funcProject());
+	    else if (funcDef.alias.equals(&quot;pz&quot;)) funcPz(nargs);
+	    else if (funcDef.alias.equals(&quot;rad&quot;)) funcDeg(false);
+	    else if (funcDef.alias.equals(&quot;rad2deg&quot;)) calcStack.add(new java.lang.Double(funcRad2Deg()));
 	    else if (funcDef.alias.equals(&quot;replace&quot;)) calcStack.add(funcReplace());
 	    else if (funcDef.alias.equals(&quot;reverse&quot;)) calcStack.add(funcReverse(popCalcStackAsString()));
 	    else if (funcDef.alias.equals(&quot;rot13&quot;)) calcStack.add(Common.rot13(popCalcStackAsString()));
@@ -1063,18 +1078,21 @@
 	    else if (funcDef.alias.equals(&quot;show&quot;));
 	    else if (funcDef.alias.equals(&quot;sin&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.sin(makeRadiant(popCalcStackAsNumber(0)))));
 	    else if (funcDef.alias.equals(&quot;skeleton&quot;)) funcSkeleton(nargs);
-	    else if (funcDef.alias.equals(&quot;sqrt&quot;)) calcStack.add(new java.lang.Double(funcSqrt())); 
+	    else if (funcDef.alias.equals(&quot;sqrt&quot;)) calcStack.add(new java.lang.Double(funcSqrt()));
 	    else if (funcDef.alias.equals(&quot;sval&quot;)) calcStack.add(funcSval(popCalcStackAsString()));
 	    else if (funcDef.alias.equals(&quot;tan&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.tan(makeRadiant(popCalcStackAsNumber(0)))));
 	    else if (funcDef.alias.equals(&quot;uc&quot;)) calcStack.add(popCalcStackAsString().toUpperCase());
 	    else if (funcDef.alias.equals(&quot;val&quot;)) calcStack.add(new java.lang.Double(funcVal(popCalcStackAsString())));
 	    else err(MyLocale.getMsg(1728,&quot;Function not yet implemented: &quot;)+funcName);
 	}
-	
-	public void parse(Vector tck, Vector msgStack){
+
+	public void parse(String s, Vector msgStack){
+		Tokenizer tokeniser=new Tokenizer();
+		tokeniser.tokenizeSource(s, msgStack); // Tokeniser sets message if an error occurred
+		if (msgStack.size()!=0) return;  // Error during tokenizing
 		calcStack.clear();
 		clearLocalSymbols();
-		tokenStack = tck;
+		tokenStack = tokeniser.TokenStack;
 		messageStack = msgStack;
 		scanpos = 0;
 		try{
@@ -1083,23 +1101,314 @@
 			//Vm.debug(ex.toString());
 		}
 	}
-	
-	private boolean createWptIfNeeded(String wayPoint, String name, String type){
+
+
+//#################################################################################
+//  TokenObj
+//#################################################################################
+
+	/**
+	*	Class to hold a token object.
+	*	@see Tokenizer
+	*	@see Parser
+	*/
+	public class TokenObj{
+		/** Token types */
+		public static final int TT_VARIABLE=0;
+		public static final int TT_STRING=1;
+		public static final int TT_NUMBER=2;
+		public static final int TT_SYMBOL=3;
+		public static final int TT_FORMATSTR=4;
+		public static final int TT_IF=5;
+		public static final int TT_THEN=6;
+		public static final int TT_ENDIF=7;
+		public static final int TT_STOP=8;
+		public static final int TT_OPENBRACKET=9;
+		public static final int TT_CLOSEBRACKET=10;
+		public static final int TT_LT=20;   // Don't change the sequence from LT to NT
+		public static final int TT_GT=21;
+		public static final int TT_LE=22;
+		public static final int TT_GE=23;
+		public static final int TT_EQ=24;
+		public static final int TT_NE=25;
+
+		int tt; // Tokentype
+		String token;
+		int line, position;
+	}
+
+//#################################################################################
+//  Tokenizer
+//#################################################################################
+
+
+	/**
+	*	Class to tokenise (break up) the code into single tokens, so the
+	*	parser my do its job.
+	*	@see Parser
+	*/
+	public class Tokenizer{
+
+		/** Normally only a semicolon (;) can be used to separate commands. If this variable is set to true,
+		 * newlines also terminate a command. If a newline is preceded with a backslash (=line continuation character),
+		 * the newline does not terminate the command even if this variable is true.
+		 */
+		public boolean newLineIsSeparator=true;
+		/** instructions to tokenise */
+		String mySource;
+		/** source character */
+		char look;
+		/** pointer to next character to read */
+		int sourcePointer = 0;
+		/** (partial) token */
+		String currentStream;
+		Vector TokenStack = new Vector();
+		/** position of token */
+		int currentLine, currentPos;
+		TokenObj thisToken;
+		Vector messageStack;
+
+		public Tokenizer(){
+		}
+
+	    private void err(String str) throws Exception {
+	    	messageStack.add(MyLocale.getMsg(1700,&quot;Error on line: &quot;) + currentLine + &quot;  &quot;+MyLocale.getMsg(1701,&quot; position: &quot;) + currentPos);
+	    	messageStack.add(str);
+	    	if (Global.mainTab.solverP.mText.setSelectionRange(0,currentLine-1,currentPos,currentLine-1))Global.mainTab.solverP.mText.repaintNow();
+	    	throw new Exception(&quot;Error &quot;+str);
+	    }
+
+		private boolean isAlpha(char c){
+			return  &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;.indexOf(c)!=-1;
+		}
+
+		private boolean isDigit(char c){
+			return &quot;0123456789&quot;.indexOf(c)!=-1;
+		}
+
+		private boolean isSymbol(char c){
+			return &quot;?!&lt;&gt;(){}*/,;^+-=&quot;.indexOf(c)!=-1;
+		}
+
+		/**
+		 * Convert Unicode version of special chars to normal
+		 * @param c Char to convert
+		 * @return Converted char
+		 */
+		private char standardiseSourceChar(char c) {
+			if (c=='\u00A0' || (c&gt;='\u2002' &amp;&amp; c&lt;='\u200b')) c=' ';
+			if (c&gt;='\u2010' &amp;&amp; c&lt;='\u2015') c='-';
+			if (c&gt;='\u201c' &amp;&amp; c&lt;='\u201f') c='&quot;';
+			if (c=='[') c='(';
+			if (c==']') c=')';
+			if (c=='\u00f7' || c=='\u2044') c='/';
+			if (c=='\u2024') c='.';
+			return c;
+		}
+
+		private boolean getChar(){
+			if(sourcePointer &gt;= mySource.length()) {
+				look='\n';
+				return false;
+			}
+			look = mySource.charAt(sourcePointer++);
+			currentPos++;
+			return true;
+		}
+
+		private char lookAhead() {
+			if(sourcePointer &gt;= mySource.length())
+				return '\n';
+			char c=standardiseSourceChar(mySource.charAt(sourcePointer));
+			return c;
+
+		}
+
+		private void backUp() {
+			sourcePointer--;
+			currentPos--;
+		}
+
+		/** Create a new token object and remember the place where it started.
+		 *  String tokens could span several lines, so we need to remember the starting line and position.
+		 */
+		private void startToken() {
+			thisToken = new TokenObj();
+			thisToken.line = currentLine;
+			thisToken.position = currentPos;
+		}
+
+		/** Add the previously started token to the token stack */
+		private void emitToken(int tt){
+//			eve.sys.Vm.debug(currentStream);
+			thisToken.token = currentStream;
+			thisToken.tt=tt;
+			TokenStack.add(thisToken);
+			currentStream = &quot;&quot;;
+		}
+
+		private void streamAlphas(){
+			startToken();
+			while(getChar()){
+				if(isAlpha(look) || isDigit(look))
+					currentStream += look;
+				else
+					break;
+			}
+			String s=currentStream.toUpperCase();
+			if (s.equals(&quot;STOP&quot;) || s.equals(&quot;ST&quot;))
+				emitToken(TokenObj.TT_STOP);
+			else if (s.equals(&quot;IF&quot;))
+				emitToken(TokenObj.TT_IF);
+			else if (s.equals(&quot;THEN&quot;))
+				emitToken(TokenObj.TT_THEN);
+			else if (s.equals(&quot;ENDIF&quot;) || s.equals(&quot;FI&quot;))
+				{ currentStream=&quot;ENDIF&quot;; emitToken(TokenObj.TT_ENDIF); }
+			else
+				emitToken(TokenObj.TT_VARIABLE);
+			// We have read one character too far, so back off
+			backUp();
+		}
+
+		private void streamDigits(){
+			boolean foundDecSep=false; // To check that only one decimal point is allowed in a number
+			startToken();
+			while(getChar()){
+				look=standardiseSourceChar(look);
+				if(isDigit(look) || (look=='.' &amp;&amp; !foundDecSep)) {
+					currentStream += look;
+					if (look=='.') foundDecSep=true;
+				} else
+					break;
+			}
+			emitToken(TokenObj.TT_NUMBER);
+			// We have read one character too far, so back off
+			backUp();
+		}
+
+		private void streamString() throws Exception {
+			startToken();
+			currentStream=&quot;&quot;;
+			while(getChar()){ // collect chars until next &quot;
+				if (look=='&quot;') {
+					if (lookAhead()!='&quot;') break;  // &quot; not followed by &quot; =&gt; End of string
+					// Two &quot; following each other are replaced by &quot;
+					currentStream+=&quot;\&quot;&quot;;
+					getChar();
+				} else if (look=='\\') {
+					if (!getChar()) break;
+					if (look=='n') currentStream += &quot;\n&quot;;
+					else currentStream += look;
+				} else currentStream += look;
+				// Need to count newlines inside a string spanning multiple lines so that we don't loose track
+				if (look=='\n') {
+					currentLine++;
+					currentPos=0;
+				}
+			} // EOT or look==&quot;
+			if (look!='&quot;') {
+				// Restore start position of string for correct indication of error
+				currentLine=thisToken.line;
+				currentPos=thisToken.position;
+				err(MyLocale.getMsg(1730,&quot;Unterminated string&quot;));
+			}
+			emitToken(TokenObj.TT_STRING);
+
+		}
+
+		private void streamSymbol() {
+			startToken();
+			// Check for == != &lt;= &gt;= &lt;&gt; &gt;&lt;
+			if (look=='=' || look=='!' || look=='&lt;' || look=='&gt;') {
+				getChar();
+				currentStream+=look;
+				if (currentStream.equals(&quot;==&quot;))  { emitToken(TokenObj.TT_EQ); return;}
+				if (currentStream.equals(&quot;!=&quot;) || currentStream.equals(&quot;&gt;&lt;&quot;) || currentStream.equals(&quot;&lt;&gt;&quot;))
+												{ emitToken(TokenObj.TT_NE); ; return;}
+				if (currentStream.equals(&quot;&lt;=&quot;)) { emitToken(TokenObj.TT_LE); return; }
+				if (currentStream.equals(&quot;&gt;=&quot;)) { emitToken(TokenObj.TT_GE); return; }
+				backUp(); // Not a valid comparison symbol, forget the last character
+				currentStream=currentStream.substring(0,1);
+				if (currentStream.equals(&quot;=&quot;)) emitToken(TokenObj.TT_EQ);
+				else if (currentStream.equals(&quot;&lt;&quot;)) emitToken(TokenObj.TT_LT);
+				else if (currentStream.equals(&quot;&gt;&quot;)) emitToken(TokenObj.TT_GT);
+				else emitToken(TokenObj.TT_SYMBOL);
+			} else
+				emitToken(TokenObj.TT_SYMBOL);
+		}
+
+		/** Eat up all characters until next newline as we are in a comment */
+		private void eatUpComment() {
+			while (getChar() &amp;&amp; look !='\n');
+			currentStream=&quot;;&quot;; // Insert a dummy ;
+			startToken();
+			emitToken(TokenObj.TT_SYMBOL);
+			currentStream=&quot;&quot;;
+			currentLine++;
+			currentPos=0;
+		}
+
+		private void formatString() throws Exception {
+			currentStream=&quot;&quot;;
+			startToken();
+			while (getChar() &amp;&amp; look!=':') {
+				look=standardiseSourceChar(look);
+				currentStream += look;
+				if (look!='.' &amp;&amp; look!='0' &amp;&amp; look!='#') err(MyLocale.getMsg(1731,&quot;Invalid format character&quot;));
+			}
+			emitToken(TokenObj.TT_FORMATSTR);
+		}
+
+		public void tokenizeSource(String src, Vector msg){
+			mySource = src+&quot;\n&quot;;
+			sourcePointer = 0;
+			TokenStack.clear();
+			messageStack=msg;
+			currentLine = 1;
+			currentPos = 0;
+			currentStream=&quot;&quot;;
+			try {
+				while(getChar()){
+					look=standardiseSourceChar(look);
+					if (look==' ') continue;
+					currentStream += look;
+					if(isAlpha(look) || look=='$') streamAlphas();
+					else if(isDigit(look)) streamDigits();
+					else if(isSymbol(look)) streamSymbol();
+					else if(look == '&quot;') streamString();
+					else if(look == '\n') {
+						if (newLineIsSeparator &amp;&amp; !currentStream.equals(&quot;\\\n&quot;) &amp;&amp; !currentStream.equals(&quot;_\n&quot;)) {
+							currentStream=&quot;;&quot;;
+							startToken();
+							emitToken(TokenObj.TT_SYMBOL);
+						}
+						currentStream = &quot;&quot;; currentLine++; currentPos=0;
+					}
+					else if(look == '#') eatUpComment();	// Ignore characters until EOL
+					else if(look == ':') formatString();
+					else if (newLineIsSeparator &amp;&amp; (look=='\\' || look=='_')) ;
+					else err(MyLocale.getMsg(1732,&quot;Invalid character&quot;));
+				}
+			} catch (Exception e) {}
+		}
+	}
+	private boolean createWptIfNeeded(String wayPoint, String name, int type){
 	   	int ci=Global.getProfile().getCacheIndex(wayPoint);
     	if (ci &gt;= 0) return false;
-    	
+
 		CacheHolder ch = new CacheHolder();
 		ch.wayPoint = wayPoint;
 		ch.type = type;
-		ch.CacheSize = &quot;None&quot;;
-		ch.CacheName= name;
-		
+		ch.setCacheSize(&quot;None&quot;);
+		ch.cacheName= name;
+
 		Global.getProfile().hasUnsavedChanges=true;
 		Global.getProfile().setAddiRef(ch);
 
-		Global.mainTab.cacheDB.add(ch);
-		Global.mainTab.tbP.myMod.numRows++;
+		Global.getProfile().cacheDB.add(ch);
+		Global.mainTab.tbP.tModel.numRows++;
 		return true;
 	}
-	
+
+
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/Preferences.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/Preferences.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/Preferences.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,14 +1,21 @@
-package CacheWolf;
-import utils.FileBugfix;
-import ewe.io.*;
-import ewe.sys.*;
-import ewe.ui.*;
+package cachewolf;
+import java.io.*;
+import eve.sys.*;
+import eve.ui.*;
 import ewesoft.xml.*;
 import ewesoft.xml.sax.*;
-import ewe.filechooser.*;
-import ewe.util.*;
-import ewe.util.Map.MapEntry;
+import eve.ui.filechooser.*;
+import java.util.*;
 
+import cachewolf.imp.SpiderGC;
+import cachewolf.utils.Common;
+import cachewolf.utils.SafeXML;
+import cachewolf.utils.STRreplace;
+
+
+import eve.ui.data.*;
+//import java.util.Map.MapEntry;
+
 /**
  *	A class to hold the preferences that were loaded upon start up of CacheWolf.
  *	This class is also capable of parsing the prefs.xml file as well as
@@ -36,86 +43,72 @@
 	}
 
 	private static Preferences _reference;
-	
+
 	private String pathToConfigFile;
-	
-	/**
-	 * Call this method to set the path of the config file &lt;br&gt;
-	 * If you call it with null it defaults to [program-dir]/pref.xml
-	 * if p is a directory &quot;pref.xml&quot; will automatically appended
-	 * @param p
-	 */
-	public void setPathToConfigFile(String p) {
-		String p_;
-		if (p == null) {
-			/*
-			String test;
-			test = Vm.getenv(&quot;APPDATA&quot;, &quot;/&quot;); // returns in java-vm on win xp: c:\&lt;dokumente und Einstellungen&gt;\&lt;username&gt;\&lt;application data&gt;
-			log(&quot;Vm.getenv(APPDATA: &quot; + test); // this works also in win32.exe (ewe-vm on win xp)
-			test = Vm.getenv(&quot;HOME&quot;, &quot;/&quot;); // This should return on *nix system the home dir
-			log(&quot;Vm.getenv(HOME: &quot; + test);
-			test = System.getProperty(&quot;user.dir&quot;); // return in java-vm on win xp: &lt;working dir&gt; or maybe &lt;program dir&gt; 
-			log(&quot;System.getProperty(user.dir: &quot; + test); // in win32.exe -&gt; null
-			test = System.getProperty(&quot;user.home&quot;); // in MS-java-VM env variable $HOME is ignored and always &lt;windir&gt;\java returned, see <A HREF="http://support.microsoft.com/kb/177181/en-us/">http://support.microsoft.com/kb/177181/en-us/</A>
-			log(&quot;System.getProperty(user.home: &quot; + test); // in win32.exe -&gt; null
-			// &quot;user.dir&quot;              User's current working directory
-			// &quot;user.home&quot;             User home directory (taken from <A HREF="http://scv.bu.edu/Doc/Java/tutorial/java/system/properties.html">http://scv.bu.edu/Doc/Java/tutorial/java/system/properties.html</A> )
-			 */
-			p_ = FileBase.makePath(FileBase.getProgramDirectory(), &quot;pref.xml&quot;);
-		}
-		else {
-			if (new FileBugfix(p).isDirectory()) p_ = FileBase.makePath(p, &quot;pref.xml&quot;);
-			else p_ = p; 
-		}
-		pathToConfigFile = STRreplace.replace(p_, &quot;//&quot;, &quot;/&quot;); // this is necessary in case that the root dir is the dir where the pref.xml is stored
-		pathToConfigFile = pathToConfigFile.replace('\\', '/');
-	}
 
+    /**
+     * Call this method to set the path of the config file &lt;br&gt;
+     * If you call it with null it defaults to [program-dir]/pref.xml
+     * if p is a directory &quot;pref.xml&quot; will automatically appended
+     * @param p
+     */
+    public void setPathToConfigFile(String p) {
+        String p_;
+        if (p == null) {
+        	p_ = eve.io.File.makePath(eve.io.File.getProgramDirectory(), &quot;pref.xml&quot;);
+        }
+        else {
+			if (new File(p).isDirectory()) p_ = eve.io.File.makePath(p, &quot;pref.xml&quot;);
+			else p_ = p;
+        }
+        pathToConfigFile = STRreplace.replace(p_, &quot;//&quot;, &quot;/&quot;); // this is necessary in case that the root dir is the dir where the pref.xml is stored
+        pathToConfigFile = pathToConfigFile.replace('\\', '/');
+    }
+
+
 	/**
 	 * Constructor is private for a singleton object
 	 */
 	private Preferences(){
 		mySPO.bits = 8;
-		mySPO.parity = SerialPort.NOPARITY;
+		mySPO.parity = eve.io.SerialPort.NOPARITY;
 		mySPO.stopBits = 1;
 		mySPO.baudRate = 4800;
-		if ( ((ewe.fx.Rect) (Window.getGuiInfo(WindowConstants.INFO_SCREEN_RECT,null,new ewe.fx.Rect(),0))).height &gt; 400) {
-			if (Vm.getPlatform().equals(&quot;Unix&quot;))
+		if (((new Window()).getWindowRect(null, false)).height &gt; 400) {
+			if (false) //TODO Find equivalent of ewe.Vm.getPlatForm:      Vm.getPlatform().equals(&quot;Unix&quot;))
 				fontSize = 12;
-			else{
-				// Default on VGA-PDAs: fontSize 21 + adjust ColWidth
-				if (Vm.isMobile()){
-					fontSize = 21;
-					listColWidth=&quot;20,20,30,30,92,177,144,83,60,105,50,104,22,30,30&quot;;
-				}
-				else
-					fontSize = 16;
+			else {
+                if (eve.sys.Device.isMobile()){
+                    fontSize = 21;
+                    listColWidth=&quot;20,20,30,30,92,177,144,83,60,105,50,104,22,30,30&quot;;
+                } else
+				 fontSize = 16;
 			}
-		} else 
-			fontSize = 11;
-	}
+		} else
+			 fontSize = 11;
+ 	}
 
     //////////////////////////////////////////////////////////////////////////////////////
     // Public fields stored in pref.xml
 	//////////////////////////////////////////////////////////////////////////////////////
-	
+
 	/** The base directory contains one subdirectory for each profile*/
-	public String baseDir = &quot;&quot;;  
+	public String baseDir = &quot;&quot;;
 	/** Name of last used profile */
-	public String lastProfile=&quot;&quot;; 
+	public String lastProfile=&quot;&quot;;
 	/** If true, the last profile is reloaded automatically without a dialogue */
-	public boolean autoReloadLastProfile=false; 
+	public boolean autoReloadLastProfile=false;
 	/** This is the login alias for geocaching.com and opencaching.de */
 	public String myAlias = &quot;&quot;;
 	/** Optional password */
 	public String password=&quot;&quot;;
-	/** This is an alternative alias used to identify found caches (i.e. if using multiple IDs) 
+	/** This is an alternative alias used to identify found caches (i.e. if using multiple IDs)
 	 *  It is currently not used yet */
 	public String myAlias2 = &quot;&quot;;
 	/** The path to the browser */
 	public String browser = &quot;&quot;;
 	/** Name of proxy for spidering */
-	public String myproxy = &quot;&quot;;    
+	public String myproxy = &quot;&quot;;
 	/** Proxyport when spidering */
 	public String myproxyport = &quot;&quot;;
 	/** Flag whether proxy is to be used */
@@ -156,12 +149,12 @@
 	/** If this flag is true, only non-logged travelbug journeys will be shown */
 	public boolean travelbugShowOnlyNonLogged=false;
 	/** If this is true, deleted images are shown with a ? in the imagepanel */
-	public boolean showDeletedImages=true; 
+	public boolean showDeletedImages=true;
 	/** This setting determines how many logs are shown per page of hintlogs (default 5) */
 	public int logsPerPage=DEFAULT_LOGS_PER_PAGE;
 	/** Initial height of hints field (set to 0 to hide them initially) */
-	public int initialHintHeight=DEFAULT_INITIAL_HINT_HEIGHT; 
-	/** Maximum logs to spider */ 
+	public int initialHintHeight=DEFAULT_INITIAL_HINT_HEIGHT;
+	/** Maximum logs to spider */
 	public int maxLogsToSpider = DEFAULT_MAX_LOGS_TO_SPIDER;
 	/** True if the Solver should ignore the case of variables */
 	public boolean solverIgnoreCase=true;
@@ -170,9 +163,9 @@
 	/** True if the description panel should show images */
 	public boolean descShowImg=true;
 	/** The type of connection which GPSBABEL uses: com1 OR usb. */
-	public String garminConn=&quot;com1&quot;;  
+	public String garminConn=&quot;com1&quot;;
 	/** Additional options for GPSBabel, i.e. -s to synthethise short names */
-	public String garminGPSBabelOptions=&quot;&quot;; 
+	public String garminGPSBabelOptions=&quot;&quot;;
 	/** Max. length for Garmin waypoint names (for etrex which can only accept 6 chars) */
 	public int garminMaxLen=0;
 	public boolean downloadPicsOC = true; //TODO Sollten die auch im Profil gespeichert werden mit Preferences als default Werte ?
@@ -186,14 +179,19 @@
 	/** True if the goto panel is North centered */
 	public boolean northCenteredGoto = true;
 	/** If not null, a customs map path has been specified by the user */
-	private String customMapsPath=null; 
+	private String customMapsPath=null;
 	/** Number of CacheHolder details that are kept in memory */
 	public int maxDetails=50;
 	/** Number of details to delete when maxDetails have been stored in cachesWithLoadedDetails */
 	public int deleteDetails=5;
-	/** The locale code (DE, EN, ...) */
-	public String language=&quot;&quot;; 
-	
+    /** The locale code (DE, EN, ...) */
+    public String language=&quot;&quot;;
+
+	/** The height of the application */
+	public int myAppHeight = 600;
+	/** The width of the application */
+	public int myAppWidth = 800;
+
 	//////////////////////////////////////////////
 	/** The debug switch (Can be used to activate dormant code) by adding
 	 * the line: &lt;pre&gt;&lt;debug value=&quot;true&quot;&gt;&lt;/pre&gt;
@@ -205,42 +203,40 @@
     //////////////////////////////////////////////////////////////////////////////////////
     // Public fields not stored in pref.xml
 	//////////////////////////////////////////////////////////////////////////////////////
-	
-	/** The height of the application */
-	public int myAppHeight = 0;
-	/** The width of the application */
-	public int myAppWidth = 0;
+
 	/** True if the preferences were changed and need to be saved */
 	public boolean dirty = false;
-	
+	/** The decimal separator (from MyLocale) */
+	//public String digSeparator = &quot;&quot;;
+
     //////////////////////////////////////////////////////////////////////////////////////
     // Read pref.xml file
 	//////////////////////////////////////////////////////////////////////////////////////
-	
+
 	/**
-	 * Method to open and parse the config file (pref.xml). Results are stored in the
+	 * Method to open and parse the config (pref.xml) file. Results are stored in the
 	 * public variables of this class.
 	 * If you want to specify a non default config file call setPathToConfigFile() first.
 	 */
 	public void readPrefFile(){
-		if (pathToConfigFile == null) setPathToConfigFile(null); // this sets the default value 
+        if (pathToConfigFile == null) setPathToConfigFile(null); // this sets the default value
 		try{
-			ewe.io.Reader r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(pathToConfigFile));
+			Reader r = new InputStreamReader(new FileInputStream(pathToConfigFile));
 			parse(r);
 			r.close();
-		}catch(IOException e){
-			log(&quot;IOException reading config file: &quot; + pathToConfigFile, e, true);
-			(new MessageBox(MyLocale.getMsg(327, &quot;Information&quot;), MyLocale.getMsg(176, &quot;First start - using default preferences \n For experts only: \n Could not read preferences file:\n&quot;) + pathToConfigFile, MessageBox.OKB)).execute();
+        }catch(IOException e){
+            log(&quot;IOException reading config file: &quot; + pathToConfigFile, e, true);
+            (new MessageBox(MyLocale.getMsg(327, &quot;Information&quot;), MyLocale.getMsg(176, &quot;First start - using default preferences \n For experts only: \n Could not read preferences file:\n&quot;) + pathToConfigFile, MessageBox.OKB)).execute();
 		}catch(Exception e){
 			if (e instanceof NullPointerException)
 				log(&quot;Error reading pref.xml: NullPointerException in Element &quot;+lastName +&quot;. Wrong attribute?&quot;,e,true);
-			else 
+			else
 				log(&quot;Error reading pref.xml: &quot;, e);
 		}
 	}
 
-	/** Helper variables for XML parser */ 
-	private StringBuffer collectElement=null; 
+	/** Helper variables for XML parser */
+	private StringBuffer collectElement=null;
 	private String lastName; // The string to the last XML that was processed
 
 	/**
@@ -295,7 +291,7 @@
 		}
 		else if (name.equals(&quot;listview&quot;)) {
 			listColMap=atts.getValue(&quot;colmap&quot;);
-			listColWidth=atts.getValue(&quot;colwidths&quot;)+&quot;,30,30&quot;; // append default values for older versions	
+			listColWidth=atts.getValue(&quot;colwidths&quot;)+&quot;,30,30&quot;; // append default values for older versions
 			if((new StringTokenizer(listColWidth,&quot;,&quot;)).countTokens()&lt;15) listColWidth+=&quot;,30,30&quot;; // for older versions
 		}
 		else if(name.equals(&quot;proxy&quot;)) {
@@ -316,13 +312,18 @@
 		}
 		else if (name.equals(&quot;descpanel&quot;)) {
 			descShowImg = Boolean.valueOf(atts.getValue(&quot;showimages&quot;)).booleanValue();
-		} 
+		}
 		else if (name.equals(&quot;screen&quot;)) {
 			menuAtTop=Boolean.valueOf(atts.getValue(&quot;menuattop&quot;)).booleanValue();
 			tabsAtTop=Boolean.valueOf(atts.getValue(&quot;tabsattop&quot;)).booleanValue();
 			showStatus=Boolean.valueOf(atts.getValue(&quot;showstatus&quot;)).booleanValue();
 			if (atts.getValue(&quot;hasclosebutton&quot;)!=null)
 				hasCloseButton=Boolean.valueOf(atts.getValue(&quot;hasclosebutton&quot;)).booleanValue();
+			if (atts.getValue(&quot;h&quot;)!=null) {
+				myAppHeight=Convert.toInt(atts.getValue(&quot;h&quot;));
+				myAppWidth=Convert.toInt(atts.getValue(&quot;w&quot;));
+			}
+
 		}
 		else if (name.equals(&quot;hintlogpanel&quot;)) {
 			logsPerPage = Convert.parseInt(atts.getValue(&quot;logsperpage&quot;));
@@ -340,13 +341,13 @@
 			customMapsPath=atts.getValue(&quot;dir&quot;).replace('\\', '/');
 		}
 		else if (name.equals(&quot;debug&quot;)) debug=Boolean.valueOf(atts.getValue(&quot;value&quot;)).booleanValue();
-		
+
 		else if (name.equals(&quot;expPath&quot;)){
 			exporterPaths.put(atts.getValue(&quot;key&quot;),atts.getValue(&quot;value&quot;));
 		}
 		else if (name.equals(&quot;travelbugs&quot;)) {
 			travelbugColMap=atts.getValue(&quot;colmap&quot;);
-			travelbugColWidth=atts.getValue(&quot;colwidths&quot;);	
+			travelbugColWidth=atts.getValue(&quot;colwidths&quot;);
 			travelbugShowOnlyNonLogged=Boolean.valueOf(atts.getValue(&quot;shownonlogged&quot;)).booleanValue();
 		}
 		else if (name.equals(&quot;gotopanel&quot;)) {
@@ -361,16 +362,17 @@
 			if (maxDetails&lt;2) maxDetails=2;
 			if (deleteDetails&lt;1) deleteDetails=1;
 		}
-		else if (name.equals(&quot;locale&quot;)) {
-			language = atts.getValue(&quot;language&quot;);
-		}
-	}
+        else if (name.equals(&quot;locale&quot;)) {
+            language = atts.getValue(&quot;language&quot;);
+        }
+    }
 
+
 	public void characters( char ch[], int start, int length ) {
 		if (collectElement!=null) {
 			collectElement.append(ch,start,length); // Collect the name of the last profile
 		}
-	}	
+	}
 
 	/**
 	 * Method that gets called when the end of an element has been identified in pref.xml
@@ -385,49 +387,50 @@
     //////////////////////////////////////////////////////////////////////////////////////
     // Write pref.xml file
 	//////////////////////////////////////////////////////////////////////////////////////
-	
+
 	/**
 	 * Method to save current preferences in the pref.xml file
 	 */
 	public void savePreferences(){
-		if (pathToConfigFile == null) setPathToConfigFile(null); // this sets the default value 
+		if (pathToConfigFile == null) setPathToConfigFile(null); // this sets the default value
 		try{
 			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(pathToConfigFile)));
 			outp.print(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;ISO-8859-1\&quot;?&gt;\n&quot;);
 			outp.print(&quot;&lt;preferences&gt;\n&quot;);
 			outp.print(&quot;    &lt;locale language=\&quot;&quot; + SafeXML.strxmlencode(language) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;	&lt;basedir dir = \&quot;&quot; + SafeXML.strxmlencode(baseDir) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;lastprofile autoreload=\&quot;&quot; + SafeXML.strxmlencode(autoReloadLastProfile) + &quot;\&quot;&gt;&quot; + SafeXML.strxmlencode(lastProfile) + &quot;&lt;/lastprofile&gt;\n&quot;); //RB
+			outp.print(&quot;	&lt;basedir dir = \&quot;&quot;+ SafeXML.strxmlencode(baseDir) +&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;lastprofile autoreload=\&quot;&quot;+autoReloadLastProfile+&quot;\&quot;&gt;&quot;+SafeXML.strxmlencode(lastProfile)+&quot;&lt;/lastprofile&gt;\n&quot;); //RB
 			outp.print(&quot;	&lt;alias name =\&quot;&quot;+ SafeXML.clean(myAlias) +&quot;\&quot; password=\&quot;&quot;+SafeXML.clean(password)+&quot;\&quot; /&gt;\n&quot;);
 			outp.print(&quot;	&lt;alias2 name =\&quot;&quot;+ SafeXML.clean(myAlias2) +&quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;	&lt;browser name = \&quot;&quot; + SafeXML.strxmlencode(browser) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;	&lt;proxy prx = \&quot;&quot; + SafeXML.strxmlencode(myproxy) + &quot;\&quot; prt = \&quot;&quot; + SafeXML.strxmlencode(myproxyport) + &quot;\&quot; active = \&quot;&quot; + SafeXML.strxmlencode(proxyActive) + &quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;	&lt;port portname = \&quot;&quot; + SafeXML.strxmlencode(mySPO.portName) + &quot;\&quot; baud = \&quot;&quot; + SafeXML.strxmlencode(mySPO.baudRate) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;	&lt;portforward active= \&quot;&quot; + SafeXML.strxmlencode(Convert.toString(forwardGPS)) + &quot;\&quot; destinationHost = \&quot;&quot; + SafeXML.strxmlencode(forwardGpsHost) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;	&lt;portlog active= \&quot;&quot; + SafeXML.strxmlencode(Convert.toString(logGPS)) + &quot;\&quot; logTimer = \&quot;&quot; + SafeXML.strxmlencode(logGPSTimer) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;font size =\&quot;&quot; + SafeXML.strxmlencode(fontSize) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;screen menuattop=\&quot;&quot; + SafeXML.strxmlencode(menuAtTop) + &quot;\&quot; tabsattop=\&quot;&quot; + SafeXML.strxmlencode(tabsAtTop) + &quot;\&quot; showstatus=\&quot;&quot; + SafeXML.strxmlencode(showStatus) + &quot;\&quot; hasclosebutton=\&quot;&quot; + SafeXML.strxmlencode(hasCloseButton) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;fixedsip state = \&quot;&quot; + SafeXML.strxmlencode(fixSIP) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;listview colmap=\&quot;&quot; + SafeXML.strxmlencode(listColMap) + &quot;\&quot; colwidths=\&quot;&quot; + SafeXML.strxmlencode(listColWidth) + &quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;    &lt;travelbugs colmap=\&quot;&quot; + SafeXML.strxmlencode(travelbugColMap) + &quot;\&quot; colwidths=\&quot;&quot; + SafeXML.strxmlencode(travelbugColWidth) + &quot;\&quot; shownonlogged=\&quot;&quot; + SafeXML.strxmlencode(travelbugShowOnlyNonLogged) + &quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;    &lt;descpanel showimages=\&quot;&quot; + SafeXML.strxmlencode(descShowImg) + &quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;    &lt;imagepanel showdeletedimages=\&quot;&quot; + SafeXML.strxmlencode(showDeletedImages) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;hintlogpanel logsperpage=\&quot;&quot; + SafeXML.strxmlencode(logsPerPage) + &quot;\&quot; initialhintheight=\&quot;&quot; + SafeXML.strxmlencode(initialHintHeight) + &quot;\&quot;  maxspiderlogs=\&quot;&quot; + SafeXML.strxmlencode(maxLogsToSpider) + &quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;    &lt;solver ignorevariablecase=\&quot;&quot; + SafeXML.strxmlencode(solverIgnoreCase) + &quot;\&quot; degMode=\&quot;&quot; + SafeXML.strxmlencode(solverDegMode) + &quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;    &lt;garmin connection = \&quot;&quot; + SafeXML.strxmlencode(garminConn) + &quot;\&quot; GPSBabelOptions = \&quot;&quot; + SafeXML.strxmlencode(garminGPSBabelOptions) + &quot;\&quot; MaxWaypointLength = \&quot;&quot; + SafeXML.strxmlencode(garminMaxLen) + &quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;    &lt;opencaching downloadPicsOC=\&quot;&quot; + SafeXML.strxmlencode(downloadPicsOC) + &quot;\&quot; downloadMaps=\&quot;&quot; + SafeXML.strxmlencode(downloadMapsOC) + &quot;\&quot; downloadMissing=\&quot;&quot; + SafeXML.strxmlencode(downloadmissingOC) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;	&lt;location lat = \&quot;&quot; + SafeXML.strxmlencode(curCentrePt.getLatDeg(CWPoint.DD)) + &quot;\&quot; long = \&quot;&quot; + SafeXML.strxmlencode(curCentrePt.getLonDeg(CWPoint.DD)) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;spider forcelogin=\&quot;&quot; + SafeXML.strxmlencode(forceLogin) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;gotopanel northcentered=\&quot;&quot; + SafeXML.strxmlencode(northCenteredGoto) + &quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;    &lt;details cacheSize=\&quot;&quot; + SafeXML.strxmlencode(maxDetails) + &quot;\&quot; delete=\&quot;&quot; + SafeXML.strxmlencode(deleteDetails) + &quot;\&quot;/&gt;\n&quot;);
-			if (customMapsPath!=null) outp.print(&quot;	&lt;mapspath dir = \&quot;&quot; + SafeXML.strxmlencode(customMapsPath.replace('\\','/')) + &quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;	&lt;browser name = \&quot;&quot;+SafeXML.strxmlencode(browser)+&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;	&lt;proxy prx = \&quot;&quot;+ SafeXML.strxmlencode(myproxy)+&quot;\&quot; prt = \&quot;&quot;+ myproxyport + &quot;\&quot; active = \&quot;&quot;+ proxyActive +&quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;	&lt;port portname = \&quot;&quot;+ SafeXML.strxmlencode(mySPO.portName) +&quot;\&quot; baud = \&quot;&quot;+ mySPO.baudRate+&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;	&lt;portforward active= \&quot;&quot;+ Convert.toString(forwardGPS)+&quot;\&quot; destinationHost = \&quot;&quot;+ SafeXML.strxmlencode(forwardGpsHost)+&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;	&lt;portlog active= \&quot;&quot;+ Convert.toString(logGPS)+&quot;\&quot; logTimer = \&quot;&quot;+ logGPSTimer +&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;font size =\&quot;&quot;+fontSize+&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;screen menuattop=\&quot;&quot;+menuAtTop+&quot;\&quot; tabsattop=\&quot;&quot;+tabsAtTop+&quot;\&quot; showstatus=\&quot;&quot;+showStatus+&quot;\&quot; hasclosebutton=\&quot;&quot;+hasCloseButton+
+					                &quot;\&quot; h=\&quot;&quot;+myAppHeight+&quot;\&quot; w=\&quot;&quot;+myAppWidth+&quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;fixedsip state = \&quot;&quot;+fixSIP+&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;listview colmap=\&quot;&quot;+listColMap+&quot;\&quot; colwidths=\&quot;&quot;+listColWidth+&quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;travelbugs colmap=\&quot;&quot;+travelbugColMap+&quot;\&quot; colwidths=\&quot;&quot;+travelbugColWidth+&quot;\&quot; shownonlogged=\&quot;&quot;+travelbugShowOnlyNonLogged+&quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;descpanel showimages=\&quot;&quot;+descShowImg+&quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;imagepanel showdeletedimages=\&quot;&quot;+showDeletedImages+&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;hintlogpanel logsperpage=\&quot;&quot;+logsPerPage+&quot;\&quot; initialhintheight=\&quot;&quot;+initialHintHeight+&quot;\&quot;  maxspiderlogs=\&quot;&quot;+maxLogsToSpider+&quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;solver ignorevariablecase=\&quot;&quot;+solverIgnoreCase+&quot;\&quot; degMode=\&quot;&quot;+solverDegMode+&quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;garmin connection = \&quot;&quot;+SafeXML.strxmlencode(garminConn)+&quot;\&quot; GPSBabelOptions = \&quot;&quot;+garminGPSBabelOptions+&quot;\&quot; MaxWaypointLength = \&quot;&quot;+garminMaxLen+&quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;opencaching downloadPicsOC=\&quot;&quot;+downloadPicsOC+&quot;\&quot; downloadMaps=\&quot;&quot;+downloadMapsOC+&quot;\&quot; downloadMissing=\&quot;&quot;+downloadmissingOC+&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;	&lt;location lat = \&quot;&quot;+curCentrePt.getLatDeg(CWPoint.DD)+&quot;\&quot; long = \&quot;&quot;+curCentrePt.getLonDeg(CWPoint.DD)+&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;spider forcelogin=\&quot;&quot;+forceLogin+&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;gotopanel northcentered=\&quot;&quot;+northCenteredGoto+&quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;details cacheSize=\&quot;&quot;+maxDetails+&quot;\&quot; delete=\&quot;&quot;+deleteDetails+&quot;\&quot;/&gt;\n&quot;);
+			if (customMapsPath!=null) outp.print(&quot;	&lt;mapspath dir = \&quot;&quot;+ SafeXML.strxmlencode(customMapsPath.replace('\\','/')) +&quot;\&quot;/&gt;\n&quot;);
 			if (debug) outp.print(&quot;    &lt;debug value=\&quot;true\&quot; /&gt;\n&quot;); // Keep the debug switch if it is set
 			// save last path of different exporters
-			Iterator itPath = exporterPaths.entries();
-			MapEntry entry;
-			while(itPath.hasNext()){
-				entry = (MapEntry) itPath.next();
-				outp.print(&quot;    &lt;expPath key = \&quot;&quot; + SafeXML.strxmlencode(entry.getKey().toString()) + &quot;\&quot; value = \&quot;&quot; + SafeXML.strxmlencode(entry.getValue().toString().replace('\\', '/')) + &quot;\&quot;/&gt;\n&quot;);
+			Enumeration ePath = exporterPaths.keys();
+			String entry;
+			while(ePath.hasMoreElements()){
+				entry = (String) ePath.nextElement();
+				outp.print(&quot;    &lt;expPath key = \&quot;&quot; + SafeXML.strxmlencode(entry) + &quot;\&quot; value = \&quot;&quot; + SafeXML.strxmlencode(((String)exporterPaths.get(entry)).replace('\\', '/')) + &quot;\&quot;/&gt;\n&quot;);
 			}
 			outp.print(&quot;&lt;/preferences&gt;&quot;);
 			outp.close();
@@ -441,32 +444,32 @@
 	//////////////////////////////////////////////////////////////////////////////////////
 
 	private static final String mapsPath = &quot;maps/standard&quot;;
-	
+
 	/**
 	 * custom = set by the user
 	 * @return custom Maps Path, null if not set
 	 */
 	public String getCustomMapsPath() {
-	   return customMapsPath;	
+	   return customMapsPath;
 	}
-	
+
 	public void saveCustomMapsPath(String mapspath_) {
 		if (customMapsPath == null || !customMapsPath.equals(mapspath_)) {
 			customMapsPath=new String(mapspath_).replace('\\', '/');
 			savePreferences();
 		}
 	}
-	
+
 	/**
 	 * gets the path to the calibrated maps
 	 * it first tries if there are manually imported maps
-	 * in &lt;baseDir&gt;/maps/standard then it tries 
+	 * in &lt;baseDir&gt;/maps/standard then it tries
 	 * the legacy dir: &lt;program-dir&gt;/maps
 	 * In case in both locations are no .wfl-files
 	 * it returns  &lt;baseDir&gt;/maps/expedia - the place where
 	 * the automatically downloaded maps are placed.
-	 * 
-	 * 
+	 *
+	 *
 	 */
 	public String getMapLoadPath() {
 		saveCustomMapsPath(getMapLoadPathInternal());
@@ -475,30 +478,30 @@
 	private String getMapLoadPathInternal() {
 		// here could also a list of map-types displayed...
 		// standard dir
-		String ret = getCustomMapsPath(); 
-		if (ret != null) return ret; 
+		String ret = getCustomMapsPath();
+		if (ret != null) return ret;
 		ret = getMapManuallySavePath(false);
-		File t = new FileBugfix(ret);
-		String[] f = t.list(&quot;*.wfl&quot;, FileBase.LIST_FILES_ONLY);
+		eve.io.File t = new eve.io.File(ret);
+		String[] f = t.list(&quot;*.wfl&quot;, eve.io.File.LIST_FILES_ONLY);
 		if (f != null &amp;&amp; f.length &gt; 0) return  baseDir + mapsPath;
-		f = t.list(&quot;*.wfl&quot;, FileBase.LIST_DIRECTORIES_ONLY | FileBase.LIST_ALWAYS_INCLUDE_DIRECTORIES);
+		f = t.list(&quot;*.wfl&quot;, eve.io.File.LIST_DIRECTORIES_ONLY | eve.io.File.LIST_ALWAYS_INCLUDE_DIRECTORIES);
 		if (f != null &amp;&amp; f.length &gt; 0) { // see if in a subdir of &lt;baseDir&gt;/maps/standard are .wfl files
 			String[] f2;
 			for (int i = 0; i&lt; f.length; i++) {
 				t.set(null, ret+&quot;/&quot;+f[i]);
-				f2 = t.list(&quot;*.wfl&quot;, FileBase.LIST_FILES_ONLY);
+				f2 = t.list(&quot;*.wfl&quot;, eve.io.File.LIST_FILES_ONLY);
 				if (f2 != null &amp;&amp; f2.length &gt; 0) return  ret;
 			}
 		}
-		// lagacy dir 
-		ret = FileBase.getProgramDirectory() + &quot;/maps&quot;;
+		// lagacy dir
+		ret = eve.io.File.getProgramDirectory() + &quot;/maps&quot;;
 		t.set(null, ret);
-		f = t.list(&quot;*.wfl&quot;, FileBase.LIST_FILES_ONLY);
+		f = t.list(&quot;*.wfl&quot;, eve.io.File.LIST_FILES_ONLY);
 		if (f != null &amp;&amp; f.length &gt; 0) {
-			MessageBox inf = new MessageBox(&quot;Information&quot;, &quot;The directory for calibrated maps \nhas moved in this program version\n to '&lt;profiles directory&gt;/maps/standard'\n Do you want to move your calibrated maps there now?&quot;, FormBase.YESB | FormBase.NOB);
-			if (inf.execute() == FormBase.IDYES) {
+			MessageBox inf = new MessageBox(&quot;Information&quot;, &quot;The directory for calibrated maps \nhas moved in this program version\n to '&lt;profiles directory&gt;/maps/standard'\n Do you want to move your calibrated maps there now?&quot;, MessageBox.YESB | MessageBox.NOB);
+			if (inf.execute() == MessageBox.IDYES) {
 				String sp = getMapManuallySavePath(false);
-				FileBugfix spF = new FileBugfix(sp);
+				eve.io.File spF = new eve.io.File(sp);
 				if (!spF.exists()) spF.mkdirs();
 				String image;
 				String lagacypath = ret;
@@ -515,13 +518,13 @@
 				t.delete();
 				return sp;
 			}
-			else return  ret;
+			return  ret;
 		}
-		// expedia dir
-		// return getMapExpediaLoadPath();
-		
-		//whole maps directory
-		return Global.getPref().baseDir.replace('\\', '/') + &quot;maps&quot;;
+        // expedia dir
+        // return getMapExpediaLoadPath();
+
+        //whole maps directory
+        return Global.getPref().baseDir.replace('\\', '/') + &quot;maps&quot;;
 	}
 
 	/**
@@ -531,9 +534,9 @@
 	 */
 	public String getMapManuallySavePath(boolean create) {
 		String mapsDir = baseDir + mapsPath;
-		if (create &amp;&amp; !(new FileBugfix(mapsDir).isDirectory())) { // dir exists? 
-			if (new FileBugfix(mapsDir).mkdirs() == false) {// dir creation failed?
-				(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(172,&quot;Error: cannot create maps directory: \n&quot;)+mapsDir, FormBase.OKB)).exec();
+		if (create &amp;&amp; !(new File(mapsDir).isDirectory())) { // dir exists?
+			if (new File(mapsDir).mkdirs() == false) {// dir creation failed?
+				(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(172,&quot;Error: cannot create maps directory: \n&quot;)+mapsDir, MessageBox.OKB)).exec();
 				return null;
 			}
 		}
@@ -545,10 +548,10 @@
 	 */
 	public String getMapDownloadSavePath(String mapkind) {
 		String subdir = Global.getProfile().dataDir.substring(Global.getPref().baseDir.length()).replace('\\', '/');
-		String mapsDir = Global.getPref().baseDir + &quot;maps/&quot; + Common.ClearForFileName(mapkind)+ &quot;/&quot; + subdir;
-		if (!(new FileBugfix(mapsDir).isDirectory())) { // dir exists? 
-			if (new FileBugfix(mapsDir).mkdirs() == false) // dir creation failed?
-			{(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(172,&quot;Error: cannot create maps directory: \n&quot;)+new FileBugfix(mapsDir).getParentFile(), FormBase.OKB)).exec();
+		String mapsDir = Global.getPref().baseDir + &quot;maps/&quot; + Common.clearForFileName(mapkind)+ &quot;/&quot; + subdir;
+		if (!(new File(mapsDir).isDirectory())) { // dir exists?
+			if (new File(mapsDir).mkdirs() == false) // dir creation failed?
+			{(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(172,&quot;Error: cannot create maps directory: \n&quot;)+new File(mapsDir).getParentFile(), MessageBox.OKB)).exec();
 			return null;
 			}
 		}
@@ -558,52 +561,51 @@
 	public String getMapExpediaLoadPath() {
 		return Global.getPref().baseDir.replace('\\', '/') + &quot;maps/expedia&quot;; // baseDir has trailing /
 	}
-	
+
     //////////////////////////////////////////////////////////////////////////////////////
     // Profile Selector
 	//////////////////////////////////////////////////////////////////////////////////////
-	
+
 	static protected final int PROFILE_SELECTOR_FORCED_ON=0;
 	static protected final int PROFILE_SELECTOR_FORCED_OFF=1;
 	static protected final int PROFILE_SELECTOR_ONOROFF=2;
 
 	/**
-	 * Open Profile selector screen 
+	 * Open Profile selector screen
 	 * @param prof
 	 * @param showProfileSelector
 	 * @return True if a profile was selected
 	 */
 	public boolean selectProfile(Profile prof, int showProfileSelector, boolean hasNewButton) {
 		// If datadir is empty, ask for one
-		if (baseDir.length()==0 || !(new FileBugfix(baseDir)).exists()) {
+		if (baseDir.length()==0 || !(new File(baseDir)).exists()) {
 			do {
-				FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT,&quot;/&quot;);
+				FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT,&quot;/&quot;);
 				fc.title = MyLocale.getMsg(170,&quot;Select base directory for cache data&quot;);
 				// If no base directory given, terminate
-				if (fc.execute() == FormBase.IDCANCEL) ewe.sys.Vm.exit(0);
+				if (fc.execute() == FileChooser.IDCANCEL) eve.sys.Vm.exit(0);
 				baseDir = fc.getChosenFile().toString();
-			}while (!(new FileBugfix(baseDir)).exists());
+			}while (!(new File(baseDir)).exists());
 		}
 		baseDir=baseDir.replace('\\','/');
 		if (!baseDir.endsWith(&quot;/&quot;)) baseDir+=&quot;/&quot;;
 		boolean profileExists=true;  // Assume that the profile exists
-		do {	
-			if(!profileExists || (showProfileSelector==PROFILE_SELECTOR_FORCED_ON) || 
+		do {
+			if(!profileExists || (showProfileSelector==PROFILE_SELECTOR_FORCED_ON) ||
 					(showProfileSelector==PROFILE_SELECTOR_ONOROFF &amp;&amp; !autoReloadLastProfile)){ // Ask for the profile
 				ProfilesForm f = new ProfilesForm(baseDir,lastProfile,!profileExists || hasNewButton);
 				int code = f.execute();
 				// If no profile chosen (includes a new one), terminate
 				if (code==-1) return false; // Cancel pressed
 				CWPoint savecenter = new CWPoint(prof.centre);
-				prof.clearProfile();
-				prof.centre = savecenter;
-				prof.hasUnsavedChanges = true;
-				//curCentrePt.set(0,0); // No centre yet
+ 				prof.clearProfile();
+ 				prof.centre = savecenter;
+ 				prof.hasUnsavedChanges = true;
 				lastProfile=f.newSelectedProfile;
 			}
-			profileExists=(new FileBugfix(baseDir+lastProfile)).exists();
+			profileExists=(new File(baseDir+lastProfile)).exists();
 			if (!profileExists) (new MessageBox(MyLocale.getMsg(144,&quot;Warning&quot;),
-					           MyLocale.getMsg(171,&quot;Profile does not exist: &quot;)+lastProfile,FormBase.MBOK)).execute();
+					           MyLocale.getMsg(171,&quot;Profile does not exist: &quot;)+lastProfile,MessageBox.MBOK)).execute();
 		} while (profileExists==false);
 		// Now we are sure that baseDir exists and basDir+profile exists
 		prof.name=lastProfile;
@@ -619,18 +621,18 @@
 	//////////////////////////////////////////////////////////////////////////////////////
 
 	/** Log file is in program directory and called log.txt */
-	private final String LOGFILENAME=FileBase.getProgramDirectory()+&quot;/log.txt&quot;;
-	
+	private final String LOGFILENAME=eve.io.File.getProgramDirectory()+&quot;/log.txt&quot;;
+
 	/**
 	 * Method to delete an existing log file. Called on every SpiderGC.
 	 * The log file is also cleared when Preferences is created and the filesize &gt; 60KB
 	 */
 	public void logInit(){
-		File logFile = new FileBugfix(LOGFILENAME);
+		File logFile = new File(LOGFILENAME);
 		logFile.delete();
 		log(&quot;CW Version &quot;+Version.getReleaseDetailed());
 	}
-	
+
 	/**
 	 * Method to log messages to a file called log.txt
 	 * It will always append to an existing file.
@@ -650,9 +652,7 @@
 		FileWriter logFile = null;
 		try{
 			logFile = new FileWriter(LOGFILENAME, true);
-			//Stream strout = null;
-			//strout = logFile.toWritableStream(true);
-			logFile.println(text);
+			logFile.write(text);
 			//Vm.debug(text); Not needed - put &lt;debug value=&quot;true&quot;&gt; into pref.xml
 		}catch(Exception ex){
 			Vm.debug(&quot;Error writing to log file!&quot;);
@@ -662,7 +662,7 @@
 	}
 
 	/** Log an exception to the log file with or without a stack trace
-	 * 
+	 *
 	 * @param text Optional message (Can be empty string)
 	 * @param e The exception
 	 * @param withStackTrace If true and the debug switch is true, the stack trace is appended to the log
@@ -675,24 +675,24 @@
 		String msg;
 		if (text.equals(&quot;&quot;)) msg=text; else msg=text+&quot;\n&quot;;
 		if (e!=null) {
-			if (withStackTrace &amp;&amp; debug) 
-				msg+=ewe.sys.Vm.getAStackTrace(e);
+			if (withStackTrace &amp;&amp; debug)
+				msg+=eve.sys.Vm.getAStackTrace(e);
 			else
 				msg+=e.toString();
 		}
 		log(msg);
 	}
-	
+
 	/** Log an exception to the log file without a stack trace, i.e.
-	 * where a stack trace is not needed because the location/cause of the error is clear 
-	 * 
+	 * where a stack trace is not needed because the location/cause of the error is clear
+	 *
 	 * @param message Optional message (Can be empty string)
 	 * @param e The exception
 	 */
 	public void log(String message,Exception e) {
 		log (message,e,false);
 	}
-		
+
     //////////////////////////////////////////////////////////////////////////////////////
     // Exporter path functions
 	//////////////////////////////////////////////////////////////////////////////////////
@@ -706,7 +706,7 @@
 	}
 
 	public void setExportPathFromFileName(String exporter,String filename){
-		File tmpfile = new FileBugfix (filename);
+		File tmpfile = new File (filename);
 		exporterPaths.put(exporter, tmpfile.getPath());
 		savePreferences();
 	}

Modified: experiments/engywuck/hist-test/src/cachewolf/PreferencesScreen.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/PreferencesScreen.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/PreferencesScreen.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,12 +1,16 @@
-package CacheWolf;
+package cachewolf;
 
-import utils.FileBugfix;
-import ewe.ui.*;
-import ewe.io.*;
-import ewe.fx.*;
-import ewe.filechooser.*;
-import ewe.sys.*;
-
+import cachewolf.imp.SpiderGC;
+import cachewolf.utils.Common;
+import eve.ui.*;
+import eve.fx.*;
+import eve.ui.filechooser.*;
+import eve.sys.*;
+import eve.ui.event.ControlEvent;
+import eve.ui.data.Editor;
+import eve.ui.data.SerialPortOptions;
+import eve.io.File;
+import eve.fx.gui.IKeys;
 /**
 *	This class displays a user interface allowing the user to change and set
 *	preferences. It also provides a method to save the changed preferences that
@@ -14,325 +18,327 @@
 *	Class ID=600
 */
 public class PreferencesScreen extends Form {
-	mButton cancelB, applyB, brwBt, gpsB,btnCentre;
-	mChoice NS, EW, inpLanguage;
-	mInput NSDeg, NSm, EWDeg, EWm, DataDir, Proxy, ProxyPort, Alias, nLogs, Browser, fontSize, inpGPS, 
-	       inpLogsPerPage,inpMaxLogsToSpider,inpPassword;
-	mCheckBox dif, ter, loc, own, hid, stat, dist, bear, chkAutoLoad, chkShowDeletedImg, chkMenuAtTop, 
-	          chkTabsAtTop, chkShowStatus,chkHasCloseButton,chkSynthShort,chkProxyActive, chkDescShowImg;
-	mTabbedPanel mTab;
-	mChoice chcGarminPort;
-	mLabel lblGarmin;
-	TableColumnChooser tccBugs,tccList;
-	
-	Preferences pref;
-	
-	CellPanel pnlGeneral = new CellPanel();
-	CellPanel pnlDisplay = new CellPanel();
-	CellPanel pnlMore = new CellPanel();
-	CellPanel pnlTB = new CellPanel();
-	//Frame frmGarmin = new Frame();
-	ScrollBarPanel scp; // TODO not neede any more?
-	String [] garminPorts= new String[]{&quot;com1&quot;,&quot;com2&quot;,&quot;com3&quot;,&quot;com4&quot;,&quot;com5&quot;,&quot;com6&quot;,&quot;com7&quot;,&quot;usb&quot;};
-	
-	public PreferencesScreen (Preferences p){
-		int sw = MyLocale.getScreenWidth();
-		int sh = MyLocale.getScreenHeight();
+    Button cancelB, applyB, brwBt, gpsB,btnCentre;
+    Choice NS, EW, inpLanguage;
+    Input NSDeg, NSm, EWDeg, EWm, DataDir, Proxy, ProxyPort, Alias, nLogs, Browser, fontSize, inpGPS,
+           inpLogsPerPage,inpMaxLogsToSpider,inpPassword;
+    CheckBox dif, ter, loc, own, hid, stat, dist, bear, chkAutoLoad, chkShowDeletedImg, chkMenuAtTop,
+              chkTabsAtTop, chkShowStatus,chkHasCloseButton,chkSynthShort,chkProxyActive, chkDescShowImg;
+    TabbedPanel mTab;
+    Choice chcGarminPort;
+    Label lblGarmin;
+    TableColumnChooser tccBugs,tccList;
 
-		mTab=new mTabbedPanel();
-		
-		pref = p;
-		this.title = MyLocale.getMsg(600,&quot;Preferences&quot;);
-		if ((sw &gt; 240) &amp;&amp; (sh &gt; 240))
-			this.resizable = true;
-		//this.moveable = true;
-		//this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
+    Preferences pref;
 
-		// set dialog-width according to fontsize
-		if((pref.fontSize &lt;= 13)||(sw &lt;= 240)||(sh &lt;= 240)){
-			setPreferredSize(240,240);
-		}
-		else if(pref.fontSize &lt;= 17){
-			setPreferredSize(300,250);
-		}
-		else if(pref.fontSize &lt;= 20){
-			setPreferredSize(350,300);
-		}
-		else if(pref.fontSize &lt;= 24){
-			setPreferredSize(400,350);
-		}
-		else if(pref.fontSize &lt;= 28){
-			setPreferredSize(450,400);
-		}
-		else{
-			setPreferredSize(500,450);
-		}
-		
-		//scp = new ScrollBarPanel(pnlGeneral);
-		
-		/////////////////////////////////////////////////////////
-		// First panel - General
-		/////////////////////////////////////////////////////////
-		Frame frmDataDir=new Frame();
-		frmDataDir.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_BOTTOM;
-		frmDataDir.addNext(new mLabel(MyLocale.getMsg(603,&quot;Data Directory:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		//frmDataDir.setTag(INSETS,new Insets(10,10,10,10));
-		frmDataDir.addLast(brwBt = new mButton(MyLocale.getMsg(604,&quot;Browse&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.EAST));
-		DataDir = new mInput();
-		DataDir.setText(pref.baseDir);
-		frmDataDir.addLast(DataDir.setTag(CellConstants.SPAN, new Dimension(3,1)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.EAST));
-		frmDataDir.addLast(chkAutoLoad = new mCheckBox(MyLocale.getMsg(629,&quot;Autoload last profile&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		if (pref.autoReloadLastProfile) chkAutoLoad.setState(true);
-		chkAutoLoad.setTag(INSETS,new Insets(0,0,2,0));
-		pnlGeneral.addLast(frmDataDir,HSTRETCH,HFILL);
-		
-		CellPanel pnlBrowser=new CellPanel();
-		pnlBrowser.setTag(INSETS,new Insets(2,0,0,0));
-		pnlBrowser.addNext(new mLabel(&quot;Browser:&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		Browser = new mInput();
-		Browser.setText(pref.browser);
-		pnlBrowser.addLast(Browser,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+    CellPanel pnlGeneral = new CellPanel();
+    CellPanel pnlDisplay = new CellPanel();
+    CellPanel pnlMore = new CellPanel();
+    CellPanel pnlTB = new CellPanel();
+    //Frame frmGarmin = new Frame();
+    ScrollBarPanel scp; // TODO not neede any more?
+    String [] garminPorts= new String[]{&quot;com1&quot;,&quot;com2&quot;,&quot;com3&quot;,&quot;com4&quot;,&quot;com5&quot;,&quot;com6&quot;,&quot;com7&quot;,&quot;usb&quot;};
 
-		pnlBrowser.addNext(new mLabel(MyLocale.getMsg(601,&quot;Your Alias:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		Alias = new mInput();
-		Alias.setText(pref.myAlias);
-		pnlBrowser.addNext(Alias,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		pnlBrowser.addNext(new mLabel(MyLocale.getMsg(594,&quot;Pwd&quot;)));
-		pnlBrowser.addLast(inpPassword=new mInput(pref.password),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		inpPassword.setToolTip(MyLocale.getMsg(593,&quot;Password is optional here.\nEnter only if you want to store it in pref.xml&quot;));
-		inpPassword.isPassword=true;
-		pnlGeneral.addLast(pnlBrowser,HSTRETCH,HFILL);
-		
-		pnlGeneral.addLast(gpsB = new mButton(&quot;GPS: &quot; + pref.mySPO.portName+&quot;/&quot;+pref.mySPO.baudRate),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		//content.addNext(Alias.setTag(Control.SPAN, new Dimension(3,1)),content.DONTSTRETCH, (content.HFILL|content.WEST));
-/*		pnlGeneral.addLast(inpGPS=new mInput(&quot;&quot;));
-		inpGPS.modify(ControlConstants.Disabled|ControlConstants.NoFocus,0);
-		inpGPS.setText(pref.mySPO.portName+&quot;/&quot;+pref.mySPO.baudRate);
-	*/	
-		// Garmin and GPSBabel
-		pnlGeneral.addNext(lblGarmin=new mLabel(MyLocale.getMsg(173,&quot;Garmin:  PC Port:&quot;)),DONTSTRETCH,LEFT);
-//		lblGarmin.setTag(INSETS,new Insets(4,0,0,0));
-		pnlGeneral.addNext(chcGarminPort=new mChoice(garminPorts,0),DONTSTRETCH,RIGHT);
-		//chcGarminPort.setTag(INSETS,new Insets(4,0,0,0));
-		chcGarminPort.selectItem(pref.garminConn);
-		pnlGeneral.addLast(chkSynthShort=new mCheckBox(MyLocale.getMsg(174,&quot;Short Names&quot;)),STRETCH,LEFT);
-		//chkSynthShort.setTag(INSETS,new Insets(4,0,0,0));
-		chkSynthShort.setState(!pref.garminGPSBabelOptions.equals(&quot;&quot;));
-		//frmGarmin.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_TOP;
-		//frmGarmin.setTag(INSETS,new Insets(4,0,0,0));
-		//pnlGeneral.addLast(frmGarmin);
-		pnlGeneral.addLast(new mLabel(&quot;&quot;));
-		
-		/////////////////////////////////////////////////////////
-		// Second panel - Screen
-		/////////////////////////////////////////////////////////
-		
-		Frame frmScreen=new Frame();
-		frmScreen.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER;
-		CellPanel pnlScreen=new CellPanel();
-		pnlScreen.addNext(new mLabel(MyLocale.getMsg(625,&quot;Screen (needs restart):&quot;)));
-		pnlScreen.addNext(new mLabel(&quot;Font&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		pnlScreen.addLast(fontSize = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		fontSize.maxLength=2;
-		fontSize.setPreferredSize(40,-1);
-		frmScreen.addLast(pnlScreen,HSTRETCH,HFILL);
-		fontSize.setText(Convert.toString(pref.fontSize));
-		
-		frmScreen.addLast(chkHasCloseButton=new mCheckBox(MyLocale.getMsg(631,&quot;PDA has close Button&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));	
-    	//lblTitle.setTag(INSETS,new Insets(2,0,0,0));
-        chkHasCloseButton.setState(pref.hasCloseButton);
-		frmScreen.addNext(chkMenuAtTop = new mCheckBox(MyLocale.getMsg(626,&quot;Menu top&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		chkMenuAtTop.setTag(INSETS,new Insets(0,0,2,0));
-		chkMenuAtTop.setState(pref.menuAtTop);
-		frmScreen.addNext(chkTabsAtTop = new mCheckBox(MyLocale.getMsg(627,&quot;Tabs top&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		chkTabsAtTop.setState(pref.tabsAtTop);
-		chkTabsAtTop.setTag(INSETS,new Insets(0,0,2,0));
-		frmScreen.addLast(chkShowStatus = new mCheckBox(MyLocale.getMsg(628,&quot;Status&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		chkShowStatus.setState(pref.showStatus);
-		chkShowStatus.setTag(INSETS,new Insets(0,0,2,0));
-		pnlDisplay.addLast(frmScreen,CellConstants.HSTRETCH,CellConstants.FILL);
-		
-		Frame frmImages=new Frame();
-		frmImages.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_TOP|UIConstants.BF_BOTTOM;
-		//frmImages.addNext(new mLabel(MyLocale.getMsg(623,&quot;Images:&quot;)),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		frmImages.addLast(chkShowDeletedImg = new mCheckBox(MyLocale.getMsg(624,&quot;Show deleted images&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		chkShowDeletedImg.setTag(INSETS,new Insets(2,0,0,0));
-		if (pref.showDeletedImages) chkShowDeletedImg.setState(true);
-		//mLabel dummy;
-		//frmImages.addNext(dummy=new mLabel(&quot;&quot;),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST|CellConstants.NORTH));
-		//dummy.setTag(INSETS,new Insets(0,0,2,0));
-		frmImages.addLast(chkDescShowImg = new mCheckBox(MyLocale.getMsg(638,&quot;Show pictures in description&quot;)),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST|CellConstants.NORTH));
-		chkDescShowImg.setTag(INSETS,new Insets(0,0,2,0));
-		if (pref.descShowImg) chkDescShowImg.setState(true);
-		pnlDisplay.addLast(frmImages,CellConstants.STRETCH,CellConstants.FILL);
+    public PreferencesScreen (Preferences p){
+            int sw = MyLocale.getScreenWidth();
+            int sh = MyLocale.getScreenHeight();
 
-		Frame frmHintLog=new Frame();
-		//frmHintLog.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_BOTTOM;
-		frmHintLog.addNext(new mLabel(MyLocale.getMsg(630,&quot;HintLogPanel:  Logs per page &quot;)),CellConstants.DONTSTRETCH,CellConstants.DONTFILL);	
-		frmHintLog.addLast(inpLogsPerPage=new mInput(),CellConstants.DONTSTRETCH,CellConstants.DONTFILL|CellConstants.EAST);
-		inpLogsPerPage.setText(Convert.toString(pref.logsPerPage));
-		inpLogsPerPage.setPreferredSize(40,-1);
-		//inpLogsPerPage.setTag(INSETS,new Insets(0,0,2,0));
-		//lblHlP.setTag(INSETS,new Insets(6,0,2,0));
-		frmHintLog.addNext(new mLabel(MyLocale.getMsg(633,&quot;Max. logs to spider&quot;)),CellConstants.DONTSTRETCH,CellConstants.DONTFILL);	
-		frmHintLog.addLast(inpMaxLogsToSpider=new mInput(),CellConstants.DONTSTRETCH,CellConstants.DONTFILL|CellConstants.EAST);
-		inpMaxLogsToSpider.setText(Convert.toString(pref.maxLogsToSpider));
-		inpMaxLogsToSpider.setPreferredSize(40,-1);
-		pnlDisplay.addLast(frmHintLog,CellConstants.STRETCH,CellConstants.FILL);
+            mTab=new TabbedPanel();
 
-		/////////////////////////////////////////////////////////
-		// Third panel - More
-		/////////////////////////////////////////////////////////
-		CellPanel pnlProxy=new CellPanel();
-		pnlProxy.addNext(new mLabel(&quot;Proxy&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		pnlProxy.addLast(Proxy = new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST)).setTag(SPAN,new Dimension(2,1));
-		Proxy.setText(pref.myproxy);
-		pnlProxy.addNext(new mLabel(&quot;Port&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		pnlProxy.addLast(ProxyPort = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		ProxyPort.setText(pref.myproxyport);
-		pnlProxy.addNext(new mLabel(&quot;&quot;),HSTRETCH,HFILL);
-		pnlProxy.addLast(chkProxyActive=new mCheckBox(MyLocale.getMsg(634,&quot;use Proxy&quot;)));
-		chkProxyActive.setState(pref.proxyActive);
-		pnlMore.addLast(pnlProxy,HSTRETCH,HFILL);
-		pnlMore.addNext(new mLabel(MyLocale.getMsg(592,&quot;Language (needs restart)&quot;)),DONTSTRETCH,DONTFILL|WEST);
-		String[] tmp = (new FileBugfix(FileBase.getProgramDirectory()+&quot;/languages&quot;).list(&quot;*.cfg&quot;, FileBase.LIST_FILES_ONLY)); //&quot;*.xyz&quot; doesn't work on some systems -&gt; use FileBugFix
-		if (tmp == null) tmp = new String[0];
-		String [] langs = new String[tmp.length +1];
-		langs[0] = &quot;auto&quot;;
-		int curlang = 0;
-		for (int i = 0; i &lt; tmp.length; i++) {
-			langs[i+1] = tmp[i].substring(0, tmp[i].lastIndexOf('.'));
-			if (langs[i+1].equalsIgnoreCase(MyLocale.language)) curlang = i+1 ;
-		}
-		//ewe.sys.Vm.copyArray(tmp, 0, langs, 1, tmp.length);
-		pnlMore.addLast(inpLanguage=new mChoice(langs, curlang),DONTSTRETCH,DONTFILL|WEST);
-		//inpLanguage.setPreferredSize(20,-1);
-		inpLanguage.setToolTip(MyLocale.getMsg(591,&quot;Select \&quot;auto\&quot; for system language or select your preferred language, e.g. DE or EN&quot;));
-		
-		/////////////////////////////////////////////////////////
-		// Fourth/Fifth panel - Listview and Travelbugs
-		/////////////////////////////////////////////////////////
+            pref = p;
+            this.title = MyLocale.getMsg(600,&quot;Preferences&quot;);
+            if ((sw &gt; 240) &amp;&amp; (sh &gt; 240))
+                    this.resizable = true;
+            //this.moveable = true;
+            //this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
 
-        mTab.addCard(pnlGeneral,MyLocale.getMsg(621,&quot;General&quot;),null);
-		mTab.addCard(pnlDisplay,MyLocale.getMsg(622,&quot;Screen&quot;),null);
-		mTab.addCard(pnlMore,MyLocale.getMsg(632,&quot;More&quot;),null);
-		mTab.addCard(tccList=new TableColumnChooser(new String[] {
-				MyLocale.getMsg(599,&quot;checkbox&quot;),
-				MyLocale.getMsg(598,&quot;type&quot;),
-				MyLocale.getMsg(606,&quot;Difficulty&quot;),
-				MyLocale.getMsg(607,&quot;Terrain&quot;),
-				MyLocale.getMsg(597,&quot;waypoint&quot;),
-				MyLocale.getMsg(596,&quot;name&quot;),
-				MyLocale.getMsg(608,&quot;Location&quot;),
-				MyLocale.getMsg(609,&quot;Owner&quot;),
-				MyLocale.getMsg(610,&quot;Hidden&quot;),
-				MyLocale.getMsg(611,&quot;Status&quot;),
-				MyLocale.getMsg(612,&quot;Distance&quot;),
-				MyLocale.getMsg(613,&quot;Bearing&quot;),
-				MyLocale.getMsg(635,&quot;Size&quot;),
-				MyLocale.getMsg(636,&quot;OC Empfehlungen&quot;),
-				MyLocale.getMsg(637,&quot;OC Index&quot;)},pref.listColMap),MyLocale.getMsg(595,&quot;List&quot;),null);
+            // set dialog-width according to fontsize
+            if((pref.fontSize &lt;= 13)||(sw &lt;= 240)||(sh &lt;= 240)){
+                    setPreferredSize(240,240);
+            }
+            else if(pref.fontSize &lt;= 17){
+                    setPreferredSize(300,250);
+            }
+            else if(pref.fontSize &lt;= 20){
+                    setPreferredSize(350,300);
+            }
+            else if(pref.fontSize &lt;= 24){
+                    setPreferredSize(400,350);
+            }
+            else if(pref.fontSize &lt;= 28){
+                    setPreferredSize(450,400);
+            }
+            else{
+                    setPreferredSize(500,450);
+            }
 
-		mTab.addCard(tccBugs=new TableColumnChooser(new String[] {
-				MyLocale.getMsg(6000,&quot;Guid&quot;),
-				MyLocale.getMsg(6001,&quot;Name&quot;),
-				MyLocale.getMsg(6002,&quot;track#&quot;),
-				MyLocale.getMsg(6003,&quot;Mission&quot;),
-				MyLocale.getMsg(6004,&quot;From Prof&quot;),
-				MyLocale.getMsg(6005,&quot;From Wpt&quot;),
-				MyLocale.getMsg(6006,&quot;From Date&quot;),
-				MyLocale.getMsg(6007,&quot;From Log&quot;),
-				MyLocale.getMsg(6008,&quot;To Prof&quot;),
-				MyLocale.getMsg(6009,&quot;To Wpt&quot;),
-				MyLocale.getMsg(6010,&quot;To Date&quot;),
-				MyLocale.getMsg(6011,&quot;To Log&quot;)},pref.travelbugColMap),&quot;T-bugs&quot;,null);
-		
-		this.addLast(mTab);
-		cancelB = new mButton(MyLocale.getMsg(614,&quot;Cancel&quot;));
-		cancelB.setHotKey(0, IKeys.ESCAPE);
-		addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		applyB = new mButton(MyLocale.getMsg(615,&quot;Apply&quot;));
-		applyB.setHotKey(0, IKeys.ACTION);
-		addLast(applyB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-	}
-	
-	public void onEvent(Event ev){
-		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelB){
-				this.close(0);
-			}
-			if (ev.target == applyB){
-				//if (pref.currProfile == 0){
-					//pref.curCentrePt.set(btnCentre.getText());
-					pref.baseDir = DataDir.getText();
-				//}
-				pref.fontSize = Convert.toInt(fontSize.getText());
-				if (pref.fontSize&lt;6) pref.fontSize=11;
-				pref.logsPerPage=Common.parseInt(inpLogsPerPage.getText());
-				if (pref.logsPerPage==0) pref.logsPerPage=pref.DEFAULT_LOGS_PER_PAGE;
-				pref.maxLogsToSpider=Common.parseInt(inpMaxLogsToSpider.getText());
-				if (pref.maxLogsToSpider==0) pref.maxLogsToSpider=pref.DEFAULT_MAX_LOGS_TO_SPIDER;
-				
-				Font defaultGuiFont = mApp.findFont(&quot;gui&quot;);
-				int sz = (pref.fontSize);
-				Font newGuiFont = new Font(defaultGuiFont.getName(), defaultGuiFont.getStyle(), sz); 
-				mApp.addFont(newGuiFont, &quot;gui&quot;); 
-				mApp.fontsChanged();
-				mApp.mainApp.font = newGuiFont;
-				
-				pref.myAlias = Alias.getText().trim();
-				SpiderGC.passwort=pref.password= inpPassword.getText().trim();
-				MyLocale.saveLanguage(MyLocale.language=inpLanguage.getText().toUpperCase().trim());
-				pref.browser = Browser.getText();
-				//Vm.debug(myPreferences.browser);
-				pref.myproxy = Proxy.getText();
-				pref.myproxyport = ProxyPort.getText();
-				pref.proxyActive=chkProxyActive.getState();
-				HttpConnection.setProxy(pref.myproxy, Common.parseInt(pref.myproxyport), pref.proxyActive); // TODO generate an error message if proxy port is not a number
-				//myPreferences.nLogs = Convert.parseInt(nLogs.getText());
-				pref.autoReloadLastProfile=chkAutoLoad.getState();
-				pref.showDeletedImages=chkShowDeletedImg.getState();
-				pref.garminConn=chcGarminPort.getSelectedItem().toString();
-				pref.garminGPSBabelOptions=chkSynthShort.state?&quot;-s&quot;:&quot;&quot;;
-				pref.menuAtTop=chkMenuAtTop.getState();
-				pref.tabsAtTop=chkTabsAtTop.getState();
-				pref.showStatus=chkShowStatus.getState();
-				pref.hasCloseButton=chkHasCloseButton.getState();
-				pref.travelbugColMap=tccBugs.getSelectedCols();
-				pref.listColMap=tccList.getSelectedCols();
-				pref.descShowImg=chkDescShowImg.getState();
-				Global.mainTab.tbP.myMod.setColumnNamesAndWidths();
-				pref.savePreferences();
-				pref.dirty = true; // Need to update table in case columns were enabled/disabled
-				this.close(0);
-			}
-			if(ev.target == brwBt){
-				FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, pref.baseDir);
-				fc.setTitle(MyLocale.getMsg(616,&quot;Select directory&quot;));
-				if(fc.execute() != FormBase.IDCANCEL)	DataDir.setText(fc.getChosen()+&quot;/&quot;);
-			}
-			if (ev.target == gpsB){
-				GPSPortOptions gpo = new GPSPortOptions();
-				gpo.portName = pref.mySPO.portName;
-				gpo.baudRate = pref.mySPO.baudRate;
-				Editor s = gpo.getEditor();
-				gpo.forwardGpsChkB.setState(pref.forwardGPS);
-				gpo.inputBoxForwardHost.setText(pref.forwardGpsHost);
-				gpo.logGpsChkB.setState(pref.logGPS);
-				gpo.inputBoxLogTimer.setText(pref.logGPSTimer);
-				Gui.setOKCancel(s);
-				if (s.execute()== FormBase.IDOK) {
-					pref.mySPO.portName = gpo.portName; 
-					pref.mySPO.baudRate = gpo.baudRate;
-					pref.forwardGPS = gpo.forwardGpsChkB.getState();
-					pref.forwardGpsHost = gpo.inputBoxForwardHost.getText();
-					pref.logGPS = gpo.logGpsChkB.getState();
-					pref.logGPSTimer = gpo.inputBoxLogTimer.getText();
-					gpsB.setText(&quot;GPS: &quot; + pref.mySPO.portName+&quot;/&quot;+pref.mySPO.baudRate);
-				}
-			}
-		}
-		super.onEvent(ev);
-	}
-	
+            //scp = new ScrollBarPanel(pnlGeneral);
+
+            /////////////////////////////////////////////////////////
+            // First panel - General
+            /////////////////////////////////////////////////////////
+            Frame frmDataDir=new Frame();
+            frmDataDir.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_BOTTOM;
+            frmDataDir.addNext(new Label(MyLocale.getMsg(603,&quot;Data Directory:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            //frmDataDir.setTag(TAG_INSETS,new Insets(10,10,10,10));
+            frmDataDir.addLast(brwBt = new Button(MyLocale.getMsg(604,&quot;Browse&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.EAST));
+            DataDir = new Input();
+            DataDir.setText(pref.baseDir);
+            frmDataDir.addLast(DataDir.setTag(CellConstants.SPAN, new Dimension(3,1)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.EAST));
+            frmDataDir.addLast(chkAutoLoad = new CheckBox(MyLocale.getMsg(629,&quot;Autoload last profile&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            if (pref.autoReloadLastProfile) chkAutoLoad.setState(true);
+            chkAutoLoad.setTag(TAG_INSETS,new Insets(0,0,2,0));
+            pnlGeneral.addLast(frmDataDir,HSTRETCH,HFILL);
+
+            CellPanel pnlBrowser=new CellPanel();
+            pnlBrowser.setTag(TAG_INSETS,new Insets(2,0,0,0));
+            pnlBrowser.addNext(new Label(&quot;Browser:&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            Browser = new Input();
+            Browser.setText(pref.browser);
+            pnlBrowser.addLast(Browser,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+
+            pnlBrowser.addNext(new Label(MyLocale.getMsg(601,&quot;Your Alias:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            Alias = new Input();
+            Alias.setText(pref.myAlias);
+            pnlBrowser.addNext(Alias,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            pnlBrowser.addNext(new Label(MyLocale.getMsg(594,&quot;Pwd&quot;)));
+            pnlBrowser.addLast(inpPassword=new Input(pref.password),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            inpPassword.setToolTip(MyLocale.getMsg(593,&quot;Password is optional here.\nEnter only if you want to store it in pref.xml&quot;));
+            inpPassword.isPassword=true;
+            pnlGeneral.addLast(pnlBrowser,HSTRETCH,HFILL);
+
+            pnlGeneral.addLast(gpsB = new Button(&quot;GPS: &quot; + pref.mySPO.portName+&quot;/&quot;+pref.mySPO.baudRate),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+            //content.addNext(Alias.setTag(Control.SPAN, new Dimension(3,1)),content.DONTSTRETCH, (content.HFILL|content.WEST));
+/*              pnlGeneral.addLast(inpGPS=new mInput(&quot;&quot;));
+            inpGPS.modify(ControlConstants.Disabled|ControlConstants.NoFocus,0);
+            inpGPS.setText(pref.mySPO.portName+&quot;/&quot;+pref.mySPO.baudRate);
+    */
+            // Garmin and GPSBabel
+            pnlGeneral.addNext(lblGarmin=new Label(MyLocale.getMsg(173,&quot;Garmin:  PC Port:&quot;)),DONTSTRETCH,LEFT);
+//          lblGarmin.setTag(TAG_INSETS,new Insets(4,0,0,0));
+            pnlGeneral.addNext(chcGarminPort=new Choice(garminPorts,0),DONTSTRETCH,RIGHT);
+            //chcGarminPort.setTag(TAG_INSETS,new Insets(4,0,0,0));
+            chcGarminPort.selectItem(pref.garminConn);
+            pnlGeneral.addLast(chkSynthShort=new CheckBox(MyLocale.getMsg(174,&quot;Short Names&quot;)),STRETCH,LEFT);
+            //chkSynthShort.setTag(TAG_INSETS,new Insets(4,0,0,0));
+            chkSynthShort.setState(!pref.garminGPSBabelOptions.equals(&quot;&quot;));
+            //frmGarmin.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_TOP;
+            //frmGarmin.setTag(TAG_INSETS,new Insets(4,0,0,0));
+            //pnlGeneral.addLast(frmGarmin);
+            pnlGeneral.addLast(new Label(&quot;&quot;));
+
+            /////////////////////////////////////////////////////////
+            // Second panel - Screen
+            /////////////////////////////////////////////////////////
+
+            Frame frmScreen=new Frame();
+            frmScreen.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER;
+            CellPanel pnlScreen=new CellPanel();
+            pnlScreen.addNext(new Label(MyLocale.getMsg(625,&quot;Screen (needs restart):&quot;)));
+            pnlScreen.addNext(new Label(&quot;Font&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            pnlScreen.addLast(fontSize = new Input(),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+            fontSize.maxLength=2;
+            fontSize.setPreferredSize(40,-1);
+            frmScreen.addLast(pnlScreen,HSTRETCH,HFILL);
+            fontSize.setText(Convert.toString(pref.fontSize));
+
+            frmScreen.addLast(chkHasCloseButton=new CheckBox(MyLocale.getMsg(631,&quot;PDA has close Button&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+    //lblTitle.setTag(TAG_INSETS,new Insets(2,0,0,0));
+    chkHasCloseButton.setState(pref.hasCloseButton);
+            frmScreen.addNext(chkMenuAtTop = new CheckBox(MyLocale.getMsg(626,&quot;Menu top&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            chkMenuAtTop.setTag(TAG_INSETS,new Insets(0,0,2,0));
+            chkMenuAtTop.setState(pref.menuAtTop);
+            frmScreen.addNext(chkTabsAtTop = new CheckBox(MyLocale.getMsg(627,&quot;Tabs top&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            chkTabsAtTop.setState(pref.tabsAtTop);
+            chkTabsAtTop.setTag(TAG_INSETS,new Insets(0,0,2,0));
+            frmScreen.addLast(chkShowStatus = new CheckBox(MyLocale.getMsg(628,&quot;Status&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            chkShowStatus.setState(pref.showStatus);
+            chkShowStatus.setTag(TAG_INSETS,new Insets(0,0,2,0));
+            pnlDisplay.addLast(frmScreen,CellConstants.HSTRETCH,CellConstants.FILL);
+
+            Frame frmImages=new Frame();
+            frmImages.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_TOP|UIConstants.BF_BOTTOM;
+            //frmImages.addNext(new mLabel(MyLocale.getMsg(623,&quot;Images:&quot;)),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            frmImages.addLast(chkShowDeletedImg = new CheckBox(MyLocale.getMsg(624,&quot;Show deleted images&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            chkShowDeletedImg.setTag(TAG_INSETS,new Insets(2,0,0,0));
+            if (pref.showDeletedImages) chkShowDeletedImg.setState(true);
+            //mLabel dummy;
+            //frmImages.addNext(dummy=new mLabel(&quot;&quot;),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST|CellConstants.NORTH));
+            //dummy.setTag(TAG_INSETS,new Insets(0,0,2,0));
+            frmImages.addLast(chkDescShowImg = new CheckBox(MyLocale.getMsg(638,&quot;Show pictures in description&quot;)),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST|CellConstants.NORTH));
+            chkDescShowImg.setTag(TAG_INSETS,new Insets(0,0,2,0));
+            if (pref.descShowImg) chkDescShowImg.setState(true);
+            pnlDisplay.addLast(frmImages,CellConstants.STRETCH,CellConstants.FILL);
+
+            Frame frmHintLog=new Frame();
+            //frmHintLog.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_BOTTOM;
+            frmHintLog.addNext(new Label(MyLocale.getMsg(630,&quot;HintLogPanel:  Logs per page &quot;)),CellConstants.DONTSTRETCH,CellConstants.DONTFILL);
+            frmHintLog.addLast(inpLogsPerPage=new Input(),CellConstants.DONTSTRETCH,CellConstants.DONTFILL|CellConstants.EAST);
+            inpLogsPerPage.setText(Convert.toString(pref.logsPerPage));
+            inpLogsPerPage.setPreferredSize(40,-1);
+            //inpLogsPerPage.setTag(TAG_INSETS,new Insets(0,0,2,0));
+            //lblHlP.setTag(TAG_INSETS,new Insets(6,0,2,0));
+            frmHintLog.addNext(new Label(MyLocale.getMsg(633,&quot;Max. logs to spider&quot;)),CellConstants.DONTSTRETCH,CellConstants.DONTFILL);
+            frmHintLog.addLast(inpMaxLogsToSpider=new Input(),CellConstants.DONTSTRETCH,CellConstants.DONTFILL|CellConstants.EAST);
+            inpMaxLogsToSpider.setText(Convert.toString(pref.maxLogsToSpider));
+            inpMaxLogsToSpider.setPreferredSize(40,-1);
+            pnlDisplay.addLast(frmHintLog,CellConstants.STRETCH,CellConstants.FILL);
+
+            /////////////////////////////////////////////////////////
+            // Third panel - More
+            /////////////////////////////////////////////////////////
+            CellPanel pnlProxy=new CellPanel();
+            pnlProxy.addNext(new Label(&quot;Proxy&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            pnlProxy.addLast(Proxy = new Input(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST)).setTag(SPAN,new Dimension(2,1));
+            Proxy.setText(pref.myproxy);
+            pnlProxy.addNext(new Label(&quot;Port&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            pnlProxy.addLast(ProxyPort = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            ProxyPort.setText(pref.myproxyport);
+            pnlProxy.addNext(new Label(&quot;&quot;),HSTRETCH,HFILL);
+            pnlProxy.addLast(chkProxyActive=new CheckBox(MyLocale.getMsg(634,&quot;use Proxy&quot;)));
+            chkProxyActive.setState(pref.proxyActive);
+            pnlMore.addLast(pnlProxy,HSTRETCH,HFILL);
+            pnlMore.addNext(new Label(MyLocale.getMsg(592,&quot;Language (needs restart)&quot;)),DONTSTRETCH,DONTFILL|WEST);
+            String[] tmp = (new File(File.getProgramDirectory()+&quot;/languages&quot;).list(&quot;*.cfg&quot;, File.LIST_FILES_ONLY)); //&quot;*.xyz&quot; doesn't work on some systems -&gt; use FileBugFix
+            if (tmp == null) tmp = new String[0];
+            String [] langs = new String[tmp.length +1];
+            langs[0] = &quot;auto&quot;;
+            int curlang = 0;
+            for (int i = 0; i &lt; tmp.length; i++) {
+                    langs[i+1] = tmp[i].substring(0, tmp[i].lastIndexOf('.'));
+                    if (langs[i+1].equalsIgnoreCase(MyLocale.language)) curlang = i+1 ;
+            }
+            //ewe.sys.Vm.copyArray(tmp, 0, langs, 1, tmp.length);
+            pnlMore.addLast(inpLanguage=new Choice(langs, curlang),DONTSTRETCH,DONTFILL|WEST);
+            //inpLanguage.setPreferredSize(20,-1);
+            inpLanguage.setToolTip(MyLocale.getMsg(591,&quot;Select \&quot;auto\&quot; for system language or select your preferred language, e.g. DE or EN&quot;));
+
+            /////////////////////////////////////////////////////////
+            // Fourth/Fifth panel - Listview and Travelbugs
+            /////////////////////////////////////////////////////////
+
+    mTab.addCard(pnlGeneral,MyLocale.getMsg(621,&quot;General&quot;),null);
+            mTab.addCard(pnlDisplay,MyLocale.getMsg(622,&quot;Screen&quot;),null);
+            mTab.addCard(pnlMore,MyLocale.getMsg(632,&quot;More&quot;),null);
+            mTab.addCard(tccList=new TableColumnChooser(new String[] {
+                            MyLocale.getMsg(599,&quot;checkbox&quot;),
+                            MyLocale.getMsg(598,&quot;type&quot;),
+                            MyLocale.getMsg(606,&quot;Difficulty&quot;),
+                            MyLocale.getMsg(607,&quot;Terrain&quot;),
+                            MyLocale.getMsg(597,&quot;waypoint&quot;),
+                            MyLocale.getMsg(596,&quot;name&quot;),
+                            MyLocale.getMsg(608,&quot;Location&quot;),
+                            MyLocale.getMsg(609,&quot;Owner&quot;),
+                            MyLocale.getMsg(610,&quot;Hidden&quot;),
+                            MyLocale.getMsg(611,&quot;Status&quot;),
+                            MyLocale.getMsg(612,&quot;Distance&quot;),
+                            MyLocale.getMsg(613,&quot;Bearing&quot;),
+                            MyLocale.getMsg(635,&quot;Size&quot;),
+                            MyLocale.getMsg(636,&quot;OC Empfehlungen&quot;),
+                            MyLocale.getMsg(637,&quot;OC Index&quot;)},pref.listColMap),MyLocale.getMsg(595,&quot;List&quot;),null);
+
+            mTab.addCard(tccBugs=new TableColumnChooser(new String[] {
+                            MyLocale.getMsg(6000,&quot;Guid&quot;),
+                            MyLocale.getMsg(6001,&quot;Name&quot;),
+                            MyLocale.getMsg(6002,&quot;track#&quot;),
+                            MyLocale.getMsg(6003,&quot;Mission&quot;),
+                            MyLocale.getMsg(6004,&quot;From Prof&quot;),
+                            MyLocale.getMsg(6005,&quot;From Wpt&quot;),
+                            MyLocale.getMsg(6006,&quot;From Date&quot;),
+                            MyLocale.getMsg(6007,&quot;From Log&quot;),
+                            MyLocale.getMsg(6008,&quot;To Prof&quot;),
+                            MyLocale.getMsg(6009,&quot;To Wpt&quot;),
+                            MyLocale.getMsg(6010,&quot;To Date&quot;),
+                            MyLocale.getMsg(6011,&quot;To Log&quot;)},pref.travelbugColMap),&quot;T-bugs&quot;,null);
+
+            this.addLast(mTab);
+            cancelB = new Button(MyLocale.getMsg(614,&quot;Cancel&quot;));
+            cancelB.setHotKey(0, IKeys.ESCAPE);
+            addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            applyB = new Button(MyLocale.getMsg(615,&quot;Apply&quot;));
+            applyB.setHotKey(0, IKeys.ACTION);
+            addLast(applyB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+    }
+
+    public void onEvent(Event ev){
+            if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+                    if (ev.target == cancelB){
+                            this.close(0);
+                    }
+                    if (ev.target == applyB){
+                            //if (pref.currProfile == 0){
+                                    //pref.curCentrePt.set(btnCentre.getText());
+                                    pref.baseDir = DataDir.getText();
+                            //}
+                            pref.fontSize = Convert.toInt(fontSize.getText());
+                            if (pref.fontSize&lt;6) pref.fontSize=11;
+                            pref.logsPerPage=Common.parseInt(inpLogsPerPage.getText());
+                            if (pref.logsPerPage==0) pref.logsPerPage=pref.DEFAULT_LOGS_PER_PAGE;
+                            pref.maxLogsToSpider=Common.parseInt(inpMaxLogsToSpider.getText());
+                            if (pref.maxLogsToSpider==0) pref.maxLogsToSpider=pref.DEFAULT_MAX_LOGS_TO_SPIDER;
+
+                            Font defaultGuiFont = Application.findFont(&quot;gui&quot;);
+                            int sz = (pref.fontSize);
+                            Font newGuiFont = new Font(defaultGuiFont.getName(), defaultGuiFont.getStyle(), sz);
+                            Application.addFont(newGuiFont, &quot;gui&quot;);
+                            Application.fontsChanged();
+                            Application.mainApp.font = newGuiFont;
+
+                            pref.myAlias = Alias.getText().trim();
+                            SpiderGC.passwort=pref.password= inpPassword.getText().trim();
+                            MyLocale.saveLanguage(MyLocale.language=inpLanguage.getText().toUpperCase().trim());
+                            pref.browser = Browser.getText();
+                            //Vm.debug(myPreferences.browser);
+                            pref.myproxy = Proxy.getText();
+                            pref.myproxyport = ProxyPort.getText();
+                            pref.proxyActive=chkProxyActive.getState();
+                            HttpConnection.setProxy(pref.myproxy, Common.parseInt(pref.myproxyport), pref.proxyActive); // TODO generate an error message if proxy port is not a number
+                            //myPreferences.nLogs = Convert.parseInt(nLogs.getText());
+                            pref.autoReloadLastProfile=chkAutoLoad.getState();
+                            pref.showDeletedImages=chkShowDeletedImg.getState();
+                            pref.garminConn=chcGarminPort.getSelectedItem().toString();
+                            pref.garminGPSBabelOptions=chkSynthShort.state?&quot;-s&quot;:&quot;&quot;;
+                            pref.menuAtTop=chkMenuAtTop.getState();
+                            pref.tabsAtTop=chkTabsAtTop.getState();
+                            pref.showStatus=chkShowStatus.getState();
+                            pref.hasCloseButton=chkHasCloseButton.getState();
+                            pref.travelbugColMap=tccBugs.getSelectedCols();
+                            pref.listColMap=tccList.getSelectedCols();
+                            pref.descShowImg=chkDescShowImg.getState();
+                            Global.mainTab.tbP.tModel.setColumnNamesAndWidths();
+                            pref.savePreferences();
+                            pref.dirty = true; // Need to update table in case columns were enabled/disabled
+                            this.close(0);
+                    }
+                    if(ev.target == brwBt){
+                            FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, pref.baseDir);
+                            fc.title=MyLocale.getMsg(616,&quot;Select directory&quot;);
+                            if(fc.execute() != FormBase.IDCANCEL)   DataDir.setText(fc.getChosen()+&quot;/&quot;);
+                    }
+                    if (ev.target == gpsB){
+                            GPSPortOptions gpo = new GPSPortOptions();
+                            gpo.portName = pref.mySPO.portName;
+                            gpo.baudRate = pref.mySPO.baudRate;
+                            Editor s = gpo.getEditor();
+                            gpo.forwardGpsChkB.setState(pref.forwardGPS);
+                            gpo.inputBoxForwardHost.setText(pref.forwardGpsHost);
+                            gpo.logGpsChkB.setState(pref.logGPS);
+                            gpo.inputBoxLogTimer.setText(pref.logGPSTimer);
+                            Gui.setOKCancel(s);
+                            if (s.execute()== FormBase.IDOK) {
+                                    pref.mySPO.portName = gpo.portName;
+                                    pref.mySPO.baudRate = gpo.baudRate;
+                                    pref.forwardGPS = gpo.forwardGpsChkB.getState();
+                                    pref.forwardGpsHost = gpo.inputBoxForwardHost.getText();
+                                    pref.logGPS = gpo.logGpsChkB.getState();
+                                    pref.logGPSTimer = gpo.inputBoxLogTimer.getText();
+                                    gpsB.setText(&quot;GPS: &quot; + pref.mySPO.portName+&quot;/&quot;+pref.mySPO.baudRate);
+                            }
+                    }
+            }
+            super.onEvent(ev);
+    }
+
 }
+
+

Modified: experiments/engywuck/hist-test/src/cachewolf/Profile.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/Profile.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/Profile.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,44 +1,47 @@
-package CacheWolf;
+package cachewolf;
 
-import CacheWolf.navi.Area;
-import ewe.io.BufferedWriter;
-import ewe.io.File;
-import ewe.io.FileNotFoundException;
-import ewe.io.FileReader;
-import ewe.io.FileWriter;
-import ewe.io.IOException;
-import ewe.io.PrintWriter;
-import ewe.sys.Convert;
-import ewe.sys.Handle;
-import ewe.sys.Vm;
-import ewe.ui.ProgressBarForm;
-import ewe.util.*;
 
+import java.io.BufferedWriter;
+import eve.io.File;
+import java.io.*;
+
+import eve.sys.Convert;
+import eve.sys.Handle;
+import eve.sys.Vm;
+import eve.ui.ProgressBarForm;
+import java.util.*;
+
+import cachewolf.navi.Area;
+import cachewolf.utils.Common;
+import cachewolf.utils.Extractor;
+import cachewolf.utils.SafeXML;
+
+
 /**
  * This class holds a profile, i.e. a group of caches with a centre location
- * 
+ *
  * @author salzkammergut
  *
  */
 public class Profile {
-
+	private static final int VERSION=1;  // The version of the raw data
 	/** The list of caches (CacheHolder objects). A pointer to this object exists in many classes in parallel to
-	 *  this object, i.e. the respective class contains both a {@link Profile} object and a cacheDB Vector. 
+	 *  this object, i.e. the respective class contains both a {@link Profile} object and a cacheDB Vector.
 	 */
 	public Vector cacheDB=new Vector();
 	/** The centre point of this group of caches. Read from ans stored to index.xml file */
 	public CWPoint centre=new CWPoint();
 	/** The name of the profile. The baseDir in preferences is appended this name to give the dataDir where
 	 *  the index.xml and cache files live. (Excuse the English spelling of centre)     */
-	public String name=new String();
+	public String name=&quot;&quot;;
 	/** This is the directory for the profile. It contains a closing /.   	 */
-	public String dataDir=new String();  
+	public String dataDir=&quot;&quot;;
 	/** Last sync date for opencaching caches */
-	public String last_sync_opencaching = new String();
+	public String last_sync_opencaching = &quot;&quot;;
 	/** Distance for opencaching caches */
-	public String distOC = new String();
+	public String distOC = &quot;&quot;;
 	/** Distance for geocaching caches */
-	public String distGC = new String();
+	public String distGC = &quot;&quot;;
 
 	public final static boolean SHOW_PROGRESS_BAR = true;
 	public final static boolean NO_SHOW_PROGRESS_BAR = false;
@@ -49,30 +52,30 @@
 	public final static String FILTERROSE=&quot;1111111111111111&quot;;
 	public final static String FILTERVAR=&quot;11111111&quot;;
 	public final static String FILTERSIZE=&quot;111111&quot;;
-	public String filterType = new String(FILTERTYPE);
-	public String filterRose = new String(FILTERROSE);
-	public String filterSize = new String(FILTERSIZE);
+	public String filterType = FILTERTYPE;
+	public String filterRose = FILTERROSE;
+	public String filterSize = FILTERSIZE;
 	//filter settings for archived ... owner (section) in filterscreen
-	public String filterVar = new String(FILTERVAR);
-	public String filterDist=new String(&quot;L&quot;);
-	public String filterDiff=new String(&quot;L&quot;);
-	public String filterTerr=new String(&quot;L&quot;);
-	// Saved filterstatus - is only refreshed from class Filter when Profile is saved
-	public int filterActive=Filter.FILTER_INACTIVE;
+	public String filterVar = FILTERVAR;
+	public String filterDist=&quot;L&quot;;
+	public String filterDiff=&quot;L&quot;;
+	public String filterTerr=&quot;L&quot;;
 	public boolean filterInverted=false;
-	public boolean showBlacklisted = false;
 
 	public long filterAttrYes = 0l;
 	public long filterAttrNo = 0l;
+	public int filterActive = Filter.FILTER_INACTIVE;
 	public int filterAttrChoice = 0;
+	public boolean showBlacklisted=false;
 
-	public boolean selectionChanged = true; // (&quot;H&#228;ckchen&quot;) used by movingMap to get to knao if it should update the caches in the map 
+	public boolean selectionChanged = true; // (&quot;H&#228;ckchen&quot;) used by movingMap to get to knao if it should update the caches in the map
 	/** True if the profile has been modified and not saved
-	 * The following modifications set this flag: New profile centre, Change of waypoint data 
+	 * The following modifications set this flag: New profile centre, Change of waypoint data
 	 */
 	public boolean hasUnsavedChanges = false;
-	public boolean byPassIndexActive = false;
 
+	/** Directory for html export */
+	public String htmlExportDirectory=&quot;&quot;;
 	//TODO Add other settings, such as max. number of logs to spider
 	//TODO Add settings for the preferred mapper to allow for maps other than expedia and other resolutions
 
@@ -83,15 +86,18 @@
 	public Profile(){
 	}
 
+	/**
+	 * Clear the profile
+	 */
 	public void clearProfile() {
 		CacheHolder.removeAllDetails();
 		cacheDB.clear();
 		centre.set(-361,-361);
 		name=&quot;&quot;;
-		dataDir=&quot;&quot;;  
+		dataDir=&quot;&quot;;
 		last_sync_opencaching = &quot;&quot;;
 		distOC = &quot;&quot;;
-		distGC = &quot;&quot;;
+		distGC=&quot;&quot;;
 		hasUnsavedChanges=false;
 	}
 
@@ -99,18 +105,10 @@
 	 *	Method to save the index.xml file that holds the total information
 	 *	on available caches in the database. The database is nothing else
 	 *	than the collection of caches in a directory.
-	 *   
-	 *   Not sure whether we need to keep 'pref' in method signature. May eventually remove it. 
-	 *   
-	 *   Saves the index with the filter settings from Filter
+	 *
+	 *  Saves the index with the filter settings from Filter
 	 */
-//	public void saveIndex(Preferences pref, boolean showprogress){
-//		saveIndex(pref,showprogress, Filter.filterActive,Filter.filterInverted);
-//	}
-
-	
-	/** Save index with filter settings given */ 
-	public void saveIndex(Preferences pref, boolean showprogress) { 
+/*	public void saveIndexRaw(boolean showprogress) {
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
 		if(showprogress){
@@ -119,31 +117,111 @@
 			pbf.exec();
 		}
 		CacheHolder.saveAllModifiedDetails(); // this must be called first as it makes some calculations
-		PrintWriter detfile;
+		DataOutputStream os;
 		CacheHolder ch;
+		createBackup(&quot;index.raw&quot;,&quot;indexraw.bak&quot;);
+		try{
+	        //detfile = new PrintWriter(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(dataDir + &quot;index.xml&quot;), &quot;UTF8&quot;))); //UTF8 not needed here
+			os = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(dataDir + &quot;index.raw&quot;)));
+		} catch (Exception e) {
+			Vm.debug(&quot;Problem creating index file &quot;+e.toString()+&quot;\nFilename=&quot;+dataDir + &quot;index.raw&quot;);
+			return;
+		}
+		CWPoint savedCentre=centre;
+		if (centre==null || !centre.isValid() || (savedCentre.latDec==0.0 &amp;&amp; savedCentre.lonDec==0.0)) savedCentre=Global.getPref().curCentrePt;
+
+		try{
+			os.writeInt(VERSION);
+			os.writeInt(cacheDB.size());
+			os.writeDouble(savedCentre.latDec);
+			os.writeDouble(savedCentre.lonDec);
+			//*detfile.print(&quot;    &lt;FILTER status = \&quot;&quot;+filterActive+(filterInverted?&quot;T&quot;:&quot;F&quot;)+
+			//		&quot;\&quot; rose = \&quot;&quot;+filterRose+&quot;\&quot; type = \&quot;&quot;+filterType+
+			//		&quot;\&quot; var = \&quot;&quot;+filterVar+&quot;\&quot; dist = \&quot;&quot;+filterDist.replace('&quot;',' ')+&quot;\&quot; diff = \&quot;&quot;+
+			//		filterDiff+&quot;\&quot; terr = \&quot;&quot;+filterTerr+&quot;\&quot; size = \&quot;&quot;+filterSize+&quot;\&quot; attributesYes = \&quot;&quot;+filterAttrYes+&quot;\&quot; attributesNo = \&quot;&quot;+filterAttrNo+&quot;\&quot; attributesChoice = \&quot;&quot;+filterAttrChoice+&quot;\&quot; /&gt;\n&quot;);
+
+			if(last_sync_opencaching == null || last_sync_opencaching.endsWith(&quot;null&quot;) || last_sync_opencaching.equals(&quot;&quot;)){
+				last_sync_opencaching = &quot;20050801000000&quot;;
+			}
+			if(distOC == null || distOC.endsWith(&quot;null&quot;) || distOC.equals(&quot;&quot;)){
+				distOC = &quot;0.0&quot;;
+			}
+			if(distGC == null || distGC.endsWith(&quot;null&quot;) || distGC.equals(&quot;&quot;)){
+				distGC = &quot;0.0&quot;;
+			}
+			os.writeUTF(&quot;    &lt;SYNCOC date = \&quot;&quot;+last_sync_opencaching+&quot;\&quot; dist = \&quot;&quot;+distOC+&quot;\&quot;/&gt;\n&quot;);
+			os.writeUTF(&quot;    &lt;SPIDERGC dist = \&quot;&quot;+distGC+&quot;\&quot;/&gt;\n&quot;);
+			if (htmlExportDirectory.length()&gt;0) os.writeUTF(&quot;    &lt;HTMLEXPORT dir=\&quot;&quot;+htmlExportDirectory+&quot;\&quot; /&gt;\n&quot;);
+			int size=cacheDB.size();
+			// Calculate the number of caches after which the progress bar is updated
+			// This is 1 percent of the total number, i.e. if size=1200 =&gt; update only after 12 caches
+			int progressInt=cacheDB.size()/100;
+			int nextProgress=0;
+			for(int i = 0; i&lt;size;i++){
+				if(showprogress &amp;&amp; i&gt;=nextProgress){
+					h.progress = (float)i/(float)size;
+					h.changed();
+					nextProgress+=progressInt;
+				}
+				ch = (CacheHolder)cacheDB.get(i);
+				if(ch.wayPoint.length()&gt;0)
+					os.writeUTF(ch.toXML());
+			}
+			os.close();
+			if(showprogress) pbf.exit(0);
+		}catch(IOException e){
+			Vm.debug(&quot;Problem writing to index file &quot;+e.toString());
+			if(showprogress) pbf.exit(0);
+		}
+		hasUnsavedChanges=false;
+	}
+*/
+	private void createBackup(String filename, String backupFilename) {
 		try {
-			File backup=new File(dataDir+&quot;index.bak&quot;);
+			File backup=new File(dataDir+backupFilename);
 			if (backup.exists()) backup.delete();
-			File index=new File(dataDir+&quot;index.xml&quot;);
-			index.rename(&quot;index.bak&quot;);
+			File index=new File(dataDir+filename);
+			index.rename(backupFilename);
 		} catch (Exception ex) {
-			pref.log(&quot;Error deleting backup or renaming index.xml&quot;);
+			Global.getPref().log(&quot;Error deleting backup or renaming &quot;+filename);
 		}
+	}
+
+	/**
+	 *	Method to save the index.xml file that holds the total information
+	 *	on available caches in the database. The database is nothing else
+	 *	than the collection of caches in a directory.
+	 *
+	 *  Saves the index with the filter settings from Filter
+	 */
+	public void saveIndex(boolean showprogress) {
+		eve.util.OperationTimer ot=new eve.util.OperationTimer();
+		ot.start(&quot;SAVEINDEX&quot;);
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+		if(showprogress){
+			pbf.showMainTask = false;
+			pbf.setTask(h,&quot;Saving Index&quot;);
+			pbf.exec();
+		}
+		CacheHolder.saveAllModifiedDetails(); // this must be called first as it makes some calculations
+		PrintWriter detfile;
+		CacheHolder ch;
+		createBackup(&quot;index.xml&quot;,&quot;index.bak&quot;);
 		try{
+	        //detfile = new PrintWriter(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(dataDir + &quot;index.xml&quot;), &quot;UTF8&quot;))); //UTF8 not needed here
 			detfile = new PrintWriter(new BufferedWriter(new FileWriter(dataDir + &quot;index.xml&quot;)));
 		} catch (Exception e) {
 			Vm.debug(&quot;Problem creating index file &quot;+e.toString()+&quot;\nFilename=&quot;+dataDir + &quot;index.xml&quot;);
 			return;
 		}
 		CWPoint savedCentre=centre;
-		if (centre==null || !centre.isValid() || (savedCentre.latDec==0.0 &amp;&amp; savedCentre.lonDec==0.0)) savedCentre=pref.curCentrePt;
+		if (centre==null || !centre.isValid() || (savedCentre.latDec==0.0 &amp;&amp; savedCentre.lonDec==0.0)) savedCentre=Global.getPref().curCentrePt;
 
 		try{
 			detfile.print(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;ISO-8859-1\&quot;?&gt;\n&quot;);
-			detfile.print(&quot;&lt;CACHELIST format=\&quot;decimal\&quot;&gt;\n&quot;);
+			detfile.print(&quot;&lt;CACHELIST format=\&quot;decimal\&quot; size=\&quot;&quot;+cacheDB.size()+&quot;\&quot; /&gt;\n&quot;);
 			if (savedCentre.isValid())
-//				detfile.print(&quot;    &lt;CENTRE lat=\&quot;&quot;+savedCentre.getNSLetter() + &quot; &quot; + savedCentre.getLatDeg(CWPoint.CW) + &quot;&deg; &quot; + savedCentre.getLatMin(CWPoint.CW)+ &quot;\&quot; &quot;+
-//				&quot;long=\&quot;&quot;+savedCentre.getEWLetter() + &quot; &quot; + savedCentre.getLonDeg(CWPoint.CW) + &quot;&deg; &quot; + savedCentre.getLonMin(CWPoint.CW)+&quot;\&quot;/&gt;\n&quot;);
 				detfile.print(&quot;    &lt;CENTRE lat=\&quot;&quot;+savedCentre.latDec+&quot;\&quot; lon=\&quot;&quot;+savedCentre.lonDec+&quot;\&quot;/&gt;\n&quot;);
 			if(last_sync_opencaching == null || last_sync_opencaching.endsWith(&quot;null&quot;) || last_sync_opencaching.equals(&quot;&quot;)){
 				last_sync_opencaching = &quot;20050801000000&quot;;
@@ -154,34 +232,29 @@
 			if(distGC == null || distGC.endsWith(&quot;null&quot;) || distGC.equals(&quot;&quot;)){
 				distGC = &quot;0.0&quot;;
 			}
-
-			detfile.print(&quot;    &lt;FILTER status = \&quot;&quot;+filterActive+(filterInverted?&quot;T&quot;:&quot;F&quot;)+ 
+			detfile.print(&quot;    &lt;FILTER status = \&quot;&quot;+filterActive+(filterInverted?&quot;T&quot;:&quot;F&quot;)+
 					&quot;\&quot; rose = \&quot;&quot;+filterRose+&quot;\&quot; type = \&quot;&quot;+filterType+
 					&quot;\&quot; var = \&quot;&quot;+filterVar+&quot;\&quot; dist = \&quot;&quot;+filterDist.replace('&quot;',' ')+&quot;\&quot; diff = \&quot;&quot;+
-					filterDiff+&quot;\&quot; terr = \&quot;&quot;+filterTerr+&quot;\&quot; size = \&quot;&quot;+filterSize+&quot;\&quot; attributesYes = \&quot;&quot;+filterAttrYes+
-					&quot;\&quot; attributesNo = \&quot;&quot;+filterAttrNo+&quot;\&quot; attributesChoice = \&quot;&quot;+filterAttrChoice+&quot;\&quot; showBlacklist = \&quot;&quot;+showBlacklisted+&quot;\&quot; /&gt;\n&quot;);
+					filterDiff+&quot;\&quot; terr = \&quot;&quot;+filterTerr+&quot;\&quot; size = \&quot;&quot;+filterSize+&quot;\&quot; attributesYes = \&quot;&quot;+filterAttrYes+&quot;\&quot; attributesNo = \&quot;&quot;+filterAttrNo+&quot;\&quot; attributesChoice = \&quot;&quot;+filterAttrChoice+&quot;\&quot; showBlacklist = \&quot;&quot;+showBlacklisted+&quot;\&quot; /&gt;\n&quot;);
 			detfile.print(&quot;    &lt;SYNCOC date = \&quot;&quot;+last_sync_opencaching+&quot;\&quot; dist = \&quot;&quot;+distOC+&quot;\&quot;/&gt;\n&quot;);
-			detfile.print(&quot;    &lt;SPIDERGC dist = \&quot;&quot;+distGC+&quot;\&quot;/&gt;\n&quot;);
-			int size=cacheDB.size();
+			detfile.print(&quot;    &lt;SPIDERGC dist = \&quot;&quot;+distGC+&quot;\&quot;/&gt;\n&quot;);			int size=cacheDB.size();
+			if (htmlExportDirectory.length()&gt;0) detfile.print(&quot;    &lt;HTMLEXPORT dir=\&quot;&quot;+htmlExportDirectory+&quot;\&quot; /&gt;\n&quot;);
+			// Calculate the number of caches after which the progress bar is updated
+			// This is 1 percent of the total number, i.e. if size=1200 =&gt; update only after 12 caches
+			int progressInt=cacheDB.size()/100;
+			int nextProgress=0;
 			for(int i = 0; i&lt;size;i++){
-				if(showprogress){
+				if(showprogress &amp;&amp; i&gt;=nextProgress){
 					h.progress = (float)i/(float)size;
 					h.changed();
+					nextProgress+=progressInt;
 				}
 				ch = (CacheHolder)cacheDB.get(i);
-				////Vm.debug(&quot;Saving: &quot; + ch.CacheName);
-				if(ch.wayPoint.length()&gt;0) { //TODO &amp;&amp; ch.LongDescription.equals(&quot;An Error Has Occured&quot;) == false){
-/*					detfile.print(&quot;    &lt;CACHE name = \&quot;&quot;+SafeXML.clean(ch.CacheName)+&quot;\&quot; owner = \&quot;&quot;+SafeXML.clean(ch.CacheOwner)+
-							//&quot;\&quot; lat = \&quot;&quot;+ SafeXML.clean(ch.LatLon) +
-							&quot;\&quot; lat = \&quot;&quot;+ ch.pos.latDec + &quot;\&quot; lon = \&quot;&quot;+ch.pos.lonDec+
-							&quot;\&quot; hidden = \&quot;&quot;+ch.DateHidden+&quot;\&quot; wayp = \&quot;&quot;+SafeXML.clean(ch.wayPoint)+&quot;\&quot; status = \&quot;&quot;+ch.CacheStatus+&quot;\&quot; type = \&quot;&quot;+ch.type+&quot;\&quot; dif = \&quot;&quot;+ch.hard+&quot;\&quot; terrain = \&quot;&quot; + ch.terrain + &quot;\&quot; dirty = \&quot;false&quot; + // ch.dirty + dirty is not used, so we save it as false 
-							&quot;\&quot; size = \&quot;&quot;+ch.CacheSize+&quot;\&quot; online = \&quot;&quot; + Convert.toString(ch.is_available) + &quot;\&quot; archived = \&quot;&quot; + Convert.toString(ch.is_archived) + &quot;\&quot; has_bug = \&quot;&quot; + Convert.toString(ch.has_bug) + &quot;\&quot; black = \&quot;&quot; + Convert.toString(ch.is_black) + &quot;\&quot; owned = \&quot;&quot; + Convert.toString(ch.is_owned) + &quot;\&quot; found = \&quot;&quot; + Convert.toString(ch.is_found) + &quot;\&quot; is_new = \&quot;&quot; + Convert.toString(ch.is_new) +&quot;\&quot; is_log_update = \&quot;&quot; + Convert.toString(ch.is_log_update) + &quot;\&quot; is_update = \&quot;&quot; + Convert.toString(ch.is_update) + &quot;\&quot; is_HTML = \&quot;&quot; + Convert.toString(ch.is_HTML) + &quot;\&quot; DNFLOGS = \&quot;&quot; + ch.noFindLogs + &quot;\&quot; ocCacheID = \&quot;&quot; + ch.ocCacheID + &quot;\&quot; is_INCOMPLETE = \&quot;&quot;+Convert.toString(ch.is_incomplete)+ &quot;\&quot; lastSyncOC = \&quot;&quot; + ch.lastSyncOC + &quot;\&quot; /&gt;\n&quot;);
-*/					detfile.print(ch.toXML());
-				}
+				if(ch.wayPoint.length()&gt;0)
+					detfile.print(ch.toXML());
 			}
 			detfile.print(&quot;&lt;/CACHELIST&gt;\n&quot;);
 			detfile.close();
-			buildReferences(); //TODO Why is this needed here?
 			if(showprogress) pbf.exit(0);
 		}catch(Exception e){
 			Vm.debug(&quot;Problem writing to index file &quot;+e.toString());
@@ -189,6 +262,8 @@
 			if(showprogress) pbf.exit(0);
 		}
 		hasUnsavedChanges=false;
+		ot.end();
+		eve.sys.Vm.debug(ot.toString());
 	}
 
 	/**
@@ -197,19 +272,23 @@
 	 *	than the collection of caches in a directory.
 	 */
 	public void readIndex(){
-		
 		try {
 			selectionChanged = true;
 			boolean fmtDec=false;
 			char decSep=MyLocale.getDigSeparator().charAt(0);
 			char notDecSep=decSep=='.'?',':'.';
-			FileReader in = new FileReader(dataDir + &quot;index.xml&quot;);
+			BufferedReader in = new BufferedReader(new FileReader(dataDir + &quot;index.xml&quot;));
 			in.readLine(); // &lt;?xml version= ...
 			String text=in.readLine(); // &lt;CACHELIST&gt;
-			if (text!=null &amp;&amp; text.indexOf(&quot;decimal&quot;)&gt;0) fmtDec=true;
+			if (text!=null) {
+				if (text.indexOf(&quot;decimal&quot;)&gt;0) fmtDec=true;
+				int i=text.indexOf(&quot;size=\&quot;&quot;);
+				int j=text.indexOf(&quot;\&quot;&quot;,i+7);
+				//if (i&gt;0 &amp;&amp; j&gt;i+6) cacheDB.ensureCapacity(Common.parseInt(text.substring(i+6,j)));
+			}
 			Extractor ex = new Extractor(null, &quot; = \&quot;&quot;, &quot;\&quot; &quot;, 0, true);
-			
-			//ewe.sys.Time startT=new ewe.sys.Time();
+
+			//eve.sys.Time startT=new eve.sys.Time();
 			while ((text = in.readLine()) != null){
 				// Check for Line with cache data
 				if (text.indexOf(&quot;&lt;CACHE &quot;)&gt;=0){
@@ -222,13 +301,13 @@
 						start=text.indexOf(&quot;lon=\&quot;&quot;)+5;
 						String lon=text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)).replace(notDecSep,decSep);
 						centre.set(Convert.parseDouble(lat),Convert.parseDouble(lon));
-					} else {	
+					} else {
 						int start=text.indexOf(&quot;lat=\&quot;&quot;)+5;
 						String lat=SafeXML.cleanback(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
 						start=text.indexOf(&quot;long=\&quot;&quot;)+6;
 						String lon=SafeXML.cleanback(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
 						centre.set(lat+&quot; &quot;+lon,CWPoint.CW); // Fast parse
-					}	
+					}
 				} else if (text.indexOf(&quot;&lt;SYNCOC&quot;)&gt;=0) {
 					int start=text.indexOf(&quot;date = \&quot;&quot;)+8;
 					last_sync_opencaching=text.substring(start,text.indexOf(&quot;\&quot;&quot;,start));
@@ -242,13 +321,13 @@
 					String temp=ex.findNext(); // Filter status is now first, need to deal with old versions which don't have filter status
 					if (temp.length()==2) {
 						// Compatibility with previous versions
-						if (temp.charAt(0)=='T') 
+						if (temp.charAt(0)=='T')
 							filterActive=Filter.FILTER_ACTIVE;
 						else
 							filterActive=Common.parseInt(temp.substring(0,1));
 						filterInverted=temp.charAt(1)=='T';
 						filterRose = ex.findNext();
-					} else 
+					} else
 						filterRose = temp;
 					filterType = ex.findNext();
 					//Need this to stay &quot;downward&quot; compatible. New type introduced
@@ -269,71 +348,73 @@
 					attr = ex.findNext();
 					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
 						filterAttrChoice = Convert.parseInt(attr);
-					showBlacklisted = new Boolean(ex.findNext()).booleanValue();
+					attr = ex.findNext();
+					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
+						showBlacklisted = new Boolean(attr).booleanValue();
+					else
+						showBlacklisted = false;
+				} else if (text.indexOf(&quot;&lt;HTMLEXPORT&quot;)&gt;=0) {
+					int start=text.indexOf(&quot;dir = \&quot;&quot;)+8;
+					htmlExportDirectory=text.substring(start,text.indexOf(&quot;\&quot;&quot;,start));
 				}
 			}
 			in.close();
-			//ewe.sys.Time endT=new ewe.sys.Time();
-			//Vm.debug(&quot;Time=&quot;+((((endT.hour*60+endT.minute)*60+endT.second)*1000+endT.millis)-(((startT.hour*60+startT.minute)*60+startT.second)*1000+startT.millis)));
-			//Vm.debug(&quot;Start:&quot;+startT.format(&quot;H:mm:ss.SSS&quot;));
-			//Vm.debug(&quot;End  :&quot;+endT.format(&quot;H:mm:ss.SSS&quot;));	
-			// Build references between caches and addi wpts
 			buildReferences();
 			hasUnsavedChanges = false;
 		} catch (FileNotFoundException e) {
 			Global.getPref().log(&quot;index.xml not found in directory &quot;+dataDir); // Normal when profile is opened for first time
 			//e.printStackTrace();
 		} catch (IOException e){
-			Global.getPref().log(&quot;Problem reading index.xml in dir: &quot;+dataDir,e,true); 
+			Global.getPref().log(&quot;Problem reading index.xml in dir: &quot;+dataDir,e,true);
 		}
 		normaliseFilters();
 	}
 
-	/** Restore the filter to the values stored in this profile 
-	 *  Called from Main Form and MainMenu 
-	 *  The values of Filter.isActive and Filter.isInactive are set by the filter 
-	 **/
-	void restoreFilter() {
-		restoreFilter( false );		
-	}
-	
-	void restoreFilter(boolean clearIfInactive) {
-		boolean inverted=filterInverted; // Save it as doFilter will clear filterInverted
-		Filter flt=new Filter();
-		if (filterActive==Filter.FILTER_ACTIVE) {
-			flt.setFilter();
-			flt.doFilter();
-			if (inverted) {
-				flt.invertFilter();
-				filterInverted=true; // Needed because previous line inverts filterInverted
-			}
-		} else if (filterActive==Filter.FILTER_CACHELIST) {
-			Global.mainForm.cacheList.applyCacheList();
-			//flt.filterActive=filterActive;
-		} else if (filterActive==Filter.FILTER_INACTIVE) {
-			if (clearIfInactive) {
-				flt.clearFilter();
-			}
-		}
-	}
-	
-	void checkBlacklistStatus() {
-		Vector cacheDB=Global.getProfile().cacheDB;
-		CacheHolder ch;
-		boolean filterChanged = false;
-		for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
-			ch = (CacheHolder)cacheDB.get(i);
-			if (ch.is_black^showBlacklisted) {
-				ch.is_filtered = true;
-				filterChanged = true;
-			}
-		}
-		if ( filterChanged ) {
-			selectionChanged = true;
-			hasUnsavedChanges=true;			
-		}
-	}
+    /** Restore the filter to the values stored in this profile
+     *  Called from Main Form and MainMenu
+     *  The values of Filter.isActive and Filter.isInactive are set by the filter
+     **/
+    void restoreFilter() {
+            restoreFilter( false );
+    }
 
+    void restoreFilter(boolean clearIfInactive) {
+            boolean inverted=filterInverted; // Save it as doFilter will clear filterInverted
+            Filter flt=new Filter();
+            if (filterActive==Filter.FILTER_ACTIVE) {
+                    flt.setFilter();
+                    flt.doFilter();
+                    if (inverted) {
+                            flt.invertFilter();
+                            filterInverted=true; // Needed because previous line inverts filterInverted
+                    }
+            } else if (filterActive==Filter.FILTER_CACHELIST) {
+                    Global.mainForm.cacheList.applyCacheList();
+                    //flt.filterActive=filterActive;
+            } else if (filterActive==Filter.FILTER_INACTIVE) {
+                    if (clearIfInactive) {
+                            flt.clearFilter();
+                    }
+            }
+    }
+
+    void checkBlacklistStatus() {
+        Vector cacheDB=Global.getProfile().cacheDB;
+        CacheHolder ch;
+        boolean filterChanged = false;
+        for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+                ch = (CacheHolder)cacheDB.get(i);
+                if (ch.is_black^showBlacklisted) {
+                        ch.is_filtered = true;
+                        filterChanged = true;
+                }
+        }
+        if ( filterChanged ) {
+                selectionChanged = true;
+                hasUnsavedChanges=true;
+        }
+}
+
 	public int getCacheIndex(String wp){
 		int retval = -1;
 		CacheHolder ch;
@@ -351,7 +432,7 @@
 	public String getNewWayPointName(){
 		String strWp=null;
 		long  lgWp=1;
-		int s = cacheDB.size(); 
+		int s = cacheDB.size();
 		if (s ==0 )
 			return &quot;CW0000&quot;;
 		//Create new waypoint,look if not in db
@@ -365,9 +446,9 @@
 		}
 		return strWp;
 	}
-	
+
 	/**
-	 * 
+	 *
 	 * @param forcache maincache
 	 * @return
 	 */
@@ -376,7 +457,7 @@
 		String waypoint;
 		do {
 			waypoint=MyLocale.formatLong(++wptNo,&quot;00&quot;)+forcache.substring(2);
-		} while (Global.getProfile().getCacheIndex(waypoint)&gt;=0);
+		} while (getCacheIndex(waypoint)&gt;=0);
 		return waypoint;
 	}
 
@@ -391,16 +472,21 @@
 		if (mainindex &lt; 0) mainindex = getCacheIndex(&quot;CW&quot;+mainwpt);
 		if (mainindex &lt; 0) throw new IllegalArgumentException(&quot;no main cache found for: &quot; + ch.wayPoint);
 		CacheHolder mainch = (CacheHolder)cacheDB.get(mainindex);
+		mainch.allocAddiMem();
 		mainch.addiWpts.add(ch);
 		ch.mainCache = mainch;
 	}
 
 
-	public String toString() {
+/*	public String toString() {
 		return &quot;Profile: Name=&quot;+name+&quot;\nCentre=&quot;+centre.toString()+&quot;\ndataDir=&quot;+dataDir+&quot;\nlastSyncOC=&quot;+
 		last_sync_opencaching+&quot;\ndistOC=&quot;+distOC+&quot;\ndistGC=&quot;+distGC;
 	}
-
+*/
+	/**
+	 * Sets the selected status of all caches
+	 * @param selectStatus The value of the select status to set
+	 */
 	public void setSelectForAll(boolean selectStatus) {
 		selectionChanged = true;
 		CacheHolder ch;
@@ -408,7 +494,7 @@
 			ch = (CacheHolder)cacheDB.get(i);
 			if (ch.is_filtered == false) ch.is_Checked = selectStatus;
 		}
-	} 
+	}
 
 
 	public int numCachesInArea; // only valid after calling getSourroundingArea
@@ -424,7 +510,7 @@
 			ch = (CacheHolder) cacheDB.get(i);
 			if (!onlyOfSelected || ch.is_Checked) {
 				if (ch.pos == null) { // this can not happen
-					tmpca.set(ch.LatLon);
+					tmpca.set(ch.latLon);
 					ch.pos = new CWPoint(tmpca);
 				}
 				if (ch.pos.isValid() ){ // done: &amp;&amp; ch.pos.latDec != 0 &amp;&amp; ch.pos.lonDec != 0 TO-DO != 0 sollte rausgenommen werden sobald in der Liste vern&#252;nftig mit nicht gesetzten pos umgegangen wird
@@ -441,9 +527,9 @@
 				}
 			}
 		}
-		if (topleft != null &amp;&amp; bottomright != null) 
+		if (topleft != null &amp;&amp; bottomright != null)
 			return new Area(topleft, bottomright);
-		else return null;
+		return null;
 	}
 
 	/**
@@ -453,18 +539,13 @@
 	 *	@see	Extractor
 	 */
 	public void updateBearingDistance(){
-		CWPoint centerPoint = new CWPoint(Global.getPref().curCentrePt); // Clone current centre to be sure
-		int anz = cacheDB.getCount();
+		CWPoint centerPoint = Global.getPref().curCentrePt;
+		int anz = cacheDB.size();
 		CacheHolder ch;
-		// Jetzt durch die CacheDaten schleifen
 		while(--anz &gt;= 0){
 			ch = (CacheHolder)cacheDB.get(anz); // This returns a pointer to the CacheHolder object
 			ch.calcDistance(centerPoint);
 		}
-		// The following call is not very clean as it mixes UI with base classes
-		// However, calling it from here allows us to recenter the
-		// radar panel with only one call
-		if (Global.mainTab!=null) Global.mainTab.radarP.recenterRadar();
 	} //updateBearingDistance
 
 	/**
@@ -473,13 +554,13 @@
 	 */
 	public void buildReferences(){
 		CacheHolder ch, mainCh;
-		Hashtable dbIndex = new Hashtable((int)(cacheDB.size()/0.75f + 1), 0.75f); // initialise so that von rehashing is neccessary
+		Hashtable dbIndex = new Hashtable((int)(cacheDB.size()/0.75f + 1), 0.75f); // initialise so that no rehashing is neccessary
 
 		Integer index;
 		// Build index for faster search and clear all references
 		for(int i = cacheDB.size() -1; i &gt;= 0;i--){
 			ch = (CacheHolder)cacheDB.get(i);
-			ch.addiWpts.clear();
+			if (ch.hasAddiWpt() )ch.addiWpts.clear();
 			ch.mainCache = null;
 			// if (ch.wayPoint.startsWith(&quot;GC&quot;)) // Only put potential master caches into the index
 				dbIndex.put(ch.wayPoint, new Integer(i));
@@ -495,22 +576,23 @@
 					index = (Integer) dbIndex.get(&quot;OC&quot;+ ch.wayPoint.substring(2));
 				if (index == null)  // TODO save the source (GC or OC or Custom) of the maincache somewhere else to avoid ambiguity of addi-wpt-names
 					index = (Integer) dbIndex.get(&quot;CW&quot;+ ch.wayPoint.substring(2));
-				
+
 				if (index != null) {
 					mainCh = (CacheHolder) cacheDB.get(index.intValue());
+					mainCh.allocAddiMem();
 					mainCh.addiWpts.add(ch);
 					ch.mainCache = mainCh;
 					ch.setAttributesFromMainCache(mainCh);
 				}// if
 			}// if
 		}// for
-		// sort addi wpts
+		// sort addi wpts for each cache in ascending order
 		for(int i =  0; i &lt; max ;i++){
 			ch = (CacheHolder)cacheDB.get(i);
 			if (ch.hasAddiWpt() &amp;&amp; (ch.addiWpts.size()&gt; 1)){
 				//ch.addiWpts.sort(new MyComparer(ch.addiWpts,MyLocale.getMsg(1002,&quot;Waypoint&quot;),ch.addiWpts.size()), false);
-				ch.addiWpts.sort(
-						new ewe.util.Comparer() {	
+				eve.util.Utils.sort(new Handle(),ch.addiWpts,
+						new eve.util.Comparer() {
 							public int compare(Object o1, Object o2){
 								return ((CacheHolder) o1).wayPoint.compareTo(((CacheHolder)o2).wayPoint);
 							}
@@ -519,22 +601,22 @@
 		}
 
 	}
-	
-	
+
+
 	/** Ensure that all filters have the proper length so that the 'charAt' access in the filter
 	 * do not cause nullPointer Exceptions
 	 */
 	private void normaliseFilters() {
 		String manyOnes=&quot;11111111111111111111111111111&quot;;
-		if (filterRose.length()&lt;FILTERROSE.length()) { 
-			filterRose=(filterRose+manyOnes).substring(0,FILTERROSE.length()); 
-		}  
-		if (filterVar.length()&lt;FILTERVAR.length()) { 
-			filterVar=(filterVar+manyOnes).substring(0,FILTERVAR.length()); 
-		}  
-		if (filterType.length()&lt;FILTERTYPE.length()) { 
+		if (filterRose.length()&lt;FILTERROSE.length()) {
+			filterRose=(filterRose+manyOnes).substring(0,FILTERROSE.length());
+		}
+		if (filterVar.length()&lt;FILTERVAR.length()) {
+			filterVar=(filterVar+manyOnes).substring(0,FILTERVAR.length());
+		}
+		if (filterType.length()&lt;FILTERTYPE.length()) {
 			filterType=(filterType+manyOnes).substring(0,FILTERTYPE.length());
-		} 
+		}
 		if (filterSize.length()&lt;FILTERSIZE.length()) {
 			filterSize=(filterSize+manyOnes).substring(0,FILTERSIZE.length());
 		}

Modified: experiments/engywuck/hist-test/src/cachewolf/ProfilesForm.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/ProfilesForm.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/ProfilesForm.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,10 +1,13 @@
-package CacheWolf;
+package cachewolf;
 
-import utils.FileBugfix;
-import ewe.ui.*;
-import ewe.io.*;
-import ewe.fx.*;
+import eve.ui.*;
+import eve.io.*;
+import eve.sys.*;
+import eve.fx.*;
+import eve.fx.gui.IKeys;
+import eve.ui.event.ControlEvent;
 
+
 /**
 *	This form displays the list of profiles for a user to choose from,
 *	when CacheWolf starts up. Also allows to open a new profile.
@@ -14,48 +17,46 @@
 
 	// A subclassed mList which allows the highlighting of an entry
 	// Maybe there is an easier way of making this happen, but I could not find it.
-	private class MyList extends mList {
+	private class MyList extends List {
 		private int first=1;
 		private int select;
-	    
+
 		public MyList() {
 			super(1,1,false);
 		}
-		
+
 		public void selectLastProfile(String selectedItem) {
 			selectItem(selectedItem);
 			select=getSelectedIndex(0);
 		}
 
 		public void doPaint(Graphics gr,Rect area) {
-			if (first==1) { 
+			if (first==1) {
 				first=0;
 				selectAndView(select);
-				makeVisible(select); 
+				makeVisible(select);
 			}
 			super.doPaint(gr,area);
 		}
 
 		// Copied from BasicList.getScrollablePanel(), but exchanging
 		// the standard scroll bar with the fontsize sensitive one.
-		public ScrollablePanel getScrollablePanel()
-		{
+		public ScrollablePanel getScrollablePanel() {
 			dontAutoScroll = amScrolling = true;
 			ScrollablePanel sp = new MyScrollBarPanel(this);
 			sp.modify(0,TakeControlEvents);
 			return sp;
 		}
-		
 	}
 
 	private MyList choice;
 	private ScrollablePanel spMList;
-	private mButton btnCancel,btnNew,btnOK;
+	private Button btnCancel,btnNew,btnOK;
 	private String baseDir;
 	public String newSelectedProfile;	// This is only used if a new profile is being created
 
 	/**
-	*	Constructor to create a form to select profiles. It requires that the preferences 
+	*	Constructor to create a form to select profiles. It requires that the preferences
 	*	have been loaded so that the calling parameters can be set.
 	* @param baseDir The base directory which holds one subdirectory per profile
 	* @param oldProfiles List of names of old profiles
@@ -65,26 +66,26 @@
 		super();
     	resizable =  false;
 		int w=MyLocale.getScreenWidth();
+		if (w&gt;240) w=240;
 		int h=MyLocale.getScreenHeight();
-		if (w&gt;240) w=240;
 		if (h&gt;320) h=320;
 		setPreferredSize(w,h);
-	    defaultTags.set(CellConstants.INSETS,new Insets(2,2,2,2));		
+	    defaultTags.set(CellConstants.TAG_INSETS,new Insets(2,2,2,2));
 		title = MyLocale.getMsg(1301,&quot;Select Profile:&quot;);
 		if (hasNewButton) {
-			addNext(new mLabel(MyLocale.getMsg(1106,&quot;Choose profile or New&quot;)),DONTSTRETCH,DONTSTRETCH|LEFT);
-			addLast(btnNew=new mButton(MyLocale.getMsg(1107,&quot;New&quot;)),HSTRETCH,HFILL|RIGHT);
+			addNext(new Label(MyLocale.getMsg(1106,&quot;Choose profile or New&quot;)),DONTSTRETCH,DONTSTRETCH|LEFT);
+			addLast(btnNew=new Button(MyLocale.getMsg(1107,&quot;New&quot;)),HSTRETCH,HFILL|RIGHT);
 		} else {
-			addLast(new mLabel(MyLocale.getMsg(1108,&quot;Choose profile&quot;)),DONTSTRETCH,DONTSTRETCH|LEFT);
+			addLast(new Label(MyLocale.getMsg(1108,&quot;Choose profile&quot;)),DONTSTRETCH,DONTSTRETCH|LEFT);
 		}
-		
+
 		choice=new MyList();
 		// Get all subdirectories in the base directory
-		File fileBaseDir=new FileBugfix(baseDir);
-		String[] existingProfiles=fileBaseDir.list(&quot;*.*&quot;,FileBase.LIST_DIRECTORIES_ONLY);
+		File fileBaseDir=new File(baseDir);
+		String[] existingProfiles=fileBaseDir.list(&quot;*.*&quot;,File.LIST_DIRECTORIES_ONLY);
         // Now add these subdirectories to the list of profiles but
         // exclude the &quot;maps&quot; directory which will contain the moving maps
-        for (int i=0; i&lt;existingProfiles.length; i++) 
+        for (int i=0; i&lt;existingProfiles.length; i++)
 			if (!existingProfiles[i].equals(&quot;maps&quot;)) choice.addItem(existingProfiles[i]);
         // Highlight the profile that was used last
         choice.selectLastProfile(selectedProfile);
@@ -93,15 +94,15 @@
 		spMList.setOptions(ScrollablePanel.NeverShowHorizontalScrollers);
 		choice.setServer(spMList);
 		addLast(spMList);
-		addNext(btnCancel = new mButton(MyLocale.getMsg(1604,&quot;Cancel&quot;)),DONTSTRETCH,DONTFILL|LEFT);
-		addNext(btnOK = new mButton(MyLocale.getMsg(1605,&quot;OK&quot;)),DONTSTRETCH,HFILL|RIGHT);
+		addNext(btnCancel = new Button(MyLocale.getMsg(1604,&quot;Cancel&quot;)),DONTSTRETCH,DONTFILL|LEFT);
+		addNext(btnOK = new Button(MyLocale.getMsg(1605,&quot;OK&quot;)),DONTSTRETCH,HFILL|RIGHT);
 		if (choice.getListItems().length==0) btnOK.modify(Disabled,0);
 		btnOK.setHotKey(0, IKeys.ENTER);
 		btnCancel.setHotKey(0, IKeys.ESCAPE);
 		this.baseDir=baseDir;
-		choice.takeFocus(ControlConstants.ByKeyboard);
+		choice.takeFocus(Control.ByKeyboard);
 	}
-	
+
 	/**
 	 * Ask for a new profile directory. If it exists, cancel. If it does not exist, create it
 	 * @return Name of directory (just the part below baseDir)
@@ -109,10 +110,10 @@
 	public String createNewProfile() {
 		NewProfileForm f=new NewProfileForm(baseDir);
 	    int code=f.execute(getFrame(), Gui.CENTER_FRAME);
-		if (code==0) { 
+		if (code==0) {
 			 return f.profileDir;
-		} else
-			 return &quot;&quot;;
+		}
+		return &quot;&quot;;
 	}
 
 	/**

Modified: experiments/engywuck/hist-test/src/cachewolf/RadarPanel.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/RadarPanel.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/RadarPanel.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,95 +1,96 @@
-package CacheWolf;
-import ewe.ui.*;
-import ewe.util.*;
-import ewe.fx.*;
-import ewe.graphics.*;
+package cachewolf;
+import eve.ui.Button;
+import eve.ui.Panel;
+import eve.ui.CellPanel;
+import eve.ui.CellConstants;
+import eve.ui.List;
+import eve.ui.DragContext;
+import eve.ui.Gui;
+import eve.ui.Control;
+import java.util.Vector;
+import eve.fx.Color;
+import eve.fx.Dimension;
+import eve.fx.Font;
+import eve.fx.FontMetrics;
+import eve.fx.Image;
+import eve.fx.Graphics;
+import eve.fx.Picture;
+import eve.fx.Rect;
+import eve.fx.Point;
 
+import eve.fx.IconAndText;
+import eve.sys.Event;
+import eve.sys.Vm;
+import eve.sys.Device;
+import eve.ui.game.AniImage;
+import eve.ui.game.ImageDragContext;
+import eve.ui.game.InteractivePanel;
+import eve.ui.event.ControlEvent;
+import eve.ui.event.PenEvent;
+
 /**
 *	The radar panel. Displays the caches around a centre point.&lt;br&gt;
 *	Handles scaling as well as toggling the different views in the radar panel.&lt;br&gt;
 *	Also handles clicking on a cache.&lt;br&gt;
-*	Class ID=500
 */
 public class RadarPanel extends CellPanel{
-	mButton btMinus = new mButton(&quot;   -   &quot;);
-	mButton btToggle = new mButton(&quot;Toggle&quot;);
-	mButton btPlus = new mButton(&quot;   +   &quot;);
-	int toggleMod = 0; //0 = cacheicons, 1= cacheWP, 2 = cacheNames
-	Preferences pref;
-	Vector cacheDB;
-	myInteractivePanel iActP;
-	double scale;
-	int scaleKm = 30;
-	int centerX, centerY;
-	int height, width;
-	String selectedWaypoint = new String();
-	MainTab mt;
-	boolean penMoving = false;
-	int x1,y1,x2,y2 = 0;
-	boolean reCenterImage=true;
+	private Button btMinus = new Button(&quot;   -   &quot;);
+	private Button btToggle = new Button(&quot;Toggle&quot;);
+	private Button btPlus = new Button(&quot;   +   &quot;);
+	private int toggleMod = 0; //0 = cacheicons, 1= cacheWP, 2 = cacheNames
+	private Vector cacheDB;
+	private InterActiveRadarPanel iActP;
+	private double scale;
+	private int scaleKm = 30;
+	private int centerX, centerY;
+	private int height, width;
+	private static Color RED=new Color(255,0,0);
+	private static Color GREEN=new Color(0,255,0);
+	private static Color BLUE=new Color(0,0,255);
+	private static Color YELLOW=new Color(255,255,0);
+	private AniImage circle=null;
+	/** Flag to indicate that the background and all caches needs to be redrawn */
+	private static boolean redrawCaches=true;
 	/**
 	* Constructor for the radar panel.
 	* Loads images, sets up the interactive panel and
 	* &quot;navigation&quot; buttons.
 	*/
 	public RadarPanel(){
-		this.addLast(iActP = new myInteractivePanel(), CellConstants.STRETCH, CellConstants.FILL);
-		CellPanel cp = new CellPanel();
+		this.addLast(iActP = new InterActiveRadarPanel(), CellConstants.STRETCH, CellConstants.FILL);
+		Panel cp = new Panel();
+		cp.stretchFirstRow=true;
+		cp.equalWidths=true;
 		cp.addNext(btMinus,CellConstants.HSTRETCH, (CellConstants.FILL|CellConstants.WEST));
 		cp.addNext(btToggle,CellConstants.HSTRETCH, CellConstants.FILL);
 		cp.addLast(btPlus,CellConstants.HSTRETCH, (CellConstants.FILL|CellConstants.EAST));
 		this.addLast(cp, CellConstants.HSTRETCH, CellConstants.FILL);
+		clearRadarPanel();
+		cacheDB=Global.getProfile().cacheDB;
 	}
 	
-	public void setMainTab(MainTab tb){
-		mt = tb;
-		iActP.setMainTab(tb);
+	public void clearRadarPanel() {
+		int anz = iActP.images.size();
+		for(int i = 0; i&lt;anz;i++){
+			iActP.removeImage((AniImage)iActP.images.get(0));
+		}
+		drawBackground();
+		iActP.refresh();
+		redrawCaches=true;
 	}
 	
 	/**
-	* Informs the radar panel on preferences and currently loaded cache
-	* database. It also calculates the maximum size available for drawing 
-	* the radar.
-	*/
-	public void setParam(Preferences p, Vector db, String sWp){
-		selectedWaypoint = sWp;
-		pref = p;
-		cacheDB = db;
-		height = (pref.myAppHeight)*6/5; // add 10% each at top/bottom 
-		//height = (int)height * 2;
-		////Vm.debug(&quot;Height: &quot; + Convert.toString(height));
-		////Vm.debug(&quot;App Height: &quot; + Convert.toString(pref.myAppHeight));
-		width = (pref.myAppWidth)*6/5;
-		//width = (int)width * 2;
-	}
-	
-	// Call this after the centre has changed to re-center the radar panel
-	public void recenterRadar() {
-		reCenterImage=true;
-	}
-	
-	/**
 	* Public method to draw the different caches and the
 	* radar background
 	*/
-	public void drawThePanel(){
+	public void drawCachesAndCircle(){
 		// If there are any images remove them!
-		int anz = iActP.images.size();
-		for(int i = 0; i&lt;anz;i++){
-			iActP.removeImage((AniImage)iActP.images.get(0));
+		if (redrawCaches) {
+			drawCaches();
+			redrawCaches=false;
 		}
-		iActP.refresh();
-		drawBackground();
-		drawCaches();
+		drawCircle();
 		iActP.repaintNow();
-		if (reCenterImage) {
-			// Hack to scroll to left origin for a defined position for subsequent
-			// scroll which centers the image
-			iActP.scroll(-1000,-1000); 
-			Dimension dispSize=getDisplayedSize(null);
-			iActP.scroll((width-dispSize.width)/2,(height-dispSize.height+btMinus.getSize(null).height)/2);
-			reCenterImage=false;
-		}
 	}
 	
 	/**
@@ -101,22 +102,22 @@
 		AniImage aImg;
 		RadarPanelImage rpi;
 		int x,y = 0;
-		CacheHolder holder;
+		CacheHolder ch;
 		double degrees;
 		double pi180=java.lang.Math.PI / 180.0;
 		for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
-			holder = (CacheHolder)cacheDB.get(i);
-			if(!holder.is_filtered &amp;&amp; holder.pos.isValid()) {
-				degrees = holder.degrees * pi180;
-				x =new Float(holder.kilom/scale *  java.lang.Math.sin(degrees)).intValue();
-				y = -new Float(holder.kilom/scale *  java.lang.Math.cos(degrees)).intValue();
+			ch = (CacheHolder)cacheDB.get(i);
+			if(!ch.is_filtered &amp;&amp; ch.pos.isValid()) {
+				degrees = ch.degrees * pi180;
+				x = (int) (ch.kilom/scale *  java.lang.Math.sin(degrees));
+				y = -(int)(ch.kilom/scale *  java.lang.Math.cos(degrees));
 				if(centerX+x&gt;=0 &amp;&amp; centerY+y&gt;=0 &amp;&amp; centerX+x&lt;=width &amp;&amp; centerY+y &lt;= height){
 					if (toggleMod&gt;0) {
 						String s;
 						if (toggleMod==1)
-							s=holder.wayPoint;
+							s=ch.wayPoint;
 						else
-							s=holder.CacheName;
+							s=ch.cacheName;
 						if (s.length()&gt;0) { 
 							int tw;
 							Image img = new Image(tw=fm.getTextWidth(s),fm.getHeight());
@@ -126,45 +127,58 @@
 							g.fillRect(0,0,tw, fm.getHeight());
 							g.setColor(Color.White);
 							g.drawText(s, 0,0);
-							aImg = new AniImage(img);
+							aImg = new AniImage(img,Color.Black);
 							aImg.setLocation(centerX+x+5,centerY+y);
-							aImg.transparentColor = Color.Black;
-							aImg.properties = mImage.IsNotHot;
+							aImg.properties = eve.fx.Drawing.IsNotHot;
 							iActP.addImage(aImg);
 						}
 					}
-					Image imgCache=CacheType.cache2Img(holder.type);
+					Picture imgCache=CacheType.cache2Img(ch.type);
 					// If we have no image for the cache type use a question mark
-					if (imgCache==null) imgCache=CacheType.cacheImages[8]; 
+					if (imgCache==null) imgCache=CacheType.cachePictures[8]; 
 					rpi = new RadarPanelImage(imgCache);
-					rpi.wayPoint = holder.wayPoint;
+					rpi.wayPoint = ch.wayPoint;
 					rpi.rownum = i;
 					rpi.setLocation(centerX+x-7,centerY+y-7);
 					iActP.addImage(rpi);
-					if(holder.wayPoint.equals(selectedWaypoint)){ // Draw red circle around selected wpt
-						Image imgCircle = new Image(20, 20);
-						Graphics gCircle = new Graphics(imgCircle);
-						gCircle.setColor(Color.Black);
-						gCircle.fillRect(0,0,20,20);
-						gCircle.setColor(new Color(255,0,0));
-						gCircle.drawEllipse(0,0, 20,20);
-						aImg = new AniImage(imgCircle);
-						aImg.setLocation(centerX+x-9,centerY+y-9);
-						aImg.transparentColor = new Color(0,0,0);
-						aImg.properties = mImage.IsNotHot;
-						iActP.addImage(aImg);
-					}
 				}//if center...
 			}// if is_black...
 		}
 	}
 	
+	public void removeCircle() {
+		if (circle!=null) iActP.removeImage(circle);
+		circle=null; 
+	}
+	
+	private void drawCircle() {
+		removeCircle();
+		double pi180=java.lang.Math.PI / 180.0;
+		CacheHolder ch = (CacheHolder)cacheDB.get(Global.mainTab.tbP.getSelectedCache());
+		if(!ch.is_filtered &amp;&amp; ch.pos.isValid()) {
+			double degrees = ch.degrees * pi180;
+			int x = (int) (ch.kilom/scale *  java.lang.Math.sin(degrees));
+			int y = -(int)(ch.kilom/scale *  java.lang.Math.cos(degrees));
+			Image imgCircle = new Image(20, 20);
+			Graphics gCircle = new Graphics(imgCircle);
+			gCircle.setColor(Color.Black);
+			gCircle.fillRect(0,0,20,20);
+			gCircle.setColor(RED);
+			gCircle.drawEllipse(0,0, 19,19);
+			circle = new AniImage(imgCircle,Color.Black);
+			circle.properties = eve.fx.Drawing.IsNotHot;
+			circle.setLocation(centerX+x-9,centerY+y-9);
+			iActP.addImage(circle); 
+		}
+	}
 	/**
 	* Private method to draw the black background and green radar.
 	* Also calculates some other parameters.
 	* Always call this before calling drawCaches().
 	*/
 	private void drawBackground(){
+		width=MyLocale.getScreenWidth();
+		height=MyLocale.getScreenHeight();
 		Rect r = new Rect(new Dimension(width, height));
 		iActP.virtualSize = r;
 		iActP.refresh();
@@ -180,18 +194,18 @@
 		} else {
 			scale = (double)scaleKm / (double)width;
 		}
-		centerX = (width / 2);
-		centerY = (height / 2);
+		centerX = width / 2;
+		centerY = height / 2;
 		//centerY = (int)(centerY-centerY*0.15);
-		g.setColor(new Color(0,255,0));
+		g.setColor(GREEN);
 		int radstep= 0, steps=0, radius = 0;
 		
 		if(width &gt; height){
 			radstep = (int)(10 / scale);
-			steps = (width / radstep);
+			steps = width / radstep;
 		}else{
 			radstep = (int)(10 / scale);
-			steps = (height / radstep);
+			steps = height / radstep;
 		}
 		for(int i = 1; i &lt;= steps; i++){
 			radius = (radstep * i)*2;
@@ -203,16 +217,13 @@
 
 		// Show 1 KM radius only if we have zoomed in (useful for cities with high density of caches)
 		if (scaleKm&lt;=20) {
-			g.setColor(new Color(255,255,0)); // Yellow for 1km circle
+			g.setColor(YELLOW); // Yellow for 1km circle
 			radius = radstep/5;
 			g.drawEllipse(centerX-radius/2,centerY-radius/2, radius,radius);
 			g.free();
 		}	
 		AniImage aImg = new AniImage(img);
-		//iActP.addImage(aImg);
 		iActP.backgroundImage = img;
-		int xPos = (pref.myAppWidth/2 - width/2);
-		aImg.setLocation(xPos,0);
 		aImg.refresh();
 	}
 	
@@ -223,21 +234,238 @@
 				else if (scaleKm==10) scaleKm=5;
 				else if (scaleKm==5) scaleKm=2;
 				else scaleKm=1;
-				drawThePanel();
+				clearRadarPanel();
+				drawCachesAndCircle();
 			}
 			if (ev.target == btMinus){
 				if (scaleKm==1) scaleKm=2;
 				else if(scaleKm==2) scaleKm=5;
 				else if(scaleKm==5) scaleKm=10;
 				else scaleKm = scaleKm + 10;
-				drawThePanel();
+				clearRadarPanel();
+				drawCachesAndCircle();
 			}
 			if (ev.target == btToggle){
 				toggleMod++;
 				if(toggleMod &gt; 2) toggleMod = 0;
-				drawThePanel();
+				clearRadarPanel();
+				drawCachesAndCircle();
 			}
 		}
 
 	}
+	
+	public void resizeTo(int width, int height) {
+		eve.sys.Vm.debug(&quot;RadarP: resize: &quot;+width+&quot;,&quot;+height);
+		iActP.origin.x=(MyLocale.getScreenWidth()-width)/2;
+		iActP.origin.y=(MyLocale.getScreenHeight()- height)/2;
+		repaint();
+		super.resizeTo(width, height);
+	}
+
+//################################################################################
+//   InteractiveRadarPanel
+//################################################################################
+	
+	/**
+	*	This class allows handling of a user click on a cache
+	*	in the radar panel.
+	*	@see RadarPanel
+	*/
+	private static class InterActiveRadarPanel extends InteractivePanel{
+		Font font = new Font(&quot;gui&quot;, Font.BOLD,Global.getPref().fontSize);
+		FontMetrics fm = getFontMetrics(font);
+		long timePenOn=0;
+		AniImage imgInfo;
+		String strDifficulty=MyLocale.getMsg(1120,&quot;Diff&quot;);
+		String strTerrain=MyLocale.getMsg(1121,&quot;Terr&quot;);
+		AniImage imgDrag; // Allows the dragging of the cache into the cachelist
+		boolean canScroll=true;
+		
+		private void clearInfo() {
+			removeImage(imgInfo);
+			imgInfo=null;
+			refresh();
+			onImage=null;
+		}
+		
+		public void imageClicked(AniImage which, Point pos){
+			long timePenOff=Vm.getTimeStampLong();
+			// If the pen rested more than 500 msec, we only display the info and don't treat it as a click
+			if (timePenOff-timePenOn&lt;500 || !Device.isMobile()) { 
+				if(which instanceof RadarPanelImage){
+					RadarPanelImage ich = (RadarPanelImage)which;
+					Global.mainTab.clearDetails();
+					Global.mainTab.selectAndActive(ich.rownum);
+				}
+			} else {
+				if (imgInfo!=null) clearInfo(); 
+			}
+		}
+		
+		public boolean imageMovedOn(AniImage which) {
+			timePenOn=Vm.getTimeStampLong();
+			setFont(font);
+			RadarPanelImage imgRP=(RadarPanelImage) which;
+			java.util.Vector cacheDB=Global.getProfile().cacheDB;
+			CacheHolder ch=(CacheHolder) cacheDB.get(imgRP.rownum);
+			String s=ch.wayPoint+&quot;  &quot;+ch.getCacheSize()+&quot; / &quot;+strDifficulty+&quot;=&quot;+ch.hard+&quot;  &quot;+strTerrain+&quot;=&quot;+ch.terrain;
+			String s1=ch.cacheName;
+			if (s1.length()&gt;40) s1=s1.substring(0,40);
+			int tw=fm.getTextWidth(s)+2;
+			int tw1=fm.getTextWidth(s1)+2;
+			if (tw1&gt;tw) tw=tw1;
+			int h=fm.getHeight();
+			Image img = new Image(tw,h+h);
+			Graphics g = new Graphics(img);
+			g.setFont(font);
+			g.setColor(BLUE);
+			g.fillRect(0,0,tw, h+h);
+			g.setColor(Color.White);
+			g.drawText(s, 1,1);
+			g.drawText(s1,1,h);
+			imgInfo = new AniImage(img);
+			Rect r=getVisibleArea(null);
+			imgInfo.setLocation(r.x,r.y); // Place the info at top left corner
+			imgInfo.properties = eve.fx.Drawing.IsNotHot;
+			addImage(imgInfo);
+			refreshOnScreen(imgInfo);
+			imgDrag=which;
+		return true;
+		}
+		
+		public boolean imageMovedOff(AniImage which) {
+			clearInfo();
+			return true;
+		}
+		
+		public void onPenEvent(PenEvent ev) {
+			super.onPenEvent(ev);
+			if (ev.type==PenEvent.PEN_UP) {
+				clearInfo();
+				// The next line is needed due to a bug in eve (it does not call penReleased)
+				if (isDragging) penReleased(new Point(ev.x,ev.y));
+			}
+		}
+		
+	    ///////////////////////////////////////////////////
+		//  Allow the caches to be dragged into a cachelist
+	    ///////////////////////////////////////////////////
+		
+		String wayPoint;
+		
+		public void startDragging(DragContext dc) {
+			if (!Global.mainForm.cacheListVisible) return;
+			Vector cacheDB=Global.getProfile().cacheDB;
+	//Vm.debug(&quot;myIAP startDrag &quot;+dc.start.x+&quot;/&quot;+dc.start.y);
+			int idx=Global.getProfile().getCacheIndex(wayPoint); 
+			if (idx&gt;=0) {
+				 CacheHolder ch=(CacheHolder) cacheDB.get(idx);
+				 //wayPoint=ch.wayPoint;
+				 //Vm.debug(&quot;Waypoint : &quot;+ch.wayPoint);
+				 IconAndText icnDrag=new IconAndText();
+				 icnDrag.addColumn( CacheType.cache2Img(ch.type));
+				 icnDrag.addColumn(ch.wayPoint);
+				 dc.dragData=dc.startImageDrag(icnDrag,new Point(8,8),this);
+				 //if (dc instanceof ImageDragContext) Vm.debug(&quot;&gt;&gt;&gt;&gt;Is Image drag&quot;);
+				 canScroll=false;
+			}
+		 }
+
+		 public void stopDragging(DragContext dc) {		 
+			canScroll=true;
+		 }
+		 public void draggingStarted(ImageDragContext dc) {}
+		 public void draggingStopped(ImageDragContext dc) {}
+		 
+		 public boolean imageBeginDragged(AniImage which,Point pos) {
+			if (!Global.mainForm.cacheListVisible) return false;
+			canScroll=false;
+			clearInfo();
+			wayPoint=null;
+			AniImage dragImage=null;
+			if (which instanceof RadarPanelImage) {
+				RadarPanelImage imgRP=(RadarPanelImage) which;
+				java.util.Vector cacheDB=Global.getProfile().cacheDB;
+				CacheHolder ch=(CacheHolder) cacheDB.get(imgRP.rownum);
+				wayPoint=ch.wayPoint;
+				
+				int tw,th;
+				Image img = new Image(tw=fm.getTextWidth(wayPoint)+17,th=fm.getHeight()&gt;15?fm.getHeight():15);
+				Graphics g = new Graphics(img);
+				g.setFont(font);
+				g.setColor(Color.White);
+				g.fillRect(0,0,tw, th);
+				g.setColor(RED);
+				g.drawText(wayPoint, 15,1);
+				which.draw(g,0,0,0);
+				dragImage=new AniImage(img);
+				dragImage.properties|=AniImage.IsMoveable;
+				dragImage.setLocation(pos.x,pos.y);
+			}
+			return super.imageBeginDragged(dragImage,pos);
+		 }
+
+		 public boolean imageDragged(ImageDragContext drag, Point pos) {
+			 	if (drag.image!=null) {
+	/*			    Point p = Gui.getPosInParent(this,getWindow());
+				 	p.x += pos.x-origin.x;
+				 	p.y += pos.y-origin.y;
+				 	Control c = getWindow().findChild(p.x,p.y);
+	*/
+					drag.clearPendingDrags();
+			 	}
+			 	return super.imageDragged(drag,pos);
+		 }
+		 
+		 public boolean imageNotDragged(ImageDragContext drag, Point pos) {
+			if (drag.image!=null) {
+				images.remove(drag.image);
+				drag.image=null;
+				refresh();
+			}			
+			 Point p = Gui.getPosInParent(this,getWindow(),null);
+			 p.x += drag.curPoint.x-origin.x;
+			 p.y += drag.curPoint.y-origin.y;
+			 Control c = getWindow().findChild(p.x,p.y);
+		     if (c instanceof List &amp;&amp; c.text.equals(&quot;CacheList&quot;)) {
+		    	 if (Global.mainForm.cacheList.addCache(wayPoint)) {
+		    		 c.repaintNow();
+		    		 ((List) c).makeItemVisible(((List)c).itemsSize()-1);
+		    	 }
+		     }
+			 return false; 
+		 }
+		 
+		 public boolean canScreenScroll() {
+			 return canScroll;
+		 }
+		 public boolean scroll(int dx,int dy,Point moved) {
+			 if (canScroll)
+				 return super.scroll(dx,dy,moved);
+			 return false;
+		 }
+	}
+
+//################################################################################
+//  RadarPanelImage
+//################################################################################
+
+	/**
+	* The ImagePanelImage extends AniImage by a fileName.
+	* This is an easy way to identify the image clicked,
+	* what is needed to display the full image from the
+	* thumbnail.
+	*/
+	public class RadarPanelImage extends AniImage{
+		public String wayPoint = &quot;&quot;;
+		public int rownum;
+		
+		public RadarPanelImage(Picture i){
+			super(i);
+		}
+	}
+	
+	
+
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/RebuildIndex.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/RebuildIndex.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/RebuildIndex.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,16 +1,14 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.io.FileReader;
-import ewe.sys.Handle;
-import ewe.ui.FormBase;
-import ewe.ui.MessageBox;
-import ewe.ui.ProgressBarForm;
-import utils.FileBugfix;
+import eve.io.File;
+import eve.sys.Handle;
+import eve.ui.MessageBox;
+import eve.ui.ProgressBarForm;
 
-public class Rebuild {
+public class RebuildIndex {
 	String [] xmlFiles;
 	
-	public Rebuild() {}
+	public RebuildIndex() {}
 	
 	public void rebuild() {	
 		int i;
@@ -21,7 +19,7 @@
 		pbf.setTask(h,MyLocale.getMsg(209,&quot;Rebuilding index&quot;));
 		pbf.exec();
 
-		FileBugfix file=new FileBugfix(Global.getProfile().dataDir);
+		eve.io.File file=new eve.io.File(Global.getProfile().dataDir);
 		xmlFiles=file.list(&quot;*.xml&quot;,0);
 		int orphans=0; // xml Files without entry in database
 		int nAdded=0;  // caches added to database
@@ -33,7 +31,7 @@
 				prof.getCacheIndex(wayPoint)&gt;=0)		// Check for waypoints already in database 
 				xmlFiles[i]=null;   				// Remove existing caches or index.xml
 			else {
-				//ewe.sys.Vm.debug(&quot;Orphan: &quot;+wayPoint);
+				//eve.sys.Vm.debug(&quot;Orphan: &quot;+wayPoint);
 				orphans++;
 			}
 		}
@@ -57,13 +55,13 @@
 			(new MessageBox(MyLocale.getMsg(327, &quot;Information&quot;), 
 					  MyLocale.getMsg(210,&quot;Caches nicht in index.xml: &quot;)+orphans+
 					  MyLocale.getMsg(211,&quot;\nDavon hinzugef&#252;gt: &quot;)+nAdded
-					, FormBase.OKB)).execute();
+					, MessageBox.OKB)).execute();
 			prof.buildReferences();
-			prof.saveIndex(Global.getPref(),true);
+			prof.saveIndex(true);
 		}
 		if (orphans!=nAdded &amp;&amp; (new MessageBox(MyLocale.getMsg(327, &quot;Information&quot;),
 					MyLocale.getMsg(212,&quot;Delete all .xml files not in index.xml and associated pictures&quot;), 
-					FormBase.YESB | FormBase.NOB)).execute()==FormBase.YESB) {
+					MessageBox.YESB | MessageBox.NOB)).execute()==MessageBox.YESB) {
 			h = new Handle();
 			pbf.setTask(h,MyLocale.getMsg(213,&quot;Deleting orphans&quot;));
 			DataMover dm=new DataMover();
@@ -82,9 +80,12 @@
 
 	private String getCacheDetails(String xmlFile) {
 		try {
-			FileReader in = new FileReader(xmlFile);
-			String text= in.readAll();
+			char buf[]=new char[(int) (new File(xmlFile)).getLength()];
+			java.io.InputStreamReader in = new java.io.InputStreamReader(new java.io.FileInputStream(xmlFile),&quot;UTF8&quot;);
+			int len=in.read(buf);
 			in.close();
+			eve.util.CharArray ca=new eve.util.CharArray(buf); ca.setLength(len);
+			String text=(ca).toString();
 			int start,end;
 			// Check that we have not accidentally listed another xml file in the directory
 			if (text.indexOf(&quot;&lt;CACHEDETAILS&gt;&quot;)&lt;0 || (start=text.indexOf(&quot;&lt;CACHE &quot;))&lt;0) return null;

Modified: experiments/engywuck/hist-test/src/cachewolf/SearchCache.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/SearchCache.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/SearchCache.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,5 +1,5 @@
-package CacheWolf;
-import ewe.util.*;
+package cachewolf;
+import java.util.*;
 
 /**
 *	A class to perform a search on the cache database.
@@ -34,12 +34,12 @@
 				ch = (CacheHolder)cacheDB.get(i);
 				if (ch.is_filtered) break; // Reached end of visible records
 				if(ch.wayPoint.toUpperCase().indexOf(searchStr) &lt;0 &amp;&amp; 
-				   ch.CacheName.toUpperCase().indexOf(searchStr) &lt;0 &amp;&amp; 
-				   ch.CacheStatus.toUpperCase().indexOf(searchStr)&lt;0){
-					ch.is_flaged = false;
+				   ch.cacheName.toUpperCase().indexOf(searchStr) &lt;0 &amp;&amp; 
+				   ch.cacheStatus.toUpperCase().indexOf(searchStr)&lt;0){
+					ch.is_flagged = false;
 					ch.is_filtered = true;
 				} else
-					ch.is_flaged=true;
+					ch.is_flagged=true;
 			} // for
 		     Global.mainTab.tbP.selectRow(0);
 		} // if
@@ -53,7 +53,7 @@
 		Global.getProfile().selectionChanged = true;
 		for(int i = cacheDB.size()-1;i &gt;=0;i--){
 			CacheHolder ch=((CacheHolder)cacheDB.get(i));
-			ch.is_flaged=false;
+			ch.is_flagged=false;
 			ch.is_filtered=(ch.is_black^Global.getProfile().showBlacklisted) ;
 		}
 		//Global.getProfile().filterActive=Filter.filterActive; //TODO This is a hack. Need to tidy this up

Modified: experiments/engywuck/hist-test/src/cachewolf/ShowCacheInBrowser.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/ShowCacheInBrowser.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/ShowCacheInBrowser.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,28 +1,33 @@
-package CacheWolf;
-import utils.CWWrapper;
+package cachewolf;
+import cachewolf.utils.Common;
+import cachewolf.utils.STRreplace;
 
-import com.stevesoft.ewe_pat.Regex;
+import com.stevesoft.eve_pat.Regex;
 
-import ewe.io.BufferedWriter;
-import ewe.io.FileBase;
-import ewe.io.FileWriter;
-import ewe.io.IOException;
-import ewe.io.PrintWriter;
-import ewe.sys.Convert;
-import ewe.sys.Vm;
-import ewe.ui.FormBase;
-import ewe.ui.MessageBox;
-import ewe.util.*;
+import java.io.BufferedWriter;
+import eve.io.File;
+
+import java.io.FileOutputStream;
+import java.io.OutputStreamWriter;
+import java.io.PrintWriter;
+import java.io.IOException;
+import eve.ui.MessageBox;
+
+import eve.sys.Vm;
+import java.util.*;
+
+
 import HTML.Template;
+import eve.ui.Form;
 
 
 public class ShowCacheInBrowser {
-	String pd=FileBase.getProgramDirectory();
+	String pd=File.getProgramDirectory();
 	String saveTo=pd+&quot;/temp.html&quot;;
 	static Hashtable diff=null;
 	static Hashtable terr=null;
 	static Hashtable args=null;
-	
+
 	ShowCacheInBrowser() {
 		if (diff==null) {
 			diff=new Hashtable(15);
@@ -37,7 +42,7 @@
 			diff.put(&quot;4&quot;,y+y+y+y);
 			diff.put(&quot;4.5&quot;,y+y+y+y+y2);
 			diff.put(&quot;5&quot;,y+y+y+y+y);
-	
+
 			terr=new Hashtable(15);
 			String g=&quot;&lt;img src=\&quot;<A HREF="file://">file://</A>&quot; + pd + &quot;/g.png\&quot; border=0&gt;&quot;;
 			String g2=&quot;&lt;img src=\&quot;<A HREF="file://">file://</A>&quot; + pd + &quot;/g2.png\&quot; border=0&gt;&quot;;
@@ -50,7 +55,7 @@
 			terr.put(&quot;4&quot;,g+g+g+g);
 			terr.put(&quot;4.5&quot;,g+g+g+g+g2);
 			terr.put(&quot;5&quot;,g+g+g+g+g);
-			
+
 			args = new Hashtable();
 			args.put(&quot;filename&quot;, pd+&quot;/GCTemplate.html&quot;);
 			args.put(&quot;case_sensitive&quot;, &quot;true&quot;);
@@ -58,22 +63,22 @@
 			args.put(&quot;max_includes&quot;, new Integer(5));
 		}
 	}
-	
+
 	public void showCache(CacheHolderDetail chD) {
 		if (chD == null) return;
 		try {
 			Template tpl = new Template(args);
 			if(!chD.is_filtered){
-				Vm.showWait(true);
+				Form.showWait();
 				try {
 					if (chD.wayPoint.startsWith(&quot;OC&quot;))
-						tpl.setParam(&quot;TYPE&quot;, &quot;\&quot;<A HREF="file://">file://</A>&quot;+FileBase.getProgramDirectory()+&quot;/&quot;+CacheType.transOCType(chD.type)+&quot;.gif\&quot;&quot;);
-					else	
-						tpl.setParam(&quot;TYPE&quot;, &quot;\&quot;<A HREF="file://">file://</A>&quot;+FileBase.getProgramDirectory()+&quot;/&quot;+chD.type+&quot;.gif\&quot;&quot;);
-					tpl.setParam(&quot;SIZE&quot;, chD.CacheSize);
+						tpl.setParam(&quot;TYPE&quot;, &quot;\&quot;<A HREF="file://">file://</A>&quot;+File.getProgramDirectory()+&quot;/&quot;+CacheType.transOCType(chD.type)+&quot;.gif\&quot;&quot;);
+					else
+						tpl.setParam(&quot;TYPE&quot;, &quot;\&quot;<A HREF="file://">file://</A>&quot;+File.getProgramDirectory()+&quot;/&quot;+chD.type+&quot;.gif\&quot;&quot;);
+					tpl.setParam(&quot;SIZE&quot;, chD.getCacheSize());
 					tpl.setParam(&quot;WAYPOINT&quot;, chD.wayPoint);
-					tpl.setParam(&quot;CACHE_NAME&quot;, chD.CacheName);
-					tpl.setParam(&quot;OWNER&quot;, chD.CacheOwner);
+					tpl.setParam(&quot;CACHE_NAME&quot;, chD.cacheName);
+					tpl.setParam(&quot;OWNER&quot;, chD.cacheOwner);
 					if (chD.hard.endsWith(&quot;.0&quot;)) chD.hard=chD.hard.substring(0,chD.hard.length()-2);
 					tpl.setParam(&quot;DIFFICULTY&quot;, (String) diff.get(chD.hard.replace(',','.')));
 					if (chD.terrain.endsWith(&quot;.0&quot;)) chD.terrain=chD.terrain.substring(0,chD.terrain.length()-2);
@@ -81,16 +86,16 @@
 					tpl.setParam(&quot;DISTANCE&quot;, chD.distance.replace(',','.'));
 					tpl.setParam(&quot;BEARING&quot;, chD.bearing);
 					if (chD.pos!=null &amp;&amp; chD.pos.isValid()) {
-						tpl.setParam(&quot;LATLON&quot;, chD.LatLon);
+						tpl.setParam(&quot;LATLON&quot;, chD.latLon);
 					} else {
 						tpl.setParam(&quot;LATLON&quot;, &quot;unknown&quot;);
 					}
 					// If status is of format yyyy-mm-dd prefix it with a &quot;Found&quot; message in local language
-					if (chD.CacheStatus.length()&gt;=10 &amp;&amp; chD.CacheStatus.charAt(4)=='-')
-						tpl.setParam(&quot;STATUS&quot;,MyLocale.getMsg(318,&quot;Found&quot;)+&quot; &quot;+chD.CacheStatus);
+					if (chD.cacheStatus.length()&gt;=10 &amp;&amp; chD.cacheStatus.charAt(4)=='-')
+						tpl.setParam(&quot;STATUS&quot;,MyLocale.getMsg(318,&quot;Found&quot;)+&quot; &quot;+chD.cacheStatus);
 					else
-						tpl.setParam(&quot;STATUS&quot;, chD.CacheStatus);
-					
+						tpl.setParam(&quot;STATUS&quot;, chD.cacheStatus);
+
 					// Cache attributes
 					if (chD.attributes.getCount()&gt;0) {
 						Vector attVect=new Vector(chD.attributes.getCount()+1);
@@ -99,7 +104,7 @@
 							atts.put(&quot;IMAGE&quot;,&quot;&lt;img src=\&quot;<A HREF="file://">file://</A>&quot;+
 									   Attribute.getImageDir()+chD.attributes.getName(i)+
 									   &quot;\&quot; border=0 alt=\&quot;&quot;+chD.attributes.getInfo(i)+&quot;\&quot;&gt;&quot;);
-							if (i % 5 ==4) 
+							if (i % 5 ==4)
 								atts.put(&quot;BR&quot;,&quot;&lt;br/&gt;&quot;);
 							else
 								atts.put(&quot;BR&quot;,&quot;&quot;);
@@ -108,51 +113,51 @@
 						}
 						tpl.setParam(&quot;ATTRIBUTES&quot;,attVect);
 					}
-					
-					tpl.setParam(&quot;DATE&quot;, chD.DateHidden);
+
+					tpl.setParam(&quot;DATE&quot;, chD.dateHidden);
 					tpl.setParam(&quot;URL&quot;, chD.URL);
-					if (chD.Travelbugs.size()&gt;0) tpl.setParam(&quot;BUGS&quot;,chD.Travelbugs.toHtml());
-					if (chD.CacheNotes!=null &amp;&amp; chD.CacheNotes.trim().length()&gt;0) tpl.setParam(&quot;NOTES&quot;, STRreplace.replace(chD.CacheNotes,&quot;\n&quot;,&quot;&lt;br/&gt;\n&quot;));
-					if (chD.Solver!=null &amp;&amp; chD.Solver.trim().length()&gt;0) tpl.setParam(&quot;SOLVER&quot;, STRreplace.replace(chD.Solver,&quot;\n&quot;,&quot;&lt;br/&gt;\n&quot;));
+					if (chD.travelbugs.size()&gt;0) tpl.setParam(&quot;BUGS&quot;,chD.travelbugs.toHtml());
+					if (chD.cacheNotes!=null &amp;&amp; chD.cacheNotes.trim().length()&gt;0) tpl.setParam(&quot;NOTES&quot;, STRreplace.replace(chD.cacheNotes,&quot;\n&quot;,&quot;&lt;br/&gt;\n&quot;));
+					if (chD.solver!=null &amp;&amp; chD.solver.trim().length()&gt;0) tpl.setParam(&quot;SOLVER&quot;, STRreplace.replace(chD.solver,&quot;\n&quot;,&quot;&lt;br/&gt;\n&quot;));
 					// Look for images
-					
-					StringBuffer s=new StringBuffer(chD.LongDescription.length());
+
+					StringBuffer s=new StringBuffer(chD.longDescription.length());
 					int start=0;
 					int pos;
 					int imageNo=0;
 					Regex imgRex = new Regex(&quot;src=(?:\\s*[^\&quot;|']*?)(?:\&quot;|')(.*?)(?:\&quot;|')&quot;);
-					while (start&gt;=0 &amp;&amp; (pos=chD.LongDescription.indexOf(&quot;&lt;img&quot;,start))&gt;0) {
-						if (imageNo &gt;= chD.Images.getCount())break;
-						s.append(chD.LongDescription.substring(start,pos));
-						imgRex.searchFrom(chD.LongDescription,pos);
+					while (start&gt;=0 &amp;&amp; (pos=chD.longDescription.indexOf(&quot;&lt;img&quot;,start))&gt;0) {
+						if (imageNo &gt;= chD.images.size())break;
+						s.append(chD.longDescription.substring(start,pos));
+						imgRex.searchFrom(chD.longDescription,pos);
 						String imgUrl=imgRex.stringMatched(1);
 						//Vm.debug(&quot;imgUrl &quot;+imgUrl);
 						if (imgUrl.lastIndexOf('.')&gt;0 &amp;&amp; imgUrl.toLowerCase().startsWith(&quot;http&quot;)) {
 							String imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).substring(0,4).trim();
 							// If we have an image which we stored when spidering, we can display it
-        					if(imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)){
+							if(imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)){
 								s.append(&quot;&lt;img src=\&quot;<A HREF="file://">file://</A>&quot;+
-								   Global.getProfile().dataDir+chD.Images.get(imageNo)+&quot;\&quot;&gt;&quot;);
+								   Global.getProfile().dataDir+chD.images.get(imageNo)+&quot;\&quot;&gt;&quot;);
 								imageNo++;
 							}
 						}
-						start=chD.LongDescription.indexOf(&quot;&gt;&quot;,pos);
+						start=chD.longDescription.indexOf(&quot;&gt;&quot;,pos);
 						if (start&gt;=0) start++;
 					}
-					if (start&gt;=0) s.append(chD.LongDescription.substring(start));
+					if (start&gt;=0) s.append(chD.longDescription.substring(start));
 					tpl.setParam(&quot;DESCRIPTION&quot;, s.toString());
-					
+
 					// Do the remaining pictures which are not included in main body of text
 					// They will be hidden initially and can be displayed by clicking on a link
-					if (imageNo&lt;chD.Images.size()) {
-						Vector imageVect=new Vector(chD.Images.size()-imageNo);
-						for (; imageNo&lt;chD.Images.size(); imageNo++) {
+					if (imageNo&lt;chD.images.size()) {
+						Vector imageVect=new Vector(chD.images.size()-imageNo);
+						for (; imageNo&lt;chD.images.size(); imageNo++) {
 							Hashtable imgs=new Hashtable();
 							imgs.put(&quot;IMAGE&quot;,&quot;&lt;img src=\&quot;<A HREF="file://">file://</A>&quot;+
-									   Global.getProfile().dataDir+chD.Images.get(imageNo)+&quot;\&quot; border=0&gt;&quot;);
-							imgs.put(&quot;IMAGETEXT&quot;,chD.ImagesText.get(imageNo));
-							if (imageNo&lt;chD.ImagesInfo.size() &amp;&amp; chD.ImagesInfo.get(imageNo)!=null)
-								imgs.put(&quot;IMAGECOMMENT&quot;,chD.ImagesInfo.get(imageNo));
+									   Global.getProfile().dataDir+chD.images.get(imageNo)+&quot;\&quot; border=0&gt;&quot;);
+							imgs.put(&quot;IMAGETEXT&quot;,chD.imagesText.get(imageNo));
+							if (imageNo&lt;chD.imagesInfo.size() &amp;&amp; chD.imagesInfo.get(imageNo)!=null)
+								imgs.put(&quot;IMAGECOMMENT&quot;,chD.imagesInfo.get(imageNo));
 							else
 								imgs.put(&quot;IMAGECOMMENT&quot;,&quot;&quot;);
 							imgs.put(&quot;I&quot;,&quot;'img&quot;+new Integer(imageNo).toString()+&quot;'&quot;);
@@ -160,17 +165,17 @@
 						}
 						tpl.setParam(&quot;IMAGES&quot;,imageVect);
 					}
-					
-					Vector logVect=new Vector(chD.CacheLogs.size());
-					for (int i=0; i&lt;chD.CacheLogs.size(); i++) {
+
+					Vector logVect=new Vector(chD.cacheLogs.size());
+					for (int i=0; i&lt;chD.cacheLogs.size(); i++) {
 						Hashtable logs=new Hashtable();
-						String log=STRreplace.replace(chD.CacheLogs.getLog(i).toHtml(),&quot;<A HREF="http://www.geocaching.com/images/icons/">http://www.geocaching.com/images/icons/</A>&quot;,&quot;&quot;);
+						String log=STRreplace.replace(chD.cacheLogs.getLog(i).toHtml(),&quot;<A HREF="http://www.geocaching.com/images/icons/">http://www.geocaching.com/images/icons/</A>&quot;,&quot;&quot;);
 						int posGt=log.indexOf('&gt;'); // Find the icon which defines the type of log
 						if (posGt&lt;0) {
 							logs.put(&quot;LOG&quot;,log);
 							logs.put(&quot;LOGTYPE&quot;,&quot;&quot;);
 						} else {
-							int posBr=log.indexOf(&quot;&lt;br&gt;&quot;); 
+							int posBr=log.indexOf(&quot;&lt;br&gt;&quot;);
 							if(posBr&lt;0) {
 								logs.put(&quot;LOG&quot;,log);
 								logs.put(&quot;LOGTYPE&quot;,&quot;&quot;);
@@ -184,20 +189,20 @@
 					}
 					tpl.setParam(&quot;LOGS&quot;,logVect);
 					if (!chD.is_available) tpl.setParam(&quot;UNAVAILABLE&quot;,&quot;1&quot;);
-					if (!chD.Hints.equals(&quot;null&quot;))tpl.setParam(&quot;HINT&quot;,Common.rot13(chD.Hints));
-					
+					if (!chD.hints.equals(&quot;null&quot;))tpl.setParam(&quot;HINT&quot;,Common.rot13(chD.hints));
+
 					if (chD.hasAddiWpt()) {
 						Vector addiVect=new Vector(chD.addiWpts.size());
 						for (int i=0; i&lt;chD.addiWpts.size(); i++) {
 							Hashtable addis=new Hashtable();
 							CacheHolder ch=(CacheHolder) chD.addiWpts.get(i);
 							addis.put(&quot;WAYPOINT&quot;,ch.wayPoint);
-							addis.put(&quot;NAME&quot;,ch.CacheName);
-							addis.put(&quot;LATLON&quot;,ch.LatLon);
-							addis.put(&quot;IMG&quot;,&quot;&lt;img src=\&quot;&quot;+CacheType.type2pic(Convert.parseInt(ch.type))+&quot;\&quot;&gt;&quot;);
+							addis.put(&quot;NAME&quot;,ch.cacheName);
+							addis.put(&quot;LATLON&quot;,ch.latLon);
+							addis.put(&quot;IMG&quot;,&quot;&lt;img src=\&quot;&quot;+CacheType.type2pic(ch.type)+&quot;\&quot;&gt;&quot;);
 							CacheHolderDetail chDA=new CacheHolderDetail(ch);
 							chDA.readCache(Global.getProfile().dataDir);
-							addis.put(&quot;LONGDESC&quot;,chDA.LongDescription); // Do we need to treat longDesc as above ?
+							addis.put(&quot;LONGDESC&quot;,chDA.longDescription); // Do we need to treat longDesc as above ?
 							addiVect.add(addis);
 						}
 						tpl.setParam(&quot;ADDIS&quot;,addiVect);
@@ -208,27 +213,29 @@
 					e.printStackTrace();
 				}
 			}
-			PrintWriter detfile; 
-			FileWriter fw = new FileWriter(saveTo);
-			detfile = new PrintWriter(new BufferedWriter(fw));
+			PrintWriter detfile;
+	        detfile = new PrintWriter(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(saveTo), &quot;UTF8&quot;)));
 			tpl.printTo(detfile);
 			//detfile.print(tpl.output());
 			detfile.close();
 			try {
-				CWWrapper.exec(Global.getPref().browser, &quot;<A HREF="file://">file://</A>&quot;+saveTo); // maybe this works on some PDAs?
+				String s = &quot;\&quot;&quot;+Global.getPref().browser+&quot;\&quot; \&quot;<A HREF="file://">file://</A>&quot;+saveTo+&quot;\&quot;&quot;;
+
+				Vm.execCommandLine(s); //Global.getPref().browser+&quot; \&quot;file:&quot;+saveTo+&quot;\&quot;&quot;);
+				Global.getPref().log(&quot;Executing: &quot;+s); //Global.getPref().browser+&quot; \&quot;&quot;+saveTo+&quot;\&quot;&quot;);
 			} catch (IOException ex) {
 				(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),
-						MyLocale.getMsg(1034,&quot;Cannot start browser!&quot;) + &quot;\n&quot; + ex.toString() + &quot;\n&quot; +
-						MyLocale.getMsg(1035,&quot;Possible reason:&quot;) + &quot;\n&quot; +
-						MyLocale.getMsg(1036,&quot;A bug in ewe VM, please be&quot;) + &quot;\n&quot; +
-						MyLocale.getMsg(1037,&quot;patient for an update&quot;),FormBase.OKB)).execute();
+					MyLocale.getMsg(1034,&quot;Cannot start browser!&quot;) + &quot;\n&quot; + ex.toString() + &quot;\n&quot; +
+					MyLocale.getMsg(1035,&quot;Possible reason:&quot;) + &quot;\n&quot; +
+					MyLocale.getMsg(1036,&quot;A bug in ewe VM, please be&quot;) + &quot;\n&quot; +
+					MyLocale.getMsg(1037,&quot;patient for an update&quot;),Form.OKB)).execute();
 			}
-			
+
 		} catch(Exception e) {
 			e.printStackTrace();
 			Global.getPref().log(&quot;Error in ShowCache &quot;+e.toString());
 		} finally {
-			Vm.showWait(false);
+			Form.cancelWait();
 		}
 	}
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/SolverPanel.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/SolverPanel.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/SolverPanel.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,10 +1,14 @@
-package CacheWolf;
+package cachewolf;
 
 
-import ewe.ui.*;
-import ewe.io.*;
-import ewe.fx.*;
-import ewe.util.*;
+import eve.ui.*;
+import eve.io.*;
+import eve.fx.*;
+import java.util.*;
+import eve.sys.*;
+import eve.ui.data.InputBox;
+import eve.ui.event.ControlEvent;
+import eve.ui.event.DataChangeEvent;
 
 /**
 * Class to create the solver panel. Calls the parser and tokeniser and handles
@@ -13,19 +17,16 @@
 *	@see Tokenizer
 */
 public class SolverPanel extends CellPanel{
-	mButton mBtSolve;
-	mButton btnLoad, btnSave, btnSaveAs,btnWolfLang;
-	mTextPad mText;
-	OutputPanel mOutput;
-	Preferences pref;
-	Profile profile;
-	String currFile;
-	Tokenizer tokeniser = new Tokenizer();
-	Parser parser = new Parser();
-	Vector msgFIFO = new Vector();
-	Menu mnuContext;
+	public TextPad mText; // Accessed by Parser error
+	private Button mBtSolve;
+	//private Button btnLoad, btnSave, btnSaveAs;
+	private Button btnWolfLang;
+	private OutputPanel mOutput;
+	private Parser parser = null; // Lazy initialisation to speed up loading
+	private Vector msgFIFO = null; // Lazy initialisation to speed up loading
+	private Menu mnuContext;
 	private String originalInstructions=&quot;&quot;;
-	mButton btnDegRad; 
+	private Button btnDegRad; 
 	
 	public boolean isDirty() {
 		return !originalInstructions.equals(getInstructions());
@@ -40,41 +41,12 @@
 		mText.repaint();
 	}
 	
-	
-	private class OutputPanel extends mTextPad {
-		MenuItem mnuClr;
-		OutputPanel() {
-			this.modify(ControlConstants.NotEditable,0);
-			//this.modifiers=this.modifiers|WantHoldDown; 
-			setMenu(mnuContext=getClipboardMenu(new Menu(new MenuItem[]{ mnuClr=new MenuItem(MyLocale.getMsg(1734,&quot;Clear output&quot;)) },&quot;&quot;)));
-		} 
-		public void penRightReleased(Point p){
-			setMenu(mnuContext);
-			doShowMenu(p); // direct call (not through doMenu) is neccesary because it will exclude the whole table
-		}
-		public void penHeld(Point p){
-			setMenu(mnuContext);
-			doShowMenu(p);
-		}
-		public void popupMenuEvent(Object selectedItem){
-			if (selectedItem==mnuClr) 
-				this.setText(&quot;&quot;);
-			else 
-				super.popupMenuEvent(selectedItem);
-		}
+	public void clearOutput() {
+		mOutput.setText(&quot;&quot;);
 	}
-	private class InputPanel extends mTextPad {
-
-		public void  penDoubleClicked(Point where) {
-			execDirectCommand();
-		}
-	}
-	private class InpScreen extends InputBox {
-		InpScreen(String title) {super(title); }
-		String getInput() { return getInputValue();}
-	}
-	CellPanel programPanel, outputPanel;
 	
+	Panel programPanel, outputPanel;
+	
 	private String getSolverDegMode() {
 		return Global.getPref().solverDegMode ? &quot;DEG&quot; : &quot;RAD&quot;;
 	}
@@ -84,32 +56,29 @@
 		btnDegRad.repaint();
 	}
 	
-	public SolverPanel (Preferences p, Profile prof){
-		pref = p;
-		profile = prof;
+	public SolverPanel (){
 		SplittablePanel split = new SplittablePanel(PanelSplitter.VERTICAL);
 
 		programPanel = split.getNextPanel();
 		outputPanel = split.getNextPanel();
 		split.setSplitter(PanelSplitter.AFTER|PanelSplitter.HIDDEN,PanelSplitter.BEFORE|PanelSplitter.HIDDEN,0);
 
-		programPanel.addLast(new MyScrollBarPanel(mText = new InputPanel())).setTag(SPAN, new Dimension(2,1));
-		CellPanel pnlStatButtons=new CellPanel();
-		pnlStatButtons.addNext(btnDegRad=new mButton(getSolverDegMode()),CellConstants.DONTSTRETCH,CellConstants.DONTFILL);
+		programPanel.addLast(new MyScrollBarPanel(mText = new InputPanel())).setTag(TAG_SPAN, new Dimension(2,1));
+		Panel pnlStatButtons=new Panel();
+		pnlStatButtons.addNext(btnDegRad=new Button(getSolverDegMode()),CellConstants.DONTSTRETCH,CellConstants.DONTFILL);
 		btnDegRad.backGround=Color.Sand;
 		btnDegRad.borderStyle=btnDegRad.borderWidth=0;
-		CellPanel pnlButtons=new CellPanel();
-		pnlButtons.addNext(mBtSolve= new mButton(MyLocale.getMsg(1735,&quot;Solve!&quot;)),CellConstants.HSTRETCH, CellConstants.HFILL);
-		pnlButtons.addLast(btnWolfLang= new mButton(MyLocale.getMsg(118,&quot;WolfLanguage&quot;)),CellConstants.HSTRETCH, CellConstants.HFILL);
+		Panel pnlButtons=new Panel();
+		pnlButtons.addNext(mBtSolve= new Button(MyLocale.getMsg(1735,&quot;Solve!&quot;)),CellConstants.HSTRETCH, CellConstants.HFILL);
+		pnlButtons.addLast(btnWolfLang= new Button(MyLocale.getMsg(118,&quot;WolfLanguage&quot;)),CellConstants.HSTRETCH, CellConstants.HFILL);
 		pnlButtons.equalWidths=true;
 		pnlStatButtons.addLast(pnlButtons,CellConstants.HSTRETCH,CellConstants.HFILL);
 		programPanel.addLast(pnlStatButtons,HSTRETCH,HFILL);
-		/*programPanel.addNext(btnLoad= new mButton(MyLocale.getMsg(1736,&quot;Load&quot;)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		programPanel.addNext(btnSave= new mButton(MyLocale.getMsg(1737,&quot;Save&quot;)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		programPanel.addLast(btnSaveAs= new mButton(MyLocale.getMsg(1738,&quot;SaveAs&quot;)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		/*programPanel.addNext(btnLoad= new Button(MyLocale.getMsg(1736,&quot;Load&quot;)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		programPanel.addNext(btnSave= new Button(MyLocale.getMsg(1737,&quot;Save&quot;)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		programPanel.addLast(btnSaveAs= new Button(MyLocale.getMsg(1738,&quot;SaveAs&quot;)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		*/
 		outputPanel.addLast(new MyScrollBarPanel(mOutput = new OutputPanel()));
-
 		this.addLast(split);
 	}
 	
@@ -122,9 +91,12 @@
 	}
 	
     private void processCommand(String s) {
-		msgFIFO.clear();
-		tokeniser.tokenizeSource(s, msgFIFO); // Tokeniser sets message if an error occurred
-		if (msgFIFO.size()==0) parser.parse(tokeniser.TokenStack, msgFIFO);
+		if (parser==null) {
+			parser=new Parser(); // Lazy initialisation
+			msgFIFO=new Vector();
+		} else
+			msgFIFO.clear();
+		parser.parse(s, msgFIFO);
 		String msgStr = &quot;&quot;;
 		for(int i = 0; i &lt; msgFIFO.size(); i++){
 			msgStr = msgStr + msgFIFO.get(i) + &quot;\n&quot;;
@@ -139,7 +111,7 @@
 				processCommand(mText.getText());
 			}
 			if (ev.target==btnWolfLang) {
-				InfoScreen is = new InfoScreen(FileBase.getProgramDirectory() + &quot;/&quot; + &quot;wolflang.html&quot;, MyLocale.getMsg(118,&quot;WolfLanguage&quot;), true, pref);
+				InfoHtmlScreen is = new InfoHtmlScreen(File.getProgramDirectory() + &quot;/&quot; + &quot;wolflang.html&quot;, MyLocale.getMsg(118,&quot;WolfLanguage&quot;), true);
 				is.execute(parent.getFrame(), Gui.CENTER_FRAME);
 			}
 			if (ev.target==btnDegRad) {
@@ -194,5 +166,52 @@
 */			
 		}
 	}
+
+//############################################################################
+//  InputScreen	
+//############################################################################
+
+	private class InpScreen extends InputBox {
+		InpScreen(String title) {super(title); }
+		String getInput() { return getInputValue();}
+	}
+
+//############################################################################
+//  InputPanel	
+//############################################################################
 	
+	private class InputPanel extends TextPad {
+
+		public void  penDoubleClicked(Point where) {
+			execDirectCommand();
+		}
+	}
+	
+//############################################################################
+//  OutputPanel	
+//############################################################################
+	private class OutputPanel extends TextPad {
+		MenuItem mnuClr;
+		OutputPanel() {
+			this.modify(Control.NotEditable,0);
+			//this.modifiers=this.modifiers|WantHoldDown; 
+			setMenu(mnuContext=getClipboardMenu(new Menu(new MenuItem[]{ mnuClr=new MenuItem(MyLocale.getMsg(1734,&quot;Clear output&quot;)) },&quot;&quot;)));
+		} 
+		public void penRightReleased(Point p){
+			setMenu(mnuContext);
+			doShowMenu(p); // direct call (not through doMenu) is neccesary because it will exclude the whole table
+		}
+		public void penHeld(Point p){
+			setMenu(mnuContext);
+			doShowMenu(p);
+		}
+		public void popupMenuEvent(Object selectedItem){
+			if (selectedItem==mnuClr) 
+				this.setText(&quot;&quot;);
+			else 
+				super.popupMenuEvent(selectedItem);
+		}
+	}
+	
+	
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/StatusBar.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/StatusBar.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/StatusBar.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,81 +1,81 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.sys.Vm;
-import ewe.ui.*;
-import ewe.util.*;
-import ewe.fx.*;
+import eve.ui.*;
+import eve.sys.Event;
+import java.util.*;
+import eve.sys.Device;
+import eve.fx.*;
+import eve.ui.event.ControlEvent;
 
 /**
- * Class ID = 4500
  * @author Marc Schnitzler
  *
  */
 public class StatusBar extends CellPanel{
-	DBStats stats;
-	mLabel disp,lblFlt,lblCenter;
-	Preferences pref;
-	mButton btnFlt;
-	mImage imgFlt;
-	mButton btnCacheTour;
-	mImage imgCacheTour;
-	boolean MobileVGA;
-	
-	public StatusBar(Preferences p, Vector db){
-		pref=p;
+	private DBStats stats=new DBStats();
+	private StringBuffer sb=new StringBuffer(100);
+	private Label disp,lblCenter;
+	private Button btnFlt;
+	private Button btnCacheTour;
+	boolean mobileVGA;
+	private Color BLUE=new Color(0,0,255);
+	private Color GREEN=new Color(0,255,0);
+	private Color TURQUOISE=new Color(0,255,255);
+
+	public StatusBar(){
 		int sw = MyLocale.getScreenWidth();
-		MobileVGA = (Vm.isMobile() &amp;&amp; sw &gt;= 400);
+		mobileVGA = (Device.isMobile() &amp;&amp; sw &gt;= 400);
 		String imagesize=&quot;&quot;;
-		if(MobileVGA) imagesize=&quot;_vga&quot;;  
-		addNext(btnCacheTour=new mButton(imgCacheTour=new mImage(&quot;cachetour&quot;+imagesize+&quot;.png&quot;)),CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		imgCacheTour.transparentColor=Color.White;
-		if(MobileVGA)
+		if(mobileVGA) imagesize=&quot;_vga&quot;;
+		addNext(btnCacheTour=new Button(new Picture(&quot;cachetour&quot;+imagesize+&quot;.png&quot;,Color.White,0)),CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		btnCacheTour.setPreferredSize(20,13); btnCacheTour.borderWidth=0;
+		btnCacheTour.setToolTip(MyLocale.getMsg(197,&quot;Show/Hide cachetour&quot;));
+		if(mobileVGA)
 			btnCacheTour.setPreferredSize(28,20);
 		else
 			btnCacheTour.setPreferredSize(20,13);
-		btnCacheTour.borderWidth=0; 
-		btnCacheTour.setToolTip(MyLocale.getMsg(197,&quot;Show/Hide cachetour&quot;));
-		addNext(btnFlt= new mButton(imgFlt=new mImage(&quot;filter&quot; + imagesize + &quot;.png&quot;)),CellConstants.DONTSTRETCH, CellConstants.DONTFILL); 
-		btnFlt.backGround=new ewe.fx.Color(0,255,0); 
-		if(MobileVGA)
+		addNext(btnFlt= new Button(new Picture(&quot;filter&quot;+imagesize+&quot;.png&quot;,Color.White,0)),CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		btnFlt.backGround=new eve.fx.Color(0,255,0);
+		btnFlt.setPreferredSize(20,13);
+		btnFlt.borderWidth=0;
+		btnFlt.setToolTip(&quot;Filter status&quot;);
+		if(mobileVGA)
 			btnFlt.setPreferredSize(28,20);
 		else
 			btnFlt.setPreferredSize(20,13);
-		btnFlt.borderWidth=0; imgFlt.transparentColor=Color.White;
-		btnFlt.setToolTip(&quot;Filter status&quot;);
-//		addNext(lblFlt= new mLabel(&quot;Flt&quot;),CellConstants.DONTSTRETCH, CellConstants.DONTFILL); lblFlt.backGround=new ewe.fx.Color(0,255,0);
-		stats = new DBStats(db);
-		addNext(disp = new mLabel(&quot;&quot;),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		addNext(disp = new Label(&quot;&quot;),CellConstants.DONTSTRETCH, CellConstants.FILL);
 		disp.setToolTip(MyLocale.getMsg(196,&quot;Total # of caches (GC&amp;OC)\nTotal # visible\nTotal # found&quot;));
-		addLast(lblCenter=new mLabel(&quot;&quot;),CellConstants.STRETCH, WEST|CellConstants.FILL);
+		addLast(lblCenter=new Label(&quot;&quot;),CellConstants.STRETCH, WEST|CellConstants.FILL);
 		lblCenter.setToolTip(MyLocale.getMsg(195,&quot;Current centre&quot;));
 		updateDisplay();
 	}
-	
+
 	public void updateDisplay(){
-		String strStatus, strCenter=&quot;&quot;;
-		strStatus = MyLocale.getMsg(4500,&quot;Tot:&quot;) + &quot; &quot; + stats.total() + &quot; &quot; +
-					MyLocale.getMsg(4501,&quot;Dsp:&quot;) + &quot; &quot; + stats.visible() + &quot; &quot; +
-					MyLocale.getMsg(4502,&quot;Fnd:&quot;) + &quot; &quot; + stats.totalFound() + &quot;  &quot;;
-		disp.setText(strStatus);
+		String strCenter=&quot;&quot;;
+		sb.delete(0,100);
+		sb.append(MyLocale.getMsg(4500,&quot;Tot:&quot;)).append(&quot; &quot;).append(stats.total()).append(&quot; &quot;).
+					append(MyLocale.getMsg(4501,&quot;Dsp:&quot;)).append(&quot; &quot;).append(stats.visible()).append(&quot; &quot;).
+					append(MyLocale.getMsg(4502,&quot;Fnd:&quot;)).append(&quot; &quot;).append(stats.totalFound()).append(&quot;  &quot;);
+		disp.setText(sb.toString());
 		// Indicate that a filter is active in the status line
 		if (Global.getProfile().filterActive==Filter.FILTER_ACTIVE)
-			btnFlt.backGround=new Color(0,255,0);
+			btnFlt.backGround=GREEN;
 		else if (Global.getProfile().filterActive==Filter.FILTER_CACHELIST)
-			btnFlt.backGround=new Color(0,0,255);
+			btnFlt.backGround=BLUE;
 		else if (Global.getProfile().filterActive==Filter.FILTER_MARKED_ONLY)
-			btnFlt.backGround=new Color(0,255,255);
+			btnFlt.backGround=TURQUOISE;
 		else
 			btnFlt.backGround=null;
 		// Current centre can only be displayed if screen is big
 		// Otherwise it forces a scrollbar
 		// This can happen even on bigger screens with big fonts
-		if ((MyLocale.getScreenWidth()&gt;=320) &amp;&amp; !(MobileVGA &amp;&amp; (pref.fontSize &gt; 20))) 
-			strCenter=&quot;  \u00a4 &quot; + pref.curCentrePt.toString();
-		
+		if ((MyLocale.getScreenWidth()&gt;=320) &amp;&amp; !(mobileVGA &amp;&amp; (Global.getPref().fontSize &gt; 20)))
+			strCenter=&quot;  \u00a4 &quot; + Global.getPref().curCentrePt.toString();
+
 		lblCenter.setText(strCenter);
 		relayout(true); // in case the numbers increased and need more space
 	}
-	
+
 	public void onEvent(Event ev) {
 		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
 			if (ev.target == btnFlt){
@@ -89,10 +89,75 @@
 				Global.mainTab.tbP.refreshTable();
 			}
 			if (ev.target == btnCacheTour){
-				Global.mainForm.toggleCacheListVisible();			
+				Global.mainForm.toggleCacheListVisible();
 			}
-			Gui.takeFocus(Global.mainTab.tbP.tc, ControlConstants.ByKeyboard);
+			Gui.takeFocus(Global.mainTab.tbP.tControl, Control.ByKeyboard);
 		}
 		super.onEvent(ev);
 	}
+
+//################################################################################
+//  DBStats
+//################################################################################
+
+	/**
+	 * @author Marc
+	 * Use this class to obtain statistics or information on a cache database.
+	 */
+	private class DBStats {
+		Vector cacheDB;
+
+		public DBStats(){
+			cacheDB = Global.getProfile().cacheDB;
+		}
+
+		/**
+		 * Method to get the number of caches displayed in the list.
+		 * It will count waypoints only that start with
+		 * GC,or
+		 * OC
+		 * @return
+		 */
+		public int visible(){
+			CacheHolder ch;
+			int counter = 0;
+			for(int i = cacheDB.size()-1;i&gt;=0; i--){
+				ch = (CacheHolder)cacheDB.get(i);
+				if(ch.is_black == false &amp;&amp; ch.is_filtered == false){
+					if(ch.wayPoint.startsWith(&quot;GC&quot;) || ch.wayPoint.startsWith(&quot;OC&quot;)) counter++;
+				}
+			}
+			return counter;
+		}
+
+		/**
+		 * Method to get the number of caches available for display
+		 * @return
+		 */
+		public int total(){
+			CacheHolder ch;
+			int counter = 0;
+			for(int i = cacheDB.size()-1;i&gt;=0; i--){
+				ch = (CacheHolder)cacheDB.get(i);
+				if(ch.is_black == false){
+					if(ch.wayPoint.startsWith(&quot;GC&quot;) || ch.wayPoint.startsWith(&quot;OC&quot;)) counter++;
+				}
+			}
+			return counter;
+		}
+
+		public int totalFound(){
+			CacheHolder ch;
+			int counter = 0;
+			for(int i = cacheDB.size()-1;i&gt;=0; i--){
+				ch = (CacheHolder)cacheDB.get(i);
+				if(ch.is_found == true) {
+					if(ch.wayPoint.startsWith(&quot;GC&quot;) || ch.wayPoint.startsWith(&quot;OC&quot;)) counter++;
+				}
+			}
+			return counter;
+		}
+	}
+
+
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/TableColumnChooser.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/TableColumnChooser.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/TableColumnChooser.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,15 +1,24 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.fx.*;
-import ewe.ui.*;
-import ewe.util.*;
+import eve.fx.*;
+import eve.ui.*;
+import java.util.*;
 
+import cachewolf.utils.Common;
+
+
+import eve.ui.List;
+import eve.ui.event.ControlEvent;
+import eve.ui.event.ListEvent;
+import eve.sys.Event;
+
+
 public class TableColumnChooser extends CellPanel {
 
 	String [] colNames;
 	Vector shownCols=new Vector(20);
 	Vector hiddenCols=new Vector(20);
-	private mButton btnDown,btnUp,btnLeft,btnRight;
+	private Button btnDown,btnUp,btnLeft,btnRight;
 	private myList lstShown,lstHidden;
 	
 	/**
@@ -19,30 +28,30 @@
 	 */
 	public TableColumnChooser(String [] colNames, String selectedCols) {
         this.colNames=colNames;
-		addNext(new mLabel(MyLocale.getMsg(6050,&quot;Show column&quot;)));
-        addNext(new mLabel(&quot;&quot;));
-        addLast(new mLabel(MyLocale.getMsg(6051,&quot;Don't show column&quot;)));
+		addNext(new Label(MyLocale.getMsg(6050,&quot;Show column&quot;)));
+        addNext(new Label(&quot;&quot;));
+        addLast(new Label(MyLocale.getMsg(6051,&quot;Don't show column&quot;)));
         
-        addNext(new MyScrollBarPanel(lstShown=new myList(6,shownCols),ScrollablePanel.AlwaysShowVerticalScrollers));
+        addNext(new MyScrollBarPanel(lstShown=new myList(6,shownCols),ScrollBarPanel.AlwaysShowVerticalScrollers));
         CellPanel cpMid=new CellPanel();
-        cpMid.addLast(new mLabel(&quot;&quot;));
-        mImage imgRight=new mImage(&quot;ewe/rightarrowsmall.bmp&quot;);imgRight.transparentColor=Color.White;
-        mImage imgLeft=new mImage(&quot;ewe/leftarrowsmall.bmp&quot;);imgLeft.transparentColor=Color.White;
-        cpMid.addLast(btnRight=new mButton(imgRight));
-        cpMid.addLast(new mLabel(&quot;&quot;));
-        cpMid.addLast(btnLeft=new mButton(imgLeft));
-        cpMid.addLast(new mLabel(&quot;&quot;));
+        cpMid.addLast(new Label(&quot;&quot;));
+        Picture imgRight=new Picture(&quot;eve/rightarrowsmall.png&quot;);//TODO imgRight.transparentColor=Color.White;
+        Picture imgLeft=new Picture(&quot;eve/leftarrowsmall.png&quot;);//TODO imgLeft.transparentColor=Color.White;
+        cpMid.addLast(btnRight=new Button(imgRight));
+        cpMid.addLast(new Label(&quot;&quot;));
+        cpMid.addLast(btnLeft=new Button(imgLeft));
+        cpMid.addLast(new Label(&quot;&quot;));
         addNext(cpMid,VSTRETCH,VFILL);
-        addLast(new MyScrollBarPanel(lstHidden=new myList(6,hiddenCols),ScrollablePanel.AlwaysShowVerticalScrollers));
+        addLast(new MyScrollBarPanel(lstHidden=new myList(6,hiddenCols),ScrollBarPanel.AlwaysShowVerticalScrollers));
         
         CellPanel pnlButtons=new CellPanel();
-		mImage imgDown=new mImage(&quot;ewe/downarrowsmall.bmp&quot;); imgDown.transparentColor=Color.White;
-		mImage imgUp=new mImage(&quot;ewe/uparrowsmall.bmp&quot;); imgUp.transparentColor=Color.White;
-        pnlButtons.addNext(btnDown=new mButton(imgDown),HSTRETCH,HFILL); btnDown.modify(Disabled,0);
-		pnlButtons.addLast(btnUp=new mButton(imgUp),HSTRETCH,HFILL); btnUp.modify(Disabled,0);
+		Picture imgDown=new Picture(&quot;eve/downarrowsmall.png&quot;); //TODO imgDown.transparentColor=Color.White;
+		Picture imgUp=new Picture(&quot;eve/uparrowsmall.png&quot;); //TODO imgUp.transparentColor=Color.White;
+        pnlButtons.addNext(btnDown=new Button(imgDown),HSTRETCH,HFILL); btnDown.modify(Disabled,0);
+		pnlButtons.addLast(btnUp=new Button(imgUp),HSTRETCH,HFILL); btnUp.modify(Disabled,0);
         addNext(pnlButtons);
-        addNext(new mLabel(&quot;&quot;));
-        addLast(new mLabel(&quot;&quot;));
+        addNext(new Label(&quot;&quot;));
+        addLast(new Label(&quot;&quot;));
         
         // Set up
         for (int i=0; i&lt;colNames.length; i++) hiddenCols.add(colNames[i]);
@@ -103,7 +112,7 @@
 		super.onEvent(ev);
 	}
 	
-	private class myList extends mList {
+	private class myList extends List {
 
 		//public Vector items;
 		int idx;
@@ -112,6 +121,7 @@
 			super(rows,1,false);
 			//this.items=elements;
 			items=elements;
+			modify(WantDrag,0);
 		}
 
 		// Move selected element down by one
@@ -119,7 +129,7 @@
 			idx=getSelectedIndex(0);
     		if (idx&gt;=0) {
 	    		String s=(String) items.elementAt(idx);
-				items.del(idx);
+				items.removeElementAt(idx);
 	    		items.insertElementAt(s,idx+1);
 	    		select(idx+1);
 	    		repaint();
@@ -131,7 +141,7 @@
 			idx=getSelectedIndex(0);
     		if (idx&gt;=0) {
 				String s=(String) items.elementAt(idx);
-				items.del(idx);
+				items.removeElementAt(idx);
 	    		items.insertElementAt(s,idx-1);
 	    		select(idx-1);
 	    		repaint();
@@ -157,7 +167,7 @@
 		public void stopDragging(DragContext dc) {
 			 if (dc.dragData==null) return;
 			 dc.stopImageDrag(true);
-			 Point p = Gui.getPosInParent(this,getWindow());
+			 Point p = Gui.getPosInParent(this,getWindow(),null);
 			 p.x += dc.curPoint.x;
 			 p.y += dc.curPoint.y;
 			 Control dest = getWindow().findChild(p.x,p.y);
@@ -170,7 +180,7 @@
 		public void moveItem(myList dst, int srcIdx) {
 			 if(srcIdx&lt;0) return;
 	    	 String colToMove=(String) items.elementAt(srcIdx);
-	    	 items.del(srcIdx);
+	    	 items.removeElementAt(srcIdx);
 	    	 dst.items.add(colToMove);
 	    	 repaint();
 	    	 dst.repaint();
@@ -187,7 +197,7 @@
 	 */ 
 	public static int[] str2Array(String configString, int min, int max, int def, int minSize) {
 		Vector strConfigVector=new Vector(18);
-		SubString.split(configString,',',strConfigVector);
+		eve.util.SubString.split(configString,',',strConfigVector);
 		int i;
 		int nElem=strConfigVector.size();
 		int []res=new int[nElem&gt;minSize?nElem:minSize];

Modified: experiments/engywuck/hist-test/src/cachewolf/TableForm.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/TableForm.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/TableForm.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,9 +1,9 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.ui.CellConstants;
-import ewe.ui.Editor;
+import eve.ui.CellConstants;
+import eve.ui.Form;
 
-public class TableForm extends Editor {
+public class TableForm extends Form {
 	public TableForm(TablePanel tp) {
 		if (Global.getPref().menuAtTop) {
 			this.addLast(Global.mainForm.mMenu,CellConstants.DONTSTRETCH, CellConstants.FILL);

Modified: experiments/engywuck/hist-test/src/cachewolf/TablePanel.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/TablePanel.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/TablePanel.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,140 +1,999 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.ui.*;
-import ewe.util.*;
-import ewe.fx.*;
+import eve.sys.Convert;
+import eve.sys.Event;
+import eve.sys.Handle;
+import eve.ui.*;
+import eve.ui.event.KeyEvent;
+import eve.ui.event.PenEvent;
+import eve.ui.table.TableCellAttributes;
+import eve.ui.table.TableControl;
+import eve.ui.table.TableModel;
 
+import java.io.IOException;
+import java.util.*;
+
+import eve.fx.*;
+import eve.fx.gui.IKeys;
+import eve.io.File;
+
 /**
 *	Class to display the cache database in a table.
-*	Class ID = 1000
 */
 public class TablePanel extends CellPanel{
-	
-	myTableControl tc;
-	myTableModel myMod;
-	Preferences pref;
+	private static final Color COLOR_SEARCH		= new Color(255,255,0);
+	private static final Color COLOR_FOUND		= new Color(152,251,152);
+	private static final Color COLOR_OWNED		= new Color(135,206,235);
+	private static final Color COLOR_AVAILABLE	= new Color(255,69,0);
+	private static final Color COLOR_ARCHIVED	= new Color(139,37,0);
+	private static final Color COLOR_SELECTED	= new Color(198,198,198);
+	private static final Color COLOR_ARCHFND_FG	= new Color(255,0,0); // Archived &amp;&amp; Found
+	private static final Color COLOR_ARCHFND_BG	= new Color(152,251,152);
+
+	ListTableControl tControl;
+	ListTableModel tModel;
+
 	Vector cacheDB;
-	MainTab myMaintab;
+	//MainTab myMaintab;
 	StatusBar statBar;
 	/** We keep track of the currently selected cache in two variables(for speed)
 	 * selectedIdx is the index in cacheDB, selectedch is the actual cache
-	 * selectedIdx=-1 if no caches are visible (i.e. database empty or filtered). In 
+	 * selectedIdx=-1 if no caches are visible (i.e. database empty or filtered). In
 	 * this case selectedch is &quot;null&quot;.
 	 * Otherwise selectedIdx points to a visible cache.
 	 * When the cacheDB is reorganised (by sort/filter/search), the selected cache
 	 * may end up at a new index.
 	 */
-	int selectedIdx=0;
-	CacheHolder selectedCh;
-	
-	public TablePanel(Preferences p, Profile profileXX, StatusBar statBar){
-		pref = Global.getPref();
+	//int selectedIdx=0;
+	//CacheHolder selectedCh;
+
+	public TablePanel(StatusBar statBar){
 		Profile profile=Global.getProfile();
 		this.statBar = statBar;
 		cacheDB = profile.cacheDB;
-		addLast(new MyScrollBarPanel(tc = new myTableControl(this)));
+		addLast(new MyScrollBarPanel(tControl = new ListTableControl(this)));
 		if (statBar!=null) addLast(statBar,CellConstants.DONTSTRETCH, CellConstants.FILL);
-		myMod = new myTableModel(tc, getFontMetrics());
-		myMod.hasRowHeaders = false;
-		myMod.hasColumnHeaders  = true;
-		tc.setTableModel(myMod);
+		tModel = new ListTableModel(tControl, getFontMetrics());
+		tModel.hasRowHeaders = false;
+		tModel.hasColumnHeaders  = true;
+		tControl.setTableModel(tModel);
 	}
-	
+
 	/** Mark the row as selected so that myTableModel can color it grey */
 	public void selectRow(int row) {
 		// Ensure that the highlighted row is visible (e.g. when coming from radar panel)
-		// Next line needed for key scrolling 
-		tc.cursorTo(row, 0, true); //tc.cursor.x+tc.listMode
+		// Next line needed for key scrolling
+		tControl.cursorTo(row, 0, true); //tc.cursor.x+tc.listMode
 	}
-	
+
 	/** Highlight the first row in grey. It can be unhighlighted by clicking */
 	public void selectFirstRow() {
-		myMod.cursorSize=new Dimension(-1,1);
+		tModel.cursorSize=new Dimension(-1,1);
 		if (cacheDB.size()&gt;0) {
-			tc.cursorTo(0, 0, true);
+			tControl.cursorTo(0, 0, true);
 		}
 	}
-	
-	/** Returns the index of the currently selected cache or 0 if the cache is no longer visible
+
+	/** Returns the index of the currently selected cache or -1 of the cache is no longer visible
 	 * due to a sort/filter or search operation
-	 * -1 if no cache is visible
-	 * @return index of selected cache (0 if not visible, -1 if no cache is visible)
+	 * @return index of selected cache (-1 if not visible)
 	 */
 	public int getSelectedCache(){
-		if ( myMod.numRows &lt; 1 )
-			return -1;
 		// If the selected Cache is no longer visible (e.g. after applying a filter)
-		// select the first row
-		if (tc.cursor.y&gt;=myMod.numRows)
-			return 0;
-		return tc.cursor.y;
+		// select the last row
+		if (tControl.cursor.y&gt;=tModel.numRows)
+			return tModel.numRows-1;
+		return tControl.cursor.y;
 	}
-	
+
 	public void saveColWidth(Preferences pref){
-		String colWidths=myMod.getColWidths();
+		String colWidths=tModel.getColWidths();
 		if (!colWidths.equals(pref.listColWidth)) {
 			pref.listColWidth=colWidths;
 			pref.savePreferences();
 		}
 	}
-	
+
 	public void resetModel() {
-		myMod.numRows = cacheDB.size();
+		tModel.numRows = cacheDB.size();
 		Global.getProfile().updateBearingDistance();
-		Global.getProfile().restoreFilter(); // Restore the isActive &amp; isInverted status of the filter
-		tc.scrollToVisible(0,0);
+		Global.getProfile().restoreFilter(true); // Restore the isActive &amp; isInverted status of the filter
+		tControl.scrollToVisible(0,0);
 		refreshTable();
 	}
-	
-	/**
-	 * Similar to refreshTable but not so &quot;heavy&quot;.
-	 * Is used when user changes settings in preferences.
-	 */
-	public void refreshControl(){
-		tc.update(true);
-	}
-	
+
 	/** Move all filtered caches to the end of the table and redisplay table */
 	//TODO Add a sort here to restore the sort after a filter
 	public void refreshTable(){
-		
-		// First: Remember currently selected waypoint
 		String wayPoint;
-		Vector oldVisibleCaches = null;
-		int sel = getSelectedCache();
-		if ((sel &gt;= 0) &amp;&amp; (sel &lt; cacheDB.size()) ) // sel &gt; cacheDB.size() can happen if you load a new profile, which is smaller than the old profile and you selected one cache that exceeds the number of caches in the new profile  
-			wayPoint = ((CacheHolder)cacheDB.get(sel)).wayPoint;
+		if (getSelectedCache() &gt;= 0)
+			wayPoint = ((CacheHolder)cacheDB.get(getSelectedCache())).wayPoint;
 		else wayPoint = null;
-		// Then: remember all caches that are visible before the refresh
-		if (wayPoint != null) {
-	        oldVisibleCaches = new Vector(sel);
-	        for (int i = 0; i &lt; sel; i++) {
-		        oldVisibleCaches.add(cacheDB.get(i));
-	        }
-        }
-		myMod.updateRows();
-
+		tControl.clearSelection(null); // otherwise problems when deleting last cache in list
+		Global.mainTab.tbP.updateRows();
 		// Check whether the currently selected cache is still visible
 		int rownum = 0;
 		if (wayPoint != null) {
 			rownum = Global.getProfile().getCacheIndex(wayPoint);
-			if ( (rownum &lt; 0) || (rownum&gt;=myMod.numRows) ) {
-				// If it is not visible: Go backward in the list of the 
-				// previously visible caches and look if you find
-				// any cache that is now still visible.
-				int i;
-				for (i=sel-1; i&gt;=0; i--) {
-					CacheHolder checkCache = (CacheHolder) oldVisibleCaches.get(i);
-					rownum = Global.getProfile().getCacheIndex(checkCache.wayPoint);
-					if ((rownum &gt;= 0) &amp;&amp; (rownum &lt; myMod.numRows)) break;
-					rownum = 0;	
-				}
-			}	
+			if ( (rownum &lt; 0) || (rownum&gt;=tModel.numRows) )
+				rownum = 0;
 		}
+
+		// Check whether the currently selected cache is still visible
 		selectRow(rownum);
-
-		tc.update(true); // Update and repaint
+		tControl.update(true); // Update and repaint
+		Global.mainTab.radarP.clearRadarPanel();
+		Global.mainTab.clearDetails();
 		if (statBar!=null) statBar.updateDisplay();
 	}
-	
-}
+
+	/**
+	 * Similar to refreshTable but not so &quot;heavy&quot;.
+	 * Is used when user changes settings in preferences.
+	 */
+	public void refreshControl(){
+		tControl.update(true);
+	}
+
+	/**
+	 * Moves the addi waypoints just behind their main cache and hides filteres caches
+	 */
+	public void updateRows(){
+		Vector sortDB = new Vector();
+		Vector filteredDB = new Vector();
+		CacheHolder ch, addiWpt;
+		// sort cacheDB:
+		// - addi wpts are listet behind the main cache
+		// - filtered caches are moved to the end
+		int size=cacheDB.size();
+		for (int i=0; i&lt;size; i++){
+			ch = (CacheHolder) cacheDB.get(i);
+			if (ch.is_filtered) {
+				filteredDB.add(ch);
+			} else { // point is not filtered
+				if (ch.isAddiWpt()){ // unfiltered Addi Wpt
+					// check if main wpt is filtered
+					if(ch.mainCache != null) { // parent exists
+						if (ch.mainCache.is_filtered)
+							sortDB.add(ch); // Unfiltered Addi Wpt with filtered Main Wpt, show it on its own
+						// else Main cache is not filtered, Addi will be added below main cache further down
+					} else { //Addi without main Cache
+						sortDB.add(ch);
+					}
+				} else { // Main Wpt, not filtered. Check for Addis
+					sortDB.add(ch);
+					if (ch.hasAddiWpt()){
+						for (int j=0; j&lt;ch.addiWpts.size();j++){
+							addiWpt = (CacheHolder)ch.addiWpts.get(j);
+							if (!addiWpt.is_filtered) sortDB.add(addiWpt);
+						}
+					}// if hasAddiWpt
+				} // if AddiWpt
+			} // if filtered
+		}
+		// rebuild database
+		cacheDB.clear();
+		cacheDB.addAll(sortDB);
+		cacheDB.addAll(filteredDB);
+		tModel.numRows = sortDB.size();
+	}
+
+	/**
+	 * Delete all caches which have been ticked
+	 * @param showProgress Show the progress
+	 */
+	public void deleteSelectedCaches(boolean showProgress) {
+		CacheHolder ch;
+		Profile profile=Global.getProfile();
+		Handle h=null;
+		myProgressBarForm pbf=null;
+		if (showProgress) Form.showWait();
+
+		// Count # of caches to delete
+		int allCount=0;
+		int mainFilteredCount=0;
+		int addiFilteredCount=0;
+		int shouldDeleteCount=0;
+		boolean deleteFiltered=true;  // Bisheriges Verhalten
+		for(int i = cacheDB.size()-1; i &gt;=0; i--){
+			ch = (CacheHolder)cacheDB.get(i);
+			if ( ch.is_Checked) {
+				allCount++;
+				if (ch.is_filtered) {
+					if (ch.isAddiWpt()) {
+						addiFilteredCount++;
+					} else {
+						mainFilteredCount++;
+					}
+				}
+			}
+		}
+		// Warn if there are ticked but invisible caches - and ask if they should be deleted,
+		// too.
+		shouldDeleteCount = allCount;
+		if (addiFilteredCount + mainFilteredCount &gt; 0){
+			if ((new MessageBox(MyLocale.getMsg(144,&quot;Warning&quot;),
+					            MyLocale.getMsg(1029, &quot;There are caches that are ticked but invisible.\n(Main caches: &quot;) +
+					            	mainFilteredCount + MyLocale.getMsg(1030, &quot;, additional Waypoints: &quot;) +
+					            	addiFilteredCount+&quot;)\n&quot; + MyLocale.getMsg(1031, &quot;Delete them, too?&quot;),
+					            	FormBase.YESB | FormBase.NOB)).execute() == FormBase.IDYES) {
+				deleteFiltered = true;
+			} else {
+				deleteFiltered = false;
+				shouldDeleteCount = allCount - mainFilteredCount - addiFilteredCount;
+			}
+		}
+		if (shouldDeleteCount&gt;0) {
+			if ((new MessageBox(MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(1022, &quot;Delete selected caches (&quot;) + shouldDeleteCount + MyLocale.getMsg(1028, &quot;) ?&quot;), FormBase.YESB | FormBase.NOB)).execute() == FormBase.IDYES) {
+				DataMover dm=new DataMover();
+				if (showProgress) {
+					pbf = new myProgressBarForm();
+					h = new Handle();
+					pbf.setTask(h,MyLocale.getMsg(1012, &quot;Delete selected&quot;));
+					pbf.exec();
+				}
+				int nDeleted=0;
+				int size=cacheDB.size();
+				for(int i = size-1; i &gt;=0; i--){// Start Counting down, as the size decreases with each deleted cache
+					ch = (CacheHolder)cacheDB.get(i);
+					if(ch.is_Checked &amp;&amp; (!ch.is_filtered || deleteFiltered)) {
+						nDeleted++;
+						if (showProgress) {
+							h.progress = ((float)nDeleted)/(float)shouldDeleteCount;
+							h.changed();
+						}
+						dm.deleteCacheFiles(ch.wayPoint,profile.dataDir);
+						cacheDB.remove(ch);
+						ch.releaseCacheDetails();
+						ch=null;
+						if (showProgress &amp;&amp; pbf.isClosed) break;
+					}
+				}
+				if (showProgress) pbf.exit(0);
+				tModel.numRows-=nDeleted;
+				profile.saveIndex(true);
+				Global.getProfile().buildReferences();
+				refreshTable();
+			}
+		}
+		if (showProgress) Form.cancelWait();
+	}
+
+	/** Toggle the select status for a group of caches
+	 * If from==to, the addi Waypoints are also toggled if the cache is a main waypoint
+	 * If from!=to, each cache is toggled irrespective of its type (main or addi)
+	 * @param from index of first cache to toggle
+	 * @param to index of last cache to toggle
+	 * @param x is column of checkbox (does not have to be 0)
+	 */
+	void toggleSelect(int from, int to, int x) {
+		CacheHolder ch;
+		boolean singleRow= from == to;
+		for (int j=from; j&lt;=to; j++) {
+			ch=(CacheHolder) cacheDB.get(j);
+			ch.is_Checked= !ch.is_Checked;
+			tControl.repaintCell(j, x);
+			// set the ceckbox also for addi wpts
+			if (ch.hasAddiWpt() &amp;&amp; singleRow){
+				CacheHolder addiWpt;
+				int addiCount=ch.addiWpts.size();
+				for (int i=0;i&lt;addiCount;i++){
+					addiWpt = (CacheHolder)ch.addiWpts.get(i);
+					addiWpt.is_Checked = ch.is_Checked;
+					if (!addiWpt.is_filtered){
+						tControl.repaintCell(cacheDB.indexOf(addiWpt), x);
+					}
+				}
+			}
+		}
+	}
+
+	 private static class myProgressBarForm extends ProgressBarForm {
+		 boolean isClosed=false;
+		 protected boolean canExit(int exitCode) {
+			isClosed=true;
+			return true;
+		 }
+	 }
+
+
+//####################################################################################
+//   myTableControl
+//####################################################################################
+
+	/**
+	 *	Implements the user interaction of the list view. Works together with myTableModel and TablePanel
+	 */
+	public static class ListTableControl extends TableControl{
+		public Preferences pref;
+		public Profile profile;
+		public Vector cacheDB;
+		public TablePanel tbP;
+		private MenuItem miOpen,miGoto, miCenter, miOpenOnline, miOpenOffline, miDelete,miUpdate,
+		        miTickAll, miUntickAll,miSeparator;
+		private MenuItem[] mnuFull;
+		private MenuItem[] mnuSmall;
+		private Menu mFull,mSmall;
+		private Rect oldCursor=new Rect();
+		private Rect rbuff=new Rect();
+
+		ListTableControl(TablePanel tablePanel) {
+			mnuFull=new MenuItem[12];
+			mnuFull[0]= miOpen		= new MenuItem(MyLocale.getMsg(1021,&quot;Open description&quot;));
+			mnuFull[1]= miGoto			= new MenuItem(MyLocale.getMsg(1010,&quot;Goto&quot;));
+			mnuFull[2]= miCenter		= new MenuItem(MyLocale.getMsg(1019,&quot;Set this as center&quot;));
+			mnuFull[3]= miSeparator	= new MenuItem(&quot;-&quot;);
+			mnuFull[4]= miOpenOnline 	= new MenuItem(MyLocale.getMsg(1020,&quot;Open in $browser online&quot;));
+			mnuFull[5]= miOpenOffline	= new MenuItem(MyLocale.getMsg(1018,&quot;Open in browser offline&quot;));
+			mnuFull[6]= miSeparator;
+			mnuFull[7]= miDelete= new MenuItem(MyLocale.getMsg(1012,&quot;Delete selected&quot;));
+			mnuFull[8] = miUpdate = new MenuItem(MyLocale.getMsg(1014,&quot;Update&quot;));
+			mnuFull[9]= miSeparator;
+			mnuFull[10]= miTickAll	= new MenuItem(MyLocale.getMsg(1015,&quot;Select all&quot;));
+			mnuFull[11]=miUntickAll	= new MenuItem(MyLocale.getMsg(1016,&quot;De-select all&quot;));
+			mFull = new Menu(mnuFull,&quot;&quot;);
+
+			mnuSmall=new MenuItem[6];
+			mnuSmall[0]= miOpen;
+			mnuSmall[1]= miGoto;
+			mnuSmall[2]= miCenter;
+			mnuSmall[3]= miSeparator;
+			mnuSmall[4]= miOpenOnline;
+			mnuSmall[5]= miOpenOffline;
+			mSmall = new Menu(mnuSmall,&quot;&quot;);
+			profile=Global.getProfile();
+			cacheDB = profile.cacheDB;
+			pref = Global.getPref();
+			tbP =tablePanel;
+			allowDragSelection = false; // allow only one row to be selected at one time
+			modify(WantDrag,0);
+		}
+
+		/** Full menu when tablePanel includes checkbox */
+		public void setMenuFull() {
+			setMenu(mFull);
+		}
+
+		public Menu getMenuFull() {
+			return mFull;
+		}
+
+		/** Small menu when tablePanel does not include checkbox */
+		public void setMenuSmall() {
+			setMenu(mSmall);
+		}
+		public Menu getMenuSmall() {
+			return mSmall;
+		}
+
+		/** Set all caches either as selected or as deselected, depending on argument */
+		private void setTickForAll(boolean selectStatus) {
+			Global.getProfile().setSelectForAll(selectStatus);
+			this.repaint();
+		}
+
+		/** always select a whole row */
+		public boolean isSelected(int row,int col) {
+			return row==selection.y;
+		}
+
+		//============================= Event Handlers =============================
+		public void onEvent(Event ev) {
+			// If we changed the cache (e.g. via radar panel, we have to clear the details */
+			//if (ev instanceof TableEvent) Global.mainTab.clearDetails();
+			if (ev instanceof PenEvent &amp;&amp; (ev.type == PenEvent.PEN_DOWN) ){
+				Global.mainTab.tbP.tModel.penEventModifiers=((PenEvent)ev).modifiers;
+		    }
+			super.onEvent(ev);
+		}
+		// penPressed is in Model
+		public void penRightReleased(Point p){
+			if (cacheDB.size()&gt;0) // No context menu when DB is empty
+				menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
+		}
+		public void penHeld(Point p){
+			if (cacheDB.size()&gt;0) // No context menu when DB is empty
+				menuState.doShowMenu(p,true,null);
+		}
+		public void penDoubleClicked(Point where) {
+			Global.mainTab.select(Global.mainTab.descP);
+		}
+
+	 /**
+	  * this is only necessary to hinder the user to unselect - not clear why this is needed
+	  */
+/*		 public void penReleased(Point p,boolean isDouble) {
+			 Point p2 = cellAtPoint(p.x,p.y,null);
+			 super.penReleased(p, isDouble);
+			 Rect sel = getSelection(null);
+			 if ((sel.height == 0 || sel.height == 0) &amp;&amp; p2 != null) cursorTo(p2.y,p2.x, true); // if the selection is gone -&gt; reselect it
+
+		 }
+*/		public void onKeyEvent(KeyEvent ev) {
+			if (ev.type == KeyEvent.KEY_PRESS &amp;&amp; ev.target == this){
+				if ( (ev.modifiers &amp; IKeys.CONTROL) &gt; 0 &amp;&amp; ev.key == 1){ // &lt;ctrl-a&gt; gives 1, &lt;ctrl-b&gt; == 2
+					// select all on &lt;ctrl-a&gt;
+					setTickForAll(true);
+					ev.consumed = true;
+				}else {
+					Global.mainTab.clearDetails();
+					if (ev.key == IKeys.HOME) tbP.selectRow(0); //  cursorTo(0,cursor.x+listMode,true);
+					else if (ev.key == IKeys.END) tbP.selectRow(model.numRows-1); //cursorTo(model.numRows-1,cursor.x+listMode,true);
+					else if (ev.key == IKeys.PAGE_DOWN) tbP.selectRow(java.lang.Math.min(cursor.y+ getOnScreen(null).height-1, model.numRows-1)); //cursorTo(java.lang.Math.min(cursor.y+ getOnScreen(null).height-1, model.numRows-1),cursor.x+listMode,true); // I don't know why this doesn't work: tbp.doScroll(IScroll.Vertical, IScroll.PageHigher, 1);
+					else if (ev.key == IKeys.PAGE_UP) tbP.selectRow(java.lang.Math.max(cursor.y-getOnScreen(null).height+1, 0)); // cursorTo(java.lang.Math.max(cursor.y-getOnScreen(null).height+1, 0),cursor.x+listMode,true);
+					else if (ev.key == IKeys.ACTION || ev.key == IKeys.ENTER) Global.mainTab.select(Global.mainTab.descP);
+					else if (ev.key == IKeys.DOWN) tbP.selectRow(java.lang.Math.min(cursor.y+ 1, model.numRows-1));
+					else if (ev.key == IKeys.UP) tbP.selectRow(java.lang.Math.max(cursor.y-1, 0));
+					else if (ev.key == IKeys.LEFT &amp;&amp; Global.mainForm.cacheListVisible &amp;&amp; cursor.y&gt;=0 &amp;&amp; cursor.y&lt;tbP.tModel.numRows) Global.mainForm.cacheList.addCache(((CacheHolder)cacheDB.elementAt(cursor.y)).wayPoint);
+					else if (ev.key == IKeys.RIGHT) {
+						CacheHolder ch;
+						ch = (CacheHolder)cacheDB.get(tbP.getSelectedCache());
+						Global.mainTab.gotoPoint(ch.pos);
+					}
+					else if (ev.key == 6 ) MainMenu.search(); // (char)6 == ctrl + f
+					else super.onKeyEvent(ev);
+				}
+			}
+			else super.onKeyEvent(ev);
+		}
+
+		public void popupMenuEvent(Object selectedItem){
+			if (selectedItem == null) return;
+			CacheHolder ch;
+			if (selectedItem==miOpen){
+				penDoubleClicked(null);
+			} else if (selectedItem==miGoto){
+				ch = (CacheHolder)cacheDB.get(tbP.getSelectedCache());
+				Global.mainTab.gotoPoint(ch.pos);
+			} else if (selectedItem==miCenter){
+				if (Global.mainTab.tbP.getSelectedCache() &lt; 0) {
+					Global.getPref().log(&quot;popupMenuEvent: getSelectedCache() &lt; 0&quot;);
+					return;
+				}
+				CacheHolder thisCache = (CacheHolder)cacheDB.get(tbP.getSelectedCache());
+				CWPoint cp=new CWPoint(thisCache.latLon);
+				if (!cp.isValid()){
+					MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(4111,&quot;Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM&quot;), MessageBox.OKB);
+					tmpMB.execute();
+				} else {
+					pref.curCentrePt.set(cp);
+					Global.getProfile().updateBearingDistance();
+					this.repaint();
+				}
+			} else if (selectedItem==miOpenOnline){
+				if(browserPathIsValid()){
+					ch = (CacheHolder)cacheDB.get(tbP.getSelectedCache());
+					CacheHolderDetail chD=ch.getCacheDetails(false, true);
+					try {
+						if (chD != null) {
+							String cmd = &quot;\&quot;&quot;+pref.browser+ &quot;\&quot; \&quot;&quot; + chD.URL+&quot;\&quot;&quot;;
+							eve.sys.Vm.execCommandLine(cmd);
+						}
+					} catch (IOException ex) {
+						(new MessageBox(&quot;Error&quot;, &quot;Cannot start browser!\n&quot;+ex.toString()+&quot;\nThe are two possible reasons:\n * path to internet browser in \npreferences not correct\n * An bug in eve VM, please be \npatient for an update&quot;,MessageBox.OKB)).execute();
+					}
+				}
+			} else if (selectedItem==miOpenOffline) {
+				if(browserPathIsValid()){
+					ShowCacheInBrowser sc= new ShowCacheInBrowser();
+					sc.showCache(((CacheHolder)cacheDB.get(tbP.getSelectedCache())).getCacheDetails(false, true));
+				}
+			} else if (selectedItem==miDelete){
+				tbP.deleteSelectedCaches(true);
+			} else if (selectedItem==miTickAll){
+				setTickForAll(true);
+			} else if (selectedItem==miUntickAll){
+				setTickForAll(false);
+			} else if (selectedItem == miUpdate){
+				MainMenu.updateSelectedCaches(tbP);
+			}
+		}
+
+		public boolean browserPathIsValid() {
+			if(!new eve.io.File(pref.browser).exists()){
+				(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(1032,&quot;Path to browser:&quot;)+&quot;\n&quot;+pref.browser+&quot;\n&quot;+MyLocale.getMsg(1033,&quot;is incorrect!&quot;),FormBase.OKB)).execute();
+				return false;
+			} else
+				return true;
+		}
+
+
+
+
+	    ///////////////////////////////////////////////////
+		//  Allow the caches to be dragged into a cachelist
+	    ///////////////////////////////////////////////////
+
+		IconAndText imgDrag;
+		String wayPoint;
+		int row;
+
+		public void startDragging(DragContext dc) {
+			Vector cacheDB=Global.getProfile().cacheDB;
+			 Point p=cellAtPoint(dc.start.x,dc.start.y,null);
+			 wayPoint=null;
+			 if (p.y&gt;=0) {
+				if (!Global.mainForm.cacheListVisible) {
+					dc.cancelled=true;
+					return;
+				}
+				 row=p.y;
+				 CacheHolder ch=(CacheHolder)cacheDB.get(p.y);
+				 wayPoint=ch.wayPoint;
+				 //Vm.debug(&quot;Waypoint : &quot;+ch.wayPoint);
+				 imgDrag=new IconAndText();
+				 imgDrag.addColumn( CacheType.cache2Img(ch.type));
+				 imgDrag.addColumn(ch.wayPoint);
+				 dc.dragData=dc.startImageDrag(imgDrag,new Point(8,8),this);
+			 } else super.startDragging(dc);
+		 }
+
+		 public void stopDragging(DragContext dc) {
+			 if (wayPoint!=null &amp;&amp; !dc.cancelled) {
+				 //Vm.debug(&quot;Stop  Dragging&quot;+dc.curPoint.x+&quot;/&quot;+dc.curPoint.y);
+				 dc.stopImageDrag(true);
+				 Point p = Gui.getPosInParent(this,getWindow(),null);
+				 p.x += dc.curPoint.x;
+				 p.y += dc.curPoint.y;
+				 Control c = getWindow().findChild(p.x,p.y);
+			     if (c instanceof eve.ui.List &amp;&amp; c.text.equals(&quot;CacheList&quot;)) {
+			    	 if (Global.mainForm.cacheList.addCache(wayPoint)) {
+			    		 c.repaintNow();
+			    		 ((eve.ui.List) c).makeItemVisible(((eve.ui.List)c).itemsSize()-1);
+			    	 }
+			     }
+			     Global.mainTab.tbP.selectRow(row);
+				 //Vm.debug(&quot;Control &quot;+c.toString()+&quot;/&quot;+c.text);
+			 }else super.stopDragging(dc);
+		 }
+
+		 public void dragged(DragContext dc) {
+		 	if (wayPoint!=null)
+			   dc.imageDrag();
+		 	else
+		 		super.dragged(dc);
+		 }
+
+		 public void cursorTo(int row,int col,boolean selectNew) {
+			col=0;
+			if (row != -2 &amp;&amp; col != -2 &amp;&amp; !canSelect(row,col)) return;
+			oldCursor.set(cursor.x,cursor.y,tbP.tModel.numCols,1);
+			cursor.set(col,row);
+			if (selectNew){
+/*				Vector v = (Vector)Cache.get(Vector.class);
+				clearSelectedCells(v);
+				paintCells(v);
+				v.removeAllElements();
+				Cache.put(v);
+*/				if (row != -2 &amp;&amp; col != -2){
+					if (scrollToVisible(row,col)) repaintNow();
+					addToSelection(rbuff.set(0,row,tbP.tModel.numCols,1),false,true);
+					//fireSelectionEvent(TableEvent.FLAG_SELECTED_BY_ARROWKEY);
+					//clickedFlags = TableEvent.FLAG_SELECTED_BY_ARROWKEY;
+					//if (clickMode) clicked(row,col);
+					//clickedFlags = 0;
+				}
+				paintCells(oldCursor);
+			}
+		 }
+	}
+
+//####################################################################################
+//  MyTableModel
+//####################################################################################
+	/**
+	*	Table model used to display the cache list.
+	* 	Used by the table control in the first panel of
+	*	CacheWolf.
+	*/
+	public static class ListTableModel extends TableModel{
+
+		public static final int MAXCOLUMNS=14;
+		// Colors for Cache status (BG unless otherwise stated)
+		private Vector cacheDB;
+		/** How the columns are mapped onto the list view. If colMap[i]=j, it means that
+		 * the element j (as per the list below) is visible in column i.
+		 * [0]TickBox, [1]Type, [2]Distance, [3]Terrain, [4]waypoint, [5]name, [6]coordinates,
+		 * [7]owner, [8]datehidden, [9]status, [10]distance, [11]bearing, [12] Size, [13] # of OC recommend.
+		 * [14] OC index
+		 */
+		private int[] colMap;
+		/** The column widths corresponding to the list of columns above */
+		private int[] colWidth;
+		private String [] colName = {&quot; &quot;,&quot;?&quot;,MyLocale.getMsg(1000,&quot;D&quot;),MyLocale.getMsg(1001,&quot;T&quot;),
+				MyLocale.getMsg(1002,&quot;Waypoint&quot;),&quot;Name&quot;,MyLocale.getMsg(1004,&quot;Location&quot;),
+				MyLocale.getMsg(1005,&quot;Owner&quot;),MyLocale.getMsg(1006,&quot;Hidden&quot;),MyLocale.getMsg(1007,&quot;Status&quot;),
+				MyLocale.getMsg(1008,&quot;Dist&quot;),MyLocale.getMsg(1009,&quot;Bear&quot;),MyLocale.getMsg(1017,&quot;S&quot;),
+				MyLocale.getMsg(1026,&quot;#Rec&quot;),MyLocale.getMsg(1027,&quot;OC-IDX&quot;)};
+
+		private Picture noFindLogs[] = new Picture[4];
+		private Picture red, blue, yellow, skull, checkboxTicked,checkboxUnticked,bug;
+		private boolean sortAsc = false;
+		private int sortedBy = -1;
+		private FontMetrics fm;
+		/** This is the modifier (Shift &amp; Control key status) for Pen Events
+		 * it is set in myTableControl.onEvent */
+		public int penEventModifiers;
+		private ListTableControl tcControl;
+		public boolean showExtraWptInfo=true;
+		private IconAndText iAndT = new IconAndText();
+		private IconAndText wpVal = new IconAndText();
+		private Object [] picSizeList={&quot;?&quot;,new Picture(&quot;sizeMicro.png&quot;,Color.White,0),
+					new Picture(&quot;sizeSmall.png&quot;,Color.White,0),
+					new Picture(&quot;sizeReg.png&quot;,Color.White,0),
+					new Picture(&quot;sizeLarge.png&quot;,Color.White,0),
+					new Picture(&quot;sizeVLarge.png&quot;,Color.White,0)};
+
+		public ListTableModel(ListTableControl tc, FontMetrics fm){
+			super();
+			cacheDB = Global.getProfile().cacheDB;
+			this.fm = fm;
+			tcControl = tc;
+			setColumnNamesAndWidths();
+			//this.numRows = cacheDB.size();
+			//Dimension selrow = new Dimension(-1,1);
+			//this.cursorSize = selrow;
+			noFindLogs[0] = new Picture(&quot;no_1_log.png&quot;);
+			noFindLogs[1] = new Picture(&quot;no_2_log.png&quot;);
+			noFindLogs[2] = new Picture(&quot;no_3_log.png&quot;);
+			noFindLogs[3] = new Picture(&quot;no_4_log.png&quot;);
+			red = new Picture(&quot;red.png&quot;,Color.White,0);
+			blue = new Picture(&quot;blue.png&quot;,Color.White,0);
+			//green = new Picture(&quot;green.png&quot;,Color.White,0);
+			yellow = new Picture(&quot;yellow.png&quot;,Color.White,0);
+			skull = new Picture(&quot;skull.png&quot;,Color.DarkBlue,0);
+			bug = new Picture(&quot;bug_table.png&quot;,Color.DarkBlue,0);
+			checkboxTicked = new Picture(&quot;checkboxTicked.png&quot;);
+			checkboxUnticked= new Picture(&quot;checkboxUnticked.png&quot;);
+			iAndT.fontMetrics=fm;
+			wpVal.fontMetrics=fm;
+			//updateRows();
+		}
+
+		/**
+		 * Sets the column names and widths from preferences
+		 *
+		 */
+		public void setColumnNamesAndWidths() {
+			colMap=TableColumnChooser.str2Array(Global.getPref().listColMap,0,14,0, -1);
+			colWidth=TableColumnChooser.str2Array(Global.getPref().listColWidth,10,1024,50, colMap.length);
+			numCols=colMap.length;
+			clearCellAdjustments();
+			// If the displayed columns include the checkbox, we use the full menu
+			if ((&quot;,&quot;+Global.getPref().listColMap+&quot;,&quot;).indexOf(&quot;,0,&quot;)&gt;=0)
+				tcControl.setMenuFull();
+			else
+				tcControl.setMenuSmall();
+		}
+
+		/**
+		 * Return the column widths as a comma delimited string for storing in the preferences
+		 * @return
+		 */
+		public String getColWidths() {
+			// Update the list with the current widths
+			for (int col=0; col&lt;numCols; col++) {
+				colWidth[colMap[col]]=getColWidth(col);
+			}
+			clearCellAdjustments();
+			// Convert to string
+			StringBuffer sb=new StringBuffer(40);
+			for (int i=0; i&lt;colWidth.length; i++) {
+				if (sb.length()!=0) sb.append(',');
+				sb.append(colWidth[i]);
+			}
+			return sb.toString();
+		}
+
+		public int calculateRowHeight(int row){
+			return java.lang.Math.max(18, charHeight+4);
+		}
+
+		public int calculateColWidth(int col){
+			if(col == -1)
+	        	return 0;
+	        else if (col&lt;numCols)
+	        	return colWidth[colMap[col]];
+	        else return 0;
+		}
+
+		/**
+		* Method to set the row color of the table displaying the
+		* cache list, depending on different flags set to the cache.
+		*/
+		public TableCellAttributes getCellAttributes(int row,int col,boolean  isSelected, TableCellAttributes ta){
+			ta = super.getCellAttributes(row, col, isSelected, ta);
+			ta.alignment = CellConstants.LEFT;
+			ta.anchor = CellConstants.LEFT;
+			if(row &gt;= 0){
+				try {
+				   CacheHolder ch = (CacheHolder)cacheDB.get(row);
+					if(isSelected == true) ta.fillColor = COLOR_SELECTED;
+					else if(ch.is_available == false &amp;&amp; ch.is_found == true){
+						ta.fillColor = COLOR_ARCHFND_BG;   // Green BG
+						ta.foreground = COLOR_ARCHFND_FG;  // Red FG
+					}
+					else if(ch.is_archived == true) ta.fillColor = COLOR_ARCHIVED;
+					else if(ch.is_available == false) ta.fillColor = COLOR_AVAILABLE;
+					else if(ch.is_owned == true) ta.fillColor = COLOR_OWNED;
+					else if(ch.is_found == true)
+						ta.fillColor = COLOR_FOUND;
+					else if(ch.is_flagged == true) ta.fillColor = COLOR_SEARCH;
+				} catch (Exception e) {};
+			} else if (row==-1 &amp;&amp; colMap[col]==0 &amp;&amp; Global.getProfile().showBlacklisted) ta.fillColor=Color.Black;
+			return ta;
+		}
+
+		/**
+		 * Return the data in a cell
+		 */
+		public Object getCellData(int row, int col){
+			if(row == -1) return colName[colMap[col]];
+			try { // Access to row can fail if many caches are deleted
+				CacheHolder ch = (CacheHolder)cacheDB.get(row);
+				if(ch.is_filtered == false){
+					switch(colMap[col]) { // Faster than using column names
+						case 0: // Checkbox
+							if (ch.is_Checked)
+								return checkboxTicked;
+							return checkboxUnticked;
+						case 1: // Type
+							return  CacheType.cache2Img(ch.type);
+						case 2: // Difficulty;
+							return ch.hard;
+						case 3: // Terrain
+							return ch.terrain;
+						case 4: // Waypoint
+							if (showExtraWptInfo) {
+/*								if(ch.is_incomplete) return new IconAndText(skull, ch.wayPoint, fm);
+								if(ch.is_new       ) return new IconAndText(yellow, ch.wayPoint, fm);
+								if(ch.is_update    ) return new IconAndText(red, ch.wayPoint, fm); // TODO this is for sure quite inefficient, better store it, don't create always new when the table is refreshed or only scrolled
+								if(ch.is_log_update) return new IconAndText(blue, ch.wayPoint, fm);*/
+								if(ch.is_incomplete) {
+									iAndT.set(skull,ch.wayPoint);
+									return iAndT;
+								}
+								if(ch.is_new       )  {
+									iAndT.set(yellow,ch.wayPoint);
+									return iAndT;
+								}
+								if(ch.is_update    ) {
+									iAndT.set(red,ch.wayPoint);
+									return iAndT;
+								}
+								if(ch.is_log_update) {
+									iAndT.set(blue,ch.wayPoint);
+									return iAndT;
+								}
+							}
+							return ch.wayPoint;
+						case 5: // Cachename
+							// Fast return for majority of case
+							if (!showExtraWptInfo || (ch.has_bug == false &amp;&amp; ch.noFindLogs==0)) return ch.cacheName;
+							wpVal.clearColumns();
+							// Now need more checks
+							if(ch.has_bug == true) wpVal.addColumn(bug);
+							if(ch.noFindLogs &gt; 0){
+								if (ch.noFindLogs &gt; noFindLogs.length)
+									wpVal.addColumn(noFindLogs[noFindLogs.length-1]);
+								else
+									wpVal.addColumn(noFindLogs[ch.noFindLogs-1]);
+							}
+							wpVal.addColumn(ch.cacheName);
+							return wpVal;
+						case 6: // Location
+							return ch.latLon;
+						case 7: // Owner
+							return ch.cacheOwner;
+						case 8: // Date hidden
+							return ch.dateHidden;
+						case 9: // Status
+							return ch.cacheStatus;
+						case 10: // Distance
+							return ch.distance;
+						case 11: // Bearing
+							return ch.bearing;
+						case 12: // Size
+							return picSizeList[ch.cacheSize];
+						case 13: // OC number of recommendations
+							if (ch.wayPoint.startsWith(&quot;OC&quot;))
+								return Convert.formatInt(ch.numRecommended);
+							return null;
+						case 14: // OC rating
+							if (ch.wayPoint.startsWith(&quot;OC&quot;))
+								return Convert.formatInt(ch.recommendationScore);
+							return null;
+					} // Switch
+				} // if
+			} catch (Exception e) { return null; }
+			return null;
+		}
+
+		public boolean penPressed(Point onTable,Point cell){
+			boolean retval = false;
+			if (cell==null) return false;
+			try{
+				// Check whether the click is on the checkbox image
+				if (cell.y&gt;=0 &amp;&amp; colMap[cell.x]==0) {
+					Global.getProfile().selectionChanged = true;
+					if ((penEventModifiers &amp; IKeys.SHIFT)&gt;0) {
+						if (tcControl.cursor.y &gt;= 0) { // Second row being marked with shift key pressed
+							if (tcControl.cursor.y&lt;cell.y)
+								tcControl.tbP.toggleSelect(tcControl.cursor.y+1,cell.y,cell.x);
+							else
+								tcControl.tbP.toggleSelect(cell.y,tcControl.cursor.y-1,cell.x);
+						} else { // Remember this row as start of range, but don't toggle yet
+						}
+					} else { // Single row marked
+						tcControl.tbP.toggleSelect(cell.y,cell.y,cell.x);
+					}
+				}
+				if(cell.y == -1){ // Hit a header =&gt; sort the table accordingly
+					CacheHolder ch=null;
+					// cell.x is the physical column but we have to sort by the
+					// column it is mapped into
+					int mappedCol=colMap[cell.x];
+					if (mappedCol==0) { // Click on Tickbox header
+						// Hide/unhide the additional information about a waypoint such as
+						// travelbugs/number of notfound logs/yellow circle/red circle etc.
+						// This helps on small PDA screens
+						showExtraWptInfo=!showExtraWptInfo;
+						this.table.repaint();
+						return true;
+					}
+					Form.showWait();
+					Point a = tcControl.getSelectedCell(null);
+					if((a != null) &amp;&amp; (a.y &gt;= 0) &amp;&amp; (a.y &lt; cacheDB.size())) ch = (CacheHolder)cacheDB.get(a.y);
+					if (mappedCol == sortedBy) sortAsc=!sortAsc;
+					else sortAsc = false;
+					sortedBy = mappedCol;
+					eve.util.Utils.sort(new Handle(), cacheDB,new MyComparer(cacheDB, mappedCol,numRows), sortAsc );
+					Global.mainTab.tbP.updateRows();
+					if(a != null){
+						int rownum = Global.getProfile().getCacheIndex(ch.wayPoint);
+						if(rownum &gt;= 0){
+							tcControl.cursorTo(rownum, 0, true);
+		/*					tcControl.scrollToVisible(rownum, 0);
+							tcControl.clearSelectedCells(new Vector());
+							for(int i= 0; i &lt; MAXCOLUMNS; i++){
+								tcControl.addToSelection(rownum,i);
+							}
+			*/			}
+					}
+					Form.cancelWait();
+					tcControl.update(true);
+					retval = true;
+				}
+			} catch(NullPointerException npex){
+				Form.cancelWait();
+				Global.getPref().log(&quot;NPE in MyTableModel.Penpressed&quot;);}
+			return retval;
+		}
+
+		public void select(int row,int col,boolean selectOn) {
+			tcControl.cursorTo(row, col, true);
+		}
+
+
+
+//####################################################################################
+// MyComparer
+//####################################################################################
+
+		/**
+		*	This class handles the sorting for most of the sorting tasks. If a cache is
+		*	to be displayed in the table or not is handled in the table model
+		*	@see ListTableModel
+		*	@see DistComparer
+		*/
+		public static class MyComparer implements eve.util.Comparer{
+
+			public MyComparer(Vector cacheDB, int colToCompare, int visibleSize){
+				if (visibleSize&lt;2) return;
+				for (int i=visibleSize; i&lt;cacheDB.size(); i++) {
+					CacheHolder ch=(CacheHolder) cacheDB.get(i);
+					ch.sort=&quot;\uFFFF&quot;;
+				}
+				if (colToCompare==1) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						ch.sort=(&quot;000&quot;+String.valueOf(ch.type)).substring(0,4);
+					}
+				} else if (colToCompare==2) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						ch.sort=ch.hard;
+					}
+				} else if (colToCompare==3) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						ch.sort=ch.terrain;
+					}
+				} else if (colToCompare==4) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						ch.sort=ch.wayPoint.toUpperCase();
+					}
+				} else if (colToCompare==5) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						ch.sort=ch.cacheName.toLowerCase();
+					}
+				} else if (colToCompare==6) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						ch.sort=ch.latLon;
+					}
+				} else if (colToCompare==7) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						ch.sort=ch.cacheOwner.toLowerCase();
+					}
+				} else if (colToCompare==8) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						ch.sort=ch.dateHidden;
+					}
+				} else if (colToCompare==9) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						ch.sort=ch.cacheStatus;
+					}
+				} else if (colToCompare==10) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						int p=ch.distance.indexOf(&quot;,&quot;);
+						if (p&lt;0) p=ch.distance.indexOf(&quot;.&quot;);
+						if (p&gt;=0 &amp;&amp; p&lt;=5)
+							ch.sort=&quot;00000&quot;.substring(0,5-p)+ch.distance;
+						else
+							ch.sort=ch.distance;
+					}
+				} else if (colToCompare==11) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						ch.sort=ch.bearing;
+					}
+
+				} else if (colToCompare==12) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						if (ch.getCacheSize().length()==0) ch.sort=&quot;?&quot;;
+						else switch (ch.getCacheSize().charAt(0)) {
+							case 'M': ch.sort=&quot;1&quot;; break;
+							case 'S': ch.sort=&quot;2&quot;; break;
+							case 'R': ch.sort=&quot;3&quot;; break;
+							case 'L': ch.sort=&quot;4&quot;; break;
+							case 'V': ch.sort=&quot;5&quot;; break;
+							default: ch.sort=&quot;?&quot;;
+						}
+					}
+				} else if (colToCompare==13) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						if (ch.wayPoint.startsWith(&quot;OC&quot;))
+							ch.sort=MyLocale.formatLong(ch.numRecommended,&quot;00000&quot;);
+						else
+							ch.sort=&quot;\uFFFF&quot;;
+					}
+				} else if (colToCompare==14) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						if (ch.wayPoint.startsWith(&quot;OC&quot;))
+							ch.sort=MyLocale.formatLong(ch.recommendationScore,&quot;00000&quot;);
+						else
+							ch.sort=&quot;\uFFFF&quot;;
+					}
+				}
+			}
+
+			public int compare(Object o1, Object o2){
+				CacheHolder oo1 = (CacheHolder)o1;
+				CacheHolder oo2 = (CacheHolder)o2;
+				return oo1.sort.compareTo(oo2.sort);
+			}
+		}
+	} // MyTableModel
+} // TablePanel
+
+

Modified: experiments/engywuck/hist-test/src/cachewolf/Test.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/Test.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/Test.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,10 +1,7 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.io.File;
-import ewe.io.IOException;
-import ewe.io.RandomAccessFile;
-import ewe.sys.*;
-
+import eve.sys.*;
+import com.stevesoft.eve_pat.*;
 import java.lang.Math;;
  
 
@@ -18,21 +15,45 @@
 		testAll();
 	}
 	void testAll(){
-		testPerformance();
-/*		testRegex();
+//		testPerformance();
+	    Regex r = new Regex(&quot;x\\s*(a|b)y&quot;);
+	    r.search(&quot;abcx   ay&quot;);
+	    eve.sys.Vm.debug(&quot;sub = &quot;+r.stringMatched(1));
+		
+		Regex rex = new Regex(&quot;(?:&quot; +
+		&quot;([NSns])\\s*([0-9]{1,2})(?:[&#176;\uC2B0]\\s*|\\s+[&#176;\uC2B0]?\\s*)([0-9]{1,2})(?:(?:['&#146;]\\s*|\\s+['&#146;]?\\s*)([0-9]{1,2}))?(?:[,.]([0-9]{1,8}))?\\s*['&#146;\&quot;]?\\s*&quot; +
+		&quot;([EWewOo])\\s*([0-9]{1,3})(?:[&#176;\uC2B0]\\s*|\\s+[&#176;\uC2B0]?\\s*)([0-9]{1,2})(?:(?:['&#146;]\\s*|\\s+['&#146;]?\\s*)([0-9]{1,2}))?(?:[,.]([0-9]{1,8}))?\\s*['&#146;\&quot;]?&quot; +
+		&quot;)|(?:&quot; +
+		&quot;(?:([NnSs])\\s*(?![+-]))?&quot;   +     &quot;([+-]?[0-9]{1,2})[,.]([0-9]{1,8})(?:(?=[+-EeWwOo])|\\s+|\\s*[&#176;\uC2B0]\\s*)&quot; +
+	  	&quot;(?:([EeWwOo])\\s*(?![+-]))?&quot;    +     &quot;([+-]?[0-9]{1,3})[,.]([0-9]{1,8})\\s*[&#176;\uC2B0]?&quot; +
+		&quot;)|(?:&quot; +
+		&quot;([0-9]{1,2}[C-HJ-PQ-X])\\s*[EeOo]?\\s*([0-9]{1,7})\\s+[Nn]?\\s*([0-9]{1,7})&quot; +
+		&quot;)|(?:&quot; +
+		&quot;[Rr]:?\\s*([+-]?[0-9]{1,7})\\s+[Hh]:?\\s*([+-]?[0-9]{1,7})&quot; +
+		&quot;)&quot;);		
+	    rex.search(&quot;N 23&#176; 12.1234 E 23&#176; 45.234&quot;);
+	    eve.sys.Vm.debug(&quot;rex = &quot;+rex.stringMatched(1)+&quot; &quot;+rex.stringMatched(2)+&quot; &quot;+rex.stringMatched(3)+&quot; &quot;+rex.stringMatched(4)+
+	    		&quot; &quot;+rex.stringMatched(5)+&quot; &quot;+rex.stringMatched(6)+&quot; &quot;+rex.stringMatched(7)+&quot; &quot;+rex.stringMatched(8)+&quot; &quot;+rex.stringMatched(9)+
+	    		&quot; &quot;+rex.stringMatched(10)
+	    );
+	    
+		//testRegex();
 		if (allPassed) 
 			Vm.debug(&quot;SUCCESS: All tests passed&quot;); 
-		else 
+		else  
 			Vm.debug(&quot;FAILURE: At least one test failed&quot;); 
-*/	}
+	}
 	void testPerformance(){
 		Time start, end;
 		int i;
+		double tmp=0.0;
+		
 		// 100.000 Sinus
 		start = new Time();
 		for (i=0; i&lt;100000; i++){
-			Math.sin(53);
+			tmp = Math.sin(53);
 		}
+		tmp=tmp+0;
 		end = new Time();
 		printResult(&quot;sin(53)&quot;, start, end, i);
 		
@@ -75,32 +96,13 @@
 		end = new Time();
 		printResult(&quot;cwSet.set(\&quot;N 51&#176; 27.635 E 009&#176; 37.621\&quot;, CWPoint.CW) CWPoint set&quot;, start, end, i);
 
-		// 1.000 filewrite
-		String fileName = new String(&quot;test.tmp&quot;);
-		try {
-			RandomAccessFile out =  new RandomAccessFile(fileName,&quot;rw&quot;);
-			start = new Time();
-			for (i=0; i&lt;10000; i++){
-				out.writeBytes(fileName);
-			}
-			end = new Time();
-			out.close();
-			File dfile = new File(fileName);
-			dfile.delete();
-		} catch (IOException e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		}
-		printResult(&quot;Filewrite 10 Bytes&quot;, start, end, i);
-		
 	}
 	
 	void printResult(String what, Time start, Time end, int count){
-		String VM = Vm.getPlatform();
 		long time;
 		time = end.getTime() - start.getTime();
 		
-		Vm.debug(VM + &quot; &quot; +  Convert.toString(time) + &quot; msec &quot; + Convert.toString(count) + &quot; * &quot; + what);
+		Vm.debug(&quot; &quot; +  Convert.toString(time) + &quot; msec &quot; + Convert.toString(count) + &quot; * &quot; + what);
 	}
 	
 	void testPassedRegex(String pattern, String expectedResult, int format) {

Modified: experiments/engywuck/hist-test/src/cachewolf/Travelbug.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/Travelbug.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/Travelbug.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,4 +1,7 @@
-package CacheWolf;
+package cachewolf;
+
+import cachewolf.utils.SafeXML;
+
 /**
  * This contains the basic information of a GC travelbug.
  * @author salzkammergut

Modified: experiments/engywuck/hist-test/src/cachewolf/TravelbugJourney.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/TravelbugJourney.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/TravelbugJourney.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,4 +1,4 @@
-package CacheWolf;
+package cachewolf;
 
 /**
  * A travelbug journey starts in a cache (from....) where the tb is picked up and 
@@ -7,9 +7,11 @@
  * transfer has been logged to GC.
  * @author salzkammergut
  */
-import ewe.fx.Image;
-import ewe.sys.*;
+import cachewolf.utils.SafeXML;
+import eve.sys.*;
+import eve.fx.Picture;
 
+
 public class TravelbugJourney  {
 	/** 
 	 * The travelbug concerned @see Travelbug 
@@ -106,8 +108,8 @@
 		setToDate(getDateTime());    
 	}
 	
-	private static Image checkboxTicked = new Image(&quot;checkboxTicked.png&quot;);
-	private static Image checkboxUnticked= new Image(&quot;checkboxUnticked.png&quot;);
+	private static Picture checkboxTicked = new Picture(&quot;checkboxTicked.png&quot;);
+	private static Picture checkboxUnticked= new Picture(&quot;checkboxUnticked.png&quot;);
 	
 	/** Get an element of a TravelbugJourney by number. This is used when
 	 * displaying the journey in list format.
@@ -127,15 +129,13 @@
 			case 6: return getFromDate();
 			case 7: if (getFromLogged())
 						return checkboxTicked;
-					else
-						return checkboxUnticked;
+					return checkboxUnticked;
 			case 8: return getToProfile();
 			case 9: return getToWaypoint();
 			case 10: return getToDate();
 			case 11: if(getToLogged())
 						return checkboxTicked;
-					else
-						return checkboxUnticked;
+					return checkboxUnticked;
 			/* Special case 12: Return Z if both moves have been logged, blank otherwise
 			 This allows the not logged tbJourneys to be sorted to the top.*/
 			case 12: return bothLogsDone() ? &quot;Z&quot;: &quot; &quot;;
@@ -286,11 +286,11 @@
 		appendElem(s,&quot;fromProfile&quot;,fromProfile,true);
 		appendElem(s,&quot;fromWaypoint&quot;,fromWaypoint,false);
 		appendElem(s,&quot;fromDate&quot;,fromDate,false);
-		appendElem(s,&quot;fromLogged&quot;,(new Boolean(fromLogged)).toString(),false);
+		appendElem(s,&quot;fromLogged&quot;,Boolean.toString(fromLogged),false);
 		appendElem(s,&quot;toProfile&quot;,toProfile,true);
 		appendElem(s,&quot;toWaypoint&quot;,toWaypoint,false);
 		appendElem(s,&quot;toDate&quot;,toDate,false);
-		appendElem(s,&quot;toLogged&quot;,(new Boolean(toLogged)).toString(),false);
+		appendElem(s,&quot;toLogged&quot;,Boolean.toString(toLogged),false);
 		s.append(&quot;&gt;&lt;name&gt;&lt;![CDATA[&quot;);
 		s.append(tb.getName());
 		s.append(&quot;]]&gt;&lt;/name&gt;&lt;![CDATA[&quot;);

Modified: experiments/engywuck/hist-test/src/cachewolf/TravelbugJourneyList.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/TravelbugJourneyList.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/TravelbugJourneyList.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,13 +1,17 @@
-package CacheWolf;
+package cachewolf;
 
 /**
  * A list of @see TravelbugJourney s.
  */
-import ewe.io.BufferedWriter;
-import ewe.io.File;
-import ewe.io.FileWriter;
-import ewe.io.PrintWriter;
-import ewe.util.*;
+import java.io.BufferedWriter;
+import eve.io.File;
+import java.io.FileWriter;
+import java.io.PrintWriter;
+import java.util.*;
+
+import cachewolf.utils.SafeXML;
+
+
 import ewesoft.xml.*;
 import ewesoft.xml.sax.*;
 
@@ -102,7 +106,7 @@
 		try{
 			String datei = Global.getPref().baseDir + &quot;/&quot; + &quot;travelbugs.xml&quot;;
 			datei = datei.replace('\\', '/');
-			ewe.io.Reader r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(datei));
+			java.io.Reader r = new java.io.InputStreamReader(new java.io.FileInputStream(datei));
 			parse(r);
 			r.close();
 		}catch(Exception e){
@@ -183,7 +187,7 @@
 
 	/** Sort the list of travelbug journeys by any column */
 	public void sort(int column, boolean ascending) {
-		tbJourneyList.sort(new tbjComparer(column),ascending);
+		eve.util.Utils.sort(new eve.sys.Handle(),tbJourneyList,new tbjComparer(column),ascending);
 	}
 
 	/** Sort only part of the travelbug journey list. This is used to sort the
@@ -195,11 +199,11 @@
 	public void sortFirstHalf(int column, boolean ascending,int nElem) {
 		Object[] no = new Object[nElem];
 		for (int i=0; i&lt;nElem; i++) no[i]=tbJourneyList.elementAt(i);
-		Utils.sort(null,no,new tbjComparer(column),ascending);
-		for (int i=0; i&lt;nElem; i++) tbJourneyList.set(i,no[i]);
+		eve.util.Utils.sort(new eve.sys.Handle(),no,new tbjComparer(column),ascending);
+		for (int i=0; i&lt;nElem; i++) tbJourneyList.setElementAt(no[i],i);
 	}
 	
-	private class tbjComparer implements Comparer {
+	private class tbjComparer implements eve.util.Comparer {
 		private int col;
 		tbjComparer(int column) {
 			col=column;

Modified: experiments/engywuck/hist-test/src/cachewolf/TravelbugJourneyScreen.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/TravelbugJourneyScreen.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/TravelbugJourneyScreen.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,4 +1,4 @@
-package CacheWolf;
+package cachewolf;
 
 /**
  * A list to manage the travelbugs. Each row represents one @see TravelbugJourney.
@@ -11,14 +11,27 @@
  * @author salzkammergut
  */
 
-import utils.CWWrapper;
-import ewe.sys.Convert;
-import ewe.sys.Time;
-import ewe.sys.Vm;
-import ewe.ui.*;
-import ewe.util.*;
-import ewe.fx.*;
+import eve.sys.Convert;
+import eve.sys.Time;
+import eve.sys.Vm;
+import eve.ui.*;
+import java.util.*;
 
+import cachewolf.imp.SpiderGC;
+
+
+import eve.fx.*;
+import eve.ui.formatted.HtmlDisplay;
+import eve.sys.Event;
+import eve.ui.event.DataChangeEvent;
+import eve.ui.table.TableControl;
+import eve.ui.table.TableModel;
+import eve.ui.event.PenEvent;
+import eve.ui.event.MultiPanelEvent;
+import eve.ui.event.ControlEvent;
+import eve.ui.event.FormEvent;
+import eve.ui.table.TableCellAttributes;
+
 public class TravelbugJourneyScreen extends Form  {
 	
 	/** The list control */
@@ -29,20 +42,20 @@
 	private TravelbugJourneyList tblMyTravelbugJourneys;
 	/** The panel for the lower half of the screen */
 	private CellPanel lowerpane;
-	private mInput inpName,inpTrackingNo, 
+	private Input inpName,inpTrackingNo, 
 		   inpFromDate, inpFromProfile, inpFromWaypoint, 
 	       inpToDate, inpToProfile, inpToWaypoint;
-	private mLabel lblId;
-	private mButton btnFromDate,btnToDate;
-	private mCheckBox chkFromLogged, chkToLogged;
+	private Label lblId;
+	private Button btnFromDate,btnToDate;
+	private CheckBox chkFromLogged, chkToLogged;
 	private HtmlDisplay txtMission;
-	private mTabbedPanel pnlTab;
+	private TabbedPanel pnlTab;
     /**	 List of TBs in the current cache */
 	private TravelbugList tblSrcCache; 
 	/** The currently selected row */
 	private int selectedRow=-1;
 	/** A label which holds the number of currently displayed travelbug journeys*/
-	private mLabel lblNumVisibleJourneys;
+	private Label lblNumVisibleJourneys;
 	private final Color RED=new Color(255,0,0);
 	private int exitKeys[]={75009};
 	/** A flag to track whether the current cache has to be saved because a travelbug
@@ -65,7 +78,7 @@
 		String cache=&quot;&quot;;
 		if (curCacheNo&gt;=0 &amp;&amp; curCacheNo&lt;cacheDB.size()) {
 			ch=(CacheHolder)cacheDB.elementAt(curCacheNo);
-			cache=MyLocale.getMsg(6022,&quot;: Current cache: &quot;)+ch.wayPoint+&quot; - &quot;+ch.CacheName;
+			cache=MyLocale.getMsg(6022,&quot;: Current cache: &quot;)+ch.wayPoint+&quot; - &quot;+ch.cacheName;
 			waypoint=ch.wayPoint;
 			chD=new CacheHolderDetail(ch);
 			try {
@@ -73,46 +86,46 @@
 			}catch (Exception ex) {
 				Global.getPref().log(&quot;Failed to read cache &quot;+ch.wayPoint);
 			};
-			tblSrcCache=chD.Travelbugs;
+			tblSrcCache=chD.travelbugs;
 		}
 		title=&quot;Travelbugs&quot;+cache;
 		tcTbJourneyList=new tbListControl();
 		tcTbJourneyList.setTableModel(modTbJourneyList=new tbListTableModel());
-		tablepane.addLast(new MyScrollBarPanel(tcTbJourneyList,ScrollablePanel.AlwaysShowVerticalScrollers),STRETCH,FILL);
+		tablepane.addLast(new MyScrollBarPanel(tcTbJourneyList,ScrollBarPanel.AlwaysShowVerticalScrollers),STRETCH,FILL);
 	
 		lowerpane = split.getNextPanel();
 		
-		pnlTab=new mTabbedPanel();
-		pnlTab.extraControlsRight=lblNumVisibleJourneys=new mLabel(&quot;  0&quot;);
+		pnlTab=new TabbedPanel();
+		pnlTab.extraControlsRight=lblNumVisibleJourneys=new Label(&quot;  0&quot;);
 		//------------------------------------------------
 		// First Tab - Name &amp; Tracking #
 		//------------------------------------------------
 		CellPanel pnlName=new CellPanel();
-		pnlName.addNext(new mLabel(MyLocale.getMsg(6025,&quot;Name:&quot;)),DONTSTRETCH,DONTFILL);
-		pnlName.addLast(inpName=new mInput(),HSTRETCH,HFILL);
-		pnlName.addNext(new mLabel(MyLocale.getMsg(6026,&quot;Tracking #:&quot;)),DONTSTRETCH,DONTFILL);
-		pnlName.addLast(inpTrackingNo=new mInput(),HSTRETCH,HFILL);
-		pnlName.addNext(new mLabel(MyLocale.getMsg(6027,&quot;ID/GUID:&quot;)),DONTSTRETCH,DONTFILL);
-		pnlName.addLast(lblId=new mLabel(&quot;&quot;),HSTRETCH,HFILL);
+		pnlName.addNext(new Label(MyLocale.getMsg(6025,&quot;Name:&quot;)),DONTSTRETCH,DONTFILL);
+		pnlName.addLast(inpName=new Input(),HSTRETCH,HFILL);
+		pnlName.addNext(new Label(MyLocale.getMsg(6026,&quot;Tracking #:&quot;)),DONTSTRETCH,DONTFILL);
+		pnlName.addLast(inpTrackingNo=new Input(),HSTRETCH,HFILL);
+		pnlName.addNext(new Label(MyLocale.getMsg(6027,&quot;ID/GUID:&quot;)),DONTSTRETCH,DONTFILL);
+		pnlName.addLast(lblId=new Label(&quot;&quot;),HSTRETCH,HFILL);
 		pnlTab.addCard(pnlName,MyLocale.getMsg(6028,&quot;Name&quot;),&quot;Name&quot;);
 		
 		//------------------------------------------------
 		// Second Tab - Where was the TB picked up from
 		//------------------------------------------------
 		CellPanel pnlFrom=new CellPanel();
-		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6029,&quot;Profile/Cache:&quot;)),DONTSTRETCH,DONTFILL|WEST);
-		pnlFrom.addNext(inpFromProfile=new mInput(),HSTRETCH,HFILL);
-		pnlFrom.addLast(inpFromWaypoint=new mInput(),HSTRETCH,HFILL);
+		pnlFrom.addNext(new Label(MyLocale.getMsg(6029,&quot;Profile/Cache:&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		pnlFrom.addNext(inpFromProfile=new Input(),HSTRETCH,HFILL);
+		pnlFrom.addLast(inpFromWaypoint=new Input(),HSTRETCH,HFILL);
 		
-		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6030,&quot;Date found:&quot;)),DONTSTRETCH,DONTFILL|WEST);
-		pnlFrom.addNext(inpFromDate=new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		pnlFrom.addLast(btnFromDate=new mButton(new mImage(&quot;calendar.png&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		pnlFrom.addNext(new Label(MyLocale.getMsg(6030,&quot;Date found:&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		pnlFrom.addNext(inpFromDate=new Input(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		pnlFrom.addLast(btnFromDate=new Button(new Picture(&quot;calendar.png&quot;)),DONTSTRETCH,DONTFILL|WEST);
 		btnFromDate.modify(0,ControlConstants.TakesKeyFocus);
 		
-		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6031,&quot;Logged:&quot;)),DONTSTRETCH,DONTFILL|WEST);
-		pnlFrom.addLast(chkFromLogged=new mCheckBox(&quot;&quot;),DONTSTRETCH,DONTFILL|WEST);
+		pnlFrom.addNext(new Label(MyLocale.getMsg(6031,&quot;Logged:&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		pnlFrom.addLast(chkFromLogged=new CheckBox(&quot;&quot;),DONTSTRETCH,DONTFILL|WEST);
 		chkFromLogged.exitKeys=exitKeys;
-		pnlFrom.addLast(new mLabel(&quot;&quot;));
+		pnlFrom.addLast(new Label(&quot;&quot;));
 		
 		pnlTab.addCard(pnlFrom,MyLocale.getMsg(6032,&quot;From&quot;),&quot;From&quot;);
 
@@ -120,21 +133,21 @@
 		// Third Tab - Where was the TB dropped
 		//------------------------------------------------
 		CellPanel pnlTo=new CellPanel();
-		pnlTo.addNext(new mLabel(MyLocale.getMsg(6029,&quot;Profile/Cache:&quot;)),DONTSTRETCH,DONTFILL|WEST);
-		pnlTo.addNext(inpToProfile=new mInput(),HSTRETCH,HFILL);
-		pnlTo.addLast(inpToWaypoint=new mInput(),HSTRETCH,HFILL);
+		pnlTo.addNext(new Label(MyLocale.getMsg(6029,&quot;Profile/Cache:&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		pnlTo.addNext(inpToProfile=new Input(),HSTRETCH,HFILL);
+		pnlTo.addLast(inpToWaypoint=new Input(),HSTRETCH,HFILL);
 		
-		pnlTo.addNext(new mLabel(MyLocale.getMsg(6033,&quot;Date dropped:&quot;)),DONTSTRETCH,DONTFILL|WEST);
-		pnlTo.addNext(inpToDate=new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		pnlTo.addNext(new Label(MyLocale.getMsg(6033,&quot;Date dropped:&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		pnlTo.addNext(inpToDate=new Input(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		//inpToDate.modifyAll(DisplayOnly,0);
-		pnlTo.addLast(btnToDate=new mButton(new mImage(&quot;calendar.png&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		pnlTo.addLast(btnToDate=new Button(new Picture(&quot;calendar.png&quot;)),DONTSTRETCH,DONTFILL|WEST);
 		btnToDate.modify(0,ControlConstants.TakesKeyFocus);
-		//pnlTo.addLast(new mLabel(&quot;&quot;));
+		//pnlTo.addLast(new Label(&quot;&quot;));
 		
-		pnlTo.addNext(new mLabel(MyLocale.getMsg(6031,&quot;Logged:&quot;)),DONTSTRETCH,DONTFILL|WEST);
-		pnlTo.addLast(chkToLogged=new mCheckBox(&quot;&quot;),DONTSTRETCH,DONTFILL|WEST);
+		pnlTo.addNext(new Label(MyLocale.getMsg(6031,&quot;Logged:&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		pnlTo.addLast(chkToLogged=new CheckBox(&quot;&quot;),DONTSTRETCH,DONTFILL|WEST);
 		chkToLogged.exitKeys=exitKeys;
-		pnlTo.addLast(new mLabel(&quot;&quot;));
+		pnlTo.addLast(new Label(&quot;&quot;));
 		
 		pnlTab.addCard(pnlTo,MyLocale.getMsg(6034,&quot;To&quot;),&quot;To&quot;);
 		
@@ -142,7 +155,7 @@
 		// Last Panel - TB Mission
 		//------------------------------------------------
 		CellPanel pnlDest=new CellPanel();
-		pnlDest.addLast(new mLabel(MyLocale.getMsg(6035,&quot;Mission:&quot;)));
+		pnlDest.addLast(new Label(MyLocale.getMsg(6035,&quot;Mission:&quot;)));
 		pnlDest.addLast(txtMission=new HtmlDisplay(),STRETCH,FILL);
 		txtMission.rows=3;
 		pnlTab.addCard(pnlDest,MyLocale.getMsg(6036,&quot;Mission&quot;),&quot;Mission&quot;);
@@ -201,12 +214,12 @@
 			tcTbJourneyList.repaint();
 		}
 		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED &amp;&amp; selectedRow!=-1){
-			if (ev.target==inpTrackingNo) {pnlTab.selectNextTab(true,true); Gui.takeFocus(inpFromProfile,ControlConstants.ByKeyboard);pnlTab.repaint(); }
-			if (ev.target==inpFromDate) Gui.takeFocus(chkFromLogged,ControlConstants.ByKeyboard);
-			if (ev.target==inpToDate) Gui.takeFocus(chkToLogged,ControlConstants.ByKeyboard);
+			if (ev.target==inpTrackingNo) {pnlTab.selectNextTab(true,true); Gui.takeFocus(inpFromProfile,Control.ByKeyboard);pnlTab.repaint(); }
+			if (ev.target==inpFromDate) Gui.takeFocus(chkFromLogged,Control.ByKeyboard);
+			if (ev.target==inpToDate) Gui.takeFocus(chkToLogged,Control.ByKeyboard);
 			if (ev.target==btnFromDate || ev.target==btnToDate) {
-				mInput inpDate=ev.target==btnFromDate ? inpFromDate : inpToDate;
-				DateTimeChooser dc=new DateTimeChooser(Vm.getLocale());
+				Input inpDate=ev.target==btnFromDate ? inpFromDate : inpToDate;
+				DateTimeChooser dc=new DateTimeChooser(Vm.getLocale(), false);
 				dc.title=MyLocale.getMsg(328,&quot;Date found&quot;); 
 				dc.setPreferredSize(240,240);
 				String foundDate=inpDate.getText();
@@ -219,22 +232,22 @@
 					} catch(IllegalArgumentException e1) {}
 				};
 				dc.reset(t);
-				if (dc.execute()==ewe.ui.FormBase.IDOK) {
+				if (dc.execute()==eve.ui.FormBase.IDOK) {
 				  inpDate.setText(Convert.toString(dc.year)+&quot;-&quot;+MyLocale.formatLong(dc.month,&quot;00&quot;)+&quot;-&quot;+MyLocale.formatLong(dc.day,&quot;00&quot;)+&quot; &quot;+dc.time);
 				  if (ev.target==btnFromDate){ 
 					  tblMyTravelbugJourneys.getTBJourney(selectedRow).setFromDate(inpDate.getText());
-					  Gui.takeFocus(chkFromLogged,ControlConstants.ByKeyboard);
+					  Gui.takeFocus(chkFromLogged,Control.ByKeyboard);
 				  } else {
 					  tblMyTravelbugJourneys.getTBJourney(selectedRow).setToDate(inpDate.getText());
-					  Gui.takeFocus(chkToLogged,ControlConstants.ByKeyboard);
+					  Gui.takeFocus(chkToLogged,Control.ByKeyboard);
 				  } tcTbJourneyList.repaint();
 				}				
 			}
 		}
 		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.EXITED){
 			pnlTab.selectNextTab(true,true); 
-			if (ev.target==chkFromLogged) Gui.takeFocus(inpToProfile,ControlConstants.ByKeyboard);
-			if (ev.target==chkToLogged) Gui.takeFocus(txtMission,ControlConstants.ByKeyboard);
+			if (ev.target==chkFromLogged) Gui.takeFocus(inpToProfile,Control.ByKeyboard);
+			if (ev.target==chkToLogged) Gui.takeFocus(txtMission,Control.ByKeyboard);
 		}
 		// The user closed the travelbugs screen
 		if (ev instanceof FormEvent &amp;&amp; ev.type==FormEvent.CLOSED  &amp;&amp; chD!=null) {
@@ -245,7 +258,7 @@
 			Global.getPref().travelbugShowOnlyNonLogged=(tcTbJourneyList.mnuToggleList.modifiers &amp; MenuItem.Checked) == MenuItem.Checked;
 			String travelbugColWidth=modTbJourneyList.getColWidths();
 			// If the preferences changed, save the pref.xml file
-			Vm.showWait(true);
+			Form.showWait();
 			if (!Global.getPref().travelbugColWidth.equals(travelbugColWidth) ||
 				old!=Global.getPref().travelbugShowOnlyNonLogged) {
 				Global.getPref().travelbugColWidth=travelbugColWidth;
@@ -254,9 +267,9 @@
 			// If the list of travelbugs in the cache was modified, we need to save the cache too
 			if (chDmodified) {
 				chD.saveCacheDetails(Global.getProfile().dataDir);
-				ch.has_bug=chD.Travelbugs.size()&gt;0;
+				ch.has_bug=chD.travelbugs.size()&gt;0;
 			}
-			Vm.showWait(false);
+			Form.cancelWait();
 			chD=null;
 		}
 		updateNumBugs();
@@ -269,7 +282,7 @@
 //==============================================================
 class tbListTableModel extends TableModel {
 	private FontMetrics fm;
-	private Image imgRed;
+	private Picture imgRed;
 	tbListTableModel() {
 		
 		fillToEqualHeights=true;
@@ -280,34 +293,31 @@
 		clipData=true;
 		fm=getFontMetrics();
 		// A red dot indicates that the journey has not been completely logged
-		imgRed = new Image(&quot;red.png&quot;);
+		imgRed = new Picture(&quot;red.png&quot;);
 	}
     private int colWidth[];
 	private int columnMap[];
 	
-	public Object getCellText(int row, int col) {
-		return null;
-	}
+//	public Object getCellText(int row, int col) {
+//		return null;
+//	}
 
 	public Object getCellData(int row, int col){
-		if(row == -1){
+		if(row == -1)
 			return TravelbugJourney.getElementNameByNumber(columnMap[col]);
-		} else {
-			int map=columnMap[col];
-			// If we have not yet logged the from or the to, a red dot is placed in front of the first item
-			if (col==0 &amp;&amp; (!tblMyTravelbugJourneys.getTBJourney(row).getFromLogged() ||
-				!tblMyTravelbugJourneys.getTBJourney(row).getToLogged())) { 
-				// Is it a column with a checkbox?
-				if (map!=7 &amp;&amp; map!=11) 
-					return new IconAndText((IImage)imgRed,(String) tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map),fm);
-				else { // Checkbox - special treatment
-					IconAndText iat=new IconAndText(imgRed,&quot;&quot;,fm);
-					iat.addColumn(tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map));
-					return iat;
-				}
-			} else 
-				return tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map);
-		}	
+		int map=columnMap[col];
+		// If we have not yet logged the from or the to, a red dot is placed in front of the first item
+		if (col==0 &amp;&amp; (!tblMyTravelbugJourneys.getTBJourney(row).getFromLogged() ||
+			!tblMyTravelbugJourneys.getTBJourney(row).getToLogged())) { 
+			// Is it a column with a checkbox?
+			if (map!=7 &amp;&amp; map!=11) 
+				return new IconAndText((IImage)imgRed,(String) tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map),fm);
+			// Checkbox - special treatment
+			IconAndText iat=new IconAndText(imgRed,&quot;&quot;,fm);
+			iat.addColumn(tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map));
+			return iat;
+		}
+		return tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map);
 	}
 	public int calculateRowHeight(int row) {
 		return charHeight+2;
@@ -361,7 +371,7 @@
 	public boolean penPressed(Point onTable,Point cell){
 		boolean retval=false;
 		if(cell!=null &amp;&amp; cell.y == -1){ // Hit a header =&gt; sort the table accordingly
-			Vm.showWait(true);
+			Form.showWait();
 			if (cell.x == sortedBy) sortAsc=!sortAsc;
 			else sortAsc = false;
 			sortedBy = cell.x;
@@ -373,9 +383,9 @@
 				tblMyTravelbugJourneys.sort(columnMap[cell.x], sortAsc);
 			}
 			tcTbJourneyList.repaint();
-			Vm.showWait(false);
+			Form.cancelWait();
 			retval = true;
-		} else if (cell!=null &amp;&amp; cell.y&gt;=0 &amp;&amp; (penEventModifiers &amp; IKeys.SHIFT)&gt;0) {
+		} else if (cell!=null &amp;&amp; cell.y&gt;=0 &amp;&amp; (penEventModifiers &amp; eve.fx.gui.IKeys.SHIFT)&gt;0) {
 			// A range of rows can be marked by shift-click on the first and last row
 			if (lastRow!=-1) { // Second row being marked with shift key pressed
 				if (lastRow&lt;cell.y)
@@ -494,7 +504,7 @@
 		if (selectedItem==mnuDropTB) {
 			if (selectedRow&gt;=0 &amp;&amp; selectedRow&lt;modTbJourneyList.numRows) {
 				Travelbug tb=tblMyTravelbugJourneys.getTBJourney(selectedRow).getTb();
-				chD.Travelbugs.add(tb);
+				chD.travelbugs.add(tb);
 				tblMyTravelbugJourneys.addTbDrop(tb,Global.getProfile().name,waypoint);
 				chDmodified=true;
 				ch.has_bug=true;
@@ -534,19 +544,19 @@
 		if (selectedItem==mnuGetMission &amp;&amp; selectedRow&gt;-1) {
 			TravelbugJourney tbj=tblMyTravelbugJourneys.getTBJourney(selectedRow);
 			SpiderGC spider=new SpiderGC(Global.getPref(),Global.getProfile(),false);
-			Vm.showWait(true);
+			Form.showWait();
 			
 			//if we have an ID, get mission by ID
 			if (tbj.getTb().getGuid().length()!=0) {
 				tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
 			} else {
 				//try to get mission and name by tracking number
-				boolean suceeded = false;
+				boolean succeeded = false;
 				if (tbj.getTb().getTrackingNo().length() != 0) {
-					suceeded = spider.getBugMissionAndNameByTrackNr(tbj.getTb());
+					succeeded = spider.getBugMissionAndNameByTrackNr(tbj.getTb());
 				}
 				//if this has't worked, try to get ID by name
-				if (!suceeded) {
+				if (!succeeded) {
 					tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName().trim()));
 					//if we have an ID now, get mission by ID
 					if (tbj.getTb().getGuid().length()!=0) {
@@ -555,7 +565,7 @@
 				}
 			}
 			
-			Vm.showWait(false);
+			Form.cancelWait();
 			tcTbJourneyList.repaint();
 			txtMission.setHtml(tbj.getTb().getMission());
 			inpName.setText(tbj.getTb().getName());
@@ -565,20 +575,20 @@
 		if (selectedItem==mnuOpenOnline &amp;&amp; selectedRow&gt;=0) {
 			TravelbugJourney tbj=tblMyTravelbugJourneys.getTBJourney(selectedRow);
 			SpiderGC spider=new SpiderGC(Global.getPref(),Global.getProfile(),false);
-			Vm.showWait(true);
+			Form.showWait();
 			// First check whether ID is set, if not get it
 			if (tbj.getTb().getGuid().length()==0) tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName()));
 			if (tbj.getTb().getGuid().length()!=0) {
-				Vm.showWait(false);
+				Form.cancelWait();
 				try {
 					String s;
 					if (tbj.getTb().getGuid().length()&gt;10)
-						s = &quot;<A HREF="http://www.geocaching.com/track/details.aspx?guid=">http://www.geocaching.com/track/details.aspx?guid=</A>&quot;+tbj.getTb().getGuid();
+						s = &quot;\&quot;&quot;+Global.getPref().browser+&quot;\&quot; \&quot;<A HREF="http://www.geocaching.com/track/details.aspx?guid=">http://www.geocaching.com/track/details.aspx?guid=</A>&quot;+tbj.getTb().getGuid()+&quot;\&quot;&quot;;
 					else
-						s = &quot;<A HREF="http://www.geocaching.com/track/details.aspx?id=">http://www.geocaching.com/track/details.aspx?id=</A>&quot;+tbj.getTb().getGuid();
-
-					CWWrapper.exec(Global.getPref().browser, s);
-					Global.getPref().log(&quot;Executing: \&quot;&quot;+Global.getPref().browser+&quot;\&quot; \&quot;&quot;+s+&quot;\&quot;&quot;);
+						s = &quot;\&quot;&quot;+Global.getPref().browser+&quot;\&quot; \&quot;<A HREF="http://www.geocaching.com/track/details.aspx?id=">http://www.geocaching.com/track/details.aspx?id=</A>&quot;+tbj.getTb().getGuid()+&quot;\&quot;&quot;;
+									
+					Vm.execCommandLine(s);
+					Global.getPref().log(&quot;Executing: &quot;+s); 
 				} catch (Exception ioex) {
 				}
 			}

Modified: experiments/engywuck/hist-test/src/cachewolf/TravelbugList.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/TravelbugList.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/TravelbugList.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,12 +1,12 @@
-package CacheWolf;
+package cachewolf;
 /**
  * A list of GC travelbugs
  * @author salzkammergut
  */
-import ewe.util.Vector;
-import ewe.io.*;
+import java.util.Vector;
 import ewesoft.xml.*;
 import ewesoft.xml.sax.*;
+import java.io.StringReader;
 
 public class TravelbugList extends MinML{
 
@@ -40,7 +40,7 @@
 
 	/** Replace a travelbug in the list */
 	public void replace(int i, Travelbug tb) {
-		tbList.set(i, tb);
+		tbList.setElementAt( tb,i);
 	}
 	
 	/** Construct an empty travelbug list */

Modified: experiments/engywuck/hist-test/src/cachewolf/TravelbugPickup.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/TravelbugPickup.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/TravelbugPickup.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,6 +1,6 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.ui.InputBox;
+import eve.ui.data.InputBox;
 
 public class TravelbugPickup {
 

Modified: experiments/engywuck/hist-test/src/cachewolf/TravelbugScreen.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/TravelbugScreen.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/TravelbugScreen.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,6 +1,10 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.ui.*;
+import cachewolf.utils.SafeXML;
+import eve.ui.*;
+import eve.sys.Event;
+import eve.ui.event.ListEvent;
+import eve.ui.event.ControlEvent;
 
 /**
  * Choose a travelbug to pick up or drop
@@ -8,7 +12,7 @@
  */ 
 public class TravelbugScreen extends Form {
 	private myList disp;
-	private mButton btCancel,btAccept;
+	private Button btCancel,btAccept;
 	/** The index into the list of travelbugs indicating the selected bug */
 	public int selectedItem=-1;
 	
@@ -19,18 +23,18 @@
 	 * @param allowNew True if a travelbug not on the list can be selected
 	 */
 	TravelbugScreen(TravelbugList tbl, String title,boolean allowNew) {
-		this.setTitle(title);
+		this.title=title;
 		this.setPreferredSize(240, -1);
 		disp=new myList(tbl,allowNew);
-		ScrollBarPanel sbp = new MyScrollBarPanel(disp, ScrollablePanel.NeverShowHorizontalScrollers);
+		ScrollBarPanel sbp = new MyScrollBarPanel(disp, ScrollBarPanel.NeverShowHorizontalScrollers);
 		this.addLast(sbp);
-		this.addNext(btCancel = new mButton(MyLocale.getMsg(614,&quot;Cancel&quot;)),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		this.addLast(btAccept = new mButton(&quot;OK&quot;),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		this.addNext(btCancel = new Button(MyLocale.getMsg(614,&quot;Cancel&quot;)),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		this.addLast(btAccept = new Button(&quot;OK&quot;),CellConstants.DONTSTRETCH, CellConstants.FILL);
 		btAccept.modify(Disabled,0);
 	}
 
 	public void onEvent(Event ev){
-        if (ev instanceof ListEvent &amp;&amp; ev.type==MenuEvent.SELECTED) {
+        if (ev instanceof ListEvent &amp;&amp; ev.type==ListEvent.SELECTED) {
         	btAccept.modify(0,Disabled);
         	btAccept.repaint();
         }

Added: experiments/engywuck/hist-test/src/cachewolf/URL.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/URL.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/URL.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -0,0 +1,867 @@
+package cachewolf;
+
+// Only needed for OCXMLImporter
+
+/* URL.java -- Uniform Resource Locator Class
+Copyright (C) 1998, 1999, 2000, 2002, 2003  Free Software Foundation, Inc.
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+02111-1307 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+
+
+import java.net.MalformedURLException;
+
+
+/*
+* Written using on-line Java Platform 1.2 API Specification, as well
+* as &quot;The Java Class Libraries&quot;, 2nd edition (Addison-Wesley, 1998).
+* Status:  Believed complete and correct.
+*/
+
+/**
+* This final class represents an Internet Uniform Resource Locator (URL).
+* For details on the syntax of URL's and what they can be used for,
+* refer to RFC 1738, available from &lt;a 
+* href=&quot;<A HREF="http://ds.internic.net/rfcs/rfc1738.txt">http://ds.internic.net/rfcs/rfc1738.txt</A>&quot;&gt;<A HREF="http://ds.internic.net/rfcs/rfc1738.txt&lt;/a">http://ds.internic.net/rfcs/rfc1738.txt&lt;/a</A>&gt;
+* &lt;p&gt;
+* There are a great many protocols supported by URL's such as &quot;http&quot;,
+* &quot;ftp&quot;, and &quot;file&quot;.  This object can handle any arbitrary URL for which
+* a URLStreamHandler object can be written.  Default protocol handlers
+* are provided for the &quot;http&quot; and &quot;ftp&quot; protocols.  Additional protocols
+* handler implementations may be provided in the future.  In any case,
+* an application or applet can install its own protocol handlers that
+* can be &quot;chained&quot; with other protocol hanlders in the system to extend
+* the base functionality provided with this class. (Note, however, that
+* unsigned applets cannot access properties by default or install their
+* own protocol handlers).
+* &lt;p&gt;
+* This chaining is done via the system property java.protocol.handler.pkgs
+* If this property is set, it is assumed to be a &quot;|&quot; separated list of
+* package names in which to attempt locating protocol handlers.  The
+* protocol handler is searched for by appending the string 
+* &quot;.&lt;protocol&gt;.Handler&quot; to each packed in the list until a hander is found.
+* If a protocol handler is not found in this list of packages, or if the
+* property does not exist, then the default protocol handler of
+* &quot;gnu.java.net.&lt;protocol&gt;.Handler&quot; is tried.  If this is
+* unsuccessful, a MalformedURLException is thrown.
+* &lt;p&gt;
+* All of the constructor methods of URL attempt to load a protocol
+* handler and so any needed protocol handlers must be installed when
+* the URL is constructed.
+* &lt;p&gt;
+* Here is an example of how URL searches for protocol handlers.  Assume
+* the value of java.protocol.handler.pkgs is &quot;com.foo|com.bar&quot; and the
+* URL is &quot;<A HREF="news://comp.lang.java.programmer">news://comp.lang.java.programmer</A>&quot;.  URL would looking the 
+* following places for protocol handlers:
+* &lt;p&gt;&lt;pre&gt;
+* com.foo.news.Handler
+* com.bar.news.Handler
+* gnu.java.net.news.Handler
+* &lt;/pre&gt;&lt;p&gt;
+* If the protocol handler is not found in any of those locations, a
+* MalformedURLException would be thrown.
+* &lt;p&gt;
+* Please note that a protocol handler must be a subclass of
+* URLStreamHandler.
+* &lt;p&gt;
+* Normally, this class caches protocol handlers.  Once it finds a handler
+* for a particular protocol, it never tries to look up a new handler
+* again.  However, if the system property
+* gnu.java.net.nocache_protocol_handlers is set, then this
+* caching behavior is disabled.  This property is specific to this
+* implementation.  Sun's JDK may or may not do protocol caching, but it
+* almost certainly does not examine this property.
+* &lt;p&gt;
+* Please also note that an application can install its own factory for
+* loading protocol handlers (see setURLStreamHandlerFactory).  If this is
+* done, then the above information is superseded and the behavior of this
+* class in loading protocol handlers is dependent on that factory.
+*
+* @author Aaron M. Renn &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">arenn at urbanophile.com</A>&gt;
+* @author Warren Levy &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">warrenl at cygnus.com</A>&gt;
+*
+* @see URLStreamHandler
+*/
+public final class URL //implements Serializable
+{
+
+	/* The String version of the URL */
+	public String url;
+	
+/**
+* The name of the protocol for this URL.
+* The protocol is always stored in lower case.
+*/
+private String protocol;
+
+/**
+* The &quot;authority&quot; portion of the URL.
+*/
+private String authority;
+
+/**
+* The hostname or IP address of this protocol.
+* This includes a possible user. For example &lt;code&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">joe at some.host.net</A>&lt;/code&gt;.
+*/
+private String host;
+
+/**
+* The port number of this protocol or -1 if the port number used is
+* the default for this protocol.
+*/
+private int port = -1;	// Initialize for constructor using context.
+
+/**
+* The &quot;file&quot; portion of the URL. It is defined as &lt;code&gt;path[?query]&lt;/code&gt;.
+*/
+private String file;
+
+/**
+* The anchor portion of the URL.
+*/
+private String ref;
+
+/**
+* This is the hashCode for this URL
+*/
+private int hashCode = 0;
+
+/**
+* The protocol handler in use for this URL
+*/
+transient URLStreamHandler ph;
+
+/**
+* If an application installs its own protocol handler factory, this is
+* where we keep track of it.
+*/
+//private static URLStreamHandlerFactory factory;
+
+//private static final long serialVersionUID = -7627629688361524110L;
+
+/**
+* This a table where we cache protocol handlers to avoid the overhead
+* of looking them up each time.
+*/
+// private static Hashtable ph_cache = new Hashtable();
+
+/**
+* Whether or not to cache protocol handlers.
+*/
+// private static boolean cache_handlers;
+
+/**
+* The search path of packages to search for protocol handlers in.
+*/
+//private static String ph_search_path;
+/*
+static
+ {
+   String s = System.getProperty(&quot;gnu.java.net.nocache_protocol_handlers&quot;);
+   if (s == null)
+     cache_handlers = true;
+   else
+     cache_handlers = false;
+
+   ph_search_path = System.getProperty(&quot;java.protocol.handler.pkgs&quot;);
+
+   // Tack our default package on at the ends
+   if (ph_search_path != null)
+     ph_search_path = ph_search_path + &quot;|&quot; + &quot;gnu.java.net.protocol&quot;;
+   else
+     ph_search_path = &quot;gnu.java.net.protocol&quot;;
+ }
+*/
+/**
+* Constructs a URL and loads a protocol handler for the values passed as
+* arguments.
+* 
+* @param protocol The protocol for this URL (&quot;http&quot;, &quot;ftp&quot;, etc)
+* @param host The hostname or IP address to connect to
+* @param port The port number to use, or -1 to use the protocol's
+* default port
+* @param file The &quot;file&quot; portion of the URL.
+*
+* @exception MalformedURLException If a protocol handler cannot be loaded or
+* a parse error occurs.
+*/
+public URL(String protocol, String host, int port, String file)
+ throws MalformedURLException
+{
+ this(protocol, host, port, file, null);
+}
+
+/**
+* Constructs a URL and loads a protocol handler for the values passed in
+* as arugments.  Uses the default port for the protocol.
+*
+* @param protocol The protocol for this URL (&quot;http&quot;, &quot;ftp&quot;, etc)
+* @param host The hostname or IP address for this URL
+* @param file The &quot;file&quot; portion of this URL.
+*
+* @exception MalformedURLException If a protocol handler cannot be loaded or
+* a parse error occurs.
+*/
+public URL(String protocol, String host, String file)
+ throws MalformedURLException
+{
+ this(protocol, host, -1, file, null);
+}
+
+
+/**
+* This method initializes a new instance of &lt;code&gt;URL&lt;/code&gt; with the
+* specified protocol, host, port, and file.  Additionally, this method
+* allows the caller to specify a protocol handler to use instead of 
+* the default.  If this handler is specified, the caller must have
+* the &quot;specifyStreamHandler&quot; permission (see &lt;code&gt;NetPermission&lt;/code&gt;)
+* or a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.
+*
+* @param protocol The protocol for this URL (&quot;http&quot;, &quot;ftp&quot;, etc)
+* @param host The hostname or IP address to connect to
+* @param port The port number to use, or -1 to use the protocol's default
+* port
+* @param file The &quot;file&quot; portion of the URL.
+* @param ph The protocol handler to use with this URL.
+*
+* @exception MalformedURLException If no protocol handler can be loaded
+* for the specified protocol.
+* @exception SecurityException If the &lt;code&gt;SecurityManager&lt;/code&gt; exists
+* and does not allow the caller to specify its own protocol handler.
+*
+* @since 1.2
+*/
+public URL (String protocol, String host, int port, String file,
+	      URLStreamHandler ph)
+ throws MalformedURLException
+{
+ if (protocol == null)
+   throw new MalformedURLException(&quot;null protocol&quot;);
+ this.protocol = protocol.toLowerCase();
+
+ if (ph != null)
+   {
+			/*
+	SecurityManager s = System.getSecurityManager();
+	if (s != null)
+	  s.checkPermission (new NetPermission (&quot;specifyStreamHandler&quot;));
+			*/
+     this.ph = ph;
+   }
+ else
+   this.ph = getURLStreamHandler(protocol);
+
+ if (this.ph == null)
+   throw new MalformedURLException (
+		      &quot;Protocol handler not found: &quot; + protocol);
+
+ this.host = host;
+ this.port = port;
+ this.authority = null;
+
+ int hashAt = file.indexOf('#');
+ if (hashAt &lt; 0)
+   {
+	this.file = file;
+	this.ref = null;
+   }
+ else
+   {
+	this.file = file.substring(0, hashAt);
+	this.ref = file.substring(hashAt + 1);
+   }
+ hashCode = hashCode();			// Used for serialization.
+		url = toString();
+}
+
+/**
+* Initializes a URL from a complete string specification such as
+* &quot;<A HREF="http://www.urbanophile.com/arenn/">http://www.urbanophile.com/arenn/</A>&quot;.  First the protocol name is parsed
+* out of the string.  Then a handler is located for that protocol and
+* the parseURL() method of that protocol handler is used to parse the
+* remaining fields.
+*
+* @param spec The complete String representation of a URL
+*
+* @exception MalformedURLException If a protocol handler cannot be found
+* or the URL cannot be parsed
+*/
+public URL(String spec) throws MalformedURLException
+{
+ this((URL) null, spec, (URLStreamHandler) null);
+}
+
+/*
+* This method parses a String representation of a URL within the
+* context of an existing URL.  Principally this means that any
+* fields not present the URL are inheritied from the context URL.
+* This allows relative URL's to be easily constructed.  If the
+* context argument is null, then a complete URL must be specified
+* in the URL string.  If the protocol parsed out of the URL is
+* different from the context URL's protocol, then then URL String
+* is also expected to be a complete URL.
+*
+* @param context The context on which to parse the specification
+* @param spec The string to parse an URL
+*
+* @exception MalformedURLException If a protocol handler cannot be found 
+* for the URL cannot be parsed
+*/
+public URL(URL context, String spec) throws MalformedURLException
+{
+ this(context, spec, (URLStreamHandler) null);
+}
+
+/**
+* Creates an URL from given arguments
+* This method parses a String representation of a URL within the
+* context of an existing URL.  Principally this means that any fields
+* not present the URL are inheritied from the context URL.  This allows
+* relative URL's to be easily constructed.  If the context argument is
+* null, then a complete URL must be specified in the URL string.
+* If the protocol parsed out of the URL is different 
+* from the context URL's protocol, then then URL String is also
+* expected to be a complete URL.
+* &lt;p&gt;
+* Additionally, this method allows the caller to specify a protocol handler
+* to use instead of  the default.  If this handler is specified, the caller
+* must have the &quot;specifyStreamHandler&quot; permission
+* (see &lt;code&gt;NetPermission&lt;/code&gt;) or a &lt;code&gt;SecurityException&lt;/code&gt;
+* will be thrown.
+*
+* @param context The context in which to parse the specification
+* @param spec The string to parse as an URL
+* @param ph The stream handler for the URL
+*
+* @exception MalformedURLException If a protocol handler cannot be found
+* or the URL cannot be parsed
+* @exception SecurityException If the &lt;code&gt;SecurityManager&lt;/code&gt; exists
+* and does not allow the caller to specify its own protocol handler.
+*
+* @since 1.2
+*/
+public URL(URL context, String spec, URLStreamHandler ph)
+ throws MalformedURLException
+{
+ /* A protocol is defined by the doc as the substring before a ':'
+  * as long as the ':' occurs before any '/'.
+  *
+  * If context is null, then spec must be an absolute URL.
+  *
+  * The relative URL need not specify all the components of a URL.
+  * If the protocol, host name, or port number is missing, the value
+  * is inherited from the context.  A bare file component is appended
+  * to the context's file.  The optional anchor is not inherited. 
+  */
+
+ // If this is an absolute URL, then ignore context completely.
+ // An absolute URL must have chars prior to &quot;://&quot; but cannot have a colon
+ // right after the &quot;://&quot;.  The second colon is for an optional port value
+ // and implies that the host from the context is used if available.
+ int colon;
+ if ((colon = spec.indexOf(&quot;://&quot;, 1)) &gt; 0 &amp;&amp;
+	! spec.regionMatches(colon, &quot;://:&quot;, 0, 4))
+   context = null;
+
+ int slash;
+ if ((colon = spec.indexOf(':')) &gt; 0 &amp;&amp;
+	(colon &lt; (slash = spec.indexOf('/')) || slash &lt; 0))
+   {
+	// Protocol specified in spec string.
+	protocol = spec.substring(0, colon).toLowerCase();
+	if (context != null &amp;&amp; context.protocol.equals(protocol))
+	  {
+	    // The 1.2 doc specifically says these are copied to the new URL.
+	    host = context.host;
+	    port = context.port;
+	    file = context.file;
+	    authority = context.authority;
+	  }
+   }
+ else if (context != null)
+   {
+	// Protocol NOT specified in spec string.
+	// Use context fields (except ref) as a foundation for relative URLs.
+	colon = -1;
+	protocol = context.protocol;
+	host = context.host;
+	port = context.port;
+	file = context.file;
+     authority = context.authority;
+   }
+ else	// Protocol NOT specified in spec. and no context available.
+   throw new
+	  MalformedURLException(&quot;Absolute URL required with null context&quot;);
+
+ if (ph != null)
+   {
+			/*
+	SecurityManager s = System.getSecurityManager ();
+	if (s != null)
+	  s.checkPermission (new NetPermission (&quot;specifyStreamHandler&quot;));
+			*/
+     this.ph = ph;
+   }
+ else
+   this.ph = getURLStreamHandler(protocol);
+
+ if (this.ph == null)
+   throw new MalformedURLException(&quot;Protocol handler not found: &quot;
+				      + protocol);
+
+ // JDK 1.2 doc for parseURL specifically states that any '#' ref
+ // is to be excluded by passing the 'limit' as the indexOf the '#'
+ // if one exists, otherwise pass the end of the string.
+ int hashAt = spec.indexOf('#', colon + 1);
+ this.ph.parseURL(this, spec, colon + 1,
+		     hashAt &lt; 0 ? spec.length() : hashAt);
+ if (hashAt &gt;= 0)
+   ref = spec.substring(hashAt + 1);
+
+ hashCode = hashCode();			// Used for serialization.
+		url = toString();
+}
+
+/**
+* Test another URL for equality with this one.  This will be true only if
+* the argument is non-null and all of the fields in the URL's match 
+* exactly (ie, protocol, host, port, file, and ref).  Overrides
+* Object.equals(), implemented by calling the equals method of the handler.
+*
+* @param url The URL to compare with
+*
+* @return true if the URL is equal, false otherwise
+*/
+public boolean equals (Object obj)
+{
+ if (obj == null || ! (obj instanceof URL))
+   return false;
+
+ return ph.equals (this, (URL) obj);
+}
+
+/**
+* Returns the contents of this URL as an object by first opening a
+* connection, then calling the getContent() method against the connection
+*
+* @return A content object for this URL
+* @exception IOException If opening the connection or getting the
+* content fails.
+*
+* @since 1.3
+*/
+		/*
+public final Object getContent() throws IOException
+{
+ return openConnection().getContent();
+}
+		*/
+/**
+* Gets the contents of this URL
+*
+* @exception IOException If an error occurs
+*/
+		/*
+public final Object getContent (Class[] classes) throws IOException
+{
+ // FIXME: implement this
+ return getContent();
+}
+	 */
+
+/**
+* Returns the file portion of the URL.
+* Defined as &lt;code&gt;path[?query]&lt;/code&gt;.
+* Returns the empty string if there is no file portion.
+*/
+public String getFile()
+{
+ return file == null ? &quot;&quot; : file;
+}
+
+/**
+* Returns the path of the URL. This is the part of the file before any '?'
+* character.
+*
+* @since 1.3
+*/
+public String getPath()
+{
+ int quest = (file == null) ? -1 : file.indexOf('?');
+ return quest &lt; 0 ? getFile() : file.substring(0, quest);
+}
+
+/**
+* Returns the authority of the URL
+* 
+* @since 1.3
+*/
+public String getAuthority()
+{
+ return authority;
+}
+
+/**
+* Returns the host of the URL
+*/
+public String getHost()
+{
+ int at = (host == null) ? -1 : host.indexOf('@');
+ return at &lt; 0 ? host : host.substring(at + 1, host.length());
+}
+
+/**
+* Returns the port number of this URL or -1 if the default port number is
+* being used.
+*
+* @return The port number
+*
+* @see #getDefaultPort()
+*/
+public int getPort()
+{
+ return port;
+}
+
+/**
+* Returns the default port of the URL. If the StreamHandler for the URL
+* protocol does not define a default port it returns -1.
+*/
+		/*
+public int getDefaultPort()
+{
+ return ph.getDefaultPort();
+}
+*/
+/**
+* Returns the protocol of the URL
+*/
+public String getProtocol()
+{
+ return protocol;
+}
+
+/**
+* Returns the ref (sometimes called the &quot;# reference&quot; or &quot;anchor&quot;) portion
+* of the URL.
+*
+* @return The ref
+*/
+public String getRef()
+{
+ return ref;
+}
+
+/**
+* Returns the user information of the URL. This is the part of the host
+* name before the '@'.
+*
+* @return the user at a particular host or null when no user defined.
+*/
+public String getUserInfo ()
+{
+ int at = (host == null) ? -1 : host.indexOf('@');
+ return at &lt; 0 ? null : host.substring(0, at);
+}
+
+/**
+* Returns the query of the URL. This is the part of the file before the
+* '?'.
+*
+* @return the query part of the file, or null when there is no query part.
+*/
+public String getQuery ()
+{
+ int quest = (file == null) ? -1 : file.indexOf('?');
+ return quest &lt; 0 ? null : file.substring(quest + 1, file.length());
+}
+
+/**
+* Returns a hashcode computed by the URLStreamHandler of this URL
+*/
+public int hashCode()
+{
+ if (hashCode != 0)
+   return hashCode;		// Use cached value if available.
+ return ph.hashCode (this);
+}
+
+/**
+* Returns a URLConnection object that represents a connection to the remote
+* object referred to by the URL. The URLConnection is created by calling the
+* openConnection() method of the protocol handler
+*
+* @return A URLConnection for this URL
+* @exception IOException If an error occurs
+*/
+		/*
+public URLConnection openConnection() throws IOException
+{
+ return ph.openConnection(this);
+}
+ */
+/**
+* Opens a connection to this URL and returns an InputStream for reading
+* from that connection
+*
+* @exception IOException If an error occurs
+*/
+		/*
+public final InputStream openStream() throws IOException
+{
+ return openConnection().getInputStream();
+}
+*/
+/**
+* Tests whether or not another URL refers to the same &quot;file&quot; as this one.
+* This will be true if and only if the passed object is not null, is a
+* URL, and matches all fields but the ref (ie, protocol, host, port,
+* and file);
+*
+* @param url The URL object to test with
+*
+* @return true if URL matches this URL's file, false otherwise
+*/
+		/*
+public boolean sameFile(URL other)
+{
+ return ph.sameFile(this, other);
+}
+*/
+/**
+* Sets the specified fields of the URL. This is not a public method so
+* that only URLStreamHandlers can modify URL fields. This might be called
+* by the &lt;code&gt;parseURL()&lt;/code&gt; method in that class. URLs are otherwise
+* constant.
+*
+* @param protocol The protocol name for this URL
+* @param host The hostname or IP address for this URL
+* @param port The port number of this URL
+* @param file The &quot;file&quot; portion of this URL.
+* @param ref The anchor portion of this URL.
+*/
+protected void set(String protocol, String host, int port, String file,
+		     String ref)
+{
+ // TBD: Theoretically, a poorly written StreamHandler could pass an
+ // invalid protocol.  It will cause the handler to be set to null
+ // thus overriding a valid handler.  Callers of this method should
+ // be aware of this.
+ this.ph = getURLStreamHandler(protocol);
+ this.protocol = protocol.toLowerCase();
+ this.authority = null;
+ this.port = port;
+ this.host = host;
+ this.file = file;
+ this.ref = ref;
+ hashCode = hashCode();			// Used for serialization.
+}
+
+/**
+* Sets the specified fields of the URL. This is not a public method so
+* that only URLStreamHandlers can modify URL fields. URLs are otherwise
+* constant.
+*
+* @since 1.3
+*/
+protected void set(String protocol, String host, int port,
+		     String authority, String userInfo,
+		     String path, String query, String ref)
+{
+ // TBD: Theoretically, a poorly written StreamHandler could pass an
+ // invalid protocol.  It will cause the handler to be set to null
+ // thus overriding a valid handler.  Callers of this method should
+ // be aware of this.
+ this.ph = getURLStreamHandler(protocol);
+ this.protocol = protocol.toLowerCase();
+ if (userInfo == null)
+   this.host = host;
+ else
+   this.host = userInfo + &quot;@&quot; + host;
+ this.port = port;
+ if (query == null)
+   this.file = path;
+ else
+   this.file = path + &quot;?&quot; + query;
+ this.ref = ref;
+ hashCode = hashCode();			// Used for serialization.
+}
+
+/**
+* Sets the URLStreamHandlerFactory for this class.  This factory is
+* responsible for returning the appropriate protocol handler for
+* a given URL.
+*
+* @param fac The URLStreamHandlerFactory class to use
+*
+* @exception Error If the factory is alread set.
+* @exception SecurityException If a security manager exists and its
+* checkSetFactory method doesn't allow the operation
+*/
+		/*
+public static synchronized void
+	setURLStreamHandlerFactory(URLStreamHandlerFactory fac)
+{
+ if (factory != null)
+   throw new Error(&quot;URLStreamHandlerFactory already set&quot;);
+
+ // Throw an exception if an extant security mgr precludes
+ // setting the factory.
+ SecurityManager s = System.getSecurityManager();
+ if (s != null)
+   s.checkSetFactory();
+ factory = fac;
+}
+*/
+/**
+* Returns a String representing this URL.  The String returned is
+* created by calling the protocol handler's toExternalForm() method.
+*
+* @return A string for this URL
+*/
+public String toExternalForm()
+{
+ // Identical to toString().
+ return ph.toExternalForm(this);
+}
+
+/**
+* Returns a String representing this URL.  Identical to toExternalForm().
+* The value returned is created by the protocol handler's 
+* toExternalForm method.  Overrides Object.toString()
+*
+* @return A string for this URL
+*/
+public String toString()
+{
+ // Identical to toExternalForm().
+ return ph.toExternalForm(this);
+}
+
+/**
+* This internal method is used in two different constructors to load
+* a protocol handler for this URL.
+*
+* @param protocol The protocol to load a handler for
+*
+* @return A URLStreamHandler for this protocol, or null when not found.
+*/
+private static synchronized URLStreamHandler
+ getURLStreamHandler (String protocol)
+{
+ //URLStreamHandler ph;
+
+ // First, see if a protocol handler is in our cache
+		/*
+ if (cache_handlers)
+   {
+     Class cls = (Class)ph_cache.get(protocol);
+     if (cls != null)
+       {
+         try
+           {
+             ph = (URLStreamHandler)cls.newInstance();
+             return(ph);
+           }
+         catch (Exception e) { ; }
+       }
+   }
+			*/
+ // If a non-default factory has been set, use it to find the protocol.
+		/*
+ if (factory != null)
+   {
+     ph = factory.createURLStreamHandler(protocol);
+     if (ph != null)
+       {
+         if (cache_handlers)
+	      ph_cache.put(protocol, ph.getClass());
+
+         return(ph);
+	  }
+   }
+		*/
+ // Finally loop through our search path looking for a match
+		/*
+ StringTokenizer st = new StringTokenizer(ph_search_path, &quot;|&quot;);
+ while (st.hasMoreTokens())
+   {
+     String clsname = st.nextToken() + &quot;.&quot; + protocol + &quot;.Handler&quot;;
+      
+     try
+       {
+         Class cls = Class.forName(clsname); 
+         Object obj = cls.newInstance();
+         if (!(obj instanceof URLStreamHandler))
+           continue;
+         else
+           ph = (URLStreamHandler)obj;
+
+         if (cache_handlers)
+           ph_cache.put(protocol, cls);
+
+         return(ph);
+       }
+     catch (Exception e) { ; }
+   }
+			*/
+		return new URLStreamHandler();
+ // Still here, which is bad
+ //return null;
+}
+
+
+//===================================================================
+//public String toString() {return url;}
+//===================================================================
+
+/*
+private void readObject(ObjectInputStream ois)
+ throws IOException, ClassNotFoundException
+{
+ ois.defaultReadObject();
+ this.ph = getURLStreamHandler(protocol);
+ if (this.ph == null)
+   throw new IOException(&quot;Handler for protocol &quot; + protocol + &quot; not found&quot;);
+}
+
+private void writeObject(ObjectOutputStream oos) throws IOException
+{
+ oos.defaultWriteObject();
+}
+	*/
+}
+
+

Added: experiments/engywuck/hist-test/src/cachewolf/URLStreamHandler.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/URLStreamHandler.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/URLStreamHandler.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -0,0 +1,305 @@
+package cachewolf;
+
+//Only needed for OCXMLImporter
+
+/* URL.java -- Uniform Resource Locator Class
+Copyright (C) 1998, 1999, 2000, 2002, 2003  Free Software Foundation, Inc.
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+02111-1307 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+
+import eve.io.File;
+import java.io.IOException;
+
+//##################################################################
+public class URLStreamHandler{
+//##################################################################
+/**
+* Provides the default equals calculation. May be overidden by handlers for
+* other protocols that have different requirements for equals(). This method
+* requires that none of its arguments is null. This is guaranteed by the
+* fact that it is only called by java.net.URL class.
+*
+* @param url1 An URL object
+* @param url2 An URL object
+*/
+protected boolean equals (URL url1, URL url2)
+{
+ // This comparison is very conservative.  It assumes that any
+ // field can be null.
+ return (url1.getPort () == url2.getPort ()
+	    &amp;&amp; ((url1.getProtocol () == null &amp;&amp; url2.getProtocol () == null)
+		|| (url1.getProtocol () != null
+			&amp;&amp; url1.getProtocol ().equals (url2.getProtocol ())))
+	    &amp;&amp; ((url1.getUserInfo () == null &amp;&amp; url2.getUserInfo () == null)
+             || (url1.getUserInfo () != null
+			&amp;&amp; url1.getUserInfo ().equals(url2.getUserInfo ())))
+	    &amp;&amp; ((url1.getAuthority () == null &amp;&amp; url2.getAuthority () == null)
+             || (url1.getAuthority () != null
+			&amp;&amp; url1.getAuthority ().equals(url2.getAuthority ())))
+	    &amp;&amp; ((url1.getHost () == null &amp;&amp; url2.getHost () == null)
+		|| (url1.getHost () != null
+			&amp;&amp; url1.getHost ().equals(url2.getHost ())))
+	    &amp;&amp; ((url1.getPath () == null &amp;&amp; url2.getPath () == null)
+		|| (url1.getPath () != null
+			&amp;&amp; url1.getPath ().equals (url2.getPath ())))
+	    &amp;&amp; ((url1.getQuery () == null &amp;&amp; url2.getQuery () == null)
+             || (url1.getQuery () != null
+			&amp;&amp; url1.getQuery ().equals(url2.getQuery ())))
+	    &amp;&amp; ((url1.getRef () == null &amp;&amp; url2.getRef () == null)
+		|| (url1.getRef () != null
+			&amp;&amp; url1.getRef ().equals(url2.getRef ()))));
+}
+/**
+* Returns the default port for a URL parsed by this handler. This method is
+* meant to be overidden by handlers with default port numbers.
+*/
+protected int getDefaultPort ()
+{
+ return -1;
+}
+
+/**
+* Provides the default hash calculation. May be overidden by handlers for
+* other protocols that have different requirements for hashCode calculation.
+*/
+protected int hashCode (URL url)
+{
+ return url.getProtocol ().hashCode () +
+        ((url.getHost () == null) ? 0 : url.getHost ().hashCode ()) +
+	   url.getFile ().hashCode() +
+	   url.getPort ();
+}
+
+/**
+* This method converts a URL object into a String.  This method creates
+* Strings in the mold of http URL's, so protocol handlers which use URL's
+* that have a different syntax should override this method
+*
+* @param url The URL object to convert
+*/
+protected String toExternalForm(URL u)
+{
+ String protocol, host, file, ref;
+ int port;
+
+ protocol = u.getProtocol();
+
+ // JDK 1.2 online doc infers that host could be null because it
+ // explicitly states that file cannot be null, but is silent on host.
+ host = u.getHost();
+ if (host == null)
+   host = &quot;&quot;;
+
+ port = u.getPort();
+ file = u.getFile();
+ ref = u.getRef();
+
+ // Guess a reasonable size for the string buffer so we have to resize
+ // at most once.
+ int size = protocol.length() + host.length() + file.length() + 24;
+ StringBuffer sb = new StringBuffer(size);
+
+ if (protocol != null &amp;&amp; protocol.length() &gt; 0)
+   {
+	sb.append(protocol);
+	sb.append(&quot;:&quot;);
+   }
+
+ if (host.length() != 0)
+   sb.append(&quot;//&quot;).append(host);
+
+ // Note that this produces different results from JDK 1.2 as JDK 1.2
+ // ignores a non-default port if host is null or &quot;&quot;.  That is inconsistent
+ // with the spec since the result of this method is spec'ed so it can be
+ // used to construct a new URL that is equivalent to the original.
+ boolean port_needed = port &gt; 0 &amp;&amp; port != getDefaultPort();
+ if (port_needed)
+   sb.append(':').append(port);
+
+ sb.append(file);
+
+ if (ref != null)
+   sb.append('#').append(ref);
+
+ return sb.toString();
+}
+/**
+* This method parses the string passed in as a URL and set's the
+* instance data fields in the URL object passed in to the various values
+* parsed out of the string.  The start parameter is the position to start
+* scanning the string.  This is usually the position after the &quot;:&quot; which
+* terminates the protocol name.  The end parameter is the position to
+* stop scanning.  This will be either the end of the String, or the
+* position of the &quot;#&quot; character, which separates the &quot;file&quot; portion of
+* the URL from the &quot;anchor&quot; portion.
+* &lt;p&gt;
+* This method assumes URL's are formatted like http protocol URL's, so 
+* subclasses that implement protocols with URL's the follow a different 
+* syntax should override this method.  The lone exception is that if
+* the protocol name set in the URL is &quot;file&quot;, this method will accept
+* an empty hostname (i.e., &quot;<A HREF="file:///">file:///</A>&quot;), which is legal for that protocol
+*
+* @param url The URL object in which to store the results
+* @param spec The String-ized URL to parse
+* @param start The position in the string to start scanning from
+* @param end The position in the string to stop scanning
+*/
+protected void parseURL(URL url, String spec, int start, int end)
+{
+ String host = url.getHost();
+ int port = url.getPort();
+ String file = url.getFile();
+ String ref = url.getRef();
+ 
+ if (spec.regionMatches (start, &quot;//&quot;, 0, 2))
+   {
+	int hostEnd;
+	int colon;
+
+	start += 2;
+	int slash = spec.indexOf('/', start);
+	if (slash &gt;= 0) 
+	  hostEnd = slash;
+     else
+	  hostEnd = end;
+
+	host = spec.substring (start, hostEnd);
+	
+	// Look for optional port number.  It is valid for the non-port
+	// part of the host name to be null (e.g. a URL &quot;<A HREF="http://:80">http://:80</A>&quot;).
+	// TBD: JDK 1.2 in this case sets host to null rather than &quot;&quot;;
+	// this is undocumented and likely an unintended side effect in 1.2
+	// so we'll be simple here and stick with &quot;&quot;. Note that
+	// &quot;<A HREF="http://">http://</A>&quot; or &quot;<A HREF="http:///">http:///</A>&quot; produce a &quot;&quot; host in JDK 1.2.
+	if ((colon = host.indexOf(':')) &gt;= 0)
+	  {
+			port = eve.sys.Convert.toInt(host.substring(colon + 1));
+	    host = host.substring(0, colon);
+	  }
+	file = null;
+	start = hostEnd;
+   } 
+ else if (host == null) 
+   host = &quot;&quot;;
+
+ if (file == null || file.length() == 0
+	|| (start &lt; end &amp;&amp; spec.charAt(start) == '/')) 
+   {
+	// No file context available; just spec for file.
+	// Or this is an absolute path name; ignore any file context.
+	file = spec.substring(start, end);
+	ref = null;
+   } 
+ else if (start &lt; end)
+   {
+     // Context is available, but only override it if there is a new file.
+     char sepChar = '/';
+     int lastSlash = file.lastIndexOf (sepChar);
+     if (lastSlash &lt; 0 /*&amp;&amp; File.separatorChar != sepChar*/
+         &amp;&amp; url.getProtocol ().equals (&quot;file&quot;))
+       {
+         // On Windows, even '\' is allowed in a &quot;file&quot; URL.
+         /*sepChar = File.separatorChar;*/
+         lastSlash = file.lastIndexOf (sepChar);
+       }
+     
+				if (lastSlash == -1) file = file + sepChar + spec.substring(start,end);
+     else file = file.substring(0, lastSlash)
+             + sepChar + spec.substring (start, end);
+
+     if (url.getProtocol ().equals (&quot;file&quot;))
+       {
+         // For &quot;file&quot; URLs constructed relative to a context, we
+         // need to canonicalise the file path.
+         try
+           {
+             file = new File (file).getCanonicalPath ();
+           }
+         catch (IOException e)
+           {
+           }
+       }
+
+	ref = null;
+   }
+
+ if (ref == null)
+   {
+	// Normally there should be no '#' in the file part,
+	// but we are nice.
+	int hash = file.indexOf('#');
+	if (hash != -1)
+	  {
+	    ref = file.substring(hash + 1, file.length());
+	    file = file.substring(0, hash);
+	  }
+   }
+
+ // XXX - Classpath used to call PlatformHelper.toCanonicalForm() on
+ // the file part. It seems like overhead, but supposedly there is some
+ // benefit in windows based systems (it also lowercased the string).
+
+ setURL(url, url.getProtocol(), host, port, file, ref);
+}
+
+/**
+* This methods sets the instance variables representing the various fields
+* of the URL to the values passed in.
+*
+* @param u The URL to modify
+* @param protocol The protocol to set
+* @param host The host name to et
+* @param port The port number to set
+* @param file The filename to set
+* @param ref The reference
+*
+* @exception SecurityException If the protocol handler of the URL is
+* different from this one
+*
+* @deprecated 1.2 Please use
+* #setURL(URL,String,String,int,String,String,String,String);
+*/
+protected void setURL(URL u, String protocol, String host, int port,
+			String file, String ref)
+{
+ u.set(protocol, host, port, file, ref);
+}
+
+
+//##################################################################
+}
+//##################################################################
+

Modified: experiments/engywuck/hist-test/src/cachewolf/UrlFetcher.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/UrlFetcher.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/UrlFetcher.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,12 +1,12 @@
-package CacheWolf;
+package cachewolf;
 
-import ewe.io.ByteArrayInputStream;
-import ewe.io.IOException;
-import ewe.io.JavaUtf8Codec;
-import ewe.net.Socket;
-import ewe.util.ByteArray;
-import ewe.util.CharArray;
-import ewe.util.Properties;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import eve.io.JavaUtf8Codec;
+import java.net.Socket;
+import eve.util.ByteArray;
+import eve.util.CharArray;
+import java.util.Properties;
 
 public class UrlFetcher {
 	public static String fetchString(String address) throws IOException
@@ -21,7 +21,7 @@
 		CharArray t = new CharArray();
 		ByteArray doc = fetchByteArray(url, t);
 		Properties props = new Properties();
-		props.load(new ByteArrayInputStream(doc));
+		props.load(new ByteArrayInputStream(doc.data));
 		return props; 
 	}
 	
@@ -39,7 +39,7 @@
 		int i=-1;
 		String urltmp = new String(url);
 		while (urltmp != null &amp;&amp; i &lt;= maxRedirections ) { // allow max 5 redirections (http 302 location)
-			if (realurl != null) realurl.copyFrom(new String(urltmp));
+			if (realurl != null) realurl.setData(new String(urltmp).toCharArray());
 			i++;
 			conn = new HttpConnection(urltmp);
 			conn.setRequestorProperty(&quot;USER_AGENT&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
@@ -61,7 +61,7 @@
 	 */
 	public static boolean isUrlEncoded(String url) {
 		final String allowed = new String (&quot;-_.~!*'();:@&amp;=+$,/?%#[]&quot;);
-		char [] src = ewe.sys.Vm.getStringChars(url);
+		char [] src = eve.sys.Vm.getStringChars(url);
 		char c;
 		for (int i = 0; i&lt;src.length; i++){
 			c = src[i];
@@ -70,7 +70,7 @@
 					|| (c &gt;= '0' &amp;&amp; c &lt;= '9')
 					|| (allowed.indexOf(c) &gt;= 0)
 			) continue;
-			else return false;
+			return false;
 		}
 		return true;
 	}

Modified: experiments/engywuck/hist-test/src/cachewolf/Version.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/Version.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/Version.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,29 +1,39 @@
 
-package CacheWolf;
+package cachewolf;
 
-import com.stevesoft.ewe_pat.Regex;
-import ewe.io.*;
-import ewe.util.*;
-import ewe.sys.*;
 
+import cachewolf.utils.Common;
+
+import com.stevesoft.eve_pat.Regex;
+import java.io.IOException;
+import java.util.Properties;
+
+import eve.sys.*;
+import eve.ui.Form;
+
 /**
  * Class to hold and handle version information of the cachewolf project
- * language localisation string at at number 7000 
+ * language localisation string at at number 7000
  */
 
+/**
+ * Class to hold and handle version information of the cachewolf project
+ * language localisation string at at number 7000
+ */
+
 public class Version {
 	static final int VER_MAJOR = 1;
-	static final int VER_MINOR = 0;
+	static final int VER_MINOR = 5;
 	static final String VER_SVN =&quot;$LastChangedRevision$&quot;; // the number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
 	static final int SVN_REVISION = Common.parseInt(VER_SVN.substring(VER_SVN.indexOf(&quot; &quot;)+1, VER_SVN.lastIndexOf(&quot; &quot;)));
-	static final int VERSION_TYPE = 0;
+	static final int VERSION_TYPE = 1;
 	public static final String[] VERSION_TYPES = {
-		&quot;Release&quot;, 
+		&quot;Release&quot;,
 		&quot;ReleaseCandidate&quot;,
 		&quot;InDevelopmentStable&quot;,
 		&quot;InDevelopmentNewest&quot;
 	};
-	
+
 	/** only valid after calling checkForUpdates() */
 	static int[] updateavailabe = {0,0,0,0,0};
 	/** only valid after calling checkForUpdates() */
@@ -40,8 +50,8 @@
 	}
 
 	/**
-	 * Checks if newer versions of cachewolf are available 
-	 * @return [0] = recommended version type, [1]...[4]: 0: no update available, 1: newer version available, 2: version doesn't exists, 3: error 
+	 * Checks if newer versions of cachewolf are available
+	 * @return [0] = recommended version type, [1]...[4]: 0: no update available, 1: newer version available, 2: version doesn't exists, 3: error
 	 * @throws IOException
 	 */
 	public static void checkForUpdates() throws IOException {
@@ -77,16 +87,15 @@
 	}
 
 	public static String getUpdateMessage() {
-		Vm.showWait(true);
+		Form.showWait();
 		try {
 			checkForUpdates();
 			return MyLocale.getMsg(7022, &quot;Version type&quot;) +&quot;\n&quot;+ newVersionsArrayToString();
 		} catch (IOException e) {
 			return MyLocale.getMsg(7023, &quot;Error getting current version information&quot;) +&quot;\n&quot; + e.getMessage();
+		} finally {
+			Form.cancelWait();
 		}
-		finally {
-			Vm.showWait(false);
-		}
 	}
 
 	/**
@@ -96,20 +105,20 @@
 
 	private static int checkVersion(Properties curvers, String prefix, int t) {
 		try {
-			int curvmaj = Convert.toInt(curvers.getProperty(prefix + &quot;VersionMajor&quot;, &quot;0&quot;)); 
+			int curvmaj = Convert.toInt(curvers.getProperty(prefix + &quot;VersionMajor&quot;, &quot;0&quot;));
 			int curvmin = Convert.toInt(curvers.getProperty(prefix + &quot;VersionMinor&quot;, &quot;0&quot;));
 			String svnRString = curvers.getProperty(prefix + &quot;SvnRevision&quot;,&quot;0&quot;);
 			if (svnRString.startsWith(&quot;http&quot;)) {
 				String tmp;
 				Regex s;
-				int i = svnRString.indexOf(' '); 
+				int i = svnRString.indexOf(' ');
 				if (i &gt; 0) {
 					tmp = UrlFetcher.fetchString(svnRString.substring(0, i));
 					s = new Regex (svnRString.substring(i+1, svnRString.length())); // flyingfish works 3/2008 with (&quot;(?i)Revision[\\s]*[:=][\\s]*[\\\\r]*[\\\\n]*[\\s]*([0-9]*)&quot;);
-				} else { versionnumbers[t] = &quot;error: no RegEx&quot;; return 3; } 
+				} else { versionnumbers[t] = &quot;error: no RegEx&quot;; return 3; }
 				s.search(tmp);
 				if (!s.didMatch()) { versionnumbers[t] = &quot;error: RegEx didnot match&quot;; return 3; }
-				svnRString = s.stringMatched(1); 
+				svnRString = s.stringMatched(1);
 			}
 			versionnumbers[t] = curvmaj + &quot;.&quot; + curvmin + &quot;.&quot; + svnRString;
 			if (curvmaj &gt; VER_MAJOR) return 1;
@@ -119,7 +128,7 @@
 			if (Convert.toInt(svnRString) &gt; SVN_REVISION) return 1;
 			return 0;
 		} catch (IOException e) {
-			versionnumbers[t] = &quot;IO-error&quot;; 
+			versionnumbers[t] = &quot;IO-error&quot;;
 			return 3;
 		}
 	}

Modified: experiments/engywuck/hist-test/src/cachewolf/exp/ASCExporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/exp/ASCExporter.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/exp/ASCExporter.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,5 +1,5 @@
-package exp;
-import CacheWolf.*;
+package cachewolf.exp;
+import cachewolf.*;
 
 /**
 *	Class to export cache database to an ASCII (CSV!) file.
@@ -19,10 +19,10 @@
 		this();
 	}
 	
-	public String record (CacheHolderDetail holder, String lat, String lon){
+	public String record (CacheHolderDetail chD, String lat, String lon){
 		StringBuffer strBuf = new StringBuffer(100);
 		String dummy;
-		dummy = holder.CacheName;
+		dummy = chD.cacheName;
 		dummy = dummy.replace(',', ' ');
 		strBuf.append(dummy);
 		strBuf.append(&quot;,&quot;);

Modified: experiments/engywuck/hist-test/src/cachewolf/exp/DistanceComparer.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/exp/DistanceComparer.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/exp/DistanceComparer.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,8 +1,8 @@
-package exp;
+package cachewolf.exp;
 
-import CacheWolf.CWPoint;
-import CacheWolf.CacheHolder;
-import ewe.util.Comparer;
+import cachewolf.CWPoint;
+import cachewolf.CacheHolder;
+import eve.util.Comparer;
 
 public class DistanceComparer implements Comparer {
 	
@@ -15,11 +15,10 @@
 	public int compare(Object one, Object two) {
 		if ((! (one instanceof CacheHolder)) &amp;&amp; (!(two instanceof CacheHolder))) {
 			return 0;
-		} else {
-			CacheHolder a = (CacheHolder) one;
-			CacheHolder b = (CacheHolder) two;
-			return (int) ((a.pos.getDistance(centre) - b.pos.getDistance(centre)) * 1000);
-		}
+		} 
+		CacheHolder a = (CacheHolder) one;
+		CacheHolder b = (CacheHolder) two;
+		return (int) ((a.pos.getDistance(centre) - b.pos.getDistance(centre)) * 1000);
 	}
 	
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/exp/ExploristExporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/exp/ExploristExporter.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/exp/ExploristExporter.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,25 +1,22 @@
-package exp;
+package cachewolf.exp;
 
-import CacheWolf.*;
-import ewe.sys.*;
-import ewe.filechooser.FileChooser;
-import ewe.filechooser.FileChooserBase;
-import ewe.io.BufferedReader;
-import ewe.io.BufferedWriter;
-import ewe.io.File;
-import ewe.io.FileNotFoundException;
-import ewe.io.FileReader;
-import ewe.io.FileWriter;
-import ewe.io.LineNumberReader;
-import ewe.io.PrintWriter;
-import ewe.ui.FormBase;
-import ewe.ui.ProgressBarForm;
-import ewe.util.*;
-import ewe.io.IOException;
+import eve.sys.*;
+import eve.ui.filechooser.FileChooser;
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import eve.io.File;
+import java.io.*;
+import eve.ui.ProgressBarForm;
+import java.util.*;
+import java.io.IOException;
 
+import cachewolf.*;
+import cachewolf.utils.Common;
+
+
 /**
  * @author Kalle
- * @author TweetyHH Class for Exporting direct to Explorists *.gs Files. Caches
+ * @author TweetyHH Class for Exporting direct to Magellans *.gs Files. Caches
  *         will be exported in files with maximum of 200 Caches.
  */
 
@@ -40,7 +37,7 @@
 	// mask in file chooser
 	String mask = &quot;*.gs&quot;;
 	// decimal separator for lat- and lon-String
-	char decimalSeparator = '.';
+	//char decimalSeparator = '.';
 	// if true, the complete cache details are read
 	// before a call to the record method is made
 	boolean needCacheDetails = true;
@@ -60,16 +57,16 @@
 	public void doIt() {
 		File configFile = new File(&quot;magellan.cfg&quot;);
 		if (configFile.exists()) {
-			FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, pref.getExportPath(expName+&quot;Dir&quot;));
-			fc.setTitle(MyLocale.getMsg(2104, &quot;Choose directory for exporting .gs files&quot;));
+			FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, pref.getExportPath(expName+&quot;Dir&quot;));
+			fc.title=(MyLocale.getMsg(2104, &quot;Choose directory for exporting .gs files&quot;));
 			String targetDir;
-			if(fc.execute() != FormBase.IDCANCEL){
+			if(fc.execute() != FileChooser.IDCANCEL){
 				targetDir = fc.getChosen() + &quot;/&quot;;
 				pref.setExportPath(expName+&quot;Dir&quot;, targetDir);
 
 				CWPoint centre = profile.centre;
 				try {
-					LineNumberReader reader = new LineNumberReader(new BufferedReader(new FileReader(configFile)));
+					LineNumberReader reader = new LineNumberReader(new BufferedReader(new FileReader(configFile.getName())));
 					String line, fileName, coordinate;
 					while ((line = reader.readLine()) != null)  {
 						StringTokenizer tokenizer = new StringTokenizer(line,&quot;=&quot;);
@@ -77,18 +74,18 @@
 						coordinate = tokenizer.nextToken().trim();
 						CWPoint point = new CWPoint(coordinate);
 						DistanceComparer dc = new DistanceComparer(point);
-						cacheDB.sort(dc, false);
+						eve.util.Utils.sort(new Handle(),cacheDB,dc, false);
 						doIt(fileName);
 					}
 					reader.close();
 				} catch (FileNotFoundException e) {
-					InfoBox info = new InfoBox(MyLocale.getMsg(2100, &quot;Explorist Exporter&quot;),MyLocale.getMsg(2101, &quot;Failure at loading magellan.cfg\n&quot; + e.getMessage()));
+					InfoBox info = new InfoBox(MyLocale.getMsg(2100, &quot;Magellan Exporter&quot;),MyLocale.getMsg(2101, &quot;Failure at loading magellan.cfg\n&quot; + e.getMessage()));
 					info.show();
 				} catch (IOException e) {
-					InfoBox info = new InfoBox(MyLocale.getMsg(2100, &quot;Explorist Exporter&quot;),MyLocale.getMsg(2103, &quot;Failure at reading magellan.cfg\n&quot; + e.getMessage()));
+					InfoBox info = new InfoBox(MyLocale.getMsg(2100, &quot;Magellan Exporter&quot;),MyLocale.getMsg(2103, &quot;Failure at reading magellan.cfg\n&quot; + e.getMessage()));
 					info.show();
 				} finally {
-					cacheDB.sort(new DistanceComparer(centre),false);
+					eve.util.Utils.sort(new Handle(), cacheDB, new DistanceComparer(centre),false);
 				}
 			}
 		}
@@ -105,7 +102,7 @@
 		String fileBaseName;
 		String str = null;
 		CacheHolder ch;
-		CacheHolderDetail holder;
+		CacheHolderDetail chD;
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
 
@@ -144,22 +141,22 @@
 							outp.close();
 						}
 						outp = new PrintWriter(new BufferedWriter(
-								new FileWriter(new File(fileBaseName + expCount
+								new FileWriter(new java.io.File(fileBaseName + expCount
 										/ 200 + &quot;.gs&quot;))));
 					}
 
-					holder = new CacheHolderDetail(ch);
+					chD = new CacheHolderDetail(ch);
 					expCount++;
 					h.progress = (float) expCount / (float) counter;
 					h.changed();
 					try {
 						if (needCacheDetails) {
-							holder.readCache(profile.dataDir);
+							chD.readCache(profile.dataDir);
 						}
 					} catch (IOException e) {
 						continue;
 					}
-					str = record(holder);
+					str = record(chD);
 					if (str != null)
 						outp.print(str);
 				}// if
@@ -184,18 +181,17 @@
 	 * @return
 	 */
 	public File getOutputFile() {
-		File file;
-		FileChooser fc = new FileChooser(FileChooserBase.SAVE, pref
+		eve.io.File file;
+		FileChooser fc = new FileChooser(FileChooser.SAVE, pref
 				.getExportPath(expName));
-		fc.setTitle(MyLocale.getMsg(2102, &quot;Select target file:&quot;));
+		fc.title=(MyLocale.getMsg(2102, &quot;Select target file:&quot;));
 		fc.addMask(mask);
-		if (fc.execute() != FormBase.IDCANCEL) {
+		if (fc.execute() != FileChooser.IDCANCEL) {
 			file = fc.getChosenFile();
-			pref.setExportPath(expName, file.getPath());
+			pref.setExportPath(expName, file.getDrivePath());
 			return file;
-		} else {
-			return null;
-		}
+		} 
+		return null;
 	}
 
 	/**
@@ -230,43 +226,43 @@
 		sb.append(&quot;,&quot;);
 		String add = &quot;&quot;;
 		if (chD.isAddiWpt()) {
-			if (chD.type.equals(&quot;50&quot;)) {
+			if (chD.type==50) {
 				add = &quot;Pa:&quot;;
-			} else if (chD.type.equals(&quot;51&quot;)) {
+			} else if (chD.type==51) {
 				add = &quot;St:&quot;;
-			} else if (chD.type.equals(&quot;52&quot;)) {
+			} else if (chD.type==52) {
 				add = &quot;Qu:&quot;; 
-			} else if (chD.type.equals(&quot;53&quot;)) {	
+			} else if (chD.type==53) {	
 				add = &quot;Fi:&quot;;
-			} else if (chD.type.equals(&quot;54&quot;)) {
+			} else if (chD.type==54) {
 				add = &quot;Tr:&quot;;
-			} else if (chD.type.equals(&quot;55&quot;)) {	
+			} else if (chD.type==55) {	
 				add = &quot;Re:&quot;;
 			}
-			sb.append(add).append(removeCommas(chD.CacheName));
+			sb.append(add).append(removeCommas(chD.cacheName));
 		} else {
-			sb.append(removeCommas(chD.CacheName));
+			sb.append(removeCommas(chD.cacheName));
 		}		
 		sb.append(&quot;,&quot;);
-		sb.append(removeCommas(chD.CacheOwner));
+		sb.append(removeCommas(chD.cacheOwner));
 		sb.append(&quot;,&quot;);
-		sb.append(removeCommas(Common.rot13(chD.Hints)));
+		sb.append(removeCommas(Common.rot13(chD.hints)));
 		sb.append(&quot;,&quot;);
 		
 		if (!add.equals(&quot;&quot;)) { // Set Picture in Explorist to Virtual
 			sb.append(&quot;Virtual Cache&quot;);
-		} else if (!chD.type.equals(&quot;8&quot;)) { // Rewrite Unknown Caches
+		} else if (!(chD.type==8)) { // Rewrite Unknown Caches
 			sb.append(CacheType.transType(chD.type));
 		} else {
 			sb.append(&quot;Mystery Cache&quot;);
 		}
 		sb.append(&quot;,&quot;);
-		sb.append(toGsDateFormat(chD.DateHidden));  // created - DDMMYYY, YYY = year - 1900
+		sb.append(toGsDateFormat(chD.dateHidden));  // created - DDMMYYY, YYY = year - 1900
 		sb.append(&quot;,&quot;);
 		String lastFound = &quot;0000&quot;;
-		for (int i = 0; i &lt; chD.CacheLogs.size(); i++) {
-			if (chD.CacheLogs.getLog(i).isFoundLog() &amp;&amp; chD.CacheLogs.getLog(i).getDate().compareTo(lastFound) &gt; 0 ) {
-				lastFound = chD.CacheLogs.getLog(i).getDate();
+		for (int i = 0; i &lt; chD.cacheLogs.size(); i++) {
+			if (chD.cacheLogs.getLog(i).isFoundLog() &amp;&amp; chD.cacheLogs.getLog(i).getDate().compareTo(lastFound) &gt; 0 ) {
+				lastFound = chD.cacheLogs.getLog(i).getDate();
 			}
 		}
 		
@@ -306,9 +302,7 @@
 		if (input.length() &gt;= 10) {
 			return input.substring(8, 10) + input.substring(5, 7) + &quot;1&quot; + input.substring(2, 4);
 		} 
-		else {
-			return &quot;&quot;;
-		}
+		return &quot;&quot;;
 	}
 	
 }
\ No newline at end of file

Modified: experiments/engywuck/hist-test/src/cachewolf/exp/Exporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/exp/Exporter.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/exp/Exporter.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,18 +1,15 @@
-package exp;
+package cachewolf.exp;
 
-import CacheWolf.*;
-import ewe.sys.*;
-import ewe.filechooser.FileChooser;
-import ewe.filechooser.FileChooserBase;
-import ewe.io.BufferedWriter;
-import ewe.io.File;
-import ewe.io.FileWriter;
-import ewe.io.PrintWriter;
-import ewe.ui.FormBase;
-import ewe.ui.ProgressBarForm;
-import ewe.util.*;
-import ewe.io.IOException;
+import eve.sys.*;
+import eve.ui.filechooser.FileChooser;
+import java.io.*;
+import eve.ui.ProgressBarForm;
+import java.util.*;
+import java.io.IOException;
 
+import cachewolf.*;
+
+
 /**
  * @author Kalle
  * Base class for exporter, handles basic things like selecting
@@ -71,10 +68,10 @@
 	 *                1, if filechooser
 	 */
 	public void doIt(int variant){
-		File outFile;
+		String outFile;
 		String str;
 		CacheHolder ch;
-		CacheHolderDetail holder;
+		CacheHolderDetail chD;
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
 
@@ -83,7 +80,7 @@
 			outFile = getOutputFile();
 			if (outFile == null) return;
 		} else {
-			outFile = new File(tmpFileName);
+			outFile = tmpFileName;
 		}
 
 		pbf.showMainTask = false;
@@ -98,32 +95,32 @@
 		}
 
 		try{
-			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(outFile)));
+			PrintWriter outp =  new PrintWriter(new FileOutputStream(outFile));
 			str = this.header();
 			if (str != null) outp.print(str);
-			holder=new CacheHolderDetail();
+			chD=new CacheHolderDetail();
 			for(int i = 0; i&lt;cacheDB.size(); i++){
 				ch=(CacheHolder)cacheDB.get(i);
 				if(ch.is_black == false &amp;&amp; ch.is_filtered == false){
 					expCount++;
 					h.progress = (float)expCount/(float)counter;
 					h.changed();
-					if (needCacheDetails) holder = ch.getCacheDetails(false, false);
-					else holder.update(ch);
-					if (needCacheDetails &amp;&amp; holder == null) continue;
+					if (needCacheDetails) chD = ch.getCacheDetails(false, false);
+					else chD.update(ch);
+					if (needCacheDetails &amp;&amp; chD == null) continue;
 					switch (this.howManyParams) {
 					case NO_PARAMS:
-						str = record(holder);
+						str = record(chD);
 						break;
 					case LAT_LON:
-						if (holder.pos.isValid() == false) continue;
-						str = record(holder, holder.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-								     holder.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+						if (chD.pos.isValid() == false) continue;
+						str = record(chD, chD.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+								     chD.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
 						break;
 					case LAT_LON|COUNT: 
-						if (holder.pos.isValid() == false) continue;
-						str = record(holder, holder.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-									 holder.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+						if (chD.pos.isValid() == false) continue;
+						str = record(chD, chD.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+									 chD.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator),
 											 i);
 						break;
 					default:
@@ -148,7 +145,7 @@
 			outp.close();
 			pbf.exit(0);
 		} catch (IOException ioE){
-			Vm.debug(&quot;Error opening &quot; + outFile.getName());
+			Vm.debug(&quot;Error opening &quot; + outFile);
 		}
 		//try
 	}
@@ -193,18 +190,17 @@
 	 * uses a filechooser to get the name of the export file
 	 * @return
 	 */
-	public File getOutputFile (){
-		File file;
-		FileChooser fc = new FileChooser(FileChooserBase.SAVE, pref.getExportPath(expName));
-		fc.setTitle(&quot;Select target file:&quot;);
+	public String getOutputFile (){
+		String file;
+		FileChooser fc = new FileChooser(FileChooser.SAVE, pref.getExportPath(expName));
+		fc.title=(&quot;Select target file:&quot;);
 		fc.addMask(mask);
-		if(fc.execute() != FormBase.IDCANCEL){
-			file = fc.getChosenFile();
-			pref.setExportPath(expName, file.getPath());
+		if(fc.execute() != FileChooser.IDCANCEL){
+			file = fc.getChosen();
+			pref.setExportPath(expName, file);
 			return file;
-		} else {
-			return null;
-		}
+		} 
+		return null;
 	}
 	/**
 	 * this method can be overided by an exporter class
@@ -377,13 +373,11 @@
         if ( c &lt; 127 ) {
             // leave alone as equivalent string.
             return null;
-        } else {
-            String s=(String) iso2simpleMappings.get( new Integer(c));
-            if (s==null) // not in table, replace with empty string just to be sure
-            	return &quot;&quot;;
-            else
-            	return s;
-        }
+        } 
+        String s=(String) iso2simpleMappings.get( new Integer(c));
+        if (s==null) // not in table, replace with empty string just to be sure
+        	return &quot;&quot;;
+        return s;
     } // end charToEntity
 	
     public static String simplifyString( String text ) {

Modified: experiments/engywuck/hist-test/src/cachewolf/exp/GPXExporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/exp/GPXExporter.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/exp/GPXExporter.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,7 +1,9 @@
-package exp;
-import ewe.sys.*;
-import ewe.io.FileBase;
-import CacheWolf.*;
+package cachewolf.exp;
+import cachewolf.*;
+import cachewolf.utils.Common;
+import cachewolf.utils.SafeXML;
+import eve.sys.*;
+import eve.io.File;
 /**
 *	Class to export the cache database to a GPX file with gc.com
 *	extensions.&lt;br&gt;
@@ -20,7 +22,7 @@
 		this.setMask(&quot;*.gpx&quot;);
 		this.setNeedCacheDetails(true);
 		this.setHowManyParams(LAT_LON);
-		this.setTmpFileName(FileBase.getProgramDirectory() + &quot;/temp.gpx&quot;);
+		this.setTmpFileName(File.getProgramDirectory() + &quot;/temp.gpx&quot;);
 	}
 	
 	public GPXExporter(Preferences p, Profile prof){
@@ -28,7 +30,7 @@
 		this.setMask(&quot;*.gpx&quot;);
 		this.setNeedCacheDetails(true);
 		this.setHowManyParams(LAT_LON);
-		this.setTmpFileName(FileBase.getProgramDirectory() + &quot;/temp.gpx&quot;);
+		this.setTmpFileName(File.getProgramDirectory() + &quot;/temp.gpx&quot;);
 	}
 	
 	public String header() {
@@ -53,38 +55,37 @@
 		try{
 			strBuf.append(&quot;  &lt;wpt lat=\&quot;&quot;+lat+&quot;\&quot; lon=\&quot;&quot;+lon+&quot;\&quot;&gt;\r\n&quot;);
 		
-			String tim = ch.DateHidden.length()&gt;0 ? ch.DateHidden : DEFAULT_DATE;
-			strBuf.append(&quot;    &lt;time&gt;&quot;).append(tim.toString()).append(&quot;T00:00:00.0000000-07:00&lt;/time&gt;\r\n&quot;);
+			String tim = ch.dateHidden.length()&gt;0 ? ch.dateHidden : DEFAULT_DATE;
+			strBuf.append(&quot;    &lt;time&gt;&quot;).append(tim).append(&quot;T00:00:00.0000000-07:00&lt;/time&gt;\r\n&quot;);
 			strBuf.append(&quot;    &lt;name&gt;&quot;).append(ch.wayPoint).append(&quot;&lt;/name&gt;\r\n&quot;);
-			strBuf.append(&quot;    &lt;desc&gt;&quot;).append(SafeXML.cleanGPX(ch.CacheName)).append(&quot; by &quot;).append(SafeXML.cleanGPX(ch.CacheOwner)).append(&quot;&lt;/desc&gt;\r\n&quot;);
+			strBuf.append(&quot;    &lt;desc&gt;&quot;).append(SafeXML.cleanGPX(ch.cacheName)).append(&quot; by &quot;).append(SafeXML.cleanGPX(ch.cacheOwner)).append(&quot;&lt;/desc&gt;\r\n&quot;);
 			strBuf.append(&quot;    &lt;url&gt;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot;).append(ch.wayPoint).append(&quot;&amp;Submit6=Find&lt;/url&gt;\r\n&quot;);
-			strBuf.append(&quot;    &lt;urlname&gt;&quot;).append(SafeXML.cleanGPX(ch.CacheName)).append(&quot; by &quot;).append(SafeXML.cleanGPX(ch.CacheOwner)).append(&quot;&lt;/urlname&gt;\r\n&quot;);
+			strBuf.append(&quot;    &lt;urlname&gt;&quot;).append(SafeXML.cleanGPX(ch.cacheName)).append(&quot; by &quot;).append(SafeXML.cleanGPX(ch.cacheOwner)).append(&quot;&lt;/urlname&gt;\r\n&quot;);
 			if (!ch.isAddiWpt()){
 				strBuf.append(&quot;    &lt;sym&gt;Geocache&lt;/sym&gt;\r\n&quot;);
 				strBuf.append(&quot;    &lt;type&gt;Geocache|&quot;).append(CacheType.transType(ch.type)).append(&quot;&lt;/type&gt;\r\n&quot;);
 				String dummyAvailable = ch.is_available ? STRING_TRUE:STRING_FALSE;
 				String dummyArchived = ch.is_archived ? STRING_TRUE:STRING_FALSE;
 				strBuf.append(&quot;    &lt;groundspeak:cache available=\&quot;&quot;).append( dummyAvailable ).append( &quot;\&quot; archived=\&quot;&quot; ).append( dummyArchived).append( &quot;\&quot; xmlns:groundspeak=\&quot;<A HREF="http://www.groundspeak.com/cache/1/0\">http://www.groundspeak.com/cache/1/0\</A>&quot;&gt;\r\n&quot;);
-				strBuf.append(&quot;      &lt;groundspeak:name&gt;&quot;).append(SafeXML.cleanGPX(ch.CacheName)).append(&quot;&lt;/groundspeak:name&gt;\r\n&quot;);
-				strBuf.append(&quot;      &lt;groundspeak:placed_by&gt;&quot;).append(SafeXML.cleanGPX(ch.CacheOwner)).append(&quot;&lt;/groundspeak:placed_by&gt;\r\n&quot;);
-				strBuf.append(&quot;      &lt;groundspeak:owner&gt;&quot;).append(SafeXML.cleanGPX(ch.CacheOwner)+&quot;&lt;/groundspeak:owner&gt;\r\n&quot;);
+				strBuf.append(&quot;      &lt;groundspeak:name&gt;&quot;).append(SafeXML.cleanGPX(ch.cacheName)).append(&quot;&lt;/groundspeak:name&gt;\r\n&quot;);
+				strBuf.append(&quot;      &lt;groundspeak:placed_by&gt;&quot;).append(SafeXML.cleanGPX(ch.cacheOwner)).append(&quot;&lt;/groundspeak:placed_by&gt;\r\n&quot;);
+				strBuf.append(&quot;      &lt;groundspeak:owner&gt;&quot;).append(SafeXML.cleanGPX(ch.cacheOwner)+&quot;&lt;/groundspeak:owner&gt;\r\n&quot;);
 				strBuf.append(&quot;      &lt;groundspeak:type&gt;&quot;).append(CacheType.transType(ch.type)).append(&quot;&lt;/groundspeak:type&gt;\r\n&quot;);
-				strBuf.append(&quot;      &lt;groundspeak:container&gt;&quot;).append(ch.CacheSize).append(&quot;&lt;/groundspeak:container&gt;\r\n&quot;);
+				strBuf.append(&quot;      &lt;groundspeak:container&gt;&quot;).append(ch.getCacheSize()).append(&quot;&lt;/groundspeak:container&gt;\r\n&quot;);
 				strBuf.append(&quot;      &lt;groundspeak:difficulty&gt;&quot;).append(ch.hard.replace(',','.')).append(&quot;&lt;/groundspeak:difficulty&gt;\r\n&quot;);
 				strBuf.append(&quot;      &lt;groundspeak:terrain&gt;&quot;).append(ch.terrain.replace(',','.')).append(&quot;&lt;/groundspeak:terrain&gt;\r\n&quot;);
 				String dummyHTML = ch.is_HTML ? STRING_TRUE:STRING_FALSE;
 				strBuf.append(&quot;      &lt;groundspeak:long_description html=\&quot;&quot; ).append( dummyHTML ).append( &quot;\&quot;&gt;\r\n&quot;);
-				strBuf.append(&quot;      &quot;).append(SafeXML.cleanGPX(ch.LongDescription));
+				strBuf.append(&quot;      &quot;).append(SafeXML.cleanGPX(ch.longDescription));
 				strBuf.append(&quot;      \n&lt;/groundspeak:long_description&gt;\r\n&quot;);
-				strBuf.append(&quot;	  &lt;groundspeak:encoded_hints&gt;&quot;).append(SafeXML.cleanGPX(Common.rot13(ch.Hints))).append(&quot;&lt;/groundspeak:encoded_hints&gt;\r\n&quot;);
+				strBuf.append(&quot;	  &lt;groundspeak:encoded_hints&gt;&quot;).append(SafeXML.cleanGPX(Common.rot13(ch.hints))).append(&quot;&lt;/groundspeak:encoded_hints&gt;\r\n&quot;);
 				strBuf.append(&quot;      &lt;groundspeak:logs&gt;\r\n&quot;);
 				strBuf.append(&quot;      &lt;/groundspeak:logs&gt;\r\n&quot;);
 				strBuf.append(&quot;      &lt;groundspeak:travelbugs /&gt;\r\n&quot;);
 				strBuf.append(&quot;    &lt;/groundspeak:cache&gt;\r\n&quot;);
 			}else {
 				// there is no HTML in the description of addi wpts
-				strBuf.append(&quot;    &lt;cmt&gt;&quot;).append(SafeXML.cleanGPX(ch.LongDescription)).append(&quot;&lt;/cmt&gt;\r\n&quot;);
-				strBuf.append(&quot;    &lt;sym&gt;&quot;).append(CacheType.transType(ch.type)).append(&quot;&lt;/sym&gt;\r\n&quot;);
+				strBuf.append(&quot;    &lt;cmt&gt;&quot;).append(SafeXML.cleanGPX(ch.longDescription)).append(&quot;&lt;/cmt&gt;\r\n&quot;);				strBuf.append(&quot;    &lt;sym&gt;&quot;).append(CacheType.transType(ch.type)).append(&quot;&lt;/sym&gt;\r\n&quot;);
 				strBuf.append(&quot;    &lt;type&gt;Waypoint|&quot;).append(CacheType.transType(ch.type)).append(&quot;&lt;/type&gt;\r\n&quot;);
 			}
 			strBuf.append(&quot;  &lt;/wpt&gt;\r\n&quot;);

Modified: experiments/engywuck/hist-test/src/cachewolf/exp/HTMLExporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/exp/HTMLExporter.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/exp/HTMLExporter.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,14 +1,19 @@
-package exp;
-import com.stevesoft.ewe_pat.Regex;
+package cachewolf.exp;
+import cachewolf.*;
+import cachewolf.utils.Common;
+import cachewolf.utils.STRreplace;
 
-import CacheWolf.*;
-import ewe.util.*;
-import ewe.sys.*;
-import ewe.io.*;
-import ewe.ui.*;
-import ewe.filechooser.*;
+import com.stevesoft.eve_pat.Regex;
+
+
+import java.util.*;
+import eve.sys.*;
+import eve.ui.*;
+import eve.ui.filechooser.*;
 import HTML.*;
+import java.io.*;
 
+
 /**
 *	Class to export cache information to individual HTML files.&lt;br&gt;
 *	It uses the HTML package to parse template files. This makes the export
@@ -31,7 +36,7 @@
 	 		&quot;case_sensitive&quot;, &quot;true&quot;,
 	 		&quot;max_includes&quot;,   &quot;5&quot;
 	 	};
-	public final static String expName = &quot;HTML&quot;;
+	//public final static String expName = &quot;HTML&quot;;
 
 	public HTMLExporter(Preferences p, Profile prof){
 		pref = p;
@@ -40,18 +45,19 @@
 	}
 	
 	public void doIt(){
-		CacheHolderDetail holder;
+		CacheHolderDetail chD;
 		CacheHolder ch;
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
 
-		new String();
-		FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, pref.getExportPath(expName));
-		fc.setTitle(&quot;Select target directory:&quot;);
+		//need directory only!!!!
+		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getProfile().htmlExportDirectory);
+		fc.title=(&quot;Select target directory:&quot;);
 		String targetDir;
-		if(fc.execute() != FormBase.IDCANCEL){
+		if(fc.execute() != FileChooser.IDCANCEL){
 			targetDir = fc.getChosen() + &quot;/&quot;;
-			pref.setExportPath(expName, targetDir);
+			Global.getProfile().htmlExportDirectory=targetDir;
+			//pref.setExportPath(expName, targetDir);
 			Vector cache_index = new Vector();
 			Vector cacheImg = new Vector();
 			Vector logImg = new Vector();
@@ -83,63 +89,63 @@
 
 				ch = (CacheHolder)cacheDB.get(i);
 				if(ch.is_black == false &amp;&amp; ch.is_filtered == false){
-					holder=ch.getCacheDetails(false,true);
+					chD=ch.getCacheDetails(false,true);
 					varParams = new Hashtable();
-					varParams.put(&quot;TYPE&quot;, CacheType.transType(holder.type));
-					varParams.put(&quot;SIZE&quot;, holder.CacheSize);
-					varParams.put(&quot;WAYPOINT&quot;, holder.wayPoint);
-					varParams.put(&quot;NAME&quot;, holder.CacheName);
-					varParams.put(&quot;OWNER&quot;, holder.CacheOwner);
-					varParams.put(&quot;DIFFICULTY&quot;, holder.hard);
-					varParams.put(&quot;TERRAIN&quot;, holder.terrain);
-					varParams.put(&quot;DISTANCE&quot;, holder.distance);
-					varParams.put(&quot;BEARING&quot;, holder.bearing);
-					varParams.put(&quot;LATLON&quot;, holder.LatLon);
-					varParams.put(&quot;STATUS&quot;, holder.CacheStatus);
-					varParams.put(&quot;DATE&quot;, holder.DateHidden);
+					varParams.put(&quot;TYPE&quot;, CacheType.transType(chD.type));
+					varParams.put(&quot;SIZE&quot;, chD.getCacheSize());
+					varParams.put(&quot;WAYPOINT&quot;, chD.wayPoint);
+					varParams.put(&quot;NAME&quot;, chD.cacheName);
+					varParams.put(&quot;OWNER&quot;, chD.cacheOwner);
+					varParams.put(&quot;DIFFICULTY&quot;, chD.hard);
+					varParams.put(&quot;TERRAIN&quot;, chD.terrain);
+					varParams.put(&quot;DISTANCE&quot;, chD.distance);
+					varParams.put(&quot;BEARING&quot;, chD.bearing);
+					varParams.put(&quot;LATLON&quot;, chD.latLon);
+					varParams.put(&quot;STATUS&quot;, chD.cacheStatus);
+					varParams.put(&quot;DATE&quot;, chD.dateHidden);
 					cache_index.add(varParams);
 					//We can generate the individual page here!
 					try{
 						Template page_tpl = new Template(template_init_page);
-						page_tpl.setParam(&quot;TYPE&quot;, CacheType.transType(holder.type));
-						page_tpl.setParam(&quot;SIZE&quot;, holder.CacheSize);
-						page_tpl.setParam(&quot;WAYPOINT&quot;, holder.wayPoint);
-						page_tpl.setParam(&quot;NAME&quot;, holder.CacheName);
-						page_tpl.setParam(&quot;OWNER&quot;, holder.CacheOwner);
-						page_tpl.setParam(&quot;DIFFICULTY&quot;, holder.hard);
-						page_tpl.setParam(&quot;TERRAIN&quot;, holder.terrain);
-						page_tpl.setParam(&quot;DISTANCE&quot;, holder.distance);
-						page_tpl.setParam(&quot;BEARING&quot;, holder.bearing);
-						page_tpl.setParam(&quot;LATLON&quot;, holder.LatLon);
-						page_tpl.setParam(&quot;STATUS&quot;, holder.CacheStatus);
-						page_tpl.setParam(&quot;DATE&quot;, holder.DateHidden);
-						if (holder.is_HTML)
-							page_tpl.setParam(&quot;DESCRIPTION&quot;, modifyLongDesc(holder,targetDir));
+						page_tpl.setParam(&quot;TYPE&quot;, CacheType.transType(chD.type));
+						page_tpl.setParam(&quot;SIZE&quot;, chD.getCacheSize());
+						page_tpl.setParam(&quot;WAYPOINT&quot;, chD.wayPoint);
+						page_tpl.setParam(&quot;NAME&quot;, chD.cacheName);
+						page_tpl.setParam(&quot;OWNER&quot;, chD.cacheOwner);
+						page_tpl.setParam(&quot;DIFFICULTY&quot;, chD.hard);
+						page_tpl.setParam(&quot;TERRAIN&quot;, chD.terrain);
+						page_tpl.setParam(&quot;DISTANCE&quot;, chD.distance);
+						page_tpl.setParam(&quot;BEARING&quot;, chD.bearing);
+						page_tpl.setParam(&quot;LATLON&quot;, chD.latLon);
+						page_tpl.setParam(&quot;STATUS&quot;, chD.cacheStatus);
+						page_tpl.setParam(&quot;DATE&quot;, chD.dateHidden);
+						if (chD.is_HTML)
+							page_tpl.setParam(&quot;DESCRIPTION&quot;, modifyLongDesc(chD,targetDir));
 						else {
-							String dummyText = new String();
-							dummyText = STRreplace.replace(holder.LongDescription, &quot;\n&quot;, &quot;&lt;br&gt;&quot;);
+							String dummyText;
+							dummyText = STRreplace.replace(chD.longDescription, &quot;\n&quot;, &quot;&lt;br&gt;&quot;);
 							page_tpl.setParam(&quot;DESCRIPTION&quot;,dummyText);
 							
 						}
-						page_tpl.setParam(&quot;HINTS&quot;, holder.Hints);
-						page_tpl.setParam(&quot;DECRYPTEDHINTS&quot;, Common.rot13(holder.Hints));
+						page_tpl.setParam(&quot;HINTS&quot;, chD.hints);
+						page_tpl.setParam(&quot;DECRYPTEDHINTS&quot;, Common.rot13(chD.hints));
 						StringBuffer sb=new StringBuffer(2000);
-						for(int j = 0; j&lt;holder.CacheLogs.size(); j++){
-							sb.append(STRreplace.replace(holder.CacheLogs.getLog(j).toHtml(),&quot;<A HREF="http://www.geocaching.com/images/icons/">http://www.geocaching.com/images/icons/</A>&quot;,null));
+						for(int j = 0; j&lt;chD.cacheLogs.size(); j++){
+							sb.append(STRreplace.replace(chD.cacheLogs.getLog(j).toHtml(),&quot;<A HREF="http://www.geocaching.com/images/icons/">http://www.geocaching.com/images/icons/</A>&quot;,null));
 							sb.append(&quot;&lt;br&gt;&quot;);
-							icon=holder.CacheLogs.getLog(j).getIcon();
-							if (logIcons.find(icon)&lt;0) logIcons.add(icon); // Add the icon to list of icons to copy to dest directory
+							icon=chD.cacheLogs.getLog(j).getIcon();
+							if (logIcons.indexOf(icon)&lt;0) logIcons.add(icon); // Add the icon to list of icons to copy to dest directory
 						}
 						page_tpl.setParam(&quot;LOGS&quot;, sb.toString());
-						page_tpl.setParam(&quot;NOTES&quot;, STRreplace.replace(holder.CacheNotes, &quot;\n&quot;,&quot;&lt;br&gt;&quot;)); 
+						page_tpl.setParam(&quot;NOTES&quot;, STRreplace.replace(chD.cacheNotes, &quot;\n&quot;,&quot;&lt;br&gt;&quot;)); 
 						// Cache Images
 						cacheImg.clear();
-						for(int j = 0; j&lt;holder.Images.size(); j++){
+						for(int j = 0; j&lt;chD.images.size(); j++){
 							imgParams = new Hashtable();
-							String imgFile = new String((String)holder.Images.get(j));
+							String imgFile = (String)chD.images.get(j);
 							imgParams.put(&quot;FILE&quot;, imgFile);
-							if (j &lt; holder.ImagesText.size())
-								imgParams.put(&quot;TEXT&quot;,holder.ImagesText.get(j));
+							if (j &lt; chD.imagesText.size())
+								imgParams.put(&quot;TEXT&quot;,chD.imagesText.get(j));
 							else
 								imgParams.put(&quot;TEXT&quot;,imgFile);
 							DataMover.copy(profile.dataDir + imgFile,targetDir + imgFile);
@@ -148,12 +154,12 @@
 						page_tpl.setParam(&quot;cacheImg&quot;, cacheImg);
 						// Log images
 						logImg.clear();
-						for(int j = 0; j&lt;holder.LogImages.size(); j++){
+						for(int j = 0; j&lt;chD.logImages.size(); j++){
 							logImgParams = new Hashtable();
-							String logImgFile = (String) holder.LogImages.get(j);
+							String logImgFile = (String) chD.logImages.get(j);
 							logImgParams.put(&quot;FILE&quot;, logImgFile);
-							if (j &lt; holder.LogImagesText.size())
-								logImgParams.put(&quot;TEXT&quot;,holder.LogImagesText.get(j));
+							if (j &lt; chD.logImagesText.size())
+								logImgParams.put(&quot;TEXT&quot;,chD.logImagesText.get(j));
 							else
 								logImgParams.put(&quot;TEXT&quot;,logImgFile);
 							DataMover.copy(profile.dataDir + logImgFile,targetDir + logImgFile);
@@ -162,12 +168,12 @@
 						page_tpl.setParam(&quot;logImg&quot;, logImg);
 						// User images
 						usrImg.clear();
-						for(int j = 0; j&lt;holder.UserImages.size(); j++){
+						for(int j = 0; j&lt;chD.userImages.size(); j++){
 							usrImgParams = new Hashtable();
-							String usrImgFile = new String((String)holder.UserImages.get(j));
+							String usrImgFile = (String)chD.userImages.get(j);
 							usrImgParams.put(&quot;FILE&quot;, usrImgFile);
-							if (j &lt; holder.UserImagesText.size())
-								usrImgParams.put(&quot;TEXT&quot;,holder.UserImagesText.get(j));
+							if (j &lt; chD.userImagesText.size())
+								usrImgParams.put(&quot;TEXT&quot;,chD.userImagesText.get(j));
 							else
 								usrImgParams.put(&quot;TEXT&quot;,usrImgFile);
 							DataMover.copy(profile.dataDir + usrImgFile,targetDir + usrImgFile);
@@ -178,9 +184,9 @@
 						// Map images
 						mapImg.clear();
 						mapImgParams = new Hashtable();
-						String mapImgFile = new String(holder.wayPoint + &quot;_map.gif&quot;);
+						String mapImgFile = chD.wayPoint + &quot;_map.gif&quot;;
 						// check if map file exists
-						File test = new File(profile.dataDir + mapImgFile);
+						java.io.File test = new java.io.File(profile.dataDir + mapImgFile);
 						if (test.exists()) {
 							mapImgParams.put(&quot;FILE&quot;, mapImgFile);
 							mapImgParams.put(&quot;TEXT&quot;,mapImgFile);
@@ -188,7 +194,7 @@
 							mapImg.add(mapImgParams);
 							
 							mapImgParams = new Hashtable();
-							mapImgFile = holder.wayPoint + &quot;_map_2.gif&quot;;
+							mapImgFile = chD.wayPoint + &quot;_map_2.gif&quot;;
 							mapImgParams.put(&quot;FILE&quot;, mapImgFile);
 							mapImgParams.put(&quot;TEXT&quot;,mapImgFile);
 							DataMover.copy(profile.dataDir + mapImgFile,targetDir + mapImgFile);
@@ -198,7 +204,7 @@
 						}
 
 						
-						PrintWriter pagefile = new PrintWriter(new BufferedWriter(new FileWriter(targetDir + holder.wayPoint+&quot;.html&quot;)));
+						PrintWriter pagefile = new PrintWriter(new BufferedWriter(new FileWriter(targetDir + chD.wayPoint+&quot;.html&quot;)));
 						pagefile.print(page_tpl.output());
 						pagefile.close();
 					}catch(Exception e){
@@ -209,10 +215,10 @@
 			// Copy the log-icons to the destination directory
 			for (int j=0; j&lt;logIcons.size(); j++) {
 				icon=(String) logIcons.elementAt(j);
-				DataMover.copy(FileBase.getProgramDirectory() + &quot;/&quot;+icon,targetDir + icon);
+				DataMover.copy(eve.io.File.getProgramDirectory() + &quot;/&quot;+icon,targetDir + icon);
 				
 			}
-			DataMover.copy(FileBase.getProgramDirectory() + &quot;/recommendedlog.gif&quot;,targetDir + &quot;recommendedlog.gif&quot;);
+			DataMover.copy(eve.io.File.getProgramDirectory() + &quot;/recommendedlog.gif&quot;,targetDir + &quot;recommendedlog.gif&quot;);
 			try{
 				Template tpl = new Template(template_init_index);
 				tpl.setParam(&quot;cache_index&quot;, cache_index);
@@ -246,38 +252,38 @@
 	 * @return The modified long description
 	 */
 	private String modifyLongDesc(CacheHolderDetail chD, String targetDir) {
-		StringBuffer s=new StringBuffer(chD.LongDescription.length());
+		StringBuffer s=new StringBuffer(chD.longDescription.length());
 		int start=0;
 		int pos;
 		int imageNo=0;
 		Regex imgRex = new Regex(&quot;src=(?:\\s*[^\&quot;|']*?)(?:\&quot;|')(.*?)(?:\&quot;|')&quot;);
-		while (start&gt;=0 &amp;&amp; (pos=chD.LongDescription.indexOf(&quot;&lt;img&quot;,start))&gt;0) {
-			s.append(chD.LongDescription.substring(start,pos));
-			imgRex.searchFrom(chD.LongDescription,pos);
+		while (start&gt;=0 &amp;&amp; (pos=chD.longDescription.indexOf(&quot;&lt;img&quot;,start))&gt;0) {
+			s.append(chD.longDescription.substring(start,pos));
+			imgRex.searchFrom(chD.longDescription,pos);
 			String imgUrl=imgRex.stringMatched(1);
 			//Vm.debug(&quot;imgUrl &quot;+imgUrl);
 			if (imgUrl.lastIndexOf('.')&gt;0 &amp;&amp; imgUrl.toLowerCase().startsWith(&quot;http&quot;)) {
 				String imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).substring(0,4).trim();
 				// If we have an image which we stored when spidering, we can display it
 				if(!imgType.startsWith(&quot;.com&quot;) &amp;&amp; !imgType.startsWith(&quot;.php&quot;) &amp;&amp; !imgType.startsWith(&quot;.exe&quot;)){
-					s.append(&quot;&lt;img src=\&quot;&quot;+chD.Images.get(imageNo)+&quot;\&quot;&gt;&quot;);
+					s.append(&quot;&lt;img src=\&quot;&quot;+chD.images.get(imageNo)+&quot;\&quot;&gt;&quot;);
 					// The actual immages are copied elswhere
 					//DataMover.copy(profile.dataDir + chD.Images.get(imageNo),targetDir + chD.Images.get(imageNo));
 					imageNo++;
 				}
 			}
-			start=chD.LongDescription.indexOf(&quot;&gt;&quot;,pos);
+			start=chD.longDescription.indexOf(&quot;&gt;&quot;,pos);
 			if (start&gt;=0) start++;
-			if (imageNo &gt;= chD.Images.getCount())break;
+			if (imageNo &gt;= chD.images.size())break;
 		}
-		if (start&gt;=0) s.append(chD.LongDescription.substring(start));
+		if (start&gt;=0) s.append(chD.longDescription.substring(start));
 		return s.toString();
 	}
 	
 	private void sortAndPrintIndex(Template tmpl, Vector list, String file, String field){
 		PrintWriter detfile; 
 		
-		list.sort(new HTMLComparer(field),false);
+		eve.util.Utils.sort(new Handle(),list, new HTMLComparer(field), false);
 		try {
 			detfile = new PrintWriter(new BufferedWriter(new FileWriter(file)));
 			detfile.print(tmpl.output());
@@ -293,7 +299,7 @@
 		Vector navi_index;
 		PrintWriter detfile; 
 		
-		list.sort(new HTMLComparer(field),false);
+		eve.util.Utils.sort(new Handle(), list,new HTMLComparer(field),false);
 		navi_index = addAnchorString(list,field, fullCompare);
 		if (navi_index != null){
 			tmpl.setParam(&quot;navi_index&quot;,navi_index);
@@ -312,7 +318,7 @@
 		Vector navi_index;
 		PrintWriter detfile; 
 		
-		list.sort(new HTMLComparer(field),false);
+		eve.util.Utils.sort(new Handle(), list,new HTMLComparer(field),false);
 		navi_index = addAnchorString(list,field, diff);
 		if (navi_index != null){
 			tmpl.setParam(&quot;navi_index&quot;,navi_index);
@@ -345,9 +351,10 @@
 			currEntry = (Hashtable) list.get(i);
 			currValue = (String) currEntry.get(field);
 			currValue = currValue.toUpperCase();
-			if (currValue == null || currValue == &quot;&quot;) continue;
+
 			try {
 				if (fullCompare) {
+					if (currValue == null || currValue.equals(&quot;&quot;)) continue;
 					if (lastValue.compareTo(currValue)!= 0){
 						// Values for navigation line 
 						topIndexParms = new Hashtable();
@@ -381,7 +388,7 @@
 						currEntry.put(&quot;ANCHORTEXT&quot;, &quot;&quot;);
 					}
 				}
-				list.set(i,currEntry);
+				list.setElementAt(currEntry,i);
 				lastValue = currValue;
 			} catch (Exception e){
 				continue;
@@ -418,7 +425,7 @@
 				currEntry.put(&quot;ANCHORNAME&quot;, &quot;&quot;);
 				currEntry.put(&quot;ANCHORTEXT&quot;, &quot;&quot;);
 			}
-			list.set(i,currEntry);
+			list.setElementAt(currEntry,i);
 		}
 		return topIndex;
 	}
@@ -427,7 +434,7 @@
 	 * @author Kalle
 	 * Comparer for sorting the vector for the index.html file
 	 */
-	private class HTMLComparer implements Comparer {
+	private class HTMLComparer implements eve.util.Comparer {
 		String compareWhat;
 
 		public HTMLComparer (String what){
@@ -453,11 +460,9 @@
 				dbl2 = Common.parseDouble(str2.substring(0,str2.length()-3));
 				if (dbl1 &gt; dbl2) return 1;
 				if (dbl1 &lt; dbl2) return -1;
-				else return 0;
+				return 0;
 			}
-			else {
-				return str1.compareTo(str2);
-			}
+			return str1.compareTo(str2);
 		}
 	}
 

Modified: experiments/engywuck/hist-test/src/cachewolf/exp/KMLExporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/exp/KMLExporter.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/exp/KMLExporter.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,32 +1,33 @@
-package exp;
+package cachewolf.exp;
 
-import ewe.io.BufferedWriter;
-import ewe.io.File;
-import ewe.io.FileBase;
-import ewe.io.FileOutputStream;
-import ewe.io.FileWriter;
-import ewe.io.IOException;
-import ewe.io.InputStream;
-import ewe.io.PrintWriter;
-import ewe.sys.Convert;
-import ewe.sys.Handle;
-import ewe.sys.Vm;
-import ewe.ui.ProgressBarForm;
-import ewe.util.*;
-import ewe.util.Map.MapEntry;
-import ewe.util.zip.ZipEntry;
-import ewe.util.zip.ZipException;
-import ewe.util.zip.ZipFile;
-import CacheWolf.*;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.PrintWriter;
+import eve.sys.Handle;
+import eve.sys.Vm;
+import eve.ui.ProgressBarForm;
+import java.util.*;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipException;
+import java.util.zip.ZipFile;
 
+import cachewolf.*;
+import cachewolf.utils.Common;
+import cachewolf.utils.SafeXML;
+
+
 /**
 *	Class to export the cache database (index) to an KML-File
-*	which can be read by Google Earth   
-*   
+*	which can be read by Google Earth
+*
 */
 public class KMLExporter extends Exporter {
-	private static final String COLOR_FOUND = &quot;ff98fb98&quot;; 
-	private static final String COLOR_OWNED = &quot;ffffaa55&quot;; 
+	private static final String COLOR_FOUND = &quot;ff98fb98&quot;;
+	private static final String COLOR_OWNED = &quot;ffffaa55&quot;;
 	private static final String COLOR_AVAILABLE = &quot;ffffffff&quot;;
 	private static final String COLOR_NOT_AVAILABLE = &quot;ff0000ff&quot;;
 
@@ -36,8 +37,8 @@
 	static final int OWNED = 2;
 	static final int NOT_AVAILABLE = 3;
 	static final int UNKNOWN = 4;
-	
-	
+
+
 	String []categoryNames = {&quot;Available&quot;,&quot;Found&quot;, &quot;Owned&quot;, &quot;Not Available&quot;, &quot;UNKNOWN&quot;};
 	Hashtable [] outCacheDB = new Hashtable[categoryNames.length];
 
@@ -47,26 +48,26 @@
 		this.setHowManyParams(LAT_LON);
 	}
 
-	
+
 	public KMLExporter(Preferences p, Profile prof){
 			super();
 			this.setMask(&quot;*.kml&quot;);
 	}
 
 	public void doIt(int variant){
-		File outFile;
+		String outFile;
 		String str;
 		CacheHolder ch;
 		CacheHolder addiWpt;
-		CacheHolderDetail holder;
+		CacheHolderDetail chD;
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
-		
+
 		if (variant == ASK_FILE) {
 			outFile = getOutputFile();
 			if (outFile == null) return;
 		} else {
-			outFile = new File(tmpFileName);
+			outFile = tmpFileName;
 		}
 
 		pbf.showMainTask = false;
@@ -79,9 +80,9 @@
 			ch = (CacheHolder)cacheDB.get(i);
 			if(ch.is_black == false &amp;&amp; ch.is_filtered == false) counter++;
 		}
-		copyIcons(outFile.getParent());
+		copyIcons(new File(outFile).getParent());
 		buildOutDB();
-		
+
 		try{
 			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(outFile)));
 			str = this.header();
@@ -90,17 +91,17 @@
 				// skip over empty categories
 				if (outCacheDB[cat]==null) continue;
 
-				Iterator outLoop = outCacheDB[cat].entries();
+				Enumeration keys = outCacheDB[cat].keys();
 				outp.print(startFolder(categoryNames[cat]));
 
 				Vector tmp;
-				MapEntry entry; 
-				while (outLoop.hasNext()){
-					entry = (MapEntry) outLoop.next();
-					tmp = (Vector)entry.getValue();
+				String key;
+				while (keys.hasMoreElements()){
+					key=(String)keys.nextElement();
+					tmp = (Vector) outCacheDB[cat].get(key);
 					// skip over empty cachetypes
 					if (tmp.size() == 0) continue;
-					outp.print(startFolder(CacheType.transType((String)entry.getKey())));
+					outp.print(startFolder(CacheType.transType(Common.parseInt(key))));
 
 					for(int i = 0; i&lt;tmp.size(); i++){
 						ch = (CacheHolder) tmp.get(i);
@@ -108,30 +109,30 @@
 						expCount++;
 						h.progress = (float)expCount/(float)counter;
 						h.changed();
-						
-						holder=new CacheHolderDetail(ch);
+
+						chD=new CacheHolderDetail(ch);
 						try {
-							holder.readCache(profile.dataDir);
+							chD.readCache(profile.dataDir);
 						} catch (IOException e) {
 							continue;
 						}
-						if (holder.pos.isValid()){
-							str = record(holder, holder.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-								     holder.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+						if (chD.pos.isValid()){
+							str = record(chD, chD.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+								     chD.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
 							if (str != null) outp.print(str);
 						}
 						if (ch.hasAddiWpt()){
-						outp.print(startFolder(&quot;Additional Waypoints&quot;, false));
+							outp.print(startFolder(&quot;Additional Waypoints&quot;, false));
 							for(int j = 0; j&lt;ch.addiWpts.size(); j++){
 								addiWpt = (CacheHolder) ch.addiWpts.get(j);
-								holder=new CacheHolderDetail(addiWpt);
+								chD=new CacheHolderDetail(addiWpt);
 								expCount++;
-								if (holder.pos.isValid()){
-									str = record(holder, holder.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-										     holder.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+								if (chD.pos.isValid()){
+									str = record(chD, chD.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+										     chD.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
 									if (str != null) outp.print(str);
 								}
-								
+
 							}
 						outp.print(endFolder());// addi wpts
 						}
@@ -140,31 +141,31 @@
 				}
 				outp.print(endFolder());// category
 			}
-			
+
 			str = trailer();
 			if (str != null) outp.print(str);
 			outp.close();
 			pbf.exit(0);
 		} catch (IOException ioE){
-			Vm.debug(&quot;Error opening &quot; + outFile.getName());
+			Vm.debug(&quot;Error opening &quot; + outFile);
 		}
 		//try
 
 	}
-	
-	private void buildOutDB(){
+
+	private void buildOutDB(){ // TODO untested since EVE
 		CacheHolder ch;
 		Vector tmp;
-		Iterator categoryLoop;
-		MapEntry entry;
+		Enumeration categoryLoop;
+		String key;
 		boolean foundOne;
-		
+
 		// create the roots for the different categories
 		for (int i = 0; i &lt; categoryNames.length; i++) {
 			outCacheDB[i] = new Hashtable();
 			// create the roots for the cachetypes
 			for (int j = 0; j &lt; CacheType.wayType.length; j++) {
-				outCacheDB[i].put(CacheType.wayType[j][CacheType.WPT_NUM], new Vector());
+				outCacheDB[i].put(new Integer(CacheType.wayTypeNo[j]), new Vector());
 			}
 		}
 
@@ -172,24 +173,24 @@
 		for(int i = 0; i&lt;cacheDB.size(); i++){
 			ch=(CacheHolder)cacheDB.get(i);
 			if(ch.is_black == false &amp;&amp; ch.is_filtered == false &amp;&amp; !ch.isAddiWpt()){
-				if (ch.is_found) { tmp = (Vector) outCacheDB[FOUND].get(ch.type);}
-				else if (ch.is_owned) { tmp = (Vector) outCacheDB[OWNED].get(ch.type);}
-				else if (ch.is_archived || !ch.is_available){ tmp = (Vector) outCacheDB[NOT_AVAILABLE].get(ch.type);}
-				else if (ch.is_available){ tmp = (Vector) outCacheDB[AVAILABLE].get(ch.type);}
-				else { tmp = (Vector) outCacheDB[UNKNOWN].get(ch.type);}
-				
+				if (ch.is_found) { tmp = (Vector) outCacheDB[FOUND].get(new Integer(ch.type));} // this &quot;new&quot; is not very efficient as it is only needed because get needs an object, on which it can call hashcode()
+				else if (ch.is_owned) { tmp = (Vector) outCacheDB[OWNED].get(new Integer(ch.type));}
+				else if (ch.is_archived || !ch.is_available){ tmp = (Vector) outCacheDB[NOT_AVAILABLE].get(new Integer(ch.type));}
+				else if (ch.is_available){ tmp = (Vector) outCacheDB[AVAILABLE].get(new Integer(ch.type));}
+				else { tmp = (Vector) outCacheDB[UNKNOWN].get(new Integer(ch.type));}
+
 				tmp.add(ch);
 			}
 		}
-		
+
 		//eleminate empty categories
 		for (int i = 0; i &lt; categoryNames.length; i++) {
-			categoryLoop = outCacheDB[i].entries();
+			categoryLoop = outCacheDB[i].keys();
 			foundOne = false;
 			//look if all vectors for cachetypes are filled
-			while (categoryLoop.hasNext()){
-				entry = (MapEntry) categoryLoop.next();
-				tmp = (Vector)entry.getValue();
+			while (categoryLoop.hasMoreElements()){
+				key = (String) categoryLoop.nextElement();
+				tmp = (Vector)outCacheDB[i].get(key);
 				if (tmp.size()&gt; 0){
 					foundOne = true;
 					break;
@@ -198,14 +199,14 @@
 			// set hashtable for that category to null
 			if (!foundOne)outCacheDB[i] = null;
 		}
-		
 
+
 	}
-	
+
 	private String startFolder(String name){
 		return startFolder(name, true);
 	}
-	
+
 	private String startFolder(String name, boolean open){
 		StringBuffer strBuf = new StringBuffer(200);
 		strBuf.append(&quot;&lt;Folder&gt;\r\n&quot;);
@@ -216,23 +217,23 @@
 	}
 
 	private String endFolder() {
-		
+
 		return &quot;&lt;/Folder&gt;\r\n&quot;;
 	}
 
 	public void copyIcons(String dir){
 		try {
-			ZipFile zif = new ZipFile (FileBase.getProgramDirectory() + &quot;/POIIcons.zip&quot;);
+			ZipFile zif = new ZipFile (eve.io.File.getProgramDirectory() + &quot;/POIIcons.zip&quot;);
 			ZipEntry zipEnt;
 			int len;
-			String entName, fileName; 
+			String entName, fileName;
 
 			for (int i = 0; i &lt; CacheType.wayType.length; i++) {
-				fileName = CacheType.type2pic(Convert.parseInt(CacheType.wayType[i][CacheType.WPT_NUM]));
+				fileName = CacheType.type2pic(CacheType.wayTypeNo[i]);
 				entName = &quot;GoogleEarthIcons/&quot; + fileName;
 				zipEnt = zif.getEntry(entName);
 				if (zipEnt == null) continue;
-			    byte[] buff = new byte[ zipEnt.getSize() ];
+			    byte[] buff = new byte[ (int) zipEnt.getSize() ];
 			    InputStream  fis = zif.getInputStream(zipEnt);
 			    FileOutputStream fos = new FileOutputStream( dir + &quot;/&quot; + fileName);
 			    while( 0 &lt; (len = fis.read( buff )) )
@@ -251,28 +252,28 @@
 			}
 	}
 
-	
+
 	public String header () {
 		StringBuffer strBuf = new StringBuffer(200);
-				
+
 		strBuf.append(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;\r\n&quot;);
 		strBuf.append(&quot;&lt;kml xmlns=\&quot;<A HREF="http://earth.google.com/kml/2.0\">http://earth.google.com/kml/2.0\</A>&quot;&gt;\r\n&quot;);
 		strBuf.append(&quot;&lt;Folder&gt;\r\n&quot;);
 		strBuf.append(&quot;&lt;name&gt;CacheWolf&lt;/name&gt;\r\n&quot;);
 		strBuf.append(&quot;&lt;open&gt;1&lt;/open&gt;\r\n&quot;);
-	
+
 		return strBuf.toString();
 	}
 
 
 	public String record(CacheHolderDetail ch, String lat, String lon){
 		StringBuffer strBuf = new StringBuffer(200);
-		
+
 		strBuf.append(&quot;   &lt;Placemark&gt;\r\n&quot;);
 		if (ch.URL != null){
 			strBuf.append(&quot;      &lt;description&gt;&quot;+SafeXML.clean(ch.URL)+&quot;&lt;/description&gt;\r\n&quot;);
 		}
-		strBuf.append(&quot;      &lt;name&gt;&quot;+ ch.wayPoint + &quot; - &quot; + SafeXML.clean(ch.CacheName) +&quot;&lt;/name&gt;\r\n&quot;);
+		strBuf.append(&quot;      &lt;name&gt;&quot;+ ch.wayPoint + &quot; - &quot; + SafeXML.clean(ch.cacheName) +&quot;&lt;/name&gt;\r\n&quot;);
 		strBuf.append(&quot;      &lt;LookAt&gt;\r\n&quot;);
 		strBuf.append(&quot;         &lt;latitude&gt;&quot; + lat + &quot;&lt;/latitude&gt;\r\n&quot;);
 		strBuf.append(&quot;         &lt;longitude&gt;&quot; + lon + &quot;&lt;/longitude&gt;\r\n&quot;);
@@ -285,7 +286,7 @@
 		strBuf.append(&quot;      &lt;IconStyle&gt;\r\n&quot;);
 		strBuf.append(&quot;         &lt;Icon&gt;\r\n&quot;);
 //		strBuf.append(&quot;            &lt;href&gt;&quot;+ File.getProgramDirectory()+ &quot;/&quot; + CacheType.type2pic(Convert.parseInt(ch.type))+ &quot;&lt;/href&gt;\r\n&quot;);
-		strBuf.append(&quot;            &lt;href&gt;&quot;+ CacheType.type2pic(Convert.parseInt(ch.type))+ &quot;&lt;/href&gt;\r\n&quot;);
+		strBuf.append(&quot;            &lt;href&gt;&quot;+ CacheType.type2pic(ch.type)+ &quot;&lt;/href&gt;\r\n&quot;);
 		strBuf.append(&quot;         &lt;/Icon&gt;\r\n&quot;);
 		strBuf.append(&quot;      &lt;/IconStyle&gt;\r\n&quot;);
 		strBuf.append(&quot;      &lt;LabelStyle&gt;\r\n&quot;);
@@ -293,10 +294,10 @@
 		strBuf.append(&quot;      &lt;/LabelStyle&gt;\r\n&quot;);
 		strBuf.append(&quot;      &lt;/Style&gt;\r\n&quot;);
 		strBuf.append(&quot;   &lt;/Placemark&gt;\r\n&quot;);
-	
+
 		return strBuf.toString();
 	}
-	
+
 	public String trailer(){
 		StringBuffer strBuf = new StringBuffer(50);
 
@@ -305,13 +306,13 @@
 
 		return strBuf.toString();
 	}
-	
+
 	private String getColor(CacheHolderDetail ch){
 		if (ch.is_found) return COLOR_FOUND;
 		if (ch.is_owned) return COLOR_OWNED;
 		if (ch.is_archived || !ch.is_available) return COLOR_NOT_AVAILABLE;
-		
+
 		return COLOR_AVAILABLE;
 	}
-	
+
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/exp/LocExporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/exp/LocExporter.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/exp/LocExporter.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,7 +1,7 @@
-package exp;
-import CacheWolf.*;
-import ewe.io.File;
-import ewe.io.FileBase;
+package cachewolf.exp;
+import cachewolf.*;
+import cachewolf.utils.Common;
+import eve.io.File;
 import ewesoft.xml.*;
 import ewesoft.xml.sax.*;
 
@@ -12,7 +12,7 @@
 *	Now includes mapping of cachetypes to user defined icons (as defined in file garminmap.xml).
 */
 public class LocExporter extends Exporter{
-	public static int MODE_AUTO = TMP_FILE;
+	public static final int MODE_AUTO = TMP_FILE;
 	/**
 	 * Defines how certain cachetypes are mapped to user icons
 	 */
@@ -22,7 +22,7 @@
 		super();
 		this.setMask(&quot;*.loc&quot;);
 		this.setHowManyParams(NO_PARAMS);
-		if ((new File(FileBase.getProgramDirectory()+&quot;/garminmap.xml&quot;)).exists()) {
+		if ((new File(File.getProgramDirectory()+&quot;/garminmap.xml&quot;)).exists()) {
 			gm=new GarminMap();
 			gm.readGarminMap();
 		}
@@ -46,7 +46,7 @@
 			} catch (Exception ex){ pref.log(&quot;Invalid value for garmin.MaxWaypointLength&quot;); }
 		}
 		strBuf.append(&quot;\&quot;&gt;&lt;![CDATA[&quot;);
-		strBuf.append(simplifyString(chD.CacheName));
+		strBuf.append(simplifyString(chD.cacheName));
 		strBuf.append(&quot;]]&gt;&lt;/name&gt;\r\n   &lt;coord lat=\&quot;&quot;);
 		strBuf.append(chD.pos.getLatDeg(CWPoint.DD));
 		strBuf.append(&quot;\&quot; lon=\&quot;&quot;);
@@ -81,8 +81,8 @@
 		String lastName;
 		public void readGarminMap(){
 			try{
-				String datei = FileBase.getProgramDirectory() + &quot;/garminmap.xml&quot;;
-				ewe.io.Reader r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(datei));
+				String datei = File.getProgramDirectory() + &quot;/garminmap.xml&quot;;
+				java.io.Reader r = new java.io.InputStreamReader(new java.io.FileInputStream(datei));
 				parse(r);
 				r.close();
 			}catch(Exception e){
@@ -95,7 +95,7 @@
 		public void startElement(String name, AttributeList atts){
 			lastName=name;
 			if (name.equals(&quot;icon&quot;)) {
-				symbols[mapSize]=new IconMap(atts.getValue(&quot;type&quot;),atts.getValue(&quot;name&quot;),atts.getValue(&quot;found&quot;));
+				symbols[mapSize]=new IconMap(Common.parseInt(atts.getValue(&quot;type&quot;)),atts.getValue(&quot;name&quot;),atts.getValue(&quot;found&quot;));
 				mapSize++;
 			}
 		}		
@@ -104,25 +104,24 @@
 			// First check if there is a mapping for &quot;cache found&quot;
 			if (chD.is_found) {
 				for (int i=0; i&lt;mapSize; i++)
-					if (symbols[i].onlyIfFound!=null &amp;&amp; symbols[i].type.equals(chD.type)) return symbols[i].name;
+					if (symbols[i].onlyIfFound!=null &amp;&amp; symbols[i].type==chD.type) return symbols[i].name;
 			}
 			// Now try mapping the cache irrespective of the &quot;found&quot; status
 			for (int i=0; i&lt;mapSize; i++)
-				if (symbols[i].type.equals(chD.type)) return symbols[i].name;
+				if (symbols[i].type==chD.type) return symbols[i].name;
 		
 			// If it is not a mapped type, just use the standard mapping
 			if (chD.is_found)
 				return &quot;Geocache Found&quot;;
-			else
-				return &quot;Geocache&quot;;
+			return &quot;Geocache&quot;;
 		}
 		
 		private class IconMap {
-			public String type;
-			public String name;
+			public int type;
 			public Boolean onlyIfFound;
+			public String name;
 			
-			IconMap(String type, String name, String onlyIfFound) {
+			IconMap(int type, String name, String onlyIfFound) {
 				this.type=type;
 				this.name=name;
 				if (onlyIfFound!=null &amp;&amp; onlyIfFound.equals(&quot;1&quot;))

Modified: experiments/engywuck/hist-test/src/cachewolf/exp/MSARCSVExporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/exp/MSARCSVExporter.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/exp/MSARCSVExporter.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,6 +1,6 @@
-package exp;
+package cachewolf.exp;
 
-import CacheWolf.*;
+import cachewolf.*;
 
 /**
  * Class to export the cache database (index) to an CSV File which can bei easy
@@ -24,12 +24,12 @@
 
 	public String record(CacheHolderDetail ch, String lat, String lon) {
 		StringBuffer str = new StringBuffer(200);
-		str.append(&quot;\&quot;&quot; + ch.wayPoint + &quot; - &quot; + ch.CacheName + &quot;\&quot;;&quot;);
+		str.append(&quot;\&quot;&quot; + ch.wayPoint + &quot; - &quot; + ch.cacheName + &quot;\&quot;;&quot;);
 		str.append(lat + &quot;;&quot; + lon +&quot;;&quot;);
 		str.append(&quot;\&quot;&quot; + CacheType.transType(ch.type)+ &quot;\&quot;;&quot;);
-		str.append(&quot;\&quot;&quot; + ch.CacheSize + &quot;\&quot;;&quot;);
+		str.append(&quot;\&quot;&quot; + ch.getCacheSize() + &quot;\&quot;;&quot;);
 		str.append(&quot;\&quot;&quot; + ch.wayPoint + &quot;\&quot;;&quot;);
-		str.append(&quot;\&quot;&quot; + ch.DateHidden + &quot;\&quot;;&quot;);
+		str.append(&quot;\&quot;&quot; + ch.dateHidden + &quot;\&quot;;&quot;);
 		str.append(&quot;\&quot;&quot; + ch.URL + &quot;\&quot;\r\n&quot;);
 
 		return str.toString();

Modified: experiments/engywuck/hist-test/src/cachewolf/exp/OVLExporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/exp/OVLExporter.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/exp/OVLExporter.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,6 +1,7 @@
-package exp;
-import CacheWolf.*;
-import ewe.sys.*;
+package cachewolf.exp;
+import cachewolf.*;
+import cachewolf.utils.Common;
+import eve.sys.*;
 
 /**
 *	Class to export the cache database (index) to an ascii overlay file for
@@ -14,7 +15,7 @@
 		this.setHowManyParams(LAT_LON|COUNT);
 	}
 	
-	public String record(CacheHolderDetail ch, String lat, String lon, int counter){
+	public String record(CacheHolderDetail chD, String lat, String lon, int counter){
 		StringBuffer str = new StringBuffer(200);
 		double tmp;
 		str.append(&quot;[Symbol &quot;+Convert.toString(2*counter + 1)+&quot;]\r\n&quot;);
@@ -42,7 +43,7 @@
 		tmp = Common.parseDouble(lat);
 		tmp += 0.002;
 		str.append(&quot;YKoord=&quot;+Convert.toString(tmp).replace(',', '.')+&quot;\r\n&quot;);
-		str.append(&quot;Text=&quot;+ch.wayPoint+&quot;\r\n&quot;);
+		str.append(&quot;Text=&quot;+chD.wayPoint+&quot;\r\n&quot;);
 
 		return str.toString();
 	}

Modified: experiments/engywuck/hist-test/src/cachewolf/exp/OziExporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/exp/OziExporter.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/exp/OziExporter.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,5 +1,5 @@
-package exp;
-import CacheWolf.*;
+package cachewolf.exp;
+import cachewolf.*;
 
 /**
 *	Class to export the cache database (index) to an OziExplorer File
@@ -49,7 +49,7 @@
 		// Field 10 : Background Color (RGB value)
 		strBuf.append(&quot;16777215,&quot;);
 		// Field 11 : Description (max 40), no commas
-		tmpName = simplifyString(ch.CacheName);
+		tmpName = simplifyString(ch.cacheName);
 		if (tmpName.length() &lt;= 40){
 			strBuf.append(tmpName + &quot;,&quot;);
 		}

Modified: experiments/engywuck/hist-test/src/cachewolf/exp/PCX5Exporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/exp/PCX5Exporter.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/exp/PCX5Exporter.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,19 +1,20 @@
-package exp;
-import CacheWolf.*;
-import ewe.io.FileBase;
+package cachewolf.exp;
+import cachewolf.*;
+import cachewolf.utils.STRreplace;
+import eve.io.File;
 
 /**
 *	Class to export the cache database into an ascii file that may be imported
 *	ba Mapsource (c) by Garmin.
 */
 public class PCX5Exporter extends Exporter{
-	public static int MODE_AUTO = TMP_FILE;
-	public static int MODE_ASK = ASK_FILE;
+	public static final int MODE_AUTO = TMP_FILE;
+	public static final int MODE_ASK = ASK_FILE;
 	
 	public PCX5Exporter(Preferences p, Profile prof){
 		super();
 		this.setMask(&quot;*.wpt&quot;);
-		this.setTmpFileName(FileBase.getProgramDirectory() + &quot;/temp.pcx&quot;);
+		this.setTmpFileName(File.getProgramDirectory() + &quot;/temp.pcx&quot;);
 		this.setHowManyParams(NO_PARAMS);
 	}
 	
@@ -39,14 +40,14 @@
 		String latlonstr, dummy;
 
 		  strBuf.append(&quot;W  &quot; + ch.wayPoint + &quot; &quot;);
-		  latlonstr = STRreplace.replace(ch.LatLon, &quot;&#176;&quot;, &quot; &quot;);
+		  latlonstr = STRreplace.replace(ch.latLon, &quot;&#176;&quot;, &quot; &quot;);
 		  latlonstr = STRreplace.replace(latlonstr, &quot; &quot;, &quot;&quot;);
 		  latlonstr = STRreplace.replace(latlonstr, &quot;E&quot;, &quot; E&quot;);
 		  latlonstr = STRreplace.replace(latlonstr, &quot;W&quot;, &quot; W&quot;);
 		  strBuf.append(latlonstr + &quot;     &quot;);
 		  strBuf.append(&quot;01-JAN-04 01:00:00 -0000 &quot;);
 		  // has 42 characters
-		  dummy = ch.CacheName;
+		  dummy = ch.cacheName;
 		  if (dummy.length() &lt; 40){
 			  strBuf.append(dummy);
 			  int i = 40 - dummy.length();

Modified: experiments/engywuck/hist-test/src/cachewolf/exp/TPLExporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/exp/TPLExporter.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/exp/TPLExporter.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,8 +1,8 @@
 /*
-    CacheWolf is a software for PocketPC, Win and Linux that 
-    enables paperless caching. 
+    CacheWolf is a software for PocketPC, Win and Linux that
+    enables paperless caching.
     It supports the sites geocaching.com and opencaching.de
-    
+
     Copyright (C) 2006  CacheWolf development team
     See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
     for more information.
@@ -23,25 +23,28 @@
     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
     */
 
-package exp;
+package cachewolf.exp;
 
-import CacheWolf.CWPoint;
-import CacheWolf.CacheHolder;
-import CacheWolf.CacheHolderDetail;
-import CacheWolf.CacheType;
-import CacheWolf.Global;
-import CacheWolf.Preferences;
-import CacheWolf.Profile;
-import CacheWolf.Common;
 import HTML.Template;
-import ewe.filechooser.FileChooser;
-import ewe.filechooser.FileChooserBase;
-import ewe.io.*;
-import ewe.sys.*;
-import ewe.ui.*;
-import ewe.util.*;
-import com.stevesoft.ewe_pat.*;
+import eve.ui.filechooser.FileChooser;
+import java.io.*;
+import eve.io.*;
+import eve.sys.*;
+import eve.ui.*;
+import java.util.*;
 
+
+import cachewolf.CWPoint;
+import cachewolf.CacheHolder;
+import cachewolf.CacheHolderDetail;
+import cachewolf.CacheType;
+import cachewolf.Global;
+import cachewolf.Preferences;
+import cachewolf.Profile;
+import cachewolf.utils.Common;
+
+import com.stevesoft.eve_pat.*;
+
 /**
  * @author Kalle
  * class to export cachedata using a template
@@ -53,22 +56,22 @@
 	TextCodec codec = new AsciiCodec();
 	String badChars;
 	String decSep = &quot;.&quot;;
-	
 
+
 	public TplFilter(){
 		codec = new AsciiCodec(AsciiCodec.STRIP_CR);
 		return;
 	}
-	
+
 	public int format() {
 		return this.type;
 	}
-	
+
 	public String parse(String t) {
 		//Vm.debug(t);
 		Regex rex, rex1;
 		String param, value;
-		// Filter newlines 
+		// Filter newlines
 		rex = new Regex(&quot;(?m)\n$&quot;,&quot;&quot;);
 		t = rex.replaceAll(t);
 
@@ -83,7 +86,7 @@
 			t = rex.replaceAll(t);
 			t += newLine;
 		}
-		
+
 		// search for parameters
 		rex = new Regex(&quot;(?i)&lt;tmpl_par.*&gt;&quot;);
 		rex.search(t);
@@ -96,7 +99,7 @@
 			//Vm.debug(&quot;param=&quot; + param + &quot;\nvalue=&quot; + value);
 			//clear t, because we allow only one parameter per line
 			t = &quot;&quot;;
-			
+
 			// get the values
 			if (param.equals(&quot;charset&quot;)) {
 				if (value.equals(&quot;ASCII&quot;)) codec = new AsciiCodec();
@@ -113,19 +116,19 @@
 			if (param.equals(&quot;decsep&quot;)) {
 				decSep = value;
 			}
-
-
+			if (param.equals(&quot;debug&quot;))
+				HTML.Tmpl.Util.debug=true;
 		}
 		return t;
 	}
-		
-	
+
+
 	public String [] parse(String [] t) {
 		throw new UnsupportedOperationException();
 	}
 }
- 
 
+
 public class TPLExporter {
 	Vector cacheDB;
 	Preferences pref;
@@ -133,28 +136,28 @@
 	String tplFile;
 	String expName;
 	Regex rex=null;
-	
+
 	public TPLExporter(Preferences p, Profile prof, String tpl){
 		pref = p;
 		profile=prof;
 		cacheDB = profile.cacheDB;
 		tplFile = tpl;
-		File tmpFile = new File(tpl);
+		java.io.File tmpFile = new java.io.File(tpl);
 		expName = tmpFile.getName();
 		expName = expName.substring(0, expName.indexOf(&quot;.&quot;));
 	}
-	
+
 	public void doIt(){
-		CacheHolderDetail holder;
+		CacheHolderDetail chD;
 		CacheHolder ch;
 		ProgressBarForm pbf = new ProgressBarForm();
-		ewe.sys.Handle h = new ewe.sys.Handle();
+		eve.sys.Handle h = new eve.sys.Handle();
 
-		FileChooser fc = new FileChooser(FileChooserBase.SAVE, pref.getExportPath(expName));
-		fc.setTitle(&quot;Select target file:&quot;);
-		if(fc.execute() == FormBase.IDCANCEL) return;
-		File saveTo = fc.getChosenFile();
-		pref.setExportPath(expName, saveTo.getPath());
+		FileChooser fc = new FileChooser(FileChooser.SAVE, pref.getExportPath(expName));
+		fc.title=(&quot;Select target file:&quot;);
+		if(fc.execute() == FileChooser.IDCANCEL) return;
+		String saveTo = fc.getChosen();
+		pref.setExportPath(expName, saveTo);
 		int counter = 0;
 		for(int i = 0; i&lt;cacheDB.size();i++){
 			ch = (CacheHolder)cacheDB.get(i);
@@ -163,21 +166,21 @@
 		pbf.showMainTask = false;
 		pbf.setTask(h,&quot;Exporting ...&quot;);
 		pbf.exec();
-		Vm.gc(); // all this doesn't really work :-(
+		java.lang.Runtime.getRuntime().gc(); // all this doesn't really work :-(
 		System.runFinalization();
-		Vm.gc();
+		java.lang.Runtime.getRuntime().gc();
 		//Vm.debug(&quot;v: &quot;+Vm.countObjects(true));
 		try {
 			Vector cache_index = new Vector(); // declare variables inside try {} -&gt; in case of OutOfMemoryError, they can be garbage collected - anyhow it doesn't work :-(
 			Hashtable varParams;
 			TplFilter myFilter;
-			Hashtable args = new Hashtable(); 
+			Hashtable args = new Hashtable();
 			myFilter = new TplFilter();
 			//args.put(&quot;debug&quot;, &quot;true&quot;);
 			args.put(&quot;filename&quot;, tplFile);
 			args.put(&quot;case_sensitive&quot;, &quot;true&quot;);
 			args.put(&quot;loop_context_vars&quot;, Boolean.TRUE);
-			args.put(&quot;max_includes&quot;, new Integer(5));
+			args.put(&quot;max_includes&quot;, Integer.toString(5));
 			args.put(&quot;filter&quot;, myFilter);
 			Template tpl = new Template(args);
 
@@ -187,61 +190,61 @@
 				h.changed();
 				if(ch.is_black == false &amp;&amp; ch.is_filtered == false){
 					if (ch.pos.isValid() == false) continue;
-					holder=new CacheHolderDetail(ch);
+					chD=new CacheHolderDetail(ch);
 					try{
-						holder.readCache(profile.dataDir);
+						chD.readCache(profile.dataDir);
 					}catch(Exception e){
 						Vm.debug(&quot;Problem reading cache page&quot;);
-						Global.getPref().log(&quot;Exception in TplExporter = Problem reading cache page, Cache: &quot; + holder.wayPoint, e, true);
+						Global.getPref().log(&quot;Exception in TplExporter = Problem reading cache page, Cache: &quot; + chD.wayPoint, e, true);
 					}
 					try {
 						Regex dec = new Regex(&quot;[,.]&quot;,myFilter.decSep);
 						if (myFilter.badChars != null) rex = new Regex(&quot;[&quot;+myFilter.badChars+&quot;]&quot;,&quot;&quot;);
 						varParams = new Hashtable();
-						varParams.put(&quot;TYPE&quot;, CacheType.transType(holder.type));
-						varParams.put(&quot;SHORTTYPE&quot;, CacheType.transType(holder.type).substring(0,1));
-						varParams.put(&quot;SIZE&quot;, holder.CacheSize);
-						varParams.put(&quot;SHORTSIZE&quot;, holder.CacheSize.substring(0,1));
-						varParams.put(&quot;WAYPOINT&quot;, holder.wayPoint);
-						varParams.put(&quot;OWNER&quot;, holder.CacheOwner);
-						varParams.put(&quot;DIFFICULTY&quot;, dec.replaceAll(holder.hard));
-						varParams.put(&quot;TERRAIN&quot;, dec.replaceAll(holder.terrain));
-						varParams.put(&quot;DISTANCE&quot;, dec.replaceAll(holder.distance));
-						varParams.put(&quot;BEARING&quot;, holder.bearing);
-						varParams.put(&quot;LATLON&quot;, holder.LatLon);
-						varParams.put(&quot;LAT&quot;, dec.replaceAll(holder.pos.getLatDeg(CWPoint.DD)));
-						varParams.put(&quot;LON&quot;, dec.replaceAll(holder.pos.getLonDeg(CWPoint.DD)));
-						varParams.put(&quot;STATUS&quot;, holder.CacheStatus);
-						varParams.put(&quot;STATUS_DATE&quot;, holder.GetStatusDate());
-						varParams.put(&quot;STATUS_TIME&quot;, holder.GetStatusTime());
-						varParams.put(&quot;DATE&quot;, holder.DateHidden);
-						varParams.put(&quot;URL&quot;, holder.URL);
-						varParams.put(&quot;DESCRIPTION&quot;, holder.LongDescription);
-						if (myFilter.badChars != null) {
-							varParams.put(&quot;NAME&quot;, rex.replaceAll(holder.CacheName));
-							varParams.put(&quot;NOTES&quot;, rex.replaceAll(holder.CacheNotes));
-							varParams.put(&quot;HINTS&quot;, rex.replaceAll(holder.Hints));
-							varParams.put(&quot;DECRYPTEDHINTS&quot;, rex.replaceAll(Common.rot13(holder.Hints)));
-						} else {
-							varParams.put(&quot;NAME&quot;, holder.CacheName);
-							varParams.put(&quot;NOTES&quot;, holder.CacheNotes);
-							varParams.put(&quot;HINTS&quot;, holder.Hints);
-							varParams.put(&quot;DECRYPTEDHINTS&quot;, Common.rot13(holder.Hints));
-						}
+						varParams.put(&quot;TYPE&quot;, CacheType.transType(chD.type));
+						varParams.put(&quot;SHORTTYPE&quot;, CacheType.transType(chD.type).substring(0,1));
+						varParams.put(&quot;SIZE&quot;, chD.getCacheSize());
+						varParams.put(&quot;SHORTSIZE&quot;, chD.getCacheSize().substring(0,1));
+						varParams.put(&quot;WAYPOINT&quot;, chD.wayPoint);
+						varParams.put(&quot;OWNER&quot;, chD.cacheOwner);
+						varParams.put(&quot;DIFFICULTY&quot;, dec.replaceAll(chD.hard));
+						varParams.put(&quot;TERRAIN&quot;, dec.replaceAll(chD.terrain));
+						varParams.put(&quot;DISTANCE&quot;, dec.replaceAll(chD.distance));
+						varParams.put(&quot;BEARING&quot;, chD.bearing);
+						varParams.put(&quot;LATLON&quot;, chD.latLon);
+						varParams.put(&quot;LAT&quot;, dec.replaceAll(chD.pos.getLatDeg(CWPoint.DD)));
+						varParams.put(&quot;LON&quot;, dec.replaceAll(chD.pos.getLonDeg(CWPoint.DD)));
+						varParams.put(&quot;STATUS&quot;, chD.cacheStatus);
+						varParams.put(&quot;STATUS_DATE&quot;, chD.getStatusDate());
+						varParams.put(&quot;STATUS_TIME&quot;, chD.getStatusTime());
+						varParams.put(&quot;DATE&quot;, chD.dateHidden);
+						varParams.put(&quot;URL&quot;, chD.URL);
+						varParams.put(&quot;NOTES&quot;, chD.cacheNotes);
+						varParams.put(&quot;DESCRIPTION&quot;, chD.longDescription);
+                        if (myFilter.badChars != null) {
+                            varParams.put(&quot;NAME&quot;, rex.replaceAll(chD.cacheName));
+                            varParams.put(&quot;NOTES&quot;, rex.replaceAll(chD.cacheNotes));
+                            varParams.put(&quot;HINTS&quot;, rex.replaceAll(chD.hints));
+                            varParams.put(&quot;DECRYPTEDHINTS&quot;, rex.replaceAll(Common.rot13(chD.hints)));
+                    } else {
+                            varParams.put(&quot;NAME&quot;, chD.cacheName);
+                            varParams.put(&quot;NOTES&quot;, chD.cacheNotes);
+                            varParams.put(&quot;HINTS&quot;, chD.hints);
+                            varParams.put(&quot;DECRYPTEDHINTS&quot;, Common.rot13(chD.hints));
+                    }
 						cache_index.add(varParams);
 					}catch(Exception e){
-						Vm.debug(&quot;Problem getting Parameter, Cache: &quot; + holder.wayPoint);
+						Vm.debug(&quot;Problem getting Parameter, Cache: &quot; + chD.wayPoint);
 						e.printStackTrace();
-						Global.getPref().log(&quot;Exception in TplExporter = Problem getting Parameter, Cache: &quot; + holder.wayPoint, e, true);
+						Global.getPref().log(&quot;Exception in TplExporter = Problem getting Parameter, Cache: &quot; + chD.wayPoint, e, true);
 					}
 				}
 			}
 
 			tpl.setParam(&quot;cache_index&quot;, cache_index);
-			PrintWriter detfile; 
-			FileWriter fw = new FileWriter(saveTo);
-			fw.codec = myFilter.codec;
-			detfile = new PrintWriter(new BufferedWriter(fw));
+			PrintWriter detfile;
+			OutputStreamWriter fw = new OutputStreamWriter(new BufferedOutputStream(new FileOutputStream(saveTo)), myFilter.codec.toString());
+			detfile = new PrintWriter(fw);
 			tpl.printTo(detfile);
 			//detfile.print(tpl.output());
 			detfile.close();
@@ -250,11 +253,11 @@
 			Global.getPref().log(&quot;Exception in TplExporter&quot;, e, true);
 		} catch (OutOfMemoryError e) {
 			//Global.getPref().log(&quot;OutOfMemeory in TplExporter&quot;, e, true);
-			Vm.gc(); // this doesn't help :-(
+			java.lang.Runtime.getRuntime().gc(); // this doesn't help :-(
 			System.runFinalization();
-			Vm.gc(); // this doesn't help :-( - I don't know why :-(
+			java.lang.Runtime.getRuntime().gc(); // this doesn't help :-( - I don't know why :-(
 			//Vm.debug(&quot;n: &quot;+Vm.countObjects(true));
-			(new MessageBox(&quot;Error&quot;, &quot;Not enough memory available to load all cache data (incl. description and logs)\nexport aborted\nFilter caches to minimise memory needed for TPL-Export\nWe recommend to restart CacheWolf now&quot;, FormBase.OKB)).execute();
+			(new MessageBox(&quot;Error&quot;, &quot;Not enough memory available to load all cache data (incl. description and logs)\nexport aborted\nFilter caches to minimise memory needed for TPL-Export\nWe recommend to restart CacheWolf now&quot;, MessageBox.OKB)).execute();
 			//Vm.debug(&quot;n: &quot;+Vm.countObjects(true));
 		}
 		pbf.exit(0);

Modified: experiments/engywuck/hist-test/src/cachewolf/exp/TomTomExporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/exp/TomTomExporter.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/exp/TomTomExporter.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,15 +1,19 @@
-package exp;
+package cachewolf.exp;
 
 
-import CacheWolf.*;
-import ewe.ui.*;
-import ewe.util.*;
-import ewe.util.zip.*;
-import ewe.filechooser.FileChooser;
-import ewe.filechooser.FileChooserBase;
-import ewe.io.*;
-import ewe.sys.*;
+import eve.ui.*;
+import java.util.*;
+import java.util.zip.*;
+import eve.ui.filechooser.FileChooser;
+import eve.sys.*;
+import java.io.*;
 
+import cachewolf.*;
+import cachewolf.utils.Common;
+
+import eve.util.ByteArray;
+
+
 public class TomTomExporter {
 	public final static int TT_ASC = 0;
 	public final static int TT_OV2 = 1;
@@ -35,27 +39,27 @@
 		int fileFormat;
 
 		TomTomExporterScreen infoScreen = new TomTomExporterScreen(&quot;TomTomExport&quot;);
-		if (infoScreen.execute() == FormBase.IDCANCEL) return;
+		if (infoScreen.execute() == Form.IDCANCEL) return;
 		fileFormat = infoScreen.getFormat();
 
 		dirName = pref.getExportPath(expName);
 		
 		if (infoScreen.oneFilePerType()==true){
-			FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, dirName);
-			fc.setTitle(&quot;Select target dir:&quot;);
-			if(fc.execute() == FormBase.IDCANCEL) return;
+			FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, dirName);
+			fc.title=(&quot;Select target dir:&quot;);
+			if(fc.execute() == FileChooser.IDCANCEL) return;
 			dirName = fc.getChosen();
 			pref.setExportPath(expName, dirName);
 			prefix = infoScreen.getPrefix();
 			writeOneFilePerType(fileFormat, dirName, prefix);
 		} else{
-			FileChooser fc = new FileChooser(FileChooserBase.SAVE, dirName);
-			fc.setTitle(&quot;Select target file:&quot;);
+			FileChooser fc = new FileChooser(FileChooser.SAVE, dirName);
+			fc.title=(&quot;Select target file:&quot;);
 	
 			if (fileFormat == TT_ASC) fc.addMask(&quot;*.asc&quot;);
 			else fc.addMask(&quot;*.ov2&quot;);
 			
-			if(fc.execute() == FormBase.IDCANCEL) return;
+			if(fc.execute() == FileChooser.IDCANCEL) return;
 			fileName = fc.getChosen();
 			pref.setExportPathFromFileName(expName, fileName);
 			writeSingleFile(fileFormat, fileName);
@@ -64,10 +68,10 @@
 	
 	public void writeOneFilePerType(int format, String dirName, String prefix){
 		RandomAccessFile out = null;
-		File dfile;
+		java.io.File dfile;
 		String ext, fileName = null;
 
-		CacheHolder holder;
+		CacheHolder ch;
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
 		int currExp, counter;
@@ -79,39 +83,39 @@
 		currExp = 0;
 		counter = 0;
 		for(int i = 0; i&lt;cacheDB.size();i++){
-			holder = (CacheHolder)cacheDB.get(i);
-			if(holder.is_black == false &amp;&amp; holder.is_filtered == false) counter++;
+			ch = (CacheHolder)cacheDB.get(i);
+			if(ch.is_black == false &amp;&amp; ch.is_filtered == false) counter++;
 		}
 		
 		ext = format==TT_ASC?&quot;.asc&quot;:&quot;.ov2&quot;;
 		try{
 			//loop through type
 			for(int j = 0; j &lt; CacheType.wayType.length; j++){
-				fileName = dirName + &quot;/&quot; + prefix + CacheType.wayType[j][TT_WPT_TEXT]+ ext;
-				dfile = new File(fileName);
+				fileName = dirName + &quot;/&quot; + prefix + CacheType.wayType[j]+ ext;
+				dfile = new java.io.File(fileName);
 				dfile.delete();
 				out =  new RandomAccessFile(fileName,&quot;rw&quot;);
 				for(int i = 0; i&lt;cacheDB.size(); i++){
-					holder=(CacheHolder)cacheDB.get(i);
-					if(holder.type.equals(CacheType.wayType[j][TT_WPT_NUM]) &amp;&amp; holder.is_black == false &amp;&amp; holder.is_filtered == false){
+					ch=(CacheHolder)cacheDB.get(i);
+					if(ch.type==CacheType.wayTypeNo[j] &amp;&amp; ch.is_black == false &amp;&amp; ch.is_filtered == false){
 						currExp++;
 						h.progress = (float)currExp/(float)counter;
 						h.changed();
-						if (holder.pos.isValid() == false) continue;
+						if (ch.pos.isValid() == false) continue;
 						if (format == TT_ASC){
-							writeRecordASCII(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
+							writeRecordASCII(out, ch,ch.pos.getLatDeg(CWPoint.DD),ch.pos.getLonDeg(CWPoint.DD));
 						} else {
-							writeRecordBinary(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
+							writeRecordBinary(out, ch,ch.pos.getLatDeg(CWPoint.DD),ch.pos.getLonDeg(CWPoint.DD));
 						}
 					}//if
 				}//for cacheDB
 				out.close();
 				// check for empty files and delete them
-				dfile = new File(fileName);
+				dfile = new java.io.File(fileName);
 				if (dfile.length()==0) {
 					dfile.delete();
 				} else {
-					copyIcon(j, dirName + &quot;/&quot; + prefix + CacheType.wayType[j][TT_WPT_TEXT]); 
+					copyIcon(j, dirName + &quot;/&quot; + prefix + CacheType.wayType[j]); 
 				}
 			}//for wayType
 			pbf.exit(0);
@@ -124,9 +128,9 @@
 	
 	public void writeSingleFile(int format, String fileName){
 		RandomAccessFile out = null;
-		File dfile;
+		java.io.File dfile;
 
-		CacheHolder holder;
+		CacheHolder ch;
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
 
@@ -137,25 +141,25 @@
 		int counter = 0;
 		int expCount = 0;
 		for(int i = 0; i&lt;cacheDB.size();i++){
-			holder = (CacheHolder)cacheDB.get(i);
-			if(holder.is_black == false &amp;&amp; holder.is_filtered == false) counter++;
+			ch = (CacheHolder)cacheDB.get(i);
+			if(ch.is_black == false &amp;&amp; ch.is_filtered == false) counter++;
 		}
 
 		try{
-			dfile = new File(fileName);
+			dfile = new java.io.File(fileName);
 			dfile.delete();
 			out =  new RandomAccessFile(fileName,&quot;rw&quot;);
 			for(int i = 0; i&lt;cacheDB.size(); i++){
-				holder=(CacheHolder)cacheDB.get(i);
-				if(holder.is_black == false &amp;&amp; holder.is_filtered == false){
+				ch=(CacheHolder)cacheDB.get(i);
+				if(ch.is_black == false &amp;&amp; ch.is_filtered == false){
 					expCount++;
 					h.progress = (float)expCount/(float)counter;
 					h.changed();
-					if (holder.pos.isValid() == false) continue;
+					if (ch.pos.isValid() == false) continue;
 					if (format == TT_ASC){
-						writeRecordASCII(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
+						writeRecordASCII(out, ch,ch.pos.getLatDeg(CWPoint.DD),ch.pos.getLonDeg(CWPoint.DD));
 					} else {
-						writeRecordBinary(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
+						writeRecordBinary(out, ch,ch.pos.getLatDeg(CWPoint.DD),ch.pos.getLonDeg(CWPoint.DD));
 					}
 				}//if
 			}//for
@@ -179,15 +183,15 @@
 			outp.writeBytes(&quot;\&quot;&quot;);
 			outp.writeBytes(ch.wayPoint);
 			outp.writeBytes(&quot; - &quot;);
-			outp.writeBytes(ch.CacheName.replace(',',' '));
+			outp.writeBytes(ch.cacheName.replace(',',' '));
 			outp.writeBytes(&quot; by &quot;);
-			outp.writeBytes(ch.CacheOwner);
+			outp.writeBytes(ch.cacheOwner);
 			outp.writeBytes(&quot;- &quot;);             
 			outp.writeBytes(ch.hard);
 			outp.writeBytes(&quot;/&quot;);
 			outp.writeBytes(ch.terrain);
 			outp.writeBytes(&quot; - &quot;);
-			outp.writeBytes(ch.CacheSize);
+			outp.writeBytes(ch.getCacheSize());
 			outp.writeBytes(&quot;\&quot;\r\n&quot;);
 		} catch (IOException e) {
 			Vm.debug(&quot;Error writing to file&quot;);
@@ -204,7 +208,7 @@
 		try {
 			d = 2;
 			outp.writeByte((byte)d);
-			data = ch.wayPoint.length()+ch.CacheName.length()+ch.CacheOwner.length()+ch.hard.length()+ch.terrain.length()+ch.CacheSize.length()+27;
+			data = ch.wayPoint.length()+ch.cacheName.length()+ch.cacheOwner.length()+ch.hard.length()+ch.terrain.length()+ch.getCacheSize().length()+27;
 			writeIntBinary(outp, data);
 			latlon = Common.parseDouble(lon);
 			latlon *=100000;
@@ -214,9 +218,9 @@
 			writeIntBinary(outp, (int) latlon);
 			outp.writeBytes(ch.wayPoint);
 			outp.writeBytes(&quot; - &quot;);
-			outp.writeBytes(ch.CacheName);
+			outp.writeBytes(ch.cacheName);
 			outp.writeBytes(&quot; by &quot;);
-			outp.writeBytes(ch.CacheOwner);
+			outp.writeBytes(ch.cacheOwner);
 			//Wenn Leerzeichen am Ende von Cache.Owner entfernt: 
 			//Hier wieder einf&#252;gen
 			//und data = holder.wayPoint.length()+holder.CacheName.length()+.....
@@ -226,7 +230,7 @@
 			outp.writeBytes(&quot;/&quot;);
 			outp.writeBytes(ch.terrain);
 			outp.writeBytes(&quot; - &quot;);
-			outp.writeBytes(ch.CacheSize);
+			outp.writeBytes(ch.getCacheSize());
 			d = 0;
 			outp.writeByte((byte)d);
 		} catch (IOException e) {
@@ -256,16 +260,16 @@
 	
 	public void copyIcon(int intWayType, String filename){
 		try {
-			ZipFile zif = new ZipFile (FileBase.getProgramDirectory() + &quot;/POIIcons.zip&quot;);
+			ZipFile zif = new ZipFile (eve.io.File.getProgramDirectory() + &quot;/POIIcons.zip&quot;);
 			ZipEntry zipEnt;
 			int len;
 			String entName; 
 			
-			entName = &quot;TomTomIcons/&quot;+ &quot;GC-&quot; + CacheType.wayType[intWayType][TT_WPT_TEXT] + &quot;.bmp&quot;;
+			entName = &quot;TomTomIcons/&quot;+ &quot;GC-&quot; + CacheType.wayType[intWayType] + &quot;.bmp&quot;;
 			zipEnt = zif.getEntry(entName);
 			if (zipEnt == null) return;
 			
-		    byte[] buff = new byte[ zipEnt.getSize() ];
+		    byte[] buff = new byte[ (int) zipEnt.getSize() ];
 		    InputStream  fis = zif.getInputStream(zipEnt);
 		    FileOutputStream fos = new FileOutputStream( filename + &quot;.bmp&quot;);
 		    while( 0 &lt; (len = fis.read( buff )) )
@@ -274,10 +278,10 @@
 		    fos.close();
 		    fis.close();
 		} catch (ZipException e) {
-			Vm.debug(&quot;Problem copying Icon&quot; + &quot;GC-&quot; + CacheType.wayType[intWayType][TT_WPT_TEXT] + &quot;.bmp&quot; );
+			Vm.debug(&quot;Problem copying Icon&quot; + &quot;GC-&quot; + CacheType.wayType[intWayType] + &quot;.bmp&quot; );
 			e.printStackTrace();
 		} catch (IOException e) {
-			Vm.debug(&quot;Problem copying Icon&quot; + &quot;GC-&quot; + CacheType.wayType[intWayType][TT_WPT_TEXT] + &quot;.bmp&quot; );
+			Vm.debug(&quot;Problem copying Icon&quot; + &quot;GC-&quot; + CacheType.wayType[intWayType] + &quot;.bmp&quot; );
 			e.printStackTrace();
 		}
 

Modified: experiments/engywuck/hist-test/src/cachewolf/exp/TomTomExporterScreen.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/exp/TomTomExporterScreen.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/exp/TomTomExporterScreen.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,13 +1,16 @@
-package exp;
+package cachewolf.exp;
 
-import CacheWolf.MyLocale;
-import ewe.ui.*;
+import cachewolf.MyLocale;
+import eve.ui.*;
+import eve.fx.gui.IKeys; 
+import eve.ui.event.ControlEvent;
+import eve.sys.Event;
 
 public class TomTomExporterScreen extends Form {
-	mButton cancelB, okB;
-	mCheckBox chkASC, chkOV2, chkOneFilePerType;
+	Button cancelB, okB;
+	CheckBox chkASC, chkOV2, chkOneFilePerType;
 	CheckBoxGroup chkGroupFormat;
-	mInput inpPrefix;
+	Input inpPrefix;
 	
 	public TomTomExporterScreen(String title){
 		super();
@@ -15,31 +18,31 @@
 
 		// checkboxgroup for fileformat
 		chkGroupFormat = new CheckBoxGroup();
-		chkASC = new mCheckBox(&quot;.asc&quot;);
+		chkASC = new CheckBox(&quot;.asc&quot;);
 		chkASC.setGroup(chkGroupFormat);
-		chkOV2 = new mCheckBox(&quot;.ov2&quot;);
+		chkOV2 = new CheckBox(&quot;.ov2&quot;);
 		chkOV2.setGroup(chkGroupFormat);
 		chkGroupFormat.selectIndex(TomTomExporter.TT_OV2);
 		
-		this.addLast(new mLabel(&quot;Fileformat&quot;));
+		this.addLast(new Label(&quot;Fileformat&quot;));
 		this.addNext(chkASC);
 		this.addLast(chkOV2);
 		
 		// checkbox for one file for all or one file per cachetype
-		chkOneFilePerType = new mCheckBox(&quot;Eine Datei pro Cachetyp&quot;);
+		chkOneFilePerType = new CheckBox(&quot;Eine Datei pro Cachetyp&quot;);
 		chkOneFilePerType.setState(true);
 		this.addLast(chkOneFilePerType);
 		
 		//prefix for files, if one file per cachetype
-		inpPrefix = new mInput(&quot;GC-&quot;);
+		inpPrefix = new Input(&quot;GC-&quot;);
 		activateInpPrefix();
 		this.addLast(inpPrefix);
 		
 		// cancel and ok Button
-		cancelB = new mButton(MyLocale.getMsg(1604,&quot;Cancel&quot;));
+		cancelB = new Button(MyLocale.getMsg(1604,&quot;Cancel&quot;));
 		cancelB.setHotKey(0, IKeys.ESCAPE);
 		this.addNext(cancelB,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		okB = new mButton(MyLocale.getMsg(1605,&quot;OK&quot;));
+		okB = new Button(MyLocale.getMsg(1605,&quot;OK&quot;));
 		okB.setHotKey(0, IKeys.ACTION);
 		okB.setHotKey(0, IKeys.ENTER);
 		this.addLast(okB,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
@@ -66,10 +69,10 @@
 	public void onEvent(Event ev){
 		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
 			if (ev.target == cancelB){
-				this.close(FormBase.IDCANCEL);
+				this.close(Form.IDCANCEL);
 			}
 			if (ev.target == okB){
-				this.close(FormBase.IDOK);
+				this.close(Form.IDOK);
 			}
 			if (ev.target == chkOneFilePerType){
 				activateInpPrefix(); 

Added: experiments/engywuck/hist-test/src/cachewolf/imp/DBImporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/imp/DBImporter.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/imp/DBImporter.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -0,0 +1,172 @@
+package cachewolf.imp;
+
+import java.util.Enumeration;
+import java.util.Hashtable;
+import java.util.Vector;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
+import cachewolf.CWPoint;
+import cachewolf.CacheHolder;
+import cachewolf.CacheHolderDetail;
+import cachewolf.CacheType;
+import cachewolf.Filter;
+import cachewolf.InfoBox;
+import cachewolf.MyLocale;
+import cachewolf.Preferences;
+import cachewolf.Profile;
+import cachewolf.utils.Common;
+import cachewolf.utils.SafeXML;
+import eve.sys.Handle;
+import eve.ui.Form;
+import eve.ui.ProgressBarForm;
+
+
+public class DBImporter {
+	int i,j,ln;
+	Vector cacheDB;
+	int zaehlerGel = 0;
+	Hashtable DBindex = new Hashtable();
+	
+	public DBImporter(){
+		cacheDB = cachewolf.Global.getProfile().cacheDB;
+		//index db for faster search
+		CacheHolder ch;
+		for(i = cacheDB.size()-1;i&gt;=0; i--){
+			ch = (CacheHolder)cacheDB.get(i);
+			DBindex.put(ch.wayPoint, new Integer(i));
+		}//for
+	}
+
+	public void doIt(String file){
+		Filter flt = new Filter();
+		boolean wasFiltered = (cachewolf.Global.getProfile().filterActive==Filter.FILTER_ACTIVE);		
+		flt.clearFilter();
+		try {
+			java.io.BufferedReader r;
+			
+			if (file.indexOf(&quot;.zip&quot;) &gt; 0){
+				ZipFile zif = new ZipFile (file);
+				ZipEntry zipEnt;
+				Enumeration zipEnum = zif.entries();
+				// there could be more than one file in the archive
+				while (zipEnum.hasMoreElements()) {	
+					zipEnt = (ZipEntry) zipEnum.nextElement();
+					if (zipEnt.getName().endsWith(&quot;db&quot;)){
+						r = new java.io.BufferedReader(new java.io.InputStreamReader(zif.getInputStream(zipEnt)));
+						
+						parse(r,zipEnt.getSize());
+						r.close();
+					}
+				}
+			} else { // Already unpacked
+				r = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file)));
+				parse(r,new java.io.File(file).length());
+				r.close();
+			}
+			// save Index 
+			cachewolf.Global.getProfile().saveIndex(Profile.NO_SHOW_PROGRESS_BAR);
+			Form.cancelWait();
+		}catch(Exception e){
+			e.printStackTrace();
+			Form.cancelWait();
+		}
+		if(wasFiltered){
+			flt.setFilter();
+			flt.doFilter();
+		}
+	}
+
+	private final void parse(java.io.BufferedReader r,long len) {
+// One typical line in DB file
+//734139 &quot;CQ DE HB0 - HAM-Cache in Liechtenstein by DunaX&quot; 2007 11 12 47.1388 9.53848333333333 
+//&quot;Multi-cache&quot; &quot;Regular&quot; GC17DPV 7a5585fd-af71-4ab7-ab42-27da2e461ef2 1.5 1.5
+		final int LINESIZE=150;
+		float size=len/LINESIZE;
+		boolean showprogress=true; // Keep this so that we can later decide whether to make it switchable
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+		if(showprogress){
+			pbf.showMainTask = false;
+			pbf.setTask(h,&quot;Importing DB&quot;);
+			pbf.exec();
+		}
+		// Each line is about 150 chars
+		int progressInt=(int) len/LINESIZE/100;
+		int nextProgress=0;
+		int idx;
+		String line;
+		ln=0; // Line No
+		try {
+			while((line=r.readLine())!=null) {
+				ln++;
+				CacheHolder ch=new CacheHolder();
+				// &quot;cachename by owner&quot;
+				i=line.indexOf(&quot;\&quot;&quot;);
+				j=line.indexOf(&quot;\&quot;&quot;,i+1);
+				String name=line.substring(i+1,j);
+				i=name.indexOf(&quot; by &quot;);
+				if (i&gt;0) {
+					ch.cacheName=SafeXML.cleanback(name.substring(0,i));
+					ch.cacheOwner=SafeXML.cleanback(name.substring(i+4));
+				} else {
+					ch.cacheName=SafeXML.cleanback(name);
+				}
+				// date hidden: Y M D
+				StringBuffer sb=new StringBuffer(12);
+				sb.append(line.substring(j+2,j+6)).append(&quot;-&quot;);
+				i=line.indexOf(&quot; &quot;,j+7);
+				if (j+8==i) sb.append(&quot;0&quot;);
+				sb.append(line.substring(j+7,i)).append(&quot;-&quot;);
+				j=line.indexOf(&quot; &quot;,i+1);
+				if (i+2==j) sb.append(&quot;0&quot;);
+				sb.append(line.substring(i+1,j));
+				ch.dateHidden=sb.toString();
+				// lat lon
+				i=line.indexOf(&quot; &quot;,j+1);
+				double lat=Common.parseDouble(line.substring(j+1,i));
+				j=line.indexOf(&quot; &quot;,i+1);
+				ch.pos=new CWPoint(lat,Common.parseDouble(line.substring(i+1,j)));
+				ch.latLon=ch.pos.toString();
+				// Type
+				i=line.indexOf(&quot;\&quot;&quot;,i+1);
+				j=line.indexOf(&quot;\&quot;&quot;,i+1);
+				ch.type=CacheType.typeText2Number(line.substring(i+1,j));
+				// Size
+				i=line.indexOf(&quot;\&quot;&quot;,j+1);
+				j=line.indexOf(&quot;\&quot;&quot;,i+1);
+				ch.setCacheSize(line.substring(i+1,j));
+				//waypoint
+				i=line.indexOf(&quot; &quot;,j+1);
+				j=line.indexOf(&quot; &quot;,i+1);
+				ch.wayPoint=line.substring(i+1,j);
+				// skip ID
+				i=line.indexOf(&quot; &quot;,j+1);
+				// diff terrain
+				j=line.indexOf(&quot; &quot;,i+1);
+				ch.hard=line.substring(i+1,j);
+				ch.terrain=line.substring(j+1);
+				idx=searchWpt(ch.wayPoint);
+				if (idx&lt;0)
+					cacheDB.add(ch);
+				else
+					((CacheHolder)cacheDB.get(idx)).update(ch);
+				ch=null;
+				if(showprogress &amp;&amp; ln&gt;=nextProgress){
+					h.progress = (float)ln/size;
+					h.changed();
+					nextProgress+=progressInt;
+				}
+			}
+		} catch(Exception ex) {}
+		if(showprogress) pbf.exit(0);
+	}
+	
+	private int searchWpt(String wpt){
+		Integer INTR = (Integer)DBindex.get(wpt);
+		if(INTR != null){
+			return INTR.intValue();
+		} 
+		return -1;
+	}
+}

Modified: experiments/engywuck/hist-test/src/cachewolf/imp/GPXImporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/imp/GPXImporter.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/imp/GPXImporter.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,20 +1,37 @@
-package CacheWolf;
+package cachewolf.imp;
 
 import ewesoft.xml.*;
 import ewesoft.xml.sax.*;
-import ewe.sys.*;
-import ewe.ui.FormBase;
-import ewe.ui.MessageBox;
-import ewe.util.*;
-import ewe.util.zip.*;
+import eve.sys.*;
+import eve.ui.MessageBox;
+import java.util.*;
+import java.util.zip.*;
 
+import cachewolf.CacheHolder;
+import cachewolf.CacheHolderDetail;
+import cachewolf.CacheType;
+import cachewolf.Filter;
+import cachewolf.InfoBox;
+import cachewolf.Log;
+import cachewolf.MyLocale;
+import cachewolf.Preferences;
+import cachewolf.Profile;
+import cachewolf.Travelbug;
+import cachewolf.utils.Common;
+import cachewolf.utils.Extractor;
+import cachewolf.utils.ParseLatLon;
+import cachewolf.utils.SafeXML;
+
+
+import eve.ui.Form;
+
 /**
-*	Class to import Data from an GPX File. If cache data exists, the data from 
+*	Class to import Data from an GPX File. If cache data exists, the data from
 *	the GPX-File is ignored.
 *	Class ID = 4000
 */
 public class GPXImporter extends MinML {
-	
+
 	static Preferences pref;
 	Profile profile;
 	Vector cacheDB;
@@ -23,13 +40,12 @@
 	boolean inWpt, inCache, inLogs, inBug;
 	public XMLElement document;
 	private Vector files = new Vector();
-	private boolean debugGPX = false; 
+	private boolean debugGPX = false;
 	InfoBox infB;
 	boolean spiderOK = true;
 	boolean doSpider = false;
 	boolean fromOC = false;
 	boolean fromTC = false;
-	boolean nameFound = false;
 	int zaehlerGel = 0;
 	Hashtable DBindex = new Hashtable();
 	public static final int DOIT_ASK = 0;
@@ -38,7 +54,7 @@
 	boolean getMaps = false;
 	SpiderGC imgSpider;
 	StringBuffer strBuf;
-	
+
 	public GPXImporter(Preferences p, Profile prof, String f )
 	{
 		profile=prof;
@@ -59,7 +75,7 @@
 			DBindex.put(ch.wayPoint, new Integer(i));
 		}//for
 	}
-/*	skg: This Constructor is not referenced, therefore commented out 
+/*	skg: This Constructor is not referenced, therefore commented out
 	public GPXImporter(Vector DB, String[] f,String d, Preferences p)
 	{
 		pref = p;
@@ -68,7 +84,7 @@
 		for (int i=0;i&lt;f.length;i++){
 			files.add(d + &quot;/&quot; + f[i]);
 		}
-		
+
 		//msgA = msgArea;
 		inWpt = false;
 		inCache = false;
@@ -82,17 +98,16 @@
 			DBindex.put((String)ch.wayPoint, new Integer(i));
 		}//for
 	}
-*/	
+*/
 	public void doIt(int how){
 		Filter flt = new Filter();
-		boolean wasFiltered = (profile.filterActive==Filter.FILTER_ACTIVE);
-		flt.clearFilter();
-		try{
-			ewe.io.Reader r;
+		boolean wasFiltered = (profile.filterActive==Filter.FILTER_ACTIVE);		flt.clearFilter();
+		try {
+			java.io.Reader r;
 			String file;
-			
+
 			OCXMLImporterScreen options = new OCXMLImporterScreen(&quot;Spider Options&quot;, OCXMLImporterScreen.IMAGES);
-			if (options.execute() == FormBase.IDCANCEL) {	return; }
+			if (options.execute() == OCXMLImporterScreen.IDCANCEL) {	return; }
 			//String dist = options.distanceInput.getText();
 			//if (dist.length()== 0) return;
 			//getMaps = options.mapsCheckBox.getState();
@@ -103,9 +118,9 @@
 				imgSpider = new SpiderGC(pref, profile, false);
 			}
 			options.close(0);
-			
+
 			//Vm.debug(&quot;State of: &quot; + doSpider);
-			Vm.showWait(true);
+			Form.showWait();
 			for (int i=0; i&lt;files.size();i++){
 				//Test for zip.file
 				file = (String)files.get(i);
@@ -119,8 +134,8 @@
 						zipEnt = (ZipEntry) zipEnum.nextElement();
 						// skip over PRC-files
 						if (zipEnt.getName().endsWith(&quot;gpx&quot;)){
-							r = new ewe.io.InputStreamReader(zif.getInputStream(zipEnt));
-							infB = new InfoBox(zipEnt.toString(),(MyLocale.getMsg(4000,&quot;Loaded caches: &quot;) + zaehlerGel));
+							r = new java.io.InputStreamReader(zif.getInputStream(zipEnt));
+							infB = new InfoBox(zipEnt.toString(),(MyLocale.getMsg(4000,&quot;Loaded caches&quot;) + zaehlerGel));
 							infB.exec();
 							parse(r);
 							r.close();
@@ -129,27 +144,28 @@
 					}
 				}
 				else {
-					r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(file));
-					infB = new InfoBox(&quot;Info&quot;,(MyLocale.getMsg(4000,&quot;Loaded caches: &quot;) + zaehlerGel));
+					r = new java.io.InputStreamReader(new java.io.FileInputStream(file));
+					infB = new InfoBox(&quot;Info&quot;,(MyLocale.getMsg(4000,&quot;Loaded caches&quot;) + zaehlerGel));
 					infB.show();
 					parse(r);
 					r.close();
 					infB.close(0);
 				}
-				// save Index 
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+				// save Index
+				profile.saveIndex(Profile.SHOW_PROGRESS_BAR);
 				infB.close(0);
 			}
-				Vm.showWait(false);
-			}catch(Exception e){
-				e.printStackTrace();
-				Vm.showWait(false);
-			}
+			Form.cancelWait();
+		}catch(Exception e){
+			e.printStackTrace();
+			Form.cancelWait();
+		}
 		if(wasFiltered){
 			flt.setFilter();
 			flt.doFilter();
 		}
 	}
+
 	public void startElement(String name, AttributeList atts){
 		strBuf=new StringBuffer(300);
 		if (name.equals(&quot;gpx&quot;)){
@@ -159,22 +175,21 @@
 			if (atts.getValue(&quot;creator&quot;).startsWith(&quot;TerraCaching&quot;)) fromTC = true;
 			else fromTC = false;
 
-			if (fromOC &amp;&amp; doSpider) (new MessageBox(&quot;Warnung&quot;, MyLocale.getMsg(4001, &quot;GPX files from opencaching don't contain information of images, they cannot be laoded. Best you get caches from opencaching by menu /Application/Import/Download from Opencaching&quot;), FormBase.OKB)).execute();
+			if (fromOC &amp;&amp; doSpider) (new MessageBox(&quot;Warnung&quot;, MyLocale.getMsg(4001, &quot;GPX files from opencaching don't contain information of images, they cannot be laoded. Best you get caches from opencaching by menu /Application/Import/Download from Opencaching&quot;), Form.OKB)).execute();
 			zaehlerGel = 0;
 		}
 		if (name.equals(&quot;wpt&quot;)) {
 			chD = new CacheHolderDetail();
 			chD.pos.set(Common.parseDouble(atts.getValue(&quot;lat&quot;)),Common.parseDouble(atts.getValue(&quot;lon&quot;)));
-			chD.LatLon=chD.pos.toString();
+			chD.latLon=chD.pos.toString();
 			inWpt = true;
 			inLogs = false;
 			inBug = false;
-			nameFound = false;
 			zaehlerGel++;
 			infB.setInfo(MyLocale.getMsg(4000,&quot;Loaded caches: &quot;) + zaehlerGel);
 			return;
 		}
-		
+
 		if (name.equals(&quot;link&quot;)&amp;&amp; inWpt){
 			chD.URL = atts.getValue(&quot;href&quot;);
 			return;
@@ -184,7 +199,7 @@
 			inCache = true;
 			if (atts.getValue(&quot;available&quot;).equals(&quot;True&quot;))
 				chD.is_available = true;
-			else 
+			else
 				chD.is_available = false;
 			if (atts.getValue(&quot;archived&quot;).equals(&quot;True&quot;))
 				chD.is_archived = true;
@@ -205,18 +220,18 @@
 			if (status.equals(&quot;Archived&quot;)) chD.is_archived = true;
 			return;
 		}
-		
+
 		if (name.equals(&quot;terra:terracache&quot;)) {
 			inCache=true;
 		}
 
-		
+
 		if (name.equals(&quot;groundspeak:long_description&quot;)) {
 			if (atts.getValue(&quot;html&quot;).toLowerCase().equals(&quot;true&quot;))
 				chD.is_HTML= true;
-			else 
+			else
 				chD.is_HTML = false;
-			
+
 		}
 		if (name.equals(&quot;description&quot;) || name.equals(&quot;terra:description&quot;) ) {
 			//set HTML always to true if from oc.de or TC
@@ -237,11 +252,11 @@
 			}
 		}
 	}
-	
+
 	public void endElement(String name){
 		strData=strBuf.toString();
 		//Vm.debug(&quot;Ende: &quot; + name);
-		
+
 		// logs
 		if (inLogs){
 			if (name.equals(&quot;groundspeak:date&quot;)|| name.equals(&quot;time&quot;)|| name.equals(&quot;terra:date&quot;))  {
@@ -256,42 +271,42 @@
 				logFinder = new String(strData);
 				return;
 			}
-			if (name.equals(&quot;groundspeak:text&quot;) || name.equals(&quot;text&quot;) || name.equals(&quot;terra:entry&quot;)){ 
+			if (name.equals(&quot;groundspeak:text&quot;) || name.equals(&quot;text&quot;) || name.equals(&quot;terra:entry&quot;)){
 				logData = new String(strData);
 				return;
 			}
 			if (name.equals(&quot;groundspeak:log&quot;) || name.equals(&quot;log&quot;) || name.equals(&quot;terra:log&quot;) ) {
-				chD.CacheLogs.add(new Log(logIcon,logDate,logFinder,logData));
-				if(logIcon.equals(&quot;icon_smile.gif&quot;) &amp;&amp; 
+				chD.cacheLogs.add(new Log(logIcon,logDate,logFinder,logData));
+				if(logIcon.equals(&quot;icon_smile.gif&quot;) &amp;&amp;
 						  (logFinder.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; logFinder.equalsIgnoreCase(pref.myAlias2)))) {
-							chD.CacheStatus=logDate;
+							chD.cacheStatus=logDate;
 							chD.is_found=true;
 				}
 				return;
 			}
 		}
-		
+
 		if (name.equals(&quot;wpt&quot;)){
 			// Add cache Data only, if waypoint not already in database
-			//if (searchWpt(cacheDB, holder.wayPoint)== -1){
+			//if (searchWpt(cacheDB,chD.wayPoint)== -1){
 			int index=searchWpt(chD.wayPoint);
 			//Vm.debug(&quot;here ?!?!?&quot;);
 			//Vm.debug(&quot;chould be new!!!!&quot;);
 			if (index == -1){
-				chD.noFindLogs=chD.CacheLogs.countNotFoundLogs();
+				chD.noFindLogs=chD.cacheLogs.countNotFoundLogs();
 				chD.is_new = true;
 				cacheDB.add(new CacheHolder(chD));
 				// don't spider additional waypoints, so check
 				// if waypoint starts with &quot;GC&quot;
 				if(doSpider == true) {
 					if(spiderOK == true &amp;&amp; chD.is_archived == false){
-							if(chD.LatLon.length() &gt; 1){
+							if(chD.latLon.length() &gt; 1){
 							if(getMaps){
-								ParseLatLon pll = new ParseLatLon(chD.LatLon,&quot;.&quot;);
+								ParseLatLon pll = new ParseLatLon(chD.latLon,&quot;.&quot;);
 								pll.parse();
 								//MapLoader mpl = new MapLoader(pref.myproxy, pref.myproxyport);
-								//mpl.loadTo(profile.dataDir + &quot;/&quot; + holder.wayPoint + &quot;_map.gif&quot;, &quot;3&quot;);
-								//mpl.loadTo(profile.dataDir + &quot;/&quot; + holder.wayPoint + &quot;_map_2.gif&quot;, &quot;10&quot;);
+								//mpl.loadTo(profile.dataDir + &quot;/&quot; +chD.wayPoint + &quot;_map.gif&quot;, &quot;3&quot;);
+								//mpl.loadTo(profile.dataDir + &quot;/&quot; + chD.wayPoint + &quot;_map_2.gif&quot;, &quot;10&quot;);
 							}
 						}
 					if(chD.wayPoint.startsWith(&quot;GC&quot;)|| fromTC) {
@@ -301,20 +316,20 @@
 						String text;
 						String orig;
 						String imgName;
-						orig = chD.LongDescription;
+						orig = chD.longDescription;
 						Extractor ex = new Extractor(orig, &quot;&lt;img src=\&quot;&quot;, &quot;&gt;&quot;, 0, false);
 						text = ex.findNext();
 						int num = 0;
 						while(ex.endOfSearch() == false &amp;&amp; spiderOK == true){
 							//Vm.debug(&quot;Replacing: &quot; + text);
-							if (num &gt;= chD.ImagesText.getCount())break;
-							imgName = (String)chD.ImagesText.get(num);
-							chD.LongDescription = replace(chD.LongDescription, text, &quot;[[Image: &quot; + imgName + &quot;]]&quot;);
+							if (num &gt;= chD.imagesText.size())break;
+							imgName = (String)chD.imagesText.get(num);
+							chD.longDescription = replace(chD.longDescription, text, &quot;[[Image: &quot; + imgName + &quot;]]&quot;);
 							num++;
 							text = ex.findNext();
 						}
 					}
-						
+
 					}
 				}
 				chD.saveCacheDetails(saveDir);
@@ -331,16 +346,16 @@
 				} catch (Exception e) {Vm.debug(&quot;Could not open file: &quot; + e.toString());};
 				oldCh.update(chD);
 				oldCh.saveCacheDetails(saveDir);
-				cacheDB.set(index, new CacheHolder(oldCh));
+				cacheDB.setElementAt(new CacheHolder(oldCh),index);
 				//crw.saveIndex(cacheDB,saveDir);
 			}
-			
+
 			inWpt = false;
 			return;
 		}
 		if (name.equals(&quot;sym&quot;)&amp;&amp; strData.endsWith(&quot;Found&quot;)) {
 			chD.is_found = true;
-			chD.CacheStatus = MyLocale.getMsg(318,&quot;Found&quot;);
+			chD.cacheStatus = MyLocale.getMsg(318,&quot;Found&quot;);
 			return;
 		}
 		if (name.equals(&quot;groundspeak:travelbugs&quot;)) {
@@ -350,25 +365,25 @@
 
 		if (name.equals(&quot;groundspeak:name&quot;)&amp;&amp; inBug) {
 			Travelbug tb=new Travelbug(strData);
-			chD.Travelbugs.add(tb);
-			//holder.Bugs += &quot;&lt;b&gt;Name:&lt;/b&gt; &quot; + strData + &quot;&lt;br&gt;&lt;hr&gt;&quot;;
+			chD.travelbugs.add(tb);
+			//chD.Bugs += &quot;&lt;b&gt;Name:&lt;/b&gt; &quot; + strData + &quot;&lt;br&gt;&lt;hr&gt;&quot;;
 			chD.has_bug = true;
 			return;
 		}
-		
+
 		if (name.equals(&quot;time&quot;) &amp;&amp; inWpt) {
 			//String Date = new String();
 			//Date = strData.substring(5,7); // month
 			//Date += &quot;/&quot; + strData.substring(8,10); // day
 			//Date += &quot;/&quot; + strData.substring(0,4); // year
-			chD.DateHidden = strData.substring(0,10); //Date;
+			chD.dateHidden = strData.substring(0,10); //Date;
 			return;
 		}
 		// cache information
 		if (name.equals(&quot;groundspeak:cache&quot;) || name.equals(&quot;geocache&quot;)|| name.equals(&quot;terra:terracache&quot;)) {
 			inCache = false;
 		}
-		
+
 		if (name.equals(&quot;name&quot;) &amp;&amp; inWpt &amp;&amp; !inCache) {
 			chD.wayPoint = strData;
 			//msgA.setText(&quot;import &quot; + strData);
@@ -379,7 +394,7 @@
 		// fill name with contents of &lt;desc&gt;, in case of gc.com the name is
 		// later replaced by the contents of &lt;groundspeak:name&gt; which is shorter
 		if (name.equals(&quot;desc&quot;)&amp;&amp; inWpt ) {
-			chD.CacheName = strData;
+			chD.cacheName = strData;
 			//Vm.debug(&quot;CacheName: &quot; + strData);
 			//msgA.setText(&quot;import &quot; + strData);
 			return;
@@ -388,27 +403,27 @@
 			chD.URL = strData;
 			return;
 		}
-		
+
 		// Text for additional waypoints, no HTML
 		if (name.equals(&quot;cmt&quot;)&amp;&amp; inWpt){
-			chD.LongDescription = strData;
+			chD.longDescription = strData;
 			chD.is_HTML = false;
 			return;
 		}
-		
+
 		// aditional wapypoint
 		if (name.equals(&quot;type&quot;)&amp;&amp; inWpt &amp;&amp; !inCache &amp;&amp; strData.startsWith(&quot;Waypoint&quot;)){
 			chD.type= CacheType.typeText2Number(strData);
-			chD.CacheSize = &quot;None&quot;;
+			chD.setCacheSize(&quot;None&quot;);
 		}
 
-		
+
 		if ((name.equals(&quot;groundspeak:name&quot;)|| name.equals(&quot;terra:name&quot;)) &amp;&amp; inCache) {
-			chD.CacheName = strData;
+			chD.cacheName = strData;
 			return;
 		}
 		if (name.equals(&quot;groundspeak:owner&quot;) || name.equals(&quot;owner&quot;)||name.equals(&quot;terra:owner&quot;)) {
-			chD.CacheOwner = strData;
+			chD.cacheOwner = strData;
 			if(pref.myAlias.equals(strData)) chD.is_owned = true;
 			return;
 		}
@@ -425,34 +440,34 @@
 			return;
 		}
 		if (name.equals(&quot;groundspeak:container&quot;)|| name.equals(&quot;container&quot;)){
-			chD.CacheSize = strData;
+			chD.setCacheSize(strData);
 			return;
 		}
-		
+
 		if (name.equals(&quot;terra:size&quot;)){
-			chD.CacheSize = TCSizetoText(strData);
+			chD.setCacheSize(TCSizetoText(strData));
 		}
 
 		if (name.equals(&quot;groundspeak:short_description&quot;)|| name.equals(&quot;summary&quot;)) {
-			if (chD.is_HTML)	chD.LongDescription =SafeXML.cleanback(strData)+&quot;&lt;br&gt;&quot;; // &lt;br&gt; needed because we also use a &lt;br&gt; in SpiderGC. Without it the comparison in ch.update fails
-			else chD.LongDescription =strData+&quot;\n&quot;;
+			if (chD.is_HTML)	chD.longDescription =SafeXML.cleanback(strData)+&quot;&lt;br&gt;&quot;; // &lt;br&gt; needed because we also use a &lt;br&gt; in SpiderGC. Without it the comparison in ch.update fails
+			else chD.longDescription =strData+&quot;\n&quot;;
 			return;
 		}
 
 		if (name.equals(&quot;groundspeak:long_description&quot;)|| name.equals(&quot;description&quot;)|| name.equals(&quot;terra:description&quot;)) {
-			if (chD.is_HTML)	chD.LongDescription +=SafeXML.cleanback(strData);
-			else chD.LongDescription +=strData;
+			if (chD.is_HTML)	chD.longDescription +=SafeXML.cleanback(strData);
+			else chD.longDescription +=strData;
 			return;
 		}
 		if (name.equals(&quot;groundspeak:encoded_hints&quot;) || name.equals(&quot;hints&quot;)) {
-			chD.Hints = Common.rot13(strData);
+			chD.hints = Common.rot13(strData);
 			return;
 		}
-		
+
 		if (name.equals(&quot;terra:hint&quot;)) {
 			// remove &quot;&lt;br&gt;&lt;br&gt;&quot; from the end
 			int indexTrash = strData.indexOf(&quot;&lt;br&gt;&lt;br&gt;&quot;);
-			if (indexTrash &gt; 0)	chD.Hints = Common.rot13(strData.substring(0,indexTrash));
+			if (indexTrash &gt; 0)	chD.hints = Common.rot13(strData.substring(0,indexTrash));
 			return;
 		}
 
@@ -462,8 +477,8 @@
 		strBuf.append(ch,start,length);
 		if (debugGPX) Vm.debug(&quot;Char: &quot; + strBuf.toString());
 	}
-	
 
+
 	public static String typeText2Image(String typeText){
 		if (typeText.equals(&quot;Found it&quot;)||typeText.equals(&quot;Found&quot;)||typeText.equals(&quot;find&quot;)) return &quot;icon_smile.gif&quot;;
 		if (typeText.equals(&quot;Didn't find it&quot;)||typeText.equals(&quot;Not Found&quot;)||typeText.equals(&quot;no_find&quot;)) return &quot;icon_sad.gif&quot;;
@@ -475,7 +490,7 @@
 		if (typeText.equals(&quot;Attended&quot;)) return &quot;icon_attended.gif&quot;;
 		if (typeText.equals(&quot;Publish Listing&quot;)) return &quot;green.png&quot;;
 		if (typeText.equals(&quot;Will Attend&quot;)) return &quot;icon_rsvp.gif&quot;;
-		if (typeText.equals(&quot;Post Reviewer Note&quot;)) return &quot;big_smile.gif&quot;;
+		if (typeText.equals(&quot;Post Reviever Note&quot;)) return &quot;big_smile.gif&quot;;
 		if (typeText.equals(&quot;Unarchive&quot;)) return &quot;traffic_cone.gif&quot;;
 		if (typeText.equals(&quot;Archive (show)&quot;)) return &quot;traffic_cone.gif&quot;;
 		if (typeText.equals(&quot;Owner Maintenance&quot;)) return &quot;icon_maint.gif&quot;;
@@ -484,7 +499,7 @@
 		//Vm.debug(&quot;Unknown Log Type:&quot; + typeText);
 		return typeText;
 	}
-	
+
 	public static String TCSizetoText(String size){
 		if (size.equals(&quot;1&quot;)) return &quot;Micro&quot;;
 		if (size.equals(&quot;2&quot;)) return &quot;Medium&quot;;
@@ -515,22 +530,23 @@
 		return -1;
 	}
 	*/
-	
+
 	private int searchWpt(String wpt){
 		Integer INTR = (Integer)DBindex.get(wpt);
 		if(INTR != null){
 			return INTR.intValue();
-		} else return -1;
+		}
+		return -1;
 	}
 	private void spiderImagesUsingSpider(){
 		String addr;
 		String cacheText;
-		
+
 		// just to be sure to have a spider object
 		if (imgSpider == null) imgSpider = new SpiderGC(pref, profile, false);
-		
+
 		if (fromTC) {
-				imgSpider.getImages(chD.LongDescription, chD);
+				imgSpider.getImages(chD.longDescription, chD);
 		}
 		else {
 			addr = &quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot; + chD.wayPoint ;
@@ -539,7 +555,7 @@
 			imgSpider.getImages(cacheText, chD);
 		}
 	}
-	
+
 	public static String replace(String source, String pattern, String replace){
 		if (source!=null)
 		{
@@ -547,17 +563,17 @@
 			StringBuffer sb = new StringBuffer();
 			int found = -1;
 			int start = 0;
-		
+
 			while( (found = source.indexOf(pattern, start) ) != -1) {
 			    sb.append(source.substring(start, found));
 			    sb.append(replace);
 			    start = found + len;
 			}
-		
+
 			sb.append(source.substring(start));
-		
+
 			return sb.toString();
 		}
-		else return &quot;&quot;;
+		return &quot;&quot;;
 	}
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/imp/KMLImporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/imp/KMLImporter.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/imp/KMLImporter.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,12 +1,15 @@
-package CacheWolf.imp;
+package cachewolf.imp;
 
 import ewesoft.xml.*;
-import ewe.util.*;
+import java.util.*;
 import ewesoft.xml.sax.*;
-import ewe.io.*;
-import ewe.sys.*;
-import CacheWolf.CWPoint;
+import java.io.*;
 
+import cachewolf.CWPoint;
+
+import eve.sys.*;
+import eve.ui.Form;
+
 /**
  * Class to import coordinates from a KML file generated from
  * google earth.
@@ -19,8 +22,8 @@
 	
 	public Vector points = new Vector();
 	private CWPoint point = new CWPoint();
-	private String file = new String();
-	String strData = new String();
+	private String file = &quot;&quot;;
+	String strData = &quot;&quot;;
 	private int status = 0;
 	private static int MultiGeometry = 1;
 	private static int LineString = 2;
@@ -33,14 +36,14 @@
 	public void importFile() {
 		try{
 			Reader r;
-			Vm.showWait(true);
+			Form.showWait();
 			r = new FileReader(file);
 			parse(r);
 			r.close();
-			Vm.showWait(false);
+			Form.cancelWait();
 		}catch(Exception e){
 			//Vm.debug(e.toString());
-			Vm.showWait(false);
+			Form.cancelWait();
 		}
 	}
 	
@@ -72,11 +75,9 @@
 	private void parseCoordinatesLine(){
 		StringTokenizer exBlock = new StringTokenizer(strData, &quot; &quot;);
 		StringTokenizer numbers;
-		String lat = new String();
-		String lon = new String();
+		String lat, lon;
+		String test;
 		
-		String test = new String();
-		
 		while(exBlock.hasMoreTokens()){
 			test = exBlock.nextToken();
 			//Vm.debug(&quot;==&gt; &quot; + test + &quot; &lt;==&quot;);

Modified: experiments/engywuck/hist-test/src/cachewolf/imp/LOCXMLImporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/imp/LOCXMLImporter.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/imp/LOCXMLImporter.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -24,13 +24,21 @@
     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
     */
 
-package CacheWolf;
+package cachewolf.imp;
 
-import ewe.sys.Vm;
-import ewe.util.*;
-import ewe.io.*;
+import eve.sys.Vm;
+import java.util.*;
+import java.io.*;
+
+import cachewolf.CacheHolder;
+import cachewolf.CacheHolderDetail;
+import cachewolf.Profile;
+import cachewolf.utils.Common;
+
+
 import ewesoft.xml.MinML;
 import ewesoft.xml.sax.AttributeList;
+import eve.ui.Form;
 
 /**
  * @author Kalle
@@ -39,17 +47,15 @@
 public class LOCXMLImporter extends MinML {
 	boolean debugXML = false;
 	Vector cacheDB;
-	Preferences pref;
 	Profile profile;
 	String file;
-	CacheHolderDetail holder;
+	CacheHolderDetail chD;
 
 	Hashtable DBindexWpt = new Hashtable();
-	String strData = new String();
+	String strData = &quot;&quot;;
 
 	
-	public LOCXMLImporter ( Preferences pf, Profile prof, String f ){
-		pref = pf;
+	public LOCXMLImporter ( Profile prof, String f ){
 		profile=prof;
 		cacheDB = profile.cacheDB;
 		file = f;
@@ -63,17 +69,17 @@
 	public void doIt() {
 		try{
 			Reader r;
-			Vm.showWait(true);
+			Form.showWait();
 			//Test for zip.file
 						r = new FileReader(file);
 						parse(r);
 						r.close();
 			// save Index 
-			profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
-			Vm.showWait(false);
+			profile.saveIndex(Profile.NO_SHOW_PROGRESS_BAR);
+			Form.cancelWait();
 		}catch(Exception e){
 			//Vm.debug(e.toString());
-			Vm.showWait(false);
+			Form.cancelWait();
 		}
 		
 	}
@@ -86,12 +92,12 @@
 		}
 		strData =&quot;&quot;;
 		if (name.equals(&quot;name&quot;)){
-			holder = getHolder(atts.getValue(&quot;id&quot;));
+			chD = getHolder(atts.getValue(&quot;id&quot;));
 			return;
 		}
 		if (name.equals(&quot;coord&quot;)){
-			holder.pos.set(Common.parseDouble(atts.getValue(&quot;lat&quot;)),Common.parseDouble(atts.getValue(&quot;lon&quot;)));
-			holder.LatLon = holder.pos.toString();
+			chD.pos.set(Common.parseDouble(atts.getValue(&quot;lat&quot;)),Common.parseDouble(atts.getValue(&quot;lon&quot;)));
+			chD.latLon = chD.pos.toString();
 			return;
 		}
 
@@ -100,30 +106,30 @@
 	
 	public void endElement(String name){
 		if (name.equals(&quot;name&quot;)){
-			holder.CacheName = strData;
+			chD.cacheName = strData;
 		}
 
 		if (name.equals(&quot;waypoint&quot;)){
 			int index;
-			index = searchWpt(holder.wayPoint);
+			index = searchWpt(chD.wayPoint);
 			if (index == -1){
-				holder.is_new = true;
-				cacheDB.add(new CacheHolder(holder));
-				DBindexWpt.put(holder.wayPoint, new Integer(cacheDB.size()-1));
+				chD.is_new = true;
+				cacheDB.add(new CacheHolder(chD));
+				DBindexWpt.put(chD.wayPoint, new Integer(cacheDB.size()-1));
 			}
 			// update (overwrite) data
 			else {
-				holder.is_new = false;
-				cacheDB.set(index, new CacheHolder(holder));
+				chD.is_new = false;
+				cacheDB.setElementAt(new CacheHolder(chD),index);
 			}
 			// save all  (after each cache???)
-			holder.saveCacheDetails(profile.dataDir);
-			profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
+			chD.saveCacheDetails(profile.dataDir);
+			profile.saveIndex(Profile.NO_SHOW_PROGRESS_BAR);
 			return;
 		}
 
 		if (name.equals(&quot;link&quot;)){
-			holder.URL = strData;
+			chD.URL = strData;
 			return;
 		}
 
@@ -145,9 +151,9 @@
 	*/
 	private int searchWpt(String wpt){
 		Integer INTR = (Integer)DBindexWpt.get(wpt);
-		if(INTR != null){
+		if(INTR != null)
 			return INTR.intValue();
-		} else return -1;
+		return -1;
 	}
 
 	private CacheHolderDetail getHolder(String wpt){// See also OCXMLImporter

Modified: experiments/engywuck/hist-test/src/cachewolf/imp/OCXMLImporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/imp/OCXMLImporter.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/imp/OCXMLImporter.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,20 +1,39 @@
-package CacheWolf;
+package cachewolf.imp;
 
-import utils.FileBugfix;
 
-import com.stevesoft.ewe_pat.Regex;
+import cachewolf.CWPoint;
+import cachewolf.CacheHolder;
+import cachewolf.CacheHolderDetail;
+import cachewolf.CacheType;
+import cachewolf.InfoBox;
+import cachewolf.Log;
+import cachewolf.MyLocale;
+import cachewolf.Preferences;
+import cachewolf.Profile;
+import cachewolf.URL;
+import cachewolf.UrlFetcher;
+import cachewolf.utils.Common;
+import cachewolf.utils.SafeXML;
 
+import com.stevesoft.eve_pat.Regex;
+
 import ewesoft.xml.*;
 import ewesoft.xml.sax.*;
-import ewe.io.*;
-import ewe.sys.*;
-import ewe.ui.FormBase;
-import ewe.ui.MessageBox;
-import ewe.util.*;
-import ewe.util.zip.*;
-import ewe.net.*;
-import ewe.sys.Double;
+import eve.io.*;
+import eve.sys.*;
+import eve.ui.MessageBox;
+import java.util.*;
+import java.util.zip.*;
+import eve.ui.Form;
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.io.IOException;
+import eve.util.ByteArray;
+import java.io.FileOutputStream;
+import java.net.MalformedURLException;
 
+import eve.util.CharArray;
+
 /**
  *	Class to import Data from opencaching.de. 
  *	It uses the lastmodified parameter to identify new or changed caches.
@@ -41,7 +60,7 @@
 	Preferences pref;
 	Profile profile;
 	Time dateOfthisSync;
-	String strData = new String();
+	String strData = &quot;&quot;;
 	int picCnt;
 	boolean incUpdate = true; // complete or incremental Update
 	boolean ignoreDesc = false;
@@ -49,11 +68,10 @@
 	Hashtable DBindexWpt = new Hashtable();
 	Hashtable DBindexID = new Hashtable();
 
-	String picUrl = new String();
-	String picTitle =  new String();
-	String picID = new String();
-	String ocSeekUrl = new String(&quot;<A HREF="http://">http://</A>&quot;+OPENCACHING_HOST+&quot;/viewcache.php?cacheid=&quot;);
-	String cacheID = new String();
+	String picUrl = &quot;&quot;;
+	String picTitle =  &quot;&quot;;
+	String ocSeekUrl = &quot;<A HREF="http://">http://</A>&quot;+OPENCACHING_HOST+&quot;/viewcache.php?cacheid=&quot;;
+	String cacheID = &quot;&quot;;
 
 	String logData, logIcon, logDate, logFinder;
 	boolean loggerRecommended;
@@ -92,16 +110,18 @@
 	 * @return true, if some change was made to the cacheDB
 	 */
 	public boolean syncSingle(int number, InfoBox infB) {
+
 		ch = (CacheHolder)cacheDB.get(number);
 		chD= null; //new CacheHolderDetail(ch); //TODO is this still correct? use getDetails ?
 
 		if (infB.isClosed) {
-			if (askForOptions) return false; 
-			else return true;
+			if (askForOptions) 
+				return false; 
+			return true;
 		}
 		if (askForOptions) {
 			OCXMLImporterScreen importOpt = new OCXMLImporterScreen( MyLocale.getMsg(1600, &quot;Opencaching.de Download&quot;),OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.ALL);
-			if (importOpt.execute() == FormBase.IDCANCEL) {	return false; }
+			if (importOpt.execute() == OCXMLImporterScreen.IDCANCEL) {	return false; }
 			askForOptions = false;
 			reload = importOpt.missingCheckBox.getState();
 		}
@@ -122,7 +142,7 @@
 		dateOfthisSync.parse(lastS, &quot;yyyyMMddHHmmss&quot;);
 	
 
-		String url = new String();
+		String url = &quot;&quot;;
 		picCnt = 0;
 		//Build url
 		url = &quot;<A HREF="http://">http://</A>&quot; + OPENCACHING_HOST + &quot;/xml/ocxml11.php?&quot;
@@ -147,24 +167,21 @@
 		String finalMessage;
 
 		
-		String url = new String();
+		String url = &quot;&quot;;
 
 		String lastS =  profile.last_sync_opencaching;
 		CWPoint centre = pref.curCentrePt; // No need to clone curCentrePt as centre is only read
 		if (!centre.isValid()) {
-			(new MessageBox(&quot;Error&quot;, &quot;Coordinates for centre must be set&quot;, FormBase.OKB)).execute();
+			(new MessageBox(&quot;Error&quot;, &quot;Coordinates for centre must be set&quot;, MessageBox.OKB)).execute();
 			return;
 		}
 		OCXMLImporterScreen importOpt = new OCXMLImporterScreen( MyLocale.getMsg(1600, &quot;Opencaching.de Download&quot;),
 																 OCXMLImporterScreen.ALL | OCXMLImporterScreen.DIST | OCXMLImporterScreen.IMAGES);
-		if (importOpt.execute() == FormBase.IDCANCEL) {	return; }
-		Vm.showWait(true);
+		if (importOpt.execute() == OCXMLImporterScreen.IDCANCEL) {	return; }
+		Form.showWait();
 		String dist = importOpt.distanceInput.getText();
 		if (dist.length()== 0) return;
-		
-		Double distDouble = new Double();
-		distDouble.value = Common.parseDouble(dist);
-		dist = distDouble.toString(0, 1, 0).replace(',', '.');
+		dist=MyLocale.formatDouble(Common.parseDouble(dist),&quot;00.0&quot;);
 		//check, if distance is greater than before
 		if (Convert.toInt(dist) &gt; Convert.toInt(profile.distOC) ||
 				pref.downloadmissingOC  ){
@@ -202,7 +219,7 @@
 		inf.exec();
 
 		success = syncOC(url);
-		Vm.showWait(false);
+		Form.cancelWait();
 		if (success) {
 			profile.last_sync_opencaching = dateOfthisSync.format(&quot;yyyyMMddHHmmss&quot;);
 			//pref.savePreferences();
@@ -217,23 +234,23 @@
 	}
 	
 	private boolean syncOC(String url) {
-		String finalMessage = new String();
+		String finalMessage = &quot;&quot;;
 		boolean success=true;
 		File tmpFile = null;
 		BufferedReader r;
-		String file = new String();
+		String file;
 
 		//inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
 		
 		picCnt = 0;
 		try{
-			chD = null;
+			chD=null;
 			file = fetch(url, &quot;dummy&quot;);
 
 			//parse
-			tmpFile = new FileBugfix(profile.dataDir + file);
+			tmpFile = new File(profile.dataDir + file);
 			if (tmpFile.getLength() == 0 ) {
-				throw new IOException(&quot;no updates available&quot;);
+				throw new java.io.IOException(&quot;no updates available&quot;);
 			}
 
 			ZipFile zif = new ZipFile (profile.dataDir + file);
@@ -245,7 +262,7 @@
 				zipEnt = (ZipEntry) zipEnum.nextElement();
 				// skip over PRC-files and empty files
 				if (zipEnt.getSize()&gt; 0 &amp;&amp; zipEnt.getName().endsWith(&quot;xml&quot;)){
-					r = new BufferedReader (new InputStreamReader(zif.getInputStream(zipEnt), IO.JAVA_UTF8_CODEC));
+					r = new BufferedReader (new InputStreamReader(zif.getInputStream(zipEnt), &quot;UTF8&quot;));
 					parse(r);
 					r.close();
 				}
@@ -254,7 +271,7 @@
 		}catch (ZipException e){
 			finalMessage = MyLocale.getMsg(1614,&quot;Error while unzipping udpate file&quot;);
 			success = false;
-		}catch (IOException e){
+		}catch (java.io.IOException e){
 			if (e.getMessage().equalsIgnoreCase(&quot;no updates available&quot;)) { finalMessage = &quot;No updates available&quot;; success = false; }
 			else {
 				if (e.getMessage().equalsIgnoreCase(&quot;could not connect&quot;) ||
@@ -284,7 +301,7 @@
 				ch.calcRecommendationScore();
 			}
 		} */
-		profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+		profile.saveIndex(Profile.SHOW_PROGRESS_BAR);
 		inf.setInfo(finalMessage);
 
 		return success;
@@ -356,7 +373,7 @@
 			cacheID = atts.getValue(&quot;id&quot;);
 		}
 		if(name.equals(&quot;type&quot;)){
-			chD.type = CacheType.transOCType(atts.getValue(&quot;id&quot;));
+			chD.type = CacheType.transOCType(Common.parseInt(atts.getValue(&quot;id&quot;)));
 			return;
 		}
 		if(name.equals(&quot;status&quot;)){
@@ -370,7 +387,7 @@
 			return;
 		}
 		if(name.equals(&quot;size&quot;)){
-			chD.CacheSize = transSize(atts.getValue(&quot;id&quot;));
+			chD.setCacheSize(transSize(atts.getValue(&quot;id&quot;)));
 			return;
 		}
 
@@ -392,7 +409,7 @@
 		}
 
 		if (name.equals(&quot;language&quot;) &amp;&amp; !atts.getValue(&quot;id&quot;).equals(&quot;DE&quot;)){
-			if (chD.LongDescription.length()&gt; 0) ignoreDesc = true; // TODO &quot;DE&quot; in preferences adjustable
+			if (chD.longDescription.length()&gt; 0) ignoreDesc = true; // TODO &quot;DE&quot; in preferences adjustable
 			else ignoreDesc = false;
 		}
 	}
@@ -412,7 +429,7 @@
 				logIcon = GPXImporter.typeText2Image(&quot;Found&quot;); 
 				if (logFinder.equalsIgnoreCase(user) || logFinder.equalsIgnoreCase(pref.myAlias2)) { // see also endCacheLog
 					chD.is_found = true; 
-					chD.CacheStatus = MyLocale.getMsg(318,&quot;Found&quot;);
+					chD.cacheStatus = MyLocale.getMsg(318,&quot;Found&quot;);
 				}
 				break;
 			case 2:	logIcon = GPXImporter.typeText2Image(&quot;Not Found&quot;); 
@@ -444,16 +461,16 @@
 			// update (overwrite) data
 			else {
 				chD.is_new = false;
-				cacheDB.set(index, new CacheHolder(chD));
+				cacheDB.setElementAt( new CacheHolder(chD),index);
 				// save ocCacheID, in case, the previous data is from GPX
 				DBindexID.put(chD.ocCacheID, new Integer(index));
 			}
 			// clear data (picture, logs) if we do a complete Update
 			if (incUpdate == false){
-				chD.CacheLogs.clear();
-				chD.Images.clear();
-				chD.ImagesText.clear();
-				chD.ImagesInfo.clear();
+				chD.cacheLogs.clear();
+				chD.images.clear();
+				chD.imagesText.clear();
+				chD.imagesInfo.clear();
 			}
 
 			// save all
@@ -470,12 +487,12 @@
 		}
 
 		if(name.equals(&quot;name&quot;)){
-			chD.CacheName = strData;
+			chD.cacheName = strData;
 			return;
 		}
 		if(name.equals(&quot;userid&quot;)) {
-			chD.CacheOwner = strData;
-			if(chD.CacheOwner.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; chD.CacheOwner.equalsIgnoreCase(pref.myAlias2))) chD.is_owned = true;
+			chD.cacheOwner = strData;
+			if(chD.cacheOwner.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; chD.cacheOwner.equalsIgnoreCase(pref.myAlias2))) chD.is_owned = true;
 			return;
 		}
 
@@ -485,7 +502,7 @@
 		}
 		if(name.equals(&quot;latitude&quot;)) {
 			chD.pos.set(Common.parseDouble(strData),longitude);
-			chD.LatLon = chD.pos.toString();
+			chD.latLon = chD.pos.toString();
 			return;
 		}
 		if(name.equals(&quot;difficulty&quot;)) {
@@ -497,7 +514,7 @@
 			return;
 		}
 		if(name.equals(&quot;datehidden&quot;)) {
-			chD.DateHidden = strData.substring(0,10); //Date;
+			chD.dateHidden = strData.substring(0,10); //Date;
 			return;
 		}
 	}
@@ -514,7 +531,7 @@
 					imgRegexUrl.setIgnoreCase(true);
 					int descIndex=0;
 					int numDownloaded=1;
-					while (imgRegexUrl.searchFrom(chD.LongDescription, descIndex)) { // &quot;img&quot; found
+					while (imgRegexUrl.searchFrom(chD.longDescription, descIndex)) { // &quot;img&quot; found
 						imgTag=imgRegexUrl.stringMatched(1); // (1) enth&#228;lt das gesamte &lt;img ...&gt;-tag
 						fetchUrl=imgRegexUrl.stringMatched(2); // URL in Anf&#252;hrungszeichen in (2) falls ohne in (3) Ergebnis ist auf jeden Fall ohne Anf&#252;hrungszeichen 
 						if (fetchUrl==null) { fetchUrl=imgRegexUrl.stringMatched(3); }
@@ -529,7 +546,7 @@
 							// kein alternativer Text als Bild&#252;berschrift -&gt; Dateiname
 						} else { 
 							if (fetchUrl.toLowerCase().indexOf(&quot;opencaching.de&quot;) &gt; 0 || fetchUrl.toLowerCase().indexOf(&quot;geocaching.com&quot;) &gt; 0) //wenn von Opencaching oder geocaching ist Dateiname doch nicht so toll, weil nur aus Nummer bestehend 
-								imgAltText = new String(&quot;No image title&quot;);
+								imgAltText = &quot;No image title&quot;;
 							else imgAltText = fetchUrl.substring(fetchUrl.lastIndexOf(&quot;/&quot;)+1);
 						}
 						descIndex = imgRegexUrl.matchedTo();
@@ -549,17 +566,17 @@
 			}
 
 			if (name.equals(&quot;shortdesc&quot;)){
-				chD.LongDescription = strData;
+				chD.longDescription = strData;
 				return;
 			}
 
 			if (name.equals(&quot;desc&quot;)){ // &lt;/desc&gt;
-				if (chD.is_HTML)	chD.LongDescription +=SafeXML.cleanback(strData);
-				else chD.LongDescription +=strData;
+				if (chD.is_HTML)	chD.longDescription +=SafeXML.cleanback(strData);
+				else chD.longDescription +=strData;
 				return;
 			}
 			if (name.equals(&quot;hint&quot;)){
-				chD.Hints = Common.rot13(strData);
+				chD.hints = Common.rot13(strData);
 				return;
 			}
 		}
@@ -567,31 +584,31 @@
 
 	private String createPicFilename(String fetchURL) {
 		String fileName = chD.wayPoint + &quot;_&quot; + fetchURL.substring(fetchURL.lastIndexOf(&quot;/&quot;)+1);
-		return Common.ClearForFileName(fileName);
+		return Common.clearForFileName(fileName);
 	}
-	
 	private void getPic(String fetchURL, String picDesc) { // TODO handling of relativ URLs
 		try {
-			if (!fetchURL.startsWith(&quot;<A HREF="http://">http://</A>&quot;)) fetchURL = new URL(new URL(&quot;<A HREF="http://">http://</A>&quot; + OPENCACHING_HOST+&quot;/&quot;), fetchURL).toString(); // TODO this is not quite correct: actually the &quot;base&quot; URL must be known... but anyway a different baseURL should not happen very often  - it doesn't in my area
+			if (!fetchURL.startsWith(&quot;<A HREF="http://">http://</A>&quot;)) fetchURL = new URL(new URL(&quot;<A HREF="http://">http://</A>&quot; + OPENCACHING_HOST+&quot;/&quot;), fetchURL).toString();
+			// if (!fetchURL.startsWith(&quot;<A HREF="http://">http://</A>&quot;)) fetchURL = &quot;<A HREF="http://">http://</A>&quot; + OPENCACHING_HOST + &quot;/&quot; + fetchURL; // TODO use URL.relative or so.. this is not quite correct: actually the &quot;base&quot; URL must be known... but anyway a different baseURL should not happen very often  - it doesn't in my area
 			String fileName = createPicFilename(fetchURL);
 			// add title
-			chD.ImagesText.add(picDesc);
-			chD.ImagesInfo.add(null); // need to stay in sync with ImagesText
+			chD.imagesText.add(picDesc);
+			chD.imagesInfo.add(null); // need to stay in sync with ImagesText
 			try {
 				File ftest = new File(profile.dataDir + fileName);
 				if (ftest.exists()){
-					chD.Images.add(fileName);
+					chD.images.add(fileName);
 				}
 				else {
 					if (pref.downloadPicsOC) {
-						chD.Images.add(fetch(fetchURL, fileName));
+						chD.images.add(fetch(fetchURL, fileName));
 					}
 				}
 			} catch (IOException e) {
-				String ErrMessage = new String (MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;) + chD.wayPoint + &quot;: ignoring IOException: &quot;+e.getMessage()+ &quot; while downloading picture:&quot;+fileName+&quot; from URL:&quot;+fetchURL); 
+				String ErrMessage = MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;) + chD.wayPoint + &quot;: ignoring IOException: &quot;+e.getMessage()+ &quot; while downloading picture:&quot;+fileName+&quot; from URL:&quot;+fetchURL; 
 				if (e.getMessage().toLowerCase().equalsIgnoreCase(&quot;could not connect&quot;) ||
 						e.getMessage().equalsIgnoreCase(&quot;unkown host&quot;)) { // is there a better way to find out what happened?
-					ErrMessage = MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;)+chD.CacheName + &quot; (&quot;+chD.wayPoint+&quot;)&quot;+MyLocale.getMsg(1619,&quot;: could not download image from URL: &quot;)+fetchURL;
+					ErrMessage = MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;)+chD.cacheName + &quot; (&quot;+chD.wayPoint+&quot;)&quot;+MyLocale.getMsg(1619,&quot;: could not download image from URL: &quot;)+fetchURL;
 				} 
 				inf.addWarning(&quot;\n&quot;+ErrMessage);
 				//(new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), ErrMessage, MessageBox.OKB)).exec();
@@ -599,7 +616,7 @@
 				e.printStackTrace();
 			}
 		} catch (MalformedURLException e) {
-			String ErrMessage = new String (MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;) + chD.wayPoint + &quot;: ignoring MalformedUrlException: &quot; + e.getMessage()+ &quot; while downloading from URL:&quot; + fetchURL); 
+			String ErrMessage = MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;) + chD.wayPoint + &quot;: ignoring MalformedUrlException: &quot; + e.getMessage()+ &quot; while downloading from URL:&quot; + fetchURL; 
 			inf.addWarning(&quot;\n&quot;+ErrMessage);
 			pref.log(ErrMessage);
 		}
@@ -610,7 +627,7 @@
 	private void endPicture(String name){
 
 		if(name.equals(&quot;id&quot;)){
-			picID = strData;
+			//picID = strData;
 			return;
 		}
 
@@ -628,7 +645,7 @@
 			return;
 		}
 		if(name.equals(&quot;picture&quot;)){ 
-			//String fileName = holder.wayPoint + &quot;_&quot; + picUrl.substring(picUrl.lastIndexOf(&quot;/&quot;)+1);
+			//String fileName = chD.wayPoint + &quot;_&quot; + picUrl.substring(picUrl.lastIndexOf(&quot;/&quot;)+1);
 			getPic(picUrl,picTitle);
 			chD.hasUnsavedChanges = true; //saveCacheDetails(profile.dataDir);
 			return;
@@ -637,7 +654,7 @@
 
 	private void endCacheLog(String name){
 		if (name.equals(&quot;cachelog&quot;)){ // &lt;/cachelog&gt;
-			chD.CacheLogs.merge(new Log(logIcon, logDate, logFinder, logData, loggerRecommended));
+			chD.cacheLogs.merge(new Log(logIcon, logDate, logFinder, logData, loggerRecommended));
 			chD.hasUnsavedChanges = true; //chD.saveCacheDetails(profile.dataDir);
 			return;
 		}
@@ -651,7 +668,7 @@
 		if (name.equals(&quot;date&quot;))  {
 			logDate = new String(strData);
 			if (chD.is_found) {
-				chD.CacheStatus=strData.substring(0,10);
+				chD.cacheStatus=strData.substring(0,10);
 			}
 			return;
 		}
@@ -659,7 +676,7 @@
 			logFinder = new String(strData);
 			if((logFinder.toLowerCase().compareTo(user) == 0 || logFinder.equalsIgnoreCase(pref.myAlias2)) &amp;&amp; logtype == 1){
 				chD.is_found = true; // see startCacheLog - in the current .xml this is set by startCacheLog but we sequence in the xml from opencaching might change, so I leave this also here
-				chD.CacheStatus = MyLocale.getMsg(318,&quot;Found&quot;);
+				chD.cacheStatus = MyLocale.getMsg(318,&quot;Found&quot;);
 			}
 			return;
 		}
@@ -676,7 +693,7 @@
 		CharArray realurl = new CharArray();
 		ByteArray daten = UrlFetcher.fetchByteArray(addr, realurl);
 		String address = realurl.toString();
-		if (chD != null) fileName = chD.wayPoint + &quot;_&quot; + Common.ClearForFileName(address.substring(address.lastIndexOf(&quot;/&quot;)+1));
+		if (chD != null) fileName = chD.wayPoint + &quot;_&quot; + Common.clearForFileName(address.substring(address.lastIndexOf(&quot;/&quot;)+1));
 		// else fileName = Common.ClearForFileName(address.substring(address.lastIndexOf(&quot;/&quot;)+1));
 
 		//save file
@@ -718,9 +735,9 @@
 	 */
 	private int searchWpt(String wpt){
 		Integer INTR = (Integer)DBindexWpt.get(wpt);
-		if(INTR != null){
+		if(INTR != null)
 			return INTR.intValue();
-		} else return -1;
+		return -1;
 	}
 
 	/**
@@ -729,9 +746,9 @@
 	 */
 	private int searchID(String cacheID){
 		Integer INTR = (Integer)DBindexID.get(cacheID);
-		if(INTR != null){
+		if(INTR != null)
 			return INTR.intValue();
-		} else return -1;
+		return -1;
 	}
 
 

Modified: experiments/engywuck/hist-test/src/cachewolf/imp/OCXMLImporterScreen.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/imp/OCXMLImporterScreen.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/imp/OCXMLImporterScreen.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,9 +1,15 @@
 /**
  * 
  */
-package CacheWolf;
+package cachewolf.imp;
 
-import ewe.ui.*;
+import cachewolf.Global;
+import cachewolf.MyLocale;
+import cachewolf.Preferences;
+import eve.ui.*;
+import eve.fx.gui.IKeys;
+import eve.sys.Event;
+import eve.ui.event.ControlEvent;
 
 /**
  * @author pfeffer
@@ -12,12 +18,10 @@
  * 20061209 Bugfix: Checking for uninitialised missingCheckBox
  */
 public class OCXMLImporterScreen extends Form {
-	mButton cancelB, okB;
+	Button cancelB, okB;
 	Preferences pref;
-	mInput distanceInput;
-	mCheckBox imagesCheckBox, /*mapsCheckBox, */ missingCheckBox, foundCheckBox;
-	mLabel distLbl;
-	mLabel distUnit;
+	Input distanceInput;
+	CheckBox imagesCheckBox, /*mapsCheckBox, */ missingCheckBox, foundCheckBox;
 	static int DIST = 1;
 	static int IMAGES = 2;
 	static int ALL = 4;
@@ -31,8 +35,8 @@
 		
 		this.title = title;
 		if ((options &amp; DIST) &gt; 0) {
-			this.addNext(distLbl = new mLabel(MyLocale.getMsg(1601,&quot;Distance:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			distanceInput = new mInput();
+			this.addNext(new Label(MyLocale.getMsg(1601,&quot;Distance:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			distanceInput = new Input();
 			String dist1;
 			String dist2;
 			if ((options &amp; ISGC) &gt; 0) {
@@ -47,33 +51,33 @@
 			}
 			distanceInput.setText(dist1);
 			this.addNext(distanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			this.addLast(distUnit = new mLabel(&quot; km&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addLast(new Label(&quot; km&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		}
 
 		if ((options &amp; IMAGES) &gt; 0) {
-			imagesCheckBox = new mCheckBox();
+			imagesCheckBox = new CheckBox();
 			imagesCheckBox.setText(MyLocale.getMsg(1602,&quot;Download Images&quot;));
 			imagesCheckBox.setState(true); // @ToDo: aus Prefs
 			this.addLast(imagesCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
 		}
 		if((options &amp; INCLUDEFOUND) &gt; 0){
-			foundCheckBox = new mCheckBox();
+			foundCheckBox = new CheckBox();
 			foundCheckBox.setText(MyLocale.getMsg(1622,&quot;Exclude found caches&quot;));
 			foundCheckBox.setState(true);
 			this.addLast(foundCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
 		}
 
 		if((options &amp; ALL) &gt; 0){
-			missingCheckBox = new mCheckBox();
+			missingCheckBox = new CheckBox();
 			missingCheckBox.setText(MyLocale.getMsg(1606,&quot;Alle erneut downloaden&quot;));
 			missingCheckBox.setState(false); // @ToDo: aus Prefs
 			this.addLast(missingCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
 		}
 
-		cancelB = new mButton(MyLocale.getMsg(1604,&quot;Cancel&quot;));
+		cancelB = new Button(MyLocale.getMsg(1604,&quot;Cancel&quot;));
 		cancelB.setHotKey(0, IKeys.ESCAPE);
 		this.addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		okB = new mButton(MyLocale.getMsg(1605,&quot;OK&quot;));
+		okB = new Button(MyLocale.getMsg(1605,&quot;OK&quot;));
 		okB.setHotKey(0, IKeys.ACTION);
 		okB.setHotKey(0, IKeys.ENTER);
 		this.addLast(okB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
@@ -81,14 +85,14 @@
 	public void onEvent(Event ev){
 		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
 			if (ev.target == cancelB){
-				this.close(FormBase.IDCANCEL);
+				this.close(Form.IDCANCEL);
 			}
 			if (ev.target == okB){
 				    // distOC wird hier noch nicht in Pref eingetragen, damit noch gepr&#252;ft werden kann, ob es gr&#246;&#223;er oder kleiner ist als vorher
 					if (imagesCheckBox!=null) pref.downloadPicsOC = imagesCheckBox.state;
 					if (missingCheckBox!=null) pref.downloadmissingOC = missingCheckBox.state;
 					// TODO: sofort speichern?
-				this.close(FormBase.IDOK);
+				this.close(Form.IDOK);
 				}
 		}
 		super.onEvent(ev);

Modified: experiments/engywuck/hist-test/src/cachewolf/imp/SpiderGC.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/imp/SpiderGC.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/imp/SpiderGC.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -23,17 +23,43 @@
     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
     */
 
-package CacheWolf;
-import ewe.net.*;
-import ewe.io.*;
-import ewe.sys.*;
-import ewe.sys.Double;
-import ewe.util.*;
-import com.stevesoft.ewe_pat.*;
-import ewe.ui.*;
-import ewe.data.Property;
-import ewe.data.PropertyList;
+package cachewolf.imp;
+import eve.net.*;
+import java.io.*;
+import eve.sys.*;
+import java.util.*;
 
+
+import cachewolf.CWPoint;
+import cachewolf.CacheHolder;
+import cachewolf.CacheHolderDetail;
+import cachewolf.CacheType;
+import cachewolf.Global;
+import cachewolf.HttpConnection;
+import cachewolf.InfoBox;
+import cachewolf.Log;
+import cachewolf.LogList;
+import cachewolf.MyLocale;
+import cachewolf.Preferences;
+import cachewolf.Profile;
+import cachewolf.Travelbug;
+import cachewolf.utils.Common;
+import cachewolf.utils.DateFormat;
+import cachewolf.utils.Extractor;
+import cachewolf.utils.STRreplace;
+import cachewolf.utils.SafeXML;
+
+import com.stevesoft.eve_pat.*;
+import eve.ui.*;
+import eve.data.Property;
+import eve.data.PropertyList;
+import eve.util.ByteArray;
+import java.net.Socket;
+import java.net.UnknownHostException;
+
+import eve.util.CharArray;
+import eve.io.JavaUtf8Codec;
+
 /**
 *	Class to spider caches from gc.com
 */
@@ -95,7 +121,7 @@
 		int code = infB.execute();
 		passwort = infB.getInput();
 		infB.close(0);
-		if(code != FormBase.IDOK) return code;
+		if(code != Form.IDOK) return code;
 
 		// Now start the login proper
 		infB = new InfoBox(MyLocale.getMsg(5507,&quot;Status&quot;), MyLocale.getMsg(5508,&quot;Logging in...&quot;));
@@ -112,8 +138,9 @@
 			}
 		} catch(Exception ex){
 			infB.close(0);
-			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5499,&quot;Error loading login page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5499,&quot;Error loading login page&quot;), MessageBox.OKB)).execute();
 			pref.log(&quot;[login]:Could not fetch: gc.com login page&quot;,ex);
+			passwort=&quot;&quot;;
 			return ERR_LOGIN;
 		}
 		if (!infB.isClosed) { // If user has not aborted, we continue
@@ -127,7 +154,7 @@
 				//Vm.debug(&quot;ViewState: &quot; + viewstate);
 			} else
 				pref.log(&quot;[login]:Viewstate not found before login&quot;);
-			
+
 			if(start.indexOf(loginSuccess) &gt; 0)
 				pref.log(&quot;[login]:Already logged in&quot;);
 			else {
@@ -143,9 +170,9 @@
 					StringBuffer sb=new StringBuffer(1000);
 					sb.append(URL.encodeURL(&quot;__VIEWSTATE&quot;,false));	sb.append(&quot;=&quot;); sb.append(URL.encodeURL(viewstate,false));
 					sb.append(&quot;&amp;&quot;); sb.append(URL.encodeURL(&quot;myUsername&quot;,false));
-					sb.append(&quot;=&quot;); sb.append(encodeUTF8URL(Utils.encodeJavaUtf8String(pref.myAlias)));
+					sb.append(&quot;=&quot;); sb.append(encodeUTF8URL(eve.util.Utils.encodeJavaUtf8String(pref.myAlias)));
 					sb.append(&quot;&amp;&quot;); sb.append(URL.encodeURL(&quot;myPassword&quot;,false));
-					sb.append(&quot;=&quot;); sb.append(encodeUTF8URL(Utils.encodeJavaUtf8String(passwort)));
+					sb.append(&quot;=&quot;); sb.append(encodeUTF8URL(eve.util.Utils.encodeJavaUtf8String(passwort)));
 					sb.append(&quot;&amp;&quot;); sb.append(URL.encodeURL(&quot;cookie&quot;,false));
 					sb.append(&quot;=&quot;); sb.append(URL.encodeURL(&quot;on&quot;,false));
 					sb.append(&quot;&amp;&quot;); sb.append(URL.encodeURL(&quot;Button1&quot;,false));
@@ -162,13 +189,13 @@
 							pref.log(&quot;[login.Answer]:&quot;+start);
 						}
 						infB.close(0);
-						(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5501,&quot;Login failed! Wrong account or password?&quot;), FormBase.OKB)).execute();
+						(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5501,&quot;Login failed! Wrong account or password?&quot;), MessageBox.OKB)).execute();
 						return ERR_LOGIN;
 					}
 				}catch(Exception ex){
 					pref.log(&quot;[login]:Login failed with exception.&quot;, ex);
 					infB.close(0);
-					(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5501,&quot;Login failed. Error loading page after login.&quot;), FormBase.OKB)).execute();
+					(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5501,&quot;Login failed. Error loading page after login.&quot;), MessageBox.OKB)).execute();
 					return ERR_LOGIN;
 				}
 			}
@@ -195,17 +222,15 @@
 		boolean loginAborted=infB.isClosed;
 		infB.close(0);
 		if (loginAborted)
-			return FormBase.IDCANCEL;
-		else {
-			loggedIn = true;
-			return FormBase.IDOK;
-		}
+			return Form.IDCANCEL;
+		loggedIn = true;
+		return Form.IDOK;
 	}
 
 	/**
 	 * Method to spider a single cache.
 	 * It assumes a login has already been performed!
-	 * @return 1 if spider was successful, -1 if spider was cancelled by closing the infobox, 0 error, but continue with next cache
+	 * @return True if spider was successful, false if spider was cancelled by closing the infobox
 	 */
 	public int spiderSingle(int number, InfoBox infB, boolean forceLogin){
 		int ret=-1;
@@ -214,8 +239,8 @@
 		if (ch.isAddiWpt()) return -1;  // No point re-spidering an addi waypoint, comes with parent
 
 		// check if we need to login
-		if (!loggedIn || forceLogin){
-			if (this.login()!=FormBase.IDOK) return -1;
+		if (!loggedIn){
+			if (this.login()!=Form.IDOK) return -1;
 			// loggedIn is already set by this.login()
 		}
 		CacheHolderDetail chD=ch.getCacheDetails(true); //new CacheHolderDetail(ch);
@@ -230,7 +255,7 @@
 			boolean loadAllLogs = (MAXLOGS &gt; 5);
 			ret=getCacheByWaypointName(chD,true,true,false,loadAllLogs);
 			// Save the spidered data
-			if (ret == 1) {
+			if (ret==1) {
 				pref.log(&quot;Saving to:&quot; + profile.dataDir);
 				chD.saveCacheDetails(profile.dataDir);
 				((CacheHolder) cacheDB.get(number)).update(chD);
@@ -247,11 +272,11 @@
 	 * @return the cache coordinates
 	 */
 	public String getCacheCoordinates(String wayPoint) {
-		String completeWebPage;
+		String completevebPage;
 		// Check whether spider definitions could be loaded, if not issue appropriate message and terminate
 		// Try to login. If login fails, issue appropriate message and terminate
 		if (!loggedIn || Global.getPref().forceLogin) {
-			if (login()!=FormBase.IDOK) {
+			if (login()!=Form.IDOK) {
 				return &quot;&quot;;
 			}
 		}
@@ -260,7 +285,7 @@
 		try{
 			String doc = p.getProp(&quot;waypoint&quot;) + wayPoint;
 			pref.log(&quot;Fetching: &quot; + wayPoint);
-			completeWebPage = fetch(doc);
+			completevebPage = fetch(doc);
 		}catch(Exception ex){
 			infB.close(0);
 			pref.log(&quot;Could not fetch &quot; + wayPoint,ex);
@@ -268,7 +293,7 @@
 		}
 		infB.close(0);
 		try {
-			return getLatLon(completeWebPage);
+			return getLatLon(completevebPage);
 		} catch (Exception ex) {
 			return &quot;????&quot;;
 		}
@@ -283,7 +308,7 @@
 		CacheHolderDetail chD;
 		CWPoint origin = pref.curCentrePt; // No need to copy curCentrePt as it is only read and not written
 		if (!origin.isValid()) {
-			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5509,&quot;Coordinates for centre must be set&quot;), FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5509,&quot;Coordinates for centre must be set&quot;), MessageBox.OKB)).execute();
 			return;
 		}
 		if (System.getProperty(&quot;os.name&quot;)!=null)pref.log(&quot;Operating system: &quot;+System.getProperty(&quot;os.name&quot;)+&quot;/&quot;+System.getProperty(&quot;os.arch&quot;));
@@ -303,19 +328,18 @@
 		String doc = &quot;&quot;;
 
 		if (!loggedIn || Global.getPref().forceLogin) {
-			if(login() != FormBase.IDOK) return;
+			if(login() != Form.IDOK) return;
 		}
 
 		OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(5510,&quot;Spider Options&quot;),	OCXMLImporterScreen.INCLUDEFOUND | OCXMLImporterScreen.DIST| OCXMLImporterScreen.IMAGES| OCXMLImporterScreen.ISGC);
-		if (options.execute() == FormBase.IDCANCEL) {return; }
+		//options.distanceInput.setText(&quot;&quot;);
+		if (options.execute() == OCXMLImporterScreen.IDCANCEL) {return; }
 		String dist = options.distanceInput.getText();
 		if (dist.length()== 0) return;
 		distance = Common.parseDouble(dist);
-		
+
 		//save last radius to profile
-		Double distDouble = new Double();
-		distDouble.value = distance;
-		dist = distDouble.toString(0, 1, 0).replace(',', '.');
+		dist = MyLocale.formatDouble(distance, &quot;000.0&quot;).replace(',', '.');
 		profile.distGC = dist;
 
 		boolean doNotgetFound = options.foundCheckBox.getState();
@@ -325,7 +349,7 @@
 		//=======
 		// Prepare list of all caches that are to be spidered
 		//=======
-		Vm.showWait(true);
+		Form.showWait();
 		infB = new InfoBox(&quot;Status&quot;, MyLocale.getMsg(5502,&quot;Fetching first page...&quot;));
 		infB.exec();
 		//Get first page
@@ -336,10 +360,10 @@
 			start = fetch(ln);
 			pref.log(&quot;Got first page&quot;);
 		}catch(Exception ex){
-			pref.log(&quot;Error fetching first list page&quot;,ex,true);
-			Vm.showWait(false);
+				pref.log(&quot;Error fetching first list page&quot;,ex,true);
+			Form.cancelWait();
 			infB.close(0);
-			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5503,&quot;Error fetching first list page.&quot;), FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5503,&quot;Error fetching first list page.&quot;), MessageBox.OKB)).execute();
 			return;
 		}
 		dummy = &quot;&quot;;
@@ -349,7 +373,7 @@
 			lineRex = new Regex(p.getProp(&quot;lineRex&quot;)); //&quot;&lt;tr bgcolor=((?s).*?)&lt;/tr&gt;&quot;
 		} catch (Exception ex) {
 			infB.close(0);
-			Vm.showWait(false);
+			Form.cancelWait();
 			return;
 		}
 		int found_on_page = 0;
@@ -357,7 +381,7 @@
 			//Loop till maximum distance has been found or no more caches are in the list
 			while(distance &gt; 0){
 				if (infB.isClosed) break;
-		
+
 				rexViewstate.search(start);
 				if(rexViewstate.didMatch()){
 					viewstate = rexViewstate.stringMatched(1);
@@ -366,14 +390,14 @@
 					viewstate = &quot;&quot;;
 					pref.log(&quot;Viewstate not found&quot;);
 				}
-				
+
 				rexEventvalidation.search(start);
 				if(rexEventvalidation.didMatch()){
 					eventvalidation = rexEventvalidation.stringMatched(1);
 					//Vm.debug(&quot;EVENTVALIDATION: &quot; + eventvalidation);
 				} else {
 					eventvalidation = &quot;&quot;;
-					pref.log(&quot;Eventvalidation not found&quot;);					
+					pref.log(&quot;Eventvalidation not found&quot;);
 				}
 
 				//Vm.debug(&quot;In loop&quot;);
@@ -426,9 +450,9 @@
 						strNextPage = &quot;ctl00$ContentBody$pgrTop$ctl&quot; + page_number;
 					}
 					doc = URL.encodeURL(&quot;__EVENTTARGET&quot;,false) +&quot;=&quot;+ URL.encodeURL(strNextPage,false)
-					    + &quot;&amp;&quot; + URL.encodeURL(&quot;__EVENTARGUMENT&quot;,false) +&quot;=&quot;+ URL.encodeURL(&quot;&quot;,false)
-					    + &quot;&amp;&quot; + URL.encodeURL(&quot;__VIEWSTATE&quot;,false) +&quot;=&quot;+ URL.encodeURL(viewstate,false)
-					    + &quot;&amp;&quot; + URL.encodeURL(&quot;__EVENTVALIDATION&quot;,false) +&quot;=&quot;+ URL.encodeURL(eventvalidation,false);
+				    + &quot;&amp;&quot; + URL.encodeURL(&quot;__EVENTARGUMENT&quot;,false) +&quot;=&quot;+ URL.encodeURL(&quot;&quot;,false)
+				    + &quot;&amp;&quot; + URL.encodeURL(&quot;__VIEWSTATE&quot;,false) +&quot;=&quot;+ URL.encodeURL(viewstate,false)
+				    + &quot;&amp;&quot; + URL.encodeURL(&quot;__EVENTVALIDATION&quot;,false) +&quot;=&quot;+ URL.encodeURL(eventvalidation,false);
 					try{
 						start = &quot;&quot;;
 						pref.log(&quot;Fetching next list page:&quot; + doc);
@@ -444,7 +468,7 @@
 			}
 		} catch (Exception ex) { // Some tag missing from spider.def
 			infB.close(0);
-			Vm.showWait(false);
+			Form.cancelWait();
 			return;
 		}
 		pref.log(&quot;Found &quot; + cachesToLoad.size() + &quot; caches&quot;);
@@ -455,7 +479,7 @@
 		//=======
 		boolean loadAllLogs = (MAXLOGS &gt; 5);
 
-		int spiderErrors = 0;
+		int spiderErrors=0;
 		for(int i = 0; i&lt;cachesToLoad.size(); i++){
 			if (infB.isClosed) break;
 
@@ -473,17 +497,17 @@
 				} else {
 					if (!chD.is_found || !doNotgetFound ) {
 						chD.saveCacheDetails(profile.dataDir);
-						cacheDB.add(new CacheHolder(chD)); 
+						cacheDB.add(new CacheHolder(chD));
 					}
 				}
 			}
 		}
 		infB.close(0);
-		Vm.showWait(false);
+		Form.cancelWait();
 		if ( spiderErrors &gt; 0) {
 			new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;),spiderErrors + MyLocale.getMsg(5516,&quot; cache descriptions%0acould not be loaded.&quot;),FormBase.DEFOKB).execute();
 		}
-		Global.getProfile().saveIndex(Global.getPref(),true);
+		Global.getProfile().saveIndex(true);
 	}
 
 	/**
@@ -499,16 +523,16 @@
 	 * @param boolean doNotGetFound True if the cache is not to be spidered if it has already been found
 	 * @param boolean fetchAllLogs True if all logs are to be fetched (by adding option '&amp;logs=y' to command line).
 	 *     This is normally false when spidering from GPXImport as the logs are part of the GPX file, and true otherwise
-	 * @return -1 if the infoBox was closed (cancel spidering), 0 if there was an error (continue with next cache), 1 if everything ok
+	 * @return false if the infoBox was closed
 	 */
 	private int getCacheByWaypointName(CacheHolderDetail chD, boolean isUpdate, boolean fetchImages, boolean doNotGetFound, boolean fetchAllLogs) {
-		int ret = 1;
+		int ret=1;
 		while (true) {
 			String completeWebPage;
 			int spiderTrys=0;
 			int MAX_SPIDER_TRYS=3;
 			while (spiderTrys++&lt;MAX_SPIDER_TRYS) {
-				ret = 1;
+				ret=1;
 				try{
 					String doc = p.getProp(&quot;getPageByName&quot;) + chD.wayPoint +(fetchAllLogs?p.getProp(&quot;fetchAllLogs&quot;):&quot;&quot;);
 					pref.log(&quot;Fetching: &quot; + chD.wayPoint);
@@ -540,14 +564,14 @@
 						chD.is_HTML = true;
 						chD.is_available = true;
 						chD.is_archived = false;
-						chD.is_incomplete = true;
+						chD.is_incomplete = false;
 						// Save size of logs to be able to check whether any new logs were added
 						//int logsz = chD.CacheLogs.size();
 						//chD.CacheLogs.clear();
-						chD.addiWpts.clear();
-						chD.Images.clear();
-						chD.ImagesText.clear();
-						chD.ImagesInfo.clear();
+						if (chD.hasAddiWpt()) chD.addiWpts.clear();
+						chD.images.clear();
+						chD.imagesText.clear();
+						chD.imagesInfo.clear();
 
 						if(completeWebPage.indexOf(p.getProp(&quot;cacheUnavailable&quot;)) &gt;= 0) chD.is_available = false;
 						if(completeWebPage.indexOf(p.getProp(&quot;cacheArchived&quot;)) &gt;= 0) chD.is_archived = true;
@@ -555,11 +579,11 @@
 						// General Cache Data
 						//==========
 						chD.setLatLon(getLatLon(completeWebPage));
-						pref.log(&quot;LatLon: &quot; + chD.LatLon);
+						pref.log(&quot;LatLon: &quot; + chD.latLon);
 						if (pref.debug) pref.log(&quot;chD.pos: &quot; + chD.pos.toString());
-						if (chD.LatLon.equals(&quot;???&quot;)) {
+						if (chD.latLon.equals(&quot;???&quot;)) {
 							pref.log(&quot;&gt;&gt;&gt;&gt; Failed to spider Cache. Retry.&quot;);
-							ret = 0;
+							ret=0;
 							continue; // Restart the spider
 						}
 						pref.log(&quot;Trying description&quot;);
@@ -567,29 +591,29 @@
 						pref.log(&quot;Got description&quot;);
 
 						pref.log(&quot;Getting cache name&quot;);
-						chD.CacheName = SafeXML.cleanback(getName(completeWebPage));
-						if (pref.debug) pref.log(&quot;Name: &quot; + chD.CacheName); else pref.log(&quot;Got name&quot;);
+						chD.cacheName = SafeXML.cleanback(getName(completeWebPage));
+						if (pref.debug) pref.log(&quot;Name: &quot; + chD.cacheName); else pref.log(&quot;Got name&quot;);
 
 						pref.log(&quot;Trying owner&quot;);
-						chD.CacheOwner = SafeXML.cleanback(getOwner(completeWebPage)).trim();
-						if(chD.CacheOwner.equals(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; chD.CacheOwner.equals(pref.myAlias2))) chD.is_owned = true;
-						if (pref.debug) pref.log(&quot;Owner: &quot; + chD.CacheOwner +&quot;; is_owned = &quot;+chD.is_owned+&quot;;  alias1,2 = [&quot;+pref.myAlias+&quot;|&quot;+pref.myAlias2+&quot;]&quot;);
+						chD.cacheOwner = SafeXML.cleanback(getOwner(completeWebPage)).trim();
+						if(chD.cacheOwner.equals(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; chD.cacheOwner.equals(pref.myAlias2))) chD.is_owned = true;
+						if (pref.debug) pref.log(&quot;Owner: &quot; + chD.cacheOwner +&quot;; is_owned = &quot;+chD.is_owned+&quot;;  alias1,2 = [&quot;+pref.myAlias+&quot;|&quot;+pref.myAlias2+&quot;]&quot;);
 						else pref.log(&quot;Got owner&quot;);
 
 
 						pref.log(&quot;Trying date hidden&quot;);
-						chD.DateHidden = DateFormat.MDY2YMD(getDateHidden(completeWebPage));
-						if (pref.debug) pref.log(&quot;Hidden: &quot; + chD.DateHidden);
+						chD.dateHidden = DateFormat.MDY2YMD(getDateHidden(completeWebPage));
+						if (pref.debug) pref.log(&quot;Hidden: &quot; + chD.dateHidden);
 						else pref.log(&quot;Got date hidden&quot;);
 
 						pref.log(&quot;Trying hints&quot;);
 						chD.setHints(getHints(completeWebPage));
-						if (pref.debug) pref.log(&quot;Hints: &quot; + chD.Hints);
+						if (pref.debug) pref.log(&quot;Hints: &quot; + chD.hints);
 						else pref.log(&quot;Got hints&quot;);
 
 						pref.log(&quot;Trying size&quot;);
-						chD.CacheSize = getSize(completeWebPage);
-						if (pref.debug) pref.log(&quot;Size: &quot; + chD.CacheSize);
+						chD.setCacheSize(getSize(completeWebPage));
+						if (pref.debug) pref.log(&quot;Size: &quot; + chD.getCacheSize());
 						else pref.log(&quot;Got size&quot;);
 
 						pref.log(&quot;Trying difficulty&quot;);
@@ -628,7 +652,7 @@
 						//==========
 						// As there may be several bugs, we check whether the user has aborted
 						if (!infB.isClosed) getBugs(chD,completeWebPage);
-						chD.has_bug = chD.Travelbugs.size()&gt;0;
+						chD.has_bug = chD.travelbugs.size()&gt;0;
 
 						//==========
 						// Images
@@ -653,7 +677,7 @@
 						getAttributes(completeWebPage, chD);
 						pref.log(&quot;Got attributes&quot;);
 						if (chD.is_new) chD.is_update=false;
-						chD.is_incomplete = false;
+						chD.is_incomplete=false;
 						break;
 					}catch(Exception ex){
 						pref.log(&quot;Error reading cache: &quot;+chD.wayPoint);
@@ -668,7 +692,7 @@
 				pref.log(&quot;&gt;&gt;&gt; Failed to spider cache. Number of retrys exhausted.&quot;);
 				int decision = (new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;),MyLocale.getMsg(5515,&quot;Failed to load cache.%0aPleas check your internet connection.%0aRetry?&quot;),FormBase.DEFOKB|FormBase.NOB|FormBase.CANCELB)).execute();
 				if ( decision == FormBase.IDOK ) {
-					continue;						
+					continue;
 				} else if ( decision == FormBase.IDNO ){
 					ret = 0;
 				} else {
@@ -676,7 +700,7 @@
 				}
 			}
 			break;
-		}//while(true)
+			}// while (true)
 		if (infB.isClosed) {// If the infoBox was closed before getting here, we return -1
 			return -1;
 		}
@@ -690,9 +714,9 @@
 	 */
 	private int searchWpt(String wpt){
 		Integer INTR = (Integer)indexDB.get(wpt);
-		if(INTR != null){
+		if(INTR != null)
 			return INTR.intValue();
-		} else return -1;
+		return -1;
 	}
 
 	/**
@@ -805,8 +829,9 @@
 	private String getSize(String doc) throws Exception{
 		inRex = new Regex(p.getProp(&quot;sizeRex&quot;));
 		inRex.search(doc);
-		if(inRex.didMatch()) return inRex.stringMatched(1);
-		else return &quot;None&quot;;
+		if(inRex.didMatch())
+			return inRex.stringMatched(1);
+		return &quot;None&quot;;
 	}
 
 	/**
@@ -817,8 +842,9 @@
 	private String getDiff(String doc) throws Exception{
 		inRex = new Regex(p.getProp(&quot;difficultyRex&quot;));
 		inRex.search(doc);
-		if(inRex.didMatch()) return inRex.stringMatched(1);
-		else return &quot;&quot;;
+		if(inRex.didMatch())
+			return inRex.stringMatched(1);
+		return &quot;&quot;;
 	}
 
 	/**
@@ -829,8 +855,9 @@
 	private String getTerr(String doc) throws Exception{
 		inRex = new Regex(p.getProp(&quot;terrainRex&quot;));
 		inRex.search(doc);
-		if(inRex.didMatch()) return inRex.stringMatched(1);
-		else return &quot;&quot;;
+		if(inRex.didMatch())
+			return inRex.stringMatched(1);
+		return &quot;&quot;;
 	}
 
 	/**
@@ -838,11 +865,12 @@
 	 * @param doc A previously fetched cachepage
 	 * @return the waypoint type (Tradi, Multi, etc.)
 	 */
-	private String getType(String doc) throws Exception{
+	private int getType(String doc) throws Exception{
 		inRex = new Regex(p.getProp(&quot;cacheTypeRex&quot;));
 		inRex.search(doc);
-		if(inRex.didMatch()) return inRex.stringMatched(1);
-		else return &quot;&quot;;
+		if(inRex.didMatch())
+			return Common.parseInt(inRex.stringMatched(1));
+		return 0;
 	}
 
 	/**
@@ -885,7 +913,7 @@
 			if((icon.equals(p.getProp(&quot;icon_smile&quot;)) || icon.equals(p.getProp(&quot;icon_camera&quot;)) || icon.equals(p.getProp(&quot;icon_attended&quot;))) &amp;&amp;
 				(name.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; name.equalsIgnoreCase(pref.myAlias2))) )  {
 				chD.is_found = true;
-				chD.CacheStatus = d;
+				chD.cacheStatus = d;
 			}
 			if (nLogs&lt;=MAXLOGS) reslts.add(new Log(icon,d,name,exLog.findNext()));
 
@@ -921,7 +949,7 @@
 		Extractor exBug = new Extractor(bugBlock,p.getProp(&quot;bugExStart&quot;),p.getProp(&quot;bugExEnd&quot;),0,Extractor.EXCLUDESTARTEND);
 		String link,bug,linkPlusBug,bugDetails;
 		String oldInfoBox=infB.getInfo();
-		chD.Travelbugs.clear();
+		chD.travelbugs.clear();
 		while(exBug.endOfSearch() == false){
 			if (infB.isClosed) break; // Allow user to cancel by closing progress form
 			linkPlusBug= exBug.findNext();
@@ -939,7 +967,7 @@
 					tb.setMission(exDetails.findNext());
 					Extractor exGuid = new Extractor(bugDetails,&quot;details.aspx?guid=&quot;,&quot;\&quot; id=\&quot;aspnetForm&quot;,0,Extractor.EXCLUDESTARTEND); // TODO Replace with spider.def see also further down
 					tb.setGuid(exGuid.findNext());
-					chD.Travelbugs.add(tb);
+					chD.travelbugs.add(tb);
 				}catch(Exception ex){
 					pref.log(&quot;Could not fetch bug details&quot;);
 				}
@@ -993,20 +1021,20 @@
 					// imgType is now max 4 chars, starting with .
 					if(imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)){
 						// Check whether image was already spidered for this cache
-						idxUrl=spideredUrls.find(imgUrl);
+						if (imgUrl.indexOf('%')&gt;=0) imgUrl=URL.decodeURL(imgUrl);						idxUrl=spideredUrls.indexOf(imgUrl);
 						imgName = chD.wayPoint + &quot;_&quot; + Convert.toString(imgCounter);
 						if (idxUrl&lt;0) { // New image
 							pref.log(&quot;Loading image: &quot; + imgUrl+&quot; as &quot;+imgName);
 							spiderImage(imgUrl, imgName+imgType);
-							chD.Images.add(imgName+imgType);
+							chD.images.add(imgName+imgType);
 							spideredUrls.add(imgUrl);
 						} else { // Image already spidered as wayPoint_'idxUrl'
 							pref.log(&quot;Already loaded image: &quot; + imgUrl);
 							oldImgName = chD.wayPoint + &quot;_&quot; + Convert.toString(idxUrl);
-							chD.Images.add(oldImgName+imgType); // Store name of old image as image to load
+							chD.images.add(oldImgName+imgType); // Store name of old image as image to load
 						}
-						chD.ImagesText.add(imgName); // Keep the image name
-						chD.ImagesInfo.add(null); // Need to stay in synch with ImagesText
+						chD.imagesText.add(imgName); // Keep the image name
+						chD.imagesInfo.add(null); // Need to stay in synch with ImagesText
 						imgCounter++;
 					}
 				} catch (IndexOutOfBoundsException e) {
@@ -1031,33 +1059,34 @@
 		}
 		while(exImgSrc.endOfSearch() == false){
 			imgUrl = exImgSrc.findNext();
-			imgComment = exImgComment.findNext(); 
 			//Vm.debug(&quot;Img Url: &quot; +imgUrl);
 			if(imgUrl.length()&gt;0){
 				imgUrl = &quot;<A HREF="http://">http://</A>&quot; + imgUrl;
+				imgComment = exImgComment.findNext();
 				try{
 					imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).substring(0,4).trim();
 					// imgType is now max 4 chars, starting with .
 					if(imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)){
 						// Check whether image was already spidered for this cache
-						idxUrl=spideredUrls.find(imgUrl);
+						if (imgUrl.indexOf('%')&gt;=0) imgUrl=URL.decodeURL(imgUrl);
+						idxUrl=spideredUrls.indexOf(imgUrl);
 						imgName = chD.wayPoint + &quot;_&quot; + Convert.toString(imgCounter);
 						if (idxUrl&lt;0) { // New image
 							pref.log(&quot;Loading image: &quot; + imgUrl);
 							spiderImage(imgUrl, imgName+imgType);
-							chD.Images.add(imgName+imgType);
+							chD.images.add(imgName+imgType);
 						} else { // Image already spidered as wayPoint_ 'idxUrl'
 							pref.log(&quot;Already loaded image: &quot; + imgUrl);
 							oldImgName = chD.wayPoint + &quot;_&quot; + Convert.toString(idxUrl);
-							chD.Images.add(oldImgName+imgType); // Store name of old image as image to load
+							chD.images.add(oldImgName+imgType); // Store name of old image as image to load
 						}
-						chD.ImagesText.add(exImgName.findNext()); // Keep the image description
-						while (imgComment.startsWith(&quot;&lt;br /&gt;&quot;)) imgComment=imgComment.substring(6);
-						while (imgComment.endsWith(&quot;&lt;br /&gt;&quot;)) imgComment=imgComment.substring(0,imgComment.length()-6);
+						chD.imagesText.add(exImgName.findNext()); // Keep the image description
+						while (imgComment.startsWith(&quot;&lt;br /&gt;&quot;)) imgComment=imgComment.substring(4);
+						while (imgComment.endsWith(&quot;&lt;br /&gt;&quot;)) imgComment=imgComment.substring(0,imgComment.length()-4);
 						if (imgComment.length()==0)
-							chD.ImagesInfo.add(null);
+							chD.imagesInfo.add(null);
 						else
-							chD.ImagesInfo.add(imgComment);
+							chD.imagesInfo.add(imgComment);
 						imgCounter++;
 					}
 				} catch (IndexOutOfBoundsException e) {
@@ -1075,19 +1104,20 @@
 				imgUrl = &quot;<A HREF="http://">http://</A>&quot; + imgUrl;
 				try{
 					imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).substring(0,4).trim();
-					// imgType is now max 4 chars, starting with . Delete characters in URL after the image extension
+					// imgType is now max 4 chars, starting with .
 					imgUrl=imgUrl.substring(0,imgUrl.lastIndexOf(&quot;.&quot;)+imgType.length());
 					if( imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.bmp&quot;) || imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.gif&quot;)){
 						// Check whether image was already spidered for this cache
-						idxUrl=spideredUrls.find(imgUrl);
+						if (imgUrl.indexOf('%')&gt;=0) imgUrl=URL.decodeURL(imgUrl);
+						idxUrl=spideredUrls.indexOf(imgUrl);
 						if (idxUrl&lt;0) { // New image
 							imgName = chD.wayPoint + &quot;_&quot; + Convert.toString(imgCounter);
 							pref.log(&quot;Loading image: &quot; + imgUrl+&quot; as &quot;+imgName);
 							spiderImage(imgUrl, imgName+imgType);
-							chD.Images.add(imgName+imgType);
+							chD.images.add(imgName+imgType);
 							spideredUrls.add(imgUrl);
-							chD.ImagesText.add(imgName); // Keep the image name
-							chD.ImagesInfo.add(null);
+							chD.imagesText.add(imgName); // Keep the image name
+							chD.imagesInfo.add(null);
 							imgCounter++;
 						}
 					}
@@ -1098,7 +1128,6 @@
 		}
 	}
 
-	
 	/**
 	 * Read an image from the server
 	 * @param imgUrl The Url of the image
@@ -1115,8 +1144,8 @@
 		String datei = &quot;&quot;;
 		datei = profile.dataDir + target;
 		connImg = new HttpConnection(imgUrl);
-		if (imgUrl.indexOf('%')&gt;=0) connImg.documentIsEncoded=true;
 		connImg.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
+		if (imgUrl.indexOf('%')&gt;=0) connImg.documentIsEncoded=true; // Don't re encode already encoded images
 		//connImg.setRequestorProperty(&quot;User-Agent&quot;,&quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.12) Gecko/20080201 Firefox/2.0.0.12&quot;);
 		//connImg.setRequestorProperty(&quot;Accept&quot;,&quot;text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5&quot;);
 		try{
@@ -1129,7 +1158,7 @@
 					connImg=connImg.getRedirectedConnection(redirect);
 					pref.log(&quot;Redirect to &quot;+redirect);
 				}
-			} while(redirect!=null); // TODO this can end up in an endless loop if trying to load from a malicous site 
+			} while(redirect!=null); // TODO this can end up in an endless loop if trying to load from a malicous site
 			daten = connImg.readData(sockImg);
 			fos = new FileOutputStream(new File(datei));
 			fos.write(daten.toBytes());
@@ -1167,13 +1196,13 @@
 			rowBlock = exRowBlock.findNext();
 			rowBlock = exRowBlock.findNext();
 			while(exRowBlock.endOfSearch()==false){
-				CacheHolderDetail cxD = new CacheHolderDetail();
+				CacheHolderDetail cxD;
 				Extractor exPrefix=new Extractor(rowBlock,p.getProp(&quot;prefixExStart&quot;),p.getProp(&quot;prefixExEnd&quot;),0,true);
 				String prefix=exPrefix.findNext();
 				String adWayPoint;
 				if (prefix.length()==2)
 					adWayPoint=prefix+wayPoint.substring(2);
-				else	
+				else
 				    adWayPoint = MyLocale.formatLong(counter, &quot;00&quot;) + wayPoint.substring(2);
 				counter++;
 				int idx=profile.getCacheIndex(adWayPoint);
@@ -1189,7 +1218,7 @@
 				nameRex.search(rowBlock);
 				koordRex.search(rowBlock);
 				typeRex.search(rowBlock);
-				cxD.CacheName = nameRex.stringMatched(1);
+				cxD.cacheName = nameRex.stringMatched(1);
 				if(koordRex.didMatch()) cxD.setLatLon(koordRex.stringMatched(1));
 				if(typeRex.didMatch()) cxD.type = CacheType.typeText2Number(&quot;Waypoint|&quot;+typeRex.stringMatched(1));
 				rowBlock = exRowBlock.findNext();
@@ -1239,7 +1268,7 @@
 			HttpConnection conn;
 			if(pref.myproxy.length() &gt; 0 &amp;&amp; pref.proxyActive){
 				pref.log(&quot;[fetch]:Using proxy: &quot; + pref.myproxy + &quot; / &quot; +pref.myproxyport);
-			} 
+			}
 			conn = new HttpConnection(address);
 			conn.setRequestorProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
 			if(cookieSession.length()&gt;0){
@@ -1317,10 +1346,10 @@
 		}
 		return &quot;&quot;;
 	}
-	
-	
-	final static String hex = ewe.util.TextEncoder.hex;
 
+
+	final static String hex = eve.util.TextEncoder.hex;
+
 	public String encodeUTF8URL(byte[] what) {
 		int max = what.length;
 		char [] dest = new char[6*max]; // Assume each char is a UTF char and encoded into 6 chars
@@ -1335,7 +1364,7 @@
 			} else dest[d++] = c;
 		}
 		return new String(dest,0,d);
-	}	
+	}
 
 	/**
 	 * Load the bug id for a given name. This method is not ideal, as there are
@@ -1357,11 +1386,11 @@
 		}
 		try {
 			if (bugList.equals(&quot;&quot;) || bugList.indexOf(p.getProp(&quot;bugNotFound&quot;))&gt;=0) {
-				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6020,&quot;Travelbug not found.&quot;), FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6020,&quot;Travelbug not found.&quot;), MessageBox.OKB)).execute();
 				return &quot;&quot;;
 			}
 			if (bugList.indexOf(p.getProp(&quot;bugTotalRecords&quot;))&lt;0) {
-				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6021,&quot;More than one travelbug found. Specify name more precisely.&quot;), FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6021,&quot;More than one travelbug found. Specify name more precisely.&quot;), MessageBox.OKB)).execute();
 				return &quot;&quot;;
 			}
 			Extractor exGuid = new Extractor(bugList,p.getProp(&quot;bugGuidExStart&quot;),p.getProp(&quot;bugGuidExEnd&quot;),0,Extractor.EXCLUDESTARTEND); // TODO Replace with spider.def
@@ -1392,7 +1421,7 @@
 		}
 		try {
 			if (bugDetails.indexOf(p.getProp(&quot;bugNotFound&quot;))&gt;=0) {
-				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6020,&quot;Travelbug not found.&quot;), FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6020,&quot;Travelbug not found.&quot;), MessageBox.OKB)).execute();
 				return &quot;&quot;;
 			}
 			Extractor exDetails = new Extractor(bugDetails,p.getProp(&quot;bugDetailsStart&quot;),p.getProp(&quot;bugDetailsEnd&quot;),0,Extractor.EXCLUDESTARTEND);
@@ -1427,7 +1456,7 @@
 			return &quot;&quot;;
 		}
 	}
-	
+
 	/**
 	 * Fetch a bug's mission and namefor a given tracking number
 	 * @param TB the travelbug
@@ -1459,19 +1488,20 @@
 	}
 
 	private class myProperties extends Properties {
+		static final long serialVersionUID=0; // for compiler only
 		myProperties() {
 			super();
 			try {
-				load(new FileInputStream(FileBase.getProgramDirectory()+&quot;/spider.def&quot;));
+				load(new FileInputStream(eve.io.File.getProgramDirectory()+&quot;/spider.def&quot;));
 			} catch (Exception ex) {
 				pref.log(&quot;Failed to load spider.def&quot;,ex);
-				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5504,&quot;Could not load 'spider.def'&quot;), FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5504,&quot;Could not load 'spider.def'&quot;), MessageBox.OKB)).execute();
 			}
 		}
 		public String getProp(String key) throws Exception {
 			String s=super.getProperty(key);
 			if (s==null) {
-				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5497,&quot;Error missing tag in spider.def&quot;) + &quot;: &quot;+key, FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5497,&quot;Error missing tag in spider.def&quot;) + &quot;: &quot;+key, MessageBox.OKB)).execute();
 				throw new Exception(&quot;Missing tag in spider.def: &quot;+key);
 			}
 			return s;

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/Area.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/Area.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/Area.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,6 +1,6 @@
-package CacheWolf.navi;
+package cachewolf.navi;
 
-import CacheWolf.CWPoint;
+import cachewolf.CWPoint;
 
 public class Area {
 	 public final static int NOT_ON_EDGE = -1;
@@ -8,7 +8,7 @@
 	 public final static int AT_RIGHT_EDGE = 2;
 	 public final static int AT_BUTTOM_EDGE = 3;
 	 public final static int AT_LEFT_EDGE = 4;
-	 public static double edgeTolerance = 3 * 360/40000000; // approx 3m will be seen as the same
+	 public static final double edgeTolerance = 3 * 360/40000000; // approx 3m will be seen as the same
 
 	 CWPoint topleft;
 	 CWPoint buttomright;
@@ -26,14 +26,14 @@
 	 public boolean isInBound(TrackPoint p) {
 		 if (topleft.latDec &gt;= p.latDec &amp;&amp; topleft.lonDec &lt;= p.lonDec 
 				 &amp;&amp; buttomright.latDec &lt;= p.latDec &amp;&amp; buttomright.lonDec &gt;= p.lonDec) return true;
-		 else return false;
+		 return false;
 	 }
 	 //if(affine[4] &gt;= lati &amp;&amp; lati &gt;= lowlat &amp;&amp; affine[5] &lt;= loni &amp;&amp; loni &lt;= lowlon) isInBound = true;
 		
 	 public boolean isInBound(double lat, double lon) {
 		 if (topleft.latDec &gt;= lat &amp;&amp; topleft.lonDec &lt;= lon
 				 &amp;&amp; buttomright.latDec &lt;= lat &amp;&amp; buttomright.lonDec &gt;= lon) return true;
-		 else return false;
+		 return false;
 	 }
 
 	/**
@@ -55,7 +55,7 @@
 				 || a.isInBound(this.buttomright.latDec, this.topleft.lonDec) // buttom left
 				 || a.isInBound(this.topleft.latDec, this.buttomright.lonDec)) // top right
 			 return true;
-		 else return false;
+		 return false;
 	 }
 
 	 public boolean equals(Area a) {
@@ -64,7 +64,7 @@
 				 &amp;&amp; java.lang.Math.abs(buttomright.latDec - a.buttomright.latDec) &lt; edgeTolerance
 				 &amp;&amp; java.lang.Math.abs(buttomright.lonDec - a.buttomright.lonDec) &lt; edgeTolerance )
 			 return true;
-		 else return false;
+		 return false;
 	 }
 	 
 	 public int getEdge(CWPoint tl, CWPoint br) {
@@ -98,7 +98,7 @@
 		 for (i=0; i&lt;br.length(); i++ ) {
 			 if (ul.charAt(i) != br.charAt(i)) break;
 		 }
-		 //ewe.sys.Vm.debug(ul+&quot;\n&quot;+br+&quot;\n i:&quot;+i);
+		 //eve.sys.Vm.debug(ul+&quot;\n&quot;+br+&quot;\n i:&quot;+i);
 		 return ul.substring(0, i);
 	 }
 	 
@@ -110,8 +110,13 @@
 	 public static String getEasyFindString(CWPoint p, int prec) {
 		 double longinrange = p.lonDec;
 		 if (longinrange &gt; 180) longinrange -= 180;
-		 int lat = (int) (((p.latDec+90d)/180d) * (double)(1 &lt;&lt; (prec)));
-		 int lon = (int) (((longinrange+180)/360) * (double) (1 &lt;&lt; (prec)));
+		 Double kw = new Double(((p.latDec+90d)/180d) *  (1 &lt;&lt; prec));
+		 int lat = (int)((p.latDec+90d)/180d *  (1 &lt;&lt; prec)); // TODO handle negative values
+		 lat = kw.intValue();
+		 //kw = (double) (1 &lt;&lt; (prec));
+		 
+		 //kw = new Double(((longinrange+180)/360) * (2 ^ (prec -1)));
+		 int lon = (int)(((longinrange+180)/360) *  (1 &lt;&lt; (prec))); // 180 = 10110100
 		 String ret = &quot;&quot;;
 		 int tmp;
 		 for (int i=prec-1; i&gt;=0;  i--) {
@@ -126,7 +131,7 @@
 	 
 	 static public boolean containsRoughly(String boundingbox, String q) {
 		 if (boundingbox.length() &lt;= q.length() ) return q.startsWith(boundingbox);
-		 else return boundingbox.startsWith(q);
+		 return boundingbox.startsWith(q);
 	 }
 	 
 	 public String toString() {

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/AreaList.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/AreaList.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/AreaList.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,4 +1,4 @@
-package CacheWolf.navi;
+package cachewolf.navi;
 
 
 /**
@@ -9,7 +9,7 @@
  * @author pfeffer
  *
  */
- public class AreaList extends ewe.util.LinkedListElement { // in java since v1.2 I would use java.util.TreeSet
+ public class AreaList extends eve.util.LinkedListElement { // in java since v1.2 I would use java.util.TreeSet
 /*
 	 public AreaList(int s) {super(s);}
 

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/CWGPSPoint.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/CWGPSPoint.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/CWGPSPoint.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -4,16 +4,18 @@
  * TODO To change the template for this generated file go to
  * Window - Preferences - Java - Code Style - Code Templates
  */
-package CacheWolf.navi;
-import CacheWolf.CWPoint;
-import CacheWolf.Common;
-import CacheWolf.Extractor;
-import CacheWolf.Global;
-import ewe.sys.*;
-import ewe.io.*;
+package cachewolf.navi;
+import eve.sys.*;
+import java.io.*;
 
+import cachewolf.CWPoint;
+import cachewolf.Global;
+import cachewolf.utils.Common;
+import cachewolf.utils.Extractor;
 
 
+
+
 /**
  * @author Kalle
  * Class for decoding NMEA sentences
@@ -24,18 +26,18 @@
 	public static final int LOGRAW  = 0x02;
 	public static final int LOGALL  = LOGNMEA|LOGRAW;
 
-	public double Speed; //Speed
-	public double Bear;	//Bearing
-	public String Time; //Time
-	public String Date;
-	public int Fix; //Fix
+	public double speed; //Speed
+	public double bear;	//Bearing
+	public String time; //Time
+	public String date;
+	public int fix; //Fix
 	public int numSat; //Satellites in use, -1 indicates no data, -2 that data could not be interpreted
 	public int numSatsInView; //Satellites in view
 	public double HDOP; // Horizontal dilution of precision
-	public double Alt; //Altitude
+	public double alt; //Altitude
 
 	//Logging
-	int logTimer = 0;
+	Timer logTimer = null;
 	int logFlag = 0;
 	boolean writeLog = false;
 	boolean doLogging = false;
@@ -46,41 +48,41 @@
 	public CWGPSPoint()
 	{
 		super();
-		this.Speed = 0;
-		this.Bear = 0;
-		this.Time = &quot;&quot;;
-		this.Date=&quot;&quot;;
-		this.Fix = 0;
+		this.speed = 0;
+		this.bear = 0;
+		this.time = &quot;&quot;;
+		this.date=&quot;&quot;;
+		this.fix = 0;
 		this.numSat = 0;
 		this.numSatsInView = 0;
-		this.Alt = 0;
+		this.alt = 0;
 		this.HDOP = 0;
 	}
 
 
 	public double getSpeed(){
-		return this.Speed;
+		return this.speed;
 	}
 
 	public double getBear (){
-		return this.Bear;
+		return this.bear;
 	}
 	public String getTime(){
-		return this.Time;
+		return this.time;
 	}
 
 	/**
 	 * @return &gt; 0: fixed &lt;br&gt; 0: not fixed &lt;br&gt; -1: no data from serial port &lt;br&gt; -2 data from serial port could not be interpreted
 	 */
 	public int getFix(){
-		return this.Fix;
+		return this.fix;
 	}
 
 	/**
 	 * this method should be called, if COM-Port is closed
 	 */
 	public void noData(){
-		this.Fix = 0;
+		this.fix = 0;
 		this.numSat = 0;
 		this.HDOP = 0;
 	}
@@ -89,7 +91,7 @@
 	 * this method should be called, if not data is coming from COM-Port but is expected to come
 	 */
 	public void noDataError(){
-		this.Fix = -1;
+		this.fix = -1;
 		this.numSat = -1;
 		this.HDOP = -1;
 	}
@@ -98,20 +100,19 @@
 	 * this method should be called, if examine returns for several calls that it couldn't interprete the data
 	 */
 	public void noInterpretableData(){
-		this.Fix = -2;
+		this.fix = -2;
 		this.numSat = -2;
 		this.HDOP = -2;
 	}
 
-	public void ticked(int timerId, int elapsed){
+	public void ticked(Object timerId, long elapsed) {
 		if (timerId == logTimer) {
 			writeLog = true;
 		}
-
 	}
 
 	/**
-	 * 
+	 *
 	 * @param logFileDir directory for logfile
 	 * @param seconds	 intervall for writing to logfile
 	 * @param flag		 level of logging
@@ -129,9 +130,9 @@
 		} catch (IOException e) {
 			Vm.debug(&quot;Error creating LogFile &quot; + logFileName);
 			return -1;
-		} 
+		}
 		// start timer
-		logTimer = Vm.requestTimer(this, 1000 * seconds);
+		logTimer = (Timer) eve.sys.Timer.requestTick(this, 1000 * seconds);
 		logFlag = flag;
 		doLogging = true;
 		return 0;
@@ -144,9 +145,8 @@
 			try {
 				logFile.close();
 			} catch (IOException e) {}
-			if (logTimer &gt; 0) {
-				Vm.cancelTimer(logTimer);
-				logTimer = 0;
+			if (logTimer !=null) {
+				logTimer = null;
 			}
 		}
 		doLogging = false;
@@ -162,7 +162,7 @@
 	}
 
 	public double getAlt(){
-		return this.Alt;
+		return this.alt;
 	}
 
 	public double getHDOP(){
@@ -170,32 +170,32 @@
 	}
 
 	/**
-	 * 
+	 *
 	 * @param NMEA	string with data to examine
 	 * @return true if some data could be interpreted false otherwise
 	 */
-	public boolean examine(String NMEA){ 
+	public boolean examine(String NMEA){
 		boolean interpreted = false;
 		boolean logWritten = false;
 		try {
 			int i, start, end;
-			String latDeg=&quot;0&quot;, latMin=&quot;0&quot;, latNS=&quot;N&quot;; 
+			String latDeg=&quot;0&quot;, latMin=&quot;0&quot;, latNS=&quot;N&quot;;
 			String lonDeg=&quot;0&quot;, lonMin=&quot;0&quot;, lonEW=&quot;E&quot;;
 			String currToken;
 			end = 0;
 			lastStrExamined = NMEA;
 			//Vm.debug(NMEA);
-/*			if (writeLog &amp;&amp; (logFlag &amp; LOGRAW) &gt; 0){ 
+/*			if (writeLog &amp;&amp; (logFlag &amp; LOGRAW) &gt; 0){
 				try {
 					logFile.write(NMEA);
 					writeLog = false;
 				} catch (IOException e) {}
 			}
 */			while(true){
-				start = NMEA.indexOf(&quot;$GP&quot;, end);  
+				start = NMEA.indexOf(&quot;$GP&quot;, end);
 				if (start == -1) break;
-				end = NMEA.indexOf(&quot;*&quot;, start);  
-				if ((end == -1)||(end+3 &gt; NMEA.length())) break;  
+				end = NMEA.indexOf(&quot;*&quot;, start);
+				if ((end == -1)||(end+3 &gt; NMEA.length())) break;
 
 
 				//Vm.debug(NMEA.substring(start,end+3));
@@ -203,8 +203,8 @@
 					//Vm.debug(&quot;checksum wrong&quot;);
 					continue;
 				}
-				// Write log after finding valid NMEA sequence 
-				if (writeLog &amp;&amp; (logFlag &amp; LOGRAW) &gt; 0){ 
+				// Write log after finding valid NMEA sequence
+				if (writeLog &amp;&amp; (logFlag &amp; LOGRAW) &gt; 0){
 					try {
 						logFile.write(NMEA.substring(start,end+3)+&quot;\n&quot;);
 						logWritten = true;
@@ -225,7 +225,7 @@
 							continue; // sometimes there are 2 colons directly one after the other like &quot;,,&quot; (e.g. loox)
 						}
 						switch (i){
-						case 1: this.Time = currToken; break;
+						case 1: this.time = currToken; break;
 						case 2: try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
 						try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
 						break;
@@ -237,21 +237,21 @@
 						break;
 						case 5: lonEW = currToken;
 						break;
-						case 6: 
+						case 6:
 							if (!latlonerror) {
-								this.Fix = Convert.toInt(currToken); 
-								interpreted = true; 
+								this.fix = Convert.toInt(currToken);
+								interpreted = true;
 								break;
 							} else {
-								this.Fix = 0; 
+								this.fix = 0;
 								break;
 							}
 						case 7: this.numSat = Convert.toInt(currToken); interpreted = true; break;
 						case 8: try {this.HDOP = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} break;
-						case 9: try {this.Alt = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} break;
+						case 9: try {this.alt = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} break;
 						} // switch
 					} // while
-					if (Fix &gt; 0) this.set(latNS, latDeg, latMin, &quot;0&quot;, lonEW, lonDeg, lonMin, &quot;0&quot;, CWPoint.DMM);
+					if (fix &gt; 0) this.set(latNS, latDeg, latMin, &quot;0&quot;, lonEW, lonDeg, lonMin, &quot;0&quot;, CWPoint.DMM);
 
 				} // if
 
@@ -262,10 +262,10 @@
 						i++;
 						if (currToken.length()==0) continue;
 						switch (i){
-						case 1: try { this.Bear =Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {}
-						if (this.Bear &gt; 360) Vm.debug(&quot;Error bear VTG&quot;);
+						case 1: try { this.bear =Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {}
+						if (this.bear &gt; 360) Vm.debug(&quot;Error bear VTG&quot;);
 						break;
-						case 7: try { this.Speed = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} 
+						case 7: try { this.speed = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {}
 						break;
 						} // switch
 					} // while
@@ -287,10 +287,10 @@
 						//Vm.debug(&quot;zz: &quot; + i);
 						//Vm.debug(currToken);
 						switch (i){
-						case 1: this.Time = currToken; interpreted = true; break;
-						case 2: status = currToken; 
-						if (status.equals(&quot;A&quot;)) this.Fix = 1;
-						else this.Fix = 0;
+						case 1: this.time = currToken; interpreted = true; break;
+						case 2: status = currToken;
+						if (status.equals(&quot;A&quot;)) this.fix = 1;
+						else this.fix = 0;
 						interpreted = true;
 						break;
 						case 3: 	//Vm.debug(&quot;Here---&gt;&quot;);
@@ -308,27 +308,27 @@
 						interpreted = true;
 						break;
 						case 7: if (status.equals(&quot;A&quot;)){
-							try {this.Speed = Common.parseDouble(currToken)*1.854;
+							try {this.speed = Common.parseDouble(currToken)*1.854;
 							interpreted = true; } catch (NumberFormatException e) { }
 						}
 						break;
 						case 8: if (status.equals(&quot;A&quot;) &amp;&amp; currToken.length()&gt; 0){
-							try {this.Bear = Common.parseDouble(currToken);
+							try {this.bear = Common.parseDouble(currToken);
 							interpreted = true; } catch (NumberFormatException e) { }
 						}
 						break;
 						case 9: if (status.equals(&quot;A&quot;) &amp;&amp; currToken.length()&gt; 0){
-							try {this.Date = currToken;
+							try {this.date = currToken;
 							interpreted = true; } catch (NumberFormatException e) { }
 						}
 						break;
 						} // switch
 					} // while
-					if (latlonerror) this.Fix = 0;
+					if (latlonerror) this.fix = 0;
 					else {
 						if (status.equals(&quot;A&quot;)){
 							this.set(latNS, latDeg, latMin, &quot;0&quot;,
-									lonEW, lonDeg, lonMin, &quot;0&quot;, CWPoint.DMM);				
+									lonEW, lonDeg, lonMin, &quot;0&quot;, CWPoint.DMM);
 						}
 					}
 				} // if
@@ -345,7 +345,7 @@
 						} // switch
 					} // while
 				} // if
-				
+
 				//Vm.debug(&quot;End of examine&quot;);
 			} //while
 		} catch (Exception e) {
@@ -381,14 +381,14 @@
 	public void printAll(){
 		Vm.debug(&quot;Latitude:     &quot; + this.getLatDeg(DD));
 		Vm.debug(&quot;Longitude:    &quot; + this.getLonDeg(DD));
-		Vm.debug(&quot;Speed:        &quot; + this.Speed);
-		Vm.debug(&quot;Bearing:      &quot; + this.Bear);
-		Vm.debug(&quot;Time:         &quot; + this.Time);
-		Vm.debug(&quot;Fix:          &quot; + this.Fix);
+		Vm.debug(&quot;Speed:        &quot; + this.speed);
+		Vm.debug(&quot;Bearing:      &quot; + this.bear);
+		Vm.debug(&quot;Time:         &quot; + this.time);
+		Vm.debug(&quot;Fix:          &quot; + this.fix);
 		Vm.debug(&quot;Sats:         &quot; + this.numSat);
 		Vm.debug(&quot;Sats in view: &quot; + this.numSatsInView);
 		Vm.debug(&quot;HDOP:         &quot; + this.HDOP);
-		Vm.debug(&quot;Alt:          &quot; + this.Alt);
+		Vm.debug(&quot;Alt:          &quot; + this.alt);
 		Vm.debug(&quot;----------------&quot;);
 	}
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/Ellipsoid.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/Ellipsoid.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/Ellipsoid.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,53 +1,51 @@
-package CacheWolf.navi;
+package cachewolf.navi;
 
 public class Ellipsoid {
-	public double a, b;
-	/**
-	 * 
-	 * @param ai
-	 * @param bi
-	 * @param isminoraxis if true bi is interpreted as axis, if false bi is interpreted as flattening
-	 */
-	public Ellipsoid(double ai, double bi, boolean isminoraxis ) {
-		a = ai;
-		if (isminoraxis) b = bi; // flattening = (a - b) / a
-		else {
-			b = a - (1/bi) * a;
-		}
-	}
-	
-	   /**
-	    * Get semi-major axis.
-	    * @return semi-major axis (in meters).
-	    */
-	   public double getSemiMajorAxis()
-	   {
-	     return a;
-	   }
+        public double a, b;
+        /**
+         * 
+         * @param ai
+         * @param bi
+         * @param isminoraxis if true bi is interpreted as axis, if false bi is interpreted as flattening
+         */
+        public Ellipsoid(double ai, double bi, boolean isminoraxis ) {
+                a = ai;
+                if (isminoraxis) b = bi; // flattening = (a - b) / a
+                else {
+                        b = a - (1/bi) * a;
+                }
+        }
+        
+           /**
+            * Get semi-major axis.
+            * @return semi-major axis (in meters).
+            */
+           public double getSemiMajorAxis() {
+             return a;
+           }
 
-	   /**
-	    * Get semi-minor axis.
-	    * @return semi-minor axis (in meters).
-	    */
-	   public double getSemiMinorAxis()
-	   {
-	     return b;
-	   }
+           /**
+            * Get semi-minor axis.
+            * @return semi-minor axis (in meters).
+            */
+           public double getSemiMinorAxis() {
+             return b;
+           }
 
-	   /**
-	    * Get flattening
-	    * @return
-	    */
-	   public double getFlattening()
-	   {
-	     return (a - b) / a;
-	   }
+           /**
+            * Get flattening
+            * @return
+            */
+           public double getFlattening() {
+             return (a - b) / a;
+           }
 
-	   /**
-	    * Get inverse flattening.
-	    * @return
-	    */
-	   public double getInverseFlattening()
-	   {
-	     return a / (a - b);
-	   }}
+           /**
+            * Get inverse flattening.
+            * @return
+            */
+           public double getInverseFlattening() {
+             return a / (a - b);
+           }
+      }
+

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/GeodeticCalculator.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/GeodeticCalculator.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/GeodeticCalculator.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -5,9 +5,9 @@
  * This code may be freely used and modified on any personal or professional
  * project.  It comes with no warranty.
  */
-//package org.gavaghan.geodesy;
-package CacheWolf.navi;
 
+package cachewolf.navi;
+
 /**
  * &lt;p&gt;
  * Implementation of Thaddeus Vincenty's algorithms to solve the direct and inverse
@@ -271,11 +271,11 @@
          // modification by MiK77: check if lambda is zero to avoid division by zero. Use lambda0 for division in this case.
          double change = 1.0;
          if (lambda != 0) {
-        	 change = Math.abs((lambda - lambda0) / lambda);
+                 change = Math.abs((lambda - lambda0) / lambda);
          } else if (lambda0 != 0){
-        	 change = Math.abs((lambda - lambda0) / lambda0); 
+                 change = Math.abs((lambda - lambda0) / lambda0); 
          } else {
-        	 change = 0.0;
+                 change = 0.0;
          }
 
          if ((i &gt; 1) &amp;&amp; (change &lt; 0.0000000000001))
@@ -340,14 +340,14 @@
    
    static public double calculateDistance(Ellipsoid ellipsoid, TrackPoint start, TrackPoint end)
    {
-	   return calculateDistanceAndBearing(ellipsoid, start, end, null);
+           return calculateDistanceAndBearing(ellipsoid, start, end, null);
    }
    
    static public double calculateBearing(Ellipsoid ellipsoid, TrackPoint start, TrackPoint end)
    {
-	   double bearing[]={0.0};
-	   calculateDistanceAndBearing(ellipsoid, start, end, bearing);
-	   return bearing[0];
+           double bearing[]={0.0};
+           calculateDistanceAndBearing(ellipsoid, start, end, bearing);
+           return bearing[0];
    }
 
 }
\ No newline at end of file

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/GkPoint.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/GkPoint.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/GkPoint.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,4 +1,5 @@
-package CacheWolf.navi;
+package cachewolf.navi;
+import cachewolf.utils.Common;
 
 /**
  * Point in Gau&#223;-Kr&#252;ger Format
@@ -11,7 +12,6 @@
 	int stripe;
 	int stripewidth;
 	float lengthOfStripe0; // e.g. in italien GK stripe 1 is at 9 degree
-
 	public GkPoint() { super(); }
 	
 	public GkPoint(GkPoint p) {
@@ -26,6 +26,7 @@
 	public GkPoint(double e, double n, int stripewidthi, float degreeOfStripeZero) {
 		stripe = (int) Math.floor(e / 1000000);
 		set(e - 1000000 * stripe - 500000, n, stripe, stripewidthi, degreeOfStripeZero);
+		set(e - 1000000 * stripe - 500000, n, (int) Math.floor(e / 1000000), stripewidthi);
 	}
 	
 	/**
@@ -37,9 +38,9 @@
 	 */
 	public GkPoint(double e, double n, int region) {
 		switch (region) {
-		case GERMAN_GK:	set(e, n, 3, 0); break;
-		case ITALIAN_GB:	set(e, n, 6, 3); break;
-		default: throw new IllegalArgumentException(&quot;GkPoint (double, double, int): region: &quot; + region + &quot; not supported&quot;);
+			case GERMAN_GK:	set(e, n, 3, 0); break;
+			case ITALIAN_GB:	set(e, n, 6, 3); break;
+			default: throw new IllegalArgumentException(&quot;GkPoint (double, double, int): region: &quot; + region + &quot; not supported&quot;);
 		}
 	}
 	
@@ -70,17 +71,15 @@
 	}
 	
 	public double getStripeLon() {
-		return stripe * stripewidth + lengthOfStripe0; // TODO + stripeoffset
+		return stripe * stripewidth+ lengthOfStripe0; // TODO + stripeoffset
 	}
 	
 	public int getStripe() {
 		return stripe;
 	}
-
 	public TrackPoint toTrackPoint(int region) {
 		return new TrackPoint(northing, getGkEasting(region));
-		}
-	
+	}
 	/**
 	 * This will give you the normal Gau&#223;-Kr&#252;ger easting value
 	 * (that means including the stripe number)
@@ -90,7 +89,6 @@
 	public static final int ITALIAN_GB = 3900; 
 	public static final int DEFAULT_GK = GERMAN_GK;
 	
-
 	/**
 	 * 
 	 * @param region international telephone area code * 100  
@@ -109,7 +107,7 @@
 		}
 		return e;
 	}
-
+	
 	/**
 	 * easting measured in meters from stripe middle
 	 * @return
@@ -135,13 +133,7 @@
 
 	
 	public String toString(int decimalplaces, String prefix, String seperator, int region) {
-		ewe.sys.Double n = new ewe.sys.Double();
-		ewe.sys.Double e = new ewe.sys.Double();
-		n.set(northing);
-		e.set(getGkEasting(region));
-		n.decimalPlaces = decimalplaces;
-		e.decimalPlaces = decimalplaces;
-		return prefix + e.toString().replace(',', '.') + seperator + n.toString().replace(',', '.');
+		return prefix + Common.doubleToString(getGkEasting(region),decimalplaces).replace(',', '.') + seperator + Common.doubleToString(northing,decimalplaces).replace(',', '.');
 	}
 	
 	/**

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/GotoPanel.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/GotoPanel.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/GotoPanel.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,24 +1,21 @@
-package CacheWolf.navi;
+package cachewolf.navi;
 
-import CacheWolf.CWPoint;
-import CacheWolf.CacheHolder;
-import CacheWolf.CoordsScreen;
-import CacheWolf.DetailsPanel;
-import CacheWolf.Global;
-import CacheWolf.MainTab;
-import CacheWolf.MyLocale;
-import CacheWolf.Preferences;
-import CacheWolf.Profile;
-import ewe.ui.*;
-import ewe.util.Vector;
-import ewe.fx.*;
-import ewe.graphics.AniImage;
-//import ewe.io.IOException;
-//import ewe.io.SerialPort;
-//import ewe.io.SerialPortOptions;
-import ewe.sys.*;
-import ewe.sys.Double;
+import eve.ui.*;
+import eve.fx.*;
+import eve.sys.*;
+import java.lang.Double;
 
+import cachewolf.CWPoint;
+import cachewolf.CacheHolder;
+import cachewolf.CoordsScreen;
+import cachewolf.Global;
+import cachewolf.MainTab;
+import cachewolf.MyLocale;
+import cachewolf.Preferences;
+
+import eve.ui.event.MenuEvent;
+import eve.ui.event.ControlEvent;
+
 /**
  *	Class to create the panel which handles the connection to the GPS-device&lt;br&gt;
  *	Displays: current position,speed and bearing; relation to destination waypoint&lt;br&gt;
@@ -31,25 +28,25 @@
 	//public CWGPSPoint gpsPosition = new CWGPSPoint();
 	//public CWPoint toPoint = new CWPoint();
 	public Navigate myNavigation;
-	mButton btnGPS, btnCenter,btnSave;
-	mButton btnGoto, btnMap;
+	Button btnGPS, btnCenter,btnSave;
+	Button btnGoto, btnMap;
 	int currFormat;
 
-	mLabel lblGPS, lblPosition, lblDST;
+	Label lblGPS, lblPosition, lblDST;
 	Color gpsStatus;
 
 	MainTab mainT;
-	Vector cacheDB;
-	DetailsPanel detP;
+	//Vector cacheDB;
+	//DetailsPanel detP;
 
 	Preferences pref;
-	Profile profile;
+	//Profile profile;
 	// different panels to avoid spanning
 	CellPanel ButtonP = new CellPanel();
 	CellPanel CoordsP = new CellPanel();
 	CellPanel roseP = new CellPanel();
 
-	ImageControl icRose;
+	//ImageControl icRose;
 	GotoRose compassRose;
 
 	final static Color RED = new Color(255,0,0);
@@ -59,17 +56,17 @@
 
 	final static Font BOLD = new Font(&quot;Arial&quot;, Font.BOLD, 14);
 
-	int ticker = 0;
-	
+	//int ticker = 0;
+
 	Menu mnuContextFormt;
 	MenuItem miDMM, miDMS, miDD, miUTM, miGK;
-	
+
 	Menu mnuContextRose;
 	MenuItem miLuminary[] = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
 	MenuItem miNorthCentered;
-	
+
 	/**
-	 * Create GotoPanel 
+	 * Create GotoPanel
 	 * @param Preferences 	global preferences
 	 * @param MainTab		reference to MainTable
 	 * @param DetailsPanel 	reference to DetailsPanel
@@ -78,18 +75,17 @@
 	public GotoPanel(Navigate nav) {
 		myNavigation = nav;
 		pref = Global.getPref();
-		profile=Global.getProfile();
 		mainT = Global.mainTab;
-		detP = mainT.detP;
-		cacheDB = profile.cacheDB;
+		//detP = mainT.detP;
+		//cacheDB = profile.cacheDB;
 
 		// Button
-		ButtonP.addNext(btnGPS = new mButton(MyLocale.getMsg(1504,&quot;Start&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		ButtonP.addNext(btnCenter = new mButton(MyLocale.getMsg(309,&quot;Centre&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		ButtonP.addNext(btnSave = new mButton(MyLocale.getMsg(311,&quot;Create Waypoint&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		ButtonP.addLast(btnMap = new mButton(MyLocale.getMsg(1506,&quot;Map&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addNext(btnGPS = new Button(MyLocale.getMsg(1504,&quot;Start&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addNext(btnCenter = new Button(MyLocale.getMsg(309,&quot;Centre&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addNext(btnSave = new Button(MyLocale.getMsg(311,&quot;Create Waypoint&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addLast(btnMap = new Button(MyLocale.getMsg(1506,&quot;Map&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 
-		//Format selection for coords		
+		//Format selection for coords
 		//context menu
 		mnuContextFormt = new Menu();
 		mnuContextFormt.addItem(miDD = new MenuItem(&quot;d.d&#176;&quot;));
@@ -113,41 +109,39 @@
 		}
 
 		//Coords
-		CoordsP.addNext(lblGPS = new mLabel(&quot;GPS: &quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		CoordsP.addNext(lblGPS = new Label(&quot;GPS: &quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		lblGPS.backGround = RED;
 		lblGPS.setMenu(mnuContextFormt);
-		lblGPS.modifyAll(ControlConstants.WantHoldDown, 0);
+		lblGPS.modifyAll(Control.WantHoldDown, 0);
 
-		lblPosition = new mLabel(myNavigation.gpsPos.toString(currFormat));
-		lblPosition.anchor = mLabel.CENTER;
+		CoordsP.addLast(lblPosition = new Label(myNavigation.gpsPos.toString(currFormat)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		lblPosition.setMenu(mnuContextFormt);
-		lblPosition.modifyAll(ControlConstants.WantHoldDown, 0);
-		CoordsP.addLast(lblPosition, CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		lblPosition.anchor = Label.CENTER;
+		lblPosition.modifyAll(Control.WantHoldDown, 0);
 
-		CoordsP.addNext(lblDST = new mLabel(MyLocale.getMsg(1500,&quot;DST:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		CoordsP.addNext(lblDST = new Label(MyLocale.getMsg(1500,&quot;DST:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		lblDST.backGround = new Color(0,0,255);
 		lblDST.setMenu(mnuContextFormt);
-		lblDST.modifyAll(ControlConstants.WantHoldDown, 0);
+		lblDST.modifyAll(Control.WantHoldDown, 0);
 
-		CoordsP.addLast(btnGoto = new mButton(getGotoBtnText()),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		
+		CoordsP.addLast(btnGoto = new Button(getGotoBtnText()),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+
 		//Rose for bearing
-//		compassRose = new GotoRose(&quot;rose.png&quot;);
+		//compassRose = new GotoRose(&quot;rose.png&quot;);
 		compassRose = new GotoRose();
-		icRose = new ImageControl(compassRose);
-		icRose.setMenu(mnuContextRose);
-		icRose.modifyAll(ControlConstants.WantHoldDown, 0); // this is necessary in order to make PenHold on a PDA work as right click
-		roseP.addLast(icRose,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTH));
-		
+		compassRose.setMenu(mnuContextRose);
+		compassRose.modifyAll(Control.WantHoldDown, 0); // this is necessary in order to make PenHold on a PDA work as right click
+		roseP.addLast(compassRose,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTH|CellConstants.WEST));
+
 		mnuContextRose.addItem(new MenuItem(&quot;&quot;, MenuItem.Separator, null));
 		mnuContextRose.addItem(miNorthCentered = new MenuItem(MyLocale.getMsg(1503,&quot;North Centered&quot;)));
 		if (compassRose.isNorthCentered()) miNorthCentered.modifiers |= MenuItem.Checked;
 		else miNorthCentered.modifiers &amp;= MenuItem.Checked;
 
 		//add Panels
-		this.addLast(ButtonP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
-		this.addLast(CoordsP,CellConstants.HSTRETCH, CellConstants.HFILL|CellConstants.NORTH).setTag(SPAN,new Dimension(2,1));
-		this.addLast(roseP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
+		this.addLast(ButtonP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST); //.setTag(TAG_SPAN,new Dimension(2,1));
+		this.addLast(CoordsP,CellConstants.HSTRETCH, CellConstants.HFILL|CellConstants.NORTH); //.setTag(TAG_SPAN,new Dimension(2,1));
+		this.addLast(roseP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.NORTH|CellConstants.WEST); //.setTag(TAG_SPAN,new Dimension(2,1));
 
 		// for debuging
 		/*		CWGPSPoint myGPS;
@@ -176,56 +170,54 @@
 //		// myGPS.noInterpretableData();
 
 
-//		}	
+//		}
 	}
-	
+
 	public void resizeTo(int width, int height){
 		super.resizeTo(width, height);
 		Rect coordsRect = CoordsP.getRect();
 		int roseHeight = height - coordsRect.y - coordsRect.height;
-		if (Gui.screenIs(Gui.PDA_SCREEN) &amp;&amp; Vm.isMobile()) {
+		if (Gui.screenIs(Gui.PDA_SCREEN) &amp;&amp; Device.isMobile()) {
 			//some space for the SIP button
-			if ( (Vm.getParameter(VmConstants.VM_FLAGS) &amp; (VmConstants.VM_FLAG_SIP_BUTTON_ON_SCREEN)) == (VmConstants.VM_FLAG_SIP_BUTTON_ON_SCREEN) ){
-				Rect screen = (Rect)Window.getGuiInfo(WindowConstants.INFO_SCREEN_RECT,null,new Rect(),0);
-				roseHeight -= screen.height / 14;				
+			if ( (Vm.getParameter(Vm.VM_FLAGS) &amp; (Vm.VM_FLAG_SIP_BUTTON_ON_SCREEN)) == (Vm.VM_FLAG_SIP_BUTTON_ON_SCREEN) ){
+				roseHeight -= MyLocale.getScreenHeight() / 14;
 			}
 		}
-		roseP.resizeTo(width, roseHeight); 
-		icRose.resizeTo(width, roseHeight);
-		compassRose.resize(width, roseHeight);
+		roseP.resizeTo(width, roseHeight);
+		compassRose.resizeTo(width, roseHeight);
 	}
 
 
 	/**
-	 * set the coords of the destination  
+	 * set the coords of the destination
 	 * @param dest destination
-	 */ 
+	 */
 	public void setDestination(CWPoint dest){
 		myNavigation.setDestination(dest);
-		if (!myNavigation.destination.isValid()) (new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(1507,&quot;Coordinates are out of range:&quot;) +&quot;\n&quot;+MyLocale.getMsg(1508,&quot;latitude&quot;)+&quot;: &quot;+myNavigation.destination.latDec+&quot;\n &quot;+MyLocale.getMsg(1509,&quot;longditue&quot;)+&quot;: &quot;+myNavigation.destination.lonDec, FormBase.OKB)).execute();
-		
+		if (!myNavigation.destination.isValid()) (new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(1507,&quot;Coordinates are out of range:&quot;) +&quot;\n&quot;+MyLocale.getMsg(1508,&quot;latitude&quot;)+&quot;: &quot;+myNavigation.destination.latDec+&quot;\n &quot;+MyLocale.getMsg(1509,&quot;longditue&quot;)+&quot;: &quot;+myNavigation.destination.lonDec, MessageBox.OKB)).execute();
+
 	}
-	
+
 	public void destChanged(CWPoint d) { // called from myNavigate
 		btnGoto.setText(getGotoBtnText());
 		updateDistance();
 	}
-	
 
+
 	/**
-	 * set the coords of the destination and switch to gotoPanel  
-	 * @param LatLon destination
-	 */ 
+	 * set the coords of the destination and switch to gotoPanel
+	 * @param latLon destination
+	 */
 	public void setDestinationAndSwitch(CWPoint where) {
 		myNavigation.setDestination(where);
 		mainT.select(this);
 	}
-	
+
 	/**
 	 * updates distance and bearing
 	 *
 	 */
-	
+
 	public void updateDistance() {
 		//update distance
 		float distance = -1.0f;
@@ -236,23 +228,23 @@
 	}
 
 	/**
-	 * method which is called if a timer is set up  
-	 */ 
+	 * method which is called if a timer is set up
+	 */
 	public void updateGps(int fix) {
-		Double bearMov = new Double();
-		Double speed = new Double();
-		Double sunAzimut = new Double();
 		//Vm.debug(&quot;ticked: before&quot;);
 		compassRose.setGpsStatus(fix, myNavigation.gpsPos.getSats(), myNavigation.gpsPos.getSatsInView(), myNavigation.gpsPos.getHDOP());
 		if ((fix &gt; 0) &amp;&amp; (myNavigation.gpsPos.getSats()&gt;= 0)) {
+			Double bearMov;
+			Double speed;
+			Double sunAzimut;
 			// display values only, if signal good
 			//Vm.debug(&quot;currTrack.add: nachher&quot;);
 			lblPosition.setText(myNavigation.gpsPos.toString(currFormat));
-			speed.set(myNavigation.gpsPos.getSpeed());
-			sunAzimut.set(myNavigation.skyOrientationDir.lonDec);
-			bearMov.set(myNavigation.gpsPos.getBear());
+			speed=new Double(myNavigation.gpsPos.getSpeed());
+			sunAzimut=new Double(myNavigation.skyOrientationDir.lonDec);
+			bearMov=new Double(myNavigation.gpsPos.getBear());
 			updateDistance();
-			compassRose.setSunMoveDirections((float)sunAzimut.value, (float)bearMov.value, (float)speed.value);
+			compassRose.setSunMoveDirections((float)sunAzimut.doubleValue(), (float)bearMov.doubleValue(), (float)speed.doubleValue());
 			// Set background to signal quality
 		}
 
@@ -262,13 +254,13 @@
 		}
 		// receiving no data
 		if (fix == -1) {
-			if (gpsStatus != RED) (new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1510, &quot;No data from GPS\nConnection to serial port closed&quot;),FormBase.OKB)).exec();
+			if (gpsStatus != RED) (new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1510, &quot;No data from GPS\nConnection to serial port closed&quot;),MessageBox.OKB)).exec();
 			gpsStatus = RED;
 			myNavigation.stopGps();
 		}
 		// cannot interprete data
 		if (fix == -2) {
-			if (gpsStatus != RED) (new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1511, &quot;Cannot interpret data from GPS\n possible reasons:\n wrong Port,\n wrong Baudrate,\n not NMEA-Protocol\nConnection to serial port closed\nLast String tried to interprete:\n&quot;)+myNavigation.gpsPos.lastStrExamined, FormBase.OKB)).exec();
+			if (gpsStatus != RED) (new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1511, &quot;Cannot interpret data from GPS\n possible reasons:\n wrong Port,\n wrong Baudrate,\n not NMEA-Protocol\nConnection to serial port closed\nLast String tried to interprete:\n&quot;)+myNavigation.gpsPos.lastStrExamined, MessageBox.OKB)).exec();
 			gpsStatus = RED;
 			myNavigation.stopGps(); // TODO automatic in myNavigate?
 		}
@@ -277,25 +269,26 @@
 	public void gpsStarted() {
 		btnGPS.setText(MyLocale.getMsg(1505,&quot;Stop&quot;));
 	}
-	
+
 	public void startGps() {
 		myNavigation.startGps(pref.logGPS, Convert.toInt(pref.logGPSTimer));
 	}
 
-	public void gpsStoped() {
+	public void gpsStopped() {
 		btnGPS.setText(MyLocale.getMsg(1504,&quot;Start&quot;));
 		gpsStatus = this.backGround;
 		this.repaintNow(); // without this the change in the background color will not be displayed
 	}
 
-	
+
 	private String getGotoBtnText() {
-		if (myNavigation.destination == null) return MyLocale.getMsg(999,&quot;Not set&quot;);
-		else return myNavigation.destination.toString(currFormat);
+		if (myNavigation.destination == null)
+			return MyLocale.getMsg(999,&quot;Not set&quot;);
+		return myNavigation.destination.toString(currFormat);
 	}
-	
+
 	public void switchToMovingMap() {
-		CWPoint centerTo = null;
+		CWPoint centerTo=null;
 		if (myNavigation.isGpsPosValid()) centerTo = new CWPoint(myNavigation.gpsPos); // set gps-pos if gps is on
 		else {
 			// setze Zielpunkt als Ausgangspunkt, wenn GPS aus ist und lade entsprechende Karte
@@ -311,24 +304,24 @@
 			}
 		}
 		if (centerTo != null &amp;&amp; centerTo.isValid())
-			mainT.SwitchToMovingMap(centerTo, false);
+			mainT.switchToMovingMap(centerTo, false);
 		else
-		(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1513, &quot;Cannot start moving map without valid coordinates. Please enter coordinates as destination, as center, in selected cache or start GPS&quot;), FormBase.OKB)).execute(); 
+			(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1513, &quot;Cannot start moving map without valid coordinates. Please enter coordinates as destination, as center, in selected cache or start GPS&quot;), MessageBox.OKB)).execute();
 	}
-	
+
 	/**
 	 * Eventhandler
 	 */
 
 	public void onEvent(Event ev){
-		if (ev instanceof MenuEvent) { 
+		if (ev instanceof MenuEvent) {
 			if (ev.type == MenuEvent.SELECTED ) {
-				MenuItem action = (MenuItem) mnuContextFormt.getSelectedItem(); 
+				MenuItem action = (MenuItem) mnuContextFormt.getSelectedItem();
 				if (action != null) {
 					if (action == miDD) {
 						mnuContextFormt.close();
 						currFormat = CWPoint.DD;
-						}
+					}
 					if (action == miDMM) {
 						mnuContextFormt.close();
 						currFormat = CWPoint.DMM;
@@ -351,9 +344,9 @@
 					miUTM.modifiers &amp;= ~MenuItem.Checked;
 					miGK.modifiers &amp;= ~MenuItem.Checked;
 					switch (currFormat) {
-					case CWPoint.DD: miDD.modifiers |= MenuItem.Checked; break;   
-					case CWPoint.DMM: miDMM.modifiers |= MenuItem.Checked; break;   
-					case CWPoint.DMS: miDMS.modifiers |= MenuItem.Checked; break;   
+					case CWPoint.DD: miDD.modifiers |= MenuItem.Checked; break;
+					case CWPoint.DMM: miDMM.modifiers |= MenuItem.Checked; break;
+					case CWPoint.DMS: miDMS.modifiers |= MenuItem.Checked; break;
 					case CWPoint.UTM: miUTM.modifiers |= MenuItem.Checked; break;
 					case CWPoint.GK: miGK.modifiers |= MenuItem.Checked; break;
 					}
@@ -373,7 +366,7 @@
 					if (action == miNorthCentered) {
 						if (compassRose.isNorthCentered()) {
 							compassRose.setNorthCentered(false);
-							miNorthCentered.modifiers &amp;= ~MenuItem.Checked;							
+							miNorthCentered.modifiers &amp;= ~MenuItem.Checked;
 						}
 						else
 						{
@@ -392,25 +385,25 @@
 				else myNavigation.stopGps();
 			}
 
-			// set current position as centre and recalculate distance of caches in MainTab 
+			// set current position as centre and recalculate distance of caches in MainTab
 			if (ev.target == btnCenter){
 				if (myNavigation.gpsPos.isValid()) {
-				Vm.showWait(true);
-				pref.curCentrePt.set(myNavigation.gpsPos);
-				mainT.updateBearDist();
-				Vm.showWait(false);
+					Form.showWait();
+					pref.curCentrePt.set(myNavigation.gpsPos);
+					mainT.updateBearDist();
+					Form.cancelWait();
 				} else (new MessageBox(MyLocale.getMsg(312, &quot;Error&quot;), MyLocale.getMsg(1514, &quot;Cannot recalculate distances, because the GPS position is not set&quot;), MessageBox.OKB)).execute();
 			}
 			//Start moving map
 			if (ev.target == btnMap){
 				switchToMovingMap();
-			} 
+			}
 			// create new waypoint with current GPS-position
 			if (ev.target == btnSave){
 				CacheHolder ch = new CacheHolder();
-				ch.LatLon = myNavigation.gpsPos.toString();
+				ch.latLon = myNavigation.gpsPos.toString();
 				ch.pos = new CWPoint(myNavigation.gpsPos);
-				ch.type = &quot;51&quot;; // see CacheType.GC_AW_STAGE_OF_MULTI // TODO unfertig
+				ch.type = 51; // see CacheType.GC_AW_STAGE_OF_MULTI // TODO unfertig
 				mainT.newWaypoint(ch);
 			}
 			// change destination waypoint
@@ -418,7 +411,7 @@
 				CoordsScreen cs = new CoordsScreen();
 				if (myNavigation.destination.isValid())	cs.setFields(myNavigation.destination, currFormat);
 				else cs.setFields(new CWPoint(0,0), currFormat);
-				if (cs.execute(null, CellConstants.TOP) == FormBase.IDOK)
+				if (cs.execute(null, Gui.TOP) == CoordsScreen.IDOK)
 					setDestination(cs.getCoords());
 			}
 		}
@@ -429,28 +422,30 @@
 /** class for displaying the compass rose
  * including goto, sun and moving direction
  */
-class GotoRose extends AniImage {
+class GotoRose extends Panel {
+	//TODO Too many objects are created
+	//TOTO Store the sine and cosine in a variable
 	float gotoDir = -361;
 	float sunDir = -361;
 	float moveDir = -361;
 	float distance = -1;
-	
+
 	int m_fix = -1;
 	int m_sats = -1;
 	int m_satsInView = 0;
 	double m_hdop = -1;
 	float m_speed = -1;
-	
+
 	String m_Luminary = MyLocale.getMsg(6100, &quot;Sun&quot;);
-	
+
 	Font mainFont;
 	FontMetrics fm;
 	int lineHeight;
-	
+
 	int roseRadius;
-	
+
 	boolean northCentered = Global.getPref().northCenteredGoto;
-	
+
 	final static Color RED = new Color(255,0,0);
 	final static Color YELLOW = new Color(255,255,0);
 	final static Color GREEN = new Color(0,255,0);
@@ -465,162 +460,162 @@
 	 * @param sd sun direction
 	 * @param md moving direction
 	 */
-	public GotoRose(String fn){
-		super(fn);
-	}
-	
+	//public GotoRose(String fn){
+	//}
+
 	public GotoRose(){
 		super();
 	}
-	
+
 	public void setWaypointDirectionDist(float wd, float dist) {
 		gotoDir = wd;
 		distance = dist;
 	}
-	
+
 	public void setSunMoveDirections(float sd, float md, float speed ) {
 		sunDir = sd;
 		moveDir = md;
 		m_speed = speed;
-		refresh();
+		repaint();
 	}
-	
+
 	public void setGpsStatus(int fix, int sats, int satsInView, double hdop) {
 		m_fix = fix;
 		m_sats = sats;
 		m_satsInView = satsInView;
 		m_hdop = hdop;
-		refresh();
+		repaint();
 	}
-	
+
 	public void setLuminaryName(String Luminary) {
 		m_Luminary = Luminary;
-		refresh();
+		repaint();
 	}
 
-	
+
 	/**
 	 * draw arrows for the directions of movement and destination waypoint
 	 * @param ctrl the control to paint on
 	 * @param moveDir degrees of movement
 	 * @param destDir degrees of destination waypoint
 	 */
-	
-	public void doDraw(Graphics g,int options) {
+
+	public void doPaint(Graphics g, Rect area)  {
 		g.setColor(Color.White);
-		g.fillRect(0, 0, location.width, location.height);
+		g.fillRect(0, 0, this.width, this.height);
 
-		int fontSize = location.width / 17;
+		int fontSize = this.width/17;
 		mainFont = new Font(&quot;Verdana&quot;, Font.BOLD, fontSize);
 		g.setFont(mainFont);
 		fm = g.getFontMetrics(mainFont);
 		lineHeight = fm.getHeight() + 1;
-		roseRadius = java.lang.Math.min((location.width * 3) / 4, location.height) / 2;
+		roseRadius = java.lang.Math.min((this.width * 3) / 4, this.height) / 2;
 
 		if (northCentered) {
-			//scale(location.width, location.height, null, 0);
-			//super.doDraw(g, options);
-			drawFullRose(g, 0, new Color(255,255,255), new Color(200,200,200), new Color(255,255,255), new Color(200,200,200), new Color(150,150,150), new Color(75,75,75), 1.0f, true, true);
+			drawFullRose(g, 0, 				// angle
+					Color.White, 			// colLeft
+					new Color(200,200,200), // colRight
+					Color.White, 			// colNorthLeft
+					new Color(200,200,200), // colNorthRight
+					new Color(150,150,150), // colBorder
+					new Color(75,75,75),    // colText
+					1.0f,					// scale
+					true, 					// bDrawText
+					true);					// bDrawEightArrows
 		}
 		else {
 			int radius = (int)(roseRadius * 0.75f);
-
-			g.setPen(new Pen(new Color(150,150,150),Pen.SOLID,3));
-			g.drawEllipse(location.width/2 - radius, location.height/2 - radius, 2 * radius, 2 * radius );
+			Pen oldPen = g.getPen(Pen.getCached());
+			g.changePen(new Color(150,150,150),Pen.SOLID,3);
+			//g.setPen(new Pen(new Color(150,150,150),Pen.SOLID,3));
+			g.drawEllipse(this.width/2 - radius, this.height/2 - radius, 2 * radius, 2 * radius );
+			g.set(oldPen);
+			oldPen.cache();
 		}
-		
+
 		drawArrows(g);
 		drawWayPointData(g);
 		drawGpsData(g);
 		drawLuminaryData(g);
 		drawGpsStatus(g);
 	}
-		
+
 	private void drawWayPointData(Graphics g){
 		String strTemp = MyLocale.getMsg(1512, &quot;Waypoint&quot;);
 		g.setColor(Color.DarkBlue);
 		g.fillRect(0, 0, fm.getTextWidth(strTemp) + 4, lineHeight);
-		g.setColor(Color.White);		
+		g.setColor(Color.White);
 		g.drawText(strTemp, 2, 0);
-		
-		g.setColor(Color.Black);		
-		
-		Double tmp = new Double();
-		strTemp = &quot;&quot;;
+
+		g.setColor(Color.Black);
+
 		if ( distance &gt;= 0.0f ) {
-			tmp.set(distance);
-			if (tmp.value &gt;= 1){
-				strTemp = MyLocale.formatDouble(tmp,&quot;0.000&quot;)+ &quot; km&quot;;
+			if (distance &gt;= 1){
+				strTemp = MyLocale.formatDouble(distance,&quot;0.000&quot;)+ &quot; km&quot;;
+			} else {
+				strTemp = MyLocale.formatDouble(distance*1000.0,&quot;0&quot;) + &quot; m&quot;;
 			}
-			else {
-				tmp.set(tmp.value * 1000);
-				strTemp = tmp.toString(3,0,0) + &quot; m&quot;;
-			}
 		}
 		else strTemp = &quot;--- km&quot;;
 		g.drawText(strTemp, 2, lineHeight);
-		
-		tmp.set(gotoDir);
-		if ((tmp.value &lt;= 360) &amp;&amp; (tmp.value &gt;= -360))
-			strTemp = tmp.toString(0,0,0) + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
-		else strTemp = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+
+		if ((gotoDir &lt;= 360) &amp;&amp; (gotoDir &gt;= -360))
+			strTemp = MyLocale.formatDouble(gotoDir,&quot;0&quot;) + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+		else
+			strTemp = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
 		g.drawText(strTemp, 2, 2*lineHeight);
 	}
-	
+
 	private void drawGpsData(Graphics g){
 		g.setColor(RED);
-		
+
 		String strHeadline = MyLocale.getMsg(1501,&quot;Current&quot;);
-		
-		Double tmp = new Double();
 
-		tmp.set(m_speed);
+		Double tmp = new Double(m_speed);
 		String strSpeed = &quot;- km/h&quot;;
 		if (m_speed &gt;= 0) {
 			if (m_speed &gt;= 100) {
-				strSpeed = MyLocale.formatDouble(tmp,&quot;0&quot;) + &quot; km/h&quot;;				
+				strSpeed = MyLocale.formatDouble(tmp,&quot;0&quot;) + &quot; km/h&quot;;
 			}
 			else {
 				strSpeed = MyLocale.formatDouble(tmp,&quot;0.0&quot;) + &quot; km/h&quot;;
 			}
 		}
-		
-		tmp.set(moveDir);
+
+		tmp = new Double(moveDir);
 		String strMoveDir = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
-		if ((tmp.value &lt;= 360) &amp;&amp; (tmp.value &gt;= -360))
-			strMoveDir = tmp.toString(0,0,0) + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+		if ((tmp.doubleValue() &lt;= 360) &amp;&amp; (tmp.doubleValue() &gt;= -360))
+			strMoveDir = tmp.toString() + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
 
 		int textWidth = java.lang.Math.max(fm.getTextWidth(strSpeed), fm.getTextWidth(strMoveDir));
 		textWidth = java.lang.Math.max(textWidth, fm.getTextWidth(strHeadline));
-		
-		int startX = location.width - (textWidth + 4);
-		g.fillRect(startX, 0, location.width - startX, lineHeight);
-		
-		g.setColor(Color.Black);		
-		g.drawText(strHeadline, startX + 2, 0);		
+
+		int startX = this.width - (textWidth + 4);
+		g.fillRect(startX, 0, this.width - startX, lineHeight);
+
+		g.setColor(Color.Black);
+		g.drawText(strHeadline, startX + 2, 0);
 		g.drawText(strSpeed, startX + 2, lineHeight);
 		g.drawText(strMoveDir, startX + 2, 2*lineHeight);
 	}
-	
+
 	private void drawLuminaryData(Graphics g){
 		g.setColor(YELLOW);
 
 		String strSunDir = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
 		if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360) {
-			Double tmp = new Double();
-			tmp.set(sunDir);
-			strSunDir = tmp.toString(0,0,0) + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+			strSunDir = MyLocale.formatDouble(sunDir, &quot;0&quot;) + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
 		}
 
 		int textWidth = java.lang.Math.max(fm.getTextWidth(m_Luminary), fm.getTextWidth(strSunDir));
-		int startY = location.height - 2*lineHeight;
-		g.fillRect(0, startY, textWidth + 4, location.height - startY);
+		int startY = this.height - 2*lineHeight;
+		g.fillRect(0, startY, textWidth + 4, this.height - startY);
 
-		g.setColor(Color.Black);		
+		g.setColor(Color.Black);
 		g.drawText(m_Luminary, 2, startY);
 		g.drawText(strSunDir, 2, startY + lineHeight);
 	}
-	
+
 	private void drawGpsStatus(Graphics g){
 		if ((m_fix &gt; 0) &amp;&amp; (m_sats &gt;= 0)) {
 			// Set background to signal quality
@@ -643,9 +638,9 @@
 		if (m_hdop &gt;= 0) strHdop = &quot;HDOP: &quot; + Convert.toString(m_hdop);
 
 		int textWidth = java.lang.Math.max(fm.getTextWidth(strSats), fm.getTextWidth(strHdop));
-		int startX = location.width - (textWidth + 4);
-		int startY = location.height - 2*lineHeight;
-		g.fillRect(startX, startY, location.width - startX ,location.height - startY);
+		int startX = this.width - (textWidth + 4);
+		int startY = this.height - 2*lineHeight;
+		g.fillRect(startX, startY, this.width - startX ,this.height - startY);
 
 		g.setColor(Color.Black);
 		g.drawText(strSats, startX + 2, startY);
@@ -657,7 +652,7 @@
 		{
 			// select moveDirColor according to difference to gotoDir
 			Color moveDirColor = RED;
-			
+
 			if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360 &amp;&amp; moveDir &lt; 360 &amp;&amp; moveDir &gt; -360)
 			{
 				float diff = java.lang.Math.abs(moveDir - gotoDir);
@@ -669,7 +664,7 @@
 				{
 					diff = 360.0f - diff;
 				}
-				
+
 				if (diff &lt;= 12.25f)
 				{
 					moveDirColor = GREEN;
@@ -700,28 +695,28 @@
 					//drawDoubleArrow(g, 360 - moveDir, BLUE, new Color(175,0,0), 1.0f);
 					//drawRose(g, 360 - moveDir, new Color(100,100,100), new Color(200,200,200), 1.0f);
 					drawFullRose(g, 360 - moveDir, new Color(255,255,255), new Color(200,200,200), new Color(150,150,150), new Color(200,200,200), new Color(200,200,200), new Color(75,75,75), 1.0f, false, false);
-					
+
 					int radius = (int)(roseRadius * 0.75f);
-					g.setPen(new Pen(RED,Pen.SOLID,3));
-					g.drawLine(location.width/2, location.height/2 - radius, location.width/2, location.height/2 + radius);
-					
+					g.changePen(RED,Pen.SOLID,3);
+					g.drawLine(this.width/2, this.height/2 - radius, this.width/2, this.height/2 + radius);
+
 					if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360) drawThinArrow(g, gotoDir - moveDir, Color.DarkBlue, moveDirColor, 1.0f);
-					if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360) drawSunArrow(g, sunDir - moveDir, YELLOW, 0.75f);					
-				}				
+					if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360) drawSunArrow(g, sunDir - moveDir, YELLOW, 0.75f);
+				}
 			}
 		}
 	}
 
 	/**
-	 * draw single arrow 
+	 * draw single arrow
 	 * @param g handle for drawing
 	 * @param angle angle of arrow
 	 * @param col color of arrow
 	 */
-	private void drawSimpleArrow(Graphics g, float angle, Color col, float scale) {
+/*	private void drawSimpleArrow(Graphics g, float angle, Color col, float scale) {
 		float angleRad;
-		int x, y, centerX = location.width/2, centerY = location.height/2;
-		int arrowLength = roseRadius; 
+		int x, y, centerX = this.width/2, centerY = this.height/2;
+		int arrowLength = roseRadius;
 
 		angleRad = (angle) * (float)java.lang.Math.PI / 180;
 		x = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad) * scale).intValue();
@@ -729,73 +724,75 @@
 		g.setPen(new Pen(col,Pen.SOLID,3));
 		g.drawLine(centerX,centerY,x,y);
 	}
-	
+*/
 	private void drawSunArrow(Graphics g, float angle, Color col, float scale) {
 		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
+		int centerX = this.width/2, centerY = this.height/2;
 		float arrowLength = roseRadius * scale;
 		float halfArrowWidth = arrowLength * 0.08f;
 		float circlePos = arrowLength * 0.7f;
 		int circleRadius = (int)(arrowLength * 0.1f);
 
-		int circleX = centerX + new Float(circlePos * java.lang.Math.sin(angleRad)).intValue();
-		int circleY = centerY - new Float(circlePos * java.lang.Math.cos(angleRad)).intValue();
+		//int pointX = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		//int pointY = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		int circleX = centerX + (int) (circlePos * java.lang.Math.sin(angleRad));
+		int circleY = centerY - (int) (circlePos * java.lang.Math.cos(angleRad));
 
 		int[] pointsX = new int[4];
 		int[] pointsY = new int[4];
 
-		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
-		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
-		pointsX[1] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
-		pointsY[1] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
-		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
-		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
-		pointsX[3] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
-		pointsY[3] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
-		
+		pointsX[0] = centerX + (int)(arrowLength * java.lang.Math.sin(angleRad));
+		pointsY[0] = centerY - (int)(arrowLength * java.lang.Math.cos(angleRad));
+		pointsX[1] = centerX + (int)(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0));
+		pointsY[1] = centerY - (int)(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0));
+		pointsX[2] = centerX + (int)(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI));
+		pointsY[2] = centerY - (int)(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI));
+		pointsX[3] = centerX + (int)(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0));
+		pointsY[3] = centerY - (int)(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0));
+
 //		g.setPen(new Pen(col,Pen.SOLID,3));
 //		g.drawLine(centerX,centerY,pointX,pointY);
-		
-		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
-		g.setBrush(new Brush(col, Brush.SOLID));
+
+		g.changePen(Color.Black,Pen.SOLID,1);
+		g.changeBrush(col, Brush.SOLID);
 		g.fillPolygon(pointsX, pointsY, 4);
 		g.fillEllipse(circleX - circleRadius, circleY - circleRadius, 2 * circleRadius, 2 * circleRadius);
 	}
-	
+
 	private void drawThinArrow(Graphics g, float angle, Color col, Color colPoint, float scale) {
 		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
+		int centerX = this.width/2, centerY = this.height/2;
 		float arrowLength = roseRadius * scale;
 		float halfOpeningAngle = (float)(java.lang.Math.PI * 0.03);
 		float sideLineLength = arrowLength * 0.75f;
-		
+
 		int[] pointsX = new int[4];
 		int[] pointsY = new int[4];
 
-		pointsX[0] = centerX + new Float(sideLineLength * java.lang.Math.sin(angleRad - halfOpeningAngle)).intValue();
-		pointsY[0] = centerY - new Float(sideLineLength * java.lang.Math.cos(angleRad - halfOpeningAngle)).intValue();
-		pointsX[1] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
-		pointsY[1] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
-		pointsX[2] = centerX + new Float(sideLineLength * java.lang.Math.sin(angleRad + halfOpeningAngle)).intValue();
-		pointsY[2] = centerY - new Float(sideLineLength * java.lang.Math.cos(angleRad + halfOpeningAngle)).intValue();
+		pointsX[0] = centerX + (int)(sideLineLength * java.lang.Math.sin(angleRad - halfOpeningAngle));
+		pointsY[0] = centerY - (int)(sideLineLength * java.lang.Math.cos(angleRad - halfOpeningAngle));
+		pointsX[1] = centerX + (int)(arrowLength * java.lang.Math.sin(angleRad));
+		pointsY[1] = centerY - (int)(arrowLength * java.lang.Math.cos(angleRad));
+		pointsX[2] = centerX + (int)(sideLineLength * java.lang.Math.sin(angleRad + halfOpeningAngle));
+		pointsY[2] = centerY - (int)(sideLineLength * java.lang.Math.cos(angleRad + halfOpeningAngle));
 		pointsX[3] = centerX;
 		pointsY[3] = centerY;
-		
-		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
-		g.setBrush(new Brush(col, Brush.SOLID));
+
+		g.changePen(Color.Black,Pen.SOLID,1);
+		g.changeBrush(col, Brush.SOLID);
 		g.fillPolygon(pointsX, pointsY, 4);
 		if (colPoint != null) {
-			g.setBrush(new Brush(colPoint, Brush.SOLID));
-			g.fillPolygon(pointsX, pointsY, 3);			
+			g.changeBrush(colPoint, Brush.SOLID);
+			g.fillPolygon(pointsX, pointsY, 3);
 		}
 	}
-	
-	private void drawDoubleArrow(Graphics g, float angle, Color colFront, Color colRear, float scale) {
+
+/*	private void drawDoubleArrow(Graphics g, float angle, Color colFront, Color colRear, float scale) {
 		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
-		float arrowLength = roseRadius * scale;
+		int centerX = this.width/2, centerY = this.height/2;
+		float arrowLength = (float)roseRadius * scale;
 		float halfArrowWidth = arrowLength * 0.1f;
-		
+
 		int[] pointsX = new int[3];
 		int[] pointsY = new int[3];
 
@@ -805,24 +802,24 @@
 		pointsY[1] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
 		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
 		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
-		
+
 		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
 		g.setBrush(new Brush(colFront, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 3);
-		
+
 		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
 		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
-		
+
 		g.setBrush(new Brush(colRear, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 3);
 	}
-	
-	private void drawRose(Graphics g, float angle, Color colFront, Color colRear, float scale) {
+*/
+/*	private void drawRose(Graphics g, float angle, Color colFront, Color colRear, float scale) {
 		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
-		float arrowLength = roseRadius * scale;
+		int centerX = this.width/2, centerY = this.height/2;
+		float arrowLength = (float)roseRadius * scale;
 		float halfArrowWidth = arrowLength * 0.12f;
-		
+
 		int[] pointsX = new int[8];
 		int[] pointsY = new int[8];
 
@@ -842,15 +839,15 @@
 		pointsY[6] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - 3.0 * java.lang.Math.PI / 4.0)).intValue();
 		pointsX[7] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
 		pointsY[7] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
-		
+
 		g.setPen(new Pen(colRear,Pen.SOLID,1));
 		g.setBrush(new Brush(colRear, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 8);
-		
+
 		g.setBrush(new Brush(colFront, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 3);
 	}
-	
+*/
 	private void drawFullRose(Graphics g, float angle, Color colLeft, Color colRight, Color colNorthLeft, Color colNorthRight,
 			Color colBorder, Color colText, float scale, boolean bDrawText, boolean bDrawEightArrows) {
 		float subScale1 = 1.0f;
@@ -861,7 +858,7 @@
 			drawRosePart(g,  45 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, &quot;NE&quot;, bDrawText);
 			drawRosePart(g, 135 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, &quot;SE&quot;, bDrawText);
 			drawRosePart(g, 225 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, &quot;SW&quot;, bDrawText);
-			drawRosePart(g, 315 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, &quot;NW&quot;, bDrawText);	
+			drawRosePart(g, 315 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, &quot;NW&quot;, bDrawText);
 		}
 
 		drawRosePart(g,   0 + angle, colNorthLeft, colNorthRight, colBorder, colText, scale * subScale1, innerScale, &quot;N&quot;, bDrawText);
@@ -869,37 +866,37 @@
 		drawRosePart(g, 180 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, &quot;S&quot;, bDrawText);
 		drawRosePart(g, 270 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, &quot;W&quot;, bDrawText);
 	}
-	
+
 	private void drawRosePart(Graphics g, float angle, Color colLeft, Color colRight, Color colBorder, Color colText, float scale, float innerScale, String strDir, boolean bDrawText) {
 		float angleRad = angle * (float)java.lang.Math.PI / 180;
 		float angleRadText = (angle + 7.5f) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
-				
+		int centerX = this.width/2, centerY = this.height/2;
+
 		float arrowLength = roseRadius * scale;
 		float halfArrowWidth = arrowLength * innerScale;
-		
+
 		int[] pointsX = new int[3];
 		int[] pointsY = new int[3];
 
 		pointsX[0] = centerX;
 		pointsY[0] = centerY;
-		pointsX[1] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
-		pointsY[1] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
-		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 4.0)).intValue();
-		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 4.0)).intValue();
-				
-		g.setPen(new Pen(colBorder,Pen.SOLID,1));
-		g.setBrush(new Brush(colLeft, Brush.SOLID));
-		g.fillPolygon(pointsX, pointsY, 3);
+		pointsX[1] = centerX + (int)(arrowLength * java.lang.Math.sin(angleRad));
+		pointsY[1] = centerY - (int)(arrowLength * java.lang.Math.cos(angleRad));
+		pointsX[2] = centerX + (int)(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 4.0));
+		pointsY[2] = centerY - (int)(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 4.0));
 
-		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 4.0)).intValue();
-		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 4.0)).intValue();
-		
-		g.setBrush(new Brush(colRight, Brush.SOLID));
-		g.fillPolygon(pointsX, pointsY, 3);
-					
+		g.changePen(colBorder,Pen.SOLID,1);
+		g.changeBrush(colLeft, Brush.SOLID);
+		g.paintPolygon(pointsX, pointsY, 3);
+
+		pointsX[2] = centerX + (int)(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 4.0));
+		pointsY[2] = centerY - (int)(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 4.0));
+
+		g.changeBrush(colRight, Brush.SOLID);
+		g.paintPolygon(pointsX, pointsY, 3);
+
 		if (bDrawText){
-			int tempFontSize = new Float(scale * mainFont.getSize()).intValue();
+			int tempFontSize = (int)(scale * mainFont.getSize());
 			Font tempFont = new Font(mainFont.getName(), Font.BOLD, tempFontSize);
 			g.setFont(tempFont);
 			FontMetrics tempFm = g.getFontMetrics(tempFont);
@@ -909,45 +906,45 @@
 
 			float stringPosition = arrowLength - stringGap / 2.0f;
 			g.setColor(colText);
-			g.drawText(strDir, centerX + new Float(stringPosition * java.lang.Math.sin(angleRadText) - stringWidth / 2.0f).intValue(),
-					           centerY - new Float(stringPosition * java.lang.Math.cos(angleRadText) + stringHeight / 2.0f).intValue());
-			
+			g.drawText(strDir, centerX + (int)(stringPosition * java.lang.Math.sin(angleRadText) - stringWidth / 2.0f),
+					           centerY - (int)(stringPosition * java.lang.Math.cos(angleRadText) + stringHeight / 2.0f));
+
 			g.setFont(mainFont);
 		}
 	}
-	
+
 	private void drawThickArrow(Graphics g, float angle, Color col, float scale) {
 		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
+		int centerX = this.width/2, centerY = this.height/2;
 		float arrowLength = roseRadius * scale;
 		float halfArrowWidth = arrowLength * 0.1f;
-		
+
 		int[] pointsX = new int[4];
 		int[] pointsY = new int[4];
 
-		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
-		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
-		pointsX[1] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
-		pointsY[1] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
-		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
-		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
-		pointsX[3] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
-		pointsY[3] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
-		
-		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
-		g.setBrush(new Brush(col, Brush.SOLID));
+		pointsX[0] = centerX + (int)(arrowLength * java.lang.Math.sin(angleRad));
+		pointsY[0] = centerY - (int)(arrowLength * java.lang.Math.cos(angleRad));
+		pointsX[1] = centerX + (int)(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0));
+		pointsY[1] = centerY - (int)(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0));
+		pointsX[2] = centerX + (int)(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI));
+		pointsY[2] = centerY - (int)(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI));
+		pointsX[3] = centerX + (int)(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0));
+		pointsY[3] = centerY - (int)(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0));
+
+		g.changePen(Color.Black,Pen.SOLID,1);
+		g.changeBrush(col, Brush.SOLID);
 		g.fillPolygon(pointsX, pointsY, 4);
 	}
-	
+
 	public void setNorthCentered(boolean nc) {
 		northCentered = nc;
 		if (northCentered != Global.getPref().northCenteredGoto) {
 			Global.getPref().northCenteredGoto = northCentered;
 			Global.getPref().savePreferences();
 		}
-		refresh();
+		repaint();
 	}
-	
+
 	public boolean isNorthCentered() {
 		return northCentered;
 	}

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/MapImage.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/MapImage.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/MapImage.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,14 +1,7 @@
-package CacheWolf.navi;
-import ewe.fx.*;
-import ewe.graphics.*;
-import ewe.io.FileInputStream;
-import ewe.io.FileReader;
-import ewe.io.IOException;
-import ewe.io.InputStream;
-import ewe.io.InputStreamReader;
-import ewe.io.Stream;
-import ewe.util.ByteArray;
-/** 
+package cachewolf.navi;
+import eve.fx.*;
+import eve.ui.game.*;
+/**
  * class that can be used with any x and any y
  * it will save taht location and make itself automatically
  * invisible if it is not on the screen. Call setscreensize to
@@ -25,21 +18,13 @@
 		if (screenDim == null) screenDim = new Dimension(0,0);
 	}
 
-	public MapImage(String f) throws ImageDecodingException, UnsupportedImageFormatException, ImageNotFoundException, ewe.sys.SystemResourceException {
+	public MapImage(String f) throws ImageDecodingException, UnsupportedImageFormatException, ImageNotFoundException, eve.sys.SystemResourceException {
+		super(f);
 		if (screenDim == null) screenDim = new Dimension(0,0);
-		//super(f); the following code is only necessary because of an Bug in ewe 1.49, which doesn't read from a fakefilesystem. If there were no bug, calling super(f) would be sufficient
-		ewe.io.File file = ewe.sys.Vm.newFileObject();
-		file.set(null, f);
-		try {
-		//ByteArray imbytes = ewe.io.IO.readAllBytes(input, knownSize, stopAfterKnownSize);(file, null, true); // this would be possible if ewe 1.49 wouldn't have another bug: fakefilesystem doesn't implement (oderride) length(), it only overrides getLenght(), that's why readallBytes will call the original File implementation and cause and NullpointerException
-		setImage(new Image(new FileInputStream(f).toReadableStream(), 0), 0); // copied from super() 
-		freeSource(); // copied from super()
-		} catch (IOException e) { 
-			throw new ImageNotFoundException(f); // in order to behave the same way as super would have 
-		}
+		//TODO Check whether EVE reads correctly from a fake filesystem (EWE 1.49 did not)
 	}
 
-	public MapImage(mImage im) {
+	public MapImage(Picture im) {
 		super(im);
 		if (screenDim == null) screenDim = new Dimension(0,0);
 	}
@@ -48,25 +33,25 @@
 	 * Best you call this routine before you make any instance of MapImage
 	 * If the windows size changes after instantiation call  screenDimChanged()
 	 * for every symbol.
-	 * 
+	 *
 	 */
 	public static void setScreenSize(int w, int h) {
 		screenDim = new Dimension(w, h);
 	}
 
 	public void setImage(Image im, Color c) {
-		super.setImage(im, c);
+		super.setImage(im.getImageData());
 		if (screenDim == null) screenDim = new Dimension(0,0);
 	}
 
 	public void setLocation (int x, int y) {
 		locAlways.x = x;
 		locAlways.y = y;
-		if (!hidden &amp;&amp; isOnScreen()) { 
+		if (!hidden &amp;&amp; isOnScreen()) {
 			super.setLocation(x, y);
-			properties &amp;= ~mImage.IsInvisible;
+			properties &amp;= ~AniImage.IsInvisible;
 		} else {
-			properties |= mImage.IsInvisible;
+			properties |= AniImage.IsInvisible;
 			super.move(0, 0);
 		}
 	}
@@ -74,19 +59,19 @@
 	public void move (int x, int y) {
 		locAlways.x = x;
 		locAlways.y = y;
-		if (!hidden &amp;&amp; isOnScreen()) { 
+		if (!hidden &amp;&amp; isOnScreen()) {
 			super.move(x, y);
-			properties &amp;= ~mImage.IsInvisible;
+			properties &amp;= ~AniImage.IsInvisible;
 		} else {
-			properties |= mImage.IsInvisible;
+			properties |= AniImage.IsInvisible;
 			super.move(0, 0);
 		}
 	}
 
-	public boolean isOnScreen() { 
-		if ( (locAlways.x + location.width &gt; 0 &amp;&amp; locAlways.x &lt; screenDim.width) &amp;&amp; 
+	public boolean isOnScreen() {
+		if ( (locAlways.x + location.width &gt; 0 &amp;&amp; locAlways.x &lt; screenDim.width) &amp;&amp;
 				(locAlways.y + location.height &gt; 0 &amp;&amp; locAlways.y &lt; screenDim.height) ) return true;
-		else return false;
+		return false;
 	}
 
 	public void screenDimChanged() {
@@ -98,7 +83,7 @@
 
 	public void hide() {
 		hidden = true;
-		properties |= mImage.IsInvisible;
+		properties |= AniImage.IsInvisible;
 	}
 	public void unhide() {
 		hidden = false;

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/MapImporter.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/MapImporter.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/MapImporter.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,35 +1,53 @@
-package CacheWolf.navi;
+package cachewolf.navi;
 
-import ewe.util.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-import ewe.sys.*;
-import ewe.ui.*;
-import ewe.graphics.*;
-import ewe.fx.*;
+import java.util.*;
+import eve.io.*;
+import eve.ui.filechooser.FileChooser;
+import eve.sys.*;
+import eve.ui.*;
+import eve.fx.*;
+import eve.ui.game.AniImage;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.FileReader;
+import java.io.BufferedReader;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
 
-import CacheWolf.CWPoint;
-import CacheWolf.Common;
-import CacheWolf.CoordsScreen;
-import CacheWolf.Global;
-import CacheWolf.InfoBox;
-import CacheWolf.MyLocale;
-import CacheWolf.Preferences;
+import cachewolf.CWPoint;
+import cachewolf.CoordsScreen;
+import cachewolf.Global;
+import cachewolf.InfoBox;
+import cachewolf.MyLocale;
+import cachewolf.Preferences;
+import cachewolf.utils.Common;
 
+import eve.util.FormattedDataSource;
+import eve.util.mString;
+import eve.ui.event.ControlEvent;
+import eve.ui.game.InteractivePanel;
+
+
+import eve.util.ByteArray;
+
+
+
 /**
  *	This class is for importing and manually georeferencing maps
  *	This class id=4100 for cachewolf-languages
  */
 public class MapImporter extends Form {
 	Preferences pref;
-	String mapsPath = new String();
-	String thisMap = new String();
-	public String selectedMap = new String();
+	String mapsPath = &quot;&quot;;
+	String thisMap = &quot;&quot;;
+	public String selectedMap = &quot;&quot;;
 	CellPanel infPanel;
-	mLabel infLabel = new mLabel(&quot;                          &quot;);
+	Label infLabel = new Label(&quot;                          &quot;);
 	Vector GCPs = new Vector();
 	MapInfoObject wfl = new MapInfoObject();
-	mButton infButton;
+	Button infButton;
 	ScrollBarPanel scp;
 	AniImage mapImg;
 	int imageWidth, imageHeight = 0;
@@ -72,16 +90,14 @@
 		}catch(FileNotFoundException ex){
 			//	Vm.debug(&quot;Cannot load world file!&quot;);
 		}catch (IOException ex) { // is thrown if lat/lon out of range
-			MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, &quot;Error&quot;), ex.getMessage(), FormBase.OKB);
+			MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, &quot;Error&quot;), ex.getMessage(), MessageBox.OKB);
 			tmpMB.execute();
 			Vm.debug(&quot;Cannot load world file!&quot;);
 		}
 		mapInteractivePanel pane = new mapInteractivePanel(this);
-		scp = new CacheWolf.MyScrollBarPanel(pane);
-		Image img = new Image(Common.getImageName(mapsPath + thisMap));
-		PixelBuffer pB = new PixelBuffer(img);
+		scp = new cachewolf.MyScrollBarPanel(pane);
 		//pB = pB.scale((int)(pref.myAppWidth*0.98),(int)(pref.myAppHeight*0.98));
-		mapImg = new AniImage(pB.toDrawableImage());
+		mapImg = new AniImage(Common.getImageName(mapsPath + thisMap));
 		pane.addImage(mapImg);
 		scp.setPreferredSize(mapImg.getWidth(),mapImg.getHeight());
 		imageWidth = mapImg.getWidth();
@@ -89,7 +105,7 @@
 		this.addLast(scp.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
 		infPanel = new CellPanel();
 		infPanel.addNext(infLabel,CellConstants.STRETCH, CellConstants.FILL);
-		infButton = new mButton(MyLocale.getMsg(4107,&quot;Done!&quot;));
+		infButton = new Button(MyLocale.getMsg(4107,&quot;Done!&quot;));
 		infPanel.addLast(infButton,CellConstants.DONTSTRETCH, CellConstants.FILL);
 		this.addLast(infPanel, CellConstants.DONTSTRETCH, CellConstants.FILL);
 		//scp.repaintNow();
@@ -114,25 +130,25 @@
 	/**
 	 *	Method to copy (&quot;import&quot;) a png based map
 	 *	into the maps folder in the CacheWolf base directory.
-	 *	
+	 *
 	 *	If the maps directory does not exist it will create it.
 	 *	If it finds .map files it will assume these are oziexplorer calibration files.
 	 *	It will use these files to automatically georeference the files during import.
 	 */
 	public int importMap(){
-		String rawFileName = new String();
-		FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, Global.getPref().baseDir);
+		String rawFileName;
+		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir);
 		fc.addMask(&quot;*.png,*.gif,*.bmp,*.jpg&quot;);
-		fc.setTitle(MyLocale.getMsg(4100,&quot;Select Directory:&quot;));
-		int tmp = fc.execute() ; 
-		if(tmp != FormBase.IDYES) return FormBase.IDCANCEL;
+		fc.title=(MyLocale.getMsg(4100,&quot;Select Directory:&quot;));
+		int tmp = fc.execute() ;
+		if(tmp != FileChooser.IDYES) return Form.IDCANCEL;
 		File inDir = fc.getChosenFile();
 		File mapFile;
-		InfoBox inf = new InfoBox(&quot;Info&quot;, MyLocale.getMsg(4109,&quot;Loading maps...            \n&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false); 
+		InfoBox inf = new InfoBox(&quot;Info&quot;, MyLocale.getMsg(4109,&quot;Loading maps...            \n&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
 		inf.setPreferredSize(220, 300);
 		inf.setInfoHeight(100);
 		inf.relayout(false);
-		Vm.showWait(this, true);
+		Form.showWait();
 		inf.exec();
 
 		//User selected a map, but maybe there are more png(s)
@@ -140,14 +156,14 @@
 		//at the same time try to find associated .map files!
 		//These are georeference files targeted for OziExplorer.
 		//So lets check if we have more than 1 png file:
-		String line = new String();
+		String line = &quot;&quot;;
 		InputStream in = null;
 		OutputStream out = null;
-		FileReader inMap;
+		BufferedReader inMap;
 		byte[] buf;
 		int len;
 		String[] parts;
-		String [] files = inDir.listMultiple(&quot;*.png,*.jpg,*.gif,*.bmp&quot;, FileBase.LIST_FILES_ONLY);
+		String [] files = inDir.listMultiple(&quot;*.png,*.jpg,*.gif,*.bmp&quot;, File.LIST_FILES_ONLY);
 
 		String currfile = null;
 		String curInFullPath;
@@ -171,7 +187,7 @@
 					if (first) {
 						first = false;
 						header.copyFrom(buf, 0, len);
-						ImageInfo tmpII = Image.getImageInfo(header,null);
+						ImageInfo tmpII = Image.getImageInfo((new FormattedDataSource()).set(header),null);
 						imageWidth = tmpII.width;
 						imageHeight = tmpII.height;
 						out = new FileOutputStream(curOutFullPath); // only create outfile if geImageInfo didn't throw an exception so do it only here not directly after opening input stream
@@ -187,7 +203,7 @@
 			} finally {
 				try {
 					if (in != null) in.close();
-					if (out  != null) out.close(); 
+					if (out  != null) out.close();
 				} catch (Throwable e) {}
 			}
 			//Check for a .map file
@@ -201,7 +217,7 @@
 				GCPoint gcpG = new GCPoint();
 				//Vm.debug(&quot;Found file: &quot; + inDir.getFullPath() + &quot;/&quot; + rawFileName + &quot;.map&quot;);
 				try {
-					inMap = new FileReader(inDir.getFullPath() + &quot;/&quot; + rawFileName + &quot;.map&quot;);
+					inMap = new BufferedReader(new FileReader(inDir.getFullPath() + &quot;/&quot; + rawFileName + &quot;.map&quot;));
 					while((line = inMap.readLine()) != null){
 						if(line.equals(&quot;MMPNUM,4&quot;)){
 
@@ -300,17 +316,17 @@
 					inf.addWarning(&quot;\n&quot;+MyLocale.getMsg(4117, &quot;Error while importing .map-file: &quot;)+ex.getMessage());
 				} catch(IOException ex){
 					inf.addWarning(&quot;\n&quot;+MyLocale.getMsg(4118, &quot;IO-Error while reading or writing calibration file&quot;)+&quot;\n&quot; + ex.getMessage());
-				} 
+				}
 			} else { // if map file.exists
 				if (!imageerror) inf.addWarning(&quot;\n&quot;+MyLocale.getMsg(4119, &quot;No calibration file found for: &quot;) + currfile + &quot; - you can calibrate it manually&quot;);
 			}
 		} // for file
-		Vm.showWait(this, false);
+		Form.cancelWait();
 		inf.addText(&quot;\n&quot;+MyLocale.getMsg(4120, &quot;done.&quot;));
 		inf.addOkButton();
 		//inf.addOkButton(); doesn't work
-		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
-		return FormBase.IDOK;
+		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false;
+		return Form.IDOK;
 	}
 
 
@@ -330,13 +346,13 @@
 					try {
 						retry = false;
 						wfl.saveWFL(mapsPath, thisMap);
-						if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
+						if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false;
 					} catch (IOException e) {
-						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(321, &quot;Error writing file &quot;) + e.getMessage()+MyLocale.getMsg(324, &quot; - retry?&quot;), FormBase.YESB | FormBase.NOB);
-						if (tmpMB.execute() == FormBase.IDYES) retry = true;
+						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(321, &quot;Error writing file &quot;) + e.getMessage()+MyLocale.getMsg(324, &quot; - retry?&quot;), MessageBox.YESB | MessageBox.NOB);
+						if (tmpMB.execute() == MessageBox.IDYES) retry = true;
 					}catch (IllegalArgumentException e) {
-						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(325, &quot;Map not calibrated&quot;)+MyLocale.getMsg(324, &quot; - retry?&quot;), FormBase.YESB | FormBase.NOB);
-						if (tmpMB.execute() == FormBase.IDYES) { retry = true; break; }
+						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(325, &quot;Map not calibrated&quot;)+MyLocale.getMsg(324, &quot; - retry?&quot;), MessageBox.YESB | MessageBox.NOB);
+						if (tmpMB.execute() == MessageBox.IDYES) { retry = true; break; }
 					}
 				}
 				if (!retry) close(0);
@@ -370,20 +386,20 @@
 		g.drawLine(16,0,16,31);
 		AniImage aImg = new AniImage(img);
 		aImg.setLocation(pos.x-16,pos.y-16);
-		aImg.transparentColor = new Color(0,0,0);
-		//aImg.properties = mImage.IsNotHot;
-		aImg.properties = mImage.AlwaysOnTop;
+		//TODO How to set transparent color ? aImg.transparentColor = new Color(0,0,0);
+		//aImg.properties = Picture.IsNotHot;
+		aImg.properties = eve.fx.Drawing.AlwaysOnTop;
 		this.addImage(aImg);
 		g.free();
 		this.repaintNow();
 		f.updatePosition(pos.x, pos.y);
 
 		CoordsScreen cooS = new CoordsScreen(); // (String)lr.get(4108,&quot;Coordinates:&quot;), (String)lr.get(4108,&quot;Coordinates:&quot;), InfoBox.INPUT);
-		if (cooS.execute()==FormBase.IDOK) {
+		if (cooS.execute()==CoordsScreen.IDOK) {
 			GCPoint gcp = new GCPoint(cooS.getCoords());
 			gcp.bitMapX = pos.x;
 			gcp.bitMapY = pos.y;
-			f.addGCP(gcp); 
+			f.addGCP(gcp);
 		} else this.removeImage(aImg); // CANCEL pressed
 	}
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/MapInfoObject.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/MapInfoObject.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/MapInfoObject.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,24 +1,27 @@
-package CacheWolf.navi;
+package cachewolf.navi;
 
-import CacheWolf.CWPoint;
-import CacheWolf.Common;
-import CacheWolf.Matrix;
-import CacheWolf.MyLocale;
-import ewe.fx.Point;
-import ewe.io.BufferedWriter;
-import ewe.io.FileInputStream;
-import ewe.io.FileWriter;
-import ewe.io.File;
-import ewe.io.IOException;
-import ewe.io.InputStreamReader;
-import ewe.io.PrintWriter;
-import ewe.sys.*;
+import eve.fx.Point;
+import java.io.BufferedWriter;
+import java.io.FileInputStream;
+import java.io.FileWriter;
+import eve.io.File;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.BufferedReader;
+import java.io.PrintWriter;
+import eve.sys.*;
 import java.lang.Math;
 
-import utils.FileBugfix;
+import cachewolf.CWPoint;
+import cachewolf.MyLocale;
+import cachewolf.utils.Common;
+import cachewolf.utils.STRreplace;
+import cachewolf.utils.Matrix;
 
+
+
 /**
- * class to read, save and do the calculations for calibrated and 
+ * class to read, save and do the calculations for calibrated and
  * calibrating maps
  * start offset for language file: 4300
  * @author pfeffer
@@ -43,19 +46,19 @@
 	public float scale; // in meters per pixel, note: it is assumed that this scale identifying the scale of the map, automatically adjusted when zooming
 	public float zoomFactor = 1; // if the image is zoomed, direct after laoding always 1
 	public Point shift = new Point (0,0);
-	public CWPoint origAffineUpperLeft; // this is only valid after zooming 
+	public CWPoint origAffineUpperLeft; // this is only valid after zooming
 	public float rotationRad; // contains the rotation of the map == north direction in rad
 	/** full path to the respective worldfile, including &quot;.wfl&quot;*/
-	public String fileNameWFL = new String();
+	public String fileNameWFL = &quot;&quot;;
 	/** filename wihout directory */
 //	public String fileName = new String();
-	/** name of the map, introduced to allow 'maps' without an image (empty maps) */ 
-	public String mapName = new String();
+	/** name of the map, introduced to allow 'maps' without an image (empty maps) */
+	public String mapName = &quot;&quot;;
 	//private Character digSep = new Character(' ');
 	static private String digSep = MyLocale.getDigSeparator();
-	private int coordTrans = 0; 
+	private int coordTrans = 0;
 
-	public MapInfoObject() { }
+	public MapInfoObject() {}
 
 	public MapInfoObject(MapInfoObject map) {
 		super (map.topleft, map.buttomright);
@@ -107,7 +110,7 @@
 		mapName = name+&quot;.wfl&quot;;
 		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
 		double pixel2deg = meters2deg * scalei;
-		double pixel2deghorizontal = pixel2deg / java.lang.Math.cos(center.latDec*java.lang.Math.PI / 180); 
+		double pixel2deghorizontal = pixel2deg / java.lang.Math.cos(center.latDec*java.lang.Math.PI / 180);
 		affine[0]=0; //x2lat
 		affine[1]=pixel2deghorizontal; //x2lon
 		affine[2]=-pixel2deg; //y2lat
@@ -128,7 +131,7 @@
 	}
 
 	/**
-	 * 
+	 *
 	 * @param path including trailing &quot;/&quot;
 	 * @param n without &quot;.wfl&quot;
 	 * @return name of the map including fast-find-prefix
@@ -140,14 +143,14 @@
 		return mapName;
 	}
 
-	/** 
+	/**
 	 * @return the filename of the associated map image, &quot;&quot; if no file is associated, null if associated file could not be found
 	 */
 	public String getImageFilename() {
-		// if (fileName == null || fileName.length() &gt; 0) return fileName; 
+		// if (fileName == null || fileName.length() &gt; 0) return fileName;
 		if (fileNameWFL.length() == 0) return &quot;&quot;; // no image associated (empty map)
 		String n = fileNameWFL.substring(0, fileNameWFL.lastIndexOf(&quot;.&quot;));
-		return Common.getImageName(CacheWolf.STRreplace.replace(n, &quot;//&quot;, &quot;/&quot;));
+		return Common.getImageName(STRreplace.replace(n, &quot;//&quot;, &quot;/&quot;));
 	}
 
 	/**
@@ -159,10 +162,10 @@
 	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
 	 */
 	public void loadwfl(String mapsPath, String thisMap) throws IOException, ArithmeticException {
-		FileInputStream instream = new FileInputStream (CacheWolf.STRreplace.replace(mapsPath + thisMap + &quot;.wfl&quot;, &quot;//&quot;, &quot;/&quot;));
-		InputStreamReader in = new InputStreamReader(instream);
-		
-		String line = new String();
+		FileInputStream instream = new FileInputStream (STRreplace.replace(mapsPath + thisMap + &quot;.wfl&quot;, &quot;//&quot;, &quot;/&quot;));
+		BufferedReader in = new BufferedReader(new InputStreamReader(instream));
+
+		String line = &quot;&quot;;
 		try {
 			for(int i = 0; i&lt;4;i++){
 				line = in.readLine();
@@ -177,14 +180,16 @@
 			line = in.readLine();
 			buttomright.lonDec = Common.parseDoubleException(line);
 			line = in.readLine(); // readLine returns null, if End of File reached
-			if (line != null) coordTrans = Common.parseInt(line);
-			else coordTrans = 0;
+			if (line != null)
+				coordTrans = Common.parseInt(line);
+			else
+				coordTrans = 0;
 			fileNameWFL = mapsPath + thisMap + &quot;.wfl&quot;;
 //			fileName = &quot;&quot;; //mapsPath + thisMap + &quot;.png&quot;;
 			mapName = thisMap;
 			in.close();
 			if( !buttomright.isValid() ) {
-				affine[0] = 0; affine[1] = 0; affine[2] = 0; affine[3] = 0; 
+				affine[0] = 0; affine[1] = 0; affine[2] = 0; affine[3] = 0;
 				topleft.makeInvalid();
 				throw (new IOException(MyLocale.getMsg(4301, &quot;Lat/Lon out of range while reading &quot;)+mapsPath + thisMap + &quot;.wfl&quot;));
 			}
@@ -195,7 +200,7 @@
 		origAffineUpperLeft = new CWPoint(affineTopleft);
 	}
 
-	public void evalGCP(ewe.util.Vector GCPs, int imageWidth, int imageHeight) throws IllegalArgumentException {
+	public void evalGCP(java.util.Vector GCPs, int imageWidth, int imageHeight) throws IllegalArgumentException {
 		evalGCP(GCPs, imageWidth, imageHeight, 0);
 	}
 		/**
@@ -204,12 +209,12 @@
 	 *  @throws IllegalArgumentException when less than 3 georeferenced points were given in GCPs
 	 */
 
-	public void evalGCP(ewe.util.Vector GCPs, int imageWidth, int imageHeight, int epsg_code) throws IllegalArgumentException {
+	public void evalGCP(java.util.Vector GCPs, int imageWidth, int imageHeight, int epsg_code) throws IllegalArgumentException {
 		//N 48 16.000 E 11 32.000
 		//N 48 16.000 E 11 50.000
 		//N 48 9.000 E 11 32.000
 		if (GCPs.size() &lt; 3 ) throw new IllegalArgumentException(MyLocale.getMsg(4304, &quot;not enough points to calibrate the map&quot;));
-		GCPoint gcp = new GCPoint();
+		GCPoint gcp;
 		//Calculate parameters for latitutde affine transformation (affine 0,2,4)
 		Matrix X = new Matrix(GCPs.size(),3);
 		Matrix trg = new Matrix(GCPs.size(),1);
@@ -219,14 +224,14 @@
 			trg.matrix[i][0] = gcp.latDec;
 		}
 		Matrix Xtran = new Matrix(X);
-		Xtran.Transpose();
+		Xtran.transpose();
 		Matrix XtranX = new Matrix(Xtran);
-		XtranX.Multiply(X);
+		XtranX.multiply(X);
 		Matrix XtranXinv = new Matrix(XtranX);
-		XtranXinv.Inverse();
+		XtranXinv.inverse();
 		Matrix beta = new Matrix(XtranXinv);
-		beta.Multiply(Xtran);
-		beta.Multiply(trg);
+		beta.multiply(Xtran);
+		beta.multiply(trg);
 		affine[0] = beta.matrix[1][0];
 		affine[2] = beta.matrix[2][0];
 		affineTopleft.latDec = beta.matrix[0][0];
@@ -242,14 +247,14 @@
 			trg.matrix[i][0] = gcp.lonDec;
 		}
 		Xtran = new Matrix(X);
-		Xtran.Transpose();
+		Xtran.transpose();
 		XtranX = new Matrix(Xtran);
-		XtranX.Multiply(X);
+		XtranX.multiply(X);
 		XtranXinv = new Matrix(XtranX);
-		XtranXinv.Inverse();
+		XtranXinv.inverse();
 		beta = new Matrix(XtranXinv);
-		beta.Multiply(Xtran);
-		beta.Multiply(trg);
+		beta.multiply(Xtran);
+		beta.multiply(trg);
 		affine[1] = beta.matrix[1][0];
 		affine[3] = beta.matrix[2][0];
 		affineTopleft.lonDec = beta.matrix[0][0];
@@ -292,7 +297,7 @@
 	}
 
 	public void saveWFL() throws IOException, IllegalArgumentException {
-		File dateiF = new FileBugfix(fileNameWFL);
+		File dateiF = new File(fileNameWFL);
 		String tmp = dateiF.getDrivePath(); // contains the name and the extension
 		saveWFL(tmp, mapName);
 	}
@@ -305,7 +310,7 @@
 	 * @throws IllegalArgumentException when affine[x] for all x == 0 (&quot;map not calibrated&quot;).
 	 */
 	public void saveWFL(String mapsPath, String mapFileName) throws IOException, IllegalArgumentException {
-		if (affine[0]==0 &amp;&amp; affine[1]==0 &amp;&amp; affine[2]==0 &amp;&amp; affine[3]==0 &amp;&amp; 
+		if (affine[0]==0 &amp;&amp; affine[1]==0 &amp;&amp; affine[2]==0 &amp;&amp; affine[3]==0 &amp;&amp;
 				!topleft.isValid()) throw (new IllegalArgumentException(MyLocale.getMsg(4306, &quot;map not calibrated&quot;)));
 		PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(mapsPath + &quot;/&quot; + mapFileName + &quot;.wfl&quot;)));
 		StringBuffer towriteB=new StringBuffer(400);
@@ -338,18 +343,18 @@
 		// restore original values to calculate corret shift (upperleft)
 		affineTopleft.latDec = origAffineUpperLeft.latDec;
 		affineTopleft.lonDec = origAffineUpperLeft.lonDec;
-		affine[0] = affine[0] * zoomFactor; 
-		affine[1] = affine[1] * zoomFactor; 
+		affine[0] = affine[0] * zoomFactor;
+		affine[1] = affine[1] * zoomFactor;
 		affine[2] = affine[2] * zoomFactor;
 		affine[3] = affine[3] * zoomFactor;
 		TrackPoint upperleft = calcLatLon(diffX, diffY);
 		if (coordTrans != 0) upperleft = TransformCoordinatesProperties.fromWgs84(upperleft, coordTrans);
 		affineTopleft.latDec = upperleft.latDec; // TODO nachdenken affineTopleft
 		affineTopleft.lonDec = upperleft.lonDec;
-		affine[0] = affine[0] / zf ; 
-		affine[1] = affine[1] / zf ; 
-		affine[2] = affine[2] / zf ; 
-		affine[3] = affine[3] / zf ; 
+		affine[0] = affine[0] / zf ;
+		affine[1] = affine[1] / zf ;
+		affine[2] = affine[2] / zf ;
+		affine[3] = affine[3] / zf ;
 		zoomFactor = zf ;
 		shift.x = diffX;
 		shift.y = diffY;
@@ -368,11 +373,11 @@
 		if (coordTrans != 0) t = TransformCoordinatesProperties.fromWgs84(ll, coordTrans);
 		else t = ll;
 		Point coords = new Point();
-		double b0, b1;
+		double b0,b1;
 		b0 = t.latDec - affineTopleft.latDec;
 		b1 = t.lonDec - affineTopleft.lonDec;
-		double mapx = transLatX * b0 + transLonX * b1;
-		double mapy = transLatY * b0 + transLonY * b1;
+		double mapx = transLatX* b0 + transLonX*b1;
+		double mapy = transLatY* b0 + transLonY*b1;
 		coords.x = (int)Math.round(mapx);
 		coords.y = (int)Math.round(mapy);
 		//Vm.debug(&quot;mapX=mapx2: &quot;+mapx+&quot;=&quot;+mapx2+&quot;; mapy=mapy2: &quot;+mapy+&quot;=&quot;+mapy2);
@@ -393,7 +398,7 @@
 			ll = TransformCoordinatesProperties.toWgs84(ll, coordTrans);
 		return ll;
 	}
-	
+
 	public CWPoint calcLatLon(Point p) {
 		return calcLatLon(p.x, p.y);
 	}
@@ -401,7 +406,7 @@
 	/**
 	 * Get the prefix used for easy and fast finding of the best map
 	 * The filname of the .wfl and respective image should start with this
-	 * prefix in order to make finding the best map much faster 
+	 * prefix in order to make finding the best map much faster
 	 * @return
 	 */
 	public String getFfPrefix() {
@@ -425,7 +430,7 @@
 		}
 
 		/**
-		 * If you are using Gau&#223;-Kr&#252;ger, put lat = northing, lon = easting 
+		 * If you are using Gau&#223;-Kr&#252;ger, put lat = northing, lon = easting
 		 * @param lat
 		 * @param lon
 		 */
@@ -440,4 +445,3 @@
 			bitMapY = px.y;
 		}
 	}
-	
\ No newline at end of file

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/MapLoader.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/MapLoader.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/MapLoader.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,21 +1,26 @@
-package CacheWolf.navi;
+package cachewolf.navi;
 
-import CacheWolf.CWPoint;
-import CacheWolf.Common;
-import CacheWolf.HttpConnection;
-import CacheWolf.InfoBox;
-import CacheWolf.MyLocale;
-import CacheWolf.STRreplace;
-import ewe.ui.*;
-import ewe.io.*;
-import ewe.fx.*;
-import ewe.util.*;
-import ewe.sys.*;
-import ewe.net.*;
+import eve.ui.*;
+import eve.io.*;
+import eve.fx.*;
+import java.util.*;
+import eve.sys.*;
 import java.lang.Math;
+import java.net.Socket;
+import java.io.FileOutputStream;
+import java.io.FileInputStream;
+import eve.util.ByteArray;
+import java.io.IOException;
 
-import utils.FileBugfix;
+import cachewolf.CWPoint;
+import cachewolf.HttpConnection;
+import cachewolf.InfoBox;
+import cachewolf.MyLocale;
+import cachewolf.utils.Common;
+import cachewolf.utils.STRreplace;
 
+import eve.util.mString;
+
 /**
  *
  * start offset for language file: 4800
@@ -42,7 +47,7 @@
 	float tileScale;
 
 	/**
-	 * 
+	 *
 	 * @param prxy
 	 * @param prt
 	 * @param wmspath without trailing &quot;/&quot;
@@ -54,32 +59,32 @@
 
 		onlineMapServices = new Vector();
 		String dateien[];
-		FileBugfix files = new FileBugfix(wmspath);
+		File files = new File(wmspath);
 		String FileName;
 		OnlineMapService tempOMS;
-		MessageBox f = null; 
-		dateien = files.list(&quot;*.wms&quot;, FileBase.LIST_FILES_ONLY); //&quot;*.xyz&quot; doesn't work on some systems -&gt; use FileBugFix
+		MessageBox f = null;
+		dateien = files.list(&quot;*.wms&quot;, File.LIST_FILES_ONLY); //&quot;*.xyz&quot; doesn't work on some systems -&gt; use FileBugFix
 		for(int i = 0; i &lt; dateien.length;i++){
 			FileName = dateien[i];
 			try {
 				if (!showprogress &amp;&amp; ((i &amp; 0) == 0) &amp;&amp; (new Time().getTime()-start  &gt; 100) ) { // reason for (i &amp; 7 == 0): test time only after i is incremented 15 times
-					showprogress = true;      
+					showprogress = true;
 					progressBox = new InfoBox(MyLocale.getMsg(327, &quot;Info&quot;), MyLocale.getMsg(4800, &quot;Loading online map services&quot;));
-					progressBox.exec(); 
-					progressBox.waitUntilPainted(500);
-					ewe.sys.Vm.showWait(true);
+					progressBox.exec();
+					progressBox.getWindow().waitUntilPainted(500);
+					eve.ui.Form.showWait();
 				}
 				tempOMS = new WebMapService(STRreplace.replace(wmspath + &quot;/&quot; + FileName, &quot;//&quot;, &quot;/&quot;));
 				onlineMapServices.add(tempOMS);
-			}catch(Exception ex){ 
-				if (f == null) (f=new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(4801, &quot;Ignoring error while \n reading web map service definition file \n&quot;)+ex.toString(), FormBase.OKB)).exec();
+			}catch(Exception ex){
+				if (f == null) (f=new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(4801, &quot;Ignoring error while \n reading web map service definition file \n&quot;)+ex.toString(), MessageBox.OKB)).exec();
 			}
 		}
 		tempOMS = new ExpediaMapService();
 		onlineMapServices.add(tempOMS);
 		if (progressBox != null) {
 			progressBox.close(0);
-			ewe.sys.Vm.showWait(false);
+			eve.ui.Form.cancelWait();
 		}
 	}
 
@@ -112,7 +117,7 @@
 	}
 
 	/**
-	 * download maps from expedia at zoomlevel alti and save the maps and the .wfl 
+	 * download maps from expedia at zoomlevel alti and save the maps and the .wfl
 	 * in path
 	 * @param center centre of all tiles
 	 * @param radius in meters
@@ -120,7 +125,7 @@
 	 * @param size in pixels
 	 * @param overlapping in pixels
 	 * @param path without &quot;/&quot; at the end
-	 * 
+	 *
 	 */
 	public void setTiles (CWPoint center, float radius, float scale, Point size, int overlapping) {
 		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
@@ -142,8 +147,8 @@
 		double pixelsPerLon = metersPerLon / metersperpixel;
 
 		//over all pixelsize without borders
-		double pixelsY = (topleft.latDec - buttomright.latDec) * pixelsPerLat; 
-		double pixelsX = -(topleft.lonDec - buttomright.lonDec) * pixelsPerLon ; 
+		double pixelsY = (topleft.latDec - buttomright.latDec) * pixelsPerLat;
+		double pixelsX = -(topleft.lonDec - buttomright.lonDec) * pixelsPerLon ;
 
 		//border sizes around given area and overlapping between tiles
 		//int borderX = (int) java.lang.Math.round((float)size.x * (overlapping - 1.0));
@@ -151,8 +156,8 @@
 		int borderX = overlapping;
 		int borderY = overlapping;
 
-		numMapsY = (int) java.lang.Math.ceil( (pixelsY + borderY) / (size.y - borderY) );
-		numMapsX = (int) java.lang.Math.ceil( (pixelsX + borderX) / (size.x - borderX) );
+		numMapsY = (int) java.lang.Math.ceil( (pixelsY + borderY) / (float)(size.y - borderY) );
+		numMapsX = (int) java.lang.Math.ceil( (pixelsX + borderX) / (float)(size.x - borderX) );
 
 		//increments calulated from pixel offset of tiles
 		latinc = -(size.y - borderY) / pixelsPerLat;
@@ -202,7 +207,7 @@
 		progressInfobox = progrssInfoboxi;
 	}
 	/**
-	 * 
+	 *
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -219,16 +224,16 @@
 	}
 
 	public String createFilename(CWPoint center, float scale) {
-		String filename = Common.ClearForFileName(currentOnlineMapService.getNameForFileSystem()+&quot;_s&quot;+Common.DoubleToString(scale, 1)
+		String filename = Common.clearForFileName(currentOnlineMapService.getNameForFileSystem()+&quot;_s&quot;+Common.doubleToString(scale, 1)
 				+ &quot;_c&quot; + center.toString(CWPoint.LAT_LON).replace(',', '-'));
 		return filename;
 	}
 
 	/**
-	 * @param url usual URL. If a redirect is requiered (as in the case of 
+	 * @param url usual URL. If a redirect is requiered (as in the case of
 	 * Expedia, add an &quot;R&quot; before &quot;<A HREF="http://">http://</A>&quot; --&gt; Don't download the url, retry until getting a http-redirect
 	 * this is necessary for expedia as it delivers the image only after a http-redirect
-	 * and sometimes doesn't send a redirect on the first try 
+	 * and sometimes doesn't send a redirect on the first try
 	 * @param datei path and name of file to save to
 	 */
 	public void downloadImage(String url, String datei) throws IOException {
@@ -251,7 +256,7 @@
 	//	this prevents gdz1.leipzig.ifag.de (dtk100) from answering and ist not necessary for expedia connImg.setRequestorProperty(&quot;Cookie&quot;, &quot;jscript=1; path=/;&quot;);
 		connImg.documentIsEncoded = true;
 		try{
-			File dateiF = new FileBugfix(datei);
+			java.io.File dateiF = new java.io.File(datei);
 			if(!dateiF.exists()){
 				int i=0;
 				sockImg = connImg.connect();
@@ -274,10 +279,10 @@
 					String tmp = connImg.readText(sockImg, null).toString(); // TODO if the content is binary will will get an Exception in InfoBox, trying to display the content
 					tmp = tmp.substring(0, (tmp.length() &lt; 1000 ? tmp.length() : 1000));
 					sockImg.close();
-					throw new IOException(MyLocale.getMsg(4808, &quot;downloadImage: content-type:&quot;)+&quot; &quot; + ct + MyLocale.getMsg(4809, &quot; is not an image, begin of content:&quot;)+&quot; &quot; + tmp); 
+					throw new IOException(MyLocale.getMsg(4808, &quot;downloadImage: content-type:&quot;)+&quot; &quot; + ct + MyLocale.getMsg(4809, &quot; is not an image, begin of content:&quot;)+&quot; &quot; + tmp);
 				}
 				daten = connImg.readData(sockImg);
-				fos = new FileOutputStream(datei); // note: using the constructor (File) instead of (String) will cause not to use the fake file system
+				fos = new FileOutputStream(datei);
 				fos.write(daten.toBytes());
 				fos.close();
 				sockImg.close();
@@ -296,7 +301,7 @@
 	String name;
 	/** Type of map (used as directory name when downloading maps. We currently have &quot;topo&quot; and &quot;photo&quot; defined as map types */
 	String mapType;
-	/** Esentially the same as name, but used for the file system. It will be part of the names of the downloaded images */ 
+	/** Esentially the same as name, but used for the file system. It will be part of the names of the downloaded images */
 	String filename;
 	String MainUrl; //<A HREF="http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS">http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS</A>
 	/** including &quot;.&quot; */
@@ -306,11 +311,11 @@
 	double maxscale;
 	Area boundingBox;
 
-	/** 
-	 * This method is used in case the online map service provides only certain steps of 
+	/**
+	 * This method is used in case the online map service provides only certain steps of
 	 * zoomlevels. In this case the scale in meters per pixel must be returned, which
-	 * will be used instead of the wished scale. 
-	 * 
+	 * will be used instead of the wished scale.
+	 *
 	 * @param scale
 	 * @return
 	 */
@@ -322,7 +327,7 @@
 		return imageFileExt;
 	}
 
-	/** 
+	/**
 	 * Overlaod this to integrate name of layers
 	 * @return friendly service name
 	 */
@@ -330,8 +335,8 @@
 		return name;
 	}
 
-	/** 
-	 * This method is called to get a name of the 
+	/**
+	 * This method is called to get a name of the
 	 * online map service which will be part of the filename
 	 * used for the downloaded image
 	 * @return friendly service name
@@ -386,11 +391,11 @@
 		return bbox;
 	}
 
-	
+
 	protected MapInfoObject getMapInfoObjectInternal(Area maparea, Point pixelsize) {
 		throw new IllegalArgumentException(MyLocale.getMsg(4811, &quot;OnlineMapService: getMapInfoObjectInternal(Area maparea, Point pixelsize):\n This method must be overloaded in order to be able to use it&quot;));
 	}
-	
+
 	/**
 	 * Overload this (don't call super()) or alternatively overload getMapInfoObjectInternal
 	 * @param center
@@ -410,8 +415,8 @@
 class WebMapService extends OnlineMapService {
 	String layersUrlPart; //
 	String versionUrlPart; // VERSION=1.1.0
-	String serviceTypeUrlPart; //&quot;SERVICE=WMS&quot; 
-	int coordinateReferenceSystem[]; // WGS84: 4326, German GK: 31466 / 
+	String serviceTypeUrlPart; //&quot;SERVICE=WMS&quot;
+	int coordinateReferenceSystem[]; // WGS84: 4326, German GK: 31466 /
 	String coordinateReferenceSystemUrlPart[]; //&amp;SRS=EPSG:31466
 	String requestUrlPart;
 	String imageFormatUrlPart; // FORMAT=image/png
@@ -420,7 +425,7 @@
 	double maxscaleWMS;
 
 	/**
-	 * 
+	 *
 	 * @param filename without file extension
 	 * @throws IOException
 	 * @throws IllegalArgumentException
@@ -430,7 +435,7 @@
 		Properties wms = new Properties();
 		wms.load(in);
 		in.close();
-		String tmp = FileBase.getFileExt(filename_);
+		String tmp = File.getFileExt(filename_);
 		this.filename = tmp.substring(0, tmp.lastIndexOf('.'));
 		name = wms.getProperty(&quot;Name&quot;, &quot;&quot;).trim();
 		if (name == &quot;&quot;) throw new IllegalArgumentException(MyLocale.getMsg(4812, &quot;WebMapService: property &gt;Name:&lt; missing in file:\n&quot;) + filename);
@@ -481,7 +486,7 @@
 	private static final int TOPRIGHT_INDEX = 2;
 	private static final int BUTTOMLEFT_INDEX = 3;
 	/**
-	 * 
+	 *
 	 * @param maparea
 	 * @return [0] = topleft, [1] = buttomright, [2] = topright, [3] = buttomleft
 	 */
@@ -499,7 +504,7 @@
 		//Vm.debug(&quot;rot right direkt: &quot; + TransformCoordinates.GkToWgs84(ret[TOPRIGHT_INDEX], region).getBearing(TransformCoordinates.GkToWgs84(ret[BUTTOMRIGHT_INDEX], region)));
 		//ret[2] = TransformCoordinates.wgs84ToGermanGk(topright, coordinateReferenceSystem[crs]);
 		//ret[3] = TransformCoordinates.wgs84ToGermanGk(buttomleft, coordinateReferenceSystem[crs]);
-		return ret;	
+		return ret;
 	}
 	public Area CenterScaleToArea(CWPoint center, float scale, Point pixelsize) {
 		Area bbox = new Area();
@@ -536,13 +541,13 @@
 		// <A HREF="http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS&amp;VERSION=1.1.0&amp;REQUEST=GetMap&amp;SRS=EPSG:31466&amp;BBOX=2577567.0149,5607721.7566,2578567.0077,5608721.7602&amp;WIDTH=500&amp;HEIGHT=500&amp;LAYERS=Raster:TK25_KMF:Farbkombination&amp;STYLES=&amp;FORMAT=image/png">http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS&amp;VERSION=1.1.0&amp;REQUEST=GetMap&amp;SRS=EPSG:31466&amp;BBOX=2577567.0149,5607721.7566,2578567.0077,5608721.7602&amp;WIDTH=500&amp;HEIGHT=500&amp;LAYERS=Raster:TK25_KMF:Farbkombination&amp;STYLES=&amp;FORMAT=image/png</A>
 		CWPoint buttomleft = new CWPoint (maparea.buttomright.latDec, maparea.topleft.lonDec);
 		CWPoint topright = new CWPoint (maparea.topleft.latDec, maparea.buttomright.lonDec);
-		double scaleh = maparea.buttomright.getDistance(buttomleft) * 1000 / pixelsize.x; 
-		double scalev = maparea.topleft.getDistance(topright) * 1000 / pixelsize.y; 
+		double scaleh = maparea.buttomright.getDistance(buttomleft) * 1000 / pixelsize.x;
+		double scalev = maparea.topleft.getDistance(topright) * 1000 / pixelsize.y;
 		double scale = Math.sqrt(scaleh * scaleh + scalev * scalev); // meters per pixel measured diagonal
 		if ( scale &lt; minscaleWMS || scale &gt; maxscaleWMS ) throw new IllegalArgumentException(MyLocale.getMsg(4825, &quot;scale&quot;)+&quot; &quot; + scale / Math.sqrt(2)+ MyLocale.getMsg(4826, &quot; not supported by online map service, supported scale range:&quot;)+&quot; &quot; + minscale + &quot; - &quot; + maxscale + MyLocale.getMsg(4827, &quot; (measured in meters per pixel vertically)&quot;));
 		int crs = 0;
 		String bbox = &quot;BBOX=&quot;;
-		int region = TransformCoordinates.getGkRegion(coordinateReferenceSystem[0]); 
+		int region = TransformCoordinates.getGkRegion(coordinateReferenceSystem[0]);
 		if (region &gt; 0) {
 			crs = getCrs(maparea.getCenter());
 			GkPoint[] gk = getGkArea(maparea);
@@ -550,12 +555,12 @@
 			topright = TransformCoordinates.GkToWgs84(gk[TOPRIGHT_INDEX], region);
 			bbox += TransformCoordinates.wgs84ToGaussKrueger(buttomleft, coordinateReferenceSystem[crs]).toString(2, &quot;&quot;, &quot;,&quot;, region);
 			bbox += &quot;,&quot; + TransformCoordinates.wgs84ToGaussKrueger(topright, coordinateReferenceSystem[crs]).toString(2, &quot;&quot;, &quot;,&quot;, region);
-		} else if (coordinateReferenceSystem[0] == TransformCoordinates.EPSG_WGS84) 
+		} else if (coordinateReferenceSystem[0] == TransformCoordinates.EPSG_WGS84)
 			bbox += buttomleft.toString(CWPoint.LON_LAT)  + &quot;,&quot; + topright.toString(CWPoint.LON_LAT);
 		else throw new IllegalArgumentException(MyLocale.getMsg(4828, &quot;Coordinate system not supported by cachewolf:&quot;)+&quot; &quot; + coordinateReferenceSystem.toString());
-		String ret = MainUrl + &quot;SERVICE=WMS&quot; + &quot;&amp;&quot;+ versionUrlPart + &quot;&amp;&quot; + requestUrlPart + &quot;&amp;&quot; + 
-		coordinateReferenceSystemUrlPart[crs] + &quot;&amp;&quot; + bbox + 
-		&quot;&amp;WIDTH=&quot; + pixelsize.x + &quot;&amp;HEIGHT=&quot; + pixelsize.y + &quot;&amp;&quot; + 
+		String ret = MainUrl + &quot;SERVICE=WMS&quot; + &quot;&amp;&quot;+ versionUrlPart + &quot;&amp;&quot; + requestUrlPart + &quot;&amp;&quot; +
+		coordinateReferenceSystemUrlPart[crs] + &quot;&amp;&quot; + bbox +
+		&quot;&amp;WIDTH=&quot; + pixelsize.x + &quot;&amp;HEIGHT=&quot; + pixelsize.y + &quot;&amp;&quot; +
 		layersUrlPart + &quot;&amp;&quot; + stylesUrlPart + &quot;&amp;&quot; + imageFormatUrlPart;
 		Vm.debug(ret);
 		return ret;
@@ -565,7 +570,7 @@
 	 * This method gives the number in the arrays of coordinateReferenceSystems, which should be used
 	 * a) if only one is in the array 0 is returned
 	 * b) if there are more, find out which one matches the correct Gau&#223;-K&#252;ger stripe
-	 * Call this routine with center of the area (use Area.getcenter()) 
+	 * Call this routine witch the center of the area (use Area.getcenter())
 	 * @param p Point for which the epsg code is searched for
 	 * @return
 	 */
@@ -589,9 +594,9 @@
 		CWPoint topright = new CWPoint (maparea.topleft.latDec, maparea.buttomright.lonDec);
 		CWPoint topleft = new CWPoint(maparea.topleft);
 		CWPoint buttomright = new CWPoint(maparea.buttomright);
-		double metersperpixalhorizontal = ( buttomright.getDistance(buttomleft) + topleft.getDistance(topright))/2 * 1000 / pixelsize.x; 
+		double metersperpixalhorizontal = ( buttomright.getDistance(buttomleft) + topleft.getDistance(topright))/2 * 1000 / pixelsize.x;
 		double metersperpixalvertical = ( buttomright.getDistance(topright) + topleft.getDistance(buttomleft))/2 * 1000 / pixelsize.y;
-		int region = TransformCoordinates.getGkRegion(coordinateReferenceSystem[0]); 
+		int region = TransformCoordinates.getGkRegion(coordinateReferenceSystem[0]);
 		if ( region &gt; 0) {
 			GkPoint[] gk = getGkArea(maparea);
 			// bounding box in WMS is defined around the pixels, not exactly on the pixels --&gt; the bounding box must be reduced on all edges by half a pixel
@@ -640,19 +645,19 @@
 
 class ExpediaMapService extends OnlineMapService {
 	/*
-	 * information from: DownloadMouseMode.properties in project GPSylon ( in directory gpsylon_src-0.5.2\plugins\downloadmousemode\auxiliary\org\dinopolis\gpstool\plugin\downloadmousemode and DownloadMapCalculator.java in Dir gpsylon_src-0.5.2\plugins\downloadmousemode\src\org\dinopolis\gpstool\plugin\downloadmousemode 
+	 * information from: DownloadMouseMode.properties in project GPSylon ( in directory gpsylon_src-0.5.2\plugins\downloadmousemode\auxiliary\org\dinopolis\gpstool\plugin\downloadmousemode and DownloadMapCalculator.java in Dir gpsylon_src-0.5.2\plugins\downloadmousemode\src\org\dinopolis\gpstool\plugin\downloadmousemode
 	 * download.map.url.expedia_east=http\://www.expedia.com/pub/agent.dll?qscr=mrdt&amp;ID=3XNsF.&amp;CenP={0,number,#.########},{1,number,#.########}&amp;Lang=EUR0809&amp;Alti={2,number,#}&amp;Size={3,number,#},{4,number,#}&amp;Offs=0.000000,0.000000\&amp;BCheck=1
 	 * download.map.url.expedia_east.title=Url of Expedia Europe
 	 * download.map.scale_factor.expedia_east=3950
 	 */
 	final static float downloadMapScaleFactorExpedia_east = 3950;
 	final static float MAPBLAST_METERS_PER_PIXEL = 1.0f/2817.947378f;
-	final static float EXPEDIA_METERS_PER_PIXEL = downloadMapScaleFactorExpedia_east * MAPBLAST_METERS_PER_PIXEL; 
+	final static float EXPEDIA_METERS_PER_PIXEL = downloadMapScaleFactorExpedia_east * MAPBLAST_METERS_PER_PIXEL;
 
 	public ExpediaMapService() {
 		name = &quot;Expedia&quot;;
 		filename = &quot;expedia&quot;;
-		MainUrl = &quot;<A HREF="Rhttp://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.">Rhttp://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.</A>&quot;; //&quot;<A HREF="Rhttp://">Rhttp://</A>&quot; forces doenloadUrl to retry the URL until it gets an http-redirect and then downloads from there 
+		MainUrl = &quot;<A HREF="Rhttp://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.">Rhttp://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.</A>&quot;; //&quot;<A HREF="Rhttp://">Rhttp://</A>&quot; forces doenloadUrl to retry the URL until it gets an http-redirect and then downloads from there
 		imageFileExt = &quot;.gif&quot;;
 		mapType = &quot;expedia&quot;;
 		recommendedScale = 5;
@@ -662,9 +667,9 @@
 	}
 
 	public float getMetersPerPixel(float scale) {
-		return EXPEDIA_METERS_PER_PIXEL * getZoomlevel(scale);
+		return  EXPEDIA_METERS_PER_PIXEL * getZoomlevel(scale);
 	}
-	
+
 	private int getZoomlevel(float scale) {
 		return (int)(Math.ceil(scale / EXPEDIA_METERS_PER_PIXEL));
 	}
@@ -672,8 +677,7 @@
 	public String getUrlForCenterScale(CWPoint center, float scale, Point pixelsize) {
 		int zoomlevel = getZoomlevel(scale);
 		String zone;
-		if (     (center.lonDec &lt;= -30   &amp;&amp; center.lonDec &gt;= -170) || 
-				( center.lonDec &gt; 360-30 &amp;&amp; center.lonDec &lt;= 360-170) ) zone = &quot;USA0409&quot;; // TODO test which zone-code ist best for asia
+		if (center.lonDec &lt;= -10) zone = &quot;USA0409&quot;;
 		else zone = &quot;EUR0809&quot;;
 		String quelle = MainUrl + &quot;&amp;CenP=&quot; + center.toString(CWPoint.LAT_LON);
 		quelle = quelle + &quot;&amp;Alti=&quot;+Convert.toString(zoomlevel)+&quot;&amp;Lang=&quot;+zone+&quot;&amp;Size=&quot;+Convert.toString(pixelsize.x)+&quot;,&quot;+Convert.toString(pixelsize.y)+&quot;&amp;Offs=0,0&amp;MapS=0&quot;; //&amp;Pins=|&quot; + latD.toString().replace(',', '.') + &quot;,&quot; + lonD.toString().replace(',', '.') + &quot;|5|&quot;;

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/MapLoaderGui.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/MapLoaderGui.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/MapLoaderGui.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,19 +1,23 @@
-package CacheWolf.navi;
+package cachewolf.navi;
 
-import CacheWolf.CWPoint;
-import CacheWolf.CacheHolder;
-import CacheWolf.CoordsScreen;
-import CacheWolf.Global;
-import CacheWolf.InfoBox;
-import CacheWolf.MyLocale;
-import CacheWolf.NewProfileWizard;
-import CacheWolf.Preferences;
-import ewe.io.FileBase;
-import ewe.sys.Convert;
-import ewe.sys.Vm;
-import ewe.ui.*;
-import ewe.util.Vector;
+import eve.io.File;
+import eve.sys.Convert;
+import eve.ui.*;
+import java.util.Vector;
 
+import cachewolf.CWPoint;
+import cachewolf.CacheHolder;
+import cachewolf.CoordsScreen;
+import cachewolf.Global;
+import cachewolf.InfoBox;
+import cachewolf.MyLocale;
+import cachewolf.Preferences;
+
+import eve.ui.event.ControlEvent;
+import eve.sys.Event;
+import eve.ui.event.DataChangeEvent;
+import eve.fx.gui.IKeys;
+
 /**
  * @author pfeffer
  * This Class is the Dialog for Download calibrated from expedia.com
@@ -22,30 +26,30 @@
  */
 
 public class MapLoaderGui extends Form {
-	mButton cancelB, okBtiles, okBPerCache, cancelBPerCache;
+	Button cancelB, okBtiles, okBPerCache, cancelBPerCache;
 	Preferences pref;
-	mTabbedPanel mTab = new mTabbedPanel();
+	TabbedPanel mTab = new TabbedPanel();
 	CellPanel pnlTiles = new CellPanel();
 	CellPanel pnlPerCache = new CellPanel();
 
 	final String descString = MyLocale.getMsg(1802,&quot;Download georeferenced maps\n Select online service:&quot;);
-	mChoice mapServiceChoice;
-	mCheckBox forCachesChkBox = new mCheckBox(MyLocale.getMsg(1803,&quot;for&quot;));
-	mChoice forSelectedChkBox = new mChoice(new String[] {MyLocale.getMsg(1804,&quot;all&quot;), MyLocale.getMsg(1805,&quot;selected&quot;)}, 0);
-	mChoice forSelectedChkBoxPerCache = new mChoice(new String[] {MyLocale.getMsg(1804,&quot;all&quot;), MyLocale.getMsg(1805,&quot;selected&quot;)}, 1);
-	mLabel cachesLbl = new mLabel(MyLocale.getMsg(1806,&quot;caches&quot;));
-	mInput distanceInput;
-	mLabel distLbl;
-	mLabel km = new mLabel(&quot;km&quot;);
-	mLabel coosLbl;
-	mButton coosBtn;
-	mLabel scaleLbl = new mLabel(MyLocale.getMsg(1807,&quot;Approx. m per pixel:&quot;));
-	mInput scaleInput = new mInput (&quot;3&quot;);
-	mInput scaleInputPerCache = new mInput (&quot;1&quot;);
-	mLabel overlappingLbl = new mLabel(MyLocale.getMsg(1808,&quot;overlapping in pixel:&quot;));
-	mInput overlappingInput = new mInput(&quot;100&quot;);
-	mCheckBox overviewChkBox = new mCheckBox(MyLocale.getMsg(1809,&quot;download an overview map&quot;));
-	mCheckBox overviewChkBoxPerCache = new mCheckBox(MyLocale.getMsg(1809,&quot;download an overview map&quot;));
+	Choice mapServiceChoice;
+	CheckBox forCachesChkBox = new CheckBox(MyLocale.getMsg(1803,&quot;for&quot;));
+	Choice forSelectedChkBox = new Choice(new String[] {MyLocale.getMsg(1804,&quot;all&quot;), MyLocale.getMsg(1805,&quot;selected&quot;)}, 0);
+	Choice forSelectedChkBoxPerCache = new Choice(new String[] {MyLocale.getMsg(1804,&quot;all&quot;), MyLocale.getMsg(1805,&quot;selected&quot;)}, 1);
+	Label cachesLbl = new Label(MyLocale.getMsg(1806,&quot;caches&quot;));
+	Input distanceInput;
+	Label distLbl;
+	Label km = new Label(&quot;km&quot;);
+	Label coosLbl;
+	Button coosBtn;
+	Label scaleLbl = new Label(MyLocale.getMsg(1807,&quot;Approx. m per pixel:&quot;));
+	Input scaleInput = new Input (&quot;3&quot;);
+	Input scaleInputPerCache = new Input (&quot;1&quot;);
+	Label overlappingLbl = new Label(MyLocale.getMsg(1808,&quot;overlapping in pixel:&quot;));
+	Input overlappingInput = new Input(&quot;100&quot;);
+	CheckBox overviewChkBox = new CheckBox(MyLocale.getMsg(1809,&quot;download an overview map&quot;));
+	CheckBox overviewChkBoxPerCache = new CheckBox(MyLocale.getMsg(1809,&quot;download an overview map&quot;));
 
 	MapLoader mapLoader;
 	String[] unsortedMapServices;
@@ -60,7 +64,7 @@
 	float scale;
 	int overlapping;
 	boolean overviewmap;
-	int numCaches;
+	//int numCaches;
 
 	public MapLoaderGui(Vector cacheDBi) {
 		super();
@@ -68,30 +72,30 @@
 		pref = Global.getPref(); // myPreferences sollte sp&#228;ter auch diese Einstellungen speichern
 		center = new CWPoint(pref.curCentrePt);
 		cacheDB = cacheDBi;
-		mapLoader = new MapLoader(FileBase.getProgramDirectory()+&quot;/&quot;+&quot;webmapservices&quot;);
+		mapLoader = new MapLoader(File.getProgramDirectory()+&quot;/&quot;+&quot;webmapservices&quot;);
 
 		// sort the items in the list of services in a way that services which cover the current center point.
 		unsortedMapServices = mapLoader.getAvailableOnlineMapServices();
 		sortMapServices();
-		mapServiceChoice = new mChoice(sortedmapServices, 0);
+		mapServiceChoice = new Choice(sortedmapServices, 0);
 		MessageArea desc = new MessageArea(descString); 
-		desc.modifyAll(ControlConstants.NotEditable | ControlConstants.DisplayOnly | ControlConstants.NoFocus, ControlConstants.TakesKeyFocus);
-		desc.borderStyle = UIConstants.BDR_NOBORDER;
+		desc.modifyAll(TextPad.NotEditable | TextPad.DisplayOnly | TextPad.NoFocus, TextPad.TakesKeyFocus);
+		desc.borderStyle = TextPad.BDR_NOBORDER;
 		this.addLast(desc);
 		this.addLast(mapServiceChoice);
 		// tiles panel
 		pnlTiles.addNext(forCachesChkBox);
 		pnlTiles.addNext(forSelectedChkBox);
 		pnlTiles.addLast(cachesLbl);
-		pnlTiles.addNext(distLbl = new mLabel(MyLocale.getMsg(1810,&quot;Within a rectangle of:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		distanceInput = new mInput();
+		pnlTiles.addNext(distLbl = new Label(MyLocale.getMsg(1810,&quot;Within a rectangle of:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		distanceInput = new Input();
 		int tmp = Convert.toInt((Global.getProfile().distOC));
 		tmp = java.lang.Math.max(tmp, Convert.toInt((Global.getProfile().distGC)));
 		distanceInput.setText(Convert.toString((tmp &gt; 0 ? tmp : 15)));
 		pnlTiles.addNext(distanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		pnlTiles.addLast(km);
-		pnlTiles.addNext(coosLbl = new mLabel(MyLocale.getMsg(1811, &quot;around the centre:&quot;)+&quot; &quot;));
-		pnlTiles.addLast(coosBtn = new mButton(center.toString()));
+		pnlTiles.addNext(coosLbl = new Label(MyLocale.getMsg(1811, &quot;around the centre:&quot;)+&quot; &quot;));
+		pnlTiles.addLast(coosBtn = new Button(center.toString()));
 		pnlTiles.addNext(scaleLbl);
 		mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
 		scaleInput.setText(Convert.toString(mapLoader.currentOnlineMapService.recommendedScale));
@@ -103,10 +107,10 @@
 		pnlTiles.addLast(overlappingInput);
 		overviewChkBox.setState(true);
 		pnlTiles.addLast(overviewChkBox);
-		cancelB = new mButton(MyLocale.getMsg(1604,&quot;Cancel&quot;));
+		cancelB = new Button(MyLocale.getMsg(1604,&quot;Cancel&quot;));
 		cancelB.setHotKey(0, IKeys.ESCAPE);
 		pnlTiles.addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		okBtiles = new mButton(MyLocale.getMsg(1605,&quot;OK&quot;));
+		okBtiles = new Button(MyLocale.getMsg(1605,&quot;OK&quot;));
 		okBtiles.setHotKey(0, IKeys.ACTION);
 		okBtiles.setHotKey(0, IKeys.ENTER);
 		pnlTiles.addLast(okBtiles,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
@@ -114,16 +118,16 @@
 		mTab.addCard(pnlTiles, MyLocale.getMsg(1812, &quot;Tiles&quot;), MyLocale.getMsg(1812, &quot;Tiles&quot;));
 
 		// per cache panel
-		pnlPerCache.addNext(new mLabel(MyLocale.getMsg(1813, &quot;Download one map for&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addNext(new Label(MyLocale.getMsg(1813, &quot;Download one map for&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
 		pnlPerCache.addNext(forSelectedChkBoxPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
-		pnlPerCache.addLast(new mLabel(MyLocale.getMsg(1806, &quot;caches&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
-		pnlPerCache.addNext(new mLabel(MyLocale.getMsg(1807, &quot;Approx. m per pixel&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addLast(new Label(MyLocale.getMsg(1806, &quot;caches&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addNext(new Label(MyLocale.getMsg(1807, &quot;Approx. m per pixel&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
 		pnlPerCache.addLast(scaleInputPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
 
-		cancelBPerCache = new mButton(MyLocale.getMsg(1604,&quot;Cancel&quot;));
+		cancelBPerCache = new Button(MyLocale.getMsg(1604,&quot;Cancel&quot;));
 		cancelBPerCache.setHotKey(0, IKeys.ESCAPE);
 		pnlPerCache.addNext(cancelBPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
-		okBPerCache = new mButton(MyLocale.getMsg(1605,&quot;OK&quot;));
+		okBPerCache = new Button(MyLocale.getMsg(1605,&quot;OK&quot;));
 		okBPerCache.setHotKey(0, IKeys.ACTION);
 		okBPerCache.setHotKey(0, IKeys.ENTER);
 		pnlPerCache.addLast(okBPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
@@ -181,13 +185,13 @@
 		progressBox.relayout(false);
 		progressBox.exec();
 		mapLoader.setProgressInfoBox(progressBox);
-		Vm.showWait(true);
-		ewe.fx.Point size = new ewe.fx.Point(1000,1000); // Size of the downloaded maps
+		Form.showWait();
+		eve.fx.Point size = new eve.fx.Point(1000,1000); // Size of the downloaded maps
 		if (forCachesChkBox.getState() || perCache) {
 			Area surArea = Global.getProfile().getSourroundingArea(onlySelected); // calculate map boundaries from cacheDB
 			if (surArea == null) {
-				(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1817, &quot;No Caches are seleted&quot;), FormBase.OKB)).execute();
-				Vm.showWait(false);
+				(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1817, &quot;No Caches are seleted&quot;), MessageBox.OKB)).execute();
+				Form.cancelWait();
 				progressBox.close(0);
 				return;
 			}
@@ -218,22 +222,22 @@
 				ch = (CacheHolder) cacheDB.get(i);
 				if (!this.onlySelected || ch.is_Checked) {
 					if (ch.pos == null) { // this can not happen
-						tmpca.set(ch.LatLon);
+						tmpca.set(ch.latLon);
 						ch.pos = new CWPoint(tmpca);
 					}
 					if (ch.pos.isValid() &amp;&amp; ch.pos.latDec != 0 &amp;&amp; ch.pos.lonDec != 0) { // TODO != 0 sollte verschwinden, sobald das handling von nicht gesetzten Koos &#252;berall korrekt ist
 						numdownloaded++;
-						progressBox.setInfo(MyLocale.getMsg(1820, &quot;Downloading map '&quot;)+mapLoader.currentOnlineMapService.getName()+&quot;'\n&quot;+numdownloaded+&quot; / &quot;+numCaches+MyLocale.getMsg(1821, &quot;\n for cache:\n&quot;)+ch.CacheName);
+						progressBox.setInfo(MyLocale.getMsg(1820, &quot;Downloading map '&quot;)+mapLoader.currentOnlineMapService.getName()+&quot;'\n&quot;+numdownloaded+&quot; / &quot;+numCaches+MyLocale.getMsg(1821, &quot;\n for cache:\n&quot;)+ch.cacheName);
 						try {
 							mapLoader.downloadMap(ch.pos, scale, size, mapsDir);
 						} catch (Exception e) {
-							progressBox.addWarning(MyLocale.getMsg(1822, &quot;Cache:&quot;)+&quot; &quot; + ch.CacheName + &quot;(&quot; + ch.wayPoint + &quot;) &quot;+MyLocale.getMsg(1823, &quot;Ignoring error:&quot;)+&quot; &quot; + e.getMessage()+&quot;\n&quot;);
+							progressBox.addWarning(MyLocale.getMsg(1822, &quot;Cache:&quot;)+&quot; &quot; + ch.cacheName + &quot;(&quot; + ch.wayPoint + &quot;) &quot;+MyLocale.getMsg(1823, &quot;Ignoring error:&quot;)+&quot; &quot; + e.getMessage()+&quot;\n&quot;);
 						}
 					}
 				}
 			}
 		}
-		Vm.showWait(false);
+		Form.cancelWait();
 		progressBox.addWarning(MyLocale.getMsg(1826, &quot;Finished downloading and calibration of maps&quot;));
 		progressBox.addOkButton();
 		progressBox.waitUntilClosed();
@@ -249,10 +253,10 @@
 		if (forCachesChkBox.getState()) {
 			// create map rectangle from caches
 			a = 0;
-			b = ControlConstants.Disabled;
+			b = Control.Disabled;
 		}
 		else { // use centre and distance input
-			a = ControlConstants.Disabled;
+			a = Control.Disabled;
 			b = 0;
 		}
 		forSelectedChkBox.modify(a, b);
@@ -269,7 +273,7 @@
 	public void onEvent(Event ev){
 		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
 			if (ev.target == cancelB || ev.target == cancelBPerCache){
-				this.close(FormBase.IDCANCEL);
+				this.close(Form.IDCANCEL);
 			}
 			if (ev.target == okBtiles || ev.target == okBPerCache){
 				mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
@@ -278,20 +282,20 @@
 					if (forSelectedChkBox.getSelectedItem().toString().equalsIgnoreCase(MyLocale.getMsg(1804, &quot;all&quot;))) onlySelected = false;
 					else onlySelected = true;
 					overviewmap = overviewChkBox.getState();
-					radius = (float)CacheWolf.Common.parseDouble(distanceInput.getText());
-					scale = (float)CacheWolf.Common.parseDouble(scaleInput.getText());
+					radius = (float)cachewolf.utils.Common.parseDouble(distanceInput.getText());
+					scale = (float)cachewolf.utils.Common.parseDouble(scaleInput.getText());
 					overlapping = Convert.toInt(overlappingInput.getText());
 					if (!forCachesChkBox.getState()) {
 						if (radius &lt;= 0) { 
-							(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1827, &quot;'radius' must be graeter than 0&quot;), FormBase.OKB)).execute();
+							(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1827, &quot;'radius' must be graeter than 0&quot;), MessageBox.OKB)).execute();
 							return;
 						}
 						if (overlapping &lt; 0) { 
-							(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1828, &quot;'overlapping' must be greater or equal 0&quot;), FormBase.OKB)).execute();
+							(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1828, &quot;'overlapping' must be greater or equal 0&quot;), MessageBox.OKB)).execute();
 							return;
 						}
 						if (!center.isValid() &amp;&amp; !forCachesChkBox.getState()) {
-							(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1829, &quot;Please enter the 'centre' around which the maps shall be downloaded&quot;), FormBase.OKB)).execute();
+							(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1829, &quot;Please enter the 'centre' around which the maps shall be downloaded&quot;), MessageBox.OKB)).execute();
 							return;
 						}
 					}
@@ -303,16 +307,16 @@
 					scale = Convert.toFloat(scaleInputPerCache.getText());
 				}
 				if (scale &lt; mapLoader.currentOnlineMapService.minscale || scale &gt; mapLoader.currentOnlineMapService.maxscale) {
-					(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1830, &quot;The selected online map service provides map in the scale from&quot;)+&quot; &quot; + mapLoader.currentOnlineMapService.minscale + MyLocale.getMsg(1831, &quot; to&quot;)+&quot; &quot;+ mapLoader.currentOnlineMapService.maxscale +MyLocale.getMsg(1832, &quot;\n please adjust 'Approx. meter pro pixel' accordingly&quot;), FormBase.OKB)).execute();
+					(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1830, &quot;The selected online map service provides map in the scale from&quot;)+&quot; &quot; + mapLoader.currentOnlineMapService.minscale + MyLocale.getMsg(1831, &quot; to&quot;)+&quot; &quot;+ mapLoader.currentOnlineMapService.maxscale +MyLocale.getMsg(1832, &quot;\n please adjust 'Approx. meter pro pixel' accordingly&quot;), MessageBox.OKB)).execute();
 					return;
 				}
-				this.close(FormBase.IDOK); 
+				this.close(Form.IDOK); 
 				this.downloadTiles();
 			}
 			if (ev.target == coosBtn) {
 				CoordsScreen cs = new CoordsScreen();
 				cs.setFields(center, CWPoint.CW);
-				if (cs.execute() != FormBase.IDCANCEL) {
+				if (cs.execute() != CoordsScreen.IDCANCEL) {
 					center = cs.getCoords();
 					coosBtn.setText(center.toString());
 					int tmp = sortingMapServices[mapServiceChoice.selectedIndex];

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/MapSymbol.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/MapSymbol.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/MapSymbol.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,9 +1,9 @@
-package CacheWolf.navi;
+package cachewolf.navi;
 
-import CacheWolf.CWPoint;
-import ewe.fx.*;
+import cachewolf.CWPoint;
+import eve.fx.*;
 
-public class MapSymbol extends MapImage {
+public class MapSymbol extends MapImage { 
 	Object mapObject;
 	String name;
 	String filename;
@@ -14,14 +14,14 @@
 		filename = filenamei;
 		where = where_;
 	}
-	public MapSymbol(String namei, Object mapObjecti, Image fromIm, CWPoint where_) {
+	public MapSymbol(String namei, Object mapObjecti, Picture fromIm, CWPoint where_) {
 		name = namei;
 		where = where_;
 		mapObject = mapObjecti;
 		setImage(fromIm);
 	}
 	public void loadImage(){
-		setImage(new Image(filename),0); freeSource();;
+		setImage((new Picture(filename)).toImage(0),null); //freeSource();
 		//properties = AniImage.AlwaysOnTop;
 	}
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/MapsList.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/MapsList.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/MapsList.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,19 +1,21 @@
-package CacheWolf.navi;
+package cachewolf.navi;
 
-import CacheWolf.CWPoint;
-import CacheWolf.Common;
-import CacheWolf.Global;
-import CacheWolf.InfoBox;
-import CacheWolf.MyLocale;
-import utils.FileBugfix;
-import ewe.io.File;
-import ewe.io.FileBase;
-import ewe.io.IOException;
-import ewe.sys.Time;
-import ewe.ui.FormBase;
-import ewe.ui.MessageBox;
-import ewe.util.Vector;
-import ewe.fx.*;
+import eve.io.File;
+import java.io.IOException;
+import eve.sys.Time;
+import eve.ui.MessageBox;
+import java.util.Vector;
+
+import cachewolf.CWPoint;
+import cachewolf.Global;
+import cachewolf.InfoBox;
+import cachewolf.MyLocale;
+import cachewolf.utils.Common;
+
+import eve.fx.*;
+import eve.ui.Form;
+import eve.ui.FormBase;
+
 /**
  * class to handle a list of maps
  * it loads the list, finds the best map for a given location,
@@ -22,7 +24,8 @@
  *
  */
 public class MapsList extends Vector {
-	public static float scaleTolerance = 1.15f; // absolute deviations from this factor are seen to have the same scale
+	static final long serialVersionUID=0; // For compiler only
+	public static final float scaleTolerance = 1.15f; // absolute deviations from this factor are seen to have the same scale
 
 	/**
 	 * loads alle the maps in mapsPath in all subDirs but not recursive, only one level 
@@ -32,12 +35,15 @@
 		super(); // forget already loaded maps
 		//if (mmp.mapImage != null) 
 		String dateien[];
-		FileBugfix files = new FileBugfix(mapsPath);
-		String rawFileName = new String();
-		String[] dirstmp = files.list(null, FileBase.LIST_DIRECTORIES_ONLY);
+		File files = new File(mapsPath);
+		String rawFileName;
+		String[] dirstmp = files.list(null, File.LIST_DIRECTORIES_ONLY);
 		Vector dirs;
-		if (dirstmp != null) dirs = new Vector(dirstmp);
-		else dirs = new Vector();
+		if (dirstmp != null) {
+			dirs = new Vector();
+			for (int i=0; i&lt;dirstmp.length; i++)
+				dirs.add(dirstmp[i]);
+		} else dirs = new Vector();
 		dirs.add(&quot;.&quot;); // include the mapsPath itself
 		MapListEntry tempMIO;
 		MessageBox f = null; 
@@ -45,20 +51,19 @@
 
 		
 		for (int j = 0; j &lt; dirs.size(); j++) {
-			files = new FileBugfix(mapsPath+&quot;/&quot;+dirs.get(j));
-			//ewe.sys.Vm.debug(&quot;mapd-Dirs:&quot;+files);
+			files = new File(mapsPath+&quot;/&quot;+dirs.get(j));
+			//eve.sys.Vm.debug(&quot;mapd-Dirs:&quot;+files);
 			
 			//add subdirectories
 			if (!dirs.get(j).equals(&quot;.&quot;)) {
-				dirstmp = files.list(null, FileBase.LIST_DIRECTORIES_ONLY);
+				dirstmp = files.list(null, File.LIST_DIRECTORIES_ONLY);
 				if (dirstmp != null) {
 					for (int subDir = 0; subDir &lt; dirstmp.length; subDir++) {
-						dirs.add(j+1+subDir, dirs.get(j)+&quot;/&quot;+dirstmp[subDir]);
+						dirs.add(dirs.get(j)+&quot;/&quot;+dirstmp[subDir]);
 					}
 				}
 			}
-
-			dateien = files.list(&quot;*.wfl&quot;, FileBase.LIST_FILES_ONLY); //&quot;*.xyz&quot; doesn't work on some systems -&gt; use FileBugFix
+			dateien = files.list(&quot;*.wfl&quot;, File.LIST_FILES_ONLY); //&quot;*.xyz&quot; doesn't work on some systems -&gt; use FileBugFix
 			if (dateien == null) continue;
 			for(int i = 0; i &lt; dateien.length;i++){
 				// if (!dateien[i].endsWith(&quot;.wfl&quot;)) continue;
@@ -68,9 +73,9 @@
 						tempMIO = new MapListEntry(mapsPath+&quot;/&quot;, rawFileName);
 					else tempMIO = new MapListEntry(mapsPath+&quot;/&quot;+dirs.get(j)+&quot;/&quot;, rawFileName);
 					if (tempMIO.sortEntryBBox != null) add(tempMIO);
-					//ewe.sys.Vm.debug(tempMIO.getEasyFindString() + tempMIO.mapName);
+					//eve.sys.Vm.debug(tempMIO.getEasyFindString() + tempMIO.mapName);
 				}catch(Exception ex){ // TODO exception ist, glaub ich evtl &#252;berfl&#252;ssig 
-					if (f == null) (f=new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(4700, &quot;Ignoring error while \n reading calibration file \n&quot;)+ex.toString(), FormBase.OKB)).exec();
+					if (f == null) (f=new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(4700, &quot;Ignoring error while \n reading calibration file \n&quot;)+ex.toString(), MessageBox.OKB)).exec();
 				} /* catch(ArithmeticException ex){ // affine contain not allowed values 
 					if (f == null) (f=new MessageBox(&quot;Warning&quot;, &quot;Ignoring error while \n reading calibration file \n&quot;+ex.toString(), MessageBox.OKB)).exec();
 				} */
@@ -130,13 +135,14 @@
 				showprogress = true;      
 				progressBox = new InfoBox(MyLocale.getMsg(327,&quot;Info&quot;), MyLocale.getMsg(4701,&quot;Searching for best map&quot;));
 				progressBox.exec(); 
-				progressBox.waitUntilPainted(100);
-				ewe.sys.Vm.showWait(true);
+				progressBox.getWindow().waitUntilPainted(100);
+				Form.showWait();
 			}
 			ml = (MapListEntry)get(i);
 			try {
 				if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
-				else { mi = ml.getMap(); testkw++;}
+				mi = ml.getMap(); 
+				testkw++;
 			} catch (IOException ex) {continue; } // could not read .wfl-file
 			better = false;
 //			mi = (MapInfoObject)get(i);
@@ -171,7 +177,7 @@
 		}
 		if (progressBox != null) {
 			progressBox.close(0);
-			ewe.sys.Vm.showWait(false);
+			Form.cancelWait();
 		}
 		if (bestMap == null) return null;
 		return new MapInfoObject(bestMap); // return a copy of the MapInfoObject so that zooming won't change the MapInfoObject in the list 
@@ -209,13 +215,13 @@
 				showprogress = true;      
 				progressBox = new InfoBox(MyLocale.getMsg(327,&quot;Info&quot;), MyLocale.getMsg(4701,&quot;Searching for best map&quot;));
 				progressBox.exec(); 
-				progressBox.waitUntilPainted(100);
-				ewe.sys.Vm.showWait(true);
+				progressBox.getWindow().waitUntilPainted(100);
+				Form.showWait();
 			}
 			ml = (MapListEntry)get(i);
 			try {
 				if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
-				else { mi = ml.getMap();}
+				mi = ml.getMap();
 			} catch (IOException ex) {continue; } // could not read .wfl-file
 			better = false;
 			if (mi.isInBound(topleft) &amp;&amp; mi.isInBound(bottomright)) { // both points are inside the map
@@ -243,10 +249,10 @@
 		} // for
 		if (progressBox != null) {
 			progressBox.close(0);
-			ewe.sys.Vm.showWait(false);
+			Form.cancelWait();
 		}
 		if (fittingmap == null) return null;
-		return new MapInfoObject(fittingmap); // TODO in case that this one and the old one are identical this instantiation could eventually be avoided as it is done at every greater shift of the map
+		return new MapInfoObject(fittingmap);
 	}
 
 	/**
@@ -278,14 +284,14 @@
 				showprogress = true;      
 				progressBox = new InfoBox(MyLocale.getMsg(327,&quot;Info&quot;), MyLocale.getMsg(4701,&quot;Searching for best map&quot;));
 				progressBox.exec(); 
-				progressBox.waitUntilPainted(100);
-				ewe.sys.Vm.showWait(true);
+				progressBox.getWindow().waitUntilPainted(100);
+				Form.showWait();
 			}
 			better = false;
 			ml = (MapListEntry)get(i);
 			try {
 				if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
-				else { mi = ml.getMap();}
+				mi = ml.getMap();
 			} catch (IOException ex) {continue; } // could not read .wfl-file
 			if (mi.fileNameWFL == &quot;&quot;) continue; // exclude &quot;maps&quot; without image // TODO make this a boolean in MapInfoObject
 			if (screenArea == null || !scaleEquals(lastscale, mi)) {
@@ -318,7 +324,7 @@
 		}
 		if (progressBox != null) {
 			progressBox.close(0);
-			ewe.sys.Vm.showWait(false);
+			Form.cancelWait();
 		}
 		if (bestMap == null) return null;
 		return new MapInfoObject(bestMap);
@@ -341,13 +347,15 @@
 	}
 	public static boolean scaleEquals(MapInfoObject a, MapInfoObject b) {
 		//return java.lang.Math.abs(a.scale - b.scale) &lt; scaleTolerance;
-		if (a.scale &gt; b.scale) return a.scale / b.scale &lt; scaleTolerance; 
-		else return b.scale / a.scale &lt; scaleTolerance;
+		if (a.scale &gt; b.scale) 
+			return a.scale / b.scale &lt; scaleTolerance; 
+		return b.scale / a.scale &lt; scaleTolerance;
 	}
 	public static boolean scaleEquals(float s, MapInfoObject b) {
 		//return java.lang.Math.abs(s - b.scale) &lt; scaleTolerance;
-		if (s &gt; b.scale) return s / b.scale &lt; scaleTolerance;
-		else return b.scale / s &lt; scaleTolerance;
+		if (s &gt; b.scale) 
+			return s / b.scale &lt; scaleTolerance;
+		return b.scale / s &lt; scaleTolerance;
 	}
 
 	/**
@@ -435,11 +443,12 @@
 		map = null;
 		/*
 		try {map = new MapInfoObject(path, filename); } catch (Exception e) {
+			// TODO: handle exception
 		}
 		
-		ewe.sys.Vm.debug(&quot;centerID: &quot;+map.getCenterID());
-		ewe.sys.Vm.debug(&quot;PxID: &quot;+map.getPxSizeID());
-		ewe.sys.Vm.debug(&quot;scaleID: &quot;+map.getScaleID()+&quot;scale: &quot;+map.scale);
+		eve.sys.Vm.debug(&quot;centerID: &quot;+map.getCenterID());
+		eve.sys.Vm.debug(&quot;PxID: &quot;+map.getPxSizeID());
+		eve.sys.Vm.debug(&quot;scaleID: &quot;+map.getScaleID()+&quot;scale: &quot;+map.scale);
 		*/
 		try {
 			if (filenamei.startsWith(&quot;FF1&quot;)) sortEntryBBox = filenamei.substring(0, filenamei.indexOf(&quot;E-&quot;));
@@ -448,14 +457,14 @@
 			try {
 				map = new MapInfoObject(path, filename);
 				sortEntryBBox = &quot;FF1&quot;+map.getEasyFindString();
-				ewe.sys.Vm.debug(sortEntryBBox + &quot;: &quot;+filename);
+				eve.sys.Vm.debug(sortEntryBBox + &quot;: &quot;+filename);
 				if (rename == 0) { // never asked before
 					if ( (new MessageBox(MyLocale.getMsg(4702,&quot;Optimisation&quot;), MyLocale.getMsg(4703,&quot;Cachewolf can make loading maps much faster by adding a identification mark to the filename. Do you want me to do this now?\n It can take several minutes&quot;), 
-							FormBase.YESB | FormBase.NOB)).execute() == FormBase.IDYES)
+							MessageBox.YESB | MessageBox.NOB)).execute() == MessageBox.IDYES)
 					{
 						renameProgressInfoB = new InfoBox(MyLocale.getMsg(327,&quot;Info&quot;), MyLocale.getMsg(4704,&quot;\nRenaming file:&quot;)+&quot;    \n&quot;);
 						renameProgressInfoB.exec();
-						renameProgressInfoB.waitUntilPainted(100);
+						renameProgressInfoB.getWindow().waitUntilPainted(100);
 						rename = 1; // rename
 					} else rename = 2; // don't rename
 				}
@@ -505,7 +514,7 @@
 	public static void loadingFinished() {
 		if (renameProgressInfoB != null) renameProgressInfoB.close(0);
 		renameProgressInfoB = null;
-		rename = 0;
+		rename=0;
 	}
 	
 	/*

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/MovingMap.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/MovingMap.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/MovingMap.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,22 +1,34 @@
-package CacheWolf.navi;
+package cachewolf.navi;
 
-import CacheWolf.CWPoint;
-import CacheWolf.CacheHolder;
-import CacheWolf.CacheType;
-import CacheWolf.Global;
-import CacheWolf.InfoBox;
-import CacheWolf.MainTab;
-import CacheWolf.MyLocale;
-import CacheWolf.Preferences;
-import ewe.ui.*;
-import ewe.graphics.*;
-import ewe.io.IOException;
-import ewe.sys.*;
-import ewe.filechooser.FileChooser;
-import ewe.filechooser.FileChooserBase;
-import ewe.fx.*;
-import ewe.util.Vector;
+import eve.ui.*;
+import java.io.IOException;
+import eve.sys.*;
+import eve.ui.filechooser.FileChooser;
+import eve.fx.*;
+import eve.fx.gui.IKeys;
+import java.util.Vector;
 
+import cachewolf.CWPoint;
+import cachewolf.CacheHolder;
+import cachewolf.CacheType;
+import cachewolf.Global;
+import cachewolf.InfoBox;
+import cachewolf.MainTab;
+import cachewolf.MyLocale;
+import cachewolf.Preferences;
+import cachewolf.utils.Common;
+
+import eve.ui.game.AniImage;
+import eve.ui.game.InteractivePanel;
+import eve.ui.game.ImageList;
+import eve.ui.game.ImageDragContext;
+import eve.ui.event.PenEvent;
+import eve.ui.event.ControlEvent;
+import eve.ui.event.WindowEvent;
+import eve.ui.event.MenuEvent;
+import eve.ui.event.KeyEvent;
+import eve.ui.event.FormEvent;
+import eve.fx.gui.WindowConstants;
 /**
  *	Class to handle a moving map.
  */
@@ -24,11 +36,11 @@
 	public final static int gotFix = 4; //green
 	public final static int lostFix = 3; //yellow
 	public final static int noGPSData = 2; // red
-	public final static int noGPS = 1; // no GPS-Position marker, manually disconnected 
+	public final static int noGPS = 1; // no GPS-Position marker, manually disconnected
 	public final static int ignoreGPS = -1; // ignore even changes in GPS-signal (eg. from lost fix to gotFix) this is wanted when the map is moved manually
 
 	public MapSymbol gotoPos = null;
-	public int GpsStatus;
+	public int gpsStatus;
 	Preferences pref;
 	MovingMapPanel mmp;
 	MapsList maps;
@@ -41,14 +53,14 @@
 	//String mapPath;
 	Navigate myNavigation;
 	boolean running = false;
-	
+
 	MapImage mapImage1to1;
 	ArrowsOnMap directionArrows = new ArrowsOnMap();
 	AniImage statusImageHaveSignal;
 	AniImage statusImageNoSignal;
 	AniImage statusImageNoGps;
-	AniImage bottonImageClose;
-	AniImage bottonImageChooseMap; 
+	AniImage buttonImageClose;
+	AniImage buttonImageChooseMap;
 	AniImage buttonImageGpsOn;
 	AniImage buttonImageLens;
 	AniImage buttonImageLensActivated;
@@ -73,10 +85,9 @@
 	boolean noMapsAvailable;
 	boolean zoomingMode = false;
 	boolean mapsloaded = false;
-	
+
 	Point lastRepaintMapPos = null;
 	double lastDistance = -1;
-	
 	float lastHighestResolutionGPSDestScale = -1;
 
 	public MovingMap(Navigate nav, Vector cacheDB){
@@ -84,28 +95,26 @@
 		this.myNavigation = nav;
 		this.pref = Global.getPref();
 		if (pref.myAppHeight &lt;= 640 &amp;&amp; pref.myAppWidth &lt;= 640)	this.windowFlagsToSet = WindowConstants.FLAG_FULL_SCREEN;
-//      The following line is commented out, because this caused trouble under ewe-vm v1.49 on win-xp
-//      when MovingMap was started with maximized CacheWolf-Window
-//		this.windowFlagsToClear = WindowConstants.FLAG_HAS_TITLE | UIConstants.BDR_NOBORDER;
+		this.windowFlagsToClear = WindowConstants.FLAG_HAS_TITLE | UIConstants.BDR_NOBORDER;
 		this.hasTopBar = false;
 		this.noBorder = true;
 		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
-		this.title = &quot;Moving Map&quot;; 
+		this.title = &quot;Moving Map&quot;;
 		this.backGround = new Color(254,254,254); // background must not be black because black is interpreted as transparent and transparent images above (eg trackoverlay) want be drawn in windows-VM, so be care, don|t use white either
 		//this.mapPath = Global.getPref().getMapLoadPath();
 
 		mmp = new MovingMapPanel(this);
 		this.addLast(mmp);
-		
+
 		boolean mobileVGA = false;
-		if (Vm.isMobile() &amp;&amp; MyLocale.getScreenWidth() &gt;= 400) mobileVGA = true;  
+		if (Device.isMobile() &amp;&amp; MyLocale.getScreenWidth() &gt;= 400) mobileVGA = true;
 		String imagesize=&quot;&quot;;
 		if(mobileVGA) imagesize=&quot;_vga&quot;;
-		
+
 		statusImageHaveSignal = new AniImage(&quot;position_green&quot;+imagesize+&quot;.png&quot;);
 		statusImageNoSignal = new AniImage(&quot;position_yellow&quot;+imagesize+&quot;.png&quot;);
 		statusImageNoGps = new AniImage(&quot;position_red&quot;+imagesize+&quot;.png&quot;);
-		bottonImageChooseMap = new AniImage(&quot;choose_map&quot;+imagesize+&quot;.gif&quot;); 
+		buttonImageChooseMap = new AniImage(&quot;choose_map&quot;+imagesize+&quot;.gif&quot;);
 		buttonImageGpsOn = new AniImage(&quot;snap2gps&quot;+imagesize+&quot;.gif&quot;);
 		buttonImageLens = new AniImage(&quot;lupe&quot;+imagesize+&quot;.png&quot;);
 		buttonImageLensActivated = new AniImage(&quot;lupe_activated&quot;+imagesize+&quot;.png&quot;);
@@ -114,60 +123,62 @@
 		buttonImageZoom1to1 = new AniImage(&quot;zoom1to1&quot;+imagesize+&quot;.png&quot;);
 		posCircle = new MapSymbol(&quot;position_green&quot;+imagesize+&quot;.png&quot;, &quot;gps-position&quot;, new CWPoint());
 		MARK_CACHE_IMAGE = &quot;mark_cache.png&quot;;
-		
+
 		DrawnIcon closeX;
 		if(mobileVGA)
-			closeX = new DrawnIcon(DrawnIcon.CROSS,30,30,new Color(0,0,0));
+			closeX = new DrawnIcon(DrawnIcon.CROSS,30,30,Color.Black);
 		else
-			closeX = new DrawnIcon(DrawnIcon.CROSS,15,15,new Color(0,0,0));
-		bottonImageClose = new AniImage(new Image(closeX.getWidth(), closeX.getHeight()));
-		Graphics tmp = new Graphics(bottonImageClose.image);
-		tmp.setColor(255, 255, 255);
+			closeX = new DrawnIcon(DrawnIcon.CROSS,15,15,Color.Black);
+		Image imgButtonClose = new Image(closeX.getWidth(), closeX.getHeight());
+		Graphics tmp = new Graphics(imgButtonClose);
+		//tmp.setColor(255, 255, 255);
+		tmp.set(new Brush(Color.White,Brush.SOLID));
 		tmp.fillRect(0, 0, closeX.getWidth(), closeX.getHeight());
 		closeX.doDraw(tmp, 0);
-		bottonImageClose.properties |= mImage.AlwaysOnTop;
-		mmp.addImage(bottonImageClose);
-		buttonImageGpsOn.properties = mImage.AlwaysOnTop;
+		buttonImageClose = new AniImage(imgButtonClose);
+		buttonImageClose.properties |= AniImage.AlwaysOnTop;
+		mmp.addImage(buttonImageClose);
+		buttonImageGpsOn.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(buttonImageGpsOn);
-		bottonImageChooseMap.properties = mImage.AlwaysOnTop;
-		mmp.addImage(bottonImageChooseMap);
-		directionArrows.properties = mImage.AlwaysOnTop;
+		buttonImageChooseMap.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(buttonImageChooseMap);
+		directionArrows.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(directionArrows);
-		buttonImageLens.properties = mImage.AlwaysOnTop;
-		buttonImageLensActivated.properties = mImage.AlwaysOnTop;
-		buttonImageLensActivatedZoomIn.properties = mImage.AlwaysOnTop;
-		buttonImageLensActivatedZoomOut.properties = mImage.AlwaysOnTop;
+		buttonImageLens.properties = AniImage.AlwaysOnTop;
+		buttonImageLensActivated.properties = AniImage.AlwaysOnTop;
+		buttonImageLensActivatedZoomIn.properties = AniImage.AlwaysOnTop;
+		buttonImageLensActivatedZoomOut.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(buttonImageLens);
-		buttonImageZoom1to1.properties = mImage.AlwaysOnTop;
+		buttonImageZoom1to1.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(buttonImageZoom1to1);
 		//target distance
 		int fontSize = ( 3 * pref.fontSize ) / 2;
 		Font font = new Font(&quot;Helvetica&quot;, Font.PLAIN, fontSize );
 		fm = getFontMetrics(font);
 		DistanceImage = new AniImage();
-		DistanceImage.setImage(new Image(MyLocale.getScreenWidth()/2, fm.getHeight() ), Color.White); // consider the size of the font used
-		DistanceImageGraphics = new Graphics(DistanceImage.image);
+		DistanceImage.setImage(new Image(MyLocale.getScreenWidth()/2, fm.getHeight()).getImageData()); //, Color.White); // consider the size of the font used
+		DistanceImageGraphics = new Graphics((Image)DistanceImage.getImage());
 		DistanceImageGraphics.setFont(font);
-		DistanceImage.properties = mImage.AlwaysOnTop;
+		DistanceImage.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(DistanceImage);
 		//scale
 		ScaleImage = new AniImage();
-		ScaleImage.setImage(new Image(MyLocale.getScreenWidth()/2, fm.getHeight() ), Color.White); // consider the size of the font used
-		ScaleImageGraphics = new Graphics(ScaleImage.image);
+		ScaleImage.setImage(new Image(MyLocale.getScreenWidth()/2, fm.getHeight()).getImageData()); //, Color.White); // consider the size of the font used
+		ScaleImageGraphics = new Graphics((Image)ScaleImage.getImage());
 		ScaleImageGraphics.setFont(font);
-		ScaleImage.properties = mImage.AlwaysOnTop;
+		ScaleImage.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(ScaleImage);
 		//resizeTo(pref.myAppWidth, pref.myAppWidth); // is necessary to initialise mapImage.screenSize
 		setGpsStatus(noGPS);
-		posCircle.properties = mImage.AlwaysOnTop;
+		posCircle.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(posCircle);
 		mmp.startDragResolution = 5;
 		mapsloaded = false;
 		//updateDistance(); // fill Rect with transparent color
 		scaleWanted = 1;
 		mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
-		lastHighestResolutionGPSDestScale = -1;
-		
+	 	lastHighestResolutionGPSDestScale = -1;
+
 		lastRepaintMapPos = new Point(pref.myAppWidth +1, pref.myAppHeight +1);
 	}
 
@@ -178,9 +189,9 @@
 
 	public void updateFormSize(int w, int h) {
 		MapImage.setScreenSize(w, h);
-		bottonImageClose.setLocation(w- bottonImageClose.getWidth()- 5, 5);
-		buttonImageGpsOn.setLocation(w- bottonImageChooseMap.getWidth()-5, bottonImageClose.getHeight() + 20);
-		bottonImageChooseMap.setLocation(10,10);
+		buttonImageClose.setLocation(w- buttonImageClose.getWidth()- 5, 5);
+		buttonImageGpsOn.setLocation(w- buttonImageChooseMap.getWidth()-5, buttonImageClose.getHeight() + 20);
+		buttonImageChooseMap.setLocation(10,10);
 		directionArrows.setLocation(w/2-directionArrows.getWidth()/2, 10);
 		buttonImageZoom1to1.setLocation(w - buttonImageZoom1to1.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 - buttonImageZoom1to1.getHeight() -10);
 		buttonImageLens.setLocation(w - buttonImageLens.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 );
@@ -189,14 +200,14 @@
 		buttonImageLensActivatedZoomOut.setLocation(w - buttonImageLensActivatedZoomOut.getWidth()-10, h/2 - buttonImageLensActivatedZoomOut.getHeight()/2 );
 		DistanceImage.setLocation(0, h - DistanceImage.getHeight());
 		ScaleImage.setLocation(w - ScaleImage.getWidth(), h - ScaleImage.getHeight());
-		if (mmp.mapImage != null) mmp.mapImage.screenDimChanged(); 
+		if (mmp.mapImage != null) mmp.mapImage.screenDimChanged();
 		if (posCircle != null) posCircle.screenDimChanged();
 		if (tracks != null) rebuildOverlaySet();
 		if (symbols != null) { // TODO: see if the rest of the code works with symbols = null
 			for (int i = symbols.size() -1; i &gt;= 0; i-- ) {
 				((MapSymbol)symbols.get(i)).screenDimChanged();
 			}
-}
+		}
 	}
 
 	boolean loadingMapList = false;
@@ -209,30 +220,29 @@
 		if (loadingMapList) return;
 		loadingMapList = true;
 		//this.mapPath = mapsPath;
-		Vm.showWait(this, true);
+		Form.showWait();
 		resetCenterOfMap();
 		InfoBox inf = new InfoBox(MyLocale.getMsg(4201, &quot;Info&quot;), MyLocale.getMsg(4203, &quot;Loading list of maps...&quot;));
 		inf.exec();
-		inf.waitUntilPainted(100);
+		inf.getWindow().waitUntilPainted(100);
 		boolean saveGpsIgnoreStatus = dontUpdatePos;
 		dontUpdatePos = true;
 		maps = new MapsList(mapsPath); // this actually loads the maps
 		if (maps.isEmpty()) {
-			(new MessageBox(MyLocale.getMsg(4201, &quot;Information&quot;), MyLocale.getMsg(4204, &quot;No georeferenced map available \n Please choose a scale \n to show the track and the caches. \n You can get one by the menu: Application/Maps/download calibrated&quot;), FormBase.OKB)).execute();
-			noMapsAvailable = true;
+			(new MessageBox(MyLocale.getMsg(4201, &quot;Information&quot;), MyLocale.getMsg(4204, &quot;No georeferenced map available \n Please choose a scale \n to show the track and the caches. \n You can get one by the menu: Application/Maps/download calibrated&quot;), FormBase.OKB)).execute();			noMapsAvailable = true;
 		} else noMapsAvailable = false;
 		maps.addEmptyMaps(lat); // the empty maps must be added last, otherwise in method setBestMap, when no mapt is available, a malfunction will happen, see there
 		dontUpdatePos = saveGpsIgnoreStatus;
 		inf.close(0);
-		Vm.showWait(this, false);
+		Form.cancelWait();
 		this.mapsloaded = true;
 		loadingMapList = false;
 	}
 
 	public void updateScale() {
-		ScaleImageGraphics.setColor(ScaleImage.transparentColor);
+		//TODO ScaleImageGraphics.setColor(ScaleImage.transparentColor);
 		ScaleImageGraphics.fillRect(0, 0, ScaleImage.location.width,ScaleImage.location.height);
-		
+
 		if (currentMap != null)
 		{
 			float lineLengthMeters = 40 * currentMap.scale;
@@ -249,24 +259,24 @@
 			{
 				lineLengthString = Convert.toString((int) lineLengthMeters / 1000) + &quot;km&quot;;
 			}
-			
+
 			int backgroundStartX = ScaleImage.location.width - (lineLengthPixels + fm.getTextWidth(lineLengthString) + 7);
-			
+
 			ScaleImageGraphics.setColor(new Color(250,250,250));
 			ScaleImageGraphics.fillRect(backgroundStartX, 0, ScaleImage.location.width - backgroundStartX ,ScaleImage.location.height);
 
-			ScaleImageGraphics.setPen(new Pen(Color.DarkBlue,Pen.SOLID,3));
+			ScaleImageGraphics.changePen(Color.DarkBlue,Pen.SOLID,3);
 			ScaleImageGraphics.drawLine(backgroundStartX + 2, ScaleImage.location.height / 2, backgroundStartX+2+lineLengthPixels, ScaleImage.location.height / 2);
 			ScaleImageGraphics.setColor(Color.DarkBlue);
 			ScaleImageGraphics.drawText(lineLengthString , backgroundStartX + lineLengthPixels + 5, 0);
 		}
-		
-		ScaleImageGraphics.drawImage(ScaleImage.image,null,Color.LightBlue,0,0,ScaleImage.location.width,ScaleImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
-		ScaleImageGraphics.drawImage(ScaleImage.image,null,Color.White,0,0,ScaleImage.location.width,ScaleImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
+
+		ScaleImageGraphics.drawImageData(ScaleImage.getImageData(),new Rect(0,0,ScaleImage.location.width,ScaleImage.location.height),new Rect(0,0,ScaleImage.location.width,ScaleImage.location.height),0); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed  Color.LightBlue,0,0,
+		ScaleImageGraphics.drawImageData(ScaleImage.getImageData(),new Rect(0,0,ScaleImage.location.width,ScaleImage.location.height),new Rect(0,0,ScaleImage.location.width,ScaleImage.location.height),0); // these 2 commands are necessary because of a bug or near to a bug in the eve-vm
 	}
-	
+
 	public void updateDistance(boolean repaint) {
-		DistanceImageGraphics.setColor(DistanceImage.transparentColor);
+		//TODO DistanceImageGraphics.setColor(DistanceImage.transparentColor);
 		DistanceImageGraphics.fillRect(0, 0, DistanceImage.location.width,DistanceImage.location.height);
 		if (gotoPos != null &amp;&amp; posCircle.where.isValid())
 		{
@@ -274,19 +284,20 @@
 			if (currentDistance != lastDistance)
 			{
 				lastDistance = currentDistance;
-				ewe.sys.Double dd = new ewe.sys.Double();
-				dd.set(currentDistance);
+				double dd=currentDistance;
 				String d;
-				if (dd.value &lt; 1) {
-					dd.value = dd.value * 1000; 
-					dd.decimalPlaces = 0;
-					d = MyLocale.getMsg(4206, &quot;Dist: &quot;) + dd.toString() + &quot;m&quot;;
-				} 
+				if (dd &lt; 1) {
+					dd = dd * 1000;
+					d = MyLocale.getMsg(4206, &quot;Dist: &quot;) + Common.doubleToString(dd,0) + &quot;m&quot;;
+					int digits = (int)java.lang.Math.floor( java.lang.Math.log(dd) / java.lang.Math.log(10.0) );
+					digits = java.lang.Math.max(0, digits);
+				}
 				else {
-					dd.decimalPlaces = 2;
-					d = MyLocale.getMsg(4206, &quot;Dist: &quot;) + dd.toString() + &quot;km&quot;;
+					d = MyLocale.getMsg(4206, &quot;Dist: &quot;) + Common.doubleToString(dd,2) + &quot;km&quot;;
+					int digits = (int)java.lang.Math.floor( java.lang.Math.log(dd) / java.lang.Math.log(10.0) );
+					digits = java.lang.Math.max(0, digits);
 				}
-				
+
 				int backgroundWidth = fm.getTextWidth(d) + 4;
 
 				DistanceImageGraphics.setColor(new Color(250,250,250));
@@ -294,19 +305,20 @@
 
 				DistanceImageGraphics.setColor(Color.DarkBlue);
 				DistanceImageGraphics.drawText(d, 2, 0);
-				
-				DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.LightBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
-				DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.White,0,0,DistanceImage.location.width,DistanceImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
+
+				DistanceImageGraphics.drawImageData(DistanceImage.getImageData(),null,new Rect(0,0,DistanceImage.location.width,DistanceImage.location.height),0); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed
+				DistanceImageGraphics.drawImageData(DistanceImage.getImageData(),null,new Rect(0,0,DistanceImage.location.width,DistanceImage.location.height),0); // these 2 commands are necessary because of a bug or near to a bug in the eve-vm
 				if (repaint)
 				{
-					DistanceImage.refreshNow();
+					//TODO DistanceImage.updateImage();
 				}
 			}
 		}
 		else
 		{
-			DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.LightBlue,0,0,DistanceImage.location.width,DistanceImage.location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
-			DistanceImageGraphics.drawImage(DistanceImage.image,null,Color.White,0,0,DistanceImage.location.width,DistanceImage.location.height); // these 2 commands are necessary because of a bug or near to a bug in the ewe-vm
+			Rect area=new Rect(0,0,DistanceImage.location.width,DistanceImage.location.height);
+			DistanceImageGraphics.drawImageData(DistanceImage.getImageData(),area,area,0); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed Color.LightBlue,
+			DistanceImageGraphics.drawImageData(DistanceImage.getImageData(),area,area,0); // these 2 commands are necessary because of a bug or near to a bug in the eve-vm
 		}
 	}
 
@@ -326,19 +338,19 @@
 			for (int i=cacheDB.size()-1; i&gt;=0; i--) {
 				ch = (CacheHolder) cacheDB.get(i);
 				if (ch.is_Checked &amp;&amp; !ch.is_filtered &amp;&amp; ch != mainT.ch) {
-					if (ch.pos.isValid()) addSymbol(ch.CacheName, ch, CacheType.cache2Img(ch.type), ch.pos);
+					if (ch.pos.isValid()) addSymbol(ch.cacheName, ch, CacheType.cache2Img(ch.type), ch.pos);
 				}
 			}
 		}
 		setMarkedCache(mainT.ch);
 		addTrack(myNavigation.curTrack);
-		if (tracks != null &amp;&amp; tracks.size() &gt; 0 &amp;&amp; ((Track)tracks.get(0)).num &gt; 0) 
+		if (tracks != null &amp;&amp; tracks.size() &gt; 0 &amp;&amp; ((Track)tracks.get(0)).num &gt; 0)
 			rebuildOverlaySet(); // show points which where added when MavingMap was not running
 		destChanged(myNavigation.destination);
 		FormFrame ret = exec();
 		return ret;
 	}
-	
+
 	CacheHolder markedCache = null;
 	public void setMarkedCache(CacheHolder ch) {
 		if (ch == markedCache) return;
@@ -348,15 +360,15 @@
 		}
 		if (ch != null) {
 			addSymbol(&quot;selectedCache&quot;, MARK_CACHE_IMAGE, ch.pos);
-			addSymbolIfNecessary(ch.CacheName, ch, CacheType.cache2Img(ch.type), ch.pos);
+			addSymbolIfNecessary(ch.cacheName, ch, CacheType.cache2Img(ch.type), ch.pos);
 		}
 		markedCache = ch;
 	}
-	
+
 	public void addTrack(Track tr) {
 		if (tr == null) return;
 		if (tracks == null) tracks = new Vector();
-		if (tracks.find(tr) &gt;= 0 ) return; // track already in list
+		if (tracks.indexOf(tr) &gt;= 0 ) return; // track already in list
 		tracks.add(tr);
 		rebuildOverlaySet();
 	}
@@ -371,25 +383,25 @@
 
 	/**
 	 * adds an 3x3 set of overlays to the map-window which contain the track
-	 * 
+	 *
 	 * add tracks with addtrack(track) before
 	 */
 
 	public void addOverlaySet() {
 		if (tracks == null) return; // no tracks
 		try {
-			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
+			TrackOverlaySetCenterTopLeft = screenXY2LatLon(100, 100);
 			addMissingOverlays();
 		} catch (NullPointerException e) {} // hapens if currentmap == null or PosCircle not valid
-		catch (IllegalArgumentException e) {} // happens if screensize is still not known    ---&gt; in both cases creation of Overlayset will be done in updateOverlayPos if tracks != null 
+		catch (IllegalArgumentException e) {} // happens if screensize is still not known    ---&gt; in both cases creation of Overlayset will be done in updateOverlayPos if tracks != null
 	}
 
 	public void destroyOverlaySet() {
 		if (TrackOverlays != null) {
 			for (int i=0; i&lt; TrackOverlays.length; i++) {	destroyOverlay(i);	}
 		}
-		Vm.getUsedMemory(true); // call garbage collection
-		Vm.gc();
+		Vm.getUsedObjectMemory(true); // call garbage collection
+		Runtime.getRuntime().gc();
 	}
 
 	public void rebuildOverlaySet() {
@@ -401,20 +413,20 @@
 		if (currentMap == null || (!posCircle.where.isValid()) || width == 0 || height == 0) return; // height == 0 happens if this is called before the form ist displayed on the screen
 		if (TrackOverlays == null) {
 			TrackOverlays = new TrackOverlay[9];
-			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
+			TrackOverlaySetCenterTopLeft = screenXY2LatLon(100, 100);
 		}
 		boolean saveGPSIgnoreStatus = dontUpdatePos; // avoid multi-threading problems
 		dontUpdatePos = true;
-		Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft); // TrackOverlay[4] == center of Trackoverlays 
+		Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft); // TrackOverlay[4] == center of Trackoverlays
 		//upperleftOf4.x = (upperleftOf4.x + 1* width) % (width * 2) - 1 * width;
 		//upperleftOf4.y = (upperleftOf4.y + 1* height) % (height * 2) - 1 * height;
 		int i;
 		for (int yi=0; yi&lt;3; yi++) {
 			for (int xi=0; xi&lt;3; xi++) {
 				i = yi*3+xi;
-				if (TrackOverlays[i]==null) { 
-					TrackOverlays[i]= new TrackOverlay(ScreenXY2LatLon(upperleftOf4.x+(xi-1)*width, upperleftOf4.y+(yi-1)*height), width, height, currentMap); 
-					TrackOverlays[i].setLocation(width+1, height+1); // outside of the screen will hide it automatically it will get the correct position in upadteOverlayposition 
+				if (TrackOverlays[i]==null) {
+					TrackOverlays[i]= new TrackOverlay(screenXY2LatLon(upperleftOf4.x+(xi-1)*width, upperleftOf4.y+(yi-1)*height), width, height, currentMap);
+					TrackOverlays[i].setLocation(width+1, height+1); // outside of the screen will hide it automatically it will get the correct position in upadteOverlayposition
 					TrackOverlays[i].tracks = this.tracks;
 					TrackOverlays[i].paintTracks();
 					mmp.addImage(TrackOverlays[i]);
@@ -427,7 +439,7 @@
 	}
 
 	private void destroyOverlay(int ov) {
-		if (TrackOverlays[ov] == null) return; 
+		if (TrackOverlays[ov] == null) return;
 		mmp.removeImage(TrackOverlays[ov]);
 		TrackOverlays[ov].free();
 		TrackOverlays[ov]=null;
@@ -435,7 +447,7 @@
 	public void rearangeOverlays() {
 		Point oldp = getXYonScreen(TrackOverlaySetCenterTopLeft);
 		if (TrackOverlays[1].isOnScreen()) { // oben raus
-			TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y - 2* height));
+			TrackOverlaySetCenterTopLeft.set(screenXY2LatLon(oldp.x, oldp.y - 2* height));
 			destroyOverlay(6);
 			destroyOverlay(7);
 			destroyOverlay(8);
@@ -456,7 +468,7 @@
 			destroyOverlay(5);
 		} else {
 			if (TrackOverlays[3].isOnScreen()) { // links raus
-				TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y ));
+				TrackOverlaySetCenterTopLeft.set(screenXY2LatLon(oldp.x - 2* width, oldp.y ));
 				destroyOverlay(2);
 				destroyOverlay(5);
 				destroyOverlay(8);
@@ -477,7 +489,7 @@
 				destroyOverlay(7);
 			} else {
 				if (TrackOverlays[5].isOnScreen()) { // rechts raus
-					TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y ));
+					TrackOverlaySetCenterTopLeft.set(screenXY2LatLon(oldp.x + 2* width, oldp.y ));
 					destroyOverlay(0);
 					destroyOverlay(3);
 					destroyOverlay(6);
@@ -498,7 +510,7 @@
 					destroyOverlay(7);
 				} else {
 					if (TrackOverlays[7].isOnScreen()) { // unten raus
-						TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y + 2* height));
+						TrackOverlaySetCenterTopLeft.set(screenXY2LatLon(oldp.x, oldp.y + 2* height));
 						destroyOverlay(0);
 						destroyOverlay(1);
 						destroyOverlay(2);
@@ -519,7 +531,7 @@
 						destroyOverlay(5);
 					} else { // it is important to test for diagonal only if the other didn't match
 						if (TrackOverlays[0].isOnScreen()) {  // links oben raus
-							TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y - 2* height));
+							TrackOverlaySetCenterTopLeft.set(screenXY2LatLon(oldp.x - 2* width, oldp.y - 2* height));
 							destroyOverlay(8);
 							mmp.removeImage(TrackOverlays[0]);
 							TrackOverlays[8]=TrackOverlays[0];
@@ -534,7 +546,7 @@
 							destroyOverlay(7);
 						} else {
 							if (TrackOverlays[2].isOnScreen()) { // rechts oben raus
-								TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y - 2* height));
+								TrackOverlaySetCenterTopLeft.set(screenXY2LatLon(oldp.x + 2* width, oldp.y - 2* height));
 								destroyOverlay(6);
 								mmp.removeImage(TrackOverlays[2]);
 								TrackOverlays[6]=TrackOverlays[2];
@@ -549,7 +561,7 @@
 								destroyOverlay(8);
 							} else {
 								if (TrackOverlays[6].isOnScreen()) { // links unten raus
-									TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y + 2* height));
+									TrackOverlaySetCenterTopLeft.set(screenXY2LatLon(oldp.x - 2* width, oldp.y + 2* height));
 									destroyOverlay(2);
 									mmp.removeImage(TrackOverlays[6]);
 									TrackOverlays[2]=TrackOverlays[6];
@@ -564,7 +576,7 @@
 									destroyOverlay(8);
 								} else {
 									if (TrackOverlays[8].isOnScreen()) { // rechts unten raus
-										TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y + 2* height));
+										TrackOverlaySetCenterTopLeft.set(screenXY2LatLon(oldp.x + 2* width, oldp.y + 2* height));
 										destroyOverlay(0);
 										mmp.removeImage(TrackOverlays[8]);
 										TrackOverlays[0]=TrackOverlays[8];
@@ -580,14 +592,14 @@
 									}else
 										for (int i=0; i&lt;TrackOverlays.length; i++) {
 											destroyOverlay(i);
-											TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
+											TrackOverlaySetCenterTopLeft = screenXY2LatLon(100, 100);
 										} // this happens if a position jump occured
 								}}}}}}} // close all IFs
-		Vm.gc(); // call garbage collection
+		Runtime.getRuntime().gc(); // call garbage collection
 		//Vm.debug(&quot;Overlayrearanged&quot;+TrackOverlays.toString());
 	}
 
-	public void ShowLastAddedPoint(Track tr) {
+	public void showLastAddedPoint(Track tr) {
 		if (TrackOverlays == null || tr == null) return;
 		for (int i=0; i&lt;TrackOverlays.length; i++){
 			TrackOverlays[i].paintLastAddedPoint(tr);
@@ -602,13 +614,13 @@
 		Dimension ws = mmp.getSize(null);
 		int ww = ws.width;
 		int wh = ws.height;
-		//Vm.sleep(100); // this is necessary because the ewe vm ist not multi-threaded and the serial thread also needs time
+		//Vm.sleep(100); // this is necessary because the eve vm ist not multi-threaded and the serial thread also needs time
 		int num, x, y;
 		for (int yi=0; yi&lt;3; yi++) {
 			for (int xi=0; xi&lt;3; xi++) {
 				num = yi*3+xi;
 				x = posOnScreen.x+(xi-1)*ww;
-				y = posOnScreen.y+(yi-1)*wh; 
+				y = posOnScreen.y+(yi-1)*wh;
 				TrackOverlays[num].setLocation(x, y);
 			}
 		}
@@ -623,7 +635,7 @@
 					|| TrackOverlays[0].locAlways.y &gt; 0 || TrackOverlays[8].locAlways.y &lt; 0) { // testForNeedToRearange
 				rearangeOverlays();
 				addMissingOverlays();
-				// updateOverlayOnlyPos(); is called from addMissingOverlays 
+				// updateOverlayOnlyPos(); is called from addMissingOverlays
 			}
 		}
 	}
@@ -668,7 +680,7 @@
 	public void mapMoved(int diffX, int diffY) {
 		int w = posCircle.getWidth();
 		int h = posCircle.getHeight();
-		int npx = posCircleX-w/2+diffX; 
+		int npx = posCircleX-w/2+diffX;
 		int npy = posCircleY-h/2+diffY;
 		posCircle.move(npx, npy);
 		posCircleX = posCircleX+diffX;
@@ -691,7 +703,7 @@
 	 */
 	public Point getMapPositionOnScreen() {
 		if (currentMap == null || !posCircle.where.isValid()) return new Point(pref.myAppWidth +1, pref.myAppHeight +1); // in case no calculation is possible return somthing outside of the screen
-		Point mapPos = new Point(); 
+		Point mapPos = new Point();
 		//if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
 		//else {
 		Point mapposint = currentMap.calcMapXY(posCircle.where);
@@ -702,7 +714,7 @@
 	}
 
 	/**
-	 * 
+	 *
 	 * @param lat
 	 * @param lon
 	 * @return
@@ -715,7 +727,7 @@
 		return new Point(coords.x + mapPos.x, coords.y + mapPos.y);
 	}
 
-	public CWPoint ScreenXY2LatLon (int x, int y){
+	public CWPoint screenXY2LatLon (int x, int y){
 		Point mapPos = getMapPositionOnScreen();
 		return currentMap.calcLatLon(x - mapPos.x, y - mapPos.y);
 	}
@@ -739,24 +751,23 @@
 		if (symbols==null) symbols=new Vector();
 		MapSymbol ms = new MapSymbol(name, filename, where);
 		ms.loadImage();
-		ms.properties |= mImage.AlwaysOnTop;
+		ms.properties |= AniImage.AlwaysOnTop;
 		Point pOnScreen = getXYonScreen(where);
 		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
 		symbols.add(ms);
 		mmp.addImage(ms);
 		return ms;
 	}
-	
-	public void addSymbolIfNecessary(String name, Object mapObject, Image imSymb, CWPoint where) {
+
+	public void addSymbolIfNecessary(String name, Object mapObject, Picture imSymb, CWPoint where) {
 		if (findMapSymbol(name) &gt;= 0) return;
-		else addSymbol(name, mapObject, imSymb, where);
-		
+		addSymbol(name, mapObject, imSymb, where);
 	}
-		
-	public void addSymbol(String name, Object mapObject, Image imSymb, CWPoint ll) {
+
+	public void addSymbol(String name, Object mapObject, Picture imSymb, CWPoint ll) {
 		if (symbols==null) symbols=new Vector();
 		MapSymbol ms = new MapSymbol(name, mapObject, imSymb, ll);
-		ms.properties = mImage.AlwaysOnTop;
+		ms.properties = AniImage.AlwaysOnTop;
 		Point pOnScreen = getXYonScreen(ll);
 		if (pOnScreen != null) ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
 		symbols.add(ms);
@@ -764,7 +775,7 @@
 	}
 
 	public void destChanged(CWPoint d) {
-		if(!running || (d == null &amp;&amp; gotoPos == null) || 
+		if(!running || (d == null &amp;&amp; gotoPos == null) ||
 				(d != null &amp;&amp; gotoPos != null &amp;&amp; gotoPos.where.equals(d))) return;
 		removeGotoPosition();
 		if (d == null || !d.isValid() ) return;
@@ -813,11 +824,11 @@
 		MapSymbol ms;
 		for (int i = symbols.size() -1; i &gt;= 0 ; i--) {
 			ms= (MapSymbol)symbols.get(i);
-			if (ms.name == name) return i;
+			if (ms.name == name) return i;// TODO is this comparison right or should it use equals() ?
 		}
 		return -1;
 	}
-	
+
 	public int findMapSymbol(Object obj) {
 		if (symbols == null) return -1;
 		MapSymbol ms;
@@ -830,8 +841,8 @@
 
 	/**
 	 * Move the map so that the posCircle is at lat/lon
-	 * 
-	 * @param  
+	 *
+	 * @param
 	 */
 	public void updateOnlyPosition(CWPoint where, boolean updateOverlay){
 		//Point oldMapPos = getMapPositionOnScreen();
@@ -839,20 +850,20 @@
 		Point mapPos = getMapPositionOnScreen();
 		//Vm.debug(&quot;mapx = &quot; + mapx);
 		//Vm.debug(&quot;mapy = &quot; + mapy);
-		if (forceMapLoad || (java.lang.Math.abs(lastRepaintMapPos.x - mapPos.x) &gt; 1 || java.lang.Math.abs(lastRepaintMapPos.y - mapPos.y) &gt; 1)) 
+		if (forceMapLoad || (java.lang.Math.abs(lastRepaintMapPos.x - mapPos.x) &gt; 1 || java.lang.Math.abs(lastRepaintMapPos.y - mapPos.y) &gt; 1))
 		{
 			lastRepaintMapPos = mapPos;
 			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x, mapPos.y);
 			updateSymbolPositions();
 			updateDistance(false);
 			if (updateOverlay ) updateOverlayPos(); // &amp;&amp; TrackOverlays != null
-			mmp.repaintNow(); 
+			mmp.repaintNow();
 		}
 		else
 		{
 			updateDistance(true);
 		}
-		//Vm.debug(&quot;update only position&quot;);			
+		//Vm.debug(&quot;update only position&quot;);
 	}
 	/**
 	 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
@@ -887,18 +898,18 @@
 
 	public void updateGps(int fix) {
 		if (!running || ignoreGps) return;
-		// runMovingMap neccessary in case of multi-threaded Java-VM: ticked could be called during load of mmp 
+		// runMovingMap neccessary in case of multi-threaded Java-VM: ticked could be called during load of mmp
 		if ((fix &gt; 0) &amp;&amp; (myNavigation.gpsPos.getSats()&gt;= 0)) { // TODO is getSats really necessary?
 			directionArrows.setDirections((float)myNavigation.gpsPos.getBearing(myNavigation.destination),
 					(float)myNavigation.skyOrientationDir.lonDec, (float)myNavigation.gpsPos.getBear());
 			setGpsStatus(MovingMap.gotFix);
 			updatePosition(myNavigation.gpsPos);
-			ShowLastAddedPoint(myNavigation.curTrack);
+			showLastAddedPoint(myNavigation.curTrack);
 		}
 		if (fix == 0 &amp;&amp; myNavigation.gpsPos.getSats()== 0) 	setGpsStatus(MovingMap.lostFix);
 		if (fix &lt; 0 )	setGpsStatus(MovingMap.noGPSData);
 	}
-	
+
 	public void gpsStarted() {
 		addTrack(myNavigation.curTrack);
 		ignoreGps = false;
@@ -923,7 +934,7 @@
 	 * but anyway the map will be adjusted (moved) relativ to posCircle
 	 * when a better map was found the called method updateposition will set
 	 * posCirleLat/-Lon to lat/lon.
-	 * 
+	 *
 	 * @param lat
 	 * @param lon
 	 * @param loadIfSameScale false: will not change the map if the better map has the same scale as the current - this is used not to change the map if it covers already the screen completely
@@ -933,14 +944,14 @@
 		if (inBestMap) return;
 		inBestMap = true;
 		Object [] s = getRectForMapChange(where);
-		CWPoint cll = (CWPoint) s[0]; 
-		Rect screen = (Rect) s[1]; 
+		CWPoint cll = (CWPoint) s[0];
+		Rect screen = (Rect) s[1];
 		boolean posCircleOnScreen = ((Boolean) s[2]).booleanValue();
 		MapInfoObject newmap = null;
 		//if (mapChangeModus == 0) mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
 		wantMapTest = true;
 		switch (mapChangeModus) {
-		case NORMAL_KEEP_RESOLUTION: 
+		case NORMAL_KEEP_RESOLUTION:
 			lastHighestResolutionGPSDestScale = -1;
 			newmap = maps.getBestMap(cll, screen, scaleWanted, false);
 			if (newmap == null) newmap = currentMap;
@@ -950,30 +961,30 @@
 			lastHighestResolutionGPSDestScale = -1;
 			newmap = maps.getBestMap(cll, screen, 0.000001f, false);
 			break;
-		case HIGHEST_RESOLUTION_GPS_DEST: 
-			if (gotoPos!= null &amp;&amp; GpsStatus != noGPS &amp;&amp; posCircle.where.isValid()) {
+		case HIGHEST_RESOLUTION_GPS_DEST:
+			if (gotoPos!= null &amp;&amp; gpsStatus != noGPS &amp;&amp; posCircle.where.isValid()) {
 				if ( ( !posCircleOnScreen ) &amp;&amp; ( lastHighestResolutionGPSDestScale &gt; 0 ) ) {
 					newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale , false);
 				} else {
 					newmap = maps.getMapForArea(posCircle.where, gotoPos.where); // TODO use home-coos if no gps? - consider start from details panel and from gotopanel
 					if (newmap == null)	newmap = maps.getBestMap(cll, screen, 10000000000000000000000000000000000f, false); // use map with most available overview if no map containing PosCircle and GotoPos is available
-					
+
 					if (newmap != null) {
-						lastHighestResolutionGPSDestScale = newmap.scale;	
-						
+						lastHighestResolutionGPSDestScale = newmap.scale;
+
 						if (!posCircleOnScreen) {
 							newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale , false);
-						}						
+						}
 					}
 				}
 			}
 			//	either Goto-Pos or GPS-Pos not set
 			else {
 				lastHighestResolutionGPSDestScale = -1;
-				newmap = maps.getBestMap(cll, screen, 0.000001f, false); 
+				newmap = maps.getBestMap(cll, screen, 0.000001f, false);
 			}
 			break;
-		default: (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4208, &quot;Bug: \nillegal mapChangeModus: &quot;) + mapChangeModus, FormBase.OKB)).execute(); break;
+		default: (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4208, &quot;Bug: \nillegal mapChangeModus: &quot;) + mapChangeModus, MessageBox.OKB)).execute(); break;
 		}
 		if ( newmap != null &amp;&amp; (currentMap == null || !currentMap.mapName.equals(newmap.mapName)) ) {
 			if (loadIfSameScale || !MapsList.scaleEquals(currentMap.scale / currentMap.zoomFactor, newmap) ) {
@@ -988,11 +999,11 @@
 			// (new MessageBox(&quot;Information&quot;, &quot;F&#252;r die aktuelle Position steht keine Karte zur Verf&#252;ng, bitte w&#228;hlen Sie eine manuell&quot;, MessageBox.OKB)).execute();
 			posCircle.where.set(cll); // choosemap calls setmap with posCircle-coos
 			try {
-				setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), where); // beware: &quot;-4&quot; only works if the empty maps were added last see MapsList.addEmptyMaps
-			} catch (IOException e) { (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4209, &quot;setBestMap: problem in: setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), lat, lon) lat/lon:&quot;) + where.toString(), FormBase.OKB)).exec(); }
+				setMap( ((MapListEntry)maps.elementAt(maps.size() - 4)).getMap(), where); // beware: &quot;-4&quot; only works if the empty maps were added last see MapsList.addEmptyMaps
+			} catch (IOException e) { (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4209, &quot;setBestMap: problem in: setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), lat, lon) lat/lon:&quot;) + where.toString(), MessageBox.OKB)).exec(); }
 			while (currentMap == null) { // this actually cannot happen, but maybe in case of an inconstistent code change (esp. regarding empty maps)
-				mmp.chooseMap(); // force the user to select a scale 
-				 if (currentMap == null) (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4210, &quot;Moving map cannot run without a map - please select one. \n You can select an empty map&quot;), FormBase.OKB)).execute();
+				mmp.chooseMap(); // force the user to select a scale
+				 if (currentMap == null) (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4210, &quot;Moving map cannot run without a map - please select one. \n You can select an empty map&quot;), MessageBox.OKB)).execute();
 			}
 		}
 		inBestMap = false;
@@ -1007,10 +1018,10 @@
 	}
 	/**
 	 * method to get a point on the screen which must be included in the map
-	 * the map methods are looking for. If the poscircle is on the screen this will be 
+	 * the map methods are looking for. If the poscircle is on the screen this will be
 	 * that point. If it is outside then the centre of the screen will be used.
-	 * 
-	 * returns [0] = CWPoint of that point, [1] Rect describing the screen around it 
+	 *
+	 * returns [0] = CWPoint of that point, [1] Rect describing the screen around it
 	 * @param lat
 	 * @param lon
 	 * @return
@@ -1027,19 +1038,19 @@
 			y = posCircleY; // TODO eigentlich interessiert, ob nach dem evtl. Kartenwechsel PosCircle on Screen ist. So wie es jetzt ist, kann 2mal der gleiche Aufruf zum laden unterschiedlicher Karten f&#252;hren, wenn vorher PosCircle nicht auf dem SChirm war, nach dem ersten Laden aber schon.
 			cll = new CWPoint(ll);
 		} else { // when posCircle out of screen - use centre of screen as point which as to be included in the map
-			cll = ScreenXY2LatLon(w/2, h/2);
+			cll = screenXY2LatLon(w/2, h/2);
 			x = w/2;
 			y = h/2;
-		} 
+		}
 		Object[] ret = new Object[3];
 		ret[0] = cll;
 		ret[1] = new Rect(x, y, w, h);
 		ret[2] = posCircleOnScreen;
-		return ret; 
+		return ret;
 	}
 
 	/**
-	 * 
+	 *
 	 * @param betterOverview true: getmap with better overview
 	 * @return
 	 */
@@ -1050,11 +1061,11 @@
 
 		CWPoint cll;
 		if (currentMap != null) {
-			cll = ScreenXY2LatLon(w/2, h/2);
+			cll = screenXY2LatLon(w/2, h/2);
 		} else {
 			cll = new CWPoint(posCircle.where);
 		}
-		
+
 		MapInfoObject m = maps.getMapChangeResolution(cll, screen, currentMap.scale / currentMap.zoomFactor, !betterOverview);
 		if (m != null) {
 			boolean saveGpsIgnStatus = dontUpdatePos;
@@ -1063,33 +1074,33 @@
 			setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
 			dontUpdatePos = saveGpsIgnStatus;
 		}
-		else (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4211, &quot;No &quot;) + 
-				(betterOverview ? MyLocale.getMsg(4212, &quot;less&quot;) : MyLocale.getMsg(4213, &quot;more&quot;) ) + 
-				MyLocale.getMsg(4214, &quot; detailed map available&quot;), 
-				FormBase.OKB)).execute();
+		else (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4211, &quot;No &quot;) +
+				(betterOverview ? MyLocale.getMsg(4212, &quot;less&quot;) : MyLocale.getMsg(4213, &quot;more&quot;) ) +
+				MyLocale.getMsg(4214, &quot; detailed map available&quot;),
+				MessageBox.OKB)).execute();
 	}
 
 	public void loadMapForAllCaches(){
 		Area sur = Global.getProfile().getSourroundingArea(true);
 		if (sur == null) {
-			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4215, &quot;Keine  Caches mit H&#228;ckchen ausgew&#228;hlt&quot;), FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4215, &quot;Keine  Caches mit H&#228;ckchen ausgew&#228;hlt&quot;), MessageBox.OKB)).execute();
 			return;
 		}
 		MapInfoObject newmap = maps.getMapForArea(sur.topleft, sur.buttomright);
 		if (newmap == null ) { // no map that includs all caches is available -&gt; load map with lowest resolution
 			Object [] s = getRectForMapChange(posCircle.where);
-			CWPoint cll = (CWPoint) s[0]; 
-			Rect screen = (Rect) s[1]; 
+			CWPoint cll = (CWPoint) s[0];
+			Rect screen = (Rect) s[1];
 			newmap = maps.getBestMap(cll, screen, Float.MAX_VALUE -1, false);
 		}
 		if (newmap == null) { // no map is covering any area of the caches -&gt; zoom an empty map to cover all caches on screen
 			try {
 				Object [] s = getRectForMapChange(posCircle.where);
-			//	CWPoint cll = (CWPoint) s[0]; 
-				Rect screen = (Rect) s[1]; 
+			//	CWPoint cll = (CWPoint) s[0];
+				Rect screen = (Rect) s[1];
 				float neededscalex = (float) (sur.topleft.getDistance(sur.topleft.latDec, sur.buttomright.lonDec) * 1000 / (screen.width-15)); // 15 for the size of the cache image
 				float neededscaley = (float) (sur.topleft.getDistance(sur.buttomright.latDec, sur.topleft.lonDec) * 1000 / (screen.height-15)); // 15 for the size of the cache image
-				newmap = ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(); // beware: &quot;-4&quot; only works if the empty maps were added last see MapsList.addEmptyMaps
+				newmap = ((MapListEntry)maps.elementAt(maps.size() - 4)).getMap(); // beware: &quot;-4&quot; only works if the empty maps were added last see MapsList.addEmptyMaps
 				newmap.zoom(newmap.scale * newmap.zoomFactor / (neededscalex &gt; neededscaley ? neededscalex : neededscaley), 0, 0);
 				forceMapLoad = true;
 			} catch (IOException e) { (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4279, &quot;loadMapForAllCaches: IO-Exception in: newmap = ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap();&quot;), FormBase.OKB)).exec(); }
@@ -1102,8 +1113,8 @@
 	}
 
 	public void setGpsStatus (int status) {
-		if (status == GpsStatus) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
-		GpsStatus = status;
+		if (status == gpsStatus) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
+		gpsStatus = status;
 		dontUpdatePos = false;
 		ignoreGps = false;
 		switch (status) {
@@ -1112,11 +1123,11 @@
 		case lostFix:   { posCircle.change(statusImageNoSignal); break; }
 		case noGPSData: { posCircle.change(statusImageNoGps); break; }
 		}
-		mapMoved(0, 0); // positions the posCircle correctly accourding to its size (which can change when the image changes, e.g. from null to something else 
-		posCircle.refreshNow();
+		mapMoved(0, 0); // positions the posCircle correctly accourding to its size (which can change when the image changes, e.g. from null to something else
+		posCircle.refresh(); // was refreshNow
 	}
 
-	public void SnapToGps() {
+	public void snapToGps() {
 		resetCenterOfMap();
 		dontUpdatePos = false;
 		ignoreGps = false;
@@ -1125,31 +1136,31 @@
 		autoSelectMap = true;
 		forceMapLoad = true;
 		showMap();
-		if (myNavigation.gpsPos.Fix &lt;=0) updatePosition(posCircle.where);
+		if (myNavigation.gpsPos.fix &lt;=0) updatePosition(posCircle.where);
 		else updateGps(myNavigation.gpsPos.getFix());
 	}
 
 	/** sets and displays the map
-	 * 
+	 *
 	 * @param newmap
 	 * @param lat move map so that lat/lon is in the centre / -361: don't adust to lat/lon
 	 * @param lon -361: don't adust to lat/lon
 	 */
 	public void setMap(MapInfoObject newmap, CWPoint where) {
-		if (currentMap != null &amp;&amp; newmap.mapName.equals(currentMap.mapName) &amp;&amp; !forceMapLoad) { // note: newmap.mapName == currentMap.mapName won't work because they are different String containing the same text 
-			updateOnlyPosition(where, true); 
+		if (currentMap != null &amp;&amp; newmap.mapName.equals(currentMap.mapName) &amp;&amp; !forceMapLoad) { // note: newmap.mapName == currentMap.mapName won't work because they are different String containing the same text
+			updateOnlyPosition(where, true);
 			return;
 		}
-		Vm.showWait(true);
+		Form.showWait();
 		boolean saveIgnoreStatus;
 		saveIgnoreStatus = dontUpdatePos;
 		dontUpdatePos = true;  // make updatePosition ignore calls during loading new map
 		InfoBox inf;
 		inf = new InfoBox(MyLocale.getMsg(4201, &quot;Information&quot;), MyLocale.getMsg(4216, &quot;Loading map...&quot;));
 		inf.show();
-		inf.waitUntilPainted(100);
+		inf.getWindow().waitUntilPainted(100);
 		try {
-			this.currentMap = newmap; 
+			this.currentMap = newmap;
 			this.title = currentMap.mapName;
 			lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
 			lastCompareY = Integer.MAX_VALUE;
@@ -1158,20 +1169,20 @@
 				mmp.removeImage(mmp.mapImage); mmp.mapImage.free(); mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
 
 				//Vm.debug(&quot;free: &quot;+Vm.getUsedMemory(false)+&quot;classMemory: &quot;+Vm.getClassMemory()+ &quot;after garbage collection: &quot;+Vm.getUsedMemory(false));
-				Vm.getUsedMemory(true); // calls the garbage collection
+				Vm.getUsedObjectMemory(true); // calls the garbage collection
 			} // give memory free before loading the new map to avoid out of memory error
-			String ImageFilename = currentMap.getImageFilename(); 
+			String ImageFilename = currentMap.getImageFilename();
 			if (ImageFilename == null ) {
 				mmp.mapImage = new MapImage();
 				maps.remove(currentMap);
-				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4217, &quot;Could not find image associated with: \n&quot;)+currentMap.fileNameWFL, FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4217, &quot;Could not find image associated with: \n&quot;)+currentMap.fileNameWFL, MessageBox.OKB)).execute();
 			}
-			else { 
+			else {
 				if (ImageFilename.length() &gt; 0) mmp.mapImage = new MapImage(ImageFilename); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
 				else mmp.mapImage = new MapImage(); // no image associated with the calibration info (&quot;empty map&quot;)
 			}
 			mapImage1to1 = mmp.mapImage;
-			mmp.mapImage.properties = mmp.mapImage.properties | mImage.IsMoveable;
+			mmp.mapImage.properties = mmp.mapImage.properties | AniImage.IsMoveable;
 			if (mapHidden) mmp.mapImage.hide();
 			mmp.mapImage.move(0,0);
 			mmp.addImage(mmp.mapImage);
@@ -1182,54 +1193,54 @@
 			forceMapLoad = false;
 			directionArrows.setMap(currentMap);
 			updateScale();
-			inf.close(0);  // this doesn't work in a ticked-thread in the ewe-vm. That's why i made a new mThread in gotoPanel for ticked
-			Vm.showWait(false);
+			inf.close(0);  // this doesn't work in a ticked-thread in the eve-vm. That's why i made a new mThread in gotoPanel for ticked
+			Form.cancelWait();
 			dontUpdatePos = saveIgnoreStatus;
-		} catch (IllegalArgumentException e) { // thrown by new AniImage() in ewe-vm if file not found;
+		} catch (IllegalArgumentException e) { // thrown by new AniImage() in eve-vm if file not found;
 			if (mmp.mapImage != null) {
-				mmp.removeImage(mmp.mapImage); 
+				mmp.removeImage(mmp.mapImage);
 				mmp.mapImage.free();
 				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
 			}
 			rebuildOverlaySet();
 			updateOnlyPosition(where, false);
 			inf.close(0);
-			Vm.showWait(false);
-			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4218, &quot;Could not load map: \n&quot;)+ newmap.getImageFilename(), FormBase.OKB)).execute();
+			Form.cancelWait();
+			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4218, &quot;Could not load map: \n&quot;)+ newmap.getImageFilename(), MessageBox.OKB)).execute();
 			dontUpdatePos = saveIgnoreStatus;
 		} catch (OutOfMemoryError e) {
 			if (mmp.mapImage != null) {
-				mmp.removeImage(mmp.mapImage); 
+				mmp.removeImage(mmp.mapImage);
 				mmp.mapImage.free();
 				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
 			}
 			rebuildOverlaySet();
 			updateOnlyPosition(where, false);
 			inf.close(0);
-			Vm.showWait(false);
-			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4219, &quot;Not enough memory to load map: \n&quot;) 
+			Form.cancelWait();
+			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4219, &quot;Not enough memory to load map: \n&quot;)
 					+ newmap.getImageFilename()
-					+ MyLocale.getMsg(4220, &quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;), 
-					FormBase.OKB)).execute();
+					+ MyLocale.getMsg(4220, &quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;),
+					MessageBox.OKB)).execute();
 			dontUpdatePos = saveIgnoreStatus;
 		}catch (SystemResourceException e) {
 			if (mmp.mapImage != null) {
-				mmp.removeImage(mmp.mapImage); 
+				mmp.removeImage(mmp.mapImage);
 				mmp.mapImage.free();
 				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
 			}
 			rebuildOverlaySet();
-			updateOnlyPosition(where, false); // TODO this doesn't work correctly if the resolution changed, I guess because the pixels of PosCircle will be interpreted from the new resolution, but should be interpreted using the old resolution to test: select a map with a much greater value of m per pixel manually 
+			updateOnlyPosition(where, false); // TODO this doesn't work correctly if the resolution changed, I guess because the pixels of PosCircle will be interpreted from the new resolution, but should be interpreted using the old resolution to test: select a map with a much greater value of m per pixel manually
 			inf.close(0);
-			Vm.showWait(false);
+			Form.cancelWait();
 			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4221, &quot;Not enough ressources to load map: &quot;)
 					+ newmap.getImageFilename()
-					+ MyLocale.getMsg(4220, &quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;), 
-					FormBase.OKB)).execute();
+					+ MyLocale.getMsg(4220, &quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;),
+					MessageBox.OKB)).execute();
 			dontUpdatePos = saveIgnoreStatus;
 		}
 	}
-	
+
 	private void updateAfterMapChange(CWPoint newCenter) {
 		if (!posCircle.where.isValid()) {
 			posCircle.where.set(newCenter);
@@ -1242,17 +1253,17 @@
 		int mapPosY = h/2 - centerOnMap.y;
 		int newPosCircleX = mapPosX + circlePosOnMap.x;
 		int newPosCircleY = mapPosY + circlePosOnMap.y;
-		
+
 		if (mmp != null &amp;&amp; mmp.mapImage != null) mmp.mapImage.move(mapPosX, mapPosY);
-		
+
 		int wCircle = posCircle.getWidth();
 		int hCircle = posCircle.getHeight();
-		int npx = newPosCircleX-wCircle/2; 
+		int npx = newPosCircleX-wCircle/2;
 		int npy = newPosCircleY-hCircle/2;
 		posCircle.move(npx, npy);
 		posCircleX = newPosCircleX;
 		posCircleY = newPosCircleY;
-		
+
 		updateOnlyPosition(posCircle.where, true);
 	}
 
@@ -1283,9 +1294,9 @@
 	 * @param h
 	 */
 	public void zoomScreenRect(Point firstclickpoint, int w, int h) {
-		int newImageWidth = (int) (this.width *  (this.width  &lt; 481 ? 2 : 1.6)); // (maximal) size of the zoomed image 
-		int newImageHeight= (int) (this.height * (this.width &lt; 481 ?  2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors 
-		CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y + h/2);
+		int newImageWidth = (int) (this.width *  (this.width  &lt; 481 ? 2 : 1.6)); // (maximal) size of the zoomed image
+		int newImageHeight= (int) (this.height * (this.width &lt; 481 ?  2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors
+		CWPoint center = screenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y + h/2);
 		float zoomFactor;
 		if (h &lt; 0) {
 			h = java.lang.Math.abs(h);
@@ -1306,32 +1317,32 @@
 		int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w/2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth /2);
 		int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h/2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight /2);
 		Rect newImageRect = new Rect(xinunscaledimage , yinunscaledimage, newImageWidth, newImageHeight);
-		if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.image != null)
+		if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.getImageData() != null)
 		{
 			// try to avoid overlapping by shifting
-			if (newImageRect.x &lt; 0) 
+			if (newImageRect.x &lt; 0)
 				newImageRect.x = 0; // align left if left overlapping
-			if (newImageRect.y &lt; 0) 
+			if (newImageRect.y &lt; 0)
 				newImageRect.y = 0;
-			if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth()) 
+			if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth())
 				newImageRect.x = mapImage1to1.getWidth()- newImageWidth; // align right if right overlaping
-			if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight()) 
+			if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight())
 				newImageRect.y = mapImage1to1.getHeight()- newImageHeight;
 			// crop if after shifting still overlapping
-			if (newImageRect.x &lt; 0) 
+			if (newImageRect.x &lt; 0)
 				newImageRect.x = 0;
-			if (newImageRect.y &lt; 0) 
+			if (newImageRect.y &lt; 0)
 				newImageRect.y = 0;
-			if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth()) 
+			if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth())
 				newImageRect.width = mapImage1to1.getWidth() - newImageRect.x;
-			if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight()) 
+			if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight())
 				newImageRect.height= mapImage1to1.getHeight()- newImageRect.y;
 		}
 		zoomFromUnscaled(zoomFactor * currentMap.zoomFactor, newImageRect, center);
 	}
 
 	public void zoom1to1() {
-		CWPoint center = ScreenXY2LatLon(this.width /2 , this.height/2);
+		CWPoint center = screenXY2LatLon(this.width /2 , this.height/2);
 		if (mapImage1to1 != null) zoomFromUnscaled(1, new Rect(0,0,mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
 		else zoomFromUnscaled(1, new Rect(0,0, 1,1), center);
 	}
@@ -1341,13 +1352,13 @@
 	 * @param zoomFactor relative to original image
 	 * @param newImageRect Rect in the 1:1 image that contains the area to be zoomed into
 	 * @param center
-	 */		
+	 */
 	public void zoomFromUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
-		Vm.showWait(this, true);
+		Form.showWait();
 		boolean savegpsstatus = dontUpdatePos;
 		if (mapImage1to1 != null) {
 			dontUpdatePos = true; // avoid multi-thread problems
-			int saveprop = mImage.IsMoveable;
+			int saveprop = AniImage.IsMoveable;
 			MapImage tmp = null; // = mmp.mapImage;
 			if (mmp.mapImage != null) {
 				tmp = mmp.mapImage;
@@ -1358,37 +1369,43 @@
 					mmp.mapImage = null;
 				} else tmp = mapImage1to1;
 			}
-			Vm.getUsedMemory(true);
+			Vm.getUsedObjectMemory(true);
 			try {
 				if (zoomFactor == 1) tmp = mapImage1to1;
-				else tmp = new MapImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor), (int)(newImageRect.height*zoomFactor), newImageRect, 0));
+				else tmp = new MapImage(
+						new Picture(
+								ImageTool.scale(
+										mapImage1to1.getImageData(),
+										(int) (newImageRect.width*zoomFactor),
+										(int)(newImageRect.height*zoomFactor),0).getImageData(),0
+										)); //, newImageRect, 0));
 				currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
 			} catch (OutOfMemoryError e) {
-				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), 
-						MyLocale.getMsg(4222, &quot;Out of memory error&quot;), FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;),
+						MyLocale.getMsg(4222, &quot;Out of memory error&quot;), MessageBox.OKB)).execute();
 				//tmp = mapImage1to1;
 			} //if (tmp != null) currentMap.zoom();}
-			Vm.getUsedMemory(true);
+			Vm.getUsedObjectMemory(true);
 			mmp.mapImage = tmp; // use unscaled or no image in case of OutOfMemoryError
 			mmp.mapImage.properties = saveprop;
 			if (mapHidden) mmp.mapImage.hide();
 			mmp.addImage(mmp.mapImage);
 			mmp.images.moveToBack(mmp.mapImage);
-			if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.image != null)
+			if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.getImageData() != null)
 			{
 				Point mappos = getMapPositionOnScreen();
 				mmp.mapImage.move(mappos.x,mappos.y);
 			}
-		} else // no map image loaded 
+		} else // no map image loaded
 		{ currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y); }
 		// scaleWanted = currentMap.scale; use this if you want to change automatically to a map scale that best fits the zooming
 		destroyOverlaySet();
-		Vm.getUsedMemory(true); // call garbage collection
+		Vm.getUsedObjectMemory(true); // call garbage collection
 		setCenterOfScreen(center, false);
 		addOverlaySet();
 		updateScale();
 		this.repaintNow();
-		Vm.showWait(this, false);
+		Form.cancelWait();
 		dontUpdatePos = savegpsstatus;
 	}
 
@@ -1403,7 +1420,7 @@
 	public void onEvent(Event ev){
 		if(ev instanceof FormEvent &amp;&amp; (ev.type == FormEvent.CLOSED )){
 			running = false;
-		}  
+		}
 		if( ev instanceof KeyEvent &amp;&amp; ev.target == this &amp;&amp; ( (((KeyEvent)ev).key == IKeys.ESCAPE) || (((KeyEvent)ev).key == IKeys.ENTER) || (((KeyEvent)ev).key == IKeys.ACTION) ) ) {
 			this.close(0);
 			ev.consumed = true;
@@ -1420,29 +1437,29 @@
 	MenuItem gotoMenuItem = new MenuItem(MyLocale.getMsg(4230, &quot;Goto here$g&quot;), 0, null);
 	MenuItem newWayPointMenuItem = new MenuItem(MyLocale.getMsg(4232, &quot;Create new Waypoint here$n&quot;), 0, null);;
 	MenuItem openCacheDescMenuItem,addCachetoListMenuItem;
-	
+
 	MenuItem miLuminary[];
 
 	Menu mapsMenu;
-	MenuItem selectMapMI = new MenuItem(MyLocale.getMsg(4234, &quot;Select a map manually$s&quot;), new IconAndText(new mImage(&quot;map_open.png&quot;), MyLocale.getMsg(4235, &quot;Select a map manually&quot;), null, CellConstants.RIGHT));
-	MenuItem changeMapDirMI = new MenuItem(MyLocale.getMsg(4236, &quot;Change map directory$c&quot;), new IconAndText(new mImage(&quot;map_cd.png&quot;), MyLocale.getMsg(4237, &quot;Change map directory&quot;), null, CellConstants.RIGHT));
-	MenuItem showMapMI = new MenuItem(MyLocale.getMsg(4238, &quot;Show map&quot;), new IconAndText(new mImage(&quot;map_on.png&quot;), MyLocale.getMsg(4239, &quot;Show map&quot;), null, CellConstants.RIGHT));
-	MenuItem hideMapMI = new MenuItem(MyLocale.getMsg(4240, &quot;Hide map&quot;), new IconAndText(new mImage(&quot;map_off.png&quot;), MyLocale.getMsg(4241, &quot;Hide map&quot;), null, CellConstants.RIGHT));
+	MenuItem selectMapMI = new MenuItem(MyLocale.getMsg(4234, &quot;Select a map manually$s&quot;), new IconAndText(new Picture(&quot;map_open.png&quot;), MyLocale.getMsg(4235, &quot;Select a map manually&quot;), null, Graphics.RIGHT));
+	MenuItem changeMapDirMI = new MenuItem(MyLocale.getMsg(4236, &quot;Change map directory$c&quot;), new IconAndText(new Picture(&quot;map_cd.png&quot;), MyLocale.getMsg(4237, &quot;Change map directory&quot;), null, Graphics.RIGHT));
+	MenuItem showMapMI = new MenuItem(MyLocale.getMsg(4238, &quot;Show map&quot;), new IconAndText(new Picture(&quot;map_on.png&quot;), MyLocale.getMsg(4239, &quot;Show map&quot;), null, Graphics.RIGHT));
+	MenuItem hideMapMI = new MenuItem(MyLocale.getMsg(4240, &quot;Hide map&quot;), new IconAndText(new Picture(&quot;map_off.png&quot;), MyLocale.getMsg(4241, &quot;Hide map&quot;), null, Graphics.RIGHT));
 	// automatic
 	MenuItem mapChangeModusMI = new MenuItem(MyLocale.getMsg(4242, &quot;Modus for automatic map change&quot;), MenuItem.Separator, null);;
-	MenuItem highestResGpsDestMI = new MenuItem(MyLocale.getMsg(4244, &quot;Highest res. containing dest. &amp; cur. position&quot;), new IconAndText(new mImage(&quot;res_gps_goto.png&quot;), MyLocale.getMsg(4245, &quot;Highest res. containing dest. &amp; cur. position&quot;), null, CellConstants.RIGHT)); //immer h&#246;chste Aufl&#246;sung w&#228;hlen, die akt. Pos. und Ziel enthalten 
-	MenuItem highestResolutionMI = new MenuItem(MyLocale.getMsg(4246, &quot;Highest resolution&quot;), new IconAndText(new mImage(&quot;res_high.png&quot;), MyLocale.getMsg(4247, &quot;Highest resolution&quot;), null, CellConstants.RIGHT)); //immer h&#246;chste Aufl&#246;sung w&#228;hlen 
-	MenuItem keepManResolutionMI = new MenuItem(MyLocale.getMsg(4248, &quot;Keep manual resolution&quot;), new IconAndText(new mImage(&quot;res_manuell.png&quot;), MyLocale.getMsg(4249, &quot;Keep manual resolution&quot;), null, CellConstants.RIGHT)); // manuell gew&#228;hlte Aufl&#246;sung beibehalten  
+	MenuItem highestResGpsDestMI = new MenuItem(MyLocale.getMsg(4244, &quot;Highest res. containing dest. &amp; cur. position&quot;), new IconAndText(new Picture(&quot;res_gps_goto.png&quot;), MyLocale.getMsg(4245, &quot;Highest res. containing dest. &amp; cur. position&quot;), null, Graphics.RIGHT)); //immer h&#246;chste Aufl&#246;sung w&#228;hlen, die akt. Pos. und Ziel enthalten
+	MenuItem highestResolutionMI = new MenuItem(MyLocale.getMsg(4246, &quot;Highest resolution&quot;), new IconAndText(new Picture(&quot;res_high.png&quot;), MyLocale.getMsg(4247, &quot;Highest resolution&quot;), null, Graphics.RIGHT)); //immer h&#246;chste Aufl&#246;sung w&#228;hlen
+	MenuItem keepManResolutionMI = new MenuItem(MyLocale.getMsg(4248, &quot;Keep manual resolution&quot;), new IconAndText(new Picture(&quot;res_manuell.png&quot;), MyLocale.getMsg(4249, &quot;Keep manual resolution&quot;), null, Graphics.RIGHT)); // manuell gew&#228;hlte Aufl&#246;sung beibehalten
 	// manuell
 	MenuItem mapChangeResMI = new MenuItem(MyLocale.getMsg(4250, &quot;Change resolution manually&quot;), MenuItem.Separator, null);;
-	MenuItem AllCachesResMI = new MenuItem(MyLocale.getMsg(4252, &quot;Load a map containing all marked caches&quot;),  new IconAndText(new mImage(&quot;loupe_all.png&quot;), MyLocale.getMsg(4253, &quot;Load a map containing all marked caches&quot;), null, CellConstants.RIGHT));   
-	MenuItem moreDetailsMI = new MenuItem(MyLocale.getMsg(4254, &quot;Load a map with more details&quot;), new IconAndText(new mImage(&quot;loupe_more_details.png&quot;), MyLocale.getMsg(4255, &quot;Load a map with more details&quot;), null, CellConstants.RIGHT)); // laod a map with more details 
-	MenuItem moreOverviewMI = new MenuItem(MyLocale.getMsg(4256, &quot;Load a map for a better overview&quot;), new IconAndText(new mImage(&quot;loupe_better_overview.png&quot;), MyLocale.getMsg(4257, &quot;Load a map for a better overview&quot;), null, CellConstants.RIGHT)); // Load a map for a better overview --&gt; lesser details  
+	MenuItem AllCachesResMI = new MenuItem(MyLocale.getMsg(4252, &quot;Load a map containing all marked caches&quot;),  new IconAndText(new Picture(&quot;loupe_all.png&quot;), MyLocale.getMsg(4253, &quot;Load a map containing all marked caches&quot;), null, Graphics.RIGHT));
+	MenuItem moreDetailsMI = new MenuItem(MyLocale.getMsg(4254, &quot;Load a map with more details&quot;), new IconAndText(new Picture(&quot;loupe_more_details.png&quot;), MyLocale.getMsg(4255, &quot;Load a map with more details&quot;), null, Graphics.RIGHT)); // laod a map with more details
+	MenuItem moreOverviewMI = new MenuItem(MyLocale.getMsg(4256, &quot;Load a map for a better overview&quot;), new IconAndText(new Picture(&quot;loupe_better_overview.png&quot;), MyLocale.getMsg(4257, &quot;Load a map for a better overview&quot;), null, Graphics.RIGHT)); // Load a map for a better overview --&gt; lesser details
 	// move map to
 	MenuItem moveToMI = new MenuItem(MyLocale.getMsg(4258, &quot;Move map to and load map&quot;), MenuItem.Separator, null);;
-	MenuItem moveToDestMI = new MenuItem(MyLocale.getMsg(4260, &quot;Move to goto point&quot;), new IconAndText(new mImage(&quot;move2goto.png&quot;), MyLocale.getMsg(4261, &quot;Move to goto point&quot;), null, CellConstants.RIGHT)); //* Karte zum Ziel verschieben (und ggf. entsprechende Karte laden) 
-	MenuItem moveToGpsMI = new MenuItem(MyLocale.getMsg(4262, &quot;Move to GPS position&quot;), new IconAndText(new mImage(&quot;move2gps.png&quot;), MyLocale.getMsg(4263, &quot;Move to GPS position&quot;), null, CellConstants.RIGHT));   
-	MenuItem moveToCenterMI = new MenuItem(MyLocale.getMsg(4264, &quot;Move to centre&quot;), new IconAndText(new mImage(&quot;move2center.png&quot;), MyLocale.getMsg(4265, &quot;Move to centre&quot;), null, CellConstants.RIGHT));   
+	MenuItem moveToDestMI = new MenuItem(MyLocale.getMsg(4260, &quot;Move to goto point&quot;), new IconAndText(new Picture(&quot;move2goto.png&quot;), MyLocale.getMsg(4261, &quot;Move to goto point&quot;), null, Graphics.RIGHT)); //* Karte zum Ziel verschieben (und ggf. entsprechende Karte laden)
+	MenuItem moveToGpsMI = new MenuItem(MyLocale.getMsg(4262, &quot;Move to GPS position&quot;), new IconAndText(new Picture(&quot;move2gps.png&quot;), MyLocale.getMsg(4263, &quot;Move to GPS position&quot;), null, Graphics.RIGHT));
+	MenuItem moveToCenterMI = new MenuItem(MyLocale.getMsg(4264, &quot;Move to centre&quot;), new IconAndText(new Picture(&quot;move2center.png&quot;), MyLocale.getMsg(4265, &quot;Move to centre&quot;), null, Graphics.RIGHT));
 
 	CacheHolder clickedCache;
 	MovingMap mm;
@@ -1458,7 +1475,7 @@
 		for (int i=0; i&lt;SkyOrientation.LUMINARY_NAMES.length; i++) {
 			miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i));
 		}
-		set(ControlConstants.WantHoldDown, true); // want to get simulated right-clicks
+		set(Control.WantHoldDown, true); // want to get simulated right-clicks
 	}
 
 	public boolean imageBeginDragged(AniImage which,Point pos) {
@@ -1470,12 +1487,13 @@
 		}
 		// move (drag) map
 		//if (!(which == null || which == mapImage || which instanceof TrackOverlay || which == mm.directionArrows) ) return false;
-		saveGpsIgnoreStatus = mm.dontUpdatePos; 
+		saveGpsIgnoreStatus = mm.dontUpdatePos;
 		mm.dontUpdatePos = true;
 		saveMapLoc = pos;
 		bringMapToTop();
-		if (mapImage.isOnScreen() &amp;&amp; !mapImage.hidden ) return super.imageBeginDragged(mapImage, pos);
-		else return super.imageBeginDragged(null, pos);
+		if (mapImage.isOnScreen() &amp;&amp; !mapImage.hidden )
+			return super.imageBeginDragged(mapImage, pos);
+		return super.imageBeginDragged(null, pos);
 	}
 
 	public boolean imageNotDragged(ImageDragContext dc,Point pos){
@@ -1498,7 +1516,7 @@
 			saveMapLoc = new Point (ev.x, ev.y);
 			paintingZoomArea = true;
 			mm.zoomingMode = true;
-		} 
+		}
 		if (!mm.zoomingMode &amp;&amp; ev.type == PenEvent.PEN_DOWN &amp;&amp; ev.modifiers == PenEvent.RIGHT_BUTTON) {
 			penHeld(new Point (ev.x, ev.y));
 		}
@@ -1517,7 +1535,7 @@
 
 		if (mm.zoomingMode &amp;&amp; paintingZoomArea &amp;&amp; (ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {
 			int left, top;
-			Graphics dr = this.getGraphics();
+			Graphics dr = this.getGraphics().getGraphics();
 			if (lastZoomWidth &lt; 0)left = saveMapLoc.x + lastZoomWidth;
 			else left = saveMapLoc.x;
 			if (lastZoomHeight &lt; 0)top = saveMapLoc.y + lastZoomHeight;
@@ -1526,13 +1544,13 @@
 			top -= 2;
 			if (top &lt; 0) top = 0;
 			if (left &lt; 0) left = 0;
-			if ((lastZoomWidth &lt;= 0) &amp;&amp; (ev.x - saveMapLoc.x &gt; 0)) { // changed from zooming out to zooming in 
+			if ((lastZoomWidth &lt;= 0) &amp;&amp; (ev.x - saveMapLoc.x &gt; 0)) { // changed from zooming out to zooming in
 				removeImage(mm.buttonImageLensActivated);
 				removeImage(mm.buttonImageLensActivatedZoomOut);
 				addImage(mm.buttonImageLensActivatedZoomIn);
 				this.repaintNow(dr, new Rect(mm.buttonImageLensActivatedZoomIn.location.x, mm.buttonImageLensActivatedZoomIn.location.y, mm.buttonImageLensActivatedZoomIn.getWidth(), mm.buttonImageLensActivatedZoomIn.getHeight()));
 			}
-			if ((lastZoomWidth &gt;= 0) &amp;&amp; (ev.x - saveMapLoc.x &lt; 0)) { // changed from zooming out to zooming in 
+			if ((lastZoomWidth &gt;= 0) &amp;&amp; (ev.x - saveMapLoc.x &lt; 0)) { // changed from zooming out to zooming in
 				removeImage(mm.buttonImageLensActivated);
 				removeImage(mm.buttonImageLensActivatedZoomIn);
 				addImage(mm.buttonImageLensActivatedZoomOut);
@@ -1545,8 +1563,8 @@
 			else left = saveMapLoc.x;
 			if (lastZoomHeight &lt; 0)top = saveMapLoc.y + lastZoomHeight;
 			else top = saveMapLoc.y;
-			dr.setPen(new Pen(new Color(255,0,0),Pen.SOLID,3));
-			dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight), 0); // bug in ewe: thickness parameter is ignored
+			dr.changePen(new Color(255,0,0),Pen.SOLID,3);
+			dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight)); // bug in eve: thickness parameter is ignored
 		}
 		super.onPenEvent(ev);
 	}
@@ -1568,7 +1586,7 @@
 	}
 
 	public void moveMap(int diffX, int diffY) {
-		Point p = new Point();
+		Point p;
 		if (mapImage!= null) {
 			p = mapImage.locAlways;
 			mapImage.move(p.x+diffX,p.y+diffY);
@@ -1586,14 +1604,14 @@
 		super.doPaint(g, area);
 		if (mm.gotoPos != null) {
 			Point dest = mm.getXYonScreen(mm.gotoPos.where);
-			g.setPen(new Pen(Color.DarkBlue, Pen.SOLID, 3));
+			g.changePen(Color.DarkBlue, Pen.SOLID, 3);
 			g.drawLine(mm.posCircleX, mm.posCircleY, dest.x, dest.y);
 		}
 	}
 
 	public void chooseMap() {
 		CWPoint gpspos;
-		if (mm.myNavigation.gpsPos.Fix &gt; 0) gpspos = new CWPoint(mm.myNavigation.gpsPos.latDec, mm.myNavigation.gpsPos.lonDec);
+		if (mm.myNavigation.gpsPos.fix &gt; 0) gpspos = new CWPoint(mm.myNavigation.gpsPos.latDec, mm.myNavigation.gpsPos.lonDec);
 		else gpspos = null;
 		ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos(), mm.currentMap);
 		if(l.execute() == FormBase.IDOK){
@@ -1606,12 +1624,12 @@
 			} else {
 				mm.setGpsStatus(MovingMap.noGPS);
 				mm.ignoreGps = true;
-				mm.setMap(l.selectedMap, mm.posCircle.where); 
+				mm.setMap(l.selectedMap, mm.posCircle.where);
 				if (mm.currentMap.fileNameWFL.length() &gt; 0)
 					mm.setCenterOfScreen(l.selectedMap.center, true); // if map has an image
 				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
 				//Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
-				//double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4]; 
+				//double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4];
 				//mm.posCircleX = 0; // place map to the upper left corner of windows
 				//mm.posCircleY = 0;
 				//mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
@@ -1623,11 +1641,11 @@
 	 *	Method to react to user.
 	 */
 	public void imageClicked(AniImage which, Point pos){
-		if (which == mm.bottonImageChooseMap){
+		if (which == mm.buttonImageChooseMap){
 			mapsMenu = new Menu();
 			mapsMenu.addItem(selectMapMI);
 			mapsMenu.addItem(changeMapDirMI);
-			if (!mm.noMapsAvailable) 
+			if (!mm.noMapsAvailable)
 			{
 				if (mm.mapHidden) mapsMenu.addItem(showMapMI);
 				else mapsMenu.addItem(hideMapMI);
@@ -1638,9 +1656,9 @@
 			highestResolutionMI.modifiers &amp;= ~MenuItem.Checked;
 			keepManResolutionMI.modifiers &amp;= ~MenuItem.Checked;
 			switch (mm.mapChangeModus) {
-			case MovingMap.NORMAL_KEEP_RESOLUTION: keepManResolutionMI.modifiers |= MenuItem.Checked; break;   
-			case MovingMap.HIGHEST_RESOLUTION: highestResolutionMI.modifiers |= MenuItem.Checked; break;   
-			case MovingMap.HIGHEST_RESOLUTION_GPS_DEST: highestResGpsDestMI.modifiers |= MenuItem.Checked; break;   
+			case MovingMap.NORMAL_KEEP_RESOLUTION: keepManResolutionMI.modifiers |= MenuItem.Checked; break;
+			case MovingMap.HIGHEST_RESOLUTION: highestResolutionMI.modifiers |= MenuItem.Checked; break;
+			case MovingMap.HIGHEST_RESOLUTION_GPS_DEST: highestResGpsDestMI.modifiers |= MenuItem.Checked; break;
 			}
 			mapsMenu.addItem(mapChangeModusMI);
 			mapsMenu.addItem(highestResGpsDestMI);
@@ -1673,9 +1691,9 @@
 			lastZoomHeight = 0;
 		}
 		if (which == mm.buttonImageZoom1to1) {
-			mm.zoom1to1(); 
+			mm.zoom1to1();
 		}
-		if (which == mm.bottonImageClose) {
+		if (which == mm.buttonImageClose) {
 			WindowEvent tmp = new WindowEvent();
 			tmp.type = WindowEvent.CLOSE;
 			mm.postEvent(tmp);
@@ -1684,14 +1702,14 @@
 
 	public void snapToGps() {
 		mm.myNavigation.startGps(mm.pref.logGPS, Convert.toInt(mm.pref.logGPSTimer));
-		mm.SnapToGps();
+		mm.snapToGps();
 	}
 
 	public void penHeld(Point p){
 		//	if (!menuIsActive()) doMenu(p);
-		if (!mm.zoomingMode) { 
+		if (!mm.zoomingMode) {
 			//( (ev.type == PenEvent.PEN_DOWN) &amp;&amp; ((PenEvent)ev).modifiers == PenEvent.RIGHT_BUTTON)
-			//|| ((ev.type == PenEvent.RIGHT_BUTTON) ) )) ---&gt; these events are not posted --&gt; this overridering is the only solution 
+			//|| ((ev.type == PenEvent.RIGHT_BUTTON) ) )) ---&gt; these events are not posted --&gt; this overridering is the only solution
 			kontextMenu = new Menu();
 			if ( !(mm.directionArrows.onHotArea(p.x, p.y)) ) {
 				kontextMenu.addItem(gotoMenuItem);
@@ -1700,16 +1718,16 @@
 				if (clickedOnImage != null &amp;&amp; clickedOnImage instanceof MapSymbol) {
 					clickedCache = ((CacheHolder)((MapSymbol)clickedOnImage).mapObject);
 					if (clickedCache != null) {
-						openCacheDescMenuItem = new MenuItem(MyLocale.getMsg(4270, &quot;Open&quot;)+&quot; '&quot;+(clickedCache.CacheName.length()&gt;0 ? clickedCache.CacheName : clickedCache.wayPoint)+&quot;'$o&quot;); // clickedCache == null can happen if clicked on the goto-symbol
+						openCacheDescMenuItem = new MenuItem(MyLocale.getMsg(4270, &quot;Open&quot;)+&quot; '&quot;+(clickedCache.cacheName.length()&gt;0 ? clickedCache.cacheName : clickedCache.wayPoint)+&quot;'$o&quot;); // clickedCache == null can happen if clicked on the goto-symbol
 						kontextMenu.addItem(openCacheDescMenuItem);
-						if (Global.mainForm.cacheListVisible) { 
+						if (Global.mainForm.cacheListVisible) {
 							addCachetoListMenuItem = new MenuItem(MyLocale.getMsg(199,&quot;Add to cachetour&quot;));
 							kontextMenu.addItem(addCachetoListMenuItem);
 						}
 					}
 				}
 			}
-			else {			
+			else {
 				for (int i=0; i&lt;SkyOrientation.LUMINARY_NAMES.length; i++) {
 					kontextMenu.addItem(miLuminary[i]);
 					if (i == mm.myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
@@ -1724,24 +1742,24 @@
 		if (mapsMenu != null &amp;&amp; ev instanceof PenEvent &amp;&amp; ev.type == PenEvent.PEN_DOWN &amp;&amp; ev.target == this) {mapsMenu.close(); mapsMenu = null;}
 		if (kontextMenu != null &amp;&amp; ev instanceof PenEvent &amp;&amp; ev.type == PenEvent.PEN_DOWN &amp;&amp; ev.target == this) {kontextMenu.close(); kontextMenu = null; }
 
-		if (ev instanceof MenuEvent) { 
+		if (ev instanceof MenuEvent) {
 			if (ev.target == mapsMenu) {
-				if (ev.type == MenuEvent.ABORTED || ev.type == ControlEvent.CANCELLED || ev.type == ControlEvent.FOCUS_OUT) mapsMenu.close(); // TODO menuIsActive() benutzen? 
+				if (ev.type == MenuEvent.ABORTED || ev.type == MenuEvent.CANCELLED || ev.type == MenuEvent.FOCUS_OUT) mapsMenu.close(); // TODO menuIsActive() benutzen?
 				if (ev.type == MenuEvent.SELECTED ) {
-					MenuItem action = (MenuItem) mapsMenu.getSelectedItem(); 
+					MenuItem action = (MenuItem) mapsMenu.getSelectedItem();
 					if (mapsMenu.getSelectedItem() != null) {
 						//maps
-						if (action == selectMapMI)	{ 
+						if (action == selectMapMI)	{
 							mapsMenu.close();
 							chooseMap();
 						}
 						if (action == changeMapDirMI)	{
 							mapsMenu.close();
-							FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, Global.getPref().baseDir+&quot;maps&quot;);
+							FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir+&quot;maps&quot;);
 							fc.addMask(&quot;*.wfl&quot;);
-							fc.setTitle(MyLocale.getMsg(4200,&quot;Select map directory:&quot;));
-							if(fc.execute() != FormBase.IDCANCEL){
-								Global.getPref().saveCustomMapsPath(fc.getChosen().toString());
+							fc.title=(MyLocale.getMsg(4200,&quot;Select map directory:&quot;));
+							if(fc.execute() != FileChooser.IDCANCEL){
+								Global.getPref().saveCustomMapsPath(fc.getChosen());
 								mm.loadMaps(Global.getPref().getMapLoadPath(), mm.posCircle.where.latDec);
 								mm.forceMapLoad();
 							}
@@ -1773,7 +1791,7 @@
 						if (action == moreDetailsMI) {
 							mapsMenu.close();
 							mm.loadMoreDetailedMap(false);
-						} 
+						}
 						if (action == moreOverviewMI) {
 							mapsMenu.close();
 							mm.loadMoreDetailedMap(true);
@@ -1793,7 +1811,7 @@
 						}
 						if (action == moveToGpsMI) {
 							mapsMenu.close();
-							this.snapToGps();						
+							this.snapToGps();
 						}
 
 					}
@@ -1801,10 +1819,10 @@
 			} // if (ev.target == mapsMenu)
 			if (ev.target == kontextMenu) {
 				if ((((MenuEvent)ev).type==MenuEvent.SELECTED)) {
-					MenuItem action = (MenuItem) kontextMenu.getSelectedItem(); 
+					MenuItem action = (MenuItem) kontextMenu.getSelectedItem();
 					if (action == gotoMenuItem) {
 						kontextMenu.close();
-						mm.myNavigation.setDestination(mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y));	
+						mm.myNavigation.setDestination(mm.screenXY2LatLon(saveMapLoc.x, saveMapLoc.y));
 					}
 					if (action == openCacheDescMenuItem) {
 						//mm.onEvent(new FormEvent(FormEvent.CLOSED, mm));
@@ -1819,12 +1837,12 @@
 					if (action == newWayPointMenuItem) {
 						kontextMenu.close();
 						WindowEvent close = new WindowEvent();
-						close.target = mm; 
+						close.target = mm;
 						close.type = WindowEvent.CLOSE;
 						mm.postEvent(close);
 						CacheHolder newWP = new CacheHolder();
-						newWP.pos = mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y);
-						newWP.LatLon=newWP.pos.toString(); 
+						newWP.pos = mm.screenXY2LatLon(saveMapLoc.x, saveMapLoc.y);
+						newWP.latLon=newWP.pos.toString();
 						Global.mainTab.newWaypoint(newWP);
 					}
 					if (action == addCachetoListMenuItem) {
@@ -1841,7 +1859,7 @@
 					}
 				}
 			} // if (ev.target == kontextMenu)
-		} // if (ev instanceof ControlEvent ) 
+		} // if (ev instanceof ControlEvent )
 		super.onEvent(ev);
 	}
 }
@@ -1852,14 +1870,14 @@
  */
 class ListBox extends Form{
 	public MapInfoObject selectedMap; // = new MapInfoObject();
-	mButton cancelButton, okButton;
-	mList list = new mList(4,1,false);
+	Button cancelButton, okButton;
+	List list = new List(4,1,false);
 	public boolean selected = false;
 	Vector maps;
 
 	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos, MapInfoObject curMap){
 		this.title = MyLocale.getMsg(4271, &quot;Maps&quot;);
-		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else 
+		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else
 		// set width to screenwidth *3/4 but to at least 240 if the screen is big engough for 240px width
 		this.setPreferredSize(java.lang.Math.max(MyLocale.getScreenWidth()*3/4, java.lang.Math.min(240, MyLocale.getScreenWidth()) ), MyLocale.getScreenHeight()*3/4);
 		this.maps = maps;
@@ -1879,9 +1897,9 @@
 				ml = (MapListEntry)maps.get(i);
 				try {
 					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
-					else { map = ml.getMap();}
+					map = ml.getMap();
 				} catch (IOException ex) {continue; } // could not read .wfl-file
-				if( map.isInBound(Gps.latDec, Gps.lonDec) &amp;&amp; map.isInBound(gotopos) ) 
+				if( map.isInBound(Gps.latDec, Gps.lonDec) &amp;&amp; map.isInBound(gotopos) )
 				{
 					list.addItem(i + &quot;: &quot; + map.mapName);
 					row++;
@@ -1898,9 +1916,9 @@
 				ml = (MapListEntry)maps.get(i);
 				try {
 					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
-					else { map = ml.getMap();}
+					map = ml.getMap();
 				} catch (IOException ex) {continue; } // could not read .wfl-file
-				if( map.isInBound(Gps.latDec, Gps.lonDec) ) 
+				if( map.isInBound(Gps.latDec, Gps.lonDec) )
 				{
 					list.addItem(i + &quot;: &quot; + map.mapName);
 					row++;
@@ -1917,7 +1935,7 @@
 				ml = (MapListEntry)maps.get(i);
 				try {
 					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
-					else { map = ml.getMap();}
+					map = ml.getMap();
 				} catch (IOException ex) {continue; } // could not read .wfl-file
 				if(map.isInBound(gotopos)) {
 					list.addItem(i + &quot;: &quot; + map.mapName);
@@ -1938,20 +1956,20 @@
 			}
 		}
 		list.selectItem(oldmap, true);
-		this.addLast(new CacheWolf.MyScrollBarPanel(list),CellConstants.STRETCH, CellConstants.FILL);
-		cancelButton = new mButton(MyLocale.getMsg(4276, &quot;Cancel&quot;));
+		this.addLast(new cachewolf.MyScrollBarPanel(list),CellConstants.STRETCH, CellConstants.FILL);
+		cancelButton = new Button(MyLocale.getMsg(4276, &quot;Cancel&quot;));
 		cancelButton.setHotKey(0, KeyEvent.getCancelKey(true));
 		this.addNext(cancelButton,CellConstants.STRETCH, CellConstants.FILL);
-		okButton = new mButton(MyLocale.getMsg(4277, &quot;Select&quot;));
+		okButton = new Button(MyLocale.getMsg(4277, &quot;Select&quot;));
 		okButton.setHotKey(0, KeyEvent.getActionKey(true));
 		this.addLast(okButton,CellConstants.STRETCH, CellConstants.FILL);
 		okButton.takeFocus(0);
 	}
 	public void mapSelected() {
-		try { 
+		try {
 			selectedMap = null;
 			int mapNum = 0;
-			String it = new String();
+			String it;
 			it = list.getText();
 			if (it != &quot;&quot;){
 				it = it.substring(0,it.indexOf(':'));
@@ -1962,15 +1980,15 @@
 				selected = true;
 				this.close(FormBase.IDOK);
 				} catch (IOException e) {
-					(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4278, &quot;Cannot load wfl-file: \n&quot;) 
-							+ ((MapListEntry)maps.get(mapNum)).filename, FormBase.OKB)).execute();
+					(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4278, &quot;Cannot load wfl-file: \n&quot;)
+							+ ((MapListEntry)maps.get(mapNum)).filename, MessageBox.OKB)).execute();
 				}
 			}
 			else {
 				selected = false;
 				this.close(FormBase.IDCANCEL);
 			}
-		}catch (NegativeArraySizeException e) {} // happens in substring when a dividing line selected 
+		}catch (NegativeArraySizeException e) {} // happens in substring when a dividing line selected
 	}
 
 	public void onEvent(Event ev){
@@ -1997,11 +2015,11 @@
 	float sunDir = -361;
 	float moveDir = -361;
 
-	int minY;
+	//int minY;
 	Graphics draw;
 	private MapInfoObject map=null;
 
-	Color moveDirColor = new Color(255,0,0); // RED 
+	Color moveDirColor = new Color(255,0,0); // RED
 	final static Color sunDirColor = new Color(255,255,0); // Yellow
 	//final static Color GREEN = new Color(0,255,0);
 	final static Color gotoDirColor = new Color(0,0,128); // dark blue
@@ -2010,7 +2028,6 @@
 	Point[] gotoDirArrow = null;
 	Point[] moveDirArrow = null;
 	Point[] northDirArrow = null;
-	
 	int imageSize = Global.getPref().fontSize * 8;
 	int arrowThickness = imageSize / 28;
 	
@@ -2026,8 +2043,9 @@
 	}
 
 	public void newImage() {
-		setImage(new Image(imageSize,imageSize), Color.White);
-		draw = new Graphics(image);
+		Image img;
+		setImage((img=new Image(80,80)).getImageData()); //, Color.White);
+		draw = new Graphics(img);
 	}
 	public void setMap(MapInfoObject m) {
 		map = m;
@@ -2059,7 +2077,7 @@
 		drawArrows(g);
 		return;
 /*		if (!dirsChanged) {
-			g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height); // the transparency with a transparent color doesn't work in ewe-vm for pocketpc, it works in java-vm, ewe-vm on pocketpc2003 
+			g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height); // the transparency with a transparent color doesn't work in eve-vm for pocketpc, it works in java-vm, eve-vm on pocketpc2003
 			return;
 		}
 		dirsChanged = false;
@@ -2068,7 +2086,7 @@
 		draw.fillRect(0, 0, location.width, location.height);
 		minY = Integer.MAX_VALUE;
 		drawArrows(draw);
-		draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw 
+		draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw
 		g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
 */	}
 
@@ -2090,10 +2108,10 @@
 				if (northDirArrow == null) northDirArrow = new Point[2];
 				makeArrow(northDirArrow, 0, 1.0f); // north direction
 			} else northDirArrow = null;
-			
+
 			//select moveDirColor according to difference to gotoDir
 			moveDirColor = new Color(255,0,0); // red
-			
+
 			if (moveDirArrow != null &amp;&amp; gotoDirArrow != null)
 			{
 				float diff = java.lang.Math.abs(moveDir - gotoDir);
@@ -2105,7 +2123,7 @@
 				{
 					diff = 360.0f - diff;
 				}
-				
+
 				if (diff &lt;= 5.0)
 				{
 					moveDirColor = new Color(0,192,0);// darkgreen
@@ -2122,7 +2140,7 @@
 		}
 
 	/**
-	 * make (calculate) Pixel array for a single arrow 
+	 * make (calculate) Pixel array for a single arrow
 	 * @param g handle for drawing
 	 * @param angle angle of arrow
 	 * @param col color of arrow
@@ -2137,8 +2155,8 @@
 		arrow[0].x = centerX;
 		arrow[0].y = centerY;
 		angleRad = angle * (float)java.lang.Math.PI / 180 + map.rotationRad;
-		arrow[1].x = centerX + new Float(centerX * java.lang.Math.sin(angleRad) * scale).intValue();
-		arrow[1].y = centerY - new Float(centerY * java.lang.Math.cos(angleRad) * scale).intValue();
+		arrow[1].x = centerX + (int)(centerX * java.lang.Math.sin(angleRad) * scale);
+		arrow[1].y = centerY - (int)(centerY * java.lang.Math.cos(angleRad) * scale);
 		//	g.setPen(new Pen(Color.Black,Pen.SOLID,7));
 		//	g.drawLine(centerX,centerY,x,y);
 	}
@@ -2149,10 +2167,10 @@
 		drawArrow(g, moveDirArrow, moveDirColor);
 		drawArrow(g, sunDirArrow, sunDirColor);
 	}
-	
+
 	public void drawArrow(Graphics g, Point[] arrow, Color col) {
 		if (arrow == null) return;
-		g.setPen(new Pen(col,Pen.SOLID,arrowThickness));
+		g.changePen(col,Pen.SOLID,arrowThickness);
 		g.drawLine(arrow[0].x, arrow[0].y, arrow[1].x,arrow[1].y);
 	}
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/Navigate.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/Navigate.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/Navigate.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,23 +1,24 @@
-package CacheWolf.navi;
+package cachewolf.navi;
 
-import CacheWolf.CWPoint;
-import CacheWolf.Global;
-import CacheWolf.MyLocale;
-import CacheWolf.Preferences;
-import ewe.fx.Color;
-import ewe.io.IOException;
-import ewe.io.SerialPort;
-import ewe.io.SerialPortOptions;
-import ewe.net.Socket;
-import ewe.sys.mThread;
-import ewe.ui.FormBase;
-import ewe.ui.MessageBox;
-import ewe.util.mString;
+import eve.fx.Color;
+import java.io.IOException;
+import eve.io.SerialPort;
+import eve.ui.data.SerialPortOptions;
+import java.net.Socket;
 
+import cachewolf.CWPoint;
+import cachewolf.Global;
+import cachewolf.MyLocale;
+import cachewolf.Preferences;
+
+import eve.ui.MessageBox;
+import eve.util.mString;
+import eve.sys.Handle;
+
 /**
  * Non-Gui Class to handle all things regarding navigation
  * (GPS, Sun direction etc.)
- * start offset in localisation file: 4400 
+ * start offset in localisation file: 4400
  * @author Pfeffer
  *
  */
@@ -48,14 +49,14 @@
 
 	public void startGps(boolean loggingOn, int loggingIntervall) {
 		setRawLogging(loggingOn, loggingIntervall);
-		if (serThread != null) if (serThread.isAlive()) return; // TODO use gpsRunning
+		if (serThread != null) if ((serThread.check() &amp; Handle.Running)!=0) return; // TODO use gpsRunning
 		try {
 			serThread = new SerialThread(pref.mySPO, gpsPos, (pref.forwardGPS ? pref.forwardGpsHost : &quot;&quot;));
 			if (pref.forwardGPS &amp;&amp; !serThread.tcpForward) {
-				(new MessageBox(MyLocale.getMsg(4400, &quot;Warning&quot;), 
+				(new MessageBox(MyLocale.getMsg(4400, &quot;Warning&quot;),
 						MyLocale.getMsg(4401, &quot;Ignoring error:\n could not forward GPS data to host:\n&quot;)
 						+ pref.forwardGpsHost+&quot;\n&quot; + serThread.lastError
-						+ MyLocale.getMsg(4402, &quot;\nstop and start GPS to retry&quot;), FormBase.OKB)).exec();
+						+ MyLocale.getMsg(4402, &quot;\nstop and start GPS to retry&quot;), MessageBox.OKB)).exec();
 			}
 			if (gpsPos.latDec == 0 &amp;&amp; gpsPos.lonDec == 0) { // TODO use isValid() // TODO raus damit?
 				gpsPos.latDec = destination.latDec; // setze Zielpunkt als Ausgangspunkt
@@ -69,16 +70,16 @@
 			if (gotoPanel != null) gotoPanel.gpsStarted();
 			if (movingMap != null) movingMap.gpsStarted();
 		} catch (IOException e) {
-			(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;), 
-					MyLocale.getMsg(4404, &quot;Could not connect to GPS-receiver.\n Error while opening serial Port &quot;) 
+			(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;),
+					MyLocale.getMsg(4404, &quot;Could not connect to GPS-receiver.\n Error while opening serial Port &quot;)
 					+ e.getMessage()
-					+ MyLocale.getMsg(4405, &quot;\npossible reasons:\n Another (GPS-)program is blocking the port\nwrong port\nOn Loox: active infra-red port is blocking GPS&quot;), 
-					FormBase.OKB)).execute(); 
+					+ MyLocale.getMsg(4405, &quot;\npossible reasons:\n Another (GPS-)program is blocking the port\nwrong port\nOn Loox: active infra-red port is blocking GPS&quot;),
+					MessageBox.OKB)).execute();
 		} catch (UnsatisfiedLinkError e) {
-			(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;), 
-					MyLocale.getMsg(4404, &quot;Could not connect to GPS-receiver.\n Error while opening serial Port &quot;) 
-					+ MyLocale.getMsg(4406, &quot;Please copy jave_ewe.dll into the directory of the cachewolf program&quot;), 
-					FormBase.OKB)).execute(); 
+			(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;),
+					MyLocale.getMsg(4404, &quot;Could not connect to GPS-receiver.\n Error while opening serial Port &quot;)
+					+ MyLocale.getMsg(4406, &quot;Please copy jave_eve.dll into the directory of the cachewolf program&quot;),
+					MessageBox.OKB)).execute();
 		}
 	}
 
@@ -100,17 +101,17 @@
 		stopDisplayTimer();
 		gpsPos.stopLog();
 		gpsRunning = false;
-		if (gotoPanel != null) gotoPanel.gpsStoped();
+		if (gotoPanel != null) gotoPanel.gpsStopped();
 		if (movingMap != null) movingMap.gpsStoped();
 	}
 
 	public boolean isGpsPosValid() {
-		return 	serThread != null &amp;&amp; serThread.isAlive() &amp;&amp; gpsPos.isValid() ; // &amp;&amp; gpsPos.getfiex();
+		return 	serThread != null &amp;&amp; ((serThread.check()&amp;Handle.Running)!=0) &amp;&amp; gpsPos.isValid() ; // &amp;&amp; gpsPos.getfiex();
 
 	}
 
 
-	public void setDestination(String LatLon) { 
+	public void setDestination(String LatLon) {
 		setDestination(new CWPoint(LatLon));
 	}
 
@@ -136,21 +137,21 @@
 			try {
 				curTrack.add(gpsPos);
 			} catch (IndexOutOfBoundsException e) { // track full -&gt; create a new one
-				curTrack = new Track(trackColor); 
+				curTrack = new Track(trackColor);
 				curTrack.add(gpsPos);
-				if (movingMap != null) movingMap.addTrack(curTrack);
+				if (movingMap != null) movingMap.addTrack(curTrack); // TODO maybe gotoPanel should also hold a list of Tracks, because otherwise they will be destroyed if not saved in mmp before
 			}
 			try {
-				SkyOrientation.getSunAzimut(gpsPos.Time, gpsPos.Date, gpsPos.latDec, gpsPos.lonDec);
-				double jd = SkyOrientation.utc2juliandate(gpsPos.Time, gpsPos.Date);
+				SkyOrientation.getSunAzimut(gpsPos.time, gpsPos.date, gpsPos.latDec, gpsPos.lonDec);
+				double jd = SkyOrientation.utc2juliandate(gpsPos.time, gpsPos.date);
 				skyOrientationDir = SkyOrientation.getLuminaryDir(luminary, jd, gpsPos);
-				// ewe.sys.Vm.debug(&quot;neu: &quot;+ skyOrientationDir.lonDec+ &quot;jd: &quot; + jd);
+				// eve.sys.Vm.debug(&quot;neu: &quot;+ skyOrientationDir.lonDec+ &quot;jd: &quot; + jd);
 			} catch (NumberFormatException e) { // irgendeine Info zu Berechnung des Sonnenaziumt fehlt (insbesondere Datum und Uhrzeit sind nicht unbedingt gleichzeitig verf&#252;gbar wenn es einen Fix gibt)
-				skyOrientationDir.set(-361, -361); // any value out of range (bigger than 360) will prevent drawArrows from drawing it 
+				skyOrientationDir.set(-361, -361); // any value out of range (bigger than 360) will prevent drawArrows from drawing it
 			}
 
 		} else {
-			skyOrientationDir.set(-361, -361); // any value out of range (bigger than 360) will prevent drawArrows from drawing it		
+			skyOrientationDir.set(-361, -361); // any value out of range (bigger than 360) will prevent drawArrows from drawing it
 		}
 		gotoPanel.updateGps(fix);
 		if (movingMap != null) movingMap.updateGps(fix);
@@ -161,53 +162,51 @@
  * Thread for reading data from COM-port
  *
  */
-class SerialThread extends mThread{
-	SerialPort comSp;   
+class SerialThread extends eve.sys.Task{
+	SerialPort comSp;
 	byte[] comBuff = new byte[1024*10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
 	int comLength = 0;
 	CWGPSPoint myGPS;
 	boolean run, tcpForward;
 	Socket tcpConn;
-	String lastError = new String();
+	String lastError = &quot;&quot;;
 
 	public SerialThread(SerialPortOptions spo, CWGPSPoint GPSPoint, String forwardIP) throws IOException {
 		try{
-			spo.portName = CacheWolf.Common.fixSerialPortName(spo.portName);
+			spo.portName = cachewolf.utils.Common.fixSerialPortName(spo.portName);
 			comSp = new SerialPort(spo);
 		} catch (IOException e) {
 			throw new IOException(spo.portName);
-		} // catch (UnsatisfiedLinkError e) {} // TODO in original java-vm 
-		if (forwardIP.length()&gt;0) { 
+		} // catch (UnsatisfiedLinkError e) {} // TODO in original java-vm
+		if (forwardIP.length()&gt;0) {
 			try {
 				tcpConn = new Socket(forwardIP, 23);
 				tcpForward = true;
-			} catch (ewe.net.UnknownHostException e) { tcpForward = false; lastError = e.getMessage();
-			} catch (IOException e) { tcpForward = false; lastError = e.getMessage(); 
+			} catch (java.net.UnknownHostException e) { tcpForward = false; lastError = e.getMessage();
+			} catch (IOException e) { tcpForward = false; lastError = e.getMessage();
 			}
 		}
 		myGPS = GPSPoint;
 	}
 
-	public void run() {
+	public void doRun() {
 		int noData = 0;
 		int notinterpreted = 0;
 		run = true;
 		while (run){
-			try {
 				sleep(1000);
 				//Vm.debug(&quot;Loop? &quot; + noData);
 				noData++;
 				if (noData &gt; 5) { myGPS.noDataError(); }
-			} catch (InterruptedException e) {}
 			if (comSp != null)	{
-				comLength = comSp.nonBlockingRead(comBuff, 0 ,comBuff.length);
+//TODO Activate				comLength = comSp.nonBlockingRead(comBuff, 0 ,comBuff.length);
 				//Vm.debug(&quot;Length: &quot; + comBuff.length);
 				if (comLength &gt; 0)	{
 					noData = 0;
-					String str = mString.fromAscii(comBuff, 0, comLength); 
+					String str = mString.fromAscii(comBuff, 0, comLength);
 					if (tcpForward) {
 						try {
-							tcpConn.write(comBuff, 0, comLength);
+							tcpConn.getOutputStream().write(comBuff, 0, comLength);
 						} catch (IOException e) { tcpForward = false; }
 					}
 					//Vm.debug(str);
@@ -217,22 +216,26 @@
 			}
 		} // while
 		myGPS.noData();
-		tcpConn.close();
+		try {
+			tcpConn.close();
+		} catch (Exception ex) {};
 	}
 
 	public void stop() {
-		run = false;
-		if (comSp != null) comSp.close();
+		try {
+			run = false;
+			if (comSp != null) comSp.close();
+		} catch(IOException ex) {}
 	}
 }
 
-/** 
- * Class for creating a new mThread to create timer ticks to be able to do form.close in the ticked-thread. 
- * Using the Vm.requestTimer-Method causes &quot;ewe.sys.EventDirectionException: This task cannot be done within 
- * a Timer Tick.&quot; in the ewe-vm when form.close is called.  
+/**
+ * Class for creating a new mThread to create timer ticks to be able to do form.close in the ticked-thread.
+ * Using the Vm.requestTimer-Method causes &quot;eve.sys.EventDirectionException: This task cannot be done within
+ * a Timer Tick.&quot; in the eve-vm when form.close is called.
  */
 
-class UpdateThread extends mThread {
+class UpdateThread extends eve.sys.Task {
 	public boolean run;
 	public int calldelay;
 	public Navigate ticked;
@@ -242,10 +245,10 @@
 		calldelay = cd;
 	}
 
-	public void run () {
+	public void doRun () {
 		run = true;
 		while (run) {
-			try { sleep (calldelay);} catch (InterruptedException e) {}
+			sleep (calldelay);
 			ticked.ticked();
 		}
 	}
@@ -255,4 +258,3 @@
 	}
 }
 
-

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/SelectMap.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/SelectMap.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/SelectMap.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,11 +1,13 @@
-package CacheWolf.navi;
+package cachewolf.navi;
 
-import CacheWolf.Global;
-import CacheWolf.InfoBox;
-import CacheWolf.MyLocale;
-import utils.FileBugfix;
-import ewe.io.*;
-import ewe.ui.*;
+import cachewolf.Global;
+import cachewolf.InfoBox;
+import cachewolf.MyLocale;
+import eve.io.*;
+import eve.sys.*;
+import eve.ui.*;
+import eve.ui.event.ControlEvent;
+import eve.ui.event.ListEvent;
 
 /**
 *	This class displays a user interface to select maps that should be or are already calibrated
@@ -14,32 +16,32 @@
 public class SelectMap extends Form{
 	ScrollBarPanel top;
 	ScrollBarPanel bot;
-	mButton mBCancel, mBLoad;
-	String mapsPath = new String();
-	mList nonCMaps = new mList(3,1,false);
-	mList CMaps = new mList(3,1,false);
+	Button mBCancel, mBLoad;
+	String mapsPath = &quot;&quot;;
+	eve.ui.List nonCMaps = new eve.ui.List(3,1,false);
+	eve.ui.List CMaps = new eve.ui.List(3,1,false);
 	String dateien[];
-	String selectedMap = new String();
+	String selectedMap = &quot;&quot;;
 	public boolean worldfileexists = false;
 	
 	public SelectMap(){
 		mapsPath = Global.getPref().getMapManuallySavePath(false)+&quot;/&quot;; //  File.getProgramDirectory() + &quot;/maps/&quot;;
-		top = new CacheWolf.MyScrollBarPanel(CMaps);
-		bot = new CacheWolf.MyScrollBarPanel(nonCMaps);
+		top = new cachewolf.MyScrollBarPanel(CMaps);
+		bot = new cachewolf.MyScrollBarPanel(nonCMaps);
 		this.title = MyLocale.getMsg(4101,&quot;Maps&quot;);
-		this.addLast(new mLabel(MyLocale.getMsg(4102,&quot;Calibrated Maps&quot;)), CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(new Label(MyLocale.getMsg(4102,&quot;Calibrated Maps&quot;)), CellConstants.STRETCH, CellConstants.FILL);
 		this.addLast(top, CellConstants.STRETCH, CellConstants.FILL);
-		this.addLast(new mLabel(MyLocale.getMsg(4103,&quot;Non Calibrated Maps&quot;)), CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(new Label(MyLocale.getMsg(4103,&quot;Non Calibrated Maps&quot;)), CellConstants.STRETCH, CellConstants.FILL);
 		this.addLast(bot, CellConstants.STRETCH, CellConstants.FILL);
-		this.addNext(mBCancel = new mButton(MyLocale.getMsg(4104,&quot;Cancel&quot;)),CellConstants.STRETCH, CellConstants.FILL);
-		this.addLast(mBLoad = new mButton(MyLocale.getMsg(4105,&quot;Open&quot;)),CellConstants.STRETCH, CellConstants.FILL);
+		this.addNext(mBCancel = new Button(MyLocale.getMsg(4104,&quot;Cancel&quot;)),CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(mBLoad = new Button(MyLocale.getMsg(4105,&quot;Open&quot;)),CellConstants.STRETCH, CellConstants.FILL);
 		InfoBox inf = new InfoBox(&quot;Info&quot;, MyLocale.getMsg(4109,&quot;Loading maps...&quot;)); 
 		inf.show();
 		try{
-			File files = new FileBugfix(mapsPath);
+			File files = new File(mapsPath);
 			File checkWFL;
-			String rawFileName = new String();
-			dateien = files.listMultiple(&quot;*.png,*.jpg,*.gif,*.bmp&quot;, FileBase.LIST_FILES_ONLY);
+			String rawFileName;
+			dateien = files.listMultiple(&quot;*.png,*.jpg,*.gif,*.bmp&quot;, File.LIST_FILES_ONLY);
 			for(int i = 0; i &lt; dateien.length;i++){
 				rawFileName = dateien[i].substring(0, dateien[i].lastIndexOf(&quot;.&quot;));
 				checkWFL = new File(mapsPath + rawFileName + &quot;.wfl&quot;);
@@ -65,7 +67,7 @@
 				this.close(0);
 			}
 		}
-		if(ev instanceof ListEvent &amp;&amp; ev.type == MenuEvent.SELECTED){
+		if(ev instanceof ListEvent &amp;&amp; ev.type == ListEvent.SELECTED){
 			if(ev.target == nonCMaps){
 				selectedMap = nonCMaps.getText();
 				CMaps.deleteSelection();

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/SkyOrientation.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/SkyOrientation.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/SkyOrientation.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,8 +1,8 @@
-package CacheWolf.navi;
+package cachewolf.navi;
 
-import CacheWolf.CWPoint;
-import CacheWolf.MyLocale;
-import ewe.sys.Convert;
+import cachewolf.CWPoint;
+import cachewolf.MyLocale;
+import eve.sys.Convert;
 
 /** Class to caculate positions of luminaries
  * all methods are static
@@ -38,7 +38,7 @@
 		// Sirius
 	};
 	
-	public static String [] LUMINARY_NAMES = { 
+	public static final String [] LUMINARY_NAMES = { 
 		MyLocale.getMsg(6100, &quot;Sun&quot;), 
 		MyLocale.getMsg(6101, &quot;Moon&quot;), 
 		MyLocale.getMsg(6102, &quot;Grater Bear&quot;),
@@ -48,7 +48,7 @@
 		MyLocale.getMsg(6106, &quot;Southern Cross&quot;)
 	};
 
-	public static String [] LUMINARY_DESC = {
+	public static final String [] LUMINARY_DESC = {
 		MyLocale.getMsg(6100, &quot;Sun&quot;), 
 		MyLocale.getMsg(6101, &quot;Moon&quot;), 
 		MyLocale.getMsg(6122, &quot;Alioth in Greater Bear&quot;),
@@ -112,7 +112,7 @@
 			if (monat&lt;2) {jahr--; monat+=12;} // verlegung des Jahres Endes auf Feb macht Berechnung von SChaltjahren einfacher
 			double a = (int)java.lang.Math.floor(jahr/100.); // Alle hundert Jahre kein Schlatjahr (abrunden)
 			double b = 2 - a + java.lang.Math.floor(a/4.);
-			double jd = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*(monat+1.)) + tag + (double)stunde/24 + (double)minute/1440 + (double)sekunde/86400 + b - 1524.5;
+			double jd = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*(monat+1.)) + tag + ((double)stunde)/24 + ((double)minute)/1440 + (double)sekunde/86400 + b - 1524.5;
 			return jd;
 			//double jd0 = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) +(double)tag + b - 1524.5;
 		} catch (IndexOutOfBoundsException e) {
@@ -145,7 +145,7 @@
 			if (monat&lt;2) {jahr--; monat+=12;} // verlegung des Jahres Endes auf Feb macht Berechnung von SChaltjahren einfacher
 			double a = (int)java.lang.Math.floor(jahr/100.); // Alle hundert Jahre kein Schlatjahr (abrunden)
 			double b = 2 - a + java.lang.Math.floor(a/4.);
-			double jd = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*(monat+1.)) + tag + (double)stunde/24 + (double)minute/1440 + (double)sekunde/86400 + b - 1524.5;
+			double jd = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*(monat+1.)) + tag + (stunde*3600 + minute*60 + sekunde)/86400. + b - 1524.5;
 			double jd0 = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*(monat+1.)) +tag + b - 1524.5;
 			// Ekliptikalkoordinaten der Sonne berechnen (see <A HREF="http://de.wikipedia.org/wiki/Sonnenstand">http://de.wikipedia.org/wiki/Sonnenstand</A> )
 			double n = jd - 2451545.0;
@@ -160,7 +160,7 @@
 			if (alphaNenner&lt;0) {alpha +=180;}
 			// Azimut
 			double t0 = (jd0 - 2451545.)/36525.; // schon in t0 bzw jd0 richtig berechnet?
-			double thetaHG = 6.697376 + 2400.05134 * t0 + 1.002738 * (stunde + minute/60. + sekunde/3600.);
+			double thetaHG = 6.697376 + 2400.05134 * t0 + 1.002738 * (stunde*3600 + minute*60 + sekunde)/3600.;
 			double theta = thetaHG * 15. + lon;
 			double azimutNenner = java.lang.Math.cos((theta-alpha)/180*java.lang.Math.PI)*java.lang.Math.sin(lat/180*java.lang.Math.PI)-
 			java.lang.Math.tan(delta/180*java.lang.Math.PI)*java.lang.Math.cos(lat/180*java.lang.Math.PI);
@@ -171,12 +171,12 @@
 			// null = Sueden auf Null = Norden umrechnen
 			azimut +=180.;
 			if (azimut &gt;360.) azimut -=360.;
-			//ewe.sys.Vm.debug(&quot;sunAzimut1: &quot; + azimut);
-			//ewe.sys.Vm.debug(&quot;sun Elevation: &quot; +getSunAzimut2 (utc, datum, lat, lon).latDec);
+			//eve.sys.Vm.debug(&quot;sunAzimut1: &quot; + azimut);
+			//eve.sys.Vm.debug(&quot;sun Elevation: &quot; +getSunAzimut2 (utc, datum, lat, lon).latDec);
 			//CWPoint MoonDir = getMoonDir(jd, new CWPoint(lat, lon));
-			//ewe.sys.Vm.debug(&quot;Moon Elevation: &quot; + MoonDir.latDec + &quot;Moon Azimut: &quot; + MoonDir.lonDec);
+			//eve.sys.Vm.debug(&quot;Moon Elevation: &quot; + MoonDir.latDec + &quot;Moon Azimut: &quot; + MoonDir.lonDec);
 			//CWPoint OrionDir = getAlnilamDir(jd, new CWPoint(lat, lon));
-			//ewe.sys.Vm.debug(&quot;Alnilam (Orion) Elevation: &quot; + OrionDir.latDec + &quot;Alnilam (Orion) Azimut: &quot; + OrionDir.lonDec );
+			//eve.sys.Vm.debug(&quot;Alnilam (Orion) Elevation: &quot; + OrionDir.latDec + &quot;Alnilam (Orion) Azimut: &quot; + OrionDir.lonDec );
 			
 			return azimut;
 		} catch (IndexOutOfBoundsException e) {

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/Track.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/Track.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/Track.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,15 +1,15 @@
-package CacheWolf.navi;
+package cachewolf.navi;
 
-import ewe.fx.*;
+import eve.fx.*;
 
 public class Track {
 	public Color trackColor;
-	public TrackPoint TrackPoints[];
+	public TrackPoint trackPoints[];
 	public int num;
 	
 	public Track(Color f) {
 		trackColor = f;
-		TrackPoints = new TrackPoint[5000];
+		trackPoints = new TrackPoint[5000];
 		num = 0;
 	}
 /*===== add is currently not used	
@@ -18,17 +18,17 @@
 		num++;
 	}
 =====*/	
-	/**
+	/*
 	 * throws IndexOutOfBoundsException when track is full
 	 */
 	public void add(TrackPoint t) { 
-		if (TrackPoints == null || t == null) return;
-		TrackPoints[num] = new TrackPoint(t);
+		if (trackPoints == null || t == null) return;
+		trackPoints[num] = new TrackPoint(t);
 		num++;
 	}
 /*===== loadTrack/saveTrack are currently not used
 	public void loadTrack(String filename){ // TODO untested!
-		byte [] all = ewe.sys.Vm.readResource(null,filename);
+		byte [] all = eve.sys.Vm.readResource(null,filename);
 		if (all == null) return; // TODO error handling
 		num = Utils.readInt(all, 0, 4);
 		for (int i=0; i&lt;=num; i++){

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/TrackOverlay.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/TrackOverlay.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/TrackOverlay.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,21 +1,22 @@
-package CacheWolf.navi;
+package cachewolf.navi;
 
 //import java.awt.image.BufferedImage;
 
-import ewe.fx.Color;
-import ewe.fx.Graphics;
-import ewe.fx.IImage;
-import ewe.fx.Image;
-import ewe.fx.Point;
-import ewe.util.Vector;
+import eve.fx.Color;
+import eve.fx.Graphics;
 
+import eve.fx.Image;
+import eve.fx.Point;
 
+import java.util.Vector;
+
+
 public class TrackOverlay extends MapImage {
 	public TrackPoint topLeft;
 	public TrackPoint bottomRight;
 	Graphics draw;
-	Graphics drawMask;
-	int test;
+	//Graphics drawMask;
+	//int test;
 	MapInfoObject trans; 
 	Point pixelShift;
 	public Vector tracks;
@@ -32,21 +33,22 @@
 		trans = transi;
 		pixelShift = trans.calcMapXY(topLeft);
 		bottomRight = trans.calcLatLon(widthi + pixelShift.x, highti + pixelShift.y);
-		if (ewe.sys.Vm.getPlatform().equalsIgnoreCase(&quot;java&quot;)) {
-			useTransparentColor = true; 
-			setImage(new Image(widthi, highti), transparentColorForOverlay); // java-vm: transparency with a mask is very memory consuming, but transparency with a mask is much faster in ewe-vm and doesn't consume more memory than a transparency color (ewe 1.49)
-		} else {
-			useTransparentColor = false; // // momentanously this it not used, but this is only because ewe treats areas as opaque which has a non white color in the image, so that the mask doesn't need to be changed
-			Image maski = new Image(widthi, highti);
-			drawMask = new Graphics(maski);
-			drawMask.setColor(Color.White);
-			drawMask.fillRect(0, 0, maski.getWidth(), maski.getHeight());
-			setImage(new Image(widthi, highti), maski); // java-vm: transparency with a mask is very memory consuming, but transparency with a mask is much faster in ewe-vm and doesn't consume more memory than a transparency color (ewe 1.49)
-			maski.free(); //setimage produces an inverted copy of the mask
-			maski = null;
+//TODO		if (eve.sys.Vm.getPlatform().equalsIgnoreCase(&quot;java&quot;)) {
+//			useTransparentColor = true; 
+//			setImage(new Image(widthi, highti), transparentColorForOverlay); // java-vm: transparency with a mask is very memory consuming, but transparency with a mask is much faster in eve-vm and doesn't consume more memory than a transparency color (eve 1.49)
+//		} else 
+		{
+			useTransparentColor = false; // // momentanously this it not used, but this is only because eve treats areas as opaque which has a non white color in the image, so that the mask doesn't need to be changed
+			//Image maski = new Image(widthi, highti);
+			//drawMask = new Graphics(maski);
+			//drawMask.setColor(Color.White);
+			//drawMask.fillRect(0, 0, maski.getWidth(), maski.getHeight());
+			setImage(new Image(widthi, highti), Color.White); // java-vm: transparency with a mask is very memory consuming, but transparency with a mask is much faster in eve-vm and doesn't consume more memory than a transparency color (eve 1.49)
+			//maski.free(); //setimage produces an inverted copy of the mask
+			//maski = null;
 		}
 		//properties = AlwaysOnTop; // arrows are above, so dont set it.
-		draw = new Graphics(image);
+		draw = new Graphics((Image) image);
 		draw.setDrawOp(Graphics.DRAW_OVER);
 		if (useTransparentColor) draw.setColor(transparentColorForOverlay);
 		else draw.setColor(Color.White);
@@ -57,7 +59,9 @@
 		//draw.fillRectRGB(50, 50, 52, 52, 0x00ff0000); // fillRectRGB has a Bug - it never returns - use fillRect instead
 		//image.setPixels(markImage, 0, 50, 50, 2, 2, 0); // out of an to me unkwon reason this doesn't work here, but it does in painttracks
 	}
-	public void imageSet()
+
+//TODO ImageSet is not used in project	
+/*	public void imageSet()
 //	==================================================================
 	{
 		IImage i = drawable;
@@ -70,8 +74,8 @@
 //		if (mask != null &amp;&amp; mask != sourceMask) mask.freeze(); // dont freeze the mask, it could change. Anyway momentanously it doesnt change, because when the image contains non-white in the opaque areas, it will be opaque without changing the mask
 		properties &amp;= ~HasChanged;
 	}
+*/
 
-
 	public void paintTracks() {
 	// for debugging TrackOverlayPositions
 	// draw.setPen(new Pen(Color.LightBlue,Pen.SOLID,1));
@@ -97,10 +101,9 @@
 			if (tr.num &gt; 0) {
 				for (i=0; i &lt; tr.num; i++) {
 					n++;
-					if  ((numberOfPoints - n &gt; 5*60) &amp;&amp; ((n &amp; 1) == 0)) continue;
-					if  ((numberOfPoints - n &gt; 15*60) &amp;&amp; ((n &amp; 2) == 0)) continue;
-					if  ((numberOfPoints - n &gt; 30*60) &amp;&amp; ((n &amp; 4) == 0)) continue;
-					paintPoint(tr.trackColor, tr.TrackPoints[i]);
+					if  ((numberOfPoints - n &gt; 30*60) &amp;&amp; ((n &amp; 1) == 0)) continue;
+					if  ((numberOfPoints - n &gt; 60*60) &amp;&amp; ((n &amp; 2) == 0)) continue;
+					paintPoint(tr.trackColor, tr.trackPoints[i]);
 				}
 			}
 		}
@@ -116,15 +119,15 @@
 	 */
 	public boolean paintPoint(Color f, TrackPoint where){
 		if (where.latDec &lt; bottomRight.latDec || where.latDec &gt; topLeft.latDec || where.lonDec &lt; topLeft.lonDec || where.lonDec &gt; bottomRight.lonDec) return false;
-		//ewe.sys.Vm.debug(&quot;showlastaddedpoint, lat: &quot;+lat+&quot;   lon: &quot;+lon);
+		//eve.sys.Vm.debug(&quot;showlastaddedpoint, lat: &quot;+lat+&quot;   lon: &quot;+lon);
 		Point p = trans.calcMapXY(where);
 		int x = p.x - pixelShift.x;
 		int y = p.y - pixelShift.y;
 		//draw.drawLine(x, y, x, y);
-		//ewe.sys.Vm.debug(&quot;showlastaddedpoint, x: &quot;+x+&quot;   y: &quot;+y+&quot;loc.x: &quot;+location.x+&quot;  loc.y:&quot;+location.y);
+		//eve.sys.Vm.debug(&quot;showlastaddedpoint, x: &quot;+x+&quot;   y: &quot;+y+&quot;loc.x: &quot;+location.x+&quot;  loc.y:&quot;+location.y);
 		draw.fillRect(x-1, y-1, 3, 3);
 		//drawMask.fillRect(x-1, y-1, 3, 3);
-		/*	if (image.bufferedImage != null) { // funktioniert gut, allerdings nur in der java-VM wenn ewe.fx.Image.bufferedImage als public definiert
+		/*	if (image.bufferedImage != null) { // funktioniert gut, allerdings nur in der java-VM wenn eve.fx.Image.bufferedImage als public definiert
 			int yd;
 			for  (int xd=-1; xd&lt;=1; xd++) {
 				for (yd=-1; yd&lt;=1; yd++) {
@@ -140,14 +143,14 @@
 	}
 
 	/**
-	 * this method forces ewe to transfer the drawn points
+	 * this method forces eve to transfer the drawn points
 	 * from _awtImage to bufferedImage, which is drawn to the screen
 	 *
 	 */
 	private void fixate() {
 		if (numPixels == 0) return;
 		//	draw.drawImage(image,null,Color.DarkBlue,0,0,location.width,location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
-		draw.drawImage(image, null, Color.Pink, 0, 0, 1, 1); // width and height is anyway ignored, evtl. testen,  
+		doDraw(draw,0);   // null, Color.Pink, 0, 0, 1, 1); // width and height is anyway ignored, evtl. testen,  
 		imageChangesDontShow = false;
 		removeAllPixels();
 	}
@@ -183,7 +186,7 @@
 	public void paintLastAddedPoint(Track tr) { 
 		//draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
 		draw.setColor(tr.trackColor);
-		if (paintPoint(tr.trackColor, tr.TrackPoints[tr.num-1])) notOnThisOverlaySince = 0;
+		if (paintPoint(tr.trackColor, tr.trackPoints[tr.num-1])) notOnThisOverlaySince = 0;
 		else notOnThisOverlaySince++;
 		if (notOnThisOverlaySince &gt; FIXATE_IF_NO_PIXELS_NUM) { // zur Performanceverbesserung: wenn in den letzten 60 Updates keines mehr f&#252;r dieses Overlay dabei war, Overlay Pixels fest schreiben, damit doDraw entlastet wird.
 			fixate();
@@ -226,7 +229,7 @@
  *  Zur Not w&#228;re auch denkbar, doDraw zu &#252;berschreiben, um bei jedem Aufruf alle 
  *  Trackpoints neu zu zeichnen.
  *  Work-Aorund: draw.drawImage(image,null,Color.Pink,0,0,1,1); bewirkt, dass awtImage ins
- *  bufferedImage kopiert wird. Dabei wird die transparentColor (in mImage) nicht ge&#228;ndert
+ *  bufferedImage kopiert wird. Dabei wird die transparentColor (in Picture) nicht ge&#228;ndert
  *  und beim Aufruf von doDraw wird wieder die urspr&#252;ngliche transparentColor verwendet
  *  
  */
@@ -234,7 +237,7 @@
 //drawmask.setDrawOp(Graphics.DRAW_OVER);
 //drawmask.drawRect(x-1, y-1, 2, 2, 1);
 //this.setImage(image, mask);
-//n&#228;chster Versuch: image.bufferedImage in ewe.fx.Image public definieren !!!
+//n&#228;chster Versuch: image.bufferedImage in eve.fx.Image public definieren !!!
 //image.rgb
 //draw._g.surfaceData.bufImg.raster.data[y*this.location.width + x] = -65536; := image._awtImage
 //((Image)image).eImage(colorOrMask)._awtImage.raster.data[0]=0;
@@ -246,7 +249,7 @@
 //image.mask = null;
 //image.bufferedImage = null;
 //image.setPixels(markPixels, 0 , x-20, y, 2, 2, 0); // dadrin sollte bufferedImage = null gesetzt werden, wird es aber nicht :-(
-//ewe.fx.mImage mark = new mImage();
+//eve.fx.Picture mark = new Picture();
 //Image mark = new Image(2,2);
 //new Graphics(mark).drawImage(image, null, transparentColor, x-40, y, 2, 2);
 //mark.draw(draw, x-50, y, Graphics.DRAW_OVER); // options (Graphics.DRAW_OVER) are ignored anyway
@@ -257,7 +260,7 @@
 //(java.awt.Image.b)
 //image.bufferedImage=null;
 //draw.flush();
-//ewe.ui.PenEvent.refreshTip(draw.surface);
+//eve.ui.PenEvent.refreshTip(draw.surface);
 //draw.setPixelRGB(x, y, -65536);
 //this.changed(); hilft auch nicht
 //this.refresh(); // hilft nicht :-(
@@ -265,9 +268,9 @@
 //imageMayChange = true; // hilft auch nicht :-(
 
 /*
- * In der ewe-VM f&#252;r PocketPC-ARM funktioniert die Festlegung einer 
+ * In der eve-VM f&#252;r PocketPC-ARM funktioniert die Festlegung einer 
  * transparenten Farbe nicht (Hintergrund wird wei&#223; statt durchsichtig)
- * deswegen (und weil in ewe-VM effizienter) Umstellung auf Transparenzmaske
+ * deswegen (und weil in eve-VM effizienter) Umstellung auf Transparenzmaske
  * statt transparenter Farbe
  * TODO Dies ist in Java-VM allerdings extrem Speicher fressend -&gt; evtl abfragen 
 static int fixMask(WObject image,WObject col,int isMask):

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/TrackPoint.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/TrackPoint.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/TrackPoint.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,5 +1,6 @@
-package CacheWolf.navi;
+package cachewolf.navi;
 
+
 /**
  * this is not CWPoint because it should be as small as possible
  * @author pfeffer

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/TransformCoordinates.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/TransformCoordinates.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/TransformCoordinates.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,11 +1,13 @@
-package CacheWolf.navi;
+package cachewolf.navi;
 
-import CacheWolf.CWPoint;
-import CacheWolf.Matrix;
-import CacheWolf.MyLocale;
 
 import java.lang.Math;
 
+import cachewolf.CWPoint;
+import cachewolf.MyLocale;
+import cachewolf.utils.Matrix;
+
+
 /**
  * Class to transform coordinates and shift datums
  * it uses the 7 parameter Helmert Transformation
@@ -58,7 +60,7 @@
 	/** use this for south Germany, maximum deviation sub meter, valid in the former BRD (west germany) in 47&#176;00' N ... 50&#176;20' N */
 	public static final TransformParameters GK_SOUTH_GERMANY =  GK_SOUTH_GERMANY_TO_WGS84; 
 
-	public static Area FORMER_GDR = new Area(new CWPoint(54.923414, 10.503013), new CWPoint(50.402578, 14.520637)); 
+	public static final Area FORMER_GDR = new Area(new CWPoint(54.923414, 10.503013), new CWPoint(50.402578, 14.520637)); 
 	
 	// taken from <A HREF="http://www.lverma.nrw.de/produkte/druckschriften/verwaltungsvorschriften/images/gps/TrafopsNRW.pdf">http://www.lverma.nrw.de/produkte/druckschriften/verwaltungsvorschriften/images/gps/TrafopsNRW.pdf</A> for NRW this transform has deviations lower than 34cm.
 	private static final TransformParameters GK_NRW_GERMANY_TO_WGS84 = new TransformParameters(566.1, 116.3, 390.1, -1.11, -0.24, 3.76, 12.6);
@@ -164,7 +166,7 @@
 	public static CWPoint italianGkToWgs84(GkPoint gk) {
 		if (ITALY_SARDINIA_GK.isInBound(gk.toTrackPoint(GkPoint.ITALIAN_GB))) return gkToWgs84(gk, HAYFORD1909, GB_ITALIAN_SARDINIA_TO_WGS84, 0.9996);
 		if (ITALY_SICILIA_GK.isInBound(gk.toTrackPoint(GkPoint.ITALIAN_GB))) return gkToWgs84(gk, HAYFORD1909, GB_ITALIAN_SICILIA_TO_WGS84, 0.9996);
-		else return gkToWgs84(gk, HAYFORD1909, GB_ITALIAN_PENINSULAR_TO_WGS84, 0.9996);
+		return gkToWgs84(gk, HAYFORD1909, GB_ITALIAN_PENINSULAR_TO_WGS84, 0.9996);
 	}
 
 	public static CWPoint GkToWgs84(GkPoint gk, int region) {
@@ -214,7 +216,7 @@
 	public static TransformParameters getItalianGkTransformParameters(TrackPoint ll) {
 		if (ITALY_SARDINIA.isInBound(ll)) return GB_ITALIAN_SARDINIA_TO_WGS84;
 		if (ITALY_SICILIA.isInBound(ll)) return GB_ITALIAN_SICILIA_TO_WGS84;
-		else return GB_ITALIAN_PENINSULAR_TO_WGS84;
+		return GB_ITALIAN_PENINSULAR_TO_WGS84;
 	}
 	
 	/**
@@ -252,7 +254,7 @@
 		//ewe.sys.Vm.debug(&quot;wgs84-ll: &quot; + new CWPoint(ll).toString(CWPoint.DMS));
 		//ewe.sys.Vm.debug(&quot;gkll: &quot; + gkll.toString(CWPoint.DMS));
 		if (stripe == -1)	return projectLatlon2GkStripeauto(gkll, forgk, stripewidth, degreeOfStripe0, scale);
-		else return projectLatlon2GK(gkll, forgk, stripewidth, stripe, degreeOfStripe0, scale); 
+		return projectLatlon2GK(gkll, forgk, stripewidth, stripe, degreeOfStripe0, scale); 
 	}
 	/**
 	 * Call this method to convert any Gau&#223;-Kr&#252;ger coordinates into
@@ -334,9 +336,9 @@
 		rotate.matrix[2][0] = - rotate.matrix[0][2];
 		rotate.matrix[2][1] = - rotate.matrix[1][2];
 
-		rotate.Multiply(coos);
+		rotate.multiply(coos);
 		coos = rotate;
-		coos.MultiplyByScalar(transParams.s); // scale
+		coos.multiplyByScalar(transParams.s); // scale
 
 		return new XyzCoordinates(coos.matrix[0][0], coos.matrix[1][0], coos.matrix[2][0]);
 	}

Modified: experiments/engywuck/hist-test/src/cachewolf/navi/TransformCoordinatesProperties.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/navi/TransformCoordinatesProperties.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/navi/TransformCoordinatesProperties.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,33 +1,32 @@
-package CacheWolf.navi;
+package cachewolf.navi;
+import java.util.Properties;
 
-import ewe.io.IOException;
-import ewe.io.InputStream;
-import ewe.sys.Convert;
-import ewe.util.Properties;
-import CacheWolf.CWPoint;
-import CacheWolf.MyLocale;
+import cachewolf.CWPoint;
+import cachewolf.MyLocale;
 
+
+
 /**
- * Class to load the parameters of a datum shift of a map and
- * the projection parameters from an Inputstream by the corresponding
- * EPSG code
- * After instantiation you can simply use to and fromWGS84 to
- * convert between WGS84 and the given Coordinate reference system, given
- * by the EPSG code
- * Start offset in the language file: 4920  
- * @author Pfeffer
- *
- */
+* Class to load the parameters of a datum shift of a map and
+* the projection parameters from an Inputstream by the corresponding
+* EPSG code
+* After instantiation you can simply use to and fromWGS84 to
+* convert between WGS84 and the given Coordinate reference system, given
+* by the EPSG code
+* Start offset in the language file: 4920  
+* @author Pfeffer
+*
+*/
 public class TransformCoordinatesProperties extends Properties {
 	public int epsgCode;
-	
-	public TransformCoordinatesProperties(InputStream is) throws IOException {
+	static final long serialVersionUID=0;
+/*	public TransformCoordinatesProperties(InputStream is) throws IOException {
 		super();
 		load(is);
 		epsgCode = Convert.toInt(getProperty(&quot;EpsgCode&quot;, &quot;-1&quot;));
 		if (epsgCode == -1) throw new IllegalArgumentException(MyLocale.getMsg(4922, &quot;EPSG code missing in: &quot;) + is.getName());
 	}
-	
+*/	
 	public TransformCoordinatesProperties(int epsgcodei) {
 		if (!TransformCoordinates.isSupported(epsgcodei)) throw new IllegalArgumentException(
 				MyLocale.getMsg(4920, &quot;EPSG code &quot;) 

Modified: experiments/engywuck/hist-test/src/cachewolf/utils/Common.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/utils/Common.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/utils/Common.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,18 +1,13 @@
-package CacheWolf;
+package cachewolf.utils;
 
-import utils.FileBugfix;
-import ewe.io.Base64Codec;
-import ewe.io.File;
-import ewe.io.IOException;
-import ewe.sys.Convert;
-import ewe.util.ByteArray;
-import ewe.io.JavaUtf8Codec;
+import cachewolf.MyLocale;
+import eve.io.File;
 
 public final class Common {
 
 	private static char digSep=MyLocale.getDigSeparator().charAt(0);
 	private static char notDigSep=MyLocale.getDigSeparator().charAt(0)=='.'?',':'.';
-	
+
 	/**
 	 * get double value from string. It interpretes &quot;.&quot; and &quot;,&quot; as decimal separator
 	 * when the string cannot be interpreted, return 0.
@@ -36,7 +31,7 @@
 	public static double parseDoubleException (String value) {
 			return java.lang.Double.parseDouble(value.replace(notDigSep,digSep));
 	}
-	
+
 	public static int parseInt(String value){
 		try {
 			return java.lang.Integer.parseInt(value);
@@ -44,6 +39,18 @@
 			return 0;
 		}
 	}
+	/**
+	 * Format a double as string with a given number of decimal places
+	 * @param d The double to format
+	 * @param decimalplaces number of digits after the decimal point
+	 * @return Formatted number
+	 */
+	public static String doubleToString(double d, int decimalplaces) {
+		String format;
+		if (decimalplaces &gt; 0) format=&quot;0.0000000000&quot;.substring(0,decimalplaces+2);
+		else format = &quot;0&quot;;
+ 		return MyLocale.formatDouble(d, format).replace(',', '.');
+	}
 
 	/**
 	 * (De)codes the given text with rot13.
@@ -60,26 +67,27 @@
 
 			if (convert &amp;&amp; ((c &gt;= 'a' &amp;&amp; c &lt;= 'm') || (c &gt;= 'A' &amp;&amp; c &lt;= 'M'))) {
 				dummy[i] = (char) (c + 13);
-			} 
+			}
 			else if (convert &amp;&amp; ((c &gt;= 'n' &amp;&amp; c &lt;= 'z') || (c &gt;= 'N' &amp;&amp; c &lt;= 'Z'))) {
 				dummy[i] = (char) (c - 13);
-			} 
+			}
 			else if (c == '[') {
 				convert = false;
 				dummy[i] = '[';
-			} 
+			}
 			else if (c == ']') {
 				convert = true;
 				dummy[i] = ']';
-			} 
+			}
 			else {
 				dummy[i] = c;
 			}
 		}// for
 		return new String(dummy);
 	}
-	
-	public static String stringToHex(String str){
+
+/* Not used. SKG 20080316
+  	public static String stringToHex(String str){
 		StringBuffer strBuf = new StringBuffer();
 		StringBuffer strHex = new StringBuffer();
 		StringBuffer strTxt = new StringBuffer();
@@ -92,18 +100,18 @@
 		strBuf.append(strHex);
 		return strBuf.toString();
 	}
-	
-	public static String ClearForFileName(String str) {
+*/
+	public static String clearForFileName(String str) {
 		String ret = str.replace('?', '_');
 		ret = ret.replace(' ', '-');
 		ret = ret.replace(':', '-');
 		return ret;
 	}
-	
+
 	/**
 	 * finds the correct (existing) extension to an image filename
 	 * @param filename without extension
-	 * @return filename with extension 
+	 * @return filename with extension
 	 */
 	static public String getImageName(String name) {
 		String fileName;
@@ -111,7 +119,7 @@
 		String[] t = {&quot;.png&quot;, &quot;.gif&quot;, &quot;.jpg&quot;, &quot;.bmp&quot;};
 		int i;
 		for (i = 0; i&lt;t.length; i++) {
-			tmp = new FileBugfix(name+t[i]);
+			tmp = new File(name+t[i]);
 			if (tmp.exists()) break;
 		}
 		if (i &gt;=t.length) fileName = null;
@@ -119,7 +127,7 @@
 		return fileName;
 	}
 	/** get the extension of a filename, including &quot;.&quot;
-	 * remark: ewe.io.File.getFileExtension return name + extension
+	 * remark: eve.io.File.getFileExtension return name + extension
 	 * @param fn
 	 * @return
 	 */
@@ -129,19 +137,12 @@
 		if (dot &lt; 0) return &quot;&quot;;
 		return fn.substring(dot, fn.length());
 	}
-	
-	public static String DoubleToString(double d, int decimalplaces) {
-		ewe.sys.Double e = new ewe.sys.Double();
-		e.set(d);
-		e.decimalPlaces = decimalplaces;
-		return e.toString().replace(',', '.');
 
-	}
-	
 	public static String fixSerialPortName(String name) {
-		if (name.startsWith(&quot;/&quot;)) return new String(&quot;..&quot;+name); // on linux (*nix) machines it is quite usual to give the complete file path to the serial port, but ewe expects only &quot;ttyS0&quot; or similar
-		else                      return name;
+		if (name.startsWith(&quot;/&quot;))
+			return new String(&quot;..&quot;+name); // on linux (*nix) machines it is quite usual to give the complete file path to the serial port, but ewe expects only &quot;ttyS0&quot; or similar
+		else
+			return name;
 	}
 
-
 }

Modified: experiments/engywuck/hist-test/src/cachewolf/utils/DateFormat.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/utils/DateFormat.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/utils/DateFormat.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,4 +1,4 @@
-package CacheWolf;
+package cachewolf.utils;
 /* Several date formats are used by GC.COM
  *    2/27/2004   - Hidden dates are in format mm/dd/yyyy (=US style)
  *    February 27 - Found dates which happened this year
@@ -6,12 +6,13 @@
  * The internal standard is sortable:
  *    2004-02-27    - YYYY-MM-DD   
  */
-import ewe.sys.*;
+import eve.sys.Time;
+import eve.sys.Convert;
 
 public class DateFormat {
 
 /** Convert the US Format into a sortable format */
-static String MDY2YMD(String date) {
+public static String MDY2YMD(String date) {
 	// Dates are in format M/D/Y
 	int p1,p2=-1;
 	p1=date.indexOf(&quot;/&quot;);
@@ -20,8 +21,8 @@
 		return date.substring(p2+1)+&quot;-&quot;+
 		        (p1==1?&quot;0&quot;:&quot;&quot;)+date.substring(0,p1)+&quot;-&quot;+
 		        (p1+2==p2?&quot;0&quot;:&quot;&quot;)+date.substring(p1+1,p2);
-	} else
-		return date;
+	} 
+	return date;
 }
 
 /* Convert the sortable date into a US date */
@@ -30,7 +31,7 @@
 //}
 
 /** Convert the log format into a sortable format */
-static String logdate2YMD(String logdate) {
+public static String logdate2YMD(String logdate) {
    String monthNames[]={&quot;January&quot;,&quot;February&quot;,&quot;March&quot;,&quot;April&quot;,&quot;May&quot;,&quot;June&quot;,&quot;July&quot;,&quot;August&quot;,&quot;September&quot;,&quot;October&quot;,&quot;November&quot;,&quot;December&quot;};
    Time t=new Time();
    String year,month,day;
@@ -40,7 +41,7 @@
    year=logdate.substring(i+2,i+6);
    for (m=0; m&lt;12; m++) {
 	   if (logdate.startsWith(monthNames[m])) {
-		   month=(m&lt;9?&quot;0&quot;:&quot;&quot;)+Convert.formatInt(m+1);
+		   month=(m&lt;9?&quot;0&quot;:&quot;&quot;)+Convert.formatInt(m+1); //TODO Eliminate Convert
 		   day=logdate.substring(monthNames[m].length()+1,i);
 		   if (day.length()==1)day=&quot;0&quot;+day;
 		   return year+&quot;-&quot;+month+&quot;-&quot;+day;

Modified: experiments/engywuck/hist-test/src/cachewolf/utils/Extractor.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/utils/Extractor.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/utils/Extractor.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,4 +1,4 @@
-package CacheWolf;
+package cachewolf.utils;
 
 
 /**
@@ -14,7 +14,7 @@
 		String tst;
 		boolean betweenonly;
 		public static boolean INCLUDESTARTEND = false;
-		public static boolean EXCLUDESTARTEND = true;
+		public static final boolean EXCLUDESTARTEND = true;
 		/**
 		*	Create an extractor.
 		*	sTxt = The string to search through.&lt;br&gt;
@@ -50,8 +50,9 @@
 		* that is being searched through.
 		*/
 		public boolean endOfSearch(){
-			if(searchText == null || startOffset &gt;= searchText.length()) return true;
-			else return false;
+			if(searchText == null || startOffset &gt;= searchText.length()) 
+				return true;
+			return false;
 		}
 		
 		/**
@@ -60,13 +61,13 @@
 		*	is returned til it's end.
 		*/
 		public String findNext(){
-			if (searchText == null) return new String(); //maby null should 
+			if (searchText == null) return &quot;&quot;; //maby null should 
 			int idxStart = searchText.indexOf(start,startOffset);
 			int idxEnd = searchText.indexOf(end, idxStart+start.length());
 			////Vm.debug(&quot;Start: &quot; + Convert.toString(idxStart) + &quot; End: &quot; + Convert.toString(idxEnd));
 			if(idxEnd == -1) idxEnd = searchText.length(); //index counts from zero length from 1 but the last char is not included in substr and substr accepts length +1 (but not length+2)
 			startOffset = idxEnd;
-			tst = new String();
+			tst = &quot;&quot;;
 			if(idxStart &gt; -1){
 				if(betweenonly == false){
 					if (idxEnd+end.length() &gt;= searchText.length()) 

Modified: experiments/engywuck/hist-test/src/cachewolf/utils/Matrix.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/utils/Matrix.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/utils/Matrix.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,6 +1,6 @@
-package CacheWolf;
+package cachewolf.utils;
 
-import ewe.sys.*;
+import eve.sys.*;
 
 public class Matrix{
 	int iDF = 0;
@@ -22,7 +22,7 @@
 	*	Method to multiply this matrix with another matrix.
 	*	The result is stored in this matrix!
 	*/
-	public void Multiply(Matrix srcMatrix){
+	public void multiply(Matrix srcMatrix){
 		double m[][] = new double[matrix.length][srcMatrix.matrix[0].length];
 		for (int i = 0; i &lt; m.length; i++)
 			for (int j = 0; j &lt; m[i].length; j++){
@@ -49,7 +49,7 @@
 		return product;
 	}
 	
-	public void MultiplyByScalar (double f) {
+	public void multiplyByScalar (double f) {
 		for (int i = 0; i &lt; matrix.length; i++)
 			for (int j = 0; j &lt; matrix[0].length; j++)
 				matrix[i][j] = matrix[i][j] * f;
@@ -69,7 +69,7 @@
 	*	would become:	|1 3 5 |
 	*			|2 4 6 |
 	*/
-	public void Transpose(){
+	public void transpose(){
 		
 		double m[][] = new double[matrix[0].length][matrix.length];
 		for (int i = 0; i &lt; matrix.length; i++)
@@ -99,7 +99,7 @@
 	/**
 	*	Method to display the contents of a matrix.
 	*/
-	public void DumpMatrix(){
+	public void dumpMatrix(){
 		for (int i = 0; i &lt; matrix.length; i++)
 			for (int j = 0; j &lt; matrix[i].length; j++)
 				Vm.debug(&quot;[ &quot;+i+ &quot; &quot; + j + &quot; ] &quot; + matrix[i][j]);
@@ -125,16 +125,15 @@
 					{
 						iDF = 0;
 						break outahere;
-					} else {
-						for (int c = 0; c &lt; tms; c++) {
-							temp = m[col][c];
-							m[col][c] = m[col + v][c]; // switch rows
-							m[col + v][c] = temp;
-						}
-						v++; // count row switchs
-						iDF = iDF * -1; // each switch changes determinant
-										// factor
+					} 
+					for (int c = 0; c &lt; tms; c++) {
+						temp = m[col][c];
+						m[col][c] = m[col + v][c]; // switch rows
+						m[col + v][c] = temp;
 					}
+					v++; // count row switchs
+					iDF = iDF * -1; // each switch changes determinant
+									// factor
 				}
 				if (m[col][col] != 0) {
 					try {
@@ -154,7 +153,7 @@
 	/**
 	*	Method to calculate the determinate of a matrix
 	*/
-	public double Determinant(double[][] matrix) {
+	public double determinant(double[][] matrix) {
 		int tms = matrix.length;
 		double det = 1;
 		matrix = UpperTriangle(matrix);
@@ -171,7 +170,7 @@
 	*	Method to calculate the inverse of this matrix.
 	*	The result is stored in this matrix!
 	*/
-	public void Inverse() {
+	public void inverse() {
 		// Formula used to Calculate Inverse:
 		// inv(A) = 1/det(A) * adj(A)
 		
@@ -180,7 +179,7 @@
 		double m[][] = new double[tms][tms];
 		double mm[][] = Adjoint(matrix);
 
-		double det = Determinant(matrix);
+		double det = determinant(matrix);
 		double dd = 0;
 
 		if (det == 0) {
@@ -228,7 +227,7 @@
 					}
 					ja = 0;
 				}
-				det = Determinant(ap);
+				det = determinant(ap);
 				m[i][j] = java.lang.Math.pow(-1, i + j) * det;
 			}
 		m = Transpose2(m);
@@ -237,7 +236,7 @@
 	
 	/**
 	*	&quot;Old&quot; helper method used by some other classes in cachewolf.
-	*	@deprecated Do not use when coding new classes!
+	*	//@deprecated Do not use when coding new classes!
 	*/
 	public static double dot(double p1, double p2, double q1, double q2, double x1, double x2){
 		double dt,AB0,AB1,BC0,BC1 = 0;
@@ -251,7 +250,7 @@
 	
 	/**
 	*	&quot;Old&quot; helper method used by some other classes in cachewolf.
-	*	@deprecated Do not use when coding new classes!
+	*	//@deprecated Do not use when coding new classes!
 	*/
 	public static double cross(double p1, double p2, double q1, double q2, double x1, double x2){
 		double cr,AB0,AB1,AC0,AC1 = 0;
@@ -265,7 +264,7 @@
 	
 	/**
 	*	&quot;Old&quot; helper method used by some other classes in cachewolf.
-	*	@deprecated Do not use when coding new classes!
+	*	//@deprecated Do not use when coding new classes!
 	*/
 	public static double dist(double p1, double p2, double q1, double q2){
 		double d1, d2,dt = 0;

Modified: experiments/engywuck/hist-test/src/cachewolf/utils/ParseLatLon.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/utils/ParseLatLon.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/utils/ParseLatLon.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,6 +1,8 @@
-package CacheWolf;
+package cachewolf.utils;
 
-import ewe.sys.*;
+import cachewolf.Global;
+import eve.sys.*;
+import cachewolf.MyLocale;
 
 /**
 *	This class parses a string representation of longitude and latitude.
@@ -8,8 +10,8 @@
 *	latitude (DD.dddd)
 */
 public class ParseLatLon {
-	
-	String latlon;	
+
+	String latlon;
 	/**
 	*	After a calling the method parse()
 	*	this variable holds the double value of latitude
@@ -31,7 +33,7 @@
 		latlon = ll;
 		digSep=MyLocale.getDigSeparator().charAt(0);
 	}
-	
+
 	/**
 	*	Constructor to parse a lat lon string like:
 	*	N 49 33.167 E 011 21.608.
@@ -41,10 +43,10 @@
 		latlon = ll;
 		digSep=MyLocale.getDigSeparator().charAt(0);
 	}
-	
+
 	private int start;
 	private int end;
-	
+
 	/** Get the next non-blank part of the latlon String */
 	String getNext() {
         start=end;
@@ -53,13 +55,13 @@
         while (latlon.charAt(end)!=' ') end++; // collect non-blanks
 		return latlon.substring(start,end);
 	}
-	
+
 	/**
 	* Parse a string that contains lat lon into it's lat and lon doubles. Class
 	* variable latlon must have been set befor you call this method.
 	*/
 	public void parse() throws NumberFormatException {
-		if (digSep==',') 
+		if (digSep==',')
 			latlon = latlon.replace('.', ',')+&quot; &quot;;
 		else
 			latlon = latlon.replace(',', '.')+&quot; &quot;;
@@ -81,8 +83,8 @@
 			if(latNS.charAt(0)=='S') lat2= -lat2 ;
 			lon2 = Convert.parseDouble(lonDeg) + Convert.parseDouble(lonMin)/60.0;
 			if(lonEW.charAt(0)=='W') lon2 = -lon2;
-		} catch (Exception e) { 
-			throw new NumberFormatException(&quot;Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM&quot;); 
+		} catch (Exception e) {
+			throw new NumberFormatException(&quot;Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM&quot;);
 		}
 
 	}

Modified: experiments/engywuck/hist-test/src/cachewolf/utils/STRreplace.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/utils/STRreplace.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/utils/STRreplace.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,5 +1,6 @@
-package CacheWolf;
+package cachewolf.utils;
 
+
 public class STRreplace{
 		/* Replace all instances of a String in a String.
 		 *   @param  s  String to alter.

Modified: experiments/engywuck/hist-test/src/cachewolf/utils/SafeXML.java
===================================================================
--- experiments/engywuck/hist-test/src/cachewolf/utils/SafeXML.java	2008-10-26 14:34:32 UTC (rev 1564)
+++ experiments/engywuck/hist-test/src/cachewolf/utils/SafeXML.java	2008-10-26 14:40:13 UTC (rev 1565)
@@ -1,4 +1,4 @@
-package CacheWolf;
+package cachewolf.utils;
 
 /**
 *	A class to replace unsafe XML characters with characters that a user
@@ -6,7 +6,7 @@
 * 20061222: skg Modified cleanback to speed up the new index.xml reader
 */
 
-import ewe.util.Hashtable;
+import java.util.Hashtable;
 
 public class SafeXML{
 	private static final char ENTITY_START = '&amp;';
@@ -119,6 +119,7 @@
 				
 				&quot;&#34;&quot;,  &quot;\&quot;&quot;,
 				&quot;&#38;&quot;,  &quot;&amp;&quot;,
+				&quot;&#39;&quot;,  &quot;'&quot;,
 				&quot;&#60;&quot;,  &quot;&lt;&quot;,
 				&quot;&#62;&quot;,  &quot;&gt;&quot;,
 				&quot;&#160;&quot;, &quot; &quot;,
@@ -230,8 +231,8 @@
 				&quot;&#8220;&quot;, &quot;\&quot;&quot;,
 				&quot;&#8221;&quot;, &quot;\&quot;&quot;,
 				&quot;&#8222;&quot;, &quot;\&quot;&quot;,
-				&quot;&#8223;&quot;, &quot;\&quot;&quot;,
 				&quot;&#8226;&quot;, &quot;&#149;&quot;,
+				&quot;&#8223;&quot;, &quot;\&quot;&quot;,
 				&quot;&#8242;&quot;, &quot;'&quot;,
 				&quot;&#8243;&quot;, &quot;\&quot;&quot;
 				};
@@ -414,7 +415,6 @@
 
 		if (src == null)
 			return (null);
-
 		slen = src.length();
 		dst = new StringBuffer(slen);
 		tmp = new char[slen];
@@ -448,7 +448,6 @@
 
 		if (src == null)
 			return (null);
-
 		slen = src.length();
 		dst = new StringBuffer(slen);
 		tmp = new char[slen];
@@ -519,4 +518,4 @@
 				dst.append(tmp[i++]);
 		return (dst.toString());
 	}
-}
+}
\ No newline at end of file


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001458.html">[Cachewolf-svn] r1564 - in	experiments/engywuck/hist-test/src/cachewolf: . imp utils
</A></li>
	<LI>Next message: <A HREF="001460.html">[Cachewolf-svn] r1566 - in experiments/engywuck/hist-test/programs:	. resources
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1459">[ date ]</a>
              <a href="thread.html#1459">[ thread ]</a>
              <a href="subject.html#1459">[ subject ]</a>
              <a href="author.html#1459">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
