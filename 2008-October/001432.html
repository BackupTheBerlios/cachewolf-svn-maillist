<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r1538 - in experiments: . EVE EVE/src	EVE/src/cachewolf EVE/src/cachewolf/exp EVE/src/cachewolf/imp	EVE/src/cachewolf/navi EVE/src/cachewolf/utils
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1538%20-%20in%20experiments%3A%20.%20EVE%20EVE/src%0A%09EVE/src/cachewolf%20EVE/src/cachewolf/exp%20EVE/src/cachewolf/imp%0A%09EVE/src/cachewolf/navi%20EVE/src/cachewolf/utils&In-Reply-To=%3C200810152010.m9FKAIpV018539%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001431.html">
   <LINK REL="Next"  HREF="001433.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r1538 - in experiments: . EVE EVE/src	EVE/src/cachewolf EVE/src/cachewolf/exp EVE/src/cachewolf/imp	EVE/src/cachewolf/navi EVE/src/cachewolf/utils</H1>
    <B>salzkammergut at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1538%20-%20in%20experiments%3A%20.%20EVE%20EVE/src%0A%09EVE/src/cachewolf%20EVE/src/cachewolf/exp%20EVE/src/cachewolf/imp%0A%09EVE/src/cachewolf/navi%20EVE/src/cachewolf/utils&In-Reply-To=%3C200810152010.m9FKAIpV018539%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r1538 - in experiments: . EVE EVE/src	EVE/src/cachewolf EVE/src/cachewolf/exp EVE/src/cachewolf/imp	EVE/src/cachewolf/navi EVE/src/cachewolf/utils">salzkammergut at mail.berlios.de
       </A><BR>
    <I>Wed Oct 15 22:10:18 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001431.html">[Cachewolf-svn] r1537 - trunk
</A></li>
        <LI>Next message: <A HREF="001433.html">[Cachewolf-svn] r1539 - in experiments/EVE: . lib lib/lib-folder	lib/lib-folder/HTML lib/lib-folder/HTML/Tmpl	lib/lib-folder/com lib/lib-folder/com/bbn	lib/lib-folder/com/bbn/openmap lib/lib-folder/com/bbn/openmap/proj	lib/lib-folder/com/bbn/openmap/proj/coords	lib/lib-folder/com/bbn/openmap/util lib/lib-folder/com/stevesoft	lib/lib-folder/com/stevesoft/ewe_pat	lib/lib-folder/com/stevesoft/ewe_pat/wrap	lib/lib-folder/ewesoft lib/lib-folder/ewesoft/xml	lib/lib-folder/ewesoft/xml/sax
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1432">[ date ]</a>
              <a href="thread.html#1432">[ thread ]</a>
              <a href="subject.html#1432">[ subject ]</a>
              <a href="author.html#1432">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: salzkammergut
Date: 2008-10-15 22:07:59 +0200 (Wed, 15 Oct 2008)
New Revision: 1538

Added:
   experiments/EVE/
   experiments/EVE/src/
   experiments/EVE/src/cachewolf/
   experiments/EVE/src/cachewolf/Attribute.java
   experiments/EVE/src/cachewolf/Attributes.java
   experiments/EVE/src/cachewolf/AttributesSelector.java
   experiments/EVE/src/cachewolf/AttributesViewer.java
   experiments/EVE/src/cachewolf/CWPoint.java
   experiments/EVE/src/cachewolf/CacheHolder.java
   experiments/EVE/src/cachewolf/CacheHolderDetail.java
   experiments/EVE/src/cachewolf/CacheList.java
   experiments/EVE/src/cachewolf/CacheType.java
   experiments/EVE/src/cachewolf/CacheWolf.java
   experiments/EVE/src/cachewolf/CalcPanel.java
   experiments/EVE/src/cachewolf/CenterScreen.java
   experiments/EVE/src/cachewolf/CoordsScreen.java
   experiments/EVE/src/cachewolf/DataMover.java
   experiments/EVE/src/cachewolf/DateTimeChooser.java
   experiments/EVE/src/cachewolf/DescriptionPanel.java
   experiments/EVE/src/cachewolf/DetailsPanel.java
   experiments/EVE/src/cachewolf/Filter.java
   experiments/EVE/src/cachewolf/FilterScreen.java
   experiments/EVE/src/cachewolf/GPSPortOptions.java
   experiments/EVE/src/cachewolf/Global.java
   experiments/EVE/src/cachewolf/HintLogPanel.java
   experiments/EVE/src/cachewolf/HttpConnection.java
   experiments/EVE/src/cachewolf/ImageDetailScreen.java
   experiments/EVE/src/cachewolf/ImagePanel.java
   experiments/EVE/src/cachewolf/InfoBox.java
   experiments/EVE/src/cachewolf/InfoHtmlScreen.java
   experiments/EVE/src/cachewolf/Log.java
   experiments/EVE/src/cachewolf/LogList.java
   experiments/EVE/src/cachewolf/MainForm.java
   experiments/EVE/src/cachewolf/MainMenu.java
   experiments/EVE/src/cachewolf/MainTab.java
   experiments/EVE/src/cachewolf/MyEditor.java
   experiments/EVE/src/cachewolf/MyLocale.java
   experiments/EVE/src/cachewolf/MyScrollBarPanel.java
   experiments/EVE/src/cachewolf/NewProfileForm.java
   experiments/EVE/src/cachewolf/NewProfileWizard.java
   experiments/EVE/src/cachewolf/Parser.java
   experiments/EVE/src/cachewolf/Preferences.java
   experiments/EVE/src/cachewolf/PreferencesScreen.java
   experiments/EVE/src/cachewolf/Profile.java
   experiments/EVE/src/cachewolf/ProfilesForm.java
   experiments/EVE/src/cachewolf/RadarPanel.java
   experiments/EVE/src/cachewolf/RebuildIndex.java
   experiments/EVE/src/cachewolf/SearchCache.java
   experiments/EVE/src/cachewolf/ShowCacheInBrowser.java
   experiments/EVE/src/cachewolf/SolverPanel.java
   experiments/EVE/src/cachewolf/StatusBar.java
   experiments/EVE/src/cachewolf/TableColumnChooser.java
   experiments/EVE/src/cachewolf/TableForm.java
   experiments/EVE/src/cachewolf/TablePanel.java
   experiments/EVE/src/cachewolf/Test.java
   experiments/EVE/src/cachewolf/Travelbug.java
   experiments/EVE/src/cachewolf/TravelbugJourney.java
   experiments/EVE/src/cachewolf/TravelbugJourneyList.java
   experiments/EVE/src/cachewolf/TravelbugJourneyScreen.java
   experiments/EVE/src/cachewolf/TravelbugList.java
   experiments/EVE/src/cachewolf/TravelbugPickup.java
   experiments/EVE/src/cachewolf/TravelbugScreen.java
   experiments/EVE/src/cachewolf/URL.java
   experiments/EVE/src/cachewolf/URLStreamHandler.java
   experiments/EVE/src/cachewolf/UrlFetcher.java
   experiments/EVE/src/cachewolf/Version.java
   experiments/EVE/src/cachewolf/exp/
   experiments/EVE/src/cachewolf/exp/ASCExporter.java
   experiments/EVE/src/cachewolf/exp/DistanceComparer.java
   experiments/EVE/src/cachewolf/exp/ExploristExporter.java
   experiments/EVE/src/cachewolf/exp/Exporter.java
   experiments/EVE/src/cachewolf/exp/GPXExporter.java
   experiments/EVE/src/cachewolf/exp/HTMLExporter.java
   experiments/EVE/src/cachewolf/exp/KMLExporter.java
   experiments/EVE/src/cachewolf/exp/LocExporter.java
   experiments/EVE/src/cachewolf/exp/MSARCSVExporter.java
   experiments/EVE/src/cachewolf/exp/OVLExporter.java
   experiments/EVE/src/cachewolf/exp/OziExporter.java
   experiments/EVE/src/cachewolf/exp/PCX5Exporter.java
   experiments/EVE/src/cachewolf/exp/TPLExporter.java
   experiments/EVE/src/cachewolf/exp/TomTomExporter.java
   experiments/EVE/src/cachewolf/exp/TomTomExporterScreen.java
   experiments/EVE/src/cachewolf/imp/
   experiments/EVE/src/cachewolf/imp/DBImporter.java
   experiments/EVE/src/cachewolf/imp/GPXImporter.java
   experiments/EVE/src/cachewolf/imp/KMLImporter.java
   experiments/EVE/src/cachewolf/imp/LOCXMLImporter.java
   experiments/EVE/src/cachewolf/imp/OCXMLImporter.java
   experiments/EVE/src/cachewolf/imp/OCXMLImporterScreen.java
   experiments/EVE/src/cachewolf/imp/SpiderGC.java
   experiments/EVE/src/cachewolf/navi/
   experiments/EVE/src/cachewolf/navi/Area.java
   experiments/EVE/src/cachewolf/navi/AreaList.java
   experiments/EVE/src/cachewolf/navi/CWGPSPoint.java
   experiments/EVE/src/cachewolf/navi/Ellipsoid.java
   experiments/EVE/src/cachewolf/navi/GeodeticCalculator.java
   experiments/EVE/src/cachewolf/navi/GkPoint.java
   experiments/EVE/src/cachewolf/navi/GotoPanel.java
   experiments/EVE/src/cachewolf/navi/MapImage.java
   experiments/EVE/src/cachewolf/navi/MapImporter.java
   experiments/EVE/src/cachewolf/navi/MapInfoObject.java
   experiments/EVE/src/cachewolf/navi/MapLoader.java
   experiments/EVE/src/cachewolf/navi/MapLoaderGui.java
   experiments/EVE/src/cachewolf/navi/MapSymbol.java
   experiments/EVE/src/cachewolf/navi/MapsList.java
   experiments/EVE/src/cachewolf/navi/MovingMap.java
   experiments/EVE/src/cachewolf/navi/Navigate.java
   experiments/EVE/src/cachewolf/navi/SelectMap.java
   experiments/EVE/src/cachewolf/navi/SkyOrientation.java
   experiments/EVE/src/cachewolf/navi/Track.java
   experiments/EVE/src/cachewolf/navi/TrackOverlay.java
   experiments/EVE/src/cachewolf/navi/TrackPoint.java
   experiments/EVE/src/cachewolf/navi/TransformCoordinates.java
   experiments/EVE/src/cachewolf/navi/TransformCoordinatesProperties.java
   experiments/EVE/src/cachewolf/utils/
   experiments/EVE/src/cachewolf/utils/Common.java
   experiments/EVE/src/cachewolf/utils/DateFormat.java
   experiments/EVE/src/cachewolf/utils/Extractor.java
   experiments/EVE/src/cachewolf/utils/Matrix.java
   experiments/EVE/src/cachewolf/utils/ParseLatLon.java
   experiments/EVE/src/cachewolf/utils/STRreplace.java
   experiments/EVE/src/cachewolf/utils/SafeXML.java
Log:
FINALLY!

A first stab at a CW version based on EVE. Warning: This is very much work in progress and has not been exhaustively tested although the main functions with the exception of the MM seem to work alright. (You have been warned!) The moving map is not functional and still needs extensive work due to the many changes of the graphics framework.

The current version should (more or less) be equivalent to CW-EWE-1533. Some additional changes:
- Naming convention changed in-line with Java conventions (directories in lowercase, Classes in Uppercase)
- Also some tidying within files: Class member names changed to lowercase.
- Four subdirectories to cachewolf: exp (=exporters), imp (=importers including spider), navi (=moving map) and utils (=utilities).
- Some related files were combined to make editing easier, e.g. TablePanel now contains old myTableModel and myTableControl and myComparer, Parser now contains Tokenizer etc. The cachewolf directory should only contain screens and main classes - there are still too many files in this directory.
- References to FileBugfix were removed - need to test whether the file system bugs have been fixed in EVE. If necessary, EVE needs to be updated.
- All helper files (language files, attributes, images) are identical to CW-EWE.
- The &quot;DelayedDisplay&quot; to speed up loading on the PDA which was suggested by Mike Brereton in the EVE forum has not been implemented yet.
- RadarPanel background is buffered for faster redrawing when a different cache is selected in the listview
- some other changes which I have now forgotten :-(

Extensive testing now needed. I did not have time for this as pressure to release some code was mounting and I have been very busy at work over the last few months. The moving map is not functional. With hindsight it was a mistake to start the conversion to EVE off-line, as many changes were checked in after I had done a considerable amount of work which I did not want to undo.  :-(

Could somebody who is more conversant with SVN (Engywuck?) please move these files to an appropriate location.

salzkammergut


Added: experiments/EVE/src/cachewolf/Attribute.java
===================================================================
--- experiments/EVE/src/cachewolf/Attribute.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/Attribute.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,188 @@
+package cachewolf;
+
+import eve.fx.Picture;
+import eve.io.File;
+import cachewolf.utils.STRreplace;
+
+/**
+ * This class represents a single attribute
+ * @author skg
+ *
+ */
+public class Attribute {
+	// Constructors
+	public Attribute() { attNo=0; }
+	public Attribute(String attributeName) { attNo=attName2int(attributeName); }
+
+	private int attNo;
+
+	public int getAttrNr () { return attNo; }
+
+	/**
+	 * The attribute names are identical to the image names.
+	 * Internally the first image name has number 0, the next number 1 and so on.
+	 */
+	public static final String [] attributeNames= {
+			&quot;error.gif&quot;,			//00 Unknown attribute
+			&quot;available-no.gif&quot;, 	//01 not 24-7
+			&quot;available-yes.gif&quot;, 	//02 available 24-7
+			&quot;bicycles-no.gif&quot;, 		//03 no bikes
+			&quot;bicycles-yes.gif&quot;, 	//04 bikes allowed
+			&quot;boat-no.gif&quot;, 			//05
+			&quot;boat-yes.gif&quot;, 		//06
+			&quot;cactus-no.gif&quot;, 		//07
+			&quot;cactus-yes.gif&quot;,		//08
+			&quot;campfires-no.gif&quot;, 	//09 no campfires
+			&quot;campfires-yes.gif&quot;, 	//10 campfires allowed
+			&quot;camping-no.gif&quot;, 		//11 No camping
+			&quot;camping-yes.gif&quot;, 		//12 Camping allowed
+			&quot;cliff-no.gif&quot;, 		//13
+			&quot;cliff-yes.gif&quot;, 		//14 falling-rocks nearby
+			&quot;climbing-no.gif&quot;, 		//15 no difficult climbing
+			&quot;climbing-yes.gif&quot;, 	//16 difficult climbing
+			&quot;compass-no.gif&quot;, 		//17
+			&quot;compass-yes.gif&quot;,		//18
+			&quot;cow-no.gif&quot;, 			//19
+			&quot;cow-yes.gif&quot;, 			//20 watch for livestock
+			&quot;danger-no.gif&quot;, 		//21
+			&quot;danger-yes.gif&quot;, 		//22 dangerous area
+			&quot;dogs-no.gif&quot;, 			//23 no dogs
+			&quot;dogs-yes.gif&quot;, 		//24 dogs allowed
+			&quot;fee-no.gif&quot;, 			//25
+			&quot;fee-yes.gif&quot;, 			//26 access/parking fees
+			&quot;hiking-no.gif&quot;, 		//27
+			&quot;hiking-yes.gif&quot;, 		//28 significant hike
+			&quot;horses-no.gif&quot;, 		//29 no horses
+			&quot;horses-yes.gif&quot;, 		//30 horses allowed
+			&quot;hunting-no.gif&quot;, 		//31
+			&quot;hunting-yes.gif&quot;, 		//32 hunting area
+			&quot;jeeps-no.gif&quot;, 		//33 no off-road vehicles
+			&quot;jeeps-yes.gif&quot;, 		//34 off-road vehicles allowed
+			&quot;kids-no.gif&quot;, 			//35 no kids
+			&quot;kids-yes.gif&quot;, 		//36 kid friendly
+			&quot;mine-no.gif&quot;, 			//37
+			&quot;mine-yes.gif&quot;, 		//38
+			&quot;motorcycles-no.gif&quot;, 	//39 no motorcycles
+			&quot;motorcycles-yes.gif&quot;, 	//40 motorcycles allowed
+			&quot;night-no.gif&quot;, 		//41 not recommended at night
+			&quot;night-yes.gif&quot;, 		//42 recommended at night
+			&quot;onehour-no.gif&quot;, 		//43 takes more than one hour
+			&quot;onehour-yes.gif&quot;, 		//44 takes less than one hour
+			&quot;parking-no.gif&quot;, 		//45
+			&quot;parking-yes.gif&quot;, 		//46 parking available
+			&quot;phone-no.gif&quot;, 		//47
+			&quot;phone-yes.gif&quot;, 		//48 telephone nearby
+			&quot;picnic-no.gif&quot;, 		//49
+			&quot;picnic-yes.gif&quot;, 		//50 picnic tables available
+			&quot;poisonoak-no.gif&quot;, 	//51
+			&quot;poisonoak-yes.gif&quot;, 	//52
+			&quot;public-no.gif&quot;, 		//53
+			&quot;public-yes.gif&quot;, 		//54 public transit available
+			&quot;quads-no.gif&quot;, 		//55 no quads
+			&quot;quads-yes.gif&quot;, 		//56 quads allowed
+			&quot;rappelling-no.gif&quot;, 	//57
+			&quot;rappelling-yes.gif&quot;, 	//58 climbing gear
+			&quot;restrooms-no.gif&quot;, 	//59
+			&quot;restrooms-yes.gif&quot;, 	//60 restrooms available
+			&quot;scenic-no.gif&quot;, 		//61
+			&quot;scenic-yes.gif&quot;, 		//62 scenic view
+			&quot;scuba-no.gif&quot;, 		//63
+			&quot;scuba-yes.gif&quot;, 		//64
+			&quot;snakes-no.gif&quot;, 		//65
+			&quot;snakes-yes.gif&quot;, 		//66
+			&quot;snowmobiles-no.gif&quot;, 	//67 no snowmobiles
+			&quot;snowmobiles-yes.gif&quot;, 	//68
+			&quot;stealth-no.gif&quot;, 		//69 no stealth required
+			&quot;stealth-yes.gif&quot;, 		//70 stealth required
+			&quot;stroller-no.gif&quot;,		//71 not stroller accessible
+			&quot;stroller-yes.gif&quot;, 	//72 stroller accessible
+			&quot;swimming-no.gif&quot;, 		//73
+			&quot;swimming-yes.gif&quot;, 	//74
+			&quot;thorn-no.gif&quot;, 		//75
+			&quot;thorn-yes.gif&quot;, 		//76 thorns!
+			&quot;ticks-no.gif&quot;, 		//77
+			&quot;ticks-yes.gif&quot;, 		//78 ticks!
+			&quot;wading-no.gif&quot;, 		//79
+			&quot;wading-yes.gif&quot;, 		//80 may require wading
+			&quot;water-no.gif&quot;, 		//81
+			&quot;water-yes.gif&quot;, 		//82 drinking water nearby
+			&quot;wheelchair-no.gif&quot;, 	//83 not wheelchair accessible
+			&quot;wheelchair-yes.gif&quot;, 	//84 wheelchair accessible
+			&quot;winter-no.gif&quot;, 		//85 not available for winter
+			&quot;winter-yes.gif&quot;, 		//86 available in winter
+			&quot;firstaid-no.gif&quot;,      //87 does not need maintenance
+			&quot;firstaid-yes.gif&quot;,     //88 needs maintenance
+			&quot;flashlight-yes.gif&quot;    // 89 Flashlight required
+	};
+	private static Picture [] attributeImages=new Picture[90];
+	private static String IMAGEDIR=STRreplace.replace(File.getProgramDirectory()+&quot;/attributes/&quot;, &quot;//&quot;, &quot;/&quot;);
+	public static String getImageDir() {
+		return IMAGEDIR;
+	}
+
+    /**
+     * Returns the image name for a give attribute number
+     * @return Image Name
+     */
+	public String getImageName(){
+		if (attNo&gt;attributeNames.length)
+			return &quot;error.gif&quot;;
+		return attributeNames[attNo];
+	}
+
+	/**
+	 * Returns the text description of the image
+	 * @return Text description of Image
+	 */
+	public String getInfo(){
+		return MyLocale.getMsg(2500+attNo,&quot;No attribute info found&quot;);
+	}
+
+	/**
+	 * Returns the width of the attribute icons
+	 * @return The width of the images
+	 */
+	public static int getImageWidth() {
+		initErrorImg();
+		return attributeImages[0].getWidth();
+	}
+
+    /**
+     * Get the image for a given attribute number. We use lazy initialisation here, i.e. the images are only
+     * loaded when they are requested.
+     * @param attNo The attribute number
+     * @return
+     */
+    public Picture getImage() {
+    	if (attNo&lt;0 || attNo&gt;=attributeNames.length) {
+    		return attributeImages[0];
+    	}
+    	if (attributeImages[attNo]==null) {
+    		attributeImages[attNo]=new Picture(IMAGEDIR+attributeNames[attNo]);
+    	}
+    	return attributeImages[attNo];
+    }
+
+	/**
+     * Encode an attribute name with the internal attribute number
+     * @param attributeName The attribute name (=filename) to encode
+     * @return The number of the attribute
+     */
+    private int attName2int(String attributeName) {
+    	int size=attributeNames.length;
+    	for (int i=1; i&lt;size; i++) {
+    		if (attributeName.equalsIgnoreCase(attributeNames[i])) return i;
+    	}
+    	return 0; // Error
+    }
+
+    private static void initErrorImg() {
+		if (attributeImages[0]==null) attributeImages[0]=new Picture(IMAGEDIR+&quot;error.gif&quot;);
+    }
+
+    { // Static initialisation of error image
+    	initErrorImg();
+    }
+
+
+}

Added: experiments/EVE/src/cachewolf/Attributes.java
===================================================================
--- experiments/EVE/src/cachewolf/Attributes.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/Attributes.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,123 @@
+package cachewolf;
+
+import cachewolf.utils.Extractor;
+import eve.fx.*;
+
+
+public class Attributes {
+	public final static int MAXATTRIBS=12;
+	/**
+	 * The number of attributes for this cache (=number of array elements in use in attribs)
+	 */
+	private int count=0;
+	/**
+	 * The attributes are represented as a byte array with each element encoding one attribute
+	 */
+	private Attribute attribs[]=new Attribute[MAXATTRIBS];
+
+	public long attributesYes;
+	public long attributesNo;
+
+	public Attributes() {
+	}
+
+	/**
+	 * Get the number of attributes in the list
+	 * @return number of attributes
+	 */public int getCount(){
+		return count;
+	}
+
+	/**
+	 * Clear the attributes list
+	 *
+	 */
+	 public void clear() {
+		count=0;
+		attributesYes=0;
+		attributesNo=0;
+	}
+
+    ////////////////////////////////////////////////
+    // Attribute set functions
+    ////////////////////////////////////////////////
+
+	public void xmlAttributesStart() {}
+	public void xmlAttributesEnd(String elem){
+		clear();
+		Extractor ex=new Extractor(elem,&quot;&lt;ATT&gt;&quot;,&quot;&lt;/ATT&gt;&quot;,0,true);
+		String dummy = ex.findNext();
+		while(ex.endOfSearch()==false){
+			add(dummy);
+			dummy = ex.findNext();
+		}
+	}
+
+	public void xmlAttributeStart(){}
+	public void xmlAttributeEnd(String elem){
+		add(elem);
+	}
+
+	/*
+	 * Prepare for attributes to be written to cache.xml file
+	 */
+	public String xmlAttributesWrite(){
+		StringBuffer sb=new StringBuffer(1000);
+		sb.append(&quot;&lt;ATTRIBUTES&gt;\n&quot;);
+		for (int i=0; i&lt;count; i++) {
+			sb.append(&quot;   &lt;ATT&gt;&quot;);
+			sb.append(attribs[i].getImageName());
+			sb.append(&quot;&lt;/ATT&gt;\n&quot;);
+		}
+		sb.append(&quot;&lt;/ATTRIBUTES&gt;\n&quot;);
+		return sb.toString();
+	}
+
+	/**
+	 * Add a new attributes
+	 * @param attributeName
+	 */
+	public void add(String attributeName){
+		if (count&lt;attribs.length) {
+			if ( !attributeName.equalsIgnoreCase( &quot;attribute-blank.gif&quot; ) ) {
+				Attribute attr = new Attribute(attributeName);
+				attribs[count++] = attr;
+				if (attributeName.endsWith(&quot;-yes.gif&quot;))
+					attributesYes |= (1l &lt;&lt; ( (long)(Math.ceil(attr.getAttrNr() / 2.0) - 1.0) ) );
+				else
+					attributesNo |= (1l &lt;&lt; ( (long)(Math.ceil(attr.getAttrNr() / 2.0) - 1.0) ) );
+			}
+		}
+    }
+
+	/**
+	 * Get the name of the i'th attribute in the list
+	 * @param i The number of the attribute to retrieve
+	 * @return The name of the attribute (e.g. horses-no.gif)
+	 */
+	public String getName(int i) {
+		if (i&gt;=0 &amp;&amp; i&lt;count) return attribs[i].getImageName();
+		return &quot;error.gif&quot;;
+	}
+
+	/**
+	 * Get the image corresponding to an attribute
+	 * @param i The number of the attribute for which the image is to be retrieved
+	 * @return The Picture of the attribute
+	 */
+	public Picture getImage(int i) {
+		if (i&gt;=0 &amp;&amp; i&lt;count) return attribs[i].getImage();
+		return new Attribute().getImage();
+	}
+
+	/**
+	 * Get the infotext for an attribute
+	 * @param i The number of the attribute for which the infotext is to be retrieved
+	 * @return The infotext of the attribute
+	 */
+	public String getInfo(int i) {
+		if (i&gt;=0 &amp;&amp; i&lt;count) return attribs[i].getInfo();
+		return &quot;No info&quot;;
+	}
+}
+

Added: experiments/EVE/src/cachewolf/AttributesSelector.java
===================================================================
--- experiments/EVE/src/cachewolf/AttributesSelector.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/AttributesSelector.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,135 @@
+package cachewolf;
+
+import eve.fx.*;
+import eve.sys.*;
+import eve.ui.*;
+import eve.ui.game.*;
+import eve.ui.event.*;
+
+public class AttributesSelector extends Panel {
+	protected static final int TILESIZE=22; // Here we always use the small icons thus tilesize=22
+	public long selectionMaskYes = 0;
+	public long selectionMaskNo = 0;
+	protected Label mInfo;
+
+	public AttributesSelector() {
+		//Rect r = new Rect(0,0,TILESIZE * ICONS_PER_ROW,TILESIZE * ICONROWS); // As on GC: 6 wide, 2 high
+		iap.virtualSize = new Rect(0,0,200,200);
+		iap.setPreferredSize(170, 155);
+		addLast(iap,CellConstants.STRETCH,FILL);
+		addLast(mInfo=new Label(&quot;&quot;),HSTRETCH,HFILL);
+	}
+
+	public void setSelectionMasks(long yes, long no) {
+		selectionMaskYes = yes;
+		selectionMaskNo = no;
+		showAttributePalette();
+	}
+
+	protected class AttAniImage extends AniImage {
+		public String info;
+		public String attrName;
+		public String value;
+		public int attrNr;
+		public long bitMask;
+		AttAniImage (ImageData img) {
+			super(img);
+		}
+		AttAniImage (AttAniImage cp, String val) {
+			//super(null);
+			PixelBuffer rawImg=new PixelBuffer(Attribute.getImageDir() + cp.attrName + val );
+			change (rawImg.getHeight()!=20 ? rawImg.scale(20,20) : rawImg  );
+			value = val;
+			info = MyLocale.getMsg( value.equals(&quot;-no.gif&quot;) ? (2500+cp.attrNr-1) : 2500+cp.attrNr,&quot;No attribute info found&quot;);
+			attrName = cp.attrName;
+			location = cp.location;
+			attrNr = cp.attrNr;
+			bitMask = cp.bitMask;
+		}
+	}
+	
+	protected class AttInteractivePanel extends InteractivePanel {
+				public boolean imageMovedOn(AniImage which) {
+			if (!((AttAniImage)which).info.startsWith(&quot;*&quot;)) { // If text starts with * we have no explanation yet
+				mInfo.setText(((AttAniImage)which).info);
+				mInfo.repaintNow();
+			}
+			return true;
+		}
+		public boolean imageMovedOff(AniImage which) {
+			mInfo.setText(&quot;&quot;);
+			mInfo.repaintNow();
+			return true;
+		}
+		public boolean imagePressed(AniImage which, Point pos) {
+			if (which != null) {
+				String value = ((AttAniImage)which).value;
+				long bit = ((AttAniImage)which).bitMask;
+				if (value.equals(&quot;-non.gif&quot;)) {
+					selectionMaskYes |= bit;
+					selectionMaskNo  &amp;= ~bit;
+					value=&quot;-yes.gif&quot;;
+				} else if (value.equals(&quot;-yes.gif&quot;)) {
+					selectionMaskYes &amp;= ~bit;
+					selectionMaskNo  |= bit;
+					value=&quot;-no.gif&quot;;
+				} else {
+					selectionMaskYes &amp;= ~bit;
+					selectionMaskNo  &amp;= ~bit;
+					value=&quot;-non.gif&quot;;
+				}
+				AttAniImage tmpImg = new AttAniImage( (AttAniImage)which, value );
+				removeImage(which);
+				addImage(tmpImg);
+				//System.out.println (&quot;AniImage pressed: &quot; + ((attAniImage)which).info);
+				refresh();
+				notifyDataChange(new DataChangeEvent(DataChangeEvent.DATA_CHANGED,this));
+			}
+			return true;
+		}
+	}
+	protected InteractivePanel iap=new AttInteractivePanel();
+
+	public void showAttributePalette() {
+		iap.images.clear();
+		int width = 170;
+		int x = 2; int y = 2;
+		long bitMask = 0;
+		String attrName;
+		String value;
+		for (int i=0; i &lt; Attribute.attributeNames.length; ++i) {
+			if (Attribute.attributeNames[i].endsWith(&quot;-yes.gif&quot;)) {
+				attrName = Attribute.attributeNames[i].substring(0,Attribute.attributeNames[i].length()-8);
+				bitMask = ( 1l &lt;&lt; ( (long)(java.lang.Math.ceil(i / 2.0) - 1.0) ) );
+				if ( (selectionMaskYes &amp; bitMask) != 0 )
+					value = &quot;-yes.gif&quot;;
+				else if ( (selectionMaskNo &amp; bitMask) != 0 )
+					value = &quot;-no.gif&quot;;
+				else
+					value = &quot;-non.gif&quot;;
+				PixelBuffer rawImg=new PixelBuffer(Attribute.getImageDir()+attrName+value);	
+				AttAniImage img=new AttAniImage((rawImg.getHeight()!=20 ? rawImg.scale(20,20) : rawImg ));
+				img.info=MyLocale.getMsg(2500+i,&quot;No attribute info found&quot;);
+				img.value=value;
+				img.attrName=attrName;
+				img.attrNr = i;
+				img.bitMask = bitMask;
+
+				if (x+TILESIZE &gt; width) {
+					x = 2;
+					y += TILESIZE;
+				}
+				img.location=new Rect(x,y,TILESIZE,TILESIZE);
+				//System.out.println(&quot;img.location=new Rect(&quot;+x+&quot;,&quot;+y+&quot;,&quot;+TILESIZE+&quot;,&quot;+TILESIZE+&quot;);&quot;);
+				iap.addImage(img);
+				x += TILESIZE;
+			}
+		}
+		iap.repaintNow();
+	}
+	
+/*	public void resizeTo(int width, int height) {
+		super.resizeTo(width,height);
+	}
+*/	
+}

Added: experiments/EVE/src/cachewolf/AttributesViewer.java
===================================================================
--- experiments/EVE/src/cachewolf/AttributesViewer.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/AttributesViewer.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,62 @@
+package cachewolf;
+
+import eve.fx.*;
+import eve.ui.*;
+import eve.ui.game.*;
+
+public class AttributesViewer extends Panel {
+	protected static final int TILESIZE=Attribute.getImageWidth()+2;
+	protected final static int ICONS_PER_ROW=MyLocale.getScreenWidth()/TILESIZE&lt;Attributes.MAXATTRIBS ? MyLocale.getScreenWidth()/TILESIZE : Attributes.MAXATTRIBS;
+	protected final static int ICONROWS=(Attributes.MAXATTRIBS+ICONS_PER_ROW-1)/ICONS_PER_ROW;
+	protected Label mInfo;
+
+	protected class AttInteractivePanel extends InteractivePanel {
+		public boolean imageMovedOn(AniImage which) {
+			if (!((AttAniImage)which).info.startsWith(&quot;*&quot;)) { // If text starts with * we have no explanation yet
+				mInfo.setText(((AttAniImage)which).info);
+				mInfo.repaintNow();
+			}
+			return true;
+		}
+		public boolean imageMovedOff(AniImage which) {
+			mInfo.setText(&quot;&quot;);
+			mInfo.repaintNow();
+			return true;
+		}
+	}
+	
+	protected class AttAniImage extends AniImage {
+		public String info;
+		AttAniImage (Picture img) {
+			super(img);
+		}
+	}
+	
+	public AttributesViewer (){
+		Rect r = new Rect(0,0,TILESIZE * ICONS_PER_ROW,TILESIZE * ICONROWS); // As on GC: 6 wide, 2 high
+		iap.virtualSize = r;
+		iap.setFixedSize(TILESIZE * ICONS_PER_ROW,TILESIZE * ICONROWS);
+		addLast(iap,CellConstants.HSTRETCH,CellConstants.FILL);
+		addLast(mInfo=new Label(&quot;&quot;),HSTRETCH,HFILL);
+	}
+	protected InteractivePanel iap=new AttInteractivePanel();
+	
+	public void showImages(Attributes att) {
+		iap.images.clear();
+		for (int i=0; i&lt;att.getCount(); i++) {
+			AttAniImage img=new AttAniImage( att.getImage(i));
+			img.info=att.getInfo(i);
+			img.location=new Rect((i % ICONS_PER_ROW)*TILESIZE,(i / ICONS_PER_ROW)*TILESIZE,TILESIZE,TILESIZE);
+			iap.addImage(img);			
+		}
+		iap.repaintNow();
+	}
+	
+	public void clear() {
+		iap.images.clear();
+	}
+/*	public void resizeTo(int width, int height) {
+		super.resizeTo(width,height);
+	}
+*/	
+}

Added: experiments/EVE/src/cachewolf/CWPoint.java
===================================================================
--- experiments/EVE/src/cachewolf/CWPoint.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/CWPoint.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,684 @@
+
+package cachewolf;
+
+
+import eve.sys.Convert;
+
+import cachewolf.navi.GkPoint;
+import cachewolf.navi.TrackPoint;
+import cachewolf.navi.TransformCoordinates;
+import cachewolf.utils.Common;
+import cachewolf.utils.ParseLatLon;
+import cachewolf.utils.STRreplace;
+import cachewolf.navi.GeodeticCalculator;
+
+import com.bbn.openmap.proj.coords.*;
+import com.bbn.openmap.proj.*;
+import com.bbn.openmap.*;
+import com.stevesoft.eve_pat.Regex;
+
+
+/**
+ * Class for getting an setting coords in different formats
+ * and for doing projection and calculation of bearing and
+ * distance
+ *
+ */
+public class CWPoint extends TrackPoint{
+	public MGRSPoint utm = new MGRSPoint();
+	public boolean utmValid = false;
+
+	public static final int DD = 0;
+	public static final int DMM = 1;
+	public static final int DMS = 2;
+	public static final int UTM = 3;
+	public static final int GK = 4;
+	public static final int CW = 5;
+	public static final int REGEX = 6;
+	public static final int LAT_LON = 7;
+	public static final int LON_LAT = 8;
+	
+	/** Degrees/Radians conversion constant. */
+	static private final double PiOver180 = Math.PI / 180.0;	
+
+	/**
+	 * Create CWPoint by using lat and lon 
+	 * @param lat Latitude as decimal
+	 * @param lon Longitude as decimal
+	 */
+	public CWPoint(double lat, double lon) {
+		super(lat, lon);
+		this.utmValid = false;
+	}
+
+	/**
+	 * Creates an empty CWPoint, use set methods for filling 
+	 */
+	
+	public CWPoint() {
+		super(-361,-361); // construct with unvalid == unset lat/lon 
+		this.utmValid = false;
+		
+	}
+
+	/**
+	 * Create CWPoint by using a LatLonPoint 
+	 * @param CWPoint LatLonPoint
+	 */
+
+	public CWPoint(LatLonPoint llPoint){
+		super (llPoint.getLatitude(), llPoint.getLongitude());
+		this.utmValid = false;
+	}
+
+	/**
+	 * Create CWPoint by using a CWPoint 
+	 * @param CWPoint LatLonPoint
+	 */
+
+	public CWPoint(TrackPoint cwPoint){
+		super(cwPoint.latDec, cwPoint.lonDec);
+		this.utmValid = false;
+	}
+
+	
+	/**
+	 * Create CWPoint by using coordinates in &quot;CacheWolf&quot; format 
+	 * @param coord  String of type N 49&#176; 33.167 E 011&#176; 21.608
+	 * @param format only CWPoint.CW or CWPoint.REGEX is supported
+	 */
+	public CWPoint(String coord, int format) {
+		super(-361,-361);
+		set(coord, format);
+	}
+
+		
+	/**
+	 * Create CWPoint 
+	 * @param strLatNS &quot;N&quot; or &quot;S&quot;
+	 * @param strLatDeg	Degrees of Latitude
+	 * @param strLatMin	Minutes of Latitude
+	 * @param strLatSec	Seconds of Latitude
+	 * @param strLonEW	&quot;E&quot; or &quot;W&quot;
+	 * @param strLonDeg	Degrees of Longitude
+	 * @param strLonMin	Minutes of Longitude
+	 * @param strLonSec	Seconds of Longitude
+	 * @param format	Format: DD, DMM, DMS, CW, UTM
+	 */
+	//TODO Remove ? Only used in OCXMLImporter and TablePanel when reading preferences
+	public CWPoint(String strLatNS, String strLatDeg, String strLatMin, String strLatSec,
+			     String strLonEW, String strLonDeg, String strLonMin, String strLonSec,
+			     int format) {
+		set(strLatNS, strLatDeg, strLatMin, strLatSec,
+			strLonEW, strLonDeg, strLonMin, strLonSec,
+			format);	
+	}
+	
+	
+	/**
+	 * set lat and lon by parsing coordinates with Regex 
+	 * @param coord  String like N 49&#176; 33.167 E 011&#176; 21.608
+	 */
+	public CWPoint(String coord) {
+		set(coord);
+	}
+	/*public boolean equals (CWPoint p) {
+		return super.equals(p);
+	}*/
+
+	/**
+	 * Set lat and lon 
+	 * @param lat Latitude as decimal
+	 * @param lon Longitude as decimal
+	 */
+	public void set (double lat, double lon){
+		this.latDec = lat;
+		this.lonDec = lon;
+		this.utmValid = false;
+	}
+
+	/**
+	 * Set CWPoint by using a LatLonPoint 
+	 * @param CWPoint LatLonPoint
+	 */
+
+	public void set (LatLonPoint llPoint){
+		this.latDec = llPoint.getLatitude();
+		this.lonDec = llPoint.getLongitude();
+		this.utmValid = false;
+	}
+
+	/**
+	 * Set CWPoint by using a CWPoint 
+	 * @param CWPoint cwPointt
+	 */
+
+	public void set (TrackPoint cwPoint){
+		this.latDec = cwPoint.latDec;
+		this.lonDec = cwPoint.lonDec;
+		this.utmValid = false;
+	}
+
+	
+	/**
+	 * set lat and lon by using coordinates in &quot;CacheWolf&quot; format 
+	 * @param coord  String of type N 49&#176; 33.167 E 011&#176; 21.608
+	 * @param format only CWPoint.CW is supported
+	 */
+	public void set (String coord, int format) {
+
+		if (coord!=null) {
+			switch (format){
+			case CW: 	ParseLatLon pll = new ParseLatLon (coord);
+				try {
+					pll.parse();
+					this.latDec = pll.lat2;
+					this.lonDec = pll.lon2;
+				} catch (Exception e) {
+					this.latDec = 91;
+					this.lonDec = 361;
+					break;
+				}
+			case REGEX: set(coord);
+			break;
+
+			default: 	this.latDec = 91; this.lonDec = 361;
+			}
+		} else { 
+			this.latDec = 91; this.lonDec = 361;
+		}
+		this.utmValid = false;
+	}
+
+
+
+	/**
+	 * set lat and lon by parsing coordinates with regular expression 
+	 * @param coord  String of type N 49&#176; 33.167 E 011&#176; 21.608
+	 * 				 	or 			-12.3456 23.4567
+	 * 					or			32U 2345234 8902345
+	 */
+	public void set (String coord) {
+	//replace non-breaking-spaces by normal spaces
+	coord = coord.replace((char)0xA0, ' ');
+		/*		(?: 
+					([NSns])\s*([0-9]{1,2})[\s&#176;]+([0-9]{1,2})(?:\s+([0-9]{1,2}))?[,.]([0-9]{1,8})\s* 
+					([EWewOo])\s*([0-9]{1,3})[\s&#176;]+([0-9]{1,2})(?:\s+([0-9]{1,2}))?[,.]([0-9]{1,8}) 
+					)|(?: 
+					  ([+-NnSs]?[0-9]{1,2})[,.]([0-9]{1,8})(?:(?=\+)|(?=-)|\s+|\s*&#176;\s*)([+-WwEeOo]?[0-9]{1,3})[,.]([0-9]{1,8})\s*[&#176;]? 
+					)|(?: 
+					   ([0-9]{1,2}[C-HJ-PQ-X])\s*[EeOo]?\s*([0-9]{1,7})\s+[Nn]?\s*([0-9]{1,7}) 
+					)
+		*/		
+				Regex rex=new Regex(&quot;(?:&quot; +
+									&quot;([NSns])\\s*([0-9]{1,2})(?:[&#176;\uC2B0]\\s*|\\s+[&#176;\uC2B0]?\\s*)([0-9]{1,2})(?:(?:['&#146;]\\s*|\\s+['&#146;]?\\s*)([0-9]{1,2}))?(?:[,.]([0-9]{1,8}))?\\s*['&#146;\&quot;]?\\s*&quot; +
+									&quot;[,./_;+:-]*\\s*&quot; + // allow N xx xx.xxx / E xxx xx.xxx
+									&quot;([EWewOo])\\s*([0-9]{1,3})(?:[&#176;\uC2B0]\\s*|\\s+[&#176;\uC2B0]?\\s*)([0-9]{1,2})(?:(?:['&#146;]\\s*|\\s+['&#146;]?\\s*)([0-9]{1,2}))?(?:[,.]([0-9]{1,8}))?\\s*['&#146;\&quot;]?&quot; +
+									&quot;)|(?:&quot; +
+									&quot;(?:([NnSs])\\s*(?![+-]))?&quot;   +     &quot;([+-]?[0-9]{1,2})[,.]([0-9]{1,8})(?:(?=[+-EeWwOo])|\\s+|\\s*[&#176;\uC2B0]\\s*)&quot; +
+								  	&quot;(?:([EeWwOo])\\s*(?![+-]))?&quot;    +     &quot;([+-]?[0-9]{1,3})[,.]([0-9]{1,8})\\s*[&#176;\uC2B0]?&quot; +
+									&quot;)|(?:&quot; +
+									&quot;([0-9]{1,2}[C-HJ-PQ-X])\\s*[EeOo]?\\s*([0-9]{1,7})\\s+[Nn]?\\s*([0-9]{1,7})&quot; +
+									&quot;)|(?:&quot; +
+									&quot;[Rr]:?\\s*([+-]?[0-9]{1,7})\\s+[Hh]:?\\s*([+-]?[0-9]{1,7})&quot; +
+									&quot;)&quot;); 
+				this.latDec = -91; // return unset / unvalid values if parsing was not successfull
+				this.lonDec = -361;
+				rex.search(coord);
+				if (rex.stringMatched(1)!= null) { // Std format
+					// Handle &quot;E&quot; oder &quot;O&quot; for longitiude
+					String strEW = rex.stringMatched(6).toUpperCase();
+					if (!strEW.equals(&quot;W&quot;)) strEW = &quot;E&quot;;
+					if (rex.stringMatched(4)!=null){ //Seconds available
+						set(rex.stringMatched(1).toUpperCase(), rex.stringMatched(2),rex.stringMatched(3),rex.stringMatched(4) + &quot;.&quot; + rex.stringMatched(5),
+							strEW, rex.stringMatched(7),rex.stringMatched(8),rex.stringMatched(9) + &quot;.&quot; + rex.stringMatched(10),DMS);
+					} else {
+						set(rex.stringMatched(1).toUpperCase(), rex.stringMatched(2),rex.stringMatched(3)+ &quot;.&quot; + rex.stringMatched(5), null,
+							strEW, rex.stringMatched(7),rex.stringMatched(8)+ &quot;.&quot; + rex.stringMatched(10), null, DMM);
+					}
+						
+				} else if (rex.stringMatched(12) != null){ // Decimal
+					
+					set(rex.stringMatched(11)==null?&quot;N&quot;:rex.stringMatched(11).toUpperCase(), rex.stringMatched(12)+ &quot;.&quot; + rex.stringMatched(13), null, null,
+						rex.stringMatched(14)==null?&quot;E&quot;:rex.stringMatched(14).toUpperCase(), rex.stringMatched(15)+ &quot;.&quot; + rex.stringMatched(16), null, null, DD);
+				} else if (rex.stringMatched(17) != null){ // UTM
+					set(rex.stringMatched(17),rex.stringMatched(19),rex.stringMatched(18)); //parse sequence is E N, but set needs N E
+				} else if (rex.stringMatched(20) != null){ // GK
+					set(rex.stringMatched(20),rex.stringMatched(21));
+				}
+				//else Vm.debug(&quot;CWPoint: &quot;+coord+&quot; could not be parsed&quot;);
+			}	/**
+	 * set lat and lon 
+	 * @param strLatNS &quot;N&quot; or &quot;S&quot;
+	 * @param strLatDeg	Degrees of Latitude
+	 * @param strLatMin	Minutes of Latitude
+	 * @param strLatSec	Seconds of Latitude
+	 * @param strLonEW	&quot;E&quot; or &quot;W&quot;
+	 * @param strLonDeg	Degrees of Longitude
+	 * @param strLonMin	Minutes of Longitude
+	 * @param strLonSec	Seconds of Longitude
+	 * @param format	Format: DD, DMM, DMS 
+	 */
+	public void set(String strLatNS, String strLatDeg, String strLatMin, String strLatSec,
+		     String strLonEW, String strLonDeg, String strLonMin, String strLonSec,
+		     int format) {
+		switch (format){
+			case DD: 	this.latDec = Common.parseDouble(strLatDeg);
+						this.lonDec = Common.parseDouble(strLonDeg);
+						break;
+			case DMM: 	this.latDec = Math.abs(Common.parseDouble(strLatDeg)) + Math.abs((Common.parseDouble(strLatMin)/60));
+						this.lonDec = Math.abs(Common.parseDouble(strLonDeg)) + Math.abs((Common.parseDouble(strLonMin)/60));
+						break;
+			case DMS: 	this.latDec = Math.abs(Common.parseDouble(strLatDeg)) + Math.abs((Common.parseDouble(strLatMin)/60))+Math.abs((Common.parseDouble(strLatSec)/3600));
+						this.lonDec = Math.abs(Common.parseDouble(strLonDeg)) + Math.abs((Common.parseDouble(strLonMin)/60))+Math.abs((Common.parseDouble(strLonSec)/3600));
+						break;
+			
+			default: 	this.latDec = 91; this.lonDec = 361;
+		}
+		//makeValid();
+		// To avoid changing sign twice if we have something like W -34.2345
+		if (strLatNS.trim().equals(&quot;S&quot;) &amp;&amp; this.latDec&gt;0) this.latDec *= -1;
+		if (strLonEW.trim().equals(&quot;W&quot;) &amp;&amp; this.lonDec&gt;0) this.lonDec *= -1;
+		this.utmValid = false;
+	}
+
+	
+	/**
+	 * shift the point
+	 * @param meters positiv to north (east), negativ to south (west)
+	 * @param direction 0 north-south, 1 east-west
+	 */
+	public void shift(double meters, int direction) {
+		double meters2deglon = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		switch (direction) { // TODO use ellipsoid distance calculations for better accuracy
+			case 0: latDec += meters *  meters2deglon; return;
+			case 1: lonDec += meters * (meters2deglon / Math.cos(latDec / 180 * Math.PI));return;
+		}
+	}
+
+	/**
+	 * mark the Point as invalid
+	 *
+	 */
+	public void makeInvalid() {
+		latDec = -361;
+		lonDec = 91;
+	}
+
+	/**
+	 * set lat and lon by using UTM coordinates  
+	 * @param strZone UTM-zone, e.g. 32U
+	 * @param strNorthing Northing component
+	 * @param strEasting  Easting component
+	 */
+	public void set ( String strZone, String strNorthing, String strEasting){
+		LatLonPoint ll =  new LatLonPoint();
+		
+		utm.zone_letter = strZone.charAt(strZone.length()-1);
+		utm.zone_number = Convert.toInt(strZone.substring(0,strZone.length()-1));
+		utm.northing = (float) Common.parseDouble(strNorthing);
+		utm.easting = (float) Common.parseDouble(strEasting);
+		
+		ll = utm.toLatLonPoint(); // returns null if unvalit UTM-coordinates
+		if (ll != null) { 
+			this.utmValid = true;
+			this.latDec = ll.getLatitude();
+			this.lonDec = ll.getLongitude();
+		} else {this.latDec = 91; this.lonDec = 361; }
+	}
+	
+	/**
+	 * set lat and lon by using GK coordinates  
+	 * @param strEasting  Easting component
+	 * @param strNorthing Northing component
+	 */
+	public void set ( String strEasting, String strNorthing ){
+		GkPoint gk = new GkPoint(Common.parseDouble(strEasting), Common.parseDouble(strNorthing), GkPoint.GERMAN_GK);
+		
+		this. latDec = TransformCoordinates.germanGkToWgs84(gk).latDec;
+		this. lonDec = TransformCoordinates.germanGkToWgs84(gk).lonDec;
+		this.utmValid = false;
+	}
+
+	/**
+	 * Get degrees of latitude in different formats
+	 * @param format	Format: DD, DMM, DMS,
+	 */
+	public String getLatDeg(int format) {
+		switch (format) {
+		case DD: 	return MyLocale.formatDouble(this.latDec, &quot;00.00000&quot;).replace(',','.');
+		case CW:
+		case DMM:
+		case DMS:	return getDMS(latDec,0,format);
+		default: return &quot;&quot;;
+		}
+	}
+	
+	/**
+	 * Get degrees of longitude in different formats
+	 * @param format	Format: DD, DMM, DMS,
+	 */
+	public String getLonDeg(int format) {
+		switch (format) {
+		case DD: 	return MyLocale.formatDouble(this.lonDec, &quot;000.00000&quot;).replace(',','.');
+		case CW:
+		case DMM:
+		case DMS:	return (((lonDec&lt;100.0) &amp;&amp; (lonDec&gt;-100.0))?&quot;0&quot;:&quot;&quot;)+getDMS(lonDec,0,format);
+		default: 	return &quot;&quot;; 
+		}
+	}
+
+	/**
+	 * Get minutes of latitude in different formats
+	 * @param format	Format: DD, DMM, DMS,
+	 */
+	public String getLatMin(int format) {
+		return getDMS(latDec,1,format);
+	}
+
+	/**
+	 * Get minutes of longitude in different formats
+	 * @param format	Format: DD, DMM, DMS,
+	 */
+	public String getLonMin(int format) {
+		return getDMS(lonDec,1,format);	
+	}
+
+	/**
+	 * Get seconds of latitude in different formats
+	 * @param format	Format: DD, DMM, DMS,
+	 */
+	public String getLatSec(int format) {
+		return getDMS(latDec,2,format);
+	}
+
+	/**
+	 * Get seconds of longitude in different formats
+	 * @param format	Format: DD, DMM, DMS,
+	 */
+	public String getLonSec(int format) {
+		return getDMS(lonDec,2,format);
+	}
+
+	/**
+	 * Returns the degrees or minutes or seconds (depending on parameter what) formatted as a string
+	 * To determine the degrees, we need to calculate the minutes (and seconds) just in case rounding errors
+	 * propagate. Equally we need to know the seconds to determine the minutes value.
+	 * @param deg The coordinate in degrees
+	 * @param what 0=deg, 1=min, 2=sec
+	 * @param format DD,CW,DMM,DMS
+	 * @return 
+	 */
+	private String getDMS(double deg, int what, int format) {
+		deg=Math.abs(deg);
+		long iDeg=(int) deg;
+		double tmpMin, tmpSec;
+		tmpMin= (deg - iDeg)*60.0;
+		switch(format) {
+			case DD: return &quot;&quot;;
+			case CW:
+			case DMM: 	
+			    // Need to check if minutes would round up to 60
+				if (java.lang.Math.round(tmpMin*1000.0) == 60000) { tmpMin =0;  iDeg++; }
+				switch (what) {
+					case 0: return MyLocale.formatLong(iDeg, &quot;00&quot;);
+					case 1: return MyLocale.formatDouble(tmpMin, &quot;00.000&quot;).replace(',','.');
+					case 2: return &quot;&quot;;
+				}
+			case DMS:
+				tmpSec= (tmpMin - (int)tmpMin) * 60.0;
+				tmpMin=(int) tmpMin;
+				// Check if seconds round up to 60 
+				if (java.lang.Math.round(tmpSec*10.0) == 600) { tmpSec = 0; tmpMin=tmpMin+1.0; }
+				// Check if minutes round up to 60
+				if (java.lang.Math.round(tmpMin) == 60) { tmpMin = 0; iDeg++; }
+				switch (what) {
+					case 0: return MyLocale.formatLong(iDeg, &quot;00&quot;);
+					case 1: return MyLocale.formatDouble(tmpMin, &quot;00&quot;);
+					case 2: return MyLocale.formatDouble(tmpSec, &quot;00.0&quot;).replace(',','.');
+				}
+		}
+		return &quot;&quot;; // Dummy to keep compiler happy
+	}
+	
+	/**
+	 * Get &quot;N&quot; or &quot;S&quot; letter for latitude
+	 */
+	public String getNSLetter() {
+		return 	this.latDec &lt; 0?&quot;S&quot;:&quot;N&quot;;
+	}
+
+	/**
+	 * Get &quot;E&quot; or &quot;W&quot; letter for latitude
+	 */
+	public String getEWLetter() {
+		return  this.lonDec &lt; 0?&quot;W&quot;:&quot;E&quot;;
+	}
+
+	/**
+	 * Get UTMzonenumber, e.g. 32U
+	 */
+	public String getUTMZone(){
+		checkUTMvalid();
+		return Convert.toString(utm.zone_number) + utm.zone_letter;
+	}
+	
+	/**
+	 * Get UTM northing
+	 */
+	public String getUTMNorthing(){
+		checkUTMvalid();
+		return Convert.toString((long)utm.northing).replace(',','.');
+	}
+
+	/**
+	 * Get UTM easting
+	 */
+	public String getUTMEasting() {
+		checkUTMvalid();
+		return Convert.toString((long)utm.easting).replace(',','.');
+	}
+	
+	/**
+	 * Get GK northing
+	 */
+	public String getGKNorthing(int decimalplaces){
+		double gkNorthing = TransformCoordinates.wgs84ToGermanGk(this).getNorthing();
+		return Common.doubleToString(gkNorthing,decimalplaces);
+	}
+
+	/**
+	 * Get GK easting
+	 */
+	public String getGKEasting(int decimalplaces) {
+		double gkEasting = TransformCoordinates.wgs84ToGermanGk(this).getGkEasting(GkPoint.GERMAN_GK);
+		return Common.doubleToString(gkEasting,decimalplaces);
+	}
+	
+	public String getGermanGkCoordinates() {
+		return TransformCoordinates.wgs84ToGermanGk(this).toString(0, &quot;R:&quot;, &quot; H:&quot;,GkPoint.GERMAN_GK);
+	}
+
+	public String getGermanGkCoordinates(int decimalplaces, String pref, String seperator, int region) {
+		return TransformCoordinates.wgs84ToGermanGk(this).toString(decimalplaces, pref, seperator, region);
+	}
+	
+	/**
+	 * Method to calculate a projected waypoint
+	 * @param degrees Bearing
+	 * @param distance Distance in km
+	 * @return projected waypoint
+	 */
+	public CWPoint project(double degrees, double distance){
+		return new CWPoint( GeodeticCalculator.calculateEndingGlobalCoordinates(TransformCoordinates.WGS84, this, degrees, distance * 1000.0) );
+	}
+
+	/**
+	 * Method to calculate the bearing of a waypoint
+	 * @param dest waypoint
+	 * @return  bearing of waypoint 361 if this or dest is not valid
+	 */	
+	public double getBearing(CWPoint dest){
+		if (!this.isValid() || dest == null || !dest.isValid()) return 361;
+		
+		return GeodeticCalculator.calculateBearing(TransformCoordinates.WGS84 , this, dest);
+	}
+	
+	/**
+	 *	Method to identify one of 16 compass directions based
+	 * 	on the bearing. 
+	 * @param degrees bearing
+	 * @return  direction
+	 */	
+	public static String getDirection(double degrees){
+		return getDirectionFromBearing(degrees);
+	}
+	
+	/**
+	 *	Method to identify one of 16 compass directions based
+	 * 	on the bearing of the destination waypoint
+	 * @param dest waypoint
+	 * @return  direction
+	 */	
+	public String getDirection(CWPoint dest){
+		return getDirectionFromBearing(getBearing(dest));
+	}
+
+
+	/**
+	 * Method to calculate the distance to a waypoint
+	 * @param dest waypoint
+	 * @return  distance to waypoint in KM
+	 */	
+	public double getDistance (CWPoint dest){
+		return GeodeticCalculator.calculateDistance(TransformCoordinates.WGS84 , this, dest) / 1000.0;
+	}
+
+	/**
+	 * Method to calculate the distance to a waypoint
+	 * @param dest lat, lon
+	 * @return  distance to waypoint in KM
+	 */	
+	public double getDistance (double latDecD, double lonDecD){
+		return getDistance( new CWPoint(latDecD, lonDecD));
+	}
+
+	/**
+	 * Method to calculate the distance to a waypoint
+	 * @param dest lat, lon
+	 * @return  distance to waypoint in Rad
+	 */	
+	public double getDistanceRad (double latDecD, double lonDecD){
+		double phi1 = this.latDec * PiOver180;
+		double lambda0 = this.lonDec * PiOver180;
+		double phi = latDecD * PiOver180;
+		double lambda = lonDecD * PiOver180;
+		double pdiff =  Math.sin(((phi - phi1) / 2.0));
+		double ldiff =  Math.sin((lambda - lambda0) / 2.0);
+		double rval =  Math.sqrt((pdiff * pdiff) +  Math.cos(phi1) *  Math.cos(phi) * (ldiff * ldiff));
+
+		return 2.0 *  Math.asin(rval);		
+	}
+	
+	public double getDistanceRad (CWPoint ll) {
+		return getDistance(ll.latDec, ll.lonDec);
+	}
+
+	
+
+	/**
+	 * Returns the string reprenstation of the CWPoint
+	 * Format ist CacheWolf (N 49&#176; 33.167 E 011&#176; 21.608), which can be used 
+	 * with parseLatLon
+	 * @return  string like N 49&#176; 33.167 E 011&#176; 21.608 
+	 */	
+	public String toString(){
+		return toString(CW);
+		
+	}
+	/**
+	 * Returns the string representation of the CWPoint
+	 * Formats DD, DMM (same as CW), DMS, UTM  
+	 * @return  string representation of CWPoint 
+	 */	
+	public String toString(int format){
+		if (!isValid()) return MyLocale.getMsg(999,&quot;not set&quot;);
+		switch (format) {
+		case DD:	return getNSLetter() + &quot; &quot; + STRreplace.replace(getLatDeg(format),&quot;-&quot;,&quot;&quot;) + &quot;&#176; &quot;
+						+  getEWLetter() + &quot; &quot; + STRreplace.replace(getLonDeg(format),&quot;-&quot;,&quot;&quot;)+ &quot;&#176;&quot;;
+		case CW:	format = DMM;	
+					return getNSLetter() + &quot; &quot; + getLatDeg(format) + &quot;&#176; &quot; + getLatMin(format) + &quot; &quot;
+						+  getEWLetter() + &quot; &quot; + getLonDeg(format) + &quot;&#176; &quot; + getLonMin(format);
+		case DMM:	return getNSLetter() + &quot; &quot; + getLatDeg(format) + &quot;&#176; &quot; + getLatMin(format) + &quot; &quot;
+						+  getEWLetter() + &quot; &quot; + getLonDeg(format) + &quot;&#176; &quot; + getLonMin(format);
+		case DMS:	return getNSLetter() + &quot; &quot; + getLatDeg(format) + &quot;&#176; &quot; + getLatMin(format) + &quot;\' &quot; + getLatSec(format) + &quot;\&quot; &quot; 
+						+  getEWLetter() + &quot; &quot; + getLonDeg(format) + &quot;&#176; &quot; + getLonMin(format) + &quot;\' &quot; + getLonSec(format) + &quot;\&quot;&quot;;
+		case UTM:	return getUTMZone()  + &quot; E &quot; + getUTMEasting()+ &quot; N &quot; + getUTMNorthing();
+		case LON_LAT:
+			return Common.doubleToString(lonDec, 8) +  &quot;,&quot; + Common.doubleToString(latDec, 8);
+		case LAT_LON:
+			return Common.doubleToString(latDec, 8) +  &quot;,&quot; + Common.doubleToString(lonDec, 8);
+		case GK:
+			return getGermanGkCoordinates();
+		default: return &quot;Unknown Format: &quot; + format;
+
+		}
+
+	}
+	
+	/**
+	 * Checks, if the data of utm is valid, if not, utm ist calculated
+	 */	
+	private void checkUTMvalid() {
+		if (this.utmValid) return;
+		this.utm = MGRSPoint.LLtoMGRS(new LatLonPoint(this.latDec, this.lonDec));
+		this.utmValid = true;
+	}
+	
+	/**
+	*	Method to identify one of 16 compass directions based
+	* 	on the bearing.
+	*/
+	private static String getDirectionFromBearing(double wert){
+		//System.out.println(wert);
+		String strBear = new String();
+		double stVal = -11.25;
+		if(wert &gt;= stVal) strBear = &quot;N&quot;;
+		stVal += 22.5;
+		if(wert &gt;= stVal) strBear = &quot;NNE&quot;;
+		stVal += 22.5;
+		if(wert &gt;= stVal) strBear = &quot;NE&quot;;
+		stVal += 22.5;
+		if(wert &gt;= stVal) strBear = &quot;ENE&quot;;
+		stVal += 22.5;
+		if(wert &gt;= stVal) strBear = &quot;E&quot;;
+		stVal += 22.5;
+		if(wert &gt;= stVal) strBear = &quot;ESE&quot;;
+		stVal += 22.5;
+		if(wert &gt;= stVal) strBear = &quot;SE&quot;;
+		stVal += 22.5;
+		if(wert &gt;= stVal) strBear = &quot;SSE&quot;;
+		stVal += 22.5;
+		if(wert &gt;= stVal) strBear = &quot;S&quot;;
+		stVal += 22.5;
+		if(wert &gt;= stVal) strBear = &quot;SSW&quot;;
+		stVal += 22.5;
+		if(wert &gt;= stVal) strBear = &quot;SW&quot;;
+		stVal += 22.5;
+		if(wert &gt;= stVal) strBear = &quot;WSW&quot;;
+		stVal += 22.5;
+		if(wert &gt;= stVal) strBear = &quot;W&quot;;
+		stVal += 22.5;
+		if(wert &gt;= stVal) strBear = &quot;WNW&quot;;
+		stVal += 22.5;
+		if(wert &gt;= stVal) strBear = &quot;NW&quot;;
+		stVal += 22.5;
+		if(wert &gt;= stVal) strBear = &quot;NNW&quot;;
+		stVal += 22.5;
+		if(wert &gt;= stVal) strBear = &quot;N&quot;;
+		stVal += 22.5;
+		return strBear;
+	} //getBearing
+
+	
+}

Added: experiments/EVE/src/cachewolf/CacheHolder.java
===================================================================
--- experiments/EVE/src/cachewolf/CacheHolder.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/CacheHolder.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,586 @@
+package cachewolf;
+
+import java.io.IOException;
+import eve.sys.Convert;
+import eve.ui.MessageBox;
+import java.util.Vector;
+import com.stevesoft.eve_pat.*;
+
+import cachewolf.utils.Common;
+import cachewolf.utils.DateFormat;
+import cachewolf.utils.SafeXML;
+
+
+/**
+ *	A class to hold information on a cache.&lt;br&gt;
+ *	Not all attributes are filled at once. You will have to look at other
+ *	classes and methods to get more information.
+ *	
+ */
+public class CacheHolder {
+	protected static final String NODISTANCE = &quot;? km&quot;;
+	protected static final String NOBEARING = &quot;?&quot;;
+	protected static final String EMPTY = &quot;&quot;;
+
+	/** Cachestatus is Found, Not found or a date in format yyyy-mm-dd hh:mm for found date */
+	public String cacheStatus = EMPTY;
+	/** The name of the waypoint typicall GC.... or OC.... or CW...... (can be any characters) */
+	public String wayPoint = EMPTY;
+	/** The name of the cache (short description) */
+	public String cacheName = EMPTY;
+	/** The alias of the owner */
+	public String cacheOwner = EMPTY;
+	/** The coordinates of the cache */
+	public CWPoint pos = new CWPoint();
+	/** The coordinates of the cache */
+	public String latLon = pos.toString();
+	/** The date when the cache was hidden in format yyyy-mm-dd */
+	public String dateHidden = EMPTY;
+	/** The size of the cache (as per GC cache sizes Micro, Small, ....) */
+	public String cacheSize = &quot;None&quot;;
+	/** The distance from the centre in km */
+	public double kilom = 0;
+	/** The formatted distance such as &quot;x.xx km&quot; */
+	public String distance = NODISTANCE;
+	/** The bearing N, NNE, NE, ENE ... from the current centre to this point */
+	public String bearing = NOBEARING;
+	/** The angle (0=North, 180=South) from the current centre to this point */
+	public double degrees = 0;
+	/** The difficulty of the cache from 1 to 5 in .5 incements */ 
+	public String hard = EMPTY;
+	/** The terrain rating of the cache from 1 to 5 in .5 incements */
+	public String terrain = EMPTY;
+	/** The cache type (@see CacheType for translation table)  */
+	public int type = 0; 
+	/** True if the cache has been archived */
+	public boolean is_archived = false;
+	/** True if the cache is available for searching */
+	public boolean is_available = true;
+	/** True if we own this cache */
+	public boolean is_owned = false;
+	/** True if we have found this cache */
+	public boolean is_found = false;
+	/** If this is true, the cache has been filtered (is currently invisible) */
+	public boolean is_filtered = false;
+	/** True if the number of logs for this cache has changed */
+	public boolean is_log_update = false;
+	/** True if cache details have changed: longDescription, Hints,  */
+	public boolean is_update = false;
+	/** True if the cache data is incomplete (e.g. an error occurred during spidering */
+	public boolean is_incomplete = false;
+	/** True if the cache is blacklisted */
+	public boolean is_black = false;
+	/** True if the cache is new */
+	public boolean is_new = false;
+	/** True if the cache is part of the results of a search */
+	public boolean is_flagged = false;
+	/** True if the cache has been selected using the tick box in the list view */
+	public boolean is_Checked = false;
+	/** Not used: This attribute is saved with the cache and read back but never set */
+//	public String dirty = EMPTY;
+	/** The unique OC cache ID */
+	public String ocCacheID = EMPTY;
+	/** The number of times this cache has not been found (max. 5) */
+	public int noFindLogs = 0;
+	/** Number of recommendations (from the opencaching logs) */
+	public int numRecommended = 0;
+	/** Number of Founds since start of recommendations system */
+	public int numFoundsSinceRecommendation = 0;
+	/** Recommendation score: calculated as rations  numRecommended / numLogsSinceRecommendation * 100 */
+	public int recommendationScore = 0;
+	/** True if this cache has travelbugs */
+	public boolean has_bug = false;
+	/** True if the cache description is stored in HTML format */
+	public boolean is_HTML = true;
+	/** List of additional waypoints associated with this waypoint */
+	public Vector addiWpts = new Vector();
+	/** in range is used by the route filter to identify caches in range of a segment*/
+	public boolean in_range = false;
+	/** If this is an additional waypoint, this links back to the main waypoint */
+	public CacheHolder mainCache;
+	/** The date this cache was last synced with OC in format yyyyMMddHHmmss */
+	public String lastSyncOC = EMPTY;
+	public CacheHolderDetail details = null;
+	/** When sorting the cacheDB this field is used. The relevant field is copied here and
+	 *  the sort is always done on this field to speed up the sorting process 
+	 */
+	public String sort;
+	private static StringBuffer sb=new StringBuffer(530); // Used in toXML()
+
+	public long attributesYes = 0;
+	public long attributesNo  = 0;
+
+//	static int nObjects=0;
+	public CacheHolder() {//nObjects++;Vm.debug(&quot;CacheHolder() nO=&quot;+nObjects);
+	}
+
+	public CacheHolder(CacheHolder ch) {//nObjects++;Vm.debug(&quot;CacheHolder(ch) nO=&quot;+nObjects);
+		update(ch);
+	}
+
+	static char decSep,notDecSep;
+	static {
+		decSep=MyLocale.getDigSeparator().charAt(0);
+		notDecSep=decSep=='.'?',':'.';
+	}
+
+	public CacheHolder(String xmlString) {
+		int start,end;
+		try {
+			start=xmlString.indexOf('&quot;'); end=xmlString.indexOf('&quot;',start+1);
+			cacheName = SafeXML.cleanback(xmlString.substring(start+1,end));
+			
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+            cacheOwner = SafeXML.cleanback(xmlString.substring(start+1,end));
+			// Assume coordinates are in decimal format
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			double lat=Convert.parseDouble(xmlString.substring(start+1,end).replace(notDecSep,decSep));
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			double lon=Convert.parseDouble(xmlString.substring(start+1,end).replace(notDecSep,decSep));
+			pos=new CWPoint(lat,lon);
+			latLon=pos.toString();
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			dateHidden = xmlString.substring(start+1,end); 
+			// Convert the US format to YYYY-MM-DD if necessary
+			if (dateHidden.indexOf('/')&gt;-1) dateHidden=DateFormat.MDY2YMD(dateHidden);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			wayPoint = SafeXML.cleanback(xmlString.substring(start+1,end));
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			cacheStatus = xmlString.substring(start+1,end);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			type = Common.parseInt(xmlString.substring(start+1,end));
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			hard = xmlString.substring(start+1,end);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			terrain = xmlString.substring(start+1,end);
+
+			// The next item was 'dirty' but this is no longer used.
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_filtered = xmlString.substring(start+1,end).equals(&quot;true&quot;); 
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			cacheSize = xmlString.substring(start+1,end);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_available = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_archived = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			has_bug = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_black = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+			if(is_black!=Global.getProfile().showBlacklisted) is_filtered = true;
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_owned = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_found = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_new = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_log_update = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_update = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+
+			// for backwards compatibility set value to true, if it is not in the file
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_HTML = !xmlString.substring(start+1,end).equals(&quot;false&quot;);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			noFindLogs = Convert.toInt(xmlString.substring(start+1,end));
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			ocCacheID = xmlString.substring(start+1,end);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			is_incomplete = xmlString.substring(start+1,end).equals(&quot;true&quot;);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			lastSyncOC = xmlString.substring(start+1,end);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			numRecommended = Convert.toInt(xmlString.substring(start+1,end));
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			numFoundsSinceRecommendation = Convert.toInt(xmlString.substring(start+1,end));
+			recommendationScore = LogList.getScore(numRecommended, numFoundsSinceRecommendation);
+
+			start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+			if (start &gt; -1 &amp;&amp; end &gt; -1) {
+				attributesYes = Convert.parseLong(xmlString.substring(start+1,end));
+
+				start=xmlString.indexOf('&quot;',end+1); end=xmlString.indexOf('&quot;',start+1);
+				if (start &gt; -1 &amp;&amp; end &gt; -1)
+					attributesNo = Convert.parseLong(xmlString.substring(start+1,end));
+			}
+		} catch (Exception ex) {
+
+		}
+	}
+
+	public void update(CacheHolder ch) {
+		update(ch, false);
+	}
+	public void update(CacheHolder ch, boolean overwrite) {
+		this.recommendationScore = ch.recommendationScore;
+		this.numFoundsSinceRecommendation = ch.numFoundsSinceRecommendation;
+		this.numRecommended = ch.numRecommended;
+		if (overwrite) {
+			this.cacheStatus=ch.cacheStatus;
+			this.is_found = ch.is_found;
+			this.pos = ch.pos;
+			this.latLon = ch.latLon;
+		} else {
+			/* Here we have to distinguish several cases:
+	   this.is_found       this                ch               Update 'this'
+	   --------------------------------------------------------------------
+	   false               empty               yyyy-mm-dd       yes
+	   true                &quot;Found&quot;             yyyy-mm-dd       yes
+	   true                yyyy-mm-dd          yyyy-mm-dd       no (or yes)
+	   true                yyyy-mm-dd hh:mm    yyyy-mm-dd       no
+			 */
+			if (!this.is_found || this.cacheStatus.indexOf(&quot;:&quot;)&lt;0) {
+				this.cacheStatus=ch.cacheStatus;
+				this.is_found = ch.is_found;
+			}
+			// Don't overwrite valid coordinates with invalid ones
+			if (ch.pos.isValid() || !this.pos.isValid()) {
+				this.pos = ch.pos;
+				this.latLon = ch.latLon;
+			}
+		}
+		this.wayPoint = ch.wayPoint;
+		this.cacheName = ch.cacheName;
+		this.cacheOwner = ch.cacheOwner;
+
+		this.dateHidden = ch.dateHidden;
+		this.cacheSize = ch.cacheSize;
+		this.kilom = ch.kilom;
+		this.distance = ch.distance;
+		this.bearing = ch.bearing;
+		this.degrees = ch.degrees;
+		this.hard = ch.hard;
+		this.terrain = ch.terrain;
+		this.type = ch.type;
+		this.is_archived = ch.is_archived;
+		this.is_available = ch.is_available;
+		this.is_owned = ch.is_owned;
+		this.is_filtered = ch.is_filtered;
+		this.is_log_update = ch.is_log_update;
+		this.is_update = ch.is_update;
+		this.is_incomplete = ch.is_incomplete;
+		this.is_black=ch.is_black;
+		this.addiWpts = ch.addiWpts;
+		this.mainCache=ch.mainCache;
+		this.is_new=ch.is_new;
+		this.is_flagged = ch.is_flagged;
+		this.is_Checked = ch.is_Checked;
+		//this.dirty = ch.dirty;
+		this.ocCacheID = ch.ocCacheID;
+		this.noFindLogs = ch.noFindLogs;
+		this.has_bug = ch.has_bug;
+		this.is_HTML = ch.is_HTML;
+		this.sort=ch.sort;
+		this.lastSyncOC = ch.lastSyncOC;
+
+		this.attributesYes = ch.attributesYes;
+		this.attributesNo = ch.attributesNo;
+	}
+
+	public String getStatusDate() {
+		String statusDate = &quot;&quot;;
+		
+		if (is_found) {
+			Regex rexDate=new Regex(&quot;([0-9]{4}-[0-9]{2}-[0-9]{2})&quot;);
+			rexDate.search(cacheStatus);
+			if (rexDate.stringMatched(1)!= null) {
+				statusDate = rexDate.stringMatched(1);
+			}
+		}
+
+		return statusDate;		
+	}
+
+	public String getStatusTime() {
+		String statusTime = &quot;&quot;;
+
+		if (is_found) {
+			Regex rexTime=new Regex(&quot;([0-9]{1,2}:[0-9]{2})&quot;);
+			rexTime.search(cacheStatus);
+			if (rexTime.stringMatched(1)!= null) {
+				statusTime = rexTime.stringMatched(1);
+			}
+			else {
+				Regex rexDate=new Regex(&quot;([0-9]{4}-[0-9]{2}-[0-9]{2})&quot;);
+				rexDate.search(cacheStatus);
+				if (rexDate.stringMatched(1)!= null) {
+					statusTime = &quot;00:00&quot;;
+				}
+			}
+		}
+		return statusTime;		
+	}
+	
+	
+	
+	
+	/**
+	 * Call it only when necessary, it takes time, because all logs must be parsed
+	 *
+	 */
+	public void calcRecommendationScore() {
+		if (wayPoint.toLowerCase().startsWith(&quot;oc&quot;) ) {
+			CacheHolderDetail chD;
+			if (this instanceof CacheHolderDetail)	chD = (CacheHolderDetail)this;
+			else chD = getCacheDetails(true, false);
+			if (chD != null) {
+				chD.cacheLogs.calcRecommendations();
+				recommendationScore = chD.cacheLogs.recommendationRating;
+				numFoundsSinceRecommendation = chD.cacheLogs.foundsSinceRecommendation;
+				numRecommended = chD.cacheLogs.numRecommended;
+			} else { // cache doesn't have details
+				recommendationScore = -1;
+				numFoundsSinceRecommendation = -1;
+				numRecommended = -1;
+			}
+		} else {
+			recommendationScore = -1;
+			numFoundsSinceRecommendation = -1;
+			numRecommended = -1;
+		}
+		if (details != null) {
+		details.recommendationScore = recommendationScore;
+		details.numFoundsSinceRecommendation = numFoundsSinceRecommendation;
+		details.numRecommended = numRecommended;
+		}
+	}
+	
+	/** Return a XML string containing all the cache data for storing in index.xml */
+	public String toXML() {
+		if (this instanceof CacheHolderDetail || (details != null &amp;&amp; details.hasUnsavedChanges)) calcRecommendationScore(); 
+		sb.delete(0,sb.length());
+		sb.append(&quot;    &lt;CACHE name = \&quot;&quot;);
+		sb.append(SafeXML.clean(cacheName));
+		sb.append(&quot;\&quot; owner = \&quot;&quot;);		sb.append(SafeXML.clean(cacheOwner));
+		sb.append(&quot;\&quot; lat = \&quot;&quot;); 		sb.append(pos.latDec ); 
+		sb.append(&quot;\&quot; lon = \&quot;&quot;);		sb.append(pos.lonDec);
+		sb.append(&quot;\&quot; hidden = \&quot;&quot;);	sb.append(dateHidden);
+		sb.append(&quot;\&quot; wayp = \&quot;&quot;);		sb.append(SafeXML.clean(wayPoint));
+		sb.append(&quot;\&quot; status = \&quot;&quot;);	sb.append(cacheStatus);
+		sb.append(&quot;\&quot; type = \&quot;&quot;);		sb.append(type);
+		sb.append(&quot;\&quot; dif = \&quot;&quot;);		sb.append(hard);
+		sb.append(&quot;\&quot; terrain = \&quot;&quot; );	sb.append(terrain ); 
+		sb.append(&quot;\&quot; filtered = \&quot;&quot; ); sb.append(is_filtered); // This was 'dirty', but dirty is not used
+		sb.append(&quot;\&quot; size = \&quot;&quot;);		sb.append(cacheSize);
+		sb.append(&quot;\&quot; online = \&quot;&quot; );	sb.append(is_available); 
+		sb.append(&quot;\&quot; archived = \&quot;&quot; );	sb.append(is_archived); 
+		sb.append(&quot;\&quot; has_bug = \&quot;&quot; ); 	sb.append(has_bug); 
+		sb.append(&quot;\&quot; black = \&quot;&quot; ); 	sb.append(is_black); 
+		sb.append(&quot;\&quot; owned = \&quot;&quot; ); 	sb.append(is_owned); 
+		sb.append(&quot;\&quot; found = \&quot;&quot; ); 	sb.append(is_found); 
+		sb.append(&quot;\&quot; is_new = \&quot;&quot; );	sb.append(is_new);
+		sb.append(&quot;\&quot; is_log_update = \&quot;&quot; );sb.append(is_log_update); 
+		sb.append(&quot;\&quot; is_update = \&quot;&quot; );sb.append(is_update); 
+		sb.append(&quot;\&quot; is_HTML = \&quot;&quot; ); 	sb.append(is_HTML); 
+		sb.append(&quot;\&quot; DNFLOGS = \&quot;&quot; ); 	sb.append(noFindLogs ); 
+		sb.append(&quot;\&quot; ocCacheID = \&quot;&quot; );sb.append(ocCacheID ); 
+		sb.append(&quot;\&quot; is_INCOMPLETE = \&quot;&quot;);sb.append(is_incomplete); 
+		sb.append(&quot;\&quot; lastSyncOC = \&quot;&quot; );sb.append(lastSyncOC ); 
+		sb.append(&quot;\&quot; num_recommended = \&quot;&quot;);sb.append(Convert.formatInt(numRecommended)); 
+		sb.append(&quot;\&quot; num_found = \&quot;&quot; );sb.append(Convert.formatInt(numFoundsSinceRecommendation));
+		sb.append(&quot;\&quot; attributesYes = \&quot;&quot; ); sb.append(Convert.formatLong(attributesYes));
+		sb.append(&quot;\&quot; attributesNo = \&quot;&quot; ); sb.append(Convert.formatLong(attributesNo));
+		sb.append(&quot;\&quot; /&gt;\n&quot;);
+		return sb.toString();
+	}
+
+	public void setLatLon(String latLon) {
+		latLon=latLon.trim();
+		if (!latLon.equals(this.latLon.trim())) is_update=true;
+		this.latLon = latLon;
+		pos.set(latLon);
+	}
+
+	public boolean isAddiWpt() {
+		return CacheType.isAddiWpt(this.type);
+	}
+
+	public boolean hasAddiWpt() {
+		if (this.addiWpts.size()&gt;0) 
+			return true;
+		return false;
+	}
+
+
+	public void calcDistance(CWPoint toPoint) {	
+		if(pos.isValid()){
+			kilom = pos.getDistance(toPoint);
+			degrees = toPoint.getBearing(pos);
+			bearing = CWPoint.getDirection(degrees);
+			distance = MyLocale.formatDouble(kilom,&quot;0.00&quot;)+&quot; km&quot;;
+		} else {
+			distance = NODISTANCE;
+			bearing = NOBEARING;
+		}
+	}
+	public void setAttributesFromMainCache(CacheHolder mainCh){
+		this.cacheOwner = mainCh.cacheOwner;
+		this.cacheStatus = mainCh.cacheStatus;
+		this.is_archived = mainCh.is_archived;
+		this.is_available = mainCh.is_available;
+		this.is_black = mainCh.is_black;
+		this.is_owned = mainCh.is_owned;
+		this.is_new = mainCh.is_new;
+		this.is_found = mainCh.is_found;
+	}
+
+	public void setAttributesToAddiWpts(){
+		if (this.hasAddiWpt()){
+			CacheHolder addiWpt;
+			for (int i= this.addiWpts.size() - 1;  i&gt;=0; i--){
+				addiWpt = (CacheHolder) this.addiWpts.get(i);
+				addiWpt.setAttributesFromMainCache(this);
+			}
+		}
+	}
+
+	/**
+	 * True if ch and this belong to the same main cache. 
+	 * @param ch
+	 * @return
+	 */
+	public boolean hasSameMainCache(CacheHolder ch) {
+		if (this == ch) return true;
+		if (ch == null) return false;
+		if ((!this.isAddiWpt()) &amp;&amp; (!ch.isAddiWpt())) return false;
+		CacheHolder main1, main2;
+		if (this.isAddiWpt()) main1 = this.mainCache;  else main1 = this;
+		if (ch instanceof CacheHolderDetail) {
+			if (ch.isAddiWpt()) 
+				main2=ch.mainCache;
+			else 
+				return main1.wayPoint.equals(ch.wayPoint);
+			} else { // ch instanceof CacheHolder 
+				if (ch.isAddiWpt()) main2 = ch.mainCache; else main2 = ch; 
+			}
+		return main1 == main2;
+	}
+
+	/** 
+	 * Call this method to get the long-description and so on.
+	 * If the according .xml-file is already read, it will return
+	 * that one, otherwise it will be loaded.
+	 * To avoid memory problems this routine loads not for more caches than maxDetails
+	 * the details. If maxdetails is reached, it will remove from RAM the details 
+	 * of the 5 caches that were loaded most long ago.
+	 */
+	public CacheHolderDetail getCacheDetails(boolean maybenew) {
+		return getCacheDetails(maybenew, true);
+	}
+	
+	/** 
+	 * Call this method to get the long-description and so on.
+	 * If the according .xml-file is already read, it will return
+	 * that one, otherwise it will be loaded.
+	 * To avoid memory problems this routine loads not for more caches than maxDetails
+	 * the details. If maxdetails is reached, it will remove from RAM the details 
+	 * of the 5 caches that were loaded most long ago.
+	 * 
+	 * @param alarmuser if true an error message will be displayed to the user, if the details could not be read
+	 * @return the respective CacheHolderDetail, null if according xml-file could not be read
+	 */
+		
+	public CacheHolderDetail getCacheDetails(boolean maybenew, boolean alarmuser) {
+		if (details != null) {
+			if (details.hasUnsavedChanges) this.update(details);
+			else details.update(this);
+			return details;
+		}
+		details = new CacheHolderDetail(this);
+		try {
+			details.readCache(Global.getProfile().dataDir);
+		} catch (IOException e) {
+			if (maybenew) details.update(this);
+			else {
+				if (alarmuser) (new MessageBox(&quot;Error&quot;, &quot;Could not read cache details for cache: &quot;+this.wayPoint, MessageBox.OKB)).execute();
+				return null;
+			} 
+		}
+		detailsAdded();
+		return details;
+	}
+
+	/**
+	 * Call this after you added the cache with details to the 
+	 * cacheDB &lt;br&gt; It is assumed that that details is set
+	 * for an example see OCXMLImporter.endCache()
+	 *
+	 */
+	public void detailsAdded() {
+		cachesWithLoadedDetails.add(this);
+		if (cachesWithLoadedDetails.size() &gt;= Global.getPref().maxDetails) removeOldestDetails();
+	}
+
+	public void releaseCacheDetails() {
+		if (details != null &amp;&amp; details.hasUnsavedChanges){
+			//calcRecommendationScore();
+			details.saveCacheDetails(Global.getProfile().dataDir);
+			this.update(details);
+		}
+		details = null;
+		cachesWithLoadedDetails.remove(this);
+	}
+
+	//final static int maxDetails = 50; 
+	static Vector cachesWithLoadedDetails = new Vector(Global.getPref().maxDetails);
+
+	public static void removeOldestDetails() {
+		for (int i=0; i&lt;Global.getPref().deleteDetails; i++)
+			((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
+	}
+
+	public static void removeAllDetails() {
+		for (int i=cachesWithLoadedDetails.size()-1; i&gt;=0; i--)
+			((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
+	}
+
+	/**
+	 * when importing caches you can set details.saveChanges = true
+	 * when the import ist finished call this method to save the pending changes
+	 *
+	 */
+	public static void saveAllModifiedDetails() {
+		CacheHolder ch;
+		CacheHolderDetail chD;
+		for (int i=cachesWithLoadedDetails.size()-1; i&gt;=0; i--) {
+			ch = (CacheHolder)(cachesWithLoadedDetails.get(i));
+			chD = ch.getCacheDetails(false);
+			if (chD.hasUnsavedChanges) {
+				//ch.calcRecommendationScore();
+				chD.saveCacheDetails(Global.getProfile().dataDir);
+				ch.update(chD);
+			}
+		}
+	}
+
+	/*
+public void finalize() {nObjects--;
+   Vm.debug(&quot;Destroying CacheHolder &quot;+wayPoint);
+   Vm.debug(&quot;CacheHolder: &quot;+nObjects+&quot; objects left&quot;);
+}
+	 */
+}
\ No newline at end of file

Added: experiments/EVE/src/cachewolf/CacheHolderDetail.java
===================================================================
--- experiments/EVE/src/cachewolf/CacheHolderDetail.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/CacheHolderDetail.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,376 @@
+package cachewolf;
+
+import eve.ui.filechooser.FileChooser;
+import java.io.BufferedWriter;
+import eve.io.File;
+import java.io.FileOutputStream;
+import java.io.OutputStreamWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.Vector;
+
+import cachewolf.utils.Extractor;
+
+
+import eve.ui.data.*;
+
+public class CacheHolderDetail extends CacheHolder {
+	  public String longDescription = EMPTY;
+	  public String lastUpdate = EMPTY;
+	  public String hints = EMPTY;
+	  public LogList cacheLogs=new LogList();
+	  public String cacheNotes = EMPTY;
+	  public Vector images = new Vector();
+	  public Vector imagesText = new Vector();
+	  public Vector imagesInfo = new Vector();
+	  public Vector logImages = new Vector();
+	  public Vector logImagesText = new Vector();
+	  public Vector userImages = new Vector();
+	  public Vector userImagesText = new Vector();
+	  public Attributes attributes=new Attributes();
+	  public Vector cacheIcons = new Vector();
+	  public TravelbugList travelbugs=new TravelbugList();
+	  //public String Bugs = EMPTY; Superceded by Travelbugs
+	  public String URL = EMPTY;
+	  public String solver = EMPTY;
+	  /** For faster cache import (from opencaching) changes are only written when the details are freed from memory 
+	   * If you want to save the changes automatically when the details are unloaded, set this to true */ 
+	  public boolean hasUnsavedChanges = false;
+	  
+	 public CacheHolderDetail() {
+	 }
+	 //public CacheHolderDetail(String wpt) {super(wpt); }
+	 public CacheHolderDetail(CacheHolder ch) {
+		 super(ch);
+	 }
+
+	 public void setLongDescription(String longDescription) {
+	 	if (this.longDescription.equals(&quot;&quot;)) is_new=true;
+	 	else if (!stripControlChars(this.longDescription).equals(stripControlChars(longDescription))) is_update=true;
+	 	this.longDescription = longDescription;
+	 }
+	 
+	 private String stripControlChars(String desc) {
+		 StringBuffer sb=new StringBuffer(desc.length());
+		 for (int i=0; i&lt;desc.length(); i++) {
+			char c=desc.charAt(i);
+			if (c&gt;' ') sb.append(c);
+		 }
+		 return sb.toString();
+	 }
+	 
+	 public void setHints(String hints) {
+	 	if (!this.hints.equals(hints)) is_update=true;
+	 	this.hints = hints;
+	 }
+	 
+	 public void setCacheLogs(LogList newLogs) {
+		 int size=newLogs.size();
+		 for (int i=size-1; i&gt;=0; i--) { // Loop over all new logs, must start with oldest log
+			 if (cacheLogs.merge(newLogs.getLog(i))&gt;=0) this.is_log_update=true;
+		 }
+		 //CacheLogs=logs;
+		 noFindLogs=cacheLogs.countNotFoundLogs();
+	 }
+
+	 
+	  /**
+	 * Method to update an existing cache with new data. This is
+	 * necessary to avoid missing old logs. Called from GPX Importer
+	 * @param newCh new cache data
+	 * @return CacheHolder with updated data
+	 */
+	public CacheHolderDetail update(CacheHolderDetail newCh){
+		  super.update(newCh);
+		  // flags
+		  if (this.is_found == true &amp;&amp; this.cacheStatus.equals(&quot;&quot;)) this.cacheStatus = MyLocale.getMsg(318,&quot;Found&quot;);
+
+		  //travelbugs:GPX-File contains all actual travelbugs but not the missions
+		  //  we need to check whether the travelbug is already in the existing list
+		  this.has_bug = newCh.travelbugs.size()&gt;0;
+		  for (int i=newCh.travelbugs.size()-1; i&gt;=0; i--) {
+			 Travelbug tb=newCh.travelbugs.getTB(i);  
+		     Travelbug oldTB=this.travelbugs.find(tb.getName());
+		     // If the bug is already in the cache, we keep it
+		     if (oldTB!=null)
+		    	 newCh.travelbugs.replace(i,oldTB);
+		    
+		  }
+		  this.travelbugs = newCh.travelbugs;
+		  
+		  // URL
+		  this.URL = newCh.URL;
+		  
+		  setLongDescription(newCh.longDescription);
+		  setHints(newCh.hints);
+		  setCacheLogs(newCh.cacheLogs);
+		  
+		  if (newCh.solver.length()&gt;0) this.solver=newCh.solver;
+	 	return this;
+	  }
+	  
+	  /**
+	   * Adds a user image to the cache data
+	   * @param profile
+	   */
+		public void addUserImage(Profile profile){
+		  File imgFile;
+		  String imgDesc, imgDestName;
+		  
+		  //Get Image and description
+			FileChooser fc = new FileChooser(FileChooser.OPEN, profile.dataDir);
+			fc.title=&quot;Select image file:&quot;;
+			if(fc.execute() != FileChooser.IDCANCEL){
+				imgFile = fc.getChosenFile();
+				imgDesc = new InputBox(&quot;Description&quot;).input(&quot;&quot;,10);
+				//Create Destination Filename
+				String ext = imgFile.getFileExt().substring(imgFile.getFileExt().lastIndexOf(&quot;.&quot;));
+				imgDestName = this.wayPoint + &quot;_U_&quot; + (this.userImages.size()+1) + ext;
+				
+				this.userImages.add(imgDestName);
+				this.userImagesText.add(imgDesc);
+				// Copy File
+				DataMover.copy(imgFile.getFullPath(),profile.dataDir + imgDestName);
+				// Save Data
+				saveCacheDetails(profile.dataDir);
+			}
+	  }
+
+	  
+		/**
+		*	Method to parse a specific cache.xml file.
+		*	It fills information on cache details, hints, logs, notes and
+		*	images.
+		*/
+		public void readCache(String dir) throws IOException{
+eve.sys.Vm.debug(&quot;===chD:readDetail: &quot;+wayPoint);
+			String dummy;
+			String filename=dir+wayPoint.toLowerCase()+&quot;.xml&quot;;
+			if (!new File(filename).exists()) {
+				filename=dir+wayPoint+&quot;.xml&quot;;
+				if (!new File(filename).exists()) new java.io.FileNotFoundException(dir+wayPoint.toLowerCase()+&quot;.xml&quot;);
+			}
+			char buf[]=new char[(int) (new File(filename)).getLength()];
+			java.io.InputStreamReader in = new java.io.InputStreamReader(new java.io.FileInputStream(filename),&quot;UTF8&quot;);
+			int len=in.read(buf);
+			in.close();
+			eve.util.CharArray ca=new eve.util.CharArray(buf); ca.setLength(len);
+			String text=(ca).toString();
+			Extractor ex = new Extractor(text, &quot;&lt;DETAILS&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/DETAILS&gt;&quot;, 0, true);		
+			longDescription = ex.findNext();
+			ex = new Extractor(text, &quot;&lt;HINTS&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/HINTS&gt;&quot;, 0, true);
+			hints = ex.findNext();
+			// Attributes
+			ex = new Extractor(text,&quot;&lt;ATTRIBUTES&gt;&quot;,&quot;&lt;/ATTRIBUTES&gt;&quot;,0,true);
+			attributes.xmlAttributesEnd(ex.findNext());
+			
+			ex = new Extractor(text, &quot;&lt;LOGS&gt;&quot;,&quot;&lt;/LOGS&gt;&quot;, 0, true);
+			dummy = ex.findNext();
+			cacheLogs.clear();
+			ex = new Extractor(dummy, &quot;&lt;LOG&gt;&quot;,&quot;&lt;/LOG&gt;&quot;, 0, true);
+			
+			dummy = ex.findNext();
+			while(ex.endOfSearch()==false){
+				cacheLogs.add(new Log(dummy));
+				dummy = ex.findNext();
+			}
+			ex = new Extractor(text, &quot;&lt;NOTES&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/NOTES&gt;&quot;, 0, true);
+			cacheNotes = ex.findNext();
+			images.clear();
+			ex = new Extractor(text, &quot;&lt;IMG&gt;&quot;, &quot;&lt;/IMG&gt;&quot;, 0, true);
+			dummy = ex.findNext();
+			while(ex.endOfSearch() == false){
+				images.add(dummy);
+				dummy = ex.findNext();
+			}
+			imagesText.clear();
+			ex = new Extractor(text, &quot;&lt;IMGTEXT&gt;&quot;, &quot;&lt;/IMGTEXT&gt;&quot;, 0, true);
+			dummy = ex.findNext();
+			while(ex.endOfSearch() == false){
+				int pos=dummy.indexOf(&quot;&lt;DESC&gt;&quot;);
+				if (pos&gt;0) {
+					imagesText.add(dummy.substring(0,pos));
+					imagesInfo.add(dummy.substring(pos+6,dummy.indexOf(&quot;&lt;/DESC&gt;&quot;)));
+				} else {
+					imagesText.add(dummy);
+					imagesInfo.add(null);
+				}
+				dummy = ex.findNext();
+			}
+
+			// Logimages
+			logImages.clear();
+			ex = new Extractor(text, &quot;&lt;LOGIMG&gt;&quot;, &quot;&lt;/LOGIMG&gt;&quot;, 0, true);
+			dummy = ex.findNext();
+			while(ex.endOfSearch() == false){
+				logImages.add(dummy);
+				dummy = ex.findNext();
+			}
+			logImagesText.clear();
+			ex = new Extractor(text, &quot;&lt;LOGIMGTEXT&gt;&quot;, &quot;&lt;/LOGIMGTEXT&gt;&quot;, 0, true);
+			dummy = ex.findNext();
+			while(ex.endOfSearch() == false){
+				logImagesText.add(dummy);
+				dummy = ex.findNext();
+			}
+
+			userImages.clear();
+			ex = new Extractor(text, &quot;&lt;USERIMG&gt;&quot;, &quot;&lt;/USERIMG&gt;&quot;, 0, true);
+			dummy = ex.findNext();
+			while(ex.endOfSearch() == false){
+				userImages.add(dummy);
+				dummy = ex.findNext();
+			}
+			userImagesText.clear();
+			ex = new Extractor(text, &quot;&lt;USERIMGTEXT&gt;&quot;, &quot;&lt;/USERIMGTEXT&gt;&quot;, 0, true);
+			dummy = ex.findNext();
+			while(ex.endOfSearch() == false){
+				userImagesText.add(dummy);
+				dummy = ex.findNext();
+			}
+
+			ex = new Extractor(text, &quot;&lt;TRAVELBUGS&gt;&quot;, &quot;&lt;/TRAVELBUGS&gt;&quot;, 0, false);
+			dummy=ex.findNext();
+			if (ex.endOfSearch()) {
+				ex = new Extractor(text, &quot;&lt;BUGS&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/BUGS&gt;&quot;, 0, true);
+				String Bugs = ex.findNext();
+				travelbugs.addFromHTML(Bugs);
+			} else
+				travelbugs.addFromXML(dummy);
+			
+			ex = new Extractor(text, &quot;&lt;URL&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/URL&gt;&quot;, 0, true);
+			// if no URL is stored, set default URL (at this time only possible for gc.com)
+			dummy = ex.findNext();
+			if (dummy.length() &gt; 10){
+				URL = dummy;
+			}
+			else {
+				if (wayPoint.startsWith(&quot;GC&quot;)) {
+					URL = &quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot;+ wayPoint + &quot;&amp;Submit6=Find&amp;log=y&quot;;
+				}
+			}
+			ex = new Extractor(text, &quot;&lt;SOLVER&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/SOLVER&gt;&quot;, 0, true);
+			solver=ex.findNext();
+		}
+		
+		/**
+		*	Method to save a cache.xml file.
+		*/
+		public void saveCacheDetails(String dir){
+			PrintWriter detfile;
+			//File exists?
+			boolean exists = (new File(dir + wayPoint + &quot;.xml&quot;)).exists();
+			//yes: then delete
+			if (exists) {
+				boolean ok = (new File(dir + wayPoint + &quot;.xml&quot;)).delete();
+				if(ok) ok = true;
+			}
+			boolean exists2 = (new File(dir + wayPoint.toLowerCase() + &quot;.xml&quot;)).exists();
+			//yes: delete
+			if (exists2) {
+				boolean ok2 = (new File(dir + wayPoint.toLowerCase() + &quot;.xml&quot;)).delete();
+				if(ok2) ok2=true;
+			}
+			//Vm.debug(&quot;Writing to: &quot; +dir + &quot;for: &quot; + wayPoint);
+			try{
+		        detfile = new PrintWriter(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(dir + wayPoint.toLowerCase() + &quot;.xml&quot;), &quot;UTF8&quot;)));
+			} catch (Exception e) {
+				Global.getPref().log(&quot;Problem creating details file&quot;,e,true);
+				return;
+			}
+			try{
+				if(wayPoint.length()&gt;0){
+				  detfile.print(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;ISO-8859-1\&quot;?&gt;\r\n&quot;);
+				  detfile.print(&quot;&lt;CACHEDETAILS&gt;\r\n&quot;);
+				  detfile.print(&quot;&lt;DETAILS&gt;&lt;![CDATA[&quot;+longDescription+&quot;]]&gt;&lt;/DETAILS&gt;\r\n&quot;);
+				  detfile.print(attributes.xmlAttributesWrite());
+				  detfile.print(&quot;&lt;HINTS&gt;&lt;![CDATA[&quot;+hints+&quot;]]&gt;&lt;/HINTS&gt;\r\n&quot;);
+				  detfile.print(&quot;&lt;LOGS&gt;\r\n&quot;);
+				  for(int i = 0; i &lt; cacheLogs.size(); i++){
+					  detfile.print(cacheLogs.getLog(i).toXML());
+				  }
+				  detfile.print(&quot;&lt;/LOGS&gt;\r\n&quot;);
+			
+				  detfile.print(&quot;&lt;NOTES&gt;&lt;![CDATA[&quot;+cacheNotes+&quot;]]&gt;&lt;/NOTES&gt;\n&quot;);
+				  detfile.print(&quot;&lt;IMAGES&gt;&quot;);
+				  String stbuf;
+				  for(int i = 0;i&lt;images.size();i++){
+						detfile.print(&quot;    &lt;IMG&gt;&quot;+images.get(i)+&quot;&lt;/IMG&gt;\n&quot;);
+				  }
+				  int iis = imagesInfo.size();
+				  for(int i = 0;i&lt;imagesText.size();i++){
+						stbuf = (String)imagesText.get(i);
+						if (i &lt; iis &amp;&amp; imagesInfo.get(i) != null)
+							detfile.print(&quot;    &lt;IMGTEXT&gt;&quot;+stbuf+&quot;&lt;DESC&gt;&quot;+imagesInfo.get(i)+&quot;&lt;/DESC&gt;&lt;/IMGTEXT&gt;\n&quot;);
+						else 
+							detfile.print(&quot;    &lt;IMGTEXT&gt;&quot;+stbuf+&quot;&lt;/IMGTEXT&gt;\n&quot;);
+				  }
+				  for(int i = 0;i&lt;logImages.size();i++){
+						detfile.print(&quot;    &lt;LOGIMG&gt;&quot;+logImages.get(i)+&quot;&lt;/LOGIMG&gt;\n&quot;);
+				  }
+				  for(int i = 0;i&lt;logImagesText.size();i++){
+						detfile.print(&quot;    &lt;LOGIMGTEXT&gt;&quot;+logImagesText.get(i)+&quot;&lt;/LOGIMGTEXT&gt;\n&quot;);
+				  }
+				  for(int i = 0;i&lt;userImages.size();i++){
+						detfile.print(&quot;    &lt;USERIMG&gt;&quot;+userImages.get(i)+&quot;&lt;/USERIMG&gt;\n&quot;);
+				  }
+				  for(int i = 0;i&lt;userImagesText.size();i++){
+						detfile.print(&quot;    &lt;USERIMGTEXT&gt;&quot;+userImagesText.get(i)+&quot;&lt;/USERIMGTEXT&gt;\n&quot;);
+				  }
+
+
+				  detfile.print(&quot;&lt;/IMAGES&gt;\n&quot;);
+				  //detfile.print(&quot;&lt;BUGS&gt;&lt;![CDATA[\n&quot;);
+				  //detfile.print(Bugs+&quot;\n&quot;);
+				  //detfile.print(&quot;]]&gt;&lt;/BUGS&gt;\n&quot;);
+				  detfile.print(travelbugs.toXML());
+				  detfile.print(&quot;&lt;URL&gt;&lt;![CDATA[&quot;+URL+&quot;]]&gt;&lt;/URL&gt;\r\n&quot;);
+				  detfile.print(&quot;&lt;SOLVER&gt;&lt;![CDATA[&quot;+solver+&quot;]]&gt;&lt;/SOLVER&gt;\r\n&quot;);
+				  detfile.print(toXML()); // This will allow restoration of index.xml
+				  detfile.print(&quot;&lt;/CACHEDETAILS&gt;\n&quot;);
+				} // if length
+			} catch (Exception e){
+				Global.getPref().log(&quot;Problem waypoint &quot; + wayPoint + &quot; writing to a details file: &quot; + e.getMessage());
+			}
+			try{
+			  detfile.close();
+			} catch (Exception e){
+			  Global.getPref().log(&quot;Problem waypoint &quot; + wayPoint + &quot; writing to a details file: &quot; + e.getMessage());
+			}
+			hasUnsavedChanges = false;
+		}
+		
+		/**
+		 * Method for checking if to caches belongs to each other, e.g.
+		 * an additional waypoint belongs to the main cache.
+		 * Works currently only, if the last 4 or 5 chars of the waypoint are
+		 * the same, this is the gc.com way. 
+		 * @param ch cache to check
+		 * @return true if there is a relation, false otherwise
+		 */
+/*		public boolean belongsTo (CacheHolder ch) {
+			
+			// avoid self referencing
+			if (this.wayPoint.equals(ch.wayPoint)) return false;
+
+			return this.wayPoint.endsWith(ch.wayPoint.substring(2));
+		}
+*/		
+		/**
+		 * Return true if this cache has additional info for some pictures
+		 * @return true if cache has additional info, false otherwise
+		 */
+		public boolean hasImageInfo() {
+			for (int i=imagesInfo.size()-1; i&gt;=0; i--)
+				if (imagesInfo.get(i)!=null) return true;
+			return false;
+		}
+
+		
+
+//	   public void finalize() {
+//		   super.finalize();
+//		   Vm.debug(&quot;Destroying CacheHolder &quot;+wayPoint);
+//	   }
+
+}

Added: experiments/EVE/src/cachewolf/CacheList.java
===================================================================
--- experiments/EVE/src/cachewolf/CacheList.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/CacheList.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,470 @@
+package cachewolf;
+
+import eve.ui.filechooser.FileChooser;
+import eve.fx.*;
+import eve.sys.*;
+import eve.ui.*;
+import java.util.*;
+import java.io.FileReader;
+import java.io.PrintWriter;
+import java.io.BufferedWriter;
+import eve.ui.event.KeyEvent;
+import eve.fx.gui.IKeys;
+import eve.ui.event.MenuEvent;
+import eve.ui.event.MultiPanelEvent;
+import eve.ui.event.ControlEvent;
+import java.io.BufferedReader;
+import java.io.FileWriter;
+
+
+/********************************************************
+ * This class implements the core functionality of a flexible cachelist for collecting
+ * &quot;Cachetours&quot;. Caches can be dragged into the list from the main list view and
+ * from the radar panel view. Caches can be removed from the list by dragging them
+ * out or selecting them and pressing the &quot;delete&quot; key. Within the list the selected
+ * cache can be moved up/down using two buttons. The finished list can be saved and
+ * reloaded with the selected position being stored. The list can be applied as
+ * a filter to the main list, thereby hiding all caches that are not in the list
+ * and sorting the caches according to the list.
+ * Created by skg, Februar 2007
+ ********************************************************/
+public class CacheList extends CellPanel {
+    /** The extension for cachelists (CL) */
+    private final static String EXTENSION=&quot;CL&quot;;
+	private final static String TITLE=MyLocale.getMsg(188,&quot;CACHETOUR: NEW&quot;);
+	private static int applyCount=0; // Counts the number of times we apply the list
+    CacheList() {
+		this.setPreferredSize(100,-1);
+		this.equalWidths=true;
+		Picture imgDown=new Picture(&quot;eve/downarrowsmall.png&quot;); //imgDown.transparentColor=Color.White;
+		Picture imgUp=new Picture(&quot;eve/uparrowsmall.png&quot;); //imgUp.transparentColor=Color.White;
+		// Title
+		lblTitle=new Label(TITLE);
+		lblTitle.backGround=new Color(0,0,200); lblTitle.foreGround=Color.White;
+		addLast(lblTitle,HSTRETCH,HFILL|HCENTER);
+		// The actual list
+		lstCaches=new myList(10,1,false); lstCaches.text=&quot;CacheList&quot;;
+		lstCaches.addItem(MyLocale.getMsg(180,&quot;Drag caches&quot;));lstCaches.addItem(MyLocale.getMsg(181,&quot;here&quot;));
+		ScrollablePanel scp=lstCaches.getScrollablePanel();
+		addLast(scp,STRETCH,FILL); scp.setOptions(MyScrollBarPanel.NeverShowHorizontalScrollers);
+		// The buttons to move the selected cache
+		addNext(btnDown=new Button(imgDown),HSHRINK,HFILL); btnDown.modify(Disabled,0);
+		addLast(btnUp=new Button(imgUp),HSHRINK,HFILL); btnUp.modify(Disabled,0);
+		// Buttons to clear, load and save the list
+		Panel cp=new Panel(); cp.equalWidths=true;
+		cp.addNext(btnNew=new Button(new Picture(&quot;clnew.png&quot;,new Color(255,0,0),0)),HSTRETCH,HFILL);
+		btnNew.setToolTip(MyLocale.getMsg(182,&quot;New list&quot;));
+		cp.addNext(btnLoad=new Button(new Picture(&quot;clopen.png&quot;,new Color(255,0,0),0)),HSTRETCH,HFILL);
+		btnLoad.setToolTip(MyLocale.getMsg(183,&quot;Load list&quot;));
+		cp.addNext(btnSaveAs=new Button(new Picture(&quot;clsaveas.png&quot;,new Color(0,255,0),0)),HSTRETCH,HFILL);
+		btnSaveAs.setToolTip(MyLocale.getMsg(184,&quot;Save as&quot;));
+		cp.addLast(btnSave=new Button(new Picture(&quot;clsave.png&quot;,new Color(255,0,0),0)),HSTRETCH,HFILL);
+		btnSave.setToolTip(MyLocale.getMsg(185,&quot;Save (without confirmation)&quot;));
+		addLast(cp,HSTRETCH,HFILL);
+		// Button to toggle whether additional waypoints are automatically dragged
+		// with the parent waypoint
+		addLast(chkAddAddis=new CheckBox(MyLocale.getMsg(193,&quot;add Addis&quot;)),HSTRETCH,HFILL);
+		chkAddAddis.setToolTip(MyLocale.getMsg(186,&quot;Also drag Addi Wpts&quot;));
+		// Finally button to apply the list as a filter
+		addLast(btnFilter=new Button(MyLocale.getMsg(189,&quot;Apply List&quot;)),HSTRETCH,HFILL);btnFilter.modify(Disabled,0);
+		btnFilter.setToolTip(MyLocale.getMsg(190,&quot;Show only these waypoints&quot;));
+	}
+    /** Flag to ensure the initial message &quot;Caches hierher ziehen&quot; is cleared
+     * when the first cache is dragged into the list */
+	private boolean needsInit=true;
+	/** The actual list. This is mirrored by cacheList */
+	private myList lstCaches;
+	/** True if there are unsaved changes */
+	private boolean dirty=false;
+	// The UI elements
+	private Label lblTitle;
+	private CheckBox chkAddAddis;
+	private Button btnDown, btnUp, btnLoad, btnNew, btnSave, btnSaveAs, btnFilter;
+	/** This list mirrors the items in the list of selected caches for faster access. When the
+     * list of selected caches is manipulated (btnUp, btnDown), this list is also kept up to date
+     */
+	private Vector cacheList=new Vector(20);
+	/** The full filename of the current file */
+	private String currFile=null;
+
+	private class myList extends eve.ui.List {
+		myList(int rows, int columns, boolean multi) {
+			super(rows,columns,multi);
+			modify(WantDrag,0);
+		}
+
+		//  Allow the caches to be dragged out of the cachelist
+		//String wayPoint;
+		int idx;
+
+		public void startDragging(DragContext dc) {
+			 idx=getSelectedIndex(0);
+			 if (idx&gt;=0) {
+				 CacheHolder ch=(CacheHolder)cacheList.get(idx);
+				 //wayPoint=ch.wayPoint;
+				 IconAndText imgDrag=new IconAndText();
+				 imgDrag.addColumn( CacheType.cache2Img(ch.type));
+				 imgDrag.addColumn(ch.wayPoint);
+				 dc.dragData=dc.startImageDrag(imgDrag,new Point(8,8),this);
+			 }
+		}
+
+		public void dragged(DragContext dc) {
+			 	dc.imageDrag();
+		}
+
+		public void stopDragging(DragContext dc) {
+			 dc.stopImageDrag(true);
+			 Point p = Gui.getPosInParent(this,getWindow(),null);
+			 p.x += dc.curPoint.x;
+			 p.y += dc.curPoint.y;
+			 Control c = getWindow().findChild(p.x,p.y);
+		     if (!(c instanceof myList)) {
+		    	 // target is not myList =&gt; Remove dragged cache from list
+		    	 cacheList.removeElementAt(idx);
+		    	 lstCaches.deleteItem(idx);
+		    	 repaint();
+		    	 changeUpDownButtonStatus();
+		     }
+		 }
+
+		// Alternative method of deleting a cache from the list through
+		// Keyboard interface
+		public void onKeyEvent(KeyEvent ev) {
+			/* This is a bit of a hack. By default eve sends key events to
+			 * this panel. So if the list has not had anything dragged into it,
+			 * we redirect the focus to the list view, assuming that that is where
+			 * the key event needs to go.
+			 */
+			if (needsInit &amp;&amp; ev.target==this) {
+				Gui.takeFocus(Global.mainTab.tbP.tControl, Control.ByKeyboard);
+				ev.target=Global.mainTab.tbP.tControl;
+				postEvent(ev);
+			}
+			if (ev.type == KeyEvent.KEY_PRESS &amp;&amp; ev.target == this){
+				if (ev.key == IKeys.DELETE &amp;&amp; cacheList.size()&gt;0) {
+			    	 idx=getSelectedIndex(0);
+					 cacheList.removeElementAt(idx);
+			    	 lstCaches.deleteItem(idx);
+			    	 repaint();
+			    	 changeUpDownButtonStatus();
+				}
+			}
+			super.onKeyEvent(ev);
+		}
+		public ScrollablePanel getScrollablePanel() {
+			dontAutoScroll = amScrolling = true;
+			ScrollBarPanel sp = new MyScrollBarPanel(this);
+			sp.modify(0,TakeControlEvents);
+			return sp;
+		}
+
+
+	} //******************* myList
+
+	/** Simple sort to ensure that the main list keeps the order of this list */
+	private class mySort implements eve.util.Comparer{
+		public int compare(Object o1, Object o2){
+			CacheHolder oo1 = (CacheHolder)o1;
+			CacheHolder oo2 = (CacheHolder)o2;
+			return oo1.sort.compareTo(oo2.sort);
+		}
+	}
+
+	/** Enable the up/down buttons only if at least 2 caches are in the list */
+	private void changeUpDownButtonStatus() {
+		btnUp.modify(0,Disabled);
+		if (needsInit || lstCaches.itemsSize()&lt;2 || lstCaches.getSelectedIndex(0)==0) btnUp.modify(Disabled,0);
+		btnDown.modify(0,Disabled);
+		if (needsInit || lstCaches.itemsSize()&lt;2 || lstCaches.getSelectedIndex(0)==lstCaches.itemsSize()-1) btnDown.modify(Disabled,0);
+		btnUp.repaintNow();
+		btnDown.repaintNow();
+		// Need at least 2 caches in list to enable it
+		btnFilter.modify(0,Disabled);
+		if (needsInit || lstCaches.itemsSize()&lt;2) btnFilter.modify(Disabled,0);
+		btnFilter.repaintNow();
+	}
+
+	public void onEvent(Event ev) {
+		if (ev instanceof MenuEvent &amp;&amp; ev.type==MenuEvent.SELECTED) {
+			if (lstCaches.itemsSize()&gt;0 &amp;&amp; !needsInit) {
+				int lstCacheIdx=lstCaches.getSelectedIndex(0);
+				CacheHolder ch=(CacheHolder)cacheList.get(lstCacheIdx);
+				int idx=Global.getProfile().cacheDB.indexOf(ch);
+				// Ensure that the main view is updated with the selected cache, i.e.
+				// DetailsPanel, HintLog, Pictures etc.
+				int activeTab=Global.mainTab.cardPanel.selectedItem;
+				if (activeTab==0) {
+					// Select the cache also in the main list view
+					Global.mainTab.tbP.selectRow(idx);
+					Global.mainTab.tbP.tControl.repaint();
+				} else {
+					// We need to change to the list view first to load a new cache
+					Global.mainTab.onEvent(new MultiPanelEvent(0,Global.mainTab,0));
+					Global.mainTab.tbP.selectRow(idx);
+					Global.mainTab.onEvent(new MultiPanelEvent(0,Global.mainTab,activeTab));
+				}
+			}
+		}
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
+			if (ev.target==btnNew) {
+				newCacheList();
+			} else if(ev.target == btnLoad){
+				FileChooser fc = new FileChooser(FileChooser.OPEN, Global.getProfile().dataDir);
+				//fc.addMask(currCh.wayPoint + &quot;.wl&quot;);
+				fc.addMask(&quot;*.&quot;+EXTENSION);
+				fc.addMask(&quot;*.*&quot;);
+				fc.title=MyLocale.getMsg(191,&quot;Select File&quot;);
+				if(fc.execute() != FileChooser.IDCANCEL){
+					currFile = fc.getChosen();
+					readFromFile(currFile);
+				}
+			} else if((ev.target == btnSave) &amp;&amp; (currFile != null)){
+				saveToFile(currFile);
+			} else if((ev.target == btnSaveAs)||((ev.target == btnSave) &amp;&amp; (currFile == null))){
+				FileChooser fc = new FileChooser(FileChooser.SAVE, Global.getProfile().dataDir);
+				//fc.addMask(currCh.wayPoint + &quot;.wl&quot;);
+				fc.addMask(&quot;*.&quot;+EXTENSION);
+				fc.title=MyLocale.getMsg(191,&quot;Select File&quot;);
+				if(fc.execute() != FileChooser.IDCANCEL){
+					currFile = fc.getChosen();
+					if (currFile.indexOf('.')==0 || !currFile.toUpperCase().endsWith(&quot;.&quot;+EXTENSION)) currFile+=&quot;.&quot;+EXTENSION;
+					saveToFile(currFile);
+				}
+			} else if (ev.target==btnUp) {
+				int sel=lstCaches.getSelectedIndex(0);
+				if (sel&gt;0) {
+					dirty=true;
+					// Swap items in hidden list
+					Object swap=cacheList.get(sel-1);
+					cacheList.setElementAt(cacheList.get(sel),sel-1);
+					cacheList.setElementAt(swap,sel);
+					// Swap items in visible cachelist and repaint
+					swap=lstCaches.items.get(sel-1);
+					lstCaches.items.setElementAt(lstCaches.items.get(sel),sel-1);
+					lstCaches.items.setElementAt(swap,sel);
+					lstCaches.repaintDataNow();
+					lstCaches.select(sel-1);
+				}
+			} else if (ev.target==btnDown) {
+				int sel=lstCaches.getSelectedIndex(0);
+				if (sel&lt;lstCaches.itemsSize()-1) {
+					dirty=true;
+					// Swap items in hidden list
+					Object swap=cacheList.get(sel+1);
+					cacheList.setElementAt(cacheList.get(sel),sel+1);
+					cacheList.setElementAt(swap,sel);
+					// Swap items in visible cachelist and repaint
+					swap=lstCaches.items.get(sel+1);
+					lstCaches.items.setElementAt(lstCaches.items.get(sel),sel+1);
+					lstCaches.items.setElementAt(swap,sel);
+					lstCaches.repaintDataNow();
+					lstCaches.select(sel+1);
+				}
+			} else if (ev.target==btnFilter) {
+				applyCacheList();			}
+		}
+		changeUpDownButtonStatus();
+	}
+
+	/** Apply the cache list */
+	public void applyCacheList() {
+		Global.getProfile().selectionChanged = true;
+		Vector cacheDB=Global.getProfile().cacheDB;
+		CacheHolder ch;
+		int wrongBlackStatus=0;
+		String apply=&quot;\uFFFF&quot;+Convert.toString(applyCount++);
+		// Start by setting all caches to filtered
+		for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+			ch = (CacheHolder)cacheDB.get(i);
+			ch.is_filtered=true ; // ignore blacklist attribute
+			ch.sort=apply;
+		}
+		// Now &quot;unfilter&quot; the caches in our list
+		for (int i = cacheList.size()-1; i&gt;=0; i--) {
+			ch = (CacheHolder)cacheList.get(i);
+			/* If the cache was reloaded from a GPX file since we dragged it into the list,
+			   the pointer ch points to a CacheHolder object that is no longer part of cacheDB.
+			   In this case we need to search the cacheDB for an object with the name of ch.wayPoint
+			   and use that object. To speed up this process and avoid having to search the whole
+			   cacheDB for each entry in cacheList, we simply compare the sort field of ch to apply.
+			*/
+			if (!ch.sort.equals(apply)) {
+				int idx=Global.getProfile().getCacheIndex(ch.wayPoint);
+				if (idx==-1) continue;
+				ch=null;
+				ch=(CacheHolder) cacheDB.get(idx);
+			}
+			if (ch.is_black!=Global.getProfile().showBlacklisted)
+				wrongBlackStatus++;
+			else {
+				ch.is_filtered=false;
+				ch.sort=MyLocale.formatLong(i,&quot;00000&quot;);
+			}
+		}
+		// The sort command places all filtered caches at the end
+		eve.util.Utils.sort(new Handle(),cacheDB, new mySort(),false);
+		Global.getProfile().filterActive=Filter.FILTER_CACHELIST;
+		Global.getProfile().filterInverted=false;
+		Global.getProfile().hasUnsavedChanges=true;
+		updateScreen(cacheList.size()-wrongBlackStatus);
+		if (wrongBlackStatus&gt;0)
+			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;),MyLocale.getMsg(4600,&quot;Some cache(s) cannot be shown because of wrong blacklist status&quot;), MessageBox.OKB)).execute();
+
+	}
+
+	/** Add a cache (and its addis) to the list
+	 * @return true if the cache is not already in lstCaches */
+	public boolean addCache(String wayPoint) {
+		// Check whether this is the first cache being added
+		if (needsInit)  {lstCaches.deleteItem(0);lstCaches.deleteItem(0);  needsInit=false; lstCaches.repaint(); }
+		int idx=Global.getProfile().getCacheIndex(wayPoint);
+		if (idx==-1) return false;
+		CacheHolder ch=(CacheHolder) Global.getProfile().cacheDB.get(idx);
+		boolean cachesAdded=false;
+		// Add main cache
+		cachesAdded|=addCache(ch);
+		// Add addis if user wants it
+		if (chkAddAddis.state &amp;&amp; ch.hasAddiWpt()) {
+			CacheHolder addiWpt;
+			for (int j=0; j&lt;ch.addiWpts.size();j++){
+				addiWpt = (CacheHolder)ch.addiWpts.get(j);
+				if (!addiWpt.is_filtered) cachesAdded|=addCache(addiWpt);
+			}
+		}
+		// Update screen if any cache was added
+		if (cachesAdded) {
+			lstCaches.select(lstCaches.itemsSize()-1);
+			changeUpDownButtonStatus();
+		}
+		return cachesAdded;
+	}
+
+	/** Add a cache to the visible and invisible list */
+	private boolean addCache(CacheHolder ch) {
+		if (cacheList.indexOf(ch)&lt;0) {
+			// Add cache reference to hidden list
+			cacheList.add(ch);
+			// Add Cache and cache icon to visible list
+			lstCaches.addItem((new MenuItem()).iconize(ch.wayPoint+&quot;   &quot;+ch.cacheName,CacheType.cache2Img(ch.type),true));
+		    dirty=true;
+			return true;
+		}
+		return false;
+	}
+
+	void updateScreen(int numRows) {
+		Global.mainTab.tbP.tModel.numRows=numRows;
+		// Check whether the currently selected cache is still visible
+		//selectRow(getSelectedCache());
+		Global.mainTab.tbP.tControl.update(true); // Update and repaint
+		if (Global.mainTab.tbP.statBar!=null) Global.mainTab.tbP.statBar.updateDisplay();
+		int selPanel;
+		if ((selPanel=Global.mainTab.cardPanel.selectedItem)&gt;-1) {
+			if (selPanel==1) {
+				//postEvent(new MultiPanelEvent(MultiPanelEvent.SELECTED,Global.mainTab,1));
+				Global.mainTab.detP.repaint();
+			}
+		}
+	}
+
+	/** Check if there are any unsaved changes and ask user if he wants to save */
+	public void saveIfDirty() {
+		if (dirty) {
+			if ((new MessageBox(MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(192,&quot;Save changes&quot;),MessageBox.MBYESNO)).execute()==MessageBox.IDYES) {
+				if (currFile!=null)
+					saveToFile(currFile);
+				else {
+					FileChooser fc = new FileChooser(FileChooser.SAVE, Global.getProfile().dataDir);
+					fc.addMask(&quot;*.&quot;+EXTENSION);
+					fc.title=MyLocale.getMsg(191,&quot;Select File&quot;);
+					if(fc.execute() != FileChooser.IDCANCEL){
+						currFile = fc.getChosen();
+						saveToFile(currFile);
+					}
+				}
+			}
+		}
+		dirty=false;
+	}
+
+	/** Clear the cachelist (save unsaved changes if needed) */
+	private void newCacheList() {
+		saveIfDirty();
+		lstCaches.items.clear();
+		cacheList.clear();
+		lstCaches.repaint();
+		lblTitle.setText(TITLE);
+		currFile=null;
+	}
+
+	/** Read a list of caches */
+	private void readFromFile(String fileName) {
+		if (needsInit)  {lstCaches.deleteItem(0);lstCaches.deleteItem(0);  needsInit=false; }
+		int select=-1;
+		try {
+			BufferedReader in = new BufferedReader(new FileReader(fileName));
+			String wayPoint;
+			int idx;
+			Vector cacheDB=Global.getProfile().cacheDB;
+			int lineNr=0;
+			while ((wayPoint = in.readLine()) != null){
+				wayPoint=wayPoint.trim();
+				// Select the cache starting with &gt;
+				if (wayPoint.startsWith(&quot;&gt;&quot;)) {
+					wayPoint=wayPoint.substring(1);
+					select=lineNr;
+				}
+				// Only add the cache if it is in this profile
+				idx=Global.getProfile().getCacheIndex(wayPoint);
+				if (idx&gt;=0) {
+					addCache((CacheHolder) cacheDB.get(idx));
+				}
+				lineNr++;
+			}
+			in.close();
+		} catch(Exception e) {
+			Global.getPref().log(&quot;Problem reading: &quot; +fileName,e,true);
+		}
+		if (select&gt;-1)
+			lstCaches.select(select);
+		else
+		    lstCaches.select(lstCaches.itemsSize()-1);
+		lstCaches.repaint();
+		this.postEvent(new MenuEvent(MenuEvent.SELECTED,this,null));
+		changeUpDownButtonStatus();
+		setTitle(fileName);
+		dirty=false;
+	}
+
+	/** Save the cachelist */
+	private void saveToFile(String fileName) {
+		int selectedIndex=lstCaches.getSelectedIndex(0);
+		try {
+			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(fileName)));
+			for (int i=0; i&lt;cacheList.size(); i++) {
+				// Put a &gt; in front of the selected cache
+				outp.print((i==selectedIndex?&quot;&gt;&quot;:&quot;&quot;)+((CacheHolder)cacheList.get(i)).wayPoint+&quot;\n&quot;);
+			}
+			outp.close();
+		} catch(Exception e) {
+			Global.getPref().log(&quot;Problem saving: &quot; +fileName,e,true);
+		}
+		setTitle(fileName);
+		dirty=false;
+	}
+
+	/** Set the title */
+	private void setTitle(String fileName) {
+		String localFileName=fileName.replace('\\','/');
+		// Delete the path preceding the filename
+		if (localFileName.lastIndexOf('/')&gt;0)
+			localFileName=localFileName.substring(localFileName.lastIndexOf('/')+1);
+		// Drop the extension
+		if (localFileName.indexOf('.')&gt;0)
+			lblTitle.setText(localFileName.substring(0,localFileName.indexOf('.')));
+		else
+			lblTitle.setText(localFileName);
+		lblTitle.repaint();
+	}
+}

Added: experiments/EVE/src/cachewolf/CacheType.java
===================================================================
--- experiments/EVE/src/cachewolf/CacheType.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/CacheType.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,315 @@
+/**
+ * This class contains the waypoint types. To add a new waypoint, you only need to modify this file
+ */
+package cachewolf;
+
+import eve.fx.Picture;
+import eve.sys.Vm;
+
+
+/**
+ * @author Kalle
+ * Class for dealing with different cachetypes from gc and oc
+ */
+
+/**
+*	Listing of types and mappings
+*	
+*	OC		GC		Comment		Regel
+*	1		8		Other			1-&gt;8
+*	2		2		Traditional		2-&gt;2
+*	3		3		Multi			3-&gt;3
+*	4		4		Virtual		4-&gt;4
+*	5		11		Webcam		5-&gt;11
+*	6		6		Event			6-&gt;6
+*	7		8		Quiz			7-&gt;8
+*	8		??		Math			8-&gt;108 (ok)
+*	9		??		Moving		9-&gt;109 (ok)
+*	10		??		Drive-In		10-&gt;110 (ok)
+*/
+
+public class CacheType {
+	public static final Picture cachePictures[] = new Picture[454]; // Pictures are used by TableControl
+	public static final int WHERIGO=200; // The cache we mapped the wherigo to
+	static {
+		cachePictures[0] = new Picture(&quot;0.png&quot;);
+		//cachePictures[1] = new Picture();
+		cachePictures[2] = new Picture(&quot;2.png&quot;);
+		cachePictures[3] = new Picture(&quot;3.png&quot;);
+		cachePictures[4] = new Picture(&quot;4.png&quot;);
+		cachePictures[5] = new Picture(&quot;5.png&quot;);
+		cachePictures[6] = new Picture(&quot;6.png&quot;);
+		cachePictures[8] = new Picture(&quot;8.png&quot;);
+		//cachePictures[9] = new Picture();
+		//cachePictures[10] = new Picture();
+		cachePictures[11] = new Picture(&quot;11.png&quot;);
+		cachePictures[12] = new Picture(&quot;12.png&quot;);
+		cachePictures[13] = new Picture(&quot;13.png&quot;);
+		//additional waypoints, begin with 50
+		cachePictures[50] = new Picture(&quot;pkg.png&quot;);
+		cachePictures[51] = new Picture(&quot;stage.png&quot;);
+		cachePictures[52] = new Picture(&quot;puzzle.png&quot;);
+		cachePictures[53] = new Picture(&quot;flag.png&quot;);
+		cachePictures[54] = new Picture(&quot;trailhead.png&quot;);
+		cachePictures[55] = new Picture(&quot;waypoint.png&quot;);
+
+		cachePictures[108] = new Picture(&quot;108.png&quot;);
+		cachePictures[109] = new Picture(&quot;109.png&quot;);
+		cachePictures[110] = new Picture(&quot;110.png&quot;);
+		cachePictures[137] = new Picture(&quot;137.png&quot;);
+		cachePictures[WHERIGO] = new Picture(&quot;1858.png&quot;);  // Fudge as whereigo is really 1858
+		cachePictures[453] = new Picture(&quot;453.png&quot;);
+	}
+
+	//Types from gc.com
+	static protected final int GC_TRADITIONAL = 2;
+	static protected final int GC_MULTI = 3;
+	static protected final int GC_VIRTUAL = 4;
+	static protected final int GC_LETTERBOX = 5;
+	static protected final int GC_EVENT = 6;
+	static protected final int GC_UNKNOWN = 8;
+	static protected final int GC_WEBCAM = 11;
+	static protected final int GC_LOCATIONLESS = 12;
+	static protected final int GC_CITO = 13;
+	static protected final int GC_EARTH = 137;
+	static protected final int GC_MEGA_EVENT = 453;
+	// additional waypoints have no numbers in GPX Files, so lets use our own.
+	static protected final int GC_AW_PARKING = 50;
+	static protected final int GC_AW_STAGE_OF_MULTI = 51;
+	static protected final int GC_AW_QUESTION = 52;
+	static protected final int GC_AW_FINAL = 53;
+	static protected final int GC_AW_TRAILHEAD = 54;
+	static protected final int GC_AW_REFERENCE = 55;
+	
+	//Types from oc.de
+	static protected final int OC_UNKNOWN = 1;
+	static protected final int OC_TRADITIONAL = 2;
+	static protected final int OC_MULTI = 3;
+	static protected final int OC_VIRTUAL = 4;
+	static protected final int OC_WEBCAM = 5;
+	static protected final int OC_EVENT = 6;
+	static protected final int OC_QUIZ = 7;
+	static protected final int OC_MATH = 8;
+	static protected final int OC_MOVING = 9;
+	static protected final int OC_DRIVE_IN = 10;
+	
+	//Our own mapping
+	static protected final int CW_TRADITIONAL = 2;
+	static protected final int CW_MULTI = 3;
+	static protected final int CW_VIRTUAL = 4;
+	static protected final int CW_LETTERBOX = 5;
+	static protected final int CW_EVENT = 6;
+	static protected final int CW_QUIZ = 7;
+	static protected final int CW_UNKNOWN = 8;
+	static protected final int CW_MATH = 8;
+	static protected final int CW_MOVING = 9;
+	static protected final int CW_DRIVE_IN = 10;
+	static protected final int CW_WEBCAM = 11;
+	static protected final int CW_LOCATIONLESS = 12;
+	static protected final int CW_CITO = 13;
+	static protected final int CW_EARTH = 137;
+	static protected final int CW_MEGA_EVENT = 453;
+	static protected final int CW_WHERIGO = 1858;
+	static protected final int CW_PARKING = 50;
+	static protected final int CW_STAGE_OF_MULTI = 51;
+	static protected final int CW_QUESTION = 52;
+	static protected final int CW_FINAL = 53;
+	static protected final int CW_TRAILHEAD = 54;
+	static protected final int CW_REFERENCE = 55;
+	static protected final int CW_CNT_TYPES = 20;
+
+	//Sources
+	static protected final int SRC_GC = 1;
+	static protected final int SRC_OC = 2;
+	static protected final int SRC_CW = 3;
+
+	//pictures
+	static protected final String CW_PIC_UNKNOWN = &quot;8.png&quot;;
+	static protected final String CW_PIC_TRADITIONAL = &quot;2.png&quot;;
+	static protected final String CW_PIC_MULTI = &quot;3.png&quot;;
+	static protected final String CW_PIC_VIRTUAL = &quot;4.png&quot;;
+	static protected final String CW_PIC_WEBCAM = &quot;11.png&quot;;
+	static protected final String CW_PIC_EVENT = &quot;6.png&quot;;
+	static protected final String CW_PIC_QUIZ = &quot;8.png&quot;;
+	static protected final String CW_PIC_MATH = &quot;108.png&quot;;
+	static protected final String CW_PIC_MOVING = &quot;109.png&quot;;
+	static protected final String CW_PIC_DRIVE_IN = &quot;110.png&quot;;
+	static protected final String CW_PIC_LETTERBOX = &quot;5.png&quot;;
+	static protected final String CW_PIC_LOCATIONLESS = &quot;12.png&quot;;
+	static protected final String CW_PIC_CITO = &quot;13.png&quot;;
+	static protected final String CW_PIC_EARTH = &quot;137.png&quot;;
+	static protected final String CW_PIC_MEGA_EVENT = &quot;453.png&quot;;
+	static protected final String CW_PIC_WHERIGO = &quot;1858.png&quot;;
+	static protected final String CW_PIC_PARKING = &quot;pkg.png&quot;;
+	static protected final String CW_PIC_STAGE_OF_MULTI = &quot;stage.png&quot;;
+	static protected final String CW_PIC_QUESTION = &quot;puzzle.png&quot;;
+	static protected final String CW_PIC_FINAL = &quot;flag.png&quot;;
+	static protected final String CW_PIC_TRAILHEAD = &quot;trailhead.png&quot;;
+	static protected final String CW_PIC_REFERENCE = &quot;waypoint.png&quot;;
+	
+
+	
+	// array with names and types for exporters
+	public final static int WPT_TEXT = 0;
+	public final static int WPT_NUM = 1;
+
+	public static final String[] wayType = {&quot;Custom&quot;,&quot;Traditional&quot;,
+			&quot;Multi&quot;,&quot;Virtual&quot;,
+			&quot;Letterbox&quot;,&quot;Event&quot;,
+			&quot;Mega Event&quot;,&quot;Mystery&quot;,
+			&quot;Webcam&quot;,&quot;Locationless&quot;,
+			&quot;CITO&quot;,&quot;Earthcache&quot;,&quot;WhereIGo&quot;,
+			&quot;Addi: Parking&quot;,&quot;Addi: Stage&quot;,
+			&quot;Addi: Question&quot;,&quot;Addi: Final&quot;,
+			&quot;Addi: Trailhead&quot;,&quot;Addi: Reference&quot;};
+	public static final int [] wayTypeNo={0,2,3,4,5,6,453,8,11,12,13,137,1858,50,51,52,53,54,55};
+	
+	public static final String[] wayTypeList() {
+		String [] list=new String[wayType.length];
+		for (int j = 0; j &lt; wayType.length; j++) {
+			list[j]=wayType[j];
+		}
+		return list;
+	}
+	
+	/**
+	 * For a given waypoint type, return the position in waytype
+	 * @param waypointType The waypoint type (e.g. &quot;12&quot;)
+	 * @return
+	 */
+	public static int getWayTypePos(int waypointType) {
+		for (int j = 0; j &lt; wayType.length; j++) {
+			if (waypointType==wayTypeNo[j]) return j;
+		}
+		return -1;
+	}
+
+	public static String transType(int geoNum){
+		String geo = &quot;Unknown&quot;;
+		if(geoNum==2) geo = &quot;Traditional Cache&quot;;
+		if(geoNum==3) geo = &quot;Multi-cache&quot;;
+		if(geoNum==4) geo = &quot;Virtual Cache&quot;;
+		if(geoNum==5) geo = &quot;Letterbox Hybrid&quot;;
+		if(geoNum==6) geo = &quot;Event Cache&quot;;
+		if(geoNum==11) geo = &quot;Webcam Cache&quot;;
+		if(geoNum==8) geo = &quot;Unknown Cache&quot;;
+		if(geoNum==12) geo = &quot;Locationless Cache&quot;;
+		if(geoNum==13) geo = &quot;Cache In Trash Out Event&quot;;
+		if(geoNum==137) geo = &quot;Earthcache&quot;;
+		if(geoNum==453) geo = &quot;Mega Event Cache&quot;;
+		if(geoNum==1858) geo = &quot;WhereIGo Cache&quot;;
+		if(geoNum==50) geo = &quot;Parking Area&quot;;
+		if(geoNum==51) geo = &quot;Stages of a Multicache&quot;;
+		if(geoNum==52) geo = &quot;Question to Answer&quot;;
+		if(geoNum==53) geo = &quot;Final Location&quot;;
+		if(geoNum==54) geo = &quot;Trailhead&quot;;
+		if(geoNum==55) geo = &quot;Reference Point&quot;;
+		return geo;
+	}
+	
+	/**
+	 * Returns the image name of a given internal type
+	 * @param type Type of cache
+	 * @return The image name of the cache
+	 */
+	public static String type2pic(int type) {
+		switch(type) {
+			case CW_TRADITIONAL:	return CW_PIC_TRADITIONAL;
+			case CW_MULTI:			return CW_PIC_MULTI;
+			case CW_VIRTUAL:		return CW_PIC_VIRTUAL;
+			case CW_LETTERBOX:		return CW_PIC_LETTERBOX;
+			case CW_EVENT:			return CW_PIC_EVENT;
+			case CW_QUIZ:			return CW_PIC_QUIZ;
+			case CW_UNKNOWN:		return CW_PIC_UNKNOWN;
+			case CW_MOVING:			return CW_PIC_MOVING;
+			case CW_DRIVE_IN:		return CW_PIC_DRIVE_IN;
+			case CW_WEBCAM:			return CW_PIC_WEBCAM;
+			case CW_LOCATIONLESS:	return CW_PIC_LOCATIONLESS;
+			case CW_CITO:			return CW_PIC_CITO;
+			case CW_EARTH:			return CW_PIC_EARTH;
+			case CW_MEGA_EVENT:		return CW_PIC_MEGA_EVENT;
+			case CW_WHERIGO:	    return CW_PIC_WHERIGO;
+			case CW_PARKING:		return CW_PIC_PARKING;
+			case CW_STAGE_OF_MULTI:	return CW_PIC_STAGE_OF_MULTI;
+			case CW_QUESTION:		return CW_PIC_QUESTION;
+			case CW_FINAL:			return CW_PIC_FINAL;
+			case CW_TRAILHEAD:		return CW_PIC_TRAILHEAD;
+			case CW_REFERENCE:		return CW_PIC_REFERENCE;
+			default:		return &quot;no_picture.png&quot;;
+		}
+	}
+
+	public static boolean isAddiWpt(int type){
+		if (type==50) return true;
+		if (type==51) return true;
+		if (type==52) return true;
+		if (type==53) return true;
+		if (type==54) return true;
+		if (type==55) return true;
+		return false;
+	}
+
+	public static int typeText2Number(String typeText){
+		if (typeText.equals(&quot;Traditional Cache&quot;) || typeText.equals(&quot;Traditional&quot;)|| typeText.equals(&quot;Classic&quot;)) return 2;
+		if (typeText.equals(&quot;Multi-cache&quot;) || typeText.equals(&quot;Multi&quot;) || typeText.equals(&quot;Offset&quot;)) return 3;
+		if (typeText.equals(&quot;Virtual Cache&quot;) || typeText.equals(&quot;Virtual&quot;)) return 4;
+		if (typeText.equals(&quot;Letterbox Hybrid&quot;)) return 5;
+		if (typeText.equals(&quot;Event Cache&quot;) || typeText.equals(&quot;Event&quot;)) return 6;
+		if (typeText.equals(&quot;Unknown Cache&quot;) || typeText.equals(&quot;Other&quot;) || typeText.equals(&quot;Quiz&quot;)) return 8;
+		if (typeText.equals(&quot;Webcam Cache&quot;) || typeText.equals(&quot;Webcam&quot;)) return 11;
+		if (typeText.equals(&quot;Locationless (Reverse) Cache&quot;)) return 12;
+		if (typeText.equals(&quot;Cache In Trash Out Event&quot;)) return 13;
+		if (typeText.equals(&quot;Earthcache&quot;) || typeText.equals(&quot;Earth&quot;)) return 137;
+		if (typeText.equals(&quot;Mega-Event Cache&quot;)) return 453;
+		if (typeText.equals(&quot;Wherigo Cache&quot;)) return 1858;
+		if (typeText.equals(&quot;Waypoint|Parking Area&quot;)) return 50;
+		if (typeText.equals(&quot;Waypoint|Stages of a Multicache&quot;)) return 51;
+		if (typeText.equals(&quot;Waypoint|Question to Answer&quot;)) return 52;
+		if (typeText.equals(&quot;Waypoint|Final Coordinates&quot;)||typeText.equals(&quot;Waypoint|Final Location&quot;)) return 53;
+		if (typeText.equals(&quot;Waypoint|Trailhead&quot;)) return 54;
+		if (typeText.equals(&quot;Waypoint|Reference Point&quot;)) return 55;
+		Vm.debug(&quot;Unknown Cache Type:&quot; + typeText);
+		return 0;
+	}
+
+	/**
+		*	Method to translate opencaching types to geocaching types.
+		*	Required to be &quot;backwards&quot; compatible :-(
+		*	OC		GC		Comment		Regel
+		*	1		8		Other			1-&gt;8
+		*	2		2		Traditional		2-&gt;2
+		*	3		3		Multi			3-&gt;3
+		*	4		4		Virtual		4-&gt;4
+		*	5		11		Webcam		5-&gt;11
+		*	6		6		Event			6-&gt;6
+		*	7		8		Quiz			7-&gt;8
+		*	8		??		Math			8-&gt;108 (ok)
+		*	9		??		Moving		9-&gt;109 (ok)
+		*	10		??		Drive-In		10-&gt;110 (ok)
+		*/
+		public static int transOCType(int type){
+			if(type==1) return 8;
+			if(type==2) return 2;
+			if(type==3) return 3;	
+			if(type==4) return 4;
+			if(type==5) return 11;
+			if(type==6) return 6;
+			if(type==7) return 8;
+			if(type==8|| type==9 ||type==10) return 8;
+	/* Not supported at the moment
+			if(type8) return &quot;108&quot;;
+			if(type9) return &quot;109&quot;;
+			if(type10) return &quot;110&quot;;
+	*/
+			//no match found? return custom type!
+			return 0;
+		}
+
+		
+	public static Picture cache2Img(int cacheType) {
+		if (cacheType==1858)
+			return cachePictures[WHERIGO];
+		return cachePictures[cacheType]; // TODO save in cacheholder as int
+	}
+
+}

Added: experiments/EVE/src/cachewolf/CacheWolf.java
===================================================================
--- experiments/EVE/src/cachewolf/CacheWolf.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/CacheWolf.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,94 @@
+package cachewolf; // REV 1332 / 1360
+
+import eve.ui.data.*;
+import eve.ui.*;
+import eve.sys.*;
+/**
+*	This is the application starter class.
+*	It startes the eve VM and creates the main form that displays
+*	the user interface.
+*	@param 	null	no parameters required.
+*	@return null	does not return any return codes
+*	@see			MainForm
+*	@author	 Marc Schnitzler
+*	@version version of this class, Date: date of release of the version of the class
+*/
+
+
+public class CacheWolf extends Editor{
+
+
+	public static void main(String vmArgs[])
+	{
+		//start with parameters:
+		//args[0]: spider
+		//args[1]: distance
+		Application.startApplication(vmArgs);
+		Gui.screenIs(Gui.PDA_SCREEN);
+		//eve.io.File f=new eve.io.File(&quot;c:/TEMP/&quot;);
+		//String [] files=f.listMultiple(&quot;*.*;*.zip;*.pdf&quot;,eve.io.File.LIST_DIRECTORIES_ONLY);
+		//Gui.screenIs(Gui.PDA_SCREEN)
+		/*if (Device.isMobile() &amp;&amp; MyLocale.getScreenHeight() &gt;= 400) {
+			Font defaultGuiFont = Application.findFont(&quot;gui&quot;);
+			int sz = 10; //(int)(defaultGuiFont.getSize());
+			Font newGuiFont = new Font(defaultGuiFont.getName(), defaultGuiFont.getStyle(), sz);
+			Application.addFont(newGuiFont, &quot;gui&quot;);
+			Application.mainApp.font = newGuiFont;
+			Application.fontsChanged();
+
+		}*/
+		if (Gui.screenIs(Gui.PDA_SCREEN) &amp;&amp; Device.isMobile()) {
+			//TODO Vm.setSIP(Vm.SIP_LEAVE_BUTTON);
+		}
+
+        // get program command line parameters and switches
+        String[] args = vmArgs; // Vm.getProgramArguments(); &lt;-- only works in eclipse, but mixes the letters in the ewe-vm (tested in ewe-1.49 on win xp)
+        String configfile = null;
+        boolean debug = false;
+        if(args.length &gt; 0){
+                if(args[0].equals(&quot;test&quot;)){
+                        Test t=new Test();
+                        t.testAll();
+                }
+                for (int i=0; i &lt; args.length ; i++) {
+                        Vm.debug(&quot;prog: &quot; + args[i]);
+                        Vm.debug(&quot;vm: &quot; + vmArgs[i]);
+                        if (args[i] != null &amp;&amp; args[i].length() &gt; 1 &amp;&amp;
+                                        (args[i].startsWith(&quot;-&quot;) || args[i].startsWith(&quot;/&quot;)) ) {
+                                String c = args[i].substring(1, args[i].length());
+                                if (c.equalsIgnoreCase(&quot;c&quot;)) {
+                                        if (i &lt; args.length -1 ) {
+                                                configfile = args[i+1];
+                                                i++;
+                                        } else {
+                                                (new MessageBox(&quot;Error&quot;, MyLocale.getMsg(7200, &quot;Usage: CacheWolf [-c &lt;path to pref.xml&gt;] [-debug]&quot;), MessageBox.OKB)).execute();
+                                                // return usage info
+                                                eve.sys.Vm.exit(1);
+                                        }
+                                }
+                                if (c.equalsIgnoreCase(&quot;debug&quot;)) {
+                                        //Vm.debug(&quot;d&quot;);
+                                        debug = true;
+                                }
+
+                        }
+                }
+        }
+        if (debug) {
+            Vm.debug(&quot;prg-args: &quot; + args.length);
+            Vm.debug(&quot;vm-args: &quot; + vmArgs.length);
+        }
+
+		MainForm mainF = new MainForm(debug,configfile);
+		Device.preventIdleState(true);
+		mainF.execute();
+		Device.preventIdleState(false);
+		Application.exit(0);
+	}
+
+}
+
+// for javadoc see: <A HREF="http://java.sun.com/j2se/javadoc/writingdoccomments/index.html#exampleresult">http://java.sun.com/j2se/javadoc/writingdoccomments/index.html#exampleresult</A>
+// or the local files &quot;JavaDoc&quot; directory
+// Javadoc Main Page: <A HREF="http://java.sun.com/j2se/javadoc/index.jsp">http://java.sun.com/j2se/javadoc/index.jsp</A>
+// javadoc -classpath eve.jar -d &quot;cachewolf doc&quot; cachewolf/*.java

Added: experiments/EVE/src/cachewolf/CalcPanel.java
===================================================================
--- experiments/EVE/src/cachewolf/CalcPanel.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/CalcPanel.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,218 @@
+package cachewolf;
+
+import eve.ui.*;
+import eve.ui.formatted.TextDisplay;
+
+import cachewolf.utils.Common;
+
+
+import eve.fx.Dimension;
+import eve.fx.FontMetrics;
+import eve.sys.Event;
+import eve.ui.event.ControlEvent;
+
+/**
+*	Class to create the panel to do calculation with waypoints&lt;br&gt;
+*	Also allows for creation of a custom waypoint.&lt;br&gt;
+*	Class ID 1400
+*/
+
+/**
+ * Wrapper class to pass bearing and distance
+ */
+class BearingDistance {
+	public double degrees;
+	public double distance;
+
+	public BearingDistance(){
+		this.degrees = 0;
+		this.distance = 0;
+	}
+
+	public BearingDistance(double degrees, double distance) {
+		this.degrees = degrees;
+		this.distance = distance;
+	}
+}
+
+public class CalcPanel extends CellPanel {
+
+	CheckBox chkDMM, chkDMS, chkDD, chkUTM, chkGK;
+	CheckBoxGroup chkFormat = new CheckBoxGroup();
+	Choice chcDistUnit;
+	Input inpBearing, inpDistance;
+	TextDisplay txtOutput;
+	Button btnCalc, btnClear, btnSave, btnGoto;
+	BearingDistance bd = new BearingDistance();
+	CWPoint coordInp = new CWPoint();
+	CWPoint coordOut = new CWPoint();
+	// Needed for creation of new waypoint
+	MainTab mainT;
+	// different panels to avoid spanning
+	CellPanel TopP = new CellPanel();
+	CellPanel BottomP = new CellPanel();
+	String lastWaypoint = &quot;&quot;;
+
+	int currFormat;
+	Button btnChangeLatLon;
+
+	public CalcPanel()	{
+		mainT = Global.mainTab;
+
+		TopP.addNext(chkDD =new CheckBox(&quot;d.d&#176;&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addNext(chkDMM =new CheckBox(&quot;d&#176;m.m\'&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addNext(chkDMS =new CheckBox(&quot;d&#176;m\'s\&quot;&quot;),CellConstants.DONTSTRETCH,CellConstants.WEST);
+		TopP.addNext(chkUTM =new CheckBox(&quot;UTM&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addLast(chkGK =new CheckBox(&quot;GK&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
+
+		chkDD.setGroup(chkFormat);
+		chkDMM.setGroup(chkFormat);
+		chkDMS.setGroup(chkFormat);
+		chkUTM.setGroup(chkFormat);
+		chkGK.setGroup(chkFormat);
+		chkFormat.setInt(CWPoint.DMM);
+		btnChangeLatLon=new Button();
+		TopP.addLast(btnChangeLatLon,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		//inpBearing and direction, unit for inpDistance
+		BottomP.addNext(new Label(MyLocale.getMsg(1403,&quot;Bearing&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		BottomP.addLast(new Label(MyLocale.getMsg(1404,&quot;Distance&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		BottomP.addNext(inpBearing = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		inpBearing.setText(&quot;0&quot;);
+		BottomP.addNext(inpDistance = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		inpDistance.setText(&quot;0&quot;);
+		// Check for narrow screen and reduce width of fields to avoid horizontal scroll panel
+		if (MyLocale.getScreenWidth()&lt;=240) {
+			FontMetrics fm = getFontMetrics(inpBearing.getFont());
+			inpBearing.setPreferredSize(fm.getTextWidth(&quot;99999999&quot;),fm.getHeight()*4/3);
+			inpDistance.setPreferredSize(fm.getTextWidth(&quot;99999999&quot;),fm.getHeight()*4/3);
+		}
+		BottomP.addLast(chcDistUnit = new Choice(new String[]{&quot;m&quot;, &quot;km&quot;,MyLocale.getMsg(1407,&quot;steps&quot;), MyLocale.getMsg(1408,&quot;feet&quot;), MyLocale.getMsg(1409,&quot;yards&quot;), MyLocale.getMsg(1410,&quot;miles&quot;)},0),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST)).setTag(CellConstants.TAG_INSETS,new eve.fx.Insets(0,2,0,0));
+		chcDistUnit.setInt(0);
+
+		// Buttons for calc and save
+		BottomP.addNext(btnCalc = new Button(&quot;Calc&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		BottomP.addNext(btnClear = new Button(&quot;Clear&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		BottomP.addNext(btnGoto = new Button(&quot;Goto&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		BottomP.addLast(btnSave = new Button(MyLocale.getMsg(311,&quot;Create Waypoint&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+
+		// Output
+		txtOutput = new TextDisplay(3,1); // Need to limit size for small screens
+		ScrollBarPanel sbp = new MyScrollBarPanel(txtOutput);
+		BottomP.addLast(sbp.setTag(Control.TAG_SPAN, new Dimension(4,1)),CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
+
+		//add Panels
+		this.addLast(TopP,CellConstants.HSTRETCH, CellConstants.WEST);//.setTag(TAG_SPAN,new Dimension(4,1));
+		this.addLast(BottomP,CellConstants.VSTRETCH, CellConstants.VFILL|CellConstants.WEST); //.setTag(TAG_SPAN,new Dimension(4,1));
+
+	}
+
+	public void readFields(CWPoint coords, BearingDistance degKm, int format){
+		coords.set(btnChangeLatLon.getText());
+		currFormat = chkFormat.getSelectedIndex();
+		degKm.degrees = Common.parseDouble(inpBearing.getText());
+
+		double rawDistance = Common.parseDouble(inpDistance.getText());
+		switch ( chcDistUnit.getInt() ) {
+		case 0:
+			// meter
+			degKm.distance = rawDistance / 1000.0;
+			break;
+		case 1:
+			// kilometer
+			degKm.distance = rawDistance;
+			break;
+		case 2:
+			// steps
+			degKm.distance = rawDistance * 0.00063;
+			break;
+		case 3:
+			// feet
+			degKm.distance = rawDistance * 0.0003048;
+			break;
+		case 4:
+			// yards
+			degKm.distance = rawDistance * 0.0009144;
+			break;
+		case 5:
+			// miles
+			degKm.distance = rawDistance * 1.609344;
+			break;
+		default:
+			// meter
+			degKm.distance = rawDistance / 1000.0;
+			break;
+		}
+		return;
+	}
+
+	// ch must be not null
+	public void setFields(CacheHolder ch){
+        if ( !ch.wayPoint.equalsIgnoreCase(lastWaypoint) ) {
+            lastWaypoint = ch.wayPoint;
+            if (ch.pos.isValid()) {
+                    inpBearing.setText(&quot;0&quot;);
+                    inpDistance.setText(&quot;0&quot;);
+
+                    currFormat = CWPoint.DMM;
+                    if (ch.latLon.length()== 0) coordInp.set(0,0);
+                    else coordInp.set(ch.latLon, CWPoint.CW);
+                    setFields(coordInp, CWPoint.DMM);
+            }
+    }
+	}
+
+
+	public void setFields(CWPoint coords, int format) {
+		if (format == CWPoint.CW) format = CWPoint.DMM;
+		btnChangeLatLon.setText(coords.toString(format));
+		chkFormat.selectIndex(format);
+	}
+
+
+	public void onEvent(Event ev){
+
+		//Vm.debug(ev.toString());
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (ev.target == chkFormat){
+				readFields(coordInp,bd, currFormat);
+				setFields(coordInp, currFormat);
+				this.repaintNow();
+			}
+
+			if (ev.target == btnCalc){
+				readFields(coordInp, bd, currFormat);
+				coordOut = coordInp.project(bd.degrees, bd.distance);
+				txtOutput.appendText(coordOut.toString(currFormat)+ &quot;\n&quot;,true);
+			}
+			if (ev.target == btnClear){
+				txtOutput.setText(&quot;&quot;);
+			}
+			if (ev.target == btnSave){
+				CacheHolder ch = new CacheHolder();
+				readFields(coordInp, bd, currFormat);
+				coordOut = coordInp.project(bd.degrees, bd.distance);
+				ch.latLon = coordOut.toString();
+				ch.pos.set(coordOut);
+				ch.type = 51; // see CacheType.GC_AW_STAGE_OF_MULTI // TODO unfertig
+				mainT.newWaypoint(ch);
+			}
+
+			if (ev.target == btnGoto){
+				readFields(coordInp, bd, currFormat);
+				coordOut = coordInp.project(bd.degrees, bd.distance);
+				mainT.gotoPoint(coordOut);
+			}
+			if (ev.target == btnChangeLatLon){
+				CoordsScreen cs = new CoordsScreen();
+				readFields(coordInp, bd, currFormat);
+				cs.setFields(coordInp,currFormat);
+				if (cs.execute()== CoordsScreen.IDOK){
+					btnChangeLatLon.setText(cs.getCoords().toString(currFormat));
+					coordInp.set(cs.getCoords());
+				}
+			}
+
+		}
+		super.onEvent(ev);
+	}
+}

Added: experiments/EVE/src/cachewolf/CenterScreen.java
===================================================================
--- experiments/EVE/src/cachewolf/CenterScreen.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/CenterScreen.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,90 @@
+package cachewolf;
+
+
+import eve.ui.*;
+import eve.sys.*;
+import eve.ui.event.ControlEvent;
+
+/**
+*	This form displays profile specific data.
+*	It allows the copying of the current centre to the profile centre
+*/
+public class CenterScreen extends Form {
+
+	private Button btnOK, btnCurrentCentre, btnProfileCentre, btnCur2Prof, btnProf2Cur;
+	Preferences pref;
+	Profile profile;
+	CellPanel content = new CellPanel();
+
+	/**
+	*/
+	public CenterScreen(Preferences p, Profile prof){
+		super();
+		pref=p;
+		profile=prof;
+		
+    	resizable =  false;
+		content.setText(MyLocale.getMsg(1115,&quot;Centre&quot;));
+		content.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_RECT;
+	    //defaultTags.set(this.TAG_INSETS,new Insets(2,2,2,2));		
+		title = MyLocale.getMsg(1118,&quot;Profile&quot;)+&quot;: &quot;+profile.name;
+		content.addNext(new Label(MyLocale.getMsg(1116,&quot;Current&quot;)));
+		content.addLast(btnCurrentCentre=new Button(pref.curCentrePt.toString()),HSTRETCH,HFILL|LEFT);
+		content.addNext(new Label(&quot;      &quot;),HSTRETCH,HFILL);
+		content.addNext(btnCur2Prof=new Button(&quot;   v   &quot;),DONTSTRETCH,DONTFILL|LEFT);
+		content.addNext(new Label(MyLocale.getMsg(1117,&quot;copy&quot;)));
+		content.addLast(btnProf2Cur=new Button(&quot;   ^   &quot;),DONTSTRETCH,DONTFILL|RIGHT);
+		content.addNext(new Label(MyLocale.getMsg(1118,&quot;Profile&quot;)));
+		content.addLast(btnProfileCentre=new Button(profile.centre.toString()),HSTRETCH,HFILL|LEFT);
+		addLast(content,HSTRETCH,HFILL);
+		addLast(new Label(&quot;&quot;),VSTRETCH,FILL);
+		//addNext(btnCancel = new Button(MyLocale.getMsg(1604,&quot;Cancel&quot;)),DONTSTRETCH,DONTFILL|LEFT);
+		addLast(btnOK = new Button(&quot;OK&quot;),DONTSTRETCH,HFILL|RIGHT);
+	}
+	
+	/**
+	*	The event handler to react to a users selection.
+	*	A return value is created and passed back to the calling form
+	*	while it closes itself.
+	*/
+	public void onEvent(Event ev){
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			/*if (ev.target == btnCancel){
+				close(-1);
+			}*/
+			if (ev.target == btnOK){
+				close(1);
+			}
+			if (ev.target == btnCurrentCentre){
+				CoordsScreen cs = new CoordsScreen();
+				cs.setFields(pref.curCentrePt, CWPoint.CW);
+				if (cs.execute()== CoordsScreen.IDOK){
+					pref.curCentrePt.set(cs.getCoords());
+					btnCurrentCentre.setText(pref.curCentrePt.toString());
+					Global.getProfile().updateBearingDistance();
+				}
+			}
+			if (ev.target == btnProfileCentre){
+				CoordsScreen cs = new CoordsScreen();
+				cs.setFields(profile.centre, CWPoint.CW);
+				if (cs.execute()== CoordsScreen.IDOK){
+					profile.centre.set(cs.getCoords());
+					btnProfileCentre.setText(profile.centre.toString());
+					profile.hasUnsavedChanges=true;
+				}
+			}
+			if (ev.target == btnCur2Prof){
+				profile.centre.set(pref.curCentrePt);
+				btnProfileCentre.setText(profile.centre.toString());
+				profile.hasUnsavedChanges=true;
+			}
+			if (ev.target == btnProf2Cur){
+				pref.curCentrePt.set(profile.centre);
+				btnCurrentCentre.setText(pref.curCentrePt.toString());
+				Global.getProfile().updateBearingDistance();
+			}
+		}
+		super.onEvent(ev);
+	}
+
+}

Added: experiments/EVE/src/cachewolf/CoordsScreen.java
===================================================================
--- experiments/EVE/src/cachewolf/CoordsScreen.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/CoordsScreen.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,310 @@
+package cachewolf;
+
+import cachewolf.imp.SpiderGC;
+import cachewolf.navi.Navigate;
+import cachewolf.utils.STRreplace;
+import eve.ui.*;
+import eve.fx.Dimension;
+import eve.sys.*;
+import eve.ui.event.*;
+import eve.fx.gui.IKeys;
+
+/**
+*	Class for entering coordinates&lt;br&gt;
+*/
+
+
+public class CoordsScreen extends Form {
+
+	CheckBox chkDMM, chkDMS, chkDD, chkUTM, chkGK;
+	CheckBoxGroup chkFormat = new CheckBoxGroup();
+	Choice chcNS, chcEW;
+	Input inpNSDeg, inpNSm, inpNSs, inpEWDeg, inpEWm, inpEWs;
+	Input inpUTMZone, inpUTMNorthing, inpUTMEasting;
+	Input inpText;
+	Button btnCancel, btnApply, btnCopy, btnPaste, btnParse, btnGps, btnClear;
+	CWPoint coordInp = new CWPoint();
+	CellPanel topLinePanel = new CellPanel();
+	CellPanel mainPanel = new CellPanel();
+	int exitKeys[]={75009};
+	int currFormat;
+
+	private boolean allowInvalid = false;
+
+	public CoordsScreen(boolean allowInvalidCoords){
+		allowInvalid = allowInvalidCoords;
+		InitCoordsScreen();
+	}
+
+	public CoordsScreen() {
+		InitCoordsScreen();
+	}
+
+	private void InitCoordsScreen() {
+		this.title=&quot;&quot;;
+		//Radiobuttons for format
+		topLinePanel.addNext(chkDD =new CheckBox(&quot;d.d&#176;&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		topLinePanel.addNext(chkDMM =new CheckBox(&quot;d&#176;m.m\'&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		topLinePanel.addNext(chkDMS =new CheckBox(&quot;d&#176;m\'s\&quot;&quot;),CellConstants.DONTSTRETCH,CellConstants.WEST);
+		topLinePanel.addNext(chkUTM =new CheckBox(&quot;UTM&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		topLinePanel.addLast(chkGK =new CheckBox(&quot;GK&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
+
+		chkDD.setGroup(chkFormat); chkDD.exitKeys=exitKeys;
+		chkDMM.setGroup(chkFormat);chkDMM.exitKeys=exitKeys;
+		chkDMS.setGroup(chkFormat);chkDMS.exitKeys=exitKeys;
+		chkUTM.setGroup(chkFormat);chkUTM.exitKeys=exitKeys;
+		chkGK.setGroup(chkFormat);chkGK.exitKeys=exitKeys;
+
+		this.addLast(topLinePanel,CellConstants.DONTSTRETCH, CellConstants.WEST);
+
+		// Input for degrees
+		mainPanel.addNext(chcNS = new Choice(new String[]{&quot;N&quot;, &quot;S&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		chcNS.setInt(0);
+		mainPanel.addNext(inpNSDeg = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(inpNSm = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addLast(inpNSs = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+
+		mainPanel.addNext(chcEW = new Choice(new String[]{&quot;E&quot;, &quot;W&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		chcEW.setInt(0);
+		mainPanel.addNext(inpEWDeg = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(inpEWm = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addLast(inpEWs = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+
+		// Input for UTM
+		mainPanel.addNext(new Label(MyLocale.getMsg(1400,&quot;Zone&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(new Label(MyLocale.getMsg(1402,&quot;Easting&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		if (allowInvalid) {
+			mainPanel.addNext(new Label(MyLocale.getMsg(1401,&quot;Northing&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			mainPanel.addLast(btnClear = new Button(MyLocale.getMsg(1413,&quot;Clear&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
+		} else {
+			mainPanel.addLast(new Label(MyLocale.getMsg(1401,&quot;Northing&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		}
+		mainPanel.addNext(inpUTMZone = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(inpUTMEasting = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(inpUTMNorthing = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addLast(btnGps = new Button(&quot;GPS&quot;),CellConstants.HSTRETCH, (CellConstants.HFILL));
+
+		mainPanel.addLast(new Label(MyLocale.getMsg(1405,&quot;To load coordinates from GC, enter GCxxxxx below&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL)).setTag(TAG_SPAN,new Dimension(4,1));
+			// Input for free Text
+		mainPanel.addNext(inpText = new Input(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		inpText.toolTip=MyLocale.getMsg(1406,&quot;Enter coordinates in any format or GCxxxxx&quot;);
+		inpText.setTag(TAG_SPAN,new Dimension(3,1));
+		mainPanel.addLast(btnParse = new Button(MyLocale.getMsg(619,&quot;Parse&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
+
+		// Buttons for cancel and apply, copy and paste
+		btnCancel = new Button(MyLocale.getMsg(614,&quot;Cancel&quot;));
+		btnCancel.setHotKey(0, IKeys.ESCAPE);
+		mainPanel.addNext(btnCancel,CellConstants.HSTRETCH, (CellConstants.HFILL));
+		//btnCancel.setTag(TAG_SPAN,new Dimension(4,1));
+		mainPanel.addNext(btnApply = new Button(MyLocale.getMsg(615,&quot;Apply&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
+		//btnApply.setTag(TAG_SPAN,new Dimension(4,1));
+		mainPanel.addNext(btnPaste = new Button(MyLocale.getMsg(617,&quot;Paste&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
+		//btnParse.setTag(TAG_SPAN,new Dimension(4,1));
+		mainPanel.addLast(btnCopy = new Button(MyLocale.getMsg(618,&quot;Copy&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
+		//btnCopy.setTag(TAG_SPAN,new Dimension(4,1));
+		chcNS.exitKeys=exitKeys; chcEW.exitKeys=exitKeys;
+		//add Panels
+		this.addLast(mainPanel,CellConstants.DONTSTRETCH, CellConstants.WEST);
+		chcNS.takeFocus(Control.ByKeyboard);
+	}
+
+	public void activateFields(int format){
+		inpEWDeg.wantReturn=false; inpEWm.wantReturn=false; inpEWs.wantReturn=false; inpUTMNorthing.wantReturn=false;
+		switch (format){
+			case CWPoint.DD:
+				enable(chcNS); enable(inpNSDeg); disable(inpNSm); disable(inpNSs);
+				enable(chcEW); enable(inpEWDeg); disable(inpEWm); disable(inpEWs);
+				inpEWDeg.wantReturn=true;
+				disable(inpUTMZone); disable(inpUTMNorthing); disable(inpUTMEasting);
+				break;
+			case CWPoint.CW:
+			case CWPoint.DMM:
+				enable(chcNS); enable(inpNSDeg); enable(inpNSm); disable(inpNSs);
+				enable(chcEW); enable(inpEWDeg); enable(inpEWm); disable(inpEWs);
+				inpEWm.wantReturn=true;
+				disable(inpUTMZone); disable(inpUTMNorthing); disable(inpUTMEasting);
+				break;
+			case CWPoint.DMS:
+				enable(chcNS); enable(inpNSDeg); enable(inpNSm); enable(inpNSs);
+				enable(chcEW); enable(inpEWDeg); enable(inpEWm); enable(inpEWs);
+				inpEWs.wantReturn=true;
+				disable(inpUTMZone); disable(inpUTMNorthing); disable(inpUTMEasting);
+				break;
+			case CWPoint.UTM:
+				disable(chcNS); disable(inpNSDeg); disable(inpNSm); disable(inpNSs);
+				disable(chcEW); disable(inpEWDeg); disable(inpEWm); disable(inpEWs);
+				enable(inpUTMZone); enable(inpUTMNorthing); enable(inpUTMEasting);
+				inpUTMNorthing.wantReturn=true;
+	 			break;
+			case CWPoint.GK:
+				disable(chcNS); disable(inpNSDeg); disable(inpNSm); disable(inpNSs);
+				disable(chcEW); disable(inpEWDeg); disable(inpEWm); disable(inpEWs);
+				disable(inpUTMZone); enable(inpUTMNorthing); enable(inpUTMEasting);
+				inpUTMNorthing.wantReturn=true;
+	 			break;
+		}
+
+		this.stretchLastColumn = true;
+		this.stretchLastRow = true;
+		this.repaintNow();
+	}
+
+	private void enable(Control c) {c.modify(ControlConstants.TakesKeyFocus,ControlConstants.Disabled); }
+	private void disable(Control c) {c.modify(ControlConstants.Disabled,ControlConstants.TakesKeyFocus); }
+
+	public void readFields(CWPoint coords, int format){
+		String NS, EW;
+		if (format == CWPoint.UTM)
+			coords.set(inpUTMZone.getText(),
+					   inpUTMNorthing.getText(), inpUTMEasting.getText());
+		else if (format == CWPoint.GK) {
+			coords.set(inpUTMEasting.getText(), inpUTMNorthing.getText());
+		}
+		else {
+			NS = chcNS.getInt()== 0?&quot;N&quot;:&quot;S&quot;;
+			EW = chcEW.getInt()== 0?&quot;E&quot;:&quot;W&quot;;
+			coords.set(NS, inpNSDeg.getText(), inpNSm.getText(), inpNSs.getText(),
+							 EW, inpEWDeg.getText(), inpEWm.getText(), inpEWs.getText(),
+							 format);
+		}
+
+		return;
+	}
+	public void setFields(CWPoint coords, int format) {
+		if (format == CWPoint.CW) format = CWPoint.DMM;
+		if (format == CWPoint.UTM){
+			inpUTMZone.setText(coords.getUTMZone());
+			inpUTMNorthing.setText(coords.getUTMNorthing());
+			inpUTMEasting.setText((coords.getUTMEasting()));
+		}
+		else if (format == CWPoint.GK){
+			inpUTMZone.setText(&quot;&quot;);
+			if (coords.isValid()){
+				inpUTMNorthing.setText(coords.getGKNorthing(0));
+				inpUTMEasting.setText((coords.getGKEasting(0)));
+			}
+			else {
+				inpUTMNorthing.setText(&quot;0&quot;);
+				inpUTMEasting.setText(&quot;0&quot;);
+			}
+		}
+		else {
+			chcNS.setInt(coords.getNSLetter().equals(&quot;N&quot;)?0:1);
+			chcEW.setInt(coords.getEWLetter().equals(&quot;E&quot;)?0:1);
+
+			inpNSDeg.setText(STRreplace.replace(coords.getLatDeg(format),&quot;-&quot;,&quot;&quot;));
+			inpNSm.setText(coords.getLatMin(format));
+			inpNSs.setText(coords.getLatSec(format));
+
+			inpEWDeg.setText(STRreplace.replace(coords.getLonDeg(format),&quot;-&quot;,&quot;&quot;));
+			inpEWm.setText(coords.getLonMin(format));
+			inpEWs.setText(coords.getLonSec(format));
+		}
+		chkFormat.selectIndex(format);
+		inpText.setText(coords.toString(format));
+		currFormat = format;
+		activateFields(format);
+	}
+
+	public CWPoint getCoords(){
+		return coordInp;
+	}
+
+
+	public void onEvent(Event ev){
+
+		//Vm.debug(ev.toString());
+		// Ensure that the Enter key moves to the appropriate field
+		// for Checkboxes and Choice controls this is done via the exitKeys
+		// For input fields we use the wantReturn field
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.EXITED){
+			if (((ControlEvent)ev).target==chkDD || ((ControlEvent)ev).target==chkDMM ||
+			    ((ControlEvent)ev).target==chkDMS) Gui.takeFocus(chcNS,Control.ByKeyboard);
+			if (((ControlEvent)ev).target==chkUTM) Gui.takeFocus(inpUTMZone,Control.ByKeyboard);
+			if (((ControlEvent)ev).target==chkGK) Gui.takeFocus(inpUTMEasting,Control.ByKeyboard);
+			if (((ControlEvent)ev).target==chcNS) Gui.takeFocus(inpNSDeg,Control.ByKeyboard);
+			if (((ControlEvent)ev).target==chcEW) Gui.takeFocus(inpEWDeg,Control.ByKeyboard);
+		}
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (((ControlEvent)ev).target==inpEWDeg || ((ControlEvent)ev).target==inpEWm ||
+					((ControlEvent)ev).target==inpEWs || ((ControlEvent)ev).target==inpUTMNorthing) Gui.takeFocus(btnApply,Control.ByKeyboard);
+			if (ev.target == chkFormat){
+				readFields(coordInp, currFormat);
+				currFormat = chkFormat.getSelectedIndex();
+				setFields(coordInp, currFormat);
+				activateFields(currFormat);
+				this.repaintNow();
+			}
+
+			if (ev.target == btnCancel){
+				this.close(IDCANCEL);
+			}
+
+			if (ev.target == btnApply){
+				currFormat = chkFormat.getSelectedIndex();
+				readFields(coordInp, currFormat);
+				if (coordInp.isValid())
+					this.close(IDOK);
+				else {
+					if	( allowInvalid ) {
+						if ((new MessageBox(MyLocale.getMsg(144,&quot;Warnung&quot;),MyLocale.getMsg(1412,&quot;Coordinates invalid. Apply anyway?&quot;),FormBase.DEFOKB|FormBase.NOB)).execute() == FormBase.IDOK ) {
+							this.close(IDOK);
+						}
+					} else {
+						(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(1411,&quot;Please enter valid coordinates&quot;), FormBase.OKB)).execute();
+					}
+				}
+			}
+
+			if (ev.target == btnPaste){
+				inpText.setText(Vm.getClipboardText());
+			}
+
+			if (ev.target == btnCopy){
+				currFormat = chkFormat.getSelectedIndex();
+				readFields(coordInp, currFormat);
+				Vm.setClipboardText(coordInp.toString(chkFormat.getSelectedIndex()));
+			}
+
+			if (ev.target == btnParse){
+				// try to parse coords
+				CWPoint coord;
+				String inp=inpText.getText().trim().toUpperCase();
+				if (inp.startsWith(&quot;GC&quot;)) {
+					SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile(), false);
+					coord = new CWPoint(spider.getCacheCoordinates(inp));
+				} else {
+					coord = new CWPoint(inp);
+				}
+				if (coord.latDec == -91 &amp;&amp; coord.lonDec == -361){
+					MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(4111,&quot;Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM&quot;), MessageBox.OKB);
+					tmpMB.exec();
+				}else {
+					currFormat = chkFormat.getSelectedIndex();
+					setFields(coord,currFormat);
+					activateFields(currFormat);
+					this.repaintNow();
+				}
+			}
+
+			if (ev.target == btnGps){
+				Navigate nav=Global.mainTab.nav;
+				if (nav.gpsPos.isValid()){
+					CWPoint coord = nav.gpsPos;
+					currFormat = chkFormat.getSelectedIndex();
+					setFields(coord,currFormat);
+					activateFields(currFormat);
+				}
+			}
+			if (ev.target == btnClear){
+				CWPoint coord = new CWPoint(91,361);
+				currFormat = chkFormat.getSelectedIndex();
+				setFields(coord,currFormat);
+				activateFields(currFormat);
+			}
+		}
+		super.onEvent(ev);
+	}
+
+
+}

Added: experiments/EVE/src/cachewolf/DataMover.java
===================================================================
--- experiments/EVE/src/cachewolf/DataMover.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/DataMover.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,254 @@
+package cachewolf;
+
+import eve.ui.filechooser.FileChooser;
+import java.io.*;
+import eve.ui.*;
+import java.util.Vector;
+import eve.sys.*;
+
+
+/**
+*	This class moves or copies the database files of selected caches from one directory to
+*   another. It provides also the possibility to delete cachefiles.
+*/
+public class DataMover {
+
+	Vector srcDB;
+	Preferences pref;
+	Profile profile;
+
+	public DataMover(){
+		pref = Global.getPref();
+		profile=Global.getProfile();
+		srcDB = profile.cacheDB;
+	}
+	public void deleteCaches(){
+
+		MessageBox mBox = new MessageBox (MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(145,&quot;Cachedata of ALL VISIBLE caches will be deleted! Continue?&quot;), MessageBox.IDYES |MessageBox.IDNO);
+		if (mBox.execute() != MessageBox.IDOK){
+			return;
+		}
+		processCaches(new Deleter(MyLocale.getMsg(143, &quot;Delete&quot;)));
+		// write indexfiles
+		profile.saveIndex(Profile.NO_SHOW_PROGRESS_BAR);
+	}
+
+	public void copyCaches(){
+		Profile dstProfile=new Profile();
+
+		dstProfile.dataDir=selectTargetDir();
+		if (dstProfile.dataDir.equals(profile.dataDir) ||
+			dstProfile.dataDir.equals(&quot;&quot;)) return;
+		MessageBox mBox = new MessageBox (MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(146,&quot;Cachedata of ALL VISIBLE caches will be copied! Continue?&quot;), MessageBox.IDYES |MessageBox.IDNO);
+		if (mBox.execute() != MessageBox.IDOK){
+			return;
+		}
+
+		// Read indexfile of destination, if one exists
+		File ftest = new File(dstProfile.dataDir + &quot;index.xml&quot;);
+		if(ftest.exists()){
+			dstProfile.readIndex();
+		}
+		processCaches(new Copier(MyLocale.getMsg(141, &quot;Copy&quot;),dstProfile));
+		// write indexfiles and keep the filter status
+		dstProfile.saveIndex(Profile.NO_SHOW_PROGRESS_BAR);
+	}
+
+	public void moveCaches() {
+		Profile dstProfile=new Profile();
+
+		// Select destination directory
+		dstProfile.dataDir=selectTargetDir();
+		if (dstProfile.dataDir.equals(profile.dataDir) ||
+			dstProfile.dataDir.equals(&quot;&quot;)) return;
+
+		MessageBox mBox = new MessageBox (MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(147,&quot;Cachedata of ALL VISIBLE caches will be moved! Continue?&quot;), MessageBox.IDYES |MessageBox.IDNO);
+		if (mBox.execute() != MessageBox.IDOK){
+			return;
+		}
+
+		// Read indexfile of destination, if one exists
+		File ftest = new File(dstProfile.dataDir + &quot;index.xml&quot;);
+		if(ftest.exists()){
+			dstProfile.readIndex();
+		}
+		processCaches(new Mover(MyLocale.getMsg(142, &quot;Move&quot;),dstProfile));
+		// write indexfiles
+		dstProfile.saveIndex(Profile.NO_SHOW_PROGRESS_BAR);
+		profile.saveIndex(Profile.NO_SHOW_PROGRESS_BAR);
+	}
+
+	 /**
+	  * This function carries out the copy/delete/move with a progress bar.
+	  * The Executor class defines what operation is to be carried out.
+	  * @param exec
+	  */
+	 private void processCaches(Executor exec) {
+		 // First empty the cache so that the correct cache details are on disk
+		 CacheHolder.saveAllModifiedDetails();
+		int size=srcDB.size();
+		int count=0;
+		// Count the number of caches to move/delete/copy
+		for(int i = 0; i&lt;size; i++) {
+			if(((CacheHolder)srcDB.get(i)).is_filtered==false) count++;
+		}
+		myProgressBarForm pbf = new myProgressBarForm();
+		Handle h = new Handle();
+		pbf.setTask(h,exec.title);
+		pbf.exec();
+
+		int nProcessed=0;
+		// Now do the actual work
+		for(int i = size-1; i&gt;=0; i--){
+			CacheHolder srcHolder=(CacheHolder)srcDB.get(i);
+			if(srcHolder.is_filtered==false){
+				h.progress = ((float)nProcessed++)/(float)count;
+				h.changed();
+				//Now do the copy/delete/move of the cache
+				exec.doIt(i,srcHolder);
+			}
+			if (pbf.isClosed) break;
+		}
+		pbf.exit(0);
+	 }
+
+	 class myProgressBarForm extends ProgressBarForm {
+		 boolean isClosed=false;
+		 protected boolean canExit(int exitCode) {
+			isClosed=true;
+			return true;
+		 }
+	 }
+
+	//////////////////////////////////////////////////////////////////////
+	// Utility functions
+	//////////////////////////////////////////////////////////////////////
+
+	public String selectTargetDir() {
+		// Select destination directory
+		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, pref.baseDir);
+		fc.title=MyLocale.getMsg(148,&quot;Select Target directory&quot;);
+		if(fc.execute() != FormBase.IDCANCEL){
+			return fc.getChosen() + &quot;/&quot;;
+		}
+		return &quot;&quot;;
+	}
+
+	public void deleteCacheFiles(String wpt, String dir){
+		// delete files in dstDir to clean up trash
+		//TODO Remove FileBugfix
+		String tmp[] = (new eve.io.File(dir)).list(wpt + &quot;*.*&quot;, eve.io.File.LIST_FILES_ONLY);
+		for (int i=0; i &lt; tmp.length;i++){
+			File tmpFile = new File(dir + tmp[i]);
+			tmpFile.delete();
+		}
+	}
+
+	public void moveCacheFiles(String wpt, String srcDir, String dstDir){
+		String srcFiles[] = new eve.io.File(srcDir).list(wpt + &quot;*.*&quot;, eve.io.File.LIST_FILES_ONLY);
+		for (int i=0; i &lt; srcFiles.length;i++){
+			eve.io.File srcFile = new eve.io.File(srcDir + srcFiles[i]);
+			eve.io.File dstFile = new eve.io.File(dstDir + srcFiles[i]);
+			srcFile.move(dstFile);
+		}
+	}
+
+	public void copyCacheFiles(String wpt, String srcDir, String dstDir){
+		String srcFiles[] = new eve.io.File(srcDir).list(wpt + &quot;*.*&quot;, eve.io.File.LIST_FILES_ONLY);
+		for (int i=0; i &lt; srcFiles.length;i++){
+			copy(srcDir + srcFiles[i],dstDir + srcFiles[i]);
+		}
+	}
+
+	public static void copy( String sFileSrc, String sFileDst)
+	  {
+	    try {
+			java.io.File   fSrc = new java.io.File( sFileSrc );
+		    int    len  = 32768;
+		    byte[] buff = new byte[ (int)java.lang.Math.min( len, fSrc.length() ) ];
+		    java.io.FileInputStream  fis = new java.io.FileInputStream(  fSrc );
+		    java.io.FileOutputStream fos = new java.io.FileOutputStream( sFileDst);
+		    while( 0 &lt; (len = fis.read( buff )) )
+		      fos.write( buff, 0, len );
+		    fos.flush();
+		    fos.close();
+		    fis.close();
+	    }
+	    catch (Exception ex){
+	    	Vm.debug(&quot;Filecopy failed: &quot;+sFileSrc+&quot;=&gt;&quot;+sFileDst);
+	    }
+	}
+
+	//////////////////////////////////////////////////////////////////////
+	// Executor
+	//////////////////////////////////////////////////////////////////////
+
+	private abstract class Executor {
+		String title;
+		Profile dstProfile;
+		public void doIt(int i, CacheHolder srcHolder){}
+	}
+
+	private class Deleter extends Executor {
+		 Deleter(String title) {
+			 this.title=title;
+		 }
+		 public void doIt(int i,CacheHolder srcHolder) {
+			srcHolder.releaseCacheDetails();
+			deleteCacheFiles(srcHolder.wayPoint,profile.dataDir);
+			srcDB.removeElementAt(i);
+		 }
+	}
+
+	private class Copier extends Executor {
+		 Copier(String title, Profile dstProfile) {
+			 this.title=title;
+			 this.dstProfile=dstProfile;
+		 }
+		 public void doIt(int i,CacheHolder srcHolder) {
+			srcHolder.releaseCacheDetails();
+			// does cache exists in destDB ?
+			int dstPos = dstProfile.getCacheIndex(srcHolder.wayPoint);
+			if (dstPos &gt;= 0){
+				deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
+				copyCacheFiles(srcHolder.wayPoint,profile.dataDir, dstProfile.dataDir);
+				// Update database
+				dstProfile.cacheDB.setElementAt(srcHolder,dstPos);
+			}
+			else {
+				deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
+				copyCacheFiles(srcHolder.wayPoint,profile.dataDir, dstProfile.dataDir);
+				// Update database
+				dstProfile.cacheDB.add(srcHolder);
+			}
+		 }
+	}
+
+	private class Mover extends Executor {
+		 Mover(String title, Profile dstProfile) {
+			 this.title=title;
+			 this.dstProfile=dstProfile;
+		 }
+		 public void doIt(int i,CacheHolder srcHolder) {
+			// does cache exists in destDB ?
+			srcHolder.releaseCacheDetails();
+			int dstPos = dstProfile.getCacheIndex(srcHolder.wayPoint);
+			if (dstPos &gt;= 0){
+				deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
+				moveCacheFiles(srcHolder.wayPoint,profile.dataDir, dstProfile.dataDir);
+				// Update database
+				dstProfile.cacheDB.setElementAt(srcHolder,dstPos);
+				srcDB.removeElementAt(i);
+				i--;
+			}
+			else {
+				deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
+				moveCacheFiles(srcHolder.wayPoint,profile.dataDir, dstProfile.dataDir);
+				// Update database
+				dstProfile.cacheDB.add(srcHolder);
+				srcDB.removeElementAt(i);
+				i--;
+			}
+		 }
+	}
+}

Added: experiments/EVE/src/cachewolf/DateTimeChooser.java
===================================================================
--- experiments/EVE/src/cachewolf/DateTimeChooser.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/DateTimeChooser.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,518 @@
+package cachewolf;
+import eve.ui.*;
+import eve.fx.*;
+import eve.sys.*;
+import eve.ui.data.*;
+import eve.ui.table.*;
+import eve.ui.event.*;
+import eve.sys.Vm;
+
+public class DateTimeChooser extends Editor {
+
+	MultiPanel panels = new CardPanel();
+	
+	public int year;
+	public String monthName;
+	public int month;
+	public int day;
+	public int hour;
+	public int minute;
+	public String time;
+	
+	public boolean autoAdvance = true;
+	public boolean didAll = false;
+	private boolean hasTime; // True if the time can also be set
+	TableControl dayChooser, monthChooser, yearChooser,timeChooser;
+	TableModel tmYearChooser;
+	timeChooserTableModel tmTimeChooser;
+	public eve.sys.Locale locale = Vm.getLocale();
+	
+	//Control dayDisplay;
+	//Control monthDisplay;
+	//Control yearDisplay;
+	//Control timeDisplay;
+	//Control minuteDisplay;
+
+	Time getTime() {
+		Time t = (Time)dateSet.getCopy();
+		t.day = day;
+		t.month = month;
+		t.year = year;
+		t.hour = hour;
+		t.minute = minute;
+		t.update();
+		return t;
+		//return new Time(day,month,year);
+	}
+	
+	void addTable(TableControl tc,TableModel tm,String name) {
+		tc.setTableModel(tm);
+		tc.setClickMode(true);
+		panels.addItem(tc,name,null);
+	}
+	
+
+	Control addTopData(CellPanel cp,String field) {
+		Control dl = new Button();//DumbLabel(1,10);
+		cp.addNext(addField(dl,field),HSTRETCH,HFILL);
+		dl.addListener(this);
+		//dl.anchor = CENTER;
+		dl.modify(DrawFlat,0);
+		dl.borderStyle = BDR_OUTLINE|BF_TOP|BF_RIGHT|BF_SQUARE;
+		//if (!added) dl.borderStyle |= BF_LEFT;
+		dl.borderColor = Color.Black;
+		return dl;
+	}
+	
+	public String firstPanel = &quot;monthName&quot;;
+	
+	public void reset(Time t) {
+		setDate(t);
+		didAll = false;
+		newDate();
+		panels.select(firstPanel);
+	}
+	
+	public CellPanel addTopSection(CellPanel addTo,Control cp) {
+		int IconSize;
+		if (Device.isMobile() &amp;&amp; MyLocale.getScreenWidth() &gt;= 400)
+			IconSize = 20;
+		else
+			IconSize = 10;
+		addTo.modify(DrawFlat,0);
+		addTo.defaultTags.set(TAG_INSETS,new Insets(0,0,0,0));
+		Button b = new Button();
+		b.borderStyle = BDR_OUTLINE|BF_LEFT|BF_TOP|BF_RIGHT|BF_SQUARE;
+		b.image = new DrawnIcon(DrawnIcon.CROSS,IconSize,IconSize,new Color(0x80,0,0));
+		addTo.addNext(addField(b,&quot;reject&quot;)).setCell(DONTSTRETCH);
+		addTo.addNext(cp,HSTRETCH,HFILL);
+		b = new Button();
+		b.borderStyle = BDR_OUTLINE|BF_TOP|BF_RIGHT|BF_SQUARE;
+		b.image = new DrawnIcon(DrawnIcon.TICK,IconSize,IconSize,new Color(0,0x80,0));
+		addTo.addNext(addField(b,&quot;accept&quot;)).setCell(DONTSTRETCH);
+		return addTo;
+	}
+	
+	CardPanel cards = new CardPanel();
+	
+	public DateTimeChooser(Locale l, boolean hasTime) {
+		if (l != null) locale = l;
+		this.hasTime=hasTime;
+		setDate(new Time());
+		addLast(cards);
+		CellPanel addTo = new CellPanel();
+		cards.addItem(addTo,&quot;full&quot;,null);
+		
+		CellPanel cp = new CellPanel();
+		CellPanel top = new CellPanel();
+		cp.equalWidths = true;
+		firstPanel = &quot;day&quot;;
+		addTopData(cp,&quot;day&quot;); // dayDisplay
+		addTopData(cp,&quot;monthName&quot;); // monthDisplay
+		addTopData(cp,&quot;year&quot;); // yearDisplay
+		if (hasTime) addTopData(cp,&quot;time&quot;); // timDisplay
+		cp.endRow();
+	
+	
+		addTopSection(top,cp);
+		addTo.addLast(top).setCell(HSTRETCH);
+		addTo.addLast((Control)panels);	
+		
+		addTable(dayChooser = new TableControl(),new dayChooserTableModel(locale),&quot;day&quot;);
+		addTable(monthChooser = new TableControl(),new monthChooserTableModel(locale),&quot;monthName&quot;);
+		addTable(yearChooser = new TableControl(),tmYearChooser=new yearChooserTableModel(),&quot;year&quot;);
+		if (hasTime) addTable(timeChooser = new TableControl(),tmTimeChooser=new timeChooserTableModel(),&quot;time&quot;);
+/*	
+		Button b = new Button();
+		//b.borderStyle = BDR_OUTLINE|BF_LEFT|BF_TOP|BF_RIGHT|BF_SQUARE;
+		b.image = new DrawnIcon(DrawnIcon.CROSS,10,10,new Color(0x80,0,0));
+		addField(b,&quot;reject&quot;);
+		b.image = new DrawnIcon(DrawnIcon.CROSS,10,10,new Color(0x80,0,0));
+		b = new Button();
+		b.image = new DrawnIcon(DrawnIcon.TICK,10,10,new Color(0,0x80,0));
+		addField(b,&quot;accept&quot;);
+*/
+		newDate();
+	}
+	
+	public void fieldChanged(FieldTransfer ft,Editor ed) {
+		newDate();
+	}
+	
+	public void action(FieldTransfer ft,Editor ed) {
+		String n = ft.fieldName;
+		if (n.equals(&quot;day&quot;)||n.equals(&quot;monthName&quot;)||n.equals(&quot;year&quot;)||n.equals(&quot;time&quot;))
+			panels.select(n);
+		if (n.equals(&quot;accept&quot;) || n.equals(&quot;entered&quot;))
+			exit(IDOK);
+		if (n.equals(&quot;reject&quot;)) exit(IDCANCEL);
+	}
+	
+	public void onControlEvent(ControlEvent ev) {
+		if (ev instanceof TableEvent &amp;&amp; ev.type == TableEvent.CELL_CLICKED){
+			if (ev.target == dayChooser){
+				day = Convert.toInt((String)((TableEvent)ev).cellData);
+				newDate();
+				toControls(&quot;day&quot;);
+				if (autoAdvance &amp;&amp; !didAll) {
+					panels.select(&quot;monthName&quot;);
+				}
+			}else if (ev.target == monthChooser){
+				month = ((java.lang.Long)(((TableEvent)ev).cellData)).intValue();
+				newDate();
+				monthName = locale.getString(Locale.SHORT_MONTH,month,0);
+				toControls(&quot;monthName&quot;);
+				if (autoAdvance &amp;&amp; !didAll) {
+					panels.select(&quot;year&quot;);
+					didAll = true;
+				}
+			}else if (ev.target == yearChooser){
+				String p = (String) tmYearChooser.getCellData(((TableEvent)ev).row,((TableEvent)ev).col); 
+				int dec = year % 100;
+				year -= dec;
+				if (p.charAt(0) == 'C'){
+					if (p.charAt(1) == '+') year = year+100+dec;
+					else year = year-100+dec;
+				}else{
+					int val = Convert.toInt(p);
+					if (val &gt; 9) year = val*100;
+					else {
+						dec = dec*10+val;
+						year += dec%100;
+					}
+				}
+				newDate();
+				toControls(&quot;year&quot;);
+			}else if (ev.target == timeChooser){
+				int newHour=tmTimeChooser.getHourFor(((TableEvent)ev).row,((TableEvent)ev).col);
+				if (newHour&gt;-1) hour=newHour;
+				int newMinute=tmTimeChooser.getMinuteFor(((TableEvent)ev).row,((TableEvent)ev).col);
+				if (newMinute&gt;-1) minute=newMinute;
+				time=MyLocale.formatLong(hour,&quot;00&quot;)+&quot;:&quot;+MyLocale.formatLong(minute,&quot;00&quot;);
+				tmTimeChooser.set(hour,minute);
+				timeChooser.repaintNow();
+				newDate();
+				toControls(&quot;time&quot;);
+			}
+		}
+		if (ev.type == ControlEvent.CANCELLED) exit(IDCANCEL);
+		else super.onControlEvent(ev);
+	}
+	
+	Time dateSet;
+	
+	public void setDate(Time t) {
+		dateSet = t;
+		if (!t.isValid()) t = new Time();
+		//Time.toString(t,t instanceof TimeOfDay ? t.getFormat() : locale.getString(Locale.SHORT_DATE_FORMAT,0,0),locale);
+		day = t.day; month = t.month; year = t.year; hour=t.hour; minute=t.minute;
+		time=MyLocale.formatLong(hour,&quot;00&quot;)+&quot;:&quot;+MyLocale.formatLong(minute,&quot;00&quot;);
+		monthName = locale.getString(Locale.SHORT_MONTH,t.month,0);
+		toControls(&quot;day,month,year,monthName,time&quot;); 
+	}
+	
+	public void newDate() {
+		Time t = new Time(day,month,year); t.hour=hour; t.minute=minute;
+		Time t2 = t;
+		if (!t2.isValid()) t2 = new Time(day = 1,month,year);
+		if (!t2.isValid()) t2 = new Time();
+		if (t2 != t){
+			setDate(t2);
+		}
+		dayChooserTableModel dcm = (dayChooserTableModel)dayChooser.getTableModel();
+		dcm.set(day,month,year);
+		monthChooserTableModel mcm = (monthChooserTableModel)monthChooser.getTableModel();
+		mcm.set(day,month,year);
+		if (hasTime) {
+			timeChooserTableModel tcm = (timeChooserTableModel)timeChooser.getTableModel();
+			tcm.set(hour,minute);
+		}
+		//dayChooser.repaintNow();
+		//monthChooser.repaintNow();
+	}
+} // DateTimeChooser
+
+
+//-------------------------------------------------------
+class monthChooserTableModel extends TableModel {
+//-------------------------------------------------------
+	int chosenMonth;
+	Locale locale = Vm.getLocale();
+
+	monthChooserTableModel(Locale locale) {
+		this.locale = locale;
+		numRows = 3;
+		numCols = 4;
+		hasColumnHeaders = false;
+		hasRowHeaders = false;
+		fillToEqualHeights = fillToEqualWidths = true;
+	}
+	
+	void set(int day,int month,int year) {
+		int old = chosenMonth;
+		chosenMonth = month;
+		if (old != chosenMonth) refreshMonth(old);
+	}
+
+	int getMonthFor(int row,int cell) {
+		if (row == -1 || cell == -1) return 0;
+		int idx = row*4+cell;
+		return idx+1;
+	}
+
+	Point getCellFor(int month,Point dest) {
+		month--;
+		int row = (month/4)%3;
+		int col = month%4;
+		return Point.unNull(dest).set(col,row);
+	}
+
+	void refreshMonth(int month) {
+		Point p = getCellFor(month,null);
+		table.repaintCell(p.y,p.x);
+	}
+
+	public TableCellAttributes getCellAttributes(int row,int col,boolean isSelected,TableCellAttributes ta) {
+		ta.flat = true;
+		ta = super.getCellAttributes(row,col,isSelected,ta);
+		ta.borderStyle = fixBorder(UIConstants.BDR_OUTLINE|UIConstants.BF_BOTTOM|UIConstants.BF_RIGHT,row,col,true);
+		if (getMonthFor(row,col) == chosenMonth &amp;&amp; !isSelected){
+			ta.fillColor = new Color(0x80,0x80,0xff);
+		}
+		return ta;
+	}
+
+	public boolean getCellText(int row,int col,eve.util.StringList strList) {
+		strList.tryAdd(locale.getString(Locale.SHORT_MONTH,getMonthFor(row,col),0));
+		return true;
+	}
+
+	public Object getCellData(int row,int col) {
+		int month = getMonthFor(row,col);
+		return new java.lang.Long(month);
+	}
+}
+
+//-------------------------------------------------------
+class dayChooserTableModel extends TableModel {
+//-------------------------------------------------------
+	
+	java.util.Vector days = new java.util.Vector();
+	Locale locale = Vm.getLocale();
+	int firstDayIndex = 0;
+	int numDays = 28;
+	
+	int chosenDay = 0;
+	
+	
+	void set(int day,int month,int year) {
+		//eve.sys.Vm.debug(month+&quot;,&quot;+year);
+		numDays = Time.numberOfDays(month,year);
+		Time t = new Time(1,month,year);
+		firstDayIndex = Time.indexOfDayInWeek(t.dayOfWeek,locale)-1;
+		//eve.sys.Vm.debug(&quot;&quot;+firstDayIndex+&quot;, &quot;+numDays);
+		int oldDay = chosenDay;
+		chosenDay = day;
+		if (oldDay != chosenDay) refreshDay(oldDay);
+	}
+	
+	int getDayFor(int row,int cell) {
+		if (row == -1 || cell == -1) return 0;
+		int idx = row*7+cell;
+		if (idx &gt;= firstDayIndex &amp;&amp; idx &lt; firstDayIndex+numDays) return idx-firstDayIndex+1;
+		idx = idx+35;
+		if (idx &gt;= firstDayIndex &amp;&amp; idx &lt; firstDayIndex+numDays) return idx-firstDayIndex+1;
+		return 0;
+	}
+	
+	Point getCellFor(int day,Point dest) {
+		day += firstDayIndex-1;
+		int row = (day/7)%5;
+		int col = day%7;
+		return Point.unNull(dest).set(col,row);
+	}
+	
+	void refreshDay(int day) {
+		Point p = getCellFor(day,null);
+		table.repaintCell(p.y,p.x);
+	}
+	
+	public TableCellAttributes getCellAttributes(int row,int col,boolean isSelected,TableCellAttributes ta) {
+		ta.flat = true;
+		ta = super.getCellAttributes(row,col,isSelected,ta);
+		ta.borderStyle = fixBorder(UIConstants.BDR_OUTLINE|UIConstants.BF_BOTTOM|UIConstants.BF_RIGHT,row,col,true);
+		if (getDayFor(row,col) == chosenDay &amp;&amp; !isSelected){
+			ta.fillColor = new Color(0x80,0x80,0xff);
+		}
+		return ta;
+	}
+	
+	dayChooserTableModel(Locale l) {
+		this.locale = l;
+		numRows = 5;
+		numCols = 7;
+		hasColumnHeaders = true;
+		hasRowHeaders = false;
+		for (int i = 1; i&lt;=7; i++) days.add(l.getString(Locale.SHORT_DAY_OF_WEEK,i,0));
+	
+		fillToEqualHeights = fillToEqualWidths = true;
+	}
+	
+	public boolean canSelect(int row,int col) {
+		return (getDayFor(row,col) != 0);
+	}
+	
+	public Object getCellData(int row,int col) {
+		if (row == -1) 
+			return days.get(col);
+		int val = getDayFor(row,col);
+		if (val == 0) return null;
+		return Convert.toString(val);
+		
+	}
+	
+}
+
+
+//-------------------------------------------------------
+class yearChooserTableModel extends TableModel {
+//-------------------------------------------------------
+	
+	yearChooserTableModel() {
+		numRows = 4;
+		numCols = 4;
+		hasColumnHeaders = false;
+		hasRowHeaders = false;
+		fillToEqualWidths = true;
+		fillToEqualHeights = true;
+	}
+	String [] all = eve.util.mString.split(&quot;19xx|7|8|9|20xx|4|5|6|21xx|1|2|3|18xx|0|C+|C-&quot;);
+
+/*	public boolean getCellText(int row,int col,eve.util.StringList sl) {
+		if (row &gt;= 0 &amp;&amp; col &gt;= 0) {
+			sl.tryAdd(all[col+row*4]);
+			return true;
+		}
+		return false;
+	}
+*/	
+	
+	public Object getCellData(int row,int col) {
+		if (row &gt;= 0 &amp;&amp; col &gt;= 0) {
+			return all[col+row*4];
+		}
+		return null;
+	}	
+	
+	public TableCellAttributes getCellAttributes(int row,int col,boolean isSelected,TableCellAttributes ta) {
+		ta.flat = true;
+		ta = super.getCellAttributes(row,col,isSelected,ta);
+		return ta;
+	}
+
+}
+
+//-------------------------------------------------------
+class timeChooserTableModel extends TableModel {
+//	-------------------------------------------------------
+	int chosenHour=-2,chosenMinute=-2;
+	
+	timeChooserTableModel() {
+		numRows = 6;
+		numCols = 15;
+		hasColumnHeaders = false;
+		hasRowHeaders = false;
+		fillToEqualWidths = true;
+		fillToEqualHeights = true;
+	}
+	void set(int hour,int minute) {
+		int old = chosenHour;
+		chosenHour = hour;
+		if (old != chosenHour) refreshHour(old);
+		old = chosenMinute;
+		chosenMinute = minute;
+		if (old != chosenMinute) refreshMinute(old);
+	}
+
+	int getHourFor(int row,int cell) {
+		if (row == -1 || cell == -1) return 0;
+		if (cell&gt;=4) return -1;
+		return row*4+cell;
+	}
+
+	Point getCellForHour(int hour,Point dest) {
+		int row = (hour/4)%6;
+		int col = hour%4;
+		return Point.unNull(dest).set(col,row);
+	}
+
+	void refreshHour(int hour) {
+		Point p = getCellForHour(hour,null);
+		table.repaintCell(p.y,p.x);
+	}
+
+	int getMinuteFor(int row,int cell) {
+		if (row == -1 || cell == -1) return 0;
+		if (cell&lt;=4) return -1;
+		return row*10+cell-5;
+	}
+
+	Point getCellForMinute(int minute,Point dest) {
+		int row = (minute/10)%6;
+		int col = minute%10;
+		return Point.unNull(dest).set(col,row);
+	}
+
+	void refreshMinute(int minute) {
+		Point p = getCellForMinute(minute,null);
+		table.repaintCell(p.y,p.x);
+	}
+
+
+	public boolean getCellText(int row,int col, eve.util.StringList strList) {
+		if (row &gt;= 0 &amp;&amp; col &gt;= 0) 
+			if (col&lt;4) { 
+				strList.tryAdd(Convert.toString(row*4+col));
+				return true;
+			} else if (col==4) 
+				return false;
+			else {
+				strList.tryAdd(Convert.toString(row*10+col-5));
+				return true;
+			}
+		return false;
+	}
+
+//	public Object getCellData(int row,int col) {
+//		return (String)getCellText(row,col);
+//	}
+
+	public TableCellAttributes getCellAttributes(int row,int col,boolean isSelected,TableCellAttributes ta) {
+		ta.flat = true;
+		if (col==4) {
+			ta = super.getCellAttributes(row,col,isSelected,ta);
+			ta.fillColor=Color.LightGray;
+		} else
+			ta = super.getCellAttributes(row,col,isSelected,ta);
+		if (getHourFor(row,col) == chosenHour &amp;&amp; !isSelected){
+			ta.fillColor = new Color(0x80,0x80,0xff);
+		}
+		if (getMinuteFor(row,col) == chosenMinute &amp;&amp; !isSelected){
+			ta.fillColor = new Color(0x80,0x80,0xff);
+		}
+		return ta;
+	}
+
+	public int calculateColWidth(int col) {
+		if (col==4)
+        	return 4;
+        else if (col&lt;4)
+        	return super.calculateColWidth(col)+2;
+        else	
+        	return super.calculateColWidth(col);
+	}
+}
+
+
+
+

Added: experiments/EVE/src/cachewolf/DescriptionPanel.java
===================================================================
--- experiments/EVE/src/cachewolf/DescriptionPanel.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/DescriptionPanel.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,190 @@
+package cachewolf;
+
+import com.stevesoft.eve_pat.Regex;
+
+import eve.ui.*;
+import eve.ui.formatted.*;
+import eve.fx.*;
+import eve.sys.*;
+import java.util.Vector;
+import eve.ui.event.*;
+
+/**
+*	This class shows the long description on a cache.
+*/
+public class DescriptionPanel extends CellPanel{
+	private HtmlDisplay disp;
+	private Button btnPlus, btnMinus;
+	private Panel buttonP;
+	private String desc,newDesc;
+	CacheHolderDetail currCache;
+	private FormattedTextMaker tm;
+
+	public DescriptionPanel(){
+		ScrollBarPanel sbp = new MyScrollBarPanel(disp = new HtmlDisplay(), 0);
+		this.addLast(sbp);
+		buttonP = new Panel();
+		buttonP.addNext(btnPlus = new Button(&quot;+&quot;),CellConstants.HSTRETCH, CellConstants.HFILL);
+		buttonP.addLast(btnMinus = new Button(&quot;-&quot;),CellConstants.HSTRETCH, CellConstants.HFILL);
+		buttonP.equalWidths=true;
+		this.addLast(buttonP,CellConstants.HSTRETCH,CellConstants.HFILL);
+		clear();
+	}
+	
+	/**
+	*	Set the text to display. Text should be HTML formated.
+	*/
+	//String description = null;
+	//CacheHolderDetail chD;
+	
+	public void setText(CacheHolderDetail chD){
+		boolean isHtml=chD.is_HTML;
+		//if (currCache == cache) return;
+		int scrollto = 0;
+		if (chD.hasSameMainCache(currCache)) scrollto = disp.getTopLine();
+		//Makes no sense if (chD == null) desc = &quot;&quot;;
+		else {
+			if (chD.isAddiWpt()) {
+				CacheHolderDetail mainCache=chD.mainCache.getCacheDetails(true);
+				isHtml=mainCache.is_HTML;
+				if (chD.longDescription != null &amp;&amp; chD.longDescription.length() &gt; 0)
+					 desc = chD.longDescription + (isHtml?&quot;&lt;hr&gt;\n&quot;:&quot;\n&quot;)+mainCache.longDescription;
+				else 
+					desc = mainCache.longDescription;
+			} else // not an addi-wpt
+				desc = chD.longDescription; 
+		}
+		//if (!desc.equals(description)) {
+			//disp.getDecoderProperties().setBoolean(&quot;allowImages&quot;,true);
+			Form.showWait(); 
+			if (isHtml) {
+				int imageNo=0;
+				if (Global.getPref().descShowImg) {
+					Vector Images;
+					if (chD.isAddiWpt()) {
+						Images = chD.mainCache.getCacheDetails(true).images;
+					} else {
+						Images = chD.images;						
+					}					
+					StringBuffer s=new StringBuffer(desc.length()+Images.size()*100);
+					int start=0;
+					int pos;
+					Regex imgRex = new Regex(&quot;src=(?:\\s*[^\&quot;|']*?)(?:\&quot;|')(.*?)(?:\&quot;|')&quot;);
+					if (Images.size() &gt; 0) {
+						while (start&gt;=0 &amp;&amp; (pos=desc.indexOf(&quot;&lt;img&quot;,start))&gt;0) {
+							s.append(desc.substring(start,pos));
+							imgRex.searchFrom(desc,pos);
+							String imgUrl=imgRex.stringMatched(1);
+							//Vm.debug(&quot;imgUrl &quot;+imgUrl);
+							if (imgUrl.lastIndexOf('.')&gt;0 &amp;&amp; imgUrl.toLowerCase().startsWith(&quot;http&quot;)) {
+								String imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).substring(0,4).trim();
+								// If we have an image which we stored when spidering, we can display it
+								if(!imgType.startsWith(&quot;.com&quot;) &amp;&amp; !imgType.startsWith(&quot;.php&quot;) &amp;&amp; !imgType.startsWith(&quot;.exe&quot;)){
+									s.append(&quot;&lt;img src=\&quot;&quot;+
+											//Global.getProfile().dataDir+
+											Images.get(imageNo)+&quot;\&quot;&gt;&quot;);
+									imageNo++;
+								} // else s.append(&quot;&lt;!-- not valid image type --&gt;&quot;);
+							} // else s.append(&quot;&lt;!-- Not http --&gt;&quot;);
+							start=desc.indexOf(&quot;&gt;&quot;,pos);
+							if (start&gt;=0) start++;
+							if (imageNo &gt;= Images.size())break;
+						}
+					}
+					if (start&gt;=0) s.append(desc.substring(start));
+					newDesc=s.toString(); // Don't store in desc as this could modify chD
+				}
+				if (chD.hasImageInfo()) {
+					newDesc+=getPicDesc(imageNo,chD);
+				}
+				//disp.setHtml(desc);
+				disp.startHtml();
+				disp.getDecoderProperties().set(&quot;documentroot&quot;,Global.getProfile().dataDir);
+				disp.addHtml(newDesc,new eve.sys.Handle());
+				tm=disp.endHtml();
+				
+			}
+			else {
+				disp.startHtml(); // To clear the old HTML display
+				disp.addHtml(desc,new eve.sys.Handle());
+				tm=disp.endHtml();
+				//disp.setPlainText(desc);
+			}
+			disp.scrollTo(scrollto,false);
+			//description = desc;
+			Form.cancelWait();
+		//}
+		currCache = chD;
+	}
+	
+	/**
+	 * Get the descriptions for the pictures (if they exist)
+	 * @param imagesShown images already shown as part of long description (don't show again)
+	 * @param chD
+	 */
+	private String getPicDesc(int imagesShown,CacheHolderDetail chD) {
+		StringBuffer sb=new StringBuffer(1000);
+		sb.append(&quot;&lt;hr&gt;&lt;font size=\&quot;+1\&quot; color=\&quot;red\&quot;&gt;&quot;).append(MyLocale.getMsg(202,&quot;IMAGES&quot;).toUpperCase()).append(&quot;&lt;/font&gt;&quot;);
+		sb.append(&quot;&lt;br&gt;&lt;br&gt;&quot;);
+		for (int i=imagesShown; i&lt;chD.imagesInfo.size(); i++) {
+			sb.append(chD.imagesText.get(i)).append(&quot;&lt;br&gt;&quot;);
+			// Show the additional text if there is one
+			if (chD.imagesInfo.get(i)!=null) sb.append(&quot;&lt;font color='blue'&gt;&quot;).append(chD.imagesInfo.get(i)).append(&quot;&lt;/font&gt;&quot;);
+			// Only show the image if images are enabled
+			if (Global.getPref().descShowImg) sb.append(&quot;&lt;img src=\&quot;&quot;+chD.images.get(i)+&quot;\&quot;&gt;&lt;br&gt;&quot;);
+			sb.append(&quot;&lt;br&gt;&lt;br&gt;&lt;hr&gt;&quot;);
+		}
+		return sb.toString();
+	}
+	
+	
+	
+	public void clear() {
+		disp.startHtml(); // To clear the old HTML display
+		disp.addHtml(&quot;loading ...&quot;,new eve.sys.Handle());
+		disp.endHtml();
+		//disp.setPlainText(&quot;loading ...&quot;);
+	}
+	
+	private void redraw() {
+		int currLine;
+
+		Form.showWait();
+		currLine = disp.getTopLine();
+		//if (currCache.is_HTML)	setText(desc);
+		//else				disp.setPlainText(currCache.longDescription);
+		disp.scrollTo(currLine,false);
+		Form.cancelWait();
+	}
+	
+	/**
+	 * Eventhandler
+	 */
+	public void onEvent(Event ev){
+		
+		if (ev instanceof ControlEvent &amp;&amp; ev.type==TextDisplay.LINES_SPLIT) { 
+			ev.consumed=true; return; } // LINES_SPLIT event does not have to percolate up
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (ev.target == btnPlus){
+				Font currFont = disp.getFont();
+				currFont = currFont.changeNameAndSize(null, currFont.getSize() + 2);
+				//tm.newFont=currFont;
+				disp.setFont(currFont);
+				disp.displayPropertiesChanged();
+				//disp.repaintNow();
+				//redraw();
+			}
+
+			if (ev.target == btnMinus){
+				Font currFont = disp.getFont();
+				currFont = currFont.changeNameAndSize(null, currFont.getSize() - 2);
+				disp.setFont(currFont);
+				disp.displayPropertiesChanged();
+				//disp.repaintNow();
+				//redraw();
+			}
+		}
+		super.onEvent(ev);
+	}
+
+}

Added: experiments/EVE/src/cachewolf/DetailsPanel.java
===================================================================
--- experiments/EVE/src/cachewolf/DetailsPanel.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/DetailsPanel.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,623 @@
+package cachewolf;
+
+import eve.ui.*;
+import eve.ui.formatted.*;
+import eve.fx.*;
+
+import eve.sys.*;
+import eve.ui.event.*;
+
+/**
+*	Class to create the panel to show the cache details.&lt;br&gt;
+*	Also allows for creation of a custom waypoint.&lt;br&gt;
+*
+*   
+*/
+public class DetailsPanel extends CellPanel{
+	Input inpWaypoint = new Input();
+	Input inpName = new Input();
+	Button btnWayLoc = new Button();
+	Input inpHidden = new Input();
+	Input inpOwner = new Input();
+	Button btnAddDateTime;
+	Choice chcType = new Choice(CacheType.wayTypeList(),0);
+	Choice chcSize = new Choice(new String[]{&quot;&quot;, &quot;Micro&quot;, &quot;Small&quot;, &quot;Regular&quot;, &quot;Large&quot;,&quot;Other&quot;,&quot;Very Large&quot;,&quot;None&quot;},0);
+	ComboBox chcStatus = new ComboBox(new String[]{&quot;&quot;, MyLocale.getMsg(313,&quot;Flag 1&quot;), MyLocale.getMsg(314,&quot;Flag 2&quot;), MyLocale.getMsg(315,&quot;Flag 3&quot;), MyLocale.getMsg(316,&quot;Flag 4&quot;), MyLocale.getMsg(317,&quot;Search&quot;), MyLocale.getMsg(318,&quot;Found&quot;), MyLocale.getMsg(319,&quot;Not Found&quot;), MyLocale.getMsg(320,&quot;Owner&quot;)},0);
+	Button btnNewWpt, btnShowBug, btnShowMap, btnGoto, btnAddPicture, btnBlack, btnNotes;
+	Button btnFoundDate,btnHiddenDate;
+	CacheHolder thisCache;
+	Panel pnlTools = new Panel(); 
+	AttributesViewer attV;
+	TextPad mNotes;
+	
+	private boolean dirty_notes = false;
+	private boolean dirty_details = false;
+	private boolean blackStatus = false;
+	private boolean blackStatusChanged=false;
+	private boolean needsTableUpdate = false;
+	private boolean isBigScreen = false;
+	
+	Preferences pref; // Test
+	Profile profile;
+	Picture imgBlack;
+	Picture imgBlackNo;
+	Picture imgShowBug, imgShowBugNo;
+	Label lblDiff, lblTerr;
+	
+	public DetailsPanel(){
+		pref = Global.getPref();
+		profile=Global.getProfile();
+		//cacheDB = profile.cacheDB;
+		////////////////////
+		// Tools
+		////////////////////
+		// Use larger Button-Icons on VGA-mobiles
+		int sw = MyLocale.getScreenWidth();
+		String imagesize=&quot;&quot;;
+		if (eve.sys.Device.isMobile() &amp;&amp; sw &gt;= 400) imagesize=&quot;_vga&quot;;  
+		// Button 1: New Waypoint
+		pnlTools.addNext(btnNewWpt = new Button(new Picture(&quot;newwpt&quot;+imagesize+&quot;.png&quot;,new Color(255,0,0),0))); 
+		btnNewWpt.setToolTip(MyLocale.getMsg(311,&quot;Create Waypoint&quot;));
+		PenEvent.wantPenMoved(btnNewWpt,PenEvent.WANT_PEN_MOVED_ONOFF,true);
+		// Button 2: Goto
+		pnlTools.addNext(btnGoto = new Button(new Picture(&quot;goto&quot;+imagesize+&quot;.png&quot;,Color.White,0)));//Goto.gif funzt manchmal nicht
+		btnGoto.setToolTip(MyLocale.getMsg(345,&quot;Goto these coordinates&quot;));
+		// Button 3: Travelbugs
+		imgShowBug = new Picture(&quot;bug&quot;+imagesize+&quot;.gif&quot;);
+		imgShowBugNo = new Picture(&quot;bug_no&quot;+imagesize+&quot;.gif&quot;);
+		pnlTools.addNext(btnShowBug = new Button(imgShowBugNo)); 
+		//btnShowBug.modify(Control.Disabled,0);
+		btnShowBug.setToolTip(MyLocale.getMsg(346,&quot;Show travelbugs&quot;));
+		// Button 4: Show Map
+		pnlTools.addNext(btnShowMap = new Button(new Picture(&quot;globe_small&quot;+imagesize+&quot;.gif&quot;))); 
+		btnShowMap.setToolTip(MyLocale.getMsg(347,&quot;Show map&quot;));
+		// Button 5: Add images
+		pnlTools.addNext(btnAddPicture = new Button(new Picture(&quot;images&quot;+imagesize+&quot;.gif&quot;))); 
+		btnAddPicture.setToolTip(MyLocale.getMsg(348,&quot;Add user pictures&quot;));
+		// Button 6: Toggle blacklist status
+		imgBlackNo = new Picture(&quot;no_black&quot;+imagesize+&quot;.png&quot;,Color.Black,0); 
+		imgBlack = new Picture(&quot;is_black&quot;+imagesize+&quot;.png&quot;,Color.White,0); 
+		pnlTools.addNext(btnBlack=new Button(imgBlackNo)); 
+		btnBlack.setToolTip(MyLocale.getMsg(349,&quot;Toggle Blacklist status&quot;));
+		// Button 7: Notes
+		pnlTools.addNext(btnNotes=new Button(new Picture(&quot;notes&quot;+imagesize+&quot;.gif&quot;,Color.DarkBlue,0))); 
+		btnNotes.setToolTip(MyLocale.getMsg(351,&quot;Add/Edit notes&quot;));
+		// Button 8: Date/time stamp
+		pnlTools.addLast(btnAddDateTime = new Button(new Picture(&quot;date_time&quot;+imagesize+&quot;.png&quot;))); 
+		btnAddDateTime.setToolTip(MyLocale.getMsg(350,&quot;Add timestamp to notes&quot;));
+		//showMap.modify(Control.Disabled,0);
+		pnlTools.stretchFirstRow=true;
+		this.addLast(pnlTools,CellConstants.DONTSTRETCH, CellConstants.WEST).setTag(TAG_SPAN,new Dimension(3,1));;
+		
+		////////////////////
+		// Main body of screen
+		////////////////////
+
+		this.addNext(new Label(MyLocale.getMsg(300,&quot;Type:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTHWEST));
+		Panel line1Panel = new Panel(); line1Panel.stretchFirstColumn=true;
+		line1Panel.addNext(chcType,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		line1Panel.addLast(lblDiff=new Label(MyLocale.getMsg(1000,&quot;D&quot;)+&quot;: 5.5&quot;),CellConstants.DONTSTRETCH,(CellConstants.DONTFILL|CellConstants.EAST));
+		this.addLast(line1Panel,HSTRETCH,HFILL);
+		
+		this.addNext(new Label(MyLocale.getMsg(301,&quot;Size:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		Panel line2Panel = new Panel(); line2Panel.stretchFirstColumn=true; 	
+		line2Panel.addNext(chcSize,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		line2Panel.addLast(lblTerr=new Label(MyLocale.getMsg(1001,&quot;T&quot;)+&quot;: 5.5&quot;),CellConstants.DONTSTRETCH,(CellConstants.DONTFILL|CellConstants.EAST));
+		this.addLast(line2Panel,HSTRETCH,HFILL); 
+		
+		this.addNext(new Label(MyLocale.getMsg(302,&quot;Waypoint:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		this.addLast(inpWaypoint,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		
+		this.addNext(new Label(MyLocale.getMsg(303,&quot;Name:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		this.addLast(inpName,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		
+		this.addNext(new Label(MyLocale.getMsg(304,&quot;Location:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		this.addLast(btnWayLoc,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		
+		this.addNext(new Label(MyLocale.getMsg(307,&quot;Status:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		Panel cp=new Panel(); cp.stretchFirstColumn=true;
+		cp.addNext(chcStatus,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		cp.addLast(btnFoundDate=new Button(new Picture(&quot;calendar&quot;+imagesize+&quot;.png&quot;)),DONTSTRETCH,DONTFILL);
+		this.addLast(cp,HSTRETCH,HFILL);
+		
+		this.addNext(new Label(MyLocale.getMsg(306,&quot;Owner:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		this.addLast(inpOwner,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		
+		this.addNext(new Label(MyLocale.getMsg(305,&quot;Hidden on:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		Panel ip=new Panel(); ip.stretchFirstColumn=true;
+		ip.addNext(inpHidden,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		ip.addLast(btnHiddenDate=new Button(new Picture(&quot;calendar&quot;+imagesize+&quot;.png&quot;)),DONTSTRETCH,DONTFILL);
+		this.addLast(ip,HSTRETCH,HFILL);
+		inpHidden.modifyAll(DisplayOnly,0);
+		
+		attV=new AttributesViewer();
+		this.addLast(attV);
+		if ((MyLocale.getScreenWidth() &gt;= 400) &amp;&amp; (MyLocale.getScreenHeight() &gt;= 600)){
+			isBigScreen = true;  
+			this.addLast(new Label(MyLocale.getMsg(308,&quot;Notes:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			mNotes = new TextPad();
+			mNotes.modify(ControlConstants.NotEditable,0);
+			this.addLast(new MyScrollBarPanel(mNotes));
+		}
+	}
+	
+	public void clear() {
+		attV.clear();
+	}
+
+	public void setNeedsTableUpdate(boolean tableUpdate) {
+		needsTableUpdate = tableUpdate;
+	}
+	public boolean needsTableUpdate() {
+		return needsTableUpdate;
+	}
+
+	public boolean isDirty() {
+		return dirty_notes || dirty_details || needsTableUpdate;
+	}
+	public boolean hasBlackStatusChanged() {
+		return blackStatusChanged;
+	}
+	
+	
+	/**
+	* @param chD details of the cache to display
+	* @param dbindex index in cacheDB, in which changes will be saved
+	*/
+	public void setDetails(CacheHolder ch){
+		thisCache = ch;
+		dirty_notes = false;
+		dirty_details = false;
+		inpWaypoint.setText(ch.wayPoint);
+		inpName.setText(ch.cacheName);
+	    btnWayLoc.setText(ch.pos.toString());
+		inpHidden.setText(ch.dateHidden);
+		inpOwner.setText(ch.cacheOwner);
+		if (ch.cacheStatus.length()&gt;=10 &amp;&amp; ch.cacheStatus.charAt(4)=='-')
+			chcStatus.setText(MyLocale.getMsg(318,&quot;Found&quot;)+&quot; &quot;+ch.cacheStatus);
+		else {
+			chcStatus.setText(ch.cacheStatus);
+			// If the cache status contains a date, do not overwrite it with 'found' message
+			if(ch.is_found == true) chcStatus.setText(MyLocale.getMsg(318,&quot;Found&quot;));
+		}
+		chcType.setInt(transType(ch.type));
+		if(ch.is_black){
+			btnBlack.image = imgBlack;
+		} else {
+			btnBlack.image = imgBlackNo;
+		}
+		blackStatus=ch.is_black; 
+		blackStatusChanged=false;
+		btnBlack.repaintNow();
+		if (inpWaypoint.getText().length() == 0)
+			createWptName();
+		if(ch.has_bug == true) {
+			//btnShowBug.modify(Control.Disabled,1);
+			btnShowBug.image = imgShowBug;
+		} else {
+			//btnShowBug.modify(Control.Disabled,0);
+			btnShowBug.image = imgShowBugNo;
+		}
+		btnShowBug.repaintNow();
+		if(ch.cacheSize.equals(&quot;Micro&quot;)) chcSize.setInt(1);
+		if(ch.cacheSize.equals(&quot;Small&quot;)) chcSize.setInt(2);
+		if(ch.cacheSize.equals(&quot;Regular&quot;)) chcSize.setInt(3);
+		if(ch.cacheSize.equals(&quot;Large&quot;)) chcSize.setInt(4);
+		if(ch.cacheSize.equals(&quot;Other&quot;)) chcSize.setInt(5);
+		if(ch.cacheSize.equals(&quot;Very Large&quot;)) chcSize.setInt(6);
+		if(ch.cacheSize.equals(&quot;None&quot;)) chcSize.setInt(7);
+		if(ch.cacheSize.equals(&quot;Not chosen&quot;)) chcSize.setInt(7);
+		attV.showImages(ch.getCacheDetails(true).attributes);
+		lblTerr.setText((ch.terrain.length()&gt;0) ? (MyLocale.getMsg(1001,&quot;T&quot;)+&quot;: &quot;+ch.terrain) : &quot;&quot;);
+		lblDiff.setText((ch.hard.length()&gt;0)    ? (MyLocale.getMsg(1000,&quot;D&quot;)+&quot;: &quot;+ch.hard) : &quot;&quot;); 
+		if(isBigScreen)	mNotes.setText(ch.details.cacheNotes);	}
+	
+	
+	/**
+	*	Translate the cache type to the value in the cache type dropdown
+	*	control.
+	*/
+	private int transType(int type){
+		int c_type = CacheType.getWayTypePos(type);
+		if (c_type&lt;0) c_type=0;
+		return c_type;
+	}
+	
+	/**
+	*	Method to translate a selected cache type in the drop down control
+	*	to a &quot;true&quot; cache type.&lt;br&gt;
+	*	This transformation is required to ease the display of the cache type
+	*	icon in the table display.
+	*/
+	public int transSelect(int num){
+		return CacheType.wayTypeNo[num];
+	}
+	
+	/**
+	 * if is addi -&gt; returns the respective AddiWpt
+	 * if is main -&gt; returns the respective MainWpt 
+	 *
+	 */
+	public void createWptName() {
+		String wpt = inpWaypoint.getText().toUpperCase();
+		if (CacheType.isAddiWpt(transSelect(chcType.getInt())) &amp;&amp; 
+				(Global.mainTab.mainCache.startsWith(&quot;GC&quot;)||Global.mainTab.mainCache.startsWith(&quot;OC&quot;)||Global.mainTab.mainCache.startsWith(&quot;CW&quot;)) &amp;&amp;
+				wpt.startsWith(&quot;CW&quot;)) {
+			// for what was this?:
+			Global.mainTab.lastselected=Global.mainTab.mainCache; //I don't know exactly, but it's needed for creating a series of Addis
+			
+			inpWaypoint.setText(Global.getProfile().getNewAddiWayPointName(Global.mainTab.mainCache));
+		} 
+		if (!CacheType.isAddiWpt(transSelect(chcType.getInt())) &amp;&amp; !(wpt.startsWith(&quot;GC&quot;) 
+				|| wpt.startsWith(&quot;OC&quot;) || wpt.startsWith(&quot;CW&quot;)) ) {
+			inpWaypoint.setText(Global.getProfile().getNewWayPointName());
+		}
+	}
+	
+	/**
+	*	Method to react to a user input.
+	*/
+	public void onEvent(Event ev){
+		if (ev instanceof DataChangeEvent ) {
+			if (ev.target == inpWaypoint) {
+				// If user used lower case -&gt; convert directly to upper case
+				inpWaypoint.setText(inpWaypoint.getText().toUpperCase());
+			}
+			dirty_details = true;
+			needsTableUpdate = true;
+			profile.hasUnsavedChanges=true;
+			if (ev.target==chcType) {
+				createWptName();
+			}
+		}
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if(ev.target == btnNotes){
+				dirty_notes=true; // TODO I think this is redundant, because the notes are saved seperately by the notes screen itself
+				NotesScreen nsc = new NotesScreen(thisCache.getCacheDetails(true));
+				nsc.execute(this.getFrame(), Gui.CENTER_FRAME);
+				if(isBigScreen) mNotes.setText(thisCache.getCacheDetails(true).cacheNotes);	
+			} else if(ev.target == btnShowMap){
+				Global.mainTab.switchToMovingMap(thisCache.pos, true);
+/*				try {
+					MapDetailForm mdf = new MapDetailForm(thisCache.wayPoint, pref, profile);
+					mdf.execute();
+				} catch (IllegalArgumentException e) {
+					MessageBox tmp = new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(322,&quot;Kann Bild/Karte nicht finden&quot;)+&quot;: &quot;+e.getMessage(), MessageBox.OKB);
+					tmp.exec();
+				}
+	*/		} else if(ev.target == btnShowBug){
+				//InfoScreen is = new InfoScreen(thisCache.Travelbugs.toHtml(), &quot;Travelbugs&quot;, false, pref);
+				//is.execute();
+				TravelbugInCacheScreen ts = new TravelbugInCacheScreen(thisCache.getCacheDetails(true).travelbugs.toHtml(), &quot;Travelbugs&quot;);
+				ts.execute(this.getFrame(), Gui.CENTER_FRAME);
+			} else /* if (ev.target == btnCenter){
+				CWPoint cp=new CWPoint(thisCache.LatLon);
+				if (!cp.isValid()){
+					MessageBox tmpMB = new MessageBox(MyLocale.getMsg(312,&quot;Error&quot;), MyLocale.getMsg(4111,&quot;Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM&quot;), MessageBox.OKB);
+					tmpMB.exec();
+				} else {				
+					pref.curCentrePt.set(cp);
+					Global.mainTab.updateBearDist();
+				}
+			}
+			else */ if (ev.target == btnAddDateTime){
+				dirty_notes=true;
+				String note = thisCache.getCacheDetails(true).cacheNotes;
+				Time dtm = new Time();
+				dtm.getTime();
+				dtm.setFormat(&quot;E dd.MM.yyyy '/' HH:mm&quot;);
+				if(note.length() &gt; 0)	note = note + &quot;\n&quot; + dtm.toString();
+				else 	note = note + dtm.toString();
+				note = note + &quot;\n&quot;;
+				thisCache.getCacheDetails(true).cacheNotes = note;
+				thisCache.getCacheDetails(true).saveCacheDetails( Global.getProfile().dataDir);
+			} else if (ev.target == btnAddPicture){
+				thisCache.getCacheDetails(true).addUserImage(profile);
+			} else if(ev.target == btnBlack){
+				if(thisCache.is_black) {
+					thisCache.is_black = false;
+					btnBlack.image = imgBlackNo;
+				}
+				else {
+					thisCache.is_black = true;
+					btnBlack.image = imgBlack;
+				}
+				blackStatus = thisCache.is_black;
+				thisCache.setAttributesToAddiWpts();
+				btnBlack.repaintNow();
+				dirty_details=true;
+				blackStatusChanged=true;
+			} else if (ev.target == btnNewWpt){
+				CacheHolder ch = new CacheHolder();
+				ch.latLon = thisCache.latLon;
+				ch.pos = new CWPoint( thisCache.pos );
+				ch.type = 51;
+				Global.mainTab.newWaypoint(ch);
+			} else if (ev.target == btnGoto){
+				// TODO if something changed saveWpt();
+				Global.mainTab.gotoPoint(thisCache.pos);
+			} else if (ev.target == btnWayLoc){
+				CWPoint coords = new CWPoint(btnWayLoc.getText(),CWPoint.CW);
+				CoordsScreen cs = new CoordsScreen(true);
+				cs.setFields(coords, CWPoint.CW);
+				if (cs.execute()== CoordsScreen.IDOK){
+					dirty_details=true;
+					coords = cs.getCoords();
+					thisCache.pos.set(coords);
+					btnWayLoc.setText(coords.toString());
+					thisCache.latLon=coords.toString();
+					// If the current centre is valid, calculate the distance and bearing to it
+					CWPoint centre=Global.getPref().curCentrePt;
+					if (centre.isValid()) thisCache.calcDistance(centre);
+				}
+			} else if (ev.target==btnFoundDate) {
+				DateTimeChooser dc=new DateTimeChooser(Vm.getLocale(), true);
+				dc.title=MyLocale.getMsg(328,&quot;Date found&quot;); 
+				dc.setPreferredSize(240,240);
+				String foundDate=chcStatus.getText();
+				if (foundDate.startsWith(MyLocale.getMsg(318,&quot;Found&quot;)+&quot; &quot;)) foundDate=foundDate.substring(MyLocale.getMsg(318,&quot;Found&quot;).length()+1);
+				Time t=new Time();
+				try {
+					t.parse(foundDate,&quot;y-M-d H:m&quot;);
+				} catch(IllegalArgumentException e) {
+					try {
+						t.parse(foundDate,&quot;y-M-d&quot;);
+					} catch(IllegalArgumentException e1) {}
+				};
+				dc.reset(t);
+				if (dc.execute()==eve.ui.FormBase.IDOK) {
+				  chcStatus.setText(MyLocale.getMsg(318,&quot;Found&quot;)+&quot; &quot;+Convert.toString(dc.year)+&quot;-&quot;+MyLocale.formatLong(dc.month,&quot;00&quot;)+&quot;-&quot;+MyLocale.formatLong(dc.day,&quot;00&quot;)+&quot; &quot;+dc.time);
+				  dirty_details=true;
+				  profile.hasUnsavedChanges=true;
+				}
+			} else if (ev.target==btnHiddenDate) {
+				//DateTimeChooser.dayFirst=true;
+				DateTimeChooser dc=new DateTimeChooser(Vm.getLocale(),false);
+				dc.title=MyLocale.getMsg(329,&quot;Hidden date&quot;); 
+				dc.setPreferredSize(240,240);
+				if (inpHidden.getText().length()==10)
+				try {
+					dc.setDate(new Time(
+						Convert.parseInt(inpHidden.getText().substring(8)),
+					    Convert.parseInt(inpHidden.getText().substring(5,7)),
+						Convert.parseInt(inpHidden.getText().substring(0,4))));
+				} catch (NumberFormatException e) {
+					dc.reset(new Time());
+				}
+				if (dc.execute()==eve.ui.FormBase.IDOK) {
+				  inpHidden.setText(Convert.toString(dc.year)+&quot;-&quot;+MyLocale.formatLong(dc.month,&quot;00&quot;)+&quot;-&quot;+MyLocale.formatLong(dc.day,&quot;00&quot;));
+				  dirty_details=true;
+				  profile.hasUnsavedChanges=true;
+				}
+			}
+			ev.consumed=true;
+		}
+	}
+	
+	public void saveDirtyWaypoint() {
+		// We have to update two objects: thisCache (a CacheHolderDetail) which contains 
+		// the full cache which will be written to the cache.xml file AND
+		// the CacheHolder object which sits in cacheDB
+		  // Strip the found message if the status contains a date
+		if (chcStatus.getText().startsWith(MyLocale.getMsg(318,&quot;Found&quot;)) &amp;&amp; 
+				  chcStatus.getText().length()&gt;=MyLocale.getMsg(318,&quot;Found&quot;).length()+11)
+			  thisCache.cacheStatus = chcStatus.getText().substring(MyLocale.getMsg(318,&quot;Found&quot;).length()+1);
+		  else	  
+			  thisCache.cacheStatus = chcStatus.getText();
+		  thisCache.is_found = chcStatus.getText().startsWith(MyLocale.getMsg(318,&quot;Found&quot;));
+		  thisCache.cacheOwner = inpOwner.getText().trim();
+		  thisCache.is_owned = thisCache.cacheStatus.equals(MyLocale.getMsg(320,&quot;Owner&quot;));
+		  // Avoid setting is_owned if alias is empty and username is empty
+		  if(thisCache.is_owned == false){
+			  thisCache.is_owned = (!pref.myAlias.equals(&quot;&quot;) &amp;&amp; pref.myAlias.equals(thisCache.cacheOwner)) || 
+					        (!pref.myAlias2.equals(&quot;&quot;) &amp;&amp; pref.myAlias2.equals(thisCache.cacheOwner));
+		  }
+		  thisCache.is_black = blackStatus;
+		  String oldWaypoint=thisCache.wayPoint;
+		  thisCache.wayPoint = inpWaypoint.getText().toUpperCase().trim();
+		  thisCache.cacheSize = chcSize.getText();
+		  // If the waypoint does not have a name, give it one
+		  if (thisCache.wayPoint.equals(&quot;&quot;)) { 
+			  thisCache.wayPoint=profile.getNewWayPointName();
+		  }
+		  //Don't allow single letter names=&gt; Problems in updateBearingDistance
+		  // This is a hack but faster than slowing down the loop in updateBearingDistance
+		  if (thisCache.wayPoint.length()&lt;2) thisCache.wayPoint+=&quot; &quot;;
+		  thisCache.cacheName = inpName.getText().trim();
+		  thisCache.latLon = thisCache.pos.toString();
+		  thisCache.dateHidden = inpHidden.getText().trim();
+		  int oldType=thisCache.type;
+		  thisCache.type = transSelect(chcType.getInt());
+		 // thisCache.saveCacheDetails(profile.dataDir); // this is redundant, because all changes affecting the details are immediately saved
+		  // Now update the table
+		  CacheHolder ch = thisCache; // TODO variable ch is redundant
+		  
+	  /* The references have to be rebuilt if:
+	   *   - the cachetype changed from addi-&gt;normal or normal-&gt;addi
+	   *   - the old cachetype or the new cachetype were 'addi' and 
+	   *     the waypointname has changed 
+	   */
+	  if (CacheType.isAddiWpt(ch.type)!=CacheType.isAddiWpt(oldType) ||
+		 ((CacheType.isAddiWpt(ch.type) || CacheType.isAddiWpt(oldType)) &amp;&amp;
+		 !thisCache.wayPoint.equals(oldWaypoint))) {
+			  // If we changed the type to addi, check that a parent exists
+			  if (CacheType.isAddiWpt(ch.type)) {
+				  int idx;
+				  if (ch.wayPoint.length()&lt;5)
+					  idx=-1;
+				  else {
+					  idx=profile.getCacheIndex(&quot;GC&quot;+ ch.wayPoint.substring(ch.wayPoint.length() == 5?1:2));
+					  if (idx&lt;0) idx=profile.getCacheIndex(&quot;OC&quot;+ ch.wayPoint.substring(ch.wayPoint.length() == 5?1:2));
+					  if (idx&lt;0) idx=profile.getCacheIndex(&quot;CW&quot;+ ch.wayPoint.substring(ch.wayPoint.length() == 5?1:2));
+					  if (idx&lt;0) (new MessageBox(MyLocale.getMsg(144,&quot;Warning&quot;),
+							  MyLocale.getMsg(734,&quot;No main cache found for addi waypoint &quot;)+&quot; &quot;+ch.wayPoint+
+							  &quot;\n&quot;+MyLocale.getMsg(735,&quot;Addi Waypoints must have the format xxYYYY, where xx are any 2 chars and YYYY are the main cache's chars after the GC&quot;),FormBase.OKB)).execute();
+				  }
+				  profile.buildReferences(); // TODO this takes quite long -&gt; use profile.setAddiRef instead
+			  } else {
+				  profile.buildReferences(); // we have to do this to release the link between the two caches  
+			  }
+		  }
+		  // set status also on addi wpts
+		  ch.setAttributesToAddiWpts();
+		  dirty_notes=false;
+		  dirty_details=false;
+		  setNeedsTableUpdate(false);
+		  if (thisCache.details != null) thisCache.details.hasUnsavedChanges = false;
+		  thisCache.getCacheDetails(true).hasUnsavedChanges = true;
+	}
+
+	private class TravelbugInCacheScreen extends Form {
+		
+		private DispPanel disp = new DispPanel();
+		private Button btCancel;
+		private TravelbugJourneyList tbjList;
+		
+		TravelbugInCacheScreen(String text, String title) {
+			this.title=title;
+			this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
+			disp.setHtml(text);
+			ScrollBarPanel sbp = new MyScrollBarPanel(disp, ScrollBarPanel.NeverShowHorizontalScrollers);
+			this.addLast(sbp);
+			this.addLast(btCancel = new Button(MyLocale.getMsg(3000,&quot;Close&quot;)),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		}
+
+		public void onEvent(Event ev){
+			if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+				if (ev.target == btCancel){
+					this.close(0);
+				}
+			}
+		}
+
+		// Subclassed HtmlDisplay with Pop-up menu
+		private class DispPanel extends HtmlDisplay {
+			MenuItem mnuPickupTB, mnuDropTB;
+			MenuItem[] TBMenuItems=new MenuItem[2];
+			Menu mnuPopup;
+			DispPanel() {
+				TBMenuItems[0]= mnuPickupTB = new MenuItem(MyLocale.getMsg(6016,&quot;Pick up Travelbug&quot;));
+				TBMenuItems[1]= mnuDropTB = new MenuItem(MyLocale.getMsg(6017,&quot;Drop Travelbug&quot;));
+				mnuPopup=new Menu(TBMenuItems,&quot;&quot;);
+			} 
+			public void penRightReleased(Point p){
+				setMenu(mnuPopup);
+				doShowMenu(p); // direct call (not through doMenu) is neccesary because it will exclude the whole table
+			}
+			public void penHeld(Point p){
+				setMenu(mnuPopup);
+				doShowMenu(p);
+			}
+			public void popupMenuEvent(Object selectedItem){
+				if (selectedItem==mnuPickupTB) { 
+					Travelbug tb=TravelbugPickup.pickupTravelbug(thisCache.getCacheDetails(true).travelbugs);	
+					if (tb!=null) {
+						dirty_details=true;
+						// Get the list of my travelbugs
+						tbjList=new TravelbugJourneyList();
+						tbjList.readTravelbugsFile();
+						// Add the tb to this list
+						tbjList.addTbPickup(tb,Global.getProfile().name,thisCache.wayPoint);
+						tbjList.saveTravelbugsFile();
+						tbjList=null;
+						setHtml(thisCache.getCacheDetails(true).travelbugs.toHtml());
+						repaint();
+						thisCache.has_bug=thisCache.getCacheDetails(true).travelbugs.size()&gt;0;						
+					}
+				} else if (selectedItem==mnuDropTB) {
+					tbjList=new TravelbugJourneyList();
+					tbjList.readTravelbugsFile();
+					TravelbugList tbl=tbjList.getMyTravelbugs();
+					TravelbugScreen tbs=new TravelbugScreen(tbl,MyLocale.getMsg(6017,&quot;Drop a travelbug&quot;),false);
+					tbs.execute();
+					if (tbs.selectedItem&gt;=0) {
+						Travelbug tb=tbl.getTB(tbs.selectedItem);
+						thisCache.getCacheDetails(true).travelbugs.add(tb);
+						tbjList.addTbDrop(tb,Global.getProfile().name,thisCache.wayPoint);
+					}
+					tbjList.saveTravelbugsFile();
+					tbjList=null;
+					thisCache.has_bug=thisCache.getCacheDetails(true).travelbugs.size()&gt;0;
+					setHtml(thisCache.getCacheDetails(true).travelbugs.toHtml());
+					repaint();
+					dirty_details=true;
+				} else 
+					super.popupMenuEvent(selectedItem);
+			}
+		}
+
+	
+	}
+
+//#############################################################################
+//  NotesScreen
+//#############################################################################
+	
+	/**
+	*	This class displays a form to show and edit notes for a cache.
+	*/
+	private class NotesScreen extends Form{
+		TextPad wayNotes = new TextPad();
+		CacheHolderDetail thisCache = null;
+		Button addDateTime;
+		Button btSave = new Button(MyLocale.getMsg(127,&quot;Save&quot;));
+		Button cancelBtn = new Button(&quot;Cancel&quot;);
+		ScrollBarPanel sbp = new MyScrollBarPanel(wayNotes);
+		
+		public NotesScreen(CacheHolderDetail ch){
+			this.title = &quot;Notes&quot;;
+			String imagesize = &quot;&quot;;
+			if (eve.sys.Device.isMobile() &amp;&amp; MyLocale.getScreenWidth() &gt;= 400) imagesize=&quot;_vga&quot;;
+			addDateTime = new Button(new Picture(&quot;date_time&quot;+imagesize+&quot;.png&quot;));
+			setPreferredSize(Global.getPref().myAppWidth, Global.getPref().myAppHeight);
+			this.resizeOnSIP = true;
+			thisCache = ch;
+			wayNotes.setText(thisCache.cacheNotes);
+			addLast(sbp.setTag(Control.TAG_SPAN, new Dimension(3,1)),CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
+			titleControls=new CellPanel();
+			titleControls.addNext(addDateTime,CellConstants.HSTRETCH,CellConstants.HFILL);
+			titleControls.addNext(cancelBtn,CellConstants.HSTRETCH,CellConstants.HFILL);
+			titleControls.addLast(btSave,CellConstants.HSTRETCH,CellConstants.HFILL);
+		}
+		
+		public void onEvent(Event ev){
+			if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+				if (ev.target == addDateTime){
+					String note = wayNotes.getText();
+					Time dtm = new Time();
+					dtm.getTime();
+					dtm.setFormat(&quot;E dd.MM.yyyy '/' HH:mm&quot;);
+					if(note.length() &gt; 0)	note = note + &quot;\n&quot; + dtm.toString();
+					else 	note = note + dtm.toString();
+					note = note + &quot;\n&quot;;
+					wayNotes.setText(note);
+				}
+				if(ev.target == btSave){
+					thisCache.cacheNotes = wayNotes.getText();
+					thisCache.saveCacheDetails( Global.getProfile().dataDir);
+					this.close(0);
+				}
+				if(ev.target == cancelBtn){
+					if ( (!thisCache.cacheNotes.equals(wayNotes.getText())) ) {
+						if ( (new MessageBox(&quot;Warning&quot;, &quot;You will loose any changes made to the notes. Do you want to continue?&quot;
+								, MessageBox.YESB|MessageBox.NOB)).execute() == MessageBox.IDYES) {
+							this.close(0);
+						}
+					} else this.close(0); // no changes -&gt; exit without asking
+				} 
+				if(ev.target == titleOK){
+					if ( (!thisCache.cacheNotes.equals(wayNotes.getText())) ) {
+						if ( (new MessageBox(&quot;Warning&quot;, &quot;Save changes made to the notes?&quot;
+								, MessageBox.YESB|MessageBox.NOB)).execute() == MessageBox.IDYES) {
+							thisCache.cacheNotes = wayNotes.getText();
+							thisCache.saveCacheDetails( Global.getProfile().dataDir);
+						}
+					}
+				}
+			}
+			super.onEvent(ev);
+		}
+	}
+	
+
+}

Added: experiments/EVE/src/cachewolf/Filter.java
===================================================================
--- experiments/EVE/src/cachewolf/Filter.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/Filter.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,592 @@
+package cachewolf;
+import eve.ui.MessageBox;
+import java.util.*;
+import eve.sys.*;
+import java.io.*;
+
+
+import cachewolf.imp.*;
+import cachewolf.utils.Common;
+import cachewolf.utils.Matrix;
+
+import com.stevesoft.eve_pat.*;
+
+/**
+*	Class that actually filters the cache database.&lt;br&gt;
+*	The class that uses this filter must set the different public variables.
+*   @author BilboWolf (optimiert von salzkammergut)
+*/
+public class Filter{
+	public static final int FILTER_INACTIVE=0;
+	public static final int FILTER_ACTIVE=1;
+	public static final int FILTER_CACHELIST=2;
+	public static final int FILTER_MARKED_ONLY=3;
+
+	/** Indicator whether a filter is inverted */
+	//public static boolean filterInverted=false;
+	/** Indicator whether a filter is active. Used in status bar to indicate filter status */
+	//public static int filterActive=FILTER_INACTIVE;
+
+	private static final int SMALLER = -1;
+	private static final int EQUAL = 0;
+	private static final int GREATER = 1;
+
+	private static final int TRADITIONAL = 1;
+	private static final int MULTI = 2;
+	private static final int VIRTUAL = 4;
+	private static final int LETTER = 8;
+	private static final int EVENT = 16;
+	private static final int WEBCAM = 32;
+	private static final int MYSTERY = 64;
+	private static final int LOCLESS = 128;
+	private static final int CUSTOM = 256;
+	private static final int MEGA = 512;
+	private static final int EARTH = 1024;
+	private static final int PARKING = 2048;
+	private static final int STAGE = 4096;
+	private static final int QUESTION = 8192;
+	private static final int FINAL = 16384;
+	private static final int TRAILHEAD = 32768;
+	private static final int REFERENCE = 65536;
+	private static final int CITO = 131072;
+	private static final int WHERIGO = 262144;
+	private static final int TYPE_ALL=TRADITIONAL|MULTI|VIRTUAL|LETTER|EVENT|WEBCAM|MYSTERY|LOCLESS|CUSTOM
+	                                  |MEGA|EARTH|PARKING|STAGE|QUESTION|FINAL|TRAILHEAD|REFERENCE|CITO|WHERIGO;
+	private static final int TYPE_MAIN=TRADITIONAL|MULTI|VIRTUAL|LETTER|EVENT|WEBCAM|MYSTERY|LOCLESS|CUSTOM|MEGA|EARTH|CITO|WHERIGO;
+
+	private static final int N = 1;
+	private static final int NNE = 2;
+	private static final int NE = 4;
+	private static final int ENE = 8;
+	private static final int E = 16;
+	private static final int ESE = 32;
+	private static final int SE = 64;
+	private static final int SSE = 128;
+	private static final int SSW = 256;
+	private static final int SW = 512;
+	private static final int WSW = 1024;
+	private static final int W = 2048;
+	private static final int WNW = 4096;
+	private static final int NW = 8192;
+	private static final int NNW = 16384;
+	private static final int S = 32768;
+	private static final int ROSE_ALL= N|NNE|NE|ENE|E|ESE|SE|SSE|SSW|SW|WSW|W|WNW|NW|NNW|S;
+
+	private static final int MICRO=1;
+	private static final int SMALL=2;
+	private static final int REGULAR=4;
+	private static final int LARGE=8;
+	private static final int VERYLARGE=16;
+	private static final int OTHER=32;
+	private static final int SIZE_ALL=MICRO|SMALL|REGULAR|LARGE|VERYLARGE|OTHER;
+
+	private int distdirec = 0;
+	private int diffdirec = 0;
+	private int terrdirec = 0;
+
+	//String[] byVec;
+
+
+	private int roseMatchPattern;
+	private boolean hasRoseMatchPattern;
+	private int typeMatchPattern;
+	private boolean hasTypeMatchPattern;
+	private int sizeMatchPattern;
+	private boolean hasSizeMatchPattern;
+
+	private boolean foundByMe;
+	private boolean notFoundByMe;
+
+	private boolean ownedByMe;
+	private boolean notOwnedByMe;
+
+	double fscDist;
+	double fscTerr;
+	double fscDiff;
+
+	private boolean archived = false;
+	private boolean notArchived = false;
+
+	private boolean available=false;
+	private boolean notAvailable = false;
+	double pi180=java.lang.Math.PI / 180.0;
+
+	private long attributesYesPattern = 0;
+	private long attributesNoPattern = 0;
+	private int attributesChoice = 0;
+
+	/**
+	*	Apply a route filter. Each waypoint is on a seperate line.
+	*	We use a regex method to allow for different formats of waypoints:
+	*	possible is currently: DD MM.mmm
+	*/
+	public void doFilterRoute(File routeFile, double distance){
+		Global.getProfile().selectionChanged = true;
+		Vector cacheDB=Global.getProfile().cacheDB;
+		//load file into a vector:
+		Vector wayPoints = new Vector();
+		Regex rex = new Regex(&quot;(N|S).*?([0-9]{1,2}).*?([0-9]{1,3})(,|.)([0-9]{1,3}).*?(E|W).*?([0-9]{1,2}).*?([0-9]{1,3})(,|.)([0-9]{1,3})&quot;);
+		CWPoint cwp, fromPoint, toPoint;
+		CacheHolder ch;
+		double lat,lon, calcDistance = 0;
+		BufferedReader in=null;
+		try{
+			if((routeFile.getAbsolutePath()).indexOf(&quot;.kml&quot;) &gt; 0){
+				KMLImporter kml = new KMLImporter(routeFile.getAbsolutePath());
+				kml.importFile();
+				wayPoints = kml.getPoints();
+			} else {
+				in = new BufferedReader(new FileReader(routeFile));
+				String line;
+				while((line = in.readLine()) != null){
+					rex.search(line);
+					/*
+					Vm.debug(line);
+					Vm.debug(rex.stringMatched(1));
+					Vm.debug(rex.stringMatched(2));
+					Vm.debug(rex.stringMatched(3));
+					Vm.debug(rex.stringMatched(5));
+
+					Vm.debug(rex.stringMatched(6));
+					Vm.debug(rex.stringMatched(7));
+					Vm.debug(rex.stringMatched(8));
+					Vm.debug(rex.stringMatched(10));
+					Vm.debug(&quot; &quot;);
+					*/
+					// parse the route file
+					if(rex.didMatch()){
+						lat = Convert.toDouble(rex.stringMatched(2)) + Convert.toDouble(rex.stringMatched(3))/60 + Convert.toDouble(rex.stringMatched(5))/60000;
+						lon = Convert.toDouble(rex.stringMatched(7)) + Convert.toDouble(rex.stringMatched(8))/60 + Convert.toDouble(rex.stringMatched(10))/60000;
+
+						if(rex.stringMatched(1).equals(&quot;S&quot;) || rex.stringMatched(1).equals(&quot;s&quot;)) lat = -lat;
+						if(rex.stringMatched(6).equals(&quot;W&quot;) || rex.stringMatched(6).equals(&quot;w&quot;)) lon = -lon;
+
+						cwp = new CWPoint(lat, lon);
+
+						wayPoints.add(cwp);
+					}
+				}
+			}
+			//initialise database
+			for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+				ch = (CacheHolder)cacheDB.get(i);
+				ch.in_range = false;
+				//cacheDB.set(i, ch);
+			}
+			// for each segment of the route...
+			for(int z=0;z&lt;wayPoints.size()-1;z++){
+				fromPoint = (CWPoint)wayPoints.get(z);
+				toPoint = (CWPoint)wayPoints.get(z+1);
+				//... go through the current cache database
+				for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+					ch = (CacheHolder)cacheDB.get(i);
+					cwp = new CWPoint(ch.latLon, CWPoint.CW);
+					calcDistance = DistToSegment(fromPoint, toPoint, cwp);
+					calcDistance = (calcDistance*180*60)/java.lang.Math.PI;
+					calcDistance = calcDistance * 1.852;
+					//Vm.debug(&quot;Distcalc: &quot; + calcDistance + &quot;Cache: &quot; +ch.CacheName + &quot; / z is = &quot; + z);
+					if(calcDistance &lt;= distance) {
+						//Vm.debug(&quot;Distcalc: &quot; + calcDistance + &quot;Cache: &quot; +ch.CacheName + &quot; / z is = &quot; + z);
+						ch.in_range = true;
+					}
+					//cacheDB.set(i, ch);
+				} // for database
+			} // for segments
+			for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+				ch = (CacheHolder)cacheDB.get(i);
+				if(ch.is_filtered == false &amp;&amp; ch.in_range == false) ch.is_filtered = true;
+			}
+		}catch(FileNotFoundException fnex){
+			(new MessageBox(&quot;Error&quot;, &quot;File not found&quot;, MessageBox.OKB)).execute();
+		}catch(IOException ioex){
+			(new MessageBox(&quot;Error&quot;, &quot;Problem reading file!&quot;, MessageBox.OKB)).execute();
+		} finally {
+			try {
+				in.close();
+			} catch (Exception ex) {}
+		}
+	}
+
+	/**
+	*	Method to calculate the distance of a point to a segment
+	*/
+	private double DistToSegment(CWPoint fromPoint, CWPoint toPoint, CWPoint cwp){
+
+		/*
+		double XTD = 0;
+		double dist = 0;
+
+		double crs_AB = fromPoint.getBearing(toPoint);
+		crs_AB = crs_AB * java.lang.Math.PI / 180;
+		double crs_AD = fromPoint.getBearing(cwp);
+		crs_AD = crs_AD * java.lang.Math.PI / 180;
+		double dist_AD = fromPoint.getDistance(cwp);
+		Vm.debug(&quot;Distance: &quot;+dist_AD);
+		dist_AD = dist_AD / 1.852;
+		dist_AD = (java.lang.Math.PI/(180*60))*dist_AD;
+		XTD =java.lang.Math.asin(java.lang.Math.sin(dist_AD)*java.lang.Math.sin(crs_AD-crs_AB));
+		return java.lang.Math.abs(XTD);
+		*/
+		double dist = 0;
+		double px = cwp.lonDec * pi180;
+		double py = cwp.latDec * pi180;
+		double X1 = fromPoint.lonDec * pi180;
+		double Y1 = fromPoint.latDec * pi180;
+		double X2 = toPoint.lonDec * pi180;
+		double Y2 = toPoint.latDec * pi180;
+		double dx = X2 - X1;
+		double dy = Y2 - Y1;
+		if(dx == 0 &amp;&amp; dy == 0){
+			// have a point and not a segment!
+			dx = px - X1;
+			dy = py - Y1;
+			return java.lang.Math.sqrt(dx*dx + dy*dy);
+		}
+		dist = Matrix.cross(X1,Y1,X2,Y2,px,py) / Matrix.dist(X1,Y1,X2,Y2);
+		double dot1 = Matrix.dot(X1,Y1,X2,Y2,px,py);
+		if(dot1 &gt; 0) return Matrix.dist(X2,Y2,px,py);
+		double dot2 = Matrix.dot(X2,Y2,X1,Y1,px,py);
+		if(dot2 &gt; 0) return Matrix.dist(X1,Y1,px,py);
+		dist = java.lang.Math.abs(dist);
+		return dist;
+
+	}
+
+	/**
+	 * Set the filter from the filter data stored in the profile
+	 * (the filterscreen also updates the profile)
+	 */
+	public void setFilter() {
+		Profile profile=Global.getProfile();
+		archived     = profile.filterVar.charAt(0) == '1';
+		available    = profile.filterVar.charAt(1) == '1';
+		foundByMe    = profile.filterVar.charAt(2) == '1';
+		ownedByMe    = profile.filterVar.charAt(3) == '1';
+		notArchived  = profile.filterVar.charAt(4) == '1';
+		notAvailable = profile.filterVar.charAt(5) == '1';
+		notFoundByMe = profile.filterVar.charAt(6) == '1';
+		notOwnedByMe = profile.filterVar.charAt(7) == '1';
+		typeMatchPattern=0;
+		String filterType=profile.filterType;
+		if (filterType.charAt(0) == '1') typeMatchPattern|=TRADITIONAL;
+		if (filterType.charAt(1) == '1') typeMatchPattern|=MULTI;
+		if (filterType.charAt(2) == '1') typeMatchPattern|=VIRTUAL;
+		if (filterType.charAt(3) == '1') typeMatchPattern|=LETTER;
+		if (filterType.charAt(4) == '1') typeMatchPattern|=EVENT;
+		if (filterType.charAt(5) == '1') typeMatchPattern|=WEBCAM;
+		if (filterType.charAt(6) == '1') typeMatchPattern|=MYSTERY;
+		if (filterType.charAt(7) == '1') typeMatchPattern|=EARTH;
+		if (filterType.charAt(8) == '1') typeMatchPattern|=LOCLESS;
+		if (filterType.charAt(9) == '1') typeMatchPattern|=MEGA;
+		if (filterType.charAt(10) == '1') typeMatchPattern|=CUSTOM;
+		if (filterType.charAt(11) == '1') typeMatchPattern|=PARKING;
+		if (filterType.charAt(12) == '1') typeMatchPattern|=STAGE;
+		if (filterType.charAt(13) == '1') typeMatchPattern|=QUESTION;
+		if (filterType.charAt(14) == '1') typeMatchPattern|=FINAL;
+		if (filterType.charAt(15) == '1') typeMatchPattern|=TRAILHEAD;
+		if (filterType.charAt(16) == '1') typeMatchPattern|=REFERENCE;
+		if (filterType.charAt(17) == '1') typeMatchPattern|=CITO;
+		if (filterType.charAt(18) == '1') typeMatchPattern|=WHERIGO;
+		hasTypeMatchPattern= typeMatchPattern!=TYPE_ALL;
+		roseMatchPattern=0;
+		String filterRose=profile.filterRose;
+		if (filterRose.charAt(0) == '1') roseMatchPattern|=NW;
+		if (filterRose.charAt(1) == '1') roseMatchPattern|=NNW;
+		if (filterRose.charAt(2) == '1') roseMatchPattern|=N;
+		if (filterRose.charAt(3) == '1') roseMatchPattern|=NNE;
+		if (filterRose.charAt(4) == '1') roseMatchPattern|=NE;
+		if (filterRose.charAt(5) == '1') roseMatchPattern|=ENE;
+		if (filterRose.charAt(6) == '1') roseMatchPattern|=E;
+		if (filterRose.charAt(7) == '1') roseMatchPattern|=ESE;
+		if (filterRose.charAt(8) == '1') roseMatchPattern|=SE;
+		if (filterRose.charAt(9) == '1') roseMatchPattern|=SSE;
+		if (filterRose.charAt(10) == '1') roseMatchPattern|=S;
+		if (filterRose.charAt(11) == '1') roseMatchPattern|=SSW;
+		if (filterRose.charAt(12) == '1') roseMatchPattern|=SW;
+		if (filterRose.charAt(13) == '1') roseMatchPattern|=WSW;
+		if (filterRose.charAt(14) == '1') roseMatchPattern|=W;
+		if (filterRose.charAt(15) == '1') roseMatchPattern|=WNW;
+		hasRoseMatchPattern=roseMatchPattern!=ROSE_ALL;
+		sizeMatchPattern=0;
+		String filterSize=profile.filterSize;
+		if (filterSize.charAt(0) == '1') sizeMatchPattern|=MICRO;
+		if (filterSize.charAt(1) == '1') sizeMatchPattern|=SMALL;
+		if (filterSize.charAt(2) == '1') sizeMatchPattern|=REGULAR;
+		if (filterSize.charAt(3) == '1') sizeMatchPattern|=LARGE;
+		if (filterSize.charAt(4) == '1') sizeMatchPattern|=VERYLARGE;
+		if (filterSize.charAt(5) == '1') sizeMatchPattern|=OTHER;
+		hasSizeMatchPattern=sizeMatchPattern!=SIZE_ALL;
+		distdirec = profile.filterDist.charAt(0) == 'L' ? SMALLER : GREATER;
+		fscDist = Common.parseDouble(profile.filterDist.substring(1));  // Distance
+		diffdirec = profile.filterDiff.charAt(0) == 'L' ? SMALLER :
+					(profile.filterDiff.charAt(0) == '=' ? EQUAL : GREATER );
+		fscDiff = Common.parseDouble(profile.filterDiff.substring(1));  // Difficulty
+		terrdirec = profile.filterTerr.charAt(0) == 'L' ? SMALLER :
+				(profile.filterTerr.charAt(0) == '=' ? EQUAL : GREATER );
+		fscTerr = Common.parseDouble(profile.filterTerr.substring(1));  // Terrain
+		attributesYesPattern = profile.filterAttrYes;
+		attributesNoPattern = profile.filterAttrNo;
+		attributesChoice = profile.filterAttrChoice;
+	}
+
+	/**
+	*	Apply the filter. Caches that match a criteria are flagged
+	*	is_filtered = true. The table model is responsible for displaying or
+	*	not displaying a cache that is filtered.
+	*/
+	public void doFilter(){
+		Vector cacheDB=Global.getProfile().cacheDB;
+		if (cacheDB.size()==0) return;
+		if (!hasFilter()) { // If the filter was completely reset, we can just clear it
+			clearFilter();
+			return;
+		}
+		Global.getProfile().selectionChanged = true;
+		CacheHolder ch;
+		int cacheTypePattern;
+		int cacheRosePattern;
+		int cacheSizePattern;
+		// Values from filterscreen are parsed outside the main filter loop (fsc=FilterSCreen)
+		double dummyd1;
+		//Loop db and match once against type pattern and once against rose pattern
+		//Default is_filtered = false, means will be displayed!
+		//If cache does not match type or rose pattern then is_filtered is set to true
+		// and we proceed to next cache (no further tests needed)
+		//Then we check the other filter criteria one by one: As soon as one is found that
+		// eliminates the cache (i.e. sets is_filtered to true), we can skip the other tests
+		// A cache is only displayed (i.e. is_filtered = false) if it meets all 9 filter criteria
+		for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+			ch = (CacheHolder)cacheDB.get(i);
+			ch.is_filtered = ch.is_black^Global.getProfile().showBlacklisted;
+			///////////////////////////////
+			// Filter criterium 1: Cache type
+			///////////////////////////////
+			if (hasTypeMatchPattern) { // Only do the checks if we have a filter
+				cacheTypePattern = 0;
+				// As each cache can only have one type, we can use else if and set the type
+				if (ch.type==0) cacheTypePattern = CUSTOM;
+				else if(ch.type==2) cacheTypePattern = TRADITIONAL;
+				else if(ch.type==3) cacheTypePattern = MULTI;
+				else if(ch.type==4) cacheTypePattern = VIRTUAL;
+				else if(ch.type==5) cacheTypePattern = LETTER;
+				else if(ch.type==6) cacheTypePattern = EVENT;
+				else if(ch.type==8) cacheTypePattern = MYSTERY;
+				else if(ch.type==11) cacheTypePattern = WEBCAM;
+				else if(ch.type==12) cacheTypePattern = LOCLESS;
+				else if(ch.type==137)cacheTypePattern = EARTH;
+				else if(ch.type==453)cacheTypePattern = MEGA;
+				else if(ch.type==50)cacheTypePattern = PARKING;
+				else if(ch.type==51)cacheTypePattern = STAGE;
+				else if(ch.type==52)cacheTypePattern = QUESTION;
+				else if(ch.type==53)cacheTypePattern = FINAL;
+				else if(ch.type==54)cacheTypePattern = TRAILHEAD;
+				else if(ch.type==55)cacheTypePattern = REFERENCE;
+				else if(ch.type==13)cacheTypePattern = CITO;
+				else if(ch.type==1858)cacheTypePattern = WHERIGO;
+				if ((cacheTypePattern &amp; typeMatchPattern) == 0) { ch.is_filtered=true; continue; }
+			}
+			///////////////////////////////
+			// Filter criterium 2: Bearing from centre
+			///////////////////////////////
+			// The optimal number of comparisons to identify one of 16 objects is 4 (=log2(16))
+			// By using else if we can reduce the number of comparisons from 16 to just over 8
+			// By first checking the first letter, we can reduce the average number further to
+			// just under 5
+			if (hasRoseMatchPattern) {
+				if (ch.bearing.startsWith(&quot;N&quot;)) {
+					if(ch.bearing.equals(&quot;NW&quot;)) cacheRosePattern = NW;
+					else if(ch.bearing.equals(&quot;NNW&quot;)) cacheRosePattern = NNW;
+					else if(ch.bearing.equals(&quot;N&quot;)) cacheRosePattern = N;
+					else if(ch.bearing.equals(&quot;NNE&quot;)) cacheRosePattern = NNE;
+					else cacheRosePattern = NE;
+				} else if (ch.bearing.startsWith(&quot;E&quot;)) {
+					if(ch.bearing.equals(&quot;ENE&quot;)) cacheRosePattern = ENE;
+					else if(ch.bearing.equals(&quot;E&quot;)) cacheRosePattern = E;
+					else cacheRosePattern = ESE;
+				} else if (ch.bearing.startsWith(&quot;S&quot;)) {
+					if(ch.bearing.equals(&quot;SW&quot;)) cacheRosePattern = SW;
+					else if(ch.bearing.equals(&quot;SSW&quot;)) cacheRosePattern = SSW;
+					else if(ch.bearing.equals(&quot;S&quot;)) cacheRosePattern = S;
+					else if(ch.bearing.equals(&quot;SSE&quot;)) cacheRosePattern = SSE;
+					else cacheRosePattern = SE;
+				} else {
+					if(ch.bearing.equals(&quot;WNW&quot;)) cacheRosePattern = WNW;
+					else if(ch.bearing.equals(&quot;W&quot;)) cacheRosePattern = W;
+					else cacheRosePattern = WSW;
+				}
+				if ((cacheRosePattern &amp; roseMatchPattern) == 0) { ch.is_filtered=true; continue; }
+			}
+			///////////////////////////////
+			// Filter criterium 3: Distance
+			///////////////////////////////
+			if(fscDist&gt;0.0){
+				dummyd1 = Common.parseDouble(ch.distance.substring(0,ch.distance.length()-3));
+				if(distdirec == SMALLER &amp;&amp; dummyd1 &gt; fscDist)  { ch.is_filtered=true; continue; }
+				if(distdirec == GREATER &amp;&amp; dummyd1 &lt; fscDist)  { ch.is_filtered=true; continue; }
+			}
+			///////////////////////////////
+			// Filter criterium 4: Difficulty
+			///////////////////////////////
+			if(fscDiff&gt;0.0){
+				dummyd1 = Common.parseDouble(ch.hard);
+				if(diffdirec == SMALLER &amp;&amp; dummyd1 &gt; fscDiff) { ch.is_filtered=true; continue; }
+				if(diffdirec == EQUAL &amp;&amp; dummyd1 != fscDiff) { ch.is_filtered=true; continue; }
+				if(diffdirec == GREATER &amp;&amp; dummyd1 &lt; fscDiff) { ch.is_filtered=true; continue; }
+			}
+			///////////////////////////////
+			// Filter criterium 5: Terrain
+			///////////////////////////////
+			if(fscTerr&gt;0.0){
+				dummyd1 = Common.parseDouble(ch.terrain);
+				if(terrdirec == SMALLER &amp;&amp;  dummyd1 &gt; fscTerr) { ch.is_filtered=true; continue; }
+				if(terrdirec == EQUAL &amp;&amp; dummyd1 != fscTerr) { ch.is_filtered=true; continue; }
+				if(terrdirec == GREATER &amp;&amp;  dummyd1 &lt; fscTerr) { ch.is_filtered=true; continue; }
+			}
+//Vm.debug(ch.wayPoint+&quot; Found&quot;+ch.is_found+&quot;  FoundyMe=&quot;+foundByMe+&quot;   notFoundByMe=&quot;+notFoundByMe);
+//Vm.debug(ch.wayPoint+&quot; Owned&quot;+ch.is_owned+&quot;  OwnedByMe=&quot;+ownedByMe+&quot;   notOwnedByMe=&quot;+notOwnedByMe);
+//Vm.debug(ch.wayPoint+&quot; Archived&quot;+ch.is_archived+&quot;  Archived=&quot;+archived+&quot;   notArchived=&quot;+notArchived);
+//Vm.debug(ch.wayPoint+&quot; Available&quot;+ch.is_available+&quot;  Available=&quot;+available+&quot;   notAvailable=&quot;+notAvailable);
+//Vm.debug(&quot;Blacklisted: &quot;+ch.is_black);
+			///////////////////////////////
+			// Filter criterium 6: Found by me
+			///////////////////////////////
+			if((ch.is_found &amp;&amp; !foundByMe) ||
+			   (!ch.is_found &amp;&amp; !notFoundByMe)){ ch.is_filtered=true; continue; }
+			///////////////////////////////
+			// Filter criterium 7: Owned by me
+			///////////////////////////////
+			if((ch.is_owned &amp;&amp; !ownedByMe) ||
+			   (!ch.is_owned &amp;&amp; !notOwnedByMe)) { ch.is_filtered=true; continue; }
+
+			///////////////////////////////
+			// Filter criterium 8: Archived
+			///////////////////////////////
+			if((ch.is_archived &amp;&amp; !archived) ||
+			   (!ch.is_archived &amp;&amp; !notArchived)){ ch.is_filtered=true; continue; }
+
+			///////////////////////////////
+			// Filter criterium 9: Unavailable
+			///////////////////////////////
+			if((ch.is_available &amp;&amp; !available) ||
+			   (!ch.is_available &amp;&amp; !notAvailable)) { ch.is_filtered=true; continue; }
+			///////////////////////////////
+			// Filter criterium 10: Size
+			///////////////////////////////
+			if (hasSizeMatchPattern) {
+				cacheSizePattern=0;
+				if (ch.cacheSize.startsWith(&quot;M&quot;)) cacheSizePattern = MICRO;
+				else if (ch.cacheSize.startsWith(&quot;S&quot;)) cacheSizePattern = SMALL;
+				else if (ch.cacheSize.startsWith(&quot;R&quot;)) cacheSizePattern = REGULAR;
+				else if (ch.cacheSize.startsWith(&quot;L&quot;)) cacheSizePattern = LARGE;
+				else if (ch.cacheSize.startsWith(&quot;V&quot;)) cacheSizePattern = VERYLARGE;
+				else cacheSizePattern = OTHER;
+				if ((cacheSizePattern &amp; sizeMatchPattern) == 0) { ch.is_filtered=true; continue; }
+			}
+			///////////////////////////////
+			// Filter criterium 11: Attributes
+			///////////////////////////////
+			if ( (attributesYesPattern != 0 || attributesNoPattern != 0) &amp;&amp; ch.mainCache == null) {
+				if (attributesChoice == 0) {
+					// AND-condition:
+					if (
+						(ch.attributesYes &amp; attributesYesPattern) != attributesYesPattern
+						|| (ch.attributesNo &amp; attributesNoPattern) != attributesNoPattern )
+					{
+						ch.is_filtered=true;
+						continue;
+					}
+				} else if (attributesChoice == 1) {
+					// OR-condition:
+					if (
+						(ch.attributesYes &amp; attributesYesPattern) == 0
+						&amp;&amp; (ch.attributesNo &amp; attributesNoPattern) == 0 )
+					{
+						ch.is_filtered=true;
+						continue;
+					}
+				} else {
+					// NOT-condition:
+					if (
+						(ch.attributesYes &amp; attributesYesPattern) != 0
+						|| (ch.attributesNo &amp; attributesNoPattern) != 0 )
+					{
+						ch.is_filtered=true;
+						continue;
+					}
+				}
+			}
+		} // for
+		// Ensure that for all main caches that are filtered, the addis are also filtered independently of
+		// the filter status of the addi
+		if ((typeMatchPattern &amp; TYPE_MAIN) != 0){ //exception: don't filter out correxpnding Addis, if only Addis are enabled
+			for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+				ch = (CacheHolder)cacheDB.get(i);
+				if (ch.mainCache!=null) {
+					// We have found an addi, filte it if its parent is filtered
+					ch.is_filtered|=ch.mainCache.is_filtered;
+				}
+			}
+		}
+		for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+			ch = (CacheHolder)cacheDB.get(i);
+			if (ch.mainCache!=null) {
+				// We have found an addi, filte it if its parent is filtered
+				ch.is_filtered|=ch.mainCache.is_filtered;
+			}
+		}
+		Global.getProfile().filterActive=FILTER_ACTIVE;
+		Global.getProfile().filterInverted=false;
+		Global.getProfile().hasUnsavedChanges=true;
+	}
+
+	/**
+	*	Invert is_filtered flag on all caches
+	*/
+	public void invertFilter(){
+		Vector cacheDB=Global.getProfile().cacheDB;
+		CacheHolder ch;
+		if (cacheDB.size()==0) return;
+		Global.getProfile().selectionChanged = true;
+		boolean showBlackListed=Global.getProfile().showBlacklisted;
+		for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+			ch = (CacheHolder)cacheDB.get(i);
+			if (ch.is_black==showBlackListed)
+				ch.is_filtered=!ch.is_filtered; // Only invert those that would be shown under blacklist filter
+			else
+				ch.is_filtered=true; // Hide all those that have the wrong is_black status
+		}
+		Global.getProfile().filterInverted=!Global.getProfile().filterInverted;
+		Global.getProfile().hasUnsavedChanges=true;
+	}
+
+	/**
+	*	Clear the is_filtered flag from the cache database.
+	*/
+	public void clearFilter(){
+		Global.getProfile().selectionChanged = true;
+		Vector cacheDB=Global.getProfile().cacheDB;
+		CacheHolder ch;
+		for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+			ch = (CacheHolder)cacheDB.get(i);
+			ch.is_filtered=(ch.is_black^Global.getProfile().showBlacklisted) ; // Always filter blacklisted caches
+		}
+		Global.getProfile().filterActive=FILTER_INACTIVE;
+		Global.getProfile().filterInverted=false;
+		Global.getProfile().hasUnsavedChanges=true;
+	}
+
+	public boolean hasFilter() {
+		Profile prof=Global.getProfile();
+		return !(prof.filterType.equals(Profile.FILTERTYPE) &amp;&amp;
+		    prof.filterRose.equals(Profile.FILTERROSE) &amp;&amp;
+		    prof.filterVar.equals(Profile.FILTERVAR) &amp;&amp;
+		    prof.filterSize.equals(Profile.FILTERSIZE) &amp;&amp;
+		    prof.filterDist.equals(&quot;L&quot;) &amp;&amp;
+		    prof.filterDiff.equals(&quot;L&quot;) &amp;&amp;
+		    prof.filterTerr.equals(&quot;L&quot;) &amp;&amp;
+		    prof.filterAttrYes == 0l &amp;&amp;
+		    prof.filterAttrNo == 0l);
+	}
+
+}
+

Added: experiments/EVE/src/cachewolf/FilterScreen.java
===================================================================
--- experiments/EVE/src/cachewolf/FilterScreen.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/FilterScreen.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,687 @@
+package cachewolf;
+import eve.ui.*;
+import eve.ui.event.*;
+import eve.fx.*;
+import eve.sys.*;
+import eve.ui.filechooser.*;
+
+/**
+*	This class displays a form that the user uses to set the filter criteria.
+*	Class ID=700
+*/
+public class FilterScreen extends Form{
+	private static final Color COLOR_FILTERINACTIVE=new Color(190,190,190);
+	private static final Color COLOR_FILTERACTIVE=new Color(0,255,0);
+	private static final Color COLOR_FILTERALL=new Color(255,0,0); // Red
+
+	private Button btnCancel, btnApply,
+					btnBearing,btnTypes,btnAttributes,btnRatings,btnContainer,btnAddi, btnSelect,btnDeselect,btnCacheAttributes;
+	//private Button btnSearch;
+	private Choice chcDist, chcDiff, chcTerr, chcAttrib;
+	private CheckBox chkFound, chkNotFound, chkTrad, chkVirtual, chkEvent, chkEarth, chkMega,
+					  chkOwned, chkNotOwned, chkMulti, chkLetter, chkWebcam, chkMystery, chkLocless,
+	                  chkCustom,chkParking,	chkStage, chkQuestion, chkFinal, chkTrailhead, chkReference,
+					  chkMicro,chkSmall,chkRegular,chkLarge,chkVeryLarge,chkOther,chkCito,
+	                  chkArchived,chkNotArchived, chkAvailable,chkNotAvailable,
+					  chkNW, chkNNW , chkN , chkNNE, chkNE, chkENE, chkE, chkESE, chkSE, chkSSE, chkS,
+					  chkSSW, chkSW, chkWSW, chkW, chkWNW,chkWherigo;
+
+	private Input inpDist, inpTerr, inpDiff;
+
+	AttributesSelector attV;
+
+	private CellPanel pnlBearDist=new CellPanel();
+	private CellPanel pnlAttributes=new CellPanel();
+	private CellPanel pnlRatings=new CellPanel();
+	private CellPanel pnlCacheTypes=new CellPanel();
+	private CellPanel pnlContainer=new CellPanel();
+	private CellPanel pnlSearch=new CellPanel();
+	private CellPanel pnlRose = new CellPanel();
+	private CellPanel pnlAddi=new CellPanel();
+	private CellPanel pnlCacheAttributes=new CellPanel();
+	private CardPanel cp=new CardPanel();
+
+	// A subclassed checkbox with a &quot;third&quot; state (=grey background).
+	// If all addi wpts are false or all addi wpts are true, the background is white
+	// If the addi wpt filter is a mixture of true/false, the bg is grey
+	// Thus the addi filter can be set in one of two ways: Using the single checkbox with all the other
+	// attributes, or using the multiple checkboxes for each addi waypoint type
+	private class myChkBox extends CheckBox {
+		Color bgColor=Color.White;
+		myChkBox(String s) {super(s); }
+		public void doPaintSquare(Graphics g) {
+			int h = height;
+			g.setColor(bgColor);
+			int sp = 2*boxWidth/15;
+			int bx = text.length() == 0 ? 0 : 2;
+			int by = text.length() == 0 ? 0 : (h-boxWidth)/2+1;
+			g.fillRect(bx+2,by+2,boxWidth-4,boxWidth-4);
+			if (state || pressState){
+				Color c = Color.LightGray;
+				if (!pressState){
+					if (!state)
+						c=bgColor;
+					else
+						c=Color.Black;
+				}
+				Pen oldPen = g.getPen(Pen.getCached());
+				g.changePen(c,Pen.SOLID,sp);
+//				Pen oldpen = g.setPen(new Pen(c,Pen.SOLID,2));
+				g.drawLine(bx+4,by+boxWidth-5,bx+boxWidth-5,by+4);
+				g.drawLine(bx+4,by+boxWidth-5,bx+4,by+boxWidth-10);
+//				g.drawLine(bx+3,by+3,bx+boxWidth-5,by+boxWidth-5);
+//				g.drawLine(bx+3,by+boxWidth-5,bx+boxWidth-5,by+3);
+				g.set(oldPen);
+				oldPen.cache();
+			}
+			g.draw3DRect(new Rect(bx,by,boxWidth,boxWidth),	GuiStyle.checkboxEdge,true,null,Color.DarkGray);
+		}
+	}
+	private myChkBox addiWptChk;
+
+	private Button addImg(String imgName) {
+		Button mb=new Button(new Picture(imgName)); mb.borderWidth=0; mb.modify(NotEditable|PreferredSizeOnly,0);
+		return mb;
+	}
+	private void addTitle(CellPanel c, String title) {
+		Label lblTitle;
+		c.addLast(lblTitle=new Label(title),HSTRETCH,FILL|CENTER);
+		lblTitle.backGround=new Color(127,127,127);
+		lblTitle.foreGround=Color.White;
+		lblTitle.setTag(TAG_INSETS,new Insets(2,0,4,0));
+	}
+
+	public FilterScreen() {
+		this.title = MyLocale.getMsg(700,&quot;Set Filter&quot;);
+
+		//////////////////////////
+		// Panel 1 - Bearing &amp; Distance
+		//////////////////////////
+		addTitle(pnlBearDist,MyLocale.getMsg(714,&quot;Bearings &amp; Distance&quot;));
+		pnlBearDist.addNext(new Label(MyLocale.getMsg(701,&quot;Distance: &quot;)),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlBearDist.addNext(chcDist = new Choice(new String[]{&quot;&lt;=&quot;, &quot;&gt;=&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlBearDist.addLast(inpDist = new Input(),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlBearDist.addLast(new Label(&quot;&quot;));
+		pnlRose.addNext(chkNW = new CheckBox(&quot;NW&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkNNW = new CheckBox(&quot;NNW&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkN = new CheckBox(&quot;N&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addLast(chkNNE = new CheckBox(&quot;NNE&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+
+		pnlRose.addNext(chkNE = new CheckBox(&quot;NE&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkENE = new CheckBox(&quot;ENE&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkE = new CheckBox(&quot;E &quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addLast(chkESE = new CheckBox(&quot;ESE&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+
+		pnlRose.addNext(chkSE = new CheckBox(&quot;SE&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkSSE = new CheckBox(&quot;SSE&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkS = new CheckBox(&quot;S&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addLast(chkSSW = new CheckBox(&quot;SSW&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+
+		pnlRose.addNext(chkSW = new CheckBox(&quot;SW&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkWSW = new CheckBox(&quot;WSW&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(chkW = new CheckBox(&quot;W &quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addLast(chkWNW = new CheckBox(&quot;WNW&quot;),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlRose.addNext(btnDeselect=new Button(MyLocale.getMsg(716,&quot;Deselect all&quot;)),CellConstants.HSTRETCH, CellConstants.FILL);
+		btnDeselect.setTag(TAG_SPAN,new Dimension(2,1));
+		pnlRose.addLast(btnSelect=new Button(MyLocale.getMsg(717,&quot;Select all&quot;)),CellConstants.HSTRETCH, CellConstants.FILL);
+		pnlBearDist.addLast(pnlRose, CellConstants.STRETCH,CellConstants.FILL);
+
+		//////////////////////////
+		// Panel 2 - Cache attributes
+		//////////////////////////
+		addTitle(pnlAttributes,MyLocale.getMsg(720,&quot;Status&quot;));
+		Label lblTitleAtt;
+		pnlAttributes.addLast(lblTitleAtt=new Label(MyLocale.getMsg(715,&quot;Show all caches with status:&quot;)),HSTRETCH,FILL);
+		lblTitleAtt.setTag(TAG_SPAN,new Dimension(2,1));
+		pnlAttributes.addNext(chkArchived = new CheckBox(MyLocale.getMsg(710,&quot;Archived&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addLast(chkNotArchived = new CheckBox(MyLocale.getMsg(729,&quot;Nicht archiviert&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		pnlAttributes.addNext(chkAvailable = new CheckBox(MyLocale.getMsg(730,&quot;Suchbar&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addLast(chkNotAvailable = new CheckBox(MyLocale.getMsg(711,&quot;Not available&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		pnlAttributes.addNext(chkFound = new CheckBox(MyLocale.getMsg(703,&quot;Found&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addLast(chkNotFound = new CheckBox(MyLocale.getMsg(731,&quot;Noch nicht gefunden&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		pnlAttributes.addNext(chkOwned = new CheckBox(MyLocale.getMsg(707,&quot;Owned&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAttributes.addLast(chkNotOwned = new CheckBox(MyLocale.getMsg(732,&quot;Anderer Besitzer&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		//////////////////////////
+		// Panel 3 - Cache ratings
+		//////////////////////////
+		addTitle(pnlRatings,MyLocale.getMsg(718,&quot;Cache ratings&quot;));
+		pnlRatings.addNext(new Label(MyLocale.getMsg(702,&quot;Difficulty: &quot;)),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlRatings.addNext(chcDiff = new Choice(new String[]{&quot;&lt;=&quot;,&quot;=&quot;, &quot;&gt;=&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		//pnlRatings.addLast(difIn = new Choice(new String[]{&quot;1.0&quot;, &quot;1.5&quot;, &quot;2.0&quot;, &quot;2.5&quot;, &quot;3.0&quot;, &quot;3.5&quot;, &quot;4.0&quot;, &quot;4.5&quot;, &quot;5.0&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlRatings.addLast(inpDiff = new Input(),CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		pnlRatings.addNext(new Label(&quot;Terrain: &quot;),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlRatings.addNext(chcTerr = new Choice(new String[]{&quot;&lt;=&quot;, &quot;=&quot;, &quot;&gt;=&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		//pnlRatings.addLast(terrIn = new Choice(new String[]{&quot;1.0&quot;, &quot;1.5&quot;, &quot;2.0&quot;, &quot;2.5&quot;, &quot;3.0&quot;, &quot;3.5&quot;, &quot;4.0&quot;, &quot;4.5&quot;, &quot;5.0&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlRatings.addLast(inpTerr = new Input(),CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		//////////////////////////
+		// Panel 4 - Cache types
+		//////////////////////////
+
+		addTitle(pnlCacheTypes,MyLocale.getMsg(719,&quot;Cache types&quot;));
+		pnlCacheTypes.addNext(addImg(&quot;2.png&quot;));
+		pnlCacheTypes.addNext(chkTrad = new CheckBox(&quot;Traditonal&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		pnlCacheTypes.addNext(addImg(&quot;3.png&quot;));
+		pnlCacheTypes.addLast(chkMulti = new CheckBox(&quot;Multi&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		pnlCacheTypes.addNext(addImg(&quot;4.png&quot;));
+		pnlCacheTypes.addNext(chkVirtual = new CheckBox(&quot;Virtual&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		pnlCacheTypes.addNext(addImg(&quot;5.png&quot;));
+		pnlCacheTypes.addLast(chkLetter = new CheckBox(&quot;Letterbox&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		pnlCacheTypes.addNext(addImg(&quot;6.png&quot;));
+		pnlCacheTypes.addNext(chkEvent = new CheckBox(&quot;Event&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		pnlCacheTypes.addNext(addImg(&quot;11.png&quot;));
+		pnlCacheTypes.addLast(chkWebcam = new CheckBox(&quot;Webcam&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		pnlCacheTypes.addNext(addImg(&quot;8.png&quot;));
+		pnlCacheTypes.addNext(chkMystery = new CheckBox(&quot;Mystery&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		pnlCacheTypes.addNext(addImg(&quot;137.png&quot;));
+		pnlCacheTypes.addLast(chkEarth = new CheckBox(&quot;Earth&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		pnlCacheTypes.addNext(addImg(&quot;12.png&quot;));
+		pnlCacheTypes.addNext(chkLocless = new CheckBox(&quot;Locationless&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		pnlCacheTypes.addNext(addImg(&quot;453.png&quot;));
+		pnlCacheTypes.addLast(chkMega = new CheckBox(&quot;Mega-Ev.&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		pnlCacheTypes.addNext(addImg(&quot;13.png&quot;));
+		pnlCacheTypes.addNext(chkCito = new CheckBox(&quot;Cito-Ev.&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		//pnlCacheTypes.addLast(addiWptChk = new CheckBox(&quot;Add. Wpt&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		//pnlCacheTypes.addLast(new Label(&quot;&quot;));
+		pnlCacheTypes.addNext(addImg(&quot;0.png&quot;));
+		pnlCacheTypes.addLast(chkCustom = new CheckBox(&quot;Custom&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		pnlCacheTypes.addNext(addImg(&quot;1858.png&quot;));
+		pnlCacheTypes.addNext(chkWherigo = new myChkBox(&quot;WherIGo&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		pnlCacheTypes.addNext(addImg(&quot;110.png&quot;));
+		pnlCacheTypes.addNext(addiWptChk = new myChkBox(&quot;Add. Wpt&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+
+		//addiWptChk.modify(0,NotAnEditor);
+		//////////////////////////
+		// Panel 5 - Addi waypoints
+		//////////////////////////
+		addTitle(pnlAddi,MyLocale.getMsg(726,&quot;Additional waypoints&quot;));
+		pnlAddi.addNext(addImg(&quot;pkg.png&quot;));
+		pnlAddi.addNext(chkParking = new CheckBox(&quot;Parking&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAddi.addNext(addImg(&quot;stage.png&quot;));
+		pnlAddi.addLast(chkStage = new CheckBox(&quot;Stage&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAddi.addNext(addImg(&quot;puzzle.png&quot;));
+		pnlAddi.addNext(chkQuestion = new CheckBox(&quot;Question&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAddi.addNext(addImg(&quot;flag.png&quot;));
+		pnlAddi.addLast(chkFinal = new CheckBox(&quot;Final&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAddi.addNext(addImg(&quot;trailhead.png&quot;));
+		pnlAddi.addNext(chkTrailhead = new CheckBox(&quot;Trailhead&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlAddi.addNext(addImg(&quot;waypoint.png&quot;));
+		pnlAddi.addLast(chkReference = new CheckBox(&quot;Reference&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+        pnlAddi.addLast(new Label(&quot;&quot;),VSTRETCH,FILL);
+
+		//////////////////////////
+		// Panel 6 - Cache container
+		//////////////////////////
+		addTitle(pnlContainer,MyLocale.getMsg(727,&quot;Cache container&quot;));
+		pnlContainer.addLast(chkMicro=new CheckBox(&quot;Micro&quot;));
+		pnlContainer.addLast(chkSmall=new CheckBox(&quot;Small&quot;));
+		pnlContainer.addLast(chkRegular=new CheckBox(&quot;Regular&quot;));
+		pnlContainer.addLast(chkLarge=new CheckBox(&quot;Large&quot;));
+		pnlContainer.addLast(chkVeryLarge=new CheckBox(&quot;Very Large&quot;));
+		pnlContainer.addLast(chkOther=new CheckBox(&quot;Other&quot;));
+
+		//////////////////////////
+		// Panel 7 - Search
+		//////////////////////////
+		addTitle(pnlSearch,&quot;Search&quot;);
+		pnlSearch.addLast(new Label(&quot;To be implemented&quot;));
+
+
+		//////////////////////////
+		// Panel 8 - Cache attributes
+		//////////////////////////
+
+		if (MyLocale.getScreenHeight()&gt;240) addTitle(pnlCacheAttributes,MyLocale.getMsg(737,&quot;Attributes&quot;));
+		pnlCacheAttributes.addNext(new Label(MyLocale.getMsg(739,&quot;Filter on&quot;)+&quot;:&quot;), CellConstants.DONTSTRETCH, CellConstants.FILL);
+		pnlCacheAttributes.addLast(chcAttrib = new Choice(new String[]{MyLocale.getMsg(740,&quot;all&quot;), MyLocale.getMsg(741,&quot;one&quot;), MyLocale.getMsg(742,&quot;none&quot;)},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+
+		attV=new AttributesSelector();
+		pnlCacheAttributes.addLast(attV, CellConstants.STRETCH|CellConstants.LEFT, CellConstants.STRETCH);
+		attV.setSelectionMasks( 0l, 0l );
+
+		CellPanel frmScreen=new CellPanel();
+		Label lblInfo;
+		frmScreen.addLast(lblInfo=new Label(MyLocale.getMsg(725,&quot;Note: Filters are additive, active filter=green&quot;))).setTag(TAG_SPAN,new Dimension(2,1));
+		lblInfo.setTag(TAG_INSETS,new Insets(0,0,2,0));
+		frmScreen.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_BOTTOM;
+		this.addLast(frmScreen,HSTRETCH,HFILL);
+
+		CellPanel pnlButtons=new CellPanel();
+		pnlButtons.addLast(new Label(&quot;Filter&quot;));
+		pnlButtons.addLast(btnBearing=new Button(MyLocale.getMsg(721,&quot;Bearing&quot;)));
+		pnlButtons.addLast(btnAttributes=new Button(MyLocale.getMsg(720,&quot;Attributes&quot;)));
+		pnlButtons.addLast(btnRatings=new Button(MyLocale.getMsg(722,&quot;Ratings&quot;)));
+		pnlButtons.addLast(btnTypes=new Button(MyLocale.getMsg(723,&quot;Types&quot;)));
+		pnlButtons.addLast(btnAddi=new Button(MyLocale.getMsg(733,&quot;Add. Wpt&quot;)));
+		pnlButtons.addLast(btnContainer=new Button(MyLocale.getMsg(724,&quot;Container&quot;)));
+		pnlButtons.addLast(btnCacheAttributes=new Button(MyLocale.getMsg(738,&quot;Attributes&quot;)));
+		// Search ist f&#252;r 0.9n noch deaktiviert
+		//pnlButtons.addLast(btnSearch=new Button(&quot;Search&quot;)); btnSearch.modify(Disabled,0);
+		addNext(pnlButtons,HSTRETCH,FILL);
+
+		cp.addItem(pnlBearDist,&quot;Bear&quot;,null);
+		cp.addItem(pnlAttributes,&quot;Att&quot;,null);
+		cp.addItem(pnlRatings,&quot;DT&quot;,null);
+		cp.addItem(pnlCacheTypes,&quot;Type&quot;,null);
+		cp.addItem(pnlAddi,&quot;Addi&quot;,null);
+		cp.addItem(pnlContainer,&quot;Size&quot;,null);
+		cp.addItem(pnlSearch,&quot;Search&quot;,null);
+		cp.addItem(pnlCacheAttributes,&quot;Attr&quot;,null);
+		addLast(cp,VSTRETCH,FILL);
+
+		CellPanel btPanel = new CellPanel();
+		btPanel.addNext(btnCancel = new Button(MyLocale.getMsg(708,&quot;Cancel&quot;)),CellConstants.STRETCH, CellConstants.FILL);
+		btPanel.addLast(btnApply = new Button(MyLocale.getMsg(709,&quot;Apply&quot;)),CellConstants.STRETCH, CellConstants.FILL);
+		//nbtPanel.addLast(btnRoute = new Button(&quot;Route&quot;),CellConstants.STRETCH, CellConstants.FILL);
+		addLast(btPanel.setTag(Control.TAG_SPAN, new Dimension(3,1)), CellConstants.STRETCH, CellConstants.FILL);
+
+		int sw = MyLocale.getScreenWidth(); int sh = MyLocale.getScreenHeight();
+		Preferences pref = Global.getPref();int fs = pref.fontSize;
+		int psx; int psy;
+		if((sw&gt;300) &amp;&amp; (sh&gt;300)){
+			// larger screens: size according to fontsize
+			psx=240;psy=260;
+			if(fs &gt; 12){psx=300;psy=330;}
+			if(fs &gt; 17){psx=400;psy=340;}
+			if(fs &gt; 23){psx=500;psy=350;}
+			setPreferredSize(psx,psy);
+		}
+		else{
+			// small screens: fixed size
+			if (sh&gt;240)
+				setPreferredSize(240,260);
+			else
+				setPreferredSize(240,240);
+		}
+		cp.select(3);
+	}
+
+
+	public void setData(){
+		Profile prof=Global.getProfile();
+
+		//////////////////////////
+		// Panel 1 - Bearing &amp; Distance
+		//////////////////////////
+		if (prof.filterDist.length()&gt;1) {
+			if (prof.filterDist.charAt(0)=='L')
+				chcDist.select(0);
+			else
+				chcDist.select(1);
+			inpDist.setText(prof.filterDist.substring(1));
+		} else {
+			chcDist.select(0);
+			inpDist.setText(&quot;&quot;);
+		}
+		String fltRose=prof.filterRose;
+		chkNW.state   = fltRose.charAt(0) == '1';
+		chkNNW.state  = fltRose.charAt(1) == '1';
+		chkN.state    = fltRose.charAt(2) == '1';
+		chkNNE.state  = fltRose.charAt(3) == '1';
+
+		chkNE.state   = fltRose.charAt(4) == '1';
+		chkENE.state  = fltRose.charAt(5) == '1';
+		chkE.state    = fltRose.charAt(6) == '1';
+		chkESE.state  = fltRose.charAt(7) == '1';
+
+		chkSE.state   = fltRose.charAt(8) == '1';
+		chkSSE.state  = fltRose.charAt(9) == '1';
+		chkS.state    = fltRose.charAt(10) == '1';
+		chkSSW.state  = fltRose.charAt(11) == '1';
+
+		chkSW.state   = fltRose.charAt(12) == '1';
+		chkWSW.state  = fltRose.charAt(13) == '1';
+		chkW.state    = fltRose.charAt(14) == '1';
+		chkWNW.state  = fltRose.charAt(15) == '1';
+
+		//////////////////////////
+		// Panel 2 - Cache attributes
+		//////////////////////////
+		String fltVar=prof.filterVar;
+		chkArchived.state      = fltVar.charAt(0) == '1';
+		chkAvailable.state     = fltVar.charAt(1) == '1';
+		chkFound.state         = fltVar.charAt(2) == '1';
+		chkOwned.state         = fltVar.charAt(3) == '1';
+		chkNotArchived.state   = fltVar.charAt(4) == '1';
+		chkNotAvailable.state  = fltVar.charAt(5) == '1';
+		chkNotFound.state      = fltVar.charAt(6) == '1';
+		chkNotOwned.state      = fltVar.charAt(7) == '1';
+
+		//////////////////////////
+		// Panel 3 - Cache ratings
+		//////////////////////////
+		if (prof.filterDiff.length()&gt;1) {
+			if (prof.filterDiff.charAt(0)=='L')
+				chcDiff.select(0);
+			else if (prof.filterDiff.charAt(0)=='=')
+				chcDiff.select(1);
+			else
+				chcDiff.select(2);
+			inpDiff.setText(prof.filterDiff.substring(1));
+		} else {
+			chcDiff.select(0);
+			inpDiff.setText(&quot;&quot;);
+		}
+
+		if (prof.filterTerr.length()&gt;1) {
+			if (prof.filterTerr.charAt(0)=='L')
+				chcTerr.select(0);
+			else if (prof.filterTerr.charAt(0)=='=')
+				chcTerr.select(1);
+			else
+				chcTerr.select(2);
+			inpTerr.setText(prof.filterTerr.substring(1));
+		} else {
+			chcTerr.select(0);
+			inpTerr.setText(&quot;&quot;);
+		}
+
+
+		//////////////////////////
+		// Panel 4 - Cache types
+		//////////////////////////
+
+		String fltType=prof.filterType;
+		chkTrad.state       = fltType.charAt(0) == '1';
+		chkMulti.state      = fltType.charAt(1) == '1';
+		chkVirtual.state    = fltType.charAt(2) == '1';
+		chkLetter.state     = fltType.charAt(3) == '1';
+		chkEvent.state      = fltType.charAt(4) == '1';
+		chkWebcam.state     = fltType.charAt(5) == '1';
+		chkMystery.state    = fltType.charAt(6) == '1';
+		chkEarth.state      = fltType.charAt(7) == '1';
+		chkLocless.state    = fltType.charAt(8) == '1';
+		chkMega.state       = fltType.charAt(9) == '1';
+		chkCustom.state     = fltType.charAt(10) == '1';
+		chkCito.state       = fltType.charAt(17) == '1';
+		chkWherigo.state    = fltType.charAt(18) == '1';
+
+		// Note addiWptState is set by setColors
+
+		//////////////////////////
+		// Panel 5 - Additional waypoints
+		//////////////////////////
+		chkParking.state    = fltType.charAt(11) == '1';
+		chkStage.state      = fltType.charAt(12) == '1';
+		chkQuestion.state   = fltType.charAt(13) == '1';
+		chkFinal.state      = fltType.charAt(14) == '1';
+		chkTrailhead.state  = fltType.charAt(15) == '1';
+		chkReference.state  = fltType.charAt(16) == '1';
+		addiWptChk.state= !fltType.substring(11,17).equals(&quot;000000&quot;);
+
+		//////////////////////////
+		// Panel 6 - Cache container
+		//////////////////////////
+		String fltSize=prof.filterSize;
+		chkMicro.state      = fltSize.charAt(0) == '1';
+		chkSmall.state      = fltSize.charAt(1) == '1';
+		chkRegular.state    = fltSize.charAt(2) == '1';
+		chkLarge.state      = fltSize.charAt(3) == '1';
+		chkVeryLarge.state  = fltSize.charAt(4) == '1';
+		chkOther.state      = fltSize.charAt(5) == '1';
+
+		//////////////////////////
+		// Panel 7 - Search
+		//////////////////////////
+
+		//////////////////////////
+		// Panel 8 - Cache attributes
+		//////////////////////////
+		attV.setSelectionMasks( prof.filterAttrYes, prof.filterAttrNo );
+		chcAttrib.select(prof.filterAttrChoice);
+
+		// Adjust colors of buttons depending on which filters are active
+		setColors();
+	}
+
+	// Set the colors of the filter buttons according to which filters are active
+	private void setColors() {
+		// Panel 1 - Bearing &amp; Distance
+		if (inpDist.getText().length()&gt;0 ||
+			  !(chkNW.state &amp;&amp; chkNNW.state &amp;&amp; chkN.state &amp;&amp; chkNNE.state &amp;&amp;
+				chkNE.state &amp;&amp; chkENE.state &amp;&amp; chkE.state &amp;&amp; chkESE.state &amp;&amp;
+				chkSE.state &amp;&amp; chkSSE.state &amp;&amp; chkS.state &amp;&amp; chkSSW.state &amp;&amp;
+				chkSW.state &amp;&amp; chkWSW.state &amp;&amp; chkW.state &amp;&amp; chkWNW.state))
+			btnBearing.backGround=COLOR_FILTERACTIVE;
+		else
+			btnBearing.backGround=COLOR_FILTERINACTIVE;
+		if (  !(chkNW.state || chkNNW.state || chkN.state || chkNNE.state ||
+				chkNE.state || chkENE.state || chkE.state || chkESE.state ||
+				chkSE.state || chkSSE.state || chkS.state || chkSSW.state ||
+				chkSW.state || chkWSW.state || chkW.state || chkWNW.state))
+			btnBearing.backGround=COLOR_FILTERALL;
+		btnBearing.repaint();
+
+		// Panel 2 - Cache attributes
+		if (!( chkArchived.state    &amp;&amp; chkAvailable.state    &amp;&amp; chkFound.state    &amp;&amp; chkOwned.state &amp;&amp;
+			   chkNotArchived.state &amp;&amp; chkNotAvailable.state &amp;&amp; chkNotFound.state &amp;&amp; chkNotOwned.state))
+			btnAttributes.backGround=COLOR_FILTERACTIVE;
+		else
+			btnAttributes.backGround=COLOR_FILTERINACTIVE;
+		if ((chkArchived.state==false &amp;&amp; chkNotArchived.state==false) ||
+			    (chkAvailable.state==false &amp;&amp; chkNotAvailable.state==false) ||
+			    (chkFound.state==false &amp;&amp; chkNotFound.state==false) ||
+			    (chkOwned.state==false &amp;&amp; chkNotOwned.state==false))
+			btnAttributes.backGround=COLOR_FILTERALL;
+		btnAttributes.repaint();
+
+		// Panel 3 - Cache ratings
+		if (inpDiff.getText().length()&gt;0 || inpTerr.getText().length()&gt;0)
+			btnRatings.backGround=COLOR_FILTERACTIVE;
+		else
+			btnRatings.backGround=COLOR_FILTERINACTIVE;
+		btnRatings.repaint();
+
+		// Panel 5 - Addi Waypoints
+		if (chkParking.state || chkStage.state || chkQuestion.state ||
+			chkFinal.state || chkTrailhead.state || chkReference.state ) { // At least one tick
+			btnAddi.backGround=COLOR_FILTERACTIVE;
+			addiWptChk.state=true;
+			if (chkParking.state &amp;&amp; chkStage.state &amp;&amp;  chkQuestion.state &amp;&amp;
+				chkFinal.state &amp;&amp; chkTrailhead.state &amp;&amp; chkReference.state ) { // All ticked?
+				addiWptChk.bgColor=Color.White;
+				btnAddi.backGround=COLOR_FILTERINACTIVE;
+			} else {
+				addiWptChk.bgColor=Color.LightGray;
+			}
+		} else { // All not ticked
+			btnAddi.backGround=COLOR_FILTERACTIVE;
+			addiWptChk.bgColor=Color.White;
+			addiWptChk.state=false;
+		}
+		btnAddi.repaint();
+
+		// Panel 4 - Cache types
+		boolean allAddis=(chkParking.state &amp;&amp; chkStage.state &amp;&amp;  chkQuestion.state &amp;&amp;
+		chkFinal.state &amp;&amp; chkTrailhead.state &amp;&amp; chkReference.state) ;
+		if (!(chkTrad.state &amp;&amp; chkMulti.state &amp;&amp; 	chkVirtual.state &amp;&amp; chkLetter.state &amp;&amp;
+		      chkEvent.state &amp;&amp; chkWebcam.state &amp;&amp; chkMystery.state &amp;&amp; chkEarth.state &amp;&amp;
+		      chkLocless.state &amp;&amp; chkMega.state &amp;&amp; chkCito.state &amp;&amp; chkWherigo.state &amp;&amp; chkCustom.state &amp;&amp; allAddis) )
+			btnTypes.backGround=COLOR_FILTERACTIVE;
+		else
+			btnTypes.backGround=COLOR_FILTERINACTIVE;
+		if (!(chkTrad.state || chkMulti.state || 	chkVirtual.state || chkLetter.state ||
+			      chkEvent.state || chkWebcam.state || chkMystery.state || chkEarth.state ||
+			      chkLocless.state || chkMega.state || chkCustom.state || chkParking.state
+			      || chkStage.state || chkQuestion.state ||
+					chkFinal.state || chkTrailhead.state || chkCito.state || chkWherigo.state || chkReference.state ))
+			btnTypes.backGround=COLOR_FILTERALL;
+		btnTypes.repaint();
+
+
+		// Panel 6 - Cache container
+		if (!(chkMicro.state &amp;&amp; chkSmall.state &amp;&amp; chkRegular.state &amp;&amp;
+			  chkLarge.state &amp;&amp; chkVeryLarge.state &amp;&amp; chkOther.state))
+			  btnContainer.backGround=COLOR_FILTERACTIVE;
+		else
+			  btnContainer.backGround=COLOR_FILTERINACTIVE;
+		if (!(chkMicro.state || chkSmall.state || chkRegular.state ||
+				  chkLarge.state || chkVeryLarge.state || chkOther.state))
+			  btnContainer.backGround=COLOR_FILTERALL;
+		btnContainer.repaint();
+
+		// Panel 7 - Search
+
+		// Panel 8 - Cache attributes
+		if ( attV.selectionMaskYes == 0l &amp;&amp; attV.selectionMaskNo == 0l)
+			btnCacheAttributes.backGround=COLOR_FILTERINACTIVE;
+		else
+			btnCacheAttributes.backGround=COLOR_FILTERACTIVE;
+		btnCacheAttributes.repaint();
+
+
+	}
+
+	/**
+	*	React to the users input, create a filter and set the variable of the filter.
+	*	@see Filter
+	*/
+	public void onEvent(Event ev){
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (ev.target == btnCancel){
+				this.close(0);
+			}
+			else if (ev.target == btnApply){
+				Form.showWait();
+				//Save filter required
+				Profile pfl = Global.getProfile();
+				pfl.filterVar = (chkArchived.state    ? &quot;1&quot; : &quot;0&quot;) +
+							(chkAvailable.state   ? &quot;1&quot; : &quot;0&quot;) +
+							(chkFound.state       ? &quot;1&quot; : &quot;0&quot;) +
+							(chkOwned.state       ? &quot;1&quot; : &quot;0&quot;) +
+							(chkNotArchived.state ? &quot;1&quot; : &quot;0&quot;) +
+							(chkNotAvailable.state? &quot;1&quot; : &quot;0&quot;) +
+							(chkNotFound.state    ? &quot;1&quot; : &quot;0&quot;) +
+							(chkNotOwned.state    ? &quot;1&quot; : &quot;0&quot;);
+				pfl.filterType =(chkTrad.state    ? &quot;1&quot; : &quot;0&quot;) +
+								(chkMulti.state   ? &quot;1&quot; : &quot;0&quot;) +
+								(chkVirtual.state ? &quot;1&quot; : &quot;0&quot;) +
+								(chkLetter.state  ? &quot;1&quot; : &quot;0&quot;) +
+								(chkEvent.state   ? &quot;1&quot; : &quot;0&quot;) +
+								(chkWebcam.state  ? &quot;1&quot; : &quot;0&quot;) +
+								(chkMystery.state ? &quot;1&quot; : &quot;0&quot;) +
+								(chkEarth.state   ? &quot;1&quot; : &quot;0&quot;) +
+								(chkLocless.state ? &quot;1&quot; : &quot;0&quot;) +
+								(chkMega.state    ? &quot;1&quot; : &quot;0&quot;) +
+								(chkCustom.state  ? &quot;1&quot; : &quot;0&quot;) +
+								(chkParking.state ? &quot;1&quot; : &quot;0&quot;) +
+								(chkStage.state   ? &quot;1&quot; : &quot;0&quot;) +
+								(chkQuestion.state? &quot;1&quot; : &quot;0&quot;) +
+								(chkFinal.state   ? &quot;1&quot; : &quot;0&quot;) +
+								(chkTrailhead.state ? &quot;1&quot; : &quot;0&quot;) +
+								(chkReference.state ? &quot;1&quot; : &quot;0&quot;)+
+								(chkCito.state ? &quot;1&quot; : &quot;0&quot;)+
+								(chkWherigo.state ? &quot;1&quot; : &quot;0&quot;);
+				pfl.filterRose = (chkNW.state  ? &quot;1&quot;:&quot;0&quot;)+
+							 (chkNNW.state ? &quot;1&quot;:&quot;0&quot;)+
+							 (chkN.state   ? &quot;1&quot;:&quot;0&quot;)+
+							 (chkNNE.state ? &quot;1&quot;:&quot;0&quot;)+
+							 (chkNE.state  ? &quot;1&quot;:&quot;0&quot;)+
+							 (chkENE.state ? &quot;1&quot;:&quot;0&quot;)+
+							 (chkE.state   ? &quot;1&quot;:&quot;0&quot;)+
+							 (chkESE.state ? &quot;1&quot;:&quot;0&quot;)+
+							 (chkSE.state  ? &quot;1&quot;:&quot;0&quot;)+
+							 (chkSSE.state ? &quot;1&quot;:&quot;0&quot;)+
+							 (chkS.state   ? &quot;1&quot;:&quot;0&quot;)+
+							 (chkSSW.state ? &quot;1&quot;:&quot;0&quot;)+
+							 (chkSW.state  ? &quot;1&quot;:&quot;0&quot;)+
+							 (chkWSW.state ? &quot;1&quot;:&quot;0&quot;)+
+							 (chkW.state   ? &quot;1&quot;:&quot;0&quot;)+
+							 (chkWNW.state ? &quot;1&quot;:&quot;0&quot;);
+				pfl.filterSize =(chkMicro.state ? &quot;1&quot; : &quot;0&quot;)+
+							(chkSmall.state ? &quot;1&quot; : &quot;0&quot;)+
+							(chkRegular.state ? &quot;1&quot; : &quot;0&quot;)+
+							(chkLarge.state ? &quot;1&quot; : &quot;0&quot;)+
+							(chkVeryLarge.state ? &quot;1&quot; : &quot;0&quot;)+
+							(chkOther.state ? &quot;1&quot; : &quot;0&quot;);
+
+				if(chcDist.selectedIndex == 0) {
+					pfl.filterDist=&quot;L&quot;+inpDist.getText();
+				} else {
+					pfl.filterDist=&quot;G&quot;+inpDist.getText();
+				}
+
+				if(chcDiff.selectedIndex == 0) {
+					pfl.filterDiff=&quot;L&quot;+inpDiff.getText();
+				} else if(chcDiff.selectedIndex == 1) {
+					pfl.filterDiff=&quot;=&quot;+inpDiff.getText();
+				} else {
+					pfl.filterDiff=&quot;G&quot;+inpDiff.getText();
+				}
+
+				if(chcTerr.selectedIndex == 0) {
+					pfl.filterTerr=&quot;L&quot;+inpTerr.getText();
+				} else if(chcTerr.selectedIndex == 1){
+					pfl.filterTerr=&quot;=&quot;+inpTerr.getText();
+				} else {
+					pfl.filterTerr=&quot;G&quot;+inpTerr.getText();
+				}
+				pfl.filterAttrYes = attV.selectionMaskYes;
+				pfl.filterAttrNo = attV.selectionMaskNo;
+				pfl.filterAttrChoice = chcAttrib.selectedIndex;
+				Filter flt = new Filter();
+				flt.setFilter();
+				flt.doFilter();
+				Global.mainTab.tbP.tControl.scrollToVisible(0,0);
+				Form.cancelWait();
+				//Tabelle neu zeichnen lassen!
+				this.close(0);
+			} else if (ev.target == addiWptChk) { // Set all addi filters to value of main addi filter
+				chkParking.setState(addiWptChk.state);
+				chkStage.setState(addiWptChk.state);
+				chkQuestion.setState(addiWptChk.state);
+				chkFinal.setState(addiWptChk.state);
+				chkTrailhead.setState(addiWptChk.state);
+				chkReference.setState(addiWptChk.state);
+				addiWptChk.bgColor=Color.White;
+				addiWptChk.repaint();
+			} else if (ev.target == btnBearing) cp.select(0);
+			else if (ev.target == btnAttributes) cp.select(1);
+			else if (ev.target == btnRatings)cp.select(2);
+			else if (ev.target == btnTypes)cp.select(3);
+			else if (ev.target == btnAddi)cp.select(4);
+			else if (ev.target == btnContainer)cp.select(5);
+//			else if (ev.target == btnSearch)cp.select(6);
+			else if (ev.target == btnCacheAttributes)cp.select(7);
+			else if (ev.target == btnDeselect) {
+				chkNW.state= chkNNW.state  = chkN.state    = chkNNE.state  =
+				chkNE.state   = chkENE.state  = chkE.state    = chkESE.state  =
+				chkSE.state   = chkSSE.state  = chkS.state    = chkSSW.state  =
+				chkSW.state   = chkWSW.state  = chkW.state    = chkWNW.state = false;
+				setColors();
+				repaint();
+
+			} else if (ev.target == btnSelect) {
+				chkNW.state= chkNNW.state  = chkN.state    = chkNNE.state  =
+				chkNE.state   = chkENE.state  = chkE.state    = chkESE.state  =
+				chkSE.state   = chkSSE.state  = chkS.state    = chkSSW.state  =
+				chkSW.state   = chkWSW.state  = chkW.state    = chkWNW.state = true;
+				setColors();
+				repaint();
+			}
+		}
+		if (ev instanceof DataChangeEvent )	{
+			setColors();
+		}
+
+	}
+
+}

Added: experiments/EVE/src/cachewolf/GPSPortOptions.java
===================================================================
--- experiments/EVE/src/cachewolf/GPSPortOptions.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/GPSPortOptions.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,288 @@
+package cachewolf;
+
+import eve.ui.*;
+import java.io.*;
+
+import eve.ui.formatted.TextDisplay;
+import eve.sys.*;
+import eve.ui.data.SerialPortOptions;
+import eve.io.SerialPort;
+import eve.util.mString;
+import eve.ui.data.Editor;
+import eve.ui.data.EditorEvent;
+import java.lang.InterruptedException;
+import eve.ui.ComboBox;
+import eve.ui.Button;
+import cachewolf.utils.Common;
+
+
+/**
+ * Thread for reading data from COM-port
+ *
+ */
+class mySerialThread extends mThread{
+	SerialPort comSp;
+	byte[] comBuff = new byte[1024];
+	int comLength = 0;
+	TextDisplay out;
+	boolean run;
+	public String lastgot;
+
+	public mySerialThread(SerialPortOptions spo, TextDisplay td) throws IOException {
+		comSp = new SerialPort(spo);
+		//comSp.setFlowControl(SerialPort.SOFTWARE_FLOW_CONTROL);
+		out = td;
+		lastgot = null;
+	}
+
+	public void run() {
+		run = true;
+		while (run){
+			try {
+				sleep(200);
+			} catch (InterruptedException e) {}
+			if (comSp != null)	{
+				try {
+					if (comSp.getInputStream().available() &gt; 0)	{
+						comSp.getInputStream().read(comBuff,0,comSp.getInputStream().available());
+						String str = mString.fromAscii(comBuff, 0, comLength).toUpperCase();
+						lastgot=str;
+						if (out != null) out.appendText(str,true);
+					}
+				} catch(Exception ex) {}
+			}
+		}
+	}
+
+	public String nonBlockingRead() {
+		String ret = new String(lastgot); //mString.fromAscii(gpsBuff,0,gpsLen);
+		lastgot = null;
+		return ret;
+
+	}
+
+	public boolean stopThread() {
+		run = false;
+		boolean ret=false;
+		if (comSp != null) {
+			try {
+				comSp.close(); //compSp == null can happen if a exception occured
+			} catch (IOException ex) {
+				ret=true;
+			}
+			try { eve.sys.mThread.sleep(500); // wait in order to give the system time to close the serial port
+			} catch (InterruptedException e) {}
+		}
+		else ret = true;
+		return ret;
+	}
+
+
+}
+
+public class GPSPortOptions extends SerialPortOptions {
+	TextDisplay txtOutput;
+	Button btnTest, btnUpdatePortList, btnScan;
+	public Input inputBoxForwardHost;
+	Label  labelForwardHost;
+	public CheckBox forwardGpsChkB;
+	public Input inputBoxLogTimer;
+	Label  labelLogTimer;
+	public CheckBox logGpsChkB;
+	mySerialThread serThread;
+	boolean gpsRunning = false;
+	MyEditor ed = new MyEditor();
+
+
+	public Editor getEditor(){
+		// The following lines are mainly copied from SerialPortOptions.
+		// Reason: We want to use MyEditor instead of the default Editor,
+		//         because the latter places the ok/cancel buttons centered.
+		// Because this is from the general SerialPortOptions class, maybe not all of the code
+		// must be necessary.
+		ed.objectClass = getClass();
+		ed.sampleObject = this;
+		ed.setObject(this);
+		ed.title = MyLocale.getMsg(7100, &quot;Serial Port Options&quot;);
+		InputStack is = new InputStack();
+		ed.addLast(is).setCell(CellConstants.HSTRETCH);
+		CellPanel cp = new CellPanel();
+		ed.addField(cp.addNext(new ComboBox()).setCell(CellConstants.HSTRETCH),&quot;portName&quot;);
+		btnUpdatePortList = new Button(MyLocale.getMsg(7101,&quot;Update Ports$u&quot;));
+		ed.addField(cp.addLast(btnUpdatePortList).setCell(CellConstants.DONTSTRETCH),&quot;update&quot;);
+		is.add(cp,&quot;Port:$p&quot;);
+		ComboBox cb = new ComboBox();
+		is.add(ed.addField(cb,&quot;baudRate&quot;),MyLocale.getMsg(7102,&quot;Baud:$b&quot;));
+		cb.choice.addItems(eve.util.mString.split(&quot;110|300|1200|2400|4800|9600|19200|38400|57600|115200&quot;));
+		//
+		// End of copy from SerialPortOptions.
+		//
+		ed.buttonConstraints = CellConstants.HFILL;
+		btnScan = new Button(MyLocale.getMsg(7103,&quot;Scan$u&quot;));
+		btnScan.setCell(CellConstants.DONTSTRETCH);
+		ed.addField(ed.addNext(btnScan),&quot;scan&quot;);
+		btnTest = new Button(MyLocale.getMsg(7104,&quot;Test$t&quot;));
+		ed.addField(ed.addLast(btnTest.setCell(CellConstants.DONTSTRETCH)),&quot;test&quot;);
+		txtOutput = new TextDisplay();
+		ScrollBarPanel sbp = new MyScrollBarPanel(txtOutput);
+		sbp.setOptions(ScrollablePanel.AlwaysShowVerticalScrollers | ScrollablePanel.AlwaysShowHorizontalScrollers);
+		ed.addField(ed.addLast(sbp),&quot;out&quot;);
+		forwardGpsChkB = new CheckBox(&quot;&quot;);
+		ed.addField(ed.addNext(forwardGpsChkB, CellConstants.DONTSTRETCH, (CellConstants.EAST | CellConstants.DONTFILL)), &quot;forwardGpsChkB&quot;);
+		labelForwardHost = new Label(MyLocale.getMsg(7105, &quot;Forward GPS data to host&quot;));
+		ed.addField(ed.addNext(labelForwardHost, CellConstants.DONTSTRETCH, (CellConstants.WEST | CellConstants.DONTFILL)), &quot;labelForwardIP&quot;);
+		inputBoxForwardHost = new Input(&quot;tcpForwardHost&quot;);
+		inputBoxForwardHost.setPromptControl(labelForwardHost);
+		inputBoxForwardHost.setToolTip(MyLocale.getMsg(7106, &quot;All data from GPS will be sent to TCP-port 23\n and can be redirected there to a serial port\n by HW Virtual Serial Port&quot;));
+		ed.addField(ed.addLast(inputBoxForwardHost,0 , (CellConstants.WEST | CellConstants.HFILL)), &quot;tcpForwardHost&quot;);
+		logGpsChkB = new CheckBox(&quot;&quot;);
+		ed.addField(ed.addNext(logGpsChkB, CellConstants.DONTSTRETCH, (CellConstants.EAST | CellConstants.DONTFILL)), &quot;logGpsChkB&quot;);
+		labelLogTimer = new Label(MyLocale.getMsg(7107, &quot;Interval in sec for logging&quot;));
+		ed.addField(ed.addNext(labelLogTimer, CellConstants.DONTSTRETCH, (CellConstants.WEST | CellConstants.DONTFILL)), &quot;labelLogTimer&quot;);
+		inputBoxLogTimer = new Input(&quot;GPSLogTimer&quot;);
+		inputBoxLogTimer.setPromptControl(labelLogTimer);
+		ed.addField(ed.addLast(inputBoxLogTimer,0 , (CellConstants.WEST | CellConstants.HFILL)), &quot;GPSLogTimer&quot;);
+		this.ed.firstFocus = btnUpdatePortList;
+		gpsRunning = false;
+		return ed;
+	}
+	boolean interruptScan = false;
+	boolean scanRunning = false;
+	public void action(String field,Editor ed_){
+		if (field.equals(&quot;scan&quot;)) {
+			if (scanRunning == false) {
+				txtOutput.setText(&quot;&quot;);
+				new mThread() {
+					public void run() {
+						btnTest.set(Button.Disabled, true);
+						btnTest.repaintNow();
+						btnScan.setText(Gui.getTextFrom(MyLocale.getMsg(7119,&quot;Stop&quot;)));
+						btnScan.repaintNow();
+						String[] ports = SerialPort.enumerateAvailablePorts(); // in case of bluethooth this can take several seconds
+						if (ports == null) {
+							txtOutput.appendText(MyLocale.getMsg(7109, &quot;Could not get list of available serial ports\n&quot;), true);
+						} else {
+							scanRunning = true;
+							interruptScan = false;
+							int i;
+							for (i=0; i&lt;ports.length; i++){
+								if (interruptScan) {
+									txtOutput.appendText(MyLocale.getMsg(7120, &quot;Canceled&quot;), true); // MyLocale.getMsg(7109, &quot;Could not get list of available serial ports\n&quot;), true);
+									fin();
+									return;
+								}
+								if (!testPort(ports[i], baudRate)) 	continue;
+								else {
+									portName = ports[i];
+									if (ed != null) ed.toControls(&quot;portName&quot;);
+									break;
+								}
+							}
+							if (i &gt;= ports.length) txtOutput.appendText(MyLocale.getMsg(7110, &quot;GPS not found\n&quot;), true);
+						}
+						fin();
+					}
+					private void fin() {
+						scanRunning = false;
+						if (btnTest != null) {
+							btnTest.set(Button.Disabled, false);
+							btnTest.repaintNow();
+						}
+						if (btnScan != null) {
+							btnScan.setText(Gui.getTextFrom(MyLocale.getMsg(7103,&quot;Scan$u&quot;)));
+							btnScan.repaintNow();
+						}
+					}
+				}.start();
+			} else { // port scan running -&gt; stop it.
+				interruptScan = true;
+			}
+		}
+		if (field.equals(&quot;test&quot;)){
+			if (!gpsRunning){
+				ed_.fromControls();
+				txtOutput.setText(MyLocale.getMsg(7117, &quot;Displaying data from serial port directly:\n&quot;));
+				try {
+					btnScan.set(Button.Disabled, true);
+					btnScan.repaintNow();
+					this.portName = Common.fixSerialPortName(portName);
+					serThread = new mySerialThread(this, txtOutput);
+					serThread.start();
+					btnTest.setText(Gui.getTextFrom(MyLocale.getMsg(7118, &quot;Stop&quot;)));
+					gpsRunning = true;
+				} catch (IOException e) {
+					btnScan.set(Button.Disabled, false);
+					btnScan.repaintNow();
+					txtOutput.appendText(MyLocale.getMsg(7108, &quot;Failed to open serial port: &quot;) + this.portName + &quot;, IOException: &quot; + e.getMessage() + &quot;\n&quot;, true);
+				}
+			}
+			else {
+				serThread.stopThread();
+				btnTest.setText(Gui.getTextFrom(MyLocale.getMsg(7104,&quot;Test$t&quot;)));
+				gpsRunning = false;
+				btnScan.set(Button.Disabled, false);
+				btnScan.repaintNow();
+			}
+
+		}
+
+		super.action(field, ed_);
+	}
+
+	public void fieldEvent(FieldTransfer xfer, Editor editor, Object event){
+		if ( event != null &amp;&amp; event instanceof EditorEvent) {
+			EditorEvent ev = (EditorEvent) event;
+			if (xfer.fieldName.equals(&quot;_editor_&quot;)) {
+				if (ev.type == EditorEvent.CLOSED) {
+					if (serThread != null) serThread.stopThread();
+				}
+			}
+			super.fieldEvent(xfer,editor,event);
+		}
+	}
+
+	private boolean testPort(String port, int baud){
+		mySerialThread gpsPort;
+		long now;
+
+		SerialPortOptions testspo= new SerialPortOptions();
+		testspo.baudRate = baud;
+		testspo.portName = Common.fixSerialPortName(port);
+		try {
+			gpsPort = new mySerialThread(testspo, null);
+		} catch (IOException e) {
+			txtOutput.appendText(MyLocale.getMsg(7108, &quot;Failed to open serial port: &quot;) + testspo.portName + &quot;\n&quot;, true);
+			return false;
+		}
+		//if (!gpsPort.isOpen()) txtOutput.appendText(MyLocale.getMsg(7108, &quot;Failed (2) to open serial port: &quot;) + this.portName + &quot;\n&quot;, true);
+
+		//try to read some data
+		now = new Time().getTime();
+		txtOutput.appendText(MyLocale.getMsg(7111, &quot;Trying &quot;) + port + MyLocale.getMsg(7112, &quot; at &quot;) + baud + &quot; Baud\n&quot;, true);
+		gpsPort.start();
+		boolean gpsfound = false;
+		boolean gotdata = false;
+		while ( (new Time().getTime() - now) &lt; 3000 &amp;&amp; !gpsfound){
+//			gpsLen = gpsPort.lastgot.length(); // nonBlockingRead(gpsBuff,0, gpsBuff.length);
+			//txtOutput.appendText(&quot;gpsLen: &quot; + gpsLen, true);
+			if (gpsPort.lastgot != null) {
+				if (!gotdata) {
+					gotdata = true;
+					txtOutput.appendText(MyLocale.getMsg(7113, &quot; - got some data\n&quot;), true);
+					now = new Time().getTime(); // if receiced some data, give the GPS some extra time to send NMEA data (e.g. Sirf initially sends some non-NMEA text info about it self)
+				}
+				if (gpsPort.nonBlockingRead().indexOf(&quot;$GP&quot;, 0) &gt;= 0) gpsfound = true;
+			}
+			try {eve.sys.mThread.sleep(200); } catch (InterruptedException e) {}
+		}
+		gpsPort.stopThread();
+		if (gpsfound)	 txtOutput.appendText(MyLocale.getMsg(7114, &quot; - GPS Port found\n&quot;), true);
+		else {
+			if (gotdata) txtOutput.appendText(MyLocale.getMsg(7115, &quot; - No GPS data tag found\n&quot;), true);
+			else         txtOutput.appendText(MyLocale.getMsg(7116, &quot; - No data received\n&quot;), true);
+		}
+		//catch (IOException io) { txtOutput.appendText(&quot;error closing serial port&quot;, true); }
+		return gpsfound;
+	}
+
+}

Added: experiments/EVE/src/cachewolf/Global.java
===================================================================
--- experiments/EVE/src/cachewolf/Global.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/Global.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,24 @@
+package cachewolf;
+
+
+/**
+ * Global data: Preferences and Profile
+ * 
+ * @author salzkammergut
+ */
+public class Global {
+	  private static Preferences pref=Preferences.getPrefObject();
+	  private static Profile profile=new Profile();
+
+	  static public Preferences getPref() {
+		  return pref;
+	  }
+	
+	  static public Profile getProfile() {
+		  return profile;
+	  }
+      // A bit of a hack to allow access from one panel to another
+	  static public MainTab mainTab;
+	  static public MainForm mainForm;
+}
+

Added: experiments/EVE/src/cachewolf/HintLogPanel.java
===================================================================
--- experiments/EVE/src/cachewolf/HintLogPanel.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/HintLogPanel.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,260 @@
+package cachewolf;
+
+import cachewolf.utils.Common;
+import eve.ui.*;
+import eve.fx.Point;
+import eve.sys.*;
+import eve.fx.Rect;
+import eve.ui.formatted.HtmlDisplay;
+import eve.ui.game.AniImage;
+import eve.ui.event.KeyEvent;
+import eve.ui.game.InteractivePanel;
+import eve.ui.event.ControlEvent;
+import eve.fx.gui.IKeys; 
+import eve.ui.game.ImageDragContext;
+
+
+/**
+ *	Class to create the panel that holds hints and logs.
+ *	It holds a method to cryt and decrypt hints.
+ *	Two buttons allow for navigation through the logs. 5 logs are displayed at
+ *   together. This was implemented to allow for better performance on the
+ *	PocketPC. This number can be changed in the preferences.
+ *	Class ID=400
+ */
+public class HintLogPanel extends CellPanel{
+	private int crntLogPosition = 0;
+	private CacheHolderDetail currCache;
+	private final static int DEFAULT_STRINGBUFFER_SIZE=8000;
+	private TextPad hint = new TextPad();
+	//mTextPad logs = new mTextPad();
+	private HtmlDisplay logs = new HtmlDisplay();
+	//AniImage htmlTxtImage;
+	//fastScrollText htmlImagDisp = new fastScrollText();
+	private Button decodeButton = new Button(&quot;Decode&quot;);
+	private Button moreBt = new Button(&quot;&gt;&gt;&quot;);
+	private Button prevBt = new Button(&quot;&lt;&lt;&quot;);
+	private MyScrollBarPanel sbplog;
+	private int lastScrollbarWidth = 0;
+	
+	public HintLogPanel(){
+		SplittablePanel split = new SplittablePanel(PanelSplitter.VERTICAL);
+		CellPanel logpane = split.getNextPanel();
+		CellPanel hintpane = split.getNextPanel();
+		split.setSplitter(PanelSplitter.AFTER|PanelSplitter.HIDDEN,PanelSplitter.BEFORE|PanelSplitter.HIDDEN,0);
+		int initialHintHeight=Global.getPref().initialHintHeight;
+		if (initialHintHeight&lt;0 || initialHintHeight&gt;1000) initialHintHeight=Global.getPref().DEFAULT_INITIAL_HINT_HEIGHT;
+		hintpane.setPreferredSize(100,initialHintHeight); 
+		MyScrollBarPanel sbphint = new MyScrollBarPanel(hint);
+		hintpane.addLast(sbphint,CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
+		hintpane.addNext(prevBt,CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		hintpane.addNext(decodeButton,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		decodeButton.setMinimumSize(MyLocale.getScreenWidth()*2/3,10);
+		hintpane.addLast(moreBt,CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.EAST));
+		hint.modify(Control.NotEditable,0);
+
+		sbplog = new MyScrollBarPanel(logs, ScrollBarPanel.NeverShowHorizontalScrollers);
+		//sbplog.stretchFirstRow=true;sbplog.stretchLastRow=false; sbplog.backGround=new eve.fx.Color(0,0,255);
+		logpane.addLast(sbplog, CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(split, CellConstants.STRETCH, CellConstants.FILL);
+		clear();
+	}
+	
+	public void setText(CacheHolderDetail cache){
+		this.currCache = cache;
+		if(!cache.hints.equals(&quot;null&quot;)) 
+			hint.setText(cache.hints);
+		else
+			hint.setText(&quot;&quot;);
+		crntLogPosition = 0;
+		setLogs(0);
+		moreBt.modify(0,Control.Disabled);
+		prevBt.modify(0,Control.Disabled);
+//		if (Gui.screenIs(Gui.PDA_SCREEN) &amp;&amp; Device.isMobile()) {
+//		Vm.setSIP(0);
+//		}
+		////Vm.debug(&quot;In log: &quot; + cache.CacheLogs);
+	}
+
+	public void clear() {
+		logs.setHtml(&quot;loading ...&quot;);
+		/*if (htmlTxtImage != null) {
+			htmlImagDisp.removeImage(htmlTxtImage);
+			htmlTxtImage.free();		
+		}*/
+	}
+	void setLogs(int crntLogPosition) {
+		Form.showWait();
+		clear();
+		StringBuffer dummy = new StringBuffer(DEFAULT_STRINGBUFFER_SIZE);
+		int counter = 0;
+		int nLogs=currCache.cacheLogs.size();
+		int logsPerPage=Global.getPref().logsPerPage;
+		for(int i = crntLogPosition; i&lt;nLogs; i++){
+			dummy.append(currCache.cacheLogs.getLog(i).toHtml());
+			dummy.append(&quot;&lt;/br&gt;&quot;);
+			if(++counter &gt;= logsPerPage) break;
+		}
+		//logs.resizeTo(width, 50);
+		// The cache GCP0T6 crashes the HtmlDisplay
+		// As a temporary fix
+		try {
+			logs.setHtml(dummy.toString());
+		} catch (Exception e) {
+			logs=new HtmlDisplay();
+			Global.getPref().log(&quot;Error rendering HTML&quot;,e,true);
+			logs.setPlainText(&quot;eve VM: Internal error displaying logs&quot;);
+		}
+		/*int h = logs.getLineHeight() * logs.getNumLines();
+		htmlTxtImage = new AniImage(new Image(width, h));
+		htmlTxtImage.setLocation(0, 0);
+		htmlTxtImage.properties |= AniImage.IsMoveable;
+		Graphics draw = new Graphics((Image)htmlTxtImage.getImage());
+		logs.resizeTo(htmlTxtImage.getWidth()-lastScrollbarWidth, htmlTxtImage.getHeight());
+		logs.doPaint(draw, new Rect(0,0,htmlTxtImage.getWidth(), htmlTxtImage.getHeight()));
+		htmlImagDisp.addImage(htmlTxtImage);
+		Rect r = new Rect(new Dimension (width, h));
+		htmlImagDisp.virtualSize = r;
+		htmlImagDisp.origin = new Point();
+		htmlImagDisp.checkScrolls();
+		// Can I get a reasonable value for scrollbarWidth before calling checkScrolls() 
+		// and in a more reasonable way?
+		// Now its ugly: I paint it, calculate the scrollbars and then resize the panel...
+		// Better: Now I only redo it when the scrollbar width changed, which is not the case
+		// normally.
+		int scrollbarWidth = sbplog.vbar.getRect().width;
+		if (scrollbarWidth != lastScrollbarWidth) { 
+		    lastScrollbarWidth = scrollbarWidth;
+   		    logs.resizeTo(htmlTxtImage.getWidth()-scrollbarWidth, htmlTxtImage.getHeight());
+   		    logs.doPaint(draw, new Rect(0,0,htmlTxtImage.getWidth(), htmlTxtImage.getHeight()));
+		}
+
+		htmlImagDisp.repaintNow();
+		*/
+		repaintNow();
+		Form.cancelWait();
+	}
+
+	/**
+	 * Method that handles user input on this panel.
+	 * It handles decryption of hints and navigation through
+	 * the logs (always 5 at a time). Navigation of logs is required
+	 * for performance reasons on the pocketpc.
+	 */
+	public void onEvent(Event ev){
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			int minLogs = java.lang.Math.min(Global.getPref().logsPerPage, currCache.cacheLogs.size());
+			if(ev.target == moreBt){
+				prevBt.modify(0,Control.Disabled);
+				prevBt.repaintNow();
+				crntLogPosition += minLogs;
+				if(crntLogPosition &gt;= currCache.cacheLogs.size()) {
+					//crntLogPosition = cache.CacheLogs.size()-5;
+					crntLogPosition = currCache.cacheLogs.size()- minLogs;
+					moreBt.modify(Control.Disabled,0);
+					moreBt.repaintNow();
+				}
+				setLogs(crntLogPosition);
+			} // = moreBt
+			if(ev.target == prevBt){
+				moreBt.modify(0,Control.Disabled);
+				moreBt.repaintNow();
+				crntLogPosition -= minLogs;
+				if(crntLogPosition &lt;= 0) {
+					prevBt.modify(Control.Disabled,0);
+					prevBt.repaintNow();
+					crntLogPosition = 0;
+				}
+				setLogs(crntLogPosition);
+			}
+			if(ev.target == decodeButton){
+				hint.setText(Common.rot13(hint.getText()));
+			}
+		}
+	}
+}
+
+class fastScrollText extends InteractivePanel { // TODO extend this class in a way that text can be marked and copied
+	public boolean scrollVertical = true;
+	public boolean scrollHorizontal = false;
+	public boolean imageNotDragged(ImageDragContext drag,Point where) {
+		if (drag == null || drag.image == null) return super.imageNotDragged(drag, where);
+		//Rect r = getDim(null);
+		if (drag.image.location.y &lt;= 0 ){
+			drag.image.move(0, drag.image.location.y);
+		} else {
+			drag.image.move(0, 0);
+		}
+		return	super.imageNotDragged(drag, where);
+	}
+	
+	// I copied it here because the original has a bug when scrolling
+	// added the support for scrolling / draggin only vertically
+	// rewrite to support for images bigger than the canvas
+	// the return value is never used
+//	============================================================
+	public boolean imageDragged(ImageDragContext dc,Point where)
+//	============================================================
+	{
+		dc.curPoint = new Point(where.x,where.y);
+		AniImage moving = dc.image;
+		Rect r = getDim(null);
+		boolean didAutoScroll = false;
+		Point to = new Point(where.x-dc.start.x,where.y-dc.start.y);
+		if (!scrollHorizontal) to.x = 0;
+		if (!scrollVertical) to.y = 0;
+		//if (origin.y - to.y &lt; 0 || origin.y - to.y + r.height &gt; moving.location.height) return true; 
+		if (moving == null) { // this is not used only copied
+			if (!dragBackground) return true;
+			int dx = dc.start.x-where.x, dy = dc.start.y-where.y;
+			if (where.x &lt; origin.x || where.x &gt;= origin.x+r.width || where.y &lt; origin.y || where.y &gt;= origin.y+r.height &amp;&amp; autoScrolling){
+				if (where.x &lt;= origin.x) dx = scrollStep;
+				if (where.x &gt;= origin.x+r.width) dx = -scrollStep;
+				if (where.y &lt;= origin.y) dy = scrollStep;
+				if (where.y &gt;= origin.y+r.height) dy = -scrollStep; // here +/- is wrong in InteractivePanel.java
+				dc.start.x = where.x; dc.start.y = where.y;
+			}
+			//dc.start.move(where.x,where.y);
+			if (dx != 0 || dy != 0) scroll(dx,dy);
+			refresh();
+			return true;
+		}else if (true || where.x &lt; origin.x || where.x &gt;= origin.x+r.width || where.y &lt; origin.y || where.y &gt;= origin.y+r.height){
+	 			if (autoScrolling) {
+					didAutoScroll = true;
+					scroll(-to.x,-to.y);
+			}
+		}
+/*		if (moving.canGo(to)) {
+			moving.move(to.x,to.y);
+			draggingImage(dc);
+			if (ri != null) ri.dragEvent(this,ri.Drag,dc);
+		}
+	*/	checkTouching(dc,false);
+		if (didAutoScroll) refresh();
+		else refresh(dc.image,null);//updateImage(dc.image);
+		return(true);
+	}
+	public void onKeyEvent(KeyEvent ev) {
+		if (ev.type == KeyEvent.KEY_PRESS) {
+			if (ev.key == IKeys.DOWN) {
+				 doScroll(IScroll.Vertical, IScroll.ScrollHigher, 1);
+				 refresh();
+			}
+			if (ev.key == IKeys.UP) {
+				 doScroll(IScroll.Vertical, IScroll.ScrollLower, 1);
+				 refresh();
+			}
+			if (ev.key == IKeys.PAGE_DOWN) {
+				 doScroll(IScroll.Vertical, IScroll.PageHigher, 1);
+				 refresh();
+			}
+			if (ev.key == IKeys.PAGE_UP) {
+				 doScroll(IScroll.Vertical, IScroll.PageLower, 1);
+				 refresh();
+			}
+		}
+	}
+
+	
+	
+}

Added: experiments/EVE/src/cachewolf/HttpConnection.java
===================================================================
--- experiments/EVE/src/cachewolf/HttpConnection.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/HttpConnection.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,744 @@
+package cachewolf;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.Socket;
+import java.util.Vector;
+
+import cachewolf.utils.Common;
+
+import eve.net.ChunkedDataInputStream;
+import eve.data.Property;
+import eve.data.PropertyList;
+import eve.io.AsciiCodec;
+import eve.io.File;
+import eve.io.PartialInputStream;
+import eve.io.StreamUtils;
+import eve.io.TextCodec;
+import eve.sys.Convert;
+import eve.sys.Handle;
+import eve.sys.Task;
+import eve.sys.TimeOut;
+import eve.sys.Vm;
+import eve.util.ByteArray;
+import eve.util.CharArray;
+import eve.util.SubString;
+import eve.net.Net;
+import eve.net.URL;
+
+
+/**
+Use this class to create an HttpConnection with a Web Server and to read
+in the data for the connection.&lt;p&gt;
+To use this do the following:
+&lt;ol&gt;
+&lt;li&gt;Create an HttpConnection object with a URL or specify the host, port and document to get.
+&lt;li&gt;Change any of the HttpConnection parameters (including documentIsEncoded if your
+document is URL encoded - i.e. it has '?' type data within it) and set requestor properties as needed.
+&lt;li&gt;Call connectAsync() or connect() to make a Socket that is connected with the server. These
+methods will also send the Http request (e.g. GET or POST), send the requestor parameters and
+then read in and parse the server response and server parameters. When these methods are
+complete the next data to be read in from the Socket will be the actual data bytes for the
+http tranfer.
+&lt;li&gt;Call redirectTo() to see if the request resulted in a redirection response from the server.
+If redirectTo() returns a new HttpConnection object, then close the open Socket and go back
+to step 2 using the new HttpConnection object instead.
+&lt;li&gt;Call readInData() with the connected Socket to read in the raw data bytes of the requested
+document or call readInText() to read in and convert the document to text.
+&lt;/ol&gt;
+**/
+//##################################################################
+public class HttpConnection {
+//##################################################################
+/**
+* The host to connect to.
+**/
+public String host;
+/**
+* The port to connect to.
+**/
+public int port;
+/**
+* The document to fetch/submit.
+**/
+public String document;
+/**
+* This is the command to be sent to the server. By default it is &quot;GET&quot;. If you call
+* setPostData() and command is &quot;GET&quot; then the command will be replaced by &quot;POST&quot;.
+**/
+public String command = &quot;GET&quot;;
+/**
+* This is the version sent to the server. By default it is &quot;HTTP/1.1&quot;. You could
+* change it to something else if necessary.
+**/
+public String requestVersion = &quot;HTTP/1.1&quot;;
+/**
+* These are the properties that will be sent to the WebServer. These are sent after the
+* initial GET/POST line. This is initially null, so you will have to create a new PropertyList
+* for it, or use one of the setRequestorProperty() or addRequestorProperty() methods.
+**/
+public PropertyList requestorProperties;
+/**
+* This is the list of properties for the server and document. It is only valid after a connection has
+* been made since it is sent by the server to the requestor. One properties that will always be in
+* this list will be &quot;response&quot; (the first line sent by the server in response to the request).
+* All other properties will be as specified by the server, and &lt;b&gt;the property names will be
+* converted to all lowercase letters&lt;/b&gt;.
+**/
+public PropertyList documentProperties;
+/**
+* This is the response code from the server. It is only valid after a connection has
+* been made.
+**/
+public int responseCode;
+/**
+* If the document you supplied is already URL encoded, set this to true.
+**/
+public boolean documentIsEncoded;
+/**
+* Set this to true for keep alive mode requests.
+**/
+public boolean keepAliveMode;
+/**
+* This is the length of the document &lt;b&gt;read in&lt;/b&gt;, valid after a connection call. If it is -1, then the
+* web server has not provided the length of the document.
+**/
+public int contentLength = -1;
+/**
+* This is the codec used when sending data to the server. 
+**/
+public TextCodec textCodec;
+
+InputStream bytesToPost;
+Object originalPostData;
+
+	/**
+	 * Set these when the class is instantiated the first time.
+	 * afterwards you don't need to set proxy parameters anymore
+	 */
+	private static String proxy = Global.getPref().myproxy;
+	private static int proxyPort = Common.parseInt(Global.getPref().myproxyport);
+	private static boolean useProxy = Global.getPref().proxyActive;
+	
+	public static void setProxy(String proxyi, int proxyporti, boolean useproxyi) {
+		proxy = proxyi;
+		proxyPort = proxyporti;
+		useProxy = useproxyi;
+	}
+
+
+
+/**
+ * This returns true if post data has been set for this connection.
+ */
+public boolean hasPostData()
+{
+	return bytesToPost != null;
+}
+/**
+ * Get a new HttpConnection whose parameters are copied from this HttpConnection
+ * but which directs its request to a different host/document as directed by
+ * a redirect response from an initial request.&lt;p&gt;
+ * Note that if this is a POST request and if the post-data source is an InputStream
+ * or Stream, then you will need to call setPostData() again to set up the post data
+ * for the new connection. Otherwise, the post data will be copied to this device.
+ * Call hasPostData() to determine if the post data was copied across successfully.
+ * 
+ * @param redirectTo the URL that the server instructed the client to redirect to.
+ * @return a new HttpConnection with parameters copied from this one.
+ */
+public HttpConnection getRedirectedConnection(String redirectTo)
+{
+	HttpConnection c = new HttpConnection(redirectTo);
+	c.keepAliveMode = keepAliveMode;
+	c.contentLength = contentLength;
+	c.getRequestorProperties().set(getRequestorProperties());
+	if (originalPostData != null) c.setPostData(originalPostData);
+	c.documentIsEncoded = documentIsEncoded;
+	c.command = command;
+	c.textCodec = textCodec == null ? null : (TextCodec)textCodec.getCopy();
+	c.requestVersion = requestVersion;
+	return c;
+}
+/**
+Returns the requestor properties. These are the property commands sent to the server when the
+connection is made. You can add directly to this OR you can call setRequestorProperty() or
+addRequestorProperty();
+ */
+//===================================================================
+public PropertyList getRequestorProperties()
+//===================================================================
+{
+	if (requestorProperties == null) requestorProperties = new PropertyList();
+	return requestorProperties;
+}
+/**
+ * Set the data to post out as either a Stream, InputStream,byte[],ByteArray or String.
+ * If the data is a Stream or InputStream then you must also call setPostDataLength() 
+ * which in turn sets the &quot;Content-Length&quot; property of the requestor properties - otherwise
+ * if &quot;Content-Length&quot; is not already set it will be set to the length of the byte[] or ByteArray.
+ * @param data the data to post either as a Stream, InputStream, byte[] or ByteArray
+ */
+//===================================================================
+public void setPostData(Object data)
+//===================================================================
+{
+	if (data instanceof InputStream) bytesToPost = (InputStream)data;
+	else if (data instanceof ByteArray) {
+		originalPostData = data;
+		ByteArray ba = (ByteArray)data;
+		bytesToPost = new ByteArrayInputStream(ba.data,0,ba.length);
+		getRequestorProperties().defaultTo(&quot;Content-Length&quot;,Convert.toString(((ByteArray)data).length));
+	}
+	else if (data instanceof byte[]) {
+		originalPostData = data;
+		bytesToPost = new ByteArrayInputStream((byte[])data);
+		getRequestorProperties().defaultTo(&quot;Content-Length&quot;,Convert.toString(((byte[])data).length));
+	}else if (data instanceof String){
+		String s = (String)data;
+		TextCodec td = textCodec;
+		if (td == null) td = new AsciiCodec();
+		try{
+			ByteArray got = td.encodeText(Vm.getStringChars(s),0,s.length(),true,null);
+			setPostData(got.toBytes());
+		}catch(IOException e){
+			
+		}
+	}
+	if (bytesToPost != null &amp;&amp; command.equalsIgnoreCase(&quot;get&quot;))
+		command = &quot;POST&quot;;
+}
+/**
+ * This sets the &quot;Content-Length&quot; requestor property to be the specified length.
+ * @param length the number of bytes to be posted.
+ */
+//===================================================================
+public void setPostDataLength(int length)
+//===================================================================
+{
+	getRequestorProperties().set(&quot;Content-Length&quot;,Convert.toString(length));
+}
+/**
+ * Set an exclusive requestor property. These are sent to the web server after the initial request line.
+ * @param name The name of the property.
+ * @param property The value of the property.
+ */
+//===================================================================
+public void setRequestorProperty(String name, String property)
+//===================================================================
+{
+	getRequestorProperties().set(name,property);
+}
+/**
+ * Add a non-exclusive requestor property. These are sent to the web server after the initial request line.
+ * @param name The name of the property.
+ * @param property The value of the property.
+ */
+//===================================================================
+public void addRequestorProperty(String name, String property)
+//===================================================================
+{
+	getRequestorProperties().add(name,property);
+}
+/**
+ * Set the default value of a requestor property. If the value is already set
+ * this will have no effect. Otherwise the value will be set to defaultValue.
+ * @param name the name of the property.
+ * @param defaultValue the value to default to.
+ */
+public void defaultRequestorProperty(String name, String defaultValue)
+{
+	getRequestorProperties().defaultTo(name,defaultValue);
+}
+protected Socket openSocket;
+protected Socket connectedSocket;
+
+/**
+* If a connection has already been made to the server, then you can call
+* this method and the HttpConnection protocol will be done over this Socket.
+* @param sock The already connected socket.
+*/
+//===================================================================
+public void setAlreadyOpenSocket(Socket sock)
+//===================================================================
+{	
+	openSocket = sock;
+}
+
+/**
+ * Create a new HttpConnection to the specified host and port to fetch the specified document.
+ * @param host The host to connect to.
+ * @param port The port to connect on.
+ * @param document the document to get.
+ */
+//===================================================================
+public HttpConnection(String host, int port, String document)
+//===================================================================
+{
+	this.host = host;
+	this.port = port;
+	this.document = document;
+}
+/**
+ * Create an HttpConnection with an <A HREF="http://">http://</A> URL.
+ * @param url The full url, starting with <A HREF="http://">http://</A>
+ */
+//===================================================================
+public HttpConnection(String url)
+//===================================================================
+{
+		if (useProxy) { 
+			host = proxy;
+			port = proxyPort;
+			document = url;
+		}	else {
+			url = File.fixupPath(url);
+			//ewe.sys.Vm.debug(&quot;url: &quot;+url);
+			port = 80;
+			String uu = url.toLowerCase();
+			if (uu.startsWith(&quot;<A HREF="http://">http://</A>&quot;)){
+				uu = url.replace('\\','/');
+				host = uu.substring(7);
+				int first = host.indexOf('/');
+				if (first == -1) document = &quot;/&quot;;
+				else {
+					document = host.substring(first);
+					host = host.substring(0,first);
+				}
+				int colon = host.indexOf(':');
+				if (colon != -1){
+					port = Convert.toInt(host.substring(colon+1));
+					host = host.substring(0,colon);
+				}
+			}
+		}
+}
+
+//===================================================================
+public HttpConnection(URL url)
+//===================================================================
+{
+	this(url.toString());
+	documentIsEncoded = true;
+}
+static char [] space = {' '}, percentSpace = {'%','2','0'};
+
+//===================================================================
+public String toURLString()
+//===================================================================
+{
+	return &quot;<A HREF="http://">http://</A>&quot;+host+&quot;:&quot;+port+document;
+}
+//===================================================================
+public String getEncodedDocument()
+//===================================================================
+{
+	if (documentIsEncoded) return document;
+	return URL.encodeURL(document,false);
+}
+//===================================================================
+Object waitOnIO(Handle h,String errorMessage) throws IOException
+//===================================================================
+{
+	try{
+		h.waitOn(Handle.Success);
+		return h.returnValue;
+	}catch(Exception e){
+		if (h.error instanceof IOException) 
+			throw (IOException)h.error;
+		throw new IOException(errorMessage);
+	}
+}
+public static final int SocketConnected = 0x1;
+public static final int DataReady = 0x2;
+
+static Vector lines;
+static SubString data;
+
+//===================================================================
+int makeRequest(Socket sock,TextCodec td) throws IOException
+//===================================================================
+{
+	responseCode = -1;
+	if (td == null) td = textCodec;
+	if (td == null) td = new AsciiCodec();
+	PropertyList pl = new PropertyList();
+	if (requestorProperties != null) pl.set(requestorProperties);
+	pl.defaultTo(&quot;Connection&quot;,keepAliveMode ? &quot;keep-alive&quot; : &quot;close&quot;);
+	pl.defaultTo(&quot;Host&quot;,host);
+	StringBuffer sb = new StringBuffer();
+	sb.append(command+&quot; &quot;+getEncodedDocument()+&quot; &quot;+requestVersion+&quot;\r\n&quot;);
+	for (int i = 0; i&lt;pl.size(); i++){
+		Property p = (Property)pl.get(i);
+		if (p.value != null) sb.append(p.name+&quot;: &quot;+p.value+&quot;\r\n&quot;);
+	}
+	sb.append(&quot;\r\n&quot;);
+	String req = sb.toString();
+	char [] rc = Vm.getStringChars(req);
+	ByteArray ba = ((TextCodec)td.getCopy()).encodeText(rc,0,rc.length,true,null);
+	OutputStream os = sock.getOutputStream();
+	os.write(ba.data,0,ba.length);
+	os.flush();
+	//
+	if (bytesToPost != null){
+		StreamUtils.transfer(null,bytesToPost,os);
+		os.flush();
+		bytesToPost.close();
+		/*
+		// For debugging - output eol and a blank line.
+		byte[] ret = new byte[]{(byte)'\r',(byte)'\n'};
+		sock.write(ret);
+		sock.write(ret);
+		sock.flush();
+		*/
+	}
+	//
+	int lastReceived = -1;
+	//
+	ba.clear();
+	InputStream is = sock.getInputStream();
+	while(true){
+		int got = is.read();
+		if (got == -1) throw new IOException(&quot;Unexpected end of stream.&quot;);
+		if (got == 10){
+			if (lastReceived == 10) break; //Got all the data now.
+		}else if (got == 13) continue; //Ignore CR.
+		ba.append((byte)got);
+		lastReceived = got;
+	}
+	//
+	CharArray all = ((TextCodec)td.getCopy()).decodeText(ba.data,0,ba.length,true,null);
+	if (data == null){
+		data = new SubString();
+		lines = new Vector();
+	}
+	data.set(all.data,0,all.length);
+	int got = data.split('\n',lines);
+	documentProperties = new PropertyList();
+	if (got == 0) throw new IOException(&quot;No response&quot;);
+
+
+	String response = lines.get(0).toString();
+	documentProperties.set(&quot;response&quot;,response);
+	{
+		int idx = response.indexOf(' ');
+		if (idx != -1){
+			int id2 = response.indexOf(' ',idx+1);
+			if (id2 != -1){
+				responseCode = Convert.toInt(response.substring(idx+1,id2));
+			}
+		}
+	}
+	for (int i = 1; i&lt;got; i++){
+		String s = lines.get(i).toString();
+		int idx = s.indexOf(':');
+		if (idx == -1) continue;
+		String name = s.substring(0,idx).trim().toLowerCase();
+		String value = s.substring(idx+1).trim();
+		//if (document.endsWith(&quot;html&quot;)) ewe.sys.Vm.debug(document+&quot;: &quot;+name+&quot; = &quot;+value);
+		documentProperties.add(name,value);
+	}
+	contentLength = documentProperties.getInt(&quot;content-length&quot;,-1);
+	//if (document.endsWith(&quot;?&quot;) || document.endsWith(&quot;.gif&quot;))
+	//ewe.sys.Vm.debug(documentProperties.toString());
+	return responseCode;
+}
+
+static final String [] encodings = {&quot;transfer-coding&quot;,&quot;transfer-encoding&quot;};
+//byte [] buffer;
+
+
+
+/**
+ * Call this after a successful connection. If the server requested a redirect (a 3xx code) then
+ * this will return an HttpConnection to the new location which you can connect to again. You must
+ * setup any post data or requestor properties again before re-connecting.
+ * Alternatively you could also call getRedirectTo() and then if that returns a non-null
+ * String, you can call getRedirectedConnection() to get copies.
+ * If there is no redirection required or possible the method will return this same HttpConnection.
+ */
+//===================================================================
+public HttpConnection redirectTo()
+//===================================================================
+{
+	if (responseCode &lt; 300 || responseCode &gt; 399) return this;
+	String newURL = documentProperties.getString(&quot;location&quot;,null);
+	if (newURL == null) return this;
+	return new HttpConnection(newURL);
+}					
+
+/**
+ * Call this after a success connection. If it returns a non-null String then
+ * you need to redirect the connection to the new location. If this returns non-null
+ * you can call getRedirectedConnection() to get a new HttpConnection that you can
+ * use to redirect the connection without having to setup the connection parameters
+ * again.
+ * @return null if no redirection is needed, otherwise the location directed to.
+ */
+public String getRedirectTo()
+{
+	if (responseCode &lt; 300 || responseCode &gt; 399) return null;
+	return documentProperties.getString(&quot;location&quot;,null);
+}
+/**
+ * Read in all the data from the Socket.
+ * @param connection The socket returned by a connect() call.
+ * @return A Handle with which you can monitor the connection. When the Handle
+	reports Success, then the returnValue of the Handle will be a ewe.util.ByteArray
+	object that holds the data read in.
+ */
+//===================================================================
+public Handle readInData(Socket connection) 
+//===================================================================
+{
+	int length = documentProperties.getInt(&quot;content-length&quot;,-1);
+	if (length == 0)
+		return new Handle(Handle.Succeeded,new ByteArray());
+	//
+	try{
+		InputStream is = getInputStream(connection);
+		return StreamUtils.readAllBytes(is,null,length,0);
+	}catch(IOException e){
+		Handle h = new Handle();
+		h.fail(e);
+		return h;
+	}
+}
+/**
+ * Read in all the data from the Socket.
+ * @return A Handle with which you can monitor the connection. When the Handle
+	reports Success, then the returnValue of the Handle will be a ewe.util.ByteArray
+	object that holds the data read in.
+ */
+//===================================================================
+public Handle readInData() 
+//===================================================================
+{
+	return readInData(connectedSocket);
+}
+/**
+* Get an InputStream to read in the data. This is a very important method as it is used by
+* the readInData() method.
+**/
+//===================================================================
+public InputStream getInputStream(Socket connectedSocket) throws IOException
+//===================================================================
+{
+	//ewe.sys.Vm.debug(documentProperties.toString());
+	int length = documentProperties.getInt(&quot;content-length&quot;,-1);
+	if (&quot;chunked&quot;.equals(documentProperties.getValue(encodings,null))){
+		//System.out.println(&quot;Is chunked!&quot;);
+		return new ChunkedDataInputStream(connectedSocket.getInputStream(),10240);
+	}
+	//System.out.println(&quot;Is not chunked!&quot;);
+	return new PartialInputStream(connectedSocket.getInputStream(),length);
+	
+}
+/**
+* Get an InputStream to read in the data. This is a very important method as it is used by
+* the readInData() method.
+**/
+//===================================================================
+public InputStream getInputStream() throws IOException
+//===================================================================
+{
+	return getInputStream(connectedSocket);
+}
+/**
+ * Read in the document body from the Socket. This method blocks until the complete
+ * data is read in. readInData() is a non-blocking version.
+ * @param connection The socket returned by a connect() call.
+ * @return A ByteArray containing the read in data.
+ */
+//===================================================================
+public ByteArray readData(Socket connection) throws IOException
+//===================================================================
+{
+	return (ByteArray)waitOnIO(readInData(connection),&quot;Error reading data.&quot;);
+}
+/**
+ * Read in all the data from the Socket, converting it to text using the specified
+ * codec. 
+ * @param connection The socket returned by a connect() call.
+ * @param documentTextDecoder The text codec to use to convert the bytes read in into text. If
+ * this is null then a simple Ascii codec will be used.
+ * @return A Handle with which you can monitor the connection. When the Handle
+	reports Success, then the returnValue of the Handle will be a ewe.util.CharArray
+	object that holds the text read in.
+ */
+//===================================================================
+public Handle readInText(final Socket connection,TextCodec documentTextDecoder)
+//===================================================================
+{
+	if (documentTextDecoder == null) documentTextDecoder = new AsciiCodec();
+	final TextCodec cc = (TextCodec)documentTextDecoder.getCopy();
+	return new Task(){
+		protected void doRun(){
+			Handle handle = this;
+			try{
+				Handle h = readInData(connection);
+				if (!waitOnSuccess(h,TimeOut.Forever,true)) return;
+				ByteArray ba = (ByteArray)h.returnValue;
+				handle.returnValue = cc.decodeText(ba.data,0,ba.length,true,null);
+				handle.set(Handle.Succeeded);
+			}catch(Exception e){
+				fail(e);
+			}
+		}
+	}.start();
+}
+/**
+ * Read in the document body from the Socket. This method blocks until the complete
+ * data is read in. readInText() is a non-blocking version.
+ * @param connection The socket returned by a connect() call.
+ * @param documentTextDecoder The text codec to use to convert the bytes read in into text. If
+ * this is null then a simple Ascii codec will be used.
+ * @return A CharArray containing the text that was read in.
+ */
+//===================================================================
+public CharArray readText(Socket connection,TextCodec documentTextDecoder) throws IOException
+//===================================================================
+{
+	return (CharArray)waitOnIO(readInText(connection,documentTextDecoder),&quot;Error reading data.&quot;);
+}
+/**
+ * Connect asynchronously. This makes the connection, sends the request and requestor properties
+ * reads in the reply and server properties and then returns the connected Socket ready for
+ * for reading in the actual data.
+ * @return A Handle used to monitor the connection. When the Handle reports a state of
+ * Success, then the returnValue of the IOHandle will hold the connected socket.
+ */
+//===================================================================
+public Handle connectAsync()
+//===================================================================
+{
+	return connectAsync(new AsciiCodec());
+}
+/**
+ * Connect asynchronously. This makes the connection, sends the request and requestor properties
+ * reads in the reply and server properties and then returns the connected Socket ready for
+ * for reading in the actual data.
+ * @param serverTextDecoder The text decoder to convert the server and requestor properties data into text.
+ * @return A Handle used to monitor the connection. When the Handle reports a state of
+ * Success, then the returnValue of the Handle will hold the connected socket.
+ */
+//===================================================================
+public Handle connectAsync(final TextCodec serverTextDecoder)
+//===================================================================
+{
+	return new Task(){
+		protected void doRun(){
+			while(true){
+			//
+			// Create a Socket using an IOHandle.
+			//
+			Handle handle = this;
+			try{
+				Handle sh = (openSocket != null) ? new Handle(Handle.Succeeded,openSocket) : Net.newSocket(host,port); 
+				try{
+					//
+					// Now wait until connected.
+					//
+					if (!waitOnSuccess(sh,TimeOut.Forever,true)){
+						handle.fail(sh.error);
+						return;
+					}
+					//ewe.sys.Vm.debug(&quot;Socket connected.&quot;);
+					//
+					// Report that the socket connection was made.
+					// Now have to decode the data.
+					//
+					Socket sock = (Socket)sh.returnValue;
+					handle.setFlags(SocketConnected,0);
+					//
+					makeRequest(sock,serverTextDecoder);
+					//ewe.sys.Vm.debug(&quot;Request made.&quot;);
+					handle.returnValue = connectedSocket = sock;
+					handle.setFlags(Handle.Success,0);
+					return;
+				}catch(Exception e){
+					if (openSocket == null){
+						handle.fail(e);
+						return;
+					}
+					openSocket = null;
+					continue;
+				}
+			}catch(Exception e){
+				handle.fail(e);
+			}
+		}}
+	}.start();
+}
+/**
+ * This makes the connection, blocking the current thread.
+ * @return A Socket that you can read the data from. The document properties will be in
+ * the document properties list.
+ * @exception IOException if there was an error connecting or getting the data.
+ */
+//===================================================================
+public Socket connect() throws IOException
+//===================================================================
+{
+	return (Socket)waitOnIO(connectAsync(),&quot;Could not connect.&quot;);
+}
+/**
+ * Connect to the server and save the socket for later use as the &quot;connectedSocket&quot; field.
+ * @return the connected socket - before any data is sent or read.
+ * @exception IOException if a connection could not be made.
+ */
+//===================================================================
+public Socket connectSocketOnly() throws IOException
+//===================================================================
+{
+	//if (connectedSocket != null) return connectedSocket;
+	//return connectedSocket = new Socket(host,port);
+	if (openSocket != null) return openSocket;
+	return openSocket = new Socket(host,port);
+}
+
+/*
+//===================================================================
+public Handle connectAsync2()
+//===================================================================
+{
+	return new ewe.sys.Vm.TaskObject(){
+		protected void doRun(){
+			try{
+				Socket sock = new Socket(host,port);
+				handle.setFlags(SocketConnected,0);
+								
+			}catch(Exception e){
+				handle.set(Handle.Failed);
+				return;
+			}
+		}
+	}.stratTask();
+}
+*/
+/*
+//===================================================================
+public static void main(String args[]) throws IOException, InterruptedException
+//===================================================================
+{
+	ewe.sys.Vm.startEwe(args);
+	HttpConnection hp = new HttpConnection(&quot;192.168.0.52&quot;,80,&quot;/eweDemo.zip&quot;);
+	Socket sock = hp.connect();
+	Handle h = hp.readInData(sock);
+	ProgressBarForm pbf = new ProgressBarForm();
+	pbf.showStop = true;
+	pbf.execute(h,&quot;Reading...&quot;);
+	pbf.showMainTask = false;
+	pbf.showSubTask = true;
+	h.waitUntilStopped();
+	if ((h.check() &amp; h.Success) != 0) ewe.sys.Vm.debug(&quot;Success!!&quot;);
+	sock.close();
+	ewe.sys.Vm.exit(0);
+}
+*/
+//##################################################################
+}
+//##################################################################
+

Added: experiments/EVE/src/cachewolf/ImageDetailScreen.java
===================================================================
--- experiments/EVE/src/cachewolf/ImageDetailScreen.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/ImageDetailScreen.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,131 @@
+package cachewolf;
+import eve.fx.*;
+import eve.ui.*;
+import eve.ui.game.AniImage;
+import eve.ui.game.InteractivePanel;
+import eve.sys.Event;
+import eve.ui.event.ControlEvent;
+import eve.fx.Fx;
+
+/**
+* Class creates a view on the image scaled
+* to the application size, but only if the image is larger than
+* the available app size.
+*/
+public class ImageDetailScreen extends Form{
+	ImageInteractivePanel ipp = new ImageInteractivePanel();
+	ScrollBarPanel scp;
+	
+	public ImageDetailScreen(String imgLoc, Preferences p){
+		scp = new MyScrollBarPanel(ipp);
+		ipp.setImage(imgLoc);
+		this.title = &quot;Image&quot;;
+		this.setPreferredSize(p.myAppWidth, p.myAppHeight);
+		this.addLast(scp, CellConstants.STRETCH, CellConstants.FILL);
+	}
+	
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent &amp;&amp; ev.type==ControlEvent.EXITED) {
+			ev.consumed=true;
+			this.close(0);
+		} else super.onEvent(ev);
+	}
+
+//#####################################################################################
+//  ImageInteractivePanel	
+//#####################################################################################
+	
+	/**
+	*	This class handles the resizing im images
+	*/
+	private class ImageInteractivePanel extends InteractivePanel{
+		int state = -1; // 0 = nothing, -1 = scaled to app, 1 = scaled to original size
+		//ScrollBarPanel scp;
+		String imgLoc = &quot;&quot;;
+		AniImage pic=null;
+		
+		public ImageInteractivePanel() {
+			super();
+			this.setMenu(mClose);
+		}
+		
+		private Menu mClose = new Menu(new String[]{
+				&quot;Close&quot;},&quot;&quot;);
+		
+		public void resizeTo(int w, int h) {
+			this.width = w;
+			this.height = h;
+			if (state == -1) fitImageToWindow();
+			virtualSize = new Rect(0, 0, java.lang.Math.max(w, pic.getWidth()), java.lang.Math.max(h, pic.getHeight()));
+			checkScrolls();
+			super.resizeTo(w, h);
+		}
+
+		public void setImage(String filename) {
+			imgLoc = filename;
+			Picture mI = new Picture(imgLoc);
+			if (pic != null) {
+				this.removeImage(pic);
+				pic.freeImage();
+				pic.free();
+			}
+			pic = new AniImage(mI);
+			pic.setLocation(0, 0);
+			// mI.free(); this works in the java-VM, but it will delete the image in the ewe-vm --&gt; leave it commeted out
+			this.addImage(pic);
+			virtualSize = new Rect(pic.getSize(null));
+			checkScrolls();
+		}
+			
+		public void fitImageToWindow() {
+			Rect s = this.parent.getRect();
+			int ww = pic.getWidth();
+			int wh = pic.getHeight();
+			double scale =  java.lang.Math.max((double)ww/(double)s.width, (double)wh/(double)s.height);
+			if (scale != 1){
+				this.removeImage(pic);
+				AniImage tmp = new AniImage(Fx.scaleImage(pic.getImageData(),(int)(ww/scale), (int)(wh/scale)));
+				pic.freeImage();
+				pic.free();
+				pic = tmp;
+				pic.setLocation(0, 0);
+				this.addImage(pic);
+				virtualSize = new Rect(pic.getSize(null));
+				checkScrolls();
+			}
+		}
+			
+		
+		public void imageClicked(AniImage which, Point pos){
+			state = -state;
+			if(state == 1){
+				setImage(imgLoc);
+				this.repaintNow();
+			}
+			if(state == -1){
+				fitImageToWindow();
+				this.repaintNow();
+			}
+		}
+
+		public void penRightReleased(Point p){
+				menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
+		}
+		
+		public void penHeld(Point p){
+				menuState.doShowMenu(p,true,null); 
+		}
+		public void popupMenuEvent(Object selectedItem){
+			postEvent(new ControlEvent(ControlEvent.EXITED,this));
+		}
+		public void formClosing() {
+			super.formClosing();
+			if (pic != null) {
+				pic.freeImage();
+				pic.free();
+			}
+		}	
+	} // ImageInteractivePanel
+
+}
+

Added: experiments/EVE/src/cachewolf/ImagePanel.java
===================================================================
--- experiments/EVE/src/cachewolf/ImagePanel.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/ImagePanel.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,297 @@
+package cachewolf;
+import eve.sys.*;
+import eve.fx.*;
+import eve.ui.*;
+import eve.io.*;
+import java.util.*;
+
+import cachewolf.utils.SafeXML;
+
+
+import eve.ui.game.*;
+import eve.ui.event.*;
+
+
+/**
+*	Class to display the cache and log images. It creates a thumbnail view and
+*	allows the user to click on an image that will then be displayed in its original size
+*	as long as the image fits the application size. If the application size is not sufficient
+*	then the image will be scaled to the available screen size.
+*   A right mouseclick on an image will open a dialogue to delete the file. 
+*/
+public class ImagePanel extends InteractivePanel{
+	/** Picture to replace deleted pictures */
+	private final String NO_IMAGE=&quot;no_picture.png&quot;;
+	/** Minimum time (msec) to recognise a long pen down event (=right mouse key) */
+	private final int LONG_PEN_DOWN_DURATION=500;
+
+	Preferences pref;
+	Profile profile;
+	//private final int thumb_max_size = 300;
+	//private final int thumb_min_size = 100;
+	private final int padding = 20;
+	private int thumb_size = 0;
+	private int locX, locY, locCounter;
+	/** Start and duration of pen-pressed event to simulate right mouse key */
+	private long start, duration=0;
+	
+	/**
+	* Constructor to create the image panel.&lt;p&gt;
+	*/
+	public ImagePanel(){
+	}
+	
+//	static CacheHolderDetail oldCache=null;
+	/**
+	* Method to set the individual cache images.
+	* Gets called immediatly before panel is displayed
+	* @see MainTab#onEvent(Event ev)
+	*/
+	public void setImages(CacheHolderDetail cache){
+//		if (cache!=oldCache) {
+			pref = Global.getPref();
+			profile=Global.getProfile();
+			Form.showWait();
+			clearImages();
+			thumb_size = (pref.myAppWidth-2*padding) / 3;
+			thumb_size = thumb_size - padding;
+			int rowCounter = cache.images.size() + cache.userImages.size();
+			rowCounter = rowCounter/3+1;
+			Rect r = new Rect(0, 0, pref.myAppWidth, rowCounter*thumb_size+rowCounter*padding+padding);
+			this.virtualSize = r;
+			//this.setPreferredSize(pref.myAppWidth, rowCounter*thumb_size+rowCounter*padding+40);
+			this.checkScrolls();
+			this.refresh();
+			locY=0;
+			addTitle(MyLocale.getMsg(340,&quot;Cache Images:&quot;));
+			locY = 20;
+			locX = padding;
+			addImages(cache.images,cache.imagesText);
+			// load user images
+			if(locCounter==1 || locCounter ==2) locY = locY + thumb_size;
+			//Vm.debug(&quot;thumb_size: &quot; + Convert.toString(thumb_size));
+			//Vm.debug(&quot;locy after: &quot; + Convert.toString(locY));
+			if (cache.userImages.size()&gt; 0){
+				addTitle(MyLocale.getMsg(341,&quot;User Images:&quot;));
+				locY = locY + 20;
+				locX = padding;
+				locCounter = 0;
+				addImages(cache.userImages,cache.userImagesText);
+			}
+//			oldCache=cache;
+//		} // cache!=oldCache	
+		this.refresh();
+		Form.cancelWait();
+		//this.repaintNow();
+	}
+
+	/**
+	 * Clear the images in the panel
+	 *
+	 */
+	public void clearImages() {
+//		oldCache=null;
+		int lgr = images.size();
+		for(int i = 0; i&lt;lgr;i++){
+			this.removeImage((AniImage)images.get(0));
+		}
+	}
+	
+	/**
+	 * Add a title above the cache images and above the user images
+	 * @param title Title to add (&quot;cache images&quot; or &quot;user images&quot;)
+	 */
+	private void addTitle(String title) {
+		AniImage aImg;
+		Font font = new Font(&quot;Verdana&quot;, Font.BOLD, 20);
+		FontMetrics fm = getFontMetrics();
+		int stringWidth = fm.getTextWidth(title);
+		int stringHeight = fm.getHeight();
+		Image img = new Image(stringWidth*2,stringHeight+5);
+		Graphics g = new Graphics(img);
+		g.setColor(new Color(195,195,195));
+		g.fillRect(0,0,stringWidth*2,stringHeight+5);
+		g.setColor(new Color(0,0,0));
+		g.setFont(font);
+		g.drawText(title, 0,0);
+		g.free();
+		aImg = new AniImage(img);
+		aImg.setLocation(0, locY);
+		addImage(aImg);
+		aImg.refresh();
+	}
+	
+	/**
+	 * Add the images to the panel. Can add both normal and user images
+	 * @param images Vector of images or userImages
+	 * @param imagesText Vector of image texts or user image texts
+	 */
+	private void addImages(Vector images, Vector imagesText) {
+		String location, imgText;
+		PixelBuffer mI;
+		int scaleX, scaleY;
+		double dummyC;
+		ImagePanelImage ipi;
+		AniImage AimgText;
+		locCounter=0;
+		for(int i = 0; i&lt;images.size(); i++){
+			location = profile.dataDir + (String)images.get(i);
+			if (!(new File(location)).exists()) {
+				location=NO_IMAGE;
+				if (!pref.showDeletedImages) continue; // Don't show the deleted Image if user does not want it
+			}
+			try{
+				mI = new PixelBuffer(location);
+				// actuall new Picture(location); should do the following &quot;if&quot; but it doesn't anyhow
+				if (mI.getWidth() &lt;= 0 || mI.getHeight() &lt;= 0 ) throw new IllegalArgumentException(location);
+				scaleX = thumb_size;
+				scaleY = thumb_size;
+				dummyC = 0;
+				double thumb_size2 = thumb_size;
+				if(mI.getWidth()&gt;mI.getHeight()){
+					scaleX = thumb_size;
+					dummyC = (double)mI.getHeight()/ (double)mI.getWidth();
+					dummyC = dummyC * thumb_size2;
+					scaleY = (int)dummyC;
+				}
+				if(mI.getWidth() &lt;= mI.getHeight()){
+					scaleY = thumb_size;
+					dummyC = (double)mI.getWidth()/(double)mI.getHeight();
+					dummyC = dummyC * thumb_size2;
+					scaleX = (int)dummyC;
+				}
+				if(mI.getWidth() &lt;= thumb_size){
+					scaleX = mI.getWidth();
+					scaleY = mI.getHeight();
+				}
+				mI = mI.scale(scaleX,scaleY);
+				ipi = new ImagePanelImage(mI.getImageData());
+				mI.freeImage();
+				ipi.freeImage();
+				//mI.free(); --&gt; this only works in java-VM, in ewe it will delete the image, so leave it commented out				ipi.fileName = location; // this is set only to easily identify the filename of the image clicked
+				ipi.fileName = location; // this is set only to easily identify the filename of the image clicked
+				ipi.setLocation(locX, locY);
+				addImage(ipi);
+				//Name of picture:
+				if(imagesText.size()&gt;i){
+					if (location.equals(NO_IMAGE))
+						imgText=MyLocale.getMsg(342,&quot;Deleted&quot;);
+					else
+						imgText = SafeXML.cleanback((String)imagesText.get(i));
+					if(imgText.length()==0) imgText = &quot;???&quot;;
+					//AimgText = new AniImage();
+					AimgText = getImageText(imgText);
+					AimgText.setLocation(locX,locY+scaleY);
+					addImage(AimgText);
+					AimgText.refresh();
+					ipi.imageText = imgText; 
+				}
+				ipi.refresh();
+				locX = locX + thumb_size + padding;
+				
+				locCounter++;
+				if(locCounter &gt; 2) {
+					locCounter = 0;
+					locX = padding;
+					locY = locY+thumb_size+padding;
+				}
+			}catch(IllegalArgumentException imex){ // file not found, could not decode etc.
+				MessageBox tmp = new MessageBox(MyLocale.getMsg(321,&quot;Fehler&quot;), MyLocale.getMsg(322,&quot;Kann Bild/Karte nicht laden&quot;)+&quot;:\n&quot;+imex.getMessage(), MessageBox.OKB); // @todo: language support
+				tmp.exec();
+			} catch (OutOfMemoryError e) { // TODO show an error icon in the panel instead of nothing
+				(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(343,&quot;Not enough free memory to load cache image&quot;)+&quot;:\n&quot;+location,MessageBox.OKB)).exec();
+			} catch (SystemResourceException e) { // TODO show an error icon in the panel instead of nothing
+				(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(343,&quot;Not enough free memory to load cache image&quot;)+&quot;\n&quot;+location,MessageBox.OKB)).exec();
+			}
+		} //for
+		
+	}
+	
+	private AniImage getImageText(String text){
+		Font font = new Font(&quot;Verdana&quot;, Font.BOLD, 14);
+		FontMetrics fm = getFontMetrics();
+		int stringWidth = fm.getTextWidth(text);
+		int stringHeight = fm.getHeight();
+		Image img = new Image(stringWidth*2,stringHeight+5);
+		Graphics g = new Graphics(img);
+		g.setColor(new Color(195,195,195));
+		g.fillRect(0,0,stringWidth*2,stringHeight+5);
+		g.setColor(new Color(0,0,0));
+		g.setFont(font);
+		g.drawText(text, 0,0);
+		g.free();
+		AniImage a = new AniImage(img);
+		return a;
+	}
+
+	
+	/**
+	* React to when a user clicks an image.
+	* If left mouse key is clicked, will open a new window displaying the image scaled
+	* to window size if the image is larger, otherwise the true size is displayed.
+	* If right mouse key is clicked, a dialogue to delete the image wil be displayed
+	*/
+	public void imageClicked(AniImage which, Point pos){
+		//eve.sys.Vm.debug(&quot;Clicked&quot;+pos.x+&quot;,&quot;+pos.y+&quot; &quot;+(((eve.ui.Gui.currentPenPress().modifiers&amp;PenEvent.RIGHT_BUTTON)==PenEvent.RIGHT_BUTTON)?&quot;RIGHT&quot;:&quot;LEFT&quot;) );
+		
+		if ((Gui.currentPenPress().modifiers&amp;PenEvent.RIGHT_BUTTON)==PenEvent.RIGHT_BUTTON || duration&gt;LONG_PEN_DOWN_DURATION) {
+			// Right button pressed - delete image to conserve space
+			if (which instanceof ImagePanelImage &amp;&amp; !((ImagePanelImage)which).fileName.equals(NO_IMAGE)) {
+				MessageBox mBox = new MessageBox (MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(344,&quot;Delete image&quot;)+&quot; \&quot;&quot;+((ImagePanelImage)which).imageText+&quot;\&quot;?&quot;, MessageBox.IDYES |MessageBox.IDNO);
+				if (mBox.execute() == MessageBox.IDOK){
+						//Vm.debug(&quot;Deleting &quot;+((ImagePanelImage)which).fileName);
+						try {
+							File f=new File(((ImagePanelImage)which).fileName);
+							f.delete();
+							removeImage(which);
+						} catch(Exception e) {};
+				}
+			}
+		} else { 
+			String fn;
+			if(which instanceof ImagePanelImage){
+				ImagePanelImage ich = (ImagePanelImage)which;
+				fn = ich.fileName;
+				try {
+					ImageDetailScreen iF = new ImageDetailScreen(fn, pref);
+					iF.execute(null, Gui.CENTER_FRAME);
+				} catch (IllegalArgumentException e) {
+					MessageBox tmp = new MessageBox(MyLocale.getMsg(321,&quot;Fehler&quot;), MyLocale.getMsg(322,&quot;Kann Bild/Karte nicht finden&quot;), MessageBox.OKB); // @todo: language support
+					tmp.exec();
+				} catch (OutOfMemoryError e) {
+					(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(343,&quot;Not enough free memory to load cache image&quot;)+&quot;\n&quot;+fn,MessageBox.OKB)).exec();
+				}
+			}
+		}
+	}
+
+	/**
+	 * Create a &quot;pen held down&quot; event on hardware that does not support a right mouse key (e.g. Windows Mobile)
+	 * by measuring the time between pen down and pen up events. This is used in imageClicked to differentiate 
+	 * between left and right mouse keys.
+	 */
+	public void onPenEvent(PenEvent ev) {
+		if (ev.type==PenEvent.PEN_DOWN) {
+			start = Vm.getTimeStampLong();
+		}
+		if (ev.type==PenEvent.PEN_UP) {
+			duration=Vm.getTimeStampLong()-start;
+		}
+		super.onPenEvent(ev);
+	}
+	
+	/**
+	* The ImagePanelImage extends AniImage by a fileName.
+	* This is an easy way to identify the image clicked,
+	* what is needed to display the full image from the
+	* thumbnail.
+	*/
+	private class ImagePanelImage extends AniImage{
+		public String fileName = &quot;&quot;;
+		public String imageText = null;
+		public ImagePanelImage(ImageData i){
+			super(i);
+		}
+	}
+
+}
\ No newline at end of file

Added: experiments/EVE/src/cachewolf/InfoBox.java
===================================================================
--- experiments/EVE/src/cachewolf/InfoBox.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/InfoBox.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,145 @@
+package cachewolf;
+import eve.ui.*;
+import eve.sys.*;
+import eve.fx.gui.*;
+import eve.ui.event.*;
+
+public class InfoBox extends Form{
+	TextMessage msgArea;
+	CheckBox mCB;
+	TextMessage warnings;
+	public boolean mCB_state = false;
+	Button mB = new Button(&quot;OK&quot;);
+	Button mC = new Button(&quot;Cancel&quot;);
+	public Input feedback = new Input();
+	public final static int CHECKBOX = 1;
+	public final static int INPUT = 2;
+	public final static int DISPLAY_ONLY = 3;
+	public final static int PROGRESS_WITH_WARNINGS = 4;
+	private int type = 0;
+	/** This variable is set to true if the user closed the Info window by
+	 *  clicking the &quot;close&quot; button. It can be used to check if a lengthy task needs to be
+	 *  aborted (i.e. spidering)
+	 */
+	public boolean isClosed=false;
+
+	public InfoBox(String title, String info){
+		this(title, info, DISPLAY_ONLY);
+	}
+
+	public String getInput(){
+		return feedback.getText();
+	}
+
+	public void addText(String t) {
+		msgArea.setText(msgArea.text + t);
+		this.repaintNow();
+	}
+
+	public InfoBox(String title, String info, int ty){
+		this(title, info, ty, true);
+		//this.setPreferredSize(170, 50);
+		relayout(false);
+	}
+
+	public InfoBox(String title, String info, int ty, boolean autoWrap) {
+		type = ty;
+		// Resize InfoBox with Fontsize
+		Preferences pref=Global.getPref();
+		int fs = pref.fontSize;
+		int sw = MyLocale.getScreenWidth();
+		int psx; int psy;
+		psx=170;psy=50;
+		if((fs &gt; 11) &amp;&amp; (sw &gt;= 200)){psx=200;psy=70;}
+		if((fs &gt; 16) &amp;&amp; (sw &gt;= 250)){psx=250;psy=90;}
+		if((fs &gt; 21) &amp;&amp; (sw &gt;= 300)){psx=300;psy=110;}
+		if((fs &gt; 24) &amp;&amp; (sw &gt;= 350)){psx=350;psy=130;}
+		this.setPreferredSize(psx, psy);
+
+		this.title = title;
+		switch (type) {
+		case CHECKBOX: 
+			mCB = new CheckBox(info);
+			this.addLast(mCB, CellConstants.STRETCH, CellConstants.FILL);
+			break;
+		case INPUT:
+			Label mL = new Label(info);
+			this.addNext(mL, CellConstants.STRETCH, CellConstants.FILL);
+			this.addLast(feedback, CellConstants.STRETCH, CellConstants.FILL);
+			break;
+		case DISPLAY_ONLY:
+			msgArea = new TextMessage(info);
+			msgArea.autoWrap = autoWrap;
+			msgArea.alignment = Gui.CENTER;
+			msgArea.anchor = Gui.CENTER;
+			this.addLast(msgArea.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
+			break;
+		case PROGRESS_WITH_WARNINGS:
+			msgArea = new TextMessage(info);
+			msgArea.autoWrap = autoWrap;
+			msgArea.alignment = Gui.CENTER;
+			msgArea.anchor = Gui.CENTER;
+			msgArea.setPreferredSize(psx-20, psy);
+			this.addLast(msgArea.getScrollablePanel(), CellConstants.HEXPAND | CellConstants.HGROW, CellConstants.HEXPAND | CellConstants.HGROW);
+			warnings = new TextMessage(&quot;&quot;);
+			warnings.autoWrap = autoWrap;
+			this.addLast(warnings.getScrollablePanel(), CellConstants.HEXPAND | CellConstants.VEXPAND |CellConstants.VGROW, CellConstants.HEXPAND | CellConstants.VEXPAND |CellConstants.VGROW);
+			mB.set(Control.Disabled, true);
+			mB.setPreferredSize(40, 20);
+			addLast(mB, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+			break;
+		}
+		mC.setHotKey(0, IKeys.ESCAPE);
+		mB.setHotKey(0, IKeys.ACTION);
+		mB.setHotKey(0, IKeys.ENTER);
+		if (ty == CHECKBOX || ty == INPUT) {
+			this.addNext(mC, CellConstants.STRETCH, CellConstants.FILL);
+			this.addLast(mB, CellConstants.STRETCH, CellConstants.FILL);
+		}
+	}
+
+	public void setInfo(String info){
+		msgArea.setText(info);
+		this.repaintNow();
+	}
+	
+	public void setInfoHeight(int heighti) {
+		msgArea.setPreferredSize(getPreferredSize(null).width, heighti);
+	}
+	public void setInfoWidth(int widthi) {
+		msgArea.setPreferredSize(widthi,getPreferredSize(null).height);
+	}	
+	public String getInfo(){
+		return msgArea.getText();
+	}
+
+	public void addWarning (String w) {
+		warnings.setText(warnings.text + w);
+	}
+	public void addOkButton() { //unfortunately this doesn't work
+		mB.set(Control.Disabled, false);
+		//addNext(mB);
+		//relayout(true);
+		//mB.set(Control.Invisible, false);
+		this.repaintNow();
+	}
+
+	public void onEvent(Event ev){
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
+			if(ev.target == mB){
+				if(type == CHECKBOX) mCB_state = mCB.getState();
+				this.close(Form.IDOK);
+			}
+			if(ev.target == mC){
+				this.close(Form.IDCANCEL);
+			}
+		}
+		super.onEvent(ev);
+	}
+	
+	protected boolean canExit(int exitCode) {
+		isClosed=true;
+		return true;
+	}
+	
+}
\ No newline at end of file

Added: experiments/EVE/src/cachewolf/InfoHtmlScreen.java
===================================================================
--- experiments/EVE/src/cachewolf/InfoHtmlScreen.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/InfoHtmlScreen.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,54 @@
+package cachewolf;
+
+import eve.ui.*;
+import eve.io.File;
+import eve.sys.*;
+import eve.ui.formatted.HtmlDisplay;
+import eve.ui.event.ControlEvent;
+
+
+/**
+*	This class displays an information screen. It loads the html text to display
+*	from a file that is given upon creation of this class. It offers
+*	a cancel button enabling the user to close the screen and return to
+*	wherever the user was before
+*/
+public class InfoHtmlScreen extends Form {
+	
+	HtmlDisplay disp = new HtmlDisplay();
+	Button btCancel;
+	
+	public InfoHtmlScreen(String datei, String tit, boolean readFromFile){
+		String text = &quot;&quot;;
+		this.title=tit;
+		Preferences pref = Global.getPref();
+		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
+		if(readFromFile == true){
+			try{
+				char buf[]=new char[(int) (new File(datei)).getLength()];
+				java.io.InputStreamReader in = new java.io.InputStreamReader(new java.io.FileInputStream(datei),&quot;UTF8&quot;);
+				int len=in.read(buf);
+				in.close();
+				eve.util.CharArray ca=new eve.util.CharArray(buf); ca.setLength(len);
+				text=(ca).toString();
+				//BufferedReader in = new BufferedReader(new FileReader(datei));
+				//text = in.readAll();
+				//in.close();
+			}catch(Exception ex){
+				//Vm.debug(&quot;Error! Could not open &quot; + datei);
+			}
+		} else text = datei;
+		disp.setHtml(text);
+		ScrollBarPanel sbp = new MyScrollBarPanel(disp, ScrollBarPanel.NeverShowHorizontalScrollers);
+		this.addLast(sbp);
+		this.addLast(btCancel = new Button(MyLocale.getMsg(3000,&quot;Close&quot;)),CellConstants.DONTSTRETCH, CellConstants.FILL);
+	}
+	
+	public void onEvent(Event ev){
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (ev.target == btCancel){
+				this.close(0);
+			}
+		}
+	}
+}

Added: experiments/EVE/src/cachewolf/Log.java
===================================================================
--- experiments/EVE/src/cachewolf/Log.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/Log.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,129 @@
+package cachewolf;
+
+import cachewolf.imp.GPXImporter;
+
+public class Log {
+	private static String MAXLOGICON=&quot;MAXLOG&quot;;
+	private static String INVALIDLOGICON=null;
+	/** The icon which describes the log e.g. icon_sad */
+	private String icon;
+	/** The date in format yyyy-mm-dd */
+	private String date;
+	/** The person who logged the cache */
+	private String logger;
+	/** The logged message */
+	private String message;
+	/** true, if the logger recommended the cache */
+	private boolean recommended = false;
+	
+	/** Create a log from a single line in format&lt;br&gt;
+	 * &lt;pre&gt;RECOMMENDED=&quot;1&quot;&lt;img src='ICON'&gt;&nbsp;DATE LOGGER&lt;br&gt;MESSAGE
+	 * or &lt;img src='ICON'&gt;&nbsp;DATE by LOGGER&lt;br&gt;MESSAGE&lt;/pre&gt;
+	 * @param logLine
+	 */
+	public Log(String logLine) {
+//		RECOMMENDED=&quot;1&quot;&lt;img src='icon_smile.gif'&gt;&nbsp;2007-01-14 xyz&lt;br&gt;a wonderful log
+		try {
+			int ic1=logLine.indexOf(&quot;RECOMMENDED=\&quot;1\&quot;&quot;);
+			if (ic1 &gt;= 0) 
+				recommended = true; else recommended = false;
+			ic1=logLine.indexOf(&quot;&lt;img src='&quot;);
+			int ic2=logLine.indexOf(&quot;'&quot;,ic1+10);
+			icon=logLine.substring(ic1+10,ic2);
+			int d1=logLine.indexOf(&quot;;&quot;);
+			date=logLine.substring(d1+1,d1+11);
+			int l1=d1+12;
+			if (logLine.substring(l1,l1+3).equals(&quot;by &quot;)) l1+=3;
+			int l2=logLine.indexOf(&quot;&lt;br&gt;&quot;,l1);
+			logger=logLine.substring(l1,l2);
+			message=logLine.substring(l2+4, logLine.indexOf(&quot;]]&gt;&quot;, l1));
+		} catch (Exception ex) {
+			if (logLine.indexOf(&quot;&lt;img&quot;)&lt;0) { // Have we reached the line that states max logs reached 
+				icon=MAXLOGICON; 
+			} else {
+				Global.getPref().log(&quot;Error parsing log: &quot;+logLine);
+				icon=INVALIDLOGICON;
+			}	
+			date=&quot;1900-00-00&quot;;
+			logger=message=&quot;&quot;;
+		}
+	}
+	
+	public Log(String icon, String date, String logger, String message) {
+		this(icon, date, logger, message, false);
+	}
+	
+	public Log(String icon, String date, String logger, String message, boolean recommended_) {
+		this.icon=icon;
+		this.date=date;
+		this.logger=logger;
+		this.message=message.trim();
+		this.recommended = recommended_;
+	}
+	
+	public static Log maxLog() {
+		return new Log(MAXLOGICON,&quot;1900-00-00&quot;,&quot;&quot;,&quot;&quot;);
+	}
+	
+	public String getIcon() {
+		return icon;
+	}
+	public void setIcon(String icon) {
+		this.icon = icon;
+	}
+	public String getDate() {
+		return date;
+	}
+	public void setDate(String date) {
+		this.date = date;
+	}
+	public String getLogger() {
+		return logger;
+	}
+	public void setLogger(String logger) {
+		this.logger = logger;
+	}
+	public String getMessage() {
+		return message;
+	}
+	public void setMessage(String message) {
+		this.message = message.trim();
+	}
+
+	public boolean isRecomended() {
+		return recommended;
+	}
+	
+	public boolean isFoundLog() {
+		return icon.equals(GPXImporter.typeText2Image(&quot;Found&quot;));
+	}
+	
+	/** Return XML representation of log for storing in cache.xml */
+	public String toXML(){
+		StringBuffer s=new StringBuffer(400);
+		s.append(&quot;&lt;LOG&gt;&quot;);
+		if (recommended)
+			s.append(&quot;RECOMMENDED=\&quot;1\&quot;&quot;);
+		s.append(&quot;&lt;![CDATA[&quot;);
+		s.append(toHtml());
+		s.append(&quot;]]&gt;)&quot;);
+		s.append(&quot;&lt;/LOG&gt;\r\n&quot;);
+		return s.toString();
+	}
+	
+	/** Return HTML representation of log for display on screen */
+	public String toHtml(){
+//		&lt;img src='icon_smile.gif'&gt;&nbsp;2007-01-14 xyz&lt;br&gt;a wonderful log
+		if (icon.equals(MAXLOGICON)) return &quot;&lt;hr&gt;&quot;+MyLocale.getMsg(736,&quot;Too many logs&quot;)+&quot;&lt;hr&gt;&quot;;
+		StringBuffer s=new StringBuffer(300);
+		s.append(&quot;&lt;img src='&quot;+icon+&quot;'&gt;&quot;);
+		if (recommended) s.append(&quot;&lt;img src='recommendedlog.gif'&gt;&quot;);
+		s.append(&quot;&nbsp;&quot;);
+		s.append(date);
+		s.append(&quot; by &quot;);
+		s.append(logger);
+		s.append(&quot;&lt;br&gt;&quot;);
+		s.append(message.trim());
+		return s.toString();
+	}
+}

Added: experiments/EVE/src/cachewolf/LogList.java
===================================================================
--- experiments/EVE/src/cachewolf/LogList.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/LogList.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,133 @@
+package cachewolf;
+
+import java.util.Vector;
+
+public class LogList {
+	/** The Vector containing the Log objects 
+	 * The list is always sorted in descending order */
+	private Vector logList=new Vector(10);
+
+	/** Construct an empty Log list */
+	public LogList() {
+	}
+	
+	/** Get the Log at a certain position in the list */
+	public Log getLog(int i) {
+		return (Log) logList.elementAt(i);
+	}
+	
+	/** Return the size of the list */
+	public int size() {
+		return logList.size();
+	}
+	
+	/** Clear the Log list */
+	public void clear() {
+		logList.clear();
+	}
+
+	/** Add a Log to the list */
+	public void add(Log log) {
+		if (log.getIcon()!=null) logList.add(log); // Don't add invalid logs
+	}
+	
+	/** Remove a Log from the list */
+	public void remove(int i) {
+		logList.removeElementAt(i);
+	}
+
+	/** Replace a Log in the list */
+	public void replace(int i, Log log) {
+		logList.setElementAt(log,i);
+	}
+	
+	/** Merge a log into the list at the appropriate position
+	 * @param newLog
+	 * @return the position where the log was placed or -1 if it is already in the list
+	 */ 
+	 
+	public int merge(Log newLog) {
+		String newDate=newLog.getDate();
+		int size=size();
+		int i;
+		for (i=0; i&lt;size; i++) {
+			 int comp=newDate.compareTo(((Log) logList.elementAt(i)).getDate());
+			 if (comp&gt;0) {
+				 logList.insertElementAt(newLog, i);
+				 return i;
+			 }
+			 if (comp==0) break;
+		}
+		// Now i points to the first log with same date as the new log or i==size()
+		if (i==size) {
+			add(newLog);
+			return size;
+		}
+		int firstLog=i;
+		// Check whether we have any logs with same date by same user
+		String newLogger=newLog.getLogger();
+		String newIcon=newLog.getIcon();
+		while (i&lt;size &amp;&amp;  newDate.equals(((Log) logList.elementAt(i)).getDate())) {
+			Log log=(Log) logList.elementAt(i);
+			if (log.getLogger().equals(newLogger) &amp;&amp;
+				log.getIcon().equals(newIcon)) {
+				// Has the log message changed vs. the one we have in cache.xml?
+				if (!log.getMessage().equals(newLog.getMessage())) {
+					replace(i,newLog);
+					return i;
+				} 
+				return -1; // Log already in list
+			}
+			i++;
+		}
+		if (i==size) {
+			add(newLog);
+			return i;
+		} 
+		logList.insertElementAt(newLog, firstLog);
+		return firstLog;
+	}
+
+	 /**
+	  *  Count the number of not-found logs
+	  */
+	 public int countNotFoundLogs() {
+		int countNoFoundLogs = 0;
+		while(countNoFoundLogs &lt; size() &amp;&amp; countNoFoundLogs &lt; 5){
+			if(getLog(countNoFoundLogs).getIcon().startsWith(&quot;icon_sad&quot;)) {
+				countNoFoundLogs++;
+			}else break;
+		}
+		return countNoFoundLogs;
+	 }
+
+	 /** only valid after calling calcRecommendations() */
+	 int numRecommended = 0;
+	 /** only valid after calling calcRecommendations() */
+	 int foundsSinceRecommendation = 0;
+	 /** only valid after calling calcRecommendations() */
+	 int recommendationRating = 0;
+	 
+	 /**
+	  * call this to 
+	  *
+	  */
+	 public void calcRecommendations() {
+		 numRecommended = 0;
+		 foundsSinceRecommendation = 0;
+		 Log l;
+		 int s = size();
+		 int i;
+		 for (i= 0 ; i &lt; s; i++){
+			 l = getLog(i);
+			 if (l.getDate().compareTo(&quot;2007-01-14&quot;) &lt; 0) break; // this is the date when the recommendation system was introdueced in opencaching.de see: <A HREF="http://www.geoclub.de/viewtopic.php?t=14901&amp;highlight=formel">http://www.geoclub.de/viewtopic.php?t=14901&amp;highlight=formel</A>
+			 if (l.isRecomended()) numRecommended++;
+			 if (l.isFoundLog()) foundsSinceRecommendation++; 
+		 }
+		 recommendationRating = getScore(numRecommended, foundsSinceRecommendation);
+	 }
+	 
+	 public static int getScore(int numrecommends, int numfoundlogs) {
+		 return Math.round((((float)numrecommends * (float)numrecommends +1f ) / (numfoundlogs / 10f +1f))*100f);
+	 }
+}

Added: experiments/EVE/src/cachewolf/MainForm.java
===================================================================
--- experiments/EVE/src/cachewolf/MainForm.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/MainForm.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,179 @@
+package cachewolf;
+
+import eve.ui.*;
+import eve.sys.*;
+import eve.fx.*;
+
+/**
+*	Mainform is responsible for building the user interface.
+*	Class ID = 5000
+*/
+public class MainForm extends Form {
+	// The next three declares are for the cachelist
+	public boolean cacheListVisible=false;
+    public CacheList cacheList;
+    SplittablePanel split;
+
+	StatusBar statBar=null;
+	Preferences pref = Global.getPref(); // Singleton pattern
+	Profile profile = Global.getProfile();
+	MainTab mTab;
+	MainMenu mMenu;
+
+	/**
+	*	Constructor for MainForm&lt;p&gt;
+	*	Loads preferences and the cache index list. Then constructs a
+	*	MainMenu and the tabbed Panel (MainTab). MainTab holds the different
+	*	tab panels. MainMenu contains the menu entries.
+	*	@see	MainMenu
+	*	@see	MainTab
+	*/
+	public MainForm(){
+		doIt();
+	}
+
+	public MainForm(boolean dbg, String pathtoprefxml){
+		pref.debug = dbg;
+		pref.setPathToConfigFile(pathtoprefxml); // in case pathtoprefxml == null the preferences will determine the path itself
+		doIt();
+	}
+	protected void checkButtons() {
+		if (pref.hasCloseButton) super.checkButtons();
+	}
+
+	protected boolean canExit(int exitCode) {
+		mTab.saveUnsavedChanges(true);
+		return pref.hasCloseButton;
+	}
+
+	public void doIt(){
+		//*maximizeOnPDA();
+		//*Form.showWait();
+		//*pref.readPrefFile();
+		Global.mainForm=this;
+		//this.title = &quot;CacheWolf &quot; + Version.getRelease();
+		this.exitSystemOnClose = true;
+		this.resizable = true;
+		this.moveable = true;
+		this.windowFlagsToSet = Window.FLAG_MAXIMIZE_ON_PDA;
+		if (!Device.isMobile()) {
+			this.resizable = false;
+			this.moveable = false;
+			int h,w;
+			h=pref.myAppHeight;
+			if (h&gt;MyLocale.getScreenHeight()) h=MyLocale.getScreenHeight();
+			w=pref.myAppWidth;
+			if (w&gt;MyLocale.getScreenWidth()) w=MyLocale.getScreenWidth();
+			this.setPreferredSize(w,h);
+		}
+		this.resizeOnSIP = true;
+		InfoBox infB = null;
+		// Load CacheList
+		try{
+			pref.readPrefFile();
+			if (MyLocale.initErrors.length() != 0) {
+				new MessageBox(&quot;Error&quot;, MyLocale.initErrors, FormBase.OKB).execute();
+			}
+			addGuiFont();
+			if (!pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_ONOROFF, true))
+				eve.sys.Vm.exit(0); // User MUST select or create a profile
+			Form.showWait();
+			infB = new InfoBox(&quot;CacheWolf&quot;,MyLocale.getMsg(5000,&quot;Loading Cache-List&quot;));
+			infB.exec();
+			infB.getWindow().waitUntilPainted(100);
+			profile.readIndex();
+			pref.curCentrePt.set(profile.centre);
+ 			profile.updateBearingDistance();
+ 			boolean saveHasUnsavedChanges = profile.hasUnsavedChanges;
+ 			profile.restoreFilter(); // this method sets hasUnsavedChanges to true
+ 			profile.hasUnsavedChanges = saveHasUnsavedChanges ; // in case that the profile is new, it hasUnsavedChanges, so set it back
+			title=&quot;Cachewolf &quot;+Version.getRelease()+&quot; - &quot;+profile.name;
+		} catch (Exception e){
+			if(pref.debug == true) Vm.debug(&quot;MainForm:: Exception:: &quot; + e.toString());
+		}
+
+
+		if(pref.fixSIP == true){
+			if (Gui.screenIs(Gui.PDA_SCREEN) &amp;&amp; Device.isMobile()) {
+				//Vm.setSIP(Vm.SIP_LEAVE_BUTTON|Vm.SIP_ON);
+				//TODO Vm.setParameter(Vm.SET_ALWAYS_SHOW_SIP_BUTTON,1);
+				Device.preventIdleState(true);
+			}
+		} //TODO else Vm.setSIP(0);
+
+        if (pref.showStatus) statBar = new StatusBar();
+		mMenu = new MainMenu(this);
+		mTab = new MainTab(mMenu,statBar);
+		split=new SplittablePanel(PanelSplitter.HORIZONTAL);
+		split.theSplitter.thickness=0; split.theSplitter.modify(Invisible,0);
+		CellPanel pnlCacheList = split.getNextPanel();
+		CellPanel pnlMainTab = split.getNextPanel();
+		split.setSplitter(PanelSplitter.MIN_SIZE|PanelSplitter.BEFORE,PanelSplitter.HIDDEN|PanelSplitter.BEFORE,PanelSplitter.CLOSED);
+		pnlCacheList.addLast(cacheList=new CacheList(),STRETCH,FILL);
+		pnlMainTab.addLast(mTab,STRETCH,FILL);
+
+		mTab.dontAutoScroll=true;
+
+		this.addLast(split,STRETCH,FILL);
+		/*
+		if (pref.menuAtTop) {
+			this.addLast(mMenu,CellConstants.DONTSTRETCH, CellConstants.FILL);
+			this.addLast(split,STRETCH,FILL);
+		} else {
+			this.addLast(split,STRETCH,FILL);
+			this.addLast(mMenu,CellConstants.DONTSTRETCH, CellConstants.FILL);
+		}
+		*/
+		mMenu.setTablePanel(mTab.getTablePanel());
+		if (infB != null) infB.close(0);
+		mTab.tbP.resetModel();
+		mTab.tbP.selectFirstRow();
+		//mTab.tbP.tc.paintSelection();
+		Form.cancelWait();
+	}
+
+
+	private void addGuiFont(){
+		Font defaultGuiFont = Application.findFont(&quot;gui&quot;);
+		int sz = (pref.fontSize);
+		Font newGuiFont = new Font(defaultGuiFont.getName(), defaultGuiFont.getStyle(), sz);
+		Application.addFont(newGuiFont, &quot;gui&quot;);
+		Application.mainApp.font = newGuiFont;
+		Application.fontsChanged();
+	}
+
+	public void doPaint(Graphics g, Rect r){
+		pref.myAppHeight = this.height;
+		pref.myAppWidth = this.width;
+		super.doPaint(g,r);
+	}
+
+	public void onEvent(Event ev){ // Preferences have been changed by PreferencesScreen
+		if(pref.dirty == true){
+			mTab.getTablePanel().tModel.setColumnNamesAndWidths();
+			mTab.getTablePanel().refreshControl();
+		    //mTab.getTablePanel().refreshTable();
+			pref.dirty = false;
+		}
+		super.onEvent(ev);
+	}
+
+	public void toggleCacheListVisible() {
+		cacheListVisible=!cacheListVisible;
+		if (cacheListVisible) {
+			// Make the splitterbar visible with a width of 6
+			split.theSplitter.modify(0,Invisible);
+			split.theSplitter.resizeTo(6,split.theSplitter.getRect().height);
+			Global.mainForm.mMenu.cacheTour.modifiers|=MenuItem.Checked;
+		} else {
+			// Hide the splitterbar and set width to 0
+			split.theSplitter.modify(Invisible,0);
+			split.theSplitter.resizeTo(0,split.theSplitter.getRect().height);
+			Global.mainForm.mMenu.cacheTour.modifiers&amp;=~MenuItem.Checked;
+		}
+		split.theSplitter.doOpenClose(cacheListVisible);
+		Global.mainForm.mMenu.repaint();
+
+	}
+
+}

Added: experiments/EVE/src/cachewolf/MainMenu.java
===================================================================
--- experiments/EVE/src/cachewolf/MainMenu.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/MainMenu.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,731 @@
+package cachewolf;
+
+import eve.ui.*;
+import java.util.Vector;
+
+import cachewolf.exp.*;
+import cachewolf.imp.DBImporter;
+import cachewolf.imp.GPXImporter;
+import cachewolf.imp.LOCXMLImporter;
+import cachewolf.imp.OCXMLImporter;
+import cachewolf.imp.SpiderGC;
+import cachewolf.navi.MapImporter;
+import cachewolf.navi.MapLoaderGui;
+import cachewolf.navi.SelectMap;
+
+import eve.sys.*;
+import eve.io.*;
+import eve.ui.filechooser.*;
+import eve.ui.data.InputBox;
+import eve.ui.event.MenuEvent;
+
+/**
+ *	This class creates the menu for cachewolf. It is also responsible
+ *	for reacting to user inputs in the menu.&lt;br&gt;
+ *	This class id=100
+ *	@see MainForm
+ *	@see MainTab
+ *   Last change:
+ *     20061123 salzkammergut Tidied up, added MyLocale, added additional internationalisation, combine save/filter for small screens, garminConn
+ */
+public class MainMenu extends MenuBar {
+	private MenuItem preferences,mnuContext,loadcaches,loadOC,/* savenexit,*/savenoxit,exit,search,searchAll,searchClr;
+	private MenuItem downloadmap, kalibmap, importmap;
+	private MenuItem spider, update, chkVersion, importDB;
+	private MenuItem about, wolflang, sysinfo, legend;
+	private MenuItem exportpcx5, exporthtml, exporttop50, exportGPX, exportASC, exportTomTom, exportMSARCSV;
+	private MenuItem exportOZI, exportKML, exportTPL, exportExplorist;
+	private MenuItem filtCreate, filtClear, filtInvert, filtSelected, filtNonSelected, filtBlack, filtApply;
+	private MenuItem exportGPS, mnuSeparator;
+	private MenuItem orgNewWP,orgCopy, orgMove, orgDelete,orgRebuild;
+	public MenuItem cacheTour,orgTravelbugs, mnuForceLogin;
+	private MenuItem mnuNewProfile, mnuOpenProfile, mnuEditCenter;
+	private Form father;
+	private TablePanel tbp;
+	private FilterScreen scnFilter=null; // Lazy initialitation only if it is opened
+
+	public MainMenu(Form f){
+		father = f;
+		String cwd = File.getProgramDirectory();
+
+		///////////////////////////////////////////////////////////////////////
+		// subMenu for profiles, part of &quot;Application&quot; menu below
+		///////////////////////////////////////////////////////////////////////
+		MenuItem[] mnuProfile = new MenuItem[2];
+		mnuProfile[0] = mnuNewProfile = new MenuItem(MyLocale.getMsg(1107,&quot;New&quot;));
+		mnuProfile[1] = mnuOpenProfile = new MenuItem(MyLocale.getMsg(1109,&quot;Open&quot;));
+		Menu profileMenu = new Menu(mnuProfile,MyLocale.getMsg(121,&quot;Profiles&quot;));
+
+		///////////////////////////////////////////////////////////////////////
+		// subMenu for import, part of &quot;Application&quot; menu below
+		///////////////////////////////////////////////////////////////////////
+		MenuItem[] mnuImport = new MenuItem[7];
+		mnuImport[0] = loadcaches  = new MenuItem(MyLocale.getMsg(129,&quot;Import GPX&quot;)); //TODO internationalization
+		mnuImport[1] = loadOC      = new MenuItem(MyLocale.getMsg(130,&quot;Download von opencaching.de&quot;));
+		mnuImport[2] = spider      = new MenuItem(MyLocale.getMsg(131,&quot;Spider von geocaching.com&quot;));
+		mnuImport[3] = update      = new MenuItem(MyLocale.getMsg(1014,&quot;Update cache data&quot;));
+		mnuImport[4] = importDB    = new MenuItem(&quot;Import DB&quot;); //TODO Internationalisation
+		mnuImport[5] = mnuSeparator = new MenuItem(&quot;-&quot;);
+		mnuImport[6] = mnuForceLogin      = new MenuItem(&quot;Always login to GC&quot;);
+		Menu importMenu = new Menu(mnuImport, MyLocale.getMsg(175,&quot;Import&quot;));
+		if (Global.getPref().forceLogin) mnuForceLogin.modifiers^=MenuItem.Checked;
+
+		///////////////////////////////////////////////////////////////////////
+		// subMenu for export, part of &quot;Application&quot; menu below
+		///////////////////////////////////////////////////////////////////////
+		MenuItem[] exitems = new MenuItem[12];
+		//Vm.debug(&quot;Hi in MainMenu &quot;+lr);
+		exitems[0] = exporthtml = new MenuItem(MyLocale.getMsg(100,&quot;to HTML&quot;));
+		exitems[1] = exportpcx5 = new MenuItem(MyLocale.getMsg(101,&quot;to PCX5 Mapsource&quot;));
+		exitems[2] = exporttop50 = new MenuItem(MyLocale.getMsg(102,&quot;to TOP50 ASCII&quot;));
+		exitems[3] = exportGPX = new MenuItem(MyLocale.getMsg(103,&quot;to GPX&quot;));
+		exitems[4] = exportASC = new MenuItem(MyLocale.getMsg(104,&quot;to ASC&quot;));
+		exitems[5] = exportTomTom = new MenuItem(MyLocale.getMsg(105,&quot;to TomTom&quot;));
+		exitems[6] = exportMSARCSV = new MenuItem(MyLocale.getMsg(106,&quot;to MS AutoRoute CSV&quot;));
+		exitems[7] = exportGPS = new MenuItem(MyLocale.getMsg(122,&quot;to GPS&quot;));
+		if(!(new File(cwd + &quot;/gpsbabel.exe&quot;)).exists()) exitems[7].modifiers = MenuItem.Disabled;
+		exitems[8] = exportOZI = new MenuItem(MyLocale.getMsg(124,&quot;to OZI&quot;));
+		exitems[9] = exportKML = new MenuItem(MyLocale.getMsg(125,&quot;to Google Earth&quot;));
+		exitems[10] = exportExplorist = new MenuItem(MyLocale.getMsg(132,&quot;to Explorist&quot;));
+		exitems[11] = exportTPL = new MenuItem(MyLocale.getMsg(128,&quot;via Template&quot;));
+
+		Menu exportMenu = new Menu(exitems, MyLocale.getMsg(107,&quot;Export&quot;));
+
+		///////////////////////////////////////////////////////////////////////
+		// subMenu for maps, part of &quot;Application&quot; menu below
+		///////////////////////////////////////////////////////////////////////
+		MenuItem[] mapMenuItems = new MenuItem[3];
+		mapMenuItems[0] = downloadmap = new MenuItem(MyLocale.getMsg(162,&quot;Download calibrated&quot;));
+		mapMenuItems[1] = importmap = new MenuItem(MyLocale.getMsg(150,&quot;Import&quot;));
+		mapMenuItems[2] = kalibmap = new MenuItem(MyLocale.getMsg(151,&quot;Calibrate&quot;));
+		Menu mapsMenu = new Menu(mapMenuItems, null);
+
+		// Now we start with the horizontal menu bar &quot;Application&quot;, &quot;Search&quot;, &quot;Filter&quot;, &quot;Organise&quot;, &quot;About&quot;
+		///////////////////////////////////////////////////////////////////////
+		// Create the &quot;Application&quot; pulldown menu
+		///////////////////////////////////////////////////////////////////////
+		MenuItem [] appMenuItems=new MenuItem[11];
+		appMenuItems[0] = new MenuItem(MyLocale.getMsg(121,&quot;Profile&quot;), 0, profileMenu);
+		appMenuItems[1] = preferences = new MenuItem(MyLocale.getMsg(108,&quot;Preferences&quot;));
+		appMenuItems[2] = mnuEditCenter = new MenuItem(MyLocale.getMsg(1110,&quot;Centre&quot;));
+		appMenuItems[3] = mnuContext = new MenuItem(MyLocale.getMsg(134,&quot;Current Cache&quot;));
+		appMenuItems[4] = mnuSeparator;
+		appMenuItems[5] = new MenuItem(MyLocale.getMsg(175,&quot;Import&quot;),0,importMenu);
+		appMenuItems[6] = new MenuItem(MyLocale.getMsg(107,&quot;Export&quot;),0,exportMenu);
+		appMenuItems[7] = new MenuItem(MyLocale.getMsg(149,&quot;Maps&quot;),0,mapsMenu);
+		appMenuItems[8] = mnuSeparator;
+		appMenuItems[9] = savenoxit = new MenuItem(MyLocale.getMsg(127,&quot;Save&quot;));
+		//appMenuItems[10] = savenexit = new MenuItem(MyLocale.getMsg(110,&quot;Save &amp; Exit&quot;));
+		appMenuItems[10] = exit = new MenuItem(MyLocale.getMsg(111,&quot;Exit&quot;));
+		this.addMenu(new PullDownMenu(MyLocale.getMsg(120,&quot;Application&quot;),new Menu(appMenuItems,null)));
+
+		///////////////////////////////////////////////////////////////////////
+		// Create the &quot;Search&quot; pulldown menu
+		///////////////////////////////////////////////////////////////////////
+		MenuItem[] searchMenuItems=new MenuItem[3];
+		searchMenuItems[0] = search = new MenuItem(MyLocale.getMsg(112,&quot;Search$&quot;+(char)6)); // char 6 = ctrl +f
+		searchMenuItems[1] = searchAll = new MenuItem(MyLocale.getMsg(133,&quot;Search All&quot;));
+		searchMenuItems[2] = searchClr = new MenuItem(MyLocale.getMsg(113,&quot;Clear search&quot;));
+
+		///////////////////////////////////////////////////////////////////////
+		// Create the &quot;Filter&quot; pulldown menu
+		///////////////////////////////////////////////////////////////////////
+		MenuItem[] filterMenuItems=new MenuItem[9];
+		filterMenuItems[0] = filtApply  = new MenuItem(MyLocale.getMsg(709,&quot;Apply&quot;));
+		filterMenuItems[1] = filtCreate  = new MenuItem(MyLocale.getMsg(114,&quot;Create&quot;));
+		filterMenuItems[2] = filtInvert  = new MenuItem(MyLocale.getMsg(115,&quot;Invert&quot;));
+		filterMenuItems[3] = filtClear   = new MenuItem(MyLocale.getMsg(116,&quot;Clear&quot;));
+		filterMenuItems[4] = mnuSeparator;
+		filterMenuItems[5] = filtSelected = new MenuItem(MyLocale.getMsg(160,&quot;Filter selected&quot;));
+		filterMenuItems[6] = filtNonSelected = new MenuItem(MyLocale.getMsg(1011,&quot;Filter out non selected&quot;));
+		filterMenuItems[7] = mnuSeparator;
+		filterMenuItems[8] = filtBlack   = new MenuItem(MyLocale.getMsg(161,&quot;Show Blacklist&quot;));
+		//filterMenuItems[9] = mnuSeparator;
+		//filterMenuItems[10] = filtCacheTour = new MenuItem(MyLocale.getMsg(198,&quot;Cachetour&quot;));
+
+		///////////////////////////////////////////////////////////////////////
+		// Create a combined &quot;Filter and Search&quot; pulldown menu for devices with small screens
+		///////////////////////////////////////////////////////////////////////
+		MenuItem[] filterAndSearchMenuItems=new MenuItem[12];
+		filterAndSearchMenuItems[0]=filtApply;
+		filterAndSearchMenuItems[1]=filtCreate;
+		filterAndSearchMenuItems[2]=filtInvert;
+		filterAndSearchMenuItems[3]=filtClear;
+		filterAndSearchMenuItems[4]=mnuSeparator;
+		filterAndSearchMenuItems[5]=filtSelected;
+		filterAndSearchMenuItems[6]=filtNonSelected;
+		filterAndSearchMenuItems[7]=mnuSeparator;
+		filterAndSearchMenuItems[8]=filtBlack;
+		filterAndSearchMenuItems[9]=mnuSeparator;
+		filterAndSearchMenuItems[10]=search;
+		filterAndSearchMenuItems[11]=searchClr;
+		//filterAndSearchMenuItems[12] = mnuSeparator;
+		//filterAndSearchMenuItems[13] = filtCacheTour;
+
+		// Depending on screen width display either filter and searach menus or the combined menu
+		if (MyLocale.getScreenWidth()&gt;300) {
+			this.addMenu(new PullDownMenu(MyLocale.getMsg(112,&quot;Search&quot;),new Menu(searchMenuItems,null)));
+			this.addMenu(new PullDownMenu(MyLocale.getMsg(159,&quot;Filter&quot;),new Menu(filterMenuItems,null)));
+		} else {
+			this.addMenu(new PullDownMenu(MyLocale.getMsg(159,&quot;Filter&quot;),new Menu(filterAndSearchMenuItems,null)));
+		}
+
+		///////////////////////////////////////////////////////////////////////
+		// Create the &quot;Organise&quot; pulldown menu
+		///////////////////////////////////////////////////////////////////////
+		MenuItem[] organiseMenuItems=new MenuItem[9];
+		organiseMenuItems[0] = orgNewWP = new MenuItem(MyLocale.getMsg(214,&quot;New Waypoint&quot;));
+		organiseMenuItems[1] = mnuSeparator;
+		organiseMenuItems[2] = orgCopy  = new MenuItem(MyLocale.getMsg(141,&quot;Copy&quot;));
+		organiseMenuItems[3] = orgMove  = new MenuItem(MyLocale.getMsg(142,&quot;Move&quot;));
+		organiseMenuItems[4] = orgDelete   = new MenuItem(MyLocale.getMsg(143,&quot;Delete&quot;));
+		organiseMenuItems[5] = orgRebuild   = new MenuItem(MyLocale.getMsg(208,&quot;Rebuild Index&quot;));
+		organiseMenuItems[6] = mnuSeparator;
+		organiseMenuItems[7] = orgTravelbugs = new MenuItem(MyLocale.getMsg(139,&quot;Manage travelbugs&quot;));
+		organiseMenuItems[8] = cacheTour = new MenuItem(MyLocale.getMsg(198,&quot;Cachetour&quot;));
+
+		this.addMenu(new PullDownMenu(MyLocale.getMsg(140,&quot;Organise&quot;),new Menu(organiseMenuItems,null)));
+
+		///////////////////////////////////////////////////////////////////////
+		// Create the &quot;About&quot; pulldown menu
+		///////////////////////////////////////////////////////////////////////
+		MenuItem[] aboutMenuItems=new MenuItem[5];
+		aboutMenuItems[0] = about = new MenuItem(MyLocale.getMsg(117,&quot;About&quot;));
+		aboutMenuItems[1] = legend = new MenuItem(MyLocale.getMsg(155,&quot;Legend&quot;));
+		aboutMenuItems[2] = wolflang = new MenuItem(MyLocale.getMsg(118,&quot;WolfLanguage&quot;));
+		aboutMenuItems[3] = sysinfo = new MenuItem(MyLocale.getMsg(157,&quot;System&quot;));
+		aboutMenuItems[4] = chkVersion = new MenuItem(MyLocale.getMsg(158,&quot;Version Check&quot;));
+		this.addMenu(new PullDownMenu(MyLocale.getMsg(117,&quot;About&quot;),new Menu(aboutMenuItems,null)));
+	}
+
+	public void setTablePanel(TablePanel t){
+		tbp = t;
+		if (mnuContext.subMenu == null) {
+			if ((&quot;,&quot;+Global.getPref().listColMap+&quot;,&quot;).indexOf(&quot;,0,&quot;)&gt;=0)
+				mnuContext.subMenu = tbp.tControl.getMenuFull();
+			 else
+				 mnuContext.subMenu = tbp.tControl.getMenuSmall();
+		}
+	}
+
+	public void allowProfileChange(boolean profileChangeAllowed) {
+		if (profileChangeAllowed) {
+			mnuNewProfile.modifiers&amp;=~MenuItem.Disabled;
+			mnuOpenProfile.modifiers&amp;=~MenuItem.Disabled;
+		} else {
+			mnuNewProfile.modifiers|=MenuItem.Disabled;
+			mnuOpenProfile.modifiers|=MenuItem.Disabled;
+		}
+	}
+
+	public void setForceLogin() {
+		mnuForceLogin.modifiers=Global.getPref().forceLogin ? Global.mainTab.mnuMain.modifiers|MenuItem.Checked : Global.mainTab.mnuMain.modifiers&amp;~MenuItem.Checked;
+	}
+
+	public static void search() {
+		String srch = new InputBox(MyLocale.getMsg(119,&quot;Search for:&quot;)).input(&quot;&quot;,10);
+		if (srch != null) {
+			SearchCache ssc = new SearchCache(Global.getProfile().cacheDB);
+			ssc.search(srch);
+			Global.mainTab.tbP.refreshTable();
+		}
+	}
+	public void onEvent(Event ev){
+		Preferences pref=Global.getPref();
+		Profile profile=Global.getProfile();
+		Vector cacheDB=profile.cacheDB;
+		Global.mainTab.updatePendingChanges();
+		if (ev instanceof MenuEvent){ //&amp;&amp; ev.type == MenuEvent.PRESSED
+			MenuEvent mev = (MenuEvent)ev;
+			///////////////////////////////////////////////////////////////////////
+			// subMenu for profiles, part of &quot;Application&quot; menu
+			///////////////////////////////////////////////////////////////////////
+			if(mev.selectedItem == mnuNewProfile){
+				if (NewProfileWizard.startNewProfileWizard(getFrame()) ) {				Global.mainTab.saveUnsavedChanges(true);
+					pref.curCentrePt = new CWPoint(profile.centre);
+					filtBlack.modifiers=Global.getProfile().showBlacklisted?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&amp;~MenuItem.Checked;
+					tbp.refreshTable();
+					Global.mainForm.title=&quot;CW &quot;+Version.getRelease()+&quot; - &quot;+profile.name;
+				}
+			}
+			if(mev.selectedItem == mnuOpenProfile){
+				Global.mainTab.saveUnsavedChanges(true);
+				if (pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_FORCED_ON,false)) {
+					tbp.tModel.numRows=0;
+					CacheHolder.removeAllDetails();
+					profile.cacheDB.clear();
+					InfoBox infB = new InfoBox(&quot;CacheWolf&quot;,MyLocale.getMsg(5000,&quot;Loading Cache-List&quot;));
+					infB.exec();
+					infB.getWindow().waitUntilPainted(1000);
+					Form.showWait();
+					profile.readIndex();
+					Form.cancelWait();
+					pref.curCentrePt.set(profile.centre);
+					filtBlack.modifiers=Global.getProfile().showBlacklisted?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&amp;~MenuItem.Checked;
+					Global.mainForm.title=&quot;CW &quot;+Version.getRelease()+&quot; - &quot;+profile.name;
+					infB.close(0);
+					tbp.resetModel(); // &amp; restore Filter
+				}
+			}
+			if(mev.selectedItem == mnuEditCenter){
+				CenterScreen f=new CenterScreen(pref,profile);
+				f.execute(getFrame(), Gui.CENTER_FRAME);
+				tbp.refreshTable();
+				f.close(0);
+			}
+			///////////////////////////////////////////////////////////////////////
+			// subMenu for import, part of &quot;Application&quot; menu
+			///////////////////////////////////////////////////////////////////////
+			if(mev.selectedItem == spider){
+				SpiderGC spGC = new SpiderGC(pref, profile, true);
+				Global.mainTab.saveUnsavedChanges(false);
+				spGC.doIt();
+				cacheDB.clear();
+				profile.readIndex();
+				tbp.resetModel();
+			}
+			if(mev.selectedItem == loadcaches){
+				FileChooser fc = new FileChooser(FileChooser.OPEN|FileChooser.MULTI_SELECT, pref.baseDir);
+				fc.addMask(&quot;*.gpx,*.zip,*.loc&quot;);
+				fc.title=MyLocale.getMsg(909,&quot;Select file(s)&quot;);
+				if(fc.execute() != FileChooser.IDCANCEL){
+					String dir = fc.getChosenDirectory().toString();
+					String files[] = fc.getAllChosen();
+					/*
+					int how = GPXImporter.DOIT_ASK;
+					if (files.length &gt; 0){
+							InfoBox iB = new InfoBox(&quot;Spider?&quot;, &quot;Spider Images?&quot;, InfoBox.CHECKBOX);
+							iB.execute();
+							boolean doSpider = iB.mCB_state;
+							if (doSpider) how = GPXImporter.DOIT_WITHSPOILER;
+							else how = GPXImporter.DOIT_NOSPOILER;
+					}
+					 */
+					for (int i = 0; i &lt; files.length; i++){
+						String file = dir + &quot;/&quot; + files[i];
+						if (file.endsWith(&quot;loc&quot;)){
+							LOCXMLImporter loc = new LOCXMLImporter(profile, file);
+							loc.doIt();
+						}
+						else {
+							GPXImporter gpx = new GPXImporter(pref, profile, file);
+							gpx.doIt(0);
+						}
+					}
+				}
+				Global.getProfile().showBlacklisted=false;
+				filtBlack.modifiers&amp;=Global.getProfile().showBlacklisted?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&amp;~MenuItem.Checked;
+				tbp.resetModel();
+			}
+			if(mev.selectedItem == loadOC){
+				OCXMLImporter oc = new OCXMLImporter(pref,profile);
+				oc.doIt();
+				Global.getProfile().showBlacklisted=false;
+				filtBlack.modifiers&amp;=Global.getProfile().showBlacklisted?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&amp;~MenuItem.Checked;
+				tbp.resetModel();
+			}
+			if (mev.selectedItem == update)
+				updateSelectedCaches(tbp);
+
+			if (mev.selectedItem == importDB) {
+				FileChooser fc = new FileChooser(FileChooser.OPEN, pref.baseDir);
+				fc.addMask(&quot;*.gpx,*.zip&quot;);
+				fc.title=MyLocale.getMsg(909,&quot;Select file(s)&quot;);
+				if(fc.execute() != FileChooser.IDCANCEL){
+					DBImporter dbI=new DBImporter();
+					dbI.doIt(fc.getChosenFile().toString());
+				}
+			}
+			if(mev.selectedItem == mnuForceLogin) {
+				mnuForceLogin.modifiers^=MenuItem.Checked;
+				Global.getPref().forceLogin=(mnuForceLogin.modifiers&amp;MenuItem.Checked)!=0;
+				Global.getPref().savePreferences();
+			}
+			///////////////////////////////////////////////////////////////////////
+			// subMenu for export, part of &quot;Application&quot; menu
+			///////////////////////////////////////////////////////////////////////
+			if(mev.selectedItem == exporthtml){
+				HTMLExporter htm = new HTMLExporter(pref, profile);
+				htm.doIt();
+			}
+			if(mev.selectedItem == exportpcx5){
+				PCX5Exporter pcx = new PCX5Exporter( pref, profile);
+				pcx.doIt(PCX5Exporter.MODE_ASK);
+			}
+			if(mev.selectedItem == exporttop50){
+				OVLExporter ovl = new OVLExporter(pref, profile);
+				ovl.doIt();
+			}
+			if(mev.selectedItem == exportGPX){
+				GPXExporter htm = new GPXExporter(pref, profile);
+				htm.doIt(1);
+			}
+			if(mev.selectedItem == exportASC){
+				ASCExporter asc = new ASCExporter(pref,profile);
+				asc.doIt();
+			}
+			if(mev.selectedItem == exportTomTom){
+				TomTomExporter tt = new TomTomExporter();
+				tt.doIt();
+			}
+			if(mev.selectedItem == exportMSARCSV){
+				MSARCSVExporter msar = new MSARCSVExporter(pref,profile);
+				msar.doIt();
+			}
+			if(mev.selectedItem == exportGPS){
+				Form.showWait();
+				LocExporter loc = new LocExporter();
+				String tmpFileName = File.getProgramDirectory() + &quot;/temp.loc&quot;;
+				loc.setTmpFileName(tmpFileName);
+				loc.doIt(LocExporter.MODE_AUTO);
+				ProgressBarForm.display(MyLocale.getMsg(950,&quot;Transfer&quot;),MyLocale.getMsg(951,&quot;Sending to GPS&quot;), null);
+				try{
+					pref.log(&quot;gpsbabel.exe &quot;+pref.garminGPSBabelOptions+&quot; -i geo -f \&quot;&quot;+ tmpFileName +&quot;\&quot; -o garmin -F &quot; + pref.garminConn +&quot;:&quot;);
+					java.lang.Process p = java.lang.Runtime.getRuntime().exec(&quot;gpsbabel.exe &quot;+pref.garminGPSBabelOptions+&quot; -i geo -f \&quot;&quot;+ tmpFileName +&quot;\&quot; -o garmin -F &quot; + pref.garminConn +&quot;:&quot;);
+					p.waitFor();
+				}catch(Exception ioex){
+					Form.cancelWait();
+					(new MessageBox(&quot;Error&quot;, &quot;Garmin export unsuccessful&quot;, MessageBox.OKB)).execute();
+					pref.log(&quot;Error exporting to Garmin&quot;,ioex);
+				};
+				ProgressBarForm.clear();
+				Form.cancelWait();
+			}
+			if(mev.selectedItem == exportOZI){
+				OziExporter ozi = new OziExporter( pref, profile);
+				ozi.doIt();
+			}
+			if(mev.selectedItem == exportKML){
+				KMLExporter kml = new KMLExporter( pref, profile);
+				kml.doIt();
+			}
+			if(mev.selectedItem == exportTPL){
+				FileChooser fc = new FileChooser(FileChooser.OPEN, File.getProgramDirectory());
+				fc.addMask(&quot;*.tpl&quot;);
+				fc.title=MyLocale.getMsg(910,&quot;Select Template file&quot;);
+				if(fc.execute() != FileChooser.IDCANCEL){
+					TPLExporter tpl = new TPLExporter( pref,profile, fc.getChosenFile().toString());
+					tpl.doIt();
+				}
+			}
+			if(mev.selectedItem == exportExplorist) {
+				ExploristExporter mag = new ExploristExporter( pref, profile);
+				mag.doIt();
+			}
+			///////////////////////////////////////////////////////////////////////
+			// subMenu for maps, part of &quot;Application&quot; menu
+			///////////////////////////////////////////////////////////////////////
+			if(mev.selectedItem == downloadmap){
+				MapLoaderGui mLG = new MapLoaderGui(cacheDB);
+				mLG.exec(); // .execute doesn't work because the tcp-socket uses another thread which cannot be startet if here .execute() is used!
+			}
+			if(mev.selectedItem == importmap){
+
+				MapImporter map = new MapImporter(pref);
+				map.importMap();
+			}
+			if(mev.selectedItem == kalibmap){
+				SelectMap sM = new SelectMap();
+				sM.execute();
+				if((sM.getSelectedMap()).length()&gt;0){
+					try {
+						MapImporter map = new MapImporter(pref, sM.getSelectedMap(),sM.worldfileexists);
+						map.execute(null, Gui.CENTER_FRAME);
+					} catch (java.lang.OutOfMemoryError e) {
+						MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, &quot;Error&quot;), MyLocale.getMsg(156,&quot;Out of memory error, map to big&quot;), MessageBox.OKB);
+						tmpMB.exec();
+					}
+				}
+			}
+			///////////////////////////////////////////////////////////////////////
+			// &quot;Application&quot; pulldown menu
+			///////////////////////////////////////////////////////////////////////
+			if(mev.selectedItem == preferences){
+				tbp.saveColWidth(pref);
+				PreferencesScreen pfs = new PreferencesScreen(pref);
+				pfs.execute(father.getFrame(), Gui.CENTER_FRAME);
+				pref.readPrefFile();
+			}
+			if(mev.selectedItem == savenoxit){
+				profile.saveIndex(Profile.SHOW_PROGRESS_BAR);
+				tbp.saveColWidth(pref);
+			}
+
+/*			if(mev.selectedItem == savenexit){
+				profile.saveIndex(Profile.SHOW_PROGRESS_BAR);
+				tbp.saveColWidth(pref);
+				eve.sys.Vm.exit(0);
+			}
+*/			if(mev.selectedItem == exit){
+				Global.mainTab.saveUnsavedChanges(true);
+				CacheHolder.saveAllModifiedDetails();
+				tbp.saveColWidth(pref);
+				eve.sys.Vm.exit(0);
+			}
+
+			///////////////////////////////////////////////////////////////////////
+			// &quot;Search&quot; pulldown menu
+			///////////////////////////////////////////////////////////////////////
+			if(mev.selectedItem == search){
+				search();
+			}
+			if(mev.selectedItem == searchAll){
+				SearchCache ssc = new SearchCache(cacheDB);
+				ssc.clearSearch();
+				tbp.refreshTable();
+				search();
+			}
+			if(mev.selectedItem == searchClr){
+				SearchCache ssc = new SearchCache(cacheDB);
+				ssc.clearSearch();
+				tbp.refreshTable();
+			}
+			///////////////////////////////////////////////////////////////////////
+			// &quot;Filter&quot; pulldown menu
+			///////////////////////////////////////////////////////////////////////
+			if(mev.selectedItem == filtApply){
+				Filter flt = new Filter();
+				flt.setFilter();
+				flt.doFilter();
+				tbp.refreshTable();
+			}
+			if(mev.selectedItem == filtCreate){
+				if (scnFilter==null) scnFilter=new FilterScreen();
+				scnFilter.setData();
+				scnFilter.execute(father.getFrame(), Gui.CENTER_FRAME);
+				tbp.refreshTable();
+			}
+			if(mev.selectedItem == filtInvert){
+				Filter flt = new Filter();
+				flt.invertFilter();
+				tbp.refreshTable();
+			}
+			if(mev.selectedItem == filtClear){
+				Filter flt = new Filter();
+				flt.clearFilter();
+				tbp.refreshTable();
+			}
+			if(mev.selectedItem == filtSelected){ // incremental filter
+				Global.getProfile().selectionChanged = true;
+				CacheHolder ch;
+				boolean filterChanged = false;
+				for(int i = cacheDB.size()-1; i&gt;=0; i--){
+					ch = (CacheHolder)cacheDB.get(i);
+					// This is an incremental filter, i.e. it keeps the existing filter
+					// status and only adds the marked caches to the filtered set
+					if (ch.is_Checked &amp;&amp; !ch.is_filtered) {
+						ch.is_filtered = true;
+						filterChanged = true;
+					}
+				}
+				if ( filterChanged &amp;&amp; Global.getProfile().filterActive == Filter.FILTER_INACTIVE) {
+					Global.getProfile().filterActive = Filter.FILTER_MARKED_ONLY;
+				}
+				tbp.refreshTable();
+			}
+			if (mev.selectedItem == filtNonSelected){
+				Global.getProfile().selectionChanged = true;
+				CacheHolder ch;
+				boolean filterChanged = false;
+				for(int i = cacheDB.size()-1; i &gt;=0; i--){
+					ch = (CacheHolder)cacheDB.get(i);
+					// incremental filter. Keeps status of all marked caches and
+					// adds unmarked caches to filtered list
+					if (!ch.is_Checked &amp;&amp; !ch.is_filtered) {
+						ch.is_filtered = true;
+						filterChanged = true;
+					}
+				}
+				if ( filterChanged &amp;&amp; Global.getProfile().filterActive == Filter.FILTER_INACTIVE) {
+					Global.getProfile().filterActive = Filter.FILTER_MARKED_ONLY;
+				}
+				tbp.refreshTable();
+			}
+			if(mev.selectedItem == filtBlack){
+				//filtBlack.modifiers=filtBlack.modifiers|MenuItem.Checked;
+				Global.getProfile().showBlacklisted = !Global.getProfile().showBlacklisted;
+				filtBlack.modifiers=Global.getProfile().showBlacklisted?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&amp;~MenuItem.Checked;
+				SearchCache ssc = new SearchCache(cacheDB);
+				ssc.clearSearch();// Clear search &amp; restore filter status
+				Filter flt=new Filter();
+				flt.clearFilter();
+				tbp.refreshTable();
+			}
+			///////////////////////////////////////////////////////////////////////
+			// &quot;Organise&quot; pulldown menu
+			///////////////////////////////////////////////////////////////////////
+ 			if(mev.selectedItem == orgNewWP){
+				if (Global.mainTab.tbP.getSelectedCache() &gt;= 0) Global.mainTab.lastselected = ((CacheHolder)cacheDB.get(Global.mainTab.tbP.getSelectedCache())).wayPoint;
+				Global.mainTab.newWaypoint(new CacheHolder());
+ 			}
+			if(mev.selectedItem == orgCopy){
+				profile.saveIndex(Profile.NO_SHOW_PROGRESS_BAR);
+				DataMover dm = new DataMover();
+				dm.copyCaches();
+				tbp.refreshTable();
+			}
+
+			if(mev.selectedItem == orgMove){
+				profile.saveIndex(Profile.NO_SHOW_PROGRESS_BAR);
+				DataMover dm = new DataMover();
+				dm.moveCaches();
+				tbp.refreshTable();
+			}
+
+			if(mev.selectedItem == orgDelete){
+				profile.saveIndex(Profile.NO_SHOW_PROGRESS_BAR);
+				DataMover dm = new DataMover();
+				dm.deleteCaches();
+				tbp.refreshTable();
+			}
+			if(mev.selectedItem == orgRebuild){
+				RebuildIndex rb=new RebuildIndex();
+				rb.rebuild();
+				tbp.refreshTable();
+			}
+			if(mev.selectedItem == orgTravelbugs){
+				TravelbugJourneyScreen tbs=new TravelbugJourneyScreen();
+				tbs.setPreferredSize(800,600);
+				tbs.execute(); //getFrame(), Gui.CENTER_FRAME);
+				tbs.close(0);
+			}
+			if(mev.selectedItem == cacheTour){
+				cacheTour.modifiers^=MenuItem.Checked;
+				Global.mainForm.toggleCacheListVisible();
+			}
+			///////////////////////////////////////////////////////////////////////
+			// &quot;About&quot; pulldown menu
+			///////////////////////////////////////////////////////////////////////
+			if(mev.selectedItem == about){
+				InfoHtmlScreen is = new InfoHtmlScreen(File.getProgramDirectory() + &quot;/&quot; + &quot;info.html&quot;, MyLocale.getMsg(117,&quot;About&quot;),true);
+				is.execute(father.getFrame(), Gui.CENTER_FRAME);
+			}
+			if(mev.selectedItem == legend){
+				InfoHtmlScreen is = new InfoHtmlScreen(File.getProgramDirectory() + &quot;/&quot; + &quot;legende.html&quot;, MyLocale.getMsg(155,&quot;Legend&quot;),true);
+				is.execute(father.getFrame(), Gui.CENTER_FRAME);
+			}
+			if(mev.selectedItem == wolflang){
+				InfoHtmlScreen is = new InfoHtmlScreen(File.getProgramDirectory() + &quot;/&quot; + &quot;wolflang.html&quot;, MyLocale.getMsg(118,&quot;WolfLanguage&quot;), true);
+				is.execute(father.getFrame(), Gui.CENTER_FRAME);
+			}
+			if(mev.selectedItem == sysinfo){
+				//Vm.debug(&quot;Checking system...&quot;);
+				StringBuffer sb=new StringBuffer(400);
+//TODO				Rect s = (Rect)Window.getGuiInfo(Window.INFO_SCREEN_RECT,null,new Rect(),0);
+//				Font f = mApp.guiFont;
+				sb.append(&quot;Profile: &quot;); 				sb.append(profile.dataDir);
+//TODO				sb.append(&quot;&lt;br&gt;Platform: &quot;); 			sb.append(Vm.getPlatform());
+				sb.append(&quot;&lt;br&gt;Locale lang is: &quot;);		sb.append(MyLocale.getLocaleLanguage());
+				sb.append(&quot;&lt;br&gt;Locale country is: &quot;); 	sb.append(MyLocale.getLocaleCountry());
+				sb.append(&quot;&lt;br&gt;Decimal separator is: \&quot;&quot;); sb.append(MyLocale.getDigSeparator());
+				sb.append(&quot;\&quot;&lt;br&gt;Device is PDA: &quot;);		sb.append(Device.isMobile());
+				sb.append(&quot;&lt;br&gt;Screen: &quot;);				sb.append(MyLocale.getScreenWidth());
+				sb.append(&quot; x &quot;);	 sb.append(MyLocale.getScreenHeight());
+//TODO				sb.append(&quot;&lt;br&gt;Font size: &quot;);			sb.append(f.getSize());
+				sb.append(&quot;&lt;br&gt;Entries in DB: &quot;);		sb.append(cacheDB.size());
+				sb.append(&quot;&lt;br&gt;File separator is: \&quot;&quot;); sb.append(Vm.getProperty(&quot;file.separator&quot;,&quot;def&quot;));
+				sb.append(&quot;\&quot;&lt;br&gt;Programme directory is &quot;); sb.append(File.getProgramDirectory());
+				sb.append(&quot;&lt;br&gt;Number of details in RAM is &quot;); sb.append(CacheHolder.cachesWithLoadedDetails.size());
+				sb.append(&quot; Max.: &quot;);					sb.append(Global.getPref().maxDetails);
+				sb.append(&quot;&lt;br&gt;CacheWolf version: &quot;);		sb.append(Version.getReleaseDetailed());
+				sb.append(&quot;&lt;br&gt;&quot;);
+				InfoHtmlScreen is = new InfoHtmlScreen(sb.toString(), &quot;System&quot;, false);
+				is.execute(father.getFrame(), Gui.CENTER_FRAME);
+			}
+			if(mev.selectedItem == chkVersion){
+				(new MessageBox(MyLocale.getMsg(178, &quot;Version Checking&quot;), Version.getUpdateMessage(), MessageBox.OKB)).execute();
+			}
+			  // In case that the triggered event was due to one of the context menu items, process
+			// the event by the context menu handler
+			tbp.tControl.popupMenuEvent(mev.selectedItem);
+		}
+	}
+
+	public static void updateSelectedCaches(TablePanel tablePanel) {
+		Preferences pref=Global.getPref();
+		Profile profile=Global.getProfile();
+		Vector cacheDB=profile.cacheDB;
+		CacheHolder ch;
+
+		SpiderGC spider = new SpiderGC(pref, profile, false);
+		OCXMLImporter ocSync = new OCXMLImporter(pref, profile);
+		//Vm.debug(&quot;ByPass? &quot; + profile.byPassIndexActive);
+		Form.showWait();
+		boolean alreadySaid = false;
+		boolean alreadySaid2 = false;
+		InfoBox infB = new InfoBox(&quot;Info&quot;, &quot;Loading&quot;, InfoBox.PROGRESS_WITH_WARNINGS);
+		infB.exec();
+
+		Vector cachesToUpdate = new Vector();
+		for(int i = 0; i &lt;	cacheDB.size(); i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			if(ch.is_Checked == true &amp;&amp; !ch.is_filtered) {
+				if ( ch.wayPoint.length()&gt;1 &amp;&amp; (ch.wayPoint.substring(0,2).equalsIgnoreCase(&quot;GC&quot;)
+						|| ch.wayPoint.substring(0,2).equalsIgnoreCase(&quot;OC&quot;)))
+//					if ( (ch.wayPoint.length() &gt; 1 &amp;&amp; ch.wayPoint.substring(0,2).equalsIgnoreCase(&quot;GC&quot;)))
+//					Notiz: Wenn es ein addi Wpt ist, sollte eigentlich der Maincache gespidert werden
+//					Alter code pr&#252;ft aber nur ob ein Maincache von GC existiert und versucht dann den addi direkt zu spidern, was nicht funktioniert
+				{
+					cachesToUpdate.add(new Integer(i));
+				} else {
+					if (ch.isAddiWpt() &amp;&amp; ch.mainCache!=null &amp;&amp; !ch.mainCache.is_Checked &amp;&amp; !alreadySaid2) { // Is the father ticked?
+						alreadySaid2=true;
+						(new MessageBox(MyLocale.getMsg(327,&quot;Information&quot;),
+								        MyLocale.getMsg(5001,&quot;Can't spider additional waypoint directly. Please check main cache.&quot;), FormBase.OKB)).execute();
+					}
+					if (!ch.isAddiWpt() &amp;&amp; !alreadySaid) {
+						alreadySaid = true;
+						(new MessageBox(MyLocale.getMsg(327,&quot;Information&quot;),
+								        ch.wayPoint+
+								        MyLocale.getMsg(5002,&quot;: At the moment this function is only applicable for geocaching.com and opencaching.de.&quot;), FormBase.OKB)).execute();
+					}
+				}
+
+			}
+		}
+
+		int spiderErrors = 0;
+		boolean forceLogin=Global.getPref().forceLogin; // To ensure that spiderSingle only logs in once if forcedLogin=true
+		for(int j = 0; j &lt;	cachesToUpdate.size(); j++){
+			int i = ((Integer)cachesToUpdate.get(j)).intValue();
+			ch = (CacheHolder)cacheDB.get(i);
+//			infB.setInfo(&quot;Loading: &quot; + ch.wayPoint);
+			infB.setInfo(MyLocale.getMsg(5513,&quot;Loading: &quot;) + ch.wayPoint +&quot; (&quot; + (j+1) + &quot; / &quot; + cachesToUpdate.size() + &quot;)&quot;);
+			infB.redisplay();
+			if (ch.wayPoint.substring(0,2).equalsIgnoreCase(&quot;GC&quot;)) {
+				int test = spider.spiderSingle(i, infB,forceLogin);
+				if (test == -1) {
+					infB.close(0);
+					break;
+				} else if (test == 0) {
+					spiderErrors++;
+				} else {
+					profile.hasUnsavedChanges=true;
+				}
+				forceLogin=false;
+			}
+			else {
+				if (!ocSync.syncSingle(i, infB)) {
+					infB.close(0);
+					break;
+				} else
+					profile.hasUnsavedChanges=true;
+			}
+
+//			cacheDB.clear();
+//			profile.readIndex();
+		}
+		infB.close(0);
+//		profile.hasUnsavedChanges=true;
+		profile.saveIndex(Profile.SHOW_PROGRESS_BAR);
+		profile.restoreFilter(true);
+		//profile.updateBearingDistance();
+		Global.mainTab.tbP.refreshTable();
+		Form.cancelWait();
+		if ( spiderErrors &gt; 0) {
+			new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;),spiderErrors + MyLocale.getMsg(5516,&quot; cache descriptions%0acould not be loaded.&quot;),FormBase.DEFOKB).execute();
+		}
+
+	}
+
+}

Added: experiments/EVE/src/cachewolf/MainTab.java
===================================================================
--- experiments/EVE/src/cachewolf/MainTab.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/MainTab.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,466 @@
+package cachewolf;
+
+import eve.sys.*;
+import eve.ui.*;
+import eve.fx.*;
+import java.util.*;
+
+import cachewolf.navi.GotoPanel;
+import cachewolf.navi.MapImage;
+import cachewolf.navi.MovingMap;
+import cachewolf.navi.Navigate;
+
+import eve.ui.event.*;
+import eve.ui.table.*;
+
+/**
+ *	This class creates the tabbed panel and sets the tabs to the respective
+ *	other panels. Important is to have a look at the event handler!&lt;br&gt;
+ *	@see MainForm
+ *	@see MainMenu
+ */
+public class MainTab extends TabbedPanel {
+	DescriptionPanel descP=new DescriptionPanel();
+	HintLogPanel hintLP = new HintLogPanel();
+	TablePanel tbP;
+	Vector cacheDB;
+	public DetailsPanel detP = new DetailsPanel();
+	CalcPanel calcP;
+	Preferences pref;
+	Profile profile;
+	GotoPanel gotoP; 
+	RadarPanel radarP = new RadarPanel();
+	ImagePanel imageP;
+	SolverPanel solverP;
+	String lastselected = &quot;&quot;;
+	public CacheHolder ch=null;
+	CacheHolderDetail chD =null, chMain=null;
+	MainMenu mnuMain;
+	StatusBar statBar;
+	public MovingMap mm;
+	Navigate nav;
+	public String mainCache=&quot;&quot;;
+	int oldCard=0;
+	boolean cacheDirty=false;
+	// These flags are set if data is put into the relevant panels
+	// They ensure that the panel is cleared, when a new cache is selected
+	boolean imagePhasData=false;
+	boolean descPhasData=false;
+	boolean detPhasData=false;
+	boolean hintLPhasData=false;
+	boolean solverPhasData=false;
+	boolean radarPhasData=false;
+	
+	public MainTab(MainMenu mainMenu,StatusBar statBar){
+		Global.mainTab=this;
+		mnuMain=mainMenu;
+		pref = Global.getPref();
+		profile=Global.getProfile();
+		if (!pref.tabsAtTop) tabLocation=SOUTH;
+		cacheDB = profile.cacheDB;
+		this.statBar=statBar;
+		//TODOMyLocale.setSIPButton();
+		//Don't expand tabs if the screen is very narrow, i.e. HP IPAQ 65xx, 69xx
+		int sw = MyLocale.getScreenWidth();
+		if ( sw &lt;= 240) this.dontExpandTabs=true;
+		String imagesize=&quot;&quot;;
+		if (Device.isMobile() &amp;&amp; sw &gt;= 400) imagesize=&quot;_vga&quot;;  
+		calcP = new CalcPanel(); // Init here so that Global.MainT is already set
+		tbP = new TablePanel(statBar);
+		Card c = this.addCard(new TableForm(tbP), MyLocale.getMsg(1200,&quot;List&quot;), null);
+		
+		c = this.addCard(detP, MyLocale.getMsg(1201,&quot;Details&quot;), null);
+		c.iconize(new Picture(&quot;details&quot;+imagesize+&quot;.gif&quot;),true);
+
+		c = this.addCard(descP, MyLocale.getMsg(1202,&quot;Description&quot;), null);
+		c.iconize(new Picture(&quot;descr&quot;+imagesize+&quot;.gif&quot;),true);
+
+		c = this.addCard(new MyScrollBarPanel(imageP = new ImagePanel()), MyLocale.getMsg(1203,&quot;Images&quot;), null);
+		c.iconize(new Picture(&quot;images&quot;+imagesize+&quot;.gif&quot;),true);
+
+		c = this.addCard(hintLP, MyLocale.getMsg(1204,&quot;Hints &amp; Logs&quot;), null);
+		c.iconize(new Picture(&quot;more&quot;+imagesize+&quot;.gif&quot;),true);
+
+		c = this.addCard(solverP = new SolverPanel(), MyLocale.getMsg(1205,&quot;Solver&quot;), null);
+		c.iconize(new Picture(&quot;solver&quot;+imagesize+&quot;.gif&quot;),true);
+
+		c = this.addCard(calcP, MyLocale.getMsg(1206,&quot;Calc&quot;), null);
+		Picture imgCalc=new Picture(&quot;projecttab&quot;+imagesize+&quot;.gif&quot;,new Color(0,255,0),0); 
+		c.iconize(imgCalc,true);
+
+		nav = new Navigate();
+		c = this.addCard(gotoP = new GotoPanel(nav), &quot;Goto&quot;, null);
+		c.iconize(new Picture(&quot;goto&quot;+imagesize+&quot;.gif&quot;),true);
+		nav.setGotoPanel(gotoP);
+
+		c = this.addCard(radarP, &quot;Radar&quot;, null);
+		c.iconize(new Picture(&quot;radar&quot;+imagesize+&quot;.gif&quot;),true);
+		mnuMain.allowProfileChange(true);
+	}
+	
+	public TablePanel getTablePanel(){
+		return tbP;
+	}
+
+	public void selectAndActive(int rownum){// Called from myInteractivePanel.imageClicked
+		tbP.selectRow(rownum);
+		this.selectAndExpand(0);
+	}
+
+	public void clearDetails() {
+		if (imagePhasData) { imageP.clearImages(); imagePhasData=false; }// Remove all images
+		if (descPhasData) { descP.clear(); descPhasData=false; }// write &quot;loading ...&quot;
+		if (detPhasData) { detP.clear(); detPhasData=false; }// Clear only the attributes
+		if (hintLPhasData) { hintLP.clear(); hintLPhasData=false; }// Remove the logs
+		if (solverPhasData) { solverP.setInstructions(&quot;loading ...&quot;); solverPhasData=false; }
+		if (radarPhasData) { radarP.removeCircle(); radarPhasData=false; }
+	}
+	
+	static int level=0;
+	public void onEvent(Event ev) {
+//eve.sys.Vm.debug(&quot;              &quot;.substring(0,level++*2)+&quot;[&quot;+ev.target.getClass().getName()+&quot;] &quot;+event2Name(ev.type));
+		// This section clears old data when a new line is selected in the table
+		if (ev instanceof TableEvent) {
+			clearDetails();
+		}
+		if(ev instanceof MultiPanelEvent){
+			// Check whether a profile change is allowed, if not disable the relevant options
+			checkProfileChange();
+			// Perform clean up actions for the panel we are leaving
+			onLeavingPanel(oldCard);
+			// Prepare actions for the panel we are about to enter
+			onEnteringPanel(((MultiPanelEvent)ev).selectedIndex);
+			oldCard=((MultiPanelEvent)ev).selectedIndex;
+		}
+		// If we are in Listview update status
+		if (this.getSelectedItem()==0 &amp;&amp; statBar!=null) statBar.updateDisplay();
+//eve.sys.Vm.debug(&quot;              &quot;.substring(0,--level*2)+&quot;END &quot;+&quot;[&quot;+ev.target.getClass().getName()+&quot;] &quot;+event2Name(ev.type));
+		super.onEvent(ev);
+	}
+
+	/**
+	 * Code to execute when leaving a panel (oldCard is the panel number)
+	 *
+	 */
+	private void onLeavingPanel(int panelNo) {//Vm.debug(&quot;Leaving &quot;+panelNo);
+		if (panelNo==0) { // Leaving the list view
+			// Get the cache for the current line (ch)
+			// Get the details for the current line (chD)
+			// If it is Addi get details of main Wpt (chMain)
+			chMain=null;
+			cacheDirty=false;
+			if (tbP.getSelectedCache()&gt;=Global.mainTab.tbP.tModel.numRows || tbP.getSelectedCache()&lt;0) {
+				ch=null; chD=null; 
+				lastselected=&quot;&quot;;
+			} else {
+				ch = (CacheHolder)cacheDB.get(tbP.getSelectedCache());
+				lastselected=ch.wayPoint;  // Used in Parser.Skeleton
+				try {
+					chD = ch.getCacheDetails(true);
+					//chD=new CacheHolderDetail(ch);
+					//chD.readCache(profile.dataDir);//Vm.debug(&quot;MainTab:readCache &quot;+chD.wayPoint+&quot;/S:&quot;+chD.Solver);
+				} catch(Exception e){
+					//Vm.debug(&quot;Error loading: &quot;+ch.wayPoint);
+				}
+			}
+		}
+		else if (panelNo==1) { // Leaving the Details Panel
+			// Update chD with Details
+			if(detP.isDirty()) {
+				cacheDirty=true;
+				boolean needTableUpdate = detP.needsTableUpdate();
+				detP.saveDirtyWaypoint();
+				if (needTableUpdate) {
+					tbP.updateRows();// This sorts the waypoint (if it is new) into the right position
+					tbP.selectRow(profile.getCacheIndex(detP.thisCache.wayPoint));
+				}
+				//was tbP.refreshTable();
+				tbP.tControl.update(true); // Update and repaint
+				if (statBar!=null) statBar.updateDisplay();
+			}
+		}
+		else if (panelNo==5) { // Leaving the Solver Panel
+			// Update chD or chMain with Solver
+			// If chMain is set (i.e. if it is an addi Wpt) save it immediately
+			if (chD!=null &amp;&amp; solverP.isDirty()) {
+				cacheDirty=true;
+				if (chMain==null) {
+					chD.solver=solverP.getInstructions();
+				} else {
+					chMain.solver=solverP.getInstructions();
+					chMain.saveCacheDetails(Global.getProfile().dataDir);//Vm.debug(&quot;mainT:SaveCache &quot;+chMain.wayPoint+&quot;/S:&quot;+chMain.Solver);
+					chMain=null;
+				}
+			}
+		}
+	}
+
+	/**
+	 * Code to execute when entering a panel (getSelectedItem() is the panel number)
+	 *
+	 */
+	private void onEnteringPanel(int panelNo) {//Vm.debug(&quot;Entering &quot;+panelNo);
+		switch (panelNo) {// Switch by panel number
+		case 0:
+			// If Solver or Details has changed, save Cache
+			updatePendingChanges();
+			if (detP.hasBlackStatusChanged()) {
+				// Restore the filter status (this automatically sets the status for blacklisted caches)
+				Global.getProfile().restoreFilter(true);
+				tbP.refreshTable();
+			}
+			break;
+		case 1:  // DetailsPanel
+			if (chD==null) { // Empty DB - show a dummy detail
+				newWaypoint(ch=new CacheHolder()); 
+			}
+			//TODO MyLocale.setSIPButton();
+			if (!detPhasData)  {
+				detP.setDetails(ch);
+				detPhasData=true;
+			}
+			break;
+		case 2: // Description Panel
+				//TODOMyLocale.setSIPOff();
+				if (!descPhasData) {
+					descP.setText(chD);
+					descPhasData=true;
+				}
+			break;
+		case 3: // Picture Panel
+			if (chD!=null &amp;&amp; !imagePhasData) {
+				//TODOMyLocale.setSIPOff();
+				if (chD.isAddiWpt()) { 
+					imageP.setImages(chD.mainCache.getCacheDetails(true));
+				} else {
+					imageP.setImages(chD);
+				}
+				imagePhasData=true;
+			}
+			break;
+		case 4:  // Log Hint Panel
+			if (chD!=null &amp;&amp; !hintLPhasData) {
+				//TODO MyLocale.setSIPOff();
+				if (chD.isAddiWpt()) { 
+					hintLP.setText(chD.mainCache.getCacheDetails(true));
+				} else {
+					hintLP.setText(chD);
+				}
+				hintLPhasData=true;
+			}
+			break;
+		case 5:  // Solver Panel
+			//TODO MyLocale.setSIPButton();
+			if (chD!=null &amp;&amp; !solverPhasData) {
+				if (chD.isAddiWpt()) { 
+					chMain=chD.mainCache.getCacheDetails(true);//new CacheHolderDetail(chD.mainCache);
+/*					try {
+						chMain.readCache(profile.dataDir); //Vm.debug(&quot;mainT:readCache &quot;+chD.wayPoint+&quot;=&gt;Main=&gt;&quot;+chMain.wayPoint+&quot;/S:&quot;+chMain.Solver);
+					} catch(Exception e){pref.log(&quot;Error reading cache .xml&quot;,e);}
+*/					solverP.setInstructions(chMain.solver);
+				} else {
+					//Vm.debug(&quot;mainT: Waypoint:&quot;+chD.wayPoint);
+					solverP.setInstructions(chD.solver);
+				}
+				solverPhasData=true;
+			}
+			break;
+		case 6:  // CalcPanel
+			if (chD!=null) {
+				//TODO MyLocale.setSIPOff();
+				calcP.setFields(chD);
+			}
+			break;
+		case 7: // GotoPanel
+			//TODO MyLocale.setSIPOff();
+			break;
+		case 8:  // Cache Radar Panel
+			//TODO MyLocale.setSIPOff();
+			if (!radarPhasData) {
+				radarP.drawCachesAndCircle();
+				radarPhasData=true;
+			}
+			break;
+		}
+	}
+	
+	/** Update the distances of all caches to the centre and display a message 
+	 */
+	public void updateBearDist(){// Called from DetailsPanel, GotoPanel and myTableControl
+		MessageBox info = new MessageBox(MyLocale.getMsg(327,&quot;Information&quot;), MyLocale.getMsg(1024,&quot;Entfernungen in der Listenansicht \n werden neu berechnet...&quot;).replace('~','\n'), 0);
+		info.exec();
+		profile.updateBearingDistance();
+		//tbP.refreshTable();
+		info.close(0);
+		//tbP.tControl.repaint();
+	}
+
+	public void gotoPoint(CWPoint where) { // Called from CalcPanel, DetailsPanel
+		gotoP.setDestinationAndSwitch(where); 
+	}
+
+	public void openDescriptionPanel(CacheHolder chi) {
+		//TODO MyLocale.setSIPOff();
+		// To change cache we need to be in panel 0
+		onLeavingPanel(oldCard);
+		onEnteringPanel(0); oldCard=0;
+		int row = profile.getCacheIndex(chi.wayPoint);
+		tbP.selectRow(row);
+		//tbP.tc.scrollToVisible(row, 0);
+		//tbP.selectRow(row);
+		select(descP);
+		//descP.setText(chi);
+	}
+
+
+	/**
+	 * this is called from goto / MovingMap / CalcPanel / DetailsPanel and so on to 
+	 * offer the user the possibility of entering an new waypoint
+	 * at a given position. ch must already been preset with a valid
+	 * CacheHolder object
+	 * 
+	 * @param ch
+	 */
+	public void newWaypoint(CacheHolder ch){
+		//When creating a new waypoint, simulate a change to the list view
+		//if we are currently NOT in the list view
+		if (oldCard != 0) {
+			onLeavingPanel(oldCard);
+		}
+		updatePendingChanges(); // was: onEnteringPanel(0); oldCard=0;
+		mainCache=lastselected;
+		int selectedIndex = profile.getCacheIndex( lastselected );
+		if (selectedIndex &gt;= 0) {
+			CacheHolder selectedCache = (CacheHolder) profile.cacheDB.get( selectedIndex );
+			if ( selectedCache.isAddiWpt() ) {
+				mainCache = selectedCache.mainCache.wayPoint;
+			}			
+		}
+		Global.getProfile().hasUnsavedChanges=true;
+		detP.setNeedsTableUpdate(true);
+		if (CacheType.isAddiWpt(ch.type) &amp;&amp; mainCache!=null &amp;&amp; mainCache.length()&gt;2) {
+			ch.wayPoint = profile.getNewAddiWayPointName(mainCache);
+			profile.setAddiRef(ch);
+		} else { 
+			ch.wayPoint = profile.getNewWayPointName();
+			ch.type=0;
+			lastselected=ch.wayPoint;
+		}
+		ch.cacheSize = &quot;None&quot;;
+		chD = ch.getCacheDetails(true);
+		this.ch = ch;
+		cacheDB.add(ch);
+		tbP.tModel.numRows++;
+		detP.setDetails(ch);
+		oldCard=1;
+		if (this.cardPanel.selectedItem !=1) select(detP);
+		solverP.setInstructions(&quot;&quot;);
+		//tbP.refreshTable(); // moved this instruction to onLeavingPanel
+
+	}
+
+	
+	/**
+	 * sets posCircle Lat/Lon to centerTo
+	 * 
+	 * @param centerTo true: centers centerTo on the screen and disconnects MovingMap from GPS if Gps-pos is not on the loaded map
+	 * @param forceCenter
+	 */
+	public void switchToMovingMap(CWPoint centerTo, boolean forceCenter) {
+		try {
+			if (!centerTo.isValid()) {
+				(new MessageBox(&quot;Error&quot;, &quot;No valid coordinates&quot;, MessageBox.OKB)).execute();
+				return;
+			}
+			if (mm == null) {
+				mm = new MovingMap(nav, profile.cacheDB);
+				nav.setMovingMap(mm);
+			} 
+			if (forceCenter) mm.setGpsStatus(MovingMap.noGPS); // disconnect movingMap from GPS TODO only if GPS-pos is not on the screen
+			mm.updatePosition(centerTo);
+			mm.myExec();
+			if (forceCenter) {
+				try {
+					int i = 0;
+					while (MapImage.screenDim.width == 0 &amp;&amp; i &lt; 10*60) { i++; eve.sys.mThread.sleep(100);} // wait until the window size of the moving map is known note: eve.sys.sleep() will pause the whole vm - no other thread will run
+					if (i &gt;= 10*60) {(new MessageBox(&quot;Error&quot;, &quot;MovingMap cannot be displayed - this is most likely a bug - plaese report it on www.geoclub.de&quot;, MessageBox.OKB)).execute(); return;}
+					mm.setCenterOfScreen(centerTo, false); // this can only be executed if mm knows its window size that's why myExec must be executed before
+					mm.updatePosition(centerTo);
+					/*			if(!mm.posCircle.isOnScreen()) { // TODO this doesn't work because lat lon is set to the wished pos and not to gps anymore
+				mm.setGpsStatus(MovingMap.noGPS); // disconnect movingMap from GPS if GPS-pos is not on the screen
+				mm.setResModus(MovingMap.HIGHEST_RESOLUTION);
+				mm.updatePosition(centerTo.latDec, centerTo.lonDec);
+				mm.setCenterOfScreen(centerTo, true); 
+			}
+					 */			//TODO what to do, if there is a map at centerTo, but it is not loaded because of mapSwitchMode == dest &amp; cuurpos und daf&#252;r gibt es keine Karte 
+				}catch (InterruptedException e) {//TODO switch waiting indication off
+					Global.getPref().log(&quot;Error starting mavoing map (1): &quot; + e.getMessage(), e, true);
+					(new MessageBox(&quot;Error&quot;, &quot;This must not happen please report to pfeffer how to produce this error message&quot;, MessageBox.OKB)).execute(); } 
+			}
+		} catch (Exception e) { 
+			Global.getPref().log(&quot;Error starting moving map (2): &quot; + e.getMessage(), e, true);
+			(new MessageBox(&quot;Error&quot;, &quot;Error starting moving map: &quot; + e.getMessage(), MessageBox.OKB)).execute(); }
+	}
+
+	public void updatePendingChanges() {
+		if (cacheDirty) {
+			if (chD!=null)
+				chD.saveCacheDetails(Global.getProfile().dataDir);
+			cacheDirty=false;
+		}
+	}
+	
+	/** Save the index file
+	 * 
+	 * @param askForConfirmation If true, the save can be cancelled by user
+	 */
+	public void saveUnsavedChanges(boolean askForConfirmation) {
+		if (oldCard!=0) {
+			onLeavingPanel(oldCard);
+			onEnteringPanel(0);
+			oldCard=0;
+		}
+		updatePendingChanges();
+		if (profile.hasUnsavedChanges) profile.saveIndex(true);
+		this.tbP.saveColWidth(pref);
+		Global.getPref().savePreferences();
+	}
+	
+	private void checkProfileChange() {
+		// A panel is selected. Could be the same panel twice
+		mnuMain.allowProfileChange(false);	  
+		if(this.getSelectedItem() == 0){// List view selected
+			mnuMain.allowProfileChange(true);	  
+			//TODO MyLocale.setSIPOff();
+		}
+	}
+	private String event2Name(int type) {//TODO Comment out
+		switch(type) {
+			case ControlEvent.PRESSED: return &quot;ControlEvent.PRESSED&quot;; 
+			case ControlEvent.FOCUS_IN: return &quot;ControlEvent.FOCUS_IN&quot;;
+			case ControlEvent.FOCUS_OUT: return &quot;ControlEvent.FOCUS_OUT&quot;;
+			case ControlEvent.TIMER: return &quot;ControlEvent.TIMER&quot;; 
+			case ControlEvent.CANCELLED: return &quot;ControlEvent.CANCELLED&quot;; 
+			case ControlEvent.EXITED: return &quot;ControlEvent.EXITED&quot;; 
+			case ControlEvent.MENU_SHOWN: return &quot;ControlEvent.MENU_SHOWN&quot;;
+			case eve.ui.formatted.TextDisplay.LINES_SPLIT: return &quot;ControlEvent.LINES_SPLIT&quot;; 
+			case ControlEvent.STRUCTURE_CHANGED: return &quot;ControlEvent.STRUCTURE_CHANGED&quot;;
+			case ControlEvent.OPERATION_CANCELLED: return &quot;ControlEvent.OPERATION_CANCELLED&quot;;
+			case ControlEvent.POPUP_CLOSED: return &quot;ControlEvent.POPUP_CLOSED&quot;;
+			case DataChangeEvent.DATA_CHANGED: return &quot;DataChangeEvent.DATA_CHANGED&quot;; 
+			case MultiPanelEvent.SELECTED: return &quot;MultiPanelEvent.SELECTED&quot;; 
+			case TableEvent.CELL_CLICKED: return &quot;TableEvent.CELL_CLICKED&quot;; 
+			case TableEvent.SELECTION_CHANGED: return &quot;TableEvent.SELECTION_CHANGED&quot;;
+			case TableEvent.CELL_DOUBLE_CLICKED:  return &quot;TableEvent.CELL_DOUBLE_CLICKED&quot;;
+			case eve.ui.data.EditorEvent.CLOSED: return &quot;EditorEvent.CLOSED&quot;; 
+			case eve.ui.data.EditorEvent.FROM_CONTROLS: return &quot;EditorEvent.FROM_CONTROLS&quot;;
+			case eve.ui.data.EditorEvent.OBJECT_SET: return &quot;EditorEvent.OBJECT_SET&quot;; 
+			case eve.ui.data.EditorEvent.SHOWN: return &quot;EditorEvent.SHOWN&quot;; 
+			case eve.ui.data.EditorEvent.TO_CONTROLS: return &quot;EditorEvent.TO_CONTROLS&quot;;
+		}
+		return Integer.toString(type);
+	}
+
+}
+// 
+

Added: experiments/EVE/src/cachewolf/MyEditor.java
===================================================================
--- experiments/EVE/src/cachewolf/MyEditor.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/MyEditor.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,65 @@
+package cachewolf;
+import eve.fx.Color;
+import eve.fx.Insets;
+import eve.ui.*;
+import eve.ui.data.Editor;
+
+/**
+ * Descendant from ewe.ui.Editor to allow more flexibility when needed
+ * @author engywuck
+ */
+public class MyEditor extends Editor {
+
+	// Constraint used to align buttons of MyEditor
+	public int buttonConstraints = CellConstants.CENTER;
+
+	/** 
+	 * Mainly overwritten of ewe.ui.Editor, except for the placement constraints for
+	 * the buttons which allow for variable buttonConstraints.
+	 */
+	protected void checkButtons() {
+		if (buttons != null) {
+			if (buttons.size() != 0) {
+				if (Gui.isSmartPhone &amp;&amp; getSoftKeyBarFor(null) == null) {
+					buttonsToSoftKeyBar(buttons, (no != null &amp;&amp; cancel != null) ? &quot;No/Cancel&quot;
+							: &quot;Actions&quot;, BUTTONS_TO_SOFT_KEY_FIRST_BUTTON_SEPARATE);
+				} else {
+					CellPanel p = new CellPanel();
+					p.defaultTags.set(INSETS, new Insets(0, 1, 0, 1));
+					p.modify(AlwaysEnabled | NotAnEditor, 0); // Just in case a dialog pops up
+																// with global disabling.
+					for (int i = 0; i &lt; buttons.size(); i++) {
+						p.addNext((Control) buttons.get(i));
+						if ((buttonsPerRow &gt; 0) &amp;&amp; (((i + 1) % buttonsPerRow) == 0))
+							p.endRow();
+					}
+					p.endRow();
+					CellPanel p2 = buttonsPanel = new CellPanel();
+					p.defaultTags.set(INSETS, new Insets(2, 2, 2, 2));
+					//
+					// Here is difference from ewe.ui.Editor: CENTER -&gt; buttonConstraints
+					//
+					p2.addLast(p).setControl(buttonConstraints);// p2.borderStyle =
+																// Graphics.EDGE_SUNKEN;
+				}
+			}
+		}
+		if (!hasExitButton()) {
+			if (Gui.isSmartPhone) {
+				if (getSoftKeyBarFor(null) == null) {
+					SoftKeyBar sk = makeSoftKeys();
+					sk.setKey(1, &quot;Close|&quot; + EXIT_IDCANCEL, close, null);
+				}
+			} else {
+				titleOK = new Button(close);// getButton(&quot;OK&quot;);
+				titleOK.backGround = Color.DarkBlue;
+				((Button) titleOK).insideColor = getBackground();
+			}
+		}
+		if (titleOK != null)
+			titleOK.modify(AlwaysEnabled | NotAnEditor, 0);
+		if (titleCancel != null)
+			titleCancel.modify(AlwaysEnabled | NotAnEditor, 0);
+	}
+
+}

Added: experiments/EVE/src/cachewolf/MyLocale.java
===================================================================
--- experiments/EVE/src/cachewolf/MyLocale.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/MyLocale.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,286 @@
+package cachewolf;
+/*
+ *  CacheWolf - Local settings class
+ *
+ */
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import eve.io.File;
+import java.io.FileReader;
+import java.io.FileWriter;
+import eve.sys.*;
+import java.lang.Double;
+import java.lang.Long;
+
+import eve.ui.Gui;
+import eve.fx.Dimension;
+import eve.ui.MessageBox;
+/**
+ *  This class handles internationalisation and some other local stuff like
+ *  decimal separator, screen dimensions etc.
+ *
+ *  The methods are static, the class does not need initialisation.
+ *
+ *  @author salzkammergut
+ *  Changes:
+ *    20061122 Changed name to MyLocale. Added screen width &amp; height, formatLong, SIP functions
+ *    20061124 Added formatDouble
+ */
+public class MyLocale {
+	/** This language used if the system language is not supported by CacheWolf */
+	final static String standardLanguage = &quot;EN&quot;;
+
+	private static Locale l=null;
+	private static LocalResource lr=null;
+	private static Dimension s = Gui.getScreenSize();
+	private static String digSeparator=null;
+	/** Read a non-standard language from the file language. If it is empty,
+	 * the default language is used.
+	 */
+	public static String language=getLanguage();
+
+	public static String initErrors;
+
+	private static String getLocaleFileName(String languageshort) {
+		return File.makePath(File.getProgramDirectory(), &quot;languages/&quot; + languageshort.toUpperCase() + &quot;.cfg&quot;);
+	}
+
+	/**
+	 * This is needed because of 2 Bugs (not supporting French and inconsistant LocaleID in the ewe-VM v1.49
+	 * For details see comments in method body
+	 * [maybe one is inherited from windows: not supporting french]
+	 * @param language_ 2 digits of language code as specified in ISO
+	 */
+	private static void setLocale(String language_) {
+		int tmp = Locale.createID(language_, &quot;&quot;, 0); // in ewe-vm v1.49 this call is enough to set the locale correctly and this works even with not supported languages like FR (french), e.g. it works even if tmp == -1, call new Locale() instead of new Locale(tmp) then.
+		tmp = (tmp &gt;= 1024 ? tmp-1024 : tmp); // ewe-vm v1.49 some times returns the correct value + 1024
+		// Vm.debug(&quot;spec-lang: &quot; + tmp);
+		if (tmp &gt; -1)	l = new Locale(tmp);
+		else 			l = Locale.createFor(&quot;EN&quot;, &quot;&quot;, 0 /*Locale.FORCE_CREATION*/); // forcing the requiered language doesn't work, because Locale.numberformat and so on cannot determine the requested format then. BTW: if French is system language new Locale() works even in ewe-vm v1.49
+		resourcelanguage = language_;
+	}
+
+	/**
+	 * This is used to determine the language file name - it is necessary because
+	 * ewe-vm v1.49 doesn't support French
+	 */
+	static String resourcelanguage; //TODO Is this necessary in EVE ?
+	static boolean inInit = false;
+
+
+	private static void init() {
+		if (inInit) {
+			throw new IllegalThreadStateException(&quot;init may not be run twice&quot;); // this can happen, if ewe is loading another class in background, which causes a call to e.g. MyLocale.getDigSeperator (most likely in a static statement). Ewe-Vm v1.49 seems to be loading static classes ahead, causing the danger of this problem.
+		}
+		inInit = true;
+		initErrors = &quot;&quot;;
+		// the following logic priority: 1. try to use specified language (if specified), 2. try to use system language, 3. try to use english, 4. use hard coded messages
+		if ( ( language.length()!=0 ) &amp;&amp; ( !language.equalsIgnoreCase(&quot;auto&quot;) ) ) { // Was a language explicitly specified?
+			setLocale(language);
+			if (! (new File(getLocaleFileName(resourcelanguage)).exists()) ) {
+				l = null; // language file not found
+				initErrors += &quot;Language &quot; + language + &quot; not found - using system language\n&quot;;// don't copy this messagebox into a language file, because it is only used if no languages file can be accessed
+			}
+		}
+		if ( l == null ) { // no language specified OR specified language not available -&gt; use system default
+			setLocale(Vm.getLocale().getString(Locale.LANGUAGE_SHORT, 0, 0));
+			// test if a localisation file for the system language exists
+			if (!(new File(getLocaleFileName(resourcelanguage)).exists())) {
+				setLocale(standardLanguage);
+				initErrors += &quot;Your system language is not supported by cachewolf - using English\n You can choose a different language in the preferences\n&quot;;
+				/*       //uncomment this code to print a list of all supported languge (Locales), remark: this differs from vm to vm _and_ from OS to OS
+  					 Vm.debug(&quot;gew&#228;hlte Sprache: &quot; + resourcelanguage, 0, 0);
+					 int [] all = Locale.getAllIDs(0);
+					 Locale ltmp = new Locale();
+					 for (int i = 0; i&lt;all.length; i++){
+						 ltmp.set(all[i]);
+						 String lg = ltmp.getString(Locale.LANGUAGE_SHORT,0,0);
+						 Vm.debug(i + &quot;sprache: &quot; + lg + &quot; (&quot; + ltmp.getString(Locale.LANGUAGE, 0, 0) + &quot;, &quot; + ltmp.getString(Locale.LANGUAGE_ENGLISH, 0, 0) + &quot;) land: &quot; + ltmp.getString(Locale.COUNTRY, 0, 0));
+					 }
+				 */
+			}
+		}
+		lr = null;
+		if (new File(getLocaleFileName(resourcelanguage)).exists() ) {
+			eve.io.TreeConfigFile tcf = eve.io.TreeConfigFile.getConfigFile(getLocaleFileName(resourcelanguage));
+			if (tcf != null) {
+				lr = tcf.getLocalResourceObject(new Locale() {
+					public String getString(int what,int forValue,int options) {
+						if (what == LANGUAGE_SHORT) return resourcelanguage; // this is necessary because French cannot be set in ewe-vm v1.49
+						else return super.getString(what, forValue, options);
+					}
+				}, &quot;cachewolf.Languages&quot;);
+			}
+		}
+		if (lr == null) {
+		//	Vm.debug(&quot;lr==null 1&quot;);
+			initErrors += &quot;Language file &quot; + getLocaleFileName(resourcelanguage) + &quot; couldn't be loaded - using hard coded messages&quot;;
+		//	Vm.debug(&quot;lr==null 2&quot;);
+			lr = new LocalResource(){
+				public Object get(int id,Object data){return data;}
+				public Object get(String id,Object data){return data;}
+			};
+
+		}
+		double testA = Convert.toDouble(&quot;1,50&quot;) + Convert.toDouble(&quot;3,00&quot;);
+		if(testA == 4.5) digSeparator = &quot;,&quot;; else digSeparator = &quot;.&quot;;
+		inInit = false;
+	}
+
+	/**
+	 * Return a localised string
+	 *
+     * The localised strings are stored in the configuration file (relative to
+     *  executable:&lt;br&gt;
+     *  	_config/cachewolf.Languages.cfg
+     * If the configuration file does not exist or a string cannot be found in
+     * the file, the defaultValue is resurned.
+     *
+	 * @param resourceID   The unique number of the resource
+	 * @param defaultValue The default value of the string (if not found in the config file)
+	 * @return The localised string
+	 */
+	public static String getMsg(int resourceID, String defaultValue) {
+		if (l==null)
+			init();
+		if (lr!=null) {
+			String res;
+			res=(String) lr.get(resourceID,defaultValue);
+			if (res!=null)
+			   return res;
+			//Fallthrough to default value if string does not exist in file
+		}
+		return defaultValue;
+	}
+
+	/**
+	 * Get the ISO two letter (lowercase) name of the locale language
+	 *
+	 * @return ISO two letter abbreviation of the locale language
+	 */
+	public static String getLocaleLanguage() {
+		if (l==null) init();
+		return l.getString(Locale.LANGUAGE_SHORT, 0, 0);
+	}
+
+	/**
+	 * Get the three letter (uppercase) ISO country code
+	 *
+	 * @return The three letter (uppercase) ISO country code
+	 */
+	public static String getLocaleCountry() {
+		if (l==null) init();
+		return l.getString(Locale.COUNTRY_SHORT, 0, 0);
+	}
+
+	/**
+	 * Get the screen width
+	 * @return Width of screen in pixels
+	 */
+	public static int getScreenWidth() {
+		return s.width;
+	}
+
+	/**
+	 * Get the screen height
+	 * @return Height of screen in pixels
+	 */
+	public static int getScreenHeight() {
+		return s.height;
+	}
+
+	/**
+	 * Get the decimal separator for this machine
+	 * @return decimal point (&quot;.&quot; or &quot;,&quot;)
+	 */
+	public static String getDigSeparator() {
+		if (digSeparator==null) init();
+		return digSeparator;
+	}
+
+	/**
+	 * Formats a Long integer to a given format specifier
+	 * @param number A Long which contains the number to be formatted
+	 * @param fmt A string containing the format specification&lt;/br&gt;
+	 * '$' indicates that a currency symbol should be used. &lt;/br&gt;
+	 * ',' indicates that thousands groupings should be used. &lt;/br&gt;
+	 * '.' separates formatting before the decimal point and after the decimal point.&lt;/br&gt;
+	 * '0' before the decimal point indicates the number of digits before the decimal point.&lt;/br&gt;
+	 * @return The formatted number
+	 */
+	public static String formatLong(Long number, String fmt) {
+		if (l==null) init();
+		return l.format(number.longValue(),fmt,0);
+	}
+
+	/**
+	 * Formats a long to a given format specifier
+	 * @param number A long containing the number to be formatted
+	 * @param fmt A string containing the format specification&lt;/br&gt;
+	 * @return The formatted number
+	 */
+	public static String formatLong(long number, String fmt) {
+		Long L=new Long(number);
+		return formatLong(L,fmt);
+	}
+	/**
+	 * Formats a Double to a given format specifier
+	 * @param number A Double containing the number to be formatted
+	 * @param fmt A string containing the format specification&lt;/br&gt;
+	 * @return The formatted number
+	 */
+	public static String formatDouble(Double number, String fmt) {
+		if (l==null) init();
+		return l.format(number.doubleValue(),fmt,0);
+	}
+
+	/**
+	 * Formats a Double to a given format specifier
+	 * @param number A double containing the number to be formatted
+	 * @param fmt A string containing the format specification&lt;/br&gt;
+	 * @return The formatted number
+	 */
+	public static String formatDouble(double number, String fmt) {
+		Double d=new Double(number);
+		return formatDouble(d,fmt);
+	}
+
+
+	/*=================================================================
+	 * During initialisation the file &quot;language&quot; in the program directory
+	 * is read to check whether the user wishes to ovverride the default
+	 * language. This language cannot be stored in the pref.xml file, due
+	 * to an initialisation conflict (pref.xml needs MyLocale). A better
+	 * solution may be to read the override language from the command line,
+	 * but I do not know how to specify command line parameters on a PDA
+	 ==================================================================*/
+	/**
+	 * Read the language file and return the specified language (or empty
+	 * string if none specified).
+	 * @return Language (e.g. DE, EN etc.) or &quot;&quot;
+	 */
+	private static String getLanguage() {
+        Preferences pref = Global.getPref();
+        if ( pref != null ) {
+                language = pref.language;
+        } else {
+                language = &quot;&quot;;
+        }
+        if (language==null) language=&quot;&quot;;
+        return language;
+	}
+
+	/**
+	 * Write the override language
+	 * @param language The language to write
+	 */
+	public static void saveLanguage(String saveLanguage) {
+        Preferences pref = Global.getPref();
+        if ( pref != null ) {
+			pref.language = saveLanguage;
+			pref.savePreferences();
+        }
+	}
+
+}
+

Added: experiments/EVE/src/cachewolf/MyScrollBarPanel.java
===================================================================
--- experiments/EVE/src/cachewolf/MyScrollBarPanel.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/MyScrollBarPanel.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,28 @@
+package cachewolf;
+
+import eve.ui.ScrollBarPanel;
+import eve.ui.ScrollClient;
+import eve.ui.ScrollablePanel;
+
+/**
+ * Always use this class instead of eve.ui.ScrollBarPanel
+ * as it will change it's size automatically with
+ * the font size, which is entered in the preferences dialog
+ * 
+ * @author pfeffer
+ */
+
+public class MyScrollBarPanel extends ScrollBarPanel {
+	public MyScrollBarPanel(ScrollClient client,int options) {
+		super(client, options);
+		int s = java.lang.Math.round((Global.getPref().fontSize) / 11f * 15f); // standard fontsize = 1, standard bottum size = 15
+		setScrollBarSize(s, s, s);
+	}
+	public MyScrollBarPanel(ScrollClient client)
+	{
+		this(client,0);
+	}
+	public ScrollablePanel getScrollablePanel() {
+		return new MyScrollBarPanel(getScrollClient());
+	}
+}

Added: experiments/EVE/src/cachewolf/NewProfileForm.java
===================================================================
--- experiments/EVE/src/cachewolf/NewProfileForm.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/NewProfileForm.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,61 @@
+package cachewolf;
+
+import eve.io.File;
+import eve.ui.event.ControlEvent;
+import eve.ui.Form;
+import eve.fx.gui.IKeys;
+import eve.sys.Event;
+import eve.ui.MessageBox;
+import eve.ui.Button;
+import eve.ui.Input;
+
+public class NewProfileForm extends Form {
+	private Button btnCancel,btnOK;
+	private Input inpDir;
+	public String profileDir;
+	private String baseDir;
+	//private Profile profile;
+
+	public NewProfileForm (String baseDir) {
+        super();
+		//profile=prof;
+        title = MyLocale.getMsg(1111,&quot;Create new profile:&quot;);
+		addLast(inpDir=new Input(MyLocale.getMsg(1112,&quot;New profile name&quot;)),HSTRETCH,HFILL|LEFT);
+		btnCancel = new Button(MyLocale.getMsg(708,&quot;Cancel&quot;));
+		btnCancel.setHotKey(0, IKeys.ESCAPE);
+		addNext(btnCancel,HSTRETCH,LEFT);
+		btnOK = new Button(MyLocale.getMsg(1605,&quot;OK&quot;));
+		btnOK.setHotKey(0, IKeys.ENTER);
+		addLast(btnOK,HSTRETCH,HFILL|RIGHT);
+		this.setPreferredSize(240,-1);
+		this.baseDir=baseDir;
+	}
+
+	public void onEvent(Event ev){
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (ev.target == btnCancel){
+				this.close(-1);
+			}
+			if (ev.target == btnOK){
+				profileDir=inpDir.getDisplayText();
+				File f=new File(baseDir+profileDir);
+				if (f.exists()) {
+					MessageBox mb=new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(1114,&quot;Directory exists already.&quot;),MBOK);
+					mb.execute();
+					profileDir=&quot;&quot;;
+				} else {
+					if (profileDir.indexOf(&quot;/&quot;)&gt;=0 || profileDir.indexOf(&quot;\\&quot;)&gt;=0 || !f.createDir()) {
+						MessageBox mb=new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(1113,&quot;Cannot create directory&quot;),MBOK);
+						mb.execute();
+						profileDir=&quot;&quot;;
+						this.close(-1);
+					}
+					Global.getProfile().filterActive=Filter.FILTER_INACTIVE;
+					Global.getProfile().filterInverted=false;
+					this.close(0);
+				}
+			}
+		}
+		super.onEvent(ev);
+	}
+}

Added: experiments/EVE/src/cachewolf/NewProfileWizard.java
===================================================================
--- experiments/EVE/src/cachewolf/NewProfileWizard.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/NewProfileWizard.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,31 @@
+package cachewolf;
+
+import eve.ui.FormBase;
+import eve.ui.Gui;
+
+public class NewProfileWizard {
+
+	static public boolean startNewProfileWizard(eve.ui.Frame parent) {
+		if (Global.mainTab != null) Global.mainTab.saveUnsavedChanges(true);
+		Preferences pref = Global.getPref();
+		NewProfileForm f=new NewProfileForm(pref.baseDir);
+		int code=f.execute(parent, Gui.CENTER_FRAME);
+		if (code==0) {
+			Profile profile = Global.getProfile();
+			profile.clearProfile(); 
+			pref.lastProfile=profile.name=f.profileDir;
+			pref.savePreferences(); // Remember that this was the last profile used
+			profile.dataDir=pref.baseDir+f.profileDir+&quot;/&quot;;
+			
+			CoordsScreen cs = new CoordsScreen();
+			cs.setFields(new CWPoint(), CWPoint.CW);
+			if (cs.execute() == FormBase.IDOK) {
+				profile.centre.set(cs.getCoords());
+				profile.hasUnsavedChanges=true;
+			}
+			Global.mainForm.title=&quot;Cachewolf &quot;+Version.getRelease()+&quot; - &quot;+profile.name;
+		}
+		f.close(0);
+		return (code == 0);
+	}
+}

Added: experiments/EVE/src/cachewolf/Parser.java
===================================================================
--- experiments/EVE/src/cachewolf/Parser.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/Parser.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,1414 @@
+/* A parser that parses the following grammar:
+  EBNF Meta-Symbols:
+    {xx}        xx can occur any number of times incl 0
+    [xx]        xx or empty
+    |           or
+    &quot;x&quot;         x is terminal symbol
+
+command -&gt; if |
+           simplecommand
+
+simplecommand -&gt; &quot;stop&quot; | &quot;st&quot; |
+		   assign
+           stringexp |
+
+if -&gt; &quot;IF&quot; stringexpr compop stringexpr &quot;THEN&quot; simplecommand { &quot;;&quot; simplecommand } &quot;ENDIF&quot;          // Nested IF's not allowed
+
+compop -&gt; &quot;=&quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;==&quot; | &quot;&gt;=&quot; | &quot;&lt;&gt;&quot; | &quot;!=&quot; | &quot;&gt;&lt;&quot;
+
+assign -&gt; ident = [ stringexpr ]
+
+stringexp -&gt; (string | expr ) {string | tailexp }
+
+expr -&gt; [&quot;+&quot; | &quot;-&quot;] tailexp [ formatstring ]
+
+tailexp -&gt; term { (&quot;+&quot; | &quot;-&quot;) term }
+
+term -&gt; factor { (&quot;*&quot; | &quot;/&quot;) factor }
+
+factor -&gt; expfactor { &quot;^&quot; expfactor }
+
+expfactor -&gt; ident |
+          number |
+          &quot;(&quot; stringexpr &quot;)&quot; |
+          function &quot;(&quot; stringexpr { &quot;,&quot; stringexpr }&quot;)&quot;
+
+function -&gt; &quot;sin&quot; | &quot;cos&quot; | &quot;tan&quot; | &quot;asin&quot; | &quot;acos&quot; | &quot;atan&quot; | &quot;goto&quot; | &quot;project&quot; | &quot;show&quot;  | &quot;crosstotal&quot; |
+            &quot;rot13&quot; | &quot;len&quot; | &quot;mid&quot;
+
+ident -&gt; valid identifier
+number -&gt; valid number
+
+
+*/
+
+package cachewolf;
+
+import java.util.*;
+
+import cachewolf.navi.Navigate;
+import cachewolf.utils.Common;
+import cachewolf.utils.STRreplace;
+
+import com.stevesoft.eve_pat.*;
+import eve.sys.*;
+import java.lang.Double;
+
+
+
+/**
+*	The wolf language parser. New version - January 2007
+*
+*   New features:
+*   - Improved error handling
+*   - Strings and doubles can be freely mixed as appropriate. Depending on context a conversion is performed,
+*   - Variables can store strings or doubles
+*   - Global variables (starting with $) are remembered across multiple calls to parser
+*   - Global variables are initialised with &quot;&quot;, local variables result in error if used before setting value
+*   - IF statement added
+*   - Many new functions (encode,format,goto,len,mid,count, substring,ucase,lcase,val,sval,replace, reverse,project)
+*   - less typing
+*   	- Function aliases
+*   	- Function names can be flexibly abbreviated, i.e. instead of crosstotal write cr or cross or crosst ...
+*   	- show no longer needed
+*   	- Command terminator ; no longer compulsory (only between multiple commands on same line)
+*   - New functions can easily be added
+*   - Can select whether variable names are case sensitive
+*
+*   To add a new function:
+*     1) Add its name and alias and allowed number of args to array functions
+*     2) Add a new private method in the &quot;functions&quot; section
+*     3) Add call to private method in executeFunction
+*   @author salzkammergut Januay 2007
+*/
+public class Parser{
+
+	private static class fnType {
+		public String funcName; 	 // the function name in the user input
+		public String alias;         // the funcName is mapped to this alias
+		public int nargs;            // bitmap for number of args, i.e. 14 = 1 or 2 or 3 args; 5 = 0 or 2 args
+									 // i.e. 1&lt;&lt;nargs ORed together
+		fnType(String funcName, String alias, int nargs) {
+			this.funcName=funcName; this.alias=alias; this.nargs=nargs;
+		}
+		boolean nargsValid(int testNargs){
+			return ((1&lt;&lt;testNargs)&amp;this.nargs)!=0;
+		}
+	}
+    fnType[] functions=new fnType[]{ // in alphabetical order
+    	new fnType(&quot;abs&quot;,&quot;abs&quot;,2),
+    	new fnType(&quot;acos&quot;,&quot;acos&quot;,2),
+    	new fnType(&quot;asin&quot;,&quot;asin&quot;,2),
+    	new fnType(&quot;atan&quot;,&quot;atan&quot;,2),
+      	new fnType(&quot;bearing&quot;,&quot;bearing&quot;,4),
+     	new fnType(&quot;centre&quot;,&quot;center&quot;,3),
+    	new fnType(&quot;center&quot;,&quot;center&quot;,3),
+    	new fnType(&quot;cls&quot;,&quot;cls&quot;,1),
+    	new fnType(&quot;clearscreen&quot;,&quot;cls&quot;,1),
+    	new fnType(&quot;cos&quot;,&quot;cos&quot;,2),
+    	new fnType(&quot;count&quot;,&quot;count&quot;,4),
+     	new fnType(&quot;cp&quot;,&quot;cp&quot;,1),
+    	new fnType(&quot;crosstotal&quot;,&quot;ct&quot;,6),
+    	new fnType(&quot;ct&quot;,&quot;ct&quot;,2),
+     	new fnType(&quot;curpos&quot;,&quot;cp&quot;,1),
+     	new fnType(&quot;d2r&quot;,&quot;deg2rad&quot;,2),
+     	new fnType(&quot;deg&quot;,&quot;deg&quot;,1),
+     	new fnType(&quot;deg2rad&quot;,&quot;deg2rad&quot;,2),
+     	new fnType(&quot;distance&quot;,&quot;distance&quot;,4),
+     	new fnType(&quot;encode&quot;,&quot;encode&quot;,8),
+    	new fnType(&quot;format&quot;,&quot;format&quot;,6),
+    	new fnType(&quot;goto&quot;,&quot;goto&quot;,6),
+    	new fnType(&quot;ic&quot;,&quot;ic&quot;,3),
+    	new fnType(&quot;ignorecase&quot;,&quot;ic&quot;,3),
+    	new fnType(&quot;instr&quot;,&quot;instr&quot;,12),
+    	new fnType(&quot;lcase&quot;,&quot;lc&quot;,2),
+    	new fnType(&quot;length&quot;,&quot;len&quot;,2),
+    	new fnType(&quot;ln&quot;,&quot;ln&quot;,2),
+    	new fnType(&quot;log&quot;,&quot;log&quot;,2),
+    	new fnType(&quot;mid&quot;,&quot;mid&quot;,12),
+     	new fnType(&quot;pc&quot;,&quot;pz&quot;,3),
+     	new fnType(&quot;profilecenter&quot;,&quot;pz&quot;,3),
+     	new fnType(&quot;profilecentre&quot;,&quot;pz&quot;,3),
+     	new fnType(&quot;profilzentrum&quot;,&quot;pz&quot;,3),
+    	new fnType(&quot;project&quot;,&quot;project&quot;,8),
+     	new fnType(&quot;pz&quot;,&quot;pz&quot;,3),
+    	new fnType(&quot;quersumme&quot;,&quot;ct&quot;,6),
+    	new fnType(&quot;r2d&quot;,&quot;rad2deg&quot;,2),
+    	new fnType(&quot;rad&quot;,&quot;rad&quot;,1),
+    	new fnType(&quot;rad2deg&quot;,&quot;rad2deg&quot;,2),
+    	new fnType(&quot;replace&quot;,&quot;replace&quot;,8),
+    	new fnType(&quot;reverse&quot;,&quot;reverse&quot;,2),
+    	new fnType(&quot;rot13&quot;,&quot;rot13&quot;,2),
+    	new fnType(&quot;show&quot;,&quot;show&quot;,2),
+    	new fnType(&quot;sin&quot;,&quot;sin&quot;,2),
+    	new fnType(&quot;skeleton&quot;,&quot;skeleton&quot;,3),
+    	new fnType(&quot;sqrt&quot;,&quot;sqrt&quot;,2),
+    	new fnType(&quot;sval&quot;,&quot;sval&quot;,2),
+    	new fnType(&quot;tolowercase&quot;,&quot;lc&quot;,2),
+    	new fnType(&quot;touppercase&quot;,&quot;uc&quot;,2),
+    	new fnType(&quot;tan&quot;,&quot;tan&quot;,2),
+    	new fnType(&quot;ucase&quot;,&quot;uc&quot;,2),
+    	new fnType(&quot;val&quot;,&quot;val&quot;,2),
+     	new fnType(&quot;zentrum&quot;,&quot;center&quot;,3)
+     	    	};
+	private int scanpos = 0;
+	CWPoint cwPt=new CWPoint();
+	Vector calcStack=new Vector();
+	Hashtable symbolTable = new Hashtable(50);
+	TokenObj thisToken = new TokenObj();
+	Vector tokenStack;
+	Vector messageStack;
+
+	public Parser(){
+	}
+
+///////////////////////////////////////////
+//  Utility functions
+///////////////////////////////////////////
+
+	/* All errors are handled via function 'err'. Rather than creating many different Exceptions,
+	 * only the standard Exception is used. err raises this exception and thereby causes the stack to be
+	 * unwound until 'parse' eventually catches the exception and returns to SolverPanel, which displays
+	 * the messageStack containing the error message.
+	 */
+
+	/**
+     * Add an error message to the message stack and raise an Exception.
+    */
+	private void err(String str) throws Exception {
+    	messageStack.add(MyLocale.getMsg(1700,&quot;Error on line: &quot;) + thisToken.line + &quot;  &quot;+MyLocale.getMsg(1701,&quot;position: &quot;) + thisToken.position);
+    	messageStack.add(str);
+    	// move cursor to error location
+    	if (Global.mainTab.solverP.mText.setSelectionRange(0,thisToken.line-1,thisToken.position+thisToken.token.length()-1,thisToken.line-1))Global.mainTab.solverP.mText.repaintNow();
+    	throw new Exception(&quot;Error &quot;+str);
+    }
+
+    /** Shows global symbols */
+    private void showVars(boolean globals) throws Exception {
+    	Enumeration en=symbolTable.keys();
+    	while (en.hasMoreElements()) {
+    		String varName=(String)en.nextElement();
+    		if (globals == varName.startsWith(&quot;$&quot;)) {
+    			String value=(String) getVariable(varName);
+    			if (java.lang.Double.isNaN(toNumber(value)))
+    				messageStack.add(varName+&quot; = \&quot;&quot;+STRreplace.replace(value,&quot;\&quot;&quot;,&quot;\&quot;\&quot;&quot;)+&quot;\&quot;&quot;);
+    			else
+    				messageStack.add(varName+&quot; = &quot;+value);
+    		}
+    	}
+    }
+
+	/** Clears the symbol table of all non-global symbols (those not starting with $) */
+    private void clearLocalSymbols() {
+    	Enumeration en=symbolTable.keys();
+    	while (en.hasMoreElements()) {
+    		String varName=(String)en.nextElement();
+    		if (!(varName.startsWith(&quot;$&quot;)))
+    			symbolTable.remove(varName);
+    	}
+    	Double pi=new Double(java.lang.Math.PI);
+    	symbolTable.put(&quot;PI&quot;,pi);
+    	symbolTable.put(&quot;pi&quot;,pi); // To make it easier for the user we also add a lowercase version of pi
+    }
+
+	private boolean isVariable(String varName) {
+		return varName.startsWith(&quot;$&quot;) ||  // Global variables exist per default
+		       symbolTable.containsKey(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
+	}
+
+	private boolean isInteger(double d) {
+		return java.lang.Math.ceil(d)==d &amp;&amp; java.lang.Math.floor(d)==d;
+	}
+
+    private boolean isValidCoord(String coord) {
+    	cwPt.set(coord);
+    	return cwPt.isValid();
+    }
+
+	private Object getVariable(String varName) throws Exception {
+		if (varName.startsWith(&quot;$&quot;)) { // Potential coordinate
+			int idx=Global.getProfile().getCacheIndex(varName.substring(1));
+			if (idx!=-1) { // Found it!
+				CacheHolder ch=(CacheHolder)Global.getProfile().cacheDB.get(idx);
+				// Check whether coordinates are valid
+				cwPt.set(ch.pos);
+				if (cwPt.isValid() )
+					return cwPt.toString();
+				return &quot;&quot;; // Convert invalid coordinates (N 0 0.0 E 0 0.0) into empty string
+			}
+		}
+		Object result = symbolTable.get(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
+		if(result == null) {
+			// If it is a global variable, add it with a default value
+			if (varName.startsWith(&quot;$&quot;)) {
+				result=&quot;&quot;;
+				symbolTable.put(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName,&quot;&quot;);
+			} else
+				err (MyLocale.getMsg(1702,&quot;Variable not defined: &quot;)+varName);
+		}
+		return result;
+	}
+
+	private double toNumber(String str) {
+		try {
+			if (MyLocale.getDigSeparator().equals(&quot;,&quot;))
+				str = str.replace('.', ',');
+			else
+				str = str.replace(',','.');
+			return java.lang.Double.parseDouble(str);
+		} catch (NumberFormatException e) {
+			 return java.lang.Double.NaN;
+		}
+	}
+
+	private Double getNumber(String str) throws Exception {
+		double ret=toNumber(str);
+		if (java.lang.Double.isNaN(ret))
+			err(MyLocale.getMsg(1703,&quot;Not a valid number: &quot;) + str);
+		return new java.lang.Double(ret);
+	}
+
+	/** Get the top element of the calculation stack and try and convert it to a number if it is a string */
+	private double popCalcStackAsNumber(double defaultForEmptyString) throws Exception {
+		double num;
+		if (calcStack.get(calcStack.size()-1) instanceof String) {
+			if (((String)calcStack.get(calcStack.size()-1)).equals(&quot;&quot;))
+				num=defaultForEmptyString;
+			else
+				num = getNumber((String)calcStack.get(calcStack.size()-1)).doubleValue();
+		} else {
+			num = ((java.lang.Double)calcStack.get(calcStack.size()-1)).doubleValue();
+		}
+		calcStack.removeElementAt(calcStack.size()-1);
+		return num;
+	}
+
+    private String popCalcStackAsString() {
+        String s;
+        if (calcStack.get(calcStack.size()-1) instanceof Double) {
+                java.lang.Double D=((java.lang.Double)calcStack.get(calcStack.size()-1));
+                // Double.toString() formats numbers &gt; 1E7 and &lt; 1E-3 with exponential notation
+                // For large integers we therefore use Longs
+                double d=D.doubleValue();
+                // If the double is an integer and within range of longs, use Long
+                if (java.lang.Math.floor(d)==d &amp;&amp; d&lt;java.lang.Long.MAX_VALUE &amp;&amp; d&gt;java.lang.Long.MIN_VALUE) {
+                        java.lang.Long L=new java.lang.Long((long)d);
+                        s=L.toString();
+                } else { // Use the default Double format
+                        s = D.toString().replace(',','.'); // always show numbers with decimal point;
+                        if (s.endsWith(&quot;.0&quot;)) s=s.substring(0,s.length()-2);
+                }
+        } else
+                s = (String)calcStack.get(calcStack.size()-1);
+        calcStack.removeElementAt(calcStack.size()-1);
+        return s;
+    }
+
+	private void getToken() throws Exception {
+		if(scanpos &lt; tokenStack.size()){
+			thisToken = (TokenObj)tokenStack.get(scanpos);
+			//Vm.debug(thisToken.token);
+			scanpos++;
+		} else err(MyLocale.getMsg(1704,&quot;Unexpected end of source&quot;));
+	}
+
+	private TokenObj peekToken() {
+		if(scanpos &lt; tokenStack.size()){
+			return (TokenObj)tokenStack.get(scanpos);
+		}
+		return new TokenObj();
+	}
+
+	private void getNextTokenOtherThanSemi() throws Exception {
+		do {
+			getToken();
+		} while (thisToken.token.equals(&quot;;&quot;));
+	}
+
+	private void skipPastEndif(TokenObj ifToken) throws Exception {
+		while(scanpos &lt; tokenStack.size()){
+			thisToken = (TokenObj)tokenStack.get(scanpos);
+			scanpos++;
+			if (thisToken.tt==TokenObj.TT_ENDIF) {
+				getToken();
+				return;
+			}
+		}
+		thisToken=ifToken;
+		err(MyLocale.getMsg(1705,&quot;Missing ENDIF&quot;));
+	}
+	private TokenObj lookAheadToken() {
+		return (TokenObj)tokenStack.get(scanpos);
+	}
+
+	private boolean checkNextSymIs(String str) throws Exception {
+		if(thisToken.token.toUpperCase().equals(str)){
+			return true;
+		}
+		err(MyLocale.getMsg(1706,&quot;Expected &quot;) + str + &quot;  &quot;+MyLocale.getMsg(1707,&quot;Found: &quot;)+thisToken.token);
+		return false; //Dummy as err does not return
+	}
+
+	private fnType getFunctionDefinition(String str) throws Exception {
+    	fnType fnd=null;
+    	str=str.toLowerCase();
+    	for (int i=functions.length-1; i&gt;=0; i--) {
+    		// Return the function if there is an exact match
+    		if (functions[i].funcName.equals(str)) return functions[i];
+    		if (functions[i].funcName.startsWith(str)) { // Partial match?
+        		// Only one partial match allowed
+    			if (fnd!=null) err(MyLocale.getMsg(1708,&quot;Ambiguous function name: &quot;)+str);
+    			fnd=functions[i];
+    		}
+    	}
+    	if (fnd==null) err(MyLocale.getMsg(1709,&quot;Unknown function: &quot;)+str);
+    	return fnd;
+    }
+
+///////////////////////////////////////////
+//  FUNCTIONS
+///////////////////////////////////////////
+
+	/** If we are in DEGree mode, convert the argument to RADiants, if not leave it unchanged */
+	private double makeRadiant(double arg) {
+		if (Global.getPref().solverDegMode)
+			return arg*java.lang.Math.PI/180.0;
+		return arg;
+	}
+
+	/** If we are in DEGree mode, convert the argument to degrees */
+	private double makeDegree(double arg) {
+		if (Global.getPref().solverDegMode)
+			return arg/java.lang.Math.PI*180.0;
+		return arg;
+	}
+
+    /** Calculate brearing from one point to the next */
+    private double funcBearing() throws Exception {
+    	String coordB=popCalcStackAsString();
+    	String coordA=popCalcStackAsString();
+ 		if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordA);
+		if (!isValidCoord(coordB)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordB);
+	   	cwPt.set(coordA);
+	   	double angleDeg=cwPt.getBearing(new CWPoint(coordB));
+	   	// getBearing returns a result in degrees
+	   	return Global.getPref().solverDegMode ? angleDeg : angleDeg * java.lang.Math.PI/180.0;
+    }
+
+    /** Get or set the current centre */
+	private void funcCenter(int nargs) throws Exception {
+		if (nargs==0) {
+			calcStack.add(Global.getPref().curCentrePt.toString());
+		} else {
+	    	String coordA=popCalcStackAsString();
+			if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordA);
+			Global.getPref().curCentrePt.set(coordA);
+			Global.getProfile().updateBearingDistance();
+		}
+	}
+
+	/** Clear Screen */
+	private void funcCls() {
+		// OutputPanel is private, so need to cast to base class
+		Global.mainTab.solverP.clearOutput();
+	}
+
+	private int funcCountChar(String s, char c) {
+    	int count=0;
+    	for (int i=0; i&lt;s.length(); i++)
+    		if (s.charAt(i)==c) count++;
+    	return count;
+    }
+
+    /** count(string1,string2)
+     * */
+    private void funcCount()throws Exception {
+       	String s2=popCalcStackAsString();
+    	String s1=popCalcStackAsString();
+    	if (s2.length()==0) err(MyLocale.getMsg(1710,&quot;Cannot count empty string&quot;));
+    	if (s2.length()==1) {
+    		calcStack.add(new Double(funcCountChar(s1,s2.charAt(0))));
+    	} else {
+    		String res=&quot;&quot;;
+    		for(int i=0; i&lt;s2.length(); i++) {
+    			res+=s2.charAt(i)+&quot;=&quot;+funcCountChar(s1,s2.charAt(i))+&quot; &quot;;
+    		}
+    		calcStack.add(res);
+    	}
+    }
+
+    private String funcCp(){
+    	return Global.mainTab.nav.gpsPos.toString();
+    }
+
+    /**
+     *  Crosstotal: Works for both strings and numbers. For strings any non-numeric character is ignored
+     *  Warning: When the number is non-integer or &gt; 9223372036854775807, it is formatted using the E
+     *  notation, i.e. x.xxxxxxEyy. In this case the exponent yy is also included in the crosstotal
+     */
+    private double funcCrossTotal(int nargs) throws Exception {
+        int cycles=1;
+                if (nargs==2) cycles=(int)popCalcStackAsNumber(1);
+                String aString=popCalcStackAsString().replace('-','0').trim();
+                double a=0;
+                if (cycles&lt;0) cycles=1;
+        if (cycles&gt;5) cycles=5;
+        while (cycles--&gt;0) {
+                // Cross total = Quersumme berechnen
+                        a=0;
+                        for (int i=0; i&lt;aString.length(); i++) {
+                           if (aString.charAt(i)&gt;='0' &amp;&amp; aString.charAt(i)&lt;='9')
+                              a += aString.charAt(i)-'0';
+                        }
+                        aString=Convert.toString(a);
+        }
+        return a;
+    }
+
+    private void funcDeg(boolean arg) {
+    	Global.getPref().solverDegMode=arg;
+    	Global.mainTab.solverP.showSolverMode();
+    }
+
+    /** Convert degrees into Radiants */
+    private double funcDeg2Rad() throws Exception {
+    	double a=popCalcStackAsNumber(0);
+    	return a/180.0*java.lang.Math.PI;
+    }
+
+    	/** Calculate distance between 2 points */
+    private double funcDistance() throws Exception {
+    	String coordB=popCalcStackAsString();
+    	String coordA=popCalcStackAsString();
+		// Attention: isValidCoord has sideeffect of setting cwPt
+    	if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordA);
+		if (!isValidCoord(coordB)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordB);
+    	cwPt.set(coordA);
+    	return cwPt.getDistance(new CWPoint(coordB))*1000.0;
+    }
+
+    /**
+     * Encode a string by replacing all characters in a string with their corresponding characters in
+     * another string
+     * @throws Exception
+     */
+    private String funcEncode() throws Exception {
+    	String newChars=popCalcStackAsString();
+    	String oldChars=popCalcStackAsString();
+    	if (newChars.length()!=oldChars.length()) err(MyLocale.getMsg(1711,&quot;Replacement characters strings must be of equal length&quot;));
+    	String s=popCalcStackAsString();
+    	String encodedStr=&quot;&quot;;
+    	for (int i=0; i&lt;s.length(); i++) {
+    		int pos;
+    		if ((pos=oldChars.indexOf(s.charAt(i)))!=-1) {
+    			encodedStr+=newChars.charAt(pos);
+    		} else
+    			encodedStr+=s.charAt(i);
+    	}
+    	 return encodedStr;
+    }
+
+    /** Format a valid coordinate
+     *  If called with one args, format the argument on the stack to CW standard
+     *  The optional second argument is one of these strings &quot;UTM&quot;,&quot;DMS&quot;,&quot;DD&quot;,&quot;DMM&quot; or &quot;CW&quot;
+     * @param nargs 1 or 2 args
+     */
+    private String funcFormat(int nargs) throws Exception {
+    	String fmtStr=&quot;&quot;;
+    	if (nargs==2)fmtStr=popCalcStackAsString().toLowerCase();
+    	String coord=popCalcStackAsString();
+		if (!isValidCoord(coord)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coord);
+    	cwPt.set(coord);
+    	int fmt=CWPoint.CW;
+    	if (fmtStr.equals(&quot;dd&quot;)) fmt=CWPoint.DD;
+    	else if (fmtStr.equals(&quot;dmm&quot;)) fmt=CWPoint.DMM;
+    	else if (fmtStr.equals(&quot;dms&quot;)) fmt=CWPoint.DMS;
+    	else if (fmtStr.equals(&quot;utm&quot;)) fmt=CWPoint.UTM;
+    	else if (!fmtStr.equals(&quot;cw&quot;)) err(MyLocale.getMsg(1713,&quot;Invalid coordinate format. Allowed are CW/DD/DMM/DMS/UTM&quot;));
+    	return cwPt.toString(fmt);
+    }
+
+    /** Implements a goto command goto(coordinate,optionalWaypointName).
+     */
+    private void funcGoto(int nargs) throws Exception {
+    	Navigate nav=Global.mainTab.nav;
+		String waypointName=null;
+        if (nargs==2) waypointName=popCalcStackAsString();
+		String coord=popCalcStackAsString();
+		if (!isValidCoord(coord)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coord);
+		// Don't want to switch to goto panel, just set the values
+		nav.setDestination(coord);
+		if (nargs==2) { // Now set the value of the addi waypoint (it must exist already)
+    		int i=Global.getProfile().getCacheIndex(waypointName);
+    		if (i&lt;0) err(MyLocale.getMsg(1714,&quot;Goto: Waypoint does not exist: &quot;)+waypointName);
+    		cwPt.set(coord);
+    		CacheHolder ch=((CacheHolder)Global.getProfile().cacheDB.get(i));
+    		ch.latLon=cwPt.toString(CWPoint.CW);
+    		ch.pos.set(cwPt);
+    		ch.calcDistance(Global.getPref().curCentrePt); // Update distance/bearing
+    	    Global.getProfile().selectionChanged=true; // Tell moving map to updated displayed waypoints
+    	}
+    }
+
+    /** Display or change the case sensitivity of variable names */
+    private void funcIgnoreVariableCase(int nargs) throws Exception {
+    	if (nargs==0)
+    		calcStack.add(&quot;&quot;+Global.getPref().solverIgnoreCase);
+    	else {
+    		Global.getPref().solverIgnoreCase=(popCalcStackAsNumber(0)!=0)?true:false;
+    	}
+    }
+
+    /** VB instr function
+     * instr([start],string1,string2)
+     * */
+    private int funcInstr(int nargs) throws Exception {
+    	String s2=popCalcStackAsString();
+    	String s1=popCalcStackAsString();
+    	int start=1;
+    	if (nargs==3) start=(int) popCalcStackAsNumber(1);
+    	if (start&gt;s1.length()) err(MyLocale.getMsg(1715,&quot;instr: Start position not in string&quot;));
+    	if(s2.equals(&quot;&quot;)) {
+    		if (s1.equals(&quot;&quot;))
+    			return 0;
+    		return 1;
+    	}
+    	return s1.indexOf(s2,start-1)+1;
+    }
+
+    private double funcLn() throws Exception {
+    	double a=popCalcStackAsNumber(0);
+    	if (a&lt;0) err(MyLocale.getMsg(99999,&quot;Cannot calculate log of a negative number&quot;)); //TODO
+    	return java.lang.Math.log(a);
+    }
+
+    private double funcLog() throws Exception {
+    	double a=popCalcStackAsNumber(0);
+    	if (a&lt;0) err(MyLocale.getMsg(99999,&quot;Cannot calculate log of a negative number&quot;)); //TODO
+    	return java.lang.Math.log(a)/java.lang.Math.log(10.0);
+    }
+
+    /** MID function as in Basic */
+    private String funcMid(int nargs) throws Exception {
+    	if (nargs==2) {
+        	double start=popCalcStackAsNumber(0);
+    		String s=popCalcStackAsString();
+    		if (!isInteger(start)) err(MyLocale.getMsg(1716,&quot;mid: Integer argument expected&quot;));
+    		if (start&lt;1 || start&gt;s.length()) err(MyLocale.getMsg(1717,&quot;mid: Argument out of range&quot;));
+    		return s.substring((int)start-1);
+    	}
+    	double len=popCalcStackAsNumber(0);
+    	double start=popCalcStackAsNumber(0);
+		String s=popCalcStackAsString();
+		if (!isInteger(start) || !isInteger(len)) err(MyLocale.getMsg(1716,&quot;mid: Integer argument expected&quot;));
+		int end=(int)(start+len-1);
+		if (start&gt;s.length() || start&lt;1 || end&gt;s.length()) err(MyLocale.getMsg(1717,&quot;mid: Argument out of range&quot;));
+		return s.substring((int)start-1,end);
+    }
+
+	/** Get or set the profile centre */
+	private void funcPz(int nargs) throws Exception {
+		if (nargs==0) {
+			calcStack.add(Global.getProfile().centre.toString());
+		} else {
+	    	String coordA=popCalcStackAsString();
+			if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordA);
+			Global.getProfile().centre.set(coordA);
+		}
+	}
+
+    /** Project a waypoint at some angle and some distance */
+    private String funcProject() throws Exception {
+    	double distance=popCalcStackAsNumber(0);
+    	if (distance&lt;0) err(MyLocale.getMsg(1718,&quot;Cannot project a negative distance&quot;));
+    	double degrees=popCalcStackAsNumber(0);
+    	// If we are not in degree mode, arg is in radiants ==&gt; convert it
+    	if (!Global.getPref().solverDegMode) degrees=degrees * 180.0 / java.lang.Math.PI;
+    	if (degrees&lt;0 || degrees&gt;360)
+    		if (Global.getPref().solverDegMode)
+    			err(MyLocale.getMsg(1719,&quot;Projection degrees must be in interval [0;360]&quot;));
+    		else
+    			err(MyLocale.getMsg(1739,&quot;Projection degrees must be in interval [0;2*PI]&quot;));
+    	String coord=popCalcStackAsString();
+		if (!isValidCoord(coord)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coord);
+    	cwPt.set(coord);
+    	return cwPt.project(degrees,distance/1000.0).toString();
+    }
+
+    /** Convert Radiants into degrees */
+    private double funcRad2Deg() throws Exception {
+    	double a=popCalcStackAsNumber(0);
+    	return a*180.0/java.lang.Math.PI;
+    }
+
+    /** Replace all occurrences of a string with another string */
+    private String funcReplace() throws Exception {
+    	String replaceWith=popCalcStackAsString();
+    	String whatToReplace=popCalcStackAsString();
+    	String s=popCalcStackAsString();
+        if (whatToReplace.equals(&quot;&quot;)) return s;
+        return STRreplace.replace(s,whatToReplace,replaceWith);
+    }
+
+    /** Reverse a string */
+    private String funcReverse(String s) {
+    	String res=&quot;&quot;;
+    	for (int i=s.length()-1; i&gt;=0; i--) res+=s.charAt(i);
+    	return res;
+    }
+
+    /** Create a skeleton for multis. This function can be called in three ways:&lt;br&gt;
+     *  &lt;pre&gt;sk()                Create skeleton for current cache (must have addi wpts)
+     *  sk(number)          Create skeleton for number variables
+     */
+    private void funcSkeleton(int nargs) throws Exception {
+    	String waypointName=Global.mainTab.lastselected;
+    	int ci=Global.getProfile().getCacheIndex(waypointName);
+    	if (ci&lt;0) return;
+    	// If it is an addi, find its main cache
+    	if (((CacheHolder) Global.getProfile().cacheDB.get(ci)).isAddiWpt()) {
+    		waypointName=((CacheHolder) Global.getProfile().cacheDB.get(ci)).mainCache.wayPoint;
+    	}
+   		int nStages=-1;
+    	if (nargs==1) {
+    		nStages=(int)popCalcStackAsNumber(-1.0);
+    	}
+    	// Remove the sk command from the instructions
+    	Regex rex=new Regex(&quot;sk\\(.*?\\)&quot;,&quot;&quot;);
+    	Global.mainTab.solverP.mText.setText(rex.replaceFirst(Global.mainTab.solverP.mText.getText()));
+		StringBuffer op=new StringBuffer(1000);
+    	// Check for sk(number)
+    	if (nStages&gt;0 &amp;&amp; nStages&lt;30) { // e.g. sk(3)
+			/*IF $01xxxx=&quot;&quot; THEN
+			   $01xxxx=&quot;&quot;
+			   &quot;Station 1 = &quot; $01xxxx
+			   goto($01xxxx); STOP
+			ENDIF*/
+			boolean didCreateWp=false;
+    		for (int i=0; i&lt;nStages; i++) {
+				String stage=MyLocale.formatLong(i,&quot;00&quot;);
+				String stageWpt=&quot;$&quot;+stage+waypointName.substring(2);
+				String stageName = &quot;Stage &quot;+(i+1);
+				int type = 51;
+				if (i == nStages - 1) {
+					stageName = &quot;Final&quot;;
+					type = 53;
+				}
+				didCreateWp|=createWptIfNeeded(stage+waypointName.substring(2), stageName, type);
+				op.append(&quot;IF &quot;+stageWpt+&quot;=\&quot;\&quot; THEN\n&quot;);
+				op.append(&quot;  &quot;+stageWpt+&quot; = \&quot;\&quot;\n&quot;);
+				op.append(&quot;  \&quot;&quot;+stageName+&quot; = \&quot; &quot;+stageWpt+&quot;\n&quot;);
+				op.append(&quot;  goto(&quot;+stageWpt+&quot;); STOP\n&quot;);
+				op.append(&quot;ENDIF\n&quot;);
+			}
+			Global.mainTab.solverP.mText.appendText(op.toString(),true);
+			if (didCreateWp) {
+				Global.getProfile().buildReferences();
+				Global.mainTab.updatePendingChanges();
+				Global.mainTab.tbP.updateRows();
+			}
+    	} else {
+	    	int i=Global.getProfile().getCacheIndex(waypointName);
+			if (i&lt;0) err(MyLocale.getMsg(1714,&quot;Goto: Waypoint does not exist: &quot;)+waypointName);
+	   	    CacheHolder ch=(CacheHolder)Global.getProfile().cacheDB.get(i);
+			CacheHolder addiWpt;
+	   	    if (ch.hasAddiWpt()){
+	   	    	op.append(&quot;cls()\n&quot;);
+				for (int j=0; j&lt;ch.addiWpts.size();j++){
+					addiWpt = (CacheHolder)ch.addiWpts.get(j);
+					op.append(&quot;IF $&quot;);
+					op.append(addiWpt.wayPoint);
+					op.append(&quot;=\&quot;\&quot; THEN\n   $&quot;);
+					op.append(addiWpt.wayPoint);
+					op.append(&quot;=\&quot;\&quot;&quot;);
+					//op.append(addiWpt.pos.toString());
+					op.append(&quot;\n   \&quot;Punkt &quot;);
+					op.append(addiWpt.wayPoint.substring(0,2));
+					op.append(&quot; [&quot;);
+					op.append(addiWpt.cacheName);
+					op.append(&quot;] = \&quot; $&quot;);
+					op.append(addiWpt.wayPoint);
+					CacheHolderDetail chD=new CacheHolderDetail(addiWpt);
+					try {
+						chD.readCache(Global.getProfile().dataDir);
+					} catch( Exception ex) {};
+					if (chD.longDescription.trim().length()&gt;0)
+						op.append(&quot;\n   \&quot;&quot;+STRreplace.replace(chD.longDescription,&quot;\&quot;&quot;,&quot;\&quot;\&quot;&quot;)+&quot;\&quot;&quot;);
+					op.append(&quot;\n   goto($&quot;);
+					op.append(addiWpt.wayPoint);
+					op.append(&quot;); STOP\nENDIF\n\n&quot;);
+				}
+				Global.mainTab.solverP.mText.appendText(op.toString(),true);
+			}// if hasAddiWpt
+    	}
+    }
+
+    private double funcSqrt() throws Exception {
+    	double a=popCalcStackAsNumber(0);
+    	if (a&lt;0) err(MyLocale.getMsg(1720,&quot;Cannot calculate square root of a negative number&quot;));
+    	return java.lang.Math.sqrt(a);
+    }
+
+    /** Replace each character by its number A=1, B=2 etc. and put result into a string */
+    private String funcSval(String s) {
+       	s=s.toLowerCase();
+    	String res=&quot;&quot;;
+       	for (int i=0; i&lt;s.length(); i++) {
+    		int pos=&quot;abcdefghijklmnopqrstuvwxyz&quot;.indexOf(s.charAt(i));
+    		if (pos&gt;=0)
+    			res+=(res==&quot;&quot;?&quot;&quot;:&quot; &quot;)+MyLocale.formatLong(pos+1,&quot;00&quot;);
+    	}
+    	return res;
+    }
+
+    /** Replace each character by its number A=1, B=2 etc. and sum them */
+    private double funcVal(String s) {
+    	s=s.toLowerCase();
+    	int sum=0;
+    	for (int i=0; i&lt;s.length(); i++) {
+    		sum+=&quot;abcdefghijklmnopqrstuvwxyz&quot;.indexOf(s.charAt(i))+1;
+    	}
+    	return sum;
+    }
+
+///////////////////////////////////////////
+//  PARSER
+///////////////////////////////////////////
+
+
+    /** The following methods implement a recursive descent parser.
+     * Each method is called with 'thisToken' containing a valid token. It must return with 'thisToken' again containing
+     * a valid token.
+     */
+
+	private void parseCommand()  throws Exception {
+		while(scanpos &lt; tokenStack.size()) {
+			getToken();
+			if (thisToken.token.equals(&quot;;&quot;)) continue;  // skip an empty command
+			if (thisToken.tt==TokenObj.TT_IF)
+				parseIf();
+			else
+				parseSimpleCommand();
+			checkNextSymIs(&quot;;&quot;);
+		}
+	}
+
+	private void parseSimpleCommand() throws Exception{
+		if (thisToken.tt==TokenObj.TT_STOP) throw new Exception(&quot;STOP&quot;);  // Terminate without error message
+		if (thisToken.token.equals(&quot;$&quot;)) { // Show all global variables
+			showVars(true);
+			getToken();
+		} else if (thisToken.token.equals(&quot;?&quot;)) { // Show all local variables
+			showVars(false);
+			getToken();
+		} else if (thisToken.tt==TokenObj.TT_VARIABLE &amp;&amp; lookAheadToken().tt==TokenObj.TT_EQ)
+			parseAssign();
+		else {
+			parseStringExp();
+			while (calcStack.size()&gt;0) messageStack.add(popCalcStackAsString());
+		}
+	}
+
+	private void parseIf() throws Exception{
+		int compOp;
+		boolean compRes=false;
+		TokenObj ifToken=thisToken;
+		getToken();
+		// Check for &quot;IF varName THEN&quot; construct to check whether a variable is defined
+		if (thisToken.tt==TokenObj.TT_VARIABLE &amp;&amp; peekToken().token.toUpperCase().equals(&quot;THEN&quot;)) {
+			String varName=thisToken.token;
+			getToken(); //THEN
+			Object result = symbolTable.get(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
+			if(result == null) { // Var not found check whether it is a waypoint
+				if (varName.startsWith(&quot;$&quot;)) { // Could be a cachename
+					varName=varName.substring(1);
+					compRes=Global.getProfile().getCacheIndex(varName)!=-1;
+				} else
+					compRes=false;
+			} else // Found the variable, it must have a value
+				compRes=true;
+			getNextTokenOtherThanSemi();
+		} else { // Normal: IF expression THEN
+			parseStringExp();
+			compOp=thisToken.tt;
+			if (compOp&lt;TokenObj.TT_LT || compOp&gt;TokenObj.TT_NE) err(MyLocale.getMsg(1723,&quot;Comparison operator expected&quot;));
+			getToken();
+			parseStringExp();
+			checkNextSymIs(&quot;THEN&quot;);
+			getNextTokenOtherThanSemi();
+			boolean compAsString=false; //calcStack.get(calcStack.size()-2) instanceof String;
+			// If we can parse the first argument as a double, we will do a numeric comparison
+			try {
+				Common.parseDoubleException((String)calcStack.get(calcStack.size()-2) );
+			} catch (Exception ex) {
+				compAsString=true;
+			}
+			// If the first expression is not a double, compare as string.
+			if (compAsString) {
+				String b=popCalcStackAsString();
+				String a=popCalcStackAsString();
+				switch (compOp) {
+					case TokenObj.TT_EQ: compRes=a.equals(b); break;
+					case TokenObj.TT_NE: compRes=!a.equals(b); break;
+					case TokenObj.TT_LT: compRes=a.compareTo(b)&lt;0; break;
+					case TokenObj.TT_GT: compRes=a.compareTo(b)&gt;0; break;
+					case TokenObj.TT_LE: compRes=a.compareTo(b)&lt;=0; break;
+					case TokenObj.TT_GE: compRes=a.compareTo(b)&gt;=0; break;
+				}
+			} else { // First expression is a number, compare as numbers
+				double b=popCalcStackAsNumber(0);
+				double a=popCalcStackAsNumber(0);
+				switch (compOp) {
+					case TokenObj.TT_EQ: compRes=a==b; break;
+					case TokenObj.TT_NE: compRes=a!=b; break;
+					case TokenObj.TT_LT: compRes=a&lt;b; break;
+					case TokenObj.TT_GT: compRes=a&gt;b; break;
+					case TokenObj.TT_LE: compRes=a&lt;=b; break;
+					case TokenObj.TT_GE: compRes=a&gt;=b; break;
+				}
+			}
+		}
+		if (compRes) { // comparison resulted in TRUE
+			if (thisToken.tt!=TokenObj.TT_ENDIF) {
+				parseSimpleCommand();
+				while (thisToken.token.equals(&quot;;&quot;)) {
+					getNextTokenOtherThanSemi(); // Now we have either an ENDIF or the start of a simpleexpression
+					if (thisToken.tt==TokenObj.TT_ENDIF) break;
+					parseSimpleCommand();
+				}
+				checkNextSymIs(&quot;ENDIF&quot;);
+			}
+			getToken();
+		} else // comparison failed
+			skipPastEndif(ifToken);
+	}
+
+	private void parseAssign() throws Exception  {
+		String varName=new String(thisToken.token);
+		getToken(); //=
+		getToken();
+		// Assigns of the format A=; are ignored so that they can stay as placeholders and
+		// we can fill the data progressively during a multicache
+		if (thisToken.tt==TokenObj.TT_ENDIF || thisToken.token.equals(&quot;;&quot;)) return;
+		parseStringExp();
+		if (varName.startsWith(&quot;$&quot;)) { // Potential coordinate
+			int idx=Global.getProfile().getCacheIndex(varName.substring(1));
+			if (idx!=-1) { // Yes, is a coordinate
+				CacheHolder ch=(CacheHolder)Global.getProfile().cacheDB.get(idx);
+				// Check whether new coordinates are valid
+				String coord=popCalcStackAsString();
+				cwPt.set(coord);
+				if (cwPt.isValid() || coord.equals(&quot;&quot;)) { // Can clear coord with empty string
+					ch.latLon=cwPt.toString(CWPoint.CW);
+					ch.pos.set(cwPt);
+					ch.calcDistance(Global.getPref().curCentrePt); // Update distance and bearing
+		    	    Global.getProfile().selectionChanged=true; // Tell moving map to updated displayed waypoints
+				    return;
+				}
+				err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coord);
+			}
+			// Name starts with $ but is not a waypoint, fall through and set it as global variable
+		}
+		symbolTable.put(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName, popCalcStackAsString());
+	}
+
+	private void parseStringExp()throws Exception {
+		if (thisToken.tt==TokenObj.TT_STRING) {
+			calcStack.add(thisToken.token);
+			getToken();
+		} else {
+			parseExp();
+		}
+		//calcStack.add(popCalcStackAsString());
+		while (thisToken.tt==TokenObj.TT_STRING ||
+			   thisToken.tt==TokenObj.TT_NUMBER ||
+			   thisToken.tt==TokenObj.TT_VARIABLE ||
+			   thisToken.tt==TokenObj.TT_SYMBOL &amp;&amp; thisToken.token.equals(&quot;(&quot;)) {
+			if (thisToken.tt==TokenObj.TT_STRING) {
+				calcStack.add(thisToken.token);
+				getToken();
+			} else {
+				parseTailExp('+');
+			}
+			String b=popCalcStackAsString();
+			String a=popCalcStackAsString();
+			calcStack.add(a+b);
+		}
+	}
+
+	private void parseExp()throws Exception {
+		char unaryOp='+';
+		if (thisToken.token.equals(&quot;+&quot;) || thisToken.token.equals(&quot;-&quot;) ) {
+			unaryOp=thisToken.token.charAt(0);
+			getToken();
+		}
+		parseTailExp(unaryOp);
+	}
+
+	private void parseTailExp(char unaryOp)throws Exception {
+		parseTerm();
+		if (unaryOp=='-') { // Unary minus, negate the first term
+			calcStack.add(new java.lang.Double(-popCalcStackAsNumber(0)));
+		}
+		while (thisToken.token.equals(&quot;+&quot;) || thisToken.token.equals(&quot;-&quot;) ) {
+			char op=thisToken.token.charAt(0);
+			getToken();
+			parseTerm();
+			double b=popCalcStackAsNumber(0);
+			double a=popCalcStackAsNumber(0);
+			if (op=='+')
+				calcStack.add(new java.lang.Double(a+b));
+			else
+				calcStack.add(new java.lang.Double(a-b));
+		}
+		// If expression is followed by a formatstring, format it
+		if (thisToken.tt==TokenObj.TT_FORMATSTR) {
+			calcStack.add(MyLocale.formatDouble(popCalcStackAsNumber(0),thisToken.token).replace(',','.'));
+			getToken();
+		}
+	}
+
+	private void parseTerm() throws Exception{
+		parseFactor();
+		while (thisToken.token.equals(&quot;*&quot;) || thisToken.token.equals(&quot;/&quot;) ) {
+			char op=thisToken.token.charAt(0);
+			getToken();
+			parseFactor();
+			double b=popCalcStackAsNumber(1);
+			double a=popCalcStackAsNumber(1);
+			if (op=='*')
+				calcStack.add(new java.lang.Double(a*b));
+			else
+				if (b==0.0)
+					err(MyLocale.getMsg(1729,&quot;Division by 0&quot;));
+				else
+					calcStack.add(new java.lang.Double(a/b));
+		}
+	}
+
+	private void parseFactor() throws Exception{
+		parseExpFactor();
+		while (thisToken.token.equals(&quot;^&quot;)) {
+			getToken();
+			parseExpFactor();
+			double exp=popCalcStackAsNumber(0);
+			double base=popCalcStackAsNumber(0);
+			calcStack.add(new java.lang.Double(java.lang.Math.pow(base,exp)));
+		}
+	}
+
+	private void parseExpFactor() throws Exception {
+		fnType funcDef;
+		if (thisToken.tt==TokenObj.TT_VARIABLE) {
+			if (isVariable(thisToken.token))
+				calcStack.add(getVariable(thisToken.token));
+			else if (!lookAheadToken().token.equals(&quot;(&quot;)) err(MyLocale.getMsg(1724,&quot;Variable not set: &quot;)+thisToken.token);
+			else {// Must be a function definition
+				funcDef=getFunctionDefinition(thisToken.token); // Does not return if function not defined or ambiguous
+				parseFunction(funcDef);
+			}
+		} else if (thisToken.tt==TokenObj.TT_NUMBER) {
+			calcStack.add(getNumber(thisToken.token));
+		} else if (thisToken.tt==TokenObj.TT_STRING) {
+			calcStack.add(thisToken.token);
+		} else if (thisToken.token.equals(&quot;(&quot;)) {
+			getToken();
+			parseStringExp();
+			checkNextSymIs(&quot;)&quot;);
+		}
+		else err(MyLocale.getMsg(1725,&quot;Unexpected character(s): &quot;)+thisToken.token);
+		getToken();
+	}
+
+	private void parseFunction(fnType funcDef) throws Exception {
+		String funcName=new String(thisToken.token);
+        int nargs=0;
+		getToken();
+		checkNextSymIs(&quot;(&quot;);
+		getToken();
+		if (!thisToken.token.equals(&quot;)&quot;)) { // at least one argument
+			parseStringExp();
+			nargs=1;
+			while (thisToken.token.equals(&quot;,&quot;)) {
+				if (nargs==4) err(MyLocale.getMsg(1726,&quot;Too many arguments for function &quot;)+funcName);
+				getToken();
+				parseStringExp();
+				nargs++;
+			}
+			checkNextSymIs(&quot;)&quot;);
+		}
+		//getToken(); done in parseFactor
+		executeFunction(funcName,nargs,funcDef);
+	}
+
+	private void executeFunction(String funcName, int nargs, fnType funcDef) throws Exception {
+		if (!funcDef.nargsValid(nargs)) err(MyLocale.getMsg(1727,&quot;Invalid number of arguments&quot;));
+	         if (funcDef.alias.equals(&quot;asin&quot;)) calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.asin(popCalcStackAsNumber(0)))));
+	 	else if (funcDef.alias.equals(&quot;abs&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.abs(popCalcStackAsNumber(0))));
+	    else if (funcDef.alias.equals(&quot;acos&quot;)) calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.acos(popCalcStackAsNumber(0)))));
+	    else if (funcDef.alias.equals(&quot;atan&quot;)) calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.atan(popCalcStackAsNumber(0)))));
+	    else if (funcDef.alias.equals(&quot;bearing&quot;)) calcStack.add(new java.lang.Double(funcBearing()));
+	    else if (funcDef.alias.equals(&quot;center&quot;)) funcCenter(nargs);
+	    else if (funcDef.alias.equals(&quot;cls&quot;)) funcCls();
+	    else if (funcDef.alias.equals(&quot;cos&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.cos(makeRadiant(popCalcStackAsNumber(0)))));
+	    else if (funcDef.alias.equals(&quot;count&quot;)) funcCount();
+	    else if (funcDef.alias.equals(&quot;cp&quot;)) calcStack.add(funcCp());
+	    else if (funcDef.alias.equals(&quot;ct&quot;)) calcStack.add(new java.lang.Double(funcCrossTotal(nargs)));
+	    else if (funcDef.alias.equals(&quot;deg&quot;)) funcDeg(true);
+	    else if (funcDef.alias.equals(&quot;deg2rad&quot;)) calcStack.add(new java.lang.Double(funcDeg2Rad()));
+	    else if (funcDef.alias.equals(&quot;distance&quot;)) calcStack.add(new java.lang.Double(funcDistance()));
+	    else if (funcDef.alias.equals(&quot;encode&quot;)) calcStack.add(funcEncode());
+	    else if (funcDef.alias.equals(&quot;format&quot;)) calcStack.add(funcFormat(nargs));
+	    else if (funcDef.alias.equals(&quot;goto&quot;)) funcGoto(nargs);
+	    else if (funcDef.alias.equals(&quot;ic&quot;)) funcIgnoreVariableCase(nargs);
+	    else if (funcDef.alias.equals(&quot;instr&quot;)) calcStack.add(new Double(funcInstr(nargs)));
+	    else if (funcDef.alias.equals(&quot;lc&quot;)) calcStack.add(popCalcStackAsString().toLowerCase());
+	    else if (funcDef.alias.equals(&quot;len&quot;)) calcStack.add(new Double(popCalcStackAsString().length()));
+	    else if (funcDef.alias.equals(&quot;ln&quot;)) calcStack.add(new java.lang.Double(funcLn()));
+	    else if (funcDef.alias.equals(&quot;log&quot;)) calcStack.add(new java.lang.Double(funcLog()));
+	    else if (funcDef.alias.equals(&quot;mid&quot;)) calcStack.add(funcMid(nargs));
+	    else if (funcDef.alias.equals(&quot;project&quot;)) calcStack.add(funcProject());
+	    else if (funcDef.alias.equals(&quot;pz&quot;)) funcPz(nargs);
+	    else if (funcDef.alias.equals(&quot;rad&quot;)) funcDeg(false);
+	    else if (funcDef.alias.equals(&quot;rad2deg&quot;)) calcStack.add(new java.lang.Double(funcRad2Deg()));
+	    else if (funcDef.alias.equals(&quot;replace&quot;)) calcStack.add(funcReplace());
+	    else if (funcDef.alias.equals(&quot;reverse&quot;)) calcStack.add(funcReverse(popCalcStackAsString()));
+	    else if (funcDef.alias.equals(&quot;rot13&quot;)) calcStack.add(Common.rot13(popCalcStackAsString()));
+//	    else if (funcDef.alias.equals(&quot;rs&quot;)) funcRequireSemicolon(nargs);
+	    else if (funcDef.alias.equals(&quot;show&quot;));
+	    else if (funcDef.alias.equals(&quot;sin&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.sin(makeRadiant(popCalcStackAsNumber(0)))));
+	    else if (funcDef.alias.equals(&quot;skeleton&quot;)) funcSkeleton(nargs);
+	    else if (funcDef.alias.equals(&quot;sqrt&quot;)) calcStack.add(new java.lang.Double(funcSqrt()));
+	    else if (funcDef.alias.equals(&quot;sval&quot;)) calcStack.add(funcSval(popCalcStackAsString()));
+	    else if (funcDef.alias.equals(&quot;tan&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.tan(makeRadiant(popCalcStackAsNumber(0)))));
+	    else if (funcDef.alias.equals(&quot;uc&quot;)) calcStack.add(popCalcStackAsString().toUpperCase());
+	    else if (funcDef.alias.equals(&quot;val&quot;)) calcStack.add(new java.lang.Double(funcVal(popCalcStackAsString())));
+	    else err(MyLocale.getMsg(1728,&quot;Function not yet implemented: &quot;)+funcName);
+	}
+
+	public void parse(String s, Vector msgStack){
+		Tokenizer tokeniser=new Tokenizer();
+		tokeniser.tokenizeSource(s, msgStack); // Tokeniser sets message if an error occurred
+		if (msgStack.size()!=0) return;  // Error during tokenizing
+		calcStack.clear();
+		clearLocalSymbols();
+		tokenStack = tokeniser.TokenStack;
+		messageStack = msgStack;
+		scanpos = 0;
+		try{
+			parseCommand();
+		}catch(Exception ex){
+			//Vm.debug(ex.toString());
+		}
+	}
+
+
+//#################################################################################
+//  TokenObj
+//#################################################################################
+
+	/**
+	*	Class to hold a token object.
+	*	@see Tokenizer
+	*	@see Parser
+	*/
+	public class TokenObj{
+		/** Token types */
+		public static final int TT_VARIABLE=0;
+		public static final int TT_STRING=1;
+		public static final int TT_NUMBER=2;
+		public static final int TT_SYMBOL=3;
+		public static final int TT_FORMATSTR=4;
+		public static final int TT_IF=5;
+		public static final int TT_THEN=6;
+		public static final int TT_ENDIF=7;
+		public static final int TT_STOP=8;
+		public static final int TT_OPENBRACKET=9;
+		public static final int TT_CLOSEBRACKET=10;
+		public static final int TT_LT=20;   // Don't change the sequence from LT to NT
+		public static final int TT_GT=21;
+		public static final int TT_LE=22;
+		public static final int TT_GE=23;
+		public static final int TT_EQ=24;
+		public static final int TT_NE=25;
+
+		int tt; // Tokentype
+		String token;
+		int line, position;
+	}
+
+//#################################################################################
+//  Tokenizer
+//#################################################################################
+
+
+	/**
+	*	Class to tokenise (break up) the code into single tokens, so the
+	*	parser my do its job.
+	*	@see Parser
+	*/
+	public class Tokenizer{
+
+		/** Normally only a semicolon (;) can be used to separate commands. If this variable is set to true,
+		 * newlines also terminate a command. If a newline is preceded with a backslash (=line continuation character),
+		 * the newline does not terminate the command even if this variable is true.
+		 */
+		public boolean newLineIsSeparator=true;
+		/** instructions to tokenise */
+		String mySource;
+		/** source character */
+		char look;
+		/** pointer to next character to read */
+		int sourcePointer = 0;
+		/** (partial) token */
+		String currentStream;
+		Vector TokenStack = new Vector();
+		/** position of token */
+		int currentLine, currentPos;
+		TokenObj thisToken;
+		Vector messageStack;
+
+		public Tokenizer(){
+		}
+
+	    private void err(String str) throws Exception {
+	    	messageStack.add(MyLocale.getMsg(1700,&quot;Error on line: &quot;) + currentLine + &quot;  &quot;+MyLocale.getMsg(1701,&quot; position: &quot;) + currentPos);
+	    	messageStack.add(str);
+	    	if (Global.mainTab.solverP.mText.setSelectionRange(0,currentLine-1,currentPos,currentLine-1))Global.mainTab.solverP.mText.repaintNow();
+	    	throw new Exception(&quot;Error &quot;+str);
+	    }
+
+		private boolean isAlpha(char c){
+			return  &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;.indexOf(c)!=-1;
+		}
+
+		private boolean isDigit(char c){
+			return &quot;0123456789&quot;.indexOf(c)!=-1;
+		}
+
+		private boolean isSymbol(char c){
+			return &quot;?!&lt;&gt;(){}*/,;^+-=&quot;.indexOf(c)!=-1;
+		}
+
+		/**
+		 * Convert Unicode version of special chars to normal
+		 * @param c Char to convert
+		 * @return Converted char
+		 */
+		private char standardiseSourceChar(char c) {
+			if (c=='\u00A0' || (c&gt;='\u2002' &amp;&amp; c&lt;='\u200b')) c=' ';
+			if (c&gt;='\u2010' &amp;&amp; c&lt;='\u2015') c='-';
+			if (c&gt;='\u201c' &amp;&amp; c&lt;='\u201f') c='&quot;';
+			if (c=='[') c='(';
+			if (c==']') c=')';
+			if (c=='\u00f7' || c=='\u2044') c='/';
+			if (c=='\u2024') c='.';
+			return c;
+		}
+
+		private boolean getChar(){
+			if(sourcePointer &gt;= mySource.length()) {
+				look='\n';
+				return false;
+			}
+			look = mySource.charAt(sourcePointer++);
+			currentPos++;
+			return true;
+		}
+
+		private char lookAhead() {
+			if(sourcePointer &gt;= mySource.length())
+				return '\n';
+			char c=standardiseSourceChar(mySource.charAt(sourcePointer));
+			return c;
+
+		}
+
+		private void backUp() {
+			sourcePointer--;
+			currentPos--;
+		}
+
+		/** Create a new token object and remember the place where it started.
+		 *  String tokens could span several lines, so we need to remember the starting line and position.
+		 */
+		private void startToken() {
+			thisToken = new TokenObj();
+			thisToken.line = currentLine;
+			thisToken.position = currentPos;
+		}
+
+		/** Add the previously started token to the token stack */
+		private void emitToken(int tt){
+//			eve.sys.Vm.debug(currentStream);
+			thisToken.token = currentStream;
+			thisToken.tt=tt;
+			TokenStack.add(thisToken);
+			currentStream = &quot;&quot;;
+		}
+
+		private void streamAlphas(){
+			startToken();
+			while(getChar()){
+				if(isAlpha(look) || isDigit(look))
+					currentStream += look;
+				else
+					break;
+			}
+			String s=currentStream.toUpperCase();
+			if (s.equals(&quot;STOP&quot;) || s.equals(&quot;ST&quot;))
+				emitToken(TokenObj.TT_STOP);
+			else if (s.equals(&quot;IF&quot;))
+				emitToken(TokenObj.TT_IF);
+			else if (s.equals(&quot;THEN&quot;))
+				emitToken(TokenObj.TT_THEN);
+			else if (s.equals(&quot;ENDIF&quot;) || s.equals(&quot;FI&quot;))
+				{ currentStream=&quot;ENDIF&quot;; emitToken(TokenObj.TT_ENDIF); }
+			else
+				emitToken(TokenObj.TT_VARIABLE);
+			// We have read one character too far, so back off
+			backUp();
+		}
+
+		private void streamDigits(){
+			boolean foundDecSep=false; // To check that only one decimal point is allowed in a number
+			startToken();
+			while(getChar()){
+				look=standardiseSourceChar(look);
+				if(isDigit(look) || (look=='.' &amp;&amp; !foundDecSep)) {
+					currentStream += look;
+					if (look=='.') foundDecSep=true;
+				} else
+					break;
+			}
+			emitToken(TokenObj.TT_NUMBER);
+			// We have read one character too far, so back off
+			backUp();
+		}
+
+		private void streamString() throws Exception {
+			startToken();
+			currentStream=&quot;&quot;;
+			while(getChar()){ // collect chars until next &quot;
+				if (look=='&quot;') {
+					if (lookAhead()!='&quot;') break;  // &quot; not followed by &quot; =&gt; End of string
+					// Two &quot; following each other are replaced by &quot;
+					currentStream+=&quot;\&quot;&quot;;
+					getChar();
+				} else if (look=='\\') {
+					if (!getChar()) break;
+					if (look=='n') currentStream += &quot;\n&quot;;
+					else currentStream += look;
+				} else currentStream += look;
+				// Need to count newlines inside a string spanning multiple lines so that we don't loose track
+				if (look=='\n') {
+					currentLine++;
+					currentPos=0;
+				}
+			} // EOT or look==&quot;
+			if (look!='&quot;') {
+				// Restore start position of string for correct indication of error
+				currentLine=thisToken.line;
+				currentPos=thisToken.position;
+				err(MyLocale.getMsg(1730,&quot;Unterminated string&quot;));
+			}
+			emitToken(TokenObj.TT_STRING);
+
+		}
+
+		private void streamSymbol() {
+			startToken();
+			// Check for == != &lt;= &gt;= &lt;&gt; &gt;&lt;
+			if (look=='=' || look=='!' || look=='&lt;' || look=='&gt;') {
+				getChar();
+				currentStream+=look;
+				if (currentStream.equals(&quot;==&quot;))  { emitToken(TokenObj.TT_EQ); return;}
+				if (currentStream.equals(&quot;!=&quot;) || currentStream.equals(&quot;&gt;&lt;&quot;) || currentStream.equals(&quot;&lt;&gt;&quot;))
+												{ emitToken(TokenObj.TT_NE); ; return;}
+				if (currentStream.equals(&quot;&lt;=&quot;)) { emitToken(TokenObj.TT_LE); return; }
+				if (currentStream.equals(&quot;&gt;=&quot;)) { emitToken(TokenObj.TT_GE); return; }
+				backUp(); // Not a valid comparison symbol, forget the last character
+				currentStream=currentStream.substring(0,1);
+				if (currentStream.equals(&quot;=&quot;)) emitToken(TokenObj.TT_EQ);
+				else if (currentStream.equals(&quot;&lt;&quot;)) emitToken(TokenObj.TT_LT);
+				else if (currentStream.equals(&quot;&gt;&quot;)) emitToken(TokenObj.TT_GT);
+				else emitToken(TokenObj.TT_SYMBOL);
+			} else
+				emitToken(TokenObj.TT_SYMBOL);
+		}
+
+		/** Eat up all characters until next newline as we are in a comment */
+		private void eatUpComment() {
+			while (getChar() &amp;&amp; look !='\n');
+			currentStream=&quot;;&quot;; // Insert a dummy ;
+			startToken();
+			emitToken(TokenObj.TT_SYMBOL);
+			currentStream=&quot;&quot;;
+			currentLine++;
+			currentPos=0;
+		}
+
+		private void formatString() throws Exception {
+			currentStream=&quot;&quot;;
+			startToken();
+			while (getChar() &amp;&amp; look!=':') {
+				look=standardiseSourceChar(look);
+				currentStream += look;
+				if (look!='.' &amp;&amp; look!='0' &amp;&amp; look!='#') err(MyLocale.getMsg(1731,&quot;Invalid format character&quot;));
+			}
+			emitToken(TokenObj.TT_FORMATSTR);
+		}
+
+		public void tokenizeSource(String src, Vector msg){
+			mySource = src+&quot;\n&quot;;
+			sourcePointer = 0;
+			TokenStack.clear();
+			messageStack=msg;
+			currentLine = 1;
+			currentPos = 0;
+			currentStream=&quot;&quot;;
+			try {
+				while(getChar()){
+					look=standardiseSourceChar(look);
+					if (look==' ') continue;
+					currentStream += look;
+					if(isAlpha(look) || look=='$') streamAlphas();
+					else if(isDigit(look)) streamDigits();
+					else if(isSymbol(look)) streamSymbol();
+					else if(look == '&quot;') streamString();
+					else if(look == '\n') {
+						if (newLineIsSeparator &amp;&amp; !currentStream.equals(&quot;\\\n&quot;) &amp;&amp; !currentStream.equals(&quot;_\n&quot;)) {
+							currentStream=&quot;;&quot;;
+							startToken();
+							emitToken(TokenObj.TT_SYMBOL);
+						}
+						currentStream = &quot;&quot;; currentLine++; currentPos=0;
+					}
+					else if(look == '#') eatUpComment();	// Ignore characters until EOL
+					else if(look == ':') formatString();
+					else if (newLineIsSeparator &amp;&amp; (look=='\\' || look=='_')) ;
+					else err(MyLocale.getMsg(1732,&quot;Invalid character&quot;));
+				}
+			} catch (Exception e) {}
+		}
+	}
+	private boolean createWptIfNeeded(String wayPoint, String name, int type){
+	   	int ci=Global.getProfile().getCacheIndex(wayPoint);
+    	if (ci &gt;= 0) return false;
+
+		CacheHolder ch = new CacheHolder();
+		ch.wayPoint = wayPoint;
+		ch.type = type;
+		ch.cacheSize = &quot;None&quot;;
+		ch.cacheName= name;
+
+		Global.getProfile().hasUnsavedChanges=true;
+		Global.getProfile().setAddiRef(ch);
+
+		Global.getProfile().cacheDB.add(ch);
+		Global.mainTab.tbP.tModel.numRows++;
+		return true;
+	}
+
+
+}

Added: experiments/EVE/src/cachewolf/Preferences.java
===================================================================
--- experiments/EVE/src/cachewolf/Preferences.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/Preferences.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,722 @@
+package cachewolf;
+import java.io.*;
+import eve.sys.*;
+import eve.ui.*;
+import ewesoft.xml.*;
+import ewesoft.xml.sax.*;
+import eve.ui.filechooser.*;
+import java.util.*;
+
+import cachewolf.imp.SpiderGC;
+import cachewolf.utils.Common;
+import cachewolf.utils.SafeXML;
+import cachewolf.utils.STRreplace;
+
+
+import eve.ui.data.*;
+//import java.util.Map.MapEntry;
+
+/**
+ *	A class to hold the preferences that were loaded upon start up of CacheWolf.
+ *	This class is also capable of parsing the prefs.xml file as well as
+ *	saving the current settings of preferences.
+ */
+public class Preferences extends MinML{
+
+	public final int DEFAULT_MAX_LOGS_TO_SPIDER=250;
+	public final int DEFAULT_LOGS_PER_PAGE=5;
+	public final int DEFAULT_INITIAL_HINT_HEIGHT=10;
+
+	//////////////////////////////////////////////////////////////////////////////////////
+    // Constructor
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	/**
+	 * Singleton pattern - return reference to Preferences
+	 * @return Singleton Preferences object
+	 */
+	public static Preferences getPrefObject() {
+		if (_reference == null)
+			// it's ok, we can call this constructor
+			_reference = new Preferences();
+		return _reference;
+	}
+
+	private static Preferences _reference;
+
+	private String pathToConfigFile;
+
+    /**
+     * Call this method to set the path of the config file &lt;br&gt;
+     * If you call it with null it defaults to [program-dir]/pref.xml
+     * if p is a directory &quot;pref.xml&quot; will automatically appended
+     * @param p
+     */
+    public void setPathToConfigFile(String p) {
+        String p_;
+        if (p == null) {
+        	p_ = eve.io.File.makePath(eve.io.File.getProgramDirectory(), &quot;pref.xml&quot;);
+        }
+        else {
+			if (new File(p).isDirectory()) p_ = eve.io.File.makePath(p, &quot;pref.xml&quot;);
+			else p_ = p;
+        }
+        pathToConfigFile = STRreplace.replace(p_, &quot;//&quot;, &quot;/&quot;); // this is necessary in case that the root dir is the dir where the pref.xml is stored
+        pathToConfigFile = pathToConfigFile.replace('\\', '/');
+    }
+
+
+	/**
+	 * Constructor is private for a singleton object
+	 */
+	private Preferences(){
+		mySPO.bits = 8;
+		mySPO.parity = eve.io.SerialPort.NOPARITY;
+		mySPO.stopBits = 1;
+		mySPO.baudRate = 4800;
+		if (((new Window()).getWindowRect(null, false)).height &gt; 400) {
+			if (false) //TODO Find equivalent of ewe.Vm.getPlatForm:      Vm.getPlatform().equals(&quot;Unix&quot;))
+				fontSize = 12;
+			else {
+                if (eve.sys.Device.isMobile()){
+                    fontSize = 21;
+                    listColWidth=&quot;20,20,30,30,92,177,144,83,60,105,50,104,22,30,30&quot;;
+                } else
+				 fontSize = 16;
+			}
+		} else
+			 fontSize = 11;
+ 	}
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // Public fields stored in pref.xml
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	/** The base directory contains one subdirectory for each profile*/
+	public String baseDir = &quot;&quot;;
+	/** Name of last used profile */
+	public String lastProfile=&quot;&quot;;
+	/** If true, the last profile is reloaded automatically without a dialogue */
+	public boolean autoReloadLastProfile=false;
+	/** This is the login alias for geocaching.com and opencaching.de */
+	public String myAlias = &quot;&quot;;
+	/** Optional password */
+	public String password=&quot;&quot;;
+	/** This is an alternative alias used to identify found caches (i.e. if using multiple IDs)
+	 *  It is currently not used yet */
+	public String myAlias2 = &quot;&quot;;
+	/** The path to the browser */
+	public String browser = &quot;&quot;;
+	/** Name of proxy for spidering */
+	public String myproxy = &quot;&quot;;
+	/** Proxyport when spidering */
+	public String myproxyport = &quot;&quot;;
+	/** Flag whether proxy is to be used */
+	public boolean proxyActive=false;
+	/** Serial port name and baudrate */
+	public SerialPortOptions mySPO = new SerialPortOptions();
+	/** True if the GPS data should be forwarded to an IP address */
+	public boolean forwardGPS = false;
+	/** IP address for forwarding GPS data */
+	public String forwardGpsHost = &quot;192.168.1.15&quot;;
+	/** True if the GPS data should be logged to a file */
+	public boolean logGPS = false;
+	/** Timer for logging GPS data */
+	public String logGPSTimer = &quot;5&quot;;
+	/** The default font size */
+	public int fontSize = 11;
+	// These settings govern where the menu and the tabs are displayed and whether the statusbas is shown
+	/** True if the menu is to be displayed at the top of the screen */
+	public boolean menuAtTop=true;
+	/** True if the tabs are to be displayed at the top of the screen */
+	public boolean tabsAtTop=true;
+	/** True if the status bar is to be displayed (hidden if false) */
+	public boolean showStatus=true;
+	//public boolean noTabs=false;
+	/** True if the application can be closed by clicking on the close button in the top line.
+	 * This can be set to avoid accidental closing of the application */
+	public boolean hasCloseButton=true;
+	/** True if the SIP is always visible */
+	public boolean fixSIP = false;
+	/** The list of visible columns in the list view */
+	public String listColMap=&quot;0,1,2,3,4,5,6,7,8,9,10,11,12&quot;;
+	/** The widths for each column in list view */
+	public String listColWidth=&quot;15,20,20,25,92,177,144,83,60,105,50,104,22,30,30&quot;;
+	/** The columns which are to be displayed in TravelbugsJourneyScreen. See also TravelbugJourney */
+	public String travelbugColMap=&quot;1,4,5,6,8,9,10,7&quot;;
+	/** The column widths for the travelbug journeys. */
+	public String travelbugColWidth=&quot;212,136,62,90,50,56,90,38,50,50,94,50&quot;;
+	/** If this flag is true, only non-logged travelbug journeys will be shown */
+	public boolean travelbugShowOnlyNonLogged=false;
+	/** If this is true, deleted images are shown with a ? in the imagepanel */
+	public boolean showDeletedImages=true;
+	/** This setting determines how many logs are shown per page of hintlogs (default 5) */
+	public int logsPerPage=DEFAULT_LOGS_PER_PAGE;
+	/** Initial height of hints field (set to 0 to hide them initially) */
+	public int initialHintHeight=DEFAULT_INITIAL_HINT_HEIGHT;
+	/** Maximum logs to spider */
+	public int maxLogsToSpider = DEFAULT_MAX_LOGS_TO_SPIDER;
+	/** True if the Solver should ignore the case of variables */
+	public boolean solverIgnoreCase=true;
+	/** True if the solver expects arguments for trigonometric functions in degrees */
+	public boolean solverDegMode=true;
+	/** True if the description panel should show images */
+	public boolean descShowImg=true;
+	/** The type of connection which GPSBABEL uses: com1 OR usb. */
+	public String garminConn=&quot;com1&quot;;
+	/** Additional options for GPSBabel, i.e. -s to synthethise short names */
+	public String garminGPSBabelOptions=&quot;&quot;;
+	/** Max. length for Garmin waypoint names (for etrex which can only accept 6 chars) */
+	public int garminMaxLen=0;
+	public boolean downloadPicsOC = true; //TODO Sollten die auch im Profil gespeichert werden mit Preferences als default Werte ?
+	public boolean downloadMapsOC = true;
+	public boolean downloadmissingOC = false;
+	/** The currently used centre point, can be different from the profile's centrepoint. This is used
+	 *  for spidering */
+	public CWPoint curCentrePt=new CWPoint();
+	/** True if a login screen is displayed on each spider operation */
+	public boolean forceLogin=true;
+	/** True if the goto panel is North centered */
+	public boolean northCenteredGoto = true;
+	/** If not null, a customs map path has been specified by the user */
+	private String customMapsPath=null;
+	/** Number of CacheHolder details that are kept in memory */
+	public int maxDetails=50;
+	/** Number of details to delete when maxDetails have been stored in cachesWithLoadedDetails */
+	public int deleteDetails=5;
+    /** The locale code (DE, EN, ...) */
+    public String language=&quot;&quot;;
+
+	/** The height of the application */
+	public int myAppHeight = 600;
+	/** The width of the application */
+	public int myAppWidth = 800;
+
+	//////////////////////////////////////////////
+	/** The debug switch (Can be used to activate dormant code) by adding
+	 * the line: &lt;pre&gt;&lt;debug value=&quot;true&quot;&gt;&lt;/pre&gt;
+	 * to the pref.xml file.
+	 */
+	public boolean debug = false;
+	//////////////////////////////////////////////
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // Public fields not stored in pref.xml
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	/** True if the preferences were changed and need to be saved */
+	public boolean dirty = false;
+	/** The decimal separator (from MyLocale) */
+	//public String digSeparator = &quot;&quot;;
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // Read pref.xml file
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	/**
+	 * Method to open and parse the config (pref.xml) file. Results are stored in the
+	 * public variables of this class.
+	 * If you want to specify a non default config file call setPathToConfigFile() first.
+	 */
+	public void readPrefFile(){
+        if (pathToConfigFile == null) setPathToConfigFile(null); // this sets the default value
+		try{
+			Reader r = new InputStreamReader(new FileInputStream(pathToConfigFile));
+			parse(r);
+			r.close();
+        }catch(IOException e){
+            log(&quot;IOException reading config file: &quot; + pathToConfigFile, e, true);
+            (new MessageBox(MyLocale.getMsg(327, &quot;Information&quot;), MyLocale.getMsg(176, &quot;First start - using default preferences \n For experts only: \n Could not read preferences file:\n&quot;) + pathToConfigFile, MessageBox.OKB)).execute();
+		}catch(Exception e){
+			if (e instanceof NullPointerException)
+				log(&quot;Error reading pref.xml: NullPointerException in Element &quot;+lastName +&quot;. Wrong attribute?&quot;,e,true);
+			else
+				log(&quot;Error reading pref.xml: &quot;, e);
+		}
+	}
+
+	/** Helper variables for XML parser */
+	private StringBuffer collectElement=null;
+	private String lastName; // The string to the last XML that was processed
+
+	/**
+	 * Method that gets called when a new element has been identified in pref.xml
+	 */
+	public void startElement(String name, AttributeList atts){
+		//Vm.debug(&quot;name = &quot;+name);
+		lastName=name;
+		String tmp;
+		if(name.equals(&quot;browser&quot;)) browser = atts.getValue(&quot;name&quot;);
+		else if(name.equals(&quot;fixedsip&quot;)) {
+			if(atts.getValue(&quot;state&quot;).equals(&quot;true&quot;)) {
+				fixSIP = true;
+			}
+		}
+		else if(name.equals(&quot;font&quot;)) fontSize = Convert.toInt(atts.getValue(&quot;size&quot;));
+		else if(name.equals(&quot;alias&quot;)) {
+			myAlias = SafeXML.cleanback(atts.getValue(&quot;name&quot;));
+			tmp = SafeXML.cleanback(atts.getValue(&quot;password&quot;));
+			if (tmp != null) password=tmp;
+			SpiderGC.passwort=password;
+		}
+		else if(name.equals(&quot;alias2&quot;)) SafeXML.cleanback(myAlias2 = atts.getValue(&quot;name&quot;));
+		else if(name.equals(&quot;location&quot;)){
+			curCentrePt.set(atts.getValue(&quot;lat&quot;)+&quot; &quot;+atts.getValue(&quot;long&quot;));
+		}
+		else if(name.equals(&quot;port&quot;)){
+			mySPO.portName = atts.getValue(&quot;portname&quot;);
+			mySPO.baudRate = Convert.toInt(atts.getValue(&quot;baud&quot;));
+		}
+		else if(name.equals(&quot;portforward&quot;)) {
+			forwardGPS = Convert.toBoolean(atts.getValue(&quot;active&quot;));
+			forwardGpsHost = atts.getValue(&quot;destinationHost&quot;);
+		}
+		else if(name.equals(&quot;portlog&quot;)) {
+			logGPS = Convert.toBoolean(atts.getValue(&quot;active&quot;));
+			logGPSTimer = atts.getValue(&quot;logTimer&quot;);
+		}
+		else if (name.equals(&quot;lastprofile&quot;)) {
+			collectElement=new StringBuffer(50);
+			if (atts.getValue(&quot;autoreload&quot;).equals(&quot;true&quot;)) autoReloadLastProfile=true;
+		}
+
+		else if(name.equals(&quot;basedir&quot;)) {
+			baseDir = atts.getValue(&quot;dir&quot;);
+		}
+		else if (name.equals(&quot;opencaching&quot;)) {
+			downloadPicsOC = Boolean.valueOf(atts.getValue(&quot;downloadPics&quot;)).booleanValue();
+			downloadMapsOC = Boolean.valueOf(atts.getValue(&quot;downloadMaps&quot;)).booleanValue();
+			downloadmissingOC = Boolean.valueOf(atts.getValue(&quot;downloadmissing&quot;)).booleanValue();
+
+		}
+		else if (name.equals(&quot;listview&quot;)) {
+			listColMap=atts.getValue(&quot;colmap&quot;);
+			listColWidth=atts.getValue(&quot;colwidths&quot;)+&quot;,30,30&quot;; // append default values for older versions
+			if((new StringTokenizer(listColWidth,&quot;,&quot;)).countTokens()&lt;15) listColWidth+=&quot;,30,30&quot;; // for older versions
+		}
+		else if(name.equals(&quot;proxy&quot;)) {
+			myproxy = atts.getValue(&quot;prx&quot;);
+			myproxyport = atts.getValue(&quot;prt&quot;);
+			tmp = atts.getValue(&quot;active&quot;);
+			if (tmp != null) proxyActive=Boolean.valueOf(tmp).booleanValue();
+		}
+		else if (name.equals(&quot;garmin&quot;)) {
+			garminConn=atts.getValue(&quot;connection&quot;);
+			tmp = atts.getValue(&quot;GPSBabelOptions&quot;);
+			if (tmp != null) garminGPSBabelOptions=tmp;
+			tmp = atts.getValue(&quot;MaxWaypointLength&quot;);
+			if (tmp != null) garminMaxLen=Convert.toInt(atts.getValue(&quot;MaxWaypointLength&quot;));
+		}
+		else if (name.equals(&quot;imagepanel&quot;)) {
+			showDeletedImages = Boolean.valueOf(atts.getValue(&quot;showdeletedimages&quot;)).booleanValue();
+		}
+		else if (name.equals(&quot;descpanel&quot;)) {
+			descShowImg = Boolean.valueOf(atts.getValue(&quot;showimages&quot;)).booleanValue();
+		}
+		else if (name.equals(&quot;screen&quot;)) {
+			menuAtTop=Boolean.valueOf(atts.getValue(&quot;menuattop&quot;)).booleanValue();
+			tabsAtTop=Boolean.valueOf(atts.getValue(&quot;tabsattop&quot;)).booleanValue();
+			showStatus=Boolean.valueOf(atts.getValue(&quot;showstatus&quot;)).booleanValue();
+			if (atts.getValue(&quot;hasclosebutton&quot;)!=null)
+				hasCloseButton=Boolean.valueOf(atts.getValue(&quot;hasclosebutton&quot;)).booleanValue();
+			if (atts.getValue(&quot;h&quot;)!=null) {
+				myAppHeight=Convert.toInt(atts.getValue(&quot;h&quot;));
+				myAppWidth=Convert.toInt(atts.getValue(&quot;w&quot;));
+			}
+
+		}
+		else if (name.equals(&quot;hintlogpanel&quot;)) {
+			logsPerPage = Convert.parseInt(atts.getValue(&quot;logsperpage&quot;));
+			String strInitialHintHeight=atts.getValue(&quot;initialhintheight&quot;);
+			if (strInitialHintHeight!=null) initialHintHeight=Convert.parseInt(strInitialHintHeight);
+			String strMaxLogsToSpider=atts.getValue(&quot;maxspiderlogs&quot;);
+			if (strMaxLogsToSpider!=null) maxLogsToSpider=Convert.parseInt(strMaxLogsToSpider);
+		}
+		else if (name.equals(&quot;solver&quot;)) {
+			solverIgnoreCase=Boolean.valueOf(atts.getValue(&quot;ignorevariablecase&quot;)).booleanValue();
+			tmp = atts.getValue(&quot;degMode&quot;);
+			if (tmp != null) solverDegMode=Boolean.valueOf(tmp).booleanValue();
+		}
+		else if (name.equals(&quot;mapspath&quot;)) {
+			customMapsPath=atts.getValue(&quot;dir&quot;).replace('\\', '/');
+		}
+		else if (name.equals(&quot;debug&quot;)) debug=Boolean.valueOf(atts.getValue(&quot;value&quot;)).booleanValue();
+
+		else if (name.equals(&quot;expPath&quot;)){
+			exporterPaths.put(atts.getValue(&quot;key&quot;),atts.getValue(&quot;value&quot;));
+		}
+		else if (name.equals(&quot;travelbugs&quot;)) {
+			travelbugColMap=atts.getValue(&quot;colmap&quot;);
+			travelbugColWidth=atts.getValue(&quot;colwidths&quot;);
+			travelbugShowOnlyNonLogged=Boolean.valueOf(atts.getValue(&quot;shownonlogged&quot;)).booleanValue();
+		}
+		else if (name.equals(&quot;gotopanel&quot;)) {
+			northCenteredGoto = Boolean.valueOf(atts.getValue(&quot;northcentered&quot;)).booleanValue();
+		}
+		else if (name.equals(&quot;spider&quot;)) {
+			forceLogin = Boolean.valueOf(atts.getValue(&quot;forcelogin&quot;)).booleanValue();
+		}
+		else if (name.equals(&quot;details&quot;)) {
+			maxDetails=Common.parseInt(atts.getValue(&quot;cacheSize&quot;));
+			deleteDetails=Common.parseInt(atts.getValue(&quot;delete&quot;));
+			if (maxDetails&lt;2) maxDetails=2;
+			if (deleteDetails&lt;1) deleteDetails=1;
+		}
+        else if (name.equals(&quot;locale&quot;)) {
+            language = atts.getValue(&quot;language&quot;);
+        }
+    }
+
+
+	public void characters( char ch[], int start, int length ) {
+		if (collectElement!=null) {
+			collectElement.append(ch,start,length); // Collect the name of the last profile
+		}
+	}
+
+	/**
+	 * Method that gets called when the end of an element has been identified in pref.xml
+	 */
+	public void endElement(String tag){
+		if (tag.equals(&quot;lastprofile&quot;)) {
+			if (collectElement!=null) lastProfile=collectElement.toString();
+		}
+		collectElement=null;
+	}
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // Write pref.xml file
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	/**
+	 * Method to save current preferences in the pref.xml file
+	 */
+	public void savePreferences(){
+		if (pathToConfigFile == null) setPathToConfigFile(null); // this sets the default value
+		try{
+			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(pathToConfigFile)));
+			outp.print(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;ISO-8859-1\&quot;?&gt;\n&quot;);
+			outp.print(&quot;&lt;preferences&gt;\n&quot;);
+			outp.print(&quot;    &lt;locale language=\&quot;&quot; + SafeXML.strxmlencode(language) + &quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;	&lt;basedir dir = \&quot;&quot;+ SafeXML.strxmlencode(baseDir) +&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;lastprofile autoreload=\&quot;&quot;+autoReloadLastProfile+&quot;\&quot;&gt;&quot;+SafeXML.strxmlencode(lastProfile)+&quot;&lt;/lastprofile&gt;\n&quot;); //RB
+			outp.print(&quot;	&lt;alias name =\&quot;&quot;+ SafeXML.clean(myAlias) +&quot;\&quot; password=\&quot;&quot;+SafeXML.clean(password)+&quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;	&lt;alias2 name =\&quot;&quot;+ SafeXML.clean(myAlias2) +&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;	&lt;browser name = \&quot;&quot;+SafeXML.strxmlencode(browser)+&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;	&lt;proxy prx = \&quot;&quot;+ SafeXML.strxmlencode(myproxy)+&quot;\&quot; prt = \&quot;&quot;+ myproxyport + &quot;\&quot; active = \&quot;&quot;+ proxyActive +&quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;	&lt;port portname = \&quot;&quot;+ SafeXML.strxmlencode(mySPO.portName) +&quot;\&quot; baud = \&quot;&quot;+ mySPO.baudRate+&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;	&lt;portforward active= \&quot;&quot;+ Convert.toString(forwardGPS)+&quot;\&quot; destinationHost = \&quot;&quot;+ SafeXML.strxmlencode(forwardGpsHost)+&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;	&lt;portlog active= \&quot;&quot;+ Convert.toString(logGPS)+&quot;\&quot; logTimer = \&quot;&quot;+ logGPSTimer +&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;font size =\&quot;&quot;+fontSize+&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;screen menuattop=\&quot;&quot;+menuAtTop+&quot;\&quot; tabsattop=\&quot;&quot;+tabsAtTop+&quot;\&quot; showstatus=\&quot;&quot;+showStatus+&quot;\&quot; hasclosebutton=\&quot;&quot;+hasCloseButton+
+					                &quot;\&quot; h=\&quot;&quot;+myAppHeight+&quot;\&quot; w=\&quot;&quot;+myAppWidth+&quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;fixedsip state = \&quot;&quot;+fixSIP+&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;listview colmap=\&quot;&quot;+listColMap+&quot;\&quot; colwidths=\&quot;&quot;+listColWidth+&quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;travelbugs colmap=\&quot;&quot;+travelbugColMap+&quot;\&quot; colwidths=\&quot;&quot;+travelbugColWidth+&quot;\&quot; shownonlogged=\&quot;&quot;+travelbugShowOnlyNonLogged+&quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;descpanel showimages=\&quot;&quot;+descShowImg+&quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;imagepanel showdeletedimages=\&quot;&quot;+showDeletedImages+&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;hintlogpanel logsperpage=\&quot;&quot;+logsPerPage+&quot;\&quot; initialhintheight=\&quot;&quot;+initialHintHeight+&quot;\&quot;  maxspiderlogs=\&quot;&quot;+maxLogsToSpider+&quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;solver ignorevariablecase=\&quot;&quot;+solverIgnoreCase+&quot;\&quot; degMode=\&quot;&quot;+solverDegMode+&quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;garmin connection = \&quot;&quot;+SafeXML.strxmlencode(garminConn)+&quot;\&quot; GPSBabelOptions = \&quot;&quot;+garminGPSBabelOptions+&quot;\&quot; MaxWaypointLength = \&quot;&quot;+garminMaxLen+&quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;opencaching downloadPicsOC=\&quot;&quot;+downloadPicsOC+&quot;\&quot; downloadMaps=\&quot;&quot;+downloadMapsOC+&quot;\&quot; downloadMissing=\&quot;&quot;+downloadmissingOC+&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;	&lt;location lat = \&quot;&quot;+curCentrePt.getLatDeg(CWPoint.DD)+&quot;\&quot; long = \&quot;&quot;+curCentrePt.getLonDeg(CWPoint.DD)+&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;spider forcelogin=\&quot;&quot;+forceLogin+&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;gotopanel northcentered=\&quot;&quot;+northCenteredGoto+&quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;details cacheSize=\&quot;&quot;+maxDetails+&quot;\&quot; delete=\&quot;&quot;+deleteDetails+&quot;\&quot;/&gt;\n&quot;);
+			if (customMapsPath!=null) outp.print(&quot;	&lt;mapspath dir = \&quot;&quot;+ SafeXML.strxmlencode(customMapsPath.replace('\\','/')) +&quot;\&quot;/&gt;\n&quot;);
+			if (debug) outp.print(&quot;    &lt;debug value=\&quot;true\&quot; /&gt;\n&quot;); // Keep the debug switch if it is set
+			// save last path of different exporters
+			Enumeration ePath = exporterPaths.keys();
+			String entry;
+			while(ePath.hasMoreElements()){
+				entry = (String) ePath.nextElement();
+				outp.print(&quot;    &lt;expPath key = \&quot;&quot; + SafeXML.strxmlencode(entry) + &quot;\&quot; value = \&quot;&quot; + SafeXML.strxmlencode(((String)exporterPaths.get(entry)).replace('\\', '/')) + &quot;\&quot;/&gt;\n&quot;);
+			}
+			outp.print(&quot;&lt;/preferences&gt;&quot;);
+			outp.close();
+		} catch (Exception e) {
+			log(&quot;Problem saving: &quot; +pathToConfigFile,e,true);
+		}
+	}
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // Maps
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	private static final String mapsPath = &quot;maps/standard&quot;;
+
+	/**
+	 * custom = set by the user
+	 * @return custom Maps Path, null if not set
+	 */
+	public String getCustomMapsPath() {
+	   return customMapsPath;
+	}
+
+	public void saveCustomMapsPath(String mapspath_) {
+		if (customMapsPath == null || !customMapsPath.equals(mapspath_)) {
+			customMapsPath=new String(mapspath_).replace('\\', '/');
+			savePreferences();
+		}
+	}
+
+	/**
+	 * gets the path to the calibrated maps
+	 * it first tries if there are manually imported maps
+	 * in &lt;baseDir&gt;/maps/standard then it tries
+	 * the legacy dir: &lt;program-dir&gt;/maps
+	 * In case in both locations are no .wfl-files
+	 * it returns  &lt;baseDir&gt;/maps/expedia - the place where
+	 * the automatically downloaded maps are placed.
+	 *
+	 *
+	 */
+	public String getMapLoadPath() {
+		saveCustomMapsPath(getMapLoadPathInternal());
+		return getCustomMapsPath();
+	}
+	private String getMapLoadPathInternal() {
+		// here could also a list of map-types displayed...
+		// standard dir
+		String ret = getCustomMapsPath();
+		if (ret != null) return ret;
+		ret = getMapManuallySavePath(false);
+		eve.io.File t = new eve.io.File(ret);
+		String[] f = t.list(&quot;*.wfl&quot;, eve.io.File.LIST_FILES_ONLY);
+		if (f != null &amp;&amp; f.length &gt; 0) return  baseDir + mapsPath;
+		f = t.list(&quot;*.wfl&quot;, eve.io.File.LIST_DIRECTORIES_ONLY | eve.io.File.LIST_ALWAYS_INCLUDE_DIRECTORIES);
+		if (f != null &amp;&amp; f.length &gt; 0) { // see if in a subdir of &lt;baseDir&gt;/maps/standard are .wfl files
+			String[] f2;
+			for (int i = 0; i&lt; f.length; i++) {
+				t.set(null, ret+&quot;/&quot;+f[i]);
+				f2 = t.list(&quot;*.wfl&quot;, eve.io.File.LIST_FILES_ONLY);
+				if (f2 != null &amp;&amp; f2.length &gt; 0) return  ret;
+			}
+		}
+		// lagacy dir
+		ret = eve.io.File.getProgramDirectory() + &quot;/maps&quot;;
+		t.set(null, ret);
+		f = t.list(&quot;*.wfl&quot;, eve.io.File.LIST_FILES_ONLY);
+		if (f != null &amp;&amp; f.length &gt; 0) {
+			MessageBox inf = new MessageBox(&quot;Information&quot;, &quot;The directory for calibrated maps \nhas moved in this program version\n to '&lt;profiles directory&gt;/maps/standard'\n Do you want to move your calibrated maps there now?&quot;, MessageBox.YESB | MessageBox.NOB);
+			if (inf.execute() == MessageBox.IDYES) {
+				String sp = getMapManuallySavePath(false);
+				eve.io.File spF = new eve.io.File(sp);
+				if (!spF.exists()) spF.mkdirs();
+				String image;
+				String lagacypath = ret;
+				for (int i=0; i&lt;f.length; i++) {
+					t.set(null, lagacypath+f[i]);
+					spF.set(null, sp+&quot;/&quot;+f[i]);
+					t.move(spF);
+					image = Common.getImageName(lagacypath+f[i].substring(0, f[i].lastIndexOf(&quot;.&quot;)));
+					t.set(null, image);
+					spF.set(null, sp+&quot;/&quot;+t.getFileExt());
+					t.move(spF);
+				}
+				t.set(null, lagacypath);
+				t.delete();
+				return sp;
+			}
+			return  ret;
+		}
+        // expedia dir
+        // return getMapExpediaLoadPath();
+
+        //whole maps directory
+        return Global.getPref().baseDir.replace('\\', '/') + &quot;maps&quot;;
+	}
+
+	/**
+	 * @param create if true the directory if it doesn't exist will be created
+	 * @return the path where manually imported maps should be stored
+	 * this should be adjustable in preferences...
+	 */
+	public String getMapManuallySavePath(boolean create) {
+		String mapsDir = baseDir + mapsPath;
+		if (create &amp;&amp; !(new File(mapsDir).isDirectory())) { // dir exists?
+			if (new File(mapsDir).mkdirs() == false) {// dir creation failed?
+				(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(172,&quot;Error: cannot create maps directory: \n&quot;)+mapsDir, MessageBox.OKB)).exec();
+				return null;
+			}
+		}
+		return mapsDir;
+	}
+
+	/**
+	 * to this path the automatically downloaded maps are saved
+	 */
+	public String getMapDownloadSavePath(String mapkind) {
+		String subdir = Global.getProfile().dataDir.substring(Global.getPref().baseDir.length()).replace('\\', '/');
+		String mapsDir = Global.getPref().baseDir + &quot;maps/&quot; + Common.clearForFileName(mapkind)+ &quot;/&quot; + subdir;
+		if (!(new File(mapsDir).isDirectory())) { // dir exists?
+			if (new File(mapsDir).mkdirs() == false) // dir creation failed?
+			{(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(172,&quot;Error: cannot create maps directory: \n&quot;)+new File(mapsDir).getParentFile(), MessageBox.OKB)).exec();
+			return null;
+			}
+		}
+		return mapsDir;
+	}
+
+	public String getMapExpediaLoadPath() {
+		return Global.getPref().baseDir.replace('\\', '/') + &quot;maps/expedia&quot;; // baseDir has trailing /
+	}
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // Profile Selector
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	static protected final int PROFILE_SELECTOR_FORCED_ON=0;
+	static protected final int PROFILE_SELECTOR_FORCED_OFF=1;
+	static protected final int PROFILE_SELECTOR_ONOROFF=2;
+
+	/**
+	 * Open Profile selector screen
+	 * @param prof
+	 * @param showProfileSelector
+	 * @return True if a profile was selected
+	 */
+	public boolean selectProfile(Profile prof, int showProfileSelector, boolean hasNewButton) {
+		// If datadir is empty, ask for one
+		if (baseDir.length()==0 || !(new File(baseDir)).exists()) {
+			do {
+				FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT,&quot;/&quot;);
+				fc.title = MyLocale.getMsg(170,&quot;Select base directory for cache data&quot;);
+				// If no base directory given, terminate
+				if (fc.execute() == FileChooser.IDCANCEL) eve.sys.Vm.exit(0);
+				baseDir = fc.getChosenFile().toString();
+			}while (!(new File(baseDir)).exists());
+		}
+		baseDir=baseDir.replace('\\','/');
+		if (!baseDir.endsWith(&quot;/&quot;)) baseDir+=&quot;/&quot;;
+		boolean profileExists=true;  // Assume that the profile exists
+		do {
+			if(!profileExists || (showProfileSelector==PROFILE_SELECTOR_FORCED_ON) ||
+					(showProfileSelector==PROFILE_SELECTOR_ONOROFF &amp;&amp; !autoReloadLastProfile)){ // Ask for the profile
+				ProfilesForm f = new ProfilesForm(baseDir,lastProfile,!profileExists || hasNewButton);
+				int code = f.execute();
+				// If no profile chosen (includes a new one), terminate
+				if (code==-1) return false; // Cancel pressed
+				CWPoint savecenter = new CWPoint(prof.centre);
+ 				prof.clearProfile();
+ 				prof.centre = savecenter;
+ 				prof.hasUnsavedChanges = true;
+				lastProfile=f.newSelectedProfile;
+			}
+			profileExists=(new File(baseDir+lastProfile)).exists();
+			if (!profileExists) (new MessageBox(MyLocale.getMsg(144,&quot;Warning&quot;),
+					           MyLocale.getMsg(171,&quot;Profile does not exist: &quot;)+lastProfile,MessageBox.MBOK)).execute();
+		} while (profileExists==false);
+		// Now we are sure that baseDir exists and basDir+profile exists
+		prof.name=lastProfile;
+		prof.dataDir=baseDir+lastProfile;
+		prof.dataDir=prof.dataDir.replace('\\','/');
+		if (!prof.dataDir.endsWith(&quot;/&quot;)) prof.dataDir+='/';
+		savePreferences();
+		return true;
+	}
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // Log functions
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	/** Log file is in program directory and called log.txt */
+	private final String LOGFILENAME=eve.io.File.getProgramDirectory()+&quot;/log.txt&quot;;
+
+	/**
+	 * Method to delete an existing log file. Called on every SpiderGC.
+	 * The log file is also cleared when Preferences is created and the filesize &gt; 60KB
+	 */
+	public void logInit(){
+		File logFile = new File(LOGFILENAME);
+		logFile.delete();
+		log(&quot;CW Version &quot;+Version.getReleaseDetailed());
+	}
+
+	/**
+	 * Method to log messages to a file called log.txt
+	 * It will always append to an existing file.
+	 * To show the message on the console, the global variable debug must be set.
+	 * This can be done by adding
+	 * &lt;pre&gt;&lt;debug value=&quot;true&quot;&gt;&lt;/pre&gt;
+	 * to the pref.xml file
+	 * @param text to log
+	 */
+	public void log(String text){
+		Time dtm = new Time();
+		dtm.getTime();
+		dtm.setFormat(&quot;dd.MM.yyyy'/'HH:mm&quot;);
+		text = dtm.toString()+ &quot;: &quot;+ text;
+		if (debug) Vm.debug(text);
+		text=text+&quot;\n&quot;;
+		FileWriter logFile = null;
+		try{
+			logFile = new FileWriter(LOGFILENAME, true);
+			logFile.write(text);
+			//Vm.debug(text); Not needed - put &lt;debug value=&quot;true&quot;&gt; into pref.xml
+		}catch(Exception ex){
+			Vm.debug(&quot;Error writing to log file!&quot;);
+		}finally{
+			if (logFile != null) try {logFile.close(); } catch (IOException ioe) {}
+		}
+	}
+
+	/** Log an exception to the log file with or without a stack trace
+	 *
+	 * @param text Optional message (Can be empty string)
+	 * @param e The exception
+	 * @param withStackTrace If true and the debug switch is true, the stack trace is appended to the log
+	 * The debug switch can be set by including the line &lt;i&gt;&lt;debug value=&quot;true&quot;&gt;&lt;/debug&gt;&lt;/i&gt; in the pref.xml file
+	 * or by manually setting it (i.e. in BE versions or RC versions) by including the line
+	 * &lt;pre&gt;Global.getPref().debug=true;&lt;/pre&gt;
+	 * in Version.getRelease()
+	 */
+	public void log(String text,Throwable e, boolean withStackTrace) {
+		String msg;
+		if (text.equals(&quot;&quot;)) msg=text; else msg=text+&quot;\n&quot;;
+		if (e!=null) {
+			if (withStackTrace &amp;&amp; debug)
+				msg+=eve.sys.Vm.getAStackTrace(e);
+			else
+				msg+=e.toString();
+		}
+		log(msg);
+	}
+
+	/** Log an exception to the log file without a stack trace, i.e.
+	 * where a stack trace is not needed because the location/cause of the error is clear
+	 *
+	 * @param message Optional message (Can be empty string)
+	 * @param e The exception
+	 */
+	public void log(String message,Exception e) {
+		log (message,e,false);
+	}
+
+    //////////////////////////////////////////////////////////////////////////////////////
+    // Exporter path functions
+	//////////////////////////////////////////////////////////////////////////////////////
+
+	/** Hashtable for storing the last export path */
+	private Hashtable exporterPaths = new Hashtable();
+
+	public void setExportPath(String exporter,String path){
+		exporterPaths.put(exporter, path);
+		savePreferences();
+	}
+
+	public void setExportPathFromFileName(String exporter,String filename){
+		File tmpfile = new File (filename);
+		exporterPaths.put(exporter, tmpfile.getPath());
+		savePreferences();
+	}
+
+	public String getExportPath(String exporter){
+		String dir = (String) exporterPaths.get(exporter);
+		if (dir == null){
+			dir = Global.getProfile().dataDir;
+		}
+		return dir;
+	}
+
+}

Added: experiments/EVE/src/cachewolf/PreferencesScreen.java
===================================================================
--- experiments/EVE/src/cachewolf/PreferencesScreen.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/PreferencesScreen.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,344 @@
+package cachewolf;
+
+import cachewolf.imp.SpiderGC;
+import cachewolf.utils.Common;
+import eve.ui.*;
+import eve.fx.*;
+import eve.ui.filechooser.*;
+import eve.sys.*;
+import eve.ui.event.ControlEvent;
+import eve.ui.data.Editor;
+import eve.ui.data.SerialPortOptions;
+import eve.io.File;
+import eve.fx.gui.IKeys;
+/**
+*	This class displays a user interface allowing the user to change and set
+*	preferences. It also provides a method to save the changed preferences that
+*	are saved immediatly when the user presses &quot;Apply&quot;.
+*	Class ID=600
+*/
+public class PreferencesScreen extends Form {
+    Button cancelB, applyB, brwBt, gpsB,btnCentre;
+    Choice NS, EW, inpLanguage;
+    Input NSDeg, NSm, EWDeg, EWm, DataDir, Proxy, ProxyPort, Alias, nLogs, Browser, fontSize, inpGPS,
+           inpLogsPerPage,inpMaxLogsToSpider,inpPassword;
+    CheckBox dif, ter, loc, own, hid, stat, dist, bear, chkAutoLoad, chkShowDeletedImg, chkMenuAtTop,
+              chkTabsAtTop, chkShowStatus,chkHasCloseButton,chkSynthShort,chkProxyActive, chkDescShowImg;
+    TabbedPanel mTab;
+    Choice chcGarminPort;
+    Label lblGarmin;
+    TableColumnChooser tccBugs,tccList;
+
+    Preferences pref;
+
+    CellPanel pnlGeneral = new CellPanel();
+    CellPanel pnlDisplay = new CellPanel();
+    CellPanel pnlMore = new CellPanel();
+    CellPanel pnlTB = new CellPanel();
+    //Frame frmGarmin = new Frame();
+    ScrollBarPanel scp; // TODO not neede any more?
+    String [] garminPorts= new String[]{&quot;com1&quot;,&quot;com2&quot;,&quot;com3&quot;,&quot;com4&quot;,&quot;com5&quot;,&quot;com6&quot;,&quot;com7&quot;,&quot;usb&quot;};
+
+    public PreferencesScreen (Preferences p){
+            int sw = MyLocale.getScreenWidth();
+            int sh = MyLocale.getScreenHeight();
+
+            mTab=new TabbedPanel();
+
+            pref = p;
+            this.title = MyLocale.getMsg(600,&quot;Preferences&quot;);
+            if ((sw &gt; 240) &amp;&amp; (sh &gt; 240))
+                    this.resizable = true;
+            //this.moveable = true;
+            //this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
+
+            // set dialog-width according to fontsize
+            if((pref.fontSize &lt;= 13)||(sw &lt;= 240)||(sh &lt;= 240)){
+                    setPreferredSize(240,240);
+            }
+            else if(pref.fontSize &lt;= 17){
+                    setPreferredSize(300,250);
+            }
+            else if(pref.fontSize &lt;= 20){
+                    setPreferredSize(350,300);
+            }
+            else if(pref.fontSize &lt;= 24){
+                    setPreferredSize(400,350);
+            }
+            else if(pref.fontSize &lt;= 28){
+                    setPreferredSize(450,400);
+            }
+            else{
+                    setPreferredSize(500,450);
+            }
+
+            //scp = new ScrollBarPanel(pnlGeneral);
+
+            /////////////////////////////////////////////////////////
+            // First panel - General
+            /////////////////////////////////////////////////////////
+            Frame frmDataDir=new Frame();
+            frmDataDir.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_BOTTOM;
+            frmDataDir.addNext(new Label(MyLocale.getMsg(603,&quot;Data Directory:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            //frmDataDir.setTag(TAG_INSETS,new Insets(10,10,10,10));
+            frmDataDir.addLast(brwBt = new Button(MyLocale.getMsg(604,&quot;Browse&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.EAST));
+            DataDir = new Input();
+            DataDir.setText(pref.baseDir);
+            frmDataDir.addLast(DataDir.setTag(CellConstants.SPAN, new Dimension(3,1)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.EAST));
+            frmDataDir.addLast(chkAutoLoad = new CheckBox(MyLocale.getMsg(629,&quot;Autoload last profile&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            if (pref.autoReloadLastProfile) chkAutoLoad.setState(true);
+            chkAutoLoad.setTag(TAG_INSETS,new Insets(0,0,2,0));
+            pnlGeneral.addLast(frmDataDir,HSTRETCH,HFILL);
+
+            CellPanel pnlBrowser=new CellPanel();
+            pnlBrowser.setTag(TAG_INSETS,new Insets(2,0,0,0));
+            pnlBrowser.addNext(new Label(&quot;Browser:&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            Browser = new Input();
+            Browser.setText(pref.browser);
+            pnlBrowser.addLast(Browser,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+
+            pnlBrowser.addNext(new Label(MyLocale.getMsg(601,&quot;Your Alias:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            Alias = new Input();
+            Alias.setText(pref.myAlias);
+            pnlBrowser.addNext(Alias,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            pnlBrowser.addNext(new Label(MyLocale.getMsg(594,&quot;Pwd&quot;)));
+            pnlBrowser.addLast(inpPassword=new Input(pref.password),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            inpPassword.setToolTip(MyLocale.getMsg(593,&quot;Password is optional here.\nEnter only if you want to store it in pref.xml&quot;));
+            inpPassword.isPassword=true;
+            pnlGeneral.addLast(pnlBrowser,HSTRETCH,HFILL);
+
+            pnlGeneral.addLast(gpsB = new Button(&quot;GPS: &quot; + pref.mySPO.portName+&quot;/&quot;+pref.mySPO.baudRate),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+            //content.addNext(Alias.setTag(Control.SPAN, new Dimension(3,1)),content.DONTSTRETCH, (content.HFILL|content.WEST));
+/*              pnlGeneral.addLast(inpGPS=new mInput(&quot;&quot;));
+            inpGPS.modify(ControlConstants.Disabled|ControlConstants.NoFocus,0);
+            inpGPS.setText(pref.mySPO.portName+&quot;/&quot;+pref.mySPO.baudRate);
+    */
+            // Garmin and GPSBabel
+            pnlGeneral.addNext(lblGarmin=new Label(MyLocale.getMsg(173,&quot;Garmin:  PC Port:&quot;)),DONTSTRETCH,LEFT);
+//          lblGarmin.setTag(TAG_INSETS,new Insets(4,0,0,0));
+            pnlGeneral.addNext(chcGarminPort=new Choice(garminPorts,0),DONTSTRETCH,RIGHT);
+            //chcGarminPort.setTag(TAG_INSETS,new Insets(4,0,0,0));
+            chcGarminPort.selectItem(pref.garminConn);
+            pnlGeneral.addLast(chkSynthShort=new CheckBox(MyLocale.getMsg(174,&quot;Short Names&quot;)),STRETCH,LEFT);
+            //chkSynthShort.setTag(TAG_INSETS,new Insets(4,0,0,0));
+            chkSynthShort.setState(!pref.garminGPSBabelOptions.equals(&quot;&quot;));
+            //frmGarmin.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_TOP;
+            //frmGarmin.setTag(TAG_INSETS,new Insets(4,0,0,0));
+            //pnlGeneral.addLast(frmGarmin);
+            pnlGeneral.addLast(new Label(&quot;&quot;));
+
+            /////////////////////////////////////////////////////////
+            // Second panel - Screen
+            /////////////////////////////////////////////////////////
+
+            Frame frmScreen=new Frame();
+            frmScreen.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER;
+            CellPanel pnlScreen=new CellPanel();
+            pnlScreen.addNext(new Label(MyLocale.getMsg(625,&quot;Screen (needs restart):&quot;)));
+            pnlScreen.addNext(new Label(&quot;Font&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            pnlScreen.addLast(fontSize = new Input(),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+            fontSize.maxLength=2;
+            fontSize.setPreferredSize(40,-1);
+            frmScreen.addLast(pnlScreen,HSTRETCH,HFILL);
+            fontSize.setText(Convert.toString(pref.fontSize));
+
+            frmScreen.addLast(chkHasCloseButton=new CheckBox(MyLocale.getMsg(631,&quot;PDA has close Button&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+    //lblTitle.setTag(TAG_INSETS,new Insets(2,0,0,0));
+    chkHasCloseButton.setState(pref.hasCloseButton);
+            frmScreen.addNext(chkMenuAtTop = new CheckBox(MyLocale.getMsg(626,&quot;Menu top&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            chkMenuAtTop.setTag(TAG_INSETS,new Insets(0,0,2,0));
+            chkMenuAtTop.setState(pref.menuAtTop);
+            frmScreen.addNext(chkTabsAtTop = new CheckBox(MyLocale.getMsg(627,&quot;Tabs top&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            chkTabsAtTop.setState(pref.tabsAtTop);
+            chkTabsAtTop.setTag(TAG_INSETS,new Insets(0,0,2,0));
+            frmScreen.addLast(chkShowStatus = new CheckBox(MyLocale.getMsg(628,&quot;Status&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            chkShowStatus.setState(pref.showStatus);
+            chkShowStatus.setTag(TAG_INSETS,new Insets(0,0,2,0));
+            pnlDisplay.addLast(frmScreen,CellConstants.HSTRETCH,CellConstants.FILL);
+
+            Frame frmImages=new Frame();
+            frmImages.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_TOP|UIConstants.BF_BOTTOM;
+            //frmImages.addNext(new mLabel(MyLocale.getMsg(623,&quot;Images:&quot;)),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            frmImages.addLast(chkShowDeletedImg = new CheckBox(MyLocale.getMsg(624,&quot;Show deleted images&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            chkShowDeletedImg.setTag(TAG_INSETS,new Insets(2,0,0,0));
+            if (pref.showDeletedImages) chkShowDeletedImg.setState(true);
+            //mLabel dummy;
+            //frmImages.addNext(dummy=new mLabel(&quot;&quot;),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST|CellConstants.NORTH));
+            //dummy.setTag(TAG_INSETS,new Insets(0,0,2,0));
+            frmImages.addLast(chkDescShowImg = new CheckBox(MyLocale.getMsg(638,&quot;Show pictures in description&quot;)),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST|CellConstants.NORTH));
+            chkDescShowImg.setTag(TAG_INSETS,new Insets(0,0,2,0));
+            if (pref.descShowImg) chkDescShowImg.setState(true);
+            pnlDisplay.addLast(frmImages,CellConstants.STRETCH,CellConstants.FILL);
+
+            Frame frmHintLog=new Frame();
+            //frmHintLog.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_BOTTOM;
+            frmHintLog.addNext(new Label(MyLocale.getMsg(630,&quot;HintLogPanel:  Logs per page &quot;)),CellConstants.DONTSTRETCH,CellConstants.DONTFILL);
+            frmHintLog.addLast(inpLogsPerPage=new Input(),CellConstants.DONTSTRETCH,CellConstants.DONTFILL|CellConstants.EAST);
+            inpLogsPerPage.setText(Convert.toString(pref.logsPerPage));
+            inpLogsPerPage.setPreferredSize(40,-1);
+            //inpLogsPerPage.setTag(TAG_INSETS,new Insets(0,0,2,0));
+            //lblHlP.setTag(TAG_INSETS,new Insets(6,0,2,0));
+            frmHintLog.addNext(new Label(MyLocale.getMsg(633,&quot;Max. logs to spider&quot;)),CellConstants.DONTSTRETCH,CellConstants.DONTFILL);
+            frmHintLog.addLast(inpMaxLogsToSpider=new Input(),CellConstants.DONTSTRETCH,CellConstants.DONTFILL|CellConstants.EAST);
+            inpMaxLogsToSpider.setText(Convert.toString(pref.maxLogsToSpider));
+            inpMaxLogsToSpider.setPreferredSize(40,-1);
+            pnlDisplay.addLast(frmHintLog,CellConstants.STRETCH,CellConstants.FILL);
+
+            /////////////////////////////////////////////////////////
+            // Third panel - More
+            /////////////////////////////////////////////////////////
+            CellPanel pnlProxy=new CellPanel();
+            pnlProxy.addNext(new Label(&quot;Proxy&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            pnlProxy.addLast(Proxy = new Input(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST)).setTag(SPAN,new Dimension(2,1));
+            Proxy.setText(pref.myproxy);
+            pnlProxy.addNext(new Label(&quot;Port&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            pnlProxy.addLast(ProxyPort = new Input(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            ProxyPort.setText(pref.myproxyport);
+            pnlProxy.addNext(new Label(&quot;&quot;),HSTRETCH,HFILL);
+            pnlProxy.addLast(chkProxyActive=new CheckBox(MyLocale.getMsg(634,&quot;use Proxy&quot;)));
+            chkProxyActive.setState(pref.proxyActive);
+            pnlMore.addLast(pnlProxy,HSTRETCH,HFILL);
+            pnlMore.addNext(new Label(MyLocale.getMsg(592,&quot;Language (needs restart)&quot;)),DONTSTRETCH,DONTFILL|WEST);
+            String[] tmp = (new File(File.getProgramDirectory()+&quot;/languages&quot;).list(&quot;*.cfg&quot;, File.LIST_FILES_ONLY)); //&quot;*.xyz&quot; doesn't work on some systems -&gt; use FileBugFix
+            if (tmp == null) tmp = new String[0];
+            String [] langs = new String[tmp.length +1];
+            langs[0] = &quot;auto&quot;;
+            int curlang = 0;
+            for (int i = 0; i &lt; tmp.length; i++) {
+                    langs[i+1] = tmp[i].substring(0, tmp[i].lastIndexOf('.'));
+                    if (langs[i+1].equalsIgnoreCase(MyLocale.language)) curlang = i+1 ;
+            }
+            //ewe.sys.Vm.copyArray(tmp, 0, langs, 1, tmp.length);
+            pnlMore.addLast(inpLanguage=new Choice(langs, curlang),DONTSTRETCH,DONTFILL|WEST);
+            //inpLanguage.setPreferredSize(20,-1);
+            inpLanguage.setToolTip(MyLocale.getMsg(591,&quot;Select \&quot;auto\&quot; for system language or select your preferred language, e.g. DE or EN&quot;));
+
+            /////////////////////////////////////////////////////////
+            // Fourth/Fifth panel - Listview and Travelbugs
+            /////////////////////////////////////////////////////////
+
+    mTab.addCard(pnlGeneral,MyLocale.getMsg(621,&quot;General&quot;),null);
+            mTab.addCard(pnlDisplay,MyLocale.getMsg(622,&quot;Screen&quot;),null);
+            mTab.addCard(pnlMore,MyLocale.getMsg(632,&quot;More&quot;),null);
+            mTab.addCard(tccList=new TableColumnChooser(new String[] {
+                            MyLocale.getMsg(599,&quot;checkbox&quot;),
+                            MyLocale.getMsg(598,&quot;type&quot;),
+                            MyLocale.getMsg(606,&quot;Difficulty&quot;),
+                            MyLocale.getMsg(607,&quot;Terrain&quot;),
+                            MyLocale.getMsg(597,&quot;waypoint&quot;),
+                            MyLocale.getMsg(596,&quot;name&quot;),
+                            MyLocale.getMsg(608,&quot;Location&quot;),
+                            MyLocale.getMsg(609,&quot;Owner&quot;),
+                            MyLocale.getMsg(610,&quot;Hidden&quot;),
+                            MyLocale.getMsg(611,&quot;Status&quot;),
+                            MyLocale.getMsg(612,&quot;Distance&quot;),
+                            MyLocale.getMsg(613,&quot;Bearing&quot;),
+                            MyLocale.getMsg(635,&quot;Size&quot;),
+                            MyLocale.getMsg(636,&quot;OC Empfehlungen&quot;),
+                            MyLocale.getMsg(637,&quot;OC Index&quot;)},pref.listColMap),MyLocale.getMsg(595,&quot;List&quot;),null);
+
+            mTab.addCard(tccBugs=new TableColumnChooser(new String[] {
+                            MyLocale.getMsg(6000,&quot;Guid&quot;),
+                            MyLocale.getMsg(6001,&quot;Name&quot;),
+                            MyLocale.getMsg(6002,&quot;track#&quot;),
+                            MyLocale.getMsg(6003,&quot;Mission&quot;),
+                            MyLocale.getMsg(6004,&quot;From Prof&quot;),
+                            MyLocale.getMsg(6005,&quot;From Wpt&quot;),
+                            MyLocale.getMsg(6006,&quot;From Date&quot;),
+                            MyLocale.getMsg(6007,&quot;From Log&quot;),
+                            MyLocale.getMsg(6008,&quot;To Prof&quot;),
+                            MyLocale.getMsg(6009,&quot;To Wpt&quot;),
+                            MyLocale.getMsg(6010,&quot;To Date&quot;),
+                            MyLocale.getMsg(6011,&quot;To Log&quot;)},pref.travelbugColMap),&quot;T-bugs&quot;,null);
+
+            this.addLast(mTab);
+            cancelB = new Button(MyLocale.getMsg(614,&quot;Cancel&quot;));
+            cancelB.setHotKey(0, IKeys.ESCAPE);
+            addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+            applyB = new Button(MyLocale.getMsg(615,&quot;Apply&quot;));
+            applyB.setHotKey(0, IKeys.ACTION);
+            addLast(applyB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+    }
+
+    public void onEvent(Event ev){
+            if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+                    if (ev.target == cancelB){
+                            this.close(0);
+                    }
+                    if (ev.target == applyB){
+                            //if (pref.currProfile == 0){
+                                    //pref.curCentrePt.set(btnCentre.getText());
+                                    pref.baseDir = DataDir.getText();
+                            //}
+                            pref.fontSize = Convert.toInt(fontSize.getText());
+                            if (pref.fontSize&lt;6) pref.fontSize=11;
+                            pref.logsPerPage=Common.parseInt(inpLogsPerPage.getText());
+                            if (pref.logsPerPage==0) pref.logsPerPage=pref.DEFAULT_LOGS_PER_PAGE;
+                            pref.maxLogsToSpider=Common.parseInt(inpMaxLogsToSpider.getText());
+                            if (pref.maxLogsToSpider==0) pref.maxLogsToSpider=pref.DEFAULT_MAX_LOGS_TO_SPIDER;
+
+                            Font defaultGuiFont = Application.findFont(&quot;gui&quot;);
+                            int sz = (pref.fontSize);
+                            Font newGuiFont = new Font(defaultGuiFont.getName(), defaultGuiFont.getStyle(), sz);
+                            Application.addFont(newGuiFont, &quot;gui&quot;);
+                            Application.fontsChanged();
+                            Application.mainApp.font = newGuiFont;
+
+                            pref.myAlias = Alias.getText().trim();
+                            SpiderGC.passwort=pref.password= inpPassword.getText().trim();
+                            MyLocale.saveLanguage(MyLocale.language=inpLanguage.getText().toUpperCase().trim());
+                            pref.browser = Browser.getText();
+                            //Vm.debug(myPreferences.browser);
+                            pref.myproxy = Proxy.getText();
+                            pref.myproxyport = ProxyPort.getText();
+                            pref.proxyActive=chkProxyActive.getState();
+                            HttpConnection.setProxy(pref.myproxy, Common.parseInt(pref.myproxyport), pref.proxyActive); // TODO generate an error message if proxy port is not a number
+                            //myPreferences.nLogs = Convert.parseInt(nLogs.getText());
+                            pref.autoReloadLastProfile=chkAutoLoad.getState();
+                            pref.showDeletedImages=chkShowDeletedImg.getState();
+                            pref.garminConn=chcGarminPort.getSelectedItem().toString();
+                            pref.garminGPSBabelOptions=chkSynthShort.state?&quot;-s&quot;:&quot;&quot;;
+                            pref.menuAtTop=chkMenuAtTop.getState();
+                            pref.tabsAtTop=chkTabsAtTop.getState();
+                            pref.showStatus=chkShowStatus.getState();
+                            pref.hasCloseButton=chkHasCloseButton.getState();
+                            pref.travelbugColMap=tccBugs.getSelectedCols();
+                            pref.listColMap=tccList.getSelectedCols();
+                            pref.descShowImg=chkDescShowImg.getState();
+                            Global.mainTab.tbP.tModel.setColumnNamesAndWidths();
+                            pref.savePreferences();
+                            pref.dirty = true; // Need to update table in case columns were enabled/disabled
+                            this.close(0);
+                    }
+                    if(ev.target == brwBt){
+                            FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, pref.baseDir);
+                            fc.title=MyLocale.getMsg(616,&quot;Select directory&quot;);
+                            if(fc.execute() != FormBase.IDCANCEL)   DataDir.setText(fc.getChosen()+&quot;/&quot;);
+                    }
+                    if (ev.target == gpsB){
+                            GPSPortOptions gpo = new GPSPortOptions();
+                            gpo.portName = pref.mySPO.portName;
+                            gpo.baudRate = pref.mySPO.baudRate;
+                            Editor s = gpo.getEditor();
+                            gpo.forwardGpsChkB.setState(pref.forwardGPS);
+                            gpo.inputBoxForwardHost.setText(pref.forwardGpsHost);
+                            gpo.logGpsChkB.setState(pref.logGPS);
+                            gpo.inputBoxLogTimer.setText(pref.logGPSTimer);
+                            Gui.setOKCancel(s);
+                            if (s.execute()== FormBase.IDOK) {
+                                    pref.mySPO.portName = gpo.portName;
+                                    pref.mySPO.baudRate = gpo.baudRate;
+                                    pref.forwardGPS = gpo.forwardGpsChkB.getState();
+                                    pref.forwardGpsHost = gpo.inputBoxForwardHost.getText();
+                                    pref.logGPS = gpo.logGpsChkB.getState();
+                                    pref.logGPSTimer = gpo.inputBoxLogTimer.getText();
+                                    gpsB.setText(&quot;GPS: &quot; + pref.mySPO.portName+&quot;/&quot;+pref.mySPO.baudRate);
+                            }
+                    }
+            }
+            super.onEvent(ev);
+    }
+
+}
+
+

Added: experiments/EVE/src/cachewolf/Profile.java
===================================================================
--- experiments/EVE/src/cachewolf/Profile.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/Profile.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,626 @@
+package cachewolf;
+
+
+import java.io.BufferedWriter;
+import eve.io.File;
+import java.io.*;
+
+import eve.sys.Convert;
+import eve.sys.Handle;
+import eve.sys.Vm;
+import eve.ui.ProgressBarForm;
+import java.util.*;
+
+import cachewolf.navi.Area;
+import cachewolf.utils.Common;
+import cachewolf.utils.Extractor;
+import cachewolf.utils.SafeXML;
+
+
+/**
+ * This class holds a profile, i.e. a group of caches with a centre location
+ *
+ * @author salzkammergut
+ *
+ */
+public class Profile {
+	private static final int VERSION=1;  // The version of the raw data
+	/** The list of caches (CacheHolder objects). A pointer to this object exists in many classes in parallel to
+	 *  this object, i.e. the respective class contains both a {@link Profile} object and a cacheDB Vector.
+	 */
+	public Vector cacheDB=new Vector();
+	/** The centre point of this group of caches. Read from ans stored to index.xml file */
+	public CWPoint centre=new CWPoint();
+	/** The name of the profile. The baseDir in preferences is appended this name to give the dataDir where
+	 *  the index.xml and cache files live. (Excuse the English spelling of centre)     */
+	public String name=&quot;&quot;;
+	/** This is the directory for the profile. It contains a closing /.   	 */
+	public String dataDir=&quot;&quot;;
+	/** Last sync date for opencaching caches */
+	public String last_sync_opencaching = &quot;&quot;;
+	/** Distance for opencaching caches */
+	public String distOC = &quot;&quot;;
+	/** Distance for geocaching caches */
+	public String distGC = &quot;&quot;;
+
+	public final static boolean SHOW_PROGRESS_BAR = true;
+	public final static boolean NO_SHOW_PROGRESS_BAR = false;
+
+	// When extending the filter check &quot;normaliseFilters&quot;
+	// which ensures backward compatibility. Normally no change should be needed
+	public final static String FILTERTYPE=&quot;1111111111111111111&quot;;
+	public final static String FILTERROSE=&quot;1111111111111111&quot;;
+	public final static String FILTERVAR=&quot;11111111&quot;;
+	public final static String FILTERSIZE=&quot;111111&quot;;
+	public String filterType = FILTERTYPE;
+	public String filterRose = FILTERROSE;
+	public String filterSize = FILTERSIZE;
+	//filter settings for archived ... owner (section) in filterscreen
+	public String filterVar = FILTERVAR;
+	public String filterDist=&quot;L&quot;;
+	public String filterDiff=&quot;L&quot;;
+	public String filterTerr=&quot;L&quot;;
+	public boolean filterInverted=false;
+
+	public long filterAttrYes = 0l;
+	public long filterAttrNo = 0l;
+	public int filterActive = Filter.FILTER_INACTIVE;
+	public int filterAttrChoice = 0;
+	public boolean showBlacklisted=false;
+
+	public boolean selectionChanged = true; // (&quot;H&#228;ckchen&quot;) used by movingMap to get to knao if it should update the caches in the map
+	/** True if the profile has been modified and not saved
+	 * The following modifications set this flag: New profile centre, Change of waypoint data
+	 */
+	public boolean hasUnsavedChanges = false;
+
+	/** Directory for html export */
+	public String htmlExportDirectory=&quot;&quot;;
+	//TODO Add other settings, such as max. number of logs to spider
+	//TODO Add settings for the preferred mapper to allow for maps other than expedia and other resolutions
+
+	/**
+	 * Constructor for a profile
+	 *
+	 */
+	public Profile(){
+	}
+
+	/**
+	 * Clear the profile
+	 */
+	public void clearProfile() {
+		CacheHolder.removeAllDetails();
+		cacheDB.clear();
+		centre.set(-361,-361);
+		name=&quot;&quot;;
+		dataDir=&quot;&quot;;
+		last_sync_opencaching = &quot;&quot;;
+		distOC = &quot;&quot;;
+		distGC=&quot;&quot;;
+		hasUnsavedChanges=false;
+	}
+
+	/**
+	 *	Method to save the index.xml file that holds the total information
+	 *	on available caches in the database. The database is nothing else
+	 *	than the collection of caches in a directory.
+	 *
+	 *  Saves the index with the filter settings from Filter
+	 */
+/*	public void saveIndexRaw(boolean showprogress) {
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+		if(showprogress){
+			pbf.showMainTask = false;
+			pbf.setTask(h,&quot;Saving Index&quot;);
+			pbf.exec();
+		}
+		CacheHolder.saveAllModifiedDetails(); // this must be called first as it makes some calculations
+		DataOutputStream os;
+		CacheHolder ch;
+		createBackup(&quot;index.raw&quot;,&quot;indexraw.bak&quot;);
+		try{
+	        //detfile = new PrintWriter(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(dataDir + &quot;index.xml&quot;), &quot;UTF8&quot;))); //UTF8 not needed here
+			os = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(dataDir + &quot;index.raw&quot;)));
+		} catch (Exception e) {
+			Vm.debug(&quot;Problem creating index file &quot;+e.toString()+&quot;\nFilename=&quot;+dataDir + &quot;index.raw&quot;);
+			return;
+		}
+		CWPoint savedCentre=centre;
+		if (centre==null || !centre.isValid() || (savedCentre.latDec==0.0 &amp;&amp; savedCentre.lonDec==0.0)) savedCentre=Global.getPref().curCentrePt;
+
+		try{
+			os.writeInt(VERSION);
+			os.writeInt(cacheDB.size());
+			os.writeDouble(savedCentre.latDec);
+			os.writeDouble(savedCentre.lonDec);
+			//*detfile.print(&quot;    &lt;FILTER status = \&quot;&quot;+filterActive+(filterInverted?&quot;T&quot;:&quot;F&quot;)+
+			//		&quot;\&quot; rose = \&quot;&quot;+filterRose+&quot;\&quot; type = \&quot;&quot;+filterType+
+			//		&quot;\&quot; var = \&quot;&quot;+filterVar+&quot;\&quot; dist = \&quot;&quot;+filterDist.replace('&quot;',' ')+&quot;\&quot; diff = \&quot;&quot;+
+			//		filterDiff+&quot;\&quot; terr = \&quot;&quot;+filterTerr+&quot;\&quot; size = \&quot;&quot;+filterSize+&quot;\&quot; attributesYes = \&quot;&quot;+filterAttrYes+&quot;\&quot; attributesNo = \&quot;&quot;+filterAttrNo+&quot;\&quot; attributesChoice = \&quot;&quot;+filterAttrChoice+&quot;\&quot; /&gt;\n&quot;);
+
+			if(last_sync_opencaching == null || last_sync_opencaching.endsWith(&quot;null&quot;) || last_sync_opencaching.equals(&quot;&quot;)){
+				last_sync_opencaching = &quot;20050801000000&quot;;
+			}
+			if(distOC == null || distOC.endsWith(&quot;null&quot;) || distOC.equals(&quot;&quot;)){
+				distOC = &quot;0.0&quot;;
+			}
+			if(distGC == null || distGC.endsWith(&quot;null&quot;) || distGC.equals(&quot;&quot;)){
+				distGC = &quot;0.0&quot;;
+			}
+			os.writeUTF(&quot;    &lt;SYNCOC date = \&quot;&quot;+last_sync_opencaching+&quot;\&quot; dist = \&quot;&quot;+distOC+&quot;\&quot;/&gt;\n&quot;);
+			os.writeUTF(&quot;    &lt;SPIDERGC dist = \&quot;&quot;+distGC+&quot;\&quot;/&gt;\n&quot;);
+			if (htmlExportDirectory.length()&gt;0) os.writeUTF(&quot;    &lt;HTMLEXPORT dir=\&quot;&quot;+htmlExportDirectory+&quot;\&quot; /&gt;\n&quot;);
+			int size=cacheDB.size();
+			// Calculate the number of caches after which the progress bar is updated
+			// This is 1 percent of the total number, i.e. if size=1200 =&gt; update only after 12 caches
+			int progressInt=cacheDB.size()/100;
+			int nextProgress=0;
+			for(int i = 0; i&lt;size;i++){
+				if(showprogress &amp;&amp; i&gt;=nextProgress){
+					h.progress = (float)i/(float)size;
+					h.changed();
+					nextProgress+=progressInt;
+				}
+				ch = (CacheHolder)cacheDB.get(i);
+				if(ch.wayPoint.length()&gt;0)
+					os.writeUTF(ch.toXML());
+			}
+			os.close();
+			if(showprogress) pbf.exit(0);
+		}catch(IOException e){
+			Vm.debug(&quot;Problem writing to index file &quot;+e.toString());
+			if(showprogress) pbf.exit(0);
+		}
+		hasUnsavedChanges=false;
+	}
+*/
+	private void createBackup(String filename, String backupFilename) {
+		try {
+			File backup=new File(dataDir+backupFilename);
+			if (backup.exists()) backup.delete();
+			File index=new File(dataDir+filename);
+			index.rename(backupFilename);
+		} catch (Exception ex) {
+			Global.getPref().log(&quot;Error deleting backup or renaming &quot;+filename);
+		}
+	}
+
+	/**
+	 *	Method to save the index.xml file that holds the total information
+	 *	on available caches in the database. The database is nothing else
+	 *	than the collection of caches in a directory.
+	 *
+	 *  Saves the index with the filter settings from Filter
+	 */
+	public void saveIndex(boolean showprogress) {
+		eve.util.OperationTimer ot=new eve.util.OperationTimer();
+		ot.start(&quot;SAVEINDEX&quot;);
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+		if(showprogress){
+			pbf.showMainTask = false;
+			pbf.setTask(h,&quot;Saving Index&quot;);
+			pbf.exec();
+		}
+		CacheHolder.saveAllModifiedDetails(); // this must be called first as it makes some calculations
+		PrintWriter detfile;
+		CacheHolder ch;
+		createBackup(&quot;index.xml&quot;,&quot;index.bak&quot;);
+		try{
+	        //detfile = new PrintWriter(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(dataDir + &quot;index.xml&quot;), &quot;UTF8&quot;))); //UTF8 not needed here
+			detfile = new PrintWriter(new BufferedWriter(new FileWriter(dataDir + &quot;index.xml&quot;)));
+		} catch (Exception e) {
+			Vm.debug(&quot;Problem creating index file &quot;+e.toString()+&quot;\nFilename=&quot;+dataDir + &quot;index.xml&quot;);
+			return;
+		}
+		CWPoint savedCentre=centre;
+		if (centre==null || !centre.isValid() || (savedCentre.latDec==0.0 &amp;&amp; savedCentre.lonDec==0.0)) savedCentre=Global.getPref().curCentrePt;
+
+		try{
+			detfile.print(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;ISO-8859-1\&quot;?&gt;\n&quot;);
+			detfile.print(&quot;&lt;CACHELIST format=\&quot;decimal\&quot; size=\&quot;&quot;+cacheDB.size()+&quot;\&quot; /&gt;\n&quot;);
+			if (savedCentre.isValid())
+				detfile.print(&quot;    &lt;CENTRE lat=\&quot;&quot;+savedCentre.latDec+&quot;\&quot; lon=\&quot;&quot;+savedCentre.lonDec+&quot;\&quot;/&gt;\n&quot;);
+			if(last_sync_opencaching == null || last_sync_opencaching.endsWith(&quot;null&quot;) || last_sync_opencaching.equals(&quot;&quot;)){
+				last_sync_opencaching = &quot;20050801000000&quot;;
+			}
+			if(distOC == null || distOC.endsWith(&quot;null&quot;) || distOC.equals(&quot;&quot;)){
+				distOC = &quot;0.0&quot;;
+			}
+			if(distGC == null || distGC.endsWith(&quot;null&quot;) || distGC.equals(&quot;&quot;)){
+				distGC = &quot;0.0&quot;;
+			}
+			detfile.print(&quot;    &lt;FILTER status = \&quot;&quot;+filterActive+(filterInverted?&quot;T&quot;:&quot;F&quot;)+
+					&quot;\&quot; rose = \&quot;&quot;+filterRose+&quot;\&quot; type = \&quot;&quot;+filterType+
+					&quot;\&quot; var = \&quot;&quot;+filterVar+&quot;\&quot; dist = \&quot;&quot;+filterDist.replace('&quot;',' ')+&quot;\&quot; diff = \&quot;&quot;+
+					filterDiff+&quot;\&quot; terr = \&quot;&quot;+filterTerr+&quot;\&quot; size = \&quot;&quot;+filterSize+&quot;\&quot; attributesYes = \&quot;&quot;+filterAttrYes+&quot;\&quot; attributesNo = \&quot;&quot;+filterAttrNo+&quot;\&quot; attributesChoice = \&quot;&quot;+filterAttrChoice+&quot;\&quot; showBlacklist = \&quot;&quot;+showBlacklisted+&quot;\&quot; /&gt;\n&quot;);
+			detfile.print(&quot;    &lt;SYNCOC date = \&quot;&quot;+last_sync_opencaching+&quot;\&quot; dist = \&quot;&quot;+distOC+&quot;\&quot;/&gt;\n&quot;);
+			detfile.print(&quot;    &lt;SPIDERGC dist = \&quot;&quot;+distGC+&quot;\&quot;/&gt;\n&quot;);			int size=cacheDB.size();
+			if (htmlExportDirectory.length()&gt;0) detfile.print(&quot;    &lt;HTMLEXPORT dir=\&quot;&quot;+htmlExportDirectory+&quot;\&quot; /&gt;\n&quot;);
+			// Calculate the number of caches after which the progress bar is updated
+			// This is 1 percent of the total number, i.e. if size=1200 =&gt; update only after 12 caches
+			int progressInt=cacheDB.size()/100;
+			int nextProgress=0;
+			for(int i = 0; i&lt;size;i++){
+				if(showprogress &amp;&amp; i&gt;=nextProgress){
+					h.progress = (float)i/(float)size;
+					h.changed();
+					nextProgress+=progressInt;
+				}
+				ch = (CacheHolder)cacheDB.get(i);
+				if(ch.wayPoint.length()&gt;0)
+					detfile.print(ch.toXML());
+			}
+			detfile.print(&quot;&lt;/CACHELIST&gt;\n&quot;);
+			detfile.close();
+			if(showprogress) pbf.exit(0);
+		}catch(Exception e){
+			Vm.debug(&quot;Problem writing to index file &quot;+e.toString());
+			detfile.close();
+			if(showprogress) pbf.exit(0);
+		}
+		hasUnsavedChanges=false;
+		ot.end();
+		eve.sys.Vm.debug(ot.toString());
+	}
+
+	/**
+	 *	Method to read the index.xml file that holds the total information
+	 *	on available caches in the database. The database in nothing else
+	 *	than the collection of caches in a directory.
+	 */
+	public void readIndex(){
+		try {
+			selectionChanged = true;
+			boolean fmtDec=false;
+			char decSep=MyLocale.getDigSeparator().charAt(0);
+			char notDecSep=decSep=='.'?',':'.';
+			BufferedReader in = new BufferedReader(new FileReader(dataDir + &quot;index.xml&quot;));
+			in.readLine(); // &lt;?xml version= ...
+			String text=in.readLine(); // &lt;CACHELIST&gt;
+			if (text!=null) {
+				if (text.indexOf(&quot;decimal&quot;)&gt;0) fmtDec=true;
+				int i=text.indexOf(&quot;size=\&quot;&quot;);
+				int j=text.indexOf(&quot;\&quot;&quot;,i+7);
+				//if (i&gt;0 &amp;&amp; j&gt;i+6) cacheDB.ensureCapacity(Common.parseInt(text.substring(i+6,j)));
+			}
+			Extractor ex = new Extractor(null, &quot; = \&quot;&quot;, &quot;\&quot; &quot;, 0, true);
+
+			//eve.sys.Time startT=new eve.sys.Time();
+			while ((text = in.readLine()) != null){
+				// Check for Line with cache data
+				if (text.indexOf(&quot;&lt;CACHE &quot;)&gt;=0){
+					CacheHolder ch=new CacheHolder(text);
+					cacheDB.add(ch);
+				} else if (text.indexOf(&quot;&lt;CENTRE&quot;)&gt;=0) { // lat=  lon=
+					if (fmtDec) {
+						int start=text.indexOf(&quot;lat=\&quot;&quot;)+5;
+						String lat=text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)).replace(notDecSep,decSep);
+						start=text.indexOf(&quot;lon=\&quot;&quot;)+5;
+						String lon=text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)).replace(notDecSep,decSep);
+						centre.set(Convert.parseDouble(lat),Convert.parseDouble(lon));
+					} else {
+						int start=text.indexOf(&quot;lat=\&quot;&quot;)+5;
+						String lat=SafeXML.cleanback(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
+						start=text.indexOf(&quot;long=\&quot;&quot;)+6;
+						String lon=SafeXML.cleanback(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
+						centre.set(lat+&quot; &quot;+lon,CWPoint.CW); // Fast parse
+					}
+				} else if (text.indexOf(&quot;&lt;SYNCOC&quot;)&gt;=0) {
+					int start=text.indexOf(&quot;date = \&quot;&quot;)+8;
+					last_sync_opencaching=text.substring(start,text.indexOf(&quot;\&quot;&quot;,start));
+					start=text.indexOf(&quot;dist = \&quot;&quot;)+8;
+					distOC=text.substring(start,text.indexOf(&quot;\&quot;&quot;,start));
+				} else if (text.indexOf(&quot;&lt;SPIDERGC&quot;)&gt;=0) {
+					int start=text.indexOf(&quot;dist = \&quot;&quot;)+8;
+					distGC=text.substring(start,text.indexOf(&quot;\&quot;&quot;,start));
+				} else if (text.indexOf(&quot;&lt;FILTER&quot;)&gt;=0){
+					ex.setSource(text);
+					String temp=ex.findNext(); // Filter status is now first, need to deal with old versions which don't have filter status
+					if (temp.length()==2) {
+						// Compatibility with previous versions
+						if (temp.charAt(0)=='T')
+							filterActive=Filter.FILTER_ACTIVE;
+						else
+							filterActive=Common.parseInt(temp.substring(0,1));
+						filterInverted=temp.charAt(1)=='T';
+						filterRose = ex.findNext();
+					} else
+						filterRose = temp;
+					filterType = ex.findNext();
+					//Need this to stay &quot;downward&quot; compatible. New type introduced
+					//if(filterType.length()&lt;=17) filterType = filterType + &quot;1&quot;;
+					//Vm.debug(&quot;fil len: &quot; +filterType.length());
+					//This is handled by &quot;normaliseFilters&quot; which is called at the end.
+					filterVar = ex.findNext();
+					filterDist = ex.findNext();
+					filterDiff = ex.findNext();
+					filterTerr = ex.findNext();
+					filterSize = ex.findNext();
+					String attr = ex.findNext();
+					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
+						filterAttrYes = Convert.parseLong(attr);
+					attr = ex.findNext();
+					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
+						filterAttrNo = Convert.parseLong(attr);
+					attr = ex.findNext();
+					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
+						filterAttrChoice = Convert.parseInt(attr);
+					attr = ex.findNext();
+					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
+						showBlacklisted = new Boolean(attr).booleanValue();
+					else
+						showBlacklisted = false;
+				} else if (text.indexOf(&quot;&lt;HTMLEXPORT&quot;)&gt;=0) {
+					int start=text.indexOf(&quot;dir = \&quot;&quot;)+8;
+					htmlExportDirectory=text.substring(start,text.indexOf(&quot;\&quot;&quot;,start));
+				}
+			}
+			in.close();
+			buildReferences();
+			hasUnsavedChanges = false;
+		} catch (FileNotFoundException e) {
+			Global.getPref().log(&quot;index.xml not found in directory &quot;+dataDir); // Normal when profile is opened for first time
+			//e.printStackTrace();
+		} catch (IOException e){
+			Global.getPref().log(&quot;Problem reading index.xml in dir: &quot;+dataDir,e,true);
+		}
+		normaliseFilters();
+	}
+
+    /** Restore the filter to the values stored in this profile
+     *  Called from Main Form and MainMenu
+     *  The values of Filter.isActive and Filter.isInactive are set by the filter
+     **/
+    void restoreFilter() {
+            restoreFilter( false );
+    }
+
+    void restoreFilter(boolean clearIfInactive) {
+            boolean inverted=filterInverted; // Save it as doFilter will clear filterInverted
+            Filter flt=new Filter();
+            if (filterActive==Filter.FILTER_ACTIVE) {
+                    flt.setFilter();
+                    flt.doFilter();
+                    if (inverted) {
+                            flt.invertFilter();
+                            filterInverted=true; // Needed because previous line inverts filterInverted
+                    }
+            } else if (filterActive==Filter.FILTER_CACHELIST) {
+                    Global.mainForm.cacheList.applyCacheList();
+                    //flt.filterActive=filterActive;
+            } else if (filterActive==Filter.FILTER_INACTIVE) {
+                    if (clearIfInactive) {
+                            flt.clearFilter();
+                    }
+            }
+    }
+
+    void checkBlacklistStatus() {
+        Vector cacheDB=Global.getProfile().cacheDB;
+        CacheHolder ch;
+        boolean filterChanged = false;
+        for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+                ch = (CacheHolder)cacheDB.get(i);
+                if (ch.is_black^showBlacklisted) {
+                        ch.is_filtered = true;
+                        filterChanged = true;
+                }
+        }
+        if ( filterChanged ) {
+                selectionChanged = true;
+                hasUnsavedChanges=true;
+        }
+}
+
+	public int getCacheIndex(String wp){
+		int retval = -1;
+		CacheHolder ch;
+		for(int i = 0; i&lt;cacheDB.size();i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			if(ch.wayPoint.equals(wp)){
+				return i;
+			}
+		}
+		return retval;
+	}
+
+	/** Get a unique name for a new waypoint */
+	//TODO Make more efficient
+	public String getNewWayPointName(){
+		String strWp=null;
+		long  lgWp=1;
+		int s = cacheDB.size();
+		if (s ==0 )
+			return &quot;CW0000&quot;;
+		//Create new waypoint,look if not in db
+		for(int i = 0;i &lt; s;i++){
+			strWp = &quot;CW&quot; + MyLocale.formatLong(lgWp, &quot;0000&quot;);
+			if(((CacheHolder)cacheDB.get(i)).wayPoint.indexOf(strWp) &gt;=0 ){
+				//waypoint exists in database
+				lgWp++;
+				i = -1; // Because i++ will be executed next, so we start the loop with 0
+			}
+		}
+		return strWp;
+	}
+
+	/**
+	 *
+	 * @param forcache maincache
+	 * @return
+	 */
+	public String getNewAddiWayPointName(String forcache) {
+		int wptNo=-1;
+		String waypoint;
+		do {
+			waypoint=MyLocale.formatLong(++wptNo,&quot;00&quot;)+forcache.substring(2);
+		} while (getCacheIndex(waypoint)&gt;=0);
+		return waypoint;
+	}
+
+	/**
+	 * Call this after getNewAddiWayPointName to set the references between main and addi correctly
+	 * @param ch
+	 */
+	public void setAddiRef(CacheHolder ch) {
+		String mainwpt = ch.wayPoint.substring(2);
+		int mainindex = getCacheIndex(&quot;GC&quot;+mainwpt);
+		if (mainindex &lt; 0) mainindex = getCacheIndex(&quot;OC&quot;+mainwpt);
+		if (mainindex &lt; 0) mainindex = getCacheIndex(&quot;CW&quot;+mainwpt);
+		if (mainindex &lt; 0) throw new IllegalArgumentException(&quot;no main cache found for: &quot; + ch.wayPoint);
+		CacheHolder mainch = (CacheHolder)cacheDB.get(mainindex);
+		mainch.addiWpts.add(ch);
+		ch.mainCache = mainch;
+	}
+
+
+/*	public String toString() {
+		return &quot;Profile: Name=&quot;+name+&quot;\nCentre=&quot;+centre.toString()+&quot;\ndataDir=&quot;+dataDir+&quot;\nlastSyncOC=&quot;+
+		last_sync_opencaching+&quot;\ndistOC=&quot;+distOC+&quot;\ndistGC=&quot;+distGC;
+	}
+*/
+	/**
+	 * Sets the selected status of all caches
+	 * @param selectStatus The value of the select status to set
+	 */
+	public void setSelectForAll(boolean selectStatus) {
+		selectionChanged = true;
+		CacheHolder ch;
+		for(int i = cacheDB.size()-1; i &gt;=	0; i--){
+			ch = (CacheHolder)cacheDB.get(i);
+			if (ch.is_filtered == false) ch.is_Checked = selectStatus;
+		}
+	}
+
+
+	public int numCachesInArea; // only valid after calling getSourroundingArea
+	public Area getSourroundingArea(boolean onlyOfSelected) {
+		if (cacheDB == null || cacheDB.size() == 0) return null;
+		CacheHolder ch;
+		CWPoint topleft = null;
+		CWPoint bottomright = null;
+		CWPoint tmpca = new CWPoint();
+		numCachesInArea = 0;
+		boolean isAddi = false;
+		for (int i=cacheDB.size()-1; i &gt;= 0; i--) {
+			ch = (CacheHolder) cacheDB.get(i);
+			if (!onlyOfSelected || ch.is_Checked) {
+				if (ch.pos == null) { // this can not happen
+					tmpca.set(ch.latLon);
+					ch.pos = new CWPoint(tmpca);
+				}
+				if (ch.pos.isValid() ){ // done: &amp;&amp; ch.pos.latDec != 0 &amp;&amp; ch.pos.lonDec != 0 TO-DO != 0 sollte rausgenommen werden sobald in der Liste vern&#252;nftig mit nicht gesetzten pos umgegangen wird
+					isAddi = ch.isAddiWpt();
+				if (!isAddi || (isAddi &amp;&amp; ch.mainCache != null &amp;&amp; ch.pos.getDistance(ch.mainCache.pos) &lt; 1000)) { // test for plausiblity of coordinates of Additional Waypoints: more then 1000 km away from main Waypoint is unplausible -&gt; ignore it // &amp;&amp; ch.mainCache != null is only necessary because the data base may be corrupted
+						if (topleft == null) topleft = new CWPoint(ch.pos);
+						if (bottomright == null) bottomright = new CWPoint(ch.pos);
+						if (topleft.latDec &lt; ch.pos.latDec) topleft.latDec = ch.pos.latDec;
+						if (topleft.lonDec &gt; ch.pos.lonDec) topleft.lonDec = ch.pos.lonDec;
+						if (bottomright.latDec &gt; ch.pos.latDec) bottomright.latDec = ch.pos.latDec;
+						if (bottomright.lonDec &lt; ch.pos.lonDec) bottomright.lonDec = ch.pos.lonDec;
+						numCachesInArea++;
+					}
+				}
+			}
+		}
+		if (topleft != null &amp;&amp; bottomright != null)
+			return new Area(topleft, bottomright);
+		return null;
+	}
+
+	/**
+	 *	Method to calculate bearing and distance of a cache in the index
+	 *	list.
+	 *	@see	CacheHolder
+	 *	@see	Extractor
+	 */
+	public void updateBearingDistance(){
+		CWPoint centerPoint = Global.getPref().curCentrePt;
+		int anz = cacheDB.size();
+		CacheHolder ch;
+		while(--anz &gt;= 0){
+			ch = (CacheHolder)cacheDB.get(anz); // This returns a pointer to the CacheHolder object
+			ch.calcDistance(centerPoint);
+		}
+	} //updateBearingDistance
+
+	/**
+	 * Method to build the reference between addi wpt
+	 * and main cache.
+	 */
+	public void buildReferences(){
+		CacheHolder ch, mainCh;
+		Hashtable dbIndex = new Hashtable((int)(cacheDB.size()/0.75f + 1), 0.75f); // initialise so that no rehashing is neccessary
+
+		Integer index;
+		// Build index for faster search and clear all references
+		for(int i = cacheDB.size() -1; i &gt;= 0;i--){
+			ch = (CacheHolder)cacheDB.get(i);
+			ch.addiWpts.clear();
+			ch.mainCache = null;
+			// if (ch.wayPoint.startsWith(&quot;GC&quot;)) // Only put potential master caches into the index
+				dbIndex.put(ch.wayPoint, new Integer(i));
+		}
+		// Build references
+		int max = cacheDB.size();
+		for(int i =  0; i &lt; max ;i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			if (ch.isAddiWpt()) {
+				//search main cache
+				index = (Integer) dbIndex.get(&quot;GC&quot;+ ch.wayPoint.substring(2));
+				if (index == null)  // TODO save the source (GC or OC or Custom) of the maincache somewhere else to avoid ambiguity of addi-wpt-names
+					index = (Integer) dbIndex.get(&quot;OC&quot;+ ch.wayPoint.substring(2));
+				if (index == null)  // TODO save the source (GC or OC or Custom) of the maincache somewhere else to avoid ambiguity of addi-wpt-names
+					index = (Integer) dbIndex.get(&quot;CW&quot;+ ch.wayPoint.substring(2));
+
+				if (index != null) {
+					mainCh = (CacheHolder) cacheDB.get(index.intValue());
+					mainCh.addiWpts.add(ch);
+					ch.mainCache = mainCh;
+					ch.setAttributesFromMainCache(mainCh);
+				}// if
+			}// if
+		}// for
+		// sort addi wpts for each cache in ascending order
+		for(int i =  0; i &lt; max ;i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			if (ch.hasAddiWpt() &amp;&amp; (ch.addiWpts.size()&gt; 1)){
+				//ch.addiWpts.sort(new MyComparer(ch.addiWpts,MyLocale.getMsg(1002,&quot;Waypoint&quot;),ch.addiWpts.size()), false);
+				eve.util.Utils.sort(new Handle(),ch.addiWpts,
+						new eve.util.Comparer() {
+							public int compare(Object o1, Object o2){
+								return ((CacheHolder) o1).wayPoint.compareTo(((CacheHolder)o2).wayPoint);
+							}
+						},false );
+			}
+		}
+
+	}
+
+
+	/** Ensure that all filters have the proper length so that the 'charAt' access in the filter
+	 * do not cause nullPointer Exceptions
+	 */
+	private void normaliseFilters() {
+		String manyOnes=&quot;11111111111111111111111111111&quot;;
+		if (filterRose.length()&lt;FILTERROSE.length()) {
+			filterRose=(filterRose+manyOnes).substring(0,FILTERROSE.length());
+		}
+		if (filterVar.length()&lt;FILTERVAR.length()) {
+			filterVar=(filterVar+manyOnes).substring(0,FILTERVAR.length());
+		}
+		if (filterType.length()&lt;FILTERTYPE.length()) {
+			filterType=(filterType+manyOnes).substring(0,FILTERTYPE.length());
+		}
+		if (filterSize.length()&lt;FILTERSIZE.length()) {
+			filterSize=(filterSize+manyOnes).substring(0,FILTERSIZE.length());
+		}
+		if (filterDist.length()==0) filterDist=&quot;L&quot;;
+		if (filterDiff.length()==0) filterDiff=&quot;L&quot;;
+		if (filterTerr.length()==0) filterTerr=&quot;L&quot;;
+	}
+
+}

Added: experiments/EVE/src/cachewolf/ProfilesForm.java
===================================================================
--- experiments/EVE/src/cachewolf/ProfilesForm.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/ProfilesForm.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,147 @@
+package cachewolf;
+
+import eve.ui.*;
+import eve.io.*;
+import eve.sys.*;
+import eve.fx.*;
+import eve.fx.gui.IKeys;
+import eve.ui.event.ControlEvent;
+
+
+/**
+*	This form displays the list of profiles for a user to choose from,
+*	when CacheWolf starts up. Also allows to open a new profile.
+*	ClassID = 1300
+*/
+public class ProfilesForm extends Form{
+
+	// A subclassed mList which allows the highlighting of an entry
+	// Maybe there is an easier way of making this happen, but I could not find it.
+	private class MyList extends List {
+		private int first=1;
+		private int select;
+
+		public MyList() {
+			super(1,1,false);
+		}
+
+		public void selectLastProfile(String selectedItem) {
+			selectItem(selectedItem);
+			select=getSelectedIndex(0);
+		}
+
+		public void doPaint(Graphics gr,Rect area) {
+			if (first==1) {
+				first=0;
+				selectAndView(select);
+				makeVisible(select);
+			}
+			super.doPaint(gr,area);
+		}
+
+		// Copied from BasicList.getScrollablePanel(), but exchanging
+		// the standard scroll bar with the fontsize sensitive one.
+		public ScrollablePanel getScrollablePanel() {
+			dontAutoScroll = amScrolling = true;
+			ScrollablePanel sp = new MyScrollBarPanel(this);
+			sp.modify(0,TakeControlEvents);
+			return sp;
+		}
+	}
+
+	private MyList choice;
+	private ScrollablePanel spMList;
+	private Button btnCancel,btnNew,btnOK;
+	private String baseDir;
+	public String newSelectedProfile;	// This is only used if a new profile is being created
+
+	/**
+	*	Constructor to create a form to select profiles. It requires that the preferences
+	*	have been loaded so that the calling parameters can be set.
+	* @param baseDir The base directory which holds one subdirectory per profile
+	* @param oldProfiles List of names of old profiles
+	* @param selectedProfile Name of the last used profile
+	*/
+	public ProfilesForm(String baseDir, String selectedProfile, boolean hasNewButton){
+		super();
+    	resizable =  false;
+		int w=MyLocale.getScreenWidth();
+		if (w&gt;240) w=240;
+		int h=MyLocale.getScreenHeight();
+		if (h&gt;320) h=320;
+		setPreferredSize(w,h);
+	    defaultTags.set(CellConstants.TAG_INSETS,new Insets(2,2,2,2));
+		title = MyLocale.getMsg(1301,&quot;Select Profile:&quot;);
+		if (hasNewButton) {
+			addNext(new Label(MyLocale.getMsg(1106,&quot;Choose profile or New&quot;)),DONTSTRETCH,DONTSTRETCH|LEFT);
+			addLast(btnNew=new Button(MyLocale.getMsg(1107,&quot;New&quot;)),HSTRETCH,HFILL|RIGHT);
+		} else {
+			addLast(new Label(MyLocale.getMsg(1108,&quot;Choose profile&quot;)),DONTSTRETCH,DONTSTRETCH|LEFT);
+		}
+
+		choice=new MyList();
+		// Get all subdirectories in the base directory
+		File fileBaseDir=new File(baseDir);
+		String[] existingProfiles=fileBaseDir.list(&quot;*.*&quot;,File.LIST_DIRECTORIES_ONLY);
+        // Now add these subdirectories to the list of profiles but
+        // exclude the &quot;maps&quot; directory which will contain the moving maps
+        for (int i=0; i&lt;existingProfiles.length; i++)
+			if (!existingProfiles[i].equals(&quot;maps&quot;)) choice.addItem(existingProfiles[i]);
+        // Highlight the profile that was used last
+        choice.selectLastProfile(selectedProfile);
+        // Add a scroll bar to the list of profiles
+		spMList=choice.getScrollablePanel();
+		spMList.setOptions(ScrollablePanel.NeverShowHorizontalScrollers);
+		choice.setServer(spMList);
+		addLast(spMList);
+		addNext(btnCancel = new Button(MyLocale.getMsg(1604,&quot;Cancel&quot;)),DONTSTRETCH,DONTFILL|LEFT);
+		addNext(btnOK = new Button(MyLocale.getMsg(1605,&quot;OK&quot;)),DONTSTRETCH,HFILL|RIGHT);
+		if (choice.getListItems().length==0) btnOK.modify(Disabled,0);
+		btnOK.setHotKey(0, IKeys.ENTER);
+		btnCancel.setHotKey(0, IKeys.ESCAPE);
+		this.baseDir=baseDir;
+		choice.takeFocus(Control.ByKeyboard);
+	}
+
+	/**
+	 * Ask for a new profile directory. If it exists, cancel. If it does not exist, create it
+	 * @return Name of directory (just the part below baseDir)
+	 */
+	public String createNewProfile() {
+		NewProfileForm f=new NewProfileForm(baseDir);
+	    int code=f.execute(getFrame(), Gui.CENTER_FRAME);
+		if (code==0) {
+			 return f.profileDir;
+		}
+		return &quot;&quot;;
+	}
+
+	/**
+	*	The event handler to react to a users selection.
+	*	A return value is created and passed back to the calling form
+	*	while it closes itself.
+	*/
+	public void onEvent(Event ev){
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (ev.target == btnCancel){
+				close(-1);
+			}
+			if (ev.target == btnOK || ev.target == choice){
+				Global.getProfile().filterActive=Filter.FILTER_INACTIVE;
+				Global.getProfile().filterInverted=false;
+				if (choice.getSelectedItem()!=null) {
+					newSelectedProfile=choice.getSelectedItem().toString();
+					close(1);
+				}
+			}
+			if (ev.target == btnNew){
+				if (NewProfileWizard.startNewProfileWizard(getFrame()) ) {
+					newSelectedProfile = Global.getProfile().name;
+					close(1);
+				}
+			}
+		}
+		super.onEvent(ev);
+	}
+
+}

Added: experiments/EVE/src/cachewolf/RadarPanel.java
===================================================================
--- experiments/EVE/src/cachewolf/RadarPanel.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/RadarPanel.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,471 @@
+package cachewolf;
+import eve.ui.Button;
+import eve.ui.Panel;
+import eve.ui.CellPanel;
+import eve.ui.CellConstants;
+import eve.ui.List;
+import eve.ui.DragContext;
+import eve.ui.Gui;
+import eve.ui.Control;
+import java.util.Vector;
+import eve.fx.Color;
+import eve.fx.Dimension;
+import eve.fx.Font;
+import eve.fx.FontMetrics;
+import eve.fx.Image;
+import eve.fx.Graphics;
+import eve.fx.Picture;
+import eve.fx.Rect;
+import eve.fx.Point;
+
+import eve.fx.IconAndText;
+import eve.sys.Event;
+import eve.sys.Vm;
+import eve.sys.Device;
+import eve.ui.game.AniImage;
+import eve.ui.game.ImageDragContext;
+import eve.ui.game.InteractivePanel;
+import eve.ui.event.ControlEvent;
+import eve.ui.event.PenEvent;
+
+/**
+*	The radar panel. Displays the caches around a centre point.&lt;br&gt;
+*	Handles scaling as well as toggling the different views in the radar panel.&lt;br&gt;
+*	Also handles clicking on a cache.&lt;br&gt;
+*/
+public class RadarPanel extends CellPanel{
+	private Button btMinus = new Button(&quot;   -   &quot;);
+	private Button btToggle = new Button(&quot;Toggle&quot;);
+	private Button btPlus = new Button(&quot;   +   &quot;);
+	private int toggleMod = 0; //0 = cacheicons, 1= cacheWP, 2 = cacheNames
+	private Vector cacheDB;
+	private InterActiveRadarPanel iActP;
+	private double scale;
+	private int scaleKm = 30;
+	private int centerX, centerY;
+	private int height, width;
+	private static Color RED=new Color(255,0,0);
+	private static Color GREEN=new Color(0,255,0);
+	private static Color BLUE=new Color(0,0,255);
+	private static Color YELLOW=new Color(255,255,0);
+	private AniImage circle=null;
+	/** Flag to indicate that the background and all caches needs to be redrawn */
+	private static Boolean redrawCaches=true;
+	/**
+	* Constructor for the radar panel.
+	* Loads images, sets up the interactive panel and
+	* &quot;navigation&quot; buttons.
+	*/
+	public RadarPanel(){
+		this.addLast(iActP = new InterActiveRadarPanel(), CellConstants.STRETCH, CellConstants.FILL);
+		Panel cp = new Panel();
+		cp.stretchFirstRow=true;
+		cp.equalWidths=true;
+		cp.addNext(btMinus,CellConstants.HSTRETCH, (CellConstants.FILL|CellConstants.WEST));
+		cp.addNext(btToggle,CellConstants.HSTRETCH, CellConstants.FILL);
+		cp.addLast(btPlus,CellConstants.HSTRETCH, (CellConstants.FILL|CellConstants.EAST));
+		this.addLast(cp, CellConstants.HSTRETCH, CellConstants.FILL);
+		clearRadarPanel();
+		cacheDB=Global.getProfile().cacheDB;
+	}
+	
+	public void clearRadarPanel() {
+		int anz = iActP.images.size();
+		for(int i = 0; i&lt;anz;i++){
+			iActP.removeImage((AniImage)iActP.images.get(0));
+		}
+		drawBackground();
+		iActP.refresh();
+		redrawCaches=true;
+	}
+	
+	/**
+	* Public method to draw the different caches and the
+	* radar background
+	*/
+	public void drawCachesAndCircle(){
+		// If there are any images remove them!
+		if (redrawCaches) {
+			drawCaches();
+			redrawCaches=false;
+		}
+		drawCircle();
+		iActP.repaintNow();
+	}
+	
+	/**
+	* Private method to draw the caches.
+	*/
+	private void drawCaches(){
+		Font font = new Font(&quot;Gui&quot;, Font.BOLD,Global.getPref().fontSize);
+		FontMetrics fm = getFontMetrics(font);
+		AniImage aImg;
+		RadarPanelImage rpi;
+		int x,y = 0;
+		CacheHolder ch;
+		double degrees;
+		double pi180=java.lang.Math.PI / 180.0;
+		for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+			ch = (CacheHolder)cacheDB.get(i);
+			if(!ch.is_filtered &amp;&amp; ch.pos.isValid()) {
+				degrees = ch.degrees * pi180;
+				x = (int) (ch.kilom/scale *  java.lang.Math.sin(degrees));
+				y = -(int)(ch.kilom/scale *  java.lang.Math.cos(degrees));
+				if(centerX+x&gt;=0 &amp;&amp; centerY+y&gt;=0 &amp;&amp; centerX+x&lt;=width &amp;&amp; centerY+y &lt;= height){
+					if (toggleMod&gt;0) {
+						String s;
+						if (toggleMod==1)
+							s=ch.wayPoint;
+						else
+							s=ch.cacheName;
+						if (s.length()&gt;0) { 
+							int tw;
+							Image img = new Image(tw=fm.getTextWidth(s),fm.getHeight());
+							Graphics g = new Graphics(img);
+							g.setFont(font);
+							g.setColor(Color.Black);
+							g.fillRect(0,0,tw, fm.getHeight());
+							g.setColor(Color.White);
+							g.drawText(s, 0,0);
+							aImg = new AniImage(img,Color.Black);
+							aImg.setLocation(centerX+x+5,centerY+y);
+							aImg.properties = eve.fx.Drawing.IsNotHot;
+							iActP.addImage(aImg);
+						}
+					}
+					Picture imgCache=CacheType.cache2Img(ch.type);
+					// If we have no image for the cache type use a question mark
+					if (imgCache==null) imgCache=CacheType.cachePictures[8]; 
+					rpi = new RadarPanelImage(imgCache);
+					rpi.wayPoint = ch.wayPoint;
+					rpi.rownum = i;
+					rpi.setLocation(centerX+x-7,centerY+y-7);
+					iActP.addImage(rpi);
+				}//if center...
+			}// if is_black...
+		}
+	}
+	
+	public void removeCircle() {
+		if (circle!=null) iActP.removeImage(circle);
+		circle=null; 
+	}
+	
+	private void drawCircle() {
+		removeCircle();
+		double pi180=java.lang.Math.PI / 180.0;
+		CacheHolder ch = (CacheHolder)cacheDB.get(Global.mainTab.tbP.getSelectedCache());
+		if(!ch.is_filtered &amp;&amp; ch.pos.isValid()) {
+			double degrees = ch.degrees * pi180;
+			int x = (int) (ch.kilom/scale *  java.lang.Math.sin(degrees));
+			int y = -(int)(ch.kilom/scale *  java.lang.Math.cos(degrees));
+			Image imgCircle = new Image(20, 20);
+			Graphics gCircle = new Graphics(imgCircle);
+			gCircle.setColor(Color.Black);
+			gCircle.fillRect(0,0,20,20);
+			gCircle.setColor(RED);
+			gCircle.drawEllipse(0,0, 19,19);
+			circle = new AniImage(imgCircle,Color.Black);
+			circle.properties = eve.fx.Drawing.IsNotHot;
+			circle.setLocation(centerX+x-9,centerY+y-9);
+			iActP.addImage(circle); 
+		}
+	}
+	/**
+	* Private method to draw the black background and green radar.
+	* Also calculates some other parameters.
+	* Always call this before calling drawCaches().
+	*/
+	private void drawBackground(){
+		width=MyLocale.getScreenWidth();
+		height=MyLocale.getScreenHeight();
+		Rect r = new Rect(new Dimension(width, height));
+		iActP.virtualSize = r;
+		iActP.refresh();
+		Image img = new Image(width, height);
+		Graphics g = new Graphics(img);
+		g.setColor(Color.Black);
+		//Vm.debug(Convert.toString(height));
+		g.fillRect(0,0,width, height);
+		
+		
+		if(width &lt; height) {
+			scale = (double)scaleKm / (double)height;
+		} else {
+			scale = (double)scaleKm / (double)width;
+		}
+		centerX = width / 2;
+		centerY = height / 2;
+		//centerY = (int)(centerY-centerY*0.15);
+		g.setColor(GREEN);
+		int radstep= 0, steps=0, radius = 0;
+		
+		if(width &gt; height){
+			radstep = (int)(10 / scale);
+			steps = width / radstep;
+		}else{
+			radstep = (int)(10 / scale);
+			steps = height / radstep;
+		}
+		for(int i = 1; i &lt;= steps; i++){
+			radius = (radstep * i)*2;
+			//Vm.debug(&quot;Draw: &quot; + Convert.toString(scale));
+			g.drawEllipse(centerX-radius/2,centerY-radius/2, radius,radius);
+		}
+		g.drawLine(centerX,0,centerX,height);
+		g.drawLine(0,centerY,width,centerY);
+
+		// Show 1 KM radius only if we have zoomed in (useful for cities with high density of caches)
+		if (scaleKm&lt;=20) {
+			g.setColor(YELLOW); // Yellow for 1km circle
+			radius = radstep/5;
+			g.drawEllipse(centerX-radius/2,centerY-radius/2, radius,radius);
+			g.free();
+		}	
+		AniImage aImg = new AniImage(img);
+		iActP.backgroundImage = img;
+		aImg.refresh();
+	}
+	
+	public void onEvent(Event ev){
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (ev.target == btPlus){
+				if (scaleKm&gt;10) scaleKm = scaleKm - 10;
+				else if (scaleKm==10) scaleKm=5;
+				else if (scaleKm==5) scaleKm=2;
+				else scaleKm=1;
+				clearRadarPanel();
+				drawCachesAndCircle();
+			}
+			if (ev.target == btMinus){
+				if (scaleKm==1) scaleKm=2;
+				else if(scaleKm==2) scaleKm=5;
+				else if(scaleKm==5) scaleKm=10;
+				else scaleKm = scaleKm + 10;
+				clearRadarPanel();
+				drawCachesAndCircle();
+			}
+			if (ev.target == btToggle){
+				toggleMod++;
+				if(toggleMod &gt; 2) toggleMod = 0;
+				clearRadarPanel();
+				drawCachesAndCircle();
+			}
+		}
+
+	}
+	
+	public void resizeTo(int width, int height) {
+		eve.sys.Vm.debug(&quot;RadarP: resize: &quot;+width+&quot;,&quot;+height);
+		iActP.origin.x=(MyLocale.getScreenWidth()-width)/2;
+		iActP.origin.y=(MyLocale.getScreenHeight()- height)/2;
+		repaint();
+		super.resizeTo(width, height);
+	}
+
+//################################################################################
+//   InteractiveRadarPanel
+//################################################################################
+	
+	/**
+	*	This class allows handling of a user click on a cache
+	*	in the radar panel.
+	*	@see RadarPanel
+	*/
+	private static class InterActiveRadarPanel extends InteractivePanel{
+		Font font = new Font(&quot;gui&quot;, Font.BOLD,Global.getPref().fontSize);
+		FontMetrics fm = getFontMetrics(font);
+		long timePenOn=0;
+		AniImage imgInfo;
+		String strDifficulty=MyLocale.getMsg(1120,&quot;Diff&quot;);
+		String strTerrain=MyLocale.getMsg(1121,&quot;Terr&quot;);
+		AniImage imgDrag; // Allows the dragging of the cache into the cachelist
+		boolean canScroll=true;
+		
+		private void clearInfo() {
+			removeImage(imgInfo);
+			imgInfo=null;
+			refresh();
+			onImage=null;
+		}
+		
+		public void imageClicked(AniImage which, Point pos){
+			long timePenOff=Vm.getTimeStampLong();
+			// If the pen rested more than 500 msec, we only display the info and don't treat it as a click
+			if (timePenOff-timePenOn&lt;500 || !Device.isMobile()) { 
+				if(which instanceof RadarPanelImage){
+					RadarPanelImage ich = (RadarPanelImage)which;
+					Global.mainTab.clearDetails();
+					Global.mainTab.selectAndActive(ich.rownum);
+				}
+			} else {
+				if (imgInfo!=null) clearInfo(); 
+			}
+		}
+		
+		public boolean imageMovedOn(AniImage which) {
+			timePenOn=Vm.getTimeStampLong();
+			setFont(font);
+			RadarPanelImage imgRP=(RadarPanelImage) which;
+			java.util.Vector cacheDB=Global.getProfile().cacheDB;
+			CacheHolder ch=(CacheHolder) cacheDB.get(imgRP.rownum);
+			String s=ch.wayPoint+&quot;  &quot;+ch.cacheSize+&quot; / &quot;+strDifficulty+&quot;=&quot;+ch.hard+&quot;  &quot;+strTerrain+&quot;=&quot;+ch.terrain;
+			String s1=ch.cacheName;
+			if (s1.length()&gt;40) s1=s1.substring(0,40);
+			int tw=fm.getTextWidth(s)+2;
+			int tw1=fm.getTextWidth(s1)+2;
+			if (tw1&gt;tw) tw=tw1;
+			int h=fm.getHeight();
+			Image img = new Image(tw,h+h);
+			Graphics g = new Graphics(img);
+			g.setFont(font);
+			g.setColor(BLUE);
+			g.fillRect(0,0,tw, h+h);
+			g.setColor(Color.White);
+			g.drawText(s, 1,1);
+			g.drawText(s1,1,h);
+			imgInfo = new AniImage(img);
+			Rect r=getVisibleArea(null);
+			imgInfo.setLocation(r.x,r.y); // Place the info at top left corner
+			imgInfo.properties = eve.fx.Drawing.IsNotHot;
+			addImage(imgInfo);
+			refreshOnScreen(imgInfo);
+			imgDrag=which;
+		return true;
+		}
+		
+		public boolean imageMovedOff(AniImage which) {
+			clearInfo();
+			return true;
+		}
+		
+		public void onPenEvent(PenEvent ev) {
+			super.onPenEvent(ev);
+			if (ev.type==PenEvent.PEN_UP) {
+				clearInfo();
+				// The next line is needed due to a bug in eve (it does not call penReleased)
+				if (isDragging) penReleased(new Point(ev.x,ev.y));
+			}
+		}
+		
+	    ///////////////////////////////////////////////////
+		//  Allow the caches to be dragged into a cachelist
+	    ///////////////////////////////////////////////////
+		
+		String wayPoint;
+		
+		public void startDragging(DragContext dc) {
+			if (!Global.mainForm.cacheListVisible) return;
+			Vector cacheDB=Global.getProfile().cacheDB;
+	//Vm.debug(&quot;myIAP startDrag &quot;+dc.start.x+&quot;/&quot;+dc.start.y);
+			int idx=Global.getProfile().getCacheIndex(wayPoint); 
+			if (idx&gt;=0) {
+				 CacheHolder ch=(CacheHolder) cacheDB.get(idx);
+				 //wayPoint=ch.wayPoint;
+				 //Vm.debug(&quot;Waypoint : &quot;+ch.wayPoint);
+				 IconAndText icnDrag=new IconAndText();
+				 icnDrag.addColumn( CacheType.cache2Img(ch.type));
+				 icnDrag.addColumn(ch.wayPoint);
+				 dc.dragData=dc.startImageDrag(icnDrag,new Point(8,8),this);
+				 //if (dc instanceof ImageDragContext) Vm.debug(&quot;&gt;&gt;&gt;&gt;Is Image drag&quot;);
+				 canScroll=false;
+			}
+		 }
+
+		 public void stopDragging(DragContext dc) {		 
+			canScroll=true;
+		 }
+		 public void draggingStarted(ImageDragContext dc) {}
+		 public void draggingStopped(ImageDragContext dc) {}
+		 
+		 public boolean imageBeginDragged(AniImage which,Point pos) {
+			if (!Global.mainForm.cacheListVisible) return false;
+			canScroll=false;
+			clearInfo();
+			wayPoint=null;
+			AniImage dragImage=null;
+			if (which instanceof RadarPanelImage) {
+				RadarPanelImage imgRP=(RadarPanelImage) which;
+				java.util.Vector cacheDB=Global.getProfile().cacheDB;
+				CacheHolder ch=(CacheHolder) cacheDB.get(imgRP.rownum);
+				wayPoint=ch.wayPoint;
+				
+				int tw,th;
+				Image img = new Image(tw=fm.getTextWidth(wayPoint)+17,th=fm.getHeight()&gt;15?fm.getHeight():15);
+				Graphics g = new Graphics(img);
+				g.setFont(font);
+				g.setColor(Color.White);
+				g.fillRect(0,0,tw, th);
+				g.setColor(RED);
+				g.drawText(wayPoint, 15,1);
+				which.draw(g,0,0,0);
+				dragImage=new AniImage(img);
+				dragImage.properties|=AniImage.IsMoveable;
+				dragImage.setLocation(pos.x,pos.y);
+			}
+			return super.imageBeginDragged(dragImage,pos);
+		 }
+
+		 public boolean imageDragged(ImageDragContext drag, Point pos) {
+			 	if (drag.image!=null) {
+	/*			    Point p = Gui.getPosInParent(this,getWindow());
+				 	p.x += pos.x-origin.x;
+				 	p.y += pos.y-origin.y;
+				 	Control c = getWindow().findChild(p.x,p.y);
+	*/
+					drag.clearPendingDrags();
+			 	}
+			 	return super.imageDragged(drag,pos);
+		 }
+		 
+		 public boolean imageNotDragged(ImageDragContext drag, Point pos) {
+			if (drag.image!=null) {
+				images.remove(drag.image);
+				drag.image=null;
+				refresh();
+			}			
+			 Point p = Gui.getPosInParent(this,getWindow(),null);
+			 p.x += drag.curPoint.x-origin.x;
+			 p.y += drag.curPoint.y-origin.y;
+			 Control c = getWindow().findChild(p.x,p.y);
+		     if (c instanceof List &amp;&amp; c.text.equals(&quot;CacheList&quot;)) {
+		    	 if (Global.mainForm.cacheList.addCache(wayPoint)) {
+		    		 c.repaintNow();
+		    		 ((List) c).makeItemVisible(((List)c).itemsSize()-1);
+		    	 }
+		     }
+			 return false; 
+		 }
+		 
+		 public boolean canScreenScroll() {
+			 return canScroll;
+		 }
+		 public boolean scroll(int dx,int dy,Point moved) {
+			 if (canScroll)
+				 return super.scroll(dx,dy,moved);
+			 return false;
+		 }
+	}
+
+//################################################################################
+//  RadarPanelImage
+//################################################################################
+
+	/**
+	* The ImagePanelImage extends AniImage by a fileName.
+	* This is an easy way to identify the image clicked,
+	* what is needed to display the full image from the
+	* thumbnail.
+	*/
+	public class RadarPanelImage extends AniImage{
+		public String wayPoint = &quot;&quot;;
+		public int rownum;
+		
+		public RadarPanelImage(Picture i){
+			super(i);
+		}
+	}
+	
+	
+
+}

Added: experiments/EVE/src/cachewolf/RebuildIndex.java
===================================================================
--- experiments/EVE/src/cachewolf/RebuildIndex.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/RebuildIndex.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,108 @@
+package cachewolf;
+
+import eve.io.File;
+import eve.sys.Handle;
+import eve.ui.MessageBox;
+import eve.ui.ProgressBarForm;
+
+public class RebuildIndex {
+	String [] xmlFiles;
+	
+	public RebuildIndex() {}
+	
+	public void rebuild() {	
+		int i;
+		Profile prof=Global.getProfile();
+		
+		myProgressBarForm pbf = new myProgressBarForm();
+		Handle h = new Handle();
+		pbf.setTask(h,MyLocale.getMsg(209,&quot;Rebuilding index&quot;));
+		pbf.exec();
+
+		eve.io.File file=new eve.io.File(Global.getProfile().dataDir);
+		xmlFiles=file.list(&quot;*.xml&quot;,0);
+		int orphans=0; // xml Files without entry in database
+		int nAdded=0;  // caches added to database
+		for (i=0; i&lt;xmlFiles.length; i++) {
+			int pos=xmlFiles[i].lastIndexOf('.');
+			if (pos&lt;0) continue;
+			String wayPoint=xmlFiles[i].substring(0,pos).toUpperCase();
+			if (wayPoint.equalsIgnoreCase(&quot;index&quot;) || 			// Check for index.xml and index.bak
+				prof.getCacheIndex(wayPoint)&gt;=0)		// Check for waypoints already in database 
+				xmlFiles[i]=null;   				// Remove existing caches or index.xml
+			else {
+				//eve.sys.Vm.debug(&quot;Orphan: &quot;+wayPoint);
+				orphans++;
+			}
+		}
+		if (orphans&gt;0) { // At least one cache not in database
+			int nProcessed=0;
+			// Now do the actual work
+			for(i = 0; i&lt;xmlFiles.length; i++){
+				if (xmlFiles[i]!=null) {
+					h.progress = ((float)nProcessed++)/(float)(orphans);
+					h.changed();
+					String details=getCacheDetails(prof.dataDir+xmlFiles[i]);
+					if (details!=null) { // In older Versions of CW the &lt;CACHE... /&gt; line was not stored in the cache.xml
+						CacheHolder ch=new CacheHolder(details);
+						prof.cacheDB.add(ch);
+						nAdded++;
+						xmlFiles[i]=null;
+					} else Global.getPref().log(&quot;File &quot;+xmlFiles[i]+&quot; not in index.xml&quot;);
+				}
+				if (pbf.isClosed) break;
+			}
+			(new MessageBox(MyLocale.getMsg(327, &quot;Information&quot;), 
+					  MyLocale.getMsg(210,&quot;Caches nicht in index.xml: &quot;)+orphans+
+					  MyLocale.getMsg(211,&quot;\nDavon hinzugef&#252;gt: &quot;)+nAdded
+					, MessageBox.OKB)).execute();
+			prof.buildReferences();
+			prof.saveIndex(true);
+		}
+		if (orphans!=nAdded &amp;&amp; (new MessageBox(MyLocale.getMsg(327, &quot;Information&quot;),
+					MyLocale.getMsg(212,&quot;Delete all .xml files not in index.xml and associated pictures&quot;), 
+					MessageBox.YESB | MessageBox.NOB)).execute()==MessageBox.YESB) {
+			h = new Handle();
+			pbf.setTask(h,MyLocale.getMsg(213,&quot;Deleting orphans&quot;));
+			DataMover dm=new DataMover();
+			int nDeleted=0;
+			for (i=0; i&lt;xmlFiles.length; i++) {
+				if (xmlFiles[i]!=null){	
+					h.progress = ((float)nDeleted++)/(float)(orphans-nAdded);
+					h.changed();
+					String wayPoint=xmlFiles[i].substring(0,xmlFiles[i].indexOf('.'));
+					dm.deleteCacheFiles(wayPoint,prof.dataDir);
+				}
+			}
+		}
+		pbf.exit(0);
+	}
+
+	private String getCacheDetails(String xmlFile) {
+		try {
+			char buf[]=new char[(int) (new File(xmlFile)).getLength()];
+			java.io.InputStreamReader in = new java.io.InputStreamReader(new java.io.FileInputStream(xmlFile),&quot;UTF8&quot;);
+			int len=in.read(buf);
+			in.close();
+			eve.util.CharArray ca=new eve.util.CharArray(buf); ca.setLength(len);
+			String text=(ca).toString();
+			int start,end;
+			// Check that we have not accidentally listed another xml file in the directory
+			if (text.indexOf(&quot;&lt;CACHEDETAILS&gt;&quot;)&lt;0 || (start=text.indexOf(&quot;&lt;CACHE &quot;))&lt;0) return null;
+			end=text.indexOf(&quot;/&gt;&quot;,start);
+			return text.substring(start,end+2);
+		} catch (Exception ex) {
+			return null;
+		}
+	}
+
+	class myProgressBarForm extends ProgressBarForm {
+		 boolean isClosed=false;
+		 protected boolean canExit(int exitCode) {
+			isClosed=true;
+			return true;
+		 }
+	 }
+	 
+	
+}

Added: experiments/EVE/src/cachewolf/SearchCache.java
===================================================================
--- experiments/EVE/src/cachewolf/SearchCache.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/SearchCache.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,63 @@
+package cachewolf;
+import java.util.*;
+
+/**
+*	A class to perform a search on the cache database.
+*	The searchstr is searched for in the waypoint
+*	and the name of the cache.
+*	A method is also provided to erase the search results.
+*/
+public class SearchCache {
+
+	Vector cacheDB;
+	
+	public SearchCache(Vector DB){
+		cacheDB = DB;
+	}
+	
+	/**
+	* Method to iterate through the cache database.
+	* Each cache where the search string is found (in waypoint
+	* and / or cache name) is flagged as matching. The search only
+	* acts on the filtered (=visible) set of caches
+	*/
+	public void search(String searchStr){
+		if(searchStr.length()&gt;0){
+			Global.getProfile().selectionChanged = true;
+			searchStr = searchStr.toUpperCase();
+			CacheHolder ch;
+			//Search through complete database
+			//Mark finds by setting is_flaged
+			//TableModel will be responsible for displaying
+			//marked caches.
+			for(int i = 0;i &lt; cacheDB.size();i++){
+				ch = (CacheHolder)cacheDB.get(i);
+				if (ch.is_filtered) break; // Reached end of visible records
+				if(ch.wayPoint.toUpperCase().indexOf(searchStr) &lt;0 &amp;&amp; 
+				   ch.cacheName.toUpperCase().indexOf(searchStr) &lt;0 &amp;&amp; 
+				   ch.cacheStatus.toUpperCase().indexOf(searchStr)&lt;0){
+					ch.is_flagged = false;
+					ch.is_filtered = true;
+				} else
+					ch.is_flagged=true;
+			} // for
+		     Global.mainTab.tbP.selectRow(0);
+		} // if
+	}
+	
+	/**
+	* Method to remove the flag from all caches in the 
+	* cache database. Restore to the state of the filter
+	*/
+	public void clearSearch(){
+		Global.getProfile().selectionChanged = true;
+		for(int i = cacheDB.size()-1;i &gt;=0;i--){
+			CacheHolder ch=((CacheHolder)cacheDB.get(i));
+			ch.is_flagged=false;
+			ch.is_filtered=(ch.is_black^Global.getProfile().showBlacklisted) ;
+		}
+		//Global.getProfile().filterActive=Filter.filterActive; //TODO This is a hack. Need to tidy this up
+		//Global.getProfile().filterInverted=Filter.filterInverted;
+		Global.getProfile().restoreFilter();
+	}
+}

Added: experiments/EVE/src/cachewolf/ShowCacheInBrowser.java
===================================================================
--- experiments/EVE/src/cachewolf/ShowCacheInBrowser.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/ShowCacheInBrowser.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,241 @@
+package cachewolf;
+import cachewolf.utils.Common;
+import cachewolf.utils.STRreplace;
+
+import com.stevesoft.eve_pat.Regex;
+
+import java.io.BufferedWriter;
+import eve.io.File;
+
+import java.io.FileOutputStream;
+import java.io.OutputStreamWriter;
+import java.io.PrintWriter;
+import java.io.IOException;
+import eve.ui.MessageBox;
+
+import eve.sys.Vm;
+import java.util.*;
+
+
+import HTML.Template;
+import eve.ui.Form;
+
+
+public class ShowCacheInBrowser {
+	String pd=File.getProgramDirectory();
+	String saveTo=pd+&quot;/temp.html&quot;;
+	static Hashtable diff=null;
+	static Hashtable terr=null;
+	static Hashtable args=null;
+
+	ShowCacheInBrowser() {
+		if (diff==null) {
+			diff=new Hashtable(15);
+			String y=&quot;&lt;img src=\&quot;<A HREF="file://">file://</A>&quot; + pd + &quot;/y.png\&quot; border=0&gt;&quot;;
+			String y2=&quot;&lt;img src=\&quot;<A HREF="file://">file://</A>&quot; + pd + &quot;/y2.png\&quot; border=0&gt;&quot;;
+			diff.put(&quot;1&quot;,y);
+			diff.put(&quot;1.5&quot;,y+y2);
+			diff.put(&quot;2&quot;,y+y);
+			diff.put(&quot;2.5&quot;,y+y+y2);
+			diff.put(&quot;3&quot;,y+y+y);
+			diff.put(&quot;3.5&quot;,y+y+y+y2);
+			diff.put(&quot;4&quot;,y+y+y+y);
+			diff.put(&quot;4.5&quot;,y+y+y+y+y2);
+			diff.put(&quot;5&quot;,y+y+y+y+y);
+
+			terr=new Hashtable(15);
+			String g=&quot;&lt;img src=\&quot;<A HREF="file://">file://</A>&quot; + pd + &quot;/g.png\&quot; border=0&gt;&quot;;
+			String g2=&quot;&lt;img src=\&quot;<A HREF="file://">file://</A>&quot; + pd + &quot;/g2.png\&quot; border=0&gt;&quot;;
+			terr.put(&quot;1&quot;,g);
+			terr.put(&quot;1.5&quot;,g+g2);
+			terr.put(&quot;2&quot;,g+g);
+			terr.put(&quot;2.5&quot;,g+g+g2);
+			terr.put(&quot;3&quot;,g+g+g);
+			terr.put(&quot;3.5&quot;,g+g+g+g2);
+			terr.put(&quot;4&quot;,g+g+g+g);
+			terr.put(&quot;4.5&quot;,g+g+g+g+g2);
+			terr.put(&quot;5&quot;,g+g+g+g+g);
+
+			args = new Hashtable();
+			args.put(&quot;filename&quot;, pd+&quot;/GCTemplate.html&quot;);
+			args.put(&quot;case_sensitive&quot;, &quot;true&quot;);
+			args.put(&quot;loop_context_vars&quot;, Boolean.TRUE);
+			args.put(&quot;max_includes&quot;, new Integer(5));
+		}
+	}
+
+	public void showCache(CacheHolderDetail chD) {
+		if (chD == null) return;
+		try {
+			Template tpl = new Template(args);
+			if(!chD.is_filtered){
+				Form.showWait();
+				try {
+					if (chD.wayPoint.startsWith(&quot;OC&quot;))
+						tpl.setParam(&quot;TYPE&quot;, &quot;\&quot;<A HREF="file://">file://</A>&quot;+File.getProgramDirectory()+&quot;/&quot;+CacheType.transOCType(chD.type)+&quot;.gif\&quot;&quot;);
+					else
+						tpl.setParam(&quot;TYPE&quot;, &quot;\&quot;<A HREF="file://">file://</A>&quot;+File.getProgramDirectory()+&quot;/&quot;+chD.type+&quot;.gif\&quot;&quot;);
+					tpl.setParam(&quot;SIZE&quot;, chD.cacheSize);
+					tpl.setParam(&quot;WAYPOINT&quot;, chD.wayPoint);
+					tpl.setParam(&quot;CACHE_NAME&quot;, chD.cacheName);
+					tpl.setParam(&quot;OWNER&quot;, chD.cacheOwner);
+					if (chD.hard.endsWith(&quot;.0&quot;)) chD.hard=chD.hard.substring(0,chD.hard.length()-2);
+					tpl.setParam(&quot;DIFFICULTY&quot;, (String) diff.get(chD.hard.replace(',','.')));
+					if (chD.terrain.endsWith(&quot;.0&quot;)) chD.terrain=chD.terrain.substring(0,chD.terrain.length()-2);
+					tpl.setParam(&quot;TERRAIN&quot;, (String) terr.get(chD.terrain.replace(',','.')));
+					tpl.setParam(&quot;DISTANCE&quot;, chD.distance.replace(',','.'));
+					tpl.setParam(&quot;BEARING&quot;, chD.bearing);
+					if (chD.pos!=null &amp;&amp; chD.pos.isValid()) {
+						tpl.setParam(&quot;LATLON&quot;, chD.latLon);
+					} else {
+						tpl.setParam(&quot;LATLON&quot;, &quot;unknown&quot;);
+					}
+					// If status is of format yyyy-mm-dd prefix it with a &quot;Found&quot; message in local language
+					if (chD.cacheStatus.length()&gt;=10 &amp;&amp; chD.cacheStatus.charAt(4)=='-')
+						tpl.setParam(&quot;STATUS&quot;,MyLocale.getMsg(318,&quot;Found&quot;)+&quot; &quot;+chD.cacheStatus);
+					else
+						tpl.setParam(&quot;STATUS&quot;, chD.cacheStatus);
+
+					// Cache attributes
+					if (chD.attributes.getCount()&gt;0) {
+						Vector attVect=new Vector(chD.attributes.getCount()+1);
+						for (int i=0; i&lt;chD.attributes.getCount(); i++) {
+							Hashtable atts=new Hashtable();
+							atts.put(&quot;IMAGE&quot;,&quot;&lt;img src=\&quot;<A HREF="file://">file://</A>&quot;+
+									   Attribute.getImageDir()+chD.attributes.getName(i)+
+									   &quot;\&quot; border=0 alt=\&quot;&quot;+chD.attributes.getInfo(i)+&quot;\&quot;&gt;&quot;);
+							if (i % 5 ==4)
+								atts.put(&quot;BR&quot;,&quot;&lt;br/&gt;&quot;);
+							else
+								atts.put(&quot;BR&quot;,&quot;&quot;);
+							atts.put(&quot;INFO&quot;,chD.attributes.getInfo(i));
+							attVect.add(atts);
+						}
+						tpl.setParam(&quot;ATTRIBUTES&quot;,attVect);
+					}
+
+					tpl.setParam(&quot;DATE&quot;, chD.dateHidden);
+					tpl.setParam(&quot;URL&quot;, chD.URL);
+					if (chD.travelbugs.size()&gt;0) tpl.setParam(&quot;BUGS&quot;,chD.travelbugs.toHtml());
+					if (chD.cacheNotes!=null &amp;&amp; chD.cacheNotes.trim().length()&gt;0) tpl.setParam(&quot;NOTES&quot;, STRreplace.replace(chD.cacheNotes,&quot;\n&quot;,&quot;&lt;br/&gt;\n&quot;));
+					if (chD.solver!=null &amp;&amp; chD.solver.trim().length()&gt;0) tpl.setParam(&quot;SOLVER&quot;, STRreplace.replace(chD.solver,&quot;\n&quot;,&quot;&lt;br/&gt;\n&quot;));
+					// Look for images
+
+					StringBuffer s=new StringBuffer(chD.longDescription.length());
+					int start=0;
+					int pos;
+					int imageNo=0;
+					Regex imgRex = new Regex(&quot;src=(?:\\s*[^\&quot;|']*?)(?:\&quot;|')(.*?)(?:\&quot;|')&quot;);
+					while (start&gt;=0 &amp;&amp; (pos=chD.longDescription.indexOf(&quot;&lt;img&quot;,start))&gt;0) {
+						if (imageNo &gt;= chD.images.size())break;
+						s.append(chD.longDescription.substring(start,pos));
+						imgRex.searchFrom(chD.longDescription,pos);
+						String imgUrl=imgRex.stringMatched(1);
+						//Vm.debug(&quot;imgUrl &quot;+imgUrl);
+						if (imgUrl.lastIndexOf('.')&gt;0 &amp;&amp; imgUrl.toLowerCase().startsWith(&quot;http&quot;)) {
+							String imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).substring(0,4).trim();
+							// If we have an image which we stored when spidering, we can display it
+							if(imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)){
+								s.append(&quot;&lt;img src=\&quot;<A HREF="file://">file://</A>&quot;+
+								   Global.getProfile().dataDir+chD.images.get(imageNo)+&quot;\&quot;&gt;&quot;);
+								imageNo++;
+							}
+						}
+						start=chD.longDescription.indexOf(&quot;&gt;&quot;,pos);
+						if (start&gt;=0) start++;
+					}
+					if (start&gt;=0) s.append(chD.longDescription.substring(start));
+					tpl.setParam(&quot;DESCRIPTION&quot;, s.toString());
+
+					// Do the remaining pictures which are not included in main body of text
+					// They will be hidden initially and can be displayed by clicking on a link
+					if (imageNo&lt;chD.images.size()) {
+						Vector imageVect=new Vector(chD.images.size()-imageNo);
+						for (; imageNo&lt;chD.images.size(); imageNo++) {
+							Hashtable imgs=new Hashtable();
+							imgs.put(&quot;IMAGE&quot;,&quot;&lt;img src=\&quot;<A HREF="file://">file://</A>&quot;+
+									   Global.getProfile().dataDir+chD.images.get(imageNo)+&quot;\&quot; border=0&gt;&quot;);
+							imgs.put(&quot;IMAGETEXT&quot;,chD.imagesText.get(imageNo));
+							if (imageNo&lt;chD.imagesInfo.size() &amp;&amp; chD.imagesInfo.get(imageNo)!=null)
+								imgs.put(&quot;IMAGECOMMENT&quot;,chD.imagesInfo.get(imageNo));
+							else
+								imgs.put(&quot;IMAGECOMMENT&quot;,&quot;&quot;);
+							imgs.put(&quot;I&quot;,&quot;'img&quot;+new Integer(imageNo).toString()+&quot;'&quot;);
+							imageVect.add(imgs);
+						}
+						tpl.setParam(&quot;IMAGES&quot;,imageVect);
+					}
+
+					Vector logVect=new Vector(chD.cacheLogs.size());
+					for (int i=0; i&lt;chD.cacheLogs.size(); i++) {
+						Hashtable logs=new Hashtable();
+						String log=STRreplace.replace(chD.cacheLogs.getLog(i).toHtml(),&quot;<A HREF="http://www.geocaching.com/images/icons/">http://www.geocaching.com/images/icons/</A>&quot;,&quot;&quot;);
+						int posGt=log.indexOf('&gt;'); // Find the icon which defines the type of log
+						if (posGt&lt;0) {
+							logs.put(&quot;LOG&quot;,log);
+							logs.put(&quot;LOGTYPE&quot;,&quot;&quot;);
+						} else {
+							int posBr=log.indexOf(&quot;&lt;br&gt;&quot;);
+							if(posBr&lt;0) {
+								logs.put(&quot;LOG&quot;,log);
+								logs.put(&quot;LOGTYPE&quot;,&quot;&quot;);
+							} else {
+								logs.put(&quot;LOG&quot;,log.substring(posBr));
+								logs.put(&quot;LOGTYPE&quot;,log.substring(0,posGt)+&quot; border='0'&quot;+log.substring(posGt,posBr+4));
+							}
+						}
+						logs.put(&quot;I&quot;,&quot;'log&quot;+new Integer(i).toString()+&quot;'&quot;);
+						logVect.add(logs);
+					}
+					tpl.setParam(&quot;LOGS&quot;,logVect);
+					if (!chD.is_available) tpl.setParam(&quot;UNAVAILABLE&quot;,&quot;1&quot;);
+					if (!chD.hints.equals(&quot;null&quot;))tpl.setParam(&quot;HINT&quot;,Common.rot13(chD.hints));
+
+					if (chD.hasAddiWpt()) {
+						Vector addiVect=new Vector(chD.addiWpts.size());
+						for (int i=0; i&lt;chD.addiWpts.size(); i++) {
+							Hashtable addis=new Hashtable();
+							CacheHolder ch=(CacheHolder) chD.addiWpts.get(i);
+							addis.put(&quot;WAYPOINT&quot;,ch.wayPoint);
+							addis.put(&quot;NAME&quot;,ch.cacheName);
+							addis.put(&quot;LATLON&quot;,ch.latLon);
+							addis.put(&quot;IMG&quot;,&quot;&lt;img src=\&quot;&quot;+CacheType.type2pic(ch.type)+&quot;\&quot;&gt;&quot;);
+							CacheHolderDetail chDA=new CacheHolderDetail(ch);
+							chDA.readCache(Global.getProfile().dataDir);
+							addis.put(&quot;LONGDESC&quot;,chDA.longDescription); // Do we need to treat longDesc as above ?
+							addiVect.add(addis);
+						}
+						tpl.setParam(&quot;ADDIS&quot;,addiVect);
+					}
+				}catch(Exception e){
+					Vm.debug(&quot;Problem getting Parameter, Cache: &quot; + chD.wayPoint);
+					Global.getPref().log(&quot;Problem getting parameter &quot;+e.toString()+&quot;, Cache: &quot; + chD.wayPoint);
+					e.printStackTrace();
+				}
+			}
+			PrintWriter detfile;
+	        detfile = new PrintWriter(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(saveTo), &quot;UTF8&quot;)));
+			tpl.printTo(detfile);
+			//detfile.print(tpl.output());
+			detfile.close();
+			try {
+				String s = &quot;\&quot;&quot;+Global.getPref().browser+&quot;\&quot; \&quot;<A HREF="file://">file://</A>&quot;+saveTo+&quot;\&quot;&quot;;
+
+				Vm.execCommandLine(s); //Global.getPref().browser+&quot; \&quot;file:&quot;+saveTo+&quot;\&quot;&quot;);
+				Global.getPref().log(&quot;Executing: &quot;+s); //Global.getPref().browser+&quot; \&quot;&quot;+saveTo+&quot;\&quot;&quot;);
+			} catch (IOException ex) {
+				(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),
+					MyLocale.getMsg(1034,&quot;Cannot start browser!&quot;) + &quot;\n&quot; + ex.toString() + &quot;\n&quot; +
+					MyLocale.getMsg(1035,&quot;Possible reason:&quot;) + &quot;\n&quot; +
+					MyLocale.getMsg(1036,&quot;A bug in ewe VM, please be&quot;) + &quot;\n&quot; +
+					MyLocale.getMsg(1037,&quot;patient for an update&quot;),Form.OKB)).execute();
+			}
+
+		} catch(Exception e) {
+			e.printStackTrace();
+			Global.getPref().log(&quot;Error in ShowCache &quot;+e.toString());
+		} finally {
+			Form.cancelWait();
+		}
+	}
+}

Added: experiments/EVE/src/cachewolf/SolverPanel.java
===================================================================
--- experiments/EVE/src/cachewolf/SolverPanel.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/SolverPanel.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,217 @@
+package cachewolf;
+
+
+import eve.ui.*;
+import eve.io.*;
+import eve.fx.*;
+import java.util.*;
+import eve.sys.*;
+import eve.ui.data.InputBox;
+import eve.ui.event.ControlEvent;
+import eve.ui.event.DataChangeEvent;
+
+/**
+* Class to create the solver panel. Calls the parser and tokeniser and handles
+*	the parser results.
+*	@see Parser
+*	@see Tokenizer
+*/
+public class SolverPanel extends CellPanel{
+	public TextPad mText; // Accessed by Parser error
+	private Button mBtSolve;
+	//private Button btnLoad, btnSave, btnSaveAs;
+	private Button btnWolfLang;
+	private OutputPanel mOutput;
+	private Parser parser = null; // Lazy initialisation to speed up loading
+	private Vector msgFIFO = null; // Lazy initialisation to speed up loading
+	private Menu mnuContext;
+	private String originalInstructions=&quot;&quot;;
+	private Button btnDegRad; 
+	
+	public boolean isDirty() {
+		return !originalInstructions.equals(getInstructions());
+	}
+	
+	public String getInstructions() {
+		return mText.getText();
+	}
+	public void setInstructions(String text) {
+		originalInstructions=text;
+		mText.setText(text);
+		mText.repaint();
+	}
+	
+	public void clearOutput() {
+		mOutput.setText(&quot;&quot;);
+	}
+	
+	Panel programPanel, outputPanel;
+	
+	private String getSolverDegMode() {
+		return Global.getPref().solverDegMode ? &quot;DEG&quot; : &quot;RAD&quot;;
+	}
+	
+	public void showSolverMode() {
+		btnDegRad.setText(getSolverDegMode());
+		btnDegRad.repaint();
+	}
+	
+	public SolverPanel (){
+		SplittablePanel split = new SplittablePanel(PanelSplitter.VERTICAL);
+
+		programPanel = split.getNextPanel();
+		outputPanel = split.getNextPanel();
+		split.setSplitter(PanelSplitter.AFTER|PanelSplitter.HIDDEN,PanelSplitter.BEFORE|PanelSplitter.HIDDEN,0);
+
+		programPanel.addLast(new MyScrollBarPanel(mText = new InputPanel())).setTag(TAG_SPAN, new Dimension(2,1));
+		Panel pnlStatButtons=new Panel();
+		pnlStatButtons.addNext(btnDegRad=new Button(getSolverDegMode()),CellConstants.DONTSTRETCH,CellConstants.DONTFILL);
+		btnDegRad.backGround=Color.Sand;
+		btnDegRad.borderStyle=btnDegRad.borderWidth=0;
+		Panel pnlButtons=new Panel();
+		pnlButtons.addNext(mBtSolve= new Button(MyLocale.getMsg(1735,&quot;Solve!&quot;)),CellConstants.HSTRETCH, CellConstants.HFILL);
+		pnlButtons.addLast(btnWolfLang= new Button(MyLocale.getMsg(118,&quot;WolfLanguage&quot;)),CellConstants.HSTRETCH, CellConstants.HFILL);
+		pnlButtons.equalWidths=true;
+		pnlStatButtons.addLast(pnlButtons,CellConstants.HSTRETCH,CellConstants.HFILL);
+		programPanel.addLast(pnlStatButtons,HSTRETCH,HFILL);
+		/*programPanel.addNext(btnLoad= new Button(MyLocale.getMsg(1736,&quot;Load&quot;)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		programPanel.addNext(btnSave= new Button(MyLocale.getMsg(1737,&quot;Save&quot;)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		programPanel.addLast(btnSaveAs= new Button(MyLocale.getMsg(1738,&quot;SaveAs&quot;)),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		*/
+		outputPanel.addLast(new MyScrollBarPanel(mOutput = new OutputPanel()));
+		this.addLast(split);
+	}
+	
+	private void execDirectCommand() {
+		InpScreen boxInp=new InpScreen(MyLocale.getMsg(1733,&quot;Input command&quot;));
+		boxInp.input(parent.getFrame(),&quot;&quot;,100); //,MyLocale.getScreenWidth()*4/5);
+		String s=boxInp.getInput();
+		if (s.equals(&quot;&quot;)) return;
+		processCommand(s);
+	}
+	
+    private void processCommand(String s) {
+		if (parser==null) {
+			parser=new Parser(); // Lazy initialisation
+			msgFIFO=new Vector();
+		} else
+			msgFIFO.clear();
+		parser.parse(s, msgFIFO);
+		String msgStr = &quot;&quot;;
+		for(int i = 0; i &lt; msgFIFO.size(); i++){
+			msgStr = msgStr + msgFIFO.get(i) + &quot;\n&quot;;
+		}
+		mOutput.appendText(msgStr,true);
+    }
+	
+	public void onEvent(Event ev){
+		if (ev instanceof DataChangeEvent) Global.mainTab.cacheDirty=true;
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if(ev.target == mBtSolve){
+				processCommand(mText.getText());
+			}
+			if (ev.target==btnWolfLang) {
+				InfoHtmlScreen is = new InfoHtmlScreen(File.getProgramDirectory() + &quot;/&quot; + &quot;wolflang.html&quot;, MyLocale.getMsg(118,&quot;WolfLanguage&quot;), true);
+				is.execute(parent.getFrame(), Gui.CENTER_FRAME);
+			}
+			if (ev.target==btnDegRad) {
+				Global.getPref().solverDegMode=!Global.getPref().solverDegMode;
+				btnDegRad.setText(getSolverDegMode());
+			}
+/*			if(ev.target == btnLoad){
+				FileChooser fc = new FileChooser(FileChooser.OPEN, profile.dataDir);
+				
+				fc.addMask(currCh.wayPoint + &quot;.wl&quot;);
+				fc.addMask(&quot;*.wl&quot;);
+				fc.setTitle(&quot;Select File&quot;);
+				if(fc.execute() != FileChooser.IDCANCEL){
+					currFile = fc.getChosen();
+					mText.setText(&quot;&quot;);
+					try {
+						InputStreamReader inp = new InputStreamReader( new FileInputStream(currFile));
+						mText.setText(inp.readAll());
+						inp.close();
+
+					} catch (Exception e) {
+						Vm.debug(&quot;Error reading file &quot; + e.toString());
+					}
+				}
+			}
+			if((ev.target == btnSave) &amp;&amp; (currFile != null)){
+				try {
+					OutputStreamWriter outp = new OutputStreamWriter( new FileOutputStream(currFile));
+					outp.write(mText.getText());
+					outp.close();
+				} catch (Exception e) {
+					Vm.debug(&quot;Error writing file &quot;);
+				}
+			}
+			if((ev.target == btnSaveAs)||((ev.target == btnSave) &amp;&amp; (currFile == null))){
+				FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
+				fc.addMask(currCh.wayPoint + &quot;.wl&quot;);
+				fc.addMask(&quot;*.wl&quot;);
+				fc.setTitle(&quot;Select File&quot;);
+				if(fc.execute() != FileChooser.IDCANCEL){
+					File saveFile = fc.getChosenFile();
+					currFile = fc.getChosen();
+					try {
+						OutputStreamWriter outp = new OutputStreamWriter( new FileOutputStream(saveFile));
+						outp.write(mText.getText());
+						outp.close();
+					} catch (Exception e) {
+						Vm.debug(&quot;Error writing file &quot;);
+					}
+				}
+			}
+*/			
+		}
+	}
+
+//############################################################################
+//  InputScreen	
+//############################################################################
+
+	private class InpScreen extends InputBox {
+		InpScreen(String title) {super(title); }
+		String getInput() { return getInputValue();}
+	}
+
+//############################################################################
+//  InputPanel	
+//############################################################################
+	
+	private class InputPanel extends TextPad {
+
+		public void  penDoubleClicked(Point where) {
+			execDirectCommand();
+		}
+	}
+	
+//############################################################################
+//  OutputPanel	
+//############################################################################
+	private class OutputPanel extends TextPad {
+		MenuItem mnuClr;
+		OutputPanel() {
+			this.modify(Control.NotEditable,0);
+			//this.modifiers=this.modifiers|WantHoldDown; 
+			setMenu(mnuContext=getClipboardMenu(new Menu(new MenuItem[]{ mnuClr=new MenuItem(MyLocale.getMsg(1734,&quot;Clear output&quot;)) },&quot;&quot;)));
+		} 
+		public void penRightReleased(Point p){
+			setMenu(mnuContext);
+			doShowMenu(p); // direct call (not through doMenu) is neccesary because it will exclude the whole table
+		}
+		public void penHeld(Point p){
+			setMenu(mnuContext);
+			doShowMenu(p);
+		}
+		public void popupMenuEvent(Object selectedItem){
+			if (selectedItem==mnuClr) 
+				this.setText(&quot;&quot;);
+			else 
+				super.popupMenuEvent(selectedItem);
+		}
+	}
+	
+	
+}

Added: experiments/EVE/src/cachewolf/StatusBar.java
===================================================================
--- experiments/EVE/src/cachewolf/StatusBar.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/StatusBar.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,163 @@
+package cachewolf;
+
+import eve.ui.*;
+import eve.sys.Event;
+import java.util.*;
+import eve.sys.Device;
+import eve.fx.*;
+import eve.ui.event.ControlEvent;
+
+/**
+ * @author Marc Schnitzler
+ *
+ */
+public class StatusBar extends CellPanel{
+	private DBStats stats=new DBStats();
+	private StringBuffer sb=new StringBuffer(100);
+	private Label disp,lblCenter;
+	private Button btnFlt;
+	private Button btnCacheTour;
+	boolean mobileVGA;
+	private Color BLUE=new Color(0,0,255);
+	private Color GREEN=new Color(0,255,0);
+	private Color TURQUOISE=new Color(0,255,255);
+
+	public StatusBar(){
+		int sw = MyLocale.getScreenWidth();
+		mobileVGA = (Device.isMobile() &amp;&amp; sw &gt;= 400);
+		String imagesize=&quot;&quot;;
+		if(mobileVGA) imagesize=&quot;_vga&quot;;
+		addNext(btnCacheTour=new Button(new Picture(&quot;cachetour&quot;+imagesize+&quot;.png&quot;,Color.White,0)),CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		btnCacheTour.setPreferredSize(20,13); btnCacheTour.borderWidth=0;
+		btnCacheTour.setToolTip(MyLocale.getMsg(197,&quot;Show/Hide cachetour&quot;));
+		if(mobileVGA)
+			btnCacheTour.setPreferredSize(28,20);
+		else
+			btnCacheTour.setPreferredSize(20,13);
+		addNext(btnFlt= new Button(new Picture(&quot;filter&quot;+imagesize+&quot;.png&quot;,Color.White,0)),CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		btnFlt.backGround=new eve.fx.Color(0,255,0);
+		btnFlt.setPreferredSize(20,13);
+		btnFlt.borderWidth=0;
+		btnFlt.setToolTip(&quot;Filter status&quot;);
+		if(mobileVGA)
+			btnFlt.setPreferredSize(28,20);
+		else
+			btnFlt.setPreferredSize(20,13);
+		addNext(disp = new Label(&quot;&quot;),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		disp.setToolTip(MyLocale.getMsg(196,&quot;Total # of caches (GC&amp;OC)\nTotal # visible\nTotal # found&quot;));
+		addLast(lblCenter=new Label(&quot;&quot;),CellConstants.STRETCH, WEST|CellConstants.FILL);
+		lblCenter.setToolTip(MyLocale.getMsg(195,&quot;Current centre&quot;));
+		updateDisplay();
+	}
+
+	public void updateDisplay(){
+		String strCenter=&quot;&quot;;
+		sb.delete(0,100);
+		sb.append(MyLocale.getMsg(4500,&quot;Tot:&quot;)).append(&quot; &quot;).append(stats.total()).append(&quot; &quot;).
+					append(MyLocale.getMsg(4501,&quot;Dsp:&quot;)).append(&quot; &quot;).append(stats.visible()).append(&quot; &quot;).
+					append(MyLocale.getMsg(4502,&quot;Fnd:&quot;)).append(&quot; &quot;).append(stats.totalFound()).append(&quot;  &quot;);
+		disp.setText(sb.toString());
+		// Indicate that a filter is active in the status line
+		if (Global.getProfile().filterActive==Filter.FILTER_ACTIVE)
+			btnFlt.backGround=GREEN;
+		else if (Global.getProfile().filterActive==Filter.FILTER_CACHELIST)
+			btnFlt.backGround=BLUE;
+		else if (Global.getProfile().filterActive==Filter.FILTER_MARKED_ONLY)
+			btnFlt.backGround=TURQUOISE;
+		else
+			btnFlt.backGround=null;
+		// Current centre can only be displayed if screen is big
+		// Otherwise it forces a scrollbar
+		// This can happen even on bigger screens with big fonts
+		if ((MyLocale.getScreenWidth()&gt;=320) &amp;&amp; !(mobileVGA &amp;&amp; (Global.getPref().fontSize &gt; 20)))
+			strCenter=&quot;  \u00a4 &quot; + Global.getPref().curCentrePt.toString();
+
+		lblCenter.setText(strCenter);
+		relayout(true); // in case the numbers increased and need more space
+	}
+
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (ev.target == btnFlt){
+				Filter flt = new Filter();
+				if (Global.getProfile().filterActive==Filter.FILTER_INACTIVE) {
+					flt.setFilter();
+					flt.doFilter();
+				} else {
+					flt.clearFilter();
+				}
+				Global.mainTab.tbP.refreshTable();
+			}
+			if (ev.target == btnCacheTour){
+				Global.mainForm.toggleCacheListVisible();
+			}
+			Gui.takeFocus(Global.mainTab.tbP.tControl, Control.ByKeyboard);
+		}
+		super.onEvent(ev);
+	}
+
+//################################################################################
+//  DBStats
+//################################################################################
+
+	/**
+	 * @author Marc
+	 * Use this class to obtain statistics or information on a cache database.
+	 */
+	private class DBStats {
+		Vector cacheDB;
+
+		public DBStats(){
+			cacheDB = Global.getProfile().cacheDB;
+		}
+
+		/**
+		 * Method to get the number of caches displayed in the list.
+		 * It will count waypoints only that start with
+		 * GC,or
+		 * OC
+		 * @return
+		 */
+		public int visible(){
+			CacheHolder ch;
+			int counter = 0;
+			for(int i = cacheDB.size()-1;i&gt;=0; i--){
+				ch = (CacheHolder)cacheDB.get(i);
+				if(ch.is_black == false &amp;&amp; ch.is_filtered == false){
+					if(ch.wayPoint.startsWith(&quot;GC&quot;) || ch.wayPoint.startsWith(&quot;OC&quot;)) counter++;
+				}
+			}
+			return counter;
+		}
+
+		/**
+		 * Method to get the number of caches available for display
+		 * @return
+		 */
+		public int total(){
+			CacheHolder ch;
+			int counter = 0;
+			for(int i = cacheDB.size()-1;i&gt;=0; i--){
+				ch = (CacheHolder)cacheDB.get(i);
+				if(ch.is_black == false){
+					if(ch.wayPoint.startsWith(&quot;GC&quot;) || ch.wayPoint.startsWith(&quot;OC&quot;)) counter++;
+				}
+			}
+			return counter;
+		}
+
+		public int totalFound(){
+			CacheHolder ch;
+			int counter = 0;
+			for(int i = cacheDB.size()-1;i&gt;=0; i--){
+				ch = (CacheHolder)cacheDB.get(i);
+				if(ch.is_found == true) {
+					if(ch.wayPoint.startsWith(&quot;GC&quot;) || ch.wayPoint.startsWith(&quot;OC&quot;)) counter++;
+				}
+			}
+			return counter;
+		}
+	}
+
+
+}

Added: experiments/EVE/src/cachewolf/TableColumnChooser.java
===================================================================
--- experiments/EVE/src/cachewolf/TableColumnChooser.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/TableColumnChooser.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,212 @@
+package cachewolf;
+
+import eve.fx.*;
+import eve.ui.*;
+import java.util.*;
+
+import cachewolf.utils.Common;
+
+
+import eve.ui.List;
+import eve.ui.event.ControlEvent;
+import eve.ui.event.ListEvent;
+import eve.sys.Event;
+
+
+public class TableColumnChooser extends CellPanel {
+
+	String [] colNames;
+	Vector shownCols=new Vector(20);
+	Vector hiddenCols=new Vector(20);
+	private Button btnDown,btnUp,btnLeft,btnRight;
+	private myList lstShown,lstHidden;
+	
+	/**
+	 * 
+	 * @param colNames String array of ALL column names
+	 * @param selectedCols The selected columns separated by ,
+	 */
+	public TableColumnChooser(String [] colNames, String selectedCols) {
+        this.colNames=colNames;
+		addNext(new Label(MyLocale.getMsg(6050,&quot;Show column&quot;)));
+        addNext(new Label(&quot;&quot;));
+        addLast(new Label(MyLocale.getMsg(6051,&quot;Don't show column&quot;)));
+        
+        addNext(new MyScrollBarPanel(lstShown=new myList(6,shownCols),ScrollBarPanel.AlwaysShowVerticalScrollers));
+        CellPanel cpMid=new CellPanel();
+        cpMid.addLast(new Label(&quot;&quot;));
+        Picture imgRight=new Picture(&quot;eve/rightarrowsmall.png&quot;);//TODO imgRight.transparentColor=Color.White;
+        Picture imgLeft=new Picture(&quot;eve/leftarrowsmall.png&quot;);//TODO imgLeft.transparentColor=Color.White;
+        cpMid.addLast(btnRight=new Button(imgRight));
+        cpMid.addLast(new Label(&quot;&quot;));
+        cpMid.addLast(btnLeft=new Button(imgLeft));
+        cpMid.addLast(new Label(&quot;&quot;));
+        addNext(cpMid,VSTRETCH,VFILL);
+        addLast(new MyScrollBarPanel(lstHidden=new myList(6,hiddenCols),ScrollBarPanel.AlwaysShowVerticalScrollers));
+        
+        CellPanel pnlButtons=new CellPanel();
+		Picture imgDown=new Picture(&quot;eve/downarrowsmall.png&quot;); //TODO imgDown.transparentColor=Color.White;
+		Picture imgUp=new Picture(&quot;eve/uparrowsmall.png&quot;); //TODO imgUp.transparentColor=Color.White;
+        pnlButtons.addNext(btnDown=new Button(imgDown),HSTRETCH,HFILL); btnDown.modify(Disabled,0);
+		pnlButtons.addLast(btnUp=new Button(imgUp),HSTRETCH,HFILL); btnUp.modify(Disabled,0);
+        addNext(pnlButtons);
+        addNext(new Label(&quot;&quot;));
+        addLast(new Label(&quot;&quot;));
+        
+        // Set up
+        for (int i=0; i&lt;colNames.length; i++) hiddenCols.add(colNames[i]);
+        StringTokenizer st=new StringTokenizer(selectedCols,&quot;,&quot;);
+        int iCol;
+        while (st.hasMoreTokens()) {
+        	iCol=Common.parseInt(st.nextToken());
+        	if (iCol&gt;=0 &amp;&amp; iCol&lt;colNames.length) {
+        		shownCols.add(colNames[iCol]);
+        		hiddenCols.remove(colNames[iCol]);
+        	}
+        }
+        changeUpDownButtonStatus();
+	}
+
+	public String getSelectedCols() {
+		StringBuffer sb=new StringBuffer(40);
+		for (int i=0; i&lt;lstShown.items.size(); i++) {
+			String colName=(String)lstShown.items.elementAt(i);
+			for (int j=0; j&lt;colNames.length; j++) {
+				if (colName.equals(colNames[j])) {
+					if (sb.length()!=0) sb.append(',');
+					sb.append(j);
+					break;
+				}
+			}
+		}
+		return sb.toString();
+	}
+	
+	/** Enable the up/down buttons only if at least 2 caches are in the list */
+	private void changeUpDownButtonStatus() {
+		btnUp.modify(0,Disabled);
+		if (lstShown.items.size()&lt;2 || lstShown.getSelectedIndex(0)==0) btnUp.modify(Disabled,0);
+		btnDown.modify(0,Disabled);
+		if (lstShown.items.size()&lt;2 || lstShown.getSelectedIndex(0)==lstShown.items.size()-1) btnDown.modify(Disabled,0);
+		btnUp.repaintNow();
+		btnDown.repaintNow();
+	}
+
+	
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent &amp;&amp; ev.type==ControlEvent.PRESSED) {
+			if (ev.target==btnUp) {
+				lstShown.moveUp();
+			} else if (ev.target==btnDown) {
+				lstShown.moveDown();
+			} else if (ev.target==btnRight) {
+				// Need to leave at least one item in shown list
+				if (lstShown.items.size()&gt;1)
+					lstShown.moveItem(lstHidden,lstShown.getSelectedIndex(0));
+			} else if (ev.target==btnLeft) {
+				lstHidden.moveItem(lstShown,lstHidden.getSelectedIndex(0));
+			}
+			changeUpDownButtonStatus();
+		} else if (ev instanceof ListEvent &amp;&amp; ev.target==lstShown)
+			changeUpDownButtonStatus();
+		super.onEvent(ev);
+	}
+	
+	private class myList extends List {
+
+		//public Vector items;
+		int idx;
+		
+		myList(int rows, Vector elements) {
+			super(rows,1,false);
+			//this.items=elements;
+			items=elements;
+			modify(WantDrag,0);
+		}
+
+		// Move selected element down by one
+    	public void moveDown() {
+			idx=getSelectedIndex(0);
+    		if (idx&gt;=0) {
+	    		String s=(String) items.elementAt(idx);
+				items.removeElementAt(idx);
+	    		items.insertElementAt(s,idx+1);
+	    		select(idx+1);
+	    		repaint();
+    		}
+    	}
+    	
+    	// Move selected element up by one
+    	public void moveUp() {
+			idx=getSelectedIndex(0);
+    		if (idx&gt;=0) {
+				String s=(String) items.elementAt(idx);
+				items.removeElementAt(idx);
+	    		items.insertElementAt(s,idx-1);
+	    		select(idx-1);
+	    		repaint();
+    		}
+    	}
+    	
+    	
+		public void startDragging(DragContext dc) {
+			 idx=getSelectedIndex(0);
+			 // Can only drag if we have a valid index (at least on element in list)
+			 // Also if we drag from lstShown, we must leave at least one item in list
+			 if (idx&gt;=0 &amp;&amp; idx&lt;items.size() &amp;&amp; (this!=lstShown || items.size()&gt;1)) {
+				 IconAndText imgDrag=new IconAndText();
+				 imgDrag.addColumn(items.elementAt(idx));
+				 dc.dragData=dc.startImageDrag(imgDrag,new Point(8,8),this);
+			 }
+		}
+	
+		public void dragged(DragContext dc) {
+			if (dc.dragData!=null) dc.imageDrag();
+		}
+		 
+		public void stopDragging(DragContext dc) {
+			 if (dc.dragData==null) return;
+			 dc.stopImageDrag(true);
+			 Point p = Gui.getPosInParent(this,getWindow(),null);
+			 p.x += dc.curPoint.x;
+			 p.y += dc.curPoint.y;
+			 Control dest = getWindow().findChild(p.x,p.y);
+		     if (dest instanceof myList) { 
+		    	 moveItem((myList)dest,idx);
+		    	 changeUpDownButtonStatus();
+		     }
+		 }
+		
+		public void moveItem(myList dst, int srcIdx) {
+			 if(srcIdx&lt;0) return;
+	    	 String colToMove=(String) items.elementAt(srcIdx);
+	    	 items.removeElementAt(srcIdx);
+	    	 dst.items.add(colToMove);
+	    	 repaint();
+	    	 dst.repaint();
+	    	 if (srcIdx&gt;=items.size()) select(items.size()-1);
+		}
+	
+	} // myList
+	
+	/**
+	 * Converts a comma delimited string into an integer array.
+	 * Each value is checked and has to be between min and max, If not it is
+	 * replaced with default
+	 * @param minSize TODO
+	 */ 
+	public static int[] str2Array(String configString, int min, int max, int def, int minSize) {
+		Vector strConfigVector=new Vector(18);
+		eve.util.SubString.split(configString,',',strConfigVector);
+		int i;
+		int nElem=strConfigVector.size();
+		int []res=new int[nElem&gt;minSize?nElem:minSize];
+		for (i=0; i&lt;nElem; i++) {
+			res[i]=Common.parseInt((String)strConfigVector.elementAt(i));
+			if (res[i]&lt;min || res[i]&gt;max) res[i]=def;
+		}
+		for (i=nElem+1; i&lt;minSize; i++) res[i]=def;
+		return res;
+	}
+	
+}

Added: experiments/EVE/src/cachewolf/TableForm.java
===================================================================
--- experiments/EVE/src/cachewolf/TableForm.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/TableForm.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,22 @@
+package cachewolf;
+
+import eve.ui.CellConstants;
+import eve.ui.Form;
+
+public class TableForm extends Form {
+	public TableForm(TablePanel tp) {
+		if (Global.getPref().menuAtTop) {
+			this.addLast(Global.mainForm.mMenu,CellConstants.DONTSTRETCH, CellConstants.FILL);
+			this.addLast(tp,STRETCH,FILL);
+		} else {
+			this.addLast(tp,STRETCH,FILL);
+			this.addLast(Global.mainForm.mMenu,CellConstants.DONTSTRETCH, CellConstants.FILL);
+		}
+		this.firstFocus = tp; // give the first fokus to the list of caches, not to the main menu
+		/*
+		CellPanel[] menuList = addToolbar();
+		menuList[0].addLast(Global.mainForm.mMenu);
+		menuList[1].addLast(tp);
+		*/
+	}
+}

Added: experiments/EVE/src/cachewolf/TablePanel.java
===================================================================
--- experiments/EVE/src/cachewolf/TablePanel.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/TablePanel.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,1008 @@
+package cachewolf;
+
+import eve.sys.Convert;
+import eve.sys.Event;
+import eve.sys.Handle;
+import eve.ui.*;
+import eve.ui.event.KeyEvent;
+import eve.ui.event.PenEvent;
+import eve.ui.table.TableCellAttributes;
+import eve.ui.table.TableControl;
+import eve.ui.table.TableModel;
+
+import java.io.IOException;
+import java.util.*;
+
+import eve.fx.*;
+import eve.fx.gui.IKeys;
+import eve.io.File;
+
+/**
+*	Class to display the cache database in a table.
+*/
+public class TablePanel extends CellPanel{
+	private static final Color COLOR_SEARCH		= new Color(255,255,0);
+	private static final Color COLOR_FOUND		= new Color(152,251,152);
+	private static final Color COLOR_OWNED		= new Color(135,206,235);
+	private static final Color COLOR_AVAILABLE	= new Color(255,69,0);
+	private static final Color COLOR_ARCHIVED	= new Color(139,37,0);
+	private static final Color COLOR_SELECTED	= new Color(198,198,198);
+	private static final Color COLOR_ARCHFND_FG	= new Color(255,0,0); // Archived &amp;&amp; Found
+	private static final Color COLOR_ARCHFND_BG	= new Color(152,251,152);
+
+	ListTableControl tControl;
+	ListTableModel tModel;
+
+	Vector cacheDB;
+	//MainTab myMaintab;
+	StatusBar statBar;
+	/** We keep track of the currently selected cache in two variables(for speed)
+	 * selectedIdx is the index in cacheDB, selectedch is the actual cache
+	 * selectedIdx=-1 if no caches are visible (i.e. database empty or filtered). In
+	 * this case selectedch is &quot;null&quot;.
+	 * Otherwise selectedIdx points to a visible cache.
+	 * When the cacheDB is reorganised (by sort/filter/search), the selected cache
+	 * may end up at a new index.
+	 */
+	//int selectedIdx=0;
+	//CacheHolder selectedCh;
+
+	public TablePanel(StatusBar statBar){
+		Profile profile=Global.getProfile();
+		this.statBar = statBar;
+		cacheDB = profile.cacheDB;
+		addLast(new MyScrollBarPanel(tControl = new ListTableControl(this)));
+		if (statBar!=null) addLast(statBar,CellConstants.DONTSTRETCH, CellConstants.FILL);
+		tModel = new ListTableModel(tControl, getFontMetrics());
+		tModel.hasRowHeaders = false;
+		tModel.hasColumnHeaders  = true;
+		tControl.setTableModel(tModel);
+	}
+
+	/** Mark the row as selected so that myTableModel can color it grey */
+	public void selectRow(int row) {
+		// Ensure that the highlighted row is visible (e.g. when coming from radar panel)
+		// Next line needed for key scrolling
+		tControl.cursorTo(row, 0, true); //tc.cursor.x+tc.listMode
+	}
+
+	/** Highlight the first row in grey. It can be unhighlighted by clicking */
+	public void selectFirstRow() {
+		tModel.cursorSize=new Dimension(-1,1);
+		if (cacheDB.size()&gt;0) {
+			tControl.cursorTo(0, 0, true);
+		}
+	}
+
+	/** Returns the index of the currently selected cache or -1 of the cache is no longer visible
+	 * due to a sort/filter or search operation
+	 * @return index of selected cache (-1 if not visible)
+	 */
+	public int getSelectedCache(){
+		// If the selected Cache is no longer visible (e.g. after applying a filter)
+		// select the last row
+		if (tControl.cursor.y&gt;=tModel.numRows)
+			return tModel.numRows-1;
+		return tControl.cursor.y;
+	}
+
+	public void saveColWidth(Preferences pref){
+		String colWidths=tModel.getColWidths();
+		if (!colWidths.equals(pref.listColWidth)) {
+			pref.listColWidth=colWidths;
+			pref.savePreferences();
+		}
+	}
+
+	public void resetModel() {
+		tModel.numRows = cacheDB.size();
+		Global.getProfile().updateBearingDistance();
+		Global.getProfile().restoreFilter(true); // Restore the isActive &amp; isInverted status of the filter
+		tControl.scrollToVisible(0,0);
+		refreshTable();
+	}
+
+	/** Move all filtered caches to the end of the table and redisplay table */
+	//TODO Add a sort here to restore the sort after a filter
+	public void refreshTable(){
+		String wayPoint;
+		if (getSelectedCache() &gt;= 0)
+			wayPoint = ((CacheHolder)cacheDB.get(getSelectedCache())).wayPoint;
+		else wayPoint = null;
+		tControl.clearSelection(null); // otherwise problems when deleting last cache in list
+		Global.mainTab.tbP.updateRows();
+		// Check whether the currently selected cache is still visible
+		int rownum = 0;
+		if (wayPoint != null) {
+			rownum = Global.getProfile().getCacheIndex(wayPoint);
+			if ( (rownum &lt; 0) || (rownum&gt;=tModel.numRows) )
+				rownum = 0;
+		}
+
+		// Check whether the currently selected cache is still visible
+		selectRow(rownum);
+		tControl.update(true); // Update and repaint
+		Global.mainTab.radarP.clearRadarPanel();
+		Global.mainTab.clearDetails();
+		if (statBar!=null) statBar.updateDisplay();
+	}
+
+	/**
+	 * Similar to refreshTable but not so &quot;heavy&quot;.
+	 * Is used when user changes settings in preferences.
+	 */
+	public void refreshControl(){
+		tControl.update(true);
+	}
+
+	/**
+	 * Moves the addi waypoints just behind their main cache and hides filteres caches
+	 */
+	public void updateRows(){
+		Vector sortDB = new Vector();
+		Vector filteredDB = new Vector();
+		CacheHolder ch, addiWpt;
+		// sort cacheDB:
+		// - addi wpts are listet behind the main cache
+		// - filtered caches are moved to the end
+		int size=cacheDB.size();
+		for (int i=0; i&lt;size; i++){
+			ch = (CacheHolder) cacheDB.get(i);
+			if (ch.is_filtered) {
+				filteredDB.add(ch);
+			} else { // point is not filtered
+				if (ch.isAddiWpt()){ // unfiltered Addi Wpt
+					// check if main wpt is filtered
+					if(ch.mainCache != null) { // parent exists
+						if (ch.mainCache.is_filtered)
+							sortDB.add(ch); // Unfiltered Addi Wpt with filtered Main Wpt, show it on its own
+						// else Main cache is not filtered, Addi will be added below main cache further down
+					} else { //Addi without main Cache
+						sortDB.add(ch);
+					}
+				} else { // Main Wpt, not filtered. Check for Addis
+					sortDB.add(ch);
+					if (ch.hasAddiWpt()){
+						for (int j=0; j&lt;ch.addiWpts.size();j++){
+							addiWpt = (CacheHolder)ch.addiWpts.get(j);
+							if (!addiWpt.is_filtered) sortDB.add(addiWpt);
+						}
+					}// if hasAddiWpt
+				} // if AddiWpt
+			} // if filtered
+		}
+		// rebuild database
+		cacheDB.clear();
+		cacheDB.addAll(sortDB);
+		cacheDB.addAll(filteredDB);
+		tModel.numRows = sortDB.size();
+	}
+
+	/**
+	 * Delete all caches which have been ticked
+	 * @param showProgress Show the progress
+	 */
+	public void deleteSelectedCaches(boolean showProgress) {
+		CacheHolder ch;
+		Profile profile=Global.getProfile();
+		Handle h=null;
+		myProgressBarForm pbf=null;
+		if (showProgress) Form.showWait();
+
+		// Count # of caches to delete
+		int allCount=0;
+		int mainFilteredCount=0;
+		int addiFilteredCount=0;
+		int shouldDeleteCount=0;
+		boolean deleteFiltered=true;  // Bisheriges Verhalten
+		for(int i = cacheDB.size()-1; i &gt;=0; i--){
+			ch = (CacheHolder)cacheDB.get(i);
+			if ( ch.is_Checked) {
+				allCount++;
+				if (ch.is_filtered) {
+					if (ch.isAddiWpt()) {
+						addiFilteredCount++;
+					} else {
+						mainFilteredCount++;
+					}
+				}
+			}
+		}
+		// Warn if there are ticked but invisible caches - and ask if they should be deleted,
+		// too.
+		shouldDeleteCount = allCount;
+		if (addiFilteredCount + mainFilteredCount &gt; 0){
+			if ((new MessageBox(MyLocale.getMsg(144,&quot;Warning&quot;),
+					            MyLocale.getMsg(1029, &quot;There are caches that are ticked but invisible.\n(Main caches: &quot;) +
+					            	mainFilteredCount + MyLocale.getMsg(1030, &quot;, additional Waypoints: &quot;) +
+					            	addiFilteredCount+&quot;)\n&quot; + MyLocale.getMsg(1031, &quot;Delete them, too?&quot;),
+					            	FormBase.YESB | FormBase.NOB)).execute() == FormBase.IDYES) {
+				deleteFiltered = true;
+			} else {
+				deleteFiltered = false;
+				shouldDeleteCount = allCount - mainFilteredCount - addiFilteredCount;
+			}
+		}
+		if (shouldDeleteCount&gt;0) {
+			if ((new MessageBox(MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(1022, &quot;Delete selected caches (&quot;) + shouldDeleteCount + MyLocale.getMsg(1028, &quot;) ?&quot;), FormBase.YESB | FormBase.NOB)).execute() == FormBase.IDYES) {
+				DataMover dm=new DataMover();
+				if (showProgress) {
+					pbf = new myProgressBarForm();
+					h = new Handle();
+					pbf.setTask(h,MyLocale.getMsg(1012, &quot;Delete selected&quot;));
+					pbf.exec();
+				}
+				int nDeleted=0;
+				int size=cacheDB.size();
+				for(int i = size-1; i &gt;=0; i--){// Start Counting down, as the size decreases with each deleted cache
+					ch = (CacheHolder)cacheDB.get(i);
+					if(ch.is_Checked &amp;&amp; (!ch.is_filtered || deleteFiltered)) {
+						nDeleted++;
+						if (showProgress) {
+							h.progress = ((float)nDeleted)/(float)shouldDeleteCount;
+							h.changed();
+						}
+						dm.deleteCacheFiles(ch.wayPoint,profile.dataDir);
+						cacheDB.remove(ch);
+						ch.releaseCacheDetails();
+						ch=null;
+						if (showProgress &amp;&amp; pbf.isClosed) break;
+					}
+				}
+				if (showProgress) pbf.exit(0);
+				tModel.numRows-=nDeleted;
+				profile.saveIndex(true);
+				Global.getProfile().buildReferences();
+				refreshTable();
+			}
+		}
+		if (showProgress) Form.cancelWait();
+	}
+
+	/** Toggle the select status for a group of caches
+	 * If from==to, the addi Waypoints are also toggled if the cache is a main waypoint
+	 * If from!=to, each cache is toggled irrespective of its type (main or addi)
+	 * @param from index of first cache to toggle
+	 * @param to index of last cache to toggle
+	 * @param x is column of checkbox (does not have to be 0)
+	 */
+	void toggleSelect(int from, int to, int x) {
+		CacheHolder ch;
+		boolean singleRow= from == to;
+		for (int j=from; j&lt;=to; j++) {
+			ch=(CacheHolder) cacheDB.get(j);
+			ch.is_Checked= !ch.is_Checked;
+			tControl.repaintCell(j, x);
+			// set the ceckbox also for addi wpts
+			if (ch.hasAddiWpt() &amp;&amp; singleRow){
+				CacheHolder addiWpt;
+				int addiCount=ch.addiWpts.size();
+				for (int i=0;i&lt;addiCount;i++){
+					addiWpt = (CacheHolder)ch.addiWpts.get(i);
+					addiWpt.is_Checked = ch.is_Checked;
+					if (!addiWpt.is_filtered){
+						tControl.repaintCell(cacheDB.indexOf(addiWpt), x);
+					}
+				}
+			}
+		}
+	}
+
+	 private static class myProgressBarForm extends ProgressBarForm {
+		 boolean isClosed=false;
+		 protected boolean canExit(int exitCode) {
+			isClosed=true;
+			return true;
+		 }
+	 }
+
+
+//####################################################################################
+//   myTableControl
+//####################################################################################
+
+	/**
+	 *	Implements the user interaction of the list view. Works together with myTableModel and TablePanel
+	 */
+	public static class ListTableControl extends TableControl{
+		public Preferences pref;
+		public Profile profile;
+		public Vector cacheDB;
+		public TablePanel tbP;
+		private MenuItem miOpen,miGoto, miCenter, miOpenOnline, miOpenOffline, miDelete,miUpdate,
+		        miTickAll, miUntickAll,miSeparator;
+		private MenuItem[] mnuFull;
+		private MenuItem[] mnuSmall;
+		private Menu mFull,mSmall;
+		private Rect oldCursor=new Rect();
+		private Rect rbuff=new Rect();
+
+		ListTableControl(TablePanel tablePanel) {
+			mnuFull=new MenuItem[12];
+			mnuFull[0]= miOpen		= new MenuItem(MyLocale.getMsg(1021,&quot;Open description&quot;));
+			mnuFull[1]= miGoto			= new MenuItem(MyLocale.getMsg(1010,&quot;Goto&quot;));
+			mnuFull[2]= miCenter		= new MenuItem(MyLocale.getMsg(1019,&quot;Set this as center&quot;));
+			mnuFull[3]= miSeparator	= new MenuItem(&quot;-&quot;);
+			mnuFull[4]= miOpenOnline 	= new MenuItem(MyLocale.getMsg(1020,&quot;Open in $browser online&quot;));
+			mnuFull[5]= miOpenOffline	= new MenuItem(MyLocale.getMsg(1018,&quot;Open in browser offline&quot;));
+			mnuFull[6]= miSeparator;
+			mnuFull[7]= miDelete= new MenuItem(MyLocale.getMsg(1012,&quot;Delete selected&quot;));
+			mnuFull[8] = miUpdate = new MenuItem(MyLocale.getMsg(1014,&quot;Update&quot;));
+			mnuFull[9]= miSeparator;
+			mnuFull[10]= miTickAll	= new MenuItem(MyLocale.getMsg(1015,&quot;Select all&quot;));
+			mnuFull[11]=miUntickAll	= new MenuItem(MyLocale.getMsg(1016,&quot;De-select all&quot;));
+			mFull = new Menu(mnuFull,&quot;&quot;);
+
+			mnuSmall=new MenuItem[6];
+			mnuSmall[0]= miOpen;
+			mnuSmall[1]= miGoto;
+			mnuSmall[2]= miCenter;
+			mnuSmall[3]= miSeparator;
+			mnuSmall[4]= miOpenOnline;
+			mnuSmall[5]= miOpenOffline;
+			mSmall = new Menu(mnuSmall,&quot;&quot;);
+			profile=Global.getProfile();
+			cacheDB = profile.cacheDB;
+			pref = Global.getPref();
+			tbP =tablePanel;
+			allowDragSelection = false; // allow only one row to be selected at one time
+			modify(WantDrag,0);
+		}
+
+		/** Full menu when tablePanel includes checkbox */
+		public void setMenuFull() {
+			setMenu(mFull);
+		}
+
+		public Menu getMenuFull() {
+			return mFull;
+		}
+
+		/** Small menu when tablePanel does not include checkbox */
+		public void setMenuSmall() {
+			setMenu(mSmall);
+		}
+		public Menu getMenuSmall() {
+			return mSmall;
+		}
+
+		/** Set all caches either as selected or as deselected, depending on argument */
+		private void setTickForAll(boolean selectStatus) {
+			Global.getProfile().setSelectForAll(selectStatus);
+			this.repaint();
+		}
+
+		/** always select a whole row */
+		public boolean isSelected(int row,int col) {
+			return row==selection.y;
+		}
+
+		//============================= Event Handlers =============================
+		public void onEvent(Event ev) {
+			// If we changed the cache (e.g. via radar panel, we have to clear the details */
+			//if (ev instanceof TableEvent) Global.mainTab.clearDetails();
+			if (ev instanceof PenEvent &amp;&amp; (ev.type == PenEvent.PEN_DOWN) ){
+				Global.mainTab.tbP.tModel.penEventModifiers=((PenEvent)ev).modifiers;
+		    }
+			super.onEvent(ev);
+		}
+		// penPressed is in Model
+		public void penRightReleased(Point p){
+			if (cacheDB.size()&gt;0) // No context menu when DB is empty
+				menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
+		}
+		public void penHeld(Point p){
+			if (cacheDB.size()&gt;0) // No context menu when DB is empty
+				menuState.doShowMenu(p,true,null);
+		}
+		public void penDoubleClicked(Point where) {
+			Global.mainTab.select(Global.mainTab.descP);
+		}
+
+	 /**
+	  * this is only necessary to hinder the user to unselect - not clear why this is needed
+	  */
+/*		 public void penReleased(Point p,boolean isDouble) {
+			 Point p2 = cellAtPoint(p.x,p.y,null);
+			 super.penReleased(p, isDouble);
+			 Rect sel = getSelection(null);
+			 if ((sel.height == 0 || sel.height == 0) &amp;&amp; p2 != null) cursorTo(p2.y,p2.x, true); // if the selection is gone -&gt; reselect it
+
+		 }
+*/		public void onKeyEvent(KeyEvent ev) {
+			if (ev.type == KeyEvent.KEY_PRESS &amp;&amp; ev.target == this){
+				if ( (ev.modifiers &amp; IKeys.CONTROL) &gt; 0 &amp;&amp; ev.key == 1){ // &lt;ctrl-a&gt; gives 1, &lt;ctrl-b&gt; == 2
+					// select all on &lt;ctrl-a&gt;
+					setTickForAll(true);
+					ev.consumed = true;
+				}else {
+					Global.mainTab.clearDetails();
+					if (ev.key == IKeys.HOME) tbP.selectRow(0); //  cursorTo(0,cursor.x+listMode,true);
+					else if (ev.key == IKeys.END) tbP.selectRow(model.numRows-1); //cursorTo(model.numRows-1,cursor.x+listMode,true);
+					else if (ev.key == IKeys.PAGE_DOWN) tbP.selectRow(java.lang.Math.min(cursor.y+ getOnScreen(null).height-1, model.numRows-1)); //cursorTo(java.lang.Math.min(cursor.y+ getOnScreen(null).height-1, model.numRows-1),cursor.x+listMode,true); // I don't know why this doesn't work: tbp.doScroll(IScroll.Vertical, IScroll.PageHigher, 1);
+					else if (ev.key == IKeys.PAGE_UP) tbP.selectRow(java.lang.Math.max(cursor.y-getOnScreen(null).height+1, 0)); // cursorTo(java.lang.Math.max(cursor.y-getOnScreen(null).height+1, 0),cursor.x+listMode,true);
+					else if (ev.key == IKeys.ACTION || ev.key == IKeys.ENTER) Global.mainTab.select(Global.mainTab.descP);
+					else if (ev.key == IKeys.DOWN) tbP.selectRow(java.lang.Math.min(cursor.y+ 1, model.numRows-1));
+					else if (ev.key == IKeys.UP) tbP.selectRow(java.lang.Math.max(cursor.y-1, 0));
+					else if (ev.key == IKeys.LEFT &amp;&amp; Global.mainForm.cacheListVisible &amp;&amp; cursor.y&gt;=0 &amp;&amp; cursor.y&lt;tbP.tModel.numRows) Global.mainForm.cacheList.addCache(((CacheHolder)cacheDB.elementAt(cursor.y)).wayPoint);
+					else if (ev.key == IKeys.RIGHT) {
+						CacheHolder ch;
+						ch = (CacheHolder)cacheDB.get(tbP.getSelectedCache());
+						Global.mainTab.gotoPoint(ch.pos);
+					}
+					else if (ev.key == 6 ) MainMenu.search(); // (char)6 == ctrl + f
+					else super.onKeyEvent(ev);
+				}
+			}
+			else super.onKeyEvent(ev);
+		}
+
+		public void popupMenuEvent(Object selectedItem){
+			if (selectedItem == null) return;
+			CacheHolder ch;
+			if (selectedItem==miOpen){
+				penDoubleClicked(null);
+			} else if (selectedItem==miGoto){
+				ch = (CacheHolder)cacheDB.get(tbP.getSelectedCache());
+				Global.mainTab.gotoPoint(ch.pos);
+			} else if (selectedItem==miCenter){
+				if (Global.mainTab.tbP.getSelectedCache() &lt; 0) {
+					Global.getPref().log(&quot;popupMenuEvent: getSelectedCache() &lt; 0&quot;);
+					return;
+				}
+				CacheHolder thisCache = (CacheHolder)cacheDB.get(tbP.getSelectedCache());
+				CWPoint cp=new CWPoint(thisCache.latLon);
+				if (!cp.isValid()){
+					MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(4111,&quot;Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM&quot;), MessageBox.OKB);
+					tmpMB.execute();
+				} else {
+					pref.curCentrePt.set(cp);
+					Global.getProfile().updateBearingDistance();
+					this.repaint();
+				}
+			} else if (selectedItem==miOpenOnline){
+				if(browserPathIsValid()){
+					ch = (CacheHolder)cacheDB.get(tbP.getSelectedCache());
+					CacheHolderDetail chD=ch.getCacheDetails(false, true);
+					try {
+						if (chD != null) {
+							String cmd = &quot;\&quot;&quot;+pref.browser+ &quot;\&quot; \&quot;&quot; + chD.URL+&quot;\&quot;&quot;;
+							eve.sys.Vm.execCommandLine(cmd);
+						}
+					} catch (IOException ex) {
+						(new MessageBox(&quot;Error&quot;, &quot;Cannot start browser!\n&quot;+ex.toString()+&quot;\nThe are two possible reasons:\n * path to internet browser in \npreferences not correct\n * An bug in eve VM, please be \npatient for an update&quot;,MessageBox.OKB)).execute();
+					}
+				}
+			} else if (selectedItem==miOpenOffline) {
+				if(browserPathIsValid()){
+					ShowCacheInBrowser sc= new ShowCacheInBrowser();
+					sc.showCache(((CacheHolder)cacheDB.get(tbP.getSelectedCache())).getCacheDetails(false, true));
+				}
+			} else if (selectedItem==miDelete){
+				tbP.deleteSelectedCaches(true);
+			} else if (selectedItem==miTickAll){
+				setTickForAll(true);
+			} else if (selectedItem==miUntickAll){
+				setTickForAll(false);
+			} else if (selectedItem == miUpdate){
+				MainMenu.updateSelectedCaches(tbP);
+			}
+		}
+
+		public boolean browserPathIsValid() {
+			if(!new eve.io.File(pref.browser).exists()){
+				(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(1032,&quot;Path to browser:&quot;)+&quot;\n&quot;+pref.browser+&quot;\n&quot;+MyLocale.getMsg(1033,&quot;is incorrect!&quot;),FormBase.OKB)).execute();
+				return false;
+			} else
+				return true;
+		}
+
+
+
+
+	    ///////////////////////////////////////////////////
+		//  Allow the caches to be dragged into a cachelist
+	    ///////////////////////////////////////////////////
+
+		IconAndText imgDrag;
+		String wayPoint;
+		int row;
+
+		public void startDragging(DragContext dc) {
+			Vector cacheDB=Global.getProfile().cacheDB;
+			 Point p=cellAtPoint(dc.start.x,dc.start.y,null);
+			 wayPoint=null;
+			 if (p.y&gt;=0) {
+				if (!Global.mainForm.cacheListVisible) {
+					dc.cancelled=true;
+					return;
+				}
+				 row=p.y;
+				 CacheHolder ch=(CacheHolder)cacheDB.get(p.y);
+				 wayPoint=ch.wayPoint;
+				 //Vm.debug(&quot;Waypoint : &quot;+ch.wayPoint);
+				 imgDrag=new IconAndText();
+				 imgDrag.addColumn( CacheType.cache2Img(ch.type));
+				 imgDrag.addColumn(ch.wayPoint);
+				 dc.dragData=dc.startImageDrag(imgDrag,new Point(8,8),this);
+			 } else super.startDragging(dc);
+		 }
+
+		 public void stopDragging(DragContext dc) {
+			 if (wayPoint!=null &amp;&amp; !dc.cancelled) {
+				 //Vm.debug(&quot;Stop  Dragging&quot;+dc.curPoint.x+&quot;/&quot;+dc.curPoint.y);
+				 dc.stopImageDrag(true);
+				 Point p = Gui.getPosInParent(this,getWindow(),null);
+				 p.x += dc.curPoint.x;
+				 p.y += dc.curPoint.y;
+				 Control c = getWindow().findChild(p.x,p.y);
+			     if (c instanceof eve.ui.List &amp;&amp; c.text.equals(&quot;CacheList&quot;)) {
+			    	 if (Global.mainForm.cacheList.addCache(wayPoint)) {
+			    		 c.repaintNow();
+			    		 ((eve.ui.List) c).makeItemVisible(((eve.ui.List)c).itemsSize()-1);
+			    	 }
+			     }
+			     Global.mainTab.tbP.selectRow(row);
+				 //Vm.debug(&quot;Control &quot;+c.toString()+&quot;/&quot;+c.text);
+			 }else super.stopDragging(dc);
+		 }
+
+		 public void dragged(DragContext dc) {
+		 	if (wayPoint!=null)
+			   dc.imageDrag();
+		 	else
+		 		super.dragged(dc);
+		 }
+
+		 public void cursorTo(int row,int col,boolean selectNew) {
+			col=0;
+			if (row != -2 &amp;&amp; col != -2 &amp;&amp; !canSelect(row,col)) return;
+			oldCursor.set(cursor.x,cursor.y,tbP.tModel.numCols,1);
+			cursor.set(col,row);
+			if (selectNew){
+/*				Vector v = (Vector)Cache.get(Vector.class);
+				clearSelectedCells(v);
+				paintCells(v);
+				v.removeAllElements();
+				Cache.put(v);
+*/				if (row != -2 &amp;&amp; col != -2){
+					if (scrollToVisible(row,col)) repaintNow();
+					addToSelection(rbuff.set(0,row,tbP.tModel.numCols,1),false,true);
+					//fireSelectionEvent(TableEvent.FLAG_SELECTED_BY_ARROWKEY);
+					//clickedFlags = TableEvent.FLAG_SELECTED_BY_ARROWKEY;
+					//if (clickMode) clicked(row,col);
+					//clickedFlags = 0;
+				}
+				paintCells(oldCursor);
+			}
+		 }
+	}
+
+//####################################################################################
+//  MyTableModel
+//####################################################################################
+	/**
+	*	Table model used to display the cache list.
+	* 	Used by the table control in the first panel of
+	*	CacheWolf.
+	*/
+	public static class ListTableModel extends TableModel{
+
+		public static final int MAXCOLUMNS=14;
+		// Colors for Cache status (BG unless otherwise stated)
+		private Vector cacheDB;
+		/** How the columns are mapped onto the list view. If colMap[i]=j, it means that
+		 * the element j (as per the list below) is visible in column i.
+		 * [0]TickBox, [1]Type, [2]Distance, [3]Terrain, [4]waypoint, [5]name, [6]coordinates,
+		 * [7]owner, [8]datehidden, [9]status, [10]distance, [11]bearing, [12] Size, [13] # of OC recommend.
+		 * [14] OC index
+		 */
+		private int[] colMap;
+		/** The column widths corresponding to the list of columns above */
+		private int[] colWidth;
+		private String [] colName = {&quot; &quot;,&quot;?&quot;,MyLocale.getMsg(1000,&quot;D&quot;),MyLocale.getMsg(1001,&quot;T&quot;),
+				MyLocale.getMsg(1002,&quot;Waypoint&quot;),&quot;Name&quot;,MyLocale.getMsg(1004,&quot;Location&quot;),
+				MyLocale.getMsg(1005,&quot;Owner&quot;),MyLocale.getMsg(1006,&quot;Hidden&quot;),MyLocale.getMsg(1007,&quot;Status&quot;),
+				MyLocale.getMsg(1008,&quot;Dist&quot;),MyLocale.getMsg(1009,&quot;Bear&quot;),MyLocale.getMsg(1017,&quot;S&quot;),
+				MyLocale.getMsg(1026,&quot;#Rec&quot;),MyLocale.getMsg(1027,&quot;OC-IDX&quot;)};
+
+		private Picture noFindLogs[] = new Picture[4];
+		private Picture red, blue, yellow, skull, checkboxTicked,checkboxUnticked,bug;
+		private boolean sortAsc = false;
+		private int sortedBy = -1;
+		private FontMetrics fm;
+		private Picture picSizeMicro,picSizeSmall,picSizeReg,picSizeLarge,picSizeVLarge;
+		/** This is the modifier (Shift &amp; Control key status) for Pen Events
+		 * it is set in myTableControl.onEvent */
+		public int penEventModifiers;
+		private ListTableControl tcControl;
+		public boolean showExtraWptInfo=true;
+		private IconAndText iAndT = new IconAndText();
+		private IconAndText wpVal = new IconAndText();
+
+		public ListTableModel(ListTableControl tc, FontMetrics fm){
+			super();
+			cacheDB = Global.getProfile().cacheDB;
+			this.fm = fm;
+			tcControl = tc;
+			setColumnNamesAndWidths();
+			//this.numRows = cacheDB.size();
+			//Dimension selrow = new Dimension(-1,1);
+			//this.cursorSize = selrow;
+			noFindLogs[0] = new Picture(&quot;no_1_log.png&quot;);
+			noFindLogs[1] = new Picture(&quot;no_2_log.png&quot;);
+			noFindLogs[2] = new Picture(&quot;no_3_log.png&quot;);
+			noFindLogs[3] = new Picture(&quot;no_4_log.png&quot;);
+			red = new Picture(&quot;red.png&quot;,Color.White,0);
+			blue = new Picture(&quot;blue.png&quot;,Color.White,0);
+			//green = new Picture(&quot;green.png&quot;,Color.White,0);
+			yellow = new Picture(&quot;yellow.png&quot;,Color.White,0);
+			skull = new Picture(&quot;skull.png&quot;,Color.DarkBlue,0);
+			bug = new Picture(&quot;bug_table.png&quot;,Color.DarkBlue,0);
+			checkboxTicked = new Picture(&quot;checkboxTicked.png&quot;);
+			checkboxUnticked= new Picture(&quot;checkboxUnticked.png&quot;);
+			picSizeMicro=new Picture(&quot;sizeMicro.png&quot;,Color.White,0);
+			picSizeSmall=new Picture(&quot;sizeSmall.png&quot;,Color.White,0);
+			picSizeReg=new Picture(&quot;sizeReg.png&quot;,Color.White,0);
+			picSizeLarge=new Picture(&quot;sizeLarge.png&quot;,Color.White,0);
+			picSizeVLarge=new Picture(&quot;sizeVLarge.png&quot;,Color.White,0);
+			iAndT.fontMetrics=fm;
+			wpVal.fontMetrics=fm;
+			//updateRows();
+		}
+
+		/**
+		 * Sets the column names and widths from preferences
+		 *
+		 */
+		public void setColumnNamesAndWidths() {
+			colMap=TableColumnChooser.str2Array(Global.getPref().listColMap,0,14,0, -1);
+			colWidth=TableColumnChooser.str2Array(Global.getPref().listColWidth,10,1024,50, colMap.length);
+			numCols=colMap.length;
+			clearCellAdjustments();
+			// If the displayed columns include the checkbox, we use the full menu
+			if ((&quot;,&quot;+Global.getPref().listColMap+&quot;,&quot;).indexOf(&quot;,0,&quot;)&gt;=0)
+				tcControl.setMenuFull();
+			else
+				tcControl.setMenuSmall();
+		}
+
+		/**
+		 * Return the column widths as a comma delimited string for storing in the preferences
+		 * @return
+		 */
+		public String getColWidths() {
+			// Update the list with the current widths
+			for (int col=0; col&lt;numCols; col++) {
+				colWidth[colMap[col]]=getColWidth(col);
+			}
+			clearCellAdjustments();
+			// Convert to string
+			StringBuffer sb=new StringBuffer(40);
+			for (int i=0; i&lt;colWidth.length; i++) {
+				if (sb.length()!=0) sb.append(',');
+				sb.append(colWidth[i]);
+			}
+			return sb.toString();
+		}
+
+		public int calculateRowHeight(int row){
+			return java.lang.Math.max(18, charHeight+4);
+		}
+
+		public int calculateColWidth(int col){
+			if(col == -1)
+	        	return 0;
+	        else if (col&lt;numCols)
+	        	return colWidth[colMap[col]];
+	        else return 0;
+		}
+
+		/**
+		* Method to set the row color of the table displaying the
+		* cache list, depending on different flags set to the cache.
+		*/
+		public TableCellAttributes getCellAttributes(int row,int col,boolean  isSelected, TableCellAttributes ta){
+			ta = super.getCellAttributes(row, col, isSelected, ta);
+			ta.alignment = CellConstants.LEFT;
+			ta.anchor = CellConstants.LEFT;
+			if(row &gt;= 0){
+				try {
+				   CacheHolder ch = (CacheHolder)cacheDB.get(row);
+					if(isSelected == true) ta.fillColor = COLOR_SELECTED;
+					else if(ch.is_available == false &amp;&amp; ch.is_found == true){
+						ta.fillColor = COLOR_ARCHFND_BG;   // Green BG
+						ta.foreground = COLOR_ARCHFND_FG;  // Red FG
+					}
+					else if(ch.is_archived == true) ta.fillColor = COLOR_ARCHIVED;
+					else if(ch.is_available == false) ta.fillColor = COLOR_AVAILABLE;
+					else if(ch.is_owned == true) ta.fillColor = COLOR_OWNED;
+					else if(ch.is_found == true)
+						ta.fillColor = COLOR_FOUND;
+					else if(ch.is_flagged == true) ta.fillColor = COLOR_SEARCH;
+				} catch (Exception e) {};
+			} else if (row==-1 &amp;&amp; colMap[col]==0 &amp;&amp; Global.getProfile().showBlacklisted) ta.fillColor=Color.Black;
+			return ta;
+		}
+
+		/**
+		 * Return the data in a cell
+		 */
+		public Object getCellData(int row, int col){
+			if(row == -1) return colName[colMap[col]];
+			try { // Access to row can fail if many caches are deleted
+				CacheHolder ch = (CacheHolder)cacheDB.get(row);
+				if(ch.is_filtered == false){
+					switch(colMap[col]) { // Faster than using column names
+						case 0: // Checkbox
+							if (ch.is_Checked)
+								return checkboxTicked;
+							return checkboxUnticked;
+						case 1: // Type
+							return  CacheType.cache2Img(ch.type);
+						case 2: // Difficulty;
+							return ch.hard;
+						case 3: // Terrain
+							return ch.terrain;
+						case 4: // Waypoint
+							if (showExtraWptInfo) {
+/*								if(ch.is_incomplete) return new IconAndText(skull, ch.wayPoint, fm);
+								if(ch.is_new       ) return new IconAndText(yellow, ch.wayPoint, fm);
+								if(ch.is_update    ) return new IconAndText(red, ch.wayPoint, fm); // TODO this is for sure quite inefficient, better store it, don't create always new when the table is refreshed or only scrolled
+								if(ch.is_log_update) return new IconAndText(blue, ch.wayPoint, fm);*/
+								if(ch.is_incomplete) {
+									iAndT.set(skull,ch.wayPoint);
+									return iAndT;
+								}
+								if(ch.is_new       )  {
+									iAndT.set(yellow,ch.wayPoint);
+									return iAndT;
+								}
+								if(ch.is_update    ) {
+									iAndT.set(red,ch.wayPoint);
+									return iAndT;
+								}
+								if(ch.is_log_update) {
+									iAndT.set(blue,ch.wayPoint);
+									return iAndT;
+								}
+							}
+							return ch.wayPoint;
+						case 5: // Cachename
+							// Fast return for majority of case
+							if (!showExtraWptInfo || (ch.has_bug == false &amp;&amp; ch.noFindLogs==0)) return ch.cacheName;
+							wpVal.clearColumns();
+							// Now need more checks
+							if(ch.has_bug == true) wpVal.addColumn(bug);
+							if(ch.noFindLogs &gt; 0){
+								if (ch.noFindLogs &gt; noFindLogs.length)
+									wpVal.addColumn(noFindLogs[noFindLogs.length-1]);
+								else
+									wpVal.addColumn(noFindLogs[ch.noFindLogs-1]);
+							}
+							wpVal.addColumn(ch.cacheName);
+							return wpVal;
+						case 6: // Location
+							return ch.latLon;
+						case 7: // Owner
+							return ch.cacheOwner;
+						case 8: // Date hidden
+							return ch.dateHidden;
+						case 9: // Status
+							return ch.cacheStatus;
+						case 10: // Distance
+							return ch.distance;
+						case 11: // Bearing
+							return ch.bearing;
+						case 12: // Size
+							if (ch.cacheSize.length()==0) return &quot;?&quot;;
+							switch (ch.cacheSize.charAt(0)) {
+								case 'M': return picSizeMicro;
+								case 'S': return picSizeSmall;
+								case 'R': return picSizeReg;
+								case 'L': return picSizeLarge;
+								case 'V': return picSizeVLarge;
+								default: return &quot;?&quot;;
+							}
+						case 13: // OC number of recommendations
+							if (ch.wayPoint.startsWith(&quot;OC&quot;))
+								return Convert.formatInt(ch.numRecommended);
+							return null;
+						case 14: // OC rating
+							if (ch.wayPoint.startsWith(&quot;OC&quot;))
+								return Convert.formatInt(ch.recommendationScore);
+							return null;
+					} // Switch
+				} // if
+			} catch (Exception e) { return null; }
+			return null;
+		}
+
+		public boolean penPressed(Point onTable,Point cell){
+			boolean retval = false;
+			if (cell==null) return false;
+			try{
+				// Check whether the click is on the checkbox image
+				if (cell.y&gt;=0 &amp;&amp; colMap[cell.x]==0) {
+					Global.getProfile().selectionChanged = true;
+					if ((penEventModifiers &amp; IKeys.SHIFT)&gt;0) {
+						if (tcControl.cursor.y &gt;= 0) { // Second row being marked with shift key pressed
+							if (tcControl.cursor.y&lt;cell.y)
+								tcControl.tbP.toggleSelect(tcControl.cursor.y+1,cell.y,cell.x);
+							else
+								tcControl.tbP.toggleSelect(cell.y,tcControl.cursor.y-1,cell.x);
+						} else { // Remember this row as start of range, but don't toggle yet
+						}
+					} else { // Single row marked
+						tcControl.tbP.toggleSelect(cell.y,cell.y,cell.x);
+					}
+				}
+				if(cell.y == -1){ // Hit a header =&gt; sort the table accordingly
+					CacheHolder ch=null;
+					// cell.x is the physical column but we have to sort by the
+					// column it is mapped into
+					int mappedCol=colMap[cell.x];
+					if (mappedCol==0) { // Click on Tickbox header
+						// Hide/unhide the additional information about a waypoint such as
+						// travelbugs/number of notfound logs/yellow circle/red circle etc.
+						// This helps on small PDA screens
+						showExtraWptInfo=!showExtraWptInfo;
+						this.table.repaint();
+						return true;
+					}
+					Form.showWait();
+					Point a = tcControl.getSelectedCell(null);
+					if((a != null) &amp;&amp; (a.y &gt;= 0) &amp;&amp; (a.y &lt; cacheDB.size())) ch = (CacheHolder)cacheDB.get(a.y);
+					if (mappedCol == sortedBy) sortAsc=!sortAsc;
+					else sortAsc = false;
+					sortedBy = mappedCol;
+					eve.util.Utils.sort(new Handle(), cacheDB,new MyComparer(cacheDB, mappedCol,numRows), sortAsc );
+					Global.mainTab.tbP.updateRows();
+					if(a != null){
+						int rownum = Global.getProfile().getCacheIndex(ch.wayPoint);
+						if(rownum &gt;= 0){
+							tcControl.cursorTo(rownum, 0, true);
+		/*					tcControl.scrollToVisible(rownum, 0);
+							tcControl.clearSelectedCells(new Vector());
+							for(int i= 0; i &lt; MAXCOLUMNS; i++){
+								tcControl.addToSelection(rownum,i);
+							}
+			*/			}
+					}
+					Form.cancelWait();
+					tcControl.update(true);
+					retval = true;
+				}
+			} catch(NullPointerException npex){
+				Form.cancelWait();
+				Global.getPref().log(&quot;NPE in MyTableModel.Penpressed&quot;);}
+			return retval;
+		}
+
+		public void select(int row,int col,boolean selectOn) {
+			tcControl.cursorTo(row, col, true);
+		}
+
+
+
+//####################################################################################
+// MyComparer
+//####################################################################################
+
+		/**
+		*	This class handles the sorting for most of the sorting tasks. If a cache is
+		*	to be displayed in the table or not is handled in the table model
+		*	@see ListTableModel
+		*	@see DistComparer
+		*/
+		public static class MyComparer implements eve.util.Comparer{
+
+			public MyComparer(Vector cacheDB, int colToCompare, int visibleSize){
+				if (visibleSize&lt;2) return;
+				for (int i=visibleSize; i&lt;cacheDB.size(); i++) {
+					CacheHolder ch=(CacheHolder) cacheDB.get(i);
+					ch.sort=&quot;\uFFFF&quot;;
+				}
+				if (colToCompare==1) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						ch.sort=(&quot;000&quot;+String.valueOf(ch.type)).substring(0,4);
+					}
+				} else if (colToCompare==2) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						ch.sort=ch.hard;
+					}
+				} else if (colToCompare==3) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						ch.sort=ch.terrain;
+					}
+				} else if (colToCompare==4) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						ch.sort=ch.wayPoint.toUpperCase();
+					}
+				} else if (colToCompare==5) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						ch.sort=ch.cacheName.toLowerCase();
+					}
+				} else if (colToCompare==6) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						ch.sort=ch.latLon;
+					}
+				} else if (colToCompare==7) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						ch.sort=ch.cacheOwner.toLowerCase();
+					}
+				} else if (colToCompare==8) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						ch.sort=ch.dateHidden;
+					}
+				} else if (colToCompare==9) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						ch.sort=ch.cacheStatus;
+					}
+				} else if (colToCompare==10) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						int p=ch.distance.indexOf(&quot;,&quot;);
+						if (p&lt;0) p=ch.distance.indexOf(&quot;.&quot;);
+						if (p&gt;=0 &amp;&amp; p&lt;=5)
+							ch.sort=&quot;00000&quot;.substring(0,5-p)+ch.distance;
+						else
+							ch.sort=ch.distance;
+					}
+				} else if (colToCompare==11) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						ch.sort=ch.bearing;
+					}
+
+				} else if (colToCompare==12) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						if (ch.cacheSize.length()==0) ch.sort=&quot;?&quot;;
+						else switch (ch.cacheSize.charAt(0)) {
+							case 'M': ch.sort=&quot;1&quot;; break;
+							case 'S': ch.sort=&quot;2&quot;; break;
+							case 'R': ch.sort=&quot;3&quot;; break;
+							case 'L': ch.sort=&quot;4&quot;; break;
+							case 'V': ch.sort=&quot;5&quot;; break;
+							default: ch.sort=&quot;?&quot;;
+						}
+					}
+				} else if (colToCompare==13) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						if (ch.wayPoint.startsWith(&quot;OC&quot;))
+							ch.sort=MyLocale.formatLong(ch.numRecommended,&quot;00000&quot;);
+						else
+							ch.sort=&quot;\uFFFF&quot;;
+					}
+				} else if (colToCompare==14) {
+					for (int i=0; i&lt;visibleSize; i++) {
+						CacheHolder ch=(CacheHolder) cacheDB.get(i);
+						if (ch.wayPoint.startsWith(&quot;OC&quot;))
+							ch.sort=MyLocale.formatLong(ch.recommendationScore,&quot;00000&quot;);
+						else
+							ch.sort=&quot;\uFFFF&quot;;
+					}
+				}
+			}
+
+			public int compare(Object o1, Object o2){
+				CacheHolder oo1 = (CacheHolder)o1;
+				CacheHolder oo2 = (CacheHolder)o2;
+				return oo1.sort.compareTo(oo2.sort);
+			}
+		}
+	} // MyTableModel
+} // TablePanel
+
+

Added: experiments/EVE/src/cachewolf/Test.java
===================================================================
--- experiments/EVE/src/cachewolf/Test.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/Test.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,151 @@
+package cachewolf;
+
+import eve.sys.*;
+import com.stevesoft.eve_pat.*;
+import java.lang.Math;;
+ 
+
+public class Test extends mThread{
+	boolean allPassed=true; 
+	public static void main(String args[]) {
+		new Test().start();
+	}
+
+	public void run() {
+		testAll();
+	}
+	void testAll(){
+//		testPerformance();
+	    Regex r = new Regex(&quot;x\\s*(a|b)y&quot;);
+	    r.search(&quot;abcx   ay&quot;);
+	    eve.sys.Vm.debug(&quot;sub = &quot;+r.stringMatched(1));
+		
+		Regex rex = new Regex(&quot;(?:&quot; +
+		&quot;([NSns])\\s*([0-9]{1,2})(?:[&#176;\uC2B0]\\s*|\\s+[&#176;\uC2B0]?\\s*)([0-9]{1,2})(?:(?:['&#146;]\\s*|\\s+['&#146;]?\\s*)([0-9]{1,2}))?(?:[,.]([0-9]{1,8}))?\\s*['&#146;\&quot;]?\\s*&quot; +
+		&quot;([EWewOo])\\s*([0-9]{1,3})(?:[&#176;\uC2B0]\\s*|\\s+[&#176;\uC2B0]?\\s*)([0-9]{1,2})(?:(?:['&#146;]\\s*|\\s+['&#146;]?\\s*)([0-9]{1,2}))?(?:[,.]([0-9]{1,8}))?\\s*['&#146;\&quot;]?&quot; +
+		&quot;)|(?:&quot; +
+		&quot;(?:([NnSs])\\s*(?![+-]))?&quot;   +     &quot;([+-]?[0-9]{1,2})[,.]([0-9]{1,8})(?:(?=[+-EeWwOo])|\\s+|\\s*[&#176;\uC2B0]\\s*)&quot; +
+	  	&quot;(?:([EeWwOo])\\s*(?![+-]))?&quot;    +     &quot;([+-]?[0-9]{1,3})[,.]([0-9]{1,8})\\s*[&#176;\uC2B0]?&quot; +
+		&quot;)|(?:&quot; +
+		&quot;([0-9]{1,2}[C-HJ-PQ-X])\\s*[EeOo]?\\s*([0-9]{1,7})\\s+[Nn]?\\s*([0-9]{1,7})&quot; +
+		&quot;)|(?:&quot; +
+		&quot;[Rr]:?\\s*([+-]?[0-9]{1,7})\\s+[Hh]:?\\s*([+-]?[0-9]{1,7})&quot; +
+		&quot;)&quot;);		
+	    rex.search(&quot;N 23&#176; 12.1234 E 23&#176; 45.234&quot;);
+	    eve.sys.Vm.debug(&quot;rex = &quot;+rex.stringMatched(1)+&quot; &quot;+rex.stringMatched(2)+&quot; &quot;+rex.stringMatched(3)+&quot; &quot;+rex.stringMatched(4)+
+	    		&quot; &quot;+rex.stringMatched(5)+&quot; &quot;+rex.stringMatched(6)+&quot; &quot;+rex.stringMatched(7)+&quot; &quot;+rex.stringMatched(8)+&quot; &quot;+rex.stringMatched(9)+
+	    		&quot; &quot;+rex.stringMatched(10)
+	    );
+	    
+		//testRegex();
+		if (allPassed) 
+			Vm.debug(&quot;SUCCESS: All tests passed&quot;); 
+		else  
+			Vm.debug(&quot;FAILURE: At least one test failed&quot;); 
+	}
+	void testPerformance(){
+		Time start, end;
+		int i;
+		double tmp=0.0;
+		
+		// 100.000 Sinus
+		start = new Time();
+		for (i=0; i&lt;100000; i++){
+			tmp = Math.sin(53);
+		}
+		tmp=tmp+0;
+		end = new Time();
+		printResult(&quot;sin(53)&quot;, start, end, i);
+		
+		// 1.000 CWPoint via constructor
+		start = new Time();
+		for (i=0; i&lt;100; i++){
+			new CWPoint(&quot;N 51&#176; 27.635 E 009&#176; 37.621&quot;, CWPoint.CW);
+		}
+		end = new Time();
+		printResult(&quot;CWPoint(\&quot;N 51&#176; 27.635 E 009&#176; 37.621\&quot;, CWPoint.CW)&quot;, start, end, i);
+
+		// 1.000 CWPoint via constructor ohne Lat/Lon
+		start = new Time();
+		for (i=0; i&lt;100; i++){
+			CWPoint cwP = new CWPoint();
+			cwP.set(&quot;N 51&#176; 27.635 E 009&#176; 37.621&quot;, CWPoint.CW);
+			
+		}
+		end = new Time();
+		printResult(&quot;cwp = new CWPoint(); cwp.set(\&quot;N 51 27.635 E 009 37.621\&quot;, CWPoint.CW); &quot;, start, end, i);
+
+		// 1.000 CWPoint via constructor ohne Lat/Lon
+		start = new Time();
+		CWPoint[] a = new CWPoint[10000];
+		for (i=0; i&lt;10000; i++){
+			CWPoint cwP = new CWPoint(20, 20);
+			cwP.latDec = 41.123;
+			cwP.lonDec = 9.2388;
+			a[i] = cwP;
+		}
+		end = new Time();
+		printResult(&quot;cwp = new CWPoint(); cwP.latDec = 41.123; cwP.lonDec = 9.2388;&quot;, start, end, i);
+
+		// 1.000 CWPoint via set
+		start = new Time();
+		CWPoint cwSet = new CWPoint();
+		for (i=0; i&lt;100; i++){
+			cwSet.set(&quot;N 51&#176; 27.635 E 009&#176; 37.621&quot;, CWPoint.CW);
+		}
+		end = new Time();
+		printResult(&quot;cwSet.set(\&quot;N 51&#176; 27.635 E 009&#176; 37.621\&quot;, CWPoint.CW) CWPoint set&quot;, start, end, i);
+
+	}
+	
+	void printResult(String what, Time start, Time end, int count){
+		long time;
+		time = end.getTime() - start.getTime();
+		
+		Vm.debug(&quot; &quot; +  Convert.toString(time) + &quot; msec &quot; + Convert.toString(count) + &quot; * &quot; + what);
+	}
+	
+	void testPassedRegex(String pattern, String expectedResult, int format) {
+		CWPoint coord = new CWPoint(pattern, CWPoint.REGEX);
+		String res = coord.toString(format);
+
+		if (expectedResult.equals(res)) return; 
+
+		Vm.debug(&quot;Failed test Regex: &quot;+pattern+&quot; Expected=&quot;+expectedResult+&quot; Actual=&quot;+res); 
+		allPassed=false; 
+	}
+	
+	void testRegex(){
+		testPassedRegex(&quot;S1 2.3W4 5.6&quot;,&quot;S 01&#176; 02.300 W 004&#176; 05.600&quot;, CWPoint.CW); 
+		testPassedRegex(&quot;N1 12.123 E7 34.345&quot;,&quot;N 01&#176; 12.123 E 007&#176; 34.345&quot;, CWPoint.CW);
+		testPassedRegex(&quot;S1 12.123 E7 34.345&quot;,&quot;S 01&#176; 12.123 E 007&#176; 34.345&quot;, CWPoint.CW); 
+		testPassedRegex(&quot;N1 12.123 W7 34.345&quot;,&quot;N 01&#176; 12.123 W 007&#176; 34.345&quot;, CWPoint.CW); 
+		testPassedRegex(&quot;S1 12.123 W7 34.345&quot;,&quot;S 01&#176; 12.123 W 007&#176; 34.345&quot;, CWPoint.CW); 
+		testPassedRegex(&quot;N1 12.123 E7 34,345&quot;,&quot;N 01&#176; 12.123 E 007&#176; 34.345&quot;, CWPoint.CW); 
+		testPassedRegex(&quot;n1 1.0 E12 34.3456363&quot;,&quot;N 01&#176; 01.000 E 012&#176; 34.346&quot;, CWPoint.CW); //Kleinbuchstaben erlaubt 
+		testPassedRegex(&quot;S99 60.2345 W180 65.34534&quot;,&quot;S 90&#176; 00.000 W 180&#176; 00.000&quot;, CWPoint.CW); 
+		testPassedRegex(&quot;N1 12.1234 O12 34.3456&quot;,&quot;N 01&#176; 12.123 E 012&#176; 34.346&quot;, CWPoint.CW); 
+		testPassedRegex(&quot;N1 12.1234E12 34.3456&quot;,&quot;N 01&#176; 12.123 E 012&#176; 34.346&quot;, CWPoint.CW);
+		testPassedRegex(&quot;asdfka N1&#176; 12.1234 E12&#176;34.345 sdfskd &quot;,&quot;N 01&#176; 12.123 E 012&#176; 34.345&quot;, CWPoint.CW);
+		testPassedRegex(&quot;N1&#176; 12.1234 E12&#176;34.345&quot;,&quot;N 01&#176; 12.123 E 012&#176; 34.345&quot;, CWPoint.CW); 
+		testPassedRegex(&quot;N1&#176; 12.1234E12&#176;34.345&quot;,&quot;N 01&#176; 12.123 E 012&#176; 34.345&quot;, CWPoint.CW); 
+		testPassedRegex(&quot; S17&#176; 23 13.12345 w 127&#176; 34 34.567 &quot;,&quot;S 17&#176; 23' 13.1\&quot; W 127&#176; 34' 34.6\&quot;&quot;, CWPoint.DMS); // Deg Min Sek
+		testPassedRegex(&quot; S17&#176; 23 ' 13.12345    \&quot; w 127&#176; 34'34.567\&quot; &quot;,&quot;S 17&#176; 23' 13.1\&quot; W 127&#176; 34' 34.6\&quot;&quot;, CWPoint.DMS); // Deg Min Sek
+		testPassedRegex(&quot;12.3456 23.4567&quot;,&quot;N 12.34560&#176; E 023.45670&#176;&quot;, CWPoint.DD); 
+		testPassedRegex(&quot;12.3456&#176; 23.4567&#176;&quot;,&quot;N 12.34560&#176; E 023.45670&#176;&quot;, CWPoint.DD); 
+		testPassedRegex(&quot;12.3456&#176; 23.4567 &#176;&quot;,&quot;N 12.34560&#176; E 023.45670&#176;&quot;, CWPoint.DD); 
+		testPassedRegex(&quot;12.3456&#176;23.4567 &#176;&quot;,&quot;N 12.34560&#176; E 023.45670&#176;&quot;, CWPoint.DD); 
+		testPassedRegex(&quot;12.3456+23.4567 &#176;&quot;,&quot;N 12.34560&#176; E 023.45670&#176;&quot;, CWPoint.DD); 
+		testPassedRegex(&quot;N  12.3456   W  23.4567 &#176;&quot;,&quot;N 12.34560&#176; W 023.45670&#176;&quot;, CWPoint.DD); 
+		testPassedRegex(&quot;12.3457-23.4567 &#176;&quot;,&quot;N 12.34570&#176; W 023.45670&#176;&quot;, CWPoint.DD); 
+		testPassedRegex(&quot;-12.3456 23.4567&quot;,&quot;S 12.34560&#176; E 023.45670&#176;&quot;, CWPoint.DD); 
+		testPassedRegex(&quot;12.3456 -23.4567&quot;,&quot;N 12.34560&#176; W 023.45670&#176;&quot;, CWPoint.DD); 
+		testPassedRegex(&quot;-12.345668 -23,456734&quot;,&quot;S 12.34567&#176; W 023.45673&#176;&quot;, CWPoint.DD); 
+		testPassedRegex(&quot;12.3456-23.4567&quot;,&quot;N 12.34560&#176; W 023.45670&#176;&quot;, CWPoint.DD); 
+		testPassedRegex(&quot;12.3456+23.4567&quot;,&quot;N 12.34560&#176; E 023.45670&#176;&quot;, CWPoint.DD); 
+		testPassedRegex(&quot;91.2345 180.23456&quot;,&quot;N 90.00000&#176; E 180.00000&#176;&quot;, CWPoint.DD); 
+		testPassedRegex(&quot;91.2345 180.23456&quot;,&quot;N 90.00000&#176; E 180.00000&#176;&quot;, CWPoint.DD); 
+		testPassedRegex(&quot;32U 475592 5584875&quot;,&quot;32U E 475592 N 5584875&quot;, CWPoint.UTM); 
+		testPassedRegex(&quot;14X 1 2&quot;,&quot;13N E 668186 N 2&quot;, CWPoint.UTM); 
+	}
+}

Added: experiments/EVE/src/cachewolf/Travelbug.java
===================================================================
--- experiments/EVE/src/cachewolf/Travelbug.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/Travelbug.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,91 @@
+package cachewolf;
+
+import cachewolf.utils.SafeXML;
+
+/**
+ * This contains the basic information of a GC travelbug.
+ * @author salzkammergut
+ *
+ */
+public class Travelbug {
+	/** GC unique id or guid (both are used depending on how the TB is picked up).
+	 * Travelbugs retrieved from a cache use the guid, travelbugs entered manually
+	 * use the id */
+	private String guid;       //0
+	/** GC Name i.e. &quot;First Roman Geocoin&quot; */
+	private String name;       //1
+	/** GC tracking no i.e. 652345, needed for logging */
+	private String trackingNo; //2 
+	/** GC Mission */
+	private String mission;    //3
+
+	/** Construct a travelbug with a given name */
+	public Travelbug(String name) {
+		this(&quot;&quot;,name,&quot;&quot;);
+	}
+
+	/** Construct a travelbug with id, name and mission */
+	public Travelbug(String guid, String name, String mission) {
+		setGuid(guid);
+		setName(name);
+		setMission(mission);
+		setTrackingNo(&quot;&quot;);
+	}
+	
+	public String getGuid() {
+		return guid;
+	}
+
+	public void setGuid(String guid) {
+		this.guid = guid;
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public void setName(String name) {
+		this.name = SafeXML.cleanback(name);
+	}
+
+	public String getTrackingNo() {
+		return trackingNo;
+	}
+
+	public void setTrackingNo(String trackingNo) {
+		this.trackingNo = trackingNo;
+	}
+
+	public void setMission(String mission) {
+		this.mission = mission;
+	}
+
+	public String getMission() {
+		return this.mission;
+	}
+	
+	/** Return XML representation of travelbug for storing in cache.xml */
+	public String toXML(){
+		StringBuffer s=new StringBuffer(300);
+		s.append(&quot;  &lt;tb guid=\&quot;&quot;);
+		s.append(guid);
+		s.append(&quot;\&quot;&gt;&lt;name&gt;&lt;![CDATA[&quot;);
+		s.append(name);
+		s.append(&quot;]]&gt;&lt;/name&gt;&lt;![CDATA[&quot;);
+		s.append(mission);
+		s.append(&quot;]]&gt;&lt;/tb&gt;\n&quot;);
+		return s.toString();
+	}
+	
+	/** Return HTML representation of travelbug for display on screen */
+	public String toHtml(){
+		StringBuffer s=new StringBuffer(300);
+		s.append(&quot;&lt;b&gt;Name:&lt;/b&gt; &quot;);
+		s.append(name);
+		s.append(&quot;&lt;br&gt;&quot;);
+		s.append(mission);
+		s.append(&quot;&lt;hr&gt;&quot;);
+		return s.toString();
+	}
+
+}

Added: experiments/EVE/src/cachewolf/TravelbugJourney.java
===================================================================
--- experiments/EVE/src/cachewolf/TravelbugJourney.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/TravelbugJourney.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,320 @@
+package cachewolf;
+
+/**
+ * A travelbug journey starts in a cache (from....) where the tb is picked up and 
+ * ends in another cache (to...) where the travelbug is dropped. For both transfers
+ * the date/time is recorded and a flag (...Logged) is kept, indicating whether the
+ * transfer has been logged to GC.
+ * @author salzkammergut
+ */
+import cachewolf.utils.SafeXML;
+import eve.sys.*;
+import eve.fx.Picture;
+
+
+public class TravelbugJourney  {
+	/** 
+	 * The travelbug concerned @see Travelbug 
+	 */
+	private Travelbug tb;
+	/** 
+	 * The profile from where the travelbug was picked up 
+	 */
+	private String fromProfile;//4:
+	/** 
+	 * The waypoint within the profile where the travelbug was picked up 
+	 */
+	private String fromWaypoint;//5:
+	/** 
+	 * The date and time when the travelbug was picked up 
+	 */
+	private String fromDate;   //6: 
+	/** 
+	 * Flag that indicates whether the pick-up was logged with GC 
+	 */
+	private boolean fromLogged;//7:
+	/** 
+	 * The profile where the travelbug was dropped 
+	 */
+	private String toProfile;  //8:
+	/** 
+	 * The waypoint within the profile where the travelbug was dropped 
+	 */
+	private String toWaypoint; //9:
+	/** 
+	 * The date and time when the travelbug was dropped 
+	 */
+	private String toDate;     //10:
+	/** 
+	 * Flag that indicates whether the drop was logged with GC 
+	 */
+	private boolean toLogged;  //11:
+	/**
+	 * When retrieving the elements of a travelbug journey by number, this
+	 * virtual column is used to retrieve the AND of fromLogged and toLogged. 
+	 * It thus returns true only if bith transactions have been logged.
+	 */
+	public static final int BOTHLOGGED=12;
+	
+	public TravelbugJourney(String id, String name, String trackingNo, String fromProfile, 
+			String fromWaypoint, String fromDate, String fromLogged,
+			String toProfile, String toWaypoint, String toDate, String toLogged,
+			String mission) {
+		tb=new Travelbug(id,name,mission);
+		tb.setTrackingNo(trackingNo);
+		this.fromProfile = fromProfile;
+		this.fromWaypoint = fromWaypoint;
+		this.fromDate = fromDate;
+		this.fromLogged = Convert.toBoolean(fromLogged);
+		this.toProfile = toProfile;
+		this.toWaypoint = toWaypoint;
+		this.toDate = toDate;
+		this.toLogged = Convert.toBoolean(toLogged);
+	}
+
+	public TravelbugJourney(String name) {
+		tb=new Travelbug(&quot;&quot;,name,&quot;&quot;);
+		tb.setTrackingNo(&quot;&quot;);
+		setFromProfile(&quot;&quot;);
+		setFromWaypoint(&quot;&quot;);
+		setFromDate(&quot;&quot;);    
+		setFromLogged(&quot;&quot;);
+		setToProfile(&quot;&quot;);
+		setToWaypoint(&quot;&quot;);
+		setToDate(&quot;&quot;);   
+		setToLogged(&quot;&quot;); 
+	}
+
+	public TravelbugJourney(Travelbug tb, String profile, String waypoint) {
+		this.tb=tb;
+		setFromProfile(profile);
+		setFromWaypoint(waypoint);
+		setFromDate(getDateTime());    
+		setToProfile(&quot;&quot;);
+		setToWaypoint(&quot;&quot;);
+		setToDate(&quot;&quot;);   
+		setFromLogged(&quot;&quot;);
+		setToLogged(&quot;&quot;); 
+	}
+	
+	/** Drop a travelbug in a profile/waypoint and set the current date-time as
+	 * the drop date-time.
+	 * @param profile The profile where the tb is dropped
+	 * @param waypoint the waypoint where the tb is dropped
+	 */
+	public void dropTravelbug(String profile, String waypoint) {
+		setToProfile(profile);
+		setToWaypoint(waypoint);
+		setToDate(getDateTime());    
+	}
+	
+	private static Picture checkboxTicked = new Picture(&quot;checkboxTicked.png&quot;);
+	private static Picture checkboxUnticked= new Picture(&quot;checkboxUnticked.png&quot;);
+	
+	/** Get an element of a TravelbugJourney by number. This is used when
+	 * displaying the journey in list format.
+	 * @param elementNo The element (=column) to get
+	 * @return The requested element as a String or Image
+	 */
+	public Object getElementByNumber(int elementNo) {
+		switch(elementNo) {
+	    	//--- Travelbug ---
+		    case 0: return tb.getGuid();
+		   	case 1:	return tb.getName();
+			case 2: return tb.getTrackingNo();
+			case 3: return tb.getMission();
+		    //--- TravelbugJourney ---
+			case 4: return getFromProfile();
+			case 5: return getFromWaypoint();
+			case 6: return getFromDate();
+			case 7: if (getFromLogged())
+						return checkboxTicked;
+					return checkboxUnticked;
+			case 8: return getToProfile();
+			case 9: return getToWaypoint();
+			case 10: return getToDate();
+			case 11: if(getToLogged())
+						return checkboxTicked;
+					return checkboxUnticked;
+			/* Special case 12: Return Z if both moves have been logged, blank otherwise
+			 This allows the not logged tbJourneys to be sorted to the top.*/
+			case 12: return bothLogsDone() ? &quot;Z&quot;: &quot; &quot;;
+			default: return &quot;?&quot;;
+		}
+	}
+
+	/** Return the name of the journey element by number, i.e. the title column
+	 * of a list.
+	 * @param elementNo The element (=column) to get
+	 * @return The name as a String
+	 */
+	public static String getElementNameByNumber(int elementNo) {
+		switch (elementNo) {
+		    //--- Travelbug ---
+			case 0: return MyLocale.getMsg(6000,&quot;Guid&quot;);
+		   	case 1:	return MyLocale.getMsg(6001,&quot;Name&quot;);
+			case 2: return MyLocale.getMsg(6002,&quot;track#&quot;);
+			case 3: return MyLocale.getMsg(6003,&quot;Mission&quot;);
+		    //--- TravelbugJourney ---
+			case 4: return MyLocale.getMsg(6004,&quot;From Prof&quot;);
+			case 5: return MyLocale.getMsg(6005,&quot;From Wpt&quot;);
+			case 6: return MyLocale.getMsg(6006,&quot;From Date&quot;);
+			case 7: return MyLocale.getMsg(6007,&quot;From Log&quot;);
+			case 8: return MyLocale.getMsg(6008,&quot;To Prof&quot;);
+			case 9: return MyLocale.getMsg(6009,&quot;To Wpt&quot;);
+			case 10: return MyLocale.getMsg(6010,&quot;To Date&quot;);
+			case 11: return MyLocale.getMsg(6011,&quot;To Log&quot;);
+			default: return &quot;?&quot;;
+		}
+	}
+	
+	/** Return the travelbug that defines the journey */
+	public Travelbug getTb() {
+		if (tb==null) tb=new Travelbug(&quot;&quot;);
+		return tb;
+	}
+	
+	/** The date when the travelbug was picked up */
+	public String getFromDate() {
+		return fromDate;
+	}
+
+	/** The date when the travelbug was picked up */
+	public void setFromDate(String fromDate) {
+		this.fromDate = fromDate;
+	}
+
+	/** The profile where the travelbug was picked up */
+	public String getFromProfile() {
+		return fromProfile;
+	}
+
+	/** The profile where the travelbug was picked up */
+	public void setFromProfile(String fromProfile) {
+		this.fromProfile = fromProfile;
+	}
+
+	/** The waypoint where the travelbug was picked up */
+	public String getFromWaypoint() {
+		return fromWaypoint;
+	}
+
+	/** The waypoint where the travelbug was picked up */
+	public void setFromWaypoint(String fromWaypoint) {
+		this.fromWaypoint = fromWaypoint;
+	}
+
+	/** The log status of the travelbug pick-up transaction */
+	public void setFromLogged(String fromLogged) {
+		this.fromLogged = Convert.toBoolean(fromLogged);
+	}
+
+	/** The log status of the travelbug pick-up transaction */
+	public void setFromLogged(boolean fromLogged) {
+		this.fromLogged = fromLogged;
+	}
+
+	/** The log status of the travelbug pick-up transaction */
+	public boolean getFromLogged() {
+		return this.fromLogged;
+	}
+
+	/** The date when the travelbug was dropped */
+	public String getToDate() {
+		return toDate;
+	}
+
+	/** The date when the travelbug was dropped */
+	public void setToDate(String toDate) {
+		this.toDate = toDate;
+	}
+
+	/** The profile where the travelbug was dropped */
+	public String getToProfile() {
+		return toProfile;
+	}
+
+	/** The profile where the travelbug was dropped */
+	public void setToProfile(String toProfile) {
+		this.toProfile = toProfile;
+	}
+
+	/** The waypoint where the travelbug was dropped */
+	public String getToWaypoint() {
+		return toWaypoint;
+	}
+
+	/** The waypoint where the travelbug was dropped */
+	public void setToWaypoint(String toWaypoint) {
+		this.toWaypoint = toWaypoint;
+	}
+
+	/** The log status of the travelbug drop transaction */
+	public void setToLogged(String toLogged) {
+		this.toLogged = Convert.toBoolean(toLogged);
+	}
+
+	/** The log status of the travelbug drop transaction */
+	public void setToLogged(boolean toLogged) {
+		this.toLogged = toLogged;
+	}
+
+	/** The log status of the travelbug drop transaction */
+	public boolean getToLogged() {
+		return this.toLogged;
+	}
+	
+	/** True if both transactions (pick-up and drop) have been logged with GC. */
+	public boolean bothLogsDone() {
+		return this.toLogged &amp;&amp; this.fromLogged;
+	}
+	
+	/**
+	 * Returns true if the travelbug is currently in my posession, i.e. it has
+	 * a pick-up date but no drop date.
+	 * @return The status to the travelbug
+	 */public boolean inMyPosession() {
+		return !fromDate.equals(&quot;&quot;) &amp;&amp; toDate.equals(&quot;&quot;);
+	}
+
+	/** Returns an XML representation of a TravelbugJourney for storing in a file */
+	public String toXML(){
+		StringBuffer s=new StringBuffer(200);
+		s.append(&quot;  &lt;tbj&quot;);
+		appendElem(s,&quot;id&quot;,tb.getGuid(),false);
+		appendElem(s,&quot;trackingNo&quot;,tb.getTrackingNo(),false);
+		appendElem(s,&quot;fromProfile&quot;,fromProfile,true);
+		appendElem(s,&quot;fromWaypoint&quot;,fromWaypoint,false);
+		appendElem(s,&quot;fromDate&quot;,fromDate,false);
+		appendElem(s,&quot;fromLogged&quot;,Boolean.toString(fromLogged),false);
+		appendElem(s,&quot;toProfile&quot;,toProfile,true);
+		appendElem(s,&quot;toWaypoint&quot;,toWaypoint,false);
+		appendElem(s,&quot;toDate&quot;,toDate,false);
+		appendElem(s,&quot;toLogged&quot;,Boolean.toString(toLogged),false);
+		s.append(&quot;&gt;&lt;name&gt;&lt;![CDATA[&quot;);
+		s.append(tb.getName());
+		s.append(&quot;]]&gt;&lt;/name&gt;&lt;![CDATA[&quot;);
+		s.append(tb.getMission());
+		s.append(&quot;]]&gt;&lt;/tbj&gt;\n&quot;);
+		return s.toString();
+	}
+	
+	private void appendElem(StringBuffer s,String name,String value,boolean clean) {
+		s.append(&quot; &quot;);
+		s.append(name);
+		s.append(&quot;=\&quot;&quot;);
+		if (clean)
+			s.append(SafeXML.clean(value));
+		else
+			s.append(value);
+		s.append(&quot;\&quot;&quot;);
+	}
+	
+	/** Returns the current date-time in format YYYY-MM-DD HH:MM */
+	private String getDateTime() {
+		Time t=new Time();
+		return MyLocale.formatLong(t.year,&quot;0000&quot;)+&quot;-&quot;+MyLocale.formatLong(t.month,&quot;00&quot;)+&quot;-&quot;+
+		       MyLocale.formatLong(t.day,&quot;00&quot;)+&quot; &quot;+MyLocale.formatLong(t.hour,&quot;00&quot;)+&quot;:&quot;+MyLocale.formatLong(t.minute,&quot;00&quot;);
+	}
+	
+}

Added: experiments/EVE/src/cachewolf/TravelbugJourneyList.java
===================================================================
--- experiments/EVE/src/cachewolf/TravelbugJourneyList.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/TravelbugJourneyList.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,221 @@
+package cachewolf;
+
+/**
+ * A list of @see TravelbugJourney s.
+ */
+import java.io.BufferedWriter;
+import eve.io.File;
+import java.io.FileWriter;
+import java.io.PrintWriter;
+import java.util.*;
+
+import cachewolf.utils.SafeXML;
+
+
+import ewesoft.xml.*;
+import ewesoft.xml.sax.*;
+
+public class TravelbugJourneyList extends MinML {
+
+	/** The Vector holdin the travelbug journeys */
+	private Vector tbJourneyList=new Vector(10);
+	
+	/** Return a TravelbugJourney */
+	public TravelbugJourney getTBJourney(int i) {
+		return (TravelbugJourney) tbJourneyList.elementAt(i);
+	}
+	
+	/** Number of TravelbugJourneys in list */
+	public int size() {
+		return tbJourneyList.size();
+	}
+	
+	/** Clear the list */
+	public void clear() {
+		tbJourneyList.clear();
+	}
+
+	/** Add a TravelbugJourney to the list */
+	public void add(TravelbugJourney tb) {
+		tbJourneyList.add(tb);
+	}
+	
+	/** Remove an element of the list */
+	public void remove(int i) {
+		tbJourneyList.removeElementAt(i);
+	}
+
+	/** Add e Travelbug pick-up to the list (creating a new Journey) */
+	public void addTbPickup(Travelbug tb, String profile, String waypoint) {
+		tbJourneyList.add(new TravelbugJourney(tb,profile,waypoint));
+	}
+	
+	
+	/** Add a Travelbug drop to the list for a given Travelbug which must be in the
+	 * list
+	 */
+	public void addTbDrop(Travelbug tb,String profile, String waypoint) {
+		int i=findTB(tb);
+		if (i&gt;=0) {
+			getTBJourney(i).dropTravelbug(profile,waypoint);
+		}
+	}
+	
+	/** Find a travelbug in the list */
+	private int findTB(Travelbug tb) {
+		for (int i=size()-1; i&gt;=0; i--) {
+			if (tb.getName().equals(getTBJourney(i).getTb().getName())) return i;
+		}
+		return -1;
+	}
+	
+	/** Count the number of journeys where at least one log still needs to be done
+	 */
+	public int countNonLogged() {
+		int count=0;
+		for (int i=size()-1; i&gt;=0; i--)
+			if (!getTBJourney(i).bothLogsDone()) count++;
+		return count;
+	}
+	
+	TravelbugJourneyList() {}
+	
+	/**
+	 * Return a list of the travelbugs still in my possession
+	 * @return 
+	 */
+	public TravelbugList getMyTravelbugs() {
+		TravelbugList tbl=new TravelbugList();
+		int size=size();
+		for (int i=0; i&lt;size; i++) {
+			TravelbugJourney tbj=getTBJourney(i);
+			if (tbj.inMyPosession()) tbl.add(tbj.getTb());
+		}
+		return tbl;
+	}
+	
+	// Variables needed for reading the TB list
+	private String lastName;
+	private StringBuffer xmlElement=new StringBuffer(200);
+	private TravelbugJourney tbJ;
+	/**
+	 * Method to open and parse the travelbugs.xml file which contains the tavelbugs
+	 * which were picked up and dropped by us. 
+	 */
+	public boolean readTravelbugsFile(){
+		try{
+			String datei = Global.getPref().baseDir + &quot;/&quot; + &quot;travelbugs.xml&quot;;
+			datei = datei.replace('\\', '/');
+			java.io.Reader r = new java.io.InputStreamReader(new java.io.FileInputStream(datei));
+			parse(r);
+			r.close();
+		}catch(Exception e){
+			if (e instanceof NullPointerException)
+				Global.getPref().log(&quot;Error reading travelbugs.xml: NullPointerException in Element &quot;+lastName +&quot;. Wrong attribute?&quot;,e,true);
+			else 
+				Global.getPref().log(&quot;Error reading travelbugs.xml: &quot;, e);
+			return false;
+		}
+		return true;
+	}
+	
+	/**
+	 * Method that gets called when a new element has been identified in travelbugs.xml
+	 */
+	public void startElement(String name, AttributeList atts){
+		//Vm.debug(&quot;name = &quot;+name);
+		lastName=name;
+		if (name.equals(&quot;tbj&quot;)) {
+			tbJ=new TravelbugJourney(
+				atts.getValue(&quot;id&quot;),
+				&quot;&quot;,
+				atts.getValue(&quot;trackingNo&quot;),
+				SafeXML.cleanback(atts.getValue(&quot;fromProfile&quot;)),
+				atts.getValue(&quot;fromWaypoint&quot;),
+				atts.getValue(&quot;fromDate&quot;),
+				atts.getValue(&quot;fromLogged&quot;),
+				SafeXML.cleanback(atts.getValue(&quot;toProfile&quot;)),
+				atts.getValue(&quot;toWaypoint&quot;),
+				atts.getValue(&quot;toDate&quot;),
+				atts.getValue(&quot;toLogged&quot;),
+				&quot;&quot;);
+		}
+	}
+
+	public void characters( char ch[], int start, int length ) {
+			xmlElement.append(ch,start,length); // Collect the mission
+	}	
+
+	public void endElement(String tag){
+		if (tag.equals(&quot;tbj&quot;)) {
+			tbJ.getTb().setMission(xmlElement.toString());
+			tbJourneyList.add(tbJ);
+			xmlElement.delete(0,xmlElement.length());
+		}
+		if (tag.equals(&quot;name&quot;)) {
+			tbJ.getTb().setName(xmlElement.toString());
+			xmlElement.delete(0,xmlElement.length());
+		}
+	}
+	
+	/**
+	 * Method to save current travelbugs in the travelbugs.xml file
+	 */
+	public void saveTravelbugsFile(){
+		String baseDir=Global.getPref().baseDir;
+		try {
+			File backup=new File(baseDir+&quot;travelbugs.bak&quot;);
+			if (backup.exists()) backup.delete();
+			File travelbugs=new File(baseDir+&quot;travelbugs.xml&quot;);
+			travelbugs.rename(&quot;travelbugs.bak&quot;);
+		} catch (Exception ex) {
+			Global.getPref().log(&quot;Error deleting backup or renaming travelbugs.xml&quot;);
+		}
+		String datei = baseDir + &quot;travelbugs.xml&quot;;
+		try{
+			PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(datei)));
+			outp.print(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;ISO-8859-1\&quot;?&gt;\n&quot;);
+			outp.print(&quot;&lt;travelbugJourneys&gt;\n&quot;);	
+			int size=tbJourneyList.size();
+			for (int i=0; i&lt;size; i++) outp.print(((TravelbugJourney)tbJourneyList.elementAt(i)).toXML());
+			outp.print(&quot;&lt;/travelbugJourneys&gt;\n&quot;);	
+			outp.close();
+		} catch (Exception e) {
+			Global.getPref().log(&quot;Problem saving: &quot; +datei,e,true);
+		}
+	}
+
+	/** Sort the list of travelbug journeys by any column */
+	public void sort(int column, boolean ascending) {
+		eve.util.Utils.sort(new eve.sys.Handle(),tbJourneyList,new tbjComparer(column),ascending);
+	}
+
+	/** Sort only part of the travelbug journey list. This is used to sort the
+	 * non-logged journeys, which are at the start of the list
+	 * @param column Column to sort by @see TravelbugJourney
+	 * @param ascending Sort order
+	 * @param nElem Number of elements to sort
+	 */
+	public void sortFirstHalf(int column, boolean ascending,int nElem) {
+		Object[] no = new Object[nElem];
+		for (int i=0; i&lt;nElem; i++) no[i]=tbJourneyList.elementAt(i);
+		eve.util.Utils.sort(new eve.sys.Handle(),no,new tbjComparer(column),ascending);
+		for (int i=0; i&lt;nElem; i++) tbJourneyList.setElementAt(no[i],i);
+	}
+	
+	private class tbjComparer implements eve.util.Comparer {
+		private int col;
+		tbjComparer(int column) {
+			col=column;
+		}
+		
+		public int compare(Object o1, Object o2){
+			Object oo1=((TravelbugJourney) o1).getElementByNumber(col);
+			Object oo2=((TravelbugJourney) o2).getElementByNumber(col);
+			return oo1.toString().compareTo(oo2.toString());
+		}
+	}
+
+	
+	
+}

Added: experiments/EVE/src/cachewolf/TravelbugJourneyScreen.java
===================================================================
--- experiments/EVE/src/cachewolf/TravelbugJourneyScreen.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/TravelbugJourneyScreen.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,628 @@
+package cachewolf;
+
+/**
+ * A list to manage the travelbugs. Each row represents one @see TravelbugJourney.
+ * The lower half of the screen which is separated from the top by a splitter bar,
+ * contains four tabs: One for the travelbug, one for the source (where the travelbug 
+ * was picked up), one for the destination (where the travelbug was dropped) and one
+ * for the mission. These tabs are used for inputting data about the travelbug journey.
+ * The travelbugs are read from file travelbugs.xml which is stored in the base directory.
+ * When the screen is closed, all data is written back to the file.
+ * @author salzkammergut
+ */
+
+import eve.sys.Convert;
+import eve.sys.Time;
+import eve.sys.Vm;
+import eve.ui.*;
+import java.util.*;
+
+import cachewolf.imp.SpiderGC;
+
+
+import eve.fx.*;
+import eve.ui.formatted.HtmlDisplay;
+import eve.sys.Event;
+import eve.ui.event.DataChangeEvent;
+import eve.ui.table.TableControl;
+import eve.ui.table.TableModel;
+import eve.ui.event.PenEvent;
+import eve.ui.event.MultiPanelEvent;
+import eve.ui.event.ControlEvent;
+import eve.ui.event.FormEvent;
+import eve.ui.table.TableCellAttributes;
+
+public class TravelbugJourneyScreen extends Form  {
+	
+	/** The list control */
+	private tbListControl tcTbJourneyList;
+	/** The list model */
+	private tbListTableModel modTbJourneyList;
+	/** The actual journeys */
+	private TravelbugJourneyList tblMyTravelbugJourneys;
+	/** The panel for the lower half of the screen */
+	private CellPanel lowerpane;
+	private Input inpName,inpTrackingNo, 
+		   inpFromDate, inpFromProfile, inpFromWaypoint, 
+	       inpToDate, inpToProfile, inpToWaypoint;
+	private Label lblId;
+	private Button btnFromDate,btnToDate;
+	private CheckBox chkFromLogged, chkToLogged;
+	private HtmlDisplay txtMission;
+	private TabbedPanel pnlTab;
+    /**	 List of TBs in the current cache */
+	private TravelbugList tblSrcCache; 
+	/** The currently selected row */
+	private int selectedRow=-1;
+	/** A label which holds the number of currently displayed travelbug journeys*/
+	private Label lblNumVisibleJourneys;
+	private final Color RED=new Color(255,0,0);
+	private int exitKeys[]={75009};
+	/** A flag to track whether the current cache has to be saved because a travelbug
+	 * was added to or taken from it.
+	 */
+	private boolean chDmodified=false;
+	
+	/** The current cache */
+	private CacheHolderDetail chD;
+	/** The base data of the current cache */
+	private CacheHolder ch;
+	/** The name of the current waypoint */
+	private String waypoint=&quot;&quot;;
+	
+	public TravelbugJourneyScreen() {
+		Vector cacheDB=Global.getProfile().cacheDB;
+		SplittablePanel split = new SplittablePanel(PanelSplitter.VERTICAL);
+		CellPanel tablepane = split.getNextPanel();
+		int curCacheNo=Global.mainTab.tbP.getSelectedCache();
+		String cache=&quot;&quot;;
+		if (curCacheNo&gt;=0 &amp;&amp; curCacheNo&lt;cacheDB.size()) {
+			ch=(CacheHolder)cacheDB.elementAt(curCacheNo);
+			cache=MyLocale.getMsg(6022,&quot;: Current cache: &quot;)+ch.wayPoint+&quot; - &quot;+ch.cacheName;
+			waypoint=ch.wayPoint;
+			chD=new CacheHolderDetail(ch);
+			try {
+				chD.readCache(Global.getProfile().dataDir);
+			}catch (Exception ex) {
+				Global.getPref().log(&quot;Failed to read cache &quot;+ch.wayPoint);
+			};
+			tblSrcCache=chD.travelbugs;
+		}
+		title=&quot;Travelbugs&quot;+cache;
+		tcTbJourneyList=new tbListControl();
+		tcTbJourneyList.setTableModel(modTbJourneyList=new tbListTableModel());
+		tablepane.addLast(new MyScrollBarPanel(tcTbJourneyList,ScrollBarPanel.AlwaysShowVerticalScrollers),STRETCH,FILL);
+	
+		lowerpane = split.getNextPanel();
+		
+		pnlTab=new TabbedPanel();
+		pnlTab.extraControlsRight=lblNumVisibleJourneys=new Label(&quot;  0&quot;);
+		//------------------------------------------------
+		// First Tab - Name &amp; Tracking #
+		//------------------------------------------------
+		CellPanel pnlName=new CellPanel();
+		pnlName.addNext(new Label(MyLocale.getMsg(6025,&quot;Name:&quot;)),DONTSTRETCH,DONTFILL);
+		pnlName.addLast(inpName=new Input(),HSTRETCH,HFILL);
+		pnlName.addNext(new Label(MyLocale.getMsg(6026,&quot;Tracking #:&quot;)),DONTSTRETCH,DONTFILL);
+		pnlName.addLast(inpTrackingNo=new Input(),HSTRETCH,HFILL);
+		pnlName.addNext(new Label(MyLocale.getMsg(6027,&quot;ID/GUID:&quot;)),DONTSTRETCH,DONTFILL);
+		pnlName.addLast(lblId=new Label(&quot;&quot;),HSTRETCH,HFILL);
+		pnlTab.addCard(pnlName,MyLocale.getMsg(6028,&quot;Name&quot;),&quot;Name&quot;);
+		
+		//------------------------------------------------
+		// Second Tab - Where was the TB picked up from
+		//------------------------------------------------
+		CellPanel pnlFrom=new CellPanel();
+		pnlFrom.addNext(new Label(MyLocale.getMsg(6029,&quot;Profile/Cache:&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		pnlFrom.addNext(inpFromProfile=new Input(),HSTRETCH,HFILL);
+		pnlFrom.addLast(inpFromWaypoint=new Input(),HSTRETCH,HFILL);
+		
+		pnlFrom.addNext(new Label(MyLocale.getMsg(6030,&quot;Date found:&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		pnlFrom.addNext(inpFromDate=new Input(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		pnlFrom.addLast(btnFromDate=new Button(new Picture(&quot;calendar.png&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		btnFromDate.modify(0,ControlConstants.TakesKeyFocus);
+		
+		pnlFrom.addNext(new Label(MyLocale.getMsg(6031,&quot;Logged:&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		pnlFrom.addLast(chkFromLogged=new CheckBox(&quot;&quot;),DONTSTRETCH,DONTFILL|WEST);
+		chkFromLogged.exitKeys=exitKeys;
+		pnlFrom.addLast(new Label(&quot;&quot;));
+		
+		pnlTab.addCard(pnlFrom,MyLocale.getMsg(6032,&quot;From&quot;),&quot;From&quot;);
+
+		//------------------------------------------------
+		// Third Tab - Where was the TB dropped
+		//------------------------------------------------
+		CellPanel pnlTo=new CellPanel();
+		pnlTo.addNext(new Label(MyLocale.getMsg(6029,&quot;Profile/Cache:&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		pnlTo.addNext(inpToProfile=new Input(),HSTRETCH,HFILL);
+		pnlTo.addLast(inpToWaypoint=new Input(),HSTRETCH,HFILL);
+		
+		pnlTo.addNext(new Label(MyLocale.getMsg(6033,&quot;Date dropped:&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		pnlTo.addNext(inpToDate=new Input(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		//inpToDate.modifyAll(DisplayOnly,0);
+		pnlTo.addLast(btnToDate=new Button(new Picture(&quot;calendar.png&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		btnToDate.modify(0,ControlConstants.TakesKeyFocus);
+		//pnlTo.addLast(new Label(&quot;&quot;));
+		
+		pnlTo.addNext(new Label(MyLocale.getMsg(6031,&quot;Logged:&quot;)),DONTSTRETCH,DONTFILL|WEST);
+		pnlTo.addLast(chkToLogged=new CheckBox(&quot;&quot;),DONTSTRETCH,DONTFILL|WEST);
+		chkToLogged.exitKeys=exitKeys;
+		pnlTo.addLast(new Label(&quot;&quot;));
+		
+		pnlTab.addCard(pnlTo,MyLocale.getMsg(6034,&quot;To&quot;),&quot;To&quot;);
+		
+		//------------------------------------------------
+		// Last Panel - TB Mission
+		//------------------------------------------------
+		CellPanel pnlDest=new CellPanel();
+		pnlDest.addLast(new Label(MyLocale.getMsg(6035,&quot;Mission:&quot;)));
+		pnlDest.addLast(txtMission=new HtmlDisplay(),STRETCH,FILL);
+		txtMission.rows=3;
+		pnlTab.addCard(pnlDest,MyLocale.getMsg(6036,&quot;Mission&quot;),&quot;Mission&quot;);
+
+		
+		lowerpane.addLast(pnlTab,STRETCH,FILL);
+		
+		
+		split.setSplitter(PanelSplitter.AFTER|PanelSplitter.HIDDEN,PanelSplitter.BEFORE|PanelSplitter.HIDDEN,0);
+		addLast(split,STRETCH,FILL);
+		//setPreferredSize(MyLocale.getScreenWidth()&lt;=240?240:MyLocale.getScreenWidth()*2/3,240);
+		
+		tblMyTravelbugJourneys=new TravelbugJourneyList();
+		tblMyTravelbugJourneys.readTravelbugsFile();
+		modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+		// Get the columns to display and their widths from preferences
+		modTbJourneyList.columnMap=
+			TableColumnChooser.str2Array(Global.getPref().travelbugColMap,0,11,0, -1);
+		modTbJourneyList.colWidth=
+			TableColumnChooser.str2Array(Global.getPref().travelbugColWidth,10,1024,50, -1);
+		modTbJourneyList.numCols=modTbJourneyList.columnMap.length;
+		
+		modTbJourneyList.select(0,12,true);
+		/* Restore the saved setting about showing only non-logged bugs */
+		if (Global.getPref().travelbugShowOnlyNonLogged) {
+			tcTbJourneyList.toggleNonLogged();
+		}
+		updateNumBugs();
+	}
+	
+	/** Indicate the number of journeys currently displayed */
+	private void updateNumBugs() {
+		lblNumVisibleJourneys.setText(&quot;&quot;+modTbJourneyList.numRows);
+		lblNumVisibleJourneys.repaint();
+	}
+	
+	/** The control which had the last focus */
+	private Control currentControl;
+	
+	public void onEvent(Event ev){
+		// Update the table from the input form  
+		if ((ev instanceof MultiPanelEvent || ev instanceof ControlEvent || ev instanceof DataChangeEvent) &amp;&amp; selectedRow!=-1 &amp;&amp;
+				selectedRow&lt;tblMyTravelbugJourneys.size()){
+			TravelbugJourney tbj=tblMyTravelbugJourneys.getTBJourney(selectedRow);
+			if (currentControl==inpName) 			tbj.getTb().setName(inpName.getText());
+			else if (currentControl==inpTrackingNo)  tbj.getTb().setTrackingNo(inpTrackingNo.getText());
+			else if (currentControl==inpFromProfile) tbj.setFromProfile(inpFromProfile.getText());
+			else if (currentControl==inpFromWaypoint)tbj.setFromWaypoint(inpFromWaypoint.getText());
+			else if (currentControl==inpFromDate)    tbj.setFromDate(inpFromDate.getText());
+			else if (currentControl==chkFromLogged)  tbj.setFromLogged(chkFromLogged.state);
+			else if (currentControl==inpToProfile)   tbj.setToProfile(inpToProfile.getText());
+			else if (currentControl==inpToWaypoint)  tbj.setToWaypoint(inpToWaypoint.getText());
+			else if (currentControl==inpToDate)      tbj.setToDate(inpToDate.getText());
+			else if (currentControl==chkToLogged)    tbj.setToLogged(chkToLogged.state);
+			//else if (ev.target==txtMission)     tb.setMission(txtMission.getText());
+			tcTbJourneyList.repaint();
+		}
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED &amp;&amp; selectedRow!=-1){
+			if (ev.target==inpTrackingNo) {pnlTab.selectNextTab(true,true); Gui.takeFocus(inpFromProfile,Control.ByKeyboard);pnlTab.repaint(); }
+			if (ev.target==inpFromDate) Gui.takeFocus(chkFromLogged,Control.ByKeyboard);
+			if (ev.target==inpToDate) Gui.takeFocus(chkToLogged,Control.ByKeyboard);
+			if (ev.target==btnFromDate || ev.target==btnToDate) {
+				Input inpDate=ev.target==btnFromDate ? inpFromDate : inpToDate;
+				DateTimeChooser dc=new DateTimeChooser(Vm.getLocale(), false);
+				dc.title=MyLocale.getMsg(328,&quot;Date found&quot;); 
+				dc.setPreferredSize(240,240);
+				String foundDate=inpDate.getText();
+				Time t=new Time();
+				try {
+					t.parse(foundDate,&quot;y-M-d H:m&quot;);
+				} catch(IllegalArgumentException e) {
+					try {
+						t.parse(foundDate,&quot;y-M-d&quot;);
+					} catch(IllegalArgumentException e1) {}
+				};
+				dc.reset(t);
+				if (dc.execute()==eve.ui.FormBase.IDOK) {
+				  inpDate.setText(Convert.toString(dc.year)+&quot;-&quot;+MyLocale.formatLong(dc.month,&quot;00&quot;)+&quot;-&quot;+MyLocale.formatLong(dc.day,&quot;00&quot;)+&quot; &quot;+dc.time);
+				  if (ev.target==btnFromDate){ 
+					  tblMyTravelbugJourneys.getTBJourney(selectedRow).setFromDate(inpDate.getText());
+					  Gui.takeFocus(chkFromLogged,Control.ByKeyboard);
+				  } else {
+					  tblMyTravelbugJourneys.getTBJourney(selectedRow).setToDate(inpDate.getText());
+					  Gui.takeFocus(chkToLogged,Control.ByKeyboard);
+				  } tcTbJourneyList.repaint();
+				}				
+			}
+		}
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.EXITED){
+			pnlTab.selectNextTab(true,true); 
+			if (ev.target==chkFromLogged) Gui.takeFocus(inpToProfile,Control.ByKeyboard);
+			if (ev.target==chkToLogged) Gui.takeFocus(txtMission,Control.ByKeyboard);
+		}
+		// The user closed the travelbugs screen
+		if (ev instanceof FormEvent &amp;&amp; ev.type==FormEvent.CLOSED  &amp;&amp; chD!=null) {
+			tblMyTravelbugJourneys.saveTravelbugsFile();
+			tblMyTravelbugJourneys.clear();
+			// Save the flag about showing non-logged journeys only
+			boolean old=Global.getPref().travelbugShowOnlyNonLogged;
+			Global.getPref().travelbugShowOnlyNonLogged=(tcTbJourneyList.mnuToggleList.modifiers &amp; MenuItem.Checked) == MenuItem.Checked;
+			String travelbugColWidth=modTbJourneyList.getColWidths();
+			// If the preferences changed, save the pref.xml file
+			Form.showWait();
+			if (!Global.getPref().travelbugColWidth.equals(travelbugColWidth) ||
+				old!=Global.getPref().travelbugShowOnlyNonLogged) {
+				Global.getPref().travelbugColWidth=travelbugColWidth;
+				Global.getPref().savePreferences();
+			}
+			// If the list of travelbugs in the cache was modified, we need to save the cache too
+			if (chDmodified) {
+				chD.saveCacheDetails(Global.getProfile().dataDir);
+				ch.has_bug=chD.travelbugs.size()&gt;0;
+			}
+			Form.cancelWait();
+			chD=null;
+		}
+		updateNumBugs();
+		currentControl=Gui.focusedControl();
+	}
+	
+	
+//==============================================================
+// tbListTableModel
+//==============================================================
+class tbListTableModel extends TableModel {
+	private FontMetrics fm;
+	private Picture imgRed;
+	tbListTableModel() {
+		
+		fillToEqualHeights=true;
+		allRowsSameSize=true;
+		hasRowHeaders=false;
+		//shadeAlternateRows=true;
+		cursorSize=new Dimension(12,1);
+		clipData=true;
+		fm=getFontMetrics();
+		// A red dot indicates that the journey has not been completely logged
+		imgRed = new Picture(&quot;red.png&quot;);
+	}
+    private int colWidth[];
+	private int columnMap[];
+	
+//	public Object getCellText(int row, int col) {
+//		return null;
+//	}
+
+	public Object getCellData(int row, int col){
+		if(row == -1)
+			return TravelbugJourney.getElementNameByNumber(columnMap[col]);
+		int map=columnMap[col];
+		// If we have not yet logged the from or the to, a red dot is placed in front of the first item
+		if (col==0 &amp;&amp; (!tblMyTravelbugJourneys.getTBJourney(row).getFromLogged() ||
+			!tblMyTravelbugJourneys.getTBJourney(row).getToLogged())) { 
+			// Is it a column with a checkbox?
+			if (map!=7 &amp;&amp; map!=11) 
+				return new IconAndText((IImage)imgRed,(String) tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map),fm);
+			// Checkbox - special treatment
+			IconAndText iat=new IconAndText(imgRed,&quot;&quot;,fm);
+			iat.addColumn(tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map));
+			return iat;
+		}
+		return tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map);
+	}
+	public int calculateRowHeight(int row) {
+		return charHeight+2;
+	}
+	
+	public int calculateColWidth(int col){
+		if(col == -1) 
+        	return 0;
+        else if (col&lt;numCols)
+        	return colWidth[columnMap[col]];
+        else return 0;
+	}
+	
+	public TableCellAttributes getCellAttributes(int row,int col,boolean isSelected,TableCellAttributes ta) {
+		ta=super.getCellAttributes(row,col,isSelected,ta);
+		ta.alignment = CellConstants.LEFT;
+		ta.anchor = CellConstants.LEFT;
+		// Color the elements red, if we have not yet logged
+		if (row&gt;=0)
+		switch (columnMap[col]) {
+		case 6: // fromDate
+				if (!tblMyTravelbugJourneys.getTBJourney(row).getFromLogged()) ta.foreground=RED;
+				break;
+		case 10: // toDate
+				if (!tblMyTravelbugJourneys.getTBJourney(row).getToLogged()) ta.foreground=RED;
+				break;
+		}
+		return ta;
+	}
+
+	private void showFields(TravelbugJourney tbj) {
+	   	inpName.setText(tbj.getTb().getName());
+		inpTrackingNo.setText(tbj.getTb().getTrackingNo());
+		lblId.setText(tbj.getTb().getGuid());
+		inpFromProfile.setText(tbj.getFromProfile());
+		inpFromWaypoint.setText(tbj.getFromWaypoint());
+		inpFromDate.setText(tbj.getFromDate());
+		chkFromLogged.setState(tbj.getFromLogged());
+		inpToProfile.setText(tbj.getToProfile());
+		inpToWaypoint.setText(tbj.getToWaypoint());
+		inpToDate.setText(tbj.getToDate());
+		chkToLogged.setState(tbj.getToLogged());
+		txtMission.setHtml(tbj.getTb().getMission());
+	}
+	
+	private boolean sortAsc=false;
+	private int sortedBy = -1;
+	private int lastRow=-1;
+	public int penEventModifiers; 
+
+	public boolean penPressed(Point onTable,Point cell){
+		boolean retval=false;
+		if(cell!=null &amp;&amp; cell.y == -1){ // Hit a header =&gt; sort the table accordingly
+			Form.showWait();
+			if (cell.x == sortedBy) sortAsc=!sortAsc;
+			else sortAsc = false;
+			sortedBy = cell.x;
+			// Check whether the list only shows non-logged journeys. If so, a subset
+			// of the table must be sorted
+			if ((tcTbJourneyList.mnuToggleList.modifiers &amp; MenuItem.Checked) == MenuItem.Checked) {
+				tblMyTravelbugJourneys.sortFirstHalf(columnMap[cell.x], sortAsc,modTbJourneyList.numRows);
+			} else { // Showing all journeys - sort the full table
+				tblMyTravelbugJourneys.sort(columnMap[cell.x], sortAsc);
+			}
+			tcTbJourneyList.repaint();
+			Form.cancelWait();
+			retval = true;
+		} else if (cell!=null &amp;&amp; cell.y&gt;=0 &amp;&amp; (penEventModifiers &amp; eve.fx.gui.IKeys.SHIFT)&gt;0) {
+			// A range of rows can be marked by shift-click on the first and last row
+			if (lastRow!=-1) { // Second row being marked with shift key pressed
+				if (lastRow&lt;cell.y)
+					toggleSelect(lastRow,cell.y);
+				else
+					toggleSelect(cell.y,lastRow);
+				lastRow=-1;
+				retval=true;
+			} else { // Remember this row as start of range, but don't toggle yet
+				lastRow=cell.y;
+			}
+		} else { // Single row marked
+			lastRow=-1;
+		}
+		return retval;
+	}
+
+	/** Select a range of rows */
+	private void toggleSelect(int fromRow, int toRow) {
+		tcTbJourneyList.clearSelection(null);
+		tcTbJourneyList.addToSelection(new Rect(0,fromRow,numCols,toRow-fromRow+1),false,true);
+	}
+	
+	/**
+	 * Return the column widths as a comma delimited string for storing in the preferences
+	 * @return
+	 */
+	private String getColWidths() {
+		// Update the list with the current widths
+		for (int col=0; col&lt;numCols; col++) {
+			colWidth[columnMap[col]]=getColWidth(col);
+		}
+		// Convert to string
+		StringBuffer sb=new StringBuffer(40);
+		for (int i=0; i&lt;colWidth.length; i++) {
+			if (sb.length()!=0) sb.append(',');
+			sb.append(colWidth[i]);
+		}
+		return sb.toString();
+	}
+}
+
+//==============================================================
+//tbListControl
+//==============================================================
+class tbListControl extends TableControl {
+	private MenuItem mnuNewTB, mnuDeleteTB,mnuGetMission,mnuOpenOnline,mnuDropTB,mnuPickupTB,mnuDeleteTBs;
+	public MenuItem mnuToggleList;
+	private Menu mnuFullMenu,mnuDeleteMenu;
+	
+	tbListControl() {
+		MenuItem[] TBMenuItems=new MenuItem[10];
+		TBMenuItems[0]= mnuPickupTB = new MenuItem(MyLocale.getMsg(6040,&quot;Pick up TB from current cache&quot;));
+		TBMenuItems[1]= mnuDropTB = new MenuItem(MyLocale.getMsg(6041,&quot;Drop TB in cache&quot;));
+		TBMenuItems[2]= new MenuItem(&quot;-&quot;);
+		TBMenuItems[3]= mnuNewTB = new MenuItem(MyLocale.getMsg(6042,&quot;New Travelbug&quot;));
+		TBMenuItems[4]= mnuDeleteTB = new MenuItem(MyLocale.getMsg(6043,&quot;Delete Travelbug&quot;));
+		TBMenuItems[5]= new MenuItem(&quot;-&quot;);
+		TBMenuItems[6]= mnuGetMission = new MenuItem(MyLocale.getMsg(6044,&quot;Get Mission&quot;));
+		TBMenuItems[7]= mnuOpenOnline = new MenuItem(MyLocale.getMsg(6045,&quot;Open on-line&quot;));
+		TBMenuItems[8]= new MenuItem(&quot;-&quot;);
+		TBMenuItems[9]= mnuToggleList = new MenuItem(MyLocale.getMsg(6046,&quot;Show only not logged&quot;));
+		mnuFullMenu=new Menu(TBMenuItems,&quot;&quot;);
+		// A second pop-up menu with only one entry, if a range of rows is selected
+		MenuItem[] TBMenuItemsDel=new MenuItem[1];
+		TBMenuItemsDel[0]=mnuDeleteTBs=new MenuItem(MyLocale.getMsg(6047,&quot;Delete selected Travelbugs&quot;));
+		mnuDeleteMenu=new Menu(TBMenuItemsDel,&quot;&quot;);
+		mnuDropTB.modifiers|=MenuItem.Disabled;
+		mnuDeleteTB.modifiers|=MenuItem.Disabled;
+		mnuGetMission.modifiers|=MenuItem.Disabled;
+		mnuOpenOnline.modifiers|=MenuItem.Disabled;
+	}
+	
+	public void onEvent(Event ev) {
+		Rect sel=getSelection(null);
+		if (sel.y&lt;tblMyTravelbugJourneys.size()) {
+			mnuDeleteTB.modifiers&amp;=~MenuItem.Disabled;
+			mnuGetMission.modifiers&amp;=~MenuItem.Disabled;
+			mnuOpenOnline.modifiers&amp;=~MenuItem.Disabled;
+			if (tblMyTravelbugJourneys.getTBJourney(sel.y).inMyPosession()) 
+				mnuDropTB.modifiers&amp;=~MenuItem.Disabled;
+			else
+				mnuDropTB.modifiers|=MenuItem.Disabled;
+		} else {
+			mnuDeleteTB.modifiers|=MenuItem.Disabled;
+			mnuGetMission.modifiers|=MenuItem.Disabled;
+			mnuOpenOnline.modifiers|=MenuItem.Disabled;
+		}
+		// If more than one row is selected, show the limited pop-up menu
+		if (sel.height&gt;1)
+			setMenu(mnuDeleteMenu);
+		else
+			setMenu(mnuFullMenu);
+	    if (ev instanceof PenEvent) modTbJourneyList.penEventModifiers=((PenEvent)ev).modifiers;
+		super.onEvent(ev);
+	}
+
+	public void penRightReleased(Point p){
+		menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
+	}
+
+	public void penHeld(Point p){
+		menuState.doShowMenu(p,true,null); 
+	}
+
+	public void popupMenuEvent(Object selectedItem){
+		if (selectedItem==mnuPickupTB) {
+			Travelbug tb=TravelbugPickup.pickupTravelbug(tblSrcCache);	
+			if (tb!=null) {
+				chDmodified=true;
+				tblMyTravelbugJourneys.addTbPickup(tb,Global.getProfile().name,waypoint);
+				modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+				tcTbJourneyList.repaint();
+			}
+		}
+		if (selectedItem==mnuDropTB) {
+			if (selectedRow&gt;=0 &amp;&amp; selectedRow&lt;modTbJourneyList.numRows) {
+				Travelbug tb=tblMyTravelbugJourneys.getTBJourney(selectedRow).getTb();
+				chD.travelbugs.add(tb);
+				tblMyTravelbugJourneys.addTbDrop(tb,Global.getProfile().name,waypoint);
+				chDmodified=true;
+				ch.has_bug=true;
+			}
+			repaint();
+		}
+		if (selectedItem==mnuNewTB) {
+			TravelbugJourney tbj=new TravelbugJourney(&quot;New&quot;);
+			tbj.setFromProfile(Global.getProfile().name);
+			tbj.setFromWaypoint(waypoint);
+			tblMyTravelbugJourneys.add(tbj);
+			modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+			cursorTo(tblMyTravelbugJourneys.size()-1,1,true);
+			tcTbJourneyList.repaint();
+		}
+		if (selectedItem==mnuDeleteTB &amp;&amp; selectedRow&gt;=0) {
+			tblMyTravelbugJourneys.remove(selectedRow);
+			modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+			if (selectedRow&gt;0) 
+				cursorTo(selectedRow-1,0,true);
+			else
+				modTbJourneyList.showFields(new TravelbugJourney(&quot;&quot;));
+			tcTbJourneyList.repaint();
+		}
+		/* Delete a group of travelbugs which have been marked with Shift-Click */
+		if (selectedItem==mnuDeleteTBs) {  
+			Rect sel=getSelection(null);
+			for (int i=0; i&lt;sel.height; i++)
+				tblMyTravelbugJourneys.remove(sel.y);
+			modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+			if (sel.y&lt;modTbJourneyList.numRows) 
+				cursorTo(sel.y,0,true);
+			else
+				modTbJourneyList.showFields(new TravelbugJourney(&quot;&quot;));
+			tcTbJourneyList.repaint();
+		}
+		if (selectedItem==mnuGetMission &amp;&amp; selectedRow&gt;-1) {
+			TravelbugJourney tbj=tblMyTravelbugJourneys.getTBJourney(selectedRow);
+			SpiderGC spider=new SpiderGC(Global.getPref(),Global.getProfile(),false);
+			Form.showWait();
+			
+			//if we have an ID, get mission by ID
+			if (tbj.getTb().getGuid().length()!=0) {
+				tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+			} else {
+				//try to get mission and name by tracking number
+				boolean succeeded = false;
+				if (tbj.getTb().getTrackingNo().length() != 0) {
+					succeeded = spider.getBugMissionAndNameByTrackNr(tbj.getTb());
+				}
+				//if this has't worked, try to get ID by name
+				if (!succeeded) {
+					tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName().trim()));
+					//if we have an ID now, get mission by ID
+					if (tbj.getTb().getGuid().length()!=0) {
+						tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+					}
+				}
+			}
+			
+			Form.cancelWait();
+			tcTbJourneyList.repaint();
+			txtMission.setHtml(tbj.getTb().getMission());
+			inpName.setText(tbj.getTb().getName());
+			lblId.setText(tbj.getTb().getGuid());
+			lowerpane.repaint();
+		}
+		if (selectedItem==mnuOpenOnline &amp;&amp; selectedRow&gt;=0) {
+			TravelbugJourney tbj=tblMyTravelbugJourneys.getTBJourney(selectedRow);
+			SpiderGC spider=new SpiderGC(Global.getPref(),Global.getProfile(),false);
+			Form.showWait();
+			// First check whether ID is set, if not get it
+			if (tbj.getTb().getGuid().length()==0) tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName()));
+			if (tbj.getTb().getGuid().length()!=0) {
+				Form.cancelWait();
+				try {
+					String s;
+					if (tbj.getTb().getGuid().length()&gt;10)
+						s = &quot;\&quot;&quot;+Global.getPref().browser+&quot;\&quot; \&quot;<A HREF="http://www.geocaching.com/track/details.aspx?guid=">http://www.geocaching.com/track/details.aspx?guid=</A>&quot;+tbj.getTb().getGuid()+&quot;\&quot;&quot;;
+					else
+						s = &quot;\&quot;&quot;+Global.getPref().browser+&quot;\&quot; \&quot;<A HREF="http://www.geocaching.com/track/details.aspx?id=">http://www.geocaching.com/track/details.aspx?id=</A>&quot;+tbj.getTb().getGuid()+&quot;\&quot;&quot;;
+									
+					Vm.execCommandLine(s);
+					Global.getPref().log(&quot;Executing: &quot;+s); 
+				} catch (Exception ioex) {
+				}
+			}
+		}
+		if (selectedItem==mnuToggleList) {
+			toggleNonLogged();
+		}
+		updateNumBugs();
+	}
+	
+	/** Toggle between displaying all journeys or just those which still need to be logged */
+	public void toggleNonLogged() {
+		mnuToggleList.modifiers^=MenuItem.Checked;
+		if ((mnuToggleList.modifiers &amp; MenuItem.Checked) == MenuItem.Checked) {
+			// First sort the non-logged items to the top
+			tblMyTravelbugJourneys.sort(TravelbugJourney.BOTHLOGGED, false);
+			// 		modListTable.numRows=tblMyTravelbugJourneys.size();
+			modTbJourneyList.numRows=tblMyTravelbugJourneys.countNonLogged();
+		} else {
+			modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+		}
+		tcTbJourneyList.repaint();
+	}
+	
+	
+	public void cursorTo(int row,int col,boolean selectNew) {
+		super.cursorTo(row,col,selectNew);
+		selectedRow=row;
+		if (row&gt;=0) { 
+			modTbJourneyList.showFields(tblMyTravelbugJourneys.getTBJourney(row));
+		} else {
+			modTbJourneyList.showFields(new TravelbugJourney(&quot;&quot;));
+		}
+	}
+}
+
+}

Added: experiments/EVE/src/cachewolf/TravelbugList.java
===================================================================
--- experiments/EVE/src/cachewolf/TravelbugList.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/TravelbugList.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,157 @@
+package cachewolf;
+/**
+ * A list of GC travelbugs
+ * @author salzkammergut
+ */
+import java.util.Vector;
+import ewesoft.xml.*;
+import ewesoft.xml.sax.*;
+import java.io.StringReader;
+
+public class TravelbugList extends MinML{
+
+	/** The Vector containing the Travelbug objects */
+	private Vector tbList=new Vector(10);
+	
+	/** Get the travelbug at a certain position in the list */
+	public Travelbug getTB(int i) {
+		return (Travelbug) tbList.elementAt(i);
+	}
+	
+	/** Return the size of the list */
+	public int size() {
+		return tbList.size();
+	}
+	
+	/** Clear the travelbug list */
+	public void clear() {
+		tbList.clear();
+	}
+
+	/** Add a travelbug to the list */
+	public void add(Travelbug tb) {
+		tbList.add(tb);
+	}
+	
+	/** Remove a travelbug from the list */
+	public void remove(int i) {
+		tbList.removeElementAt(i);
+	}
+
+	/** Replace a travelbug in the list */
+	public void replace(int i, Travelbug tb) {
+		tbList.setElementAt( tb,i);
+	}
+	
+	/** Construct an empty travelbug list */
+	public TravelbugList() {
+	}
+	
+	/** Find a travelbug in the list. 
+	 *  Return null if not found */
+	public Travelbug find(String name) {
+		name=name.trim();
+		for (int i=size()-1; i&gt;=0; i--)
+			if (name.equals(getTB(i).getName().trim())) return getTB(i);
+		return null;
+	}
+	
+	/** Convert the old representation to a new one. In the old representation,
+	 * all travelbugs were stored as one HTML string within the cache.xml file.
+	 * This representation does not include the id or guid and does not allow for
+	 * unique identification of the travelbug (Several travelbugs with identical
+	 * names may exist, so the id/guid must be stored to uniquely identify the travelbug. 
+	 * All TBs are stored as one HTML string &lt;b&gt;Name:&lt;/b&gt;name_of_tb&lt;br&gt;mission&lt;hr&gt;
+	 */
+	public void addFromHTML(String htmlList) {
+		int fnd;
+		fnd=htmlList.indexOf(&quot;&lt;b&gt;Name:&lt;/b&gt;&quot;);
+		while(fnd&gt;=0) {
+			int fnd2=htmlList.indexOf(&quot;&lt;br&gt;&quot;,fnd+12);
+			int fnd3=htmlList.indexOf(&quot;&lt;b&gt;Name:&lt;/b&gt;&quot;,fnd2+4);
+			Travelbug tb=new Travelbug(htmlList.substring(fnd+12,fnd2));
+			String mission;
+			if (fnd3&gt;0) {
+				mission=htmlList.substring(fnd2+4,fnd3);
+			} else {
+				mission=htmlList.substring(fnd2+4);
+			}
+			if (mission.endsWith(&quot;&lt;hr&gt;&quot;)) mission=mission.substring(0,mission.length()-4);
+			tb.setMission(mission);
+			tbList.add(tb);
+			fnd=fnd3;
+		}
+	}
+	
+	/** Return list of travelbugs in HTML representation */
+	public String toHtml() {
+		int size=tbList.size();
+		StringBuffer s=new StringBuffer(size*300);
+		for (int i=0; i&lt;size; i++) {
+			s.append(getTB(i).toHtml());
+		}
+		return s.toString();
+	}
+
+	/** Return list of travelbugs in XML representation */
+	public String toXML() {
+		int size=tbList.size();
+		StringBuffer s=new StringBuffer(size*300);
+		s.append(&quot;&lt;TRAVELBUGS&gt;\n&quot;);
+		for (int i=0; i&lt;size; i++) {
+			s.append(getTB(i).toXML());
+		}
+		s.append(&quot;&lt;/TRAVELBUGS&gt;\n&quot;);
+		return s.toString();
+	}
+	
+	/*=====================================================================
+	 * The following section implements the XML parser for a travelbug list
+       as contained in the cache.xml file 
+      =====================================================================*/ 	    
+	private String lastName=&quot;&quot;;
+	private Travelbug tb;
+	private StringBuffer xmlElement=new StringBuffer(200);
+	
+	/** 
+	 * Parse the travelbug part of a cache. The XML String passed as an argument
+	 * must contain the enclosing &lt;TRAVELBUGS&gt; ... &lt;/TRAVELBUGS&gt; XML tags. 
+	 */
+	public void addFromXML(String XMLString) {
+		try {
+			parse(new StringReader(XMLString));
+		} catch (Exception e) {
+			if (e instanceof NullPointerException)
+				Global.getPref().log(&quot;Error reading cache-travelbug list: NullPointerException in Element &quot;+lastName +&quot;. Wrong attribute?&quot;,e,true);
+			else 
+				Global.getPref().log(&quot;Error reading cache-travelbug list: &quot;, e);
+		};
+	}
+	
+	/**
+	 * Method that gets called when a new element has been identified
+	 */
+	public void startElement(String name, AttributeList atts){
+		lastName=name;
+		if (name.equals(&quot;tb&quot;)) {
+			tb=new Travelbug(atts.getValue(&quot;guid&quot;),&quot;&quot;,&quot;&quot;);
+		}
+	}
+
+	public void characters( char ch[], int start, int length ) {
+			xmlElement.append(ch,start,length); // Collect the mission or the name
+	}	
+
+	public void endElement(String tag){
+		if (tag.equals(&quot;tb&quot;)) {
+			tb.setMission(xmlElement.toString());
+			tbList.add(tb);
+			xmlElement.delete(0,xmlElement.length());
+		}
+		if (tag.equals(&quot;name&quot;)) {
+			tb.setName(xmlElement.toString());
+			xmlElement.delete(0,xmlElement.length());
+		}
+	}
+
+}

Added: experiments/EVE/src/cachewolf/TravelbugPickup.java
===================================================================
--- experiments/EVE/src/cachewolf/TravelbugPickup.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/TravelbugPickup.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,36 @@
+package cachewolf;
+
+import eve.ui.data.InputBox;
+
+public class TravelbugPickup {
+
+	/**
+	 * Choose a travelbug from those listed in the travelbug list and delete it, if
+	 * the operation was not cancelled.
+	 * @param tbl List of travelbugs from where a bug is picked up
+	 */
+	public static Travelbug pickupTravelbug(TravelbugList tbl) {
+		Travelbug tb=null;
+		TravelbugScreen tbs=new TravelbugScreen(tbl,MyLocale.getMsg(6016,&quot;Pick up travelbug&quot;),true);
+		tbs.execute(); // Select TB to pick up
+		if (tbs.selectedItem&gt;=0) { // Was a TB selected ?
+			// If the returned item is bigger than number of bugs in cache
+			// we have found a new unlisted bug. 
+			if (tbs.selectedItem==tbl.size()) {
+				InputBox ibox=new InputBox(MyLocale.getMsg(6018,&quot;Travelbug name&quot;));
+				String name=ibox.input(&quot;&quot;,240);
+				if (name==null) return null; // No name given
+				tb=new Travelbug(name);
+			} else { // A bug in the list was chosen
+				tb=tbl.getTB(tbs.selectedItem);
+				// Remove the tb from the list
+				tbl.remove(tbs.selectedItem);
+			}
+			InputBox ibox=new InputBox(MyLocale.getMsg(6019,&quot;Tracking number&quot;));
+			String trackingNo=ibox.input(&quot;&quot;,240);
+			if (trackingNo==null) trackingNo=&quot;&quot;;
+			tb.setTrackingNo(trackingNo);
+		}
+		return tb;
+	}
+}

Added: experiments/EVE/src/cachewolf/TravelbugScreen.java
===================================================================
--- experiments/EVE/src/cachewolf/TravelbugScreen.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/TravelbugScreen.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,80 @@
+package cachewolf;
+
+import cachewolf.utils.SafeXML;
+import eve.ui.*;
+import eve.sys.Event;
+import eve.ui.event.ListEvent;
+import eve.ui.event.ControlEvent;
+
+/**
+ * Choose a travelbug to pick up or drop
+ * @author salzkammergut
+ */ 
+public class TravelbugScreen extends Form {
+	private myList disp;
+	private Button btCancel,btAccept;
+	/** The index into the list of travelbugs indicating the selected bug */
+	public int selectedItem=-1;
+	
+	/**
+	 * A screen to choose a travelbug from a list of bugs
+	 * @param tbl The list of travelbugs from which to choose
+	 * @param title The title of the screen
+	 * @param allowNew True if a travelbug not on the list can be selected
+	 */
+	TravelbugScreen(TravelbugList tbl, String title,boolean allowNew) {
+		this.title=title;
+		this.setPreferredSize(240, -1);
+		disp=new myList(tbl,allowNew);
+		ScrollBarPanel sbp = new MyScrollBarPanel(disp, ScrollBarPanel.NeverShowHorizontalScrollers);
+		this.addLast(sbp);
+		this.addNext(btCancel = new Button(MyLocale.getMsg(614,&quot;Cancel&quot;)),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		this.addLast(btAccept = new Button(&quot;OK&quot;),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		btAccept.modify(Disabled,0);
+	}
+
+	public void onEvent(Event ev){
+        if (ev instanceof ListEvent &amp;&amp; ev.type==ListEvent.SELECTED) {
+        	btAccept.modify(0,Disabled);
+        	btAccept.repaint();
+        }
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (ev.target == btCancel){
+				this.close(0);
+			}
+			if (ev.target == btAccept){
+				this.close(0);
+				selectedItem=disp.getSelectedIndex(0);
+			}
+		}
+	}
+
+	private class myList extends SimpleList {
+		private TravelbugList tbl;
+		private boolean allowNew;
+		private int size; 
+		myList(TravelbugList tbl,boolean allowNew) {
+			this.tbl=tbl;
+			this.size=tbl.size();
+			this.allowNew=allowNew;
+		}
+		
+		public Object getObjectAt(int idx) {
+			return getDisplayItem(idx);		
+		}
+		public int getItemCount() {
+			return tbl.size()+ (allowNew?1:0);
+		}
+		public String getDisplayItem(int idx) {
+			if (idx==size)
+				return MyLocale.getMsg(6015,&quot;*** OTHER ***&quot;);
+			else if (tbl.getTB(idx).getName().indexOf(&quot;&amp;#&quot;)&lt;0)
+				return tbl.getTB(idx).getName();
+			else // If the name contains HTML entities, we need to convert it back
+				return SafeXML.cleanback(tbl.getTB(idx).getName());
+		}
+	}
+
+
+
+}

Added: experiments/EVE/src/cachewolf/URL.java
===================================================================
--- experiments/EVE/src/cachewolf/URL.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/URL.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,867 @@
+package cachewolf;
+
+// Only needed for OCXMLImporter
+
+/* URL.java -- Uniform Resource Locator Class
+Copyright (C) 1998, 1999, 2000, 2002, 2003  Free Software Foundation, Inc.
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+02111-1307 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+
+
+import java.net.MalformedURLException;
+
+
+/*
+* Written using on-line Java Platform 1.2 API Specification, as well
+* as &quot;The Java Class Libraries&quot;, 2nd edition (Addison-Wesley, 1998).
+* Status:  Believed complete and correct.
+*/
+
+/**
+* This final class represents an Internet Uniform Resource Locator (URL).
+* For details on the syntax of URL's and what they can be used for,
+* refer to RFC 1738, available from &lt;a 
+* href=&quot;<A HREF="http://ds.internic.net/rfcs/rfc1738.txt">http://ds.internic.net/rfcs/rfc1738.txt</A>&quot;&gt;<A HREF="http://ds.internic.net/rfcs/rfc1738.txt&lt;/a">http://ds.internic.net/rfcs/rfc1738.txt&lt;/a</A>&gt;
+* &lt;p&gt;
+* There are a great many protocols supported by URL's such as &quot;http&quot;,
+* &quot;ftp&quot;, and &quot;file&quot;.  This object can handle any arbitrary URL for which
+* a URLStreamHandler object can be written.  Default protocol handlers
+* are provided for the &quot;http&quot; and &quot;ftp&quot; protocols.  Additional protocols
+* handler implementations may be provided in the future.  In any case,
+* an application or applet can install its own protocol handlers that
+* can be &quot;chained&quot; with other protocol hanlders in the system to extend
+* the base functionality provided with this class. (Note, however, that
+* unsigned applets cannot access properties by default or install their
+* own protocol handlers).
+* &lt;p&gt;
+* This chaining is done via the system property java.protocol.handler.pkgs
+* If this property is set, it is assumed to be a &quot;|&quot; separated list of
+* package names in which to attempt locating protocol handlers.  The
+* protocol handler is searched for by appending the string 
+* &quot;.&lt;protocol&gt;.Handler&quot; to each packed in the list until a hander is found.
+* If a protocol handler is not found in this list of packages, or if the
+* property does not exist, then the default protocol handler of
+* &quot;gnu.java.net.&lt;protocol&gt;.Handler&quot; is tried.  If this is
+* unsuccessful, a MalformedURLException is thrown.
+* &lt;p&gt;
+* All of the constructor methods of URL attempt to load a protocol
+* handler and so any needed protocol handlers must be installed when
+* the URL is constructed.
+* &lt;p&gt;
+* Here is an example of how URL searches for protocol handlers.  Assume
+* the value of java.protocol.handler.pkgs is &quot;com.foo|com.bar&quot; and the
+* URL is &quot;<A HREF="news://comp.lang.java.programmer">news://comp.lang.java.programmer</A>&quot;.  URL would looking the 
+* following places for protocol handlers:
+* &lt;p&gt;&lt;pre&gt;
+* com.foo.news.Handler
+* com.bar.news.Handler
+* gnu.java.net.news.Handler
+* &lt;/pre&gt;&lt;p&gt;
+* If the protocol handler is not found in any of those locations, a
+* MalformedURLException would be thrown.
+* &lt;p&gt;
+* Please note that a protocol handler must be a subclass of
+* URLStreamHandler.
+* &lt;p&gt;
+* Normally, this class caches protocol handlers.  Once it finds a handler
+* for a particular protocol, it never tries to look up a new handler
+* again.  However, if the system property
+* gnu.java.net.nocache_protocol_handlers is set, then this
+* caching behavior is disabled.  This property is specific to this
+* implementation.  Sun's JDK may or may not do protocol caching, but it
+* almost certainly does not examine this property.
+* &lt;p&gt;
+* Please also note that an application can install its own factory for
+* loading protocol handlers (see setURLStreamHandlerFactory).  If this is
+* done, then the above information is superseded and the behavior of this
+* class in loading protocol handlers is dependent on that factory.
+*
+* @author Aaron M. Renn &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">arenn at urbanophile.com</A>&gt;
+* @author Warren Levy &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">warrenl at cygnus.com</A>&gt;
+*
+* @see URLStreamHandler
+*/
+public final class URL //implements Serializable
+{
+
+	/* The String version of the URL */
+	public String url;
+	
+/**
+* The name of the protocol for this URL.
+* The protocol is always stored in lower case.
+*/
+private String protocol;
+
+/**
+* The &quot;authority&quot; portion of the URL.
+*/
+private String authority;
+
+/**
+* The hostname or IP address of this protocol.
+* This includes a possible user. For example &lt;code&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">joe at some.host.net</A>&lt;/code&gt;.
+*/
+private String host;
+
+/**
+* The port number of this protocol or -1 if the port number used is
+* the default for this protocol.
+*/
+private int port = -1;	// Initialize for constructor using context.
+
+/**
+* The &quot;file&quot; portion of the URL. It is defined as &lt;code&gt;path[?query]&lt;/code&gt;.
+*/
+private String file;
+
+/**
+* The anchor portion of the URL.
+*/
+private String ref;
+
+/**
+* This is the hashCode for this URL
+*/
+private int hashCode = 0;
+
+/**
+* The protocol handler in use for this URL
+*/
+transient URLStreamHandler ph;
+
+/**
+* If an application installs its own protocol handler factory, this is
+* where we keep track of it.
+*/
+//private static URLStreamHandlerFactory factory;
+
+//private static final long serialVersionUID = -7627629688361524110L;
+
+/**
+* This a table where we cache protocol handlers to avoid the overhead
+* of looking them up each time.
+*/
+// private static Hashtable ph_cache = new Hashtable();
+
+/**
+* Whether or not to cache protocol handlers.
+*/
+// private static boolean cache_handlers;
+
+/**
+* The search path of packages to search for protocol handlers in.
+*/
+//private static String ph_search_path;
+/*
+static
+ {
+   String s = System.getProperty(&quot;gnu.java.net.nocache_protocol_handlers&quot;);
+   if (s == null)
+     cache_handlers = true;
+   else
+     cache_handlers = false;
+
+   ph_search_path = System.getProperty(&quot;java.protocol.handler.pkgs&quot;);
+
+   // Tack our default package on at the ends
+   if (ph_search_path != null)
+     ph_search_path = ph_search_path + &quot;|&quot; + &quot;gnu.java.net.protocol&quot;;
+   else
+     ph_search_path = &quot;gnu.java.net.protocol&quot;;
+ }
+*/
+/**
+* Constructs a URL and loads a protocol handler for the values passed as
+* arguments.
+* 
+* @param protocol The protocol for this URL (&quot;http&quot;, &quot;ftp&quot;, etc)
+* @param host The hostname or IP address to connect to
+* @param port The port number to use, or -1 to use the protocol's
+* default port
+* @param file The &quot;file&quot; portion of the URL.
+*
+* @exception MalformedURLException If a protocol handler cannot be loaded or
+* a parse error occurs.
+*/
+public URL(String protocol, String host, int port, String file)
+ throws MalformedURLException
+{
+ this(protocol, host, port, file, null);
+}
+
+/**
+* Constructs a URL and loads a protocol handler for the values passed in
+* as arugments.  Uses the default port for the protocol.
+*
+* @param protocol The protocol for this URL (&quot;http&quot;, &quot;ftp&quot;, etc)
+* @param host The hostname or IP address for this URL
+* @param file The &quot;file&quot; portion of this URL.
+*
+* @exception MalformedURLException If a protocol handler cannot be loaded or
+* a parse error occurs.
+*/
+public URL(String protocol, String host, String file)
+ throws MalformedURLException
+{
+ this(protocol, host, -1, file, null);
+}
+
+
+/**
+* This method initializes a new instance of &lt;code&gt;URL&lt;/code&gt; with the
+* specified protocol, host, port, and file.  Additionally, this method
+* allows the caller to specify a protocol handler to use instead of 
+* the default.  If this handler is specified, the caller must have
+* the &quot;specifyStreamHandler&quot; permission (see &lt;code&gt;NetPermission&lt;/code&gt;)
+* or a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.
+*
+* @param protocol The protocol for this URL (&quot;http&quot;, &quot;ftp&quot;, etc)
+* @param host The hostname or IP address to connect to
+* @param port The port number to use, or -1 to use the protocol's default
+* port
+* @param file The &quot;file&quot; portion of the URL.
+* @param ph The protocol handler to use with this URL.
+*
+* @exception MalformedURLException If no protocol handler can be loaded
+* for the specified protocol.
+* @exception SecurityException If the &lt;code&gt;SecurityManager&lt;/code&gt; exists
+* and does not allow the caller to specify its own protocol handler.
+*
+* @since 1.2
+*/
+public URL (String protocol, String host, int port, String file,
+	      URLStreamHandler ph)
+ throws MalformedURLException
+{
+ if (protocol == null)
+   throw new MalformedURLException(&quot;null protocol&quot;);
+ this.protocol = protocol.toLowerCase();
+
+ if (ph != null)
+   {
+			/*
+	SecurityManager s = System.getSecurityManager();
+	if (s != null)
+	  s.checkPermission (new NetPermission (&quot;specifyStreamHandler&quot;));
+			*/
+     this.ph = ph;
+   }
+ else
+   this.ph = getURLStreamHandler(protocol);
+
+ if (this.ph == null)
+   throw new MalformedURLException (
+		      &quot;Protocol handler not found: &quot; + protocol);
+
+ this.host = host;
+ this.port = port;
+ this.authority = null;
+
+ int hashAt = file.indexOf('#');
+ if (hashAt &lt; 0)
+   {
+	this.file = file;
+	this.ref = null;
+   }
+ else
+   {
+	this.file = file.substring(0, hashAt);
+	this.ref = file.substring(hashAt + 1);
+   }
+ hashCode = hashCode();			// Used for serialization.
+		url = toString();
+}
+
+/**
+* Initializes a URL from a complete string specification such as
+* &quot;<A HREF="http://www.urbanophile.com/arenn/">http://www.urbanophile.com/arenn/</A>&quot;.  First the protocol name is parsed
+* out of the string.  Then a handler is located for that protocol and
+* the parseURL() method of that protocol handler is used to parse the
+* remaining fields.
+*
+* @param spec The complete String representation of a URL
+*
+* @exception MalformedURLException If a protocol handler cannot be found
+* or the URL cannot be parsed
+*/
+public URL(String spec) throws MalformedURLException
+{
+ this((URL) null, spec, (URLStreamHandler) null);
+}
+
+/*
+* This method parses a String representation of a URL within the
+* context of an existing URL.  Principally this means that any
+* fields not present the URL are inheritied from the context URL.
+* This allows relative URL's to be easily constructed.  If the
+* context argument is null, then a complete URL must be specified
+* in the URL string.  If the protocol parsed out of the URL is
+* different from the context URL's protocol, then then URL String
+* is also expected to be a complete URL.
+*
+* @param context The context on which to parse the specification
+* @param spec The string to parse an URL
+*
+* @exception MalformedURLException If a protocol handler cannot be found 
+* for the URL cannot be parsed
+*/
+public URL(URL context, String spec) throws MalformedURLException
+{
+ this(context, spec, (URLStreamHandler) null);
+}
+
+/**
+* Creates an URL from given arguments
+* This method parses a String representation of a URL within the
+* context of an existing URL.  Principally this means that any fields
+* not present the URL are inheritied from the context URL.  This allows
+* relative URL's to be easily constructed.  If the context argument is
+* null, then a complete URL must be specified in the URL string.
+* If the protocol parsed out of the URL is different 
+* from the context URL's protocol, then then URL String is also
+* expected to be a complete URL.
+* &lt;p&gt;
+* Additionally, this method allows the caller to specify a protocol handler
+* to use instead of  the default.  If this handler is specified, the caller
+* must have the &quot;specifyStreamHandler&quot; permission
+* (see &lt;code&gt;NetPermission&lt;/code&gt;) or a &lt;code&gt;SecurityException&lt;/code&gt;
+* will be thrown.
+*
+* @param context The context in which to parse the specification
+* @param spec The string to parse as an URL
+* @param ph The stream handler for the URL
+*
+* @exception MalformedURLException If a protocol handler cannot be found
+* or the URL cannot be parsed
+* @exception SecurityException If the &lt;code&gt;SecurityManager&lt;/code&gt; exists
+* and does not allow the caller to specify its own protocol handler.
+*
+* @since 1.2
+*/
+public URL(URL context, String spec, URLStreamHandler ph)
+ throws MalformedURLException
+{
+ /* A protocol is defined by the doc as the substring before a ':'
+  * as long as the ':' occurs before any '/'.
+  *
+  * If context is null, then spec must be an absolute URL.
+  *
+  * The relative URL need not specify all the components of a URL.
+  * If the protocol, host name, or port number is missing, the value
+  * is inherited from the context.  A bare file component is appended
+  * to the context's file.  The optional anchor is not inherited. 
+  */
+
+ // If this is an absolute URL, then ignore context completely.
+ // An absolute URL must have chars prior to &quot;://&quot; but cannot have a colon
+ // right after the &quot;://&quot;.  The second colon is for an optional port value
+ // and implies that the host from the context is used if available.
+ int colon;
+ if ((colon = spec.indexOf(&quot;://&quot;, 1)) &gt; 0 &amp;&amp;
+	! spec.regionMatches(colon, &quot;://:&quot;, 0, 4))
+   context = null;
+
+ int slash;
+ if ((colon = spec.indexOf(':')) &gt; 0 &amp;&amp;
+	(colon &lt; (slash = spec.indexOf('/')) || slash &lt; 0))
+   {
+	// Protocol specified in spec string.
+	protocol = spec.substring(0, colon).toLowerCase();
+	if (context != null &amp;&amp; context.protocol.equals(protocol))
+	  {
+	    // The 1.2 doc specifically says these are copied to the new URL.
+	    host = context.host;
+	    port = context.port;
+	    file = context.file;
+	    authority = context.authority;
+	  }
+   }
+ else if (context != null)
+   {
+	// Protocol NOT specified in spec string.
+	// Use context fields (except ref) as a foundation for relative URLs.
+	colon = -1;
+	protocol = context.protocol;
+	host = context.host;
+	port = context.port;
+	file = context.file;
+     authority = context.authority;
+   }
+ else	// Protocol NOT specified in spec. and no context available.
+   throw new
+	  MalformedURLException(&quot;Absolute URL required with null context&quot;);
+
+ if (ph != null)
+   {
+			/*
+	SecurityManager s = System.getSecurityManager ();
+	if (s != null)
+	  s.checkPermission (new NetPermission (&quot;specifyStreamHandler&quot;));
+			*/
+     this.ph = ph;
+   }
+ else
+   this.ph = getURLStreamHandler(protocol);
+
+ if (this.ph == null)
+   throw new MalformedURLException(&quot;Protocol handler not found: &quot;
+				      + protocol);
+
+ // JDK 1.2 doc for parseURL specifically states that any '#' ref
+ // is to be excluded by passing the 'limit' as the indexOf the '#'
+ // if one exists, otherwise pass the end of the string.
+ int hashAt = spec.indexOf('#', colon + 1);
+ this.ph.parseURL(this, spec, colon + 1,
+		     hashAt &lt; 0 ? spec.length() : hashAt);
+ if (hashAt &gt;= 0)
+   ref = spec.substring(hashAt + 1);
+
+ hashCode = hashCode();			// Used for serialization.
+		url = toString();
+}
+
+/**
+* Test another URL for equality with this one.  This will be true only if
+* the argument is non-null and all of the fields in the URL's match 
+* exactly (ie, protocol, host, port, file, and ref).  Overrides
+* Object.equals(), implemented by calling the equals method of the handler.
+*
+* @param url The URL to compare with
+*
+* @return true if the URL is equal, false otherwise
+*/
+public boolean equals (Object obj)
+{
+ if (obj == null || ! (obj instanceof URL))
+   return false;
+
+ return ph.equals (this, (URL) obj);
+}
+
+/**
+* Returns the contents of this URL as an object by first opening a
+* connection, then calling the getContent() method against the connection
+*
+* @return A content object for this URL
+* @exception IOException If opening the connection or getting the
+* content fails.
+*
+* @since 1.3
+*/
+		/*
+public final Object getContent() throws IOException
+{
+ return openConnection().getContent();
+}
+		*/
+/**
+* Gets the contents of this URL
+*
+* @exception IOException If an error occurs
+*/
+		/*
+public final Object getContent (Class[] classes) throws IOException
+{
+ // FIXME: implement this
+ return getContent();
+}
+	 */
+
+/**
+* Returns the file portion of the URL.
+* Defined as &lt;code&gt;path[?query]&lt;/code&gt;.
+* Returns the empty string if there is no file portion.
+*/
+public String getFile()
+{
+ return file == null ? &quot;&quot; : file;
+}
+
+/**
+* Returns the path of the URL. This is the part of the file before any '?'
+* character.
+*
+* @since 1.3
+*/
+public String getPath()
+{
+ int quest = (file == null) ? -1 : file.indexOf('?');
+ return quest &lt; 0 ? getFile() : file.substring(0, quest);
+}
+
+/**
+* Returns the authority of the URL
+* 
+* @since 1.3
+*/
+public String getAuthority()
+{
+ return authority;
+}
+
+/**
+* Returns the host of the URL
+*/
+public String getHost()
+{
+ int at = (host == null) ? -1 : host.indexOf('@');
+ return at &lt; 0 ? host : host.substring(at + 1, host.length());
+}
+
+/**
+* Returns the port number of this URL or -1 if the default port number is
+* being used.
+*
+* @return The port number
+*
+* @see #getDefaultPort()
+*/
+public int getPort()
+{
+ return port;
+}
+
+/**
+* Returns the default port of the URL. If the StreamHandler for the URL
+* protocol does not define a default port it returns -1.
+*/
+		/*
+public int getDefaultPort()
+{
+ return ph.getDefaultPort();
+}
+*/
+/**
+* Returns the protocol of the URL
+*/
+public String getProtocol()
+{
+ return protocol;
+}
+
+/**
+* Returns the ref (sometimes called the &quot;# reference&quot; or &quot;anchor&quot;) portion
+* of the URL.
+*
+* @return The ref
+*/
+public String getRef()
+{
+ return ref;
+}
+
+/**
+* Returns the user information of the URL. This is the part of the host
+* name before the '@'.
+*
+* @return the user at a particular host or null when no user defined.
+*/
+public String getUserInfo ()
+{
+ int at = (host == null) ? -1 : host.indexOf('@');
+ return at &lt; 0 ? null : host.substring(0, at);
+}
+
+/**
+* Returns the query of the URL. This is the part of the file before the
+* '?'.
+*
+* @return the query part of the file, or null when there is no query part.
+*/
+public String getQuery ()
+{
+ int quest = (file == null) ? -1 : file.indexOf('?');
+ return quest &lt; 0 ? null : file.substring(quest + 1, file.length());
+}
+
+/**
+* Returns a hashcode computed by the URLStreamHandler of this URL
+*/
+public int hashCode()
+{
+ if (hashCode != 0)
+   return hashCode;		// Use cached value if available.
+ return ph.hashCode (this);
+}
+
+/**
+* Returns a URLConnection object that represents a connection to the remote
+* object referred to by the URL. The URLConnection is created by calling the
+* openConnection() method of the protocol handler
+*
+* @return A URLConnection for this URL
+* @exception IOException If an error occurs
+*/
+		/*
+public URLConnection openConnection() throws IOException
+{
+ return ph.openConnection(this);
+}
+ */
+/**
+* Opens a connection to this URL and returns an InputStream for reading
+* from that connection
+*
+* @exception IOException If an error occurs
+*/
+		/*
+public final InputStream openStream() throws IOException
+{
+ return openConnection().getInputStream();
+}
+*/
+/**
+* Tests whether or not another URL refers to the same &quot;file&quot; as this one.
+* This will be true if and only if the passed object is not null, is a
+* URL, and matches all fields but the ref (ie, protocol, host, port,
+* and file);
+*
+* @param url The URL object to test with
+*
+* @return true if URL matches this URL's file, false otherwise
+*/
+		/*
+public boolean sameFile(URL other)
+{
+ return ph.sameFile(this, other);
+}
+*/
+/**
+* Sets the specified fields of the URL. This is not a public method so
+* that only URLStreamHandlers can modify URL fields. This might be called
+* by the &lt;code&gt;parseURL()&lt;/code&gt; method in that class. URLs are otherwise
+* constant.
+*
+* @param protocol The protocol name for this URL
+* @param host The hostname or IP address for this URL
+* @param port The port number of this URL
+* @param file The &quot;file&quot; portion of this URL.
+* @param ref The anchor portion of this URL.
+*/
+protected void set(String protocol, String host, int port, String file,
+		     String ref)
+{
+ // TBD: Theoretically, a poorly written StreamHandler could pass an
+ // invalid protocol.  It will cause the handler to be set to null
+ // thus overriding a valid handler.  Callers of this method should
+ // be aware of this.
+ this.ph = getURLStreamHandler(protocol);
+ this.protocol = protocol.toLowerCase();
+ this.authority = null;
+ this.port = port;
+ this.host = host;
+ this.file = file;
+ this.ref = ref;
+ hashCode = hashCode();			// Used for serialization.
+}
+
+/**
+* Sets the specified fields of the URL. This is not a public method so
+* that only URLStreamHandlers can modify URL fields. URLs are otherwise
+* constant.
+*
+* @since 1.3
+*/
+protected void set(String protocol, String host, int port,
+		     String authority, String userInfo,
+		     String path, String query, String ref)
+{
+ // TBD: Theoretically, a poorly written StreamHandler could pass an
+ // invalid protocol.  It will cause the handler to be set to null
+ // thus overriding a valid handler.  Callers of this method should
+ // be aware of this.
+ this.ph = getURLStreamHandler(protocol);
+ this.protocol = protocol.toLowerCase();
+ if (userInfo == null)
+   this.host = host;
+ else
+   this.host = userInfo + &quot;@&quot; + host;
+ this.port = port;
+ if (query == null)
+   this.file = path;
+ else
+   this.file = path + &quot;?&quot; + query;
+ this.ref = ref;
+ hashCode = hashCode();			// Used for serialization.
+}
+
+/**
+* Sets the URLStreamHandlerFactory for this class.  This factory is
+* responsible for returning the appropriate protocol handler for
+* a given URL.
+*
+* @param fac The URLStreamHandlerFactory class to use
+*
+* @exception Error If the factory is alread set.
+* @exception SecurityException If a security manager exists and its
+* checkSetFactory method doesn't allow the operation
+*/
+		/*
+public static synchronized void
+	setURLStreamHandlerFactory(URLStreamHandlerFactory fac)
+{
+ if (factory != null)
+   throw new Error(&quot;URLStreamHandlerFactory already set&quot;);
+
+ // Throw an exception if an extant security mgr precludes
+ // setting the factory.
+ SecurityManager s = System.getSecurityManager();
+ if (s != null)
+   s.checkSetFactory();
+ factory = fac;
+}
+*/
+/**
+* Returns a String representing this URL.  The String returned is
+* created by calling the protocol handler's toExternalForm() method.
+*
+* @return A string for this URL
+*/
+public String toExternalForm()
+{
+ // Identical to toString().
+ return ph.toExternalForm(this);
+}
+
+/**
+* Returns a String representing this URL.  Identical to toExternalForm().
+* The value returned is created by the protocol handler's 
+* toExternalForm method.  Overrides Object.toString()
+*
+* @return A string for this URL
+*/
+public String toString()
+{
+ // Identical to toExternalForm().
+ return ph.toExternalForm(this);
+}
+
+/**
+* This internal method is used in two different constructors to load
+* a protocol handler for this URL.
+*
+* @param protocol The protocol to load a handler for
+*
+* @return A URLStreamHandler for this protocol, or null when not found.
+*/
+private static synchronized URLStreamHandler
+ getURLStreamHandler (String protocol)
+{
+ //URLStreamHandler ph;
+
+ // First, see if a protocol handler is in our cache
+		/*
+ if (cache_handlers)
+   {
+     Class cls = (Class)ph_cache.get(protocol);
+     if (cls != null)
+       {
+         try
+           {
+             ph = (URLStreamHandler)cls.newInstance();
+             return(ph);
+           }
+         catch (Exception e) { ; }
+       }
+   }
+			*/
+ // If a non-default factory has been set, use it to find the protocol.
+		/*
+ if (factory != null)
+   {
+     ph = factory.createURLStreamHandler(protocol);
+     if (ph != null)
+       {
+         if (cache_handlers)
+	      ph_cache.put(protocol, ph.getClass());
+
+         return(ph);
+	  }
+   }
+		*/
+ // Finally loop through our search path looking for a match
+		/*
+ StringTokenizer st = new StringTokenizer(ph_search_path, &quot;|&quot;);
+ while (st.hasMoreTokens())
+   {
+     String clsname = st.nextToken() + &quot;.&quot; + protocol + &quot;.Handler&quot;;
+      
+     try
+       {
+         Class cls = Class.forName(clsname); 
+         Object obj = cls.newInstance();
+         if (!(obj instanceof URLStreamHandler))
+           continue;
+         else
+           ph = (URLStreamHandler)obj;
+
+         if (cache_handlers)
+           ph_cache.put(protocol, cls);
+
+         return(ph);
+       }
+     catch (Exception e) { ; }
+   }
+			*/
+		return new URLStreamHandler();
+ // Still here, which is bad
+ //return null;
+}
+
+
+//===================================================================
+//public String toString() {return url;}
+//===================================================================
+
+/*
+private void readObject(ObjectInputStream ois)
+ throws IOException, ClassNotFoundException
+{
+ ois.defaultReadObject();
+ this.ph = getURLStreamHandler(protocol);
+ if (this.ph == null)
+   throw new IOException(&quot;Handler for protocol &quot; + protocol + &quot; not found&quot;);
+}
+
+private void writeObject(ObjectOutputStream oos) throws IOException
+{
+ oos.defaultWriteObject();
+}
+	*/
+}
+
+

Added: experiments/EVE/src/cachewolf/URLStreamHandler.java
===================================================================
--- experiments/EVE/src/cachewolf/URLStreamHandler.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/URLStreamHandler.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,305 @@
+package cachewolf;
+
+//Only needed for OCXMLImporter
+
+/* URL.java -- Uniform Resource Locator Class
+Copyright (C) 1998, 1999, 2000, 2002, 2003  Free Software Foundation, Inc.
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+02111-1307 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+
+import eve.io.File;
+import java.io.IOException;
+
+//##################################################################
+public class URLStreamHandler{
+//##################################################################
+/**
+* Provides the default equals calculation. May be overidden by handlers for
+* other protocols that have different requirements for equals(). This method
+* requires that none of its arguments is null. This is guaranteed by the
+* fact that it is only called by java.net.URL class.
+*
+* @param url1 An URL object
+* @param url2 An URL object
+*/
+protected boolean equals (URL url1, URL url2)
+{
+ // This comparison is very conservative.  It assumes that any
+ // field can be null.
+ return (url1.getPort () == url2.getPort ()
+	    &amp;&amp; ((url1.getProtocol () == null &amp;&amp; url2.getProtocol () == null)
+		|| (url1.getProtocol () != null
+			&amp;&amp; url1.getProtocol ().equals (url2.getProtocol ())))
+	    &amp;&amp; ((url1.getUserInfo () == null &amp;&amp; url2.getUserInfo () == null)
+             || (url1.getUserInfo () != null
+			&amp;&amp; url1.getUserInfo ().equals(url2.getUserInfo ())))
+	    &amp;&amp; ((url1.getAuthority () == null &amp;&amp; url2.getAuthority () == null)
+             || (url1.getAuthority () != null
+			&amp;&amp; url1.getAuthority ().equals(url2.getAuthority ())))
+	    &amp;&amp; ((url1.getHost () == null &amp;&amp; url2.getHost () == null)
+		|| (url1.getHost () != null
+			&amp;&amp; url1.getHost ().equals(url2.getHost ())))
+	    &amp;&amp; ((url1.getPath () == null &amp;&amp; url2.getPath () == null)
+		|| (url1.getPath () != null
+			&amp;&amp; url1.getPath ().equals (url2.getPath ())))
+	    &amp;&amp; ((url1.getQuery () == null &amp;&amp; url2.getQuery () == null)
+             || (url1.getQuery () != null
+			&amp;&amp; url1.getQuery ().equals(url2.getQuery ())))
+	    &amp;&amp; ((url1.getRef () == null &amp;&amp; url2.getRef () == null)
+		|| (url1.getRef () != null
+			&amp;&amp; url1.getRef ().equals(url2.getRef ()))));
+}
+/**
+* Returns the default port for a URL parsed by this handler. This method is
+* meant to be overidden by handlers with default port numbers.
+*/
+protected int getDefaultPort ()
+{
+ return -1;
+}
+
+/**
+* Provides the default hash calculation. May be overidden by handlers for
+* other protocols that have different requirements for hashCode calculation.
+*/
+protected int hashCode (URL url)
+{
+ return url.getProtocol ().hashCode () +
+        ((url.getHost () == null) ? 0 : url.getHost ().hashCode ()) +
+	   url.getFile ().hashCode() +
+	   url.getPort ();
+}
+
+/**
+* This method converts a URL object into a String.  This method creates
+* Strings in the mold of http URL's, so protocol handlers which use URL's
+* that have a different syntax should override this method
+*
+* @param url The URL object to convert
+*/
+protected String toExternalForm(URL u)
+{
+ String protocol, host, file, ref;
+ int port;
+
+ protocol = u.getProtocol();
+
+ // JDK 1.2 online doc infers that host could be null because it
+ // explicitly states that file cannot be null, but is silent on host.
+ host = u.getHost();
+ if (host == null)
+   host = &quot;&quot;;
+
+ port = u.getPort();
+ file = u.getFile();
+ ref = u.getRef();
+
+ // Guess a reasonable size for the string buffer so we have to resize
+ // at most once.
+ int size = protocol.length() + host.length() + file.length() + 24;
+ StringBuffer sb = new StringBuffer(size);
+
+ if (protocol != null &amp;&amp; protocol.length() &gt; 0)
+   {
+	sb.append(protocol);
+	sb.append(&quot;:&quot;);
+   }
+
+ if (host.length() != 0)
+   sb.append(&quot;//&quot;).append(host);
+
+ // Note that this produces different results from JDK 1.2 as JDK 1.2
+ // ignores a non-default port if host is null or &quot;&quot;.  That is inconsistent
+ // with the spec since the result of this method is spec'ed so it can be
+ // used to construct a new URL that is equivalent to the original.
+ boolean port_needed = port &gt; 0 &amp;&amp; port != getDefaultPort();
+ if (port_needed)
+   sb.append(':').append(port);
+
+ sb.append(file);
+
+ if (ref != null)
+   sb.append('#').append(ref);
+
+ return sb.toString();
+}
+/**
+* This method parses the string passed in as a URL and set's the
+* instance data fields in the URL object passed in to the various values
+* parsed out of the string.  The start parameter is the position to start
+* scanning the string.  This is usually the position after the &quot;:&quot; which
+* terminates the protocol name.  The end parameter is the position to
+* stop scanning.  This will be either the end of the String, or the
+* position of the &quot;#&quot; character, which separates the &quot;file&quot; portion of
+* the URL from the &quot;anchor&quot; portion.
+* &lt;p&gt;
+* This method assumes URL's are formatted like http protocol URL's, so 
+* subclasses that implement protocols with URL's the follow a different 
+* syntax should override this method.  The lone exception is that if
+* the protocol name set in the URL is &quot;file&quot;, this method will accept
+* an empty hostname (i.e., &quot;<A HREF="file:///">file:///</A>&quot;), which is legal for that protocol
+*
+* @param url The URL object in which to store the results
+* @param spec The String-ized URL to parse
+* @param start The position in the string to start scanning from
+* @param end The position in the string to stop scanning
+*/
+protected void parseURL(URL url, String spec, int start, int end)
+{
+ String host = url.getHost();
+ int port = url.getPort();
+ String file = url.getFile();
+ String ref = url.getRef();
+ 
+ if (spec.regionMatches (start, &quot;//&quot;, 0, 2))
+   {
+	int hostEnd;
+	int colon;
+
+	start += 2;
+	int slash = spec.indexOf('/', start);
+	if (slash &gt;= 0) 
+	  hostEnd = slash;
+     else
+	  hostEnd = end;
+
+	host = spec.substring (start, hostEnd);
+	
+	// Look for optional port number.  It is valid for the non-port
+	// part of the host name to be null (e.g. a URL &quot;<A HREF="http://:80">http://:80</A>&quot;).
+	// TBD: JDK 1.2 in this case sets host to null rather than &quot;&quot;;
+	// this is undocumented and likely an unintended side effect in 1.2
+	// so we'll be simple here and stick with &quot;&quot;. Note that
+	// &quot;<A HREF="http://">http://</A>&quot; or &quot;<A HREF="http:///">http:///</A>&quot; produce a &quot;&quot; host in JDK 1.2.
+	if ((colon = host.indexOf(':')) &gt;= 0)
+	  {
+			port = eve.sys.Convert.toInt(host.substring(colon + 1));
+	    host = host.substring(0, colon);
+	  }
+	file = null;
+	start = hostEnd;
+   } 
+ else if (host == null) 
+   host = &quot;&quot;;
+
+ if (file == null || file.length() == 0
+	|| (start &lt; end &amp;&amp; spec.charAt(start) == '/')) 
+   {
+	// No file context available; just spec for file.
+	// Or this is an absolute path name; ignore any file context.
+	file = spec.substring(start, end);
+	ref = null;
+   } 
+ else if (start &lt; end)
+   {
+     // Context is available, but only override it if there is a new file.
+     char sepChar = '/';
+     int lastSlash = file.lastIndexOf (sepChar);
+     if (lastSlash &lt; 0 /*&amp;&amp; File.separatorChar != sepChar*/
+         &amp;&amp; url.getProtocol ().equals (&quot;file&quot;))
+       {
+         // On Windows, even '\' is allowed in a &quot;file&quot; URL.
+         /*sepChar = File.separatorChar;*/
+         lastSlash = file.lastIndexOf (sepChar);
+       }
+     
+				if (lastSlash == -1) file = file + sepChar + spec.substring(start,end);
+     else file = file.substring(0, lastSlash)
+             + sepChar + spec.substring (start, end);
+
+     if (url.getProtocol ().equals (&quot;file&quot;))
+       {
+         // For &quot;file&quot; URLs constructed relative to a context, we
+         // need to canonicalise the file path.
+         try
+           {
+             file = new File (file).getCanonicalPath ();
+           }
+         catch (IOException e)
+           {
+           }
+       }
+
+	ref = null;
+   }
+
+ if (ref == null)
+   {
+	// Normally there should be no '#' in the file part,
+	// but we are nice.
+	int hash = file.indexOf('#');
+	if (hash != -1)
+	  {
+	    ref = file.substring(hash + 1, file.length());
+	    file = file.substring(0, hash);
+	  }
+   }
+
+ // XXX - Classpath used to call PlatformHelper.toCanonicalForm() on
+ // the file part. It seems like overhead, but supposedly there is some
+ // benefit in windows based systems (it also lowercased the string).
+
+ setURL(url, url.getProtocol(), host, port, file, ref);
+}
+
+/**
+* This methods sets the instance variables representing the various fields
+* of the URL to the values passed in.
+*
+* @param u The URL to modify
+* @param protocol The protocol to set
+* @param host The host name to et
+* @param port The port number to set
+* @param file The filename to set
+* @param ref The reference
+*
+* @exception SecurityException If the protocol handler of the URL is
+* different from this one
+*
+* @deprecated 1.2 Please use
+* #setURL(URL,String,String,int,String,String,String,String);
+*/
+protected void setURL(URL u, String protocol, String host, int port,
+			String file, String ref)
+{
+ u.set(protocol, host, port, file, ref);
+}
+
+
+//##################################################################
+}
+//##################################################################
+

Added: experiments/EVE/src/cachewolf/UrlFetcher.java
===================================================================
--- experiments/EVE/src/cachewolf/UrlFetcher.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/UrlFetcher.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,77 @@
+package cachewolf;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import eve.io.JavaUtf8Codec;
+import java.net.Socket;
+import eve.util.ByteArray;
+import eve.util.CharArray;
+import java.util.Properties;
+
+public class UrlFetcher {
+	public static String fetchString(String address) throws IOException
+	{
+		ByteArray daten = fetchByteArray(address, null);
+		JavaUtf8Codec codec = new JavaUtf8Codec();
+		CharArray c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
+		return c_data.toString();
+	}
+
+	public static Properties fetchPropertyList(String url) throws IOException {
+		CharArray t = new CharArray();
+		ByteArray doc = fetchByteArray(url, t);
+		Properties props = new Properties();
+		props.load(new ByteArrayInputStream(doc.data));
+		return props; 
+	}
+	
+	
+	/**
+	 * @param url - if url-not-allowed chars are contained, they will be automatically encoded
+	 * @param if non null, realurl will be filled with the real url, which can differ from the given url, in case url returns a http-redirect
+	 * @return
+	 * @throws IOException
+	 */
+	public static ByteArray fetchByteArray(String url, CharArray realurl) throws IOException {	
+		final int maxRedirections = 5;
+		HttpConnection conn = null;
+		Socket sock = null;
+		int i=-1;
+		String urltmp = new String(url);
+		while (urltmp != null &amp;&amp; i &lt;= maxRedirections ) { // allow max 5 redirections (http 302 location)
+			if (realurl != null) realurl.setData(new String(urltmp).toCharArray());
+			i++;
+			conn = new HttpConnection(urltmp);
+			conn.setRequestorProperty(&quot;USER_AGENT&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
+			conn.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
+			conn.documentIsEncoded = isUrlEncoded(urltmp);
+			sock = conn.connect();
+			if (conn.responseCode &gt;= 400) throw new IOException(&quot;URL: &quot;+ urltmp + &quot;\nhttp response code: &quot; + conn.responseCode);
+			urltmp = conn.getRedirectTo();
+		}
+		if (i &gt; maxRedirections) throw new IOException(&quot;too many http redirections while trying to fetch: &quot;+url + &quot; only &quot;+maxRedirections+&quot; are allowed&quot;);
+		ByteArray daten = conn.readData(sock);
+		sock.close();
+		return daten;
+	}
+	
+	/**
+	 * @param url
+	 * @return true, if the string seems to be already URL encoded (that is, it contains only url-allowd chars), false otherwise
+	 */
+	public static boolean isUrlEncoded(String url) {
+		final String allowed = new String (&quot;-_.~!*'();:@&amp;=+$,/?%#[]&quot;);
+		char [] src = eve.sys.Vm.getStringChars(url);
+		char c;
+		for (int i = 0; i&lt;src.length; i++){
+			c = src[i];
+			if (       (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') 
+					|| (c &gt;= 'a' &amp;&amp; c &lt;= 'z') 
+					|| (c &gt;= '0' &amp;&amp; c &lt;= '9')
+					|| (allowed.indexOf(c) &gt;= 0)
+			) continue;
+			return false;
+		}
+		return true;
+	}
+}
\ No newline at end of file

Added: experiments/EVE/src/cachewolf/Version.java
===================================================================
--- experiments/EVE/src/cachewolf/Version.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/Version.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,135 @@
+
+package cachewolf;
+
+
+import cachewolf.utils.Common;
+
+import com.stevesoft.eve_pat.Regex;
+import java.io.IOException;
+import java.util.Properties;
+
+import eve.sys.*;
+import eve.ui.Form;
+
+/**
+ * Class to hold and handle version information of the cachewolf project
+ * language localisation string at at number 7000
+ */
+
+/**
+ * Class to hold and handle version information of the cachewolf project
+ * language localisation string at at number 7000
+ */
+
+public class Version {
+	static final int VER_MAJOR = 1;
+	static final int VER_MINOR = 5;
+	static final String VER_SVN =&quot;$LastChangedRevision: 1314 $&quot;; // the number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
+	static final int SVN_REVISION = Common.parseInt(VER_SVN.substring(VER_SVN.indexOf(&quot; &quot;)+1, VER_SVN.lastIndexOf(&quot; &quot;)));
+	static final int VERSION_TYPE = 1;
+	public static final String[] VERSION_TYPES = {
+		&quot;Release&quot;,
+		&quot;ReleaseCandidate&quot;,
+		&quot;InDevelopmentStable&quot;,
+		&quot;InDevelopmentNewest&quot;
+	};
+
+	/** only valid after calling checkForUpdates() */
+	static int[] updateavailabe = {0,0,0,0,0};
+	/** only valid after calling checkForUpdates() */
+	static String[] versionnumbers;
+
+	public static String getRelease() {
+		return Convert.toString(VER_MAJOR) + &quot;.&quot; + Convert.toString(VER_MINOR);
+	}
+
+	public static String getReleaseDetailed() {
+		// habe die SVN-Nummer doch aus der Anzeige erstmal wieder herausgenommen, weil es in einem final Release doch recht seltsam auss&#228;he.
+		// Sinnvoll w&#228;re daher vielleicht, eine Methode getReleaseDatail, die die SVN-Versionnummer mit angibt und z.B. im &quot;&#252;ber&quot;-Dialog angezeigt werden k&#246;nnte.
+		return getRelease() + &quot;.&quot; + Convert.toString(SVN_REVISION) + &quot; &quot; + VERSION_TYPES[VERSION_TYPE];
+	}
+
+	/**
+	 * Checks if newer versions of cachewolf are available
+	 * @return [0] = recommended version type, [1]...[4]: 0: no update available, 1: newer version available, 2: version doesn't exists, 3: error
+	 * @throws IOException
+	 */
+	public static void checkForUpdates() throws IOException {
+		Properties curvers = UrlFetcher.fetchPropertyList(&quot;<A HREF="http://www.cachewolf.org/currentversions.txt">http://www.cachewolf.org/currentversions.txt</A>&quot;);
+		versionnumbers = new String[updateavailabe.length];
+		for (int i = updateavailabe.length-1; i &gt;=1; i--) {
+			updateavailabe[i] = checkVersion(curvers, &quot;T&quot;+(i-1), i); // this also sets versionnumber[i]
+		}
+		updateavailabe[0] = Convert.toInt(curvers.getProperty(&quot;RecommendedType&quot;, &quot;0&quot;));
+	}
+
+	/**
+	 * you must call checkForUpdates() before this method
+	 * @return
+	 */
+	public static String newVersionsArrayToString() {
+		StringBuffer ret = new StringBuffer(500);
+		for (int i=1; i &lt;= updateavailabe.length -1; i++) {
+			if (updateavailabe[i] != 2 || i-1 == VERSION_TYPE) {
+				ret.append(MyLocale.getMsg(7000+i-1, VERSION_TYPES[i-1]));
+				if (versionnumbers[i] != null) ret.append(&quot; &quot;).append(versionnumbers[i]);
+				if (i == updateavailabe[0]) ret.append(&quot;*&quot;);
+				if (i-1 == VERSION_TYPE ) ret.append(&quot;+&quot;);
+				ret.append(&quot;: &quot;);
+				ret.append(MyLocale.getMsg(7010 + updateavailabe[i], Convert.toString(updateavailabe[i])));
+				ret.append(&quot;\n&quot;);
+			}
+		}
+		ret.append(&quot;* = &quot;).append(MyLocale.getMsg(7020, &quot;Recommended version type&quot;));
+		ret.append(&quot;\n+ = &quot;).append(MyLocale.getMsg(7021, &quot;This version type&quot;)).append(&quot;\n&quot;);
+		ret.append(getReleaseDetailed());
+		return ret.toString();
+	}
+
+	public static String getUpdateMessage() {
+		Form.showWait();
+		try {
+			checkForUpdates();
+			return MyLocale.getMsg(7022, &quot;Version type&quot;) +&quot;\n&quot;+ newVersionsArrayToString();
+		} catch (IOException e) {
+			return MyLocale.getMsg(7023, &quot;Error getting current version information&quot;) +&quot;\n&quot; + e.getMessage();
+		} finally {
+			Form.cancelWait();
+		}
+	}
+
+	/**
+	 * @param url
+	 * @return: 1 = newer Version available, 0 = this is up to date, 3 = check failed
+	 */
+
+	private static int checkVersion(Properties curvers, String prefix, int t) {
+		try {
+			int curvmaj = Convert.toInt(curvers.getProperty(prefix + &quot;VersionMajor&quot;, &quot;0&quot;));
+			int curvmin = Convert.toInt(curvers.getProperty(prefix + &quot;VersionMinor&quot;, &quot;0&quot;));
+			String svnRString = curvers.getProperty(prefix + &quot;SvnRevision&quot;,&quot;0&quot;);
+			if (svnRString.startsWith(&quot;http&quot;)) {
+				String tmp;
+				Regex s;
+				int i = svnRString.indexOf(' ');
+				if (i &gt; 0) {
+					tmp = UrlFetcher.fetchString(svnRString.substring(0, i));
+					s = new Regex (svnRString.substring(i+1, svnRString.length())); // flyingfish works 3/2008 with (&quot;(?i)Revision[\\s]*[:=][\\s]*[\\\\r]*[\\\\n]*[\\s]*([0-9]*)&quot;);
+				} else { versionnumbers[t] = &quot;error: no RegEx&quot;; return 3; }
+				s.search(tmp);
+				if (!s.didMatch()) { versionnumbers[t] = &quot;error: RegEx didnot match&quot;; return 3; }
+				svnRString = s.stringMatched(1);
+			}
+			versionnumbers[t] = curvmaj + &quot;.&quot; + curvmin + &quot;.&quot; + svnRString;
+			if (curvmaj &gt; VER_MAJOR) return 1;
+			if (curvmaj &lt; VER_MAJOR) return 0;
+			if (curvmin &gt; VER_MINOR) return 1;
+			if (curvmin &lt; VER_MINOR) return 0;
+			if (Convert.toInt(svnRString) &gt; SVN_REVISION) return 1;
+			return 0;
+		} catch (IOException e) {
+			versionnumbers[t] = &quot;IO-error&quot;;
+			return 3;
+		}
+	}
+}

Added: experiments/EVE/src/cachewolf/exp/ASCExporter.java
===================================================================
--- experiments/EVE/src/cachewolf/exp/ASCExporter.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/exp/ASCExporter.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,37 @@
+package cachewolf.exp;
+import cachewolf.*;
+
+/**
+*	Class to export cache database to an ASCII (CSV!) file.
+*   This file can be used by I2C's POI Converter to generate
+*   POIs for different routing programmes, especially for
+*	Destinator ;-) !
+*/
+public class ASCExporter extends Exporter{
+	
+	public ASCExporter(){
+		super();
+		this.setMask(&quot;*.csv&quot;);
+		this.setHowManyParams(LAT_LON);
+	}
+	
+	public ASCExporter(Preferences p,Profile prof){
+		this();
+	}
+	
+	public String record (CacheHolderDetail chD, String lat, String lon){
+		StringBuffer strBuf = new StringBuffer(100);
+		String dummy;
+		dummy = chD.cacheName;
+		dummy = dummy.replace(',', ' ');
+		strBuf.append(dummy);
+		strBuf.append(&quot;,&quot;);
+		strBuf.append(dummy);
+		strBuf.append(&quot;,&quot;);
+		strBuf.append(lon);
+		strBuf.append(&quot;,&quot;);
+		strBuf.append(lat);
+		strBuf.append(&quot;,,,,\r\n&quot;);
+		return strBuf.toString();
+	}
+}

Added: experiments/EVE/src/cachewolf/exp/DistanceComparer.java
===================================================================
--- experiments/EVE/src/cachewolf/exp/DistanceComparer.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/exp/DistanceComparer.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,24 @@
+package cachewolf.exp;
+
+import cachewolf.CWPoint;
+import cachewolf.CacheHolder;
+import eve.util.Comparer;
+
+public class DistanceComparer implements Comparer {
+	
+	CWPoint centre;
+	
+	public DistanceComparer(CWPoint centre) {
+		this.centre = centre;
+	}
+
+	public int compare(Object one, Object two) {
+		if ((! (one instanceof CacheHolder)) &amp;&amp; (!(two instanceof CacheHolder))) {
+			return 0;
+		} 
+		CacheHolder a = (CacheHolder) one;
+		CacheHolder b = (CacheHolder) two;
+		return (int) ((a.pos.getDistance(centre) - b.pos.getDistance(centre)) * 1000);
+	}
+	
+}

Added: experiments/EVE/src/cachewolf/exp/ExploristExporter.java
===================================================================
--- experiments/EVE/src/cachewolf/exp/ExploristExporter.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/exp/ExploristExporter.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,308 @@
+package cachewolf.exp;
+
+import eve.sys.*;
+import eve.ui.filechooser.FileChooser;
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import eve.io.File;
+import java.io.*;
+import eve.ui.ProgressBarForm;
+import java.util.*;
+import java.io.IOException;
+
+import cachewolf.*;
+import cachewolf.utils.Common;
+
+
+/**
+ * @author Kalle
+ * @author TweetyHH Class for Exporting direct to Magellans *.gs Files. Caches
+ *         will be exported in files with maximum of 200 Caches.
+ */
+
+public class ExploristExporter {
+	// starts with no ui for file selection
+	final static int TMP_FILE = 0;
+	// brings up a screen to select a file
+	final static int ASK_FILE = 1;
+
+	// selection, which method should be called
+	final static int NO_PARAMS = 0;
+	final static int LAT_LON = 1;
+	final static int COUNT = 2;
+
+	Vector cacheDB;
+	Preferences pref;
+	Profile profile;
+	// mask in file chooser
+	String mask = &quot;*.gs&quot;;
+	// decimal separator for lat- and lon-String
+	//char decimalSeparator = '.';
+	// if true, the complete cache details are read
+	// before a call to the record method is made
+	boolean needCacheDetails = true;
+
+	// name of exporter for saving pathname
+	String expName;
+
+	public ExploristExporter(Preferences p, Profile prof) {
+		profile = prof;
+		pref = p;
+		cacheDB = profile.cacheDB;
+		expName = this.getClass().getName();
+		// remove package
+		expName = expName.substring(expName.indexOf(&quot;.&quot;) + 1);
+	}
+
+	public void doIt() {
+		File configFile = new File(&quot;magellan.cfg&quot;);
+		if (configFile.exists()) {
+			FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, pref.getExportPath(expName+&quot;Dir&quot;));
+			fc.title=(MyLocale.getMsg(2104, &quot;Choose directory for exporting .gs files&quot;));
+			String targetDir;
+			if(fc.execute() != FileChooser.IDCANCEL){
+				targetDir = fc.getChosen() + &quot;/&quot;;
+				pref.setExportPath(expName+&quot;Dir&quot;, targetDir);
+
+				CWPoint centre = profile.centre;
+				try {
+					LineNumberReader reader = new LineNumberReader(new BufferedReader(new FileReader(configFile.getName())));
+					String line, fileName, coordinate;
+					while ((line = reader.readLine()) != null)  {
+						StringTokenizer tokenizer = new StringTokenizer(line,&quot;=&quot;);
+						fileName = targetDir + tokenizer.nextToken().trim() + &quot;.gs&quot;;
+						coordinate = tokenizer.nextToken().trim();
+						CWPoint point = new CWPoint(coordinate);
+						DistanceComparer dc = new DistanceComparer(point);
+						eve.util.Utils.sort(new Handle(),cacheDB,dc, false);
+						doIt(fileName);
+					}
+					reader.close();
+				} catch (FileNotFoundException e) {
+					InfoBox info = new InfoBox(MyLocale.getMsg(2100, &quot;Magellan Exporter&quot;),MyLocale.getMsg(2101, &quot;Failure at loading magellan.cfg\n&quot; + e.getMessage()));
+					info.show();
+				} catch (IOException e) {
+					InfoBox info = new InfoBox(MyLocale.getMsg(2100, &quot;Magellan Exporter&quot;),MyLocale.getMsg(2103, &quot;Failure at reading magellan.cfg\n&quot; + e.getMessage()));
+					info.show();
+				} finally {
+					eve.util.Utils.sort(new Handle(), cacheDB, new DistanceComparer(centre),false);
+				}
+			}
+		}
+		else {
+			doIt(null);
+		}
+	}
+	
+	/**
+	 * Does the most work for exporting data
+	 */
+	public void doIt(String baseFileName) {
+		File outFile;
+		String fileBaseName;
+		String str = null;
+		CacheHolder ch;
+		CacheHolderDetail chD;
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+
+		if (baseFileName == null) {
+			outFile = getOutputFile();
+			if (outFile == null)
+				return;
+		} else {
+			outFile = new File(baseFileName);
+		}
+
+		fileBaseName = outFile.getFullPath();
+		// cut .gs
+		fileBaseName = fileBaseName.substring(0, fileBaseName.length() - 3);
+
+		pbf.showMainTask = false;
+		pbf.setTask(h, &quot;Exporting ...&quot;);
+		pbf.exec();
+
+		int counter = 0;
+		int expCount = 0;
+		for (int i = 0; i &lt; cacheDB.size(); i++) {
+			ch = (CacheHolder) cacheDB.get(i);
+			if (ch.is_black == false &amp;&amp; ch.is_filtered == false)
+				counter++;
+		}
+
+		try {
+			PrintWriter outp = null;
+			for (int i = 0; i &lt; cacheDB.size(); i++) {
+				ch = (CacheHolder) cacheDB.get(i);
+				if (ch.is_black == false &amp;&amp; ch.is_filtered == false) {
+					// all 200 caches we need a new file
+					if (expCount % 200 == 0) {
+						if (outp != null) {
+							outp.close();
+						}
+						outp = new PrintWriter(new BufferedWriter(
+								new FileWriter(new java.io.File(fileBaseName + expCount
+										/ 200 + &quot;.gs&quot;))));
+					}
+
+					chD = new CacheHolderDetail(ch);
+					expCount++;
+					h.progress = (float) expCount / (float) counter;
+					h.changed();
+					try {
+						if (needCacheDetails) {
+							chD.readCache(profile.dataDir);
+						}
+					} catch (IOException e) {
+						continue;
+					}
+					str = record(chD);
+					if (str != null)
+						outp.print(str);
+				}// if
+
+			}// for
+			str = trailer();
+
+			if (str != null)
+				outp.print(str);
+
+			outp.close();
+			pbf.exit(0);
+		} catch (IOException ioE) {
+			Vm.debug(&quot;Error opening &quot; + outFile.getName());
+		}
+		// try
+	}
+
+	/**
+	 * uses a filechooser to get the name of the export file
+	 * 
+	 * @return
+	 */
+	public File getOutputFile() {
+		eve.io.File file;
+		FileChooser fc = new FileChooser(FileChooser.SAVE, pref
+				.getExportPath(expName));
+		fc.title=(MyLocale.getMsg(2102, &quot;Select target file:&quot;));
+		fc.addMask(mask);
+		if (fc.execute() != FileChooser.IDCANCEL) {
+			file = fc.getChosenFile();
+			pref.setExportPath(expName, file.getDrivePath());
+			return file;
+		} 
+		return null;
+	}
+
+	/**
+	 * this method can be overided by an exporter class
+	 * 
+	 * @param ch
+	 *            cachedata
+	 * @return formated cache data
+	 */
+	public String record(CacheHolderDetail chD) {
+		/*
+		static protected final int GC_AW_PARKING = 50;
+		static protected final int GC_AW_STAGE_OF_MULTI = 51;
+		static protected final int GC_AW_QUESTION = 52;
+		static protected final int GC_AW_FINAL = 53;
+		static protected final int GC_AW_TRAILHEAD = 54;
+		static protected final int GC_AW_REFERENCE = 55;
+		*/
+		StringBuffer sb = new StringBuffer();
+		sb.append(&quot;$PMGNGEO,&quot;);
+		sb.append(chD.pos.getLatDeg(CWPoint.DMM));
+		sb.append(chD.pos.getLatMin(CWPoint.DMM));
+		sb.append(&quot;,&quot;);
+		sb.append(&quot;N,&quot;);
+		sb.append(chD.pos.getLonDeg(CWPoint.DMM));
+		sb.append(chD.pos.getLonMin(CWPoint.DMM));
+		sb.append(&quot;,&quot;);
+		sb.append(&quot;E,&quot;);
+		sb.append(&quot;0000,&quot;); // Height
+		sb.append(&quot;M,&quot;); // in meter
+		sb.append(chD.wayPoint);
+		sb.append(&quot;,&quot;);
+		String add = &quot;&quot;;
+		if (chD.isAddiWpt()) {
+			if (chD.type==50) {
+				add = &quot;Pa:&quot;;
+			} else if (chD.type==51) {
+				add = &quot;St:&quot;;
+			} else if (chD.type==52) {
+				add = &quot;Qu:&quot;; 
+			} else if (chD.type==53) {	
+				add = &quot;Fi:&quot;;
+			} else if (chD.type==54) {
+				add = &quot;Tr:&quot;;
+			} else if (chD.type==55) {	
+				add = &quot;Re:&quot;;
+			}
+			sb.append(add).append(removeCommas(chD.cacheName));
+		} else {
+			sb.append(removeCommas(chD.cacheName));
+		}		
+		sb.append(&quot;,&quot;);
+		sb.append(removeCommas(chD.cacheOwner));
+		sb.append(&quot;,&quot;);
+		sb.append(removeCommas(Common.rot13(chD.hints)));
+		sb.append(&quot;,&quot;);
+		
+		if (!add.equals(&quot;&quot;)) { // Set Picture in Explorist to Virtual
+			sb.append(&quot;Virtual Cache&quot;);
+		} else if (!(chD.type==8)) { // Rewrite Unknown Caches
+			sb.append(CacheType.transType(chD.type));
+		} else {
+			sb.append(&quot;Mystery Cache&quot;);
+		}
+		sb.append(&quot;,&quot;);
+		sb.append(toGsDateFormat(chD.dateHidden));  // created - DDMMYYY, YYY = year - 1900
+		sb.append(&quot;,&quot;);
+		String lastFound = &quot;0000&quot;;
+		for (int i = 0; i &lt; chD.cacheLogs.size(); i++) {
+			if (chD.cacheLogs.getLog(i).isFoundLog() &amp;&amp; chD.cacheLogs.getLog(i).getDate().compareTo(lastFound) &gt; 0 ) {
+				lastFound = chD.cacheLogs.getLog(i).getDate();
+			}
+		}
+		
+		sb.append(toGsDateFormat(lastFound)); // lastFound - DDMMYYY, YYY = year - 1900
+		sb.append(&quot;,&quot;);
+		sb.append(removeCommas(chD.hard));
+		sb.append(&quot;,&quot;);
+		sb.append(removeCommas(chD.terrain));
+		sb.append(&quot;*41&quot;);
+		return Exporter.simplifyString(sb.toString() + &quot;\r\n&quot;);
+	}
+
+	/**
+	 * this method can be overided by an exporter class
+	 * 
+	 * @return formated trailer data
+	 */
+	public String trailer() {
+		return &quot;$PMGNCMD,END*3D\n&quot;;
+	}
+	
+	/**
+	 * Changes &quot;,&quot; in &quot;.&quot; in the input String
+	 * @param input
+	 * @return changed String
+	 */
+	private String removeCommas(String input) {
+		return input.replace(',', '.');
+	}
+	
+	/**
+	 * change the Dateformat from &quot;yyyy-mm-dd&quot; to ddmmyyy, where yyy is years after 1900 
+	 * @param input Date in yyyy-mm-dd
+ 	 * @return Date in ddmmyyy
+	 */
+	private String toGsDateFormat(String input) {
+		if (input.length() &gt;= 10) {
+			return input.substring(8, 10) + input.substring(5, 7) + &quot;1&quot; + input.substring(2, 4);
+		} 
+		return &quot;&quot;;
+	}
+	
+}
\ No newline at end of file

Added: experiments/EVE/src/cachewolf/exp/Exporter.java
===================================================================
--- experiments/EVE/src/cachewolf/exp/Exporter.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/exp/Exporter.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,413 @@
+package cachewolf.exp;
+
+import eve.sys.*;
+import eve.ui.filechooser.FileChooser;
+import java.io.*;
+import eve.ui.ProgressBarForm;
+import java.util.*;
+import java.io.IOException;
+
+import cachewolf.*;
+
+
+/**
+ * @author Kalle
+ * Base class for exporter, handles basic things like selecting
+ * outputfile, display a counter etc.
+ * A new Exporter must only override the header(), record() and 
+ * trailer() methods. The member howManyParams must be set to identify
+ * which ethod should be called  
+ */
+
+public class Exporter {
+	// starts with no ui for file selection
+	final static int TMP_FILE = 0;
+	// brings up a screen to select a file
+	final static int ASK_FILE = 1;
+	
+	// selection, which method should be called
+	final static int NO_PARAMS 	= 0;
+	final static int LAT_LON 	= 1;
+	final static int COUNT 		= 2;
+	
+	Vector cacheDB;
+	Preferences pref;
+	Profile profile;
+	// mask in file chooser
+	String mask = &quot;*.*&quot;;
+	// file name, if no file chooser is used
+	String tmpFileName;
+	// decimal separator for lat- and lon-String
+	char decimalSeparator='.';
+	// if  true, the complete cache details are read
+	// before a call to the record method is made 
+	boolean needCacheDetails = false;
+	// selection, which method should be called
+	int howManyParams = 0;
+	
+	//name of exporter for saving pathname
+	String expName;
+	
+	public Exporter() {
+		profile = Global.getProfile();
+		pref = Global.getPref();
+		cacheDB = profile.cacheDB;
+		howManyParams = LAT_LON;
+		expName = this.getClass().getName(); 
+		// remove package
+		expName = expName.substring(expName.indexOf(&quot;.&quot;) + 1);
+	}
+	
+	public void doIt(){
+		this.doIt(ASK_FILE);
+	}
+
+	/**
+	 * Does the most work for exporting data
+	 * @param variant 0, if no filechooser
+	 *                1, if filechooser
+	 */
+	public void doIt(int variant){
+		String outFile;
+		String str;
+		CacheHolder ch;
+		CacheHolderDetail chD;
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+
+
+		if (variant == ASK_FILE) {
+			outFile = getOutputFile();
+			if (outFile == null) return;
+		} else {
+			outFile = tmpFileName;
+		}
+
+		pbf.showMainTask = false;
+		pbf.setTask(h,&quot;Exporting ...&quot;);
+		pbf.exec();
+
+		int counter = 0;
+		int expCount = 0;
+		for(int i = 0; i&lt;cacheDB.size();i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			if(ch.is_black == false &amp;&amp; ch.is_filtered == false) counter++;
+		}
+
+		try{
+			PrintWriter outp =  new PrintWriter(new FileOutputStream(outFile));
+			str = this.header();
+			if (str != null) outp.print(str);
+			chD=new CacheHolderDetail();
+			for(int i = 0; i&lt;cacheDB.size(); i++){
+				ch=(CacheHolder)cacheDB.get(i);
+				if(ch.is_black == false &amp;&amp; ch.is_filtered == false){
+					expCount++;
+					h.progress = (float)expCount/(float)counter;
+					h.changed();
+					if (needCacheDetails) chD = ch.getCacheDetails(false, false);
+					else chD.update(ch);
+					if (needCacheDetails &amp;&amp; chD == null) continue;
+					switch (this.howManyParams) {
+					case NO_PARAMS:
+						str = record(chD);
+						break;
+					case LAT_LON:
+						if (chD.pos.isValid() == false) continue;
+						str = record(chD, chD.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+								     chD.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+						break;
+					case LAT_LON|COUNT: 
+						if (chD.pos.isValid() == false) continue;
+						str = record(chD, chD.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+									 chD.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+											 i);
+						break;
+					default:
+						str = null;
+						break;
+					}
+					if (str != null) outp.print(str);
+				}//if
+			}//for
+			switch (this.howManyParams &amp; COUNT) {
+			case NO_PARAMS: 
+				str = trailer();
+				break;
+			case COUNT:
+				str = trailer(counter);
+				break;
+			default:
+				str = null;
+				break;
+			}
+			if (str != null) outp.print(str);
+			outp.close();
+			pbf.exit(0);
+		} catch (IOException ioE){
+			Vm.debug(&quot;Error opening &quot; + outFile);
+		}
+		//try
+	}
+	/**
+	 * sets mask for filechooser
+	 * @param mask 
+	 */
+	public void setMask(String mask){
+		this.mask = mask;
+	}
+	/**
+	 * sets decimal separator for lat/lon-string
+	 * @param sep
+	 */
+	public void setDecimalSeparator (char sep){
+		this.decimalSeparator = sep;
+	}
+	/**
+	 *  sets needCacheDetails
+	 * @param how
+	 */
+	public void setNeedCacheDetails(boolean how){
+		this.needCacheDetails = how;
+	}
+	
+	/**
+	 * sets howManyParams
+	 * @param paramBits
+	 */
+	public void setHowManyParams(int paramBits){
+		this.howManyParams = paramBits;
+	}
+	/**
+	 * sets tmpFileName
+	 * @param fName
+	 */
+	public void setTmpFileName(String fName){
+		this.tmpFileName = fName;
+	}
+
+	/**
+	 * uses a filechooser to get the name of the export file
+	 * @return
+	 */
+	public String getOutputFile (){
+		String file;
+		FileChooser fc = new FileChooser(FileChooser.SAVE, pref.getExportPath(expName));
+		fc.title=(&quot;Select target file:&quot;);
+		fc.addMask(mask);
+		if(fc.execute() != FileChooser.IDCANCEL){
+			file = fc.getChosen();
+			pref.setExportPath(expName, file);
+			return file;
+		} 
+		return null;
+	}
+	/**
+	 * this method can be overided by an exporter class
+	 * @return formated header data
+	 */	
+	public String header () {
+		return null;
+	}
+
+	/**
+	 * this method can be overided by an exporter class
+	 * @param ch	cachedata
+	 * @return formated cache data
+	 */	
+	public String record(CacheHolderDetail chD){
+		return null;
+	}
+
+	/**
+	 * this method can be overided by an exporter class
+	 * @param ch	cachedata
+	 * @param lat	
+	 * @param lon
+	 * @return formated cache data
+	 */
+	public String record(CacheHolderDetail ch, String lat, String lon){
+		return null;
+	}
+	/**
+	 * this method can be overided by an exporter class
+	 * @param ch	cachedata
+	 * @param lat	
+	 * @param lon
+	 * @param count of actual record
+	 * @return formated cache data
+	 */
+	public String record(CacheHolderDetail ch, String lat, String lon, int count){
+		return null;
+	}
+	
+	/**
+	 * this method can be overided by an exporter class
+	 * @return formated trailer data
+	 */	
+	public String trailer(){
+		return null;
+	}
+	/**
+	 * this method can be overided by an exporter class
+	 * @param total count of exported caches
+	 * @return
+	 */
+	public String trailer(int total){
+		return null;
+	}
+
+///////////////////////////////////////////////////
+//  Helper functions for string sanitisation
+///////////////////////////////////////////////////
+	
+	private static Hashtable iso2simpleMappings = new Hashtable(250);
+	static {
+		String[] mappingArray = new String[] {
+				&quot;34&quot;,  &quot;'&quot;,
+				&quot;160&quot;, &quot; &quot;,
+				&quot;161&quot;, &quot;i&quot;,
+				&quot;162&quot;, &quot;c&quot;,
+				&quot;163&quot;, &quot;$&quot;,
+				&quot;164&quot;, &quot;o&quot;,
+				&quot;165&quot;, &quot;$&quot;,
+				&quot;166&quot;, &quot;!&quot;,
+				&quot;167&quot;, &quot;$&quot;,
+				&quot;168&quot;, &quot; &quot;,
+				&quot;169&quot;, &quot; &quot;,
+				&quot;170&quot;, &quot; &quot;,
+				&quot;171&quot;, &quot;&lt;&quot;,
+				&quot;172&quot;, &quot; &quot;,
+				&quot;173&quot;, &quot;-&quot;,
+				&quot;174&quot;, &quot; &quot;,
+				&quot;175&quot;, &quot;-&quot;,
+				&quot;176&quot;, &quot; &quot;,
+				&quot;177&quot;, &quot;+/-&quot;,
+				&quot;178&quot;, &quot;2&quot;,
+				&quot;179&quot;, &quot;3&quot;,
+				&quot;180&quot;, &quot;'&quot;,
+				&quot;181&quot;, &quot; &quot;,
+				&quot;182&quot;, &quot; &quot;,
+				&quot;183&quot;, &quot; &quot;,
+				&quot;184&quot;, &quot;,&quot;,
+				&quot;185&quot;, &quot;1&quot;,
+				&quot;186&quot;, &quot; &quot;,
+				&quot;187&quot;, &quot;&gt;&quot;,
+				&quot;188&quot;, &quot;1/4&quot;,
+				&quot;189&quot;, &quot;1/2&quot;,
+				&quot;190&quot;, &quot;3/4&quot;,
+				&quot;191&quot;, &quot;?&quot;,
+				&quot;192&quot;, &quot;A&quot;,
+				&quot;193&quot;, &quot;A&quot;,
+				&quot;194&quot;, &quot;A&quot;,
+				&quot;195&quot;, &quot;A&quot;,
+				&quot;196&quot;, &quot;Ae&quot;,
+				&quot;197&quot;, &quot;A&quot;,
+				&quot;198&quot;, &quot;AE&quot;,
+				&quot;199&quot;, &quot;C&quot;,
+				&quot;200&quot;, &quot;E&quot;,
+				&quot;201&quot;, &quot;E&quot;,
+				&quot;202&quot;, &quot;E&quot;,
+				&quot;203&quot;, &quot;E&quot;,
+				&quot;204&quot;, &quot;I&quot;,
+				&quot;205&quot;, &quot;I&quot;,
+				&quot;206&quot;, &quot;I&quot;,
+				&quot;207&quot;, &quot;I&quot;,
+				&quot;208&quot;, &quot;D&quot;,
+				&quot;209&quot;, &quot;N&quot;,
+				&quot;210&quot;, &quot;O&quot;,
+				&quot;211&quot;, &quot;O&quot;,
+				&quot;212&quot;, &quot;O&quot;,
+				&quot;213&quot;, &quot;O&quot;,
+				&quot;214&quot;, &quot;Oe&quot;,
+				&quot;215&quot;, &quot;x&quot;,
+				&quot;216&quot;, &quot;O&quot;,
+				&quot;217&quot;, &quot;U&quot;,
+				&quot;218&quot;, &quot;U&quot;,
+				&quot;219&quot;, &quot;U&quot;,
+				&quot;220&quot;, &quot;Ue&quot;,
+				&quot;221&quot;, &quot;Y&quot;,
+				&quot;222&quot;, &quot; &quot;,
+				&quot;223&quot;, &quot;ss&quot;,
+				&quot;224&quot;, &quot;a&quot;,
+				&quot;225&quot;, &quot;a&quot;,
+				&quot;226&quot;, &quot;a&quot;,
+				&quot;227&quot;, &quot;a&quot;,
+				&quot;228&quot;, &quot;ae&quot;,
+				&quot;229&quot;, &quot;a&quot;,
+				&quot;230&quot;, &quot;ae&quot;,
+				&quot;231&quot;, &quot;c&quot;,
+				&quot;232&quot;, &quot;e&quot;,
+				&quot;233&quot;, &quot;e&quot;,
+				&quot;234&quot;, &quot;e&quot;,
+				&quot;235&quot;, &quot;e&quot;,
+				&quot;236&quot;, &quot;i&quot;,
+				&quot;237&quot;, &quot;i&quot;,
+				&quot;238&quot;, &quot;i&quot;,
+				&quot;239&quot;, &quot;i&quot;,
+				&quot;240&quot;, &quot;o&quot;,
+				&quot;241&quot;, &quot;n&quot;,
+				&quot;242&quot;, &quot;o&quot;,
+				&quot;243&quot;, &quot;o&quot;,
+				&quot;244&quot;, &quot;o&quot;,
+				&quot;245&quot;, &quot;o&quot;,
+				&quot;246&quot;, &quot;oe&quot;,
+				&quot;247&quot;, &quot;/&quot;,
+				&quot;248&quot;, &quot;o&quot;,
+				&quot;249&quot;, &quot;u&quot;,
+				&quot;250&quot;, &quot;u&quot;,
+				&quot;251&quot;, &quot;u&quot;,
+				&quot;252&quot;, &quot;ue&quot;,
+				&quot;253&quot;, &quot;y&quot;,
+				&quot;254&quot;, &quot;p&quot;,
+				&quot;255&quot;, &quot;y&quot;
+		};
+		for (int i = 0; i &lt; mappingArray.length; i = i + 2) {
+			iso2simpleMappings.put( Integer.valueOf( mappingArray[i]), mappingArray[i+1]);
+		}
+	}
+
+	
+	protected static String char2simpleChar( char c )
+    {
+        if ( c &lt; 127 ) {
+            // leave alone as equivalent string.
+            return null;
+        } 
+        String s=(String) iso2simpleMappings.get( new Integer(c));
+        if (s==null) // not in table, replace with empty string just to be sure
+        	return &quot;&quot;;
+        return s;
+    } // end charToEntity
+	
+    public static String simplifyString( String text ) {
+        if ( text == null ) return null;
+        int originalTextLength = text.length();
+        StringBuffer sb = new StringBuffer( 50 );
+        int charsToAppend = 0;
+        for ( int i = 0; i &lt; originalTextLength; i++ ) {
+            char c = text.charAt( i );
+            String entity = char2simpleChar( c );
+            if ( entity == null ) {
+                // we could sb.append( c ), but that would be slower
+                // than saving them up for a big append.
+                charsToAppend++;
+            } else {
+                if ( charsToAppend != 0 ) {
+                    sb.append( text.substring( i - charsToAppend, i ) );
+                    charsToAppend = 0;
+                }
+                sb.append( entity );
+            }
+        } // end for
+        // append chars to the right of the last entity.
+        if ( charsToAppend != 0 ) {
+            sb.append( text.substring( originalTextLength - charsToAppend,
+                                       originalTextLength ) );
+        }
+        // if result is not longer, we did not do anything. Save RAM.
+        return ( sb.length() == originalTextLength ) ? text : sb.toString();
+    } // end insertEntities
+
+
+}

Added: experiments/EVE/src/cachewolf/exp/GPXExporter.java
===================================================================
--- experiments/EVE/src/cachewolf/exp/GPXExporter.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/exp/GPXExporter.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,104 @@
+package cachewolf.exp;
+import cachewolf.*;
+import cachewolf.utils.Common;
+import cachewolf.utils.SafeXML;
+import eve.sys.*;
+import eve.io.File;
+/**
+*	Class to export the cache database to a GPX file with gc.com
+*	extensions.&lt;br&gt;
+*	Export of logs is not that nice. The cause is that CacheWolf does not spider
+*	logs individually, rather all logs as a single entity.
+*	ClassID = 2000
+*/
+public class GPXExporter extends Exporter{
+	
+	private final static String STRING_TRUE = &quot;True&quot;;
+	private final static String STRING_FALSE = &quot;False&quot;;
+	private final static String DEFAULT_DATE = &quot;2000-01-01&quot;;
+	
+	public GPXExporter(){
+		super();
+		this.setMask(&quot;*.gpx&quot;);
+		this.setNeedCacheDetails(true);
+		this.setHowManyParams(LAT_LON);
+		this.setTmpFileName(File.getProgramDirectory() + &quot;/temp.gpx&quot;);
+	}
+	
+	public GPXExporter(Preferences p, Profile prof){
+		super();
+		this.setMask(&quot;*.gpx&quot;);
+		this.setNeedCacheDetails(true);
+		this.setHowManyParams(LAT_LON);
+		this.setTmpFileName(File.getProgramDirectory() + &quot;/temp.gpx&quot;);
+	}
+	
+	public String header() {
+		StringBuffer strBuf = new StringBuffer(200);
+		Time tim = new Time();
+		
+		strBuf.append(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;\r\n&quot;);
+		strBuf.append(&quot;&lt;gpx xmlns:xsd=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema\">http://www.w3.org/2001/XMLSchema\</A>&quot; xmlns:xsi=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance\">http://www.w3.org/2001/XMLSchema-instance\</A>&quot; version=\&quot;1.0\&quot; creator=\&quot;Groundspeak Pocket Query\&quot; xsi:schemaLocation=\&quot;<A HREF="http://www.topografix.com/GPX/1/0">http://www.topografix.com/GPX/1/0</A> <A HREF="http://www.topografix.com/GPX/1/0/gpx.xsd">http://www.topografix.com/GPX/1/0/gpx.xsd</A> <A HREF="http://www.groundspeak.com/cache/1/0">http://www.groundspeak.com/cache/1/0</A> <A HREF="http://www.groundspeak.com/cache/1/0/cache.xsd\">http://www.groundspeak.com/cache/1/0/cache.xsd\</A>&quot; xmlns=\&quot;<A HREF="http://www.topografix.com/GPX/1/0\">http://www.topografix.com/GPX/1/0\</A>&quot;&gt;\r\n&quot;);
+		strBuf.append(&quot;  &lt;desc&gt;Geocache file generated by CacheWolf&lt;/desc&gt;\r\n&quot;);
+		strBuf.append(&quot;  &lt;author&gt;CacheWolf&lt;/author&gt;\r\n&quot;);
+		strBuf.append(&quot;  &lt;email&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">test at test.com</A>&lt;/email&gt;\r\n&quot;);
+		tim = tim.setFormat(&quot;yyyy-MM-dd&quot;);
+		tim = tim.setToCurrentTime();
+		strBuf.append(&quot; &lt;time&gt;&quot;+tim.toString()+&quot;T00:00:00.0000000-07:00&lt;/time&gt;\r\n&quot;);
+
+		return strBuf.toString();
+	}
+	
+	public String record(CacheHolderDetail ch, String lat, String lon) {
+		StringBuffer strBuf = new StringBuffer(1000);
+
+		try{
+			strBuf.append(&quot;  &lt;wpt lat=\&quot;&quot;+lat+&quot;\&quot; lon=\&quot;&quot;+lon+&quot;\&quot;&gt;\r\n&quot;);
+		
+			String tim = ch.dateHidden.length()&gt;0 ? ch.dateHidden : DEFAULT_DATE;
+			strBuf.append(&quot;    &lt;time&gt;&quot;).append(tim).append(&quot;T00:00:00.0000000-07:00&lt;/time&gt;\r\n&quot;);
+			strBuf.append(&quot;    &lt;name&gt;&quot;).append(ch.wayPoint).append(&quot;&lt;/name&gt;\r\n&quot;);
+			strBuf.append(&quot;    &lt;desc&gt;&quot;).append(SafeXML.cleanGPX(ch.cacheName)).append(&quot; by &quot;).append(SafeXML.cleanGPX(ch.cacheOwner)).append(&quot;&lt;/desc&gt;\r\n&quot;);
+			strBuf.append(&quot;    &lt;url&gt;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot;).append(ch.wayPoint).append(&quot;&amp;Submit6=Find&lt;/url&gt;\r\n&quot;);
+			strBuf.append(&quot;    &lt;urlname&gt;&quot;).append(SafeXML.cleanGPX(ch.cacheName)).append(&quot; by &quot;).append(SafeXML.cleanGPX(ch.cacheOwner)).append(&quot;&lt;/urlname&gt;\r\n&quot;);
+			if (!ch.isAddiWpt()){
+				strBuf.append(&quot;    &lt;sym&gt;Geocache&lt;/sym&gt;\r\n&quot;);
+				strBuf.append(&quot;    &lt;type&gt;Geocache|&quot;).append(CacheType.transType(ch.type)).append(&quot;&lt;/type&gt;\r\n&quot;);
+				String dummyAvailable = ch.is_available ? STRING_TRUE:STRING_FALSE;
+				String dummyArchived = ch.is_archived ? STRING_TRUE:STRING_FALSE;
+				strBuf.append(&quot;    &lt;groundspeak:cache available=\&quot;&quot;).append( dummyAvailable ).append( &quot;\&quot; archived=\&quot;&quot; ).append( dummyArchived).append( &quot;\&quot; xmlns:groundspeak=\&quot;<A HREF="http://www.groundspeak.com/cache/1/0\">http://www.groundspeak.com/cache/1/0\</A>&quot;&gt;\r\n&quot;);
+				strBuf.append(&quot;      &lt;groundspeak:name&gt;&quot;).append(SafeXML.cleanGPX(ch.cacheName)).append(&quot;&lt;/groundspeak:name&gt;\r\n&quot;);
+				strBuf.append(&quot;      &lt;groundspeak:placed_by&gt;&quot;).append(SafeXML.cleanGPX(ch.cacheOwner)).append(&quot;&lt;/groundspeak:placed_by&gt;\r\n&quot;);
+				strBuf.append(&quot;      &lt;groundspeak:owner&gt;&quot;).append(SafeXML.cleanGPX(ch.cacheOwner)+&quot;&lt;/groundspeak:owner&gt;\r\n&quot;);
+				strBuf.append(&quot;      &lt;groundspeak:type&gt;&quot;).append(CacheType.transType(ch.type)).append(&quot;&lt;/groundspeak:type&gt;\r\n&quot;);
+				strBuf.append(&quot;      &lt;groundspeak:container&gt;&quot;).append(ch.cacheSize).append(&quot;&lt;/groundspeak:container&gt;\r\n&quot;);
+				strBuf.append(&quot;      &lt;groundspeak:difficulty&gt;&quot;).append(ch.hard.replace(',','.')).append(&quot;&lt;/groundspeak:difficulty&gt;\r\n&quot;);
+				strBuf.append(&quot;      &lt;groundspeak:terrain&gt;&quot;).append(ch.terrain.replace(',','.')).append(&quot;&lt;/groundspeak:terrain&gt;\r\n&quot;);
+				String dummyHTML = ch.is_HTML ? STRING_TRUE:STRING_FALSE;
+				strBuf.append(&quot;      &lt;groundspeak:long_description html=\&quot;&quot; ).append( dummyHTML ).append( &quot;\&quot;&gt;\r\n&quot;);
+				strBuf.append(&quot;      &quot;).append(SafeXML.cleanGPX(ch.longDescription));
+				strBuf.append(&quot;      \n&lt;/groundspeak:long_description&gt;\r\n&quot;);
+				strBuf.append(&quot;	  &lt;groundspeak:encoded_hints&gt;&quot;).append(SafeXML.cleanGPX(Common.rot13(ch.hints))).append(&quot;&lt;/groundspeak:encoded_hints&gt;\r\n&quot;);
+				strBuf.append(&quot;      &lt;groundspeak:logs&gt;\r\n&quot;);
+				strBuf.append(&quot;      &lt;/groundspeak:logs&gt;\r\n&quot;);
+				strBuf.append(&quot;      &lt;groundspeak:travelbugs /&gt;\r\n&quot;);
+				strBuf.append(&quot;    &lt;/groundspeak:cache&gt;\r\n&quot;);
+			}else {
+				// there is no HTML in the description of addi wpts
+				strBuf.append(&quot;    &lt;cmt&gt;&quot;).append(SafeXML.cleanGPX(ch.longDescription)).append(&quot;&lt;/cmt&gt;\r\n&quot;);				strBuf.append(&quot;    &lt;sym&gt;&quot;).append(CacheType.transType(ch.type)).append(&quot;&lt;/sym&gt;\r\n&quot;);
+				strBuf.append(&quot;    &lt;type&gt;Waypoint|&quot;).append(CacheType.transType(ch.type)).append(&quot;&lt;/type&gt;\r\n&quot;);
+			}
+			strBuf.append(&quot;  &lt;/wpt&gt;\r\n&quot;);
+		}catch(Exception e){
+			e.printStackTrace();
+			return null;
+		}//try
+
+		return strBuf.toString();
+	}
+	
+	public String trailer() {
+		return &quot;&lt;/gpx&gt;&quot;;
+	}
+	
+}

Added: experiments/EVE/src/cachewolf/exp/HTMLExporter.java
===================================================================
--- experiments/EVE/src/cachewolf/exp/HTMLExporter.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/exp/HTMLExporter.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,470 @@
+package cachewolf.exp;
+import cachewolf.*;
+import cachewolf.utils.Common;
+import cachewolf.utils.STRreplace;
+
+import com.stevesoft.eve_pat.Regex;
+
+
+import java.util.*;
+import eve.sys.*;
+import eve.ui.*;
+import eve.ui.filechooser.*;
+import HTML.*;
+import java.io.*;
+
+
+/**
+*	Class to export cache information to individual HTML files.&lt;br&gt;
+*	It uses the HTML package to parse template files. This makes the export
+*	very flexible; enabling the user to customise the HTML files according
+*	to thier liking.
+*/
+public class HTMLExporter{
+//	TODO Exportanzahl anpassen: Bug: 7351
+	Vector cacheDB;
+	Preferences pref;
+	Profile profile;
+	String [] template_init_index = {
+	 		&quot;filename&quot;,  &quot;index.tpl&quot;,
+	 		&quot;case_sensitive&quot;, &quot;true&quot;,
+	 		&quot;max_includes&quot;,   &quot;5&quot;
+	 		//,&quot;debug&quot;, &quot;true&quot;
+	 	};
+	String [] template_init_page = {
+	 		&quot;filename&quot;,  &quot;page.tpl&quot;,
+	 		&quot;case_sensitive&quot;, &quot;true&quot;,
+	 		&quot;max_includes&quot;,   &quot;5&quot;
+	 	};
+	//public final static String expName = &quot;HTML&quot;;
+
+	public HTMLExporter(Preferences p, Profile prof){
+		pref = p;
+		profile=prof;
+		cacheDB = profile.cacheDB;
+	}
+	
+	public void doIt(){
+		CacheHolderDetail chD;
+		CacheHolder ch;
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+
+		//need directory only!!!!
+		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getProfile().htmlExportDirectory);
+		fc.title=(&quot;Select target directory:&quot;);
+		String targetDir;
+		if(fc.execute() != FileChooser.IDCANCEL){
+			targetDir = fc.getChosen() + &quot;/&quot;;
+			Global.getProfile().htmlExportDirectory=targetDir;
+			//pref.setExportPath(expName, targetDir);
+			Vector cache_index = new Vector();
+			Vector cacheImg = new Vector();
+			Vector logImg = new Vector();
+			Vector mapImg = new Vector();
+			Vector usrImg = new Vector();
+			Vector logIcons = new Vector(15);
+			String icon;
+
+			Hashtable varParams;
+			Hashtable imgParams;
+			Hashtable logImgParams;
+			Hashtable usrImgParams;
+			Hashtable mapImgParams;
+
+			//Generate index page
+			int counter = 0;
+			for(int i = 0; i&lt;cacheDB.size();i++){
+				ch = (CacheHolder)cacheDB.get(i);
+				if(ch.is_black == false &amp;&amp; ch.is_filtered == false) counter++;
+			}
+			
+			pbf.showMainTask = false;
+			pbf.setTask(h,&quot;Exporting ...&quot;);
+			pbf.exec();
+
+			for(int i = 0; i&lt;counter;i++){
+				h.progress = (float)(i+1)/(float)counter;
+				h.changed();
+
+				ch = (CacheHolder)cacheDB.get(i);
+				if(ch.is_black == false &amp;&amp; ch.is_filtered == false){
+					chD=ch.getCacheDetails(false,true);
+					varParams = new Hashtable();
+					varParams.put(&quot;TYPE&quot;, CacheType.transType(chD.type));
+					varParams.put(&quot;SIZE&quot;, chD.cacheSize);
+					varParams.put(&quot;WAYPOINT&quot;, chD.wayPoint);
+					varParams.put(&quot;NAME&quot;, chD.cacheName);
+					varParams.put(&quot;OWNER&quot;, chD.cacheOwner);
+					varParams.put(&quot;DIFFICULTY&quot;, chD.hard);
+					varParams.put(&quot;TERRAIN&quot;, chD.terrain);
+					varParams.put(&quot;DISTANCE&quot;, chD.distance);
+					varParams.put(&quot;BEARING&quot;, chD.bearing);
+					varParams.put(&quot;LATLON&quot;, chD.latLon);
+					varParams.put(&quot;STATUS&quot;, chD.cacheStatus);
+					varParams.put(&quot;DATE&quot;, chD.dateHidden);
+					cache_index.add(varParams);
+					//We can generate the individual page here!
+					try{
+						Template page_tpl = new Template(template_init_page);
+						page_tpl.setParam(&quot;TYPE&quot;, CacheType.transType(chD.type));
+						page_tpl.setParam(&quot;SIZE&quot;, chD.cacheSize);
+						page_tpl.setParam(&quot;WAYPOINT&quot;, chD.wayPoint);
+						page_tpl.setParam(&quot;NAME&quot;, chD.cacheName);
+						page_tpl.setParam(&quot;OWNER&quot;, chD.cacheOwner);
+						page_tpl.setParam(&quot;DIFFICULTY&quot;, chD.hard);
+						page_tpl.setParam(&quot;TERRAIN&quot;, chD.terrain);
+						page_tpl.setParam(&quot;DISTANCE&quot;, chD.distance);
+						page_tpl.setParam(&quot;BEARING&quot;, chD.bearing);
+						page_tpl.setParam(&quot;LATLON&quot;, chD.latLon);
+						page_tpl.setParam(&quot;STATUS&quot;, chD.cacheStatus);
+						page_tpl.setParam(&quot;DATE&quot;, chD.dateHidden);
+						if (chD.is_HTML)
+							page_tpl.setParam(&quot;DESCRIPTION&quot;, modifyLongDesc(chD,targetDir));
+						else {
+							String dummyText;
+							dummyText = STRreplace.replace(chD.longDescription, &quot;\n&quot;, &quot;&lt;br&gt;&quot;);
+							page_tpl.setParam(&quot;DESCRIPTION&quot;,dummyText);
+							
+						}
+						page_tpl.setParam(&quot;HINTS&quot;, chD.hints);
+						page_tpl.setParam(&quot;DECRYPTEDHINTS&quot;, Common.rot13(chD.hints));
+						StringBuffer sb=new StringBuffer(2000);
+						for(int j = 0; j&lt;chD.cacheLogs.size(); j++){
+							sb.append(STRreplace.replace(chD.cacheLogs.getLog(j).toHtml(),&quot;<A HREF="http://www.geocaching.com/images/icons/">http://www.geocaching.com/images/icons/</A>&quot;,null));
+							sb.append(&quot;&lt;br&gt;&quot;);
+							icon=chD.cacheLogs.getLog(j).getIcon();
+							if (logIcons.indexOf(icon)&lt;0) logIcons.add(icon); // Add the icon to list of icons to copy to dest directory
+						}
+						page_tpl.setParam(&quot;LOGS&quot;, sb.toString());
+						page_tpl.setParam(&quot;NOTES&quot;, STRreplace.replace(chD.cacheNotes, &quot;\n&quot;,&quot;&lt;br&gt;&quot;)); 
+						// Cache Images
+						cacheImg.clear();
+						for(int j = 0; j&lt;chD.images.size(); j++){
+							imgParams = new Hashtable();
+							String imgFile = (String)chD.images.get(j);
+							imgParams.put(&quot;FILE&quot;, imgFile);
+							if (j &lt; chD.imagesText.size())
+								imgParams.put(&quot;TEXT&quot;,chD.imagesText.get(j));
+							else
+								imgParams.put(&quot;TEXT&quot;,imgFile);
+							DataMover.copy(profile.dataDir + imgFile,targetDir + imgFile);
+							cacheImg.add(imgParams);
+						}
+						page_tpl.setParam(&quot;cacheImg&quot;, cacheImg);
+						// Log images
+						logImg.clear();
+						for(int j = 0; j&lt;chD.logImages.size(); j++){
+							logImgParams = new Hashtable();
+							String logImgFile = (String) chD.logImages.get(j);
+							logImgParams.put(&quot;FILE&quot;, logImgFile);
+							if (j &lt; chD.logImagesText.size())
+								logImgParams.put(&quot;TEXT&quot;,chD.logImagesText.get(j));
+							else
+								logImgParams.put(&quot;TEXT&quot;,logImgFile);
+							DataMover.copy(profile.dataDir + logImgFile,targetDir + logImgFile);
+							logImg.add(logImgParams);
+						}
+						page_tpl.setParam(&quot;logImg&quot;, logImg);
+						// User images
+						usrImg.clear();
+						for(int j = 0; j&lt;chD.userImages.size(); j++){
+							usrImgParams = new Hashtable();
+							String usrImgFile = (String)chD.userImages.get(j);
+							usrImgParams.put(&quot;FILE&quot;, usrImgFile);
+							if (j &lt; chD.userImagesText.size())
+								usrImgParams.put(&quot;TEXT&quot;,chD.userImagesText.get(j));
+							else
+								usrImgParams.put(&quot;TEXT&quot;,usrImgFile);
+							DataMover.copy(profile.dataDir + usrImgFile,targetDir + usrImgFile);
+							usrImg.add(usrImgParams);
+						}
+						page_tpl.setParam(&quot;userImg&quot;, usrImg);
+
+						// Map images
+						mapImg.clear();
+						mapImgParams = new Hashtable();
+						String mapImgFile = chD.wayPoint + &quot;_map.gif&quot;;
+						// check if map file exists
+						java.io.File test = new java.io.File(profile.dataDir + mapImgFile);
+						if (test.exists()) {
+							mapImgParams.put(&quot;FILE&quot;, mapImgFile);
+							mapImgParams.put(&quot;TEXT&quot;,mapImgFile);
+							DataMover.copy(profile.dataDir + mapImgFile,targetDir + mapImgFile);
+							mapImg.add(mapImgParams);
+							
+							mapImgParams = new Hashtable();
+							mapImgFile = chD.wayPoint + &quot;_map_2.gif&quot;;
+							mapImgParams.put(&quot;FILE&quot;, mapImgFile);
+							mapImgParams.put(&quot;TEXT&quot;,mapImgFile);
+							DataMover.copy(profile.dataDir + mapImgFile,targetDir + mapImgFile);
+							mapImg.add(mapImgParams);
+	
+							page_tpl.setParam(&quot;mapImg&quot;, mapImg);
+						}
+
+						
+						PrintWriter pagefile = new PrintWriter(new BufferedWriter(new FileWriter(targetDir + chD.wayPoint+&quot;.html&quot;)));
+						pagefile.print(page_tpl.output());
+						pagefile.close();
+					}catch(Exception e){
+						Vm.debug(&quot;Problem writing waypoint html file&quot;);
+					}
+				}//if is black, filtered
+			}
+			// Copy the log-icons to the destination directory
+			for (int j=0; j&lt;logIcons.size(); j++) {
+				icon=(String) logIcons.elementAt(j);
+				DataMover.copy(eve.io.File.getProgramDirectory() + &quot;/&quot;+icon,targetDir + icon);
+				
+			}
+			DataMover.copy(eve.io.File.getProgramDirectory() + &quot;/recommendedlog.gif&quot;,targetDir + &quot;recommendedlog.gif&quot;);
+			try{
+				Template tpl = new Template(template_init_index);
+				tpl.setParam(&quot;cache_index&quot;, cache_index);
+				PrintWriter detfile; 
+				detfile = new PrintWriter(new BufferedWriter(new FileWriter(targetDir + &quot;/index.html&quot;)));
+				detfile.print(tpl.output());
+				detfile.close();
+				// sort by waypoint
+				sortAndPrintIndex(tpl, cache_index,targetDir + &quot;/index_wp.html&quot;, &quot;WAYPOINT&quot;);
+				// sort by name
+				sortAndPrintIndex(tpl, cache_index,targetDir + &quot;/index_alpha.html&quot;, &quot;NAME&quot;, false);
+				// sort by type
+				sortAndPrintIndex(tpl, cache_index,targetDir + &quot;/index_type.html&quot;, &quot;TYPE&quot;, true);
+				// sort by size
+				sortAndPrintIndex(tpl, cache_index,targetDir + &quot;/index_size.html&quot;, &quot;SIZE&quot;, true);
+				// sort by distance
+				sortAndPrintIndex(tpl, cache_index,targetDir + &quot;/index_dist.html&quot;, &quot;DISTANCE&quot;, 10.0);
+			}catch(Exception e){
+				Vm.debug(&quot;Problem writing HTML files\n&quot;);
+				e.printStackTrace();
+			}//try
+			
+		}//if
+		pbf.exit(0);
+	}
+	
+	/**
+	 * Modify the image links in the long description so that they point to image files in the local directory
+	 * Also copy the image file to the target directory so that it can be displayed.
+	 * @param chD CacheHolderDetail
+	 * @return The modified long description
+	 */
+	private String modifyLongDesc(CacheHolderDetail chD, String targetDir) {
+		StringBuffer s=new StringBuffer(chD.longDescription.length());
+		int start=0;
+		int pos;
+		int imageNo=0;
+		Regex imgRex = new Regex(&quot;src=(?:\\s*[^\&quot;|']*?)(?:\&quot;|')(.*?)(?:\&quot;|')&quot;);
+		while (start&gt;=0 &amp;&amp; (pos=chD.longDescription.indexOf(&quot;&lt;img&quot;,start))&gt;0) {
+			s.append(chD.longDescription.substring(start,pos));
+			imgRex.searchFrom(chD.longDescription,pos);
+			String imgUrl=imgRex.stringMatched(1);
+			//Vm.debug(&quot;imgUrl &quot;+imgUrl);
+			if (imgUrl.lastIndexOf('.')&gt;0 &amp;&amp; imgUrl.toLowerCase().startsWith(&quot;http&quot;)) {
+				String imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).substring(0,4).trim();
+				// If we have an image which we stored when spidering, we can display it
+				if(!imgType.startsWith(&quot;.com&quot;) &amp;&amp; !imgType.startsWith(&quot;.php&quot;) &amp;&amp; !imgType.startsWith(&quot;.exe&quot;)){
+					s.append(&quot;&lt;img src=\&quot;&quot;+chD.images.get(imageNo)+&quot;\&quot;&gt;&quot;);
+					// The actual immages are copied elswhere
+					//DataMover.copy(profile.dataDir + chD.Images.get(imageNo),targetDir + chD.Images.get(imageNo));
+					imageNo++;
+				}
+			}
+			start=chD.longDescription.indexOf(&quot;&gt;&quot;,pos);
+			if (start&gt;=0) start++;
+			if (imageNo &gt;= chD.images.size())break;
+		}
+		if (start&gt;=0) s.append(chD.longDescription.substring(start));
+		return s.toString();
+	}
+	
+	private void sortAndPrintIndex(Template tmpl, Vector list, String file, String field){
+		PrintWriter detfile; 
+		
+		eve.util.Utils.sort(new Handle(),list, new HTMLComparer(field), false);
+		try {
+			detfile = new PrintWriter(new BufferedWriter(new FileWriter(file)));
+			detfile.print(tmpl.output());
+			detfile.close();
+		} catch (IOException e) {
+			Vm.debug(&quot;Problem writing HTML files\n&quot;);
+			e.printStackTrace();
+		}
+	}
+
+	
+	private void sortAndPrintIndex(Template tmpl, Vector list, String file, String field, boolean fullCompare){
+		Vector navi_index;
+		PrintWriter detfile; 
+		
+		eve.util.Utils.sort(new Handle(), list,new HTMLComparer(field),false);
+		navi_index = addAnchorString(list,field, fullCompare);
+		if (navi_index != null){
+			tmpl.setParam(&quot;navi_index&quot;,navi_index);
+		}
+		try {
+			detfile = new PrintWriter(new BufferedWriter(new FileWriter(file)));
+			detfile.print(tmpl.output());
+			detfile.close();
+		} catch (IOException e) {
+			Vm.debug(&quot;Problem writing HTML files\n&quot;);
+			e.printStackTrace();
+		}
+	}
+	
+	private void sortAndPrintIndex(Template tmpl, Vector list, String file, String field, double diff){
+		Vector navi_index;
+		PrintWriter detfile; 
+		
+		eve.util.Utils.sort(new Handle(), list,new HTMLComparer(field),false);
+		navi_index = addAnchorString(list,field, diff);
+		if (navi_index != null){
+			tmpl.setParam(&quot;navi_index&quot;,navi_index);
+		}
+		try {
+			detfile = new PrintWriter(new BufferedWriter(new FileWriter(file)));
+			detfile.print(tmpl.output());
+			detfile.close();
+		} catch (IOException e) {
+			Vm.debug(&quot;Problem writing HTML files\n&quot;);
+			e.printStackTrace();
+		}
+		
+	}
+
+
+	private Vector addAnchorString(Vector list, String field, boolean fullCompare){
+		Vector topIndex = new Vector();
+		Hashtable topIndexParms, currEntry;
+		String lastValue, currValue;
+		
+		if (list.size() == 0) return null;
+		
+		currEntry = (Hashtable) list.get(0);
+		lastValue = (String) currEntry.get(field);
+		if (lastValue == null || lastValue.length() == 0) lastValue = &quot;  &quot;;
+		lastValue = lastValue.toUpperCase();
+		
+		for (int i=1; i&lt;list.size(); i++){
+			currEntry = (Hashtable) list.get(i);
+			currValue = (String) currEntry.get(field);
+			currValue = currValue.toUpperCase();
+
+			try {
+				if (fullCompare) {
+					if (currValue == null || currValue.equals(&quot;&quot;)) continue;
+					if (lastValue.compareTo(currValue)!= 0){
+						// Values for navigation line 
+						topIndexParms = new Hashtable();
+						topIndexParms.put(&quot;HREF&quot;, Convert.toString(i));
+						topIndexParms.put(&quot;TEXT&quot;, currValue);
+						topIndex.add(topIndexParms);
+						// add anchor entry to list
+						currEntry.put(&quot;ANCHORNAME&quot;, Convert.toString(i));
+						currEntry.put(&quot;ANCHORTEXT&quot;, currValue);
+					}
+					else {
+						// clear value from previous run
+						currEntry.put(&quot;ANCHORNAME&quot;, &quot;&quot;);
+						currEntry.put(&quot;ANCHORTEXT&quot;, &quot;&quot;);
+					}
+				}
+				else {
+					if (lastValue.charAt(0)!= currValue.charAt(0)){
+						// Values for navigation line 
+						topIndexParms = new Hashtable();
+						topIndexParms.put(&quot;HREF&quot;, Convert.toString(i));
+						topIndexParms.put(&quot;TEXT&quot;, currValue.charAt(0)+ &quot; &quot;);
+						topIndex.add(topIndexParms);
+						// add anchor entry to list
+						currEntry.put(&quot;ANCHORNAME&quot;, Convert.toString(i));
+						currEntry.put(&quot;ANCHORTEXT&quot;, currValue.charAt(0)+ &quot; &quot;);
+					}
+					else {
+						// clear value from previous run
+						currEntry.put(&quot;ANCHORNAME&quot;, &quot;&quot;);
+						currEntry.put(&quot;ANCHORTEXT&quot;, &quot;&quot;);
+					}
+				}
+				list.setElementAt(currEntry,i);
+				lastValue = currValue;
+			} catch (Exception e){
+				continue;
+			}
+		}
+		return topIndex;
+	}
+	private Vector addAnchorString(Vector list, String field, double diff){
+		Vector topIndex = new Vector();
+		Hashtable topIndexParms, currEntry;
+		double lastValue, currValue;
+		
+		if (list.size() == 0) return null;
+		
+		currEntry = (Hashtable) list.get(0);
+		lastValue = Common.parseDouble((String) currEntry.get(field)) + diff;
+		
+		for (int i=1; i&lt;list.size(); i++){
+			currEntry = (Hashtable) list.get(i);
+			currValue = Common.parseDouble((String) currEntry.get(field));
+			if (currValue &gt;= lastValue ){
+				// Values for navigation line 
+				topIndexParms = new Hashtable();
+				topIndexParms.put(&quot;HREF&quot;, Convert.toString(i));
+				topIndexParms.put(&quot;TEXT&quot;, Convert.toString(lastValue));
+				topIndex.add(topIndexParms);
+				// add anchor entry to list
+				currEntry.put(&quot;ANCHORNAME&quot;, Convert.toString(i));
+				currEntry.put(&quot;ANCHORTEXT&quot;, Convert.toString(lastValue));
+				lastValue = currValue + diff;
+			}
+			else {
+				// clear value from previous run
+				currEntry.put(&quot;ANCHORNAME&quot;, &quot;&quot;);
+				currEntry.put(&quot;ANCHORTEXT&quot;, &quot;&quot;);
+			}
+			list.setElementAt(currEntry,i);
+		}
+		return topIndex;
+	}
+
+	/**
+	 * @author Kalle
+	 * Comparer for sorting the vector for the index.html file
+	 */
+	private class HTMLComparer implements eve.util.Comparer {
+		String compareWhat;
+
+		public HTMLComparer (String what){
+			this.compareWhat = what;
+		}
+		
+		public int compare(Object o1, Object o2){
+			Hashtable hash1 = (Hashtable)o1;
+			Hashtable hash2 = (Hashtable)o2;
+			String str1, str2;
+			double dbl1, dbl2;
+
+			str1 = hash1.get(compareWhat).toString().toLowerCase();
+			str2 = hash2.get(compareWhat).toString().toLowerCase();
+			
+			if (this.compareWhat.equals(&quot;WAYPOINT&quot;)){
+				str1 = hash1.get(compareWhat).toString().substring(2).toLowerCase();
+				str2 = hash2.get(compareWhat).toString().substring(2).toLowerCase();
+			}
+			
+			if (this.compareWhat.equals(&quot;DISTANCE&quot;)){
+				dbl1 = Common.parseDouble(str1.substring(0,str1.length()-3));
+				dbl2 = Common.parseDouble(str2.substring(0,str2.length()-3));
+				if (dbl1 &gt; dbl2) return 1;
+				if (dbl1 &lt; dbl2) return -1;
+				return 0;
+			}
+			return str1.compareTo(str2);
+		}
+	}
+
+	
+}

Added: experiments/EVE/src/cachewolf/exp/KMLExporter.java
===================================================================
--- experiments/EVE/src/cachewolf/exp/KMLExporter.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/exp/KMLExporter.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,318 @@
+package cachewolf.exp;
+
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.PrintWriter;
+import eve.sys.Handle;
+import eve.sys.Vm;
+import eve.ui.ProgressBarForm;
+import java.util.*;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipException;
+import java.util.zip.ZipFile;
+
+import cachewolf.*;
+import cachewolf.utils.Common;
+import cachewolf.utils.SafeXML;
+
+
+/**
+*	Class to export the cache database (index) to an KML-File
+*	which can be read by Google Earth   
+*   
+*/
+public class KMLExporter extends Exporter {
+	private static final String COLOR_FOUND = &quot;ff98fb98&quot;; 
+	private static final String COLOR_OWNED = &quot;ffffaa55&quot;; 
+	private static final String COLOR_AVAILABLE = &quot;ffffffff&quot;;
+	private static final String COLOR_NOT_AVAILABLE = &quot;ff0000ff&quot;;
+
+
+	static final int AVAILABLE = 0;
+	static final int FOUND = 1;
+	static final int OWNED = 2;
+	static final int NOT_AVAILABLE = 3;
+	static final int UNKNOWN = 4;
+	
+	
+	String []categoryNames = {&quot;Available&quot;,&quot;Found&quot;, &quot;Owned&quot;, &quot;Not Available&quot;, &quot;UNKNOWN&quot;};
+	Hashtable [] outCacheDB = new Hashtable[categoryNames.length];
+
+	public KMLExporter(){
+		super();
+		this.setMask(&quot;*.kml&quot;);
+		this.setHowManyParams(LAT_LON);
+	}
+
+	
+	public KMLExporter(Preferences p, Profile prof){
+			super();
+			this.setMask(&quot;*.kml&quot;);
+	}
+
+	public void doIt(int variant){
+		String outFile;
+		String str;
+		CacheHolder ch;
+		CacheHolder addiWpt;
+		CacheHolderDetail chD;
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+		
+		if (variant == ASK_FILE) {
+			outFile = getOutputFile();
+			if (outFile == null) return;
+		} else {
+			outFile = tmpFileName;
+		}
+
+		pbf.showMainTask = false;
+		pbf.setTask(h,&quot;Exporting ...&quot;);
+		pbf.exec();
+
+		int counter = 0;
+		int expCount = 0;
+		for(int i = 0; i&lt;cacheDB.size();i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			if(ch.is_black == false &amp;&amp; ch.is_filtered == false) counter++;
+		}
+		copyIcons(new File(outFile).getParent());
+		buildOutDB();
+		
+		try{
+			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(outFile)));
+			str = this.header();
+			if (str != null) outp.print(str);
+			for (int cat = 0; cat &lt; categoryNames.length; cat++) {
+				// skip over empty categories
+				if (outCacheDB[cat]==null) continue;
+
+				Enumeration keys = outCacheDB[cat].keys();
+				outp.print(startFolder(categoryNames[cat]));
+
+				Vector tmp;
+				String key;
+				while (keys.hasMoreElements()){
+					key=(String)keys.nextElement();
+					tmp = (Vector) outCacheDB[cat].get(key);
+					// skip over empty cachetypes
+					if (tmp.size() == 0) continue;
+					outp.print(startFolder(CacheType.transType(Common.parseInt(key))));
+
+					for(int i = 0; i&lt;tmp.size(); i++){
+						ch = (CacheHolder) tmp.get(i);
+						if (ch.isAddiWpt()) continue;
+						expCount++;
+						h.progress = (float)expCount/(float)counter;
+						h.changed();
+						
+						chD=new CacheHolderDetail(ch);
+						try {
+							chD.readCache(profile.dataDir);
+						} catch (IOException e) {
+							continue;
+						}
+						if (chD.pos.isValid()){
+							str = record(chD, chD.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+								     chD.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+							if (str != null) outp.print(str);
+						}
+						if (ch.hasAddiWpt()){
+						outp.print(startFolder(&quot;Additional Waypoints&quot;, false));
+							for(int j = 0; j&lt;ch.addiWpts.size(); j++){
+								addiWpt = (CacheHolder) ch.addiWpts.get(j);
+								chD=new CacheHolderDetail(addiWpt);
+								expCount++;
+								if (chD.pos.isValid()){
+									str = record(chD, chD.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+										     chD.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+									if (str != null) outp.print(str);
+								}
+								
+							}
+						outp.print(endFolder());// addi wpts
+						}
+					}
+					outp.print(endFolder());// cachetype
+				}
+				outp.print(endFolder());// category
+			}
+			
+			str = trailer();
+			if (str != null) outp.print(str);
+			outp.close();
+			pbf.exit(0);
+		} catch (IOException ioE){
+			Vm.debug(&quot;Error opening &quot; + outFile);
+		}
+		//try
+
+	}
+	
+	private void buildOutDB(){
+		CacheHolder ch;
+		Vector tmp;
+		Enumeration categoryLoop;
+		String key;
+		boolean foundOne;
+		
+		// create the roots for the different categories
+		for (int i = 0; i &lt; categoryNames.length; i++) {
+			outCacheDB[i] = new Hashtable();
+			// create the roots for the cachetypes
+			for (int j = 0; j &lt; CacheType.wayType.length; j++) {
+				outCacheDB[i].put(Integer.toString(CacheType.wayTypeNo[j]), new Vector());
+			}
+		}
+
+		// fill structure with data from cacheDB
+		for(int i = 0; i&lt;cacheDB.size(); i++){
+			ch=(CacheHolder)cacheDB.get(i);
+			if(ch.is_black == false &amp;&amp; ch.is_filtered == false &amp;&amp; !ch.isAddiWpt()){
+				if (ch.is_found) { tmp = (Vector) outCacheDB[FOUND].get(ch.type);}
+				else if (ch.is_owned) { tmp = (Vector) outCacheDB[OWNED].get(ch.type);}
+				else if (ch.is_archived || !ch.is_available){ tmp = (Vector) outCacheDB[NOT_AVAILABLE].get(ch.type);}
+				else if (ch.is_available){ tmp = (Vector) outCacheDB[AVAILABLE].get(ch.type);}
+				else { tmp = (Vector) outCacheDB[UNKNOWN].get(ch.type);}
+				
+				tmp.add(ch);
+			}
+		}
+		
+		//eleminate empty categories
+		for (int i = 0; i &lt; categoryNames.length; i++) {
+			categoryLoop = outCacheDB[i].keys();
+			foundOne = false;
+			//look if all vectors for cachetypes are filled
+			while (categoryLoop.hasMoreElements()){
+				key = (String) categoryLoop.nextElement();
+				tmp = (Vector)outCacheDB[i].get(key);
+				if (tmp.size()&gt; 0){
+					foundOne = true;
+					break;
+				}
+			}
+			// set hashtable for that category to null
+			if (!foundOne)outCacheDB[i] = null;
+		}
+		
+
+	}
+	
+	private String startFolder(String name){
+		return startFolder(name, true);
+	}
+	
+	private String startFolder(String name, boolean open){
+		StringBuffer strBuf = new StringBuffer(200);
+		strBuf.append(&quot;&lt;Folder&gt;\r\n&quot;);
+		strBuf.append(&quot;&lt;name&gt;&quot; + name + &quot;&lt;/name&gt;\r\n&quot;);
+		strBuf.append(&quot;&lt;open&gt;&quot; + (open?&quot;1&quot;:&quot;0&quot;) + &quot;&lt;/open&gt;\r\n&quot;);
+
+		return strBuf.toString();
+	}
+
+	private String endFolder() {
+		
+		return &quot;&lt;/Folder&gt;\r\n&quot;;
+	}
+
+	public void copyIcons(String dir){
+		try {
+			ZipFile zif = new ZipFile (eve.io.File.getProgramDirectory() + &quot;/POIIcons.zip&quot;);
+			ZipEntry zipEnt;
+			int len;
+			String entName, fileName; 
+
+			for (int i = 0; i &lt; CacheType.wayType.length; i++) {
+				fileName = CacheType.type2pic(CacheType.wayTypeNo[i]);
+				entName = &quot;GoogleEarthIcons/&quot; + fileName;
+				zipEnt = zif.getEntry(entName);
+				if (zipEnt == null) continue;
+			    byte[] buff = new byte[ (int) zipEnt.getSize() ];
+			    InputStream  fis = zif.getInputStream(zipEnt);
+			    FileOutputStream fos = new FileOutputStream( dir + &quot;/&quot; + fileName);
+			    while( 0 &lt; (len = fis.read( buff )) )
+			      fos.write( buff, 0, len );
+			    fos.flush();
+			    fos.close();
+			    fis.close();
+			}
+
+			} catch (ZipException e) {
+				Vm.debug(&quot;Problem copying Icon&quot;);
+				e.printStackTrace();
+			} catch (IOException e) {
+				Vm.debug(&quot;Problem copying Icon&quot;);
+				e.printStackTrace();
+			}
+	}
+
+	
+	public String header () {
+		StringBuffer strBuf = new StringBuffer(200);
+				
+		strBuf.append(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;\r\n&quot;);
+		strBuf.append(&quot;&lt;kml xmlns=\&quot;<A HREF="http://earth.google.com/kml/2.0\">http://earth.google.com/kml/2.0\</A>&quot;&gt;\r\n&quot;);
+		strBuf.append(&quot;&lt;Folder&gt;\r\n&quot;);
+		strBuf.append(&quot;&lt;name&gt;CacheWolf&lt;/name&gt;\r\n&quot;);
+		strBuf.append(&quot;&lt;open&gt;1&lt;/open&gt;\r\n&quot;);
+	
+		return strBuf.toString();
+	}
+
+
+	public String record(CacheHolderDetail ch, String lat, String lon){
+		StringBuffer strBuf = new StringBuffer(200);
+		
+		strBuf.append(&quot;   &lt;Placemark&gt;\r\n&quot;);
+		if (ch.URL != null){
+			strBuf.append(&quot;      &lt;description&gt;&quot;+SafeXML.clean(ch.URL)+&quot;&lt;/description&gt;\r\n&quot;);
+		}
+		strBuf.append(&quot;      &lt;name&gt;&quot;+ ch.wayPoint + &quot; - &quot; + SafeXML.clean(ch.cacheName) +&quot;&lt;/name&gt;\r\n&quot;);
+		strBuf.append(&quot;      &lt;LookAt&gt;\r\n&quot;);
+		strBuf.append(&quot;         &lt;latitude&gt;&quot; + lat + &quot;&lt;/latitude&gt;\r\n&quot;);
+		strBuf.append(&quot;         &lt;longitude&gt;&quot; + lon + &quot;&lt;/longitude&gt;\r\n&quot;);
+		strBuf.append(&quot;         &lt;range&gt;10000&lt;/range&gt;&lt;tilt&gt;0&lt;/tilt&gt;&lt;heading&gt;0&lt;/heading&gt;\r\n&quot;);
+		strBuf.append(&quot;      &lt;/LookAt&gt;\r\n&quot;);
+		strBuf.append(&quot;      &lt;Point&gt;\r\n&quot;);
+		strBuf.append(&quot;         &lt;coordinates&gt;&quot;  + lon + &quot;,&quot; + lat + &quot;&lt;/coordinates&gt;\r\n&quot;);
+		strBuf.append(&quot;      &lt;/Point&gt;\r\n&quot;);
+		strBuf.append(&quot;      &lt;Style&gt;\r\n&quot;);
+		strBuf.append(&quot;      &lt;IconStyle&gt;\r\n&quot;);
+		strBuf.append(&quot;         &lt;Icon&gt;\r\n&quot;);
+//		strBuf.append(&quot;            &lt;href&gt;&quot;+ File.getProgramDirectory()+ &quot;/&quot; + CacheType.type2pic(Convert.parseInt(ch.type))+ &quot;&lt;/href&gt;\r\n&quot;);
+		strBuf.append(&quot;            &lt;href&gt;&quot;+ CacheType.type2pic(ch.type)+ &quot;&lt;/href&gt;\r\n&quot;);
+		strBuf.append(&quot;         &lt;/Icon&gt;\r\n&quot;);
+		strBuf.append(&quot;      &lt;/IconStyle&gt;\r\n&quot;);
+		strBuf.append(&quot;      &lt;LabelStyle&gt;\r\n&quot;);
+		strBuf.append(&quot;         &lt;color&gt;&quot; + getColor(ch) + &quot;&lt;/color&gt;\r\n&quot;);
+		strBuf.append(&quot;      &lt;/LabelStyle&gt;\r\n&quot;);
+		strBuf.append(&quot;      &lt;/Style&gt;\r\n&quot;);
+		strBuf.append(&quot;   &lt;/Placemark&gt;\r\n&quot;);
+	
+		return strBuf.toString();
+	}
+	
+	public String trailer(){
+		StringBuffer strBuf = new StringBuffer(50);
+
+		strBuf.append(&quot;&lt;/Folder&gt;\r\n&quot;);
+		strBuf.append(&quot;&lt;/kml&gt;\r\n&quot;);
+
+		return strBuf.toString();
+	}
+	
+	private String getColor(CacheHolderDetail ch){
+		if (ch.is_found) return COLOR_FOUND;
+		if (ch.is_owned) return COLOR_OWNED;
+		if (ch.is_archived || !ch.is_available) return COLOR_NOT_AVAILABLE;
+		
+		return COLOR_AVAILABLE;
+	}
+	
+}

Added: experiments/EVE/src/cachewolf/exp/LocExporter.java
===================================================================
--- experiments/EVE/src/cachewolf/exp/LocExporter.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/exp/LocExporter.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,136 @@
+package cachewolf.exp;
+import cachewolf.*;
+import cachewolf.utils.Common;
+import eve.io.File;
+import ewesoft.xml.*;
+import ewesoft.xml.sax.*;
+
+/**
+*	Class to export the cache database into an geocaching .loc file that may be exported
+*	by GPSBabel to a Garmin GPS.
+*
+*	Now includes mapping of cachetypes to user defined icons (as defined in file garminmap.xml).
+*/
+public class LocExporter extends Exporter{
+	public static final int MODE_AUTO = TMP_FILE;
+	/**
+	 * Defines how certain cachetypes are mapped to user icons
+	 */
+	private static GarminMap gm=null;
+	
+	public LocExporter(){
+		super();
+		this.setMask(&quot;*.loc&quot;);
+		this.setHowManyParams(NO_PARAMS);
+		if ((new File(File.getProgramDirectory()+&quot;/garminmap.xml&quot;)).exists()) {
+			gm=new GarminMap();
+			gm.readGarminMap();
+		}
+	}
+	
+	public String header () {
+		return &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;&lt;loc version=\&quot;1.0\&quot; src=\&quot;EasyGPS\&quot;&gt;\r\n&quot;;
+	}
+	
+	public String record(CacheHolderDetail chD){
+		// filter out not valid coords
+		if (!chD.pos.isValid()) return null;
+		StringBuffer strBuf = new StringBuffer(200);
+		strBuf.append(&quot;&lt;waypoint&gt;\r\n   &lt;name id=\&quot;&quot;);
+		String wptName=simplifyString(chD.wayPoint);
+		if (Global.getPref().garminMaxLen==0)
+			strBuf.append(wptName);
+		else {
+			try {
+				strBuf.append(wptName.substring(wptName.length()-Global.getPref().garminMaxLen));
+			} catch (Exception ex){ pref.log(&quot;Invalid value for garmin.MaxWaypointLength&quot;); }
+		}
+		strBuf.append(&quot;\&quot;&gt;&lt;![CDATA[&quot;);
+		strBuf.append(simplifyString(chD.cacheName));
+		strBuf.append(&quot;]]&gt;&lt;/name&gt;\r\n   &lt;coord lat=\&quot;&quot;);
+		strBuf.append(chD.pos.getLatDeg(CWPoint.DD));
+		strBuf.append(&quot;\&quot; lon=\&quot;&quot;);
+		strBuf.append(chD.pos.getLonDeg(CWPoint.DD));
+		strBuf.append(&quot;\&quot;/&gt;\r\n   &lt;type&gt;&quot;);
+		if (gm!=null) {
+			strBuf.append(gm.getIcon(chD));
+		} else {
+			if (chD.is_found)
+				strBuf.append(&quot;Geocache Found&quot;);
+			else
+				strBuf.append(&quot;Geocache&quot;);
+		}
+		strBuf.append(&quot;&lt;/type&gt;\r\n&lt;/waypoint&gt;\r\n&quot;);
+		return strBuf.toString();
+	}
+	public String trailer(){
+		return &quot;&lt;/loc&gt;\r\n&quot;;
+	}
+	
+	/**
+	 * This class implements user defined icons which depend on the cache type and the found status.
+	 * See also <A HREF="http://www.geoclub.de/ftopic10413.html">http://www.geoclub.de/ftopic10413.html</A>
+	 * @author salzkammergut
+	 *
+	 */
+	private class GarminMap extends MinML {
+		
+		private IconMap[] symbols=new IconMap[24];
+		private int mapSize=0;
+		
+		String lastName;
+		public void readGarminMap(){
+			try{
+				String datei = File.getProgramDirectory() + &quot;/garminmap.xml&quot;;
+				java.io.Reader r = new java.io.InputStreamReader(new java.io.FileInputStream(datei));
+				parse(r);
+				r.close();
+			}catch(Exception e){
+				if (e instanceof NullPointerException)
+					Global.getPref().log(&quot;Error reading garminmap.xml: NullPointerException in Element &quot;+lastName +&quot;. Wrong attribute?&quot;,e,true);
+				else 
+					Global.getPref().log(&quot;Error reading garminmap.xml: &quot;, e);
+			}
+		}
+		public void startElement(String name, AttributeList atts){
+			lastName=name;
+			if (name.equals(&quot;icon&quot;)) {
+				symbols[mapSize]=new IconMap(Common.parseInt(atts.getValue(&quot;type&quot;)),atts.getValue(&quot;name&quot;),atts.getValue(&quot;found&quot;));
+				mapSize++;
+			}
+		}		
+		
+		public String getIcon(CacheHolderDetail chD) {
+			// First check if there is a mapping for &quot;cache found&quot;
+			if (chD.is_found) {
+				for (int i=0; i&lt;mapSize; i++)
+					if (symbols[i].onlyIfFound!=null &amp;&amp; symbols[i].type==chD.type) return symbols[i].name;
+			}
+			// Now try mapping the cache irrespective of the &quot;found&quot; status
+			for (int i=0; i&lt;mapSize; i++)
+				if (symbols[i].type==chD.type) return symbols[i].name;
+		
+			// If it is not a mapped type, just use the standard mapping
+			if (chD.is_found)
+				return &quot;Geocache Found&quot;;
+			return &quot;Geocache&quot;;
+		}
+		
+		private class IconMap {
+			public int type;
+			public Boolean onlyIfFound;
+			public String name;
+			
+			IconMap(int type, String name, String onlyIfFound) {
+				this.type=type;
+				this.name=name;
+				if (onlyIfFound!=null &amp;&amp; onlyIfFound.equals(&quot;1&quot;))
+					this.onlyIfFound=Boolean.TRUE;
+				else
+					this.onlyIfFound=null;
+			}
+		}
+	
+	}
+	
+}

Added: experiments/EVE/src/cachewolf/exp/MSARCSVExporter.java
===================================================================
--- experiments/EVE/src/cachewolf/exp/MSARCSVExporter.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/exp/MSARCSVExporter.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,37 @@
+package cachewolf.exp;
+
+import cachewolf.*;
+
+/**
+ * Class to export the cache database (index) to an CSV File which can bei easy
+ * importet bei MS AutoRoute (testet with AR 2001 German) Format of the file:
+ * Name;Breitengrad;L&#228;ngengrad;Typ1;Typ2;Waypoint;Datum;Hyperlink
+ * 
+ */
+public class MSARCSVExporter extends Exporter {
+
+	public MSARCSVExporter(Preferences p, Profile prof) {
+		super();
+		this.setMask(&quot;*.csv&quot;);
+		this.setDecimalSeparator(',');
+		this.setNeedCacheDetails(true);
+		this.setHowManyParams(LAT_LON);
+	}
+
+	public String header() {
+		return &quot;Name;Breitengrad;L\u00E4ngengrad;Typ1;Typ2;Waypoint;Datum;Hyperlink\r&quot;;
+	}
+
+	public String record(CacheHolderDetail ch, String lat, String lon) {
+		StringBuffer str = new StringBuffer(200);
+		str.append(&quot;\&quot;&quot; + ch.wayPoint + &quot; - &quot; + ch.cacheName + &quot;\&quot;;&quot;);
+		str.append(lat + &quot;;&quot; + lon +&quot;;&quot;);
+		str.append(&quot;\&quot;&quot; + CacheType.transType(ch.type)+ &quot;\&quot;;&quot;);
+		str.append(&quot;\&quot;&quot; + ch.cacheSize + &quot;\&quot;;&quot;);
+		str.append(&quot;\&quot;&quot; + ch.wayPoint + &quot;\&quot;;&quot;);
+		str.append(&quot;\&quot;&quot; + ch.dateHidden + &quot;\&quot;;&quot;);
+		str.append(&quot;\&quot;&quot; + ch.URL + &quot;\&quot;\r\n&quot;);
+
+		return str.toString();
+	}
+}

Added: experiments/EVE/src/cachewolf/exp/OVLExporter.java
===================================================================
--- experiments/EVE/src/cachewolf/exp/OVLExporter.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/exp/OVLExporter.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,138 @@
+package cachewolf.exp;
+import cachewolf.*;
+import cachewolf.utils.Common;
+import eve.sys.*;
+
+/**
+*	Class to export the cache database (index) to an ascii overlay file for
+*	the TOP50 map products (mainly available in german speaking countries).
+*/
+public class OVLExporter extends Exporter{
+	
+	public OVLExporter(Preferences p, Profile prof){
+		super();
+		this.setMask(&quot;*.ovl&quot;);
+		this.setHowManyParams(LAT_LON|COUNT);
+	}
+	
+	public String record(CacheHolderDetail chD, String lat, String lon, int counter){
+		StringBuffer str = new StringBuffer(200);
+		double tmp;
+		str.append(&quot;[Symbol &quot;+Convert.toString(2*counter + 1)+&quot;]\r\n&quot;);
+		str.append(&quot;Typ=6\r\n&quot;);
+		str.append(&quot;Width=15\r\n&quot;);
+		str.append(&quot;Height=15\r\n&quot;);
+		str.append(&quot;Col=1\r\n&quot;);
+		str.append(&quot;Zoom=1\r\n&quot;);
+		str.append(&quot;Size=2\r\n&quot;);
+		str.append(&quot;Area=2\r\n&quot;);
+		str.append(&quot;XKoord=&quot;+lon+&quot;\r\n&quot;);
+		str.append(&quot;YKoord=&quot;+lat+&quot;\r\n&quot;);
+		//the text
+		str.append(&quot;[Symbol &quot;+Convert.toString(2*counter + 2)+&quot;]\r\n&quot;);
+		str.append(&quot;Typ=2\r\n&quot;);
+		str.append(&quot;Col=1\r\n&quot;);
+		str.append(&quot;Zoom=1\r\n&quot;);
+		str.append(&quot;Size=2\r\n&quot;);
+		str.append(&quot;Area=2\r\n&quot;);
+		str.append(&quot;Font=3\r\n&quot;);
+		str.append(&quot;Dir=1\r\n&quot;);
+		tmp = Common.parseDouble(lon);
+		tmp += 0.002;
+		str.append(&quot;XKoord=&quot;+Convert.toString(tmp).replace(',', '.')+&quot;\r\n&quot;);
+		tmp = Common.parseDouble(lat);
+		tmp += 0.002;
+		str.append(&quot;YKoord=&quot;+Convert.toString(tmp).replace(',', '.')+&quot;\r\n&quot;);
+		str.append(&quot;Text=&quot;+chD.wayPoint+&quot;\r\n&quot;);
+
+		return str.toString();
+	}
+	
+	public String trailer(int counter){
+		StringBuffer str = new StringBuffer(200);
+
+		str.append(&quot;[Overlay]\r\n&quot;);
+		str.append(&quot;Symbols=&quot;+Convert.toString(counter*2)+&quot;\r\n&quot;);
+		// maplage section
+		str.append(&quot;[MapLage]\r\n&quot;);
+		str.append(&quot;MapName=Gesamtes Bundesgebiet (D1000)\r\n&quot;);
+		str.append(&quot;DimmFc=100\r\n&quot;);
+		str.append(&quot;ZoomFc=100\r\n&quot;);
+		str.append(&quot;CenterLat=&quot;+pref.curCentrePt.getLatDeg(CWPoint.CW)+&quot;.00\r\n&quot;);
+		str.append(&quot;CenterLong=&quot;+pref.curCentrePt.getLonDeg(CWPoint.CW)+&quot;.00\r\n&quot;);
+		str.append(&quot;RefColor=255\r\n&quot;);
+		str.append(&quot;RefRad=58\r\n&quot;);
+		str.append(&quot;RefLine=6\r\n&quot;);
+		str.append(&quot;RefOn=0\r\n&quot;);
+		str.append(&quot;\r\n&quot;);
+		return str.toString();
+	}
+
+	
+/*	public void doIt(){
+		CacheHolder holder;
+		ParseLatLon pll;
+		int symCounter = 1;
+		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
+		fc.setTitle(&quot;Select target file:&quot;);
+		if(fc.execute() != FileChooser.IDCANCEL){
+			File saveTo = fc.getChosenFile();
+			try{
+				PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
+				//symbols section, loop through database
+				//a circle and text per cache is created
+				for(int i = 0; i&lt;cacheDB.size(); i++){
+					holder=(CacheHolder)cacheDB.get(i);
+					if(holder.is_black == false &amp;&amp; holder.is_filtered == false){
+						pll = new ParseLatLon(holder.LatLon,&quot;.&quot;);
+						pll.parse();
+						//the circle!
+						outp.print(&quot;[Symbol &quot;+Convert.toString(symCounter)+&quot;]\r\n&quot;);
+						outp.print(&quot;Typ=6\r\n&quot;);
+						outp.print(&quot;Width=15\r\n&quot;);
+						outp.print(&quot;Height=15\r\n&quot;);
+						outp.print(&quot;Col=1\r\n&quot;);
+						outp.print(&quot;Zoom=1\r\n&quot;);
+						outp.print(&quot;Size=2\r\n&quot;);
+						outp.print(&quot;Area=2\r\n&quot;);
+						outp.print(&quot;XKoord=&quot;+pll.getLonDeg()+&quot;\r\n&quot;);
+						outp.print(&quot;YKoord=&quot;+pll.getLatDeg()+&quot;\r\n&quot;);
+						symCounter++;
+						//the text
+						outp.print(&quot;[Symbol &quot;+Convert.toString(symCounter)+&quot;]\r\n&quot;);
+						outp.print(&quot;Typ=2\r\n&quot;);
+						outp.print(&quot;Col=1\r\n&quot;);
+						outp.print(&quot;Zoom=1\r\n&quot;);
+						outp.print(&quot;Size=2\r\n&quot;);
+						outp.print(&quot;Area=2\r\n&quot;);
+						outp.print(&quot;Font=3\r\n&quot;);
+						outp.print(&quot;Dir=1\r\n&quot;);
+						outp.print(&quot;XKoord=&quot;+Convert.toString(pll.lon2+0.002).replace(',', '.')+&quot;\r\n&quot;);
+						outp.print(&quot;YKoord=&quot;+Convert.toString(pll.lat2+0.001).replace(',', '.')+&quot;\r\n&quot;);
+						outp.print(&quot;Text=&quot;+holder.wayPoint+&quot;\r\n&quot;);
+						symCounter++;
+					}//if holder...
+				}//for ... i &lt; cacheDB ...			
+				// overlay section
+				outp.print(&quot;[Overlay]\r\n&quot;);
+				outp.print(&quot;Symbols=&quot;+Convert.toString(symCounter-1)+&quot;\r\n&quot;);
+				// maplage section
+				outp.print(&quot;[MapLage]\r\n&quot;);
+				outp.print(&quot;MapName=Gesamtes Bundesgebiet (D1000)\r\n&quot;);
+				outp.print(&quot;DimmFc=100\r\n&quot;);
+				outp.print(&quot;ZoomFc=100\r\n&quot;);
+				outp.print(&quot;CenterLat=&quot;+myPreferences.curCentrePt.getLatDeg(CWPoint.CW)+&quot;.00\r\n&quot;);
+				outp.print(&quot;CenterLong=&quot;+myPreferences.curCentrePt.getLonDeg(CWPoint.CW)+&quot;.00\r\n&quot;);
+				outp.print(&quot;RefColor=255\r\n&quot;);
+				outp.print(&quot;RefRad=58\r\n&quot;);
+				outp.print(&quot;RefLine=6\r\n&quot;);
+				outp.print(&quot;RefOn=0\r\n&quot;);
+				outp.print(&quot;\r\n&quot;);
+				
+				outp.close();
+			}catch(Exception e){
+				Vm.debug(&quot;Error writing to OVL file! &quot;+e.toString());
+			}
+		} // if execute
+	}
+*/}

Added: experiments/EVE/src/cachewolf/exp/OziExporter.java
===================================================================
--- experiments/EVE/src/cachewolf/exp/OziExporter.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/exp/OziExporter.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,88 @@
+package cachewolf.exp;
+import cachewolf.*;
+
+/**
+*	Class to export the cache database (index) to an OziExplorer File
+*/
+public class OziExporter extends Exporter{
+	
+	public OziExporter(Preferences p, Profile prof){
+		super();
+		this.setHowManyParams(LAT_LON);
+		this.setMask(&quot;*.wpt&quot;);
+	}
+	
+	public String header () {
+		StringBuffer strBuf = new StringBuffer(200);
+		
+		strBuf.append(&quot;OziExplorer CE Waypoint File Version 1.2\r\n&quot;);
+		strBuf.append(&quot;WGS 84\r\n&quot;);
+		strBuf.append(&quot;Reserved 2\r\n&quot;);
+		strBuf.append(&quot;Reserved 3\r\n&quot;);
+
+		return strBuf.toString();
+	}
+
+	public String record(CacheHolderDetail ch, String lat, String lon){
+		StringBuffer strBuf = new StringBuffer(200);
+		String tmpName;
+
+		// Field 1 : Number - this is the location in the array (max 1000), must be unique, 
+		// usually start at 1 and increment. Can be set to -1 (minus 1) and the number will be auto generated.
+		strBuf.append(&quot;-1,&quot;);
+		// Field 2 : Name - the waypoint name, use the correct length name to suit the GPS type.
+		strBuf.append(ch.wayPoint + &quot;,&quot;);
+		// Field 3 : Latitude - decimal degrees.
+		strBuf.append(lat+&quot;,&quot;);
+		// Field 4 : Longitude - decimal degrees.
+		strBuf.append(lon+&quot;,&quot;);
+		// Field 5 : Date - see Date Format below, if blank a preset date will be used
+		strBuf.append(&quot;,&quot;);
+		// Field 6 : Symbol - 0 to number of symbols in GPS
+		strBuf.append(&quot;0,&quot;);
+		// Field 7 : Status - always set to 1
+		strBuf.append(&quot;1,&quot;);
+		// Field 8 : Map Display Format
+		strBuf.append(&quot;0,&quot;);
+		// Field 9 : Foreground Color (RGB value)
+		strBuf.append(&quot;0,&quot;);
+		// Field 10 : Background Color (RGB value)
+		strBuf.append(&quot;16777215,&quot;);
+		// Field 11 : Description (max 40), no commas
+		tmpName = simplifyString(ch.cacheName);
+		if (tmpName.length() &lt;= 40){
+			strBuf.append(tmpName + &quot;,&quot;);
+		}
+		else {
+			strBuf.append(tmpName.substring(0,40) + &quot;,&quot;);
+		}
+		// Field 12 : Pointer Direction
+		strBuf.append(&quot;0,&quot;);
+		// Field 13 : Garmin Display Format
+		strBuf.append(&quot;0,&quot;);
+		// Field 14 : Proximity Distance - 0 is off any other number is valid
+		strBuf.append(&quot;0,&quot;);
+		// Field 15 : Altitude - in feet (-777 if not valid)
+		strBuf.append(&quot;-777,&quot;);
+		// Field 16 : Font Size - in points
+		strBuf.append(&quot;8,&quot;);
+		// Field 17 : Font Style - 0 is normal, 1 is bold.
+		strBuf.append(&quot;1,&quot;);
+		// Field 18 : Symbol Size - 17 is normal size
+		strBuf.append(&quot;17,&quot;);
+		// Field 19 : Proximity Symbol Position
+		strBuf.append(&quot;0,&quot;);
+		// Field 20 : Proximity Time
+		strBuf.append(&quot;  10.0,&quot;);
+	    // Field 21 : Proximity or Route or Both
+		strBuf.append(&quot;2,&quot;);
+		// Field 22 : File Attachment Name
+		strBuf.append(&quot;,&quot;);
+		// Field 23 : Proximity File Attachment Name
+		strBuf.append(&quot;,&quot;);
+		// Field 24 : Proximity Symbol Name
+		strBuf.append(&quot; \r\n&quot;);
+
+		return strBuf.toString();
+	}
+}

Added: experiments/EVE/src/cachewolf/exp/PCX5Exporter.java
===================================================================
--- experiments/EVE/src/cachewolf/exp/PCX5Exporter.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/exp/PCX5Exporter.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,66 @@
+package cachewolf.exp;
+import cachewolf.*;
+import cachewolf.utils.STRreplace;
+import eve.io.File;
+
+/**
+*	Class to export the cache database into an ascii file that may be imported
+*	ba Mapsource (c) by Garmin.
+*/
+public class PCX5Exporter extends Exporter{
+	public static final int MODE_AUTO = TMP_FILE;
+	public static final int MODE_ASK = ASK_FILE;
+	
+	public PCX5Exporter(Preferences p, Profile prof){
+		super();
+		this.setMask(&quot;*.wpt&quot;);
+		this.setTmpFileName(File.getProgramDirectory() + &quot;/temp.pcx&quot;);
+		this.setHowManyParams(NO_PARAMS);
+	}
+	
+	public String header () {
+		StringBuffer strBuf = new StringBuffer(200);
+
+		strBuf.append(&quot;H  SOFTWARE NAME &amp; VERSION\n&quot;);
+		strBuf.append(&quot;I  PCX5 2.09\n&quot;);
+		strBuf.append(&quot;\n&quot;);
+		strBuf.append(&quot;H  R DATUM                IDX DA            DF            DX            DY            DZ\n&quot;);
+		strBuf.append(&quot;M  G WGS 84               121 +0.000000e+00 +0.000000e+00 +0.000000e+00 +0.000000e+00 +0.000000e+00\n&quot;);
+		strBuf.append(&quot;\n&quot;);
+		strBuf.append(&quot;H  COORDINATE SYSTEM\n&quot;);
+		strBuf.append(&quot;U  LAT LON DM\n&quot;);
+		strBuf.append(&quot;\n&quot;);
+		strBuf.append(&quot;H  IDNT   LATITUDE  LONGITUDE      DATE      TIME     ALT   DESCRIPTION                              PROXIMITY     SYMBOL ;waypts\r\n&quot;);
+		
+		return strBuf.toString();
+	}
+	
+	public String record(CacheHolderDetail ch){
+		StringBuffer strBuf = new StringBuffer(200);
+		String latlonstr, dummy;
+
+		  strBuf.append(&quot;W  &quot; + ch.wayPoint + &quot; &quot;);
+		  latlonstr = STRreplace.replace(ch.latLon, &quot;&#176;&quot;, &quot; &quot;);
+		  latlonstr = STRreplace.replace(latlonstr, &quot; &quot;, &quot;&quot;);
+		  latlonstr = STRreplace.replace(latlonstr, &quot;E&quot;, &quot; E&quot;);
+		  latlonstr = STRreplace.replace(latlonstr, &quot;W&quot;, &quot; W&quot;);
+		  strBuf.append(latlonstr + &quot;     &quot;);
+		  strBuf.append(&quot;01-JAN-04 01:00:00 -0000 &quot;);
+		  // has 42 characters
+		  dummy = ch.cacheName;
+		  if (dummy.length() &lt; 40){
+			  strBuf.append(dummy);
+			  int i = 40 - dummy.length();
+			  for (; i &gt; 0; i--){
+				  strBuf.append(' ');
+			  }
+		  } else {
+			  strBuf.append(dummy.substring(0,40));
+		  }
+		  strBuf.append(&quot; 0.000000e+000 &quot;);
+		  if(ch.is_found) strBuf.append(&quot;  8256\r\n&quot;);
+		  else  		  strBuf.append(&quot;  8255\r\n&quot;);
+		return strBuf.toString();
+	}
+	
+}

Added: experiments/EVE/src/cachewolf/exp/TPLExporter.java
===================================================================
--- experiments/EVE/src/cachewolf/exp/TPLExporter.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/exp/TPLExporter.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,267 @@
+/*
+    CacheWolf is a software for PocketPC, Win and Linux that
+    enables paperless caching.
+    It supports the sites geocaching.com and opencaching.de
+
+    Copyright (C) 2006  CacheWolf development team
+    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+    for more information.
+    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+		<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation version 2 of the License.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+    */
+
+package cachewolf.exp;
+
+import HTML.Template;
+import eve.ui.filechooser.FileChooser;
+import java.io.*;
+import eve.io.*;
+import eve.sys.*;
+import eve.ui.*;
+import java.util.*;
+
+
+import cachewolf.CWPoint;
+import cachewolf.CacheHolder;
+import cachewolf.CacheHolderDetail;
+import cachewolf.CacheType;
+import cachewolf.Global;
+import cachewolf.Preferences;
+import cachewolf.Profile;
+import cachewolf.utils.Common;
+
+import com.stevesoft.eve_pat.*;
+
+/**
+ * @author Kalle
+ * class to export cachedata using a template
+ */
+class TplFilter implements HTML.Tmpl.Filter
+{
+	private int type=SCALAR;
+	private String newLine=&quot;\n&quot;;
+	TextCodec codec = new AsciiCodec();
+	String badChars;
+	String decSep = &quot;.&quot;;
+
+
+	public TplFilter(){
+		codec = new AsciiCodec(AsciiCodec.STRIP_CR);
+		return;
+	}
+
+	public int format() {
+		return this.type;
+	}
+
+	public String parse(String t) {
+		//Vm.debug(t);
+		Regex rex, rex1;
+		String param, value;
+		// Filter newlines
+		rex = new Regex(&quot;(?m)\n$&quot;,&quot;&quot;);
+		t = rex.replaceAll(t);
+
+		// Filter comments &lt;#-- and --&gt;
+		rex = new Regex(&quot;&lt;#--.*--&gt;&quot;,&quot;&quot;);
+		t = rex.replaceAll(t);
+
+		// replace &lt;br&gt; or &lt;br /&gt; with newline
+		rex = new Regex(&quot;&lt;br.*&gt;&quot;,&quot;&quot;);
+		rex.search(t);
+		if (rex.didMatch()){
+			t = rex.replaceAll(t);
+			t += newLine;
+		}
+
+		// search for parameters
+		rex = new Regex(&quot;(?i)&lt;tmpl_par.*&gt;&quot;);
+		rex.search(t);
+		if (rex.didMatch()){
+			// get parameter
+			rex1 = new Regex(&quot;(?i)name=\&quot;(.*)\&quot;\\svalue=\&quot;(.*)\&quot;[?\\s&gt;]&quot;);
+			rex1.search(t);
+			param = rex1.stringMatched(1);
+			value = rex1.stringMatched(2);
+			//Vm.debug(&quot;param=&quot; + param + &quot;\nvalue=&quot; + value);
+			//clear t, because we allow only one parameter per line
+			t = &quot;&quot;;
+
+			// get the values
+			if (param.equals(&quot;charset&quot;)) {
+				if (value.equals(&quot;ASCII&quot;)) codec = new AsciiCodec();
+				if (value.equals(&quot;UTF8&quot;)) codec = new JavaUtf8Codec();
+			}
+			if (param.equals(&quot;badchars&quot;)) {
+				badChars = value;
+			}
+			if (param.equals(&quot;newline&quot;)){
+				newLine = &quot;&quot;;
+				if (value.indexOf(&quot;CR&quot;) &gt;= 0) newLine += &quot;\r&quot;;
+				if (value.indexOf(&quot;LF&quot;) &gt;= 0) newLine += &quot;\n&quot;;
+			}
+			if (param.equals(&quot;decsep&quot;)) {
+				decSep = value;
+			}
+			if (param.equals(&quot;debug&quot;))
+				HTML.Tmpl.Util.debug=true;
+		}
+		return t;
+	}
+
+
+	public String [] parse(String [] t) {
+		throw new UnsupportedOperationException();
+	}
+}
+
+
+public class TPLExporter {
+	Vector cacheDB;
+	Preferences pref;
+	Profile profile;
+	String tplFile;
+	String expName;
+	Regex rex=null;
+
+	public TPLExporter(Preferences p, Profile prof, String tpl){
+		pref = p;
+		profile=prof;
+		cacheDB = profile.cacheDB;
+		tplFile = tpl;
+		java.io.File tmpFile = new java.io.File(tpl);
+		expName = tmpFile.getName();
+		expName = expName.substring(0, expName.indexOf(&quot;.&quot;));
+	}
+
+	public void doIt(){
+		CacheHolderDetail chD;
+		CacheHolder ch;
+		ProgressBarForm pbf = new ProgressBarForm();
+		eve.sys.Handle h = new eve.sys.Handle();
+
+		FileChooser fc = new FileChooser(FileChooser.SAVE, pref.getExportPath(expName));
+		fc.title=(&quot;Select target file:&quot;);
+		if(fc.execute() == FileChooser.IDCANCEL) return;
+		String saveTo = fc.getChosen();
+		pref.setExportPath(expName, saveTo);
+		int counter = 0;
+		for(int i = 0; i&lt;cacheDB.size();i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			if(ch.is_black == false &amp;&amp; ch.is_filtered == false) counter++;
+		}
+		pbf.showMainTask = false;
+		pbf.setTask(h,&quot;Exporting ...&quot;);
+		pbf.exec();
+		java.lang.Runtime.getRuntime().gc(); // all this doesn't really work :-(
+		System.runFinalization();
+		java.lang.Runtime.getRuntime().gc();
+		//Vm.debug(&quot;v: &quot;+Vm.countObjects(true));
+		try {
+			Vector cache_index = new Vector(); // declare variables inside try {} -&gt; in case of OutOfMemoryError, they can be garbage collected - anyhow it doesn't work :-(
+			Hashtable varParams;
+			TplFilter myFilter;
+			Hashtable args = new Hashtable();
+			myFilter = new TplFilter();
+			//args.put(&quot;debug&quot;, &quot;true&quot;);
+			args.put(&quot;filename&quot;, tplFile);
+			args.put(&quot;case_sensitive&quot;, &quot;true&quot;);
+			args.put(&quot;loop_context_vars&quot;, Boolean.TRUE);
+			args.put(&quot;max_includes&quot;, Integer.toString(5));
+			args.put(&quot;filter&quot;, myFilter);
+			Template tpl = new Template(args);
+
+			for(int i = 0; i&lt;counter;i++){
+				ch = (CacheHolder)cacheDB.get(i);
+				h.progress = (float)i/(float)counter;
+				h.changed();
+				if(ch.is_black == false &amp;&amp; ch.is_filtered == false){
+					if (ch.pos.isValid() == false) continue;
+					chD=new CacheHolderDetail(ch);
+					try{
+						chD.readCache(profile.dataDir);
+					}catch(Exception e){
+						Vm.debug(&quot;Problem reading cache page&quot;);
+						Global.getPref().log(&quot;Exception in TplExporter = Problem reading cache page, Cache: &quot; + chD.wayPoint, e, true);
+					}
+					try {
+						Regex dec = new Regex(&quot;[,.]&quot;,myFilter.decSep);
+						if (myFilter.badChars != null) rex = new Regex(&quot;[&quot;+myFilter.badChars+&quot;]&quot;,&quot;&quot;);
+						varParams = new Hashtable();
+						varParams.put(&quot;TYPE&quot;, CacheType.transType(chD.type));
+						varParams.put(&quot;SHORTTYPE&quot;, CacheType.transType(chD.type).substring(0,1));
+						varParams.put(&quot;SIZE&quot;, chD.cacheSize);
+						varParams.put(&quot;SHORTSIZE&quot;, chD.cacheSize.substring(0,1));
+						varParams.put(&quot;WAYPOINT&quot;, chD.wayPoint);
+						varParams.put(&quot;OWNER&quot;, chD.cacheOwner);
+						varParams.put(&quot;DIFFICULTY&quot;, dec.replaceAll(chD.hard));
+						varParams.put(&quot;TERRAIN&quot;, dec.replaceAll(chD.terrain));
+						varParams.put(&quot;DISTANCE&quot;, dec.replaceAll(chD.distance));
+						varParams.put(&quot;BEARING&quot;, chD.bearing);
+						varParams.put(&quot;LATLON&quot;, chD.latLon);
+						varParams.put(&quot;LAT&quot;, dec.replaceAll(chD.pos.getLatDeg(CWPoint.DD)));
+						varParams.put(&quot;LON&quot;, dec.replaceAll(chD.pos.getLonDeg(CWPoint.DD)));
+						varParams.put(&quot;STATUS&quot;, chD.cacheStatus);
+						varParams.put(&quot;STATUS_DATE&quot;, chD.getStatusDate());
+						varParams.put(&quot;STATUS_TIME&quot;, chD.getStatusTime());
+						varParams.put(&quot;DATE&quot;, chD.dateHidden);
+						varParams.put(&quot;URL&quot;, chD.URL);
+						varParams.put(&quot;NOTES&quot;, chD.cacheNotes);
+						varParams.put(&quot;DESCRIPTION&quot;, chD.longDescription);
+                        if (myFilter.badChars != null) {
+                            varParams.put(&quot;NAME&quot;, rex.replaceAll(chD.cacheName));
+                            varParams.put(&quot;NOTES&quot;, rex.replaceAll(chD.cacheNotes));
+                            varParams.put(&quot;HINTS&quot;, rex.replaceAll(chD.hints));
+                            varParams.put(&quot;DECRYPTEDHINTS&quot;, rex.replaceAll(Common.rot13(chD.hints)));
+                    } else {
+                            varParams.put(&quot;NAME&quot;, chD.cacheName);
+                            varParams.put(&quot;NOTES&quot;, chD.cacheNotes);
+                            varParams.put(&quot;HINTS&quot;, chD.hints);
+                            varParams.put(&quot;DECRYPTEDHINTS&quot;, Common.rot13(chD.hints));
+                    }
+						cache_index.add(varParams);
+					}catch(Exception e){
+						Vm.debug(&quot;Problem getting Parameter, Cache: &quot; + chD.wayPoint);
+						e.printStackTrace();
+						Global.getPref().log(&quot;Exception in TplExporter = Problem getting Parameter, Cache: &quot; + chD.wayPoint, e, true);
+					}
+				}
+			}
+
+			tpl.setParam(&quot;cache_index&quot;, cache_index);
+			PrintWriter detfile;
+			OutputStreamWriter fw = new OutputStreamWriter(new BufferedOutputStream(new FileOutputStream(saveTo)), myFilter.codec.toString());
+			detfile = new PrintWriter(fw);
+			tpl.printTo(detfile);
+			//detfile.print(tpl.output());
+			detfile.close();
+		} catch (Exception e) {
+			e.printStackTrace();
+			Global.getPref().log(&quot;Exception in TplExporter&quot;, e, true);
+		} catch (OutOfMemoryError e) {
+			//Global.getPref().log(&quot;OutOfMemeory in TplExporter&quot;, e, true);
+			java.lang.Runtime.getRuntime().gc(); // this doesn't help :-(
+			System.runFinalization();
+			java.lang.Runtime.getRuntime().gc(); // this doesn't help :-( - I don't know why :-(
+			//Vm.debug(&quot;n: &quot;+Vm.countObjects(true));
+			(new MessageBox(&quot;Error&quot;, &quot;Not enough memory available to load all cache data (incl. description and logs)\nexport aborted\nFilter caches to minimise memory needed for TPL-Export\nWe recommend to restart CacheWolf now&quot;, MessageBox.OKB)).execute();
+			//Vm.debug(&quot;n: &quot;+Vm.countObjects(true));
+		}
+		pbf.exit(0);
+	}
+
+
+}

Added: experiments/EVE/src/cachewolf/exp/TomTomExporter.java
===================================================================
--- experiments/EVE/src/cachewolf/exp/TomTomExporter.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/exp/TomTomExporter.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,291 @@
+package cachewolf.exp;
+
+
+import eve.ui.*;
+import java.util.*;
+import java.util.zip.*;
+import eve.ui.filechooser.FileChooser;
+import eve.sys.*;
+import java.io.*;
+
+import cachewolf.*;
+import cachewolf.utils.Common;
+
+import eve.util.ByteArray;
+
+
+public class TomTomExporter {
+	public final static int TT_ASC = 0;
+	public final static int TT_OV2 = 1;
+	public final static int TT_WPT_TEXT = 0;
+	public final static int TT_WPT_NUM = 1;
+	public final static String expName = &quot;TomTom&quot;;
+
+	Vector cacheDB;
+	Preferences pref;
+	Profile profile;
+
+	
+
+	
+	public TomTomExporter() {
+		profile = Global.getProfile();
+		pref = Global.getPref();
+		cacheDB = profile.cacheDB;
+	}
+	
+	public void doIt(){
+		String fileName, dirName, prefix;
+		int fileFormat;
+
+		TomTomExporterScreen infoScreen = new TomTomExporterScreen(&quot;TomTomExport&quot;);
+		if (infoScreen.execute() == Form.IDCANCEL) return;
+		fileFormat = infoScreen.getFormat();
+
+		dirName = pref.getExportPath(expName);
+		
+		if (infoScreen.oneFilePerType()==true){
+			FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, dirName);
+			fc.title=(&quot;Select target dir:&quot;);
+			if(fc.execute() == FileChooser.IDCANCEL) return;
+			dirName = fc.getChosen();
+			pref.setExportPath(expName, dirName);
+			prefix = infoScreen.getPrefix();
+			writeOneFilePerType(fileFormat, dirName, prefix);
+		} else{
+			FileChooser fc = new FileChooser(FileChooser.SAVE, dirName);
+			fc.title=(&quot;Select target file:&quot;);
+	
+			if (fileFormat == TT_ASC) fc.addMask(&quot;*.asc&quot;);
+			else fc.addMask(&quot;*.ov2&quot;);
+			
+			if(fc.execute() == FileChooser.IDCANCEL) return;
+			fileName = fc.getChosen();
+			pref.setExportPathFromFileName(expName, fileName);
+			writeSingleFile(fileFormat, fileName);
+		}
+	}
+	
+	public void writeOneFilePerType(int format, String dirName, String prefix){
+		RandomAccessFile out = null;
+		java.io.File dfile;
+		String ext, fileName = null;
+
+		CacheHolder ch;
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+		int currExp, counter;
+		
+		pbf.showMainTask = false;
+		pbf.setTask(h,&quot;Exporting ...&quot;);
+		pbf.exec();
+		
+		currExp = 0;
+		counter = 0;
+		for(int i = 0; i&lt;cacheDB.size();i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			if(ch.is_black == false &amp;&amp; ch.is_filtered == false) counter++;
+		}
+		
+		ext = format==TT_ASC?&quot;.asc&quot;:&quot;.ov2&quot;;
+		try{
+			//loop through type
+			for(int j = 0; j &lt; CacheType.wayType.length; j++){
+				fileName = dirName + &quot;/&quot; + prefix + CacheType.wayType[j]+ ext;
+				dfile = new java.io.File(fileName);
+				dfile.delete();
+				out =  new RandomAccessFile(fileName,&quot;rw&quot;);
+				for(int i = 0; i&lt;cacheDB.size(); i++){
+					ch=(CacheHolder)cacheDB.get(i);
+					if(ch.type==CacheType.wayTypeNo[j] &amp;&amp; ch.is_black == false &amp;&amp; ch.is_filtered == false){
+						currExp++;
+						h.progress = (float)currExp/(float)counter;
+						h.changed();
+						if (ch.pos.isValid() == false) continue;
+						if (format == TT_ASC){
+							writeRecordASCII(out, ch,ch.pos.getLatDeg(CWPoint.DD),ch.pos.getLonDeg(CWPoint.DD));
+						} else {
+							writeRecordBinary(out, ch,ch.pos.getLatDeg(CWPoint.DD),ch.pos.getLonDeg(CWPoint.DD));
+						}
+					}//if
+				}//for cacheDB
+				out.close();
+				// check for empty files and delete them
+				dfile = new java.io.File(fileName);
+				if (dfile.length()==0) {
+					dfile.delete();
+				} else {
+					copyIcon(j, dirName + &quot;/&quot; + prefix + CacheType.wayType[j]); 
+				}
+			}//for wayType
+			pbf.exit(0);
+		} catch (IOException e){
+			Vm.debug(&quot;Problem creating file! &quot; + fileName);
+			e.printStackTrace();
+		}//try
+		
+	}
+	
+	public void writeSingleFile(int format, String fileName){
+		RandomAccessFile out = null;
+		java.io.File dfile;
+
+		CacheHolder ch;
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+
+		pbf.showMainTask = false;
+		pbf.setTask(h,&quot;Exporting ...&quot;);
+		pbf.exec();
+
+		int counter = 0;
+		int expCount = 0;
+		for(int i = 0; i&lt;cacheDB.size();i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			if(ch.is_black == false &amp;&amp; ch.is_filtered == false) counter++;
+		}
+
+		try{
+			dfile = new java.io.File(fileName);
+			dfile.delete();
+			out =  new RandomAccessFile(fileName,&quot;rw&quot;);
+			for(int i = 0; i&lt;cacheDB.size(); i++){
+				ch=(CacheHolder)cacheDB.get(i);
+				if(ch.is_black == false &amp;&amp; ch.is_filtered == false){
+					expCount++;
+					h.progress = (float)expCount/(float)counter;
+					h.changed();
+					if (ch.pos.isValid() == false) continue;
+					if (format == TT_ASC){
+						writeRecordASCII(out, ch,ch.pos.getLatDeg(CWPoint.DD),ch.pos.getLonDeg(CWPoint.DD));
+					} else {
+						writeRecordBinary(out, ch,ch.pos.getLatDeg(CWPoint.DD),ch.pos.getLonDeg(CWPoint.DD));
+					}
+				}//if
+			}//for
+			out.close();
+			copyIcon(0, fileName.substring(0,fileName.indexOf(&quot;.&quot;)));
+			pbf.exit(0);
+		}catch (Exception e){
+			Vm.debug(&quot;Problem writing to file! &quot; + fileName);
+			e.printStackTrace();
+		}//try
+	}
+	
+	
+	public void writeRecordASCII(RandomAccessFile outp, CacheHolder ch, String lat, String lon){
+		try {
+			outp.writeBytes(lon);
+			outp.writeBytes(&quot;,&quot;);
+			outp.writeBytes(lat);
+			outp.writeBytes(&quot;,&quot;);
+			//outp.writeBytes(&quot;\&quot;&quot; + ch.CacheName.replace(',',' ') + &quot;\&quot;\r\n&quot;);
+			outp.writeBytes(&quot;\&quot;&quot;);
+			outp.writeBytes(ch.wayPoint);
+			outp.writeBytes(&quot; - &quot;);
+			outp.writeBytes(ch.cacheName.replace(',',' '));
+			outp.writeBytes(&quot; by &quot;);
+			outp.writeBytes(ch.cacheOwner);
+			outp.writeBytes(&quot;- &quot;);             
+			outp.writeBytes(ch.hard);
+			outp.writeBytes(&quot;/&quot;);
+			outp.writeBytes(ch.terrain);
+			outp.writeBytes(&quot; - &quot;);
+			outp.writeBytes(ch.cacheSize);
+			outp.writeBytes(&quot;\&quot;\r\n&quot;);
+		} catch (IOException e) {
+			Vm.debug(&quot;Error writing to file&quot;);
+			e.printStackTrace();
+		}
+		return;
+	}
+
+	
+	public void writeRecordBinary(RandomAccessFile outp, CacheHolder ch, String lat, String lon){
+		int d,data;
+		double latlon;
+		
+		try {
+			d = 2;
+			outp.writeByte((byte)d);
+			data = ch.wayPoint.length()+ch.cacheName.length()+ch.cacheOwner.length()+ch.hard.length()+ch.terrain.length()+ch.cacheSize.length()+27;
+			writeIntBinary(outp, data);
+			latlon = Common.parseDouble(lon);
+			latlon *=100000;
+			writeIntBinary(outp, (int) latlon);
+			latlon = Common.parseDouble(lat);;
+			latlon *=100000;
+			writeIntBinary(outp, (int) latlon);
+			outp.writeBytes(ch.wayPoint);
+			outp.writeBytes(&quot; - &quot;);
+			outp.writeBytes(ch.cacheName);
+			outp.writeBytes(&quot; by &quot;);
+			outp.writeBytes(ch.cacheOwner);
+			//Wenn Leerzeichen am Ende von Cache.Owner entfernt: 
+			//Hier wieder einf&#252;gen
+			//und data = holder.wayPoint.length()+holder.CacheName.length()+.....
+			//wider um 1 erh&#246;hen
+			outp.writeBytes(&quot;- &quot;);             
+			outp.writeBytes(ch.hard);
+			outp.writeBytes(&quot;/&quot;);
+			outp.writeBytes(ch.terrain);
+			outp.writeBytes(&quot; - &quot;);
+			outp.writeBytes(ch.cacheSize);
+			d = 0;
+			outp.writeByte((byte)d);
+		} catch (IOException e) {
+			Vm.debug(&quot;Error writing to file&quot;);
+			e.printStackTrace();
+		}
+
+		return;
+	}
+
+	public void writeIntBinary(RandomAccessFile outp, int data){
+		
+		ByteArray buf = new ByteArray();
+		buf.appendInt(data);
+		try {
+			outp.writeByte(buf.data[3]);
+			outp.writeByte(buf.data[2]);
+			outp.writeByte(buf.data[1]);
+			outp.writeByte(buf.data[0]);
+		} catch (IOException e) {
+			Vm.debug(&quot;Error writing to file&quot;);
+			e.printStackTrace();
+		}
+
+		return;
+	}
+	
+	public void copyIcon(int intWayType, String filename){
+		try {
+			ZipFile zif = new ZipFile (eve.io.File.getProgramDirectory() + &quot;/POIIcons.zip&quot;);
+			ZipEntry zipEnt;
+			int len;
+			String entName; 
+			
+			entName = &quot;TomTomIcons/&quot;+ &quot;GC-&quot; + CacheType.wayType[intWayType] + &quot;.bmp&quot;;
+			zipEnt = zif.getEntry(entName);
+			if (zipEnt == null) return;
+			
+		    byte[] buff = new byte[ (int) zipEnt.getSize() ];
+		    InputStream  fis = zif.getInputStream(zipEnt);
+		    FileOutputStream fos = new FileOutputStream( filename + &quot;.bmp&quot;);
+		    while( 0 &lt; (len = fis.read( buff )) )
+		      fos.write( buff, 0, len );
+		    fos.flush();
+		    fos.close();
+		    fis.close();
+		} catch (ZipException e) {
+			Vm.debug(&quot;Problem copying Icon&quot; + &quot;GC-&quot; + CacheType.wayType[intWayType] + &quot;.bmp&quot; );
+			e.printStackTrace();
+		} catch (IOException e) {
+			Vm.debug(&quot;Problem copying Icon&quot; + &quot;GC-&quot; + CacheType.wayType[intWayType] + &quot;.bmp&quot; );
+			e.printStackTrace();
+		}
+
+		
+	}
+	
+}

Added: experiments/EVE/src/cachewolf/exp/TomTomExporterScreen.java
===================================================================
--- experiments/EVE/src/cachewolf/exp/TomTomExporterScreen.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/exp/TomTomExporterScreen.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,84 @@
+package cachewolf.exp;
+
+import cachewolf.MyLocale;
+import eve.ui.*;
+import eve.fx.gui.IKeys; 
+import eve.ui.event.ControlEvent;
+import eve.sys.Event;
+
+public class TomTomExporterScreen extends Form {
+	Button cancelB, okB;
+	CheckBox chkASC, chkOV2, chkOneFilePerType;
+	CheckBoxGroup chkGroupFormat;
+	Input inpPrefix;
+	
+	public TomTomExporterScreen(String title){
+		super();
+		this.title = title;
+
+		// checkboxgroup for fileformat
+		chkGroupFormat = new CheckBoxGroup();
+		chkASC = new CheckBox(&quot;.asc&quot;);
+		chkASC.setGroup(chkGroupFormat);
+		chkOV2 = new CheckBox(&quot;.ov2&quot;);
+		chkOV2.setGroup(chkGroupFormat);
+		chkGroupFormat.selectIndex(TomTomExporter.TT_OV2);
+		
+		this.addLast(new Label(&quot;Fileformat&quot;));
+		this.addNext(chkASC);
+		this.addLast(chkOV2);
+		
+		// checkbox for one file for all or one file per cachetype
+		chkOneFilePerType = new CheckBox(&quot;Eine Datei pro Cachetyp&quot;);
+		chkOneFilePerType.setState(true);
+		this.addLast(chkOneFilePerType);
+		
+		//prefix for files, if one file per cachetype
+		inpPrefix = new Input(&quot;GC-&quot;);
+		activateInpPrefix();
+		this.addLast(inpPrefix);
+		
+		// cancel and ok Button
+		cancelB = new Button(MyLocale.getMsg(1604,&quot;Cancel&quot;));
+		cancelB.setHotKey(0, IKeys.ESCAPE);
+		this.addNext(cancelB,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		okB = new Button(MyLocale.getMsg(1605,&quot;OK&quot;));
+		okB.setHotKey(0, IKeys.ACTION);
+		okB.setHotKey(0, IKeys.ENTER);
+		this.addLast(okB,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+	}
+	
+	public int getFormat() {
+		return chkGroupFormat.getSelectedIndex();
+	}
+	
+	public boolean oneFilePerType(){
+		return chkOneFilePerType.getState();
+	}
+	
+	public String getPrefix(){
+		return inpPrefix.getText();
+	}
+	
+	private void activateInpPrefix(){
+		if (chkOneFilePerType.getState()) inpPrefix.modify(0, ControlConstants.Disabled);
+		else inpPrefix.modify(ControlConstants.Disabled,0);
+		inpPrefix.repaintNow();
+	}
+
+	public void onEvent(Event ev){
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (ev.target == cancelB){
+				this.close(Form.IDCANCEL);
+			}
+			if (ev.target == okB){
+				this.close(Form.IDOK);
+			}
+			if (ev.target == chkOneFilePerType){
+				activateInpPrefix(); 
+			}
+		}
+		super.onEvent(ev);
+	}
+
+}

Added: experiments/EVE/src/cachewolf/imp/DBImporter.java
===================================================================
--- experiments/EVE/src/cachewolf/imp/DBImporter.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/imp/DBImporter.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,172 @@
+package cachewolf.imp;
+
+import java.util.Enumeration;
+import java.util.Hashtable;
+import java.util.Vector;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
+import cachewolf.CWPoint;
+import cachewolf.CacheHolder;
+import cachewolf.CacheHolderDetail;
+import cachewolf.CacheType;
+import cachewolf.Filter;
+import cachewolf.InfoBox;
+import cachewolf.MyLocale;
+import cachewolf.Preferences;
+import cachewolf.Profile;
+import cachewolf.utils.Common;
+import cachewolf.utils.SafeXML;
+import eve.sys.Handle;
+import eve.ui.Form;
+import eve.ui.ProgressBarForm;
+
+
+public class DBImporter {
+	int i,j,ln;
+	Vector cacheDB;
+	int zaehlerGel = 0;
+	Hashtable DBindex = new Hashtable();
+	
+	public DBImporter(){
+		cacheDB = cachewolf.Global.getProfile().cacheDB;
+		//index db for faster search
+		CacheHolder ch;
+		for(i = cacheDB.size()-1;i&gt;=0; i--){
+			ch = (CacheHolder)cacheDB.get(i);
+			DBindex.put(ch.wayPoint, new Integer(i));
+		}//for
+	}
+
+	public void doIt(String file){
+		Filter flt = new Filter();
+		boolean wasFiltered = (cachewolf.Global.getProfile().filterActive==Filter.FILTER_ACTIVE);		
+		flt.clearFilter();
+		try {
+			java.io.BufferedReader r;
+			
+			if (file.indexOf(&quot;.zip&quot;) &gt; 0){
+				ZipFile zif = new ZipFile (file);
+				ZipEntry zipEnt;
+				Enumeration zipEnum = zif.entries();
+				// there could be more than one file in the archive
+				while (zipEnum.hasMoreElements()) {	
+					zipEnt = (ZipEntry) zipEnum.nextElement();
+					if (zipEnt.getName().endsWith(&quot;db&quot;)){
+						r = new java.io.BufferedReader(new java.io.InputStreamReader(zif.getInputStream(zipEnt)));
+						
+						parse(r,zipEnt.getSize());
+						r.close();
+					}
+				}
+			} else { // Already unpacked
+				r = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file)));
+				parse(r,new java.io.File(file).length());
+				r.close();
+			}
+			// save Index 
+			cachewolf.Global.getProfile().saveIndex(Profile.NO_SHOW_PROGRESS_BAR);
+			Form.cancelWait();
+		}catch(Exception e){
+			e.printStackTrace();
+			Form.cancelWait();
+		}
+		if(wasFiltered){
+			flt.setFilter();
+			flt.doFilter();
+		}
+	}
+
+	private final void parse(java.io.BufferedReader r,long len) {
+// One typical line in DB file
+//734139 &quot;CQ DE HB0 - HAM-Cache in Liechtenstein by DunaX&quot; 2007 11 12 47.1388 9.53848333333333 
+//&quot;Multi-cache&quot; &quot;Regular&quot; GC17DPV 7a5585fd-af71-4ab7-ab42-27da2e461ef2 1.5 1.5
+		final int LINESIZE=150;
+		float size=len/LINESIZE;
+		boolean showprogress=true; // Keep this so that we can later decide whether to make it switchable
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+		if(showprogress){
+			pbf.showMainTask = false;
+			pbf.setTask(h,&quot;Importing DB&quot;);
+			pbf.exec();
+		}
+		// Each line is about 150 chars
+		int progressInt=(int) len/LINESIZE/100;
+		int nextProgress=0;
+		int idx;
+		String line;
+		ln=0; // Line No
+		try {
+			while((line=r.readLine())!=null) {
+				ln++;
+				CacheHolder ch=new CacheHolder();
+				// &quot;cachename by owner&quot;
+				i=line.indexOf(&quot;\&quot;&quot;);
+				j=line.indexOf(&quot;\&quot;&quot;,i+1);
+				String name=line.substring(i+1,j);
+				i=name.indexOf(&quot; by &quot;);
+				if (i&gt;0) {
+					ch.cacheName=SafeXML.cleanback(name.substring(0,i));
+					ch.cacheOwner=SafeXML.cleanback(name.substring(i+4));
+				} else {
+					ch.cacheName=SafeXML.cleanback(name);
+				}
+				// date hidden: Y M D
+				StringBuffer sb=new StringBuffer(12);
+				sb.append(line.substring(j+2,j+6)).append(&quot;-&quot;);
+				i=line.indexOf(&quot; &quot;,j+7);
+				if (j+8==i) sb.append(&quot;0&quot;);
+				sb.append(line.substring(j+7,i)).append(&quot;-&quot;);
+				j=line.indexOf(&quot; &quot;,i+1);
+				if (i+2==j) sb.append(&quot;0&quot;);
+				sb.append(line.substring(i+1,j));
+				ch.dateHidden=sb.toString();
+				// lat lon
+				i=line.indexOf(&quot; &quot;,j+1);
+				double lat=Common.parseDouble(line.substring(j+1,i));
+				j=line.indexOf(&quot; &quot;,i+1);
+				ch.pos=new CWPoint(lat,Common.parseDouble(line.substring(i+1,j)));
+				ch.latLon=ch.pos.toString();
+				// Type
+				i=line.indexOf(&quot;\&quot;&quot;,i+1);
+				j=line.indexOf(&quot;\&quot;&quot;,i+1);
+				ch.type=CacheType.typeText2Number(line.substring(i+1,j));
+				// Size
+				i=line.indexOf(&quot;\&quot;&quot;,j+1);
+				j=line.indexOf(&quot;\&quot;&quot;,i+1);
+				ch.cacheSize=line.substring(i+1,j);
+				//waypoint
+				i=line.indexOf(&quot; &quot;,j+1);
+				j=line.indexOf(&quot; &quot;,i+1);
+				ch.wayPoint=line.substring(i+1,j);
+				// skip ID
+				i=line.indexOf(&quot; &quot;,j+1);
+				// diff terrain
+				j=line.indexOf(&quot; &quot;,i+1);
+				ch.hard=line.substring(i+1,j);
+				ch.terrain=line.substring(j+1);
+				idx=searchWpt(ch.wayPoint);
+				if (idx&lt;0)
+					cacheDB.add(ch);
+				else
+					((CacheHolder)cacheDB.get(idx)).update(ch);
+				ch=null;
+				if(showprogress &amp;&amp; ln&gt;=nextProgress){
+					h.progress = (float)ln/size;
+					h.changed();
+					nextProgress+=progressInt;
+				}
+			}
+		} catch(Exception ex) {}
+		if(showprogress) pbf.exit(0);
+	}
+	
+	private int searchWpt(String wpt){
+		Integer INTR = (Integer)DBindex.get(wpt);
+		if(INTR != null){
+			return INTR.intValue();
+		} 
+		return -1;
+	}
+}

Added: experiments/EVE/src/cachewolf/imp/GPXImporter.java
===================================================================
--- experiments/EVE/src/cachewolf/imp/GPXImporter.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/imp/GPXImporter.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,579 @@
+package cachewolf.imp;
+
+import ewesoft.xml.*;
+import ewesoft.xml.sax.*;
+import eve.sys.*;
+import eve.ui.MessageBox;
+import java.util.*;
+import java.util.zip.*;
+
+import cachewolf.CacheHolder;
+import cachewolf.CacheHolderDetail;
+import cachewolf.CacheType;
+import cachewolf.Filter;
+import cachewolf.InfoBox;
+import cachewolf.Log;
+import cachewolf.MyLocale;
+import cachewolf.Preferences;
+import cachewolf.Profile;
+import cachewolf.Travelbug;
+import cachewolf.utils.Common;
+import cachewolf.utils.Extractor;
+import cachewolf.utils.ParseLatLon;
+import cachewolf.utils.SafeXML;
+
+
+import eve.ui.Form;
+
+/**
+*	Class to import Data from an GPX File. If cache data exists, the data from
+*	the GPX-File is ignored.
+*	Class ID = 4000
+*/
+public class GPXImporter extends MinML {
+
+	static Preferences pref;
+	Profile profile;
+	Vector cacheDB;
+	CacheHolderDetail chD;
+	String strData, saveDir, logData, logIcon, logDate, logFinder;
+	boolean inWpt, inCache, inLogs, inBug;
+	public XMLElement document;
+	private Vector files = new Vector();
+	private boolean debugGPX = false;
+	InfoBox infB;
+	boolean spiderOK = true;
+	boolean doSpider = false;
+	boolean fromOC = false;
+	boolean fromTC = false;
+	int zaehlerGel = 0;
+	Hashtable DBindex = new Hashtable();
+	public static final int DOIT_ASK = 0;
+	public static final int DOIT_NOSPOILER = 1;
+	public static final int DOIT_WITHSPOILER = 2;
+	boolean getMaps = false;
+	SpiderGC imgSpider;
+	StringBuffer strBuf;
+
+	public GPXImporter(Preferences p, Profile prof, String f )
+	{
+		profile=prof;
+		pref = p;
+		cacheDB = profile.cacheDB;
+		//file = f;
+		files.add(f);
+		saveDir = profile.dataDir;
+		//msgA = msgArea;
+		inWpt = false;
+		inCache = false;
+		inLogs = false;
+		inBug =false;
+		//index db for faster search
+		CacheHolder ch;
+		for(int i = 0; i&lt;cacheDB.size();i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			DBindex.put(ch.wayPoint, new Integer(i));
+		}//for
+	}
+/*	skg: This Constructor is not referenced, therefore commented out
+	public GPXImporter(Vector DB, String[] f,String d, Preferences p)
+	{
+		pref = p;
+		cacheDB = DB;
+		saveDir = pref.mydatadir;
+		for (int i=0;i&lt;f.length;i++){
+			files.add(d + &quot;/&quot; + f[i]);
+		}
+
+		//msgA = msgArea;
+		inWpt = false;
+		inCache = false;
+		inLogs = false;
+		inBug =false;
+		strData = new String();
+		//index db for faster search
+		CacheHolder ch;
+		for(int i = 0; i&lt;cacheDB.size();i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			DBindex.put((String)ch.wayPoint, new Integer(i));
+		}//for
+	}
+*/
+	public void doIt(int how){
+		Filter flt = new Filter();
+		boolean wasFiltered = (profile.filterActive==Filter.FILTER_ACTIVE);		flt.clearFilter();
+		try {
+			java.io.Reader r;
+			String file;
+
+			OCXMLImporterScreen options = new OCXMLImporterScreen(&quot;Spider Options&quot;, OCXMLImporterScreen.IMAGES);
+			if (options.execute() == OCXMLImporterScreen.IDCANCEL) {	return; }
+			//String dist = options.distanceInput.getText();
+			//if (dist.length()== 0) return;
+			//getMaps = options.mapsCheckBox.getState();
+			boolean getImages = options.imagesCheckBox.getState();
+			doSpider = false;
+			if(getImages){
+				doSpider = true;
+				imgSpider = new SpiderGC(pref, profile, false);
+			}
+			options.close(0);
+
+			//Vm.debug(&quot;State of: &quot; + doSpider);
+			Form.showWait();
+			for (int i=0; i&lt;files.size();i++){
+				//Test for zip.file
+				file = (String)files.get(i);
+				if (file.indexOf(&quot;.zip&quot;) &gt; 0){
+					ZipFile zif = new ZipFile (file);
+					ZipEntry zipEnt;
+					Enumeration zipEnum = zif.entries();
+					// there could be more than one file in the archive
+					while (zipEnum.hasMoreElements())
+					{
+						zipEnt = (ZipEntry) zipEnum.nextElement();
+						// skip over PRC-files
+						if (zipEnt.getName().endsWith(&quot;gpx&quot;)){
+							r = new java.io.InputStreamReader(zif.getInputStream(zipEnt));
+							infB = new InfoBox(zipEnt.toString(),(MyLocale.getMsg(4000,&quot;Loaded caches&quot;) + zaehlerGel));
+							infB.exec();
+							parse(r);
+							r.close();
+							infB.close(0);
+						}
+					}
+				}
+				else {
+					r = new java.io.InputStreamReader(new java.io.FileInputStream(file));
+					infB = new InfoBox(&quot;Info&quot;,(MyLocale.getMsg(4000,&quot;Loaded caches&quot;) + zaehlerGel));
+					infB.show();
+					parse(r);
+					r.close();
+					infB.close(0);
+				}
+				// save Index
+				profile.saveIndex(Profile.SHOW_PROGRESS_BAR);
+				infB.close(0);
+			}
+			Form.cancelWait();
+		}catch(Exception e){
+			e.printStackTrace();
+			Form.cancelWait();
+		}
+		if(wasFiltered){
+			flt.setFilter();
+			flt.doFilter();
+		}
+	}
+
+	public void startElement(String name, AttributeList atts){
+		strBuf=new StringBuffer(300);
+		if (name.equals(&quot;gpx&quot;)){
+			// check for opencaching
+			if (atts.getValue(&quot;creator&quot;).indexOf(&quot;opencaching&quot;)&gt; 0) fromOC = true;
+			else fromOC = false;
+			if (atts.getValue(&quot;creator&quot;).startsWith(&quot;TerraCaching&quot;)) fromTC = true;
+			else fromTC = false;
+
+			if (fromOC &amp;&amp; doSpider) (new MessageBox(&quot;Warnung&quot;, MyLocale.getMsg(4001, &quot;GPX files from opencaching don't contain information of images, they cannot be laoded. Best you get caches from opencaching by menu /Application/Import/Download from Opencaching&quot;), Form.OKB)).execute();
+			zaehlerGel = 0;
+		}
+		if (name.equals(&quot;wpt&quot;)) {
+			chD = new CacheHolderDetail();
+			chD.pos.set(Common.parseDouble(atts.getValue(&quot;lat&quot;)),Common.parseDouble(atts.getValue(&quot;lon&quot;)));
+			chD.latLon=chD.pos.toString();
+			inWpt = true;
+			inLogs = false;
+			inBug = false;
+			zaehlerGel++;
+			infB.setInfo(MyLocale.getMsg(4000,&quot;Loaded caches: &quot;) + zaehlerGel);
+			return;
+		}
+
+		if (name.equals(&quot;link&quot;)&amp;&amp; inWpt){
+			chD.URL = atts.getValue(&quot;href&quot;);
+			return;
+		}
+
+		if (name.equals(&quot;groundspeak:cache&quot;)) {
+			inCache = true;
+			if (atts.getValue(&quot;available&quot;).equals(&quot;True&quot;))
+				chD.is_available = true;
+			else
+				chD.is_available = false;
+			if (atts.getValue(&quot;archived&quot;).equals(&quot;True&quot;))
+				chD.is_archived = true;
+			else
+				chD.is_archived = false;
+			return;
+		}
+
+		if (name.equals(&quot;geocache&quot;)) {
+			inCache=true;
+			// get status
+			String status = new String(atts.getValue(&quot;status&quot;));
+			chD.is_available = false;
+			chD.is_archived = false;
+			if (status.equals(&quot;Available&quot;)) chD.is_available = true;
+			if (status.equals(&quot;Unavailable&quot;)) chD.is_available = false;
+			if (status.equals(&quot;Draft&quot;)) chD.is_available = false;
+			if (status.equals(&quot;Archived&quot;)) chD.is_archived = true;
+			return;
+		}
+
+		if (name.equals(&quot;terra:terracache&quot;)) {
+			inCache=true;
+		}
+
+
+		if (name.equals(&quot;groundspeak:long_description&quot;)) {
+			if (atts.getValue(&quot;html&quot;).toLowerCase().equals(&quot;true&quot;))
+				chD.is_HTML= true;
+			else
+				chD.is_HTML = false;
+
+		}
+		if (name.equals(&quot;description&quot;) || name.equals(&quot;terra:description&quot;) ) {
+			//set HTML always to true if from oc.de or TC
+			chD.is_HTML= true;
+		}
+
+		if (name.equals(&quot;groundspeak:logs&quot;) || name.equals(&quot;log&quot;) || name.equals(&quot;terra:logs&quot;)) {
+			inLogs = true;
+			return;
+		}
+		if (name.equals(&quot;groundspeak:travelbugs&quot;)) {
+			inBug = true;
+			return;
+		}
+		if (debugGPX){
+			for (int i = 0; i &lt; atts.getLength(); i++) {
+				Vm.debug(&quot;Type: &quot; + atts.getType(i) + &quot; Name: &quot; + atts.getName(i)+ &quot; Value: &quot;+atts.getValue(i));
+			}
+		}
+	}
+
+	public void endElement(String name){
+		strData=strBuf.toString();
+		//Vm.debug(&quot;Ende: &quot; + name);
+
+		// logs
+		if (inLogs){
+			if (name.equals(&quot;groundspeak:date&quot;)|| name.equals(&quot;time&quot;)|| name.equals(&quot;terra:date&quot;))  {
+				logDate = new String(strData.substring(0,10));
+				return;
+			}
+			if (name.equals(&quot;groundspeak:type&quot;) || name.equals(&quot;type&quot;) || name.equals(&quot;terra:type&quot;)){
+				logIcon = new String(typeText2Image(strData));
+				return;
+			}
+			if (name.equals(&quot;groundspeak:finder&quot;)|| name.equals(&quot;geocacher&quot;)|| name.equals(&quot;terra:user&quot;)){
+				logFinder = new String(strData);
+				return;
+			}
+			if (name.equals(&quot;groundspeak:text&quot;) || name.equals(&quot;text&quot;) || name.equals(&quot;terra:entry&quot;)){
+				logData = new String(strData);
+				return;
+			}
+			if (name.equals(&quot;groundspeak:log&quot;) || name.equals(&quot;log&quot;) || name.equals(&quot;terra:log&quot;) ) {
+				chD.cacheLogs.add(new Log(logIcon,logDate,logFinder,logData));
+				if(logIcon.equals(&quot;icon_smile.gif&quot;) &amp;&amp;
+						  (logFinder.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; logFinder.equalsIgnoreCase(pref.myAlias2)))) {
+							chD.cacheStatus=logDate;
+							chD.is_found=true;
+				}
+				return;
+			}
+		}
+
+		if (name.equals(&quot;wpt&quot;)){
+			// Add cache Data only, if waypoint not already in database
+			//if (searchWpt(cacheDB,chD.wayPoint)== -1){
+			int index=searchWpt(chD.wayPoint);
+			//Vm.debug(&quot;here ?!?!?&quot;);
+			//Vm.debug(&quot;chould be new!!!!&quot;);
+			if (index == -1){
+				chD.noFindLogs=chD.cacheLogs.countNotFoundLogs();
+				chD.is_new = true;
+				cacheDB.add(new CacheHolder(chD));
+				// don't spider additional waypoints, so check
+				// if waypoint starts with &quot;GC&quot;
+				if(doSpider == true) {
+					if(spiderOK == true &amp;&amp; chD.is_archived == false){
+							if(chD.latLon.length() &gt; 1){
+							if(getMaps){
+								ParseLatLon pll = new ParseLatLon(chD.latLon,&quot;.&quot;);
+								pll.parse();
+								//MapLoader mpl = new MapLoader(pref.myproxy, pref.myproxyport);
+								//mpl.loadTo(profile.dataDir + &quot;/&quot; +chD.wayPoint + &quot;_map.gif&quot;, &quot;3&quot;);
+								//mpl.loadTo(profile.dataDir + &quot;/&quot; + chD.wayPoint + &quot;_map_2.gif&quot;, &quot;10&quot;);
+							}
+						}
+					if(chD.wayPoint.startsWith(&quot;GC&quot;)|| fromTC) {
+						//spiderImages();
+						spiderImagesUsingSpider();
+						//Rename image sources
+						String text;
+						String orig;
+						String imgName;
+						orig = chD.longDescription;
+						Extractor ex = new Extractor(orig, &quot;&lt;img src=\&quot;&quot;, &quot;&gt;&quot;, 0, false);
+						text = ex.findNext();
+						int num = 0;
+						while(ex.endOfSearch() == false &amp;&amp; spiderOK == true){
+							//Vm.debug(&quot;Replacing: &quot; + text);
+							if (num &gt;= chD.imagesText.size())break;
+							imgName = (String)chD.imagesText.get(num);
+							chD.longDescription = replace(chD.longDescription, text, &quot;[[Image: &quot; + imgName + &quot;]]&quot;);
+							num++;
+							text = ex.findNext();
+						}
+					}
+
+					}
+				}
+				chD.saveCacheDetails(saveDir);
+				//crw.saveIndex(cacheDB,saveDir);
+			}
+			//Update cache data
+			else {
+				//Vm.debug(&quot;it is not new!&quot;);
+				CacheHolderDetail oldCh= new CacheHolderDetail((CacheHolder) cacheDB.get(index));
+				try {
+					//Vm.debug(&quot;Try to load&quot;);
+					oldCh.readCache(saveDir);
+					//Vm.debug(&quot;Done loading&quot;);
+				} catch (Exception e) {Vm.debug(&quot;Could not open file: &quot; + e.toString());};
+				oldCh.update(chD);
+				oldCh.saveCacheDetails(saveDir);
+				cacheDB.setElementAt(new CacheHolder(oldCh),index);
+				//crw.saveIndex(cacheDB,saveDir);
+			}
+
+			inWpt = false;
+			return;
+		}
+		if (name.equals(&quot;sym&quot;)&amp;&amp; strData.endsWith(&quot;Found&quot;)) {
+			chD.is_found = true;
+			chD.cacheStatus = MyLocale.getMsg(318,&quot;Found&quot;);
+			return;
+		}
+		if (name.equals(&quot;groundspeak:travelbugs&quot;)) {
+			inBug = false;
+			return;
+		}
+
+		if (name.equals(&quot;groundspeak:name&quot;)&amp;&amp; inBug) {
+			Travelbug tb=new Travelbug(strData);
+			chD.travelbugs.add(tb);
+			//chD.Bugs += &quot;&lt;b&gt;Name:&lt;/b&gt; &quot; + strData + &quot;&lt;br&gt;&lt;hr&gt;&quot;;
+			chD.has_bug = true;
+			return;
+		}
+
+		if (name.equals(&quot;time&quot;) &amp;&amp; inWpt) {
+			//String Date = new String();
+			//Date = strData.substring(5,7); // month
+			//Date += &quot;/&quot; + strData.substring(8,10); // day
+			//Date += &quot;/&quot; + strData.substring(0,4); // year
+			chD.dateHidden = strData.substring(0,10); //Date;
+			return;
+		}
+		// cache information
+		if (name.equals(&quot;groundspeak:cache&quot;) || name.equals(&quot;geocache&quot;)|| name.equals(&quot;terra:terracache&quot;)) {
+			inCache = false;
+		}
+
+		if (name.equals(&quot;name&quot;) &amp;&amp; inWpt &amp;&amp; !inCache) {
+			chD.wayPoint = strData;
+			//msgA.setText(&quot;import &quot; + strData);
+			return;
+		}
+		//Vm.debug(&quot;Check: &quot; + inWpt + &quot; / &quot; + fromOC);
+		//if (name.equals(&quot;desc&quot;) &amp;&amp; inWpt &amp;&amp; fromOC) {
+		// fill name with contents of &lt;desc&gt;, in case of gc.com the name is
+		// later replaced by the contents of &lt;groundspeak:name&gt; which is shorter
+		if (name.equals(&quot;desc&quot;)&amp;&amp; inWpt ) {
+			chD.cacheName = strData;
+			//Vm.debug(&quot;CacheName: &quot; + strData);
+			//msgA.setText(&quot;import &quot; + strData);
+			return;
+		}
+		if (name.equals(&quot;url&quot;)&amp;&amp; inWpt){
+			chD.URL = strData;
+			return;
+		}
+
+		// Text for additional waypoints, no HTML
+		if (name.equals(&quot;cmt&quot;)&amp;&amp; inWpt){
+			chD.longDescription = strData;
+			chD.is_HTML = false;
+			return;
+		}
+
+		// aditional wapypoint
+		if (name.equals(&quot;type&quot;)&amp;&amp; inWpt &amp;&amp; !inCache &amp;&amp; strData.startsWith(&quot;Waypoint&quot;)){
+			chD.type= CacheType.typeText2Number(strData);
+			chD.cacheSize = &quot;None&quot;;
+		}
+
+
+		if ((name.equals(&quot;groundspeak:name&quot;)|| name.equals(&quot;terra:name&quot;)) &amp;&amp; inCache) {
+			chD.cacheName = strData;
+			return;
+		}
+		if (name.equals(&quot;groundspeak:owner&quot;) || name.equals(&quot;owner&quot;)||name.equals(&quot;terra:owner&quot;)) {
+			chD.cacheOwner = strData;
+			if(pref.myAlias.equals(strData)) chD.is_owned = true;
+			return;
+		}
+		if (name.equals(&quot;groundspeak:difficulty&quot;) || name.equals(&quot;difficulty&quot;) || name.equals(&quot;terra:mental_challenge&quot;)) {
+			chD.hard = strData.replace('.',',');
+			return;
+		}
+		if (name.equals(&quot;groundspeak:terrain&quot;)|| name.equals(&quot;terrain&quot;)|| name.equals(&quot;terra:physical_challenge&quot;)) {
+			chD.terrain = strData.replace('.',',');
+			return;
+		}
+		if ((name.equals(&quot;groundspeak:type&quot;) || name.equals(&quot;type&quot;)|| name.equals(&quot;terra:style&quot;))&amp;&amp; inCache){
+			chD.type= CacheType.typeText2Number(strData);
+			return;
+		}
+		if (name.equals(&quot;groundspeak:container&quot;)|| name.equals(&quot;container&quot;)){
+			chD.cacheSize = strData;
+			return;
+		}
+
+		if (name.equals(&quot;terra:size&quot;)){
+			chD.cacheSize = TCSizetoText(strData);
+		}
+
+		if (name.equals(&quot;groundspeak:short_description&quot;)|| name.equals(&quot;summary&quot;)) {
+			if (chD.is_HTML)	chD.longDescription =SafeXML.cleanback(strData)+&quot;&lt;br&gt;&quot;; // &lt;br&gt; needed because we also use a &lt;br&gt; in SpiderGC. Without it the comparison in ch.update fails
+			else chD.longDescription =strData+&quot;\n&quot;;
+			return;
+		}
+
+		if (name.equals(&quot;groundspeak:long_description&quot;)|| name.equals(&quot;description&quot;)|| name.equals(&quot;terra:description&quot;)) {
+			if (chD.is_HTML)	chD.longDescription +=SafeXML.cleanback(strData);
+			else chD.longDescription +=strData;
+			return;
+		}
+		if (name.equals(&quot;groundspeak:encoded_hints&quot;) || name.equals(&quot;hints&quot;)) {
+			chD.hints = Common.rot13(strData);
+			return;
+		}
+
+		if (name.equals(&quot;terra:hint&quot;)) {
+			// remove &quot;&lt;br&gt;&lt;br&gt;&quot; from the end
+			int indexTrash = strData.indexOf(&quot;&lt;br&gt;&lt;br&gt;&quot;);
+			if (indexTrash &gt; 0)	chD.hints = Common.rot13(strData.substring(0,indexTrash));
+			return;
+		}
+
+
+	}
+	public void characters(char[] ch,int start,int length){
+		strBuf.append(ch,start,length);
+		if (debugGPX) Vm.debug(&quot;Char: &quot; + strBuf.toString());
+	}
+
+
+	public static String typeText2Image(String typeText){
+		if (typeText.equals(&quot;Found it&quot;)||typeText.equals(&quot;Found&quot;)||typeText.equals(&quot;find&quot;)) return &quot;icon_smile.gif&quot;;
+		if (typeText.equals(&quot;Didn't find it&quot;)||typeText.equals(&quot;Not Found&quot;)||typeText.equals(&quot;no_find&quot;)) return &quot;icon_sad.gif&quot;;
+		if (typeText.equals(&quot;Write note&quot;)||typeText.equals(&quot;Note&quot;)||typeText.equals(&quot;note&quot;)
+			||typeText.equals(&quot;Not Attempted&quot;)||typeText.equals(&quot;Other&quot;)) return &quot;icon_note.gif&quot;;
+		if (typeText.equals(&quot;Enable Listing&quot;)) return &quot;icon_enabled.gif&quot;;
+		if (typeText.equals(&quot;Temporarily Disable Listing&quot;)) return &quot;icon_disabled.gif&quot;;
+		if (typeText.equals(&quot;Webcam Photo Taken&quot;)) return &quot;11.png&quot;;
+		if (typeText.equals(&quot;Attended&quot;)) return &quot;icon_attended.gif&quot;;
+		if (typeText.equals(&quot;Publish Listing&quot;)) return &quot;green.png&quot;;
+		if (typeText.equals(&quot;Will Attend&quot;)) return &quot;icon_rsvp.gif&quot;;
+		if (typeText.equals(&quot;Post Reviever Note&quot;)) return &quot;big_smile.gif&quot;;
+		if (typeText.equals(&quot;Unarchive&quot;)) return &quot;traffic_cone.gif&quot;;
+		if (typeText.equals(&quot;Archive (show)&quot;)) return &quot;traffic_cone.gif&quot;;
+		if (typeText.equals(&quot;Owner Maintenance&quot;)) return &quot;icon_maint.gif&quot;;
+		if (typeText.equals(&quot;Needs Maintenance&quot;)) return &quot;icon_needsmaint.gif&quot;;
+		if (typeText.equals(&quot;Update Coordinates&quot;)) return &quot;coord_update.gif&quot;;
+		//Vm.debug(&quot;Unknown Log Type:&quot; + typeText);
+		return typeText;
+	}
+
+	public static String TCSizetoText(String size){
+		if (size.equals(&quot;1&quot;)) return &quot;Micro&quot;;
+		if (size.equals(&quot;2&quot;)) return &quot;Medium&quot;;
+		if (size.equals(&quot;3&quot;)) return &quot;Regular&quot;;
+		if (size.equals(&quot;4&quot;)) return &quot;Large&quot;;
+		if (size.equals(&quot;5&quot;)) return &quot;Very Large&quot;;
+
+		return &quot;None&quot;;
+	}
+
+	/**
+	* Method to iterate through cache database and look for waypoint.
+	* Returns value &gt;= 0 if waypoint is found, else -1
+	*/
+	/*
+	private int searchWpt(Vector db, String wpt){
+		if(wpt.length()&gt;0){
+			wpt = wpt.toUpperCase();
+			CacheHolder ch = new CacheHolder();
+			//Search through complete database
+			for(int i = 0;i &lt; db.size();i++){
+				ch = (CacheHolder)db.get(i);
+				if(ch.wayPoint.indexOf(wpt) &gt;=0 ){
+					return i;
+				}
+			} // for
+		} // if
+		return -1;
+	}
+	*/
+
+	private int searchWpt(String wpt){
+		Integer INTR = (Integer)DBindex.get(wpt);
+		if(INTR != null){
+			return INTR.intValue();
+		}
+		return -1;
+	}
+	private void spiderImagesUsingSpider(){
+		String addr;
+		String cacheText;
+
+		// just to be sure to have a spider object
+		if (imgSpider == null) imgSpider = new SpiderGC(pref, profile, false);
+
+		if (fromTC) {
+				imgSpider.getImages(chD.longDescription, chD);
+		}
+		else {
+			addr = &quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot; + chD.wayPoint ;
+			//Vm.debug(addr + &quot;|&quot;);
+			cacheText = SpiderGC.fetch(addr);
+			imgSpider.getImages(cacheText, chD);
+		}
+	}
+
+	public static String replace(String source, String pattern, String replace){
+		if (source!=null)
+		{
+			final int len = pattern.length();
+			StringBuffer sb = new StringBuffer();
+			int found = -1;
+			int start = 0;
+
+			while( (found = source.indexOf(pattern, start) ) != -1) {
+			    sb.append(source.substring(start, found));
+			    sb.append(replace);
+			    start = found + len;
+			}
+
+			sb.append(source.substring(start));
+
+			return sb.toString();
+		}
+		return &quot;&quot;;
+	}
+}

Added: experiments/EVE/src/cachewolf/imp/KMLImporter.java
===================================================================
--- experiments/EVE/src/cachewolf/imp/KMLImporter.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/imp/KMLImporter.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,93 @@
+package cachewolf.imp;
+
+import ewesoft.xml.*;
+import java.util.*;
+import ewesoft.xml.sax.*;
+import java.io.*;
+
+import cachewolf.CWPoint;
+
+import eve.sys.*;
+import eve.ui.Form;
+
+/**
+ * Class to import coordinates from a KML file generated from
+ * google earth.
+ * it looks for &lt;placemark&gt;&lt;MultiGeometry&gt;&lt;LineString&gt;&lt;coordinates&gt;
+ * and gathers all coordinated in a vector
+ * @author Bilbowolf
+ *
+ */
+public class KMLImporter extends MinML {
+	
+	public Vector points = new Vector();
+	private CWPoint point = new CWPoint();
+	private String file = &quot;&quot;;
+	String strData = &quot;&quot;;
+	private int status = 0;
+	private static int MultiGeometry = 1;
+	private static int LineString = 2;
+	private static int coordinates = 3;
+	
+	public KMLImporter(String file){
+		this.file = file;
+	}
+	
+	public void importFile() {
+		try{
+			Reader r;
+			Form.showWait();
+			r = new FileReader(file);
+			parse(r);
+			r.close();
+			Form.cancelWait();
+		}catch(Exception e){
+			//Vm.debug(e.toString());
+			Form.cancelWait();
+		}
+	}
+	
+	public Vector getPoints(){
+		return points;
+	}
+	
+	public void startElement(String name, AttributeList atts){
+		strData = &quot;&quot;;
+		if(name.equals(&quot;MultiGeometry&quot;)) status = MultiGeometry;
+		if(name.equals(&quot;LineString&quot;) &amp;&amp; status == MultiGeometry) status = LineString;
+		if(name.equals(&quot;coordinates&quot;) &amp;&amp; status == LineString) status = coordinates;
+	}
+	
+	public void endElement(String name){
+		if(name.equals(&quot;coordinates&quot;) &amp;&amp; status == coordinates){
+			parseCoordinatesLine();
+			//10.09052,49.78188000000001,0
+		}
+		if(name.equals(&quot;LineString&quot;) &amp;&amp; status == coordinates) status = LineString;
+		if(name.equals(&quot;MultiGeometry&quot;) &amp;&amp; status == LineString) status = 0;
+	}
+	
+	public void characters(char[] ch,int start,int length){
+		String chars = new String(ch,start,length);
+		strData += chars;
+	}
+	
+	private void parseCoordinatesLine(){
+		StringTokenizer exBlock = new StringTokenizer(strData, &quot; &quot;);
+		StringTokenizer numbers;
+		String lat, lon;
+		String test;
+		
+		while(exBlock.hasMoreTokens()){
+			test = exBlock.nextToken();
+			//Vm.debug(&quot;==&gt; &quot; + test + &quot; &lt;==&quot;);
+			numbers = new StringTokenizer(test, &quot;,&quot;);
+			//Vm.debug(numbers.nextToken());
+			//Vm.debug(numbers.nextToken());
+			lon = numbers.nextToken();
+			lat = numbers.nextToken();
+			point = new CWPoint(Convert.parseDouble(lat),Convert.parseDouble(lon));
+			points.add(point);
+		}
+	}
+}
\ No newline at end of file

Added: experiments/EVE/src/cachewolf/imp/LOCXMLImporter.java
===================================================================
--- experiments/EVE/src/cachewolf/imp/LOCXMLImporter.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/imp/LOCXMLImporter.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,177 @@
+    /*
+    CacheWolf is a software for PocketPC, Win and Linux that 
+    enables paperless caching. 
+    It supports the sites geocaching.com and opencaching.de
+    
+    Copyright (C) 2006  CacheWolf development team
+    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+    for more information.
+    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+    */
+
+package cachewolf.imp;
+
+import eve.sys.Vm;
+import java.util.*;
+import java.io.*;
+
+import cachewolf.CacheHolder;
+import cachewolf.CacheHolderDetail;
+import cachewolf.Profile;
+import cachewolf.utils.Common;
+
+
+import ewesoft.xml.MinML;
+import ewesoft.xml.sax.AttributeList;
+import eve.ui.Form;
+
+/**
+ * @author Kalle
+ *
+ */
+public class LOCXMLImporter extends MinML {
+	boolean debugXML = false;
+	Vector cacheDB;
+	Profile profile;
+	String file;
+	CacheHolderDetail chD;
+
+	Hashtable DBindexWpt = new Hashtable();
+	String strData = &quot;&quot;;
+
+	
+	public LOCXMLImporter ( Profile prof, String f ){
+		profile=prof;
+		cacheDB = profile.cacheDB;
+		file = f;
+		CacheHolder ch;
+		for(int i = 0; i&lt;cacheDB.size();i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			DBindexWpt.put(ch.wayPoint, new Integer(i));
+		}//for
+	}
+	
+	public void doIt() {
+		try{
+			Reader r;
+			Form.showWait();
+			//Test for zip.file
+						r = new FileReader(file);
+						parse(r);
+						r.close();
+			// save Index 
+			profile.saveIndex(Profile.NO_SHOW_PROGRESS_BAR);
+			Form.cancelWait();
+		}catch(Exception e){
+			//Vm.debug(e.toString());
+			Form.cancelWait();
+		}
+		
+	}
+	
+	public void startElement(String name, AttributeList atts){
+		if (debugXML){
+			for (int i = 0; i &lt; atts.getLength(); i++) {
+				Vm.debug(&quot; Name: &quot; + atts.getName(i)+ &quot; Value: &quot;+atts.getValue(i));
+			}
+		}
+		strData =&quot;&quot;;
+		if (name.equals(&quot;name&quot;)){
+			chD = getHolder(atts.getValue(&quot;id&quot;));
+			return;
+		}
+		if (name.equals(&quot;coord&quot;)){
+			chD.pos.set(Common.parseDouble(atts.getValue(&quot;lat&quot;)),Common.parseDouble(atts.getValue(&quot;lon&quot;)));
+			chD.latLon = chD.pos.toString();
+			return;
+		}
+
+		
+	}
+	
+	public void endElement(String name){
+		if (name.equals(&quot;name&quot;)){
+			chD.cacheName = strData;
+		}
+
+		if (name.equals(&quot;waypoint&quot;)){
+			int index;
+			index = searchWpt(chD.wayPoint);
+			if (index == -1){
+				chD.is_new = true;
+				cacheDB.add(new CacheHolder(chD));
+				DBindexWpt.put(chD.wayPoint, new Integer(cacheDB.size()-1));
+			}
+			// update (overwrite) data
+			else {
+				chD.is_new = false;
+				cacheDB.setElementAt(new CacheHolder(chD),index);
+			}
+			// save all  (after each cache???)
+			chD.saveCacheDetails(profile.dataDir);
+			profile.saveIndex(Profile.NO_SHOW_PROGRESS_BAR);
+			return;
+		}
+
+		if (name.equals(&quot;link&quot;)){
+			chD.URL = strData;
+			return;
+		}
+
+
+
+	}
+	
+
+	public void characters(char[] ch,int start,int length){
+		String chars = new String(ch,start,length);
+		strData += chars;
+		if (debugXML) Vm.debug(strData);
+	}
+
+	
+	/**
+	* Method to iterate through cache database and look for waypoint.
+	* Returns value &gt;= 0 if waypoint is found, else -1
+	*/
+	private int searchWpt(String wpt){
+		Integer INTR = (Integer)DBindexWpt.get(wpt);
+		if(INTR != null)
+			return INTR.intValue();
+		return -1;
+	}
+
+	private CacheHolderDetail getHolder(String wpt){// See also OCXMLImporter
+		int index;
+		CacheHolderDetail ch;
+		
+		index = searchWpt(wpt);
+		if (index == -1){
+			ch = new CacheHolderDetail();
+			ch.wayPoint = wpt;
+			return ch;
+		}
+		ch = new CacheHolderDetail((CacheHolder) cacheDB.get(index));
+		try {
+			ch.readCache(profile.dataDir);
+		} catch (Exception e) {Vm.debug(&quot;Could not open file: &quot; + e.toString());};
+		return ch;
+	}
+
+
+}

Added: experiments/EVE/src/cachewolf/imp/OCXMLImporter.java
===================================================================
--- experiments/EVE/src/cachewolf/imp/OCXMLImporter.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/imp/OCXMLImporter.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,772 @@
+package cachewolf.imp;
+
+
+import cachewolf.CWPoint;
+import cachewolf.CacheHolder;
+import cachewolf.CacheHolderDetail;
+import cachewolf.CacheType;
+import cachewolf.InfoBox;
+import cachewolf.Log;
+import cachewolf.MyLocale;
+import cachewolf.Preferences;
+import cachewolf.Profile;
+import cachewolf.URL;
+import cachewolf.UrlFetcher;
+import cachewolf.utils.Common;
+import cachewolf.utils.SafeXML;
+
+import com.stevesoft.eve_pat.Regex;
+
+import ewesoft.xml.*;
+import ewesoft.xml.sax.*;
+import eve.io.*;
+import eve.sys.*;
+import eve.ui.MessageBox;
+import java.util.*;
+import java.util.zip.*;
+import eve.ui.Form;
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.io.IOException;
+import eve.util.ByteArray;
+import java.io.FileOutputStream;
+import java.net.MalformedURLException;
+
+import eve.util.CharArray;
+
+/**
+ *	Class to import Data from opencaching.de. 
+ *	It uses the lastmodified parameter to identify new or changed caches.
+ *	See here: <A HREF="http://www.opencaching.com/phpBB2/viewtopic.php?t=281">http://www.opencaching.com/phpBB2/viewtopic.php?t=281</A> (out-dated)
+ *   See here: <A HREF="http://www.opencaching.de/doc/xml/xml11.htm">http://www.opencaching.de/doc/xml/xml11.htm</A> and <A HREF="http://develforum.opencaching.de/viewtopic.php?t=135&amp;postdays=0&amp;postorder=asc&amp;start=0">http://develforum.opencaching.de/viewtopic.php?t=135&amp;postdays=0&amp;postorder=asc&amp;start=0</A>
+ *	for more information.
+ */
+public class OCXMLImporter extends MinML {
+	static protected final int STAT_INIT = 0;
+	static protected final int STAT_CACHE = 1;
+	static protected final int STAT_CACHE_DESC = 2;
+	static protected final int STAT_CACHE_LOG = 3;
+	static protected final int STAT_PICTURE = 4;
+
+	final static String OPENCACHING_HOST = &quot;www.opencaching.de&quot;;
+	int state = STAT_INIT;
+	int numCacheImported, numDescImported, numLogImported= 0;
+
+	boolean debugGPX = false;
+	Vector cacheDB;
+	InfoBox inf;
+	CacheHolder ch;
+	CacheHolderDetail chD;
+	Preferences pref;
+	Profile profile;
+	Time dateOfthisSync;
+	String strData = &quot;&quot;;
+	int picCnt;
+	boolean incUpdate = true; // complete or incremental Update
+	boolean ignoreDesc = false;
+	boolean askForOptions = true;
+	Hashtable DBindexWpt = new Hashtable();
+	Hashtable DBindexID = new Hashtable();
+
+	String picUrl = &quot;&quot;;
+	String picTitle =  &quot;&quot;;
+	String ocSeekUrl = &quot;<A HREF="http://">http://</A>&quot;+OPENCACHING_HOST+&quot;/viewcache.php?cacheid=&quot;;
+	String cacheID = &quot;&quot;;
+
+	String logData, logIcon, logDate, logFinder;
+	boolean loggerRecommended;
+	int logtype;
+	String user;
+	double longitude;
+
+
+	public OCXMLImporter(Preferences p,Profile prof)
+	{
+		pref = p;
+		profile=prof;
+		cacheDB = profile.cacheDB;
+		if(profile.last_sync_opencaching == null ||
+				profile.last_sync_opencaching.length() &lt; 12){
+			profile.last_sync_opencaching = &quot;20050801000000&quot;;
+			incUpdate = false;
+		}
+		user = p.myAlias.toLowerCase();
+		for(int i = 0; i&lt;cacheDB.size();i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			DBindexWpt.put(ch.wayPoint, new Integer(i));
+			if (!ch.ocCacheID.equals(&quot;&quot;))
+				DBindexID.put(ch.ocCacheID, new Integer(i));
+		}//for
+
+	}
+
+	/** true, if not the last syncdate shall be used, but the caches shall be reloaded
+	 * only used in syncSingle */
+	boolean reload;
+	/**
+	 * 
+	 * @param number
+	 * @param infB
+	 * @return true, if some change was made to the cacheDB
+	 */
+	public boolean syncSingle(int number, InfoBox infB) {
+
+		ch = (CacheHolder)cacheDB.get(number);
+		chD= null; //new CacheHolderDetail(ch); //TODO is this still correct? use getDetails ?
+
+		if (infB.isClosed) {
+			if (askForOptions) 
+				return false; 
+			return true;
+		}
+		if (askForOptions) {
+			OCXMLImporterScreen importOpt = new OCXMLImporterScreen( MyLocale.getMsg(1600, &quot;Opencaching.de Download&quot;),OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.ALL);
+			if (importOpt.execute() == OCXMLImporterScreen.IDCANCEL) {	return false; }
+			askForOptions = false;
+			reload = importOpt.missingCheckBox.getState();
+		}
+
+		// this is only a dummy-InfoBox for capturing the output
+		inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
+//		inf.setPreferredSize(220, 300);
+//		inf.relayout(false);
+//		inf.exec();
+
+		String lastS; 
+		if (reload)  lastS = &quot;20050801000000&quot;;
+		else {
+			if (ch.lastSyncOC.length() &lt; 14) lastS = &quot;20050801000000&quot;;
+			else lastS = ch.lastSyncOC;
+		}
+		dateOfthisSync = new Time();
+		dateOfthisSync.parse(lastS, &quot;yyyyMMddHHmmss&quot;);
+	
+
+		String url = &quot;&quot;;
+		picCnt = 0;
+		//Build url
+		url = &quot;<A HREF="http://">http://</A>&quot; + OPENCACHING_HOST + &quot;/xml/ocxml11.php?&quot;
+			+ &quot;modifiedsince=&quot; + lastS
+			+ &quot;&amp;cache=1&quot;
+			+ &quot;&amp;cachedesc=1&quot;;
+		if (pref.downloadPicsOC) url += &quot;&amp;picture=1&quot;;
+		else url += &quot;&amp;picture=0&quot;;
+		url += &quot;&amp;cachelog=1&quot;
+			+ &quot;&amp;removedobject=0&quot;
+			+ &quot;&amp;wp=&quot; + ch.wayPoint
+			+ &quot;&amp;charset=utf-8&quot;
+			+ &quot;&amp;cdata=0&quot;
+			+ &quot;&amp;session=0&quot;;
+		syncOC(url);
+		inf.close(0);
+		return true;
+	}
+
+	public void doIt(){
+		boolean success=true;
+		String finalMessage;
+
+		
+		String url = &quot;&quot;;
+
+		String lastS =  profile.last_sync_opencaching;
+		CWPoint centre = pref.curCentrePt; // No need to clone curCentrePt as centre is only read
+		if (!centre.isValid()) {
+			(new MessageBox(&quot;Error&quot;, &quot;Coordinates for centre must be set&quot;, MessageBox.OKB)).execute();
+			return;
+		}
+		OCXMLImporterScreen importOpt = new OCXMLImporterScreen( MyLocale.getMsg(1600, &quot;Opencaching.de Download&quot;),
+																 OCXMLImporterScreen.ALL | OCXMLImporterScreen.DIST | OCXMLImporterScreen.IMAGES);
+		if (importOpt.execute() == OCXMLImporterScreen.IDCANCEL) {	return; }
+		Form.showWait();
+		String dist = importOpt.distanceInput.getText();
+		if (dist.length()== 0) return;
+		dist=MyLocale.formatDouble(Common.parseDouble(dist),&quot;00.0&quot;);
+		//check, if distance is greater than before
+		if (Convert.toInt(dist) &gt; Convert.toInt(profile.distOC) ||
+				pref.downloadmissingOC  ){
+			// resysnc
+			lastS = &quot;20050801000000&quot;;
+			incUpdate = false;
+		}
+		profile.distOC = dist;
+		// Clear status of caches in db
+		for(int i = cacheDB.size()-1; i&gt;=0 ;i--){
+			ch = (CacheHolder)cacheDB.get(i);
+			ch.is_update = false;
+			ch.is_new = false;
+			ch.is_log_update = false;
+		}	
+		picCnt = 0;
+		//Build url
+		url = &quot;<A HREF="http://">http://</A>&quot; + OPENCACHING_HOST + &quot;/xml/ocxml11.php?&quot;
+			+ &quot;modifiedsince=&quot; + lastS
+			+ &quot;&amp;cache=1&quot;
+			+ &quot;&amp;cachedesc=1&quot;;
+		if (pref.downloadPicsOC) url += &quot;&amp;picture=1&quot;;
+		else url += &quot;&amp;picture=0&quot;;
+		url += &quot;&amp;cachelog=1&quot;
+			+ &quot;&amp;removedobject=0&quot;
+			+ &quot;&amp;lat=&quot; + centre.getLatDeg(CWPoint.DD)
+			+ &quot;&amp;lon=&quot; + centre.getLonDeg(CWPoint.DD)
+			+ &quot;&amp;distance=&quot; + dist
+			+ &quot;&amp;charset=utf-8&quot;
+			+ &quot;&amp;cdata=0&quot;
+			+ &quot;&amp;session=0&quot;;
+		inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
+		inf.setPreferredSize(220, 300);
+		inf.relayout(false);
+		inf.exec();
+
+		success = syncOC(url);
+		Form.cancelWait();
+		if (success) {
+			profile.last_sync_opencaching = dateOfthisSync.format(&quot;yyyyMMddHHmmss&quot;);
+			//pref.savePreferences();
+			finalMessage = MyLocale.getMsg(1607,&quot;Update from opencaching successful&quot;); 
+			inf.addWarning(&quot;\nNumber of&quot;+
+			&quot;\n...caches new/updated: &quot; + numCacheImported +
+			&quot;\n...cache descriptions new/updated: &quot; + numDescImported +
+			&quot;\n...logs new/updated: &quot; + numLogImported);
+			inf.setInfo(finalMessage);
+		}
+		inf.addOkButton();
+	}
+	
+	private boolean syncOC(String url) {
+		String finalMessage = &quot;&quot;;
+		boolean success=true;
+		File tmpFile = null;
+		BufferedReader r;
+		String file;
+
+		//inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
+		
+		picCnt = 0;
+		try{
+			chD=null;
+			file = fetch(url, &quot;dummy&quot;);
+
+			//parse
+			tmpFile = new File(profile.dataDir + file);
+			if (tmpFile.getLength() == 0 ) {
+				throw new java.io.IOException(&quot;no updates available&quot;);
+			}
+
+			ZipFile zif = new ZipFile (profile.dataDir + file);
+			ZipEntry zipEnt;
+			Enumeration zipEnum = zif.entries();
+			inf.setInfo(&quot;...unzipping update file&quot;); 
+			while (zipEnum.hasMoreElements())
+			{
+				zipEnt = (ZipEntry) zipEnum.nextElement();
+				// skip over PRC-files and empty files
+				if (zipEnt.getSize()&gt; 0 &amp;&amp; zipEnt.getName().endsWith(&quot;xml&quot;)){
+					r = new BufferedReader (new InputStreamReader(zif.getInputStream(zipEnt), &quot;UTF8&quot;));
+					parse(r);
+					r.close();
+				}
+			}
+			zif.close();
+		}catch (ZipException e){
+			finalMessage = MyLocale.getMsg(1614,&quot;Error while unzipping udpate file&quot;);
+			success = false;
+		}catch (java.io.IOException e){
+			if (e.getMessage().equalsIgnoreCase(&quot;no updates available&quot;)) { finalMessage = &quot;No updates available&quot;; success = false; }
+			else {
+				if (e.getMessage().equalsIgnoreCase(&quot;could not connect&quot;) ||
+						e.getMessage().equalsIgnoreCase(&quot;unkown host&quot;)) { // is there a better way to find out what happened?
+					finalMessage = MyLocale.getMsg(1616,&quot;Error: could not download udpate file from opencaching.de&quot;);
+				} else { finalMessage = &quot;IOException: &quot;+e.getMessage(); }
+				success = false;
+			}
+		}catch (IllegalArgumentException e) {
+			finalMessage = MyLocale.getMsg(1621,&quot;Error parsing update file\n this is likely a bug in opencaching.de\nplease try again later\n, state:&quot;)+&quot; &quot;+state+&quot;, waypoint: &quot;+ chD.wayPoint;
+			success = false;
+			Vm.debug(&quot;Parse error: &quot; + state + &quot; &quot; + chD.wayPoint);
+			e.printStackTrace();
+		}catch (Exception e){ // here schould be used the correct exepion
+			if (chD != null)	finalMessage = MyLocale.getMsg(1615,&quot;Error parsing update file, state:&quot;)+&quot; &quot;+state+&quot;, waypoint: &quot;+ chD.wayPoint;
+			else finalMessage = MyLocale.getMsg(1615,&quot;Error parsing update file, state:&quot;)+&quot; &quot;+state+&quot;, waypoint: &lt;unkown&gt;&quot;;
+			success = false;
+			Vm.debug(&quot;Parse error: &quot; + state + &quot; Exception:&quot; + e.toString()+&quot;   &quot;+chD.ocCacheID);
+			e.printStackTrace();
+		} finally {
+			if (tmpFile != null) tmpFile.delete();
+		}
+		/*
+		for (int i=cacheDB.size()-1; i &gt;=0; i--) {
+			ch = (CacheHolder)cacheDB.get(i);
+			if (ch.wayPoint.toUpperCase().startsWith(&quot;OC&quot;)) { //TODO only handle changed caches
+				ch.calcRecommendationScore();
+			}
+		} */
+		profile.saveIndex(Profile.SHOW_PROGRESS_BAR);
+		inf.setInfo(finalMessage);
+
+		return success;
+	}
+
+	public void startElement(String name, AttributeList atts){
+		if (debugGPX){
+			for (int i = 0; i &lt; atts.getLength(); i++) {
+				Vm.debug(&quot; Name: &quot; + atts.getName(i)+ &quot; Value: &quot;+atts.getValue(i));
+			}
+		}
+		strData =&quot;&quot;;
+
+		if (name.equals(&quot;oc11xml&quot;)){
+			Time lastSync = new Time();
+			try {
+				lastSync.parse(atts.getValue(&quot;date&quot;),&quot;yyyy-MM-dd HH:mm:ss&quot;);
+			}catch (IllegalArgumentException e){ // TODO Fehler werfen
+				Vm.debug(e.toString());
+			}
+			// reduce time at 1 second to avoid sync problems
+			lastSync.setTime(lastSync.getTime() - 1000);
+			dateOfthisSync = lastSync;
+			state = STAT_INIT;
+		}
+
+		// look for changes in the state
+		if (name.equals(&quot;cache&quot;)) 		{ state = STAT_CACHE; numCacheImported++;}
+		if (name.equals(&quot;cachedesc&quot;)) 	{ state = STAT_CACHE_DESC; numDescImported++;}
+		if (name.equals(&quot;cachelog&quot;)) 	{ state = STAT_CACHE_LOG; numLogImported++; logtype = 0;}
+		if (name.equals(&quot;picture&quot;)) 	{ state = STAT_PICTURE; }
+
+		//examine data
+		switch (state) {
+		case STAT_CACHE: startCache(name, atts); break;
+		case STAT_CACHE_DESC: startCacheDesc(name, atts); break; 
+		case STAT_CACHE_LOG: startCacheLog(name, atts); break;
+		case STAT_PICTURE: startPicture(name,atts); break;
+		}
+
+	}
+
+	public void endElement(String name){
+		//examine data
+		switch (state) {
+		case STAT_CACHE: endCache(name); break;
+		case STAT_CACHE_DESC: endCacheDesc(name);break;
+		case STAT_CACHE_LOG: endCacheLog(name); break;
+		case STAT_PICTURE: endPicture(name); break;
+		}
+
+		// look for changes in the state
+		if (name.equals(&quot;cache&quot;)) 		state = STAT_INIT;
+		if (name.equals(&quot;cachedesc&quot;)) 	state = STAT_INIT;
+		if (name.equals(&quot;cachelog&quot;)) 	state = STAT_INIT;
+		if (name.equals(&quot;picture&quot;)) 	state = STAT_INIT;
+
+	}
+
+	public void characters(char[] ch,int start,int length){
+		String chars = new String(ch,start,length);
+		strData += chars;
+		if (debugGPX) Vm.debug(strData);
+	}
+
+	private void startCache(String name, AttributeList atts){
+		inf.setInfo(MyLocale.getMsg(1609,&quot;Importing Cache:&quot;)+&quot; &quot; + numCacheImported + &quot;\n&quot;);
+		if(name.equals(&quot;id&quot;)){
+			cacheID = atts.getValue(&quot;id&quot;);
+		}
+		if(name.equals(&quot;type&quot;)){
+			chD.type = CacheType.transOCType(Common.parseInt(atts.getValue(&quot;id&quot;)));
+			return;
+		}
+		if(name.equals(&quot;status&quot;)){
+			if(atts.getValue(&quot;id&quot;).equals(&quot;1&quot;)) chD.is_available = true;
+			if(atts.getValue(&quot;id&quot;).equals(&quot;2&quot;)) chD.is_available = false;
+			if(atts.getValue(&quot;id&quot;).equals(&quot;3&quot;)) {
+				chD.is_archived = true;
+				chD.is_available = false;
+			}
+			if(atts.getValue(&quot;id&quot;).equals(&quot;4&quot;)) chD.is_available = false;
+			return;
+		}
+		if(name.equals(&quot;size&quot;)){
+			chD.cacheSize = transSize(atts.getValue(&quot;id&quot;));
+			return;
+		}
+
+		if(name.equals(&quot;waypoints&quot;)){
+			chD.wayPoint = atts.getValue(&quot;oc&quot;);
+			if (chD.wayPoint.length()==0) throw new IllegalArgumentException(&quot;empty waypointname&quot;); // this should not happen - it is likey a bug in opencaching.de / it happens on 27-12-2006 on cache OC143E
+			return;
+		}
+
+	}
+	private void startCacheDesc(String name, AttributeList atts){
+		inf.setInfo(MyLocale.getMsg(1611,&quot;Importing cache description:&quot;)+&quot; &quot; + numDescImported);
+		if (name.equals(&quot;cachedesc&quot;)){
+			ignoreDesc = false;
+		}
+
+		if (name.equals(&quot;desc&quot;)){
+			chD.is_HTML = atts.getValue(&quot;html&quot;).equals(&quot;1&quot;)?true:false;
+		}
+
+		if (name.equals(&quot;language&quot;) &amp;&amp; !atts.getValue(&quot;id&quot;).equals(&quot;DE&quot;)){
+			if (chD.longDescription.length()&gt; 0) ignoreDesc = true; // TODO &quot;DE&quot; in preferences adjustable
+			else ignoreDesc = false;
+		}
+	}
+
+	private void startPicture(String name, AttributeList atts){
+		if(name.equals(&quot;picture&quot;)){
+			inf.setInfo(MyLocale.getMsg(1613,&quot;Pictures:&quot;)+&quot; &quot; + ++picCnt);
+		}
+	}
+
+	private void startCacheLog(String name, AttributeList atts){
+		inf.setInfo(MyLocale.getMsg(1612,&quot;Importing Cachlog:&quot;)+&quot; &quot; + numLogImported);
+		if (name.equals(&quot;logtype&quot;)){
+			logtype = Convert.toInt(atts.getValue(&quot;id&quot;));
+			switch (logtype) {
+			case 1: 
+				logIcon = GPXImporter.typeText2Image(&quot;Found&quot;); 
+				if (logFinder.equalsIgnoreCase(user) || logFinder.equalsIgnoreCase(pref.myAlias2)) { // see also endCacheLog
+					chD.is_found = true; 
+					chD.cacheStatus = MyLocale.getMsg(318,&quot;Found&quot;);
+				}
+				break;
+			case 2:	logIcon = GPXImporter.typeText2Image(&quot;Not Found&quot;); 
+			chD.noFindLogs += 1;
+			break;
+			case 3: logIcon = GPXImporter.typeText2Image(&quot;Note&quot;);
+			}
+			loggerRecommended = atts.getValue(&quot;recommended&quot;).equals(&quot;1&quot;);
+			return;
+		}
+
+	}
+
+	private void endCache(String name){
+		if (name.equals(&quot;cache&quot;)){
+			chD.lastSyncOC = dateOfthisSync.format(&quot;yyyyMMddHHmmss&quot;);
+			int index;
+			index = searchWpt(chD.wayPoint);
+			if (index == -1){
+				chD.is_new = true;
+				CacheHolder ch = new CacheHolder(chD);
+				ch.details = chD;
+				cacheDB.add(ch);
+				ch.detailsAdded();
+				Integer indexInt = new Integer(cacheDB.size()-1);
+				DBindexWpt.put(chD.wayPoint, indexInt);
+				DBindexID.put(chD.ocCacheID, indexInt);
+			}
+			// update (overwrite) data
+			else {
+				chD.is_new = false;
+				cacheDB.setElementAt( new CacheHolder(chD),index);
+				// save ocCacheID, in case, the previous data is from GPX
+				DBindexID.put(chD.ocCacheID, new Integer(index));
+			}
+			// clear data (picture, logs) if we do a complete Update
+			if (incUpdate == false){
+				chD.cacheLogs.clear();
+				chD.images.clear();
+				chD.imagesText.clear();
+				chD.imagesInfo.clear();
+			}
+
+			// save all
+			chD.hasUnsavedChanges = true; // this makes CachHolder save the details in case that they are unloaded from memory
+			// chD.saveCacheDetails(profile.dataDir); 
+			// profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR); // this is done after .xml is completly processed
+			return;
+		}
+		if(name.equals(&quot;id&quot;)){ // &lt;/id&gt;
+			chD = getHolder(strData); // Allocate a new CacheHolder object
+			chD.ocCacheID=strData;
+			chD.URL = ocSeekUrl + cacheID;
+			return;
+		}
+
+		if(name.equals(&quot;name&quot;)){
+			chD.cacheName = strData;
+			return;
+		}
+		if(name.equals(&quot;userid&quot;)) {
+			chD.cacheOwner = strData;
+			if(chD.cacheOwner.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; chD.cacheOwner.equalsIgnoreCase(pref.myAlias2))) chD.is_owned = true;
+			return;
+		}
+
+		if(name.equals(&quot;longitude&quot;)){
+			longitude = Common.parseDouble(strData);
+			return;
+		}
+		if(name.equals(&quot;latitude&quot;)) {
+			chD.pos.set(Common.parseDouble(strData),longitude);
+			chD.latLon = chD.pos.toString();
+			return;
+		}
+		if(name.equals(&quot;difficulty&quot;)) {
+			chD.hard = strData;
+			return;
+		}
+		if(name.equals(&quot;terrain&quot;)) {
+			chD.terrain = strData;
+			return;
+		}
+		if(name.equals(&quot;datehidden&quot;)) {
+			chD.dateHidden = strData.substring(0,10); //Date;
+			return;
+		}
+	}
+
+	private void endCacheDesc(String name){
+
+		if (!ignoreDesc){
+			if (name.equals(&quot;cachedesc&quot;)){
+				if (pref.downloadPicsOC &amp;&amp; chD.is_HTML) {
+					String fetchUrl, imgTag, imgAltText;
+					Regex imgRegexUrl = new Regex(&quot;(&lt;img[^&gt;]*src=[\&quot;\']([^&gt;^\&quot;^\']*)[^&gt;]*&gt;|&lt;img[^&gt;]*src=([^&gt;^\&quot;^\'^ ]*)[^&gt;]*&gt;)&quot;); //  Ergebnis enth&#228;lt keine Anf&#252;hrungszeichen
+					Regex imgRegexAlt = new Regex(&quot;(?:alt=[\&quot;\']([^&gt;^\&quot;^\']*)|alt=([^&gt;^\&quot;^\'^ ]*))&quot;); // get alternative text for Pic
+					imgRegexAlt.setIgnoreCase(true);
+					imgRegexUrl.setIgnoreCase(true);
+					int descIndex=0;
+					int numDownloaded=1;
+					while (imgRegexUrl.searchFrom(chD.longDescription, descIndex)) { // &quot;img&quot; found
+						imgTag=imgRegexUrl.stringMatched(1); // (1) enth&#228;lt das gesamte &lt;img ...&gt;-tag
+						fetchUrl=imgRegexUrl.stringMatched(2); // URL in Anf&#252;hrungszeichen in (2) falls ohne in (3) Ergebnis ist auf jeden Fall ohne Anf&#252;hrungszeichen 
+						if (fetchUrl==null) { fetchUrl=imgRegexUrl.stringMatched(3); }
+						if (fetchUrl==null) { // TODO Fehler ausgeben: nicht abgedeckt ist der Fall, dass in einem Cache Links auf Bilder mit unterschiedlichen URL, aber gleichem Dateinamen sind.
+							inf.addWarning(MyLocale.getMsg(1617, &quot;Ignoriere Fehler in html-Cache-Description: \&quot;&lt;img\&quot; without \&quot;src=\&quot; in cache &quot;+chD.wayPoint));
+							continue;
+						}
+						inf.setInfo(MyLocale.getMsg(1611,&quot;Importing cache description:&quot;)+&quot; &quot; + numDescImported + &quot;\n&quot;+MyLocale.getMsg(1620, &quot;downloading embedded images: &quot;) + numDownloaded++);
+						if (imgRegexAlt.search(imgTag)) {
+							imgAltText=imgRegexAlt.stringMatched(1);
+							if (imgAltText==null)	imgAltText=imgRegexAlt.stringMatched(2);
+							// kein alternativer Text als Bild&#252;berschrift -&gt; Dateiname
+						} else { 
+							if (fetchUrl.toLowerCase().indexOf(&quot;opencaching.de&quot;) &gt; 0 || fetchUrl.toLowerCase().indexOf(&quot;geocaching.com&quot;) &gt; 0) //wenn von Opencaching oder geocaching ist Dateiname doch nicht so toll, weil nur aus Nummer bestehend 
+								imgAltText = &quot;No image title&quot;;
+							else imgAltText = fetchUrl.substring(fetchUrl.lastIndexOf(&quot;/&quot;)+1);
+						}
+						descIndex = imgRegexUrl.matchedTo();
+						getPic(fetchUrl, imgAltText);
+					}
+				}
+				chD.hasUnsavedChanges = true; //saveCacheDetails(profile.dataDir);
+				return;
+			}
+
+
+			if (name.equals(&quot;cacheid&quot;)){
+				// load cachedata
+				chD = getHolder(strData);
+				chD.is_update = true;
+				return;
+			}
+
+			if (name.equals(&quot;shortdesc&quot;)){
+				chD.longDescription = strData;
+				return;
+			}
+
+			if (name.equals(&quot;desc&quot;)){ // &lt;/desc&gt;
+				if (chD.is_HTML)	chD.longDescription +=SafeXML.cleanback(strData);
+				else chD.longDescription +=strData;
+				return;
+			}
+			if (name.equals(&quot;hint&quot;)){
+				chD.hints = Common.rot13(strData);
+				return;
+			}
+		}
+	}
+
+	private String createPicFilename(String fetchURL) {
+		String fileName = chD.wayPoint + &quot;_&quot; + fetchURL.substring(fetchURL.lastIndexOf(&quot;/&quot;)+1);
+		return Common.clearForFileName(fileName);
+	}
+	private void getPic(String fetchURL, String picDesc) { // TODO handling of relativ URLs
+		try {
+			if (!fetchURL.startsWith(&quot;<A HREF="http://">http://</A>&quot;)) fetchURL = new URL(new URL(&quot;<A HREF="http://">http://</A>&quot; + OPENCACHING_HOST+&quot;/&quot;), fetchURL).toString();
+			// if (!fetchURL.startsWith(&quot;<A HREF="http://">http://</A>&quot;)) fetchURL = &quot;<A HREF="http://">http://</A>&quot; + OPENCACHING_HOST + &quot;/&quot; + fetchURL; // TODO use URL.relative or so.. this is not quite correct: actually the &quot;base&quot; URL must be known... but anyway a different baseURL should not happen very often  - it doesn't in my area
+			String fileName = createPicFilename(fetchURL);
+			// add title
+			chD.imagesText.add(picDesc);
+			chD.imagesInfo.add(null); // need to stay in sync with ImagesText
+			try {
+				File ftest = new File(profile.dataDir + fileName);
+				if (ftest.exists()){
+					chD.images.add(fileName);
+				}
+				else {
+					if (pref.downloadPicsOC) {
+						chD.images.add(fetch(fetchURL, fileName));
+					}
+				}
+			} catch (IOException e) {
+				String ErrMessage = MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;) + chD.wayPoint + &quot;: ignoring IOException: &quot;+e.getMessage()+ &quot; while downloading picture:&quot;+fileName+&quot; from URL:&quot;+fetchURL; 
+				if (e.getMessage().toLowerCase().equalsIgnoreCase(&quot;could not connect&quot;) ||
+						e.getMessage().equalsIgnoreCase(&quot;unkown host&quot;)) { // is there a better way to find out what happened?
+					ErrMessage = MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;)+chD.cacheName + &quot; (&quot;+chD.wayPoint+&quot;)&quot;+MyLocale.getMsg(1619,&quot;: could not download image from URL: &quot;)+fetchURL;
+				} 
+				inf.addWarning(&quot;\n&quot;+ErrMessage);
+				//(new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), ErrMessage, MessageBox.OKB)).exec();
+				pref.log(ErrMessage);
+				e.printStackTrace();
+			}
+		} catch (MalformedURLException e) {
+			String ErrMessage = MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;) + chD.wayPoint + &quot;: ignoring MalformedUrlException: &quot; + e.getMessage()+ &quot; while downloading from URL:&quot; + fetchURL; 
+			inf.addWarning(&quot;\n&quot;+ErrMessage);
+			pref.log(ErrMessage);
+		}
+
+	}
+
+
+	private void endPicture(String name){
+
+		if(name.equals(&quot;id&quot;)){
+			//picID = strData;
+			return;
+		}
+
+		if (name.equals(&quot;url&quot;)){
+			picUrl = strData;
+			return;
+		}
+		if (name.equals(&quot;title&quot;)){
+			picTitle = strData;
+			return;
+		}
+		if(name.equals(&quot;object&quot;)){
+			// get cachedata
+			chD = getHolder(strData);
+			return;
+		}
+		if(name.equals(&quot;picture&quot;)){ 
+			//String fileName = chD.wayPoint + &quot;_&quot; + picUrl.substring(picUrl.lastIndexOf(&quot;/&quot;)+1);
+			getPic(picUrl,picTitle);
+			chD.hasUnsavedChanges = true; //saveCacheDetails(profile.dataDir);
+			return;
+		}
+	}
+
+	private void endCacheLog(String name){
+		if (name.equals(&quot;cachelog&quot;)){ // &lt;/cachelog&gt;
+			chD.cacheLogs.merge(new Log(logIcon, logDate, logFinder, logData, loggerRecommended));
+			chD.hasUnsavedChanges = true; //chD.saveCacheDetails(profile.dataDir);
+			return;
+		}
+
+		if (name.equals(&quot;cacheid&quot;)){ // &lt;/cacheid&gt;
+			// load cachedata
+			chD = getHolder(strData);
+			return;
+		}
+
+		if (name.equals(&quot;date&quot;))  {
+			logDate = new String(strData);
+			if (chD.is_found) {
+				chD.cacheStatus=strData.substring(0,10);
+			}
+			return;
+		}
+		if (name.equals(&quot;userid&quot;)){
+			logFinder = new String(strData);
+			if((logFinder.toLowerCase().compareTo(user) == 0 || logFinder.equalsIgnoreCase(pref.myAlias2)) &amp;&amp; logtype == 1){
+				chD.is_found = true; // see startCacheLog - in the current .xml this is set by startCacheLog but we sequence in the xml from opencaching might change, so I leave this also here
+				chD.cacheStatus = MyLocale.getMsg(318,&quot;Found&quot;);
+			}
+			return;
+		}
+		if (name.equals(&quot;text&quot;)){ 
+			logData = new String(strData);
+			return;
+		}
+
+	}
+
+	private String fetch(String addr, String fileName ) throws IOException
+	{
+		//Vm.debug(&quot;Redirect: &quot; + redirect);
+		CharArray realurl = new CharArray();
+		ByteArray daten = UrlFetcher.fetchByteArray(addr, realurl);
+		String address = realurl.toString();
+		if (chD != null) fileName = chD.wayPoint + &quot;_&quot; + Common.clearForFileName(address.substring(address.lastIndexOf(&quot;/&quot;)+1));
+		// else fileName = Common.ClearForFileName(address.substring(address.lastIndexOf(&quot;/&quot;)+1));
+
+		//save file
+		//Vm.debug(&quot;Save: &quot; + myPref.mydatadir + fileName);
+		//Vm.debug(&quot;Daten: &quot; + daten.length);
+		FileOutputStream outp =  new FileOutputStream(profile.dataDir + fileName);
+		outp.write(daten.toBytes());
+		outp.close();
+		return fileName;
+	}
+
+
+	/**
+	 *	Method to translate opencaching size types to geocaching types.
+	 *	Required to be &quot;backwards&quot; compatible :-(
+	 *	OC	GC	Comment	Rule
+	 *	1	5	other size	1-&gt;5
+	 *	2 	1	micro		2-&gt;1
+	 *	3 	2	small		3-&gt;2
+	 *	4	3	normal		4-&gt;3
+	 *	5 	4	large		5-&gt;4
+	 *	6	6	very large	6-&gt;6
+	 *	7	7	no container	7-&gt;7
+	 */
+	private String transSize(String type){
+		if(type.equals(&quot;1&quot;)) return &quot;Other&quot;;
+		if(type.equals(&quot;2&quot;)) return &quot;Micro&quot;;
+		if(type.equals(&quot;3&quot;)) return &quot;Small&quot;;
+		if(type.equals(&quot;4&quot;)) return &quot;Regular&quot;;
+		if(type.equals(&quot;5&quot;)) return &quot;Large&quot;;
+		if(type.equals(&quot;6&quot;)) return &quot;Very Large&quot;;
+		if(type.equals(&quot;7&quot;)) return &quot;None&quot;;
+		return &quot;0&quot;;
+	}
+
+	/**
+	 * Method to iterate through cache database and look for waypoint.
+	 * Returns value &gt;= 0 if waypoint is found, else -1
+	 */
+	private int searchWpt(String wpt){
+		Integer INTR = (Integer)DBindexWpt.get(wpt);
+		if(INTR != null)
+			return INTR.intValue();
+		return -1;
+	}
+
+	/**
+	 * Method to iterate through cache database and look for cacheID.
+	 * Returns value &gt;= 0 if cacheID is found, else -1
+	 */
+	private int searchID(String cacheID){
+		Integer INTR = (Integer)DBindexID.get(cacheID);
+		if(INTR != null)
+			return INTR.intValue();
+		return -1;
+	}
+
+
+	private CacheHolderDetail getHolder(String wpt){// See also LOCXMLImporter
+		int index;
+		
+		index = searchWpt(wpt);
+		if (index ==-1) index = searchID(wpt);
+		if (index == -1) {
+			chD = new CacheHolderDetail();
+			return chD;
+		}
+		chD = ((CacheHolder) cacheDB.get(index)).getCacheDetails(true);
+/*		try {
+			chD.readCache(profile.dataDir);
+		} catch (Exception e) {Vm.debug(&quot;Could not open file: &quot; + e.toString());};
+	*/	return chD;
+	}
+
+
+}
\ No newline at end of file

Added: experiments/EVE/src/cachewolf/imp/OCXMLImporterScreen.java
===================================================================
--- experiments/EVE/src/cachewolf/imp/OCXMLImporterScreen.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/imp/OCXMLImporterScreen.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,100 @@
+/**
+ * 
+ */
+package cachewolf.imp;
+
+import cachewolf.Global;
+import cachewolf.MyLocale;
+import cachewolf.Preferences;
+import eve.ui.*;
+import eve.fx.gui.IKeys;
+import eve.sys.Event;
+import eve.ui.event.ControlEvent;
+
+/**
+ * @author pfeffer
+ * This Class is the Dialog for Download from Opencaching.de 
+ * is called from OCXMLImporter
+ * 20061209 Bugfix: Checking for uninitialised missingCheckBox
+ */
+public class OCXMLImporterScreen extends Form {
+	Button cancelB, okB;
+	Preferences pref;
+	Input distanceInput;
+	CheckBox imagesCheckBox, /*mapsCheckBox, */ missingCheckBox, foundCheckBox;
+	static int DIST = 1;
+	static int IMAGES = 2;
+	static int ALL = 4;
+	static int INCLUDEFOUND = 8;
+	static int ISGC = 16;
+
+	
+	public OCXMLImporterScreen(String title, int options) {
+		super();
+		pref = Global.getPref(); // myPreferences sollte sp&#228;ter auch diese Einstellungen speichern
+		
+		this.title = title;
+		if ((options &amp; DIST) &gt; 0) {
+			this.addNext(new Label(MyLocale.getMsg(1601,&quot;Distance:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			distanceInput = new Input();
+			String dist1;
+			String dist2;
+			if ((options &amp; ISGC) &gt; 0) {
+				dist1 = Global.getProfile().distGC;
+				dist2 = Global.getProfile().distOC;
+			} else {
+				dist1 = Global.getProfile().distOC;
+				dist2 = Global.getProfile().distGC;
+			}
+			if ( dist1.equals(&quot;&quot;) || dist1.equals(&quot;0&quot;) || dist1.equals(&quot;0.0&quot;) ) {
+				dist1 = dist2;
+			}
+			distanceInput.setText(dist1);
+			this.addNext(distanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addLast(new Label(&quot; km&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		}
+
+		if ((options &amp; IMAGES) &gt; 0) {
+			imagesCheckBox = new CheckBox();
+			imagesCheckBox.setText(MyLocale.getMsg(1602,&quot;Download Images&quot;));
+			imagesCheckBox.setState(true); // @ToDo: aus Prefs
+			this.addLast(imagesCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+		}
+		if((options &amp; INCLUDEFOUND) &gt; 0){
+			foundCheckBox = new CheckBox();
+			foundCheckBox.setText(MyLocale.getMsg(1622,&quot;Exclude found caches&quot;));
+			foundCheckBox.setState(true);
+			this.addLast(foundCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+		}
+
+		if((options &amp; ALL) &gt; 0){
+			missingCheckBox = new CheckBox();
+			missingCheckBox.setText(MyLocale.getMsg(1606,&quot;Alle erneut downloaden&quot;));
+			missingCheckBox.setState(false); // @ToDo: aus Prefs
+			this.addLast(missingCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+		}
+
+		cancelB = new Button(MyLocale.getMsg(1604,&quot;Cancel&quot;));
+		cancelB.setHotKey(0, IKeys.ESCAPE);
+		this.addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		okB = new Button(MyLocale.getMsg(1605,&quot;OK&quot;));
+		okB.setHotKey(0, IKeys.ACTION);
+		okB.setHotKey(0, IKeys.ENTER);
+		this.addLast(okB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+	}
+	public void onEvent(Event ev){
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (ev.target == cancelB){
+				this.close(Form.IDCANCEL);
+			}
+			if (ev.target == okB){
+				    // distOC wird hier noch nicht in Pref eingetragen, damit noch gepr&#252;ft werden kann, ob es gr&#246;&#223;er oder kleiner ist als vorher
+					if (imagesCheckBox!=null) pref.downloadPicsOC = imagesCheckBox.state;
+					if (missingCheckBox!=null) pref.downloadmissingOC = missingCheckBox.state;
+					// TODO: sofort speichern?
+				this.close(Form.IDOK);
+				}
+		}
+		super.onEvent(ev);
+	}
+}

Added: experiments/EVE/src/cachewolf/imp/SpiderGC.java
===================================================================
--- experiments/EVE/src/cachewolf/imp/SpiderGC.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/imp/SpiderGC.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,1511 @@
+/*
+    CacheWolf is a software for PocketPC, Win and Linux that
+    enables paperless caching.
+    It supports the sites geocaching.com and opencaching.de
+
+    Copyright (C) 2006  CacheWolf development team
+    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+    for more information.
+    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+		<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation version 2 of the License.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+    */
+
+package cachewolf.imp;
+import eve.net.*;
+import java.io.*;
+import eve.sys.*;
+import java.util.*;
+
+
+import cachewolf.CWPoint;
+import cachewolf.CacheHolder;
+import cachewolf.CacheHolderDetail;
+import cachewolf.CacheType;
+import cachewolf.Global;
+import cachewolf.HttpConnection;
+import cachewolf.InfoBox;
+import cachewolf.Log;
+import cachewolf.LogList;
+import cachewolf.MyLocale;
+import cachewolf.Preferences;
+import cachewolf.Profile;
+import cachewolf.Travelbug;
+import cachewolf.utils.Common;
+import cachewolf.utils.DateFormat;
+import cachewolf.utils.Extractor;
+import cachewolf.utils.STRreplace;
+import cachewolf.utils.SafeXML;
+
+import com.stevesoft.eve_pat.*;
+import eve.ui.*;
+import eve.data.Property;
+import eve.data.PropertyList;
+import eve.util.ByteArray;
+import java.net.Socket;
+import java.net.UnknownHostException;
+
+import eve.util.CharArray;
+import eve.io.JavaUtf8Codec;
+
+/**
+*	Class to spider caches from gc.com
+*/
+public class SpiderGC{
+
+	/**
+	 * The maximum number of logs that will be stored
+	 */
+	public static int MAXLOGS=250; // Can be pre-set from preferences
+	public static String passwort = &quot;&quot;; // Can be pre-set from preferences
+	public static boolean loggedIn = false;
+
+	private static int ERR_LOGIN = -10;
+	private static Preferences pref;
+	private Profile profile;
+	private static String viewstate = &quot;&quot;;
+	private static String eventvalidation = &quot;&quot;;
+	private static String cookieID = &quot;&quot;;
+	private static String cookieSession = &quot;&quot;;
+	private static double distance = 0;
+	private Regex inRex = new Regex();
+	private Vector cacheDB;
+	private Vector cachesToLoad = new Vector();
+	private Hashtable indexDB;
+	private InfoBox infB;
+	private static myProperties p=null;
+
+	public SpiderGC(Preferences prf, Profile profile, boolean bypass){
+		this.profile=profile;
+		this.cacheDB = profile.cacheDB;
+		pref = prf;
+		if (p==null) {
+			pref.logInit();
+			p=new myProperties();
+		}
+		MAXLOGS=pref.maxLogsToSpider;
+	}
+
+	/**
+	 * Method to login the user to gc.com
+	 * It will request a password and use the alias defined in preferences
+	 * If the login page cannot be fetched, the password is cleared.
+	 * If the login fails, an appropriate message is displayed.
+	 */
+	public int login(){
+		loggedIn = false;
+		String start,loginPage,loginSuccess,nextPage;
+		try {
+			loginPage=p.getProp(&quot;loginPage&quot;);
+			loginSuccess=p.getProp(&quot;loginSuccess&quot;);
+			nextPage=p.getProp(&quot;nextPage&quot;);
+		} catch (Exception ex) { // Tag not found in spider.def
+			return ERR_LOGIN;
+		}
+		//Get password
+		InfoBox infB = new InfoBox(MyLocale.getMsg(5506,&quot;Password&quot;), MyLocale.getMsg(5505,&quot;Enter Password&quot;), InfoBox.INPUT);
+		infB.feedback.setText(passwort); // Remember the PWD for next time
+		infB.feedback.isPassword=true;
+		int code = infB.execute();
+		passwort = infB.getInput();
+		infB.close(0);
+		if(code != Form.IDOK) return code;
+
+		// Now start the login proper
+		infB = new InfoBox(MyLocale.getMsg(5507,&quot;Status&quot;), MyLocale.getMsg(5508,&quot;Logging in...&quot;));
+		infB.exec();
+		try{
+			pref.log(&quot;[login]:Fetching login page&quot;);
+			//Access the page once to get a viewstate
+			start = fetch(loginPage);   //<A HREF="http://www.geocaching.com/login/Default.aspx">http://www.geocaching.com/login/Default.aspx</A>
+			if (start.equals(&quot;&quot;)) {
+				infB.close(0);
+				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5499,&quot;Error loading login page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
+				pref.log(&quot;[login]:Could not fetch: gc.com login page&quot;);
+				return ERR_LOGIN;
+			}
+		} catch(Exception ex){
+			infB.close(0);
+			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5499,&quot;Error loading login page&quot;), MessageBox.OKB)).execute();
+			pref.log(&quot;[login]:Could not fetch: gc.com login page&quot;,ex);
+			passwort=&quot;&quot;;
+			return ERR_LOGIN;
+		}
+		if (!infB.isClosed) { // If user has not aborted, we continue
+			Regex rexCookieID = new Regex(&quot;(?i)Set-Cookie: userid=(.*?);.*&quot;);
+			Regex rexViewstate = new Regex(&quot;id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
+			Regex rexEventvalidation = new Regex(&quot;id=\&quot;__EVENTVALIDATION\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
+			Regex rexCookieSession = new Regex(&quot;(?i)Set-Cookie: ASP.NET_SessionId=(.*?);.*&quot;);
+			rexViewstate.search(start);
+			if(rexViewstate.didMatch()){
+				viewstate = rexViewstate.stringMatched(1);
+				//Vm.debug(&quot;ViewState: &quot; + viewstate);
+			} else
+				pref.log(&quot;[login]:Viewstate not found before login&quot;);
+
+			if(start.indexOf(loginSuccess) &gt; 0)
+				pref.log(&quot;[login]:Already logged in&quot;);
+			else {
+				rexEventvalidation.search(start);
+				if(rexEventvalidation.didMatch()){
+					eventvalidation = rexEventvalidation.stringMatched(1);
+					//Vm.debug(&quot;EVENTVALIDATION: &quot; + eventvalidation);
+				} else
+					pref.log(&quot;[login]:Eventvalidation not found before login&quot;);
+				//Ok now login!
+				try{
+					pref.log(&quot;[login]:Logging in as &quot;+pref.myAlias);
+					StringBuffer sb=new StringBuffer(1000);
+					sb.append(URL.encodeURL(&quot;__VIEWSTATE&quot;,false));	sb.append(&quot;=&quot;); sb.append(URL.encodeURL(viewstate,false));
+					sb.append(&quot;&amp;&quot;); sb.append(URL.encodeURL(&quot;myUsername&quot;,false));
+					sb.append(&quot;=&quot;); sb.append(encodeUTF8URL(eve.util.Utils.encodeJavaUtf8String(pref.myAlias)));
+					sb.append(&quot;&amp;&quot;); sb.append(URL.encodeURL(&quot;myPassword&quot;,false));
+					sb.append(&quot;=&quot;); sb.append(encodeUTF8URL(eve.util.Utils.encodeJavaUtf8String(passwort)));
+					sb.append(&quot;&amp;&quot;); sb.append(URL.encodeURL(&quot;cookie&quot;,false));
+					sb.append(&quot;=&quot;); sb.append(URL.encodeURL(&quot;on&quot;,false));
+					sb.append(&quot;&amp;&quot;); sb.append(URL.encodeURL(&quot;Button1&quot;,false));
+					sb.append(&quot;=&quot;); sb.append(URL.encodeURL(&quot;Login&quot;,false));
+					sb.append(&quot;&amp;&quot;); sb.append(URL.encodeURL(&quot;__EVENTVALIDATION&quot;,false));
+					sb.append(&quot;=&quot;); sb.append(URL.encodeURL(eventvalidation,false));
+					start = fetch_post(loginPage, sb.toString(), nextPage);  // /login/default.aspx
+					if(start.indexOf(loginSuccess) &gt; 0)
+						pref.log(&quot;[login]:Login successful&quot;);
+					else {
+						pref.log(&quot;[login]:Login failed. Wrong Account or Password?&quot;);
+						if (pref.debug) {
+							pref.log(&quot;[login.LoginUrl]:&quot;+sb.toString());
+							pref.log(&quot;[login.Answer]:&quot;+start);
+						}
+						infB.close(0);
+						(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5501,&quot;Login failed! Wrong account or password?&quot;), MessageBox.OKB)).execute();
+						return ERR_LOGIN;
+					}
+				}catch(Exception ex){
+					pref.log(&quot;[login]:Login failed with exception.&quot;, ex);
+					infB.close(0);
+					(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5501,&quot;Login failed. Error loading page after login.&quot;), MessageBox.OKB)).execute();
+					return ERR_LOGIN;
+				}
+			}
+
+			rexViewstate.search(start);
+			if (!rexViewstate.didMatch()) {
+				pref.log(&quot;[login]:Viewstate not found&quot;);
+			}
+			viewstate = rexViewstate.stringMatched(1);
+			rexCookieID.search(start);
+			if (!rexCookieID.didMatch()) {
+				pref.log(&quot;[login]:CookieID not found. Using old one.&quot;);
+			} else
+				cookieID = rexCookieID.stringMatched(1);
+			//Vm.debug(cookieID);
+			rexCookieSession.search(start);
+			if (!rexCookieSession.didMatch()) {
+				pref.log(&quot;[login]:CookieSession not found. Using old one.&quot;);
+				//cookieSession=&quot;&quot;;
+			} else
+				cookieSession = rexCookieSession.stringMatched(1);
+			//Vm.debug(&quot;cookieSession = &quot; + cookieSession);
+		}
+		boolean loginAborted=infB.isClosed;
+		infB.close(0);
+		if (loginAborted)
+			return Form.IDCANCEL;
+		loggedIn = true;
+		return Form.IDOK;
+	}
+
+	/**
+	 * Method to spider a single cache.
+	 * It assumes a login has already been performed!
+	 * @return True if spider was successful, false if spider was cancelled by closing the infobox
+	 */
+	public int spiderSingle(int number, InfoBox infB, boolean forceLogin){
+		int ret=-1;
+		this.infB = infB;
+		CacheHolder ch = (CacheHolder)cacheDB.get(number);
+		if (ch.isAddiWpt()) return -1;  // No point re-spidering an addi waypoint, comes with parent
+
+		// check if we need to login
+		if (!loggedIn){
+			if (this.login()!=Form.IDOK) return -1;
+			// loggedIn is already set by this.login()
+		}
+		CacheHolderDetail chD=ch.getCacheDetails(true); //new CacheHolderDetail(ch);
+		try{
+/*			// Get all existing details of the cache
+			try {
+				chD.readCache(profile.dataDir);
+			} catch (IOException ioex) {
+				pref.log(&quot;No .XML file found for cache &quot;+chD.wayPoint);
+			};
+*/			// Read the cache data from GC.COM and compare to old data
+			boolean loadAllLogs = (MAXLOGS &gt; 5);
+			ret=getCacheByWaypointName(chD,true,true,false,loadAllLogs);
+			// Save the spidered data
+			if (ret==-1) {
+				pref.log(&quot;Saving to:&quot; + profile.dataDir);
+				chD.saveCacheDetails(profile.dataDir);
+				((CacheHolder) cacheDB.get(number)).update(chD);
+			}
+		}catch(Exception ex){
+			pref.log(&quot;Error spidering &quot; + chD.wayPoint + &quot; in spiderSingle&quot;);
+		}
+		return ret;
+	} // spiderSingle
+
+	/**
+	 * Fetch the coordinates of a waypoint from GC
+	 * @param wayPoint the name of the waypoint
+	 * @return the cache coordinates
+	 */
+	public String getCacheCoordinates(String wayPoint) {
+		String completevebPage;
+		// Check whether spider definitions could be loaded, if not issue appropriate message and terminate
+		// Try to login. If login fails, issue appropriate message and terminate
+		if (!loggedIn || Global.getPref().forceLogin) {
+			if (login()!=Form.IDOK) {
+				return &quot;&quot;;
+			}
+		}
+		InfoBox infB = new InfoBox(&quot;Info&quot;, &quot;Loading&quot;, InfoBox.PROGRESS_WITH_WARNINGS);
+		infB.exec();
+		try{
+			String doc = p.getProp(&quot;waypoint&quot;) + wayPoint;
+			pref.log(&quot;Fetching: &quot; + wayPoint);
+			completevebPage = fetch(doc);
+		}catch(Exception ex){
+			infB.close(0);
+			pref.log(&quot;Could not fetch &quot; + wayPoint,ex);
+			return &quot;&quot;;
+		}
+		infB.close(0);
+		try {
+			return getLatLon(completevebPage);
+		} catch (Exception ex) {
+			return &quot;????&quot;;
+		}
+	}
+
+	/**
+	*	Method to start the spider for a search around the centre coordinates
+	*/
+	public void doIt(){
+		String postStr, dummy, ln, wpt;
+		Regex lineRex;
+		CacheHolderDetail chD;
+		CWPoint origin = pref.curCentrePt; // No need to copy curCentrePt as it is only read and not written
+		if (!origin.isValid()) {
+			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5509,&quot;Coordinates for centre must be set&quot;), MessageBox.OKB)).execute();
+			return;
+		}
+		if (System.getProperty(&quot;os.name&quot;)!=null)pref.log(&quot;Operating system: &quot;+System.getProperty(&quot;os.name&quot;)+&quot;/&quot;+System.getProperty(&quot;os.arch&quot;));
+		if (System.getProperty(&quot;java.vendor&quot;)!=null)pref.log(&quot;Java: &quot;+System.getProperty(&quot;java.vendor&quot;)+&quot;/&quot;+System.getProperty(&quot;java.version&quot;));
+		// Prepare an index of caches for faster searching
+		indexDB = new Hashtable(cacheDB.size());
+		CacheHolder ch;
+		//index the database for faster searching!
+		for(int i = 0; i&lt;cacheDB.size();i++){
+			ch = (CacheHolder)cacheDB.get(i);
+			indexDB.put(ch.wayPoint, new Integer(i));
+			ch.is_new = false;
+		}
+		String start = &quot;&quot;;
+		Regex rexViewstate = new Regex(&quot;id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*)\&quot; /&gt;&quot;);
+		Regex rexEventvalidation = new Regex(&quot;id=\&quot;__EVENTVALIDATION\&quot; value=\&quot;(.*)\&quot; /&gt;&quot;);
+		String doc = &quot;&quot;;
+
+		if (!loggedIn || Global.getPref().forceLogin) {
+			if(login() != Form.IDOK) return;
+		}
+
+		OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(5510,&quot;Spider Options&quot;),	OCXMLImporterScreen.INCLUDEFOUND | OCXMLImporterScreen.DIST| OCXMLImporterScreen.IMAGES| OCXMLImporterScreen.ISGC);
+		//options.distanceInput.setText(&quot;&quot;);
+		if (options.execute() == OCXMLImporterScreen.IDCANCEL) {return; }
+		String dist = options.distanceInput.getText();
+		if (dist.length()== 0) return;
+		distance = Common.parseDouble(dist);
+
+		//save last radius to profile
+		dist = MyLocale.formatDouble(distance, &quot;000.0&quot;).replace(',', '.');
+		profile.distGC = dist;
+
+		boolean doNotgetFound = options.foundCheckBox.getState();
+		boolean getImages = options.imagesCheckBox.getState();
+		options.close(0);
+
+		//=======
+		// Prepare list of all caches that are to be spidered
+		//=======
+		Form.showWait();
+		infB = new InfoBox(&quot;Status&quot;, MyLocale.getMsg(5502,&quot;Fetching first page...&quot;));
+		infB.exec();
+		//Get first page
+		try{
+			ln = p.getProp(&quot;firstPage&quot;) + origin.getLatDeg(CWPoint.DD) + p.getProp(&quot;firstPage2&quot;) +origin.getLonDeg(CWPoint.DD);
+			if(doNotgetFound) ln = ln + &quot;&amp;f=1&quot;;
+			pref.log(&quot;Getting first page: &quot;+ln);
+			start = fetch(ln);
+			pref.log(&quot;Got first page&quot;);
+		}catch(Exception ex){
+				pref.log(&quot;Error fetching first list page&quot;,ex,true);
+			Form.cancelWait();
+			infB.close(0);
+			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5503,&quot;Error fetching first list page.&quot;), MessageBox.OKB)).execute();
+			return;
+		}
+		dummy = &quot;&quot;;
+		//String lineBlck = &quot;&quot;;
+		int page_number = 4;
+		try  {
+			lineRex = new Regex(p.getProp(&quot;lineRex&quot;)); //&quot;&lt;tr bgcolor=((?s).*?)&lt;/tr&gt;&quot;
+		} catch (Exception ex) {
+			infB.close(0);
+			Form.cancelWait();
+			return;
+		}
+		int found_on_page = 0;
+		try {
+			//Loop till maximum distance has been found or no more caches are in the list
+			while(distance &gt; 0){
+				if (infB.isClosed) break;
+
+				rexViewstate.search(start);
+				if(rexViewstate.didMatch()){
+					viewstate = rexViewstate.stringMatched(1);
+					//Vm.debug(&quot;ViewState: &quot; + viewstate);
+				} else {
+					viewstate = &quot;&quot;;
+					pref.log(&quot;Viewstate not found&quot;);
+				}
+
+				rexEventvalidation.search(start);
+				if(rexEventvalidation.didMatch()){
+					eventvalidation = rexEventvalidation.stringMatched(1);
+					//Vm.debug(&quot;EVENTVALIDATION: &quot; + eventvalidation);
+				} else {
+					eventvalidation = &quot;&quot;;
+					pref.log(&quot;Eventvalidation not found&quot;);
+				}
+
+				//Vm.debug(&quot;In loop&quot;);
+				Regex listBlockRex = new Regex(p.getProp(&quot;listBlockRex&quot;)); // &quot;&lt;table id=\&quot;dlResults\&quot;((?s).*?)&lt;/table&gt;&quot;
+				listBlockRex.search(start);
+				dummy = listBlockRex.stringMatched(1);
+				try{
+					lineRex.search(dummy);
+				}catch(NullPointerException nex){}
+				while(lineRex.didMatch()){
+					//Vm.debug(getDist(lineRex.stringMatched(1)) + &quot; / &quot; +getWP(lineRex.stringMatched(1)));
+					found_on_page++;
+					if(getDist(lineRex.stringMatched(1)) &lt;= distance){
+						String waypoint=getWP(lineRex.stringMatched(1));
+						Integer nr;
+						if((nr=(Integer)indexDB.get(waypoint)) == null){
+							cachesToLoad.add(waypoint);
+						} else {
+							pref.log(waypoint+&quot; already in DB&quot;);
+							ch=(CacheHolder) cacheDB.get(nr.intValue());
+							// If the &lt;strike&gt; tag is used, the cache is marked as unavailable or archived
+							boolean is_archived_GC=lineRex.stringMatched(1).indexOf(&quot;&lt;strike&gt;&lt;font color=\&quot;red\&quot;&gt;&quot;)!=-1;
+							boolean is_available_GC=lineRex.stringMatched(1).indexOf(&quot;&lt;strike&gt;&quot;)==-1;
+							if (ch.is_archived!=is_archived_GC) { // Update the database with the cache status
+								pref.log(&quot;Updating status of &quot;+waypoint+&quot; to &quot;+(is_archived_GC?&quot;archived&quot;:&quot;not archived&quot;));
+								ch.is_archived=is_archived_GC;
+								chD=ch.getCacheDetails(true,false);
+								ch.detailsAdded();
+							} else if (ch.is_available!=is_available_GC) { // Update the database with the cache status
+								pref.log(&quot;Updating status of &quot;+waypoint+&quot; to &quot;+(is_available_GC?&quot;available&quot;:&quot;not available&quot;));
+								ch.is_available=is_available_GC;
+								chD=ch.getCacheDetails(true,false);
+								ch.detailsAdded();
+							}
+						}
+					} else distance = 0;
+					lineRex.searchFrom(dummy, lineRex.matchedTo());
+				}
+				infB.setInfo(MyLocale.getMsg(5511,&quot;Found &quot;) + cachesToLoad.size() + MyLocale.getMsg(5512,&quot; caches&quot;));
+				if(found_on_page &lt; 20) distance = 0;
+				postStr = p.getProp(&quot;firstLine&quot;) + origin.getLatDeg(CWPoint.DD) + &quot;&amp;&quot; + origin.getLonDeg(CWPoint.DD);
+				if(doNotgetFound) postStr = postStr + p.getProp(&quot;showOnlyFound&quot;);
+				if(distance &gt; 0){
+					page_number++;
+					if(page_number &gt;= 15) page_number = 5;
+					String strNextPage;
+					if (page_number &lt; 10) {
+						strNextPage = &quot;ctl00$ContentBody$pgrTop$ctl0&quot; + page_number;
+					} else {
+						strNextPage = &quot;ctl00$ContentBody$pgrTop$ctl&quot; + page_number;
+					}
+					doc = URL.encodeURL(&quot;__EVENTTARGET&quot;,false) +&quot;=&quot;+ URL.encodeURL(strNextPage,false)
+				    + &quot;&amp;&quot; + URL.encodeURL(&quot;__EVENTARGUMENT&quot;,false) +&quot;=&quot;+ URL.encodeURL(&quot;&quot;,false)
+				    + &quot;&amp;&quot; + URL.encodeURL(&quot;__VIEWSTATE&quot;,false) +&quot;=&quot;+ URL.encodeURL(viewstate,false)
+				    + &quot;&amp;&quot; + URL.encodeURL(&quot;__EVENTVALIDATION&quot;,false) +&quot;=&quot;+ URL.encodeURL(eventvalidation,false);
+					try{
+						start = &quot;&quot;;
+						pref.log(&quot;Fetching next list page:&quot; + doc);
+						start = fetch_post(postStr, doc, p.getProp(&quot;nextListPage&quot;));
+					}catch(Exception ex){
+						//Vm.debug(&quot;Couldn't get the next page&quot;);
+						pref.log(&quot;Error getting next page&quot;);
+					}finally{
+					}
+				}
+				//Vm.debug(&quot;Distance is now: &quot; + distance);
+				found_on_page = 0;
+			}
+		} catch (Exception ex) { // Some tag missing from spider.def
+			infB.close(0);
+			Form.cancelWait();
+			return;
+		}
+		pref.log(&quot;Found &quot; + cachesToLoad.size() + &quot; caches&quot;);
+		if (!infB.isClosed) infB.setInfo(MyLocale.getMsg(5511,&quot;Found &quot;) + cachesToLoad.size() + MyLocale.getMsg(5512,&quot; caches&quot;));
+
+		//=======
+		// Now ready to spider each cache in the list
+		//=======
+		boolean loadAllLogs = (MAXLOGS &gt; 5);
+
+		int spiderErrors=0;
+		for(int i = 0; i&lt;cachesToLoad.size(); i++){
+			if (infB.isClosed) break;
+
+			wpt = (String)cachesToLoad.get(i);
+			// Get only caches not already available in the DB
+			if(searchWpt(wpt) == -1){
+				infB.setInfo(MyLocale.getMsg(5513,&quot;Loading: &quot;) + wpt +&quot; (&quot; + (i+1) + &quot; / &quot; + cachesToLoad.size() + &quot;)&quot;);
+				chD = new CacheHolderDetail();
+				chD.wayPoint=wpt;
+				int test = getCacheByWaypointName(chD,false,getImages,doNotgetFound,loadAllLogs);
+				if (test == -1) {
+					break;
+				} else if (test == 0) {
+					spiderErrors++;
+				} else {
+					if (!chD.is_found || !doNotgetFound ) {
+						chD.saveCacheDetails(profile.dataDir);
+						cacheDB.add(new CacheHolder(chD));
+					}
+				}
+			}
+		}
+		infB.close(0);
+		Form.cancelWait();
+		if ( spiderErrors &gt; 0) {
+			new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;),spiderErrors + MyLocale.getMsg(5516,&quot; cache descriptions%0acould not be loaded.&quot;),FormBase.DEFOKB).execute();
+		}
+		Global.getProfile().saveIndex(true);
+	}
+
+	/**
+	 * Read a complete cachepage from geocaching.com including all logs. This is used both when
+	 * updating already existing caches (via spiderSingle) and when spidering around a centre. It
+	 * is also used when reading a GPX file and fetching the images.
+	 *
+	 * This is the workhorse function of the spider.
+	 *
+	 * @param CacheHolderDetail chD The element wayPoint must be set to the name of a waypoint
+	 * @param boolean isUpdate True if an existing cache is being updated, false if it is a new cache
+	 * @param boolean fetchImages True if the pictures are to be fetched
+	 * @param boolean doNotGetFound True if the cache is not to be spidered if it has already been found
+	 * @param boolean fetchAllLogs True if all logs are to be fetched (by adding option '&amp;logs=y' to command line).
+	 *     This is normally false when spidering from GPXImport as the logs are part of the GPX file, and true otherwise
+	 * @return false if the infoBox was closed
+	 */
+	private int getCacheByWaypointName(CacheHolderDetail chD, boolean isUpdate, boolean fetchImages, boolean doNotGetFound, boolean fetchAllLogs) {
+		int ret=1;
+		while (true) {
+			String completeWebPage;
+			int spiderTrys=0;
+			int MAX_SPIDER_TRYS=3;
+			while (spiderTrys++&lt;MAX_SPIDER_TRYS) {
+				ret=1;
+				try{
+					String doc = p.getProp(&quot;getPageByName&quot;) + chD.wayPoint +(fetchAllLogs?p.getProp(&quot;fetchAllLogs&quot;):&quot;&quot;);
+					pref.log(&quot;Fetching: &quot; + chD.wayPoint);
+					completeWebPage = fetch(doc);
+					if	( completeWebPage.equals(&quot;&quot;)) {
+						pref.log(&quot;Could not fetch &quot; + chD.wayPoint);
+						if (!infB.isClosed) {
+							continue;
+						} else {
+							chD.is_incomplete = true;
+							return -1;
+						}
+					}
+				}catch(Exception ex){
+					pref.log(&quot;Could not fetch &quot; + chD.wayPoint,ex);
+					if (!infB.isClosed) {
+						continue;
+					} else {
+						chD.is_incomplete = true;
+						return -1;
+					}
+				}
+				// Only analyse the cache data and fetch pictures if user has not closed the progress window
+				if (!infB.isClosed) {
+					try{
+						chD.is_new = !isUpdate;
+						chD.is_update = false;
+						chD.is_log_update=false;
+						chD.is_HTML = true;
+						chD.is_available = true;
+						chD.is_archived = false;
+						chD.is_incomplete = false;
+						// Save size of logs to be able to check whether any new logs were added
+						//int logsz = chD.CacheLogs.size();
+						//chD.CacheLogs.clear();
+						chD.addiWpts.clear();
+						chD.images.clear();
+						chD.imagesText.clear();
+						chD.imagesInfo.clear();
+
+						if(completeWebPage.indexOf(p.getProp(&quot;cacheUnavailable&quot;)) &gt;= 0) chD.is_available = false;
+						if(completeWebPage.indexOf(p.getProp(&quot;cacheArchived&quot;)) &gt;= 0) chD.is_archived = true;
+						//==========
+						// General Cache Data
+						//==========
+						chD.setLatLon(getLatLon(completeWebPage));
+						pref.log(&quot;LatLon: &quot; + chD.latLon);
+						if (pref.debug) pref.log(&quot;chD.pos: &quot; + chD.pos.toString());
+						if (chD.latLon.equals(&quot;???&quot;)) {
+							pref.log(&quot;&gt;&gt;&gt;&gt; Failed to spider Cache. Retry.&quot;);
+							ret=0;
+							continue; // Restart the spider
+						}
+						pref.log(&quot;Trying description&quot;);
+						chD.setLongDescription(getLongDesc(completeWebPage));
+						pref.log(&quot;Got description&quot;);
+
+						pref.log(&quot;Getting cache name&quot;);
+						chD.cacheName = SafeXML.cleanback(getName(completeWebPage));
+						if (pref.debug) pref.log(&quot;Name: &quot; + chD.cacheName); else pref.log(&quot;Got name&quot;);
+
+						pref.log(&quot;Trying owner&quot;);
+						chD.cacheOwner = SafeXML.cleanback(getOwner(completeWebPage)).trim();
+						if(chD.cacheOwner.equals(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; chD.cacheOwner.equals(pref.myAlias2))) chD.is_owned = true;
+						if (pref.debug) pref.log(&quot;Owner: &quot; + chD.cacheOwner +&quot;; is_owned = &quot;+chD.is_owned+&quot;;  alias1,2 = [&quot;+pref.myAlias+&quot;|&quot;+pref.myAlias2+&quot;]&quot;);
+						else pref.log(&quot;Got owner&quot;);
+
+
+						pref.log(&quot;Trying date hidden&quot;);
+						chD.dateHidden = DateFormat.MDY2YMD(getDateHidden(completeWebPage));
+						if (pref.debug) pref.log(&quot;Hidden: &quot; + chD.dateHidden);
+						else pref.log(&quot;Got date hidden&quot;);
+
+						pref.log(&quot;Trying hints&quot;);
+						chD.setHints(getHints(completeWebPage));
+						if (pref.debug) pref.log(&quot;Hints: &quot; + chD.hints);
+						else pref.log(&quot;Got hints&quot;);
+
+						pref.log(&quot;Trying size&quot;);
+						chD.cacheSize = getSize(completeWebPage);
+						if (pref.debug) pref.log(&quot;Size: &quot; + chD.cacheSize);
+						else pref.log(&quot;Got size&quot;);
+
+						pref.log(&quot;Trying difficulty&quot;);
+						chD.hard = getDiff(completeWebPage);
+						if (pref.debug) pref.log(&quot;Hard: &quot; + chD.hard);
+						else pref.log(&quot;Got difficulty&quot;);
+
+						pref.log(&quot;Trying terrain&quot;);
+						chD.terrain = getTerr(completeWebPage);
+						if (pref.debug) pref.log(&quot;Terr: &quot; + chD.terrain);
+						else pref.log(&quot;Got terrain&quot;);
+
+						pref.log(&quot;Trying cache type&quot;);
+						chD.type = getType(completeWebPage);
+						if (pref.debug) pref.log(&quot;Type: &quot; + chD.type);
+						else pref.log(&quot;Got cache type&quot;);
+
+						//==========
+						// Logs
+						//==========
+						pref.log(&quot;Trying logs&quot;);
+						chD.setCacheLogs(getLogs(completeWebPage, chD));
+						pref.log(&quot;Found logs&quot;);
+
+						// If the switch is set to not store found caches and we found the cache =&gt; return
+						if (chD.is_found &amp;&amp; doNotGetFound) {
+							if (infB.isClosed) {
+								return -1;
+							} else {
+								return 1;
+							}
+						}
+
+						//==========
+						// Bugs
+						//==========
+						// As there may be several bugs, we check whether the user has aborted
+						if (!infB.isClosed) getBugs(chD,completeWebPage);
+						chD.has_bug = chD.travelbugs.size()&gt;0;
+
+						//==========
+						// Images
+						//==========
+						if(fetchImages){
+							pref.log(&quot;Trying images&quot;);
+							getImages(completeWebPage, chD);
+							pref.log(&quot;Got images&quot;);
+						}
+						//==========
+						// Addi waypoints
+						//==========
+
+						pref.log(&quot;Getting additional waypoints&quot;);
+						getAddWaypoints(completeWebPage, chD.wayPoint, chD.is_found);
+						pref.log(&quot;Got additional waypoints&quot;);
+
+						//==========
+						// Attributes
+						//==========
+						pref.log(&quot;Getting attributes&quot;);
+						getAttributes(completeWebPage, chD);
+						pref.log(&quot;Got attributes&quot;);
+						if (chD.is_new) chD.is_update=false;
+						chD.is_incomplete=false;
+						break;
+					}catch(Exception ex){
+						pref.log(&quot;Error reading cache: &quot;+chD.wayPoint);
+						pref.log(&quot;Exception in getCacheByWaypointName: &quot;,ex);
+					}
+					finally{}
+				} else {
+					break;
+				}
+			} // spiderTrys
+			if ( ( spiderTrys &gt;= MAX_SPIDER_TRYS ) &amp;&amp; ( ret == 1 ) ) {
+				pref.log(&quot;&gt;&gt;&gt; Failed to spider cache. Number of retrys exhausted.&quot;);
+				int decision = (new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;),MyLocale.getMsg(5515,&quot;Failed to load cache.%0aPleas check your internet connection.%0aRetry?&quot;),FormBase.DEFOKB|FormBase.NOB|FormBase.CANCELB)).execute();
+				if ( decision == FormBase.IDOK ) {
+					continue;
+				} else if ( decision == FormBase.IDNO ){
+					ret = 0;
+				} else {
+					ret = -1;
+				}
+			}
+			break;
+			}// while (true)
+		if (infB.isClosed) {// If the infoBox was closed before getting here, we return -1
+			return -1;
+		}
+		return ret;
+	} // getCacheByWaypointName
+
+	/**
+	 * Check whether a waypoint is in the database
+	 * @param wpt Name of waypoint to check
+	 * @return index of waypoint in database, -1 if it does not exist
+	 */
+	private int searchWpt(String wpt){
+		Integer INTR = (Integer)indexDB.get(wpt);
+		if(INTR != null)
+			return INTR.intValue();
+		return -1;
+	}
+
+	/**
+	 * Get the Distance to the centre
+	 * @param doc A previously fetched cachepage
+	 * @return Distance
+	 */
+	private double getDist(String doc) throws Exception {
+		inRex = new Regex(p.getProp(&quot;distRex&quot;));
+		inRex.search(doc);
+		if(doc.indexOf(&quot;Here&quot;) &gt;= 0) return(0);
+		if (!inRex.didMatch()) return 0;
+		if(MyLocale.getDigSeparator().equals(&quot;,&quot;)) return Convert.toDouble(inRex.stringMatched(1).replace('.',','));
+		return Convert.toDouble(inRex.stringMatched(1));
+	}
+
+	/**
+	 * Get the waypoint name
+	 * @param doc A previously fetched cachepage
+	 * @return Name of waypoint to add to list
+	 */
+	private String getWP(String doc) throws Exception {
+		inRex = new Regex(p.getProp(&quot;waypointRex&quot;));
+		inRex.search(doc);
+		if (!inRex.didMatch()) return &quot;???&quot;;
+		return &quot;GC&quot;+inRex.stringMatched(1);
+	}
+
+	/**
+	 * Get the coordinates of the cache
+	 * @param doc A previously fetched cachepage
+	 * @return Cache coordinates
+	 */
+	private String getLatLon(String doc) throws Exception{
+		inRex = new Regex(p.getProp(&quot;latLonRex&quot;));
+		inRex.search(doc);
+		if (!inRex.didMatch()) return &quot;???&quot;;
+		return inRex.stringMatched(1);
+	}
+
+	/**
+	 * Get the long description
+	 * @param doc A previously fetched cachepage
+	 * @return the long description
+	 */
+	private String getLongDesc(String doc) throws Exception{
+		String res = &quot;&quot;;
+		inRex = new Regex(p.getProp(&quot;shortDescRex&quot;));
+		Regex rex2 = new Regex(p.getProp(&quot;longDescRex&quot;));
+		inRex.search(doc);
+		rex2.search(doc);
+		res = ((inRex.stringMatched(1)==null)?&quot;&quot;:inRex.stringMatched(1)) + &quot;&lt;br&gt;&quot;;
+		res += rex2.stringMatched(1);
+		return res; // SafeXML.cleanback(res);
+	}
+
+	/**
+	 * Get the cache name
+	 * @param doc A previously fetched cachepage
+	 * @return the name of the cache
+	 */
+	private String getName(String doc) throws Exception{
+		inRex = new Regex(p.getProp(&quot;cacheNameRex&quot;));
+		inRex.search(doc);
+		if (!inRex.didMatch()) return &quot;???&quot;;
+		return inRex.stringMatched(1);
+	}
+
+	/**
+	 * Get the cache owner
+	 * @param doc A previously fetched cachepage
+	 * @return the cache owner
+	 */
+	private String getOwner(String doc) throws Exception{
+		inRex = new Regex(p.getProp(&quot;cacheOwnerRex&quot;));
+		inRex.search(doc);
+		if (!inRex.didMatch()) return &quot;???&quot;;
+		return inRex.stringMatched(1);
+	}
+
+	/**
+	 * Get the date when the cache was hidden
+	 * @param doc A previously fetched cachepage
+	 * @return Hidden date
+	 */
+	private String getDateHidden(String doc) throws Exception{
+		inRex = new Regex(p.getProp(&quot;dateHiddenRex&quot;));
+		inRex.search(doc);
+		if (!inRex.didMatch()) return &quot;???&quot;;
+		return inRex.stringMatched(1);
+	}
+
+	/**
+	 * Get the hints
+	 * @param doc A previously fetched cachepage
+	 * @return Cachehints
+	 */
+	private String getHints(String doc) throws Exception{
+		inRex = new Regex(p.getProp(&quot;hintsRex&quot;));
+		inRex.search(doc);
+		if (!inRex.didMatch()) return &quot;&quot;;
+		return inRex.stringMatched(1);
+	}
+
+	/**
+	 * Get the cache size
+	 * @param doc A previously fetched cachepage
+	 * @return Cache size
+	 */
+	private String getSize(String doc) throws Exception{
+		inRex = new Regex(p.getProp(&quot;sizeRex&quot;));
+		inRex.search(doc);
+		if(inRex.didMatch())
+			return inRex.stringMatched(1);
+		return &quot;None&quot;;
+	}
+
+	/**
+	 * Get the Difficulty
+	 * @param doc A previously fetched cachepage
+	 * @return The cache difficulty
+	 */
+	private String getDiff(String doc) throws Exception{
+		inRex = new Regex(p.getProp(&quot;difficultyRex&quot;));
+		inRex.search(doc);
+		if(inRex.didMatch())
+			return inRex.stringMatched(1);
+		return &quot;&quot;;
+	}
+
+	/**
+	 * Get the terrain rating
+	 * @param doc A previously fetched cachepage
+	 * @return Terrain rating
+	 */
+	private String getTerr(String doc) throws Exception{
+		inRex = new Regex(p.getProp(&quot;terrainRex&quot;));
+		inRex.search(doc);
+		if(inRex.didMatch())
+			return inRex.stringMatched(1);
+		return &quot;&quot;;
+	}
+
+	/**
+	 * Get the waypoint type
+	 * @param doc A previously fetched cachepage
+	 * @return the waypoint type (Tradi, Multi, etc.)
+	 */
+	private int getType(String doc) throws Exception{
+		inRex = new Regex(p.getProp(&quot;cacheTypeRex&quot;));
+		inRex.search(doc);
+		if(inRex.didMatch())
+			return Common.parseInt(inRex.stringMatched(1));
+		return 0;
+	}
+
+	/**
+	 * Get the logs
+	 * @param doc A previously fetched cachepage
+	 * @param chD Cache Details
+	 * @return A HTML string containing the logs
+	 */
+	private LogList getLogs(String doc, CacheHolderDetail chD) throws Exception{
+		String icon = &quot;&quot;;
+		String name = &quot;&quot;;
+		LogList reslts = new LogList();
+		Regex blockRex = new Regex(p.getProp(&quot;blockRex&quot;));
+		blockRex.search(doc);
+		doc = blockRex.stringMatched(1);
+		String singleLog = &quot;&quot;;
+		Extractor exSingleLog = new Extractor(doc,p.getProp(&quot;singleLogExStart&quot;), p.getProp(&quot;singleLogExEnd&quot;), 0, false); // maybe here is some change neccessary because findnext now gives the whole endstring back???
+		singleLog = exSingleLog.findNext();
+		Extractor exIcon = new Extractor(singleLog,p.getProp(&quot;iconExStart&quot;), p.getProp(&quot;iconExEnd&quot;), 0, true);
+		Extractor exNameTemp = new Extractor(singleLog,p.getProp(&quot;nameTempExStart&quot;), p.getProp(&quot;nameTempExEnd&quot;), 0 , true);
+		String nameTemp = &quot;&quot;;
+		nameTemp = exNameTemp.findNext();
+		Extractor exName = new Extractor(nameTemp, p.getProp(&quot;nameExStart&quot;), p.getProp(&quot;nameExEnd&quot;), 0 , true);
+		Extractor exDate = new Extractor(singleLog,p.getProp(&quot;dateExStart&quot;), p.getProp(&quot;dateExEnd&quot;), 0 , true);
+		Extractor exLog = new Extractor(singleLog, p.getProp(&quot;logExStart&quot;), p.getProp(&quot;logExEnd&quot;), 0, true);
+		//Vm.debug(&quot;Log Block: &quot; + singleLog);
+		int nLogs=0;
+		while(exSingleLog.endOfSearch() == false){
+			nLogs++;
+			//Vm.debug(&quot;--------------------------------------------&quot;);
+			//Vm.debug(&quot;Log Block: &quot; + singleLog);
+			//Vm.debug(&quot;Icon: &quot;+exIcon.findNext());
+			//Vm.debug(exName.findNext());
+			//Vm.debug(exDate.findNext());
+			//Vm.debug(exLog.findNext());
+			//Vm.debug(&quot;--------------------------------------------&quot;);
+			icon = exIcon.findNext();
+			name = exName.findNext();
+			String d=DateFormat.logdate2YMD(exDate.findNext());
+			if((icon.equals(p.getProp(&quot;icon_smile&quot;)) || icon.equals(p.getProp(&quot;icon_camera&quot;)) || icon.equals(p.getProp(&quot;icon_attended&quot;))) &amp;&amp;
+				(name.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; name.equalsIgnoreCase(pref.myAlias2))) )  {
+				chD.is_found = true;
+				chD.cacheStatus = d;
+			}
+			if (nLogs&lt;=MAXLOGS) reslts.add(new Log(icon,d,name,exLog.findNext()));
+
+			singleLog = exSingleLog.findNext();
+			exIcon.setSource(singleLog);
+			exNameTemp.setSource(singleLog);
+			nameTemp = exNameTemp.findNext();
+			exName.setSource(nameTemp);
+			exDate.setSource(singleLog);
+			exLog.setSource(singleLog);
+			// We cannot simply stop if we have reached MAXLOGS just in case we are waiting for
+			// a log by our alias that happened earlier.
+			if (nLogs&gt;=MAXLOGS &amp;&amp; chD.is_found) break;
+		}
+		if (nLogs&gt;MAXLOGS) {
+			reslts.add(Log.maxLog());
+			pref.log(&quot;Too many logs. MAXLOGS reached (&quot;+MAXLOGS+&quot;)&quot;);
+		} else
+			pref.log(nLogs+&quot; logs found&quot;);
+		return reslts;
+	}
+
+	/**
+	 * Read the travelbug names from a previously fetched Cache page and then
+	 * read the travelbug purpose for each travelbug
+	 * @param doc The previously fetched cachepage
+	 * @return A HTML formatted string with bug names and there purpose
+	 */
+	public void getBugs(CacheHolderDetail chD, String doc) throws Exception{
+		Extractor exBlock = new Extractor(doc,p.getProp(&quot;blockExStart&quot;),p.getProp(&quot;blockExEnd&quot;) ,0,Extractor.EXCLUDESTARTEND);
+		String bugBlock = exBlock.findNext();
+		//Vm.debug(&quot;Bugblock: &quot;+bugBlock);
+		Extractor exBug = new Extractor(bugBlock,p.getProp(&quot;bugExStart&quot;),p.getProp(&quot;bugExEnd&quot;),0,Extractor.EXCLUDESTARTEND);
+		String link,bug,linkPlusBug,bugDetails;
+		String oldInfoBox=infB.getInfo();
+		chD.travelbugs.clear();
+		while(exBug.endOfSearch() == false){
+			if (infB.isClosed) break; // Allow user to cancel by closing progress form
+			linkPlusBug= exBug.findNext();
+			int idx=linkPlusBug.indexOf(&quot;'&gt;&quot;);
+			if (idx&lt;0) break; // No link/bug pair found
+			link=linkPlusBug.substring(0,idx);
+			bug=linkPlusBug.substring(idx+2);
+			if(bug.length()&gt;0) { // Found a bug, get its details
+				Travelbug tb=new Travelbug(bug);
+				try{
+					infB.setInfo(oldInfoBox+MyLocale.getMsg(5514,&quot;\nGetting bug: &quot;)+SafeXML.cleanback(bug));
+					pref.log(&quot;Fetching bug details: &quot;+bug);
+					bugDetails = fetch(link);
+					Extractor exDetails = new Extractor(bugDetails,p.getProp(&quot;bugDetailsStart&quot;),p.getProp(&quot;bugDetailsEnd&quot;),0,Extractor.EXCLUDESTARTEND);
+					tb.setMission(exDetails.findNext());
+					Extractor exGuid = new Extractor(bugDetails,&quot;details.aspx?guid=&quot;,&quot;\&quot; id=\&quot;aspnetForm&quot;,0,Extractor.EXCLUDESTARTEND); // TODO Replace with spider.def see also further down
+					tb.setGuid(exGuid.findNext());
+					chD.travelbugs.add(tb);
+				}catch(Exception ex){
+					pref.log(&quot;Could not fetch bug details&quot;);
+				}
+			}
+			//Vm.debug(&quot;B: &quot; + bug);
+			//Vm.debug(&quot;End? &quot; + exBug.endOfSearch());
+		}
+		infB.setInfo(oldInfoBox);
+	}
+
+	/**
+	 * Get the images for a previously fetched cache page. Images are extracted
+	 * from two areas: The long description and the pictures section (including
+	 * the spoiler)
+	 * @param doc The previously fetched cachepage
+	 * @param chD The Cachedetails
+	 */
+	public void getImages(String doc, CacheHolderDetail chD){
+		int imgCounter = 0;
+		String imgName, oldImgName, imgType, imgUrl, imgComment;
+		Vector spideredUrls=new Vector(15);
+		Extractor exImgBlock,exImgComment;
+		int idxUrl; // Index of already spidered Url in list of spideredUrls
+		//========
+		//In the long description
+		//========
+		String longDesc = &quot;&quot;;
+		try {
+			if (chD.wayPoint.startsWith(&quot;TC&quot;)) longDesc = doc;
+			else
+				longDesc = getLongDesc(doc);
+			longDesc = STRreplace.replace(longDesc, &quot;&lt;img&quot;, &quot;&lt;IMG&quot;);
+			longDesc = STRreplace.replace(longDesc, &quot;src=&quot;, &quot;SRC=&quot;);
+			longDesc = STRreplace.replace(longDesc, &quot;'&quot;, &quot;\&quot;&quot;);
+			exImgBlock = new Extractor(longDesc,p.getProp(&quot;imgBlockExStart&quot;),p.getProp(&quot;imgBlockExEnd&quot;), 0, false);
+		} catch (Exception ex) {//Missing property in spider.def
+			return;
+		}
+		//Vm.debug(&quot;In getImages: Have longDesc&quot; + longDesc);
+		String tst;
+		tst = exImgBlock.findNext();
+		//Vm.debug(&quot;Test: \n&quot; + tst);
+		Extractor exImgSrc = new Extractor(tst, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
+		while(exImgBlock.endOfSearch() == false){
+			imgUrl = exImgSrc.findNext();
+			//Vm.debug(&quot;Img Url: &quot; +imgUrl);
+			if(imgUrl.length()&gt;0){
+				imgUrl = &quot;<A HREF="http://">http://</A>&quot; + imgUrl;
+				try{
+					imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).substring(0,4).trim();
+					// imgType is now max 4 chars, starting with .
+					if(imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)){
+						// Check whether image was already spidered for this cache
+						if (imgUrl.indexOf('%')&gt;=0) imgUrl=URL.decodeURL(imgUrl);						idxUrl=spideredUrls.indexOf(imgUrl);
+						imgName = chD.wayPoint + &quot;_&quot; + Convert.toString(imgCounter);
+						if (idxUrl&lt;0) { // New image
+							pref.log(&quot;Loading image: &quot; + imgUrl+&quot; as &quot;+imgName);
+							spiderImage(imgUrl, imgName+imgType);
+							chD.images.add(imgName+imgType);
+							spideredUrls.add(imgUrl);
+						} else { // Image already spidered as wayPoint_'idxUrl'
+							pref.log(&quot;Already loaded image: &quot; + imgUrl);
+							oldImgName = chD.wayPoint + &quot;_&quot; + Convert.toString(idxUrl);
+							chD.images.add(oldImgName+imgType); // Store name of old image as image to load
+						}
+						chD.imagesText.add(imgName); // Keep the image name
+						chD.imagesInfo.add(null); // Need to stay in synch with ImagesText
+						imgCounter++;
+					}
+				} catch (IndexOutOfBoundsException e) {
+					//Vm.debug(&quot;IndexOutOfBoundsException not in image span&quot;+e.toString()+&quot;imgURL:&quot;+imgUrl);
+					pref.log(&quot;Problem loading image. imgURL:&quot;+imgUrl);
+				}
+				}
+			exImgSrc.setSource(exImgBlock.findNext());
+		}
+		//========
+		//In the image span
+		//========
+		Extractor spanBlock,exImgName;
+		try {
+			spanBlock = new Extractor(doc,p.getProp(&quot;imgSpanExStart&quot;),p.getProp(&quot;imgSpanExEnd&quot;), 0 , true);
+			tst = spanBlock.findNext();
+			exImgName = new Extractor(tst,p.getProp(&quot;imgNameExStart&quot;),p.getProp(&quot;imgNameExEnd&quot;), 0 , true);
+			exImgSrc = new Extractor(tst,p.getProp(&quot;imgSrcExStart&quot;),p.getProp(&quot;imgSrcExEnd&quot;), 0, true);
+			exImgComment = new Extractor(tst,p.getProp(&quot;imgCommentExStart&quot;),p.getProp(&quot;imgCommentExEnd&quot;), 0, true);
+		} catch (Exception ex) { // Missing property in spider .def
+			return;
+		}
+		while(exImgSrc.endOfSearch() == false){
+			imgUrl = exImgSrc.findNext();
+			//Vm.debug(&quot;Img Url: &quot; +imgUrl);
+			if(imgUrl.length()&gt;0){
+				imgUrl = &quot;<A HREF="http://">http://</A>&quot; + imgUrl;
+				imgComment = exImgComment.findNext();
+				try{
+					imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).substring(0,4).trim();
+					// imgType is now max 4 chars, starting with .
+					if(imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)){
+						// Check whether image was already spidered for this cache
+						if (imgUrl.indexOf('%')&gt;=0) imgUrl=URL.decodeURL(imgUrl);
+						idxUrl=spideredUrls.indexOf(imgUrl);
+						imgName = chD.wayPoint + &quot;_&quot; + Convert.toString(imgCounter);
+						if (idxUrl&lt;0) { // New image
+							pref.log(&quot;Loading image: &quot; + imgUrl);
+							spiderImage(imgUrl, imgName+imgType);
+							chD.images.add(imgName+imgType);
+						} else { // Image already spidered as wayPoint_ 'idxUrl'
+							pref.log(&quot;Already loaded image: &quot; + imgUrl);
+							oldImgName = chD.wayPoint + &quot;_&quot; + Convert.toString(idxUrl);
+							chD.images.add(oldImgName+imgType); // Store name of old image as image to load
+						}
+						chD.imagesText.add(exImgName.findNext()); // Keep the image description
+						while (imgComment.startsWith(&quot;&lt;br /&gt;&quot;)) imgComment=imgComment.substring(4);
+						while (imgComment.endsWith(&quot;&lt;br /&gt;&quot;)) imgComment=imgComment.substring(0,imgComment.length()-4);
+						if (imgComment.length()==0)
+							chD.imagesInfo.add(null);
+						else
+							chD.imagesInfo.add(imgComment);
+						imgCounter++;
+					}
+				} catch (IndexOutOfBoundsException e) {
+					pref.log(&quot;IndexOutOfBoundsException in image span. imgURL:&quot;+imgUrl,e);
+				}
+			}
+		}
+		//========
+		//Final sweep to check for images in hrefs
+		//========
+		Extractor exFinal = new Extractor(longDesc, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
+		while(exFinal.endOfSearch() == false){
+			imgUrl = exFinal.findNext();
+			if(imgUrl.length()&gt;0){
+				imgUrl = &quot;<A HREF="http://">http://</A>&quot; + imgUrl;
+				try{
+					imgType = (imgUrl.substring(imgUrl.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).substring(0,4).trim();
+					// imgType is now max 4 chars, starting with .
+					imgUrl=imgUrl.substring(0,imgUrl.lastIndexOf(&quot;.&quot;)+imgType.length());
+					if( imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.bmp&quot;) || imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.gif&quot;)){
+						// Check whether image was already spidered for this cache
+						if (imgUrl.indexOf('%')&gt;=0) imgUrl=URL.decodeURL(imgUrl);
+						idxUrl=spideredUrls.indexOf(imgUrl);
+						if (idxUrl&lt;0) { // New image
+							imgName = chD.wayPoint + &quot;_&quot; + Convert.toString(imgCounter);
+							pref.log(&quot;Loading image: &quot; + imgUrl+&quot; as &quot;+imgName);
+							spiderImage(imgUrl, imgName+imgType);
+							chD.images.add(imgName+imgType);
+							spideredUrls.add(imgUrl);
+							chD.imagesText.add(imgName); // Keep the image name
+							chD.imagesInfo.add(null);
+							imgCounter++;
+						}
+					}
+				} catch (IndexOutOfBoundsException e) {
+					pref.log(&quot;Problem loading image. imgURL:&quot;+imgUrl);
+				}
+			}
+		}
+	}
+
+	/**
+	 * Read an image from the server
+	 * @param imgUrl The Url of the image
+	 * @param target The bytes of the image
+	 */
+	private void spiderImage(String imgUrl, String target){ // TODO implement a fetch(URL, filename) in HttpConnection and use that one
+		HttpConnection connImg;
+		Socket sockImg;
+		//InputStream is;
+		FileOutputStream fos;
+		//int bytes_read;
+		//byte[] buffer = new byte[9000];
+		ByteArray daten;
+		String datei = &quot;&quot;;
+		datei = profile.dataDir + target;
+		connImg = new HttpConnection(imgUrl);
+		connImg.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
+		if (imgUrl.indexOf('%')&gt;=0) connImg.documentIsEncoded=true; // Don't re encode already encoded images
+		//connImg.setRequestorProperty(&quot;User-Agent&quot;,&quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.12) Gecko/20080201 Firefox/2.0.0.12&quot;);
+		//connImg.setRequestorProperty(&quot;Accept&quot;,&quot;text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5&quot;);
+		try{
+			pref.log(&quot;Trying to fetch image from: &quot; + imgUrl);
+			String redirect=null;
+			do {
+				sockImg = connImg.connect();
+				redirect=connImg.getRedirectTo();
+				if (redirect!=null) {
+					connImg=connImg.getRedirectedConnection(redirect);
+					pref.log(&quot;Redirect to &quot;+redirect);
+				}
+			} while(redirect!=null); // TODO this can end up in an endless loop if trying to load from a malicous site
+			daten = connImg.readData(sockImg);
+			fos = new FileOutputStream(new File(datei));
+			fos.write(daten.toBytes());
+			fos.close();
+			sockImg.close();
+		} catch (UnknownHostException e) {
+			pref.log(&quot;Host not there...&quot;);
+		}catch(IOException ioex){
+			pref.log(&quot;File not found!&quot;);
+		} catch (Exception ex){
+			pref.log(&quot;Some other problem while fetching image&quot;,ex);
+		} finally {
+			//Continue with the spider
+		}
+	}
+
+	/**
+	 * Read all additional waypoints from a previously fetched cachepage.
+	 * @param doc The previously fetched cachepage
+	 * @param wayPoint The name of the cache
+	 * @param is_found Found status of the cached (is inherited by the additional waypoints)
+	 */
+	public void getAddWaypoints(String doc, String wayPoint, boolean is_found) throws Exception{
+		Extractor exWayBlock = new Extractor(doc,p.getProp(&quot;wayBlockExStart&quot;),p.getProp(&quot;wayBlockExEnd&quot;), 0, false);
+		String wayBlock = &quot;&quot;;
+		String rowBlock = &quot;&quot;;
+		wayBlock = exWayBlock.findNext();
+		Regex nameRex = new Regex(p.getProp(&quot;nameRex&quot;));
+		Regex koordRex = new Regex(p.getProp(&quot;koordRex&quot;));
+		Regex descRex = new Regex(p.getProp(&quot;descRex&quot;));
+		Regex typeRex = new Regex(p.getProp(&quot;typeRex&quot;));
+		int counter = 0;
+		if(exWayBlock.endOfSearch() == false &amp;&amp; wayBlock.indexOf(&quot;No additional waypoints to display.&quot;)&lt;0){
+			Extractor exRowBlock = new Extractor(wayBlock,p.getProp(&quot;rowBlockExStart&quot;),p.getProp(&quot;rowBlockExEnd&quot;), 0, false);
+			rowBlock = exRowBlock.findNext();
+			rowBlock = exRowBlock.findNext();
+			while(exRowBlock.endOfSearch()==false){
+				CacheHolderDetail cxD;
+				Extractor exPrefix=new Extractor(rowBlock,p.getProp(&quot;prefixExStart&quot;),p.getProp(&quot;prefixExEnd&quot;),0,true);
+				String prefix=exPrefix.findNext();
+				String adWayPoint;
+				if (prefix.length()==2)
+					adWayPoint=prefix+wayPoint.substring(2);
+				else
+				    adWayPoint = MyLocale.formatLong(counter, &quot;00&quot;) + wayPoint.substring(2);
+				counter++;
+				int idx=profile.getCacheIndex(adWayPoint);
+				if (idx&gt;=0) {
+					cxD=new CacheHolderDetail((CacheHolder) cacheDB.get(idx));
+					try{ // If addi exists, try to read it to preserve the notes
+						cxD.readCache(profile.dataDir);
+					} catch (Exception ex) {};
+				} else {
+					cxD=new CacheHolderDetail(); cxD.wayPoint=adWayPoint;
+				}
+				cxD.is_update=false; cxD.is_new=false;
+				nameRex.search(rowBlock);
+				koordRex.search(rowBlock);
+				typeRex.search(rowBlock);
+				cxD.cacheName = nameRex.stringMatched(1);
+				if(koordRex.didMatch()) cxD.setLatLon(koordRex.stringMatched(1));
+				if(typeRex.didMatch()) cxD.type = CacheType.typeText2Number(&quot;Waypoint|&quot;+typeRex.stringMatched(1));
+				rowBlock = exRowBlock.findNext();
+				descRex.search(rowBlock);
+				cxD.setLongDescription(descRex.stringMatched(1));
+				cxD.is_found = is_found;
+				cxD.saveCacheDetails(profile.dataDir);
+				if (idx&lt;0){
+					cxD.is_new=true; cxD.is_update=false;
+					cacheDB.add(new CacheHolder(cxD));
+				}else {
+					CacheHolder cx=(CacheHolder) cacheDB.get(idx);
+					if (cx.is_Checked &amp;&amp; // Only re-spider existing addi waypoints that are ticked
+				 	   !cx.is_filtered) { // and are visible (i.e.  not filtered)
+					   cx.update(cxD);
+					   cx.is_Checked=true;
+					}
+				}
+				rowBlock = exRowBlock.findNext();
+			}
+		}
+	}
+
+	private void getAttributes(String doc, CacheHolderDetail chD) throws Exception {
+		Extractor attBlock = new Extractor(doc,p.getProp(&quot;attBlockExStart&quot;),p.getProp(&quot;attBlockExEnd&quot;), 0 , true);
+		String atts = attBlock.findNext();
+		Extractor attEx = new Extractor(atts,p.getProp(&quot;attExStart&quot;),p.getProp(&quot;attExEnd&quot;), 0 , true);
+		String attribute=attEx.findNext();
+		chD.attributes.clear();
+		while (attEx.endOfSearch()==false) {
+			chD.attributes.add(attribute);
+			attribute=attEx.findNext();
+		}
+		chD.attributesYes = chD.attributes.attributesYes;
+		chD.attributesNo = chD.attributes.attributesNo;
+	}
+
+
+	/**
+	*	Performs an initial fetch to a given address. In this case
+	*	it will be a gc.com address. This method is used to obtain
+	*	the result of a search for caches screen.
+	*/
+	public static String fetch(String address) {
+		CharArray c_data;
+		try{
+			HttpConnection conn;
+			if(pref.myproxy.length() &gt; 0 &amp;&amp; pref.proxyActive){
+				pref.log(&quot;[fetch]:Using proxy: &quot; + pref.myproxy + &quot; / &quot; +pref.myproxyport);
+			}
+			conn = new HttpConnection(address);
+			conn.setRequestorProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
+			if(cookieSession.length()&gt;0){
+				conn.setRequestorProperty(&quot;Cookie&quot;, &quot;ASP.NET_SessionId=&quot;+cookieSession +&quot;; userid=&quot;+cookieID);
+				pref.log(&quot;[fetch]:Cookie Zeug: &quot; + &quot;Cookie: ASP.NET_SessionId=&quot;+cookieSession +&quot;; userid=&quot;+cookieID);
+			} else
+				pref.log(&quot;[fetch]:No Cookie found&quot;);
+			conn.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
+			conn.documentIsEncoded = true;
+			if (pref.debug) pref.log(&quot;[fetch]:Connecting&quot;);
+			Socket sock = conn.connect();
+			if (pref.debug) pref.log(&quot;[fetch]:Connect ok!&quot;);
+			ByteArray daten = conn.readData(sock);
+			if (pref.debug) pref.log(&quot;[fetch]:Read data ok&quot;);
+			JavaUtf8Codec codec = new JavaUtf8Codec();
+			c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
+			sock.close();
+			return getResponseHeaders(conn)+ c_data.toString();
+		}catch(IOException ioex){
+			pref.log(&quot;IOException in fetch&quot;, ioex);
+		}finally{
+			//continue
+		}
+		return &quot;&quot;;
+	}
+
+	/**
+	*	After a fetch to gc.com the next fetches have to use the post method.
+	*	This method does exactly that. Actually this method is generic in the sense
+	*	that it can be used to post to a URL using http post.
+	*/
+	private static String fetch_post(String address, String document, String path) {
+		HttpConnection conn;
+		try {
+			conn = new HttpConnection(address);
+			JavaUtf8Codec codec = new JavaUtf8Codec();
+			conn.documentIsEncoded = true;
+			conn.setRequestorProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
+			conn.setPostData(codec.encodeText(document.toCharArray(),0,document.length(),true,null));
+			conn.setRequestorProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
+			if(cookieSession.length()&gt;0){
+				conn.setRequestorProperty(&quot;Cookie&quot;, &quot;ASP.NET_SessionId=&quot;+cookieSession+&quot;; userid=&quot;+cookieID);
+				pref.log(&quot;[fetch]:Cookie Zeug: &quot; + &quot;Cookie: ASP.NET_SessionId=&quot;+cookieSession +&quot;; userid=&quot;+cookieID);
+			} else {
+				pref.log(&quot;[fetch]:No Cookie found&quot;);
+			}
+			conn.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
+			if (pref.debug) pref.log(&quot;[fetch]:Connecting&quot;);
+			Socket sock = conn.connect();
+			if (pref.debug) pref.log(&quot;[fetch]:Connect ok!&quot;);
+			ByteArray daten = conn.readData(sock);
+			if (pref.debug) pref.log(&quot;[fetch]:Read data ok&quot;);
+			CharArray c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
+			sock.close();
+			return getResponseHeaders(conn)+c_data.toString();
+		} catch (Exception e) {	}
+		return &quot;&quot;;
+	}
+
+	private static String getResponseHeaders(HttpConnection conn) {
+		PropertyList pl = conn.documentProperties;
+		if (pl != null) {
+			StringBuffer sb = new StringBuffer(1000);
+			boolean gotany = false;
+
+			for (int i = 0; i &lt; pl.size(); i++) {
+				Property p = (Property)pl.get(i);
+				if (p.value != null) {
+					sb.append(p.name).append(&quot;: &quot;).append(p.value).append(&quot;\r\n&quot;);
+					gotany = true;
+				}
+			}
+			if (gotany)
+				return sb.toString() + &quot;\r\n&quot;;
+		}
+		return &quot;&quot;;
+	}
+
+
+	final static String hex = eve.util.TextEncoder.hex;
+
+	public String encodeUTF8URL(byte[] what) {
+		int max = what.length;
+		char [] dest = new char[6*max]; // Assume each char is a UTF char and encoded into 6 chars
+		char d = 0;
+		for (int i = 0; i&lt;max; i++){
+			char c = (char) what[i];
+			if (c &lt;= ' ' || c == '+' || c == '&amp;' || c == '%' || c == '=' ||
+				   c == '|' || c == '{' || c == '}' || c&gt;0x7f ){
+					dest[d++] = '%';
+					dest[d++] = hex.charAt((c &gt;&gt; 4) &amp; 0xf);
+					dest[d++] = hex.charAt(c &amp; 0xf);
+			} else dest[d++] = c;
+		}
+		return new String(dest,0,d);
+	}
+
+	/**
+	 * Load the bug id for a given name. This method is not ideal, as there are
+	 * sometimes several bugs with identical names but different IDs. Normally
+	 * the bug GUID is used which can be obtained from the cache page.&lt;br&gt;
+	 * Note that each bug has both an ID and a GUID.
+	 * @param name The name (or partial name) of a travelbug
+	 * @return the id of the bug
+	 */
+	public String getBugId (String name) {
+		String bugList;
+		try{
+			//infB.setInfo(oldInfoBox+&quot;\nGetting bug: &quot;+bug);
+			pref.log(&quot;Fetching bugId: &quot;+name);
+			bugList = fetch(p.getProp(&quot;getBugByName&quot;)+STRreplace.replace(SafeXML.clean(name),&quot; &quot;,&quot;+&quot;));
+		}catch(Exception ex){
+			pref.log(&quot;Could not fetch bug list&quot;);
+			bugList=&quot;&quot;;
+		}
+		try {
+			if (bugList.equals(&quot;&quot;) || bugList.indexOf(p.getProp(&quot;bugNotFound&quot;))&gt;=0) {
+				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6020,&quot;Travelbug not found.&quot;), MessageBox.OKB)).execute();
+				return &quot;&quot;;
+			}
+			if (bugList.indexOf(p.getProp(&quot;bugTotalRecords&quot;))&lt;0) {
+				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6021,&quot;More than one travelbug found. Specify name more precisely.&quot;), MessageBox.OKB)).execute();
+				return &quot;&quot;;
+			}
+			Extractor exGuid = new Extractor(bugList,p.getProp(&quot;bugGuidExStart&quot;),p.getProp(&quot;bugGuidExEnd&quot;),0,Extractor.EXCLUDESTARTEND); // TODO Replace with spider.def
+			return exGuid.findNext();
+		} catch (Exception ex) {
+			return &quot;&quot;;
+		}
+	}
+
+	/**
+	 * Fetch a bug's mission for a given GUID or ID. If the guid String is longer
+	 * than 10 characters it is assumed to be a GUID, otherwise it is an ID.
+	 * @param guid the guid or id of the travelbug
+	 * @return The mission
+	 */
+	public String getBugMissionByGuid(String guid) {
+		String bugDetails;
+		try{
+			//infB.setInfo(oldInfoBox+&quot;\nGetting bug: &quot;+bug);
+			pref.log(&quot;Fetching bug detailsById: &quot;+guid);
+			if (guid.length()&gt;10)
+				bugDetails = fetch(p.getProp(&quot;getBugByGuid&quot;)+guid);
+			else
+				bugDetails = fetch(p.getProp(&quot;getBugById&quot;)+guid);
+		}catch(Exception ex){
+			pref.log(&quot;Could not fetch bug details&quot;);
+			bugDetails=&quot;&quot;;
+		}
+		try {
+			if (bugDetails.indexOf(p.getProp(&quot;bugNotFound&quot;))&gt;=0) {
+				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6020,&quot;Travelbug not found.&quot;), MessageBox.OKB)).execute();
+				return &quot;&quot;;
+			}
+			Extractor exDetails = new Extractor(bugDetails,p.getProp(&quot;bugDetailsStart&quot;),p.getProp(&quot;bugDetailsEnd&quot;),0,Extractor.EXCLUDESTARTEND);
+			return exDetails.findNext();
+		} catch (Exception ex) {
+			return &quot;&quot;;
+		}
+	}
+
+	/**
+	 * Fetch a bug's mission for a given tracking number
+	 * @param trackNr the tracking number of the travelbug
+	 * @return The mission
+	 */
+	public String getBugMissionByTrackNr(String trackNr) {
+		String bugDetails;
+		try{
+			pref.log(&quot;Fetching bug detailsByTrackNr: &quot;+trackNr);
+			bugDetails = fetch(p.getProp(&quot;getBugByTrackNr&quot;)+trackNr);
+		}catch(Exception ex){
+			pref.log(&quot;Could not fetch bug details&quot;);
+			bugDetails=&quot;&quot;;
+		}
+		try {
+			if (bugDetails.indexOf(p.getProp(&quot;bugNotFound&quot;))&gt;=0) {
+//				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6020,&quot;Travelbug not found.&quot;), MessageBox.OKB)).execute();
+				return &quot;&quot;;
+			}
+			Extractor exDetails = new Extractor(bugDetails,p.getProp(&quot;bugDetailsStart&quot;),p.getProp(&quot;bugDetailsEnd&quot;),0,Extractor.EXCLUDESTARTEND);
+			return exDetails.findNext();
+		} catch (Exception ex) {
+			return &quot;&quot;;
+		}
+	}
+
+	/**
+	 * Fetch a bug's mission and namefor a given tracking number
+	 * @param TB the travelbug
+	 * @return true if suceeded
+	 */
+	public boolean getBugMissionAndNameByTrackNr(Travelbug TB) {
+		String bugDetails;
+		String trackNr = TB.getTrackingNo();
+		try{
+			pref.log(&quot;Fetching bug detailsByTrackNr: &quot;+trackNr);
+			bugDetails = fetch(p.getProp(&quot;getBugByTrackNr&quot;)+trackNr);
+		}catch(Exception ex){
+			pref.log(&quot;Could not fetch bug details&quot;);
+			bugDetails=&quot;&quot;;
+		}
+		try {
+			if (bugDetails.indexOf(p.getProp(&quot;bugNotFound&quot;))&gt;=0) {
+//				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(6020,&quot;Travelbug not found.&quot;), MessageBox.OKB)).execute();
+				return false;
+			}
+			Extractor exDetails = new Extractor(bugDetails,p.getProp(&quot;bugDetailsStart&quot;),p.getProp(&quot;bugDetailsEnd&quot;),0,Extractor.EXCLUDESTARTEND);
+			TB.setMission( exDetails.findNext() );
+			Extractor exName = new Extractor(bugDetails,p.getProp(&quot;bugNameStart&quot;),p.getProp(&quot;bugNameEnd&quot;),0,Extractor.EXCLUDESTARTEND);
+			TB.setName( exName.findNext() );
+			return true;
+		} catch (Exception ex) {
+			return false;
+		}
+	}
+
+	private class myProperties extends Properties {
+		static final long serialVersionUID=0; // for compiler only
+		myProperties() {
+			super();
+			try {
+				load(new FileInputStream(eve.io.File.getProgramDirectory()+&quot;/spider.def&quot;));
+			} catch (Exception ex) {
+				pref.log(&quot;Failed to load spider.def&quot;,ex);
+				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5504,&quot;Could not load 'spider.def'&quot;), MessageBox.OKB)).execute();
+			}
+		}
+		public String getProp(String key) throws Exception {
+			String s=super.getProperty(key);
+			if (s==null) {
+				(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5497,&quot;Error missing tag in spider.def&quot;) + &quot;: &quot;+key, MessageBox.OKB)).execute();
+				throw new Exception(&quot;Missing tag in spider.def: &quot;+key);
+			}
+			return s;
+		}
+
+	}
+}

Added: experiments/EVE/src/cachewolf/navi/Area.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/Area.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/Area.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,144 @@
+package cachewolf.navi;
+
+import cachewolf.CWPoint;
+
+public class Area {
+	 public final static int NOT_ON_EDGE = -1;
+	 public final static int AT_TOP_EDGE = 1;
+	 public final static int AT_RIGHT_EDGE = 2;
+	 public final static int AT_BUTTOM_EDGE = 3;
+	 public final static int AT_LEFT_EDGE = 4;
+	 public static final double edgeTolerance = 3 * 360/40000000; // approx 3m will be seen as the same
+
+	 CWPoint topleft;
+	 CWPoint buttomright;
+	 
+	 public Area() {
+		 topleft = new CWPoint();
+		 buttomright = new CWPoint();
+	 }
+
+	 public Area(TrackPoint tl, TrackPoint br){
+		 topleft = new CWPoint(tl);
+		 buttomright = new CWPoint(br);
+	 }
+
+	 public boolean isInBound(TrackPoint p) {
+		 if (topleft.latDec &gt;= p.latDec &amp;&amp; topleft.lonDec &lt;= p.lonDec 
+				 &amp;&amp; buttomright.latDec &lt;= p.latDec &amp;&amp; buttomright.lonDec &gt;= p.lonDec) return true;
+		 return false;
+	 }
+	 //if(affine[4] &gt;= lati &amp;&amp; lati &gt;= lowlat &amp;&amp; affine[5] &lt;= loni &amp;&amp; loni &lt;= lowlon) isInBound = true;
+		
+	 public boolean isInBound(double lat, double lon) {
+		 if (topleft.latDec &gt;= lat &amp;&amp; topleft.lonDec &lt;= lon
+				 &amp;&amp; buttomright.latDec &lt;= lat &amp;&amp; buttomright.lonDec &gt;= lon) return true;
+		 return false;
+	 }
+
+	/**
+	 * test if a is completly within this
+	 * @param a
+	 * @return
+	 */
+	 public boolean isInBound(Area a) {
+		 return (isInBound(a.topleft) &amp;&amp; isInBound(a.buttomright));
+	 }
+	 
+	 
+	 public boolean isOverlapping(Area a) {
+		 if (       isInBound(a.topleft) || isInBound(a.buttomright) 
+				 || isInBound(a.buttomright.latDec, a.topleft.lonDec) // buttom left
+				 || isInBound(a.topleft.latDec, a.buttomright.lonDec) // top right
+				 // in case this is completly within a, the above tests will give false, so testing the otherway around
+				 || a.isInBound(this.topleft) || a.isInBound(this.buttomright)
+				 || a.isInBound(this.buttomright.latDec, this.topleft.lonDec) // buttom left
+				 || a.isInBound(this.topleft.latDec, this.buttomright.lonDec)) // top right
+			 return true;
+		 return false;
+	 }
+
+	 public boolean equals(Area a) {
+		 if(java.lang.Math.abs(topleft.latDec - a.topleft.latDec) &lt; edgeTolerance 
+				 &amp;&amp; java.lang.Math.abs(topleft.lonDec - a.topleft.lonDec) &lt; edgeTolerance
+				 &amp;&amp; java.lang.Math.abs(buttomright.latDec - a.buttomright.latDec) &lt; edgeTolerance
+				 &amp;&amp; java.lang.Math.abs(buttomright.lonDec - a.buttomright.lonDec) &lt; edgeTolerance )
+			 return true;
+		 return false;
+	 }
+	 
+	 public int getEdge(CWPoint tl, CWPoint br) {
+		 if (java.lang.Math.abs(topleft.latDec - br.latDec) &lt; edgeTolerance 
+				 &amp;&amp; java.lang.Math.abs(topleft.lonDec - tl.lonDec) &lt; edgeTolerance 
+				 &amp;&amp; java.lang.Math.abs(buttomright.lonDec - br.lonDec) &lt; edgeTolerance)
+			 return AT_TOP_EDGE;
+			 if (java.lang.Math.abs(topleft.latDec - tl.latDec) &lt; edgeTolerance 
+					 &amp;&amp; java.lang.Math.abs(buttomright.lonDec - tl.lonDec) &lt; edgeTolerance 
+					 &amp;&amp; java.lang.Math.abs(buttomright.latDec - br.latDec) &lt; edgeTolerance)
+				 return AT_RIGHT_EDGE;
+			 if (java.lang.Math.abs(topleft.lonDec - tl.lonDec) &lt; edgeTolerance 
+					 &amp;&amp; java.lang.Math.abs(buttomright.latDec - tl.latDec) &lt; edgeTolerance 
+					 &amp;&amp; java.lang.Math.abs(buttomright.lonDec - br.lonDec) &lt; edgeTolerance)
+				 return AT_BUTTOM_EDGE;
+			 if (java.lang.Math.abs(topleft.latDec - tl.latDec) &lt; edgeTolerance 
+					 &amp;&amp; java.lang.Math.abs(topleft.lonDec - br.lonDec) &lt; edgeTolerance 
+					 &amp;&amp; java.lang.Math.abs(buttomright.latDec - br.latDec) &lt; edgeTolerance)
+				 return AT_LEFT_EDGE;
+			 return NOT_ON_EDGE;
+	 }
+	 
+	 /**
+	  * get an easy find string for this area
+	  * @return
+	  */
+	 public String getEasyFindString() {
+		 String ul = getEasyFindString(topleft, 30);
+		 String br = getEasyFindString(buttomright, 30);
+		 int i;
+		 for (i=0; i&lt;br.length(); i++ ) {
+			 if (ul.charAt(i) != br.charAt(i)) break;
+		 }
+		 //eve.sys.Vm.debug(ul+&quot;\n&quot;+br+&quot;\n i:&quot;+i);
+		 return ul.substring(0, i);
+	 }
+	 
+	 /**
+	  * get an easy find string for a given point with precision prec
+	  * @param prec number of digits to return, min 2, max: 30
+	  * @return
+	  */
+	 public static String getEasyFindString(CWPoint p, int prec) {
+		 double longinrange = p.lonDec;
+		 if (longinrange &gt; 180) longinrange -= 180;
+		 Double kw = new Double(((p.latDec+90d)/180d) *  (1 &lt;&lt; prec));
+		 int lat = (int)((p.latDec+90d)/180d *  (1 &lt;&lt; prec)); // TODO handle negative values
+		 lat = kw.intValue();
+		 //kw = (double) (1 &lt;&lt; (prec));
+		 
+		 //kw = new Double(((longinrange+180)/360) * (2 ^ (prec -1)));
+		 int lon = (int)(((longinrange+180)/360) *  (1 &lt;&lt; (prec))); // 180 = 10110100
+		 String ret = &quot;&quot;;
+		 int tmp;
+		 for (int i=prec-1; i&gt;=0;  i--) {
+			 tmp = (1 &lt;&lt; i);
+			 tmp = (lat &amp; (1 &lt;&lt; i));
+			 tmp = ((lat &amp; (1 &lt;&lt; i)) &gt;&gt; i);
+			 tmp = ((lon &amp; (1 &lt;&lt; i)) &gt;&gt; i) + (((lat &amp; (1 &lt;&lt; i) ) &lt;&lt; 1) &gt;&gt; i);
+			 ret += Integer.toString(tmp);
+		 }
+		 return ret;
+	 }
+	 
+	 static public boolean containsRoughly(String boundingbox, String q) {
+		 if (boundingbox.length() &lt;= q.length() ) return q.startsWith(boundingbox);
+		 return boundingbox.startsWith(q);
+	 }
+	 
+	 public String toString() {
+		 return topleft.toString() + &quot;, &quot; + buttomright.toString();
+	 }
+	 
+	 public CWPoint getCenter() {
+		 return new CWPoint((topleft.latDec + buttomright.latDec)/2, (topleft.lonDec + buttomright.lonDec)/2);
+	 }
+}

Added: experiments/EVE/src/cachewolf/navi/AreaList.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/AreaList.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/AreaList.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,73 @@
+package cachewolf.navi;
+
+
+/**
+ * Class for handling a list of areas covered by a list of maps.
+ * this is needed to determine if a new map should be downloaded or
+ * if a map for the requested area already exists
+ *
+ * @author pfeffer
+ *
+ */
+ public class AreaList extends eve.util.LinkedListElement { // in java since v1.2 I would use java.util.TreeSet
+/*
+	 public AreaList(int s) {super(s);}
+
+	 public void addArea(CWPoint topleft, CWPoint buttomright) {
+		 Area tp = getArea(topleft);
+		 if (tp != null &amp;&amp; tp.isInBound(buttomright)) return; // area already completly in list
+		 int edge = tp.getEdge(topleft, buttomright);
+		 switch (edge) {
+		 case Area.AT_TOP_EDGE: tp.topleft.latDec = topleft.latDec; break;
+		 case Area.AT_RIGHT_EDGE: tp.buttomright.lonDec = buttomright.lonDec; break;
+		 case Area.AT_BUTTOM_EDGE: tp.buttomright.latDec = buttomright.latDec; break;
+		 case Area.AT_LEFT_EDGE: tp.topleft.lonDec = topleft.lonDec; break;
+		 case Area.NOT_ON_EDGE: addAreaUnconditionally(new Area(topleft, buttomright));
+		 }
+	 }
+
+	 public boolean AreaIsCovered(CWPoint topleft, CWPoint buttomright) {
+		 Area tp = getArea(topleft);
+		 if (tp != null &amp;&amp; tp.isInBound(buttomright)) return true; // area already completly in list
+		 else return false;
+
+	 }
+
+	 public void addArea(Area a) {
+		 addArea(a.topleft, a.buttomright);
+	 }
+
+	 public static AreaList joinAreas(AreaList al){
+		 AreaList ret = null;
+		 while (!al.equals(ret)) {
+			 ret = new AreaList(al.size());
+			 for (int i=al.size()-1; i &gt;= 0; i--) {
+				 ret.addArea((Area)al.get(i));
+			 }
+		 }
+		 return ret;
+	 }
+
+	 public boolean equals(AreaList al){
+		 if (size() != al.size()) return false;
+		 for (int i = size()-1; i &gt;= 0; i--) {
+			 if (!( ((Area)get(i)).equals((Area)al.get(i)) )) return false;
+		 }
+		 return true;
+	 }
+
+	 private void addAreaUnconditionally(Area a) {
+		 add(a); // TODO insert at the correct / sorted position
+	 }
+
+	 public Area getArea(CWPoint p) {
+		 Area ret;
+		 for (int i=size()-1; i&gt;=0; i--) {
+			 ret = ((Area)get(i));
+			 if(ret.isInBound(p)) return ret;
+		 }
+		 return null;
+	 }
+
+*/
+ }

Added: experiments/EVE/src/cachewolf/navi/CWGPSPoint.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/CWGPSPoint.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/CWGPSPoint.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,396 @@
+/*
+ * Created on 02.04.2005
+ *
+ * TODO To change the template for this generated file go to
+ * Window - Preferences - Java - Code Style - Code Templates
+ */
+package cachewolf.navi;
+import eve.sys.*;
+import java.io.*;
+
+import cachewolf.CWPoint;
+import cachewolf.Global;
+import cachewolf.utils.Common;
+import cachewolf.utils.Extractor;
+
+
+
+
+/**
+ * @author Kalle
+ * Class for decoding NMEA sentences
+ */
+
+public class CWGPSPoint extends CWPoint implements TimerProc{
+	public static final int LOGNMEA = 0x01;
+	public static final int LOGRAW  = 0x02;
+	public static final int LOGALL  = LOGNMEA|LOGRAW;
+
+	public double speed; //Speed
+	public double bear;	//Bearing
+	public String time; //Time
+	public String date;
+	public int fix; //Fix
+	public int numSat; //Satellites in use, -1 indicates no data, -2 that data could not be interpreted
+	public int numSatsInView; //Satellites in view
+	public double HDOP; // Horizontal dilution of precision
+	public double alt; //Altitude
+
+	//Logging
+	Timer logTimer = null;
+	int logFlag = 0;
+	boolean writeLog = false;
+	boolean doLogging = false;
+	FileWriter logFile;
+	String lastStrExamined = new String();
+
+
+	public CWGPSPoint()
+	{
+		super();
+		this.speed = 0;
+		this.bear = 0;
+		this.time = &quot;&quot;;
+		this.date=&quot;&quot;;
+		this.fix = 0;
+		this.numSat = 0;
+		this.numSatsInView = 0;
+		this.alt = 0;
+		this.HDOP = 0;
+	}
+
+
+	public double getSpeed(){
+		return this.speed;
+	}
+
+	public double getBear (){
+		return this.bear;
+	}
+	public String getTime(){
+		return this.time;
+	}
+
+	/**
+	 * @return &gt; 0: fixed &lt;br&gt; 0: not fixed &lt;br&gt; -1: no data from serial port &lt;br&gt; -2 data from serial port could not be interpreted
+	 */
+	public int getFix(){
+		return this.fix;
+	}
+
+	/**
+	 * this method should be called, if COM-Port is closed
+	 */
+	public void noData(){
+		this.fix = 0;
+		this.numSat = 0;
+		this.HDOP = 0;
+	}
+
+	/**
+	 * this method should be called, if not data is coming from COM-Port but is expected to come
+	 */
+	public void noDataError(){
+		this.fix = -1;
+		this.numSat = -1;
+		this.HDOP = -1;
+	}
+
+	/**
+	 * this method should be called, if examine returns for several calls that it couldn't interprete the data
+	 */
+	public void noInterpretableData(){
+		this.fix = -2;
+		this.numSat = -2;
+		this.HDOP = -2;
+	}
+
+	public void ticked(Object timerId, long elapsed) {
+		if (timerId == logTimer) {
+			writeLog = true;
+		}
+	}
+
+	/**
+	 *
+	 * @param logFileDir directory for logfile
+	 * @param seconds	 intervall for writing to logfile
+	 * @param flag		 level of logging
+	 * @return 0 success, -1 failure
+	 */
+	public int startLog(String logFileDir, int seconds, int flag){
+
+		Time currTime = new Time();
+		currTime.getTime();
+		currTime.setFormat(&quot;yyyyMMdd'_'HHmm&quot;);
+		String logFileName = new String(logFileDir + currTime.toString()+ &quot;.log&quot;);
+		// create Logfile
+		try {
+			logFile = new FileWriter(logFileName);
+		} catch (IOException e) {
+			Vm.debug(&quot;Error creating LogFile &quot; + logFileName);
+			return -1;
+		}
+		// start timer
+		logTimer = (Timer) eve.sys.Timer.requestTick(this, 1000 * seconds);
+		logFlag = flag;
+		doLogging = true;
+		return 0;
+	}
+
+	public void stopLog() {
+		writeLog = false;
+
+		if (doLogging){
+			try {
+				logFile.close();
+			} catch (IOException e) {}
+			if (logTimer !=null) {
+				logTimer = null;
+			}
+		}
+		doLogging = false;
+	}
+
+
+	public int getSats(){
+		return this.numSat;
+	}
+
+	public int getSatsInView(){
+		return this.numSatsInView;
+	}
+
+	public double getAlt(){
+		return this.alt;
+	}
+
+	public double getHDOP(){
+		return this.HDOP;
+	}
+
+	/**
+	 *
+	 * @param NMEA	string with data to examine
+	 * @return true if some data could be interpreted false otherwise
+	 */
+	public boolean examine(String NMEA){
+		boolean interpreted = false;
+		boolean logWritten = false;
+		try {
+			int i, start, end;
+			String latDeg=&quot;0&quot;, latMin=&quot;0&quot;, latNS=&quot;N&quot;;
+			String lonDeg=&quot;0&quot;, lonMin=&quot;0&quot;, lonEW=&quot;E&quot;;
+			String currToken;
+			end = 0;
+			lastStrExamined = NMEA;
+			//Vm.debug(NMEA);
+/*			if (writeLog &amp;&amp; (logFlag &amp; LOGRAW) &gt; 0){
+				try {
+					logFile.write(NMEA);
+					writeLog = false;
+				} catch (IOException e) {}
+			}
+*/			while(true){
+				start = NMEA.indexOf(&quot;$GP&quot;, end);
+				if (start == -1) break;
+				end = NMEA.indexOf(&quot;*&quot;, start);
+				if ((end == -1)||(end+3 &gt; NMEA.length())) break;
+
+
+				//Vm.debug(NMEA.substring(start,end+3));
+				if ((end - start) &lt; 15 || !checkSumOK(NMEA.substring(start,end+3))){
+					//Vm.debug(&quot;checksum wrong&quot;);
+					continue;
+				}
+				// Write log after finding valid NMEA sequence
+				if (writeLog &amp;&amp; (logFlag &amp; LOGRAW) &gt; 0){
+					try {
+						logFile.write(NMEA.substring(start,end+3)+&quot;\n&quot;);
+						logWritten = true;
+					} catch (IOException e) {}
+				}
+
+				Extractor ex = new Extractor (&quot;,&quot; + NMEA.substring(start,end), &quot;,&quot;,&quot;,&quot;,0,true);
+				currToken = ex.findNext();
+				if (currToken.equals(&quot;$GPGGA&quot;)){
+					//Vm.debug(&quot;In $GPGGA&quot;);
+					i = 0;
+					while(ex.endOfSearch() != true){
+						boolean latlonerror = false; // indicate that some error occured in the data -&gt; in this case frace fix to non-fixed in order to avoid invalid coordinates when a fix is indicated to the higher level API
+						currToken = ex.findNext();
+						i++;
+						if (currToken.length()==0) {
+							if (i &gt;= 2 &amp;&amp; i &lt;= 5) latlonerror = true; // force non-fix if lat-lon not contained
+							continue; // sometimes there are 2 colons directly one after the other like &quot;,,&quot; (e.g. loox)
+						}
+						switch (i){
+						case 1: this.time = currToken; break;
+						case 2: try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
+						try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
+						break;
+						case 3: latNS = currToken;
+						break;
+
+						case 4: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
+						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true; } catch (IndexOutOfBoundsException e) {latlonerror = true;}
+						break;
+						case 5: lonEW = currToken;
+						break;
+						case 6:
+							if (!latlonerror) {
+								this.fix = Convert.toInt(currToken);
+								interpreted = true;
+								break;
+							} else {
+								this.fix = 0;
+								break;
+							}
+						case 7: this.numSat = Convert.toInt(currToken); interpreted = true; break;
+						case 8: try {this.HDOP = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} break;
+						case 9: try {this.alt = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {} break;
+						} // switch
+					} // while
+					if (fix &gt; 0) this.set(latNS, latDeg, latMin, &quot;0&quot;, lonEW, lonDeg, lonMin, &quot;0&quot;, CWPoint.DMM);
+
+				} // if
+
+				if (currToken.equals(&quot;$GPVTG&quot;)){
+					i = 0;
+					while(ex.endOfSearch() != true){
+						currToken = ex.findNext();
+						i++;
+						if (currToken.length()==0) continue;
+						switch (i){
+						case 1: try { this.bear =Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {}
+						if (this.bear &gt; 360) Vm.debug(&quot;Error bear VTG&quot;);
+						break;
+						case 7: try { this.speed = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {}
+						break;
+						} // switch
+					} // while
+				} // if
+
+				if (currToken.equals(&quot;$GPRMC&quot;)){
+					//Vm.debug(&quot;In $GPRMC&quot;);
+					i = 0;
+					String status = &quot;V&quot;;
+					boolean latlonerror = false;
+					while(ex.endOfSearch() != true){
+						currToken = ex.findNext();
+						i++;
+						if (currToken.length()==0) {
+							if (i &gt;= 2 &amp;&amp; i &lt;= 6) latlonerror = true; // force non-fix if lat-lon not contained
+							continue; // sometimes there are 2 colons directly one after the other like &quot;,,&quot; (e.g. loox)
+						}
+						if (currToken.length()==0) continue;
+						//Vm.debug(&quot;zz: &quot; + i);
+						//Vm.debug(currToken);
+						switch (i){
+						case 1: this.time = currToken; interpreted = true; break;
+						case 2: status = currToken;
+						if (status.equals(&quot;A&quot;)) this.fix = 1;
+						else this.fix = 0;
+						interpreted = true;
+						break;
+						case 3: 	//Vm.debug(&quot;Here---&gt;&quot;);
+							try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
+							//Vm.debug(&quot;:&quot; + latDeg);
+							try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
+							//Vm.debug(&quot;:&quot; + latMin);
+							break;
+						case 4: latNS = currToken; interpreted = true;
+						break;
+						case 5: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {}
+						break;
+						case 6: lonEW = currToken;
+						interpreted = true;
+						break;
+						case 7: if (status.equals(&quot;A&quot;)){
+							try {this.speed = Common.parseDouble(currToken)*1.854;
+							interpreted = true; } catch (NumberFormatException e) { }
+						}
+						break;
+						case 8: if (status.equals(&quot;A&quot;) &amp;&amp; currToken.length()&gt; 0){
+							try {this.bear = Common.parseDouble(currToken);
+							interpreted = true; } catch (NumberFormatException e) { }
+						}
+						break;
+						case 9: if (status.equals(&quot;A&quot;) &amp;&amp; currToken.length()&gt; 0){
+							try {this.date = currToken;
+							interpreted = true; } catch (NumberFormatException e) { }
+						}
+						break;
+						} // switch
+					} // while
+					if (latlonerror) this.fix = 0;
+					else {
+						if (status.equals(&quot;A&quot;)){
+							this.set(latNS, latDeg, latMin, &quot;0&quot;,
+									lonEW, lonDeg, lonMin, &quot;0&quot;, CWPoint.DMM);
+						}
+					}
+				} // if
+
+				if (currToken.equals(&quot;$GPGSV&quot;)){
+					//Vm.debug(&quot;In $$GPGSV&quot;);
+					i = 0;
+					while(ex.endOfSearch() != true){
+						currToken = ex.findNext();
+						i++;
+						if (currToken.length()==0) continue; // sometimes there are 2 colons directly one after the other like &quot;,,&quot; (e.g. loox)
+						switch (i){
+						case 3: this.numSatsInView = Convert.toInt(currToken); interpreted = true; break;
+						} // switch
+					} // while
+				} // if
+
+				//Vm.debug(&quot;End of examine&quot;);
+			} //while
+		} catch (Exception e) {
+			Global.getPref().log(&quot;Exception in examine in CWGPSPoint&quot;, e, true);
+			e.printStackTrace();
+		}
+
+		if	(logWritten)
+			writeLog = false;
+
+		return interpreted;
+	}
+
+	private boolean checkSumOK(String nmea){
+		int startPos = 1; // begin after $
+		int endPos = nmea.length() - 3;// without * an two checksum chars
+		byte checkSum = 0;
+
+		for (int i= startPos; i&lt;endPos;i++){
+			checkSum ^= nmea.charAt(i);
+		}
+		//Vm.debug(nmea.substring(3,6)+&quot; Checksum: &quot; + nmea.substring(endPos+1) + &quot; Calculated: &quot; + Convert.intToHexString(checkSum));
+		try { return (checkSum == Byte.parseByte(nmea.substring(endPos+1),16));
+		} catch (IndexOutOfBoundsException e) {
+			return false;
+		} catch (NumberFormatException e) {
+			return false;
+		}
+	}
+
+
+
+	public void printAll(){
+		Vm.debug(&quot;Latitude:     &quot; + this.getLatDeg(DD));
+		Vm.debug(&quot;Longitude:    &quot; + this.getLonDeg(DD));
+		Vm.debug(&quot;Speed:        &quot; + this.speed);
+		Vm.debug(&quot;Bearing:      &quot; + this.bear);
+		Vm.debug(&quot;Time:         &quot; + this.time);
+		Vm.debug(&quot;Fix:          &quot; + this.fix);
+		Vm.debug(&quot;Sats:         &quot; + this.numSat);
+		Vm.debug(&quot;Sats in view: &quot; + this.numSatsInView);
+		Vm.debug(&quot;HDOP:         &quot; + this.HDOP);
+		Vm.debug(&quot;Alt:          &quot; + this.alt);
+		Vm.debug(&quot;----------------&quot;);
+	}
+}
+
+

Added: experiments/EVE/src/cachewolf/navi/Ellipsoid.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/Ellipsoid.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/Ellipsoid.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,51 @@
+package cachewolf.navi;
+
+public class Ellipsoid {
+        public double a, b;
+        /**
+         * 
+         * @param ai
+         * @param bi
+         * @param isminoraxis if true bi is interpreted as axis, if false bi is interpreted as flattening
+         */
+        public Ellipsoid(double ai, double bi, boolean isminoraxis ) {
+                a = ai;
+                if (isminoraxis) b = bi; // flattening = (a - b) / a
+                else {
+                        b = a - (1/bi) * a;
+                }
+        }
+        
+           /**
+            * Get semi-major axis.
+            * @return semi-major axis (in meters).
+            */
+           public double getSemiMajorAxis() {
+             return a;
+           }
+
+           /**
+            * Get semi-minor axis.
+            * @return semi-minor axis (in meters).
+            */
+           public double getSemiMinorAxis() {
+             return b;
+           }
+
+           /**
+            * Get flattening
+            * @return
+            */
+           public double getFlattening() {
+             return (a - b) / a;
+           }
+
+           /**
+            * Get inverse flattening.
+            * @return
+            */
+           public double getInverseFlattening() {
+             return a / (a - b);
+           }
+      }
+

Added: experiments/EVE/src/cachewolf/navi/GeodeticCalculator.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/GeodeticCalculator.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/GeodeticCalculator.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,353 @@
+/* Geodesy by Mike Gavaghan
+ * 
+ * <A HREF="http://www.gavaghan.org/blog/free-source-code/geodesy-library-vincentys-formula/">http://www.gavaghan.org/blog/free-source-code/geodesy-library-vincentys-formula/</A>
+ * 
+ * This code may be freely used and modified on any personal or professional
+ * project.  It comes with no warranty.
+ */
+
+package cachewolf.navi;
+
+/**
+ * &lt;p&gt;
+ * Implementation of Thaddeus Vincenty's algorithms to solve the direct and inverse
+ * geodetic problems. For more information, see Vincent's original publication on
+ * the NOAA website:
+ * &lt;/p&gt;
+ * See <A HREF="http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf">http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf</A>
+ * 
+ * @author Mike Gavaghan
+ * 
+ * Adapted for CacheWolf by Michael Kunz (MiK77)
+ */
+public class GeodeticCalculator
+{
+   static private final double TwoPi = 2.0 * Math.PI;
+   
+   /** Degrees/Radians conversion constant. */
+   static private final double PiOver180 = Math.PI / 180.0;
+
+   /**
+    * Calculate the destination and final bearing after traveling a specified
+    * distance, and a specified starting bearing, for an initial location. This
+    * is the solution to the direct geodetic problem.
+    * 
+    * @param ellipsoid reference ellipsoid to use
+    * @param start starting location
+    * @param startBearing starting bearing (degrees)
+    * @param distance distance to travel (meters)
+    * @param endBearing bearing at destination (degrees) element at index 0 will
+    *            be populated with the result
+    * @return
+    */
+   static public TrackPoint calculateEndingGlobalCoordinates(Ellipsoid ellipsoid, TrackPoint start, double startBearing, double distance,
+         double[] endBearing)
+   {
+      double a = ellipsoid.getSemiMajorAxis();
+      double b = ellipsoid.getSemiMinorAxis();
+      double aSquared = a * a;
+      double bSquared = b * b;
+      double f = ellipsoid.getFlattening();
+      double phi1 = start.latDec  * PiOver180;
+      double alpha1 = startBearing * PiOver180;
+      double cosAlpha1 = Math.cos(alpha1);
+      double sinAlpha1 = Math.sin(alpha1);
+      double s = distance;
+      double tanU1 = (1.0 - f) * Math.tan(phi1);
+      double cosU1 = 1.0 / Math.sqrt(1.0 + tanU1 * tanU1);
+      double sinU1 = tanU1 * cosU1;
+
+      // eq. 1
+      double sigma1 = Math.atan2(tanU1, cosAlpha1);
+
+      // eq. 2
+      double sinAlpha = cosU1 * sinAlpha1;
+
+      double sin2Alpha = sinAlpha * sinAlpha;
+      double cos2Alpha = 1 - sin2Alpha;
+      double uSquared = cos2Alpha * (aSquared - bSquared) / bSquared;
+
+      // eq. 3
+      double A = 1 + (uSquared / 16384) * (4096 + uSquared * (-768 + uSquared * (320 - 175 * uSquared)));
+
+      // eq. 4
+      double B = (uSquared / 1024) * (256 + uSquared * (-128 + uSquared * (74 - 47 * uSquared)));
+
+      // iterate until there is a negligible change in sigma
+      double deltaSigma;
+      double sOverbA = s / (b * A);
+      double sigma = sOverbA;
+      double sinSigma;
+      double prevSigma = sOverbA;
+      double sigmaM2;
+      double cosSigmaM2;
+      double cos2SigmaM2;
+
+      for (;;)
+      {
+         // eq. 5
+         sigmaM2 = 2.0 * sigma1 + sigma;
+         cosSigmaM2 = Math.cos(sigmaM2);
+         cos2SigmaM2 = cosSigmaM2 * cosSigmaM2;
+         sinSigma = Math.sin(sigma);
+         double cosSignma = Math.cos(sigma);
+
+         // eq. 6
+         deltaSigma = B
+               * sinSigma
+               * (cosSigmaM2 + (B / 4.0)
+                     * (cosSignma * (-1 + 2 * cos2SigmaM2) - (B / 6.0) * cosSigmaM2 * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM2)));
+
+         // eq. 7
+         sigma = sOverbA + deltaSigma;
+
+         // break after converging to tolerance
+         if (Math.abs(sigma - prevSigma) &lt; 0.0000000000001) break;
+
+         prevSigma = sigma;
+      }
+
+      sigmaM2 = 2.0 * sigma1 + sigma;
+      cosSigmaM2 = Math.cos(sigmaM2);
+      cos2SigmaM2 = cosSigmaM2 * cosSigmaM2;
+
+      double cosSigma = Math.cos(sigma);
+      sinSigma = Math.sin(sigma);
+
+      // eq. 8
+      double phi2 = Math.atan2(sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1, (1.0 - f)
+            * Math.sqrt(sin2Alpha + Math.pow(sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1, 2.0)));
+
+      // eq. 9
+      double tanLambda = sinSigma * sinAlpha1 / (cosU1 * cosSigma - sinU1 * sinSigma * cosAlpha1);
+      double lambda = Math.atan(tanLambda);
+
+      // eq. 10
+      double C = (f / 16) * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));
+
+      // eq. 11
+      double L = lambda - (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cosSigmaM2 + C * cosSigma * (-1 + 2 * cos2SigmaM2)));
+
+      // eq. 12
+      double alpha2 = Math.atan2(sinAlpha, -sinU1 * sinSigma + cosU1 * cosSigma * cosAlpha1);
+
+      // build result
+      double latitude = phi2 / PiOver180;
+      double longitude = start.lonDec + (L / PiOver180);
+
+      if ((endBearing != null) &amp;&amp; (endBearing.length &gt; 0))
+      {
+         endBearing[0] = alpha2 / PiOver180;
+      }
+
+      return new TrackPoint(latitude, longitude);
+   }
+
+   /**
+    * Calculate the destination after traveling a specified distance, and a
+    * specified starting bearing, for an initial location. This is the solution
+    * to the direct geodetic problem.
+    * 
+    * @param ellipsoid reference ellipsoid to use
+    * @param start starting location
+    * @param startBearing starting bearing (degrees)
+    * @param distance distance to travel (meters)
+    * @return
+    */
+   static public TrackPoint calculateEndingGlobalCoordinates(Ellipsoid ellipsoid, TrackPoint start, double startBearing, double distance)
+   {
+      return calculateEndingGlobalCoordinates(ellipsoid, start, startBearing, distance, null);
+   }
+
+   /**
+    * Calculate the geodetic curve between two points on a specified reference
+    * ellipsoid. This is the solution to the inverse geodetic problem.
+    * 
+    * @param ellipsoid reference ellipsoid to use
+    * @param start starting coordinates
+    * @param end ending coordinates
+    * @return
+    */
+//   public GeodeticCurve calculateGeodeticCurve(Ellipsoid ellipsoid, TrackPoint start, TrackPoint end)
+   static public double calculateDistanceAndBearing(Ellipsoid ellipsoid, TrackPoint start, TrackPoint end, double[] bearing)
+   {
+      //
+      // All equation numbers refer back to Vincenty's publication:
+      // See <A HREF="http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf">http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf</A>
+      //
+
+      // get constants
+      double a = ellipsoid.getSemiMajorAxis();
+      double b = ellipsoid.getSemiMinorAxis();
+      double f = ellipsoid.getFlattening();
+
+      // get parameters as radians
+      double phi1 = start.latDec * PiOver180;
+      double lambda1 = start.lonDec * PiOver180;
+      double phi2 = end.latDec * PiOver180;
+      double lambda2 = end.lonDec * PiOver180;
+
+      // calculations
+      double a2 = a * a;
+      double b2 = b * b;
+      double a2b2b2 = (a2 - b2) / b2;
+
+      double omega = lambda2 - lambda1;
+
+      double tanphi1 = Math.tan(phi1);
+      double tanU1 = (1.0 - f) * tanphi1;
+      double U1 = Math.atan(tanU1);
+      double sinU1 = Math.sin(U1);
+      double cosU1 = Math.cos(U1);
+
+      double tanphi2 = Math.tan(phi2);
+      double tanU2 = (1.0 - f) * tanphi2;
+      double U2 = Math.atan(tanU2);
+      double sinU2 = Math.sin(U2);
+      double cosU2 = Math.cos(U2);
+
+      double sinU1sinU2 = sinU1 * sinU2;
+      double cosU1sinU2 = cosU1 * sinU2;
+      double sinU1cosU2 = sinU1 * cosU2;
+      double cosU1cosU2 = cosU1 * cosU2;
+
+      // eq. 13
+      double lambda = omega;
+
+      // intermediates we'll need to compute 's'
+      double A = 0.0;
+      double B = 0.0;
+      double sigma = 0.0;
+      double deltasigma = 0.0;
+      double lambda0;
+      boolean converged = false;
+
+      for (int i = 0; i &lt; 20; i++)
+      {
+         lambda0 = lambda;
+
+         double sinlambda = Math.sin(lambda);
+         double coslambda = Math.cos(lambda);
+
+         // eq. 14
+         double sin2sigma = (cosU2 * sinlambda * cosU2 * sinlambda) + (cosU1sinU2 - sinU1cosU2 * coslambda) * (cosU1sinU2 - sinU1cosU2 * coslambda);
+         double sinsigma = Math.sqrt(sin2sigma);
+
+         // eq. 15
+         double cossigma = sinU1sinU2 + (cosU1cosU2 * coslambda);
+
+         // eq. 16
+         sigma = Math.atan2(sinsigma, cossigma);
+
+         // eq. 17 Careful! sin2sigma might be almost 0!
+         double sinalpha = (sin2sigma == 0) ? 0.0 : cosU1cosU2 * sinlambda / sinsigma;
+         double alpha = Math.asin(sinalpha);
+         double cosalpha = Math.cos(alpha);
+         double cos2alpha = cosalpha * cosalpha;
+
+         // eq. 18 Careful! cos2alpha might be almost 0!
+         double cos2sigmam = cos2alpha == 0.0 ? 0.0 : cossigma - 2 * sinU1sinU2 / cos2alpha;
+         double u2 = cos2alpha * a2b2b2;
+
+         double cos2sigmam2 = cos2sigmam * cos2sigmam;
+
+         // eq. 3
+         A = 1.0 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));
+
+         // eq. 4
+         B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));
+
+         // eq. 6
+         deltasigma = B * sinsigma
+               * (cos2sigmam + B / 4 * (cossigma * (-1 + 2 * cos2sigmam2) - B / 6 * cos2sigmam * (-3 + 4 * sin2sigma) * (-3 + 4 * cos2sigmam2)));
+
+         // eq. 10
+         double C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));
+
+         // eq. 11 (modified)
+         lambda = omega + (1 - C) * f * sinalpha * (sigma + C * sinsigma * (cos2sigmam + C * cossigma * (-1 + 2 * cos2sigmam2)));
+
+         // see how much improvement we got
+         // modification by MiK77: check if lambda is zero to avoid division by zero. Use lambda0 for division in this case.
+         double change = 1.0;
+         if (lambda != 0) {
+                 change = Math.abs((lambda - lambda0) / lambda);
+         } else if (lambda0 != 0){
+                 change = Math.abs((lambda - lambda0) / lambda0); 
+         } else {
+                 change = 0.0;
+         }
+
+         if ((i &gt; 1) &amp;&amp; (change &lt; 0.0000000000001))
+         {
+            converged = true;
+            break;
+         }
+      }
+
+      // eq. 19
+      double s = b * A * (sigma - deltasigma);      
+      double alpha1;
+      double alpha2;
+
+      // didn't converge? must be N/S
+      if (!converged)
+      {
+         if (phi1 &gt; phi2)
+         {
+            alpha1 = 180.0;
+            alpha2 = 0.0;
+         }
+         else if (phi1 &lt; phi2)
+         {
+            alpha1 = 0.0;
+            alpha2 = 180.0;
+         }
+         else
+         {
+            alpha1 = Double.NaN;
+            alpha2 = Double.NaN;
+         }
+      }
+
+      // else, it converged, so do the math
+      else
+      {
+         double radians;
+
+         // eq. 20
+         radians = Math.atan2(cosU2 * Math.sin(lambda), (cosU1sinU2 - sinU1cosU2 * Math.cos(lambda)));
+         if (radians &lt; 0.0) radians += TwoPi;
+         alpha1 = radians / PiOver180;
+
+         // eq. 21
+         radians = Math.atan2(cosU1 * Math.sin(lambda), (-sinU1cosU2 + cosU1sinU2 * Math.cos(lambda))) + Math.PI;
+         if (radians &lt; 0.0) radians += TwoPi;
+         alpha2 = radians / PiOver180;
+      }
+
+      if (alpha1 &gt;= 360.0) alpha1 -= 360.0;
+      if (alpha2 &gt;= 360.0) alpha2 -= 360.0;
+      
+      if ((bearing != null) &amp;&amp; (bearing.length &gt; 0))
+      {
+         bearing[0] = alpha1;
+      }
+
+//      return new GeodeticCurve(s, alpha1, alpha2);
+      return s;
+   }
+   
+   static public double calculateDistance(Ellipsoid ellipsoid, TrackPoint start, TrackPoint end)
+   {
+           return calculateDistanceAndBearing(ellipsoid, start, end, null);
+   }
+   
+   static public double calculateBearing(Ellipsoid ellipsoid, TrackPoint start, TrackPoint end)
+   {
+           double bearing[]={0.0};
+           calculateDistanceAndBearing(ellipsoid, start, end, bearing);
+           return bearing[0];
+   }
+
+}
\ No newline at end of file

Added: experiments/EVE/src/cachewolf/navi/GkPoint.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/GkPoint.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/GkPoint.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,150 @@
+package cachewolf.navi;
+import cachewolf.utils.Common;
+
+/**
+ * Point in Gau&#223;-Kr&#252;ger Format
+ * @author Robert Arnold
+ *
+ */
+public class GkPoint {
+	double northing; // TODO make these private
+	private double easting; // because it is not clear for routines from outside if the stripe number is included, make this available only through methods
+	int stripe;
+	int stripewidth;
+	float lengthOfStripe0; // e.g. in italien GK stripe 1 is at 9 degree
+	public GkPoint() { super(); }
+	
+	public GkPoint(GkPoint p) {
+		set(p.easting, p.northing, p.stripe, p.stripewidth, p.lengthOfStripe0);
+	}
+	
+	/**
+	 * e containing the number of the stripe
+	 * @param e
+	 * @param n
+	 */
+	public GkPoint(double e, double n, int stripewidthi, float degreeOfStripeZero) {
+		stripe = (int) Math.floor(e / 1000000);
+		set(e - 1000000 * stripe - 500000, n, stripe, stripewidthi, degreeOfStripeZero);
+		set(e - 1000000 * stripe - 500000, n, (int) Math.floor(e / 1000000), stripewidthi);
+	}
+	
+	/**
+	 * use this to set normal german Gau&#223;-Kr&#252;ger coordinates
+	 * (they contain the stripe numer in the easting value and
+	 * have a stripe with of 3 degrees)
+	 * @param e
+	 * @param n
+	 */
+	public GkPoint(double e, double n, int region) {
+		switch (region) {
+			case GERMAN_GK:	set(e, n, 3, 0); break;
+			case ITALIAN_GB:	set(e, n, 6, 3); break;
+			default: throw new IllegalArgumentException(&quot;GkPoint (double, double, int): region: &quot; + region + &quot; not supported&quot;);
+		}
+	}
+	
+	public GkPoint(double e, double n, int stripei, int stripewidthi, float degreeOfStripeZero) {
+		set(e, n, stripei, stripewidthi, degreeOfStripeZero);
+	}
+		
+	/**
+	 * 
+	 * @param e containing the stripe number
+	 * @param n
+	 * @param stripewidthi
+	 */
+	public void set(double e, double n, int stripewidthi, float degreeOfStripeZero) {
+		double stripei = Math.floor(e / 1000000);
+		set(e - 1000000 * stripei - 500000, n, (int) stripei, stripewidthi, degreeOfStripeZero);
+	}
+	
+	/**
+	 * @param e in meters from center of stripe, it may not contain the stripenumber
+	 */
+	public void set(double e, double n, int stripei, int stripewidthi, float lenthOfStripeZero_) {
+		stripe = stripei;
+		stripewidth = stripewidthi;
+		easting = e;
+		northing = n;
+		lengthOfStripe0 = lenthOfStripeZero_;
+	}
+	
+	public double getStripeLon() {
+		return stripe * stripewidth+ lengthOfStripe0; // TODO + stripeoffset
+	}
+	
+	public int getStripe() {
+		return stripe;
+	}
+	public TrackPoint toTrackPoint(int region) {
+		return new TrackPoint(northing, getGkEasting(region));
+	}
+	/**
+	 * This will give you the normal Gau&#223;-Kr&#252;ger easting value
+	 * (that means including the stripe number)
+	 * @return
+	 */
+	public static final int GERMAN_GK = 4900;
+	public static final int ITALIAN_GB = 3900; 
+	public static final int DEFAULT_GK = GERMAN_GK;
+	
+	/**
+	 * 
+	 * @param region international telephone area code * 100  
+	 * @return
+	 * @throws IllegalArgumentException if region is not supported
+	 */
+	public double getGkEasting(int region) {
+		double e;
+		switch (region) {
+		case GERMAN_GK: e = easting + 500000 + stripe * 1000000; break;
+		case ITALIAN_GB:	
+			e = easting + 500000 + stripe * 1000000;
+			if (stripe == 2) e += 20000; // because of an unknown reason the second stripe in EPSG:3004 has an false easting of 2520000
+		break;
+		default: throw new IllegalArgumentException(&quot;getGkEasting: area code &quot; + region + &quot;not supported&quot;);
+		}
+		return e;
+	}
+	
+	/**
+	 * easting measured in meters from stripe middle
+	 * @return
+	 */
+	public double getRawEasting() {
+		return easting;
+	}
+	
+	/**
+	 * easting measured in meters from stripe middle
+	 * @return
+	 */
+	public double getNorthing() {
+		return northing;
+	}
+	
+	/**
+	 * assumes _German_ Gau&#223;-Kr&#252;ger
+	 */
+	/*public String toString() {
+		return toString(0, &quot;R: &quot;, &quot; H: &quot;, GERMAN_GK);
+	}*/
+
+	
+	public String toString(int decimalplaces, String prefix, String seperator, int region) {
+		return prefix + Common.doubleToString(getGkEasting(region),decimalplaces).replace(',', '.') + seperator + Common.doubleToString(northing,decimalplaces).replace(',', '.');
+	}
+	
+	/**
+	 * shift the point
+	 * @param meters positiv to north (east), negativ to south (west)
+	 * @param direction 0 north-south, 1 east-west
+	 */
+	public void shift(double meters, int direction) {
+		switch (direction) { // TODO this works corectly only within an 3 degrees stripe
+			case 0: northing += meters; return;
+			case 1: easting += meters; return;
+		}
+	}
+}

Added: experiments/EVE/src/cachewolf/navi/GotoPanel.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/GotoPanel.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/GotoPanel.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,951 @@
+package cachewolf.navi;
+
+import eve.ui.*;
+import eve.fx.*;
+import eve.sys.*;
+import java.lang.Double;
+
+import cachewolf.CWPoint;
+import cachewolf.CacheHolder;
+import cachewolf.CoordsScreen;
+import cachewolf.Global;
+import cachewolf.MainTab;
+import cachewolf.MyLocale;
+import cachewolf.Preferences;
+
+import eve.ui.event.MenuEvent;
+import eve.ui.event.ControlEvent;
+
+/**
+ *	Class to create the panel which handles the connection to the GPS-device&lt;br&gt;
+ *	Displays: current position,speed and bearing; relation to destination waypoint&lt;br&gt;
+ *	Class ID: 1500
+ */
+
+
+public class GotoPanel extends CellPanel {
+
+	//public CWGPSPoint gpsPosition = new CWGPSPoint();
+	//public CWPoint toPoint = new CWPoint();
+	public Navigate myNavigation;
+	Button btnGPS, btnCenter,btnSave;
+	Button btnGoto, btnMap;
+	int currFormat;
+
+	Label lblGPS, lblPosition, lblDST;
+	Color gpsStatus;
+
+	MainTab mainT;
+	//Vector cacheDB;
+	//DetailsPanel detP;
+
+	Preferences pref;
+	//Profile profile;
+	// different panels to avoid spanning
+	CellPanel ButtonP = new CellPanel();
+	CellPanel CoordsP = new CellPanel();
+	CellPanel roseP = new CellPanel();
+
+	//ImageControl icRose;
+	GotoRose compassRose;
+
+	final static Color RED = new Color(255,0,0);
+	final static Color YELLOW = new Color(255,255,0);
+	final static Color GREEN = new Color(0,255,0);
+	final static Color BLUE = new Color(0,0,255);
+
+	final static Font BOLD = new Font(&quot;Arial&quot;, Font.BOLD, 14);
+
+	//int ticker = 0;
+
+	Menu mnuContextFormt;
+	MenuItem miDMM, miDMS, miDD, miUTM, miGK;
+
+	Menu mnuContextRose;
+	MenuItem miLuminary[] = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
+	MenuItem miNorthCentered;
+
+	/**
+	 * Create GotoPanel
+	 * @param Preferences 	global preferences
+	 * @param MainTab		reference to MainTable
+	 * @param DetailsPanel 	reference to DetailsPanel
+	 * @param Vector		cacheDB
+	 */
+	public GotoPanel(Navigate nav) {
+		myNavigation = nav;
+		pref = Global.getPref();
+		mainT = Global.mainTab;
+		//detP = mainT.detP;
+		//cacheDB = profile.cacheDB;
+
+		// Button
+		ButtonP.addNext(btnGPS = new Button(MyLocale.getMsg(1504,&quot;Start&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addNext(btnCenter = new Button(MyLocale.getMsg(309,&quot;Centre&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addNext(btnSave = new Button(MyLocale.getMsg(311,&quot;Create Waypoint&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addLast(btnMap = new Button(MyLocale.getMsg(1506,&quot;Map&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+
+		//Format selection for coords
+		//context menu
+		mnuContextFormt = new Menu();
+		mnuContextFormt.addItem(miDD = new MenuItem(&quot;d.d&#176;&quot;));
+		miDD.modifiers &amp;= ~MenuItem.Checked;
+		mnuContextFormt.addItem(miDMM = new MenuItem(&quot;d&#176;m.m\'&quot;));
+		miDMM.modifiers |= MenuItem.Checked;
+		mnuContextFormt.addItem(miDMS = new MenuItem(&quot;d&#176;m\'s\&quot;&quot;));
+		miDMS.modifiers &amp;= ~MenuItem.Checked;
+		mnuContextFormt.addItem(miUTM = new MenuItem(&quot;UTM&quot;));
+		miUTM.modifiers &amp;= ~MenuItem.Checked;
+		mnuContextFormt.addItem(miGK = new MenuItem(&quot;GK&quot;));
+		miGK.modifiers &amp;= ~MenuItem.Checked;
+		currFormat = CWPoint.DMM;
+
+		// Create context menu for compass rose: select luminary for orientation
+		mnuContextRose = new Menu();
+		for (int i=0; i&lt;SkyOrientation.LUMINARY_NAMES.length; i++) {
+			mnuContextRose.addItem(miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i)));
+			if (i == myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
+			else miLuminary[i].modifiers &amp;= MenuItem.Checked;
+		}
+
+		//Coords
+		CoordsP.addNext(lblGPS = new Label(&quot;GPS: &quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		lblGPS.backGround = RED;
+		lblGPS.setMenu(mnuContextFormt);
+		lblGPS.modifyAll(Control.WantHoldDown, 0);
+
+		CoordsP.addLast(lblPosition = new Label(myNavigation.gpsPos.toString(currFormat)),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		lblPosition.setMenu(mnuContextFormt);
+		lblPosition.anchor = Label.CENTER;
+		lblPosition.modifyAll(Control.WantHoldDown, 0);
+
+		CoordsP.addNext(lblDST = new Label(MyLocale.getMsg(1500,&quot;DST:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		lblDST.backGround = new Color(0,0,255);
+		lblDST.setMenu(mnuContextFormt);
+		lblDST.modifyAll(Control.WantHoldDown, 0);
+
+		CoordsP.addLast(btnGoto = new Button(getGotoBtnText()),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+
+		//Rose for bearing
+		//compassRose = new GotoRose(&quot;rose.png&quot;);
+		compassRose = new GotoRose();
+		compassRose.setMenu(mnuContextRose);
+		compassRose.modifyAll(Control.WantHoldDown, 0); // this is necessary in order to make PenHold on a PDA work as right click
+		roseP.addLast(compassRose,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTH|CellConstants.WEST));
+
+		mnuContextRose.addItem(new MenuItem(&quot;&quot;, MenuItem.Separator, null));
+		mnuContextRose.addItem(miNorthCentered = new MenuItem(MyLocale.getMsg(1503,&quot;North Centered&quot;)));
+		if (compassRose.isNorthCentered()) miNorthCentered.modifiers |= MenuItem.Checked;
+		else miNorthCentered.modifiers &amp;= MenuItem.Checked;
+
+		//add Panels
+		this.addLast(ButtonP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST); //.setTag(TAG_SPAN,new Dimension(2,1));
+		this.addLast(CoordsP,CellConstants.HSTRETCH, CellConstants.HFILL|CellConstants.NORTH); //.setTag(TAG_SPAN,new Dimension(2,1));
+		this.addLast(roseP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.NORTH|CellConstants.WEST); //.setTag(TAG_SPAN,new Dimension(2,1));
+
+		// for debuging
+		/*		CWGPSPoint myGPS;
+		myGPS = new CWGPSPoint();
+		String ex = new String();
+		boolean test = false;
+		try { FileReader f = new FileReader(&quot;c:\\kw\\20060928_1051.log&quot;);
+		ex = f.readAll();
+		test = myGPS.examine(ex);
+		f.close();
+		} catch (IOException e ) {
+			Vm.debug(e.toString());
+		}
+		test = myGPS.examine(&quot;$GPGLL,5226.8935,N,01338.5327,E,084635.00,A,D*6E&quot;);
+		test = myGPS.examine(&quot;$GPGSA,A,3,10,28,26,29,09,,,,,,,,04.1,02.6,03.2*0F&quot;);
+		test = myGPS.examine(&quot;$GPGSV,4,1,13,08,40,072,28,10,29,201,47,27,15,079,29,28,62,102,44*7E&quot;);
+		test = myGPS.examine(&quot;$GPGSV,4,2,13,29,72,289,38,26,63,296,41,09,12,259,35,18,14,324,*79&quot;);
+		test = myGPS.examine(&quot;$GPGSV,4,3,13,19,09,025,,17,06,138,,21,06,300,,37,29,171,40*7A&quot;);
+		test = myGPS.examine(&quot;$GPGSV,4,4,13,39,29,166,38*40&quot;);
+		 */
+
+		//while (true){
+//		int notinterpreted = 0;
+//		if (myGPS.examine(&quot;@&#246;&#246;H @&#246;&#246;H&#246;@&#214;&#214;HH&#220;&#196;&#220;&#214;&#196;&#196;&#196;H&quot;)) { notinterpreted = 0;} else notinterpreted++;
+//		if (notinterpreted &gt; 5) myGPS.noInterpretableData();
+//		// myGPS.noInterpretableData();
+
+
+//		}
+	}
+
+	public void resizeTo(int width, int height){
+		super.resizeTo(width, height);
+		Rect coordsRect = CoordsP.getRect();
+		int roseHeight = height - coordsRect.y - coordsRect.height;
+		if (Gui.screenIs(Gui.PDA_SCREEN) &amp;&amp; Device.isMobile()) {
+			//some space for the SIP button
+			if ( (Vm.getParameter(Vm.VM_FLAGS) &amp; (Vm.VM_FLAG_SIP_BUTTON_ON_SCREEN)) == (Vm.VM_FLAG_SIP_BUTTON_ON_SCREEN) ){
+				roseHeight -= MyLocale.getScreenHeight() / 14;
+			}
+		}
+		roseP.resizeTo(width, roseHeight);
+		compassRose.resizeTo(width, roseHeight);
+	}
+
+
+	/**
+	 * set the coords of the destination
+	 * @param dest destination
+	 */
+	public void setDestination(CWPoint dest){
+		myNavigation.setDestination(dest);
+		if (!myNavigation.destination.isValid()) (new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(1507,&quot;Coordinates are out of range:&quot;) +&quot;\n&quot;+MyLocale.getMsg(1508,&quot;latitude&quot;)+&quot;: &quot;+myNavigation.destination.latDec+&quot;\n &quot;+MyLocale.getMsg(1509,&quot;longditue&quot;)+&quot;: &quot;+myNavigation.destination.lonDec, MessageBox.OKB)).execute();
+
+	}
+
+	public void destChanged(CWPoint d) { // called from myNavigate
+		btnGoto.setText(getGotoBtnText());
+		updateDistance();
+	}
+
+
+	/**
+	 * set the coords of the destination and switch to gotoPanel
+	 * @param latLon destination
+	 */
+	public void setDestinationAndSwitch(CWPoint where) {
+		myNavigation.setDestination(where);
+		mainT.select(this);
+	}
+
+	/**
+	 * updates distance and bearing
+	 *
+	 */
+
+	public void updateDistance() {
+		//update distance
+		float distance = -1.0f;
+		if (myNavigation.gpsPos.isValid() &amp;&amp; myNavigation.destination.isValid() ) {
+			distance = (float)myNavigation.gpsPos.getDistance(myNavigation.destination);
+		}
+		compassRose.setWaypointDirectionDist((float)myNavigation.gpsPos.getBearing(myNavigation.destination), distance);
+	}
+
+	/**
+	 * method which is called if a timer is set up
+	 */
+	public void updateGps(int fix) {
+		//Vm.debug(&quot;ticked: before&quot;);
+		compassRose.setGpsStatus(fix, myNavigation.gpsPos.getSats(), myNavigation.gpsPos.getSatsInView(), myNavigation.gpsPos.getHDOP());
+		if ((fix &gt; 0) &amp;&amp; (myNavigation.gpsPos.getSats()&gt;= 0)) {
+			Double bearMov;
+			Double speed;
+			Double sunAzimut;
+			// display values only, if signal good
+			//Vm.debug(&quot;currTrack.add: nachher&quot;);
+			lblPosition.setText(myNavigation.gpsPos.toString(currFormat));
+			speed=new Double(myNavigation.gpsPos.getSpeed());
+			sunAzimut=new Double(myNavigation.skyOrientationDir.lonDec);
+			bearMov=new Double(myNavigation.gpsPos.getBear());
+			updateDistance();
+			compassRose.setSunMoveDirections((float)sunAzimut.doubleValue(), (float)bearMov.doubleValue(), (float)speed.doubleValue());
+			// Set background to signal quality
+		}
+
+		// receiving data, but signal ist not good
+		if ((fix == 0) &amp;&amp; (myNavigation.gpsPos.getSats()&gt;= 0)) {
+			gpsStatus = YELLOW;
+		}
+		// receiving no data
+		if (fix == -1) {
+			if (gpsStatus != RED) (new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1510, &quot;No data from GPS\nConnection to serial port closed&quot;),MessageBox.OKB)).exec();
+			gpsStatus = RED;
+			myNavigation.stopGps();
+		}
+		// cannot interprete data
+		if (fix == -2) {
+			if (gpsStatus != RED) (new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1511, &quot;Cannot interpret data from GPS\n possible reasons:\n wrong Port,\n wrong Baudrate,\n not NMEA-Protocol\nConnection to serial port closed\nLast String tried to interprete:\n&quot;)+myNavigation.gpsPos.lastStrExamined, MessageBox.OKB)).exec();
+			gpsStatus = RED;
+			myNavigation.stopGps(); // TODO automatic in myNavigate?
+		}
+	}
+
+	public void gpsStarted() {
+		btnGPS.setText(MyLocale.getMsg(1505,&quot;Stop&quot;));
+	}
+
+	public void startGps() {
+		myNavigation.startGps(pref.logGPS, Convert.toInt(pref.logGPSTimer));
+	}
+
+	public void gpsStopped() {
+		btnGPS.setText(MyLocale.getMsg(1504,&quot;Start&quot;));
+		gpsStatus = this.backGround;
+		this.repaintNow(); // without this the change in the background color will not be displayed
+	}
+
+
+	private String getGotoBtnText() {
+		if (myNavigation.destination == null)
+			return MyLocale.getMsg(999,&quot;Not set&quot;);
+		return myNavigation.destination.toString(currFormat);
+	}
+
+	public void switchToMovingMap() {
+		CWPoint centerTo=null;
+		if (myNavigation.isGpsPosValid()) centerTo = new CWPoint(myNavigation.gpsPos); // set gps-pos if gps is on
+		else {
+			// setze Zielpunkt als Ausgangspunkt, wenn GPS aus ist und lade entsprechende Karte
+			//centerTo = new CWPoint(myNavigation.destination);
+			if (myNavigation.destination.isValid())	centerTo = new CWPoint(myNavigation.destination);
+			else {
+				if (mainT.ch != null &amp;&amp; mainT.ch.pos.isValid()) centerTo = new CWPoint(mainT.ch.pos);
+				else {
+					if (pref.curCentrePt.isValid()) centerTo = new CWPoint(pref.curCentrePt);
+					else {
+					}
+				}
+			}
+		}
+		if (centerTo != null &amp;&amp; centerTo.isValid())
+			mainT.switchToMovingMap(centerTo, false);
+		else
+			(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1513, &quot;Cannot start moving map without valid coordinates. Please enter coordinates as destination, as center, in selected cache or start GPS&quot;), MessageBox.OKB)).execute();
+	}
+
+	/**
+	 * Eventhandler
+	 */
+
+	public void onEvent(Event ev){
+		if (ev instanceof MenuEvent) {
+			if (ev.type == MenuEvent.SELECTED ) {
+				MenuItem action = (MenuItem) mnuContextFormt.getSelectedItem();
+				if (action != null) {
+					if (action == miDD) {
+						mnuContextFormt.close();
+						currFormat = CWPoint.DD;
+					}
+					if (action == miDMM) {
+						mnuContextFormt.close();
+						currFormat = CWPoint.DMM;
+					}
+					if (action == miDMS) {
+						mnuContextFormt.close();
+						currFormat = CWPoint.DMS;
+					}
+					if (action == miUTM) {
+						mnuContextFormt.close();
+						currFormat = CWPoint.UTM;
+					}
+					if (action == miGK) {
+						mnuContextFormt.close();
+						currFormat = CWPoint.GK;
+					}
+					miDD.modifiers &amp;= ~MenuItem.Checked;
+					miDMM.modifiers &amp;= ~MenuItem.Checked;
+					miDMS.modifiers &amp;= ~MenuItem.Checked;
+					miUTM.modifiers &amp;= ~MenuItem.Checked;
+					miGK.modifiers &amp;= ~MenuItem.Checked;
+					switch (currFormat) {
+					case CWPoint.DD: miDD.modifiers |= MenuItem.Checked; break;
+					case CWPoint.DMM: miDMM.modifiers |= MenuItem.Checked; break;
+					case CWPoint.DMS: miDMS.modifiers |= MenuItem.Checked; break;
+					case CWPoint.UTM: miUTM.modifiers |= MenuItem.Checked; break;
+					case CWPoint.GK: miGK.modifiers |= MenuItem.Checked; break;
+					}
+
+					lblPosition.setText(myNavigation.gpsPos.toString(currFormat));
+					btnGoto.setText(getGotoBtnText());
+				} // end lat-lon-format context menu
+				action = (MenuItem) mnuContextRose.getSelectedItem();
+				if (action != null) {
+					for (int i=0; i&lt;miLuminary.length; i++) {
+						if (action == miLuminary[i]) {
+							myNavigation.setLuminary(i);
+							miLuminary[i].modifiers |= MenuItem.Checked;
+							compassRose.setLuminaryName(SkyOrientation.getLuminaryName(myNavigation.luminary));
+						} else miLuminary[i].modifiers &amp;= ~MenuItem.Checked;
+					}
+					if (action == miNorthCentered) {
+						if (compassRose.isNorthCentered()) {
+							compassRose.setNorthCentered(false);
+							miNorthCentered.modifiers &amp;= ~MenuItem.Checked;
+						}
+						else
+						{
+							compassRose.setNorthCentered(true);
+							miNorthCentered.modifiers |= MenuItem.Checked;
+						}
+					}
+				}
+			}
+		}
+
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			// start/stop GPS connection
+			if (ev.target == btnGPS){
+				if (btnGPS.getText().equals(MyLocale.getMsg(1504, &quot;Start&quot;))) startGps();
+				else myNavigation.stopGps();
+			}
+
+			// set current position as centre and recalculate distance of caches in MainTab
+			if (ev.target == btnCenter){
+				if (myNavigation.gpsPos.isValid()) {
+					Form.showWait();
+					pref.curCentrePt.set(myNavigation.gpsPos);
+					mainT.updateBearDist();
+					Form.cancelWait();
+				} else (new MessageBox(MyLocale.getMsg(312, &quot;Error&quot;), MyLocale.getMsg(1514, &quot;Cannot recalculate distances, because the GPS position is not set&quot;), MessageBox.OKB)).execute();
+			}
+			//Start moving map
+			if (ev.target == btnMap){
+				switchToMovingMap();
+			}
+			// create new waypoint with current GPS-position
+			if (ev.target == btnSave){
+				CacheHolder ch = new CacheHolder();
+				ch.latLon = myNavigation.gpsPos.toString();
+				ch.pos = new CWPoint(myNavigation.gpsPos);
+				ch.type = 51; // see CacheType.GC_AW_STAGE_OF_MULTI // TODO unfertig
+				mainT.newWaypoint(ch);
+			}
+			// change destination waypoint
+			if (ev.target == btnGoto){
+				CoordsScreen cs = new CoordsScreen();
+				if (myNavigation.destination.isValid())	cs.setFields(myNavigation.destination, currFormat);
+				else cs.setFields(new CWPoint(0,0), currFormat);
+				if (cs.execute(null, Gui.TOP) == CoordsScreen.IDOK)
+					setDestination(cs.getCoords());
+			}
+		}
+		super.onEvent(ev);
+	}
+}
+
+/** class for displaying the compass rose
+ * including goto, sun and moving direction
+ */
+class GotoRose extends Panel {
+	//TODO Too many objects are created
+	//TOTO Store the sine and cosine in a variable
+	float gotoDir = -361;
+	float sunDir = -361;
+	float moveDir = -361;
+	float distance = -1;
+
+	int m_fix = -1;
+	int m_sats = -1;
+	int m_satsInView = 0;
+	double m_hdop = -1;
+	float m_speed = -1;
+
+	String m_Luminary = MyLocale.getMsg(6100, &quot;Sun&quot;);
+
+	Font mainFont;
+	FontMetrics fm;
+	int lineHeight;
+
+	int roseRadius;
+
+	boolean northCentered = Global.getPref().northCenteredGoto;
+
+	final static Color RED = new Color(255,0,0);
+	final static Color YELLOW = new Color(255,255,0);
+	final static Color GREEN = new Color(0,255,0);
+	final static Color BLUE = new Color(0,0,255);
+	final static Color ORANGE = new Color(255,128,0);
+	final static Color DARKGREEN = new Color(0,192,0);
+	final static Color CYAN = new Color(0,255,255);
+	final static Color MAGENTA = new Color(255,0,255);
+
+	/**
+	 * @param gd goto direction
+	 * @param sd sun direction
+	 * @param md moving direction
+	 */
+	//public GotoRose(String fn){
+	//}
+
+	public GotoRose(){
+		super();
+	}
+
+	public void setWaypointDirectionDist(float wd, float dist) {
+		gotoDir = wd;
+		distance = dist;
+	}
+
+	public void setSunMoveDirections(float sd, float md, float speed ) {
+		sunDir = sd;
+		moveDir = md;
+		m_speed = speed;
+		repaint();
+	}
+
+	public void setGpsStatus(int fix, int sats, int satsInView, double hdop) {
+		m_fix = fix;
+		m_sats = sats;
+		m_satsInView = satsInView;
+		m_hdop = hdop;
+		repaint();
+	}
+
+	public void setLuminaryName(String Luminary) {
+		m_Luminary = Luminary;
+		repaint();
+	}
+
+
+	/**
+	 * draw arrows for the directions of movement and destination waypoint
+	 * @param ctrl the control to paint on
+	 * @param moveDir degrees of movement
+	 * @param destDir degrees of destination waypoint
+	 */
+
+	public void doPaint(Graphics g, Rect area)  {
+		g.setColor(Color.White);
+		g.fillRect(0, 0, this.width, this.height);
+
+		int fontSize = this.width/17;
+		mainFont = new Font(&quot;Verdana&quot;, Font.BOLD, fontSize);
+		g.setFont(mainFont);
+		fm = g.getFontMetrics(mainFont);
+		lineHeight = fm.getHeight() + 1;
+		roseRadius = java.lang.Math.min((this.width * 3) / 4, this.height) / 2;
+
+		if (northCentered) {
+			drawFullRose(g, 0, 				// angle
+					Color.White, 			// colLeft
+					new Color(200,200,200), // colRight
+					Color.White, 			// colNorthLeft
+					new Color(200,200,200), // colNorthRight
+					new Color(150,150,150), // colBorder
+					new Color(75,75,75),    // colText
+					1.0f,					// scale
+					true, 					// bDrawText
+					true);					// bDrawEightArrows
+		}
+		else {
+			int radius = (int)(roseRadius * 0.75f);
+			Pen oldPen = g.getPen(Pen.getCached());
+			g.changePen(new Color(150,150,150),Pen.SOLID,3);
+			//g.setPen(new Pen(new Color(150,150,150),Pen.SOLID,3));
+			g.drawEllipse(this.width/2 - radius, this.height/2 - radius, 2 * radius, 2 * radius );
+			g.set(oldPen);
+			oldPen.cache();
+		}
+
+		drawArrows(g);
+		drawWayPointData(g);
+		drawGpsData(g);
+		drawLuminaryData(g);
+		drawGpsStatus(g);
+	}
+
+	private void drawWayPointData(Graphics g){
+		String strTemp = MyLocale.getMsg(1512, &quot;Waypoint&quot;);
+		g.setColor(Color.DarkBlue);
+		g.fillRect(0, 0, fm.getTextWidth(strTemp) + 4, lineHeight);
+		g.setColor(Color.White);
+		g.drawText(strTemp, 2, 0);
+
+		g.setColor(Color.Black);
+
+		if ( distance &gt;= 0.0f ) {
+			if (distance &gt;= 1){
+				strTemp = MyLocale.formatDouble(distance,&quot;0.000&quot;)+ &quot; km&quot;;
+			} else {
+				strTemp = MyLocale.formatDouble(distance*1000.0,&quot;0&quot;) + &quot; m&quot;;
+			}
+		}
+		else strTemp = &quot;--- km&quot;;
+		g.drawText(strTemp, 2, lineHeight);
+
+		if ((gotoDir &lt;= 360) &amp;&amp; (gotoDir &gt;= -360))
+			strTemp = MyLocale.formatDouble(gotoDir,&quot;0&quot;) + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+		else
+			strTemp = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+		g.drawText(strTemp, 2, 2*lineHeight);
+	}
+
+	private void drawGpsData(Graphics g){
+		g.setColor(RED);
+
+		String strHeadline = MyLocale.getMsg(1501,&quot;Current&quot;);
+
+		Double tmp = new Double(m_speed);
+		String strSpeed = &quot;- km/h&quot;;
+		if (m_speed &gt;= 0) {
+			if (m_speed &gt;= 100) {
+				strSpeed = MyLocale.formatDouble(tmp,&quot;0&quot;) + &quot; km/h&quot;;
+			}
+			else {
+				strSpeed = MyLocale.formatDouble(tmp,&quot;0.0&quot;) + &quot; km/h&quot;;
+			}
+		}
+
+		tmp = new Double(moveDir);
+		String strMoveDir = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+		if ((tmp.doubleValue() &lt;= 360) &amp;&amp; (tmp.doubleValue() &gt;= -360))
+			strMoveDir = tmp.toString() + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+
+		int textWidth = java.lang.Math.max(fm.getTextWidth(strSpeed), fm.getTextWidth(strMoveDir));
+		textWidth = java.lang.Math.max(textWidth, fm.getTextWidth(strHeadline));
+
+		int startX = this.width - (textWidth + 4);
+		g.fillRect(startX, 0, this.width - startX, lineHeight);
+
+		g.setColor(Color.Black);
+		g.drawText(strHeadline, startX + 2, 0);
+		g.drawText(strSpeed, startX + 2, lineHeight);
+		g.drawText(strMoveDir, startX + 2, 2*lineHeight);
+	}
+
+	private void drawLuminaryData(Graphics g){
+		g.setColor(YELLOW);
+
+		String strSunDir = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+		if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360) {
+			strSunDir = MyLocale.formatDouble(sunDir, &quot;0&quot;) + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+		}
+
+		int textWidth = java.lang.Math.max(fm.getTextWidth(m_Luminary), fm.getTextWidth(strSunDir));
+		int startY = this.height - 2*lineHeight;
+		g.fillRect(0, startY, textWidth + 4, this.height - startY);
+
+		g.setColor(Color.Black);
+		g.drawText(m_Luminary, 2, startY);
+		g.drawText(strSunDir, 2, startY + lineHeight);
+	}
+
+	private void drawGpsStatus(Graphics g){
+		if ((m_fix &gt; 0) &amp;&amp; (m_sats &gt;= 0)) {
+			// Set background to signal quality
+			g.setColor(GREEN);
+		}
+		else
+		// receiving data, but signal ist not good
+		if ((m_fix == 0) &amp;&amp; (m_sats &gt;= 0)) {
+			g.setColor(YELLOW);
+		}
+		else {
+			g.setColor(RED);
+		}
+
+		String strSats = &quot;Sats: -&quot;;
+		if (m_sats &gt;= 0) {
+			strSats = &quot;Sats: &quot; + Convert.toString(m_sats) + &quot;/&quot; + Convert.toString(m_satsInView);
+		}
+		String strHdop = &quot;HDOP: -&quot;;
+		if (m_hdop &gt;= 0) strHdop = &quot;HDOP: &quot; + Convert.toString(m_hdop);
+
+		int textWidth = java.lang.Math.max(fm.getTextWidth(strSats), fm.getTextWidth(strHdop));
+		int startX = this.width - (textWidth + 4);
+		int startY = this.height - 2*lineHeight;
+		g.fillRect(startX, startY, this.width - startX ,this.height - startY);
+
+		g.setColor(Color.Black);
+		g.drawText(strSats, startX + 2, startY);
+		g.drawText(strHdop, startX + 2, startY + lineHeight);
+	}
+
+	private void drawArrows(Graphics g){
+		if (g != null)
+		{
+			// select moveDirColor according to difference to gotoDir
+			Color moveDirColor = RED;
+
+			if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360 &amp;&amp; moveDir &lt; 360 &amp;&amp; moveDir &gt; -360)
+			{
+				float diff = java.lang.Math.abs(moveDir - gotoDir);
+				while (diff &gt; 360)
+				{
+					diff -= 360.0f;
+				}
+				if (diff &gt; 180.0f)
+				{
+					diff = 360.0f - diff;
+				}
+
+				if (diff &lt;= 12.25f)
+				{
+					moveDirColor = GREEN;
+				}
+				else if (diff &lt;= 22.5f)
+				{
+					moveDirColor = CYAN;
+				}
+				else if (diff &lt;= 45.0f)
+				{
+					moveDirColor = ORANGE;
+				}
+				else if (diff &lt;= 90.0f)
+				{
+					moveDirColor = MAGENTA;
+				}
+			}
+
+			// draw only valid arrows
+			if (northCentered) {
+				if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360) drawThickArrow(g, gotoDir, Color.DarkBlue, 1.0f);
+				if (moveDir &lt; 360 &amp;&amp; moveDir &gt; -360) drawThinArrow(g, moveDir, RED, moveDirColor, 1.0f);
+				if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360) drawSunArrow(g, sunDir, YELLOW, 0.75f);
+			}
+			else {
+				//moveDir centered
+				if (moveDir &lt; 360 &amp;&amp; moveDir &gt; -360) {
+					//drawDoubleArrow(g, 360 - moveDir, BLUE, new Color(175,0,0), 1.0f);
+					//drawRose(g, 360 - moveDir, new Color(100,100,100), new Color(200,200,200), 1.0f);
+					drawFullRose(g, 360 - moveDir, new Color(255,255,255), new Color(200,200,200), new Color(150,150,150), new Color(200,200,200), new Color(200,200,200), new Color(75,75,75), 1.0f, false, false);
+
+					int radius = (int)(roseRadius * 0.75f);
+					g.changePen(RED,Pen.SOLID,3);
+					g.drawLine(this.width/2, this.height/2 - radius, this.width/2, this.height/2 + radius);
+
+					if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360) drawThinArrow(g, gotoDir - moveDir, Color.DarkBlue, moveDirColor, 1.0f);
+					if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360) drawSunArrow(g, sunDir - moveDir, YELLOW, 0.75f);
+				}
+			}
+		}
+	}
+
+	/**
+	 * draw single arrow
+	 * @param g handle for drawing
+	 * @param angle angle of arrow
+	 * @param col color of arrow
+	 */
+/*	private void drawSimpleArrow(Graphics g, float angle, Color col, float scale) {
+		float angleRad;
+		int x, y, centerX = this.width/2, centerY = this.height/2;
+		int arrowLength = roseRadius;
+
+		angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		x = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad) * scale).intValue();
+		y = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad) * scale).intValue();
+		g.setPen(new Pen(col,Pen.SOLID,3));
+		g.drawLine(centerX,centerY,x,y);
+	}
+*/
+	private void drawSunArrow(Graphics g, float angle, Color col, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = this.width/2, centerY = this.height/2;
+		float arrowLength = roseRadius * scale;
+		float halfArrowWidth = arrowLength * 0.08f;
+		float circlePos = arrowLength * 0.7f;
+		int circleRadius = (int)(arrowLength * 0.1f);
+
+		//int pointX = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		//int pointY = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		int circleX = centerX + (int) (circlePos * java.lang.Math.sin(angleRad));
+		int circleY = centerY - (int) (circlePos * java.lang.Math.cos(angleRad));
+
+		int[] pointsX = new int[4];
+		int[] pointsY = new int[4];
+
+		pointsX[0] = centerX + (int)(arrowLength * java.lang.Math.sin(angleRad));
+		pointsY[0] = centerY - (int)(arrowLength * java.lang.Math.cos(angleRad));
+		pointsX[1] = centerX + (int)(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0));
+		pointsY[1] = centerY - (int)(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0));
+		pointsX[2] = centerX + (int)(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI));
+		pointsY[2] = centerY - (int)(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI));
+		pointsX[3] = centerX + (int)(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0));
+		pointsY[3] = centerY - (int)(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0));
+
+//		g.setPen(new Pen(col,Pen.SOLID,3));
+//		g.drawLine(centerX,centerY,pointX,pointY);
+
+		g.changePen(Color.Black,Pen.SOLID,1);
+		g.changeBrush(col, Brush.SOLID);
+		g.fillPolygon(pointsX, pointsY, 4);
+		g.fillEllipse(circleX - circleRadius, circleY - circleRadius, 2 * circleRadius, 2 * circleRadius);
+	}
+
+	private void drawThinArrow(Graphics g, float angle, Color col, Color colPoint, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = this.width/2, centerY = this.height/2;
+		float arrowLength = roseRadius * scale;
+		float halfOpeningAngle = (float)(java.lang.Math.PI * 0.03);
+		float sideLineLength = arrowLength * 0.75f;
+
+		int[] pointsX = new int[4];
+		int[] pointsY = new int[4];
+
+		pointsX[0] = centerX + (int)(sideLineLength * java.lang.Math.sin(angleRad - halfOpeningAngle));
+		pointsY[0] = centerY - (int)(sideLineLength * java.lang.Math.cos(angleRad - halfOpeningAngle));
+		pointsX[1] = centerX + (int)(arrowLength * java.lang.Math.sin(angleRad));
+		pointsY[1] = centerY - (int)(arrowLength * java.lang.Math.cos(angleRad));
+		pointsX[2] = centerX + (int)(sideLineLength * java.lang.Math.sin(angleRad + halfOpeningAngle));
+		pointsY[2] = centerY - (int)(sideLineLength * java.lang.Math.cos(angleRad + halfOpeningAngle));
+		pointsX[3] = centerX;
+		pointsY[3] = centerY;
+
+		g.changePen(Color.Black,Pen.SOLID,1);
+		g.changeBrush(col, Brush.SOLID);
+		g.fillPolygon(pointsX, pointsY, 4);
+		if (colPoint != null) {
+			g.changeBrush(colPoint, Brush.SOLID);
+			g.fillPolygon(pointsX, pointsY, 3);
+		}
+	}
+
+/*	private void drawDoubleArrow(Graphics g, float angle, Color colFront, Color colRear, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = this.width/2, centerY = this.height/2;
+		float arrowLength = (float)roseRadius * scale;
+		float halfArrowWidth = arrowLength * 0.1f;
+
+		int[] pointsX = new int[3];
+		int[] pointsY = new int[3];
+
+		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[1] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsY[1] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
+
+		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setBrush(new Brush(colFront, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 3);
+
+		pointsX[0] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
+		pointsY[0] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
+
+		g.setBrush(new Brush(colRear, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 3);
+	}
+*/
+/*	private void drawRose(Graphics g, float angle, Color colFront, Color colRear, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = this.width/2, centerY = this.height/2;
+		float arrowLength = (float)roseRadius * scale;
+		float halfArrowWidth = arrowLength * 0.12f;
+
+		int[] pointsX = new int[8];
+		int[] pointsY = new int[8];
+
+		pointsX[0] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 4.0)).intValue();
+		pointsY[0] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 4.0)).intValue();
+		pointsX[1] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad)).intValue();
+		pointsY[1] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad)).intValue();
+		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 4.0)).intValue();
+		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 4.0)).intValue();
+		pointsX[3] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsY[3] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0)).intValue();
+		pointsX[4] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad + 3.0 * java.lang.Math.PI / 4.0)).intValue();
+		pointsY[4] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad + 3.0 * java.lang.Math.PI / 4.0)).intValue();
+		pointsX[5] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad + java.lang.Math.PI)).intValue();
+		pointsY[5] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad + java.lang.Math.PI)).intValue();
+		pointsX[6] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - 3.0 * java.lang.Math.PI / 4.0)).intValue();
+		pointsY[6] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - 3.0 * java.lang.Math.PI / 4.0)).intValue();
+		pointsX[7] = centerX + new Float(arrowLength * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
+		pointsY[7] = centerY - new Float(arrowLength * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
+
+		g.setPen(new Pen(colRear,Pen.SOLID,1));
+		g.setBrush(new Brush(colRear, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 8);
+
+		g.setBrush(new Brush(colFront, Brush.SOLID));
+		g.fillPolygon(pointsX, pointsY, 3);
+	}
+*/
+	private void drawFullRose(Graphics g, float angle, Color colLeft, Color colRight, Color colNorthLeft, Color colNorthRight,
+			Color colBorder, Color colText, float scale, boolean bDrawText, boolean bDrawEightArrows) {
+		float subScale1 = 1.0f;
+		float subScale2 = 0.9f;
+		float innerScale = 0.15f;
+		if(bDrawEightArrows){
+			innerScale = 0.12f;
+			drawRosePart(g,  45 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, &quot;NE&quot;, bDrawText);
+			drawRosePart(g, 135 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, &quot;SE&quot;, bDrawText);
+			drawRosePart(g, 225 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, &quot;SW&quot;, bDrawText);
+			drawRosePart(g, 315 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, &quot;NW&quot;, bDrawText);
+		}
+
+		drawRosePart(g,   0 + angle, colNorthLeft, colNorthRight, colBorder, colText, scale * subScale1, innerScale, &quot;N&quot;, bDrawText);
+		drawRosePart(g,  90 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, &quot;E&quot;, bDrawText);
+		drawRosePart(g, 180 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, &quot;S&quot;, bDrawText);
+		drawRosePart(g, 270 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, &quot;W&quot;, bDrawText);
+	}
+
+	private void drawRosePart(Graphics g, float angle, Color colLeft, Color colRight, Color colBorder, Color colText, float scale, float innerScale, String strDir, boolean bDrawText) {
+		float angleRad = angle * (float)java.lang.Math.PI / 180;
+		float angleRadText = (angle + 7.5f) * (float)java.lang.Math.PI / 180;
+		int centerX = this.width/2, centerY = this.height/2;
+
+		float arrowLength = roseRadius * scale;
+		float halfArrowWidth = arrowLength * innerScale;
+
+		int[] pointsX = new int[3];
+		int[] pointsY = new int[3];
+
+		pointsX[0] = centerX;
+		pointsY[0] = centerY;
+		pointsX[1] = centerX + (int)(arrowLength * java.lang.Math.sin(angleRad));
+		pointsY[1] = centerY - (int)(arrowLength * java.lang.Math.cos(angleRad));
+		pointsX[2] = centerX + (int)(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 4.0));
+		pointsY[2] = centerY - (int)(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 4.0));
+
+		g.changePen(colBorder,Pen.SOLID,1);
+		g.changeBrush(colLeft, Brush.SOLID);
+		g.paintPolygon(pointsX, pointsY, 3);
+
+		pointsX[2] = centerX + (int)(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 4.0));
+		pointsY[2] = centerY - (int)(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 4.0));
+
+		g.changeBrush(colRight, Brush.SOLID);
+		g.paintPolygon(pointsX, pointsY, 3);
+
+		if (bDrawText){
+			int tempFontSize = (int)(scale * mainFont.getSize());
+			Font tempFont = new Font(mainFont.getName(), Font.BOLD, tempFontSize);
+			g.setFont(tempFont);
+			FontMetrics tempFm = g.getFontMetrics(tempFont);
+			float stringHeight = tempFm.getHeight();
+			float stringWidth = tempFm.getTextWidth( strDir );
+			float stringGap = (float)java.lang.Math.sqrt(stringHeight*stringHeight + stringWidth*stringWidth);
+
+			float stringPosition = arrowLength - stringGap / 2.0f;
+			g.setColor(colText);
+			g.drawText(strDir, centerX + (int)(stringPosition * java.lang.Math.sin(angleRadText) - stringWidth / 2.0f),
+					           centerY - (int)(stringPosition * java.lang.Math.cos(angleRadText) + stringHeight / 2.0f));
+
+			g.setFont(mainFont);
+		}
+	}
+
+	private void drawThickArrow(Graphics g, float angle, Color col, float scale) {
+		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
+		int centerX = this.width/2, centerY = this.height/2;
+		float arrowLength = roseRadius * scale;
+		float halfArrowWidth = arrowLength * 0.1f;
+
+		int[] pointsX = new int[4];
+		int[] pointsY = new int[4];
+
+		pointsX[0] = centerX + (int)(arrowLength * java.lang.Math.sin(angleRad));
+		pointsY[0] = centerY - (int)(arrowLength * java.lang.Math.cos(angleRad));
+		pointsX[1] = centerX + (int)(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI / 2.0));
+		pointsY[1] = centerY - (int)(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI / 2.0));
+		pointsX[2] = centerX + (int)(halfArrowWidth * java.lang.Math.sin(angleRad + java.lang.Math.PI));
+		pointsY[2] = centerY - (int)(halfArrowWidth * java.lang.Math.cos(angleRad + java.lang.Math.PI));
+		pointsX[3] = centerX + (int)(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0));
+		pointsY[3] = centerY - (int)(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0));
+
+		g.changePen(Color.Black,Pen.SOLID,1);
+		g.changeBrush(col, Brush.SOLID);
+		g.fillPolygon(pointsX, pointsY, 4);
+	}
+
+	public void setNorthCentered(boolean nc) {
+		northCentered = nc;
+		if (northCentered != Global.getPref().northCenteredGoto) {
+			Global.getPref().northCenteredGoto = northCentered;
+			Global.getPref().savePreferences();
+		}
+		repaint();
+	}
+
+	public boolean isNorthCentered() {
+		return northCentered;
+	}
+}

Added: experiments/EVE/src/cachewolf/navi/MapImage.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/MapImage.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/MapImage.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,92 @@
+package cachewolf.navi;
+import eve.fx.*;
+import eve.ui.game.*;
+/**
+ * class that can be used with any x and any y
+ * it will save taht location and make itself automatically
+ * invisible if it is not on the screen. Call setscreensize to
+ * set the screensize
+ * @author pfeffer
+ *
+ */
+public class MapImage extends AniImage {
+	public Point locAlways = new Point(); // contains the theoretical location even if it the location is out of the screen. If the image is on the screen, it contains the same as location
+	public static Dimension screenDim;
+	boolean hidden = false;
+	public MapImage() {
+		super();
+		if (screenDim == null) screenDim = new Dimension(0,0);
+	}
+
+	public MapImage(String f) throws ImageDecodingException, UnsupportedImageFormatException, ImageNotFoundException, eve.sys.SystemResourceException {
+		super(f);
+		if (screenDim == null) screenDim = new Dimension(0,0);
+		//TODO Check whether EVE reads correctly from a fake filesystem (EWE 1.49 did not)
+	}
+
+	public MapImage(Picture im) {
+		super(im);
+		if (screenDim == null) screenDim = new Dimension(0,0);
+	}
+
+	/**
+	 * Best you call this routine before you make any instance of MapImage
+	 * If the windows size changes after instantiation call  screenDimChanged()
+	 * for every symbol.
+	 *
+	 */
+	public static void setScreenSize(int w, int h) {
+		screenDim = new Dimension(w, h);
+	}
+
+	public void setImage(Image im, Color c) {
+		super.setImage(im.getImageData());
+		if (screenDim == null) screenDim = new Dimension(0,0);
+	}
+
+	public void setLocation (int x, int y) {
+		locAlways.x = x;
+		locAlways.y = y;
+		if (!hidden &amp;&amp; isOnScreen()) {
+			super.setLocation(x, y);
+			properties &amp;= ~AniImage.IsInvisible;
+		} else {
+			properties |= AniImage.IsInvisible;
+			super.move(0, 0);
+		}
+	}
+
+	public void move (int x, int y) {
+		locAlways.x = x;
+		locAlways.y = y;
+		if (!hidden &amp;&amp; isOnScreen()) {
+			super.move(x, y);
+			properties &amp;= ~AniImage.IsInvisible;
+		} else {
+			properties |= AniImage.IsInvisible;
+			super.move(0, 0);
+		}
+	}
+
+	public boolean isOnScreen() {
+		if ( (locAlways.x + location.width &gt; 0 &amp;&amp; locAlways.x &lt; screenDim.width) &amp;&amp;
+				(locAlways.y + location.height &gt; 0 &amp;&amp; locAlways.y &lt; screenDim.height) ) return true;
+		return false;
+	}
+
+	public void screenDimChanged() {
+		move(locAlways.x, locAlways.y);
+		//if (!hidden &amp;&amp; isOnScreen()) properties &amp;= ~AniImage.IsInvisible;
+		//else properties |= AniImage.IsInvisible;
+	}
+
+
+	public void hide() {
+		hidden = true;
+		properties |= AniImage.IsInvisible;
+	}
+	public void unhide() {
+		hidden = false;
+		move(locAlways.x, locAlways.y);
+	}
+}

Added: experiments/EVE/src/cachewolf/navi/MapImporter.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/MapImporter.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/MapImporter.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,405 @@
+package cachewolf.navi;
+
+import java.util.*;
+import eve.io.*;
+import eve.ui.filechooser.FileChooser;
+import eve.sys.*;
+import eve.ui.*;
+import eve.fx.*;
+import eve.ui.game.AniImage;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.FileReader;
+import java.io.BufferedReader;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+
+import cachewolf.CWPoint;
+import cachewolf.CoordsScreen;
+import cachewolf.Global;
+import cachewolf.InfoBox;
+import cachewolf.MyLocale;
+import cachewolf.Preferences;
+import cachewolf.utils.Common;
+
+import eve.util.FormattedDataSource;
+import eve.util.mString;
+import eve.ui.event.ControlEvent;
+import eve.ui.game.InteractivePanel;
+
+
+import eve.util.ByteArray;
+
+
+
+/**
+ *	This class is for importing and manually georeferencing maps
+ *	This class id=4100 for cachewolf-languages
+ */
+public class MapImporter extends Form {
+	Preferences pref;
+	String mapsPath = &quot;&quot;;
+	String thisMap = &quot;&quot;;
+	public String selectedMap = &quot;&quot;;
+	CellPanel infPanel;
+	Label infLabel = new Label(&quot;                          &quot;);
+	Vector GCPs = new Vector();
+	MapInfoObject wfl = new MapInfoObject();
+	Button infButton;
+	ScrollBarPanel scp;
+	AniImage mapImg;
+	int imageWidth, imageHeight = 0;
+
+	/**
+	 *	This constructor should be used when importing maps
+	 */
+	public MapImporter(Preferences pref){
+		this.pref = pref;
+		mapsPath = pref.getMapManuallySavePath(true)+&quot;/&quot;; //File.getProgramDirectory() + &quot;/maps/&quot;;
+	}
+
+	/**
+	 *	When a user clicks on the map and more than three ground control points exist
+	 *	then the calculated coordinate based on the affine transformation is displayed in the
+	 *	info panel below the map.
+	 *	It helps to identify how good the georeferencing works based on the set GCPs.
+	 */
+	public void updatePosition(int x, int y){
+		if(GCPs.size()&gt;=3  || (wfl.topleft.isValid())){
+			CWPoint p = wfl.calcLatLon(x,y);
+			infLabel.setText(&quot;--&gt; &quot; + p.getLatDeg(CWPoint.DMS) + &quot; &quot; +p.getLatMin(CWPoint.DMM) + &quot; / &quot; + p.getLonDeg(CWPoint.DMS) + &quot; &quot; + p.getLonMin(CWPoint.DMM));
+		}
+	}
+
+	/**
+	 *	This is the correct constructor for georeferencing maps.
+	 */
+	public MapImporter(Preferences pref, String mapToLoad, boolean worldfileexists){
+		this.pref = pref;
+		this.title = MyLocale.getMsg(4106,&quot;Calibrate map:&quot;) + &quot; &quot; + mapToLoad;
+		this.resizable = true;
+		this.moveable = true;
+		//this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
+		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
+		thisMap = mapToLoad;
+		mapsPath = pref.getMapManuallySavePath(true)+&quot;/&quot;; //File.getProgramDirectory() + &quot;/maps/&quot;; // TDO veraltet
+		try {
+			wfl.loadwfl(mapsPath, thisMap);
+		}catch(FileNotFoundException ex){
+			//	Vm.debug(&quot;Cannot load world file!&quot;);
+		}catch (IOException ex) { // is thrown if lat/lon out of range
+			MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, &quot;Error&quot;), ex.getMessage(), MessageBox.OKB);
+			tmpMB.execute();
+			Vm.debug(&quot;Cannot load world file!&quot;);
+		}
+		mapInteractivePanel pane = new mapInteractivePanel(this);
+		scp = new cachewolf.MyScrollBarPanel(pane);
+		//pB = pB.scale((int)(pref.myAppWidth*0.98),(int)(pref.myAppHeight*0.98));
+		mapImg = new AniImage(Common.getImageName(mapsPath + thisMap));
+		pane.addImage(mapImg);
+		scp.setPreferredSize(mapImg.getWidth(),mapImg.getHeight());
+		imageWidth = mapImg.getWidth();
+		imageHeight = mapImg.getHeight();
+		this.addLast(scp.getScrollablePanel(), CellConstants.STRETCH, CellConstants.FILL);
+		infPanel = new CellPanel();
+		infPanel.addNext(infLabel,CellConstants.STRETCH, CellConstants.FILL);
+		infButton = new Button(MyLocale.getMsg(4107,&quot;Done!&quot;));
+		infPanel.addLast(infButton,CellConstants.DONTSTRETCH, CellConstants.FILL);
+		this.addLast(infPanel, CellConstants.DONTSTRETCH, CellConstants.FILL);
+		//scp.repaintNow();
+		//this.repaintNow();
+	}
+
+	/**
+	 *	Add a ground control point to the list
+	 *	If the list is longer than 3 GCPs these will be evaluated
+	 *	to obtain the required parameters for the affine
+	 *	transformation.
+	 */
+	public void addGCP(GCPoint GCP){
+		if (GCP.latDec&gt;90 || GCP.latDec&lt;-90 || GCP.lonDec&gt;360 || GCP.lonDec&lt;-180) throw new IllegalArgumentException(&quot;lat/lon out of range: &quot;+GCP.toString());
+		GCPs.add(GCP);
+		if(GCPs.size() &gt;= 3){
+			wfl.evalGCP(GCPs, imageWidth, imageHeight);
+		}
+	}
+
+
+	/**
+	 *	Method to copy (&quot;import&quot;) a png based map
+	 *	into the maps folder in the CacheWolf base directory.
+	 *
+	 *	If the maps directory does not exist it will create it.
+	 *	If it finds .map files it will assume these are oziexplorer calibration files.
+	 *	It will use these files to automatically georeference the files during import.
+	 */
+	public int importMap(){
+		String rawFileName;
+		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir);
+		fc.addMask(&quot;*.png,*.gif,*.bmp,*.jpg&quot;);
+		fc.title=(MyLocale.getMsg(4100,&quot;Select Directory:&quot;));
+		int tmp = fc.execute() ;
+		if(tmp != FileChooser.IDYES) return Form.IDCANCEL;
+		File inDir = fc.getChosenFile();
+		File mapFile;
+		InfoBox inf = new InfoBox(&quot;Info&quot;, MyLocale.getMsg(4109,&quot;Loading maps...            \n&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
+		inf.setPreferredSize(220, 300);
+		inf.setInfoHeight(100);
+		inf.relayout(false);
+		Form.showWait();
+		inf.exec();
+
+		//User selected a map, but maybe there are more png(s)
+		//copy all of them!
+		//at the same time try to find associated .map files!
+		//These are georeference files targeted for OziExplorer.
+		//So lets check if we have more than 1 png file:
+		String line = &quot;&quot;;
+		InputStream in = null;
+		OutputStream out = null;
+		BufferedReader inMap;
+		byte[] buf;
+		int len;
+		String[] parts;
+		String [] files = inDir.listMultiple(&quot;*.png,*.jpg,*.gif,*.bmp&quot;, File.LIST_FILES_ONLY);
+
+		String currfile = null;
+		String curInFullPath;
+		String curOutFullPath;
+		int num = files.length;
+		for(int i =  num -1 ; i &gt;= 0;i--){
+			currfile = files[i];
+			inf.setInfo(MyLocale.getMsg(4110,&quot;Loading: &quot;)+ &quot;\n&quot; + currfile + &quot;\n(&quot;+(num-i)+&quot;/&quot;+num+&quot;)&quot;);
+			//Copy the file
+			//Vm.debug(&quot;Copy: &quot; + inDir.getFullPath() + &quot;/&quot; +files[i]);
+			//Vm.debug(&quot;to: &quot; + mapsPath + files[i]);
+			curInFullPath = inDir.getFullPath() + &quot;/&quot; +currfile;
+			curOutFullPath = mapsPath + currfile;
+			boolean imageerror = false;
+			try {
+				in = new FileInputStream(curInFullPath);
+				buf = new byte[1024*10];
+				boolean first = true;
+				ByteArray header = new ByteArray(buf);
+				while ((len = in.read(buf)) &gt; 0) {
+					if (first) {
+						first = false;
+						header.copyFrom(buf, 0, len);
+						ImageInfo tmpII = Image.getImageInfo((new FormattedDataSource()).set(header),null);
+						imageWidth = tmpII.width;
+						imageHeight = tmpII.height;
+						out = new FileOutputStream(curOutFullPath); // only create outfile if geImageInfo didn't throw an exception so do it only here not directly after opening input stream
+					}
+					out.write(buf, 0, len);
+				}
+			} catch(IOException ex){
+				imageerror = true;
+				inf.addWarning(&quot;\n&quot;+MyLocale.getMsg(4112, &quot;IO-Error while copying image from: &quot;) + curInFullPath + MyLocale.getMsg(4113, &quot; to: &quot;) + curOutFullPath + MyLocale.getMsg(4114, &quot; error: &quot;) + ex.getMessage());
+			} catch (IllegalArgumentException e) { // thrown from Image.getImageInfo when it could not interprete the header (e.g. bmp with 32 bits per pixel)
+				imageerror = true;
+				inf.addWarning(&quot;\n&quot;+MyLocale.getMsg(4115, &quot;Error: could not decode image: &quot;) + curInFullPath + MyLocale.getMsg(4116, &quot; - image not copied&quot;));
+			} finally {
+				try {
+					if (in != null) in.close();
+					if (out  != null) out.close();
+				} catch (Throwable e) {}
+			}
+			//Check for a .map file
+			rawFileName = currfile.substring(0, currfile.lastIndexOf(&quot;.&quot;));
+			mapFile = new File(inDir.getFullPath() + &quot;/&quot; + rawFileName + &quot;.map&quot;);
+			if(!imageerror &amp;&amp; mapFile.exists()){
+				GCPoint gcp1 = new GCPoint();
+				GCPoint gcp2 = new GCPoint();
+				GCPoint gcp3 = new GCPoint();
+				GCPoint gcp4 = new GCPoint();
+				GCPoint gcpG = new GCPoint();
+				//Vm.debug(&quot;Found file: &quot; + inDir.getFullPath() + &quot;/&quot; + rawFileName + &quot;.map&quot;);
+				try {
+					inMap = new BufferedReader(new FileReader(inDir.getFullPath() + &quot;/&quot; + rawFileName + &quot;.map&quot;));
+					while((line = inMap.readLine()) != null){
+						if(line.equals(&quot;MMPNUM,4&quot;)){
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp1.bitMapX = Convert.toInt(parts[2]);
+							gcp1.bitMapY = Convert.toInt(parts[3]);
+							if(gcp1.bitMapX == 0) gcp1.bitMapX = 1;
+							if(gcp1.bitMapY == 0) gcp1.bitMapY = 1;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp2.bitMapX = Convert.toInt(parts[2]);
+							gcp2.bitMapY = Convert.toInt(parts[3]);
+							if(gcp2.bitMapX == 0) gcp2.bitMapX = 1;
+							if(gcp2.bitMapY == 0) gcp2.bitMapY = 1;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp3.bitMapX = Convert.toInt(parts[2]);
+							gcp3.bitMapY = Convert.toInt(parts[3]);
+							if(gcp3.bitMapX == 0) gcp3.bitMapX = 1;
+							if(gcp3.bitMapY == 0) gcp3.bitMapY = 1;
+							//imageWidth = gcp3.bitMapX;
+							//imageHeight = gcp3.bitMapY;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							gcp4.bitMapX = Convert.toInt(parts[2]);
+							gcp4.bitMapY = Convert.toInt(parts[3]);
+							if(gcp4.bitMapX == 0) gcp4.bitMapX = 1;
+							if(gcp4.bitMapY == 0) gcp4.bitMapY = 1;
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(MyLocale.getDigSeparator().equals(&quot;,&quot;)) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp1.bitMapX;
+							gcpG.bitMapY = gcp1.bitMapY;
+							addGCP(gcpG);
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(MyLocale.getDigSeparator().equals(&quot;,&quot;)) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp2.bitMapX;
+							gcpG.bitMapY = gcp2.bitMapY;
+							addGCP(gcpG);
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(MyLocale.getDigSeparator().equals(&quot;,&quot;)) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp3.bitMapX;
+							gcpG.bitMapY = gcp3.bitMapY;
+							addGCP(gcpG);
+
+							line = inMap.readLine();
+							parts = mString.split(line, ',');
+							if(MyLocale.getDigSeparator().equals(&quot;,&quot;)) {
+								parts[3]= parts[3].replace('.', ',');
+								parts[2]= parts[2].replace('.', ',');
+							}
+							gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+							gcpG.bitMapX = gcp4.bitMapX;
+							gcpG.bitMapY = gcp4.bitMapY;
+							addGCP(gcpG);
+							/* already read from image file itself
+							// get dimensions of image
+							while ( (line = inMap.readLine()) != null){
+								if (line.startsWith(&quot;IWH&quot;)){
+									parts = mString.split(line, ',');
+									imageWidth = Convert.toInt(parts[2]);
+									imageHeight = Convert.toInt(parts[3]);
+								}
+							}
+							 */
+							wfl.evalGCP(GCPs, imageWidth, imageHeight);
+							//Vm.debug(&quot;Saving .map file to: &quot; + mapsPath + &quot;/&quot; + rawFileName + &quot;.wfl&quot;);
+							wfl.saveWFL(mapsPath, rawFileName);
+							GCPs.clear();
+						} // if
+
+					} // while
+					if (inMap != null)	inMap.close();
+				} catch(IllegalArgumentException ex){ // is thrown from Convert.toDouble and saveWFL if affine[0-5]==0 NumberFormatException is a subclass of IllegalArgumentExepction
+					inf.addWarning(&quot;\n&quot;+MyLocale.getMsg(4117, &quot;Error while importing .map-file: &quot;)+ex.getMessage());
+				} catch(IOException ex){
+					inf.addWarning(&quot;\n&quot;+MyLocale.getMsg(4118, &quot;IO-Error while reading or writing calibration file&quot;)+&quot;\n&quot; + ex.getMessage());
+				}
+			} else { // if map file.exists
+				if (!imageerror) inf.addWarning(&quot;\n&quot;+MyLocale.getMsg(4119, &quot;No calibration file found for: &quot;) + currfile + &quot; - you can calibrate it manually&quot;);
+			}
+		} // for file
+		Form.cancelWait();
+		inf.addText(&quot;\n&quot;+MyLocale.getMsg(4120, &quot;done.&quot;));
+		inf.addOkButton();
+		//inf.addOkButton(); doesn't work
+		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false;
+		return Form.IDOK;
+	}
+
+
+
+	/**
+	 *	Handles button pressed event
+	 *	When the button is pressed a mapname.wfl file is saved in the
+	 *	maps directory.
+	 */
+	public void onEvent(Event ev){
+
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			// display coords in another format
+			if (ev.target == infButton){
+				boolean retry = true;
+				while (retry == true) {
+					try {
+						retry = false;
+						wfl.saveWFL(mapsPath, thisMap);
+						if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false;
+					} catch (IOException e) {
+						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(321, &quot;Error writing file &quot;) + e.getMessage()+MyLocale.getMsg(324, &quot; - retry?&quot;), MessageBox.YESB | MessageBox.NOB);
+						if (tmpMB.execute() == MessageBox.IDYES) retry = true;
+					}catch (IllegalArgumentException e) {
+						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(325, &quot;Map not calibrated&quot;)+MyLocale.getMsg(324, &quot; - retry?&quot;), MessageBox.YESB | MessageBox.NOB);
+						if (tmpMB.execute() == MessageBox.IDYES) { retry = true; break; }
+					}
+				}
+				if (!retry) close(0);
+			}
+		}
+	}
+}
+
+/**
+ *	Class that creates a panel and loads a map.
+ *	It catches click events to display a form where the user may enter the required ccordinates
+ *	The data is stored as a ground control point in the calling class: Map
+ */
+class mapInteractivePanel extends InteractivePanel{
+	MapImporter f;
+	public mapInteractivePanel(MapImporter f){
+		this.f = f;
+	}
+
+	/**
+	 *	Event handler to catch clicks on the map
+	 */
+	public void imageClicked(AniImage which, Point pos){
+		//Vm.debug(&quot;X = &quot; +pos.x + &quot; Y = &quot; + pos.y);
+		Image img = new Image(31, 31);
+		Graphics g = new Graphics(img);
+		g.setColor(new Color(0,0,0));
+		g.fillRect(0,0,31,31);
+		g.setColor(new Color(255,0,0));
+		g.drawLine(0,16,31,16);
+		g.drawLine(16,0,16,31);
+		AniImage aImg = new AniImage(img);
+		aImg.setLocation(pos.x-16,pos.y-16);
+		//TODO How to set transparent color ? aImg.transparentColor = new Color(0,0,0);
+		//aImg.properties = Picture.IsNotHot;
+		aImg.properties = eve.fx.Drawing.AlwaysOnTop;
+		this.addImage(aImg);
+		g.free();
+		this.repaintNow();
+		f.updatePosition(pos.x, pos.y);
+
+		CoordsScreen cooS = new CoordsScreen(); // (String)lr.get(4108,&quot;Coordinates:&quot;), (String)lr.get(4108,&quot;Coordinates:&quot;), InfoBox.INPUT);
+		if (cooS.execute()==CoordsScreen.IDOK) {
+			GCPoint gcp = new GCPoint(cooS.getCoords());
+			gcp.bitMapX = pos.x;
+			gcp.bitMapY = pos.y;
+			f.addGCP(gcp);
+		} else this.removeImage(aImg); // CANCEL pressed
+	}
+}

Added: experiments/EVE/src/cachewolf/navi/MapInfoObject.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/MapInfoObject.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/MapInfoObject.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,447 @@
+package cachewolf.navi;
+
+import eve.fx.Point;
+import java.io.BufferedWriter;
+import java.io.FileInputStream;
+import java.io.FileWriter;
+import eve.io.File;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.BufferedReader;
+import java.io.PrintWriter;
+import eve.sys.*;
+import java.lang.Math;
+
+import cachewolf.CWPoint;
+import cachewolf.MyLocale;
+import cachewolf.utils.Common;
+import cachewolf.utils.STRreplace;
+import cachewolf.utils.Matrix;
+
+
+
+/**
+ * class to read, save and do the calculations for calibrated and
+ * calibrating maps
+ * start offset for language file: 4300
+ * @author pfeffer
+ *
+ */
+public class MapInfoObject extends Area {
+	//World file:
+	// x scale
+	// y scale
+	// x rotation
+	// y rotation
+	// lon of upper left corner of image
+	// lat of upper left corner of image
+	// lon of lower right corner of image
+	// lat of lower right corner of image
+
+	private double[] affine = {0,0,0,0};
+	private CWPoint affineTopleft = new CWPoint();;
+	private double transLatX, transLatY, transLonX, transLonY; // this are needed for the inervers calculation from lat/lon to x/y
+	public CWPoint center = new CWPoint();
+	public float sizeKm = 0; // diagonale
+	public float scale; // in meters per pixel, note: it is assumed that this scale identifying the scale of the map, automatically adjusted when zooming
+	public float zoomFactor = 1; // if the image is zoomed, direct after laoding always 1
+	public Point shift = new Point (0,0);
+	public CWPoint origAffineUpperLeft; // this is only valid after zooming
+	public float rotationRad; // contains the rotation of the map == north direction in rad
+	/** full path to the respective worldfile, including &quot;.wfl&quot;*/
+	public String fileNameWFL = &quot;&quot;;
+	/** filename wihout directory */
+//	public String fileName = new String();
+	/** name of the map, introduced to allow 'maps' without an image (empty maps) */
+	public String mapName = &quot;&quot;;
+	//private Character digSep = new Character(' ');
+	static private String digSep = MyLocale.getDigSeparator();
+	private int coordTrans = 0;
+
+	public MapInfoObject() {}
+
+	public MapInfoObject(MapInfoObject map) {
+		super (map.topleft, map.buttomright);
+		mapName = map.mapName;
+		affine[0] = map.affine[0];
+		affine[1] = map.affine[1];
+		affine[2] = map.affine[2];
+		affine[3] = map.affine[3];
+		origAffineUpperLeft = new CWPoint (map.origAffineUpperLeft);
+		affineTopleft = new CWPoint(map.affineTopleft);
+		zoomFactor = map.zoomFactor;
+		shift.set(map.shift);
+		coordTrans = map.coordTrans;
+		//	fileName = new String(map.fileName);
+		fileNameWFL = new String(map.fileNameWFL);
+		mapName = new String(mapName);
+		doCalculations();
+	}
+
+	/**
+	 * constructes an MapInfoObject without an associated map
+	 * but with 1 Pixel = scale meters
+	 */
+	public MapInfoObject(double scalei, double lat) {
+		super(new CWPoint(1,0), new CWPoint(0,1));
+		mapName=MyLocale.getMsg(4300, &quot;empty 1 Pixel = &quot;) + scalei + MyLocale.getMsg(4301,&quot;meters&quot;);
+		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		double pixel2deg = meters2deg * scalei;
+		affine[0]=0; //x2lat
+		affine[1]=pixel2deg / java.lang.Math.cos(lat*java.lang.Math.PI / 180); //x2lon
+		affine[2]=-pixel2deg; //y2lat
+		affine[3]=0; //y2lon
+		topleft.latDec=1; //top
+		topleft.lonDec=0; //left
+		buttomright.latDec = 0; //buttom
+		buttomright.lonDec = 1; //right
+		affineTopleft.set(topleft);
+		doCalculations();
+		origAffineUpperLeft = new CWPoint(affineTopleft);
+	}
+
+	/**
+	 * constructs an MapInfoObject with an associated map
+	 * with 1 Pixel = scale meters, centre and width, hight in pixels
+	 * @param name path and filename of .wfl file without the extension (it is needed because the image will be searched in the same directory)
+	 */
+	public MapInfoObject(double scalei, CWPoint center, int width, int hight, String name) {
+		super();
+		mapName = name+&quot;.wfl&quot;;
+		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		double pixel2deg = meters2deg * scalei;
+		double pixel2deghorizontal = pixel2deg / java.lang.Math.cos(center.latDec*java.lang.Math.PI / 180);
+		affine[0]=0; //x2lat
+		affine[1]=pixel2deghorizontal; //x2lon
+		affine[2]=-pixel2deg; //y2lat
+		affine[3]=0; //y2lon
+		topleft.latDec=center.latDec + hight / 2 *pixel2deg; //top
+		topleft.lonDec=center.lonDec - width / 2 *pixel2deghorizontal; //left
+		affineTopleft.set(topleft);
+		buttomright.latDec = center.latDec - hight / 2 *pixel2deg; //buttom
+		buttomright.lonDec = center.lonDec + width / 2 *pixel2deghorizontal; //right
+		fileNameWFL = name;
+		origAffineUpperLeft = new CWPoint(affineTopleft);
+		doCalculations();
+	}
+
+	public MapInfoObject(String mapsPath, String thisMap) throws IOException, ArithmeticException {
+		super();
+		loadwfl(mapsPath, thisMap);
+	}
+
+	/**
+	 *
+	 * @param path including trailing &quot;/&quot;
+	 * @param n without &quot;.wfl&quot;
+	 * @return name of the map including fast-find-prefix
+	 */
+	public String setName(String path, String n) {
+		String pref = getFfPrefix();
+		mapName = pref + n;
+		fileNameWFL = path + pref + mapName + &quot;.wfl&quot;;
+		return mapName;
+	}
+
+	/**
+	 * @return the filename of the associated map image, &quot;&quot; if no file is associated, null if associated file could not be found
+	 */
+	public String getImageFilename() {
+		// if (fileName == null || fileName.length() &gt; 0) return fileName;
+		if (fileNameWFL.length() == 0) return &quot;&quot;; // no image associated (empty map)
+		String n = fileNameWFL.substring(0, fileNameWFL.lastIndexOf(&quot;.&quot;));
+		return Common.getImageName(STRreplace.replace(n, &quot;//&quot;, &quot;/&quot;));
+	}
+
+	/**
+	 * Method to load a .wfl-file
+	 * @param mapsPath path to the map inclunding / at the end
+	 * @param thisMap name of the map without extension
+	 * @throws IOException when there was a problem reading .wfl-file
+	 * @throws IOException when lat/lon were out of range
+	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
+	 */
+	public void loadwfl(String mapsPath, String thisMap) throws IOException, ArithmeticException {
+		FileInputStream instream = new FileInputStream (STRreplace.replace(mapsPath + thisMap + &quot;.wfl&quot;, &quot;//&quot;, &quot;/&quot;));
+		BufferedReader in = new BufferedReader(new InputStreamReader(instream));
+
+		String line = &quot;&quot;;
+		try {
+			for(int i = 0; i&lt;4;i++){
+				line = in.readLine();
+				affine[i] = Common.parseDoubleException(line);
+			}
+			line = in.readLine();
+			affineTopleft.latDec = Common.parseDoubleException(line);
+			line = in.readLine();
+			affineTopleft.lonDec = Common.parseDoubleException(line);
+			line = in.readLine();
+			buttomright.latDec = Common.parseDoubleException(line);
+			line = in.readLine();
+			buttomright.lonDec = Common.parseDoubleException(line);
+			line = in.readLine(); // readLine returns null, if End of File reached
+			if (line != null)
+				coordTrans = Common.parseInt(line);
+			else
+				coordTrans = 0;
+			fileNameWFL = mapsPath + thisMap + &quot;.wfl&quot;;
+//			fileName = &quot;&quot;; //mapsPath + thisMap + &quot;.png&quot;;
+			mapName = thisMap;
+			in.close();
+			if( !buttomright.isValid() ) {
+				affine[0] = 0; affine[1] = 0; affine[2] = 0; affine[3] = 0;
+				topleft.makeInvalid();
+				throw (new IOException(MyLocale.getMsg(4301, &quot;Lat/Lon out of range while reading &quot;)+mapsPath + thisMap + &quot;.wfl&quot;));
+			}
+		} catch (NullPointerException e) { // in.readline liefert null zur&#252;ck, wenn keine Daten mehr vorhanden sind
+			throw (new IOException(MyLocale.getMsg(4303, &quot;not enough lines in file &quot;)+mapsPath + thisMap + &quot;.wfl&quot;));
+		}
+		doCalculations();
+		origAffineUpperLeft = new CWPoint(affineTopleft);
+	}
+
+	public void evalGCP(java.util.Vector GCPs, int imageWidth, int imageHeight) throws IllegalArgumentException {
+		evalGCP(GCPs, imageWidth, imageHeight, 0);
+	}
+		/**
+	 *	Method to evaluate ground control points (georeferenced points) and identify the parameters
+	 *	for the affine transformation
+	 *  @throws IllegalArgumentException when less than 3 georeferenced points were given in GCPs
+	 */
+
+	public void evalGCP(java.util.Vector GCPs, int imageWidth, int imageHeight, int epsg_code) throws IllegalArgumentException {
+		//N 48 16.000 E 11 32.000
+		//N 48 16.000 E 11 50.000
+		//N 48 9.000 E 11 32.000
+		if (GCPs.size() &lt; 3 ) throw new IllegalArgumentException(MyLocale.getMsg(4304, &quot;not enough points to calibrate the map&quot;));
+		GCPoint gcp;
+		//Calculate parameters for latitutde affine transformation (affine 0,2,4)
+		Matrix X = new Matrix(GCPs.size(),3);
+		Matrix trg = new Matrix(GCPs.size(),1);
+		for(int i = 0; i &lt; GCPs.size();i++){
+			gcp = (GCPoint)GCPs.get(i);
+			X.matrix[i][0] = 1; X.matrix[i][1] = gcp.bitMapX; X.matrix[i][2] = gcp.bitMapY;
+			trg.matrix[i][0] = gcp.latDec;
+		}
+		Matrix Xtran = new Matrix(X);
+		Xtran.transpose();
+		Matrix XtranX = new Matrix(Xtran);
+		XtranX.multiply(X);
+		Matrix XtranXinv = new Matrix(XtranX);
+		XtranXinv.inverse();
+		Matrix beta = new Matrix(XtranXinv);
+		beta.multiply(Xtran);
+		beta.multiply(trg);
+		affine[0] = beta.matrix[1][0];
+		affine[2] = beta.matrix[2][0];
+		affineTopleft.latDec = beta.matrix[0][0];
+
+		//Calculate parameters for longitude affine transformation (affine 1,3,5)
+		X = new Matrix(GCPs.size(),3);
+		trg = new Matrix(GCPs.size(),1);
+		for(int i = 0; i &lt; GCPs.size();i++){
+			gcp = (GCPoint)GCPs.get(i);
+			X.matrix[i][0] = 1;
+			X.matrix[i][1] = gcp.bitMapX;
+			X.matrix[i][2] = gcp.bitMapY;
+			trg.matrix[i][0] = gcp.lonDec;
+		}
+		Xtran = new Matrix(X);
+		Xtran.transpose();
+		XtranX = new Matrix(Xtran);
+		XtranX.multiply(X);
+		XtranXinv = new Matrix(XtranX);
+		XtranXinv.inverse();
+		beta = new Matrix(XtranXinv);
+		beta.multiply(Xtran);
+		beta.multiply(trg);
+		affine[1] = beta.matrix[1][0];
+		affine[3] = beta.matrix[2][0];
+		affineTopleft.lonDec = beta.matrix[0][0];
+		coordTrans = epsg_code;
+		buttomright = calcLatLon(imageWidth, imageHeight);
+		doCalculations();
+		//Vm.debug(&quot;A B C&quot; + affine[0] + &quot; &quot; + affine[2] + &quot; &quot; + affine[4]);
+		//Vm.debug(&quot;D E F&quot; + affine[1] + &quot; &quot; + affine[3] + &quot; &quot; + affine[5]);
+	}
+
+	/**
+	 * calculates centre, diagonal size of the map and inverse to affine transformation
+	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
+	 */
+
+	private void doCalculations() throws ArithmeticException {
+		try {
+			topleft.set(calcLatLon(0, 0));
+			center.set((buttomright.latDec + topleft.latDec)/2,(buttomright.lonDec + topleft.lonDec)/2);
+			sizeKm = java.lang.Math.abs((float)center.getDistance(buttomright.latDec, buttomright.lonDec)) *2;
+
+			//calculate reverse affine
+			double nenner=(-affine[1]*affine[2]+affine[0]*affine[3]);
+			transLatX = affine[3]/nenner; // nenner == 0 cannot happen as long als affine is correct
+			transLonX = -affine[2]/nenner;
+			transLatY = -affine[1]/nenner;
+			transLonY = affine[0]/nenner;
+
+			// calculate north direction
+			Point c = calcMapXY(center);
+			int heightpixel = c.y * 2;
+			c.y -= 1000;
+			rotationRad = (float) (center.getBearing(calcLatLon(c)) / 180 * Math.PI);  // note: the direction of nord can vary across the image. In Gau&#223;-Kr&#252;ger Projection it does change about 1 degree per 10km! //(float)java.lang.Math.atan(rotationX2y);
+			if (rotationRad &gt; Math.PI) rotationRad -= 2* Math.PI;
+
+			// calculate scale in meters per pixel
+			double heightkm = calcLatLon(0, heightpixel).getDistance(topleft);
+			scale = (float) (heightkm * 1000 / heightpixel);
+		} catch (ArithmeticException ex) { throw new ArithmeticException(MyLocale.getMsg(4305, &quot;Not allowed values in affine\n (matrix cannot be inverted)\n in file \n&quot;) + fileNameWFL); }
+	}
+
+	public void saveWFL() throws IOException, IllegalArgumentException {
+		File dateiF = new File(fileNameWFL);
+		String tmp = dateiF.getDrivePath(); // contains the name and the extension
+		saveWFL(tmp, mapName);
+	}
+
+	/**
+	 *	Method to save a world file (.wfl)
+	 * @param mapsPath without &quot;/&quot; at the end
+	 * @param mapFileName without file extension
+	 * @throws IOException when there was a problem writing .wfl-file
+	 * @throws IllegalArgumentException when affine[x] for all x == 0 (&quot;map not calibrated&quot;).
+	 */
+	public void saveWFL(String mapsPath, String mapFileName) throws IOException, IllegalArgumentException {
+		if (affine[0]==0 &amp;&amp; affine[1]==0 &amp;&amp; affine[2]==0 &amp;&amp; affine[3]==0 &amp;&amp;
+				!topleft.isValid()) throw (new IllegalArgumentException(MyLocale.getMsg(4306, &quot;map not calibrated&quot;)));
+		PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(mapsPath + &quot;/&quot; + mapFileName + &quot;.wfl&quot;)));
+		StringBuffer towriteB=new StringBuffer(400);
+		towriteB.append(Convert.toString(affine[0])).append(&quot;\n&quot;);
+		towriteB.append(Convert.toString(affine[1])).append(&quot;\n&quot;);
+		towriteB.append(Convert.toString(affine[2])).append(&quot;\n&quot;);
+		towriteB.append(Convert.toString(affine[3])).append(&quot;\n&quot;);
+		towriteB.append(Convert.toString(affineTopleft.latDec)).append(&quot;\n&quot;);
+		towriteB.append(Convert.toString(affineTopleft.lonDec)).append(&quot;\n&quot;);
+		towriteB.append(Convert.toString(buttomright.latDec)).append(&quot;\n&quot;);
+		towriteB.append(Convert.toString(buttomright.lonDec)).append(&quot;\n&quot;);
+		towriteB.append(((coordTrans == 0 || coordTrans == TransformCoordinates.EPSG_WGS84) ? &quot;&quot; : Convert.toString(coordTrans)+&quot;\n&quot;));
+		String towrite = towriteB.toString();
+		if (digSep.equals(&quot;,&quot;)) towrite=towrite.replace(',', '.');
+		outp.print(towrite);
+		outp.close();
+//		this.fileName = &quot;&quot;; // this will be set in getImageFilenam //mapsPath + &quot;/&quot; + mapFileName + &quot;.png&quot;;
+		this.fileNameWFL = mapsPath + &quot;/&quot; + mapFileName + &quot;.wfl&quot;;
+		this.mapName = mapFileName;
+	}
+
+
+	/**
+	 * zoom in / out
+	 * @param zf zf &gt; 1 == zoom in, zoom is relative to original unscaled image
+	 * @param diffX shift of map in pixels (if the map was cropped while zooming) in the not zoomed image
+	 * @param diffY
+	 */
+	public void zoom(float zf, int diffX, int diffY) {
+		// restore original values to calculate corret shift (upperleft)
+		affineTopleft.latDec = origAffineUpperLeft.latDec;
+		affineTopleft.lonDec = origAffineUpperLeft.lonDec;
+		affine[0] = affine[0] * zoomFactor;
+		affine[1] = affine[1] * zoomFactor;
+		affine[2] = affine[2] * zoomFactor;
+		affine[3] = affine[3] * zoomFactor;
+		TrackPoint upperleft = calcLatLon(diffX, diffY);
+		if (coordTrans != 0) upperleft = TransformCoordinatesProperties.fromWgs84(upperleft, coordTrans);
+		affineTopleft.latDec = upperleft.latDec; // TODO nachdenken affineTopleft
+		affineTopleft.lonDec = upperleft.lonDec;
+		affine[0] = affine[0] / zf ;
+		affine[1] = affine[1] / zf ;
+		affine[2] = affine[2] / zf ;
+		affine[3] = affine[3] / zf ;
+		zoomFactor = zf ;
+		shift.x = diffX;
+		shift.y = diffY;
+		doCalculations(); // TODO lowlat neu berechnen?
+	}
+
+	/**
+	 * Method to calculate bitmap x,y of the current map using
+	 * lat and lon target coordinates. There ist no garanty that
+	 * the returned coordinates are inside of the map. They can be negative.
+	 * @param lat
+	 * @param lon
+	 */
+	public Point calcMapXY(TrackPoint ll){
+		TrackPoint t;
+		if (coordTrans != 0) t = TransformCoordinatesProperties.fromWgs84(ll, coordTrans);
+		else t = ll;
+		Point coords = new Point();
+		double b0,b1;
+		b0 = t.latDec - affineTopleft.latDec;
+		b1 = t.lonDec - affineTopleft.lonDec;
+		double mapx = transLatX* b0 + transLonX*b1;
+		double mapy = transLatY* b0 + transLonY*b1;
+		coords.x = (int)Math.round(mapx);
+		coords.y = (int)Math.round(mapy);
+		//Vm.debug(&quot;mapX=mapx2: &quot;+mapx+&quot;=&quot;+mapx2+&quot;; mapy=mapy2: &quot;+mapy+&quot;=&quot;+mapy2);
+		return coords;
+	}
+
+	/**
+	 * gives back lat/lon from x, y in map
+	 * @param x
+	 * @param y
+	 * @return
+	 */
+	public CWPoint calcLatLon(int x, int y) {
+		CWPoint ll = new CWPoint();
+		ll.latDec = x * affine[0] + y * affine[2] + affineTopleft.latDec;
+		ll.lonDec = x * affine[1] + y * affine[3] + affineTopleft.lonDec;
+		if (coordTrans != 0)
+			ll = TransformCoordinatesProperties.toWgs84(ll, coordTrans);
+		return ll;
+	}
+
+	public CWPoint calcLatLon(Point p) {
+		return calcLatLon(p.x, p.y);
+	}
+
+	/**
+	 * Get the prefix used for easy and fast finding of the best map
+	 * The filname of the .wfl and respective image should start with this
+	 * prefix in order to make finding the best map much faster
+	 * @return
+	 */
+	public String getFfPrefix() {
+		return &quot;FF1&quot;+getEasyFindString()+&quot;E-&quot;;
+	}
+}
+
+	/**
+	 *	Class based on CWPoint but intended to handle bitmap x and y
+	 *	Used for georeferencing bitmaps.
+	 */
+	class GCPoint extends CWPoint{
+		public int bitMapX = 0;
+		public int bitMapY = 0;
+
+		public GCPoint(){
+		}
+
+		public GCPoint(CWPoint p) {
+			super(p);
+		}
+
+		/**
+		 * If you are using Gau&#223;-Kr&#252;ger, put lat = northing, lon = easting
+		 * @param lat
+		 * @param lon
+		 */
+		public GCPoint(double lat, double lon){
+			this.latDec = lat;
+			this.lonDec = lon;
+			this.utmValid = false;
+		}
+		public GCPoint(CWPoint ll, Point px) {
+			super(ll);
+			bitMapX = px.x;
+			bitMapY = px.y;
+		}
+	}

Added: experiments/EVE/src/cachewolf/navi/MapLoader.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/MapLoader.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/MapLoader.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,694 @@
+package cachewolf.navi;
+
+import eve.ui.*;
+import eve.io.*;
+import eve.fx.*;
+import java.util.*;
+import eve.sys.*;
+import java.lang.Math;
+import java.net.Socket;
+import java.io.FileOutputStream;
+import java.io.FileInputStream;
+import eve.util.ByteArray;
+import java.io.IOException;
+
+import cachewolf.CWPoint;
+import cachewolf.HttpConnection;
+import cachewolf.InfoBox;
+import cachewolf.MyLocale;
+import cachewolf.utils.Common;
+import cachewolf.utils.STRreplace;
+
+import eve.util.mString;
+
+/**
+ *
+ * start offset for language file: 4800
+ */
+
+//Um Karten zu holen!
+//<A HREF="http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.09901667,11.35688333&amp;Lang=EUR0407&amp;Alti=1&amp;Size=600,600&amp;Offs=0.000000,0.000000&amp;Pins=|5748|">http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.09901667,11.35688333&amp;Lang=EUR0407&amp;Alti=1&amp;Size=600,600&amp;Offs=0.000000,0.000000&amp;Pins=|5748|</A>
+//oder
+//<A HREF="http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.15,11.5833&amp;Alti=2&amp;Lang=EUR0407&amp;Size=900,900&amp;Offs=0,0&amp;MapS=0&amp;Pins=|48.15,11.5833|4|48.15,11.5833&amp;Pins=|48.15,11.5833|1|48.15,%2011.5833||">http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.15,11.5833&amp;Alti=2&amp;Lang=EUR0407&amp;Size=900,900&amp;Offs=0,0&amp;MapS=0&amp;Pins=|48.15,11.5833|4|48.15,11.5833&amp;Pins=|48.15,11.5833|1|48.15,%2011.5833||</A>
+
+
+public class MapLoader {
+	InfoBox progressInfobox;
+
+	Vector onlineMapServices = new Vector();
+	OnlineMapService currentOnlineMapService;
+	int numMapsY;
+	int numMapsX;
+	double latinc;
+	double loninc;
+	CWPoint topleft;
+	CWPoint buttomright;
+	Point tilesSize;
+	float tileScale;
+
+	/**
+	 *
+	 * @param prxy
+	 * @param prt
+	 * @param wmspath without trailing &quot;/&quot;
+	 */
+	public MapLoader(String wmspath){
+		long start = new Time().getTime();
+		InfoBox progressBox = null;
+		boolean showprogress = false;
+
+		onlineMapServices = new Vector();
+		String dateien[];
+		File files = new File(wmspath);
+		String FileName;
+		OnlineMapService tempOMS;
+		MessageBox f = null;
+		dateien = files.list(&quot;*.wms&quot;, File.LIST_FILES_ONLY); //&quot;*.xyz&quot; doesn't work on some systems -&gt; use FileBugFix
+		for(int i = 0; i &lt; dateien.length;i++){
+			FileName = dateien[i];
+			try {
+				if (!showprogress &amp;&amp; ((i &amp; 0) == 0) &amp;&amp; (new Time().getTime()-start  &gt; 100) ) { // reason for (i &amp; 7 == 0): test time only after i is incremented 15 times
+					showprogress = true;
+					progressBox = new InfoBox(MyLocale.getMsg(327, &quot;Info&quot;), MyLocale.getMsg(4800, &quot;Loading online map services&quot;));
+					progressBox.exec();
+					progressBox.getWindow().waitUntilPainted(500);
+					eve.ui.Form.showWait();
+				}
+				tempOMS = new WebMapService(STRreplace.replace(wmspath + &quot;/&quot; + FileName, &quot;//&quot;, &quot;/&quot;));
+				onlineMapServices.add(tempOMS);
+			}catch(Exception ex){
+				if (f == null) (f=new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(4801, &quot;Ignoring error while \n reading web map service definition file \n&quot;)+ex.toString(), MessageBox.OKB)).exec();
+			}
+		}
+		tempOMS = new ExpediaMapService();
+		onlineMapServices.add(tempOMS);
+		if (progressBox != null) {
+			progressBox.close(0);
+			eve.ui.Form.cancelWait();
+		}
+	}
+
+	public String[] getAvailableOnlineMapServices(){
+		int s = onlineMapServices.size();
+		String[] services = new String[s];
+		for (int i=0; i &lt; s; i++) {
+			services[i]=onlineMapServices.get(i).toString();
+		}
+		return services;
+	}
+
+	public void setCurrentMapService(int index) {
+		currentOnlineMapService = (OnlineMapService) onlineMapServices.get(index);
+	}
+
+	/**
+	 * calculates the Expedia Alti = scale which fits in distance to its edges
+	 * @param center
+	 * @param distance in meters
+	 * @return meters per pixel calculatet in a way that the circle around center
+	 * is completly within the map
+	 */
+
+	public static float getScale(CWPoint center, float distance, Point size) {
+		float scaleLatO = distance * 2 / size.y;
+		float scaleLonO = distance * 2 / size.x;
+		float scaleO = (scaleLatO &lt; scaleLonO ? scaleLonO : scaleLatO);
+		return scaleO;
+	}
+
+	/**
+	 * download maps from expedia at zoomlevel alti and save the maps and the .wfl
+	 * in path
+	 * @param center centre of all tiles
+	 * @param radius in meters
+	 * @param scale in &quot;alti&quot; value 1 alti =  3950 /2817.947378 = 1,046861280317350198581316446428 meters per pixel
+	 * @param size in pixels
+	 * @param overlapping in pixels
+	 * @param path without &quot;/&quot; at the end
+	 *
+	 */
+	public void setTiles (CWPoint center, float radius, float scale, Point size, int overlapping) {
+		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		double metersPerLon = metersPerLat * java.lang.Math.cos(center.latDec/180*java.lang.Math.PI);
+		topleft = new CWPoint(center.latDec + (radius / metersPerLat), center.lonDec - (radius / metersPerLon));
+		buttomright = new CWPoint(center.latDec - (radius / metersPerLat), center.lonDec + (radius / metersPerLon));
+
+		this.setTiles(topleft, buttomright, scale, size, overlapping);
+	}
+
+	public void setTiles(CWPoint toplefti, CWPoint buttomrighti, float scale, Point size, int overlapping) {
+		//if (toplefti.latDec &lt;= buttomrighti.latDec || toplefti.lonDec &gt;= toplefti.lonDec) throw new IllegalArgumentException(&quot;topleft must be left and above buttom right&quot;);
+		topleft = new CWPoint(toplefti);
+		buttomright = new CWPoint(buttomrighti);
+		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
+		double metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + buttomright.latDec)/2/180*java.lang.Math.PI);
+		double metersperpixel = currentOnlineMapService.getMetersPerPixel(scale);
+		double pixelsPerLat = metersPerLat / metersperpixel;
+		double pixelsPerLon = metersPerLon / metersperpixel;
+
+		//over all pixelsize without borders
+		double pixelsY = (topleft.latDec - buttomright.latDec) * pixelsPerLat;
+		double pixelsX = -(topleft.lonDec - buttomright.lonDec) * pixelsPerLon ;
+
+		//border sizes around given area and overlapping between tiles
+		//int borderX = (int) java.lang.Math.round((float)size.x * (overlapping - 1.0));
+		//int borderY = (int) java.lang.Math.round((float)size.y * (overlapping - 1.0));
+		int borderX = overlapping;
+		int borderY = overlapping;
+
+		numMapsY = (int) java.lang.Math.ceil( (pixelsY + borderY) / (float)(size.y - borderY) );
+		numMapsX = (int) java.lang.Math.ceil( (pixelsX + borderX) / (float)(size.x - borderX) );
+
+		//increments calulated from pixel offset of tiles
+		latinc = -(size.y - borderY) / pixelsPerLat;
+		loninc = (size.x - borderX) / pixelsPerLon;
+
+		//calculation of centre of first tile
+
+		//additional size for borders and rounding
+		double oversizeX = (numMapsX * (size.x - borderX) + borderX) - pixelsX;
+		double oversizeY = (numMapsY * (size.y - borderY) + borderY) - pixelsY;
+
+		//offset for upper left corner
+		double offsetLat = -( (size.y - oversizeY) / 2.0 ) / pixelsPerLat;
+		double offsetLon = ( (size.x - oversizeX) / 2.0 ) / pixelsPerLon;
+
+		topleft.latDec += offsetLat;
+		topleft.lonDec += offsetLon;
+
+		this.tilesSize = new Point();
+		this.tilesSize.set(size);
+		this.tileScale = scale;
+	}
+
+	public void downlaodTiles(String tilesPath) {
+		double lat = topleft.latDec;
+		double lon = topleft.lonDec;
+		CWPoint center = new CWPoint();
+		for (int row = 1; row &lt;= numMapsY; row++) {
+			lon = topleft.lonDec;
+			for (int col = 1; col &lt;= numMapsX; col++) {
+				if (progressInfobox != null)
+					progressInfobox.setInfo(MyLocale.getMsg(4802, &quot;Downloading calibrated (georeferenced) \n map image \n '&quot;) + currentOnlineMapService.getName()+MyLocale.getMsg(4803, &quot;' \n Downloading tile \n row&quot;)+&quot; &quot;+row+&quot; / &quot;+numMapsY+MyLocale.getMsg(4804, &quot; column&quot;)+&quot; &quot;+ col + &quot; / &quot;+numMapsX);
+				center.set(lat, lon);
+				try {
+					downloadMap(center, tileScale, tilesSize, tilesPath);
+				} catch (Exception e) {
+					this.progressInfobox.addWarning(MyLocale.getMsg(4805, &quot;Tile&quot;)+&quot; &quot; + row + &quot;/&quot; + col + MyLocale.getMsg(4806, &quot;: Ignoring error:&quot;)+&quot; &quot; + e.getMessage()+&quot;\n&quot;);
+				}
+				if (progressInfobox.isClosed) return;
+				lon += loninc;
+			}
+			lat += latinc;
+		}
+	}
+
+	public void setProgressInfoBox (InfoBox progrssInfoboxi) {
+		progressInfobox = progrssInfoboxi;
+	}
+	/**
+	 *
+	 * @param center
+	 * @param scale
+	 * @param pixelsize
+	 * @param path must include trailing &quot;/&quot;
+	 * @throws Exception
+	 */
+	public void downloadMap(CWPoint center, float scale, Point pixelsize, String path) throws Exception {
+		MapInfoObject mio = currentOnlineMapService.getMapInfoObject(center, scale, pixelsize);
+		String filename = createFilename(mio.getCenter(), mio.scale);
+		String imagename = mio.setName(path, filename) + currentOnlineMapService.getImageFileExt();
+		String url = currentOnlineMapService.getUrlForCenterScale(center, scale, pixelsize);
+		downloadImage(url, path+imagename);
+		mio.saveWFL();
+	}
+
+	public String createFilename(CWPoint center, float scale) {
+		String filename = Common.clearForFileName(currentOnlineMapService.getNameForFileSystem()+&quot;_s&quot;+Common.doubleToString(scale, 1)
+				+ &quot;_c&quot; + center.toString(CWPoint.LAT_LON).replace(',', '-'));
+		return filename;
+	}
+
+	/**
+	 * @param url usual URL. If a redirect is requiered (as in the case of
+	 * Expedia, add an &quot;R&quot; before &quot;<A HREF="http://">http://</A>&quot; --&gt; Don't download the url, retry until getting a http-redirect
+	 * this is necessary for expedia as it delivers the image only after a http-redirect
+	 * and sometimes doesn't send a redirect on the first try
+	 * @param datei path and name of file to save to
+	 */
+	public void downloadImage(String url, String datei) throws IOException {
+		HttpConnection connImg; // TODO implement this in UrlFetcher class
+		Socket sockImg;
+		FileOutputStream fos;
+		ByteArray daten;
+		String realurl;
+		boolean forceredirect;
+		if (url.startsWith(&quot;R&quot;)) {
+			forceredirect = true;
+			realurl = url.substring(1, url.length());
+		} else {
+			forceredirect = false;
+			realurl = url;
+		}
+		connImg = new HttpConnection(realurl);
+		connImg.setRequestorProperty(&quot;USER_AGENT&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
+		connImg.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
+	//	this prevents gdz1.leipzig.ifag.de (dtk100) from answering and ist not necessary for expedia connImg.setRequestorProperty(&quot;Cookie&quot;, &quot;jscript=1; path=/;&quot;);
+		connImg.documentIsEncoded = true;
+		try{
+			java.io.File dateiF = new java.io.File(datei);
+			if(!dateiF.exists()){
+				int i=0;
+				sockImg = connImg.connect();
+				String quelle = connImg.getRedirectTo();
+				boolean redirrected = false;
+				while (i &lt; 5 &amp;&amp; (quelle != null || (forceredirect &amp;&amp; !redirrected))) { // this is necessary because expedia sometimes doesn't directly anser with the redirect to the map-image, but give a page in between. Solved the problem by retrying see also: <A HREF="http://www.geoclub.de/viewtopic.php?p=305071#305071">http://www.geoclub.de/viewtopic.php?p=305071#305071</A>
+					//Vm.debug(&quot;Redirect: &quot; + i + connImg.getRedirectTo());
+					if (quelle != null) {
+						redirrected = true;
+						sockImg.close();
+						connImg = connImg.getRedirectedConnection(quelle);
+						sockImg = connImg.connect();
+						quelle = connImg.getRedirectTo();
+					}
+					i++;
+				}
+				if (i &gt; 4) throw new IOException(MyLocale.getMsg(4807, &quot;loadTo: failed to download map: didn't get http-redirect&quot;));
+				String ct = (String)connImg.documentProperties.getValue(&quot;content-type&quot;, &quot;&quot;);
+				if (!ct.substring(0, 5).equalsIgnoreCase(&quot;image&quot;) )  {
+					String tmp = connImg.readText(sockImg, null).toString(); // TODO if the content is binary will will get an Exception in InfoBox, trying to display the content
+					tmp = tmp.substring(0, (tmp.length() &lt; 1000 ? tmp.length() : 1000));
+					sockImg.close();
+					throw new IOException(MyLocale.getMsg(4808, &quot;downloadImage: content-type:&quot;)+&quot; &quot; + ct + MyLocale.getMsg(4809, &quot; is not an image, begin of content:&quot;)+&quot; &quot; + tmp);
+				}
+				daten = connImg.readData(sockImg);
+				fos = new FileOutputStream(datei);
+				fos.write(daten.toBytes());
+				fos.close();
+				sockImg.close();
+			}
+			//Vm.debug(&quot;done&quot;);
+		}catch(IOException e){
+			throw new IOException(MyLocale.getMsg(4810, &quot;Error while downloading or saving map:\n&quot;) + e.getMessage());
+		}
+//		(new MessageBox(&quot;Error&quot;, &quot;Error saving calibration file:\n&quot;+e.getMessage(), MessageBox.OKB)).exec();
+
+	}
+}
+
+class OnlineMapService {
+	/** Friendly name of the service */
+	String name;
+	/** Type of map (used as directory name when downloading maps. We currently have &quot;topo&quot; and &quot;photo&quot; defined as map types */
+	String mapType;
+	/** Esentially the same as name, but used for the file system. It will be part of the names of the downloaded images */
+	String filename;
+	String MainUrl; //<A HREF="http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS">http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS</A>
+	/** including &quot;.&quot; */
+	String imageFileExt; // &quot;.gif&quot;, &quot;.jpg&quot;...
+	float recommendedScale;
+	double minscale;
+	double maxscale;
+	Area boundingBox;
+
+	/**
+	 * This method is used in case the online map service provides only certain steps of
+	 * zoomlevels. In this case the scale in meters per pixel must be returned, which
+	 * will be used instead of the wished scale.
+	 *
+	 * @param scale
+	 * @return
+	 */
+	public float getMetersPerPixel(float scale) {
+		return scale;
+	}
+
+	public String getImageFileExt() {
+		return imageFileExt;
+	}
+
+	/**
+	 * Overlaod this to integrate name of layers
+	 * @return friendly service name
+	 */
+	public String getName() {
+		return name;
+	}
+
+	/**
+	 * This method is called to get a name of the
+	 * online map service which will be part of the filename
+	 * used for the downloaded image
+	 * @return friendly service name
+	 */
+	public String getNameForFileSystem() {
+		return filename;
+	}
+
+	public String getMapType() {
+		return mapType;
+	}
+	/**
+	 * Overload this and return the URL to the map image, don't call super
+	 * Alternatively overload getUrlForBoundingBoxInternal
+	 * You must overload either this method or getUrlForBoundingBox
+	 * @param center
+	 * @param scale
+	 * @param pixelsize
+	 * @return
+	 */
+	public String getUrlForCenterScale(CWPoint center, float scale, Point pixelsize) {
+		Area bbox = CenterScaleToArea(center, scale, pixelsize);
+		String url = getUrlForBoundingBoxInternal(bbox, pixelsize);
+		return url;
+	}
+
+	/**
+	 * This is made protected and named &quot;...Internal&quot; because a lot of services
+	 * don't work correctly when a map is requested, that is not exactly quadratic
+	 * --&gt; alway use getUrlForCenter...
+	 * @param surArea
+	 * @param pixelsize
+	 * @return
+	 */
+	protected String getUrlForBoundingBoxInternal(Area surArea, Point pixelsize) {
+		return null;
+	}
+
+	/**
+	 * overload this if your map service uses a special projection
+	 * an return an Area that is quadratic in that projection
+	 * @param center
+	 * @param scale
+	 * @param pixelsize
+	 * @return
+	 */
+	public Area CenterScaleToArea(CWPoint center, float scale, Point pixelsize) {
+		Area bbox = new Area();
+		double halfdiagonal = Math.sqrt(pixelsize.x * pixelsize.x + pixelsize.y * pixelsize.y)/2 * scale / 1000;
+		bbox.topleft = center.project(-45, halfdiagonal);
+		bbox.buttomright = center.project(135, halfdiagonal);
+		return bbox;
+	}
+
+
+	protected MapInfoObject getMapInfoObjectInternal(Area maparea, Point pixelsize) {
+		throw new IllegalArgumentException(MyLocale.getMsg(4811, &quot;OnlineMapService: getMapInfoObjectInternal(Area maparea, Point pixelsize):\n This method must be overloaded in order to be able to use it&quot;));
+	}
+
+	/**
+	 * Overload this (don't call super()) or alternatively overload getMapInfoObjectInternal
+	 * @param center
+	 * @param scale
+	 * @param pixelsize
+	 * @return
+	 */
+	public MapInfoObject getMapInfoObject(CWPoint center, float scale, Point pixelsize) {
+		return getMapInfoObjectInternal(CenterScaleToArea(center, scale, pixelsize), pixelsize);
+	}
+
+	public String toString() {
+		return getName();
+	}
+}
+
+class WebMapService extends OnlineMapService {
+	String layersUrlPart; //
+	String versionUrlPart; // VERSION=1.1.0
+	String serviceTypeUrlPart; //&quot;SERVICE=WMS&quot;
+	int coordinateReferenceSystem[]; // WGS84: 4326, German GK: 31466 /
+	String coordinateReferenceSystemUrlPart[]; //&amp;SRS=EPSG:31466
+	String requestUrlPart;
+	String imageFormatUrlPart; // FORMAT=image/png
+	String stylesUrlPart; // STYLES=
+	double minscaleWMS;
+	double maxscaleWMS;
+
+	/**
+	 *
+	 * @param filename without file extension
+	 * @throws IOException
+	 * @throws IllegalArgumentException
+	 */
+	public WebMapService (String filename_) throws IOException, IllegalArgumentException{
+		FileInputStream in = new FileInputStream(filename_);
+		Properties wms = new Properties();
+		wms.load(in);
+		in.close();
+		String tmp = File.getFileExt(filename_);
+		this.filename = tmp.substring(0, tmp.lastIndexOf('.'));
+		name = wms.getProperty(&quot;Name&quot;, &quot;&quot;).trim();
+		if (name == &quot;&quot;) throw new IllegalArgumentException(MyLocale.getMsg(4812, &quot;WebMapService: property &gt;Name:&lt; missing in file:\n&quot;) + filename);
+		MainUrl = wms.getProperty(&quot;MainUrl&quot;, &quot;&quot;).trim();;
+		if (MainUrl == &quot;&quot;) throw new IllegalArgumentException(MyLocale.getMsg(4813, &quot;WebMapService: property &gt;MainUrl:&lt; missing in file:\n&quot;) + filename);
+		mapType = wms.getProperty(&quot;MapType&quot;, &quot;maptype_unknown&quot;).trim();
+		serviceTypeUrlPart = wms.getProperty(&quot;ServiceTypeUrlPart&quot;, &quot;SERVICE=WMS&quot;).trim();
+		layersUrlPart = wms.getProperty(&quot;LayersUrlPart&quot;, &quot;&quot;).trim();;
+		versionUrlPart = wms.getProperty(&quot;VersionUrlPart&quot;, &quot;&quot;).trim();;
+		tmp = wms.getProperty(&quot;CoordinateReferenceSystemCacheWolf&quot;, &quot;&quot;).trim();
+		if (tmp.equals(&quot;&quot;)) throw new IllegalArgumentException(MyLocale.getMsg(4814, &quot;WebMapService: no CoordinateReferenceSystemCacheWolf given&quot;));
+		String[] tmp2 = mString.split(tmp, ' ');
+		coordinateReferenceSystem = new int[tmp2.length];
+		for (int i = 0; i &lt; tmp2.length; i++) {
+			coordinateReferenceSystem[i] = Convert.toInt(tmp2[i].trim());
+			if (!TransformCoordinates.isSupported(coordinateReferenceSystem[i])) throw new IllegalArgumentException(MyLocale.getMsg(4815, &quot;Coordinate reference system not supported by CacheWolf:\n&quot;) + coordinateReferenceSystem[i]);
+		}
+		tmp = wms.getProperty(&quot;CoordinateReferenceSystemUrlPart&quot;, &quot;&quot;).trim();
+		if (tmp == &quot;&quot;) throw new IllegalArgumentException(MyLocale.getMsg(4816, &quot;WebMapService: property &gt;CoordinateReferenceSystemUrlPart:&lt; missing in file:\n&quot;) + filename);
+		tmp2 = mString.split(tmp, ' ');
+		if (tmp2.length != coordinateReferenceSystem.length) throw new IllegalArgumentException(MyLocale.getMsg(4817, &quot;number of strings in CoordinateReferenceSystemUrlPart (&quot;)+tmp2.length+MyLocale.getMsg(4818, &quot;) must match the number of codes in CoordinateReferenceSystemCacheWolf (&quot;)+coordinateReferenceSystem.length+MyLocale.getMsg(4819, &quot;) use normal space as separator&quot;));
+		coordinateReferenceSystemUrlPart = new String[tmp2.length];
+		for (int i = 0; i &lt; tmp2.length; i++) {
+			coordinateReferenceSystemUrlPart[i] = tmp2[i].trim();
+			if (coordinateReferenceSystemUrlPart[i] == &quot;&quot;) throw new IllegalArgumentException(MyLocale.getMsg(4820, &quot;WebMapService: property &gt;CoordinateReferenceSystemUrlPart:&lt; incorrect in file:\n&quot;) + filename);
+		}
+		requestUrlPart = wms.getProperty(&quot;RequestUrlPart&quot;, &quot;REQUEST=GetMap&quot;).trim();
+		imageFormatUrlPart = wms.getProperty(&quot;ImageFormatUrlPart&quot;, &quot;&quot;).trim();
+		stylesUrlPart = wms.getProperty(&quot;StylesUrlPart&quot;, &quot;&quot;).trim();
+		String topleftS = wms.getProperty(&quot;BoundingBoxTopLeftWGS84&quot;, &quot;&quot;).trim();
+		String buttomrightS = wms.getProperty(&quot;BoundingBoxButtomRightWGS84&quot;, &quot;&quot;).trim();
+		CWPoint topleft = new CWPoint(topleftS);
+		CWPoint buttomright = new CWPoint(buttomrightS);
+		if (!topleft.isValid()) topleft.set(90, -180);
+		if (!buttomright.isValid()) buttomright.set(-90, 180);
+		boundingBox = new Area (topleft, buttomright);
+		minscaleWMS = Common.parseDouble(wms.getProperty(&quot;MinScale&quot;, &quot;0&quot;).trim());
+		maxscaleWMS = Common.parseDouble(wms.getProperty(&quot;MaxScale&quot;, Convert.toString(java.lang.Double.MAX_VALUE)).trim());
+		minscale = minscaleWMS / Math.sqrt(2); // in WMS scale is measured diagonal while in CacheWolf it is measured vertical
+		maxscale = maxscaleWMS / Math.sqrt(2);
+		imageFileExt = wms.getProperty(&quot;ImageFileExtension&quot;, &quot;&quot;).trim();
+		if (imageFileExt == &quot;&quot;) throw new IllegalArgumentException(MyLocale.getMsg(4821, &quot;WebMapService: property &gt;ImageFileExtension:&lt; missing in file:\n&quot;) + filename);
+		recommendedScale = (float) Common.parseDouble(wms.getProperty(&quot;RecommendedScale&quot;, &quot;5&quot;).trim());
+	}
+
+	private static final int TOPLEFT_INDEX = 0;
+	private static final int BUTTOMRIGHT_INDEX = 1;
+	private static final int TOPRIGHT_INDEX = 2;
+	private static final int BUTTOMLEFT_INDEX = 3;
+	/**
+	 *
+	 * @param maparea
+	 * @return [0] = topleft, [1] = buttomright, [2] = topright, [3] = buttomleft
+	 */
+	private GkPoint[] getGkArea(Area maparea) {
+		GkPoint[] ret = new GkPoint[4];
+	//	CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.buttomright.lonDec);
+	//	CWPoint buttomleft = new CWPoint(maparea.buttomright.latDec, maparea.topleft.lonDec);
+		int crs = getCrs(maparea.getCenter());
+		int region = TransformCoordinates.getGkRegion(coordinateReferenceSystem[crs]);
+		ret[TOPLEFT_INDEX] = TransformCoordinates.wgs84ToGaussKrueger(maparea.topleft, coordinateReferenceSystem[crs]);
+		ret[BUTTOMRIGHT_INDEX] = TransformCoordinates.wgs84ToGaussKrueger(maparea.buttomright, coordinateReferenceSystem[crs]);
+		ret[TOPRIGHT_INDEX] = new GkPoint(ret[BUTTOMRIGHT_INDEX].getGkEasting(region), ret[TOPLEFT_INDEX].northing, ret[TOPLEFT_INDEX].stripewidth, ret[TOPLEFT_INDEX].lengthOfStripe0);
+		ret[BUTTOMLEFT_INDEX] = new GkPoint(ret[TOPLEFT_INDEX].getGkEasting(region), ret[BUTTOMRIGHT_INDEX].northing, ret[TOPLEFT_INDEX].stripewidth, ret[TOPLEFT_INDEX].lengthOfStripe0);
+		//Vm.debug(&quot;rot left direkt: &quot; + TransformCoordinates.GkToWgs84(ret[TOPLEFT_INDEX], region).getBearing(TransformCoordinates.GkToWgs84(ret[BUTTOMLEFT_INDEX], region)));
+		//Vm.debug(&quot;rot right direkt: &quot; + TransformCoordinates.GkToWgs84(ret[TOPRIGHT_INDEX], region).getBearing(TransformCoordinates.GkToWgs84(ret[BUTTOMRIGHT_INDEX], region)));
+		//ret[2] = TransformCoordinates.wgs84ToGermanGk(topright, coordinateReferenceSystem[crs]);
+		//ret[3] = TransformCoordinates.wgs84ToGermanGk(buttomleft, coordinateReferenceSystem[crs]);
+		return ret;
+	}
+	public Area CenterScaleToArea(CWPoint center, float scale, Point pixelsize) {
+		Area bbox = new Area();
+		int region = TransformCoordinates.getGkRegion(coordinateReferenceSystem[0]);
+		if (region &gt; 0 ) {
+			GkPoint cgk = TransformCoordinates.wgs84ToGaussKrueger(center, coordinateReferenceSystem[getCrs(center)]);
+			GkPoint tlgk = new GkPoint(cgk);
+			tlgk.shift(- pixelsize.x * scale / 2, 1);
+			tlgk.shift(pixelsize.y * scale / 2, 0);
+			GkPoint brgk = new GkPoint(cgk);
+			brgk.shift(pixelsize.x * scale / 2, 1);
+			brgk.shift(-pixelsize.y * scale / 2, 0);
+			bbox.topleft = TransformCoordinates.GkToWgs84(tlgk, region);
+			bbox.buttomright = TransformCoordinates.GkToWgs84(brgk, region);
+		} else {
+			switch (coordinateReferenceSystem[0]) {
+			case TransformCoordinates.EPSG_ETRS89:
+			case TransformCoordinates.EPSG_WGS84:
+				bbox.topleft.set(center);
+				bbox.topleft.shift(-pixelsize.x * scale / 2, 1);
+				bbox.topleft.shift(pixelsize.y * scale / 2, 0);
+				bbox.buttomright.set(center);
+				bbox.buttomright.shift(pixelsize.x * scale / 2, 1);
+				bbox.buttomright.shift(-pixelsize.y * scale / 2, 0);
+				break;
+			default: throw new IllegalArgumentException(&quot;CenterScaleToArea: epsg: &quot; + coordinateReferenceSystem[0] + &quot; not supported&quot;);
+			}
+		}
+		return bbox;
+	}
+
+	protected String getUrlForBoundingBoxInternal(Area maparea, Point pixelsize) {
+		if (!boundingBox.isOverlapping(maparea)) throw new IllegalArgumentException(MyLocale.getMsg(4822, &quot;area:&quot;)+&quot; &quot; + maparea.toString() + MyLocale.getMsg(4823, &quot; not covered by service:&quot;)+&quot; &quot; + name + MyLocale.getMsg(4824, &quot;, service area:&quot;)+&quot; &quot; + boundingBox.toString());
+		// <A HREF="http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS&amp;VERSION=1.1.0&amp;REQUEST=GetMap&amp;SRS=EPSG:31466&amp;BBOX=2577567.0149,5607721.7566,2578567.0077,5608721.7602&amp;WIDTH=500&amp;HEIGHT=500&amp;LAYERS=Raster:TK25_KMF:Farbkombination&amp;STYLES=&amp;FORMAT=image/png">http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS&amp;VERSION=1.1.0&amp;REQUEST=GetMap&amp;SRS=EPSG:31466&amp;BBOX=2577567.0149,5607721.7566,2578567.0077,5608721.7602&amp;WIDTH=500&amp;HEIGHT=500&amp;LAYERS=Raster:TK25_KMF:Farbkombination&amp;STYLES=&amp;FORMAT=image/png</A>
+		CWPoint buttomleft = new CWPoint (maparea.buttomright.latDec, maparea.topleft.lonDec);
+		CWPoint topright = new CWPoint (maparea.topleft.latDec, maparea.buttomright.lonDec);
+		double scaleh = maparea.buttomright.getDistance(buttomleft) * 1000 / pixelsize.x;
+		double scalev = maparea.topleft.getDistance(topright) * 1000 / pixelsize.y;
+		double scale = Math.sqrt(scaleh * scaleh + scalev * scalev); // meters per pixel measured diagonal
+		if ( scale &lt; minscaleWMS || scale &gt; maxscaleWMS ) throw new IllegalArgumentException(MyLocale.getMsg(4825, &quot;scale&quot;)+&quot; &quot; + scale / Math.sqrt(2)+ MyLocale.getMsg(4826, &quot; not supported by online map service, supported scale range:&quot;)+&quot; &quot; + minscale + &quot; - &quot; + maxscale + MyLocale.getMsg(4827, &quot; (measured in meters per pixel vertically)&quot;));
+		int crs = 0;
+		String bbox = &quot;BBOX=&quot;;
+		int region = TransformCoordinates.getGkRegion(coordinateReferenceSystem[0]);
+		if (region &gt; 0) {
+			crs = getCrs(maparea.getCenter());
+			GkPoint[] gk = getGkArea(maparea);
+			buttomleft = TransformCoordinates.GkToWgs84(gk[BUTTOMLEFT_INDEX], region);
+			topright = TransformCoordinates.GkToWgs84(gk[TOPRIGHT_INDEX], region);
+			bbox += TransformCoordinates.wgs84ToGaussKrueger(buttomleft, coordinateReferenceSystem[crs]).toString(2, &quot;&quot;, &quot;,&quot;, region);
+			bbox += &quot;,&quot; + TransformCoordinates.wgs84ToGaussKrueger(topright, coordinateReferenceSystem[crs]).toString(2, &quot;&quot;, &quot;,&quot;, region);
+		} else if (coordinateReferenceSystem[0] == TransformCoordinates.EPSG_WGS84)
+			bbox += buttomleft.toString(CWPoint.LON_LAT)  + &quot;,&quot; + topright.toString(CWPoint.LON_LAT);
+		else throw new IllegalArgumentException(MyLocale.getMsg(4828, &quot;Coordinate system not supported by cachewolf:&quot;)+&quot; &quot; + coordinateReferenceSystem.toString());
+		String ret = MainUrl + &quot;SERVICE=WMS&quot; + &quot;&amp;&quot;+ versionUrlPart + &quot;&amp;&quot; + requestUrlPart + &quot;&amp;&quot; +
+		coordinateReferenceSystemUrlPart[crs] + &quot;&amp;&quot; + bbox +
+		&quot;&amp;WIDTH=&quot; + pixelsize.x + &quot;&amp;HEIGHT=&quot; + pixelsize.y + &quot;&amp;&quot; +
+		layersUrlPart + &quot;&amp;&quot; + stylesUrlPart + &quot;&amp;&quot; + imageFormatUrlPart;
+		Vm.debug(ret);
+		return ret;
+	}
+
+	/**
+	 * This method gives the number in the arrays of coordinateReferenceSystems, which should be used
+	 * a) if only one is in the array 0 is returned
+	 * b) if there are more, find out which one matches the correct Gau&#223;-K&#252;ger stripe
+	 * Call this routine witch the center of the area (use Area.getcenter())
+	 * @param p Point for which the epsg code is searched for
+	 * @return
+	 */
+	private int getCrs(TrackPoint p) {
+		int crs = 0;
+		if (coordinateReferenceSystem.length &gt; 1) {
+			int region = TransformCoordinates.getGkRegion(coordinateReferenceSystem[0]);
+			GkPoint gkbl = TransformCoordinates.wgs84ToGk(p, region); // TODO: think / read about what to do if buttom left and top right ae not in the same Gau&#223;-Kr&#252;ger stripe?
+			crs = TransformCoordinates.whichEpsg(coordinateReferenceSystem, gkbl);
+			if (crs &lt; 0) throw new IllegalArgumentException(MyLocale.getMsg(4829, &quot;getUrlForBoundingBox: Point:&quot;)+&quot; &quot; + gkbl.toString() + MyLocale.getMsg(4830, &quot;no matching Gau&#223;-Kr&#252;ger-Stripe in the EPSG-code list in the .wms&quot;));
+		}
+		return crs;
+	}
+
+	protected MapInfoObject getMapInfoObjectInternal(Area maparea, Point pixelsize) {
+		if (!boundingBox.isOverlapping(maparea)) throw new IllegalArgumentException(MyLocale.getMsg(4822, &quot;area:&quot;)+&quot; &quot; + maparea.toString() + MyLocale.getMsg(4823, &quot; not covered by service:&quot;)+&quot; &quot; + name + MyLocale.getMsg(4824, &quot;, service area:&quot;)+&quot; &quot; + boundingBox.toString());
+		Vector georef = new Vector(4);
+
+		// calculate a rectangle in the according coordinate reference system
+		CWPoint buttomleft = new CWPoint (maparea.buttomright.latDec, maparea.topleft.lonDec);
+		CWPoint topright = new CWPoint (maparea.topleft.latDec, maparea.buttomright.lonDec);
+		CWPoint topleft = new CWPoint(maparea.topleft);
+		CWPoint buttomright = new CWPoint(maparea.buttomright);
+		double metersperpixalhorizontal = ( buttomright.getDistance(buttomleft) + topleft.getDistance(topright))/2 * 1000 / pixelsize.x;
+		double metersperpixalvertical = ( buttomright.getDistance(topright) + topleft.getDistance(buttomleft))/2 * 1000 / pixelsize.y;
+		int region = TransformCoordinates.getGkRegion(coordinateReferenceSystem[0]);
+		if ( region &gt; 0) {
+			GkPoint[] gk = getGkArea(maparea);
+			// bounding box in WMS is defined around the pixels, not exactly on the pixels --&gt; the bounding box must be reduced on all edges by half a pixel
+			gk[TOPLEFT_INDEX].shift(metersperpixalhorizontal / 2, 1);
+			gk[TOPLEFT_INDEX].shift(-metersperpixalvertical / 2, 0);
+			gk[BUTTOMRIGHT_INDEX].shift(-metersperpixalhorizontal / 2, 1);
+			gk[BUTTOMRIGHT_INDEX].shift(metersperpixalvertical / 2, 0);
+			gk[TOPRIGHT_INDEX].shift(-metersperpixalhorizontal / 2, 1);
+			gk[TOPRIGHT_INDEX].shift(-metersperpixalvertical / 2, 0);
+			gk[BUTTOMLEFT_INDEX].shift(metersperpixalhorizontal / 2, 1);
+			gk[BUTTOMLEFT_INDEX].shift(metersperpixalvertical / 2, 0);
+
+			Vm.debug(&quot;\n&quot; + maparea.topleft.toString(CWPoint.LAT_LON));
+			//Vm.debug(TransformCoordinates.germanGkToWgs84(TransformCoordinates.wgs84ToGermanGk(maparea.topleft)).toString(CWPoint.LAT_LON));
+			topleft.set(gk[TOPLEFT_INDEX].northing, gk[TOPLEFT_INDEX].getGkEasting(region));
+			buttomright.set(gk[BUTTOMRIGHT_INDEX].northing, gk[BUTTOMRIGHT_INDEX].getGkEasting(region));
+			topright.set(gk[TOPRIGHT_INDEX].northing, gk[TOPRIGHT_INDEX].getGkEasting(region));
+			buttomleft.set(gk[BUTTOMLEFT_INDEX].northing, gk[BUTTOMLEFT_INDEX].getGkEasting(region));
+		} else if (coordinateReferenceSystem[0] == TransformCoordinates.EPSG_WGS84) {
+			// bounding box in WMS is defined around the pixels, not exactly on the pixels --&gt; the bounding box must be reduced on all edges by half a pixel
+			topleft.shift(metersperpixalhorizontal / 2, 1);
+			topleft.shift(-metersperpixalvertical / 2, 0);
+			buttomright.shift(-metersperpixalhorizontal, 1);
+			buttomright.shift(metersperpixalhorizontal, 0);
+			topright = new CWPoint (topleft.latDec, buttomright.lonDec);
+			buttomleft = new CWPoint (buttomright.latDec, topleft.lonDec);
+		} else throw new IllegalArgumentException(MyLocale.getMsg(4831, &quot;getMapInfoObject: Coordinate system not supported by cachewolf:&quot;)+&quot; &quot; + coordinateReferenceSystem);
+		georef.add(new GCPoint(topleft, new Point(0, 0)));
+		georef.add(new GCPoint(buttomright, new Point(pixelsize.x, pixelsize.y)));
+		georef.add(new GCPoint(topright, new Point(pixelsize.x, 0)));
+		georef.add(new GCPoint(buttomleft, new Point(0, pixelsize.y)));
+
+		MapInfoObject ret = new MapInfoObject();
+		ret.evalGCP(georef, pixelsize.x, pixelsize.y, coordinateReferenceSystem[getCrs(maparea.getCenter())]);
+		//Vm.debug(&quot;\n nach kal&quot;);
+		//Vm.debug(&quot;fehler tl: &quot; + ret.calcLatLon(0, 0).getDistance(maparea.topleft)*1000);
+		//Vm.debug(&quot;fehler tl: &quot; + ret.calcLatLon(0, 0).getBearing(maparea.topleft));
+		//Vm.debug(&quot;fehler br: &quot; + ret.calcLatLon(pixelsize.x, pixelsize.y).getDistance(maparea.buttomright)*1000);
+		//Vm.debug(&quot;fehler br: &quot; + ret.calcLatLon(pixelsize.x, pixelsize.y).getBearing(maparea.buttomright));
+		//Vm.debug(ret.calcLatLon(pixelsize.x, pixelsize.y).toString(CWPoint.LAT_LON));
+		//Vm.debug(ret.calcLatLon(pixelsize.x, 0).toString(CWPoint.LAT_LON));
+		//Vm.debug(ret.calcLatLon(0, pixelsize.y).toString(CWPoint.LAT_LON));
+		return ret;
+	}
+}
+
+class ExpediaMapService extends OnlineMapService {
+	/*
+	 * information from: DownloadMouseMode.properties in project GPSylon ( in directory gpsylon_src-0.5.2\plugins\downloadmousemode\auxiliary\org\dinopolis\gpstool\plugin\downloadmousemode and DownloadMapCalculator.java in Dir gpsylon_src-0.5.2\plugins\downloadmousemode\src\org\dinopolis\gpstool\plugin\downloadmousemode
+	 * download.map.url.expedia_east=http\://www.expedia.com/pub/agent.dll?qscr=mrdt&amp;ID=3XNsF.&amp;CenP={0,number,#.########},{1,number,#.########}&amp;Lang=EUR0809&amp;Alti={2,number,#}&amp;Size={3,number,#},{4,number,#}&amp;Offs=0.000000,0.000000\&amp;BCheck=1
+	 * download.map.url.expedia_east.title=Url of Expedia Europe
+	 * download.map.scale_factor.expedia_east=3950
+	 */
+	final static float downloadMapScaleFactorExpedia_east = 3950;
+	final static float MAPBLAST_METERS_PER_PIXEL = 1.0f/2817.947378f;
+	final static float EXPEDIA_METERS_PER_PIXEL = downloadMapScaleFactorExpedia_east * MAPBLAST_METERS_PER_PIXEL;
+
+	public ExpediaMapService() {
+		name = &quot;Expedia&quot;;
+		filename = &quot;expedia&quot;;
+		MainUrl = &quot;<A HREF="Rhttp://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.">Rhttp://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.</A>&quot;; //&quot;<A HREF="Rhttp://">Rhttp://</A>&quot; forces doenloadUrl to retry the URL until it gets an http-redirect and then downloads from there
+		imageFileExt = &quot;.gif&quot;;
+		mapType = &quot;expedia&quot;;
+		recommendedScale = 5;
+		minscale = getMetersPerPixel(0.00000000000000000000001f);
+		maxscale = getMetersPerPixel((float)new CWPoint(0,0).getDistance(new CWPoint(0,180)) * 2 * 1000 / 1000); // whole world * 1000 because of km -&gt; m. /1000 because we have 1000x1000 Pixel usually
+		boundingBox = new Area(new CWPoint(90,-180), new CWPoint(-90,180));
+	}
+
+	public float getMetersPerPixel(float scale) {
+		return  EXPEDIA_METERS_PER_PIXEL * getZoomlevel(scale);
+	}
+
+	private int getZoomlevel(float scale) {
+		return (int)(Math.ceil(scale / EXPEDIA_METERS_PER_PIXEL));
+	}
+
+	public String getUrlForCenterScale(CWPoint center, float scale, Point pixelsize) {
+		int zoomlevel = getZoomlevel(scale);
+		String zone;
+		if (center.lonDec &lt;= -10) zone = &quot;USA0409&quot;;
+		else zone = &quot;EUR0809&quot;;
+		String quelle = MainUrl + &quot;&amp;CenP=&quot; + center.toString(CWPoint.LAT_LON);
+		quelle = quelle + &quot;&amp;Alti=&quot;+Convert.toString(zoomlevel)+&quot;&amp;Lang=&quot;+zone+&quot;&amp;Size=&quot;+Convert.toString(pixelsize.x)+&quot;,&quot;+Convert.toString(pixelsize.y)+&quot;&amp;Offs=0,0&amp;MapS=0&quot;; //&amp;Pins=|&quot; + latD.toString().replace(',', '.') + &quot;,&quot; + lonD.toString().replace(',', '.') + &quot;|5|&quot;;
+		return quelle;
+	}
+
+	public MapInfoObject getMapInfoObject(CWPoint center, float scale, Point pixelsize) {
+		float metersPerPixel2 = getMetersPerPixel(scale);
+		float metersPerPixel = metersPerPixel2;
+		MapInfoObject cal = new MapInfoObject(metersPerPixel, center,  pixelsize.x, pixelsize.y, name);
+		return cal;
+	}
+
+}

Added: experiments/EVE/src/cachewolf/navi/MapLoaderGui.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/MapLoaderGui.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/MapLoaderGui.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,338 @@
+package cachewolf.navi;
+
+import eve.io.File;
+import eve.sys.Convert;
+import eve.ui.*;
+import java.util.Vector;
+
+import cachewolf.CWPoint;
+import cachewolf.CacheHolder;
+import cachewolf.CoordsScreen;
+import cachewolf.Global;
+import cachewolf.InfoBox;
+import cachewolf.MyLocale;
+import cachewolf.Preferences;
+
+import eve.ui.event.ControlEvent;
+import eve.sys.Event;
+import eve.ui.event.DataChangeEvent;
+import eve.fx.gui.IKeys;
+
+/**
+ * @author pfeffer
+ * This Class is the Dialog for Download calibrated from expedia.com
+ * is called from 
+ *  * start offset for language file: 1800
+ */
+
+public class MapLoaderGui extends Form {
+	Button cancelB, okBtiles, okBPerCache, cancelBPerCache;
+	Preferences pref;
+	TabbedPanel mTab = new TabbedPanel();
+	CellPanel pnlTiles = new CellPanel();
+	CellPanel pnlPerCache = new CellPanel();
+
+	final String descString = MyLocale.getMsg(1802,&quot;Download georeferenced maps\n Select online service:&quot;);
+	Choice mapServiceChoice;
+	CheckBox forCachesChkBox = new CheckBox(MyLocale.getMsg(1803,&quot;for&quot;));
+	Choice forSelectedChkBox = new Choice(new String[] {MyLocale.getMsg(1804,&quot;all&quot;), MyLocale.getMsg(1805,&quot;selected&quot;)}, 0);
+	Choice forSelectedChkBoxPerCache = new Choice(new String[] {MyLocale.getMsg(1804,&quot;all&quot;), MyLocale.getMsg(1805,&quot;selected&quot;)}, 1);
+	Label cachesLbl = new Label(MyLocale.getMsg(1806,&quot;caches&quot;));
+	Input distanceInput;
+	Label distLbl;
+	Label km = new Label(&quot;km&quot;);
+	Label coosLbl;
+	Button coosBtn;
+	Label scaleLbl = new Label(MyLocale.getMsg(1807,&quot;Approx. m per pixel:&quot;));
+	Input scaleInput = new Input (&quot;3&quot;);
+	Input scaleInputPerCache = new Input (&quot;1&quot;);
+	Label overlappingLbl = new Label(MyLocale.getMsg(1808,&quot;overlapping in pixel:&quot;));
+	Input overlappingInput = new Input(&quot;100&quot;);
+	CheckBox overviewChkBox = new CheckBox(MyLocale.getMsg(1809,&quot;download an overview map&quot;));
+	CheckBox overviewChkBoxPerCache = new CheckBox(MyLocale.getMsg(1809,&quot;download an overview map&quot;));
+
+	MapLoader mapLoader;
+	String[] unsortedMapServices;
+	String[] sortedmapServices;
+	int[] sortingMapServices;
+	boolean[] inbound;
+	CWPoint center;
+	Vector cacheDB;
+	boolean perCache;
+	boolean onlySelected;
+	float radius;
+	float scale;
+	int overlapping;
+	boolean overviewmap;
+	//int numCaches;
+
+	public MapLoaderGui(Vector cacheDBi) {
+		super();
+		this.title = MyLocale.getMsg(1800, &quot;Download georeferenced maps&quot;); 
+		pref = Global.getPref(); // myPreferences sollte sp&#228;ter auch diese Einstellungen speichern
+		center = new CWPoint(pref.curCentrePt);
+		cacheDB = cacheDBi;
+		mapLoader = new MapLoader(File.getProgramDirectory()+&quot;/&quot;+&quot;webmapservices&quot;);
+
+		// sort the items in the list of services in a way that services which cover the current center point.
+		unsortedMapServices = mapLoader.getAvailableOnlineMapServices();
+		sortMapServices();
+		mapServiceChoice = new Choice(sortedmapServices, 0);
+		MessageArea desc = new MessageArea(descString); 
+		desc.modifyAll(TextPad.NotEditable | TextPad.DisplayOnly | TextPad.NoFocus, TextPad.TakesKeyFocus);
+		desc.borderStyle = TextPad.BDR_NOBORDER;
+		this.addLast(desc);
+		this.addLast(mapServiceChoice);
+		// tiles panel
+		pnlTiles.addNext(forCachesChkBox);
+		pnlTiles.addNext(forSelectedChkBox);
+		pnlTiles.addLast(cachesLbl);
+		pnlTiles.addNext(distLbl = new Label(MyLocale.getMsg(1810,&quot;Within a rectangle of:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		distanceInput = new Input();
+		int tmp = Convert.toInt((Global.getProfile().distOC));
+		tmp = java.lang.Math.max(tmp, Convert.toInt((Global.getProfile().distGC)));
+		distanceInput.setText(Convert.toString((tmp &gt; 0 ? tmp : 15)));
+		pnlTiles.addNext(distanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlTiles.addLast(km);
+		pnlTiles.addNext(coosLbl = new Label(MyLocale.getMsg(1811, &quot;around the centre:&quot;)+&quot; &quot;));
+		pnlTiles.addLast(coosBtn = new Button(center.toString()));
+		pnlTiles.addNext(scaleLbl);
+		mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
+		scaleInput.setText(Convert.toString(mapLoader.currentOnlineMapService.recommendedScale));
+		scaleInputPerCache.setText(Convert.toString(mapLoader.currentOnlineMapService.recommendedScale));
+		this.focusFirst();
+		pnlTiles.addLast(scaleInput);
+		//	pnlTiles.addLast(resolutionLbl);
+		pnlTiles.addNext(overlappingLbl);
+		pnlTiles.addLast(overlappingInput);
+		overviewChkBox.setState(true);
+		pnlTiles.addLast(overviewChkBox);
+		cancelB = new Button(MyLocale.getMsg(1604,&quot;Cancel&quot;));
+		cancelB.setHotKey(0, IKeys.ESCAPE);
+		pnlTiles.addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		okBtiles = new Button(MyLocale.getMsg(1605,&quot;OK&quot;));
+		okBtiles.setHotKey(0, IKeys.ACTION);
+		okBtiles.setHotKey(0, IKeys.ENTER);
+		pnlTiles.addLast(okBtiles,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		updateForCachesState();
+		mTab.addCard(pnlTiles, MyLocale.getMsg(1812, &quot;Tiles&quot;), MyLocale.getMsg(1812, &quot;Tiles&quot;));
+
+		// per cache panel
+		pnlPerCache.addNext(new Label(MyLocale.getMsg(1813, &quot;Download one map for&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addNext(forSelectedChkBoxPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addLast(new Label(MyLocale.getMsg(1806, &quot;caches&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addNext(new Label(MyLocale.getMsg(1807, &quot;Approx. m per pixel&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		pnlPerCache.addLast(scaleInputPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+
+		cancelBPerCache = new Button(MyLocale.getMsg(1604,&quot;Cancel&quot;));
+		cancelBPerCache.setHotKey(0, IKeys.ESCAPE);
+		pnlPerCache.addNext(cancelBPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+		okBPerCache = new Button(MyLocale.getMsg(1605,&quot;OK&quot;));
+		okBPerCache.setHotKey(0, IKeys.ACTION);
+		okBPerCache.setHotKey(0, IKeys.ENTER);
+		pnlPerCache.addLast(okBPerCache, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL));
+
+		mTab.addCard(pnlPerCache, MyLocale.getMsg(1814, &quot;Per cache&quot;), MyLocale.getMsg(1813, &quot;Per Cache&quot;));
+		this.addLast(mTab);
+	}
+
+	/**
+	 * sort the map services in order to have the services, which cover
+	 * the current center first in the list 
+	 * this sets inbound[], sortedMapServices[] and sortingmapServices[]
+	 *
+	 */	
+	private void sortMapServices() {
+		sortingMapServices = new int[unsortedMapServices.length];
+		inbound = new boolean[unsortedMapServices.length];
+		int j=0;
+		for (int i=0; i &lt; sortingMapServices.length; i++) {
+			if( ((OnlineMapService)mapLoader.onlineMapServices.get(i)).boundingBox.isInBound(center)) {
+				sortingMapServices[j] = i;
+				j++;
+				inbound[i] = true;
+			} else inbound[i] = false;
+		}
+		sortedmapServices = new String[unsortedMapServices.length];
+		for (int i=0; i &lt; sortedmapServices.length; i++) {
+			if (!inbound[i]) { 
+				sortingMapServices[j] = i;
+				j++;
+			}
+			sortedmapServices[i] = ((OnlineMapService)mapLoader.onlineMapServices.get(sortingMapServices[i])).getName();
+		}
+	}
+	
+	private int getSortedMapServiceIndex(int originalindex) {
+		for (int i = 0; i &lt; sortingMapServices.length; i++) {
+			if (sortingMapServices[i] == originalindex) return i;
+		}
+		throw new IllegalStateException(MyLocale.getMsg(1818, &quot;getSortedMapServiceIndex: index&quot;)+&quot; &quot; + originalindex + MyLocale.getMsg(1819, &quot;not found&quot;));
+	}
+
+	public String getMapsDir() {
+		String ret = Global.getPref().getMapDownloadSavePath(mapLoader.currentOnlineMapService.getMapType());
+		Global.getPref().saveCustomMapsPath(ret);
+		return ret;
+	}
+
+	public void downloadTiles() {
+		String mapsDir = getMapsDir();
+		if (mapsDir == null) return;
+		InfoBox progressBox = new InfoBox(MyLocale.getMsg(1815, &quot;Downloading georeferenced maps&quot;), MyLocale.getMsg(1816, &quot;Downloading georeferenced maps\n \n \n \n \n&quot;), InfoBox.PROGRESS_WITH_WARNINGS);
+		progressBox.setPreferredSize(220, 300);
+		progressBox.setInfoHeight(160);
+		progressBox.relayout(false);
+		progressBox.exec();
+		mapLoader.setProgressInfoBox(progressBox);
+		Form.showWait();
+		eve.fx.Point size = new eve.fx.Point(1000,1000); // Size of the downloaded maps
+		if (forCachesChkBox.getState() || perCache) {
+			Area surArea = Global.getProfile().getSourroundingArea(onlySelected); // calculate map boundaries from cacheDB
+			if (surArea == null) {
+				(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1817, &quot;No Caches are seleted&quot;), MessageBox.OKB)).execute();
+				Form.cancelWait();
+				progressBox.close(0);
+				return;
+			}
+			mapLoader.setTiles(surArea.topleft, surArea.buttomright, scale, size, overlapping );
+		} else 
+		{ // calculate from centre point an radius
+			mapLoader.setTiles(center, radius * 1000, scale, size, overlapping);
+		}
+		if (overviewmap) {
+			progressBox.setInfo(MyLocale.getMsg(1824, &quot;downloading overview map&quot;)); 
+			float scale = MapLoader.getScale(center, radius * 1000, size);
+			try {
+				mapLoader.downloadMap(center, scale, size, mapsDir);
+			} catch (Exception e) {
+				progressBox.addWarning(MyLocale.getMsg(1825, &quot;Overview map: Ignoring error:&quot;)+&quot; &quot; + e.getMessage()+&quot;\n&quot;);
+			}
+		}
+		if (!perCache){  // download tiles
+			mapLoader.setProgressInfoBox(progressBox);
+			mapLoader.downlaodTiles(mapsDir);
+		} else { // per cache
+			CacheHolder ch; 
+			CWPoint tmpca = new CWPoint();
+			int numdownloaded = 0;
+			Global.getProfile().getSourroundingArea(onlySelected); // calculate numCachesInArea
+			int numCaches = Global.getProfile().numCachesInArea;
+			for (int i=cacheDB.size()-1; i &gt;= 0; i--) {
+				ch = (CacheHolder) cacheDB.get(i);
+				if (!this.onlySelected || ch.is_Checked) {
+					if (ch.pos == null) { // this can not happen
+						tmpca.set(ch.latLon);
+						ch.pos = new CWPoint(tmpca);
+					}
+					if (ch.pos.isValid() &amp;&amp; ch.pos.latDec != 0 &amp;&amp; ch.pos.lonDec != 0) { // TODO != 0 sollte verschwinden, sobald das handling von nicht gesetzten Koos &#252;berall korrekt ist
+						numdownloaded++;
+						progressBox.setInfo(MyLocale.getMsg(1820, &quot;Downloading map '&quot;)+mapLoader.currentOnlineMapService.getName()+&quot;'\n&quot;+numdownloaded+&quot; / &quot;+numCaches+MyLocale.getMsg(1821, &quot;\n for cache:\n&quot;)+ch.cacheName);
+						try {
+							mapLoader.downloadMap(ch.pos, scale, size, mapsDir);
+						} catch (Exception e) {
+							progressBox.addWarning(MyLocale.getMsg(1822, &quot;Cache:&quot;)+&quot; &quot; + ch.cacheName + &quot;(&quot; + ch.wayPoint + &quot;) &quot;+MyLocale.getMsg(1823, &quot;Ignoring error:&quot;)+&quot; &quot; + e.getMessage()+&quot;\n&quot;);
+						}
+					}
+				}
+			}
+		}
+		Form.cancelWait();
+		progressBox.addWarning(MyLocale.getMsg(1826, &quot;Finished downloading and calibration of maps&quot;));
+		progressBox.addOkButton();
+		progressBox.waitUntilClosed();
+		mapLoader.setProgressInfoBox(null);
+		//progressBox.close(0);
+		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false; 
+		//	(new MessageBox(&quot;Download maps&quot;, &quot;Downloaded and calibrated the maps successfully&quot;, MessageBox.OKB)).execute();
+	}
+
+
+	private void updateForCachesState() {
+		int a, b;
+		if (forCachesChkBox.getState()) {
+			// create map rectangle from caches
+			a = 0;
+			b = Control.Disabled;
+		}
+		else { // use centre and distance input
+			a = Control.Disabled;
+			b = 0;
+		}
+		forSelectedChkBox.modify(a, b);
+		cachesLbl.modify(a, b);
+		distanceInput.modify(b, a);
+		distLbl.modify(b, a);
+		coosBtn.modify(b, a);
+		coosLbl.modify(b, a);
+		km.modify(b,a);
+		repaintNow();
+
+	}
+
+	public void onEvent(Event ev){
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (ev.target == cancelB || ev.target == cancelBPerCache){
+				this.close(Form.IDCANCEL);
+			}
+			if (ev.target == okBtiles || ev.target == okBPerCache){
+				mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
+				if (ev.target == okBtiles) { // get tiles
+					perCache = false;
+					if (forSelectedChkBox.getSelectedItem().toString().equalsIgnoreCase(MyLocale.getMsg(1804, &quot;all&quot;))) onlySelected = false;
+					else onlySelected = true;
+					overviewmap = overviewChkBox.getState();
+					radius = (float)cachewolf.utils.Common.parseDouble(distanceInput.getText());
+					scale = (float)cachewolf.utils.Common.parseDouble(scaleInput.getText());
+					overlapping = Convert.toInt(overlappingInput.getText());
+					if (!forCachesChkBox.getState()) {
+						if (radius &lt;= 0) { 
+							(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1827, &quot;'radius' must be graeter than 0&quot;), MessageBox.OKB)).execute();
+							return;
+						}
+						if (overlapping &lt; 0) { 
+							(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1828, &quot;'overlapping' must be greater or equal 0&quot;), MessageBox.OKB)).execute();
+							return;
+						}
+						if (!center.isValid() &amp;&amp; !forCachesChkBox.getState()) {
+							(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1829, &quot;Please enter the 'centre' around which the maps shall be downloaded&quot;), MessageBox.OKB)).execute();
+							return;
+						}
+					}
+				} else { // per cache
+					perCache = true;
+					if (forSelectedChkBoxPerCache.getSelectedItem().toString().equalsIgnoreCase(MyLocale.getMsg(1804, &quot;all&quot;))) onlySelected = false;
+					else onlySelected = true;
+					overviewmap = overviewChkBoxPerCache.getState();
+					scale = Convert.toFloat(scaleInputPerCache.getText());
+				}
+				if (scale &lt; mapLoader.currentOnlineMapService.minscale || scale &gt; mapLoader.currentOnlineMapService.maxscale) {
+					(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1830, &quot;The selected online map service provides map in the scale from&quot;)+&quot; &quot; + mapLoader.currentOnlineMapService.minscale + MyLocale.getMsg(1831, &quot; to&quot;)+&quot; &quot;+ mapLoader.currentOnlineMapService.maxscale +MyLocale.getMsg(1832, &quot;\n please adjust 'Approx. meter pro pixel' accordingly&quot;), MessageBox.OKB)).execute();
+					return;
+				}
+				this.close(Form.IDOK); 
+				this.downloadTiles();
+			}
+			if (ev.target == coosBtn) {
+				CoordsScreen cs = new CoordsScreen();
+				cs.setFields(center, CWPoint.CW);
+				if (cs.execute() != CoordsScreen.IDCANCEL) {
+					center = cs.getCoords();
+					coosBtn.setText(center.toString());
+					int tmp = sortingMapServices[mapServiceChoice.selectedIndex];
+					sortMapServices();
+					mapServiceChoice.set(sortedmapServices, (!inbound[tmp] ? 0 : getSortedMapServiceIndex((tmp))));
+				}
+			}
+			if (ev.target == forCachesChkBox) {
+				updateForCachesState();
+			}
+		} // end of &quot;if controllEvent...&quot;
+		if (ev instanceof DataChangeEvent &amp;&amp; ev.target == mapServiceChoice) {
+			mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
+			scaleInput.setText(Convert.toString(mapLoader.currentOnlineMapService.recommendedScale));
+			scaleInputPerCache.setText(Convert.toString(mapLoader.currentOnlineMapService.recommendedScale));
+		}
+		super.onEvent(ev);
+	}
+}

Added: experiments/EVE/src/cachewolf/navi/MapSymbol.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/MapSymbol.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/MapSymbol.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,27 @@
+package cachewolf.navi;
+
+import cachewolf.CWPoint;
+import eve.fx.*;
+
+public class MapSymbol extends MapImage { 
+	Object mapObject;
+	String name;
+	String filename;
+	CWPoint where;
+	
+	public MapSymbol(String namei, String filenamei, CWPoint where_) {
+		name = namei;
+		filename = filenamei;
+		where = where_;
+	}
+	public MapSymbol(String namei, Object mapObjecti, Picture fromIm, CWPoint where_) {
+		name = namei;
+		where = where_;
+		mapObject = mapObjecti;
+		setImage(fromIm);
+	}
+	public void loadImage(){
+		setImage((new Picture(filename)).toImage(0),null); //freeSource();
+		//properties = AniImage.AlwaysOnTop;
+	}
+}

Added: experiments/EVE/src/cachewolf/navi/MapsList.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/MapsList.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/MapsList.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,527 @@
+package cachewolf.navi;
+
+import eve.io.File;
+import java.io.IOException;
+import eve.sys.Time;
+import eve.ui.MessageBox;
+import java.util.Vector;
+
+import cachewolf.CWPoint;
+import cachewolf.Global;
+import cachewolf.InfoBox;
+import cachewolf.MyLocale;
+import cachewolf.utils.Common;
+
+import eve.fx.*;
+import eve.ui.Form;
+import eve.ui.FormBase;
+
+/**
+ * class to handle a list of maps
+ * it loads the list, finds the best map for a given location,
+ * says if a map is available for a given lat lon at a given scale
+ * start offset for language file: 4700
+ *
+ */
+public class MapsList extends Vector {
+	static final long serialVersionUID=0; // For compiler only
+	public static final float scaleTolerance = 1.15f; // absolute deviations from this factor are seen to have the same scale
+
+	/**
+	 * loads alle the maps in mapsPath in all subDirs but not recursive, only one level 
+	 * @param mapsPath
+	 */
+	public MapsList(String mapsPath) {
+		super(); // forget already loaded maps
+		//if (mmp.mapImage != null) 
+		String dateien[];
+		File files = new File(mapsPath);
+		String rawFileName;
+		String[] dirstmp = files.list(null, File.LIST_DIRECTORIES_ONLY);
+		Vector dirs;
+		if (dirstmp != null) {
+			dirs = new Vector();
+			for (int i=0; i&lt;dirstmp.length; i++)
+				dirs.add(dirstmp[i]);
+		} else dirs = new Vector();
+		dirs.add(&quot;.&quot;); // include the mapsPath itself
+		MapListEntry tempMIO;
+		MessageBox f = null; 
+		// sort(new StandardComparer(), false);
+
+		
+		for (int j = 0; j &lt; dirs.size(); j++) {
+			files = new File(mapsPath+&quot;/&quot;+dirs.get(j));
+			//eve.sys.Vm.debug(&quot;mapd-Dirs:&quot;+files);
+			
+			//add subdirectories
+			if (!dirs.get(j).equals(&quot;.&quot;)) {
+				dirstmp = files.list(null, File.LIST_DIRECTORIES_ONLY);
+				if (dirstmp != null) {
+					for (int subDir = 0; subDir &lt; dirstmp.length; subDir++) {
+						dirs.add(dirs.get(j)+&quot;/&quot;+dirstmp[subDir]);
+					}
+				}
+			}
+			dateien = files.list(&quot;*.wfl&quot;, File.LIST_FILES_ONLY); //&quot;*.xyz&quot; doesn't work on some systems -&gt; use FileBugFix
+			if (dateien == null) continue;
+			for(int i = 0; i &lt; dateien.length;i++){
+				// if (!dateien[i].endsWith(&quot;.wfl&quot;)) continue;
+				rawFileName = dateien[i].substring(0, dateien[i].lastIndexOf(&quot;.&quot;));
+				try {
+					if (dirs.get(j).equals(&quot;.&quot;)) // the notation dir/./filename doesn't work on all platforms anyhow
+						tempMIO = new MapListEntry(mapsPath+&quot;/&quot;, rawFileName);
+					else tempMIO = new MapListEntry(mapsPath+&quot;/&quot;+dirs.get(j)+&quot;/&quot;, rawFileName);
+					if (tempMIO.sortEntryBBox != null) add(tempMIO);
+					//eve.sys.Vm.debug(tempMIO.getEasyFindString() + tempMIO.mapName);
+				}catch(Exception ex){ // TODO exception ist, glaub ich evtl &#252;berfl&#252;ssig 
+					if (f == null) (f=new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(4700, &quot;Ignoring error while \n reading calibration file \n&quot;)+ex.toString(), MessageBox.OKB)).exec();
+				} /* catch(ArithmeticException ex){ // affine contain not allowed values 
+					if (f == null) (f=new MessageBox(&quot;Warning&quot;, &quot;Ignoring error while \n reading calibration file \n&quot;+ex.toString(), MessageBox.OKB)).exec();
+				} */
+			}
+		}
+		if (MapListEntry.rename == 1) MapListEntry.loadingFinished();
+	}
+
+	public void addEmptyMaps(double lat) {
+		MapListEntry tempMIO; 
+		tempMIO = new MapListEntry(1.0, lat);
+		add(tempMIO);
+		tempMIO = new MapListEntry(5.0, lat); // this one ( the 4th last) is automatically used when no real map is available, see MovingMap.setBestMap 
+		add(tempMIO);
+		tempMIO = new MapListEntry(50.0, lat);
+		add(tempMIO);
+		tempMIO = new MapListEntry(250.0, lat);
+		add(tempMIO);
+		tempMIO = new MapListEntry(1000.0, lat);
+		add(tempMIO);
+	}
+     
+	/* diese Routine wird gegenw&#228;rtig f&#252;r 3 ZWecke verwendet:
+	 * a) normal - keep given resolution --&gt; L&#246;sung: &#252;bergebene scale nutzen f&#252;r screen
+	 * b) highest res: Ziel: Karte mit h&#246;chster Aufl&#246;sung, die im screen ist und m&#246;glichst nah an lat/lon -&gt; ich muss aufl&#246;sung noch in Dateinamen schreiben
+	 * c) gegenteil von b)
+	 */
+	/**
+	 * find the best map for lat/lon in the list of maps
+	 * @param lat a point to be inside the map
+	 * @param lon
+	 * @param screen: width, height of the screen. The map must overlap the screen. xy: where is lat/lon on screen
+	 * @param scale scale wanted
+	 * currently the best map is the one, whose center is nearest to lat/lon
+	 * and in Area with its scale nearest to scale.
+	 * it always returns a map (if the list is not empty) as long as it overlaps the screen
+	 * @param forceScale: when true, return null if no map with specified scale could be found
+	 */
+	public MapInfoObject getBestMap(CWPoint ll, Rect screen, float scale, boolean forceScale) {
+		if (size() == 0) return null;
+		long start = new Time().getTime();
+		InfoBox progressBox = null;
+		boolean showprogress = false;
+		String cmp = &quot;FF1&quot;+Area.getEasyFindString(ll, 30);
+		MapListEntry ml;
+		MapInfoObject mi;
+		MapInfoObject bestMap = null; // = (MapInfoObject)get(0);
+		double minDistLat = 1000000000000000000000000000000000000000000000.0;
+		double minDistLon = 1000000000000000000000000000000000000000000000.0;
+		boolean latNearer, lonNearer;
+		boolean better = false;
+		Area screenArea = null; // getAreaForScreen(screen, lat, lon, bestMap.scale, bestMap);
+		float lastscale = -1;
+		int testkw = 0;
+		for (int i=size()-1; i &gt;= 0 ;i--) {
+			if (!showprogress &amp;&amp; ((i &amp; 31) == 0) &amp;&amp; (new Time().getTime()-start  &gt; 100) ) { // reason for (i &amp; 7 == 0): test time only after i is incremented 15 times
+				showprogress = true;      
+				progressBox = new InfoBox(MyLocale.getMsg(327,&quot;Info&quot;), MyLocale.getMsg(4701,&quot;Searching for best map&quot;));
+				progressBox.exec(); 
+				progressBox.getWindow().waitUntilPainted(100);
+				Form.showWait();
+			}
+			ml = (MapListEntry)get(i);
+			try {
+				if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
+				mi = ml.getMap(); 
+				testkw++;
+			} catch (IOException ex) {continue; } // could not read .wfl-file
+			better = false;
+//			mi = (MapInfoObject)get(i);
+			if (screenArea == null || !scaleEquals(lastscale, mi) ) {
+				screenArea = getAreaForScreen(screen, ll, mi.scale, mi);
+				lastscale = mi.scale;
+			}
+			if (screenArea.isOverlapping(mi) ) { // is on screen
+				if (!forceScale || (forceScale &amp;&amp; !scaleEquals(scale, mi))) { // different scale?
+					if (!forceScale &amp;&amp; (mi.isInBound(ll) &amp;&amp; (bestMap == null || scaleNearer(mi.scale, bestMap.scale, scale) || !bestMap.isInBound(ll)))) 
+						better = true; // inbound and resolution nearer at wanted resolution or old one is on screen but lat/long not inbound-&gt; better
+					else {
+						if ( bestMap == null || scaleNearerOrEuqal(mi.scale, bestMap.scale, scale)) {
+							latNearer = java.lang.Math.abs(ll.latDec - mi.center.latDec)/mi.sizeKm &lt; minDistLat ;
+							lonNearer = java.lang.Math.abs(ll.lonDec - mi.center.lonDec)/mi.sizeKm &lt; minDistLon;
+							if ( latNearer &amp;&amp; lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
+							else {
+								if ( (latNearer || lonNearer )) { 
+									if (bestMap == null || mi.center.getDistanceRad(ll) &lt; bestMap.center.getDistanceRad(ll) ) better = true;
+								}
+							}
+						}
+					}
+					if (better) {
+						minDistLat = java.lang.Math.abs(ll.latDec - mi.center.latDec)/mi.sizeKm;
+						minDistLon = java.lang.Math.abs(ll.lonDec - mi.center.lonDec)/mi.sizeKm;
+						bestMap = mi;
+						// Vm.debug(&quot;better&quot;+ i);
+					}
+				}
+			}
+		}
+		if (progressBox != null) {
+			progressBox.close(0);
+			Form.cancelWait();
+		}
+		if (bestMap == null) return null;
+		return new MapInfoObject(bestMap); // return a copy of the MapInfoObject so that zooming won't change the MapInfoObject in the list 
+	}
+	/*
+	public MapInfoObject getBestMapNotStrictSciale(double lat, double lon, Area screen, float scale) {
+		MapInfoObject ret = getBestMap(lat, lon, screen, scale, true);
+		if (ret == null) ret = getBestMap(lat, lon, screen, scale, false);
+		return ret;
+	}
+	 */ 
+	/**
+	 * @return a map which includs topleft and bottomright, 
+	 * if no map includes both it returns null
+	 * @param if more than one map includes topleft and bottomright than the one will
+	 * be returned which has its center nearest to topleft. If you have gps-pos and goto-pos
+	 * as topleft and buttomright use gps as topleft.
+	 * if topleft is really topleft or if it is buttomright is not relevant.  
+	 */
+
+	public MapInfoObject getMapForArea(CWPoint topleft, CWPoint bottomright){
+		long start = new Time().getTime();
+		InfoBox progressBox = null;
+		boolean showprogress = false;
+		MapListEntry ml;
+		MapInfoObject mi;
+		String cmp = &quot;FF1&quot;+(new Area(topleft, bottomright)).getEasyFindString();
+		MapInfoObject fittingmap = null;
+		boolean latNearer, lonNearer;
+		boolean better;
+		double minDistLat = 10000000000000000000000.0;
+		double minDistLon = 10000000000000000000000.0;
+		for (int i=size() -1; i&gt;=0 ;i--) {
+			if (!showprogress &amp;&amp; ((i &amp; 31) == 0) &amp;&amp; (new Time().getTime()-start  &gt; 100) ) { // reason for (i &amp; 7 == 0): test time only after i is incremented 15 times
+				showprogress = true;      
+				progressBox = new InfoBox(MyLocale.getMsg(327,&quot;Info&quot;), MyLocale.getMsg(4701,&quot;Searching for best map&quot;));
+				progressBox.exec(); 
+				progressBox.getWindow().waitUntilPainted(100);
+				Form.showWait();
+			}
+			ml = (MapListEntry)get(i);
+			try {
+				if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
+				mi = ml.getMap();
+			} catch (IOException ex) {continue; } // could not read .wfl-file
+			better = false;
+			if (mi.isInBound(topleft) &amp;&amp; mi.isInBound(bottomright)) { // both points are inside the map
+				if (fittingmap == null || fittingmap.scale &gt; mi.scale * scaleTolerance) {
+					better = true; // mi map has a better (lower) scale than the last knwon good map
+				} else {
+					if (fittingmap != null &amp;&amp; scaleEquals(mi, fittingmap)) { // same scale as bestmap till now -&gt; test if its center is nearer to the gps-point = topleft
+						latNearer = java.lang.Math.abs(topleft.latDec- mi.center.latDec)/mi.sizeKm &lt; minDistLat ;
+						lonNearer = java.lang.Math.abs(topleft.lonDec - mi.center.lonDec)/mi.sizeKm &lt; minDistLon;
+						if ( latNearer &amp;&amp; lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
+						else {
+							if ( (latNearer || lonNearer )) { 
+								if (mi.center.getDistanceRad(topleft) &lt; fittingmap.center.getDistanceRad(topleft) ) better = true;
+							}
+						}
+
+					}
+				}
+				if (better) {
+					fittingmap = mi;
+					minDistLat = java.lang.Math.abs(topleft.latDec - mi.center.latDec);
+					minDistLon = java.lang.Math.abs(topleft.lonDec - mi.center.lonDec);
+				}
+			}
+		} // for
+		if (progressBox != null) {
+			progressBox.close(0);
+			Form.cancelWait();
+		}
+		if (fittingmap == null) return null;
+		return new MapInfoObject(fittingmap);
+	}
+
+	/**
+	 * 
+	 * @param lat a point to be inside the map
+	 * @param lon
+	 * @param screen: width, height of the screen. The map must overlap the screen. xy: where is lat/lon on screen
+	 * @param curScale reference scale to be changed
+	 * @param moreDetails true: find map with more details == higher resolustion = lower scale / false find map with less details = better overview
+	 * @return
+	 */
+	public MapInfoObject getMapChangeResolution(CWPoint ll, Rect screen, float curScale, boolean moreDetails){
+		if (size() == 0) return null;
+		long start = new Time().getTime();
+		InfoBox progressBox = null;
+		boolean showprogress = false;
+		MapListEntry ml;
+		MapInfoObject mi;
+		MapInfoObject bestMap = null; // = (MapInfoObject)get(0);
+		double minDistLat = 1000000000000000000000000000000000000000000000.0;
+		double minDistLon = 1000000000000000000000000000000000000000000000.0;
+		boolean latNearer, lonNearer;
+		boolean better = false;
+		Area screenArea = null; // getAreaForScreen(screen, lat, lon, bestMap.scale, bestMap);
+		float lastscale = -1;
+		String cmp = &quot;FF1&quot;+Area.getEasyFindString(ll, 30);
+		for (int i=size()-1; i &gt;= 0 ;i--) { 
+			if (!showprogress &amp;&amp; ((i &amp; 31) == 0) &amp;&amp; (new Time().getTime()-start  &gt; 100) ) { // reason for (i &amp; 7 == 0): test time only after i is incremented 15 times
+				showprogress = true;      
+				progressBox = new InfoBox(MyLocale.getMsg(327,&quot;Info&quot;), MyLocale.getMsg(4701,&quot;Searching for best map&quot;));
+				progressBox.exec(); 
+				progressBox.getWindow().waitUntilPainted(100);
+				Form.showWait();
+			}
+			better = false;
+			ml = (MapListEntry)get(i);
+			try {
+				if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
+				mi = ml.getMap();
+			} catch (IOException ex) {continue; } // could not read .wfl-file
+			if (mi.fileNameWFL == &quot;&quot;) continue; // exclude &quot;maps&quot; without image // TODO make this a boolean in MapInfoObject
+			if (screenArea == null || !scaleEquals(lastscale, mi)) {
+				screenArea = getAreaForScreen(screen, ll, mi.scale, mi);
+				lastscale = mi.scale;
+			}
+			if (screenArea.isOverlapping(mi)) { // is on screen
+				if (bestMap == null || !scaleEquals(mi, bestMap)) { // different scale than known bestMap?
+					if (mi.isInBound(ll) &amp;&amp; (      // more details wanted and this map has more details?                                // less details than bestmap
+							(moreDetails &amp;&amp; (curScale &gt; mi.scale * scaleTolerance) &amp;&amp; (bestMap == null || mi.scale &gt; bestMap.scale * scaleTolerance ) ) // higher resolution wanted and mi has higher res and a lower res than bestmap, because we dont want to overjump one resolution step
+							|| (!moreDetails &amp;&amp; (curScale *  scaleTolerance &lt; mi.scale) &amp;&amp; (bestMap == null || mi.scale * scaleTolerance &lt; bestMap.scale) ) // lower resolution wanted and mi has lower res and a higher res than bestmap, because we dont want to overjump one resolution step
+					) )	better = true;	// inbound and higher resolution if higher res wanted -&gt; better
+				} else { // same scale as bestmap -&gt; look if naerer 
+					latNearer = java.lang.Math.abs(ll.latDec - mi.center.latDec)/mi.sizeKm &lt; minDistLat ;
+					lonNearer = java.lang.Math.abs(ll.lonDec - mi.center.lonDec)/mi.sizeKm &lt; minDistLon;
+					if ( latNearer &amp;&amp; lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
+					else {
+						if ( (latNearer || lonNearer )) { 
+							if (bestMap == null || mi.center.getDistanceRad(ll) &lt; bestMap.center.getDistanceRad(ll) ) better = true;
+						}
+					}
+				} // same scale
+				if (better) {
+					minDistLat = java.lang.Math.abs(ll.latDec - mi.center.latDec)/mi.sizeKm;
+					minDistLon = java.lang.Math.abs(ll.lonDec - mi.center.lonDec)/mi.sizeKm;
+					bestMap = mi;
+					// Vm.debug(&quot;better&quot;+ i);
+				}
+			}
+		}
+		if (progressBox != null) {
+			progressBox.close(0);
+			Form.cancelWait();
+		}
+		if (bestMap == null) return null;
+		return new MapInfoObject(bestMap);
+	}
+	/**
+	 * returns an area in lat/lon of the screen
+	 * @param a screen width / height and position of lat/lon on the screen
+	 * @param lat a (reference) point on the screen
+	 * @param lon
+	 * @param scale scale (meters per pixel) of the map for which the screen edges are wanted
+	 * @param map map for which the screen edges are wanted
+	 * @return
+	 */
+	private Area getAreaForScreen(Rect a, CWPoint ll, float scale, MapInfoObject map) {
+		Area ret = null;
+		Point xy = map.calcMapXY(ll);
+		Point topleft = new Point(xy.x - a.x, xy.y - a.y);
+		ret = new Area(map.calcLatLon(topleft), map.calcLatLon(topleft.x+a.width, topleft.y+a.height));
+		return ret; 
+	}
+	public static boolean scaleEquals(MapInfoObject a, MapInfoObject b) {
+		//return java.lang.Math.abs(a.scale - b.scale) &lt; scaleTolerance;
+		if (a.scale &gt; b.scale) 
+			return a.scale / b.scale &lt; scaleTolerance; 
+		return b.scale / a.scale &lt; scaleTolerance;
+	}
+	public static boolean scaleEquals(float s, MapInfoObject b) {
+		//return java.lang.Math.abs(s - b.scale) &lt; scaleTolerance;
+		if (s &gt; b.scale) 
+			return s / b.scale &lt; scaleTolerance;
+		return b.scale / s &lt; scaleTolerance;
+	}
+
+	/**
+	 * 
+	 * @param test
+	 * @param old
+	 * @param wanted
+	 * @return true if test is nearer to wanted than old, false if the change in the scale is lower than scaleTolerance
+	 */
+	public static boolean scaleNearer(float test, float old, float wanted) {
+		float testa, wanta, wantb, olda;
+		if (test &gt; wanted) { // ensure that first term is greater than 1
+			testa = test;
+			wanta = wanted;
+		} else {
+			testa = wanted;
+			wanta = test;
+		}
+		if (old &gt; wanted) { // ensure that second term is greater than 1 
+			olda = old;
+			wantb = wanted;
+		} else {
+			olda = wanted;
+			wantb = old;
+		}
+		return testa/wanta * scaleTolerance &lt; olda/wantb; 
+	}
+
+	public static boolean scaleNearerOrEuqal(float test, float old, float wanted) {
+		float testa, wanta, wantb, olda;
+		if (test &gt; wanted) { // ensure that first term is greater than 1
+			testa = test;
+			wanta = wanted;
+		} else {
+			testa = wanted;
+			wanta = test;
+		}
+		if (old &gt; wanted) { // ensure that second term is greater than 1 
+			olda = old;
+			wantb = wanted;
+		} else {
+			olda = wanted;
+			wantb = old;
+		}
+		return testa/wanta &lt; olda/wantb * scaleTolerance ; 
+	}
+	
+	/* may be the following code is used same time later to further enhance the speed of finding the best map
+	public int getQuickMap(String search){
+		boolean found = false; // TODO unfertig
+		int upperbound = 0;
+		int downbound = size();
+		int test;
+		while (!found) {
+			test = (upperbound + downbound)/2;
+			if ( ((Comparable)(get(test))).compareTo(search) &lt; 0) downbound = test;
+			else upperbound = test;
+		}
+		return 1;
+	}
+*/
+	/** for determining if a new map should be downloaded
+	public boolean isInAmap(CWPoint topleft, CWPoint buttomright) {
+		if (!latRangeList.isInRange(topleft.latDec) || !latRangeList.isInRange(buttomright.latDec)) ||
+			!lonRangeList.inInRange(topleft.lonDec) || !lonRangeList.isInRange(buttomright.lonDec)
+			return false;
+	}
+	 */
+}
+
+class MapListEntry /*implements Comparable */ {
+	String sortEntryBBox;
+	//String sortEntry;
+	String filename;
+	String path;
+	MapInfoObject map;
+	static int rename = 0;
+	static int renameCounter = 0;
+	static InfoBox renameProgressInfoB = null;
+
+	public MapListEntry (String pathi, String filenamei) {
+		filename = new String(filenamei);
+		path = new String(pathi);
+		sortEntryBBox = null;
+		map = null;
+		/*
+		try {map = new MapInfoObject(path, filename); } catch (Exception e) {
+			// TODO: handle exception
+		}
+		
+		eve.sys.Vm.debug(&quot;centerID: &quot;+map.getCenterID());
+		eve.sys.Vm.debug(&quot;PxID: &quot;+map.getPxSizeID());
+		eve.sys.Vm.debug(&quot;scaleID: &quot;+map.getScaleID()+&quot;scale: &quot;+map.scale);
+		*/
+		try {
+			if (filenamei.startsWith(&quot;FF1&quot;)) sortEntryBBox = filenamei.substring(0, filenamei.indexOf(&quot;E-&quot;));
+		} catch (IndexOutOfBoundsException ex) { }
+		if (sortEntryBBox == null ) { //|| sortEntryScaleCenterPx.length() &lt; 16) {
+			try {
+				map = new MapInfoObject(path, filename);
+				sortEntryBBox = &quot;FF1&quot;+map.getEasyFindString();
+				eve.sys.Vm.debug(sortEntryBBox + &quot;: &quot;+filename);
+				if (rename == 0) { // never asked before
+					if ( (new MessageBox(MyLocale.getMsg(4702,&quot;Optimisation&quot;), MyLocale.getMsg(4703,&quot;Cachewolf can make loading maps much faster by adding a identification mark to the filename. Do you want me to do this now?\n It can take several minutes&quot;), 
+							MessageBox.YESB | MessageBox.NOB)).execute() == MessageBox.IDYES)
+					{
+						renameProgressInfoB = new InfoBox(MyLocale.getMsg(327,&quot;Info&quot;), MyLocale.getMsg(4704,&quot;\nRenaming file:&quot;)+&quot;    \n&quot;);
+						renameProgressInfoB.exec();
+						renameProgressInfoB.getWindow().waitUntilPainted(100);
+						rename = 1; // rename
+					} else rename = 2; // don't rename
+				}
+				if (rename == 1) {
+					renameCounter++;
+					renameProgressInfoB.setInfo(MyLocale.getMsg(4704,&quot;\nRenaming file:&quot;)+&quot; &quot; + renameCounter+&quot;\n&quot;);
+					String f = path+filename+&quot;.wfl&quot;;
+					String to = sortEntryBBox+&quot;E-&quot;+filename+&quot;.wfl&quot;;
+					if (!new File(f).rename(to))
+						(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(4705,&quot;Failed to rename:\n&quot;)+f+&quot;.wfl&quot;+MyLocale.getMsg(4706,&quot;\nto:\n&quot;)+to, FormBase.OKB)).exec();
+					f = Common.getImageName(path+filename);
+					if (f != null) {
+						to = sortEntryBBox+&quot;E-&quot;+filename+Common.getFilenameExtension(f);
+						if (!new File(f).rename(to)) {
+							Global.getPref().log(&quot;MapListEntry (String pathi, String filenamei): Failed to rename: &quot;+path+filename+&quot;: &quot;+f+&quot;.wfl to: &quot;+to);
+							(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(4705,&quot;Failed to rename:\n&quot;)+f+&quot;.wfl&quot;+MyLocale.getMsg(4706,&quot;\nto:\n&quot;)+to, FormBase.OKB)).exec();
+						}
+					} else {
+						Global.getPref().log(&quot;MapListEntry (String pathi, String filenamei): Could not find image assiciated to: &quot;+path+filename+&quot;.wfl&quot;);
+						(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(4709,&quot;Could not find image assiciated to:\n&quot;)+path+filename+&quot;.wfl&quot;, FormBase.OKB)).exec();
+					}
+					filename = sortEntryBBox+&quot;E-&quot;+filename;
+					map.mapName = sortEntryBBox+&quot;E-&quot;+map.mapName;
+					map.fileNameWFL = path + filename + &quot;.wfl&quot;;
+				}
+			} catch (IOException ioex) { // this should not happen
+				(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(4707,&quot;I/O-Error while reading:&quot;)+&quot; &quot;+path+filename+&quot;: &quot;+ ioex.getMessage(), FormBase.OKB)).exec();
+				Global.getPref().log(&quot;MapListEntry (String pathi, String filenamei): I/O-Error while reading: &quot;+path+filename+&quot;: &quot;, ioex);
+			} catch (Exception ex) {
+				(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(4706,&quot;Error while reading:&quot;)+&quot; &quot;+path+filename+&quot;: &quot;+ ex.getMessage(), FormBase.OKB)).exec();
+				Global.getPref().log(&quot;MapListEntry (String pathi, String filenamei): Error while reading: &quot;+path+filename+&quot;: &quot;, ex);
+			}
+		}
+	}
+	
+	public MapListEntry(double scale, double lat) {
+		map = new MapInfoObject(scale, lat);
+		filename = map.mapName;
+		sortEntryBBox = &quot;FF1&quot;;
+	}
+	
+	public MapInfoObject getMap() throws IOException {
+		if (map == null) map = new MapInfoObject(path, filename);
+		return map;
+	}
+	
+	public static void loadingFinished() {
+		if (renameProgressInfoB != null) renameProgressInfoB.close(0);
+		renameProgressInfoB = null;
+		rename=0;
+	}
+	
+	/*
+	// this maybe needed some time later to further enhance the speed of finding the best map
+	public int compareTo(Object other) {
+		if (other == null) return 1;
+		return this.sortEntryBBox.compareTo(((MapListEntry)other).sortEntryBBox);
+	} */
+}
+

Added: experiments/EVE/src/cachewolf/navi/MovingMap.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/MovingMap.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/MovingMap.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,2178 @@
+package cachewolf.navi;
+
+import eve.ui.*;
+import java.io.IOException;
+import eve.sys.*;
+import eve.ui.filechooser.FileChooser;
+import eve.fx.*;
+import eve.fx.gui.IKeys;
+import java.util.Vector;
+
+import cachewolf.CWPoint;
+import cachewolf.CacheHolder;
+import cachewolf.CacheType;
+import cachewolf.Global;
+import cachewolf.InfoBox;
+import cachewolf.MainTab;
+import cachewolf.MyLocale;
+import cachewolf.Preferences;
+import cachewolf.utils.Common;
+
+import eve.ui.game.AniImage;
+import eve.ui.game.InteractivePanel;
+import eve.ui.game.ImageList;
+import eve.ui.game.ImageDragContext;
+import eve.ui.event.PenEvent;
+import eve.ui.event.ControlEvent;
+import eve.ui.event.WindowEvent;
+import eve.ui.event.MenuEvent;
+import eve.ui.event.KeyEvent;
+import eve.ui.event.FormEvent;
+import eve.fx.gui.WindowConstants;
+/**
+ *	Class to handle a moving map.
+ */
+public class MovingMap extends Form {
+	public final static int gotFix = 4; //green
+	public final static int lostFix = 3; //yellow
+	public final static int noGPSData = 2; // red
+	public final static int noGPS = 1; // no GPS-Position marker, manually disconnected
+	public final static int ignoreGPS = -1; // ignore even changes in GPS-signal (eg. from lost fix to gotFix) this is wanted when the map is moved manually
+
+	public MapSymbol gotoPos = null;
+	public int gpsStatus;
+	Preferences pref;
+	MovingMapPanel mmp;
+	MapsList maps;
+	Vector symbols;
+	Vector cacheDB;
+	TrackOverlay[] TrackOverlays;
+	CWPoint TrackOverlaySetCenterTopLeft;
+	Vector tracks;
+	MapInfoObject currentMap = null;
+	//String mapPath;
+	Navigate myNavigation;
+	boolean running = false;
+
+	MapImage mapImage1to1;
+	ArrowsOnMap directionArrows = new ArrowsOnMap();
+	AniImage statusImageHaveSignal;
+	AniImage statusImageNoSignal;
+	AniImage statusImageNoGps;
+	AniImage buttonImageClose;
+	AniImage buttonImageChooseMap;
+	AniImage buttonImageGpsOn;
+	AniImage buttonImageLens;
+	AniImage buttonImageLensActivated;
+	AniImage buttonImageLensActivatedZoomIn;
+	AniImage buttonImageLensActivatedZoomOut;
+	AniImage buttonImageZoom1to1;
+	AniImage DistanceImage;
+	Graphics DistanceImageGraphics;
+	AniImage ScaleImage;
+	Graphics ScaleImageGraphics;
+	MapSymbol posCircle;
+	String MARK_CACHE_IMAGE;
+	int posCircleX = 0, posCircleY = 0, lastCompareX = Integer.MAX_VALUE, lastCompareY = Integer.MAX_VALUE;
+	//double posCircleLat, posCircleLon;
+	FontMetrics fm;
+
+	boolean dontUpdatePos = false; // this is only internaly used to avoid multi-threading problems
+	boolean ignoreGps = false; // ignores updateGps-calls if true
+	boolean autoSelectMap = true;
+	boolean forceMapLoad = true; // only needed to force updateposition to try to load the best map again after OutOfMemoryError after an repeated click on snap-to-gps
+	boolean mapHidden = false;
+	boolean noMapsAvailable;
+	boolean zoomingMode = false;
+	boolean mapsloaded = false;
+
+	Point lastRepaintMapPos = null;
+	double lastDistance = -1;
+	float lastHighestResolutionGPSDestScale = -1;
+
+	public MovingMap(Navigate nav, Vector cacheDB){
+		this.cacheDB = cacheDB;
+		this.myNavigation = nav;
+		this.pref = Global.getPref();
+		if (pref.myAppHeight &lt;= 640 &amp;&amp; pref.myAppWidth &lt;= 640)	this.windowFlagsToSet = WindowConstants.FLAG_FULL_SCREEN;
+		this.windowFlagsToClear = WindowConstants.FLAG_HAS_TITLE | UIConstants.BDR_NOBORDER;
+		this.hasTopBar = false;
+		this.noBorder = true;
+		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
+		this.title = &quot;Moving Map&quot;;
+		this.backGround = new Color(254,254,254); // background must not be black because black is interpreted as transparent and transparent images above (eg trackoverlay) want be drawn in windows-VM, so be care, don|t use white either
+		//this.mapPath = Global.getPref().getMapLoadPath();
+
+		mmp = new MovingMapPanel(this);
+		this.addLast(mmp);
+
+		boolean mobileVGA = false;
+		if (Device.isMobile() &amp;&amp; MyLocale.getScreenWidth() &gt;= 400) mobileVGA = true;
+		String imagesize=&quot;&quot;;
+		if(mobileVGA) imagesize=&quot;_vga&quot;;
+
+		statusImageHaveSignal = new AniImage(&quot;position_green&quot;+imagesize+&quot;.png&quot;);
+		statusImageNoSignal = new AniImage(&quot;position_yellow&quot;+imagesize+&quot;.png&quot;);
+		statusImageNoGps = new AniImage(&quot;position_red&quot;+imagesize+&quot;.png&quot;);
+		buttonImageChooseMap = new AniImage(&quot;choose_map&quot;+imagesize+&quot;.gif&quot;);
+		buttonImageGpsOn = new AniImage(&quot;snap2gps&quot;+imagesize+&quot;.gif&quot;);
+		buttonImageLens = new AniImage(&quot;lupe&quot;+imagesize+&quot;.png&quot;);
+		buttonImageLensActivated = new AniImage(&quot;lupe_activated&quot;+imagesize+&quot;.png&quot;);
+		buttonImageLensActivatedZoomIn = new AniImage(&quot;lupe_activated_zin&quot;+imagesize+&quot;.png&quot;);
+		buttonImageLensActivatedZoomOut = new AniImage(&quot;lupe_activated_zout&quot;+imagesize+&quot;.png&quot;);
+		buttonImageZoom1to1 = new AniImage(&quot;zoom1to1&quot;+imagesize+&quot;.png&quot;);
+		posCircle = new MapSymbol(&quot;position_green&quot;+imagesize+&quot;.png&quot;, &quot;gps-position&quot;, new CWPoint());
+		MARK_CACHE_IMAGE = &quot;mark_cache.png&quot;;
+
+		DrawnIcon closeX;
+		if(mobileVGA)
+			closeX = new DrawnIcon(DrawnIcon.CROSS,30,30,Color.Black);
+		else
+			closeX = new DrawnIcon(DrawnIcon.CROSS,15,15,Color.Black);
+		Image imgButtonClose;
+		buttonImageClose = new AniImage(imgButtonClose=new Image(closeX.getWidth(), closeX.getHeight()));
+		Graphics tmp = new Graphics(imgButtonClose);
+		//tmp.setColor(255, 255, 255);
+		tmp.set(new Brush(Color.White,Brush.SOLID));
+		tmp.fillRect(0, 0, closeX.getWidth(), closeX.getHeight());
+		closeX.doDraw(tmp, 0);
+		buttonImageClose.properties |= AniImage.AlwaysOnTop;
+		mmp.addImage(buttonImageClose);
+		buttonImageGpsOn.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(buttonImageGpsOn);
+		buttonImageChooseMap.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(buttonImageChooseMap);
+		directionArrows.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(directionArrows);
+		buttonImageLens.properties = AniImage.AlwaysOnTop;
+		buttonImageLensActivated.properties = AniImage.AlwaysOnTop;
+		buttonImageLensActivatedZoomIn.properties = AniImage.AlwaysOnTop;
+		buttonImageLensActivatedZoomOut.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(buttonImageLens);
+		buttonImageZoom1to1.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(buttonImageZoom1to1);
+		//target distance
+		int fontSize = ( 3 * pref.fontSize ) / 2;
+		Font font = new Font(&quot;Helvetica&quot;, Font.PLAIN, fontSize );
+		fm = getFontMetrics(font);
+		DistanceImage = new AniImage();
+		DistanceImage.setImage(new Image(MyLocale.getScreenWidth()/2, fm.getHeight()).getImageData()); //, Color.White); // consider the size of the font used
+		DistanceImageGraphics = new Graphics((Image)DistanceImage.getImage());
+		DistanceImageGraphics.setFont(font);
+		DistanceImage.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(DistanceImage);
+		//scale
+		ScaleImage = new AniImage();
+		ScaleImage.setImage(new Image(MyLocale.getScreenWidth()/2, fm.getHeight()).getImageData()); //, Color.White); // consider the size of the font used
+		ScaleImageGraphics = new Graphics((Image)ScaleImage.getImage());
+		ScaleImageGraphics.setFont(font);
+		ScaleImage.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(ScaleImage);
+		//resizeTo(pref.myAppWidth, pref.myAppWidth); // is necessary to initialise mapImage.screenSize
+		setGpsStatus(noGPS);
+		posCircle.properties = AniImage.AlwaysOnTop;
+		mmp.addImage(posCircle);
+		mmp.startDragResolution = 5;
+		mapsloaded = false;
+		//updateDistance(); // fill Rect with transparent color
+		scaleWanted = 1;
+		mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
+	 	lastHighestResolutionGPSDestScale = -1;
+
+		lastRepaintMapPos = new Point(pref.myAppWidth +1, pref.myAppHeight +1);
+	}
+
+	public void resizeTo(int w,int h) {
+		super.resizeTo(w, h);
+		updateFormSize(w, h);
+	}
+
+	public void updateFormSize(int w, int h) {
+		MapImage.setScreenSize(w, h);
+		buttonImageClose.setLocation(w- buttonImageClose.getWidth()- 5, 5);
+		buttonImageGpsOn.setLocation(w- buttonImageChooseMap.getWidth()-5, buttonImageClose.getHeight() + 20);
+		buttonImageChooseMap.setLocation(10,10);
+		directionArrows.setLocation(w/2-directionArrows.getWidth()/2, 10);
+		buttonImageZoom1to1.setLocation(w - buttonImageZoom1to1.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 - buttonImageZoom1to1.getHeight() -10);
+		buttonImageLens.setLocation(w - buttonImageLens.getWidth()-10, h/2 - buttonImageLens.getHeight()/2 );
+		buttonImageLensActivated.setLocation(w - buttonImageLensActivated.getWidth()-10, h/2 - buttonImageLensActivated.getHeight()/2 );
+		buttonImageLensActivatedZoomIn.setLocation(w - buttonImageLensActivatedZoomIn.getWidth()-10, h/2 - buttonImageLensActivatedZoomIn.getHeight()/2 );
+		buttonImageLensActivatedZoomOut.setLocation(w - buttonImageLensActivatedZoomOut.getWidth()-10, h/2 - buttonImageLensActivatedZoomOut.getHeight()/2 );
+		DistanceImage.setLocation(0, h - DistanceImage.getHeight());
+		ScaleImage.setLocation(w - ScaleImage.getWidth(), h - ScaleImage.getHeight());
+		if (mmp.mapImage != null) mmp.mapImage.screenDimChanged();
+		if (posCircle != null) posCircle.screenDimChanged();
+		if (tracks != null) rebuildOverlaySet();
+		if (symbols != null) { // TODO: see if the rest of the code works with symbols = null
+			for (int i = symbols.size() -1; i &gt;= 0; i-- ) {
+				((MapSymbol)symbols.get(i)).screenDimChanged();
+			}
+		}
+	}
+
+	boolean loadingMapList = false;
+	/**
+	 * loads the list of maps
+	 * @param mapsPath must not have a trailing end &quot;/&quot;
+	 * @param lat used to create empty maps with correct conversion from lon to meters the latitude must be known
+	 */
+	public void loadMaps(String mapsPath, double lat){
+		if (loadingMapList) return;
+		loadingMapList = true;
+		//this.mapPath = mapsPath;
+		Form.showWait();
+		resetCenterOfMap();
+		InfoBox inf = new InfoBox(MyLocale.getMsg(4201, &quot;Info&quot;), MyLocale.getMsg(4203, &quot;Loading list of maps...&quot;));
+		inf.exec();
+		inf.getWindow().waitUntilPainted(100);
+		boolean saveGpsIgnoreStatus = dontUpdatePos;
+		dontUpdatePos = true;
+		maps = new MapsList(mapsPath); // this actually loads the maps
+		if (maps.isEmpty()) {
+			(new MessageBox(MyLocale.getMsg(4201, &quot;Information&quot;), MyLocale.getMsg(4204, &quot;No georeferenced map available \n Please choose a scale \n to show the track and the caches. \n You can get one by the menu: Application/Maps/download calibrated&quot;), FormBase.OKB)).execute();			noMapsAvailable = true;
+		} else noMapsAvailable = false;
+		maps.addEmptyMaps(lat); // the empty maps must be added last, otherwise in method setBestMap, when no mapt is available, a malfunction will happen, see there
+		dontUpdatePos = saveGpsIgnoreStatus;
+		inf.close(0);
+		Form.cancelWait();
+		this.mapsloaded = true;
+		loadingMapList = false;
+	}
+
+	public void updateScale() {
+		//TODO ScaleImageGraphics.setColor(ScaleImage.transparentColor);
+		ScaleImageGraphics.fillRect(0, 0, ScaleImage.location.width,ScaleImage.location.height);
+
+		if (currentMap != null)
+		{
+			float lineLengthMeters = 40 * currentMap.scale;
+			float digits = (float)java.lang.Math.floor( java.lang.Math.log(lineLengthMeters) / java.lang.Math.log(10.0) );
+			lineLengthMeters = (float)java.lang.Math.ceil( lineLengthMeters / (float)java.lang.Math.pow(10, digits) ) * (float)java.lang.Math.pow(10, digits);
+			int lineLengthPixels = java.lang.Math.round( lineLengthMeters / currentMap.scale );
+
+			String lineLengthString;
+			if (lineLengthMeters &lt; 1000)
+			{
+				lineLengthString = Convert.toString((int) lineLengthMeters) + &quot;m&quot;;
+			}
+			else
+			{
+				lineLengthString = Convert.toString((int) lineLengthMeters / 1000) + &quot;km&quot;;
+			}
+
+			int backgroundStartX = ScaleImage.location.width - (lineLengthPixels + fm.getTextWidth(lineLengthString) + 7);
+
+			ScaleImageGraphics.setColor(new Color(250,250,250));
+			ScaleImageGraphics.fillRect(backgroundStartX, 0, ScaleImage.location.width - backgroundStartX ,ScaleImage.location.height);
+
+			ScaleImageGraphics.changePen(Color.DarkBlue,Pen.SOLID,3);
+			ScaleImageGraphics.drawLine(backgroundStartX + 2, ScaleImage.location.height / 2, backgroundStartX+2+lineLengthPixels, ScaleImage.location.height / 2);
+			ScaleImageGraphics.setColor(Color.DarkBlue);
+			ScaleImageGraphics.drawText(lineLengthString , backgroundStartX + lineLengthPixels + 5, 0);
+		}
+
+		ScaleImageGraphics.drawImageData(ScaleImage.getImageData(),new Rect(0,0,ScaleImage.location.width,ScaleImage.location.height),new Rect(0,0,ScaleImage.location.width,ScaleImage.location.height),0); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed  Color.LightBlue,0,0,
+		ScaleImageGraphics.drawImageData(ScaleImage.getImageData(),new Rect(0,0,ScaleImage.location.width,ScaleImage.location.height),new Rect(0,0,ScaleImage.location.width,ScaleImage.location.height),0); // these 2 commands are necessary because of a bug or near to a bug in the eve-vm
+	}
+
+	public void updateDistance(boolean repaint) {
+		//TODO DistanceImageGraphics.setColor(DistanceImage.transparentColor);
+		DistanceImageGraphics.fillRect(0, 0, DistanceImage.location.width,DistanceImage.location.height);
+		if (gotoPos != null &amp;&amp; posCircle.where.isValid())
+		{
+			double currentDistance = gotoPos.where.getDistance(posCircle.where);
+			if (currentDistance != lastDistance)
+			{
+				lastDistance = currentDistance;
+				double dd=currentDistance;
+				String d;
+				if (dd &lt; 1) {
+					dd = dd * 1000;
+					d = MyLocale.getMsg(4206, &quot;Dist: &quot;) + Common.doubleToString(dd,0) + &quot;m&quot;;
+					int digits = (int)java.lang.Math.floor( java.lang.Math.log(dd) / java.lang.Math.log(10.0) );
+					digits = java.lang.Math.max(0, digits);
+				}
+				else {
+					d = MyLocale.getMsg(4206, &quot;Dist: &quot;) + Common.doubleToString(dd,2) + &quot;km&quot;;
+					int digits = (int)java.lang.Math.floor( java.lang.Math.log(dd) / java.lang.Math.log(10.0) );
+					digits = java.lang.Math.max(0, digits);
+				}
+
+				int backgroundWidth = fm.getTextWidth(d) + 4;
+
+				DistanceImageGraphics.setColor(new Color(250,250,250));
+				DistanceImageGraphics.fillRect(0, 0, backgroundWidth ,DistanceImage.location.height);
+
+				DistanceImageGraphics.setColor(Color.DarkBlue);
+				DistanceImageGraphics.drawText(d, 2, 0);
+
+				DistanceImageGraphics.drawImageData(DistanceImage.getImageData(),null,new Rect(0,0,DistanceImage.location.width,DistanceImage.location.height),0); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed
+				DistanceImageGraphics.drawImageData(DistanceImage.getImageData(),null,new Rect(0,0,DistanceImage.location.width,DistanceImage.location.height),0); // these 2 commands are necessary because of a bug or near to a bug in the eve-vm
+				if (repaint)
+				{
+					//TODO DistanceImage.updateImage();
+				}
+			}
+		}
+		else
+		{
+			Rect area=new Rect(0,0,DistanceImage.location.width,DistanceImage.location.height);
+			DistanceImageGraphics.drawImageData(DistanceImage.getImageData(),area,area,0); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed Color.LightBlue,
+			DistanceImageGraphics.drawImageData(DistanceImage.getImageData(),area,area,0); // these 2 commands are necessary because of a bug or near to a bug in the eve-vm
+		}
+	}
+
+	public void forceMapLoad() {
+		forceMapLoad = true;
+		updatePosition(posCircle.where); // this sets forceMapLoad to false after loading a map
+	}
+
+	public final FormFrame myExec() {
+		// update cache symbols in map
+		running = true;
+		MainTab mainT = Global.mainTab;
+		if (Global.getProfile().selectionChanged) {
+			Global.getProfile().selectionChanged = false;
+			removeAllMapSymbolsButGoto();
+			CacheHolder ch;
+			for (int i=cacheDB.size()-1; i&gt;=0; i--) {
+				ch = (CacheHolder) cacheDB.get(i);
+				if (ch.is_Checked &amp;&amp; !ch.is_filtered &amp;&amp; ch != mainT.ch) {
+					if (ch.pos.isValid()) addSymbol(ch.cacheName, ch, CacheType.cache2Img(ch.type), ch.pos);
+				}
+			}
+		}
+		setMarkedCache(mainT.ch);
+		addTrack(myNavigation.curTrack);
+		if (tracks != null &amp;&amp; tracks.size() &gt; 0 &amp;&amp; ((Track)tracks.get(0)).num &gt; 0)
+			rebuildOverlaySet(); // show points which where added when MavingMap was not running
+		destChanged(myNavigation.destination);
+		FormFrame ret = exec();
+		return ret;
+	}
+
+	CacheHolder markedCache = null;
+	public void setMarkedCache(CacheHolder ch) {
+		if (ch == markedCache) return;
+		if (markedCache != null) {
+			removeMapSymbol(&quot;selectedCache&quot;);
+			if (!markedCache.is_Checked) removeMapSymbol(markedCache);
+		}
+		if (ch != null) {
+			addSymbol(&quot;selectedCache&quot;, MARK_CACHE_IMAGE, ch.pos);
+			addSymbolIfNecessary(ch.cacheName, ch, CacheType.cache2Img(ch.type), ch.pos);
+		}
+		markedCache = ch;
+	}
+
+	public void addTrack(Track tr) {
+		if (tr == null) return;
+		if (tracks == null) tracks = new Vector();
+		if (tracks.indexOf(tr) &gt;= 0 ) return; // track already in list
+		tracks.add(tr);
+		rebuildOverlaySet();
+	}
+
+	public void addTracks(Track[] trs) {
+		if (trs==null || trs.length == 0) return;
+		for (int i=0; i&lt;trs.length; i++) {
+			addTrack(trs[i]);
+		}
+		rebuildOverlaySet();
+	}
+
+	/**
+	 * adds an 3x3 set of overlays to the map-window which contain the track
+	 *
+	 * add tracks with addtrack(track) before
+	 */
+
+	public void addOverlaySet() {
+		if (tracks == null) return; // no tracks
+		try {
+			TrackOverlaySetCenterTopLeft = screenXY2LatLon(100, 100);
+			addMissingOverlays();
+		} catch (NullPointerException e) {} // hapens if currentmap == null or PosCircle not valid
+		catch (IllegalArgumentException e) {} // happens if screensize is still not known    ---&gt; in both cases creation of Overlayset will be done in updateOverlayPos if tracks != null
+	}
+
+	public void destroyOverlaySet() {
+		if (TrackOverlays != null) {
+			for (int i=0; i&lt; TrackOverlays.length; i++) {	destroyOverlay(i);	}
+		}
+		Vm.getUsedObjectMemory(true); // call garbage collection
+		Runtime.getRuntime().gc();
+	}
+
+	public void rebuildOverlaySet() {
+		destroyOverlaySet();
+		addOverlaySet();
+	}
+
+	public void addMissingOverlays() {
+		if (currentMap == null || (!posCircle.where.isValid()) || width == 0 || height == 0) return; // height == 0 happens if this is called before the form ist displayed on the screen
+		if (TrackOverlays == null) {
+			TrackOverlays = new TrackOverlay[9];
+			TrackOverlaySetCenterTopLeft = screenXY2LatLon(100, 100);
+		}
+		boolean saveGPSIgnoreStatus = dontUpdatePos; // avoid multi-threading problems
+		dontUpdatePos = true;
+		Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft); // TrackOverlay[4] == center of Trackoverlays
+		//upperleftOf4.x = (upperleftOf4.x + 1* width) % (width * 2) - 1 * width;
+		//upperleftOf4.y = (upperleftOf4.y + 1* height) % (height * 2) - 1 * height;
+		int i;
+		for (int yi=0; yi&lt;3; yi++) {
+			for (int xi=0; xi&lt;3; xi++) {
+				i = yi*3+xi;
+				if (TrackOverlays[i]==null) {
+					TrackOverlays[i]= new TrackOverlay(screenXY2LatLon(upperleftOf4.x+(xi-1)*width, upperleftOf4.y+(yi-1)*height), width, height, currentMap);
+					TrackOverlays[i].setLocation(width+1, height+1); // outside of the screen will hide it automatically it will get the correct position in upadteOverlayposition
+					TrackOverlays[i].tracks = this.tracks;
+					TrackOverlays[i].paintTracks();
+					mmp.addImage(TrackOverlays[i]);
+				}
+			}
+		}
+		updateOverlayOnlyPos();
+		if (mmp.mapImage != null) mmp.images.moveToBack(mmp.mapImage);
+		dontUpdatePos = saveGPSIgnoreStatus;
+	}
+
+	private void destroyOverlay(int ov) {
+		if (TrackOverlays[ov] == null) return;
+		mmp.removeImage(TrackOverlays[ov]);
+		TrackOverlays[ov].free();
+		TrackOverlays[ov]=null;
+	}
+	public void rearangeOverlays() {
+		Point oldp = getXYonScreen(TrackOverlaySetCenterTopLeft);
+		if (TrackOverlays[1].isOnScreen()) { // oben raus
+			TrackOverlaySetCenterTopLeft.set(screenXY2LatLon(oldp.x, oldp.y - 2* height));
+			destroyOverlay(6);
+			destroyOverlay(7);
+			destroyOverlay(8);
+			mmp.removeImage(TrackOverlays[0]);
+			mmp.removeImage(TrackOverlays[1]);
+			mmp.removeImage(TrackOverlays[2]);
+			TrackOverlays[6]=TrackOverlays[0];
+			TrackOverlays[7]=TrackOverlays[1];
+			TrackOverlays[8]=TrackOverlays[2];
+			mmp.addImage(TrackOverlays[6]);
+			mmp.addImage(TrackOverlays[7]);
+			mmp.addImage(TrackOverlays[8]);
+			TrackOverlays[0] = null;
+			TrackOverlays[1] = null;
+			TrackOverlays[2] = null;
+			destroyOverlay(3);
+			destroyOverlay(4);
+			destroyOverlay(5);
+		} else {
+			if (TrackOverlays[3].isOnScreen()) { // links raus
+				TrackOverlaySetCenterTopLeft.set(screenXY2LatLon(oldp.x - 2* width, oldp.y ));
+				destroyOverlay(2);
+				destroyOverlay(5);
+				destroyOverlay(8);
+				mmp.removeImage(TrackOverlays[0]);
+				mmp.removeImage(TrackOverlays[3]);
+				mmp.removeImage(TrackOverlays[6]);
+				TrackOverlays[2]=TrackOverlays[0];
+				TrackOverlays[5]=TrackOverlays[3];
+				TrackOverlays[8]=TrackOverlays[6];
+				mmp.addImage(TrackOverlays[2]);
+				mmp.addImage(TrackOverlays[5]);
+				mmp.addImage(TrackOverlays[8]);
+				TrackOverlays[0] = null;
+				TrackOverlays[3] = null;
+				TrackOverlays[6] = null;
+				destroyOverlay(1);
+				destroyOverlay(4);
+				destroyOverlay(7);
+			} else {
+				if (TrackOverlays[5].isOnScreen()) { // rechts raus
+					TrackOverlaySetCenterTopLeft.set(screenXY2LatLon(oldp.x + 2* width, oldp.y ));
+					destroyOverlay(0);
+					destroyOverlay(3);
+					destroyOverlay(6);
+					mmp.removeImage(TrackOverlays[2]);
+					mmp.removeImage(TrackOverlays[5]);
+					mmp.removeImage(TrackOverlays[8]);
+					TrackOverlays[0]=TrackOverlays[2];
+					TrackOverlays[3]=TrackOverlays[5];
+					TrackOverlays[6]=TrackOverlays[8];
+					mmp.addImage(TrackOverlays[0]);
+					mmp.addImage(TrackOverlays[3]);
+					mmp.addImage(TrackOverlays[6]);
+					TrackOverlays[2] = null;
+					TrackOverlays[5] = null;
+					TrackOverlays[8] = null;
+					destroyOverlay(1);
+					destroyOverlay(4);
+					destroyOverlay(7);
+				} else {
+					if (TrackOverlays[7].isOnScreen()) { // unten raus
+						TrackOverlaySetCenterTopLeft.set(screenXY2LatLon(oldp.x, oldp.y + 2* height));
+						destroyOverlay(0);
+						destroyOverlay(1);
+						destroyOverlay(2);
+						mmp.removeImage(TrackOverlays[6]);
+						mmp.removeImage(TrackOverlays[7]);
+						mmp.removeImage(TrackOverlays[8]);
+						TrackOverlays[0]=TrackOverlays[6];
+						TrackOverlays[1]=TrackOverlays[7];
+						TrackOverlays[2]=TrackOverlays[8];
+						mmp.addImage(TrackOverlays[0]);
+						mmp.addImage(TrackOverlays[1]);
+						mmp.addImage(TrackOverlays[2]);
+						TrackOverlays[6] = null;
+						TrackOverlays[7] = null;
+						TrackOverlays[8] = null;
+						destroyOverlay(3);
+						destroyOverlay(4);
+						destroyOverlay(5);
+					} else { // it is important to test for diagonal only if the other didn't match
+						if (TrackOverlays[0].isOnScreen()) {  // links oben raus
+							TrackOverlaySetCenterTopLeft.set(screenXY2LatLon(oldp.x - 2* width, oldp.y - 2* height));
+							destroyOverlay(8);
+							mmp.removeImage(TrackOverlays[0]);
+							TrackOverlays[8]=TrackOverlays[0];
+							mmp.addImage(TrackOverlays[8]);
+							TrackOverlays[0] = null;
+							destroyOverlay(1);
+							destroyOverlay(2);
+							destroyOverlay(3);
+							destroyOverlay(4);
+							destroyOverlay(5);
+							destroyOverlay(6);
+							destroyOverlay(7);
+						} else {
+							if (TrackOverlays[2].isOnScreen()) { // rechts oben raus
+								TrackOverlaySetCenterTopLeft.set(screenXY2LatLon(oldp.x + 2* width, oldp.y - 2* height));
+								destroyOverlay(6);
+								mmp.removeImage(TrackOverlays[2]);
+								TrackOverlays[6]=TrackOverlays[2];
+								mmp.addImage(TrackOverlays[6]);
+								TrackOverlays[2] = null;
+								destroyOverlay(0);
+								destroyOverlay(1);
+								destroyOverlay(3);
+								destroyOverlay(4);
+								destroyOverlay(5);
+								destroyOverlay(7);
+								destroyOverlay(8);
+							} else {
+								if (TrackOverlays[6].isOnScreen()) { // links unten raus
+									TrackOverlaySetCenterTopLeft.set(screenXY2LatLon(oldp.x - 2* width, oldp.y + 2* height));
+									destroyOverlay(2);
+									mmp.removeImage(TrackOverlays[6]);
+									TrackOverlays[2]=TrackOverlays[6];
+									mmp.addImage(TrackOverlays[2]);
+									TrackOverlays[6] = null;
+									destroyOverlay(0);
+									destroyOverlay(1);
+									destroyOverlay(3);
+									destroyOverlay(4);
+									destroyOverlay(5);
+									destroyOverlay(7);
+									destroyOverlay(8);
+								} else {
+									if (TrackOverlays[8].isOnScreen()) { // rechts unten raus
+										TrackOverlaySetCenterTopLeft.set(screenXY2LatLon(oldp.x + 2* width, oldp.y + 2* height));
+										destroyOverlay(0);
+										mmp.removeImage(TrackOverlays[8]);
+										TrackOverlays[0]=TrackOverlays[8];
+										mmp.addImage(TrackOverlays[0]);
+										TrackOverlays[8] = null;
+										destroyOverlay(1);
+										destroyOverlay(2);
+										destroyOverlay(3);
+										destroyOverlay(4);
+										destroyOverlay(5);
+										destroyOverlay(6);
+										destroyOverlay(7);
+									}else
+										for (int i=0; i&lt;TrackOverlays.length; i++) {
+											destroyOverlay(i);
+											TrackOverlaySetCenterTopLeft = screenXY2LatLon(100, 100);
+										} // this happens if a position jump occured
+								}}}}}}} // close all IFs
+		Runtime.getRuntime().gc(); // call garbage collection
+		//Vm.debug(&quot;Overlayrearanged&quot;+TrackOverlays.toString());
+	}
+
+	public void showLastAddedPoint(Track tr) {
+		if (TrackOverlays == null || tr == null) return;
+		for (int i=0; i&lt;TrackOverlays.length; i++){
+			TrackOverlays[i].paintLastAddedPoint(tr);
+		}
+	}
+
+	public void updateOverlayOnlyPos() {
+		if (TrackOverlays == null || TrackOverlays[4] == null) return;
+		//	Point upperleft = getMapXYPosition();
+		Point posOnScreen;
+		posOnScreen = getXYonScreen(TrackOverlays[4].topLeft);
+		Dimension ws = mmp.getSize(null);
+		int ww = ws.width;
+		int wh = ws.height;
+		//Vm.sleep(100); // this is necessary because the eve vm ist not multi-threaded and the serial thread also needs time
+		int num, x, y;
+		for (int yi=0; yi&lt;3; yi++) {
+			for (int xi=0; xi&lt;3; xi++) {
+				num = yi*3+xi;
+				x = posOnScreen.x+(xi-1)*ww;
+				y = posOnScreen.y+(yi-1)*wh;
+				TrackOverlays[num].setLocation(x, y);
+			}
+		}
+	}
+
+	public void updateOverlayPos() {
+		if (tracks == null || tracks.size() == 0) return;
+		if (TrackOverlays == null || TrackOverlays[4] == null) addMissingOverlays();
+		else {
+			updateOverlayOnlyPos();
+			if (TrackOverlays[0].locAlways.x &gt; 0 || TrackOverlays[2].locAlways.x &lt; 0
+					|| TrackOverlays[0].locAlways.y &gt; 0 || TrackOverlays[8].locAlways.y &lt; 0) { // testForNeedToRearange
+				rearangeOverlays();
+				addMissingOverlays();
+				// updateOverlayOnlyPos(); is called from addMissingOverlays
+			}
+		}
+	}
+
+	/**
+	 * move posCircle to the Centre of the Screen
+	 *
+	 */
+	public void resetCenterOfMap() {
+		if (width != 0) {
+			posCircleX = width /2;
+			posCircleY = height /2;
+		} else {
+			posCircleX = pref.myAppWidth/2; // maybe this could /should be repleced to windows size
+			posCircleY = pref.myAppHeight/2;
+		}
+		posCircle.hidden = false;
+		posCircle.move(posCircleX-posCircle.getWidth()/2, posCircleY-posCircle.getHeight()/2); // posCircle.setLocation caused a problem -&gt; hiding the posCircle in some situation
+	}
+
+	public void movePosCircleToLatLon(CWPoint p, boolean repaint) {
+		moveScreenXYtoLatLon(new Point(posCircleX, posCircleY), p, repaint);
+	}
+
+	public void setCenterOfScreen (CWPoint c, boolean repaint) {
+		moveScreenXYtoLatLon(new Point (this.width/2, this.height/2), c, repaint);
+	}
+
+	public void moveScreenXYtoLatLon(Point s, CWPoint c, boolean repaint) {
+		Point mappos = getMapPositionOnScreen();
+		Point onscreenpos = getXYonScreen(c);
+		if (mmp != null &amp;&amp; mmp.mapImage != null) mmp.mapImage.move(mappos.x - onscreenpos.x + s.x, mappos.y - onscreenpos.y + s.y);
+		mapMoved(s.x - onscreenpos.x, s.y - onscreenpos.y);
+		if (repaint) mmp.repaintNow();
+	}
+
+	/** call this if the map moved on the screen (by dragging)
+	 * this routine will adjust (move accordingly) all other symbols on the screen
+	 * @param diffX
+	 * @param diffY
+	 */
+	public void mapMoved(int diffX, int diffY) {
+		int w = posCircle.getWidth();
+		int h = posCircle.getHeight();
+		int npx = posCircleX-w/2+diffX;
+		int npy = posCircleY-h/2+diffY;
+		posCircle.move(npx, npy);
+		posCircleX = posCircleX+diffX;
+		posCircleY = posCircleY+diffY;
+		if (posCircle.where.isValid()){
+			dontUpdatePos = false;
+			updatePosition(posCircle.where);
+		}
+		updateSymbolPositions();
+		updateOverlayPos();
+	}
+
+	/**
+	 * get upper left corner of map on window
+	 * this is called when the map needs to be moved / the position of the map is wanted
+	 * the map-position is calculated relativ to posCircle (x,y and lat/lon)
+	 * returns the same as mmp.mapImage.getLocation(mapPos);
+	 * but also works if mmp == null and is used to move the map to the correct point
+	 * @return
+	 */
+	public Point getMapPositionOnScreen() {
+		if (currentMap == null || !posCircle.where.isValid()) return new Point(pref.myAppWidth +1, pref.myAppHeight +1); // in case no calculation is possible return somthing outside of the screen
+		Point mapPos = new Point();
+		//if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
+		//else {
+		Point mapposint = currentMap.calcMapXY(posCircle.where);
+		mapPos.x = posCircleX - mapposint.x;
+		mapPos.y = posCircleY - mapposint.y;
+		//}
+		return mapPos;
+	}
+
+	/**
+	 *
+	 * @param lat
+	 * @param lon
+	 * @return
+	 */
+	public Point getXYonScreen(TrackPoint ll){
+		if (currentMap == null) return null;
+		Point coords = currentMap.calcMapXY(ll);
+		Point mapPos = getMapPositionOnScreen();
+		//		Vm.debug(&quot;getXYinMap, posCiLat: &quot;+posCircleLat+&quot;poscLOn: &quot;+ posCircleLon+&quot;gotoLat: &quot;+ lat + &quot;gotoLon: &quot;+ lon+&quot; mapPosX: &quot;+mapPos.x+&quot;mapposY&quot;+mapPos.y);
+		return new Point(coords.x + mapPos.x, coords.y + mapPos.y);
+	}
+
+	public CWPoint screenXY2LatLon (int x, int y){
+		Point mapPos = getMapPositionOnScreen();
+		return currentMap.calcLatLon(x - mapPos.x, y - mapPos.y);
+	}
+
+
+	public void updateSymbolPositions() {
+		if (symbols == null) return;
+		Point pOnScreen;
+		MapSymbol symb;
+		int w, h;
+		for (int i=symbols.size()-1; i&gt;=0; i--) {
+			symb = (MapSymbol)symbols.get(i);
+			pOnScreen = getXYonScreen(symb.where);
+			w=symb.getWidth();
+			h=symb.getHeight();
+			symb.move(pOnScreen.x-w/2, pOnScreen.y-h/2);
+		}
+	}
+
+	public MapSymbol addSymbol(String name, String filename, CWPoint where) {
+		if (symbols==null) symbols=new Vector();
+		MapSymbol ms = new MapSymbol(name, filename, where);
+		ms.loadImage();
+		ms.properties |= AniImage.AlwaysOnTop;
+		Point pOnScreen = getXYonScreen(where);
+		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		symbols.add(ms);
+		mmp.addImage(ms);
+		return ms;
+	}
+
+	public void addSymbolIfNecessary(String name, Object mapObject, Picture imSymb, CWPoint where) {
+		if (findMapSymbol(name) &gt;= 0) return;
+		addSymbol(name, mapObject, imSymb, where);
+	}
+
+	public void addSymbol(String name, Object mapObject, Picture imSymb, CWPoint ll) {
+		if (symbols==null) symbols=new Vector();
+		MapSymbol ms = new MapSymbol(name, mapObject, imSymb, ll);
+		ms.properties = AniImage.AlwaysOnTop;
+		Point pOnScreen = getXYonScreen(ll);
+		if (pOnScreen != null) ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		symbols.add(ms);
+		mmp.addImage(ms);
+	}
+
+	public void destChanged(CWPoint d) {
+		if(!running || (d == null &amp;&amp; gotoPos == null) ||
+				(d != null &amp;&amp; gotoPos != null &amp;&amp; gotoPos.where.equals(d))) return;
+		removeGotoPosition();
+		if (d == null || !d.isValid() ) return;
+		gotoPos = addSymbol(&quot;goto&quot;, &quot;goto_map.png&quot;, d);
+		//updateDistance(); - this is called from updatePosition
+		forceMapLoad = true;
+		if (this.width != 0) updatePosition(posCircle.where); // dirty hack: if this.width == 0, then the symbols are not on the screen and get hidden by updateSymbolPositions
+	}
+
+	public void removeGotoPosition() {
+		removeMapSymbol(&quot;goto&quot;);
+	}
+
+	public CWPoint getGotoPos(){
+		if (gotoPos == null) return null;
+		return new CWPoint(gotoPos.where);
+	}
+
+	public void removeAllMapSymbolsButGoto(){
+		if (symbols == null) return;
+		for (int i = symbols.size()-1; i &gt;= 0; i--) {
+			mmp.removeImage((MapSymbol)symbols.get(i));
+		}
+		symbols.removeAllElements();
+		if (gotoPos != null) symbols.add(gotoPos);
+	}
+
+	public void removeMapSymbol(String name) {
+		int symbNr = findMapSymbol(name);
+		if (symbNr != -1) removeMapSymbol(symbNr);
+	}
+
+	public void removeMapSymbol(Object obj) {
+		int symbNr = findMapSymbol(obj);
+		if (symbNr != -1) removeMapSymbol(symbNr);
+	}
+
+
+	public void removeMapSymbol(int SymNr) {
+		mmp.removeImage(((MapSymbol)symbols.get(SymNr)));
+		symbols.removeElementAt(SymNr);
+	}
+
+	public int findMapSymbol(String name) {
+		if (symbols == null) return -1;
+		MapSymbol ms;
+		for (int i = symbols.size() -1; i &gt;= 0 ; i--) {
+			ms= (MapSymbol)symbols.get(i);
+			if (ms.name == name) return i;// TODO is this comparison right or should it use equals() ?
+		}
+		return -1;
+	}
+
+	public int findMapSymbol(Object obj) {
+		if (symbols == null) return -1;
+		MapSymbol ms;
+		for (int i = symbols.size() -1; i &gt;= 0 ; i--) {
+			ms= (MapSymbol)symbols.get(i);
+			if (ms.mapObject == obj) return i;
+		}
+		return -1;
+	}
+
+	/**
+	 * Move the map so that the posCircle is at lat/lon
+	 *
+	 * @param
+	 */
+	public void updateOnlyPosition(CWPoint where, boolean updateOverlay){
+		//Point oldMapPos = getMapPositionOnScreen();
+		posCircle.where.set(where);
+		Point mapPos = getMapPositionOnScreen();
+		//Vm.debug(&quot;mapx = &quot; + mapx);
+		//Vm.debug(&quot;mapy = &quot; + mapy);
+		if (forceMapLoad || (java.lang.Math.abs(lastRepaintMapPos.x - mapPos.x) &gt; 1 || java.lang.Math.abs(lastRepaintMapPos.y - mapPos.y) &gt; 1))
+		{
+			lastRepaintMapPos = mapPos;
+			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x, mapPos.y);
+			updateSymbolPositions();
+			updateDistance(false);
+			if (updateOverlay ) updateOverlayPos(); // &amp;&amp; TrackOverlays != null
+			mmp.repaintNow();
+		}
+		else
+		{
+			updateDistance(true);
+		}
+		//Vm.debug(&quot;update only position&quot;);
+	}
+	/**
+	 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
+	 */
+	public void updatePosition(CWPoint where){
+		if (dontUpdatePos || loadingMapList) return; // avoid multi-threading problems
+		//Vm.debug(&quot;updatepos, lat: &quot;+where.latDec+&quot; lon: &quot;+where.lonDec);
+		if (!mapsloaded) {
+			loadMaps(Global.getPref().getMapLoadPath(), where.latDec);
+			lastCompareX = Integer.MAX_VALUE;
+			lastCompareY = Integer.MAX_VALUE;
+			autoSelectMap = true;
+			setBestMap(where, true);
+			forceMapLoad = false;
+			return;
+		}
+		updateOnlyPosition(where, true);
+		if (!autoSelectMap) return;
+		Point mapPos = getMapPositionOnScreen();
+		boolean screenNotCompletlyCovered =  mmp.mapImage == null || (mmp.mapImage != null &amp;&amp; ( mapPos.y &gt; 0 || mapPos.x &gt; 0 || mapPos.y+mmp.mapImage.getHeight()&lt;this.height	|| mapPos.x+mmp.mapImage.getWidth()&lt;this.width));
+		if (forceMapLoad || wantMapTest|| screenNotCompletlyCovered) 	{ // if force || want || map doesn't cover the scree completly
+			//Vm.debug(&quot;Screen not completly covered by map&quot;);
+			if (forceMapLoad || (java.lang.Math.abs(lastCompareX-mapPos.x) &gt; this.width/10 || java.lang.Math.abs(lastCompareY-mapPos.y) &gt; this.height/10)) {
+				// more then 1/10 of screen moved since last time we tried to find a better map
+				lastCompareX = mapPos.x;
+				lastCompareY = mapPos.y;
+				setBestMap(where, screenNotCompletlyCovered);
+				forceMapLoad = false;
+			}
+		}
+	}
+
+	public void updateGps(int fix) {
+		if (!running || ignoreGps) return;
+		// runMovingMap neccessary in case of multi-threaded Java-VM: ticked could be called during load of mmp
+		if ((fix &gt; 0) &amp;&amp; (myNavigation.gpsPos.getSats()&gt;= 0)) { // TODO is getSats really necessary?
+			directionArrows.setDirections((float)myNavigation.gpsPos.getBearing(myNavigation.destination),
+					(float)myNavigation.skyOrientationDir.lonDec, (float)myNavigation.gpsPos.getBear());
+			setGpsStatus(MovingMap.gotFix);
+			updatePosition(myNavigation.gpsPos);
+			showLastAddedPoint(myNavigation.curTrack);
+		}
+		if (fix == 0 &amp;&amp; myNavigation.gpsPos.getSats()== 0) 	setGpsStatus(MovingMap.lostFix);
+		if (fix &lt; 0 )	setGpsStatus(MovingMap.noGPSData);
+	}
+
+	public void gpsStarted() {
+		addTrack(myNavigation.curTrack);
+		ignoreGps = false;
+	}
+	public void gpsStoped() {
+		setGpsStatus(MovingMap.noGPS);
+	}
+
+	int mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
+	float scaleWanted;
+	boolean wantMapTest = true; // if true updateposition calls setBestMap regulary even if the currentmap covers the whole screen
+	public final static int NORMAL_KEEP_RESOLUTION = 1; // keeps the choosen resolution as long as a map is available that overlaps with the screen and with the PosCircle - it changes the resolution if no such map is available. It wil cahnge back to the wanted scale as soon as a map becomes available (through movement of the GPS-receiver)
+	public final static int HIGHEST_RESOLUTION = 2;
+	public final static int HIGHEST_RESOLUTION_GPS_DEST = 3;
+	boolean inBestMap = false; // to avoid multi-threading problems
+
+	/**
+	 * loads the best map for lat/lon according to mapChangeModus
+	 * lat/lon will be at the screen-pos of posCircle
+	 * when posCircle is not on the screen (shifted outside my the user)
+	 * then this routine uses the centre of the screen to find the best map
+	 * but anyway the map will be adjusted (moved) relativ to posCircle
+	 * when a better map was found the called method updateposition will set
+	 * posCirleLat/-Lon to lat/lon.
+	 *
+	 * @param lat
+	 * @param lon
+	 * @param loadIfSameScale false: will not change the map if the better map has the same scale as the current - this is used not to change the map if it covers already the screen completely
+	 * true: willchange the map, regardless of change in scale
+	 */
+	public void setBestMap(CWPoint where, boolean loadIfSameScale) {
+		if (inBestMap) return;
+		inBestMap = true;
+		Object [] s = getRectForMapChange(where);
+		CWPoint cll = (CWPoint) s[0];
+		Rect screen = (Rect) s[1];
+		boolean posCircleOnScreen = ((Boolean) s[2]).booleanValue();
+		MapInfoObject newmap = null;
+		//if (mapChangeModus == 0) mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
+		wantMapTest = true;
+		switch (mapChangeModus) {
+		case NORMAL_KEEP_RESOLUTION:
+			lastHighestResolutionGPSDestScale = -1;
+			newmap = maps.getBestMap(cll, screen, scaleWanted, false);
+			if (newmap == null) newmap = currentMap;
+			if (MapsList.scaleEquals(scaleWanted, newmap)) wantMapTest = false;
+			break;
+		case HIGHEST_RESOLUTION:
+			lastHighestResolutionGPSDestScale = -1;
+			newmap = maps.getBestMap(cll, screen, 0.000001f, false);
+			break;
+		case HIGHEST_RESOLUTION_GPS_DEST:
+			if (gotoPos!= null &amp;&amp; gpsStatus != noGPS &amp;&amp; posCircle.where.isValid()) {
+				if ( ( !posCircleOnScreen ) &amp;&amp; ( lastHighestResolutionGPSDestScale &gt; 0 ) ) {
+					newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale , false);
+				} else {
+					newmap = maps.getMapForArea(posCircle.where, gotoPos.where); // TODO use home-coos if no gps? - consider start from details panel and from gotopanel
+					if (newmap == null)	newmap = maps.getBestMap(cll, screen, 10000000000000000000000000000000000f, false); // use map with most available overview if no map containing PosCircle and GotoPos is available
+
+					if (newmap != null) {
+						lastHighestResolutionGPSDestScale = newmap.scale;
+
+						if (!posCircleOnScreen) {
+							newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale , false);
+						}
+					}
+				}
+			}
+			//	either Goto-Pos or GPS-Pos not set
+			else {
+				lastHighestResolutionGPSDestScale = -1;
+				newmap = maps.getBestMap(cll, screen, 0.000001f, false);
+			}
+			break;
+		default: (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4208, &quot;Bug: \nillegal mapChangeModus: &quot;) + mapChangeModus, MessageBox.OKB)).execute(); break;
+		}
+		if ( newmap != null &amp;&amp; (currentMap == null || !currentMap.mapName.equals(newmap.mapName)) ) {
+			if (loadIfSameScale || !MapsList.scaleEquals(currentMap.scale / currentMap.zoomFactor, newmap) ) {
+				//Vm.debug(&quot;better map found&quot;);
+				setMap(newmap, where);
+				moveScreenXYtoLatLon(new Point(screen.x, screen.y), cll, true);
+			}
+			inBestMap = false;
+			return;
+		}
+		if (currentMap == null &amp;&amp; newmap == null) {
+			// (new MessageBox(&quot;Information&quot;, &quot;F&#252;r die aktuelle Position steht keine Karte zur Verf&#252;ng, bitte w&#228;hlen Sie eine manuell&quot;, MessageBox.OKB)).execute();
+			posCircle.where.set(cll); // choosemap calls setmap with posCircle-coos
+			try {
+				setMap( ((MapListEntry)maps.elementAt(maps.size() - 4)).getMap(), where); // beware: &quot;-4&quot; only works if the empty maps were added last see MapsList.addEmptyMaps
+			} catch (IOException e) { (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4209, &quot;setBestMap: problem in: setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), lat, lon) lat/lon:&quot;) + where.toString(), MessageBox.OKB)).exec(); }
+			while (currentMap == null) { // this actually cannot happen, but maybe in case of an inconstistent code change (esp. regarding empty maps)
+				mmp.chooseMap(); // force the user to select a scale
+				 if (currentMap == null) (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4210, &quot;Moving map cannot run without a map - please select one. \n You can select an empty map&quot;), MessageBox.OKB)).execute();
+			}
+		}
+		inBestMap = false;
+	}
+
+	public void setResModus (int modus) {
+		scaleWanted = currentMap.scale;
+		if (mapChangeModus == modus) return;
+		mapChangeModus = modus;
+		lastHighestResolutionGPSDestScale = -1;
+		if (modus != NORMAL_KEEP_RESOLUTION) setBestMap(posCircle.where, true);
+	}
+	/**
+	 * method to get a point on the screen which must be included in the map
+	 * the map methods are looking for. If the poscircle is on the screen this will be
+	 * that point. If it is outside then the centre of the screen will be used.
+	 *
+	 * returns [0] = CWPoint of that point, [1] Rect describing the screen around it
+	 * @param lat
+	 * @param lon
+	 * @return
+	 */
+	public Object[] getRectForMapChange(CWPoint ll) {
+		int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
+		int h = (height != 0 ? height : pref.myAppHeight);
+		int x, y;
+		CWPoint cll;
+		Boolean posCircleOnScreen = java.lang.Boolean.FALSE;
+		if (posCircleX &gt;= 0 &amp;&amp; posCircleX &lt;= w &amp;&amp; posCircleY &gt;= 0 &amp;&amp; posCircleY &lt;= h &amp;&amp; ll.isValid()) {
+			posCircleOnScreen = java.lang.Boolean.TRUE;
+			x = posCircleX; // posCircle is inside the screen
+			y = posCircleY; // TODO eigentlich interessiert, ob nach dem evtl. Kartenwechsel PosCircle on Screen ist. So wie es jetzt ist, kann 2mal der gleiche Aufruf zum laden unterschiedlicher Karten f&#252;hren, wenn vorher PosCircle nicht auf dem SChirm war, nach dem ersten Laden aber schon.
+			cll = new CWPoint(ll);
+		} else { // when posCircle out of screen - use centre of screen as point which as to be included in the map
+			cll = screenXY2LatLon(w/2, h/2);
+			x = w/2;
+			y = h/2;
+		}
+		Object[] ret = new Object[3];
+		ret[0] = cll;
+		ret[1] = new Rect(x, y, w, h);
+		ret[2] = posCircleOnScreen;
+		return ret;
+	}
+
+	/**
+	 *
+	 * @param betterOverview true: getmap with better overview
+	 * @return
+	 */
+	public void loadMoreDetailedMap(boolean betterOverview){
+		int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
+		int h = (height != 0 ? height : pref.myAppHeight);
+		Rect screen = new Rect(w/2, h/2, w, h);
+
+		CWPoint cll;
+		if (currentMap != null) {
+			cll = screenXY2LatLon(w/2, h/2);
+		} else {
+			cll = new CWPoint(posCircle.where);
+		}
+
+		MapInfoObject m = maps.getMapChangeResolution(cll, screen, currentMap.scale / currentMap.zoomFactor, !betterOverview);
+		if (m != null) {
+			boolean saveGpsIgnStatus = dontUpdatePos;
+			dontUpdatePos = true;
+			setMap(m, cll);
+			setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+			dontUpdatePos = saveGpsIgnStatus;
+		}
+		else (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4211, &quot;No &quot;) +
+				(betterOverview ? MyLocale.getMsg(4212, &quot;less&quot;) : MyLocale.getMsg(4213, &quot;more&quot;) ) +
+				MyLocale.getMsg(4214, &quot; detailed map available&quot;),
+				MessageBox.OKB)).execute();
+	}
+
+	public void loadMapForAllCaches(){
+		Area sur = Global.getProfile().getSourroundingArea(true);
+		if (sur == null) {
+			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4215, &quot;Keine  Caches mit H&#228;ckchen ausgew&#228;hlt&quot;), MessageBox.OKB)).execute();
+			return;
+		}
+		MapInfoObject newmap = maps.getMapForArea(sur.topleft, sur.buttomright);
+		if (newmap == null ) { // no map that includs all caches is available -&gt; load map with lowest resolution
+			Object [] s = getRectForMapChange(posCircle.where);
+			CWPoint cll = (CWPoint) s[0];
+			Rect screen = (Rect) s[1];
+			newmap = maps.getBestMap(cll, screen, Float.MAX_VALUE -1, false);
+		}
+		if (newmap == null) { // no map is covering any area of the caches -&gt; zoom an empty map to cover all caches on screen
+			try {
+				Object [] s = getRectForMapChange(posCircle.where);
+			//	CWPoint cll = (CWPoint) s[0];
+				Rect screen = (Rect) s[1];
+				float neededscalex = (float) (sur.topleft.getDistance(sur.topleft.latDec, sur.buttomright.lonDec) * 1000 / (screen.width-15)); // 15 for the size of the cache image
+				float neededscaley = (float) (sur.topleft.getDistance(sur.buttomright.latDec, sur.topleft.lonDec) * 1000 / (screen.height-15)); // 15 for the size of the cache image
+				newmap = ((MapListEntry)maps.elementAt(maps.size() - 4)).getMap(); // beware: &quot;-4&quot; only works if the empty maps were added last see MapsList.addEmptyMaps
+				newmap.zoom(newmap.scale * newmap.zoomFactor / (neededscalex &gt; neededscaley ? neededscalex : neededscaley), 0, 0);
+				forceMapLoad = true;
+			} catch (IOException e) { (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4279, &quot;loadMapForAllCaches: IO-Exception in: newmap = ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap();&quot;), FormBase.OKB)).exec(); }
+		}
+		boolean saveGpsIgnStatus = dontUpdatePos;
+		dontUpdatePos = true;
+		setMap(newmap, posCircle.where);
+		setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+		dontUpdatePos = saveGpsIgnStatus;
+	}
+
+	public void setGpsStatus (int status) {
+		if (status == gpsStatus) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
+		gpsStatus = status;
+		dontUpdatePos = false;
+		ignoreGps = false;
+		switch (status) {
+		case noGPS: 	{ posCircle.change(null); ignoreGps = true; break; }
+		case gotFix:    { posCircle.change(statusImageHaveSignal); break; }
+		case lostFix:   { posCircle.change(statusImageNoSignal); break; }
+		case noGPSData: { posCircle.change(statusImageNoGps); break; }
+		}
+		mapMoved(0, 0); // positions the posCircle correctly accourding to its size (which can change when the image changes, e.g. from null to something else
+		posCircle.refresh(); // was refreshNow
+	}
+
+	public void snapToGps() {
+		resetCenterOfMap();
+		dontUpdatePos = false;
+		ignoreGps = false;
+		lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
+		lastCompareY = Integer.MAX_VALUE;
+		autoSelectMap = true;
+		forceMapLoad = true;
+		showMap();
+		if (myNavigation.gpsPos.fix &lt;=0) updatePosition(posCircle.where);
+		else updateGps(myNavigation.gpsPos.getFix());
+	}
+
+	/** sets and displays the map
+	 *
+	 * @param newmap
+	 * @param lat move map so that lat/lon is in the centre / -361: don't adust to lat/lon
+	 * @param lon -361: don't adust to lat/lon
+	 */
+	public void setMap(MapInfoObject newmap, CWPoint where) {
+		if (currentMap != null &amp;&amp; newmap.mapName.equals(currentMap.mapName) &amp;&amp; !forceMapLoad) { // note: newmap.mapName == currentMap.mapName won't work because they are different String containing the same text
+			updateOnlyPosition(where, true);
+			return;
+		}
+		Form.showWait();
+		boolean saveIgnoreStatus;
+		saveIgnoreStatus = dontUpdatePos;
+		dontUpdatePos = true;  // make updatePosition ignore calls during loading new map
+		InfoBox inf;
+		inf = new InfoBox(MyLocale.getMsg(4201, &quot;Information&quot;), MyLocale.getMsg(4216, &quot;Loading map...&quot;));
+		inf.show();
+		inf.getWindow().waitUntilPainted(100);
+		try {
+			this.currentMap = newmap;
+			this.title = currentMap.mapName;
+			lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
+			lastCompareY = Integer.MAX_VALUE;
+			if (mmp.mapImage != null ) {
+				//Vm.debug(&quot;free: &quot;+Vm.getUsedMemory(false)+&quot;classMemory: &quot;+Vm.getClassMemory()+ &quot;after garbage collection: &quot;+Vm.getUsedMemory(false));
+				mmp.removeImage(mmp.mapImage); mmp.mapImage.free(); mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+
+				//Vm.debug(&quot;free: &quot;+Vm.getUsedMemory(false)+&quot;classMemory: &quot;+Vm.getClassMemory()+ &quot;after garbage collection: &quot;+Vm.getUsedMemory(false));
+				Vm.getUsedObjectMemory(true); // calls the garbage collection
+			} // give memory free before loading the new map to avoid out of memory error
+			String ImageFilename = currentMap.getImageFilename();
+			if (ImageFilename == null ) {
+				mmp.mapImage = new MapImage();
+				maps.remove(currentMap);
+				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4217, &quot;Could not find image associated with: \n&quot;)+currentMap.fileNameWFL, MessageBox.OKB)).execute();
+			}
+			else {
+				if (ImageFilename.length() &gt; 0) mmp.mapImage = new MapImage(ImageFilename); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
+				else mmp.mapImage = new MapImage(); // no image associated with the calibration info (&quot;empty map&quot;)
+			}
+			mapImage1to1 = mmp.mapImage;
+			mmp.mapImage.properties = mmp.mapImage.properties | AniImage.IsMoveable;
+			if (mapHidden) mmp.mapImage.hide();
+			mmp.mapImage.move(0,0);
+			mmp.addImage(mmp.mapImage);
+			mmp.images.moveToBack(mmp.mapImage);
+			rebuildOverlaySet();
+			forceMapLoad = true; // forces updateOnlyPosition to redraw
+			updateAfterMapChange(where);
+			forceMapLoad = false;
+			directionArrows.setMap(currentMap);
+			updateScale();
+			inf.close(0);  // this doesn't work in a ticked-thread in the eve-vm. That's why i made a new mThread in gotoPanel for ticked
+			Form.cancelWait();
+			dontUpdatePos = saveIgnoreStatus;
+		} catch (IllegalArgumentException e) { // thrown by new AniImage() in eve-vm if file not found;
+			if (mmp.mapImage != null) {
+				mmp.removeImage(mmp.mapImage);
+				mmp.mapImage.free();
+				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+			}
+			rebuildOverlaySet();
+			updateOnlyPosition(where, false);
+			inf.close(0);
+			Form.cancelWait();
+			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4218, &quot;Could not load map: \n&quot;)+ newmap.getImageFilename(), MessageBox.OKB)).execute();
+			dontUpdatePos = saveIgnoreStatus;
+		} catch (OutOfMemoryError e) {
+			if (mmp.mapImage != null) {
+				mmp.removeImage(mmp.mapImage);
+				mmp.mapImage.free();
+				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+			}
+			rebuildOverlaySet();
+			updateOnlyPosition(where, false);
+			inf.close(0);
+			Form.cancelWait();
+			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4219, &quot;Not enough memory to load map: \n&quot;)
+					+ newmap.getImageFilename()
+					+ MyLocale.getMsg(4220, &quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;),
+					MessageBox.OKB)).execute();
+			dontUpdatePos = saveIgnoreStatus;
+		}catch (SystemResourceException e) {
+			if (mmp.mapImage != null) {
+				mmp.removeImage(mmp.mapImage);
+				mmp.mapImage.free();
+				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+			}
+			rebuildOverlaySet();
+			updateOnlyPosition(where, false); // TODO this doesn't work correctly if the resolution changed, I guess because the pixels of PosCircle will be interpreted from the new resolution, but should be interpreted using the old resolution to test: select a map with a much greater value of m per pixel manually
+			inf.close(0);
+			Form.cancelWait();
+			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4221, &quot;Not enough ressources to load map: &quot;)
+					+ newmap.getImageFilename()
+					+ MyLocale.getMsg(4220, &quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;),
+					MessageBox.OKB)).execute();
+			dontUpdatePos = saveIgnoreStatus;
+		}
+	}
+
+	private void updateAfterMapChange(CWPoint newCenter) {
+		if (!posCircle.where.isValid()) {
+			posCircle.where.set(newCenter);
+		}
+		Point circlePosOnMap = currentMap.calcMapXY(posCircle.where);
+		Point centerOnMap = currentMap.calcMapXY(newCenter);
+		int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
+		int h = (height != 0 ? height : pref.myAppHeight);
+		int mapPosX = w/2 - centerOnMap.x;
+		int mapPosY = h/2 - centerOnMap.y;
+		int newPosCircleX = mapPosX + circlePosOnMap.x;
+		int newPosCircleY = mapPosY + circlePosOnMap.y;
+
+		if (mmp != null &amp;&amp; mmp.mapImage != null) mmp.mapImage.move(mapPosX, mapPosY);
+
+		int wCircle = posCircle.getWidth();
+		int hCircle = posCircle.getHeight();
+		int npx = newPosCircleX-wCircle/2;
+		int npy = newPosCircleY-hCircle/2;
+		posCircle.move(npx, npy);
+		posCircleX = newPosCircleX;
+		posCircleY = newPosCircleY;
+
+		updateOnlyPosition(posCircle.where, true);
+	}
+
+	public void hideMap() {
+		if (mmp != null &amp;&amp; mmp.mapImage != null)
+			mmp.mapImage.hide();
+		mapHidden = true;
+		repaintNow();
+	}
+
+	public void showMap() {
+		if (mmp != null &amp;&amp; mmp.mapImage != null) mmp.mapImage.unhide();
+		mapHidden = false;
+		repaintNow();
+	}
+
+	public void setZoomingMode() {
+		mmp.removeImage(buttonImageLens);
+		mmp.addImage(buttonImageLensActivated);
+		repaintNow();
+		zoomingMode = true;
+	}
+
+	/**
+	 * zommes in if w&gt;0 and out if w&lt;0
+	 * @param firstclickpoint
+	 * @param w
+	 * @param h
+	 */
+	public void zoomScreenRect(Point firstclickpoint, int w, int h) {
+		int newImageWidth = (int) (this.width *  (this.width  &lt; 481 ? 2 : 1.6)); // (maximal) size of the zoomed image
+		int newImageHeight= (int) (this.height * (this.width &lt; 481 ?  2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors
+		CWPoint center = screenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y + h/2);
+		float zoomFactor;
+		if (h &lt; 0) {
+			h = java.lang.Math.abs(h);
+			firstclickpoint.y = firstclickpoint.y - h;
+		}
+		if (w &gt; 0) { // zoom in
+			zoomFactor = java.lang.Math.min((float)this.width / (float)w, (float)this.height / (float)h);
+		}
+		else { // zoom out
+			w = java.lang.Math.abs(w);
+			firstclickpoint.x = firstclickpoint.x - w; // make firstclickedpoint the upper left corner
+			zoomFactor = java.lang.Math.max((float)w / (float)this.width, (float)h / (float)this.height);
+		}
+		// calculate rect in unzoomed image in a way that the centre of the new image is the centre of selected area but give priority to the prefered image size of the scaled image
+		newImageHeight = (int) (newImageHeight / zoomFactor / currentMap.zoomFactor);
+		newImageWidth = (int) (newImageWidth / zoomFactor / currentMap.zoomFactor);
+		Point mappos = getMapPositionOnScreen();
+		int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w/2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth /2);
+		int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h/2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight /2);
+		Rect newImageRect = new Rect(xinunscaledimage , yinunscaledimage, newImageWidth, newImageHeight);
+		if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.getImageData() != null)
+		{
+			// try to avoid overlapping by shifting
+			if (newImageRect.x &lt; 0)
+				newImageRect.x = 0; // align left if left overlapping
+			if (newImageRect.y &lt; 0)
+				newImageRect.y = 0;
+			if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth())
+				newImageRect.x = mapImage1to1.getWidth()- newImageWidth; // align right if right overlaping
+			if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight())
+				newImageRect.y = mapImage1to1.getHeight()- newImageHeight;
+			// crop if after shifting still overlapping
+			if (newImageRect.x &lt; 0)
+				newImageRect.x = 0;
+			if (newImageRect.y &lt; 0)
+				newImageRect.y = 0;
+			if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth())
+				newImageRect.width = mapImage1to1.getWidth() - newImageRect.x;
+			if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight())
+				newImageRect.height= mapImage1to1.getHeight()- newImageRect.y;
+		}
+		zoomFromUnscaled(zoomFactor * currentMap.zoomFactor, newImageRect, center);
+	}
+
+	public void zoom1to1() {
+		CWPoint center = screenXY2LatLon(this.width /2 , this.height/2);
+		if (mapImage1to1 != null) zoomFromUnscaled(1, new Rect(0,0,mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
+		else zoomFromUnscaled(1, new Rect(0,0, 1,1), center);
+	}
+
+	/**
+	 * do the actual scaling
+	 * @param zoomFactor relative to original image
+	 * @param newImageRect Rect in the 1:1 image that contains the area to be zoomed into
+	 * @param center
+	 */
+	public void zoomFromUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
+		Form.showWait();
+		boolean savegpsstatus = dontUpdatePos;
+		if (mapImage1to1 != null) {
+			dontUpdatePos = true; // avoid multi-thread problems
+			int saveprop = AniImage.IsMoveable;
+			MapImage tmp = null; // = mmp.mapImage;
+			if (mmp.mapImage != null) {
+				tmp = mmp.mapImage;
+				saveprop = mmp.mapImage.properties;
+				mmp.removeImage(mmp.mapImage);
+				if (mmp.mapImage != mapImage1to1) {
+					mmp.mapImage.free();
+					mmp.mapImage = null;
+				} else tmp = mapImage1to1;
+			}
+			Vm.getUsedObjectMemory(true);
+			try {
+				if (zoomFactor == 1) tmp = mapImage1to1;
+				else tmp = new MapImage(
+						new Picture(
+								ImageTool.scale(
+										mapImage1to1.getImageData(),
+										(int) (newImageRect.width*zoomFactor),
+										(int)(newImageRect.height*zoomFactor),0).getImageData(),0
+										)); //, newImageRect, 0));
+				currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
+			} catch (OutOfMemoryError e) {
+				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;),
+						MyLocale.getMsg(4222, &quot;Out of memory error&quot;), MessageBox.OKB)).execute();
+				//tmp = mapImage1to1;
+			} //if (tmp != null) currentMap.zoom();}
+			Vm.getUsedObjectMemory(true);
+			mmp.mapImage = tmp; // use unscaled or no image in case of OutOfMemoryError
+			mmp.mapImage.properties = saveprop;
+			if (mapHidden) mmp.mapImage.hide();
+			mmp.addImage(mmp.mapImage);
+			mmp.images.moveToBack(mmp.mapImage);
+			if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.getImageData() != null)
+			{
+				Point mappos = getMapPositionOnScreen();
+				mmp.mapImage.move(mappos.x,mappos.y);
+			}
+		} else // no map image loaded
+		{ currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y); }
+		// scaleWanted = currentMap.scale; use this if you want to change automatically to a map scale that best fits the zooming
+		destroyOverlaySet();
+		Vm.getUsedObjectMemory(true); // call garbage collection
+		setCenterOfScreen(center, false);
+		addOverlaySet();
+		updateScale();
+		this.repaintNow();
+		Form.cancelWait();
+		dontUpdatePos = savegpsstatus;
+	}
+
+	/*	public void gotFocus(int how) {
+		super.gotFocus(how);
+		Dimension ws = getSize(null);
+		onWindowResize(ws.width, ws.height);
+		Vm.debug(ws.width + &quot; h: &quot;+ws.height);
+		this.setPreferredSize(width, height)
+	}
+	 */
+	public void onEvent(Event ev){
+		if(ev instanceof FormEvent &amp;&amp; (ev.type == FormEvent.CLOSED )){
+			running = false;
+		}
+		if( ev instanceof KeyEvent &amp;&amp; ev.target == this &amp;&amp; ( (((KeyEvent)ev).key == IKeys.ESCAPE) || (((KeyEvent)ev).key == IKeys.ENTER) || (((KeyEvent)ev).key == IKeys.ACTION) ) ) {
+			this.close(0);
+			ev.consumed = true;
+		}
+		super.onEvent(ev);
+	}
+}
+
+/**
+ *	Class to display the map bitmap and to select another bitmap to display.
+ */
+class MovingMapPanel extends InteractivePanel implements EventListener {
+	Menu kontextMenu;
+	MenuItem gotoMenuItem = new MenuItem(MyLocale.getMsg(4230, &quot;Goto here$g&quot;), 0, null);
+	MenuItem newWayPointMenuItem = new MenuItem(MyLocale.getMsg(4232, &quot;Create new Waypoint here$n&quot;), 0, null);;
+	MenuItem openCacheDescMenuItem,addCachetoListMenuItem;
+
+	MenuItem miLuminary[];
+
+	Menu mapsMenu;
+	MenuItem selectMapMI = new MenuItem(MyLocale.getMsg(4234, &quot;Select a map manually$s&quot;), new IconAndText(new Picture(&quot;map_open.png&quot;), MyLocale.getMsg(4235, &quot;Select a map manually&quot;), null, Graphics.RIGHT));
+	MenuItem changeMapDirMI = new MenuItem(MyLocale.getMsg(4236, &quot;Change map directory$c&quot;), new IconAndText(new Picture(&quot;map_cd.png&quot;), MyLocale.getMsg(4237, &quot;Change map directory&quot;), null, Graphics.RIGHT));
+	MenuItem showMapMI = new MenuItem(MyLocale.getMsg(4238, &quot;Show map&quot;), new IconAndText(new Picture(&quot;map_on.png&quot;), MyLocale.getMsg(4239, &quot;Show map&quot;), null, Graphics.RIGHT));
+	MenuItem hideMapMI = new MenuItem(MyLocale.getMsg(4240, &quot;Hide map&quot;), new IconAndText(new Picture(&quot;map_off.png&quot;), MyLocale.getMsg(4241, &quot;Hide map&quot;), null, Graphics.RIGHT));
+	// automatic
+	MenuItem mapChangeModusMI = new MenuItem(MyLocale.getMsg(4242, &quot;Modus for automatic map change&quot;), MenuItem.Separator, null);;
+	MenuItem highestResGpsDestMI = new MenuItem(MyLocale.getMsg(4244, &quot;Highest res. containing dest. &amp; cur. position&quot;), new IconAndText(new Picture(&quot;res_gps_goto.png&quot;), MyLocale.getMsg(4245, &quot;Highest res. containing dest. &amp; cur. position&quot;), null, Graphics.RIGHT)); //immer h&#246;chste Aufl&#246;sung w&#228;hlen, die akt. Pos. und Ziel enthalten
+	MenuItem highestResolutionMI = new MenuItem(MyLocale.getMsg(4246, &quot;Highest resolution&quot;), new IconAndText(new Picture(&quot;res_high.png&quot;), MyLocale.getMsg(4247, &quot;Highest resolution&quot;), null, Graphics.RIGHT)); //immer h&#246;chste Aufl&#246;sung w&#228;hlen
+	MenuItem keepManResolutionMI = new MenuItem(MyLocale.getMsg(4248, &quot;Keep manual resolution&quot;), new IconAndText(new Picture(&quot;res_manuell.png&quot;), MyLocale.getMsg(4249, &quot;Keep manual resolution&quot;), null, Graphics.RIGHT)); // manuell gew&#228;hlte Aufl&#246;sung beibehalten
+	// manuell
+	MenuItem mapChangeResMI = new MenuItem(MyLocale.getMsg(4250, &quot;Change resolution manually&quot;), MenuItem.Separator, null);;
+	MenuItem AllCachesResMI = new MenuItem(MyLocale.getMsg(4252, &quot;Load a map containing all marked caches&quot;),  new IconAndText(new Picture(&quot;loupe_all.png&quot;), MyLocale.getMsg(4253, &quot;Load a map containing all marked caches&quot;), null, Graphics.RIGHT));
+	MenuItem moreDetailsMI = new MenuItem(MyLocale.getMsg(4254, &quot;Load a map with more details&quot;), new IconAndText(new Picture(&quot;loupe_more_details.png&quot;), MyLocale.getMsg(4255, &quot;Load a map with more details&quot;), null, Graphics.RIGHT)); // laod a map with more details
+	MenuItem moreOverviewMI = new MenuItem(MyLocale.getMsg(4256, &quot;Load a map for a better overview&quot;), new IconAndText(new Picture(&quot;loupe_better_overview.png&quot;), MyLocale.getMsg(4257, &quot;Load a map for a better overview&quot;), null, Graphics.RIGHT)); // Load a map for a better overview --&gt; lesser details
+	// move map to
+	MenuItem moveToMI = new MenuItem(MyLocale.getMsg(4258, &quot;Move map to and load map&quot;), MenuItem.Separator, null);;
+	MenuItem moveToDestMI = new MenuItem(MyLocale.getMsg(4260, &quot;Move to goto point&quot;), new IconAndText(new Picture(&quot;move2goto.png&quot;), MyLocale.getMsg(4261, &quot;Move to goto point&quot;), null, Graphics.RIGHT)); //* Karte zum Ziel verschieben (und ggf. entsprechende Karte laden)
+	MenuItem moveToGpsMI = new MenuItem(MyLocale.getMsg(4262, &quot;Move to GPS position&quot;), new IconAndText(new Picture(&quot;move2gps.png&quot;), MyLocale.getMsg(4263, &quot;Move to GPS position&quot;), null, Graphics.RIGHT));
+	MenuItem moveToCenterMI = new MenuItem(MyLocale.getMsg(4264, &quot;Move to centre&quot;), new IconAndText(new Picture(&quot;move2center.png&quot;), MyLocale.getMsg(4265, &quot;Move to centre&quot;), null, Graphics.RIGHT));
+
+	CacheHolder clickedCache;
+	MovingMap mm;
+	MapImage mapImage;
+	Point saveMapLoc = null;
+	boolean saveGpsIgnoreStatus;
+	boolean paintingZoomArea;
+	ImageList saveImageList = null;
+	int lastZoomWidth , lastZoomHeight;
+	public MovingMapPanel(MovingMap f){
+		this.mm = f;
+		miLuminary = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
+		for (int i=0; i&lt;SkyOrientation.LUMINARY_NAMES.length; i++) {
+			miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i));
+		}
+		set(Control.WantHoldDown, true); // want to get simulated right-clicks
+	}
+
+	public boolean imageBeginDragged(AniImage which,Point pos) {
+		if (mm.zoomingMode == true) { // zoom
+//			saveMapLoc = pos;
+			//		saveGpsIgnoreStatus = mm.ignoreGps;
+			//	mm.ignoreGps = true;
+			return false;
+		}
+		// move (drag) map
+		//if (!(which == null || which == mapImage || which instanceof TrackOverlay || which == mm.directionArrows) ) return false;
+		saveGpsIgnoreStatus = mm.dontUpdatePos;
+		mm.dontUpdatePos = true;
+		saveMapLoc = pos;
+		bringMapToTop();
+		if (mapImage.isOnScreen() &amp;&amp; !mapImage.hidden )
+			return super.imageBeginDragged(mapImage, pos);
+		return super.imageBeginDragged(null, pos);
+	}
+
+	public boolean imageNotDragged(ImageDragContext dc,Point pos){
+		boolean ret = super.imageNotDragged(dc, pos);
+		bringMaptoBack();
+		if (dc.image == null) moveMap(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
+		else mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
+		mm.dontUpdatePos = saveGpsIgnoreStatus;
+		this.repaintNow();
+		return ret;
+	}
+
+	public void onPenEvent(PenEvent ev) {
+		if (!mm.zoomingMode &amp;&amp; ev.type == PenEvent.PEN_DOWN) {
+			saveMapLoc = new Point (ev.x, ev.y);
+		}
+		if (mm.zoomingMode &amp;&amp; ev.type == PenEvent.PEN_DOWN) {
+			saveGpsIgnoreStatus = mm.dontUpdatePos;
+			mm.dontUpdatePos = true;
+			saveMapLoc = new Point (ev.x, ev.y);
+			paintingZoomArea = true;
+			mm.zoomingMode = true;
+		}
+		if (!mm.zoomingMode &amp;&amp; ev.type == PenEvent.PEN_DOWN &amp;&amp; ev.modifiers == PenEvent.RIGHT_BUTTON) {
+			penHeld(new Point (ev.x, ev.y));
+		}
+		if (mm.zoomingMode &amp;&amp; ev.type == PenEvent.PEN_UP ) {
+			paintingZoomArea = false;
+			mm.zoomingMode = false;
+			mm.dontUpdatePos = saveGpsIgnoreStatus;
+			removeImage(mm.buttonImageLensActivated);
+			addImage(mm.buttonImageLens);
+			if (java.lang.Math.abs(lastZoomWidth) &lt; 15 || java.lang.Math.abs(lastZoomHeight) &lt; 15)  {
+				repaintNow();
+				return; // dont make to big zoom jumps - it is most probable not an intentional zoom
+			}
+			mm.zoomScreenRect(saveMapLoc, lastZoomWidth, lastZoomHeight);
+		}
+
+		if (mm.zoomingMode &amp;&amp; paintingZoomArea &amp;&amp; (ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {
+			int left, top;
+			Graphics dr = this.getGraphics().getGraphics();
+			if (lastZoomWidth &lt; 0)left = saveMapLoc.x + lastZoomWidth;
+			else left = saveMapLoc.x;
+			if (lastZoomHeight &lt; 0)top = saveMapLoc.y + lastZoomHeight;
+			else top = saveMapLoc.y;
+			left -= 2;
+			top -= 2;
+			if (top &lt; 0) top = 0;
+			if (left &lt; 0) left = 0;
+			if ((lastZoomWidth &lt;= 0) &amp;&amp; (ev.x - saveMapLoc.x &gt; 0)) { // changed from zooming out to zooming in
+				removeImage(mm.buttonImageLensActivated);
+				removeImage(mm.buttonImageLensActivatedZoomOut);
+				addImage(mm.buttonImageLensActivatedZoomIn);
+				this.repaintNow(dr, new Rect(mm.buttonImageLensActivatedZoomIn.location.x, mm.buttonImageLensActivatedZoomIn.location.y, mm.buttonImageLensActivatedZoomIn.getWidth(), mm.buttonImageLensActivatedZoomIn.getHeight()));
+			}
+			if ((lastZoomWidth &gt;= 0) &amp;&amp; (ev.x - saveMapLoc.x &lt; 0)) { // changed from zooming out to zooming in
+				removeImage(mm.buttonImageLensActivated);
+				removeImage(mm.buttonImageLensActivatedZoomIn);
+				addImage(mm.buttonImageLensActivatedZoomOut);
+				this.repaintNow(dr, new Rect(mm.buttonImageLensActivatedZoomOut.location.x, mm.buttonImageLensActivatedZoomOut.location.y, mm.buttonImageLensActivatedZoomOut.getWidth(), mm.buttonImageLensActivatedZoomOut.getHeight()));
+			}
+			this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth)+4, java.lang.Math.abs(lastZoomHeight)+4));
+			lastZoomWidth = ev.x - saveMapLoc.x;
+			lastZoomHeight =  ev.y - saveMapLoc.y;
+			if (lastZoomWidth &lt; 0) left = saveMapLoc.x + lastZoomWidth;
+			else left = saveMapLoc.x;
+			if (lastZoomHeight &lt; 0)top = saveMapLoc.y + lastZoomHeight;
+			else top = saveMapLoc.y;
+			dr.changePen(new Color(255,0,0),Pen.SOLID,3);
+			dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight)); // bug in eve: thickness parameter is ignored
+		}
+		super.onPenEvent(ev);
+	}
+
+	private void bringMapToTop() {
+		if (mapImage == null || mapImage.hidden) {
+			saveImageList = null;
+			return;
+		}
+		saveImageList = new ImageList();
+		saveImageList.copyFrom(images);
+		images.removeAllElements();
+		images.add(mapImage);
+	}
+	private void bringMaptoBack() {
+		if (saveImageList == null) return;
+		images = saveImageList;
+		saveImageList = null;
+	}
+
+	public void moveMap(int diffX, int diffY) {
+		Point p;
+		if (mapImage!= null) {
+			p = mapImage.locAlways;
+			mapImage.move(p.x+diffX,p.y+diffY);
+			//		if (mm.mapHidden) mapImage.properties |= AniImage.IsInvisible; // this is neccesarry because move will unhide the map if the coos show that the map is on the screen
+		}
+		mapMoved(diffX, diffY);
+	}
+
+	public void mapMoved(int diffX, int diffY){
+		mm.mapMoved(diffX, diffY);
+		this.repaintNow();
+	}
+
+	public void doPaint(Graphics g,Rect area) {
+		super.doPaint(g, area);
+		if (mm.gotoPos != null) {
+			Point dest = mm.getXYonScreen(mm.gotoPos.where);
+			g.changePen(Color.DarkBlue, Pen.SOLID, 3);
+			g.drawLine(mm.posCircleX, mm.posCircleY, dest.x, dest.y);
+		}
+	}
+
+	public void chooseMap() {
+		CWPoint gpspos;
+		if (mm.myNavigation.gpsPos.fix &gt; 0) gpspos = new CWPoint(mm.myNavigation.gpsPos.latDec, mm.myNavigation.gpsPos.lonDec);
+		else gpspos = null;
+		ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos(), mm.currentMap);
+		if(l.execute() == FormBase.IDOK){
+//			Vm.debug(&quot;Trying map: &quot; + l.selectedMap.fileName);
+			mm.autoSelectMap = false;
+			if (l.selectedMap.isInBound(mm.posCircle.where) || l.selectedMap.getImageFilename().length()==0) {
+				mm.setMap(l.selectedMap, mm.posCircle.where);
+				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+				mm.ignoreGps = false;
+			} else {
+				mm.setGpsStatus(MovingMap.noGPS);
+				mm.ignoreGps = true;
+				mm.setMap(l.selectedMap, mm.posCircle.where);
+				if (mm.currentMap.fileNameWFL.length() &gt; 0)
+					mm.setCenterOfScreen(l.selectedMap.center, true); // if map has an image
+				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+				//Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
+				//double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4];
+				//mm.posCircleX = 0; // place map to the upper left corner of windows
+				//mm.posCircleY = 0;
+				//mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
+			}
+		}
+	}
+
+	/**
+	 *	Method to react to user.
+	 */
+	public void imageClicked(AniImage which, Point pos){
+		if (which == mm.buttonImageChooseMap){
+			mapsMenu = new Menu();
+			mapsMenu.addItem(selectMapMI);
+			mapsMenu.addItem(changeMapDirMI);
+			if (!mm.noMapsAvailable)
+			{
+				if (mm.mapHidden) mapsMenu.addItem(showMapMI);
+				else mapsMenu.addItem(hideMapMI);
+			}
+
+			// automatic
+			highestResGpsDestMI.modifiers &amp;= ~MenuItem.Checked;
+			highestResolutionMI.modifiers &amp;= ~MenuItem.Checked;
+			keepManResolutionMI.modifiers &amp;= ~MenuItem.Checked;
+			switch (mm.mapChangeModus) {
+			case MovingMap.NORMAL_KEEP_RESOLUTION: keepManResolutionMI.modifiers |= MenuItem.Checked; break;
+			case MovingMap.HIGHEST_RESOLUTION: highestResolutionMI.modifiers |= MenuItem.Checked; break;
+			case MovingMap.HIGHEST_RESOLUTION_GPS_DEST: highestResGpsDestMI.modifiers |= MenuItem.Checked; break;
+			}
+			mapsMenu.addItem(mapChangeModusMI);
+			mapsMenu.addItem(highestResGpsDestMI);
+			mapsMenu.addItem(highestResolutionMI);
+			mapsMenu.addItem(keepManResolutionMI);
+			// manuell
+			mapsMenu.addItem(mapChangeResMI);
+			mapsMenu.addItem(AllCachesResMI);
+			mapsMenu.addItem(moreDetailsMI);
+			mapsMenu.addItem(moreOverviewMI);
+			// move map to
+			mapsMenu.addItem(moveToMI);
+			if (mm.gotoPos != null) moveToDestMI.modifiers &amp;= ~MenuItem.Disabled;
+			else moveToDestMI.modifiers |= MenuItem.Disabled;
+			mapsMenu.addItem(moveToDestMI);
+			if (Global.getPref().curCentrePt.isValid()) moveToCenterMI.modifiers &amp;= ~MenuItem.Disabled;
+			else moveToCenterMI.modifiers |= MenuItem.Disabled;
+			mapsMenu.addItem(moveToCenterMI);
+			mapsMenu.addItem(moveToGpsMI);
+
+			//m.set(Menu., status)
+			mapsMenu.exec(this, new Point(which.location.x, which.location.y), this);
+		}
+		if (which == mm.buttonImageGpsOn) {
+			this.snapToGps();
+		}
+		if (which == mm.buttonImageLens) {
+			mm.setZoomingMode();
+			lastZoomWidth = 0;
+			lastZoomHeight = 0;
+		}
+		if (which == mm.buttonImageZoom1to1) {
+			mm.zoom1to1();
+		}
+		if (which == mm.buttonImageClose) {
+			WindowEvent tmp = new WindowEvent();
+			tmp.type = WindowEvent.CLOSE;
+			mm.postEvent(tmp);
+		}
+	}
+
+	public void snapToGps() {
+		mm.myNavigation.startGps(mm.pref.logGPS, Convert.toInt(mm.pref.logGPSTimer));
+		mm.snapToGps();
+	}
+
+	public void penHeld(Point p){
+		//	if (!menuIsActive()) doMenu(p);
+		if (!mm.zoomingMode) {
+			//( (ev.type == PenEvent.PEN_DOWN) &amp;&amp; ((PenEvent)ev).modifiers == PenEvent.RIGHT_BUTTON)
+			//|| ((ev.type == PenEvent.RIGHT_BUTTON) ) )) ---&gt; these events are not posted --&gt; this overridering is the only solution
+			kontextMenu = new Menu();
+			if ( !(mm.directionArrows.onHotArea(p.x, p.y)) ) {
+				kontextMenu.addItem(gotoMenuItem);
+				kontextMenu.addItem(newWayPointMenuItem);
+				AniImage clickedOnImage = images.findHotImage(p);
+				if (clickedOnImage != null &amp;&amp; clickedOnImage instanceof MapSymbol) {
+					clickedCache = ((CacheHolder)((MapSymbol)clickedOnImage).mapObject);
+					if (clickedCache != null) {
+						openCacheDescMenuItem = new MenuItem(MyLocale.getMsg(4270, &quot;Open&quot;)+&quot; '&quot;+(clickedCache.cacheName.length()&gt;0 ? clickedCache.cacheName : clickedCache.wayPoint)+&quot;'$o&quot;); // clickedCache == null can happen if clicked on the goto-symbol
+						kontextMenu.addItem(openCacheDescMenuItem);
+						if (Global.mainForm.cacheListVisible) {
+							addCachetoListMenuItem = new MenuItem(MyLocale.getMsg(199,&quot;Add to cachetour&quot;));
+							kontextMenu.addItem(addCachetoListMenuItem);
+						}
+					}
+				}
+			}
+			else {
+				for (int i=0; i&lt;SkyOrientation.LUMINARY_NAMES.length; i++) {
+					kontextMenu.addItem(miLuminary[i]);
+					if (i == mm.myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
+					else miLuminary[i].modifiers &amp;= MenuItem.Checked;
+				}
+			}
+			kontextMenu.exec(this, new Point(p.x, p.y), this);
+		}
+	}
+
+	public void onEvent(Event ev){
+		if (mapsMenu != null &amp;&amp; ev instanceof PenEvent &amp;&amp; ev.type == PenEvent.PEN_DOWN &amp;&amp; ev.target == this) {mapsMenu.close(); mapsMenu = null;}
+		if (kontextMenu != null &amp;&amp; ev instanceof PenEvent &amp;&amp; ev.type == PenEvent.PEN_DOWN &amp;&amp; ev.target == this) {kontextMenu.close(); kontextMenu = null; }
+
+		if (ev instanceof MenuEvent) {
+			if (ev.target == mapsMenu) {
+				if (ev.type == MenuEvent.ABORTED || ev.type == MenuEvent.CANCELLED || ev.type == MenuEvent.FOCUS_OUT) mapsMenu.close(); // TODO menuIsActive() benutzen?
+				if (ev.type == MenuEvent.SELECTED ) {
+					MenuItem action = (MenuItem) mapsMenu.getSelectedItem();
+					if (mapsMenu.getSelectedItem() != null) {
+						//maps
+						if (action == selectMapMI)	{
+							mapsMenu.close();
+							chooseMap();
+						}
+						if (action == changeMapDirMI)	{
+							mapsMenu.close();
+							FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir+&quot;maps&quot;);
+							fc.addMask(&quot;*.wfl&quot;);
+							fc.title=(MyLocale.getMsg(4200,&quot;Select map directory:&quot;));
+							if(fc.execute() != FileChooser.IDCANCEL){
+								Global.getPref().saveCustomMapsPath(fc.getChosen());
+								mm.loadMaps(Global.getPref().getMapLoadPath(), mm.posCircle.where.latDec);
+								mm.forceMapLoad();
+							}
+						}
+						//dont show map
+						if (action == hideMapMI) {
+							mapsMenu.close();
+							mm.hideMap();
+						}
+						// show map
+						if (action == showMapMI) {
+							mapsMenu.close();
+							mm.showMap();
+						}
+						// map change modus
+						if (action == highestResGpsDestMI) {
+							mapsMenu.close();
+							mm.setResModus(MovingMap.HIGHEST_RESOLUTION_GPS_DEST);
+						}
+						if (action == highestResolutionMI) {
+							mapsMenu.close();
+							mm.setResModus(MovingMap.HIGHEST_RESOLUTION);
+						}
+						if (action == keepManResolutionMI) {
+							mapsMenu.close();
+							mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
+						}
+						// manually change map resolution
+						if (action == moreDetailsMI) {
+							mapsMenu.close();
+							mm.loadMoreDetailedMap(false);
+						}
+						if (action == moreOverviewMI) {
+							mapsMenu.close();
+							mm.loadMoreDetailedMap(true);
+						}
+						if (action == AllCachesResMI) {
+							mapsMenu.close();
+							mm.loadMapForAllCaches();
+						}
+						// moveto position
+						if (action == moveToCenterMI) {
+							mapsMenu.close();
+							mm.setCenterOfScreen(Global.getPref().curCentrePt, true);
+						}
+						if (action == moveToDestMI) {
+							mapsMenu.close();
+							mm.setCenterOfScreen(mm.gotoPos.where, true);
+						}
+						if (action == moveToGpsMI) {
+							mapsMenu.close();
+							this.snapToGps();
+						}
+
+					}
+				}
+			} // if (ev.target == mapsMenu)
+			if (ev.target == kontextMenu) {
+				if ((((MenuEvent)ev).type==MenuEvent.SELECTED)) {
+					MenuItem action = (MenuItem) kontextMenu.getSelectedItem();
+					if (action == gotoMenuItem) {
+						kontextMenu.close();
+						mm.myNavigation.setDestination(mm.screenXY2LatLon(saveMapLoc.x, saveMapLoc.y));
+					}
+					if (action == openCacheDescMenuItem) {
+						//mm.onEvent(new FormEvent(FormEvent.CLOSED, mm));
+						kontextMenu.close();
+						WindowEvent close = new WindowEvent();
+						close.target = mm;
+						close.type = WindowEvent.CLOSE;
+						mm.postEvent(close);
+						MainTab mainT = Global.mainTab;
+						mainT.openDescriptionPanel(clickedCache);
+					}
+					if (action == newWayPointMenuItem) {
+						kontextMenu.close();
+						WindowEvent close = new WindowEvent();
+						close.target = mm;
+						close.type = WindowEvent.CLOSE;
+						mm.postEvent(close);
+						CacheHolder newWP = new CacheHolder();
+						newWP.pos = mm.screenXY2LatLon(saveMapLoc.x, saveMapLoc.y);
+						newWP.latLon=newWP.pos.toString();
+						Global.mainTab.newWaypoint(newWP);
+					}
+					if (action == addCachetoListMenuItem) {
+						kontextMenu.close();
+						Global.mainForm.cacheList.addCache(clickedCache.wayPoint);
+					}
+					for (int i=0; i&lt;miLuminary.length; i++) {
+						if (action == miLuminary[i]) {
+							kontextMenu.close();
+							mm.myNavigation.setLuminary(i);
+							mm.updateGps(mm.myNavigation.gpsPos.getFix());
+							miLuminary[i].modifiers |= MenuItem.Checked;
+						} else miLuminary[i].modifiers &amp;= ~MenuItem.Checked;
+					}
+				}
+			} // if (ev.target == kontextMenu)
+		} // if (ev instanceof ControlEvent )
+		super.onEvent(ev);
+	}
+}
+
+
+/**
+ *	Class to display maps to choose from
+ */
+class ListBox extends Form{
+	public MapInfoObject selectedMap; // = new MapInfoObject();
+	Button cancelButton, okButton;
+	List list = new List(4,1,false);
+	public boolean selected = false;
+	Vector maps;
+
+	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos, MapInfoObject curMap){
+		this.title = MyLocale.getMsg(4271, &quot;Maps&quot;);
+		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else
+		// set width to screenwidth *3/4 but to at least 240 if the screen is big engough for 240px width
+		this.setPreferredSize(java.lang.Math.max(MyLocale.getScreenWidth()*3/4, java.lang.Math.min(240, MyLocale.getScreenWidth()) ), MyLocale.getScreenHeight()*3/4);
+		this.maps = maps;
+		MapInfoObject map;
+		MapListEntry ml;
+		String cmp;
+		int oldmap = -1;
+		boolean curMapFound = false;
+		boolean[] inList = new boolean[maps.size()];
+		int row = -1;
+		if (curMap == null) curMapFound = true;
+		if (gotopos != null &amp;&amp; Gps != null) {
+			list.addItem(MyLocale.getMsg(4272, &quot;--- Maps containing GPS and goto pos. ---&quot;));
+			row++;
+			cmp = &quot;FF1&quot;+(new Area(new CWPoint(Gps.latDec, Gps.lonDec), gotopos)).getEasyFindString();
+			for(int i = 0; i&lt;maps.size();i++){
+				ml = (MapListEntry)maps.get(i);
+				try {
+					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
+					map = ml.getMap();
+				} catch (IOException ex) {continue; } // could not read .wfl-file
+				if( map.isInBound(Gps.latDec, Gps.lonDec) &amp;&amp; map.isInBound(gotopos) )
+				{
+					list.addItem(i + &quot;: &quot; + map.mapName);
+					row++;
+					inList[i] = true;
+					if (!curMapFound &amp;&amp; map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+				} else inList[i] = false;
+			}
+		}
+		if (Gps != null) {
+			list.addItem(MyLocale.getMsg(4273, &quot;--- Maps containing curr. position ---&quot;));
+			row++;
+			cmp = &quot;FF1&quot;+Area.getEasyFindString(new CWPoint(Gps.latDec, Gps.lonDec), 30);
+			for(int i = 0; i&lt;maps.size();i++){
+				ml = (MapListEntry)maps.get(i);
+				try {
+					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
+					map = ml.getMap();
+				} catch (IOException ex) {continue; } // could not read .wfl-file
+				if( map.isInBound(Gps.latDec, Gps.lonDec) )
+				{
+					list.addItem(i + &quot;: &quot; + map.mapName);
+					row++;
+					inList[i] = true;
+					if (!curMapFound  &amp;&amp; map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+				}
+			}
+		}
+		if (gotopos != null) {
+			list.addItem(MyLocale.getMsg(4274, &quot;--- Karten des Ziels ---&quot;));
+			row++;
+			cmp = &quot;FF1&quot;+Area.getEasyFindString(gotopos, 30);
+			for(int i = 0; i&lt;maps.size();i++){
+				ml = (MapListEntry)maps.get(i);
+				try {
+					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
+					map = ml.getMap();
+				} catch (IOException ex) {continue; } // could not read .wfl-file
+				if(map.isInBound(gotopos)) {
+					list.addItem(i + &quot;: &quot; + map.mapName);
+					row++;
+					inList[i] = true;
+					if (!curMapFound  &amp;&amp; map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+				}
+			}
+		}
+		list.addItem(MyLocale.getMsg(4275, &quot;--- andere Karten ---&quot;));
+		row++;
+		for(int i = 0; i&lt;maps.size();i++){
+			ml = (MapListEntry)maps.get(i);
+			if(!inList[i]) {
+				list.addItem(i + &quot;: &quot; + ml.filename);
+				row++;
+				if (!curMapFound &amp;&amp; ml.filename.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+			}
+		}
+		list.selectItem(oldmap, true);
+		this.addLast(new cachewolf.MyScrollBarPanel(list),CellConstants.STRETCH, CellConstants.FILL);
+		cancelButton = new Button(MyLocale.getMsg(4276, &quot;Cancel&quot;));
+		cancelButton.setHotKey(0, KeyEvent.getCancelKey(true));
+		this.addNext(cancelButton,CellConstants.STRETCH, CellConstants.FILL);
+		okButton = new Button(MyLocale.getMsg(4277, &quot;Select&quot;));
+		okButton.setHotKey(0, KeyEvent.getActionKey(true));
+		this.addLast(okButton,CellConstants.STRETCH, CellConstants.FILL);
+		okButton.takeFocus(0);
+	}
+	public void mapSelected() {
+		try {
+			selectedMap = null;
+			int mapNum = 0;
+			String it;
+			it = list.getText();
+			if (it != &quot;&quot;){
+				it = it.substring(0,it.indexOf(':'));
+				mapNum = Convert.toInt(it);
+				//	Vm.debug(&quot;Kartennummer: &quot; + mapNum);
+				try {
+				selectedMap = ((MapListEntry)maps.get(mapNum)).getMap();
+				selected = true;
+				this.close(FormBase.IDOK);
+				} catch (IOException e) {
+					(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4278, &quot;Cannot load wfl-file: \n&quot;)
+							+ ((MapListEntry)maps.get(mapNum)).filename, MessageBox.OKB)).execute();
+				}
+			}
+			else {
+				selected = false;
+				this.close(FormBase.IDCANCEL);
+			}
+		}catch (NegativeArraySizeException e) {} // happens in substring when a dividing line selected
+	}
+
+	public void onEvent(Event ev){
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (ev.target == cancelButton){
+				selectedMap = null;
+				selected = false;
+				this.close(FormBase.IDCANCEL);
+			}
+			if (ev.target == okButton || ev.target == list){ // ev.target == list is posted by mList if a selection was double clicked
+				mapSelected();
+			}
+		}
+		super.onEvent(ev);
+	}
+
+	public void  penDoubleClicked(Point where) {
+		mapSelected();
+	}
+}
+
+class ArrowsOnMap extends AniImage {
+	float gotoDir = -361;
+	float sunDir = -361;
+	float moveDir = -361;
+
+	//int minY;
+	Graphics draw;
+	private MapInfoObject map=null;
+
+	Color moveDirColor = new Color(255,0,0); // RED
+	final static Color sunDirColor = new Color(255,255,0); // Yellow
+	//final static Color GREEN = new Color(0,255,0);
+	final static Color gotoDirColor = new Color(0,0,128); // dark blue
+	final static Color northDirColor = new Color(0,0,255); // Blue
+	Point[] sunDirArrow = null;
+	Point[] gotoDirArrow = null;
+	Point[] moveDirArrow = null;
+	Point[] northDirArrow = null;
+	int imageSize = Global.getPref().fontSize * 8;
+	int arrowThickness = imageSize / 28;
+	
+	/**
+	 * @param gd goto direction
+	 * @param sd sun direction
+	 * @param md moving direction
+	 */
+	public ArrowsOnMap(){
+		super();
+		newImage();
+		//	setDirections(90, 180, -90);
+	}
+
+	public void newImage() {
+		Image img;
+		setImage((img=new Image(80,80)).getImageData()); //, Color.White);
+		draw = new Graphics(img);
+	}
+	public void setMap(MapInfoObject m) {
+		map = m;
+		makeArrows();
+	}
+
+	public void setDirections(float gd, float sd, float md ) {
+		if (java.lang.Math.abs(gotoDir - gd) &gt; 1 // to save cpu-usage only update if the is a change of directions of more than 1 degree
+				|| java.lang.Math.abs(sunDir - sd) &gt; 1
+				|| java.lang.Math.abs(moveDir - md) &gt; 1)
+		{
+			//dirsChanged = false;
+			gotoDir = gd;
+			sunDir = sd;
+			moveDir = md;
+			makeArrows();
+		}
+	}
+
+	/**
+	 * draw arrows for the directions of movement and destination waypoint
+	 * @param ctrl the control to paint on
+	 * @param moveDir degrees of movement
+	 * @param destDir degrees of destination waypoint
+	 */
+
+	public void doDraw(Graphics g,int options) {
+		if (map == null || g == null) return;
+		drawArrows(g);
+		return;
+/*		if (!dirsChanged) {
+			g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height); // the transparency with a transparent color doesn't work in eve-vm for pocketpc, it works in java-vm, eve-vm on pocketpc2003
+			return;
+		}
+		dirsChanged = false;
+		//super.doDraw(g, options);
+		draw.setColor(Color.White);
+		draw.fillRect(0, 0, location.width, location.height);
+		minY = Integer.MAX_VALUE;
+		drawArrows(draw);
+		draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw
+		g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
+*/	}
+
+	private void makeArrows(){
+			// draw only valid arrows
+			if (moveDir &lt; 360 &amp;&amp; moveDir &gt; -360) {
+				if (moveDirArrow == null) moveDirArrow = new Point[2];
+				makeArrow(moveDirArrow, moveDir, 1.0f);
+			} else moveDirArrow = null;
+			if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360) {
+				if (gotoDirArrow == null) gotoDirArrow = new Point[2];
+				makeArrow(gotoDirArrow, gotoDir, 1.0f);
+			} else gotoDirArrow = null;
+			if (sunDir &lt; 360 &amp;&amp; sunDir&gt; -360) {
+				if (sunDirArrow == null ) sunDirArrow = new Point[2];
+				makeArrow(sunDirArrow, sunDir, 0.75f);
+			} else sunDirArrow = null;
+			if (java.lang.Math.abs(map.rotationRad) &gt; 1.5 / 180 * java.lang.Math.PI)	{ // show northth arrow only if it has more than 1.5 degree deviation from vertical direction
+				if (northDirArrow == null) northDirArrow = new Point[2];
+				makeArrow(northDirArrow, 0, 1.0f); // north direction
+			} else northDirArrow = null;
+
+			//select moveDirColor according to difference to gotoDir
+			moveDirColor = new Color(255,0,0); // red
+
+			if (moveDirArrow != null &amp;&amp; gotoDirArrow != null)
+			{
+				float diff = java.lang.Math.abs(moveDir - gotoDir);
+				while (diff &gt; 360)
+				{
+					diff -= 360.0f;
+				}
+				if (diff &gt; 180)
+				{
+					diff = 360.0f - diff;
+				}
+
+				if (diff &lt;= 5.0)
+				{
+					moveDirColor = new Color(0,192,0);// darkgreen
+				}
+				else if (diff &lt;= 22.5)
+				{
+					moveDirColor = new Color(0,255,0);// green
+				}
+				else if (diff &lt;= 45.0)
+				{
+					moveDirColor = new Color(255,128,0);// orange
+				}
+			}
+		}
+
+	/**
+	 * make (calculate) Pixel array for a single arrow
+	 * @param g handle for drawing
+	 * @param angle angle of arrow
+	 * @param col color of arrow
+	 */
+	private void makeArrow(Point[] arrow, float angle, float scale) {
+		if (map == null) return;
+
+		float angleRad;
+		int centerX = location.width/2, centerY = location.height/2;
+		if (arrow[0] == null) arrow[0] = new Point();
+		if (arrow[1] == null) arrow[1] = new Point();
+		arrow[0].x = centerX;
+		arrow[0].y = centerY;
+		angleRad = angle * (float)java.lang.Math.PI / 180 + map.rotationRad;
+		arrow[1].x = centerX + (int)(centerX * java.lang.Math.sin(angleRad) * scale);
+		arrow[1].y = centerY - (int)(centerY * java.lang.Math.cos(angleRad) * scale);
+		//	g.setPen(new Pen(Color.Black,Pen.SOLID,7));
+		//	g.drawLine(centerX,centerY,x,y);
+	}
+
+	public void drawArrows(Graphics g) {
+		drawArrow(g, northDirArrow, northDirColor);
+		drawArrow(g, gotoDirArrow, gotoDirColor);
+		drawArrow(g, moveDirArrow, moveDirColor);
+		drawArrow(g, sunDirArrow, sunDirColor);
+	}
+
+	public void drawArrow(Graphics g, Point[] arrow, Color col) {
+		if (arrow == null) return;
+		g.changePen(col,Pen.SOLID,arrowThickness);
+		g.drawLine(arrow[0].x, arrow[0].y, arrow[1].x,arrow[1].y);
+	}
+}
+
+

Added: experiments/EVE/src/cachewolf/navi/Navigate.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/Navigate.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/Navigate.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,260 @@
+package cachewolf.navi;
+
+import eve.fx.Color;
+import java.io.IOException;
+import eve.io.SerialPort;
+import eve.ui.data.SerialPortOptions;
+import java.net.Socket;
+
+import cachewolf.CWPoint;
+import cachewolf.Global;
+import cachewolf.MyLocale;
+import cachewolf.Preferences;
+
+import eve.ui.MessageBox;
+import eve.util.mString;
+import eve.sys.Handle;
+
+/**
+ * Non-Gui Class to handle all things regarding navigation
+ * (GPS, Sun direction etc.)
+ * start offset in localisation file: 4400
+ * @author Pfeffer
+ *
+ */
+public class Navigate {
+	public CWPoint destination = new CWPoint();
+	public CWGPSPoint gpsPos = new CWGPSPoint();
+	public Track curTrack = null;
+	Color trackColor = new Color(255,0,0); // red
+	public CWPoint skyOrientationDir = new CWPoint();
+	public int luminary = SkyOrientation.SUN;
+
+	public GotoPanel gotoPanel = null;
+	public MovingMap movingMap = null;
+	public SerialThread serThread = null;
+	public Preferences pref = Global.getPref();
+	public UpdateThread tickerThread;
+	public boolean gpsRunning = false;
+	boolean lograw = false;
+	int logIntervall = 10;
+
+	public void setGotoPanel(GotoPanel gp) {
+		gotoPanel = gp;
+	}
+	public void setMovingMap (MovingMap mm) {
+		movingMap = mm;
+		if (gpsRunning) mm.gpsStarted();
+	}
+
+	public void startGps(boolean loggingOn, int loggingIntervall) {
+		setRawLogging(loggingOn, loggingIntervall);
+		if (serThread != null) if ((serThread.check() &amp; Handle.Running)!=0) return; // TODO use gpsRunning
+		try {
+			serThread = new SerialThread(pref.mySPO, gpsPos, (pref.forwardGPS ? pref.forwardGpsHost : &quot;&quot;));
+			if (pref.forwardGPS &amp;&amp; !serThread.tcpForward) {
+				(new MessageBox(MyLocale.getMsg(4400, &quot;Warning&quot;),
+						MyLocale.getMsg(4401, &quot;Ignoring error:\n could not forward GPS data to host:\n&quot;)
+						+ pref.forwardGpsHost+&quot;\n&quot; + serThread.lastError
+						+ MyLocale.getMsg(4402, &quot;\nstop and start GPS to retry&quot;), MessageBox.OKB)).exec();
+			}
+			if (gpsPos.latDec == 0 &amp;&amp; gpsPos.lonDec == 0) { // TODO use isValid() // TODO raus damit?
+				gpsPos.latDec = destination.latDec; // setze Zielpunkt als Ausgangspunkt
+				gpsPos.lonDec = destination.lonDec;
+			}
+			serThread.start();
+			startDisplayTimer();
+			gpsRunning = true;
+			curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
+			if (lograw)	gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
+			if (gotoPanel != null) gotoPanel.gpsStarted();
+			if (movingMap != null) movingMap.gpsStarted();
+		} catch (IOException e) {
+			(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;),
+					MyLocale.getMsg(4404, &quot;Could not connect to GPS-receiver.\n Error while opening serial Port &quot;)
+					+ e.getMessage()
+					+ MyLocale.getMsg(4405, &quot;\npossible reasons:\n Another (GPS-)program is blocking the port\nwrong port\nOn Loox: active infra-red port is blocking GPS&quot;),
+					MessageBox.OKB)).execute();
+		} catch (UnsatisfiedLinkError e) {
+			(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;),
+					MyLocale.getMsg(4404, &quot;Could not connect to GPS-receiver.\n Error while opening serial Port &quot;)
+					+ MyLocale.getMsg(4406, &quot;Please copy jave_eve.dll into the directory of the cachewolf program&quot;),
+					MessageBox.OKB)).execute();
+		}
+	}
+
+	public void setRawLogging(boolean on, int intervall) {
+		lograw = on;
+		logIntervall = intervall; // TODO switch on and off during serthread running
+	}
+	public void startDisplayTimer() {
+		tickerThread = new UpdateThread(this, 1000);
+		tickerThread.start();
+	}
+
+	public void stopDisplayTimer(){
+		if (tickerThread != null) tickerThread.stop();
+	}
+
+	public void stopGps() {
+		serThread.stop();
+		stopDisplayTimer();
+		gpsPos.stopLog();
+		gpsRunning = false;
+		if (gotoPanel != null) gotoPanel.gpsStopped();
+		if (movingMap != null) movingMap.gpsStoped();
+	}
+
+	public boolean isGpsPosValid() {
+		return 	serThread != null &amp;&amp; ((serThread.check()&amp;Handle.Running)!=0) &amp;&amp; gpsPos.isValid() ; // &amp;&amp; gpsPos.getfiex();
+
+	}
+
+
+	public void setDestination(String LatLon) {
+		setDestination(new CWPoint(LatLon));
+	}
+
+
+	public void setDestination(CWPoint d) {
+		destination = new CWPoint (d);
+		if (gotoPanel != null) gotoPanel.destChanged(destination);
+		if (movingMap != null) movingMap.destChanged(destination);
+	}
+	/**
+	 * use the constants SkyOrientation.SUN, SkyOrientation.MOON etc.
+	 * @param lu
+	 */
+	public void setLuminary(int lu) {
+		luminary = lu;
+	}
+	public void ticked() {
+		int fix = gpsPos.getFix();
+		if (fix &gt; 0 &amp;&amp; (gpsPos.getSats()&gt;= 0)) {
+			//gpsPosition.printAll();
+			//Vm.debug(&quot;currTrack.add: before&quot;);
+			if (curTrack == null) curTrack = new Track(trackColor);
+			try {
+				curTrack.add(gpsPos);
+			} catch (IndexOutOfBoundsException e) { // track full -&gt; create a new one
+				curTrack = new Track(trackColor);
+				curTrack.add(gpsPos);
+				if (movingMap != null) movingMap.addTrack(curTrack); // TODO maybe gotoPanel should also hold a list of Tracks, because otherwise they will be destroyed if not saved in mmp before
+			}
+			try {
+				SkyOrientation.getSunAzimut(gpsPos.time, gpsPos.date, gpsPos.latDec, gpsPos.lonDec);
+				double jd = SkyOrientation.utc2juliandate(gpsPos.time, gpsPos.date);
+				skyOrientationDir = SkyOrientation.getLuminaryDir(luminary, jd, gpsPos);
+				// eve.sys.Vm.debug(&quot;neu: &quot;+ skyOrientationDir.lonDec+ &quot;jd: &quot; + jd);
+			} catch (NumberFormatException e) { // irgendeine Info zu Berechnung des Sonnenaziumt fehlt (insbesondere Datum und Uhrzeit sind nicht unbedingt gleichzeitig verf&#252;gbar wenn es einen Fix gibt)
+				skyOrientationDir.set(-361, -361); // any value out of range (bigger than 360) will prevent drawArrows from drawing it
+			}
+
+		} else {
+			skyOrientationDir.set(-361, -361); // any value out of range (bigger than 360) will prevent drawArrows from drawing it
+		}
+		gotoPanel.updateGps(fix);
+		if (movingMap != null) movingMap.updateGps(fix);
+	}
+}
+
+/**
+ * Thread for reading data from COM-port
+ *
+ */
+class SerialThread extends eve.sys.Task{
+	SerialPort comSp;
+	byte[] comBuff = new byte[1024*10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
+	int comLength = 0;
+	CWGPSPoint myGPS;
+	boolean run, tcpForward;
+	Socket tcpConn;
+	String lastError = &quot;&quot;;
+
+	public SerialThread(SerialPortOptions spo, CWGPSPoint GPSPoint, String forwardIP) throws IOException {
+		try{
+			spo.portName = cachewolf.utils.Common.fixSerialPortName(spo.portName);
+			comSp = new SerialPort(spo);
+		} catch (IOException e) {
+			throw new IOException(spo.portName);
+		} // catch (UnsatisfiedLinkError e) {} // TODO in original java-vm
+		if (forwardIP.length()&gt;0) {
+			try {
+				tcpConn = new Socket(forwardIP, 23);
+				tcpForward = true;
+			} catch (java.net.UnknownHostException e) { tcpForward = false; lastError = e.getMessage();
+			} catch (IOException e) { tcpForward = false; lastError = e.getMessage();
+			}
+		}
+		myGPS = GPSPoint;
+	}
+
+	public void doRun() {
+		int noData = 0;
+		int notinterpreted = 0;
+		run = true;
+		while (run){
+				sleep(1000);
+				//Vm.debug(&quot;Loop? &quot; + noData);
+				noData++;
+				if (noData &gt; 5) { myGPS.noDataError(); }
+			if (comSp != null)	{
+//TODO Activate				comLength = comSp.nonBlockingRead(comBuff, 0 ,comBuff.length);
+				//Vm.debug(&quot;Length: &quot; + comBuff.length);
+				if (comLength &gt; 0)	{
+					noData = 0;
+					String str = mString.fromAscii(comBuff, 0, comLength);
+					if (tcpForward) {
+						try {
+							tcpConn.getOutputStream().write(comBuff, 0, comLength);
+						} catch (IOException e) { tcpForward = false; }
+					}
+					//Vm.debug(str);
+					if (myGPS.examine(str)) notinterpreted = 0; else notinterpreted++;
+					if (notinterpreted &gt; 22) myGPS.noInterpretableData();
+				}
+			}
+		} // while
+		myGPS.noData();
+		try {
+			tcpConn.close();
+		} catch (Exception ex) {};
+	}
+
+	public void stop() {
+		try {
+			run = false;
+			if (comSp != null) comSp.close();
+		} catch(IOException ex) {}
+	}
+}
+
+/**
+ * Class for creating a new mThread to create timer ticks to be able to do form.close in the ticked-thread.
+ * Using the Vm.requestTimer-Method causes &quot;eve.sys.EventDirectionException: This task cannot be done within
+ * a Timer Tick.&quot; in the eve-vm when form.close is called.
+ */
+
+class UpdateThread extends eve.sys.Task {
+	public boolean run;
+	public int calldelay;
+	public Navigate ticked;
+
+	public UpdateThread (Navigate gp, int cd) {
+		ticked = gp;
+		calldelay = cd;
+	}
+
+	public void doRun () {
+		run = true;
+		while (run) {
+			sleep (calldelay);
+			ticked.ticked();
+		}
+	}
+
+	public void stop() {
+		run = false;
+	}
+}
+

Added: experiments/EVE/src/cachewolf/navi/SelectMap.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/SelectMap.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/SelectMap.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,88 @@
+package cachewolf.navi;
+
+import cachewolf.Global;
+import cachewolf.InfoBox;
+import cachewolf.MyLocale;
+import eve.io.*;
+import eve.sys.*;
+import eve.ui.*;
+import eve.ui.event.ControlEvent;
+import eve.ui.event.ListEvent;
+
+/**
+*	This class displays a user interface to select maps that should be or are already calibrated
+*	class id = 4100
+*/
+public class SelectMap extends Form{
+	ScrollBarPanel top;
+	ScrollBarPanel bot;
+	Button mBCancel, mBLoad;
+	String mapsPath = &quot;&quot;;
+	eve.ui.List nonCMaps = new eve.ui.List(3,1,false);
+	eve.ui.List CMaps = new eve.ui.List(3,1,false);
+	String dateien[];
+	String selectedMap = &quot;&quot;;
+	public boolean worldfileexists = false;
+	
+	public SelectMap(){
+		mapsPath = Global.getPref().getMapManuallySavePath(false)+&quot;/&quot;; //  File.getProgramDirectory() + &quot;/maps/&quot;;
+		top = new cachewolf.MyScrollBarPanel(CMaps);
+		bot = new cachewolf.MyScrollBarPanel(nonCMaps);
+		this.title = MyLocale.getMsg(4101,&quot;Maps&quot;);
+		this.addLast(new Label(MyLocale.getMsg(4102,&quot;Calibrated Maps&quot;)), CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(top, CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(new Label(MyLocale.getMsg(4103,&quot;Non Calibrated Maps&quot;)), CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(bot, CellConstants.STRETCH, CellConstants.FILL);
+		this.addNext(mBCancel = new Button(MyLocale.getMsg(4104,&quot;Cancel&quot;)),CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(mBLoad = new Button(MyLocale.getMsg(4105,&quot;Open&quot;)),CellConstants.STRETCH, CellConstants.FILL);
+		InfoBox inf = new InfoBox(&quot;Info&quot;, MyLocale.getMsg(4109,&quot;Loading maps...&quot;)); 
+		inf.show();
+		try{
+			File files = new File(mapsPath);
+			File checkWFL;
+			String rawFileName;
+			dateien = files.listMultiple(&quot;*.png,*.jpg,*.gif,*.bmp&quot;, File.LIST_FILES_ONLY);
+			for(int i = 0; i &lt; dateien.length;i++){
+				rawFileName = dateien[i].substring(0, dateien[i].lastIndexOf(&quot;.&quot;));
+				checkWFL = new File(mapsPath + rawFileName + &quot;.wfl&quot;);
+				
+				if(checkWFL.exists()){
+					CMaps.addItem(rawFileName);
+				} else {
+					nonCMaps.addItem(rawFileName);
+				}
+			}
+		}catch(Exception ex){
+			//Vm.debug(&quot;Problem retrieveing map files&quot;);
+		}
+		inf.close(0);
+	}
+	
+	public void onEvent(Event ev){
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if(ev.target == mBCancel){
+				this.close(0);
+			}
+			if(ev.target == mBLoad){
+				this.close(0);
+			}
+		}
+		if(ev instanceof ListEvent &amp;&amp; ev.type == ListEvent.SELECTED){
+			if(ev.target == nonCMaps){
+				selectedMap = nonCMaps.getText();
+				CMaps.deleteSelection();
+				worldfileexists = false;
+			}
+			if(ev.target == CMaps){
+				selectedMap = CMaps.getText();
+				nonCMaps.deleteSelection();
+				worldfileexists = true;
+			}
+		}
+		super.onEvent(ev);
+	}
+	
+	public String getSelectedMap(){
+		return selectedMap;
+	}
+}
\ No newline at end of file

Added: experiments/EVE/src/cachewolf/navi/SkyOrientation.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/SkyOrientation.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/SkyOrientation.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,354 @@
+package cachewolf.navi;
+
+import cachewolf.CWPoint;
+import cachewolf.MyLocale;
+import eve.sys.Convert;
+
+/** Class to caculate positions of luminaries
+ * all methods are static
+ * usage:
+ * call utc2juliandate and then getLuminaryDir
+ * in ressources/cachewolf.languages messege numbers from 6100
+ * 
+ * @author Pfeffer
+ *
+ */
+public class SkyOrientation {
+
+	public final static int SUN = 0;
+	public final static int MOON = 1;
+	public static final int ALIOTH = 2; // brightest star in Grater Bear (Grosser Wagen) Rektaszension 12 h 54 m 2 s Deklination +55 Grad 57' 36&quot;
+	public static final int GREATER_BEAR = ALIOTH;
+	public static final int ALNILAM = 3; //Orion = Alnilam = mittlerer Guertelstern Aequinoktium 2000): Rektaszension 5h36m13s; Deklination -1 Grad 12'7&quot;
+	public static final int ORION = ALNILAM; 
+	public static final int CASSIOPEIA_GAMMA = 4; // Kassiopeia Gamma: 00h 56m 42.50s	+60 Grad 43' 00.3&quot;
+	public static final int CASSIOPEIA = CASSIOPEIA_GAMMA;
+	public static final int DENEB = 5;
+	public static final int CYGNUS = DENEB; // Cygnus = Schwan
+	public static final int MIMOSA = 6; // second brightest star in Southern Cross
+	public static final int SOUTHERN_CROSS = MIMOSA; // SOUTHERN_CROSS = Kreus des S&#252;dens = Crux australia
+	
+	public static final CWPoint[] STARS = {
+		// (Deklination, Rektaszension)
+		/*ALIOTH*/		new CWPoint(55. +57./60. + 36./3600., (12. + 54./60. + 2./3600.)*15.), // ALIOTH: Rektaszension 12 h 54 m 2 s Deklination +55 Grad 57' 36&quot;
+		/*ALNILAM*/		new CWPoint(-1. -12./60. -7./3600., (5.+36./60. + 13./3600.)*15.), // (-1. -12./60. -7./3600., (5. + 36./60. + 13./3600.)*15.) &lt;- wikipedia // -1.19748, 5.60978 * 15.) &lt;- www.... // (-1. -11./60. -52./3600., (5. + 36./60. + 35./3600.)*15.)  &lt;- Stellarium 
+		/*Cassiopeia*/	new CWPoint(60. + 43./60. + 0.3/3600., (0 + 56./60. +42.5/3600.)*15.), // CASSIOPALA_GAMMA 00h 56m 42.50s, 60 Grad 43' 00.3&quot; &lt;-- wikipedia, Stellarium: 57m 11s, 60 Grad 45' 29&quot;
+		/*Deneb*/		new CWPoint(45. + 16./60. + 49.2/3600., (20 + 41./60. +25.6/3600.)*15.), // im Schwan (Sommerdreieck) Quelle: Stellarium
+		/*Mimosa*/		new CWPoint(-59. - 41./60. - 19./3600., (12 + 47./60. +43.2/3600.)*15.) // im Schwan (Sommerdreieck) Quelle: Stellarium
+		// Sirius
+	};
+	
+	public static final String [] LUMINARY_NAMES = { 
+		MyLocale.getMsg(6100, &quot;Sun&quot;), 
+		MyLocale.getMsg(6101, &quot;Moon&quot;), 
+		MyLocale.getMsg(6102, &quot;Grater Bear&quot;),
+		MyLocale.getMsg(6103, &quot;Orion&quot;),
+		MyLocale.getMsg(6104, &quot;Cassiopeia&quot;), 
+		MyLocale.getMsg(6105, &quot;Cygnus&quot;),
+		MyLocale.getMsg(6106, &quot;Southern Cross&quot;)
+	};
+
+	public static final String [] LUMINARY_DESC = {
+		MyLocale.getMsg(6100, &quot;Sun&quot;), 
+		MyLocale.getMsg(6101, &quot;Moon&quot;), 
+		MyLocale.getMsg(6122, &quot;Alioth in Greater Bear&quot;),
+		MyLocale.getMsg(6123, &quot;Alnilam in Orion&quot;),
+		MyLocale.getMsg(6124, &quot;Cassiopeia Gamma&quot;), 
+		MyLocale.getMsg(6125, &quot;Deneb in Cygnus&quot;),
+		MyLocale.getMsg(6126, &quot;Becrux in Southern Cross&quot;)
+	};
+
+	/**
+	 * Get the friendly name of the luminary
+	 * @param luminary
+	 * @return
+	 */
+	public static String getLuminaryName(int luminary) {
+		return LUMINARY_NAMES[luminary]; 
+	}
+	
+	/**
+	 * Get a more exact description of the luminary 
+	 * @param lu
+	 * @return
+	 */
+	public static String getLuminaryDesc(int lu) {
+		return LUMINARY_DESC[lu];
+	}
+
+	/**
+	 * get azimuth from north and elevation for horizont for a given 
+	 * Luminary (planet or star) 
+	 * @param luminary one of SUN, MOON, ALIOTH, GRAETER_BEAR, ALNILAM, ORION, CASSIOPEIA_GAMMA, CASSIOPEIA
+	 * @param jd julian date must be calculated in advance e.g. from utc2julian
+	 * @param onEarth place on earth of the observer
+	 * @return lon = azimuth from north, lat = elevation from horizont
+	 */
+	public static CWPoint getLuminaryDir(int luminary, double jd, CWPoint onEarth) {
+		switch (luminary) {
+		case SUN: return getSunDir(jd, onEarth);
+		case MOON: return getMoonDir(jd, onEarth);
+		default: 
+			return equatorial2AzimutCoos(onEarth, jd, STARS[luminary-MOON-1]);
+		}
+	}
+
+	/**
+	 * @param utc in the format as it comes from gps DDMMYY
+	 * @param datum in the format as it comes from gps HHMMSS
+	 * @return juliandate
+	 * @throws NumberFormatException if utc / datum could not be parsed successfully
+	 */
+	public static double utc2juliandate(String utc, String datum) {
+		try {
+			int tag, monat, jahr, stunde, minute, sekunde;
+			tag     = Convert.parseInt(datum.substring(0, 2));
+			monat   = Convert.parseInt(datum.substring(2, 4));
+			jahr    = Convert.parseInt(datum.substring(4, 6)) + 2000;
+			stunde  = Convert.parseInt(utc.substring(0, 2));
+			minute  = Convert.parseInt(utc.substring(2, 4));
+			sekunde = Convert.parseInt(utc.substring(4, 6)); // Kommastellen werden abgeschnitten
+			// julianisches &quot;Datum&quot; jd berechnen (see <A HREF="http://de.wikipedia.org/wiki/Julianisches_Datum">http://de.wikipedia.org/wiki/Julianisches_Datum</A> )
+			if (monat&lt;2) {jahr--; monat+=12;} // verlegung des Jahres Endes auf Feb macht Berechnung von SChaltjahren einfacher
+			double a = (int)java.lang.Math.floor(jahr/100.); // Alle hundert Jahre kein Schlatjahr (abrunden)
+			double b = 2 - a + java.lang.Math.floor(a/4.);
+			double jd = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*(monat+1.)) + tag + ((double)stunde)/24 + ((double)minute)/1440 + (double)sekunde/86400 + b - 1524.5;
+			return jd;
+			//double jd0 = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*((double)monat+1.)) +(double)tag + b - 1524.5;
+		} catch (IndexOutOfBoundsException e) {
+			// wird von substring geworfen wenn datum / utc nicht genug Ziffern haben
+			// NumberFormatException wird au&#223;erdem von Convert.ParseInt direkt geworfen wenn
+			// nicht in Int konvertiert werden kann
+			throw new NumberFormatException();
+		}
+	}
+
+	/**
+	 * old version, gives the same as the new one
+	 * @param utc
+	 * @param datum
+	 * @param lat
+	 * @param lon
+	 * @return
+	 */
+	public static float getSunAzimut (String utc, String datum, double lat, double lon) {
+		//	(new MessageBox(&quot;test&quot;, &quot;utc:&quot;+utc+&quot; datum: &quot;+datum+&quot;, lat: &quot;+lat+&quot;, len: &quot;+lon, MessageBox.OKB)).exec();
+		try {
+			int tag, monat, jahr, stunde, minute, sekunde;
+			tag = Convert.parseInt(datum.substring(0, 2));
+			monat = Convert.parseInt(datum.substring(2, 4));
+			jahr = Convert.parseInt(datum.substring(4, 6)) + 2000;
+			stunde=Convert.parseInt(utc.substring(0, 2));
+			minute=Convert.parseInt(utc.substring(2, 4));
+			sekunde=Convert.parseInt(utc.substring(4, 6)); // Kommastellen werden abgeschnitten
+			// julianisches &quot;Datum&quot; jd berechnen (see <A HREF="http://de.wikipedia.org/wiki/Julianisches_Datum">http://de.wikipedia.org/wiki/Julianisches_Datum</A> )
+			if (monat&lt;2) {jahr--; monat+=12;} // verlegung des Jahres Endes auf Feb macht Berechnung von SChaltjahren einfacher
+			double a = (int)java.lang.Math.floor(jahr/100.); // Alle hundert Jahre kein Schlatjahr (abrunden)
+			double b = 2 - a + java.lang.Math.floor(a/4.);
+			double jd = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*(monat+1.)) + tag + (stunde*3600 + minute*60 + sekunde)/86400. + b - 1524.5;
+			double jd0 = java.lang.Math.floor(365.25*(jahr + 4716.)) + java.lang.Math.floor(30.6001*(monat+1.)) +tag + b - 1524.5;
+			// Ekliptikalkoordinaten der Sonne berechnen (see <A HREF="http://de.wikipedia.org/wiki/Sonnenstand">http://de.wikipedia.org/wiki/Sonnenstand</A> )
+			double n = jd - 2451545.0;
+			double l = 280.46 + 0.9856474 * n;
+			double g = 357.528 + 0.9856003 * n;
+			double d = l + 1.915*java.lang.Math.sin(g/180*java.lang.Math.PI) + 0.02 * java.lang.Math.sin(2*g/180*java.lang.Math.PI);
+			// Rektaszension alpha und Deklination delta der Sonne berechnen
+			double e = 23.439 -0.0000004 * n;
+			double alphaNenner = java.lang.Math.cos(d/180*java.lang.Math.PI);
+			double alpha = 180/java.lang.Math.PI*java.lang.Math.atan(java.lang.Math.cos(e/180*java.lang.Math.PI)*java.lang.Math.sin(d/180*java.lang.Math.PI)/alphaNenner);
+			double delta = 180/java.lang.Math.PI*java.lang.Math.asin(java.lang.Math.sin(e/180*java.lang.Math.PI)*java.lang.Math.sin(d/180*java.lang.Math.PI) );
+			if (alphaNenner&lt;0) {alpha +=180;}
+			// Azimut
+			double t0 = (jd0 - 2451545.)/36525.; // schon in t0 bzw jd0 richtig berechnet?
+			double thetaHG = 6.697376 + 2400.05134 * t0 + 1.002738 * (stunde*3600 + minute*60 + sekunde)/3600.;
+			double theta = thetaHG * 15. + lon;
+			double azimutNenner = java.lang.Math.cos((theta-alpha)/180*java.lang.Math.PI)*java.lang.Math.sin(lat/180*java.lang.Math.PI)-
+			java.lang.Math.tan(delta/180*java.lang.Math.PI)*java.lang.Math.cos(lat/180*java.lang.Math.PI);
+			float azimut = (float) java.lang.Math.atan(java.lang.Math.sin((theta-alpha)/180*java.lang.Math.PI)/
+					azimutNenner);
+			azimut = (float) (azimut * 180f / java.lang.Math.PI);
+			if (azimutNenner&lt;0) azimut +=180.;
+			// null = Sueden auf Null = Norden umrechnen
+			azimut +=180.;
+			if (azimut &gt;360.) azimut -=360.;
+			//eve.sys.Vm.debug(&quot;sunAzimut1: &quot; + azimut);
+			//eve.sys.Vm.debug(&quot;sun Elevation: &quot; +getSunAzimut2 (utc, datum, lat, lon).latDec);
+			//CWPoint MoonDir = getMoonDir(jd, new CWPoint(lat, lon));
+			//eve.sys.Vm.debug(&quot;Moon Elevation: &quot; + MoonDir.latDec + &quot;Moon Azimut: &quot; + MoonDir.lonDec);
+			//CWPoint OrionDir = getAlnilamDir(jd, new CWPoint(lat, lon));
+			//eve.sys.Vm.debug(&quot;Alnilam (Orion) Elevation: &quot; + OrionDir.latDec + &quot;Alnilam (Orion) Azimut: &quot; + OrionDir.lonDec );
+			
+			return azimut;
+		} catch (IndexOutOfBoundsException e) {
+			// wird von substring geworfen wenn datum / utc nicht genug Ziffern haben
+			// NumberFormatException wird ausserdem von Convert.ParseInt direkt geworfen wenn
+			// nicht in Int konvertiert werden kann
+			throw new NumberFormatException();
+		}
+	}
+
+	public static CWPoint getSunAzimut2 (String utc, String datum, double lat, double lon) {
+		double jd = utc2juliandate(utc, datum);
+		CWPoint eclCoos = getSunEclipticCoos(jd);
+		// calculate ecliptic coos
+		// convert coos
+		return ecliptic2AzimutCoos(new CWPoint(lat, lon), jd, eclCoos);
+	}
+
+	public static CWPoint getSunDir (double jd, CWPoint onEarth) {
+		CWPoint eclCoos = getSunEclipticCoos(jd);
+		// calculate ecliptic coos
+		// convert coos
+		return ecliptic2AzimutCoos(onEarth, jd, eclCoos);
+	}
+
+	public static CWPoint getMoonDir(double jd, CWPoint onEarth) {
+		CWPoint eclCoo = getMoonEclipticCoos(jd);
+		return ecliptic2AzimutCoos(onEarth, jd, eclCoo);
+	}
+
+	public static CWPoint getAlnilamDir(double jd, CWPoint onEarth) {
+		// Koordinaten Alnilam (mittlerer Guertelstern des Orion), Rektaszension 5h36m13s; Deklination -1&#176;12'7 TODO Aequinoktium 2000
+		// Source: wikipedia
+		return equatorial2AzimutCoos(onEarth, jd, new CWPoint(-1. -12./60. -7./3600., (5. + 36./60. + 13./3600.)*15.) ); // (-1. -12./60. -7./3600., (5. + 36./60. + 13./3600.)*15.) &lt;- wikipedia // -1.19748, 5.60978 * 15.) &lt;- www.... // (-1. -11./60. -52./3600., (5. + 36./60. + 35./3600.)*15.)  &lt;- Stellarium
+	}
+
+	/**
+	 * get the ecliptic coordinates of the sun
+	 * @param juliandate
+	 * @return
+	 */
+	public static CWPoint getSunEclipticCoos(double juliandate) {
+		double n = juliandate - 2451545.0;
+		double l = 280.46 + 0.9856474 * n;
+		double g = 357.528 + 0.9856003 * n;
+		double lambda = l + 1.915*java.lang.Math.sin(g/180*java.lang.Math.PI) + 0.02 * java.lang.Math.sin(2*g/180*java.lang.Math.PI);
+		return new CWPoint(0, lambda);
+	}
+
+
+	// the following code is adopted from <A HREF="http://lexikon.astronomie.info/java/sunmoon/sunmoon.html">http://lexikon.astronomie.info/java/sunmoon/sunmoon.html</A>
+	// ignores the time difference between juliandate and TDT, which is something like 1 minute
+	public static CWPoint getMoonEclipticCoos(double julianDate) {
+		final double DEG = Math.PI / 180;  
+		final double RAD = 1/DEG;
+		double sunAnomalyMean = 360*DEG/365.242191*(julianDate - 2447891.5) + 279.403303*DEG - 282.768422*DEG;
+		double D = julianDate-2447891.5;
+
+		// Mean Moon orbit elements as of 1990.0
+		double l0 = 318.351648*DEG;
+		double P0 =  36.340410*DEG;
+		double N0 = 318.510107*DEG;
+		double i  = 5.145396*DEG;
+
+		double l = 13.1763966*DEG*D+l0;
+		double MMoon = l-0.1114041*DEG*D-P0; // Moon's mean anomaly M
+		double N = N0-0.0529539*DEG*D;       // Moon's mean ascending node longitude
+
+		double sunlon = getSunEclipticCoos(julianDate).lonDec; 
+		double C = l-sunlon;
+		double Ev = 1.2739*DEG*Math.sin(2*C-MMoon);
+		double Ae = 0.1858*DEG*Math.sin(sunAnomalyMean);
+		double A3 = 0.37*DEG*Math.sin(sunAnomalyMean);
+
+		double MMoon2 = MMoon+Ev-Ae-A3;  // corrected Moon anomaly
+		double Ec = 6.2886*DEG*Math.sin(MMoon2);  // equation of centre
+		double A4 = 0.214*DEG*Math.sin(2*MMoon2);
+		double l2 = l+Ev+Ec-Ae+A4; // corrected Moon's longitude
+		double V = 0.6583*DEG*Math.sin(2*(l2-sunlon));
+
+		double l3 = l2+V; // true orbital longitude;
+		double N2 = N-0.16*DEG*Math.sin(sunAnomalyMean);
+
+		CWPoint moonCoor = new CWPoint();  
+		moonCoor.lonDec = (( N2 + Math.atan2( Math.sin(l3-N2)*Math.cos(i), Math.cos(l3-N2) ) ) * RAD)% 360;
+		moonCoor.latDec = Math.asin( Math.sin(l3-N2)*Math.sin(i) ) * RAD;
+		//moonCoor.orbitLon = l3;
+		return moonCoor;
+
+		/*
+		double e  = 0.054900;
+		double a  = 384401; // km
+		double diameter0 = 0.5181*DEG; // angular diameter of Moon at a distance
+		double parallax0 = 0.9507*DEG; // parallax at distance a
+
+		  // relative distance to semi mayor axis of lunar oribt
+		  moonCoor.distance = (1-sqr(e)) / (1+e*Math.cos(MMoon2+Ec) );
+		  moonCoor.diameter = diameter0/moonCoor.distance; // angular diameter in radians
+		  moonCoor.parallax = parallax0/moonCoor.distance; // horizontal parallax in radians
+		  moonCoor.distance *= a;	// distance in km
+
+		  // Age of Moon in radians since New Moon (0) - Full Moon (pi)
+		  moonCoor.moonAge = Mod2Pi(l3-sunCoor.lon);   
+		  moonCoor.phase   = 0.5*(1-Math.cos(moonCoor.moonAge)); // Moon phase, 0-1
+
+		  var phases = new Array(&quot;Neumond&quot;, &quot;Zunehmende Sichel&quot;, &quot;Erstes Viertel&quot;, &quot;Zunnehmender Mond&quot;, 
+		  	&quot;Vollmond&quot;, &quot;Abnehmender Mond&quot;, &quot;Letztes Viertel&quot;, &quot;Abnehmende Sichel&quot;, &quot;Neumond&quot;);
+		  var mainPhase = 1./29.53*360*DEG; // show 'Newmoon, 'Quarter' for +/-1 day arond the actual event
+		  var p = Mod(moonCoor.moonAge, 90.*DEG);
+		  if (p &lt; mainPhase || p &gt; 90*DEG-mainPhase) p = 2*Math.round(moonCoor.moonAge / (90.*DEG));
+		  else p = 2*Math.floor(moonCoor.moonAge / (90.*DEG))+1;
+		  moonCoor.moonPhase = phases[p];
+
+		  moonCoor.sign = Sign(moonCoor.lon);
+		  return (float) moonCoor.lonDec;
+		return 0;
+	}
+		 */
+	}
+
+	public static CWPoint ecliptic2AzimutCoos(CWPoint onEarth, double julianDate, CWPoint ecliptic) {
+		CWPoint equat = ecliptic2Equatorial(ecliptic, julianDate);
+		return equatorial2AzimutCoos(onEarth, julianDate, equat);
+	}
+	/**
+	 * convert rektaszension alpha and deklination delta to azimuth / elevation
+	 * @param onEarth pos. on earth for which the azimut is wanted
+	 * @param julianDate
+	 * @param equatorial: lonDec = rektaszension (alpha), latDec = Deklination (delta)
+	 * @return lonDec: azimuth in degrees from north, lat: elevation in degrees from horizont
+	 * alogithism from wikipedia sonnenbahn
+	 */
+	public static CWPoint equatorial2AzimutCoos(CWPoint onEarth, double julianDate, CWPoint equatorial) {
+		double stunde = ((julianDate + 0.5) % 1) * 24;
+		double jd0 = julianDate - stunde /24; // julian date at UTC 0:00
+		double t0 = (jd0 - 2451545.)/36525.; // schon in t0 bzw jd0 richtig berechnet?
+		double thetaHG = 6.697376 + 2400.05134 * t0 + 1.002738 * stunde; // + (double)minute/60.);
+		double theta = thetaHG * 15. + onEarth.lonDec;
+		double tau = (theta - equatorial.lonDec ) /180*Math.PI;
+		double phi = onEarth.latDec/180*Math.PI;
+		double azimutNenner = Math.cos(tau)*Math.sin(phi)-
+		Math.tan(equatorial.latDec/180*Math.PI)*Math.cos(onEarth.latDec/180*java.lang.Math.PI);
+		float azimut = (float) java.lang.Math.atan(java.lang.Math.sin((theta-equatorial.lonDec)/180*Math.PI)/
+				azimutNenner);
+		azimut = (float) (azimut * 180f / java.lang.Math.PI);
+		if (azimutNenner&lt;0) azimut +=180.;
+		double h = 180 / Math.PI * Math.asin(Math.cos(equatorial.latDec/180*Math.PI) * Math.cos(tau)*Math.cos(phi) + Math.sin(equatorial.latDec/180 *Math.PI) * Math.sin(phi));
+		// null = Sueden auf Null = Norden umrechnen
+		azimut +=180.;
+		if (azimut &gt;360.) azimut -=360.;
+		return new CWPoint(h, azimut);
+	}
+
+	/**
+	 * convert from eliptical to equatorial coordinates
+	 * @param juliandate
+	 * @param eklipCoo ecliptic coos in degrees  
+	 * @return lon: Deklination (delta), lat: Rektaszension (alpha) in degree
+	 * this is adopted from <A HREF="http://lexikon.astronomie.info/java/sunmoon/sunmoon.html">http://lexikon.astronomie.info/java/sunmoon/sunmoon.html</A> 
+	 */
+	public static CWPoint ecliptic2Equatorial(CWPoint eklipCoo, double juliandate) {
+		double T = (juliandate - 2451545.0)/36525.; // Epoch 2000 January 1.5
+		double eps = (23.+(26+21.45/60)/60 + T*(-46.815 +T*(-0.0006 + T*0.00181) )/3600 ) / 180 * java.lang.Math.PI; // schiefe der Ekliptik
+		double coseps = Math.cos(eps);
+		double sineps = Math.sin(eps);
+
+		double sinlon = Math.sin(eklipCoo.lonDec / 180 * Math.PI);
+		CWPoint equatorial = new CWPoint();
+		equatorial.lonDec = (180 / Math.PI * Math.atan2( (sinlon*coseps-Math.tan(eklipCoo.latDec /180 * Math.PI)*sineps), Math.cos(eklipCoo.lonDec/180 * Math.PI) ) ) % 360; // rektaszension (alpha)
+		equatorial.latDec = 180 / Math.PI * Math.asin( Math.sin(eklipCoo.latDec/180 * Math.PI)*coseps + Math.cos(eklipCoo.latDec/180 * Math.PI)*sineps*sinlon ); // deklination (delta)
+
+		return equatorial;
+	}
+}
+

Added: experiments/EVE/src/cachewolf/navi/Track.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/Track.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/Track.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,56 @@
+package cachewolf.navi;
+
+import eve.fx.*;
+
+public class Track {
+	public Color trackColor;
+	public TrackPoint trackPoints[];
+	public int num;
+	
+	public Track(Color f) {
+		trackColor = f;
+		trackPoints = new TrackPoint[5000];
+		num = 0;
+	}
+/*===== add is currently not used	
+	public void add(double lat, double lon) {
+		TrackPoints[num] = new TrackPoint(lat, lon);
+		num++;
+	}
+=====*/	
+	/*
+	 * throws IndexOutOfBoundsException when track is full
+	 */
+	public void add(TrackPoint t) { 
+		if (trackPoints == null || t == null) return;
+		trackPoints[num] = new TrackPoint(t);
+		num++;
+	}
+/*===== loadTrack/saveTrack are currently not used
+	public void loadTrack(String filename){ // TODO untested!
+		byte [] all = eve.sys.Vm.readResource(null,filename);
+		if (all == null) return; // TODO error handling
+		num = Utils.readInt(all, 0, 4);
+		for (int i=0; i&lt;=num; i++){
+			TrackPoints[i].latDec = Double.longBitsToDouble(Utils.readLong(all, (i*2)*8 + 4));
+			TrackPoints[i].lonDec = Double.longBitsToDouble(Utils.readLong(all, (i*2+1)*8 + 4));
+		}
+	}
+	
+	public void saveTrack(String filename){  // TODO untested!
+	//ByteArray ba=new ByteArray();
+	byte[] ba = new byte[8*2*num+4]; // 8 bytes is one double int has size 4
+	Utils.writeInt(num, ba, 0, 4);
+	for (int i=0; i&lt;=num; i++){
+		Utils.writeLong(Double.doubleToLongBits(TrackPoints[i].latDec), ba, (i*2)*8 + 4);
+		Utils.writeLong(Double.doubleToLongBits(TrackPoints[i].lonDec), ba, (i*2+1)*8 + 4);
+	}
+	try{
+		PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(filename)));
+		outp.print(ba.toString());
+	}catch (IOException e) {
+		(new MessageBox(&quot;Error&quot;, &quot;Error reading trackfile:\n&quot;+e.toString(), MessageBox.OKB)).execute();}
+	}
+=====*/
+
+}

Added: experiments/EVE/src/cachewolf/navi/TrackOverlay.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/TrackOverlay.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/TrackOverlay.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,290 @@
+package cachewolf.navi;
+
+//import java.awt.image.BufferedImage;
+
+import eve.fx.Color;
+import eve.fx.Graphics;
+
+import eve.fx.Image;
+import eve.fx.Point;
+
+import java.util.Vector;
+
+
+public class TrackOverlay extends MapImage {
+	public TrackPoint topLeft;
+	public TrackPoint bottomRight;
+	Graphics draw;
+	//Graphics drawMask;
+	//int test;
+	MapInfoObject trans; 
+	Point pixelShift;
+	public Vector tracks;
+	boolean imageChangesDontShow = false;
+	public Point trackPixels[] = null;
+	public Color trackPixelsColor[] = null;
+	public int numPixels = 0;
+	final static int maxPixelsInCache = 100;
+	final static Color transparentColorForOverlay = Color.White; // only for use when transparent color is used
+	static boolean useTransparentColor;
+	public TrackOverlay (TrackPoint topLefti, int widthi, int highti, MapInfoObject transi) {
+		super();
+		topLeft = new TrackPoint(topLefti);
+		trans = transi;
+		pixelShift = trans.calcMapXY(topLeft);
+		bottomRight = trans.calcLatLon(widthi + pixelShift.x, highti + pixelShift.y);
+//TODO		if (eve.sys.Vm.getPlatform().equalsIgnoreCase(&quot;java&quot;)) {
+//			useTransparentColor = true; 
+//			setImage(new Image(widthi, highti), transparentColorForOverlay); // java-vm: transparency with a mask is very memory consuming, but transparency with a mask is much faster in eve-vm and doesn't consume more memory than a transparency color (eve 1.49)
+//		} else 
+		{
+			useTransparentColor = false; // // momentanously this it not used, but this is only because eve treats areas as opaque which has a non white color in the image, so that the mask doesn't need to be changed
+			//Image maski = new Image(widthi, highti);
+			//drawMask = new Graphics(maski);
+			//drawMask.setColor(Color.White);
+			//drawMask.fillRect(0, 0, maski.getWidth(), maski.getHeight());
+			setImage(new Image(widthi, highti), Color.White); // java-vm: transparency with a mask is very memory consuming, but transparency with a mask is much faster in eve-vm and doesn't consume more memory than a transparency color (eve 1.49)
+			//maski.free(); //setimage produces an inverted copy of the mask
+			//maski = null;
+		}
+		//properties = AlwaysOnTop; // arrows are above, so dont set it.
+		draw = new Graphics((Image) image);
+		draw.setDrawOp(Graphics.DRAW_OVER);
+		if (useTransparentColor) draw.setColor(transparentColorForOverlay);
+		else draw.setColor(Color.White);
+		draw.fillRect(0, 0, widthi, highti);
+		//int[] markImage = {0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000};
+		//int[] markMaskOpaque = {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff};
+		//mask.setPixels( markMaskOpaque, 0, 50, 50, 2, 2, 0);
+		//draw.fillRectRGB(50, 50, 52, 52, 0x00ff0000); // fillRectRGB has a Bug - it never returns - use fillRect instead
+		//image.setPixels(markImage, 0, 50, 50, 2, 2, 0); // out of an to me unkwon reason this doesn't work here, but it does in painttracks
+	}
+
+//TODO ImageSet is not used in project	
+/*	public void imageSet()
+//	==================================================================
+	{
+		IImage i = drawable;
+		if (i == null) i = image;
+		if (i != null){
+			location.width = i.getWidth();
+			location.height = i.getHeight();
+		}
+		if (image != null &amp;&amp; image != sourceImage) image.freeze();
+//		if (mask != null &amp;&amp; mask != sourceMask) mask.freeze(); // dont freeze the mask, it could change. Anyway momentanously it doesnt change, because when the image contains non-white in the opaque areas, it will be opaque without changing the mask
+		properties &amp;= ~HasChanged;
+	}
+*/
+
+	public void paintTracks() {
+	// for debugging TrackOverlayPositions
+	// draw.setPen(new Pen(Color.LightBlue,Pen.SOLID,1));
+	// draw.fillRect(1, 1, image.getWidth()-1, image.getHeight()-1);
+		//draw.setColor(255,0,0);
+		//draw.setPen(new Pen(new Color(255,0,0),Pen.SOLID,3));
+		//draw.fillRect(50, 50, 4, 4); // fillRectRGB has a Bug - it never returns - use fillRect instead
+
+		if (tracks == null || tracks.size() == 0) return;
+		int tri, i;
+		Track tr;
+		int numberOfTracks = tracks.size();
+		int numberOfPoints = ((Track)tracks.get(numberOfTracks - 1)).num;
+		if (numberOfTracks &gt; 1){
+			numberOfPoints += (numberOfTracks - 1) * ((Track)tracks.get(0)).num;
+		}
+		int n = 0;
+		
+		for (tri=0; tri &lt; numberOfTracks; tri++) {
+			tr = (Track)tracks.get(tri);
+			//draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
+			draw.setColor(tr.trackColor);
+			if (tr.num &gt; 0) {
+				for (i=0; i &lt; tr.num; i++) {
+					n++;
+					if  ((numberOfPoints - n &gt; 30*60) &amp;&amp; ((n &amp; 1) == 0)) continue;
+					if  ((numberOfPoints - n &gt; 60*60) &amp;&amp; ((n &amp; 2) == 0)) continue;
+					paintPoint(tr.trackColor, tr.trackPoints[i]);
+				}
+			}
+		}
+	}
+	
+
+	/**
+	 * 
+	 * @param f
+	 * @param lat
+	 * @param lon
+	 * @return true if point was on this overlay
+	 */
+	public boolean paintPoint(Color f, TrackPoint where){
+		if (where.latDec &lt; bottomRight.latDec || where.latDec &gt; topLeft.latDec || where.lonDec &lt; topLeft.lonDec || where.lonDec &gt; bottomRight.lonDec) return false;
+		//eve.sys.Vm.debug(&quot;showlastaddedpoint, lat: &quot;+lat+&quot;   lon: &quot;+lon);
+		Point p = trans.calcMapXY(where);
+		int x = p.x - pixelShift.x;
+		int y = p.y - pixelShift.y;
+		//draw.drawLine(x, y, x, y);
+		//eve.sys.Vm.debug(&quot;showlastaddedpoint, x: &quot;+x+&quot;   y: &quot;+y+&quot;loc.x: &quot;+location.x+&quot;  loc.y:&quot;+location.y);
+		draw.fillRect(x-1, y-1, 3, 3);
+		//drawMask.fillRect(x-1, y-1, 3, 3);
+		/*	if (image.bufferedImage != null) { // funktioniert gut, allerdings nur in der java-VM wenn eve.fx.Image.bufferedImage als public definiert
+			int yd;
+			for  (int xd=-1; xd&lt;=1; xd++) {
+				for (yd=-1; yd&lt;=1; yd++) {
+					((BufferedImage)image.bufferedImage).setRGB(x+xd, y+yd, -65536);
+				}
+			} */
+		if (imageChangesDontShow) {
+			try {addPixelIfNeccessary(x, y, f); }
+			catch (IndexOutOfBoundsException e) // thrown when there are more than pixels stored than possible
+			{ fixate();  }
+		}
+		return true;
+	}
+
+	/**
+	 * this method forces eve to transfer the drawn points
+	 * from _awtImage to bufferedImage, which is drawn to the screen
+	 *
+	 */
+	private void fixate() {
+		if (numPixels == 0) return;
+		//	draw.drawImage(image,null,Color.DarkBlue,0,0,location.width,location.height); // changing the mask forces graphics to copy from image._awtImage to image.bufferedImage, which is displayed 
+		doDraw(draw,0);   // null, Color.Pink, 0, 0, 1, 1); // width and height is anyway ignored, evtl. testen,  
+		imageChangesDontShow = false;
+		removeAllPixels();
+	}
+
+	private void removeAllPixels() {
+		numPixels = 0;
+		trackPixels = null;
+		trackPixelsColor = null;
+	}
+
+	
+	public void addPixel(int x, int y, Color f) throws IndexOutOfBoundsException {
+		if (trackPixels==null) { trackPixels = new Point[maxPixelsInCache]; trackPixelsColor = new Color[maxPixelsInCache]; } 
+		trackPixels[numPixels] = new Point(x, y); // IndexOutOfBoundsException is handled in PaintPoint
+		trackPixelsColor[numPixels] = f.getCopy();
+		numPixels++;
+	}
+
+	public void addPixelIfNeccessary(int x, int y, Color f){
+		if (trackPixels != null) {
+			int ll =(numPixels&lt;30 ? 0 : numPixels-30); // look in the last 50 added Pixels if the same Pixel is already in the list (for performance reasons dont look in the whole list)
+			for (int i=numPixels-1; i&gt;=ll; i--) {
+				if (trackPixels[i].x == x &amp;&amp; trackPixels[i].y == y &amp;&amp; f.equals(trackPixelsColor[i])) 
+				{ return; } 
+			}
+		}
+		addPixel(x, y, f);
+	}
+
+	public static final int FIXATE_IF_NO_PIXELS_NUM = 60;
+	private int notOnThisOverlaySince = 0;
+
+	public void paintLastAddedPoint(Track tr) { 
+		//draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
+		draw.setColor(tr.trackColor);
+		if (paintPoint(tr.trackColor, tr.trackPoints[tr.num-1])) notOnThisOverlaySince = 0;
+		else notOnThisOverlaySince++;
+		if (notOnThisOverlaySince &gt; FIXATE_IF_NO_PIXELS_NUM) { // zur Performanceverbesserung: wenn in den letzten 60 Updates keines mehr f&#252;r dieses Overlay dabei war, Overlay Pixels fest schreiben, damit doDraw entlastet wird.
+			fixate();
+			notOnThisOverlaySince = 0;
+		}
+
+	}
+
+	public void doDraw(Graphics g,int options) { // this is automatically called when the image need to be (re-)drawn on the screen
+		super.doDraw(g, options);
+		imageChangesDontShow = true; // g.drawImage (in super) copies _awtImage into bufferedImage, any later changes to _awtImage dont show up until the mask or the image has changed - unfortunately bufferedImage is not accessable from outside
+		// draw trackpoints which were added after image changes don't show up on the screen
+		if (tracks == null || tracks.size() == 0) return;
+		int i;
+		for (i=0; i&lt;numPixels; i++) {
+			g.setColor(trackPixelsColor[i]);
+			g.fillRect(trackPixels[i].x-1, trackPixels[i].y-1, 3, 3);
+		}
+		//g.drawText(Convert.toString(test), 10, 10);
+		//g.drawRect(10 + test, 10, 10, 10);
+		//test++;
+	}
+}
+
+
+/* draw zeichnet auf _awtImage
+ * image.drawImage erzeugt bufferedImage, wenn es vorher null war 
+ * und kopiert den entsprechenden Teil in das &#252;bergebene Surface
+ * Das Problem ist, dass bufferedImage nicht mehr upgedatet wird, wenn
+ * es einmal erzugt wurde. Es wird nur dann upgedatet, wenn das Image ein anderes wird
+ * oder die Maske eine andere. Das Update erfolgt dann &#252;ber doDraw, was doCheckMask aufruft,
+ * das das eigentliche kopieren aus _awtImage vornimmt.
+ * 
+ *  Problem: das kopieren von _awtImage in BufferedImage ist sehr zeitaufw&#228;ndig, weil
+ *  es keine native Routine ist und jedes Pixel einzeln gepr&#252;ft wird.
+ *  Deswegen w&#228;re die beste L&#246;sung, wenn ich bufferedImage direkt updaten k&#246;nnte.
+ *  Aber bufferedImage ist privat, ich kann auch in abgeleiteten Klassen nicht drauf
+ *  zugreifen. 
+ *  
+ *  Zur Not w&#228;re auch denkbar, doDraw zu &#252;berschreiben, um bei jedem Aufruf alle 
+ *  Trackpoints neu zu zeichnen.
+ *  Work-Aorund: draw.drawImage(image,null,Color.Pink,0,0,1,1); bewirkt, dass awtImage ins
+ *  bufferedImage kopiert wird. Dabei wird die transparentColor (in Picture) nicht ge&#228;ndert
+ *  und beim Aufruf von doDraw wird wieder die urspr&#252;ngliche transparentColor verwendet
+ *  
+ */
+//was alles nicht funktioniert:
+//drawmask.setDrawOp(Graphics.DRAW_OVER);
+//drawmask.drawRect(x-1, y-1, 2, 2, 1);
+//this.setImage(image, mask);
+//n&#228;chster Versuch: image.bufferedImage in eve.fx.Image public definieren !!!
+//image.rgb
+//draw._g.surfaceData.bufImg.raster.data[y*this.location.width + x] = -65536; := image._awtImage
+//((Image)image).eImage(colorOrMask)._awtImage.raster.data[0]=0;
+//image
+//((BufferedImage)(image).se.^.bufferedImage.raster.data[y*this.location.width + x]=-65536; //was dort steht wird tats&#228;chlich angezeigt, allerdings kann ich es nicht direkt setzen :-(
+//int[] markPixels = new int[4];
+//for (int i = 0; i&lt;markPixels.length; i++) { markPixels[i] = -65536; }
+//image.transparent = null; hilft auhc nicht
+//image.mask = null;
+//image.bufferedImage = null;
+//image.setPixels(markPixels, 0 , x-20, y, 2, 2, 0); // dadrin sollte bufferedImage = null gesetzt werden, wird es aber nicht :-(
+//eve.fx.Picture mark = new Picture();
+//Image mark = new Image(2,2);
+//new Graphics(mark).drawImage(image, null, transparentColor, x-40, y, 2, 2);
+//mark.draw(draw, x-50, y, Graphics.DRAW_OVER); // options (Graphics.DRAW_OVER) are ignored anyway
+//image.bufferedImage = null; // this solves the problem
+//toCursor(null);
+//this.draw(draw);
+//image=(BufferedImage)this.toNativeImage(transparentColor);
+//(java.awt.Image.b)
+//image.bufferedImage=null;
+//draw.flush();
+//eve.ui.PenEvent.refreshTip(draw.surface);
+//draw.setPixelRGB(x, y, -65536);
+//this.changed(); hilft auch nicht
+//this.refresh(); // hilft nicht :-(
+//lastDrawn.x = lastDrawn.x -10; hilft auch nicht
+//imageMayChange = true; // hilft auch nicht :-(
+
+/*
+ * In der eve-VM f&#252;r PocketPC-ARM funktioniert die Festlegung einer 
+ * transparenten Farbe nicht (Hintergrund wird wei&#223; statt durchsichtig)
+ * deswegen (und weil in eve-VM effizienter) Umstellung auf Transparenzmaske
+ * statt transparenter Farbe
+ * TODO Dies ist in Java-VM allerdings extrem Speicher fressend -&gt; evtl abfragen 
+static int fixMask(WObject image,WObject col,int isMask):
+	in Maske: 0 an durchsichtiger Stelle, sonst ff
+	in Image: ffffff an durchsichtiger Stelle
+
+	in java-VM
+	in Maske: ffffffff in image.mask, wenn nicht durchsichtig
+	          ff000000 an durchsichtiger Stelle
+	image.doCheckMask erzeugt ein Image mit 0 an den durchsichtigen Stellen, die dadurch definiert sind, dass im image 0xffffff und in (mask &amp; 0xffffff == 0) steht.
+ */
+/*
+ * this class is only needed to have a fast access to the list of pixels
+ * which are added but aniimage.draw will not lead to a change on the screen
+ * so that these pixels will be drawn seperately by doDraw
+ * 
+ */

Added: experiments/EVE/src/cachewolf/navi/TrackPoint.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/TrackPoint.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/TrackPoint.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,41 @@
+package cachewolf.navi;
+
+
+/**
+ * this is not CWPoint because it should be as small as possible
+ * @author pfeffer
+ *
+ */
+
+public class TrackPoint  {
+	public double latDec;
+	public double lonDec;
+	
+	public TrackPoint(){
+		latDec = -91;
+		lonDec = -361;
+	}
+	
+	public TrackPoint(TrackPoint t) {
+		latDec = t.latDec;
+		lonDec = t.lonDec;
+	}
+	public TrackPoint(double lat, double lon) {
+		latDec = lat;
+		lonDec = lon;
+	}
+	public boolean equals(TrackPoint tp) {
+		return latDec == tp.latDec &amp;&amp; lonDec == tp.lonDec;
+	}
+	
+	/**
+	 * Returns true if the coordinates are valid
+	 */
+	public boolean isValid() {
+		return 	latDec &lt;= 90.0 &amp;&amp; latDec &gt;= -90.0 &amp;&amp;
+				lonDec &lt;= 360 &amp;&amp; lonDec &gt;= -360;
+	}
+
+
+}
+

Added: experiments/EVE/src/cachewolf/navi/TransformCoordinates.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/TransformCoordinates.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/TransformCoordinates.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,504 @@
+package cachewolf.navi;
+
+
+import java.lang.Math;
+
+import cachewolf.CWPoint;
+import cachewolf.MyLocale;
+import cachewolf.utils.Matrix;
+
+
+/**
+ * Class to transform coordinates and shift datums
+ * it uses the 7 parameter Helmert Transformation
+ * programmed according to <A HREF="http://www.geoclub.de/files/GK_nach_GPS.xls">http://www.geoclub.de/files/GK_nach_GPS.xls</A> 
+ * and <A HREF="http://www.geoclub.de/files/GPS_nach_GK.xls">http://www.geoclub.de/files/GPS_nach_GK.xls</A>
+ * The only difference to the excel-model is that shifting is done before rotation
+ * this makes calculations easier, without changing the output.
+ * 
+ * For verification data see: 
+ *  * <A HREF="http://crs.bkg.bund.de/crseu/crs/descrtrans/BeTA/BETA2007testdaten.csv">http://crs.bkg.bund.de/crseu/crs/descrtrans/BeTA/BETA2007testdaten.csv</A>
+ *  * <A HREF="http://www.lverma.nrw.de/produkte/raumbezug/koordinatentransformation/Koordinatentransformation.htm">http://www.lverma.nrw.de/produkte/raumbezug/koordinatentransformation/Koordinatentransformation.htm</A>
+ * Now, that this is completed: there is a much more precise method right now published
+ * by the Bundesamt f&#252;r Kartographie und Geod&#228;sie for whole Germany: see:
+ *  * <A HREF="http://crs.bkg.bund.de/crseu/crs/descrtrans/BeTA/BETA2007dokumentation.pdf">http://crs.bkg.bund.de/crseu/crs/descrtrans/BeTA/BETA2007dokumentation.pdf</A>
+ *  * <A HREF="http://crs.bkg.bund.de/crs-eu/">http://crs.bkg.bund.de/crs-eu/</A> click on &quot;national CRS&quot; -&gt; germany -&gt; DE_DHDN / GK_3 -&gt; DE_DHDN (BeTA, 2007) to ETRS89
+ *  
+ *  Start offset in languages file: 4900
+ * @author Pfeffer
+ *
+ */
+public class TransformCoordinates {
+
+	public static final int EPSG_WGS84 = 4326; 
+	public static final int EPSG_ETRS89 = 25832; // TODO support it anyhow 
+	public static final int EPSG_GK2 = 31466; 
+	public static final int EPSG_GK3 = 31467; 
+	public static final int EPSG_GK4 = 31468; 
+	public static final int EPSG_GK5 = 31469;
+	/** Gau&#223;-Boaga, Monte Mario, Roma 1940, IT_ROMA1940 */
+	public static final int EPSG_ITALIAN_GB_EW1 = 3003; 
+	public static final int EPSG_ITALIAN_GB_EW2 = 3004;
+	
+	private static final Ellipsoid BESSEL = new Ellipsoid(6377397.155, 6356078.962, true);
+	public static final Ellipsoid WGS84 = new Ellipsoid(6378137.000, 6356752.314, true);
+	public static final Ellipsoid HAYFORD1909 = new Ellipsoid(6378388, 297, false);
+	
+	//	 taken from <A HREF="http://crs.bkg.bund.de/crs-eu/">http://crs.bkg.bund.de/crs-eu/</A> click on &quot;national CRS&quot; -&gt; germany -&gt; DE_DHDN / GK_3 -&gt; DE_DHDN (North) to ETRS89
+	//	 they are the same as <A HREF="http://www.geoclub.de/files/GK_nach_GPS.xls">http://www.geoclub.de/files/GK_nach_GPS.xls</A> &quot;Parametersatz 4 = Deutschland Nord&quot;
+	private static final TransformParameters GK_NORD_GERMANY_TO_WGS84 = new TransformParameters(590.5, 69.5, 411.6, 0.796, 0.052, 3.601, 8.300);
+	/** use this for nord Germany, maximum deviation sub meter, valid in the former BRD (west germany) in 52&#176;20' N ... 55&#176;00' N */
+	public static final TransformParameters GK_NORD_GERMANY =  GK_NORD_GERMANY_TO_WGS84; 
+
+	//	 taken from <A HREF="http://crs.bkg.bund.de/crs-eu/">http://crs.bkg.bund.de/crs-eu/</A> click on &quot;national CRS&quot; -&gt; germany -&gt; DE_DHDN / GK_3 -&gt; DE_DHDN (Middle) to ETRS89
+	private static final TransformParameters GK_MID_GERMANY_TO_WGS84 = new TransformParameters(584.8, 67.0, 400.3, -0.105, -0.013, 2.378, 10.290);
+	/** use this for mid-Germany, maximum deviation sub meter, valid in the former BRD (west germany) in 50&#176;20' N ... 52&#176;20' N */
+	public static final TransformParameters GK_MID_GERMANY =  GK_MID_GERMANY_TO_WGS84; 
+
+	//	 taken from <A HREF="http://crs.bkg.bund.de/crs-eu/">http://crs.bkg.bund.de/crs-eu/</A> click on &quot;national CRS&quot; -&gt; germany -&gt; DE_DHDN / GK_3 -&gt; DE_DHDN (South) to ETRS89
+	private static final TransformParameters GK_SOUTH_GERMANY_TO_WGS84 = new TransformParameters(597.1, 71.4, 412.1, -0.894, -0.068, 1.563, 7.580);
+	/** use this for south Germany, maximum deviation sub meter, valid in the former BRD (west germany) in 47&#176;00' N ... 50&#176;20' N */
+	public static final TransformParameters GK_SOUTH_GERMANY =  GK_SOUTH_GERMANY_TO_WGS84; 
+
+	public static final Area FORMER_GDR = new Area(new CWPoint(54.923414, 10.503013), new CWPoint(50.402578, 14.520637)); 
+	
+	// taken from <A HREF="http://www.lverma.nrw.de/produkte/druckschriften/verwaltungsvorschriften/images/gps/TrafopsNRW.pdf">http://www.lverma.nrw.de/produkte/druckschriften/verwaltungsvorschriften/images/gps/TrafopsNRW.pdf</A> for NRW this transform has deviations lower than 34cm.
+	private static final TransformParameters GK_NRW_GERMANY_TO_WGS84 = new TransformParameters(566.1, 116.3, 390.1, -1.11, -0.24, 3.76, 12.6);
+	/** use this for NRW in Germany. Deviations less than 34 cm */
+	public static final TransformParameters GK_NRW_GERMANY =  GK_NRW_GERMANY_TO_WGS84; 
+
+	// taken from <A HREF="http://www.lverma.nrw.de/produkte/druckschriften/verwaltungsvorschriften/images/gps/TrafopsNRW.pdf">http://www.lverma.nrw.de/produkte/druckschriften/verwaltungsvorschriften/images/gps/TrafopsNRW.pdf</A> for NRW this transform has deviations lower than 113cm.
+	// these matches to  <A HREF="http://www.geoclub.de/files/GK_nach_GPS.xls">http://www.geoclub.de/files/GK_nach_GPS.xls</A> &quot;Parametersatz 3 = Deutschland 1995&quot;
+	private static final TransformParameters GK_GERMANY_1995_TO_WGS84 = new TransformParameters(582, 105, 414, -1.04, -0.35, +3.08, 8.3);
+	/** Use this for Germany if there is no more specific available. Deviations less than 113 cm */
+	public static final TransformParameters GK_GERMANY_1995 =  GK_GERMANY_1995_TO_WGS84; 
+
+	// taken from <A HREF="http://www.geodatenzentrum.de/geodaten/gdz_home1.gdz_home_start?gdz_home_para1=Technische%A0Hinweise&amp;gdz_home_para2=Technische%A0Hinweise&amp;gdz_home_menu_nr=10&amp;gdz_home_menu_nr2=1&amp;gdz_home_para3=/auftrag/html/gdz_tech_geo_deu.htm&amp;gdz_home_spr=deu&amp;gdz_home_para0=0">http://www.geodatenzentrum.de/geodaten/gdz_home1.gdz_home_start?gdz_home_para1=Technische%A0Hinweise&amp;gdz_home_para2=Technische%A0Hinweise&amp;gdz_home_menu_nr=10&amp;gdz_home_menu_nr2=1&amp;gdz_home_para3=/auftrag/html/gdz_tech_geo_deu.htm&amp;gdz_home_spr=deu&amp;gdz_home_para0=0</A>
+	private static final TransformParameters GK_GERMANY_BKG_TO_WGS84 = new TransformParameters(586, 87, 409, -0.52, -0.15, 2.82, 9);
+	/** Use this for Germany if there is no more specific available. Deviations unknown. Data source: Bundesamt f&#252;r Kartographie und Geod&#228;sie, taken from website on: 1-11-2007 */
+	public static final TransformParameters GK_GERMANY_BKG =  GK_GERMANY_BKG_TO_WGS84; 
+
+	// take from <A HREF="http://www.geoclub.de/files/GK_nach_GPS.xls">http://www.geoclub.de/files/GK_nach_GPS.xls</A> &quot;Parametersatz 2 = Deutschland 2001&quot;
+	private static final TransformParameters GK_GERMANY_2001_TO_WGS84 = new TransformParameters(598.1, 73.7, 418.2, -0.202, -0.045, 2.455, 6.700);
+	/** Use this for Germany if there is no more specific available. maximal deviations unknown */
+	public static final TransformParameters GK_GERMANY_2001 =  GK_GERMANY_2001_TO_WGS84;
+
+	/** The italian variant of Gau&#223;-Kr&#252;ger (Gau&#223;-Boaga) */
+	// taken from <A HREF="http://crs.bkg.bund.de/crs-eu/">http://crs.bkg.bund.de/crs-eu/</A> -&gt; italy -&gt; ROMA40 (change the sign of the rotation parameters!)
+	public static final TransformParameters GB_ITALIAN_PENINSULAR_TO_WGS84 =  new TransformParameters(-104.1, -49.1, -9.9, -0.971, 2.917, -0.714, -11.68);
+	//static final Area ITALY_PENINSULAR = new Area(new CWPoint());
+	public static final TransformParameters GB_ITALIAN_SARDINIA_TO_WGS84 =  new TransformParameters(-168.6, -34.0, 38.6, 0.374, 0.679, 1.379, -9.48);
+	static final Area ITALY_SARDINIA = new Area(new CWPoint(42, 6), new CWPoint(38, 11));
+	static final Area ITALY_SARDINIA_GK = new Area(wgs84ToGaussKrueger(ITALY_SARDINIA.topleft, EPSG_ITALIAN_GB_EW1).toTrackPoint(GkPoint.ITALIAN_GB),
+			wgs84ToGaussKrueger(ITALY_SARDINIA.buttomright, EPSG_ITALIAN_GB_EW1).toTrackPoint(GkPoint.ITALIAN_GB));
+
+	public static final TransformParameters GB_ITALIAN_SICILIA_TO_WGS84 =  new TransformParameters(-50.2, -50.4, 84.8, 0.690, 2.012, -0.459, -28.08);
+	static final Area ITALY_SICILIA = new Area(new CWPoint(39, 12), new CWPoint(36.3, 15.6));
+	static final Area ITALY_SICILIA_GK = new Area(wgs84ToGaussKrueger(ITALY_SICILIA.topleft, EPSG_ITALIAN_GB_EW2).toTrackPoint(GkPoint.ITALIAN_GB),
+			wgs84ToGaussKrueger(ITALY_SICILIA.buttomright, EPSG_ITALIAN_GB_EW2).toTrackPoint(GkPoint.ITALIAN_GB));
+
+	private TransformCoordinates() {} // as all members are static, so avoid instantiation
+
+	/* replaced by getGkRegion
+	public static boolean isGermanGk(int epsgcode) {
+		boolean ret = false;
+		switch (epsgcode) {
+		case EPSG_GK2:
+		case EPSG_GK3:
+		case EPSG_GK4:
+		case EPSG_GK5: ret = true; 
+		}
+		return ret;
+	}
+	*/
+	
+	/**
+	 * 
+	 * @param epsgcode
+	 * @return region code as needed for GkPoint, -1 if not Gau&#223;-Kr&#252;ger or not supported
+	 */
+	public static int getGkRegion(int epsgcode) {
+		int ret;
+		switch (epsgcode) {
+		case EPSG_GK2:
+		case EPSG_GK3:
+		case EPSG_GK4:
+		case EPSG_GK5: ret = GkPoint.GERMAN_GK; break;
+		case EPSG_ITALIAN_GB_EW1:
+		case EPSG_ITALIAN_GB_EW2: ret = GkPoint.ITALIAN_GB; break;
+		default: ret = -1;
+		}
+		return ret;
+	}
+	
+	public static boolean isSupported(int epsgcode) {
+		boolean ret = false;
+		switch (epsgcode) {
+		case EPSG_WGS84:
+		case EPSG_GK2:
+		case EPSG_GK3:
+		case EPSG_GK4:
+		case EPSG_GK5: 
+		case EPSG_ITALIAN_GB_EW1:
+		case EPSG_ITALIAN_GB_EW2:
+			ret = true; 
+		}
+		return ret;
+	}
+		
+	/**
+	 * This is the most abstract method: If you don't know 
+	 * when to use another one (if you are in need to do so, you will
+	 * know), use this one.
+	 * @param gk
+	 * @return
+	 */
+	public static CWPoint germanGkToWgs84(GkPoint gk) {
+		if (gk.northing &lt;= 6089288.064 &amp;&amp; gk.northing &gt;= 5585291.767 &amp;&amp; // these coordinates are transformed ones from the invers routine
+				( gk.getStripe() == 4 &amp;&amp; gk.getGkEasting(GkPoint.GERMAN_GK) &gt;= 4404124.247 &amp;&amp; gk.getGkEasting(GkPoint.GERMAN_GK) &lt;= 4679300.398) ||
+				( gk.getStripe() == 5 &amp;&amp; gk.getGkEasting(GkPoint.GERMAN_GK) &gt;= 5211904.597 &amp;&amp; gk.getGkEasting(GkPoint.GERMAN_GK) &lt;= 5466056.603)
+			) return gkToWgs84(gk, BESSEL, GK_GERMANY_2001, 1);
+		if (gk.northing &lt;= 6097247.910 &amp;&amp; gk.northing &gt;= 5800464.725 )return gkToWgs84(gk, BESSEL, GK_NORD_GERMANY, 1);
+		if (gk.northing &lt;= 5800464.725 &amp;&amp; gk.northing &gt;= 5577963.555 )return gkToWgs84(gk, BESSEL, GK_MID_GERMANY, 1);
+		if (gk.northing &lt;= 5577963.555 &amp;&amp; gk.northing &gt;= 5207294.028 )return gkToWgs84(gk, BESSEL, GK_SOUTH_GERMANY, 1);
+		return  gkToWgs84(gk, BESSEL, GK_GERMANY_2001, 1);
+	}
+	public static CWPoint italianGkToWgs84(GkPoint gk) {
+		if (ITALY_SARDINIA_GK.isInBound(gk.toTrackPoint(GkPoint.ITALIAN_GB))) return gkToWgs84(gk, HAYFORD1909, GB_ITALIAN_SARDINIA_TO_WGS84, 0.9996);
+		if (ITALY_SICILIA_GK.isInBound(gk.toTrackPoint(GkPoint.ITALIAN_GB))) return gkToWgs84(gk, HAYFORD1909, GB_ITALIAN_SICILIA_TO_WGS84, 0.9996);
+		return gkToWgs84(gk, HAYFORD1909, GB_ITALIAN_PENINSULAR_TO_WGS84, 0.9996);
+	}
+
+	public static CWPoint GkToWgs84(GkPoint gk, int region) {
+		switch (region) {
+		case GkPoint.GERMAN_GK: return germanGkToWgs84(gk);
+		case GkPoint.ITALIAN_GB: return italianGkToWgs84(gk);
+		}
+		throw new IllegalArgumentException(&quot;GkToWgs84: region: &quot; + region + &quot; not supported&quot;);
+	}
+	
+	/**
+	 * This is the most abstract method: If you don't know 
+	 * when to use another one (if you are in need to do so, you will
+	 * know), use this one. This routine chooses automatically the best known
+	 * transformation parameters. Currently the maximal deviation is 1m for the
+	 * former BRD and 1.13m for the former GDR 
+	 * It also chooses automatically the correct stripe
+	 * @param gk
+	 * @return
+	 */
+	public static GkPoint wgs84ToGermanGk(CWPoint ll) {
+		return  wgs84ToGk(ll, GkPoint.GERMAN_GK); 	
+	}
+
+	/**
+	 * 
+	 * @param ll
+	 * @param region e.g. GkPoint.GERMAN_GK 
+	 * @return
+	 */
+	public static GkPoint wgs84ToGk(TrackPoint ll, int region) {
+		switch (region) {
+		case GkPoint.GERMAN_GK:	return  wgs84ToGk(ll, BESSEL, getGermanGkTransformParameters(ll), -1, 3, 0, 1); 	
+		case GkPoint.ITALIAN_GB:return  wgs84ToGk(ll, HAYFORD1909, getItalianGkTransformParameters(ll), -1, 6, 3, 0.9996); 	
+		default: throw new IllegalArgumentException(&quot;wgs84ToGk(CWPoint, int): region: &quot; + region + &quot;not supported&quot;);
+		}
+	}
+	
+	public static TransformParameters getGermanGkTransformParameters(TrackPoint ll) {
+		if (FORMER_GDR.isInBound(ll)) return GK_GERMANY_2001; // exlcude former GDR from the splitting germany in north/middel/south
+		if (ll.latDec &lt;= 55 &amp;&amp; ll.latDec &gt;= 52.33333334 ) return  GK_NORD_GERMANY;
+		if (ll.latDec &lt;= 52.33333334  &amp;&amp; ll.latDec &gt;= 50.33333334 ) return  GK_MID_GERMANY;
+		if (ll.latDec &lt;= 50.33333334  &amp;&amp; ll.latDec &gt;= 47) return  GK_SOUTH_GERMANY;
+		return GK_GERMANY_2001;
+	}
+
+	public static TransformParameters getItalianGkTransformParameters(TrackPoint ll) {
+		if (ITALY_SARDINIA.isInBound(ll)) return GB_ITALIAN_SARDINIA_TO_WGS84;
+		if (ITALY_SICILIA.isInBound(ll)) return GB_ITALIAN_SICILIA_TO_WGS84;
+		return GB_ITALIAN_PENINSULAR_TO_WGS84;
+	}
+	
+	/**
+	 * This function returns the position in the list of the given epsg code list
+	 * which corresondes to the stripe used in Gau&#223;-Kr&#252;ger Point gk
+	 * @param epsgcodes list of epsgcodes
+	 * @param gk
+	 * @return postion in array of epsgcodes, -1 if not found
+	 */
+	public static int whichEpsg(int[] epsgcodes, GkPoint gk) {
+		int stripe = gk.getStripe();
+		int i;
+		for (i = 0; i &lt; epsgcodes.length; i++) {
+			if (getGkStripeEpsg(epsgcodes[i]) == stripe) break;
+		}
+		if (i &gt;= epsgcodes.length) return -1;
+		return i;
+	}
+	
+	/**
+	 * Call this routine to convert from wgs84 into German Gau&#223;-Kr&#252;ger-Coordinates 
+	 * using the Gau&#223;-Kr&#252;ger Projection and the ellipsoid forgk
+	 * If you want the Gau&#223;-Kr&#252;ger-Coordinates in a certain stripe, provide the
+	 * stripe and stripe width, otherwise set stripe to -1, then the stripe 
+	 * will be automatically determined
+	 * @param ll
+	 * @param Gau&#223;-Kr&#252;ger-to-WGS84 transformation parameters, they will be automatically inverted
+	 * @param stripe stripe to force to, otherwise -1 will determine the stripe automatically
+	 * @return
+	 */ // TODO find out what about the Krassowski in former GDR?
+	public static GkPoint wgs84ToGk(TrackPoint ll, Ellipsoid forgk, TransformParameters gk2wgs84, int stripe, int stripewidth, int degreeOfStripe0, double scale) {
+		XyzCoordinates wgsxyz = latLon2xyz(ll, 0, WGS84);
+		XyzCoordinates gkxyz = transform(wgsxyz, gk2wgs84.inverted); 
+		CWPoint gkll = xyz2Latlon(gkxyz, forgk);
+		//ewe.sys.Vm.debug(&quot;wgs84-ll: &quot; + new CWPoint(ll).toString(CWPoint.DMS));
+		//ewe.sys.Vm.debug(&quot;gkll: &quot; + gkll.toString(CWPoint.DMS));
+		if (stripe == -1)	return projectLatlon2GkStripeauto(gkll, forgk, stripewidth, degreeOfStripe0, scale);
+		return projectLatlon2GK(gkll, forgk, stripewidth, stripe, degreeOfStripe0, scale); 
+	}
+	/**
+	 * Call this method to convert any Gau&#223;-Kr&#252;ger coordinates into
+	 * wgs84.
+	 * @param gk point to convert
+	 * @param GK2WGS84 Gau&#223;-Kr&#252;ger-to-WGS84 transformation parameters
+	 * @return
+	 */
+	public static CWPoint gkToWgs84(GkPoint gk, Ellipsoid gkon, TransformParameters gk2wgs84, double scale) {
+		CWPoint gkll = gk2LatLon(gk, gkon, scale);
+		XyzCoordinates wgsxyz = latLon2xyz(gkll, 0, gkon);
+		XyzCoordinates wgs84xyz = transform(wgsxyz, gk2wgs84);
+		CWPoint wgsll = xyz2Latlon(wgs84xyz, WGS84);
+		return wgsll;
+	}
+	
+	/**
+	 * this routine gives the correct Gau&#223;-Kr&#252;ger coordinates
+	 * in the stripe specified by EPSG-Code
+	 * @param wgs84
+	 * @param epsgcode
+	 * @return
+	 * @throws IllegalArgumentException if EPSG code is not supported GK or unsupported
+	 */
+	public static GkPoint wgs84ToGaussKrueger(TrackPoint wgs84, int epsgcode) throws IllegalArgumentException {
+		switch (getGkRegion(epsgcode)) {
+		case GkPoint.GERMAN_GK: return wgs84ToGk(wgs84, BESSEL, getGermanGkTransformParameters(wgs84), getGkStripeEpsg(epsgcode), 3, 0, 1);
+		case GkPoint.ITALIAN_GB: return wgs84ToGk(wgs84, HAYFORD1909, getItalianGkTransformParameters(wgs84), getGkStripeEpsg(epsgcode), 6, 3, 0.9996);
+		}
+		throw new IllegalArgumentException(&quot;wgs84ToGaussKrueger: epsg-code: &quot; + epsgcode + &quot;not supported&quot;);
+	}
+	
+	private static int getGkStripeEpsg(int epsgcode) {
+		int stripe;
+		switch (epsgcode) {
+		case EPSG_GK2: stripe = 2; break;
+		case EPSG_GK3: stripe = 3; break;
+		case EPSG_GK4: stripe = 4; break;
+		case EPSG_GK5: stripe = 5; break;
+		case EPSG_ITALIAN_GB_EW1: stripe = 1; break;
+		case EPSG_ITALIAN_GB_EW2: stripe = 2; break;
+		default: throw new IllegalArgumentException(&quot;wgs84ToGermanGk: epsgcode: &quot; + epsgcode + MyLocale.getMsg(4900, &quot; is not a german Gauss-Krueger coordinate&quot;));
+		}
+		return stripe; 
+	}
+	
+	private static XyzCoordinates latLon2xyz(TrackPoint ll, double alt, Ellipsoid ellipsoid) {
+		if (!ll.isValid()) throw new IllegalArgumentException(&quot;latLon2xyz: invalid lat-lon&quot;);
+		double e2 = (ellipsoid.a * ellipsoid.a - ellipsoid.b * ellipsoid.b)/(ellipsoid.a * ellipsoid.a);
+		double N = ellipsoid.a/ Math.sqrt(1 - e2 * Math.pow(Math.sin(ll.latDec / 180*Math.PI), 2));
+		XyzCoordinates ret = new XyzCoordinates(0,0,0);
+		ret.x = (N+alt) * Math.cos(ll.latDec /180*Math.PI) * Math.cos(ll.lonDec /180*Math.PI);
+		ret.y = (N+alt) * Math.cos(ll.latDec /180*Math.PI) * Math.sin(ll.lonDec /180*Math.PI);
+		ret.z = (N * Math.pow(ellipsoid.b, 2) / Math.pow(ellipsoid.a , 2) + alt) * Math.sin(ll.latDec /180*Math.PI);
+		return ret;
+	}
+
+	private static XyzCoordinates transform(XyzCoordinates from, TransformParameters transParams) {
+		Matrix coos = new Matrix(3, 1);
+		coos.matrix[0][0] = from.x;
+		coos.matrix[1][0] = from.y;
+		coos.matrix[2][0] = from.z;
+
+		Matrix shift = new Matrix(3,1);
+		shift.matrix[0][0] = transParams.dx;
+		shift.matrix[1][0] = transParams.dy;
+		shift.matrix[2][0] = transParams.dz;
+
+		coos.add(shift);
+
+		Matrix rotate = new Matrix(3,3);
+		rotate.matrix[0][0] = 1;
+		rotate.matrix[1][1] = 1;
+		rotate.matrix[2][2] = 1;
+		rotate.matrix[0][1] = transParams.ez; 
+		rotate.matrix[0][2] = - transParams.ey;
+		rotate.matrix[1][0] = - rotate.matrix[0][1];
+		rotate.matrix[1][2] = transParams.ex;
+		rotate.matrix[2][0] = - rotate.matrix[0][2];
+		rotate.matrix[2][1] = - rotate.matrix[1][2];
+
+		rotate.multiply(coos);
+		coos = rotate;
+		coos.multiplyByScalar(transParams.s); // scale
+
+		return new XyzCoordinates(coos.matrix[0][0], coos.matrix[1][0], coos.matrix[2][0]);
+	}
+
+	private static CWPoint xyz2Latlon(XyzCoordinates from, Ellipsoid ellipsoid) {
+		double e2 = (ellipsoid.a * ellipsoid.a - ellipsoid.b * ellipsoid.b)/(ellipsoid.a * ellipsoid.a);
+		double s = Math.sqrt( Math.pow(from.x,2) + Math.pow(from.y,2));
+		double T = Math.atan( from.z * ellipsoid.a / (s * ellipsoid.b));
+		double B = Math.atan( (from.z + e2 * Math.pow(ellipsoid.a, 2) / ellipsoid.b * Math.pow(Math.sin(T), 3) )/(s - e2 * ellipsoid.a * Math.pow(Math.cos(T),3)));
+		double L = Math.atan(from.y / from.x);
+		// not used: double N = ellipsoid.a / Math.sqrt(1 - e2 * Math.pow(Math.sin(B),2));
+		// not used: double h = s / Math.cos(B)- N;
+		CWPoint ret = new CWPoint();
+		ret.latDec = B * 180/Math.PI;
+		ret.lonDec = L * 180/Math.PI;
+		//ret.alt = h;
+		return ret;
+	}
+
+	private static GkPoint projectLatlon2GkStripeauto(CWPoint latlon, Ellipsoid ellipsoid, int stripewidth, float degreeOfStripe0, double scale) {
+		if (!latlon.isValid()) throw new IllegalArgumentException(&quot;projectLatlon2GK: lat-lon not valid&quot;);
+		double lonDec = latlon.lonDec;
+		lonDec -= degreeOfStripe0;
+		if (lonDec &lt; 0) lonDec += 360;
+		int stripe;
+		for (stripe = 0; stripe &lt;= 360; stripe += stripewidth) {
+			if (Math.abs(lonDec - stripe) &lt;= ((float)stripewidth) / 2) break;
+		}
+		return projectLatlon2GK(latlon, ellipsoid, stripewidth, stripe / stripewidth, degreeOfStripe0, scale);
+	}
+
+	/**
+	 * Project latlon to Gau&#223;-Kr&#252;ger-Coordinates on ellipsoid
+	 * @param latlon
+	 * @param ellipsoid
+	 * @return
+	 */
+	private static GkPoint projectLatlon2GK(CWPoint latlon, Ellipsoid ellipsoid, int stripewidth, int stripe, float degreeOfStripe0, double scale) {
+		double e2 = (ellipsoid.a * ellipsoid.a - ellipsoid.b * ellipsoid.b)/(ellipsoid.a * ellipsoid.a);
+		double l = (latlon.lonDec - degreeOfStripe0 - stripe * stripewidth) /180*Math.PI;
+		double B = latlon.latDec /180*Math.PI;
+		double N = ellipsoid.a/ Math.sqrt(1- e2 * Math.pow(Math.sin(B),2));
+		double nue = Math.sqrt(Math.pow(ellipsoid.a, 2) / Math.pow(ellipsoid.b, 2)* e2 * Math.pow(Math.cos(B), 2));
+		double t = Math.tan(B);
+
+		double n1 = (ellipsoid.a-ellipsoid.b)/(ellipsoid.a+ellipsoid.b);
+		double n2 = (ellipsoid.a+ellipsoid.b)/2 * (1+ Math.pow(n1, 2)/4 + Math.pow(n1, 4)/64);
+		double n3 = n1 * -3/2 + Math.pow(n1, 3) * 9/16  - Math.pow(n1, 5) * 3/32;
+		double n4 = Math.pow(n1, 2) * 15/16 - Math.pow(n1, 4) * 15/32;
+		double n5 = Math.pow(n1, 3) * -35/48 + Math.pow(n1, 5) * 105/256;
+		double n6 = Math.pow(n1, 4) * 315/512;
+		double arclength = n2 * (B + n3 * Math.sin(B*2) + n4 * Math.sin(B*4) + n5 * Math.sin(B*6) + n6 * Math.sin(B*8));
+
+		double h1 = t/2 * N * Math.pow(Math.cos(B), 2) * l*l;
+		double h2 = t/24 * N * Math.pow(Math.cos(B),4) * (5 - t*t + 9 * nue*nue + 4*Math.pow(nue, 4)) * Math.pow(l,4);
+		double northing = (arclength + h1 + h2) * scale;
+
+		double r1 = N * Math.cos(B) * l;
+		double r2 = N/6 * Math.pow(Math.cos(B), 3) * (1-t*t+nue*nue)*l*l*l;
+		double easting = (r1 + r2) * scale;		//+ stripe / stripewidth * 1000000 + 500000;
+		GkPoint ret = new GkPoint();
+		ret.set(easting, northing, stripe, stripewidth, degreeOfStripe0);
+		return ret;
+	}
+
+	/**
+	 * Converts Gau&#223;-Kr&#252;ger-coordinates into lat/lon on the respective ellipsoid
+	 * @param gkp
+	 * @param ellipsoid
+	 * @param stripewidth width in degree of the stripe of the Gau&#223;-Kr&#252;ger-System (3 degreee usually used in Gau&#223;-Kr&#252;ger, 6 degree usually in UTM)
+	 * @return
+	 */
+	private static CWPoint gk2LatLon (GkPoint gkp, Ellipsoid ellipsoid, double scale) {
+		double L0 = gkp.getStripeLon(); // decimal degree of the center of the stripe
+		double y = gkp.getRawEasting()/scale;
+
+		double e2 = (ellipsoid.a * ellipsoid.a - ellipsoid.b * ellipsoid.b)/(ellipsoid.a * ellipsoid.a);
+		// note: n1-n6 are similiar to the n1-n6 in projectLatlon2GK, but some term have different factors
+		double n1 = (ellipsoid.a-ellipsoid.b)/(ellipsoid.a+ellipsoid.b);
+		double n2 = (ellipsoid.a+ellipsoid.b)/2 * (1+ Math.pow(n1, 2)/4 + Math.pow(n1, 4)/64);
+		double n3 = n1 * 3/2 - Math.pow(n1, 3) * 27/32  + Math.pow(n1, 5) * 269/32;
+		double n4 = Math.pow(n1, 2) * 21/16 - Math.pow(n1, 4) * 55/32;
+		double n5 = Math.pow(n1, 3) * 151/96 - Math.pow(n1, 5) * 417/128;
+		double n6 = Math.pow(n1, 4) * 1097/512;
+
+		double B0 = (gkp.northing / scale) / n2;
+		double Bf = B0 + n3 * Math.sin(B0*2) + n4 * Math.sin(B0*4) + n5 * Math.sin(B0*6) + n6 * Math.sin(B0*8);
+
+		double Nf = ellipsoid.a / Math.sqrt (1- e2 * Math.pow(Math.sin(Bf), 2));
+		double nuef = Math.sqrt(ellipsoid.a * ellipsoid.a / ellipsoid.b / ellipsoid.b * e2 * Math.pow(Math.cos(Bf), 2));
+		double tf = Math.tan(Bf);
+
+		double la1 = tf / 2 / Nf/Nf * (-1-nuef*nuef) * y*y;
+		double la2 = tf /24 / Math.pow(Nf, 4) * (5 + 3*tf*tf + 6*nuef*nuef - 6*tf*tf * nuef*nuef - 4*Math.pow(nuef, 4) - 9*tf*tf*Math.pow(nuef, 4)) * Math.pow(y, 4);
+		// these deal with less than the overall calculation precision: double la3 = tf /720 / Math.pow(Nf, 6) * (-61 - 90*tf*tf - 45*Math.pow(tf,4) - 107*nuef*nuef + 162*tf*tf * Math.pow(nuef, 2) + 45*Math.pow(tf,4)*tf*Math.pow(nuef, 2)) * Math.pow(y, 6);
+		// these deal with less than the overall calculation precision: double la4 = tf /40320 / Math.pow(Nf, 8) * (1385+3663*tf*tf - 4095*Math.pow(tf,4) + 1575*Math.pow(nuef, 6)) * Math.pow(y, 8);
+		double lat = (Bf + la1 + la2) * 180 / Math.PI;
+
+		double lo1 = 1 / Nf / Math.cos(Bf) * y;
+		double lo2 = 1 / Math.pow(Nf, 3) / Math.cos(Bf) *  (-1 -tf*tf*2 - nuef*nuef) * Math.pow(y, 3) / 6;
+		double lon = L0 + (lo1 + lo2) * 180/Math.PI;
+		return new CWPoint(lat, lon);
+	}
+
+}
+
+class XyzCoordinates {
+	double x, y, z;
+	public XyzCoordinates (double xi, double yi, double zi) {
+		x = xi;
+		y = yi;
+		z = zi;
+	}
+}
+
+
+class TransformParameters {
+	// shift parameter in meter
+	double dx, dy, dz, 
+	// rotation parameter in rad
+	ex, ey, ez,
+	// scale as multiplicator
+	s;
+
+	/**
+	 * 
+	 * @param d shift in meter
+	 * @param exi rotation in seconds (change the sign of the values from <A HREF="http://crs.bkg.bund.de/crs-eu/">http://crs.bkg.bund.de/crs-eu/</A> )
+	 * @param si deviation of scale multiplied by 10^6 
+	 * @param addinverted
+	 */
+	public TransformParameters(double dxi, double dyi, double dzi, double exi, double eyi, double ezi, double si) {
+		set (dxi, dyi, dzi, exi, eyi, ezi, si, true);
+	}
+		
+	protected void set(double dxi, double dyi, double dzi, double exi, double eyi, double ezi, double si, boolean addinverted) {
+		dx = dxi; dy = dyi; dz = dzi; 
+		ex = exi * Math.PI/180/3600;
+		ey = eyi * Math.PI/180/3600; 
+		ez = ezi * Math.PI/180/3600;
+		s = 1/(1 - si * Math.pow(10, -6));
+		if (addinverted) {
+			inverted = new TransformParameters(this, false);
+			inverted.invert();
+		} else inverted = null;
+	}
+	
+	public TransformParameters(TransformParameters tp, boolean invert) {
+		dx = tp.dx;	dy = tp.dy;	dz = tp.dz;
+		ex = tp.ex;	ey = tp.ey;	ez = tp.ez;
+		s = tp.s;
+		if (invert) invert();
+	}
+
+	public void invert() {
+		dx *= -1; dy *= -1;	dz *= -1;
+		ex *= -1; ey *= -1;	ez *= -1;
+		s = 1/s;
+	}
+	public TransformParameters inverted = null;
+}
+
+

Added: experiments/EVE/src/cachewolf/navi/TransformCoordinatesProperties.java
===================================================================
--- experiments/EVE/src/cachewolf/navi/TransformCoordinatesProperties.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/navi/TransformCoordinatesProperties.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,95 @@
+package cachewolf.navi;
+import java.util.Properties;
+
+import cachewolf.CWPoint;
+import cachewolf.MyLocale;
+
+
+
+/**
+* Class to load the parameters of a datum shift of a map and
+* the projection parameters from an Inputstream by the corresponding
+* EPSG code
+* After instantiation you can simply use to and fromWGS84 to
+* convert between WGS84 and the given Coordinate reference system, given
+* by the EPSG code
+* Start offset in the language file: 4920  
+* @author Pfeffer
+*
+*/
+public class TransformCoordinatesProperties extends Properties {
+	public int epsgCode;
+	static final long serialVersionUID=0;
+/*	public TransformCoordinatesProperties(InputStream is) throws IOException {
+		super();
+		load(is);
+		epsgCode = Convert.toInt(getProperty(&quot;EpsgCode&quot;, &quot;-1&quot;));
+		if (epsgCode == -1) throw new IllegalArgumentException(MyLocale.getMsg(4922, &quot;EPSG code missing in: &quot;) + is.getName());
+	}
+*/	
+	public TransformCoordinatesProperties(int epsgcodei) {
+		if (!TransformCoordinates.isSupported(epsgcodei)) throw new IllegalArgumentException(
+				MyLocale.getMsg(4920, &quot;EPSG code &quot;) 
+				+ epsgcodei 
+				+ MyLocale.getMsg(4921, &quot; not supported&quot;));
+		epsgCode = epsgcodei;
+	}
+
+	/**
+	 * return ll transformed into the desired coordinate reference system
+	 * if the prjection is Gau&#223;-Kr&#252;ger, easting will be put in lonDec and
+	 * northing in latDec
+	 * @param ll
+	 * @return
+	 */
+	public static TrackPoint fromWgs84(TrackPoint ll, int epsgCode) {
+		TrackPoint ret = null;
+		switch (epsgCode) {
+		case TransformCoordinates.EPSG_WGS84:
+		case TransformCoordinates.EPSG_ETRS89:
+			ret = ll;
+		}
+		if (ret == null) {
+			int region = TransformCoordinates.getGkRegion(epsgCode);
+			if (region &gt; 0) {
+				GkPoint xy = TransformCoordinates.wgs84ToGaussKrueger(ll, epsgCode);
+				ret = xy.toTrackPoint(region);
+			} else {
+				throw new IllegalArgumentException(
+						MyLocale.getMsg(4923, &quot;fromWgs84: EPSG code &quot;) 
+						+ epsgCode 
+						+ MyLocale.getMsg(4921, &quot; not supported&quot;));
+			}
+		}
+		return ret;
+	}
+
+	/**
+	 * convert any supported coordinate reference system WGS84
+	 * if p is a Gau&#223;-Kr&#252;ger point, put latdec = northing, londec = easting 
+	 * @param p
+	 * @return
+	 */
+	public static CWPoint toWgs84(CWPoint p, int epsgCode) {
+		CWPoint ret = null;
+		switch (epsgCode) {
+		case TransformCoordinates.EPSG_WGS84:
+		case TransformCoordinates.EPSG_ETRS89:
+			ret = p;
+			break;
+		}
+		if (ret == null) {
+			int region = TransformCoordinates.getGkRegion(epsgCode);
+			if (region &gt; 0) {
+				GkPoint xy = new GkPoint(p.lonDec, p.latDec, TransformCoordinates.getGkRegion(epsgCode));
+				ret = TransformCoordinates.GkToWgs84(xy, region);
+			} else {
+				throw new IllegalArgumentException(
+						MyLocale.getMsg(4924, &quot;ToWgs84: EPSG code &quot;)
+						+ epsgCode
+						+ MyLocale.getMsg(4921, &quot; not supported&quot;));
+			}
+		}
+		return ret;
+	}
+}
\ No newline at end of file

Added: experiments/EVE/src/cachewolf/utils/Common.java
===================================================================
--- experiments/EVE/src/cachewolf/utils/Common.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/utils/Common.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,146 @@
+package cachewolf.utils;
+
+import cachewolf.MyLocale;
+import eve.io.File;
+
+public final class Common {
+
+	private static char digSep=MyLocale.getDigSeparator().charAt(0);
+	private static char notDigSep=MyLocale.getDigSeparator().charAt(0)=='.'?',':'.';
+	
+	/**
+	 * get double value from string. It interpretes &quot;.&quot; and &quot;,&quot; as decimal separator
+	 * when the string cannot be interpreted, return 0.
+	 * @param value
+	 * @return
+	 */
+	public static double parseDouble(String value){
+		// returns 0 for invalid arguments
+		try {
+			return parseDoubleException (value);
+		} catch (Exception e) {
+			return 0.0;
+		}
+	}
+
+	/**
+	 * throws some exception if the string could not be converted to double
+	 * @param value
+	 * @return
+	 */
+	public static double parseDoubleException (String value) {
+			return java.lang.Double.parseDouble(value.replace(notDigSep,digSep));
+	}
+	
+	public static int parseInt(String value){
+		try {
+			return java.lang.Integer.parseInt(value);
+		} catch (Exception e) {
+			return 0;
+		}
+	}
+	/**
+	 * Format a double as string with a given number of decimal places
+	 * @param d The double to format
+	 * @param decimalplaces number of digits after the decimal point
+	 * @return Formatted number
+	 */
+	public static String doubleToString(double d, int decimalplaces) {
+		String format=&quot;0.0000000000&quot;.substring(0,decimalplaces+2);
+		return MyLocale.formatDouble(d, format).replace(',', '.');
+	}
+	
+	/**
+	 * (De)codes the given text with rot13.
+	 * Text in [] won't be (de)coded.
+	 * @param text will be (de)coded in rot13
+	 * @return rot13 of text
+	 */
+	public static String rot13(String text) {
+		char[] dummy = new char[text.length()];
+		boolean convert = true;
+		char c;
+		for (int i = 0; i &lt; text.length(); i++) {
+			c = text.charAt(i);
+
+			if (convert &amp;&amp; ((c &gt;= 'a' &amp;&amp; c &lt;= 'm') || (c &gt;= 'A' &amp;&amp; c &lt;= 'M'))) {
+				dummy[i] = (char) (c + 13);
+			} 
+			else if (convert &amp;&amp; ((c &gt;= 'n' &amp;&amp; c &lt;= 'z') || (c &gt;= 'N' &amp;&amp; c &lt;= 'Z'))) {
+				dummy[i] = (char) (c - 13);
+			} 
+			else if (c == '[') {
+				convert = false;
+				dummy[i] = '[';
+			} 
+			else if (c == ']') {
+				convert = true;
+				dummy[i] = ']';
+			} 
+			else {
+				dummy[i] = c;
+			}
+		}// for
+		return new String(dummy);
+	}
+	
+/* Not used. SKG 20080316
+  	public static String stringToHex(String str){
+		StringBuffer strBuf = new StringBuffer();
+		StringBuffer strHex = new StringBuffer();
+		StringBuffer strTxt = new StringBuffer();
+		for (int i = 0; i &lt; str.length(); i++) {
+			strHex.append(Convert.longToHexString(str.charAt(i)) + &quot; &quot;);
+			strTxt.append(str.charAt(i)+ &quot;  &quot;);
+		}
+		strBuf.append(strTxt);
+		strBuf.append(&quot;\n&quot;);
+		strBuf.append(strHex);
+		return strBuf.toString();
+	}
+*/	
+	public static String clearForFileName(String str) {
+		String ret = str.replace('?', '_');
+		ret = ret.replace(' ', '-');
+		ret = ret.replace(':', '-');
+		return ret;
+	}
+	
+	/**
+	 * finds the correct (existing) extension to an image filename
+	 * @param filename without extension
+	 * @return filename with extension 
+	 */
+	static public String getImageName(String name) {
+		String fileName;
+		File tmp;
+		String[] t = {&quot;.png&quot;, &quot;.gif&quot;, &quot;.jpg&quot;, &quot;.bmp&quot;};
+		int i;
+		for (i = 0; i&lt;t.length; i++) {
+			tmp = new File(name+t[i]);
+			if (tmp.exists()) break;
+		}
+		if (i &gt;=t.length) fileName = null;
+		else fileName = name+t[i];
+		return fileName;
+	}
+	/** get the extension of a filename, including &quot;.&quot;
+	 * remark: eve.io.File.getFileExtension return name + extension
+	 * @param fn
+	 * @return
+	 */
+	public static String getFilenameExtension (String fn) {
+		if (fn == null || fn.length() == 0) return &quot;&quot;;
+		int dot = fn.lastIndexOf(&quot;.&quot;);
+		if (dot &lt; 0) return &quot;&quot;;
+		return fn.substring(dot, fn.length());
+	}
+	
+	public static String fixSerialPortName(String name) {
+		if (name.startsWith(&quot;/&quot;)) 
+			return new String(&quot;..&quot;+name); // on linux (*nix) machines it is quite usual to give the complete file path to the serial port, but ewe expects only &quot;ttyS0&quot; or similar
+		else                      
+			return name;
+	}
+
+}

Added: experiments/EVE/src/cachewolf/utils/DateFormat.java
===================================================================
--- experiments/EVE/src/cachewolf/utils/DateFormat.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/utils/DateFormat.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,54 @@
+package cachewolf.utils;
+/* Several date formats are used by GC.COM
+ *    2/27/2004   - Hidden dates are in format mm/dd/yyyy (=US style)
+ *    February 27 - Found dates which happened this year
+ *    February 27, 2004 - Found date in previous year
+ * The internal standard is sortable:
+ *    2004-02-27    - YYYY-MM-DD   
+ */
+import eve.sys.Time;
+import eve.sys.Convert;
+
+public class DateFormat {
+
+/** Convert the US Format into a sortable format */
+public static String MDY2YMD(String date) {
+	// Dates are in format M/D/Y
+	int p1,p2=-1;
+	p1=date.indexOf(&quot;/&quot;);
+	if (p1&gt;0) p2=date.indexOf(&quot;/&quot;,p1+1);
+	if (p1&gt;0 &amp;&amp; p2&gt;0) {
+		return date.substring(p2+1)+&quot;-&quot;+
+		        (p1==1?&quot;0&quot;:&quot;&quot;)+date.substring(0,p1)+&quot;-&quot;+
+		        (p1+2==p2?&quot;0&quot;:&quot;&quot;)+date.substring(p1+1,p2);
+	} 
+	return date;
+}
+
+/* Convert the sortable date into a US date */
+//static String YMD2MDY(String date) {
+//	return date.substring(4,6)+&quot;/&quot;+date.substring(6,8)+&quot;/&quot;+date.substring(0,4);
+//}
+
+/** Convert the log format into a sortable format */
+public static String logdate2YMD(String logdate) {
+   String monthNames[]={&quot;January&quot;,&quot;February&quot;,&quot;March&quot;,&quot;April&quot;,&quot;May&quot;,&quot;June&quot;,&quot;July&quot;,&quot;August&quot;,&quot;September&quot;,&quot;October&quot;,&quot;November&quot;,&quot;December&quot;};
+   Time t=new Time();
+   String year,month,day;
+   int i,m;
+   logdate+=&quot;, &quot;+t.year; // If logdate already has a year, this one is ignored
+   i=logdate.indexOf(',');
+   year=logdate.substring(i+2,i+6);
+   for (m=0; m&lt;12; m++) {
+	   if (logdate.startsWith(monthNames[m])) {
+		   month=(m&lt;9?&quot;0&quot;:&quot;&quot;)+Convert.formatInt(m+1); //TODO Eliminate Convert
+		   day=logdate.substring(monthNames[m].length()+1,i);
+		   if (day.length()==1)day=&quot;0&quot;+day;
+		   return year+&quot;-&quot;+month+&quot;-&quot;+day;
+	   }
+   }
+   return &quot;&quot;;
+}
+
+
+}

Added: experiments/EVE/src/cachewolf/utils/Extractor.java
===================================================================
--- experiments/EVE/src/cachewolf/utils/Extractor.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/utils/Extractor.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,84 @@
+package cachewolf.utils;
+
+
+/**
+*	This is a powerfull class that is used very often. It is quicker than
+*	XML parsing and should be used whenever possible to find and extract
+*	parts of a string in a string.
+*/
+public class Extractor  {
+		int startOffset; // No initialisation needed, done in constructor
+		String searchText;
+		String start;
+		String end;
+		String tst;
+		boolean betweenonly;
+		public static boolean INCLUDESTARTEND = false;
+		public static final boolean EXCLUDESTARTEND = true;
+		/**
+		*	Create an extractor.
+		*	sTxt = The string to search through.&lt;br&gt;
+		*	st = The string that denotes the start of the string to extract&lt;br&gt;
+		*	e = The string that denotes the end of the string to extract&lt;br&gt;
+		*	sOff = The beginning offset from which to start the search in sTxt&lt;br&gt;
+		*	only = if false the string returned will inlcude st and e; if true
+		*	it will not include st and e.
+		*
+		*/
+		public Extractor(String sTxt, String st, String e, int sOff, boolean only){
+			startOffset = sOff;
+			searchText = sTxt;
+			//Vm.debug(&quot;Start &quot; + st);
+			end = e;
+			//Vm.debug(&quot;End: &quot; + e);
+			start = st;
+			betweenonly = only;
+		}
+		
+		/**
+		 * Mehtod to set the source text to be searched through
+		 * 
+		 */
+		public void setSource(String sTxt){
+			searchText = sTxt;
+			//Vm.debug(&quot;Searchtext: &quot; + searchText);
+			startOffset = 0;
+		}
+		
+		/**
+		* Method that informs if the search has encountered the end of the string
+		* that is being searched through.
+		*/
+		public boolean endOfSearch(){
+			if(searchText == null || startOffset &gt;= searchText.length()) 
+				return true;
+			return false;
+		}
+		
+		/**
+		*	Method to find the next occurance of a string that is enclosed by
+		*	that start (st) and end string (e). if end is not found the string
+		*	is returned til it's end.
+		*/
+		public String findNext(){
+			if (searchText == null) return &quot;&quot;; //maby null should 
+			int idxStart = searchText.indexOf(start,startOffset);
+			int idxEnd = searchText.indexOf(end, idxStart+start.length());
+			////Vm.debug(&quot;Start: &quot; + Convert.toString(idxStart) + &quot; End: &quot; + Convert.toString(idxEnd));
+			if(idxEnd == -1) idxEnd = searchText.length(); //index counts from zero length from 1 but the last char is not included in substr and substr accepts length +1 (but not length+2)
+			startOffset = idxEnd;
+			tst = &quot;&quot;;
+			if(idxStart &gt; -1){
+				if(betweenonly == false){
+					if (idxEnd+end.length() &gt;= searchText.length()) 
+						 tst = searchText.substring(idxStart);
+					else tst = searchText.substring(idxStart,idxEnd+end.length());
+				}else{ 
+					tst = searchText.substring(idxStart+start.length(),idxEnd);
+				}
+			} else {
+				startOffset = searchText.length();
+			}
+			return tst;
+		}
+}

Added: experiments/EVE/src/cachewolf/utils/Matrix.java
===================================================================
--- experiments/EVE/src/cachewolf/utils/Matrix.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/utils/Matrix.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,277 @@
+package cachewolf.utils;
+
+import eve.sys.*;
+
+public class Matrix{
+	int iDF = 0;
+	
+	public double matrix[][] = new double[0][0];
+	
+	public Matrix (int rows, int cols){
+		matrix = new double[rows][cols];
+	}
+	
+	public Matrix (Matrix srcMatrix){
+		matrix = new double[srcMatrix.matrix.length][srcMatrix.matrix[0].length];
+		for (int i = 0; i &lt; srcMatrix.matrix.length; i++)
+			for (int j = 0; j &lt; srcMatrix.matrix[i].length; j++)
+				matrix[i][j] = srcMatrix.matrix[i][j];
+	}
+	
+	/**
+	*	Method to multiply this matrix with another matrix.
+	*	The result is stored in this matrix!
+	*/
+	public void multiply(Matrix srcMatrix){
+		double m[][] = new double[matrix.length][srcMatrix.matrix[0].length];
+		for (int i = 0; i &lt; m.length; i++)
+			for (int j = 0; j &lt; m[i].length; j++){
+				//Vm.debug(&quot;i: &quot; + i + &quot; j: &quot; + j);
+				m[i][j] = calculateRowColumnProduct(matrix,i,srcMatrix.matrix,j);
+			}
+		
+		matrix = new double[m.length][m[0].length];
+		for (int i = 0; i &lt; m.length; i++)
+			for (int j = 0; j &lt; m[i].length; j++)
+				matrix[i][j] = m[i][j];
+	}
+	
+	/**
+	*	Method to calculate the row column product of two matrices.
+	*	Is used by the Multiply method.
+	*/
+	private double calculateRowColumnProduct(double[][] A, int row, double[][] B, int col){
+		double product = 0;
+		for(int i = 0; i &lt; A[row].length; i++){
+			//Vm.debug(&quot;i = &quot; + i + &quot; row = &quot; + row + &quot; col = &quot; + col);
+			product +=A[row][i]*B[i][col];
+		}
+		return product;
+	}
+	
+	public void multiplyByScalar (double f) {
+		for (int i = 0; i &lt; matrix.length; i++)
+			for (int j = 0; j &lt; matrix[0].length; j++)
+				matrix[i][j] = matrix[i][j] * f;
+	}
+	
+	public void add (Matrix a) {
+		for (int i = 0; i &lt; matrix.length; i++)
+			for (int j = 0; j &lt; matrix[0].length; j++)
+				matrix[i][j] = matrix[i][j] + a.matrix[i][j];
+	}
+	
+	/**
+	*	Method to transpose a matrix
+	*	example:	| 1 2 |
+	*			| 3 4 |
+	*			| 5 6 |
+	*	would become:	|1 3 5 |
+	*			|2 4 6 |
+	*/
+	public void transpose(){
+		
+		double m[][] = new double[matrix[0].length][matrix.length];
+		for (int i = 0; i &lt; matrix.length; i++)
+			for (int j = 0; j &lt; matrix[i].length; j++)
+				m[j][i] = matrix[i][j];
+			
+		matrix = new double[m.length][m[0].length];
+		for (int i = 0; i &lt; m.length; i++)
+			for (int j = 0; j &lt; m[i].length; j++)
+				matrix[i][j] = m[i][j];
+	}
+	
+	/**
+	*	private version of the Transpose method.
+	*	used internally in this class
+	*/
+	private double[][] Transpose2(double[][] a) {
+		
+		double m[][] = new double[a[0].length][a.length];
+
+		for (int i = 0; i &lt; a.length; i++)
+			for (int j = 0; j &lt; a[i].length; j++)
+				m[j][i] = a[i][j];
+		return m;
+	}
+	
+	/**
+	*	Method to display the contents of a matrix.
+	*/
+	public void dumpMatrix(){
+		for (int i = 0; i &lt; matrix.length; i++)
+			for (int j = 0; j &lt; matrix[i].length; j++)
+				Vm.debug(&quot;[ &quot;+i+ &quot; &quot; + j + &quot; ] &quot; + matrix[i][j]);
+	}
+	
+	/**
+	*	Method used to help calculate determinate
+	*/
+	private double[][] UpperTriangle(double[][] m) {
+		double f1 = 0;
+		double temp = 0;
+		int tms = m.length; // get This Matrix Size (could be smaller than
+							// global)
+		int v = 1;
+		iDF = 1;
+
+		for (int col = 0; col &lt; tms - 1; col++) {
+			for (int row = col + 1; row &lt; tms; row++) {
+				v = 1;
+				outahere: while (m[col][col] == 0) // check if 0 in diagonal
+				{ // if so switch until not
+					if (col + v &gt;= tms) // check if switched all rows
+					{
+						iDF = 0;
+						break outahere;
+					} 
+					for (int c = 0; c &lt; tms; c++) {
+						temp = m[col][c];
+						m[col][c] = m[col + v][c]; // switch rows
+						m[col + v][c] = temp;
+					}
+					v++; // count row switchs
+					iDF = iDF * -1; // each switch changes determinant
+									// factor
+				}
+				if (m[col][col] != 0) {
+					try {
+						f1 = (-1) * m[row][col] / m[col][col];
+						for (int i = col; i &lt; tms; i++) {
+							m[row][i] = f1 * m[col][i] + m[row][i];
+						}
+					} catch (Exception e) {
+						Vm.debug(&quot;Still Here!!!&quot;);
+					}
+				}
+			}
+		}
+		return m;
+	}
+	
+	/**
+	*	Method to calculate the determinate of a matrix
+	*/
+	public double determinant(double[][] matrix) {
+		int tms = matrix.length;
+		double det = 1;
+		matrix = UpperTriangle(matrix);
+		for (int i = 0; i &lt; tms; i++) {
+			det = det * matrix[i][i];
+		} // multiply down diagonal
+		det = det * iDF; // adjust w/ determinant factor
+		return det;
+	}
+	
+	
+	
+	/**
+	*	Method to calculate the inverse of this matrix.
+	*	The result is stored in this matrix!
+	*/
+	public void inverse() {
+		// Formula used to Calculate Inverse:
+		// inv(A) = 1/det(A) * adj(A)
+		
+		int tms = matrix.length;
+
+		double m[][] = new double[tms][tms];
+		double mm[][] = Adjoint(matrix);
+
+		double det = determinant(matrix);
+		double dd = 0;
+
+		if (det == 0) {
+			Vm.debug(&quot;Determinant Equals 0, Not Invertible.&quot;);
+		} else {
+			dd = 1 / det;
+		}
+		for (int i = 0; i &lt; tms; i++)
+			for (int j = 0; j &lt; tms; j++) {
+				m[i][j] = dd * mm[i][j];
+			}
+			
+		//Store back results
+		matrix = new double[m.length][m[0].length];
+		for (int i = 0; i &lt; m.length; i++)
+			for (int j = 0; j &lt; m[i].length; j++)
+				matrix[i][j] = m[i][j];
+	}
+	
+	/**
+	*	Method to calculate the adjoint of a matrix.
+	*	Required to calculate the inverse of a matrix.
+	*/
+	private double[][] Adjoint(double[][] a) {
+		int tms = a.length;
+
+		double m[][] = new double[tms][tms];
+
+		int ii, jj, ia, ja;
+		double det;
+
+		for (int i = 0; i &lt; tms; i++)
+			for (int j = 0; j &lt; tms; j++) {
+				ia = ja = 0;
+				double ap[][] = new double[tms - 1][tms - 1];
+				for (ii = 0; ii &lt; tms; ii++) {
+					for (jj = 0; jj &lt; tms; jj++) {
+						if ((ii != i) &amp;&amp; (jj != j)) {
+							ap[ia][ja] = a[ii][jj];
+							ja++;
+						}
+					}
+					if ((ii != i) &amp;&amp; (jj != j)) {
+						ia++;
+					}
+					ja = 0;
+				}
+				det = determinant(ap);
+				m[i][j] = java.lang.Math.pow(-1, i + j) * det;
+			}
+		m = Transpose2(m);
+		return m;
+	}
+	
+	/**
+	*	&quot;Old&quot; helper method used by some other classes in cachewolf.
+	*	//@deprecated Do not use when coding new classes!
+	*/
+	public static double dot(double p1, double p2, double q1, double q2, double x1, double x2){
+		double dt,AB0,AB1,BC0,BC1 = 0;
+		AB0 = q1 - p1;
+		AB1 = q2 - p2;
+		BC0 = x1-q1;
+		BC1 = x2-q2;
+		dt = AB0 * BC0 + AB1 * BC1;
+		return dt;
+	}
+	
+	/**
+	*	&quot;Old&quot; helper method used by some other classes in cachewolf.
+	*	//@deprecated Do not use when coding new classes!
+	*/
+	public static double cross(double p1, double p2, double q1, double q2, double x1, double x2){
+		double cr,AB0,AB1,AC0,AC1 = 0;
+		AB0 = q1 - p1;
+		AB1 = q2 - p2;
+		AC0 = x1-p1;
+		AC1 = x2-p2;
+		cr= AB0 * AC1 - AB1 * AC0;
+		return cr;
+	}
+	
+	/**
+	*	&quot;Old&quot; helper method used by some other classes in cachewolf.
+	*	//@deprecated Do not use when coding new classes!
+	*/
+	public static double dist(double p1, double p2, double q1, double q2){
+		double d1, d2,dt = 0;
+		d1 = p1 - q1;
+		d2 = p2 - q2;
+		dt = d1 * d1 + d2 * d2;
+		dt = java.lang.Math.sqrt(dt);
+		return dt;
+	}
+}
\ No newline at end of file

Added: experiments/EVE/src/cachewolf/utils/ParseLatLon.java
===================================================================
--- experiments/EVE/src/cachewolf/utils/ParseLatLon.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/utils/ParseLatLon.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,91 @@
+package cachewolf.utils;
+
+import cachewolf.Global;
+import eve.sys.*;
+import cachewolf.MyLocale;
+
+/**
+*	This class parses a string representation of longitude and latitude.
+*	The result is a double value representing longitude and another representing
+*	latitude (DD.dddd)
+*/
+public class ParseLatLon {
+
+	String latlon;
+	/**
+	*	After a calling the method parse()
+	*	this variable holds the double value of latitude
+	*/
+	public double lat2;
+	/**
+	*	After a calling the method parse()
+	*	this variable holds the double value of longitude
+	*/
+	public double lon2;
+
+	private char digSep;
+
+	/**
+	*	Constructor to parse a lat lon string like:
+	*	N 49 33.167 E 011 21.608
+	*/
+	public ParseLatLon (String ll){
+		latlon = ll;
+		digSep=MyLocale.getDigSeparator().charAt(0);
+	}
+
+	/**
+	*	Constructor to parse a lat lon string like:
+	*	N 49 33.167 E 011 21.608.
+	*	Additionally you may pass the decimal symbol, i.e. &quot;.&quot; or &quot;,&quot;
+	*/
+	public ParseLatLon (String ll, String tr){
+		latlon = ll;
+		digSep=MyLocale.getDigSeparator().charAt(0);
+	}
+
+	private int start;
+	private int end;
+
+	/** Get the next non-blank part of the latlon String */
+	String getNext() {
+        start=end;
+		while (latlon.charAt(start)==' ')start++; // skip blanks
+        end=start;
+        while (latlon.charAt(end)!=' ') end++; // collect non-blanks
+		return latlon.substring(start,end);
+	}
+
+	/**
+	* Parse a string that contains lat lon into it's lat and lon doubles. Class
+	* variable latlon must have been set befor you call this method.
+	*/
+	public void parse() throws NumberFormatException {
+		if (digSep==',')
+			latlon = latlon.replace('.', ',')+&quot; &quot;;
+		else
+			latlon = latlon.replace(',', '.')+&quot; &quot;;
+		try {
+			end=0;
+			String latNS=getNext();
+			String latDeg=getNext();
+			String latMin=getNext();
+			String lonEW=getNext();
+			String lonDeg=getNext();
+			String lonMin=getNext();
+			if (lonDeg.endsWith(&quot;&#176;&quot;)){
+				lonDeg = lonDeg.substring(0,lonDeg.length()-1); // remove &#176;
+			}
+			if (latDeg.endsWith(&quot;&#176;&quot;)){
+				latDeg = latDeg.substring(0,latDeg.length()-1);// remove &#176;
+			}
+			lat2 = Convert.parseDouble(latDeg) + Convert.parseDouble(latMin)/60.0;
+			if(latNS.charAt(0)=='S') lat2= -lat2 ;
+			lon2 = Convert.parseDouble(lonDeg) + Convert.parseDouble(lonMin)/60.0;
+			if(lonEW.charAt(0)=='W') lon2 = -lon2;
+		} catch (Exception e) {
+			throw new NumberFormatException(&quot;Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM&quot;);
+		}
+
+	}
+}

Added: experiments/EVE/src/cachewolf/utils/STRreplace.java
===================================================================
--- experiments/EVE/src/cachewolf/utils/STRreplace.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/utils/STRreplace.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,32 @@
+package cachewolf.utils;
+
+
+public class STRreplace{
+		/* Replace all instances of a String in a String.
+		 *   @param  s  String to alter.
+		 *   @param  f  String to look for.
+		 *   @param  r  String to replace it with, or null to just remove it.
+		 */ 
+		public static String replace( String s, String f, String r )
+		{
+		   if (s == null)  return s;
+		   if (f == null)  return s;
+		   if (r == null)  r = &quot;&quot;;
+		
+		   int index01 = s.indexOf( f );
+		   int index02 = 0;
+		   StringBuffer sb = new StringBuffer();
+		   while (index01 != -1)
+		   {
+			   sb.append(s.substring(index02,index01)).append(r);			   
+			   index02 = index01 + f.length();
+			   index01 = s.indexOf( f, index02 );
+			  /* original impl.
+			  s = s.substring(0,index01) + r + s.substring(index01+f.length());
+			  index01 += r.length();
+			  index01 = s.indexOf( f, index01 );
+			  */
+		   }
+		   return sb.append(s.substring(index02)).toString();
+		}
+}

Added: experiments/EVE/src/cachewolf/utils/SafeXML.java
===================================================================
--- experiments/EVE/src/cachewolf/utils/SafeXML.java	2008-10-11 10:42:26 UTC (rev 1537)
+++ experiments/EVE/src/cachewolf/utils/SafeXML.java	2008-10-15 20:07:59 UTC (rev 1538)
@@ -0,0 +1,521 @@
+package cachewolf.utils;
+
+/**
+*	A class to replace unsafe XML characters with characters that a user
+*	&quot;can read&quot;, and vice versa
+* 20061222: skg Modified cleanback to speed up the new index.xml reader
+*/
+
+import java.util.Hashtable;
+
+public class SafeXML{
+	private static final char ENTITY_START = '&amp;';
+	private static final char ENTITY_END = ';';
+	
+	private static Hashtable iso2htmlMappings = new Hashtable(300);
+	static {
+		String[] mappingArray = new String[] {
+				&quot;&apos;&quot;,   &quot;'&quot;,		// Added 20061227 - not a valid HTML entity but sometimes used
+				&quot;&quot;&quot;,   &quot;\&quot;&quot;,
+				&quot;&amp;&quot;,    &quot;&amp;&quot;,
+				&quot;&lt;&quot;,     &quot;&lt;&quot;,
+				&quot;&gt;&quot;,     &quot;&gt;&quot;,
+				&quot;&nbsp;&quot;,   &quot; &quot;,
+				&quot;&iexcl;&quot;,  &quot;&#161;&quot;,
+				&quot;&cent;&quot;,   &quot;&#162;&quot;,
+				&quot;&pound;&quot;,  &quot;&#163;&quot;,
+				&quot;&curren;&quot;, &quot;&#164;&quot;,
+				&quot;&yen;&quot;,    &quot;&#165;&quot;,
+				&quot;&brvbar;&quot;, &quot;&#166;&quot;,
+				&quot;&sect;&quot;,   &quot;&#167;&quot;,
+				&quot;&uml;&quot;,    &quot;&#168;&quot;,
+				&quot;&copy;&quot;,   &quot;&#169;&quot;,
+				&quot;&ordf;&quot;,   &quot;&#170;&quot;,
+				&quot;&laquo;&quot;,  &quot;&#171;&quot;,
+				&quot;&not;&quot;,    &quot;&#172;&quot;,
+				&quot;&shy;&quot;,    &quot;&#173;&quot;,
+				&quot;&reg;&quot;,    &quot;&#174;&quot;,
+				&quot;&macr;&quot;,   &quot;&#175;&quot;,
+				&quot;&deg;&quot;,    &quot;&#176;&quot;,
+				&quot;&plusmn;&quot;, &quot;&#177;&quot;,
+				&quot;&amp;sup2;&quot;,   &quot;&#178;&quot;,
+				&quot;&amp;sup3;&quot;,   &quot;&#179;&quot;,
+				&quot;&acute;&quot;,  &quot;&#180;&quot;,
+				&quot;&micro;&quot;,  &quot;&#181;&quot;,
+				&quot;&para;&quot;,   &quot;&#182;&quot;,
+				&quot;&middot;&quot;, &quot;&#183;&quot;,
+				&quot;&cedil;&quot;,  &quot;&#184;&quot;,
+				&quot;&amp;sup1;&quot;,   &quot;&#185;&quot;,
+				&quot;&ordm;&quot;,   &quot;&#186;&quot;,
+				&quot;&raquo;&quot;,  &quot;&#187;&quot;,
+				&quot;&amp;frac14;&quot;, &quot;&#188;&quot;,
+				&quot;&amp;frac12;&quot;, &quot;&#189;&quot;,
+				&quot;&amp;frac34;&quot;, &quot;&#190;&quot;,
+				&quot;&iquest;&quot;, &quot;&#191;&quot;,
+				&quot;&Agrave;&quot;, &quot;&#192;&quot;,
+				&quot;&Aacute;&quot;, &quot;&#193;&quot;,
+				&quot;&Acirc;&quot;,  &quot;&#194;&quot;,
+				&quot;&Atilde;&quot;, &quot;&#195;&quot;,
+				&quot;&Auml;&quot;,   &quot;&#196;&quot;,
+				&quot;&Aring;&quot;,  &quot;&#197;&quot;,
+				&quot;&AElig;&quot;,  &quot;&#198;&quot;,
+				&quot;&Ccedil;&quot;, &quot;&#199;&quot;,
+				&quot;&Egrave;&quot;, &quot;&#200;&quot;,
+				&quot;&Eacute;&quot;, &quot;&#201;&quot;,
+				&quot;&Ecirc;&quot;,  &quot;&#202;&quot;,
+				&quot;&Euml;&quot;,   &quot;&#203;&quot;,
+				&quot;&Igrave;&quot;, &quot;&#204;&quot;,
+				&quot;&Iacute;&quot;, &quot;&#205;&quot;,
+				&quot;&Icirc;&quot;,  &quot;&#206;&quot;,
+				&quot;&Iuml;&quot;,   &quot;&#207;&quot;,
+				&quot;&ETH;&quot;,    &quot;&#208;&quot;,
+				&quot;&Ntilde;&quot;, &quot;&#209;&quot;,
+				&quot;&Ograve;&quot;, &quot;&#210;&quot;,
+				&quot;&Oacute;&quot;, &quot;&#211;&quot;,
+				&quot;&Ocirc;&quot;,  &quot;&#212;&quot;,
+				&quot;&Otilde;&quot;, &quot;&#213;&quot;,
+				&quot;&Ouml;&quot;,   &quot;&#214;&quot;,
+				&quot;&times;&quot;,  &quot;&#215;&quot;,
+				&quot;&Oslash;&quot;, &quot;&#216;&quot;,
+				&quot;&Ugrave;&quot;, &quot;&#217;&quot;,
+				&quot;&Uacute;&quot;, &quot;&#218;&quot;,
+				&quot;&Ucirc;&quot;,  &quot;&#219;&quot;,
+				&quot;&Uuml;&quot;,   &quot;&#220;&quot;,
+				&quot;&Yacute;&quot;, &quot;&#221;&quot;,
+				&quot;&THORN;&quot;,  &quot;&#222;&quot;,
+				&quot;&szlig;&quot;,  &quot;&#223;&quot;,
+				&quot;&agrave;&quot;, &quot;&#224;&quot;,
+				&quot;&aacute;&quot;, &quot;&#225;&quot;,
+				&quot;&acirc;&quot;,  &quot;&#226;&quot;,
+				&quot;&atilde;&quot;, &quot;&#227;&quot;,
+				&quot;&auml;&quot;,   &quot;&#228;&quot;,
+				&quot;&aring;&quot;,  &quot;&#229;&quot;,
+				&quot;&aelig;&quot;,  &quot;&#230;&quot;,
+				&quot;&ccedil;&quot;, &quot;&#231;&quot;,
+				&quot;&egrave;&quot;, &quot;&#232;&quot;,
+				&quot;&eacute;&quot;, &quot;&#233;&quot;,
+				&quot;&ecirc;&quot;,  &quot;&#234;&quot;,
+				&quot;&euml;&quot;,   &quot;&#235;&quot;,
+				&quot;&igrave;&quot;, &quot;&#236;&quot;,
+				&quot;&iacute;&quot;, &quot;&#237;&quot;,
+				&quot;&icirc;&quot;,  &quot;&#238;&quot;,
+				&quot;&iuml;&quot;,   &quot;&#239;&quot;,
+				&quot;&eth;&quot;,    &quot;&#240;&quot;,
+				&quot;&ntilde;&quot;, &quot;&#241;&quot;,
+				&quot;&ograve;&quot;, &quot;&#242;&quot;,
+				&quot;&oacute;&quot;, &quot;&#243;&quot;,
+				&quot;&ocirc;&quot;,  &quot;&#244;&quot;,
+				&quot;&otilde;&quot;, &quot;&#245;&quot;,
+				&quot;&ouml;&quot;,   &quot;&#246;&quot;,
+				&quot;&divide;&quot;, &quot;&#247;&quot;,
+				&quot;&oslash;&quot;, &quot;&#248;&quot;,
+				&quot;&ugrave;&quot;, &quot;&#249;&quot;,
+				&quot;&uacute;&quot;, &quot;&#250;&quot;,
+				&quot;&ucirc;&quot;,  &quot;&#251;&quot;,
+				&quot;&uuml;&quot;,   &quot;&#252;&quot;,
+				&quot;&yacute;&quot;, &quot;&#253;&quot;,
+				&quot;&thorn;&quot;,  &quot;&#254;&quot;,
+				&quot;&yuml;&quot;,   &quot;&#255;&quot;,
+				
+				&quot;&#34;&quot;,  &quot;\&quot;&quot;,
+				&quot;&#38;&quot;,  &quot;&amp;&quot;,
+				&quot;&#39;&quot;,  &quot;'&quot;,
+				&quot;&#60;&quot;,  &quot;&lt;&quot;,
+				&quot;&#62;&quot;,  &quot;&gt;&quot;,
+				&quot;&#160;&quot;, &quot; &quot;,
+				&quot;&#161;&quot;, &quot;&#161;&quot;,
+				&quot;&#162;&quot;, &quot;&#162;&quot;,
+				&quot;&#163;&quot;, &quot;&#163;&quot;,
+				&quot;&#164;&quot;, &quot;&#164;&quot;,
+				&quot;&#165;&quot;, &quot;&#165;&quot;,
+				&quot;&#166;&quot;, &quot;&#166;&quot;,
+				&quot;&#167;&quot;, &quot;&#167;&quot;,
+				&quot;&#168;&quot;, &quot;&#168;&quot;,
+				&quot;&#169;&quot;, &quot;&#169;&quot;,
+				&quot;&#170;&quot;, &quot;&#170;&quot;,
+				&quot;&#171;&quot;, &quot;&#171;&quot;,
+				&quot;&#172;&quot;, &quot;&#172;&quot;,
+				&quot;&#173;&quot;, &quot;&#173;&quot;,
+				&quot;&#174;&quot;, &quot;&#174;&quot;,
+				&quot;&#175;&quot;, &quot;&#175;&quot;,
+				&quot;&#176;&quot;, &quot;&#176;&quot;,
+				&quot;&#177;&quot;, &quot;&#177;&quot;,
+				&quot;&#178;&quot;, &quot;&#178;&quot;,
+				&quot;&#179;&quot;, &quot;&#179;&quot;,
+				&quot;&#180;&quot;, &quot;&#180;&quot;,
+				&quot;&#181;&quot;, &quot;&#181;&quot;,
+				&quot;&#182;&quot;, &quot;&#182;&quot;,
+				&quot;&#183;&quot;, &quot;&#183;&quot;,
+				&quot;&#184;&quot;, &quot;&#184;&quot;,
+				&quot;&#185;&quot;, &quot;&#185;&quot;,
+				&quot;&#186;&quot;, &quot;&#186;&quot;,
+				&quot;&#187;&quot;, &quot;&#187;&quot;,
+				&quot;&#188;&quot;, &quot;&#188;&quot;,
+				&quot;&#189;&quot;, &quot;&#189;&quot;,
+				&quot;&#190;&quot;, &quot;&#190;&quot;,
+				&quot;&#191;&quot;, &quot;&#191;&quot;,
+				&quot;&#192;&quot;, &quot;&#192;&quot;,
+				&quot;&#193;&quot;, &quot;&#193;&quot;,
+				&quot;&#194;&quot;, &quot;&#194;&quot;,
+				&quot;&#195;&quot;, &quot;&#195;&quot;,
+				&quot;&#196;&quot;, &quot;&#196;&quot;,
+				&quot;&#197;&quot;, &quot;&#197;&quot;,
+				&quot;&#198;&quot;, &quot;&#198;&quot;,
+				&quot;&#199;&quot;, &quot;&#199;&quot;,
+				&quot;&#200;&quot;, &quot;&#200;&quot;,
+				&quot;&#201;&quot;, &quot;&#201;&quot;,
+				&quot;&#202;&quot;, &quot;&#202;&quot;,
+				&quot;&#203;&quot;, &quot;&#203;&quot;,
+				&quot;&#204;&quot;, &quot;&#204;&quot;,
+				&quot;&#205;&quot;, &quot;&#205;&quot;,
+				&quot;&#206;&quot;, &quot;&#206;&quot;,
+				&quot;&#207;&quot;, &quot;&#207;&quot;,
+				&quot;&#208;&quot;, &quot;&#208;&quot;,
+				&quot;&#209;&quot;, &quot;&#209;&quot;,
+				&quot;&#210;&quot;, &quot;&#210;&quot;,
+				&quot;&#211;&quot;, &quot;&#211;&quot;,
+				&quot;&#212;&quot;, &quot;&#212;&quot;,
+				&quot;&#213;&quot;, &quot;&#213;&quot;,
+				&quot;&#214;&quot;, &quot;&#214;&quot;,
+				&quot;&#215;&quot;, &quot;&#215;&quot;,
+				&quot;&#216;&quot;, &quot;&#216;&quot;,
+				&quot;&#217;&quot;, &quot;&#217;&quot;,
+				&quot;&#218;&quot;, &quot;&#218;&quot;,
+				&quot;&#219;&quot;, &quot;&#219;&quot;,
+				&quot;&#220;&quot;, &quot;&#220;&quot;,
+				&quot;&#221;&quot;, &quot;&#221;&quot;,
+				&quot;&#222;&quot;, &quot;&#222;&quot;,
+				&quot;&#223;&quot;, &quot;&#223;&quot;,
+				&quot;&#224;&quot;, &quot;&#224;&quot;,
+				&quot;&#225;&quot;, &quot;&#225;&quot;,
+				&quot;&#226;&quot;, &quot;&#226;&quot;,
+				&quot;&#227;&quot;, &quot;&#227;&quot;,
+				&quot;&#228;&quot;, &quot;&#228;&quot;,
+				&quot;&#229;&quot;, &quot;&#229;&quot;,
+				&quot;&#230;&quot;, &quot;&#230;&quot;,
+				&quot;&#231;&quot;, &quot;&#231;&quot;,
+				&quot;&#232;&quot;, &quot;&#232;&quot;,
+				&quot;&#233;&quot;, &quot;&#233;&quot;,
+				&quot;&#234;&quot;, &quot;&#234;&quot;,
+				&quot;&#235;&quot;, &quot;&#235;&quot;,
+				&quot;&#236;&quot;, &quot;&#236;&quot;,
+				&quot;&#237;&quot;, &quot;&#237;&quot;,
+				&quot;&#238;&quot;, &quot;&#238;&quot;,
+				&quot;&#239;&quot;, &quot;&#239;&quot;,
+				&quot;&#240;&quot;, &quot;&#240;&quot;,
+				&quot;&#241;&quot;, &quot;&#241;&quot;,
+				&quot;&#242;&quot;, &quot;&#242;&quot;,
+				&quot;&#243;&quot;, &quot;&#243;&quot;,
+				&quot;&#244;&quot;, &quot;&#244;&quot;,
+				&quot;&#245;&quot;, &quot;&#245;&quot;,
+				&quot;&#246;&quot;, &quot;&#246;&quot;,
+				&quot;&#247;&quot;, &quot;&#247;&quot;,
+				&quot;&#248;&quot;, &quot;&#248;&quot;,
+				&quot;&#249;&quot;, &quot;&#249;&quot;,
+				&quot;&#250;&quot;, &quot;&#250;&quot;,
+				&quot;&#251;&quot;, &quot;&#251;&quot;,
+				&quot;&#252;&quot;, &quot;&#252;&quot;,
+				&quot;&#253;&quot;, &quot;&#253;&quot;,
+				&quot;&#254;&quot;, &quot;&#254;&quot;,
+				&quot;&#255;&quot;, &quot;&#255;&quot;,
+				&quot;&#8208;&quot;, &quot;-&quot;,
+				&quot;&#8209;&quot;, &quot;-&quot;,
+				&quot;&#8210;&quot;, &quot;-&quot;,
+				&quot;&#8211;&quot;, &quot;-&quot;,
+				&quot;&#8212;&quot;, &quot;-&quot;,
+				&quot;&#8213;&quot;, &quot;-&quot;,
+				&quot;&#8216;&quot;, &quot;'&quot;,
+				&quot;&#8217;&quot;, &quot;'&quot;,
+				&quot;&#8218;&quot;, &quot;'&quot;,
+				&quot;&#8219;&quot;, &quot;'&quot;,
+				&quot;&#8220;&quot;, &quot;\&quot;&quot;,
+				&quot;&#8221;&quot;, &quot;\&quot;&quot;,
+				&quot;&#8222;&quot;, &quot;\&quot;&quot;,
+				&quot;&#8226;&quot;, &quot;&#149;&quot;,
+				&quot;&#8223;&quot;, &quot;\&quot;&quot;,
+				&quot;&#8242;&quot;, &quot;'&quot;,
+				&quot;&#8243;&quot;, &quot;\&quot;&quot;
+				};
+		for (int i = 0; i &lt; mappingArray.length; i = i + 2) {
+			iso2htmlMappings.put( mappingArray[i], mappingArray[i+1]);
+		}
+	}
+		
+	
+	
+	/**
+	 * Converts a &lt;code&gt;String&lt;/code&gt; containing HTML entities to
+	 * a &lt;code&gt;String&lt;/code&gt; containing only ISO8859-1 characters.
+	 * 
+	 * Uses &lt;a href=&quot;<A HREF="http://www.ramsch.org/martin/uni/fmi-hp/iso8859-1.html">http://www.ramsch.org/martin/uni/fmi-hp/iso8859-1.html</A>&quot;&gt;ISO
+	 * 8859-1 table by Martin Ramsch&lt;/a&gt;.
+	 * 
+	 * @author &lt;a href=&quot;mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">ey at inweb.de</A>&quot;&gt;Christian Ey&lt;/a&gt;
+	 *
+	 * @version 1.0
+	 * @param htmlString The &lt;code&gt;String&lt;/code&gt; containing HTML
+	 * 	entities
+	 * @return A &lt;code&gt;String&lt;/code&gt; containing only ISO8859-1
+	 * 	characters
+	 */
+	public static String cleanback( String htmlString) {
+		int indexStart;
+		// return immediately if string is null or does not contain &amp;
+		if (htmlString != null &amp;&amp; (indexStart = htmlString.indexOf( ENTITY_START))&gt;=0) {
+			// copy everything from the beginning to entity start into buffer
+			StringBuffer isoBuffer = new StringBuffer( htmlString.substring( 0, indexStart));
+			while (indexStart &gt;= 0) {
+				int indexEnd = htmlString.indexOf( ENTITY_END, indexStart + 1);
+				if (indexEnd &gt;= 0) {
+					int alternativeStart = htmlString.indexOf( ENTITY_START, indexStart + 1);
+					if ((alternativeStart &gt; indexStart) &amp;&amp; (alternativeStart &lt; indexEnd)) {
+						// a second index start is found inbetween current index start
+						// and index end
+						
+						// flush the html string inbetween
+						isoBuffer.append( htmlString.substring( indexStart, alternativeStart));
+						
+						// use the second index start and loop again
+						indexStart = alternativeStart;
+					} else {
+						String entity = htmlString.substring( indexStart, indexEnd + 1);
+						String isoCharacter = (String) iso2htmlMappings.get( entity);
+						if (isoCharacter != null) {
+							// insert iso character instead of html entity
+							isoBuffer.append( isoCharacter);
+						} else {
+							// illegal entity detected, ignore gracefully
+							isoBuffer.append( entity);
+						}
+						indexStart = htmlString.indexOf( ENTITY_START, indexEnd + 1);
+						if (indexStart &gt;= 0) {
+							// another entity start detected, flush the html string inbetween
+							isoBuffer.append( htmlString.substring( indexEnd + 1, indexStart));
+						} else {
+							// no further entity start detected, flush rest of html string
+							isoBuffer.append( htmlString.substring( indexEnd + 1));
+						}
+					}
+				} else {
+					// entity start without matching entity end detected, ignore gracefully
+					isoBuffer.append( htmlString.substring( indexStart));
+					break;
+				}
+			}
+			return isoBuffer.toString();
+		} else {
+			// nothing to do
+			return htmlString;
+		}
+	}
+
+	/**
+     * convert a single char to its equivalent HTML entity. Ordinary chars are
+     * not changed. 160 -&gt; &nbsp;
+     *
+     * @param c Char to convert
+     *
+     * @return equivalent string eg. &amp;, null means leave char as is.
+     */
+    protected static String charToEntity( char c )
+        {
+        switch ( c ) {
+	        case 34 : return &quot;&quot;&quot;;
+	        case 38 : return &quot;&amp;&quot;;
+	        case 60 : return &quot;&lt;&quot;;
+	        case 62 : return &quot;&gt;&quot;;
+            default :
+                if ( c &lt; 127 ) {
+                    // leave alone as equivalent string.
+                    return null;
+                    // faster than String.valueOf( c ).intern();
+                } else {
+                    // use the &amp;#nnn; form
+                    return &quot;&amp;#&quot; + Integer.toString( c ) + &quot;;&quot;;
+                }
+            } // end switch
+        } // end charToEntity
+
+    /**
+     * Converts text to HTML by quoting dangerous characters. Text must not
+     * already contain entities. e.g. &quot; ==&gt; &quot; &lt; ==&gt; &lt; ordinary text
+     * passes unchanged. Does not convert space to &nbsp;
+     *
+     * @param text raw text to be processed. Must not be null.
+     *
+     * @return translated text, or null if input is null.
+     */
+    public static String clean( String text ) {
+        if ( text == null ) return null;
+        int originalTextLength = text.length();
+        StringBuffer sb = new StringBuffer( originalTextLength * 110 / 100 );
+        int charsToAppend = 0;
+        for ( int i = 0; i &lt; originalTextLength; i++ ) {
+            char c = text.charAt( i );
+            String entity = charToEntity( c );
+            if ( entity == null ) {
+                // we could sb.append( c ), but that would be slower
+                // than saving them up for a big append.
+                charsToAppend++;
+            } else {
+                if ( charsToAppend != 0 ) {
+                    sb.append( text.substring( i - charsToAppend, i ) );
+                    charsToAppend = 0;
+                }
+                sb.append( entity );
+            }
+        } // end for
+        // append chars to the right of the last entity.
+        if ( charsToAppend != 0 ) {
+            sb.append( text.substring( originalTextLength - charsToAppend,
+                                       originalTextLength ) );
+        }
+
+        // if result is not longer, we did not do anything. Save RAM.
+        return ( sb.length() == originalTextLength ) ? text : sb.toString();
+    } // end insertEntities
+	
+	
+	public static String cleanGPX(String str){
+		String dummy = new String();
+		
+		dummy = STRreplace.replace(str, &quot;&amp;&quot;,&quot;&amp;&quot;);
+		dummy = STRreplace.replace(dummy, &quot;&lt;&quot;, &quot;&lt;&quot;);
+		dummy = STRreplace.replace(dummy, &quot;&gt;&quot;, &quot;&gt;&quot;);
+		//dummy = replace(dummy, &quot;&nbsp;&quot;, &quot;&amp;nbsp;&quot;);
+		dummy = STRreplace.replace(dummy, &quot;\&quot;&quot;, &quot;&quot;&quot;);
+		dummy = STRreplace.replace(dummy, &quot;'&quot;,&quot;&apos;&quot;);
+		dummy = STRreplace.replace(dummy, &quot;]]&gt;&quot;,&quot;]] &gt;&quot;);
+
+		return dummy;
+	}
+
+	/**
+	 * Converts a data string to something that is safe to use inside
+	 * an XML file (like prefs.xml) - entities like &amp; are *NOT*
+	 * valid XML unless declared specially, so we must use the numerical
+	 * values here.
+	 *
+	 * @param src (String) raw text to be processed
+	 *
+	 * @return (String) translated text, or null if input is null
+	 */
+	public static String strxmlencode(boolean src) {
+		/* bools are always safe */
+		return (src ? &quot;true&quot; : &quot;false&quot;);
+	}
+	public static String strxmlencode(int src) {
+		/* numbers are always safe */
+		return (Integer.toString(src));
+	}
+	public static String strxmlencode(String src) {
+		int i, slen;
+		char tmp[];
+		StringBuffer dst;
+
+		if (src == null)
+			return (null);
+		slen = src.length();
+		dst = new StringBuffer(slen);
+		tmp = new char[slen];
+		src.getChars(0, slen, tmp, 0);
+		for (i = 0; i &lt; slen; ++i)
+			if (tmp[i] == '&amp;' || tmp[i] == '&lt;' ||
+			    tmp[i] == '&gt;' || tmp[i] &gt; 0x7E) {
+				dst.append(&quot;&amp;#&quot;);
+				dst.append((int)tmp[i]);
+				dst.append(';');
+			} else
+				dst.append(tmp[i]);
+		return (dst.toString());
+	}
+
+	/**
+	 * Converts a string that is safe to use inside an XML file (like
+	 * prefs.xml) back to a data string - entities like &amp; are *NOT*
+	 * valid XML unless declared specially, so we must use the numerical
+	 * values here. We also try to decode non-standard entities.
+	 *
+	 * @param src (String) translated text to be processed
+	 *
+	 * @return (String) raw text, or null if input is null
+	 */
+	public static String strxmldecode(String src) {
+		int i, j, slen;
+		char ch, tmp[];
+		StringBuffer dst;
+		boolean isinval;
+
+		if (src == null)
+			return (null);
+		slen = src.length();
+		dst = new StringBuffer(slen);
+		tmp = new char[slen];
+		src.getChars(0, slen, tmp, 0);
+		i = 0;
+		while (i &lt; slen)
+			if (tmp[i] == '&amp;') {
+				/* first scan if we have a trailing ; */
+				if (src.indexOf(';', i) == -1) {
+					/* no - ignore and proceed */
+					i++;
+					dst.append(0xFFFD);
+				} else if (tmp[++i] == '#') {
+					/* yes - numerical value? */
+					i++;
+					ch = 0;
+					isinval = false;
+					if (tmp[i] == 'x' || tmp[i] == 'X') {
+						/* hexadecimal numeric */
+						i++;
+						while ((j = tmp[i++]) != ';') {
+							ch *= 16;
+							if (j &lt; 0x30)
+								isinval = true;
+							else if (j &lt; 0x3A)
+								ch += j - 0x30;
+							else if (j &lt; 0x41)
+								isinval = true;
+							else if (j &lt; 0x47)
+								ch += j - 0x37;
+							else if (j &lt; 0x61)
+								isinval = true;
+							else if (j &lt; 0x67)
+								ch += j - 0x57;
+							else
+								isinval = true;
+						}
+					} else
+						/* decimal numeric */
+						while ((j = tmp[i++]) != ';') {
+							ch *= 10;
+							if (j &lt; 0x30)
+								isinval = true;
+							else if (j &lt; 0x3A)
+								ch += j - 0x30;
+							else
+								isinval = true;
+						}
+					if (isinval)
+						ch = 0xFFFD;
+					dst.append(ch);
+				} else {
+					/* yes - string value */
+					StringBuffer tconv = new StringBuffer(&quot;#&quot;);
+					String tc;
+
+					do {
+						tconv.append(tmp[i]);
+					} while (tmp[i++] != ';');
+
+					if ((tc = (String)iso2htmlMappings.get(tconv)) == null)
+						/* invalid entity, just retain it */
+						dst.append(tconv);
+					else
+						dst.append(tc);
+				}
+			} else
+				dst.append(tmp[i++]);
+		return (dst.toString());
+	}
+}
\ No newline at end of file


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001431.html">[Cachewolf-svn] r1537 - trunk
</A></li>
	<LI>Next message: <A HREF="001433.html">[Cachewolf-svn] r1539 - in experiments/EVE: . lib lib/lib-folder	lib/lib-folder/HTML lib/lib-folder/HTML/Tmpl	lib/lib-folder/com lib/lib-folder/com/bbn	lib/lib-folder/com/bbn/openmap lib/lib-folder/com/bbn/openmap/proj	lib/lib-folder/com/bbn/openmap/proj/coords	lib/lib-folder/com/bbn/openmap/util lib/lib-folder/com/stevesoft	lib/lib-folder/com/stevesoft/ewe_pat	lib/lib-folder/com/stevesoft/ewe_pat/wrap	lib/lib-folder/ewesoft lib/lib-folder/ewesoft/xml	lib/lib-folder/ewesoft/xml/sax
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1432">[ date ]</a>
              <a href="thread.html#1432">[ thread ]</a>
              <a href="subject.html#1432">[ subject ]</a>
              <a href="author.html#1432">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
