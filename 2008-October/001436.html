<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r1542 - in experiments/EVE/lib/lib-folder: . HTML	HTML/Tmpl HTML/Tmpl/Element HTML/Tmpl/Parsers com com/bbn	com/bbn/openmap com/bbn/openmap/proj	com/bbn/openmap/proj/coords com/bbn/openmap/util	com/stevesoft com/stevesoft/eve_pat	com/stevesoft/eve_pat/wrap ewesoft ewesoft/xml ewesoft/xml/sax
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1542%20-%20in%20experiments/EVE/lib/lib-folder%3A%20.%20HTML%0A%09HTML/Tmpl%20HTML/Tmpl/Element%20HTML/Tmpl/Parsers%20com%20com/bbn%0A%09com/bbn/openmap%20com/bbn/openmap/proj%0A%09com/bbn/openmap/proj/coords%20com/bbn/openmap/util%0A%09com/stevesoft%20com/stevesoft/eve_pat%0A%09com/stevesoft/eve_pat/wrap%20ewesoft%20ewesoft/xml%20ewesoft/xml/sax&In-Reply-To=%3C200810172047.m9HKllmH025428%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001435.html">
   <LINK REL="Next"  HREF="001437.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r1542 - in experiments/EVE/lib/lib-folder: . HTML	HTML/Tmpl HTML/Tmpl/Element HTML/Tmpl/Parsers com com/bbn	com/bbn/openmap com/bbn/openmap/proj	com/bbn/openmap/proj/coords com/bbn/openmap/util	com/stevesoft com/stevesoft/eve_pat	com/stevesoft/eve_pat/wrap ewesoft ewesoft/xml ewesoft/xml/sax</H1>
    <B>salzkammergut at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r1542%20-%20in%20experiments/EVE/lib/lib-folder%3A%20.%20HTML%0A%09HTML/Tmpl%20HTML/Tmpl/Element%20HTML/Tmpl/Parsers%20com%20com/bbn%0A%09com/bbn/openmap%20com/bbn/openmap/proj%0A%09com/bbn/openmap/proj/coords%20com/bbn/openmap/util%0A%09com/stevesoft%20com/stevesoft/eve_pat%0A%09com/stevesoft/eve_pat/wrap%20ewesoft%20ewesoft/xml%20ewesoft/xml/sax&In-Reply-To=%3C200810172047.m9HKllmH025428%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r1542 - in experiments/EVE/lib/lib-folder: . HTML	HTML/Tmpl HTML/Tmpl/Element HTML/Tmpl/Parsers com com/bbn	com/bbn/openmap com/bbn/openmap/proj	com/bbn/openmap/proj/coords com/bbn/openmap/util	com/stevesoft com/stevesoft/eve_pat	com/stevesoft/eve_pat/wrap ewesoft ewesoft/xml ewesoft/xml/sax">salzkammergut at mail.berlios.de
       </A><BR>
    <I>Fri Oct 17 22:47:47 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001435.html">[Cachewolf-svn] r1541 - experiments/EVE/lib/lib-folder
</A></li>
        <LI>Next message: <A HREF="001437.html">[Cachewolf-svn] r1543 - experiments/EVE/src/cachewolf/imp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1436">[ date ]</a>
              <a href="thread.html#1436">[ thread ]</a>
              <a href="subject.html#1436">[ subject ]</a>
              <a href="author.html#1436">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: salzkammergut
Date: 2008-10-17 22:45:24 +0200 (Fri, 17 Oct 2008)
New Revision: 1542

Added:
   experiments/EVE/lib/lib-folder/HTML/
   experiments/EVE/lib/lib-folder/HTML/Template.class
   experiments/EVE/lib/lib-folder/HTML/Template.java
   experiments/EVE/lib/lib-folder/HTML/Tmpl/
   experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/
   experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Conditional.class
   experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Conditional.java
   experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Element.class
   experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Element.java
   experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/If.class
   experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/If.java
   experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Loop.class
   experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Loop.java
   experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Unless.class
   experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Unless.java
   experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Var.class
   experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Var.java
   experiments/EVE/lib/lib-folder/HTML/Tmpl/Filter.class
   experiments/EVE/lib/lib-folder/HTML/Tmpl/Parsers/
   experiments/EVE/lib/lib-folder/HTML/Tmpl/Parsers/Parser.class
   experiments/EVE/lib/lib-folder/HTML/Tmpl/Parsers/Parser.java
   experiments/EVE/lib/lib-folder/HTML/Tmpl/Util.class
   experiments/EVE/lib/lib-folder/HTML/Tmpl/Util.java
   experiments/EVE/lib/lib-folder/com/
   experiments/EVE/lib/lib-folder/com/bbn/
   experiments/EVE/lib/lib-folder/com/bbn/openmap/
   experiments/EVE/lib/lib-folder/com/bbn/openmap/LatLonPoint.class
   experiments/EVE/lib/lib-folder/com/bbn/openmap/MoreMath.class
   experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/
   experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/AziDist.class
   experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/Ellipsoid.class
   experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/GreatCircle.class
   experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/Length.class
   experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/Planet.class
   experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/Planet.java
   experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/ProjMath.class
   experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/coords/
   experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/coords/DMSLatLonPoint.class
   experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/coords/MGRSPoint.class
   experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/coords/MGRSPoint.java
   experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/coords/UTMPoint.class
   experiments/EVE/lib/lib-folder/com/bbn/openmap/util/
   experiments/EVE/lib/lib-folder/com/bbn/openmap/util/ArgParser$Arg.class
   experiments/EVE/lib/lib-folder/com/bbn/openmap/util/ArgParser$HelpArg.class
   experiments/EVE/lib/lib-folder/com/bbn/openmap/util/ArgParser.class
   experiments/EVE/lib/lib-folder/com/bbn/openmap/util/ArgParser.java
   experiments/EVE/lib/lib-folder/com/bbn/openmap/util/Assert.class
   experiments/EVE/lib/lib-folder/com/bbn/openmap/util/AssertionException.class
   experiments/EVE/lib/lib-folder/com/stevesoft/
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/AmpersandRule.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/AmpersandRule.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Any.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Any.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackG.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackG.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackMatch.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackMatch.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackRefRule.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackRefRule.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Backup.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Backup.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BadRangeArgs.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BasicStringBufferLike.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BasicStringBufferLike.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BitSet.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BitSet.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Bits.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Bits.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Boundary.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Boundary.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Bracket.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Bracket.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Branch.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CaseMgr.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CaseMgr.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/ChangeRule.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/ChangeRule.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CodeRule.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CodeRule.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CodeVal.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Ctrl.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Ctrl.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Custom.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Custom.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CustomEndpoint.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CustomEndpoint.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/DirFileRegex.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/DirFileRegex.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/DotMulti.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/DotMulti.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/End.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/End.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FastBracket.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FastBracket.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FastChar.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FastMulti.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FastMulti.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FileRegex.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FileRegex.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Group.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Group.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/LeftRule.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/LeftRule.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Multi.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Multi.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/MultiMin.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/MultiMin.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Multi_stage2.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Multi_stage2.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodeAlpha.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodeCurrency.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodeDigit.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodeMath.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodePunct.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodeW.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodeWhite.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NoPattern.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NoPattern.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NonDirFileRegex.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NonDirFileRegex.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NotImplementedError.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NotImplementedError.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NullPattern.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NullPattern.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NullRule.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NullRule.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Or.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Or.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/OrMark.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/OrMark.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PartialBuffer.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PartialBuffer.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Pattern.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Pattern.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PatternSub.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PatternSub.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PopRule.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PopRule.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Prop.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Prop.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Pthings.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Pthings.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PushRule.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PushRule.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RBuffer.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RBuffer.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Range.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Range.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegHolder.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegOpt.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegOpt.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegRes.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegRes.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegSyntax.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegSyntax.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegSyntaxError.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegSyntaxError.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Regex.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Regex.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexReader.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexReader.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexTokenizer.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexTokenizer.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexWriter.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexWriter.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/ReplaceRule.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/ReplaceRule.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Replacer.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Replacer.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RightRule.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RightRule.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Rthings.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Rthings.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RuleHolder.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RuleHolder.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skip.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skip.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skip2.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skip2.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SkipBMH.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SkipBMH.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skipped.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skipped.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SpecialRule.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SpecialRule.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Start.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Start.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StrPos.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StrPos.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringBufferLike.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringBufferLike.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringLike.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringLike.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringRule.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringRule.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SubMark.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SubMark.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/TransPat.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/TransPat.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/TransRepRule.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Transformer.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Transformer.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UniValidator.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UniValidator.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeAlpha.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeCurrency.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeDigit.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeLower.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeMath.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodePunct.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeUpper.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeW.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeWhite.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Validator.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Validator.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/WantMoreTextReplaceRule.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/WantMoreTextReplaceRule.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/lookAhead.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/lookAhead.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/oneChar.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/oneChar.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/parsePerl.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/parsePerl.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/patInf.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/patInf.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/patInt.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/patInt.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/CharArrayBufferWrap.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/CharArrayBufferWrap.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/CharArrayWrap.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/CharArrayWrap.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/RandomAccessFileWrap.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/RandomAccessFileWrap.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/StringBufferWrap.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/StringBufferWrap.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/StringWrap.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/StringWrap.java
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/WriterWrap.class
   experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/WriterWrap.java
   experiments/EVE/lib/lib-folder/ewesoft/
   experiments/EVE/lib/lib-folder/ewesoft/xml/
   experiments/EVE/lib/lib-folder/ewesoft/xml/DocumentHandler.class
   experiments/EVE/lib/lib-folder/ewesoft/xml/DocumentHandler.java
   experiments/EVE/lib/lib-folder/ewesoft/xml/MinML$1.class
   experiments/EVE/lib/lib-folder/ewesoft/xml/MinML$MinMLBuffer.class
   experiments/EVE/lib/lib-folder/ewesoft/xml/MinML.class
   experiments/EVE/lib/lib-folder/ewesoft/xml/MinML.java
   experiments/EVE/lib/lib-folder/ewesoft/xml/Parser.class
   experiments/EVE/lib/lib-folder/ewesoft/xml/XMLDecoder.class
   experiments/EVE/lib/lib-folder/ewesoft/xml/XMLDecoder.java
   experiments/EVE/lib/lib-folder/ewesoft/xml/XMLElement.class
   experiments/EVE/lib/lib-folder/ewesoft/xml/XMLElement.java
   experiments/EVE/lib/lib-folder/ewesoft/xml/sax/
   experiments/EVE/lib/lib-folder/ewesoft/xml/sax/AttributeList.class
   experiments/EVE/lib/lib-folder/ewesoft/xml/sax/DTDHandler.class
   experiments/EVE/lib/lib-folder/ewesoft/xml/sax/DocumentHandler.class
   experiments/EVE/lib/lib-folder/ewesoft/xml/sax/EntityResolver.class
   experiments/EVE/lib/lib-folder/ewesoft/xml/sax/EntityResolver.java
   experiments/EVE/lib/lib-folder/ewesoft/xml/sax/ErrorHandler.class
   experiments/EVE/lib/lib-folder/ewesoft/xml/sax/HandlerBase.class
   experiments/EVE/lib/lib-folder/ewesoft/xml/sax/InputSource.class
   experiments/EVE/lib/lib-folder/ewesoft/xml/sax/InputSource.java
   experiments/EVE/lib/lib-folder/ewesoft/xml/sax/Locator.class
   experiments/EVE/lib/lib-folder/ewesoft/xml/sax/Parser.class
   experiments/EVE/lib/lib-folder/ewesoft/xml/sax/Parser.java
   experiments/EVE/lib/lib-folder/ewesoft/xml/sax/SAXException.class
   experiments/EVE/lib/lib-folder/ewesoft/xml/sax/SAXException.java
   experiments/EVE/lib/lib-folder/ewesoft/xml/sax/SAXParseException.class
Log:
Add libraries converted to EVE

Added: experiments/EVE/lib/lib-folder/HTML/Template.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/HTML/Template.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/HTML/Template.java
===================================================================
--- experiments/EVE/lib/lib-folder/HTML/Template.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/HTML/Template.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,1087 @@
+/*
+*      HTML.Template:  A module for using HTML Templates with java
+*
+*      Copyright (c) 2002 Philip S Tellis (<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">philip.tellis at iname.com</A>)
+*
+*      This module is free software; you can redistribute it
+*      and/or modify it under the terms of either:
+*
+*      a) the GNU General Public License as published by the Free
+*      Software Foundation; either version 1, or (at your option)
+*      any later version, or
+*
+*      b) the &quot;Artistic License&quot; which comes with this module.
+*
+*      This program is distributed in the hope that it will be
+*      useful, but WITHOUT ANY WARRANTY; without even the implied
+*      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+*      PURPOSE.  See either the GNU General Public License or the
+*      Artistic License for more details.
+*
+*      You should have received a copy of the Artistic License
+*      with this module, in the file ARTISTIC.  If not, I'll be
+*      glad to provide one.
+*
+*      You should have received a copy of the GNU General Public
+*      License along with this program; if not, write to the Free
+*      Software Foundation, Inc., 59 Temple Place, Suite 330,
+*      Boston, MA 02111-1307 USA
+*/
+
+package HTML;
+import java.util.*;
+import java.io.*;
+import eve.sys.*;
+import HTML.Tmpl.Element.*;
+import HTML.Tmpl.Parsers.*;
+import HTML.Tmpl.Util;
+import HTML.Tmpl.Filter;
+
+/**
+ * Use HTML Templates with ewe.
+ * &lt;p&gt;
+ * The HTML.Template class allows you to use HTML Templates from within
+ * your java programs.  It makes it possible to change the look of your
+ * servlets without having to recompile them.  Use HTML.Template to 
+ * separate code from presentation in your servlets.
+ * &lt;p&gt;
+ * &lt;pre&gt;
+ *	Hashtable args = new Hashtable();
+ *	args.put(&quot;filename&quot;, &quot;my_template.tmpl&quot;);
+ *
+ *	Template t = new Template(args);
+ *
+ *	t.setParam(&quot;title&quot;, &quot;The HTML Template package&quot;);
+ *	t.printTo(response.getWriter());
+ * &lt;/pre&gt;
+ * &lt;p&gt;
+ * HTML.Template is based on the perl module HTML::Template by Sam Tregar
+ *
+ * @author	Philip S Tellis
+ * @version	0.1.2
+ */
+public class Template 
+{
+	private If __template__ = new If(&quot;__template__&quot;);
+	private Hashtable params = new Hashtable();
+
+	private boolean dirty = true;
+
+	private boolean strict = true;
+	private boolean die_on_bad_params = false;
+	private boolean global_vars = false;
+	private boolean case_sensitive = false;
+	private boolean loop_context_vars = false;
+	private boolean debug = false;
+	private boolean no_includes = false;
+	private boolean search_path_on_include = false;
+	private int max_includes = 11;
+	private String filename = null;
+	private String scalarref = null;
+	private String [] arrayref = null;
+	private String [] path = null;
+	private Reader filehandle = null;
+	private Filter [] filters = null;
+
+	private Stack elements = new Stack();
+	private Parser parser;
+
+	/**
+	 * Initialises a new HTML.Template object with the contents of
+	 * the given file.
+	 *
+	 * @param filename			a string containing the name of 
+	 *					the file to be used as a 
+	 *					template.  This may be an 
+	 *					absolute or relative path to a 
+	 *					template file.
+	 *
+	 * @throws FileNotFoundException	If the file specified does not 
+	 *					exist.
+	 * @throws IllegalStateException	If &lt;tmpl_include&gt; is
+	 *					used when no_includes is in
+	 *					effect.
+	 * @throws IOException			If an input or output Exception 
+	 *					occurred while reading the 
+	 *					template.
+	 *
+	 * @deprecated No replacement.  You should use either
+	 *				{@link #Template(Object [])} or
+	 *				{@link #Template(Hashtable)}
+	 */
+	public Template(String filename)
+			throws FileNotFoundException, 
+				IllegalStateException,
+				IOException
+	{
+		this.filename = filename;
+		init();
+	}
+
+	/**
+	 * Initialises a new Template object, using the name/value
+	 * pairs passed as default values.
+	 * &lt;p&gt;
+	 * The parameters passed may be any combination of filename, 
+	 * scalarref, arrayref, path, case_sensitive, loop_context_vars, 
+	 * strict, die_on_bad_params, global_vars, max_includes, 
+	 * no_includes, search_path_on_include and debug.
+	 * Each with its own value.  Any one of filename, scalarref or
+	 * arrayref must be passed.
+	 * &lt;p&gt;
+	 * Eg:
+	 * &lt;pre&gt;
+	 *	String [] template_init = {
+	 *		&quot;filename&quot;,  &quot;my_template.tmpl&quot;,
+	 *		&quot;case_sensitive&quot;, &quot;true&quot;,
+	 *		&quot;max_includes&quot;,   &quot;5&quot;
+	 *	};
+	 *
+	 *      Template t = new Template(template_init);
+	 * &lt;/pre&gt;
+	 * &lt;p&gt;
+	 * The above code creates a new Template object, initialising
+	 * its input file to my_template.tmpl, turning on case_sensitive
+	 * parameter matching, and restricting maximum depth of includes
+	 * to five.
+	 * &lt;p&gt;
+	 * Parameter values that take boolean values may either be a String
+	 * containing the words true/false, or the Boolean values Boolean.TRUE
+	 * and Boolean.FALSE.  Numeric values may be Strings, or Integers.
+	 *
+	 * @since 0.0.8
+	 *
+	 * @param args		an array of name/value pairs to initialise
+	 *			this template with.  Valid values for
+	 *			each element may be:
+	 * @param filename	[Required] a String containing the path to a 
+	 *			template file
+	 * @param scalarref	[Required] a String containing the entire 
+	 *			template as its contents
+	 * @param arrayref	[Required] an array of lines that make up
+	 *			the template
+	 * @param path		[Optional] an array of Strings specifying
+	 *			the directories in which to look for the
+	 *			template file.  If not specified, the current
+	 *			working directory is used.  If specified,
+	 *			only the directories in this array are used.
+	 *			If you want the current directory searched,
+	 *			include &quot;.&quot; in the path.
+	 *			&lt;p&gt;
+	 *			If you have only a single path, it can be a
+	 *			plain String instead of a String array.
+	 *			&lt;p&gt;
+	 *			This is effective only for the template file,
+	 *			and not for included files, but see
+	 *			search_path_on_include for how to change that.
+	 * @param case_sensitive	[Optional] specifies whether parameter 
+	 *			matching is case sensitive or not.  A value 
+	 *			of &quot;false&quot;, &quot;0&quot; or &quot;&quot; is considered false.  
+	 *			All other values are true.
+	 *			&lt;p&gt;
+	 *			Default: false
+	 * @param loop_context_vars	[Optional] when set to true four loop
+	 * 			context variables are made available inside a 
+	 *			loop: &lt;code&gt;__FIRST__, __LAST__, __INNER__, __ODD__, __COUNTER__&lt;/code&gt;.
+	 *			They can be used with &lt;code&gt;&lt;TMPL_IF&gt;&lt;/code&gt;, 
+	 *			&lt;code&gt;&lt;TMPL_UNLESS&gt;&lt;/code&gt; and &lt;code&gt;&lt;TMPL_ELSE&gt;&lt;/code&gt; to 
+	 *			control how a loop is output. Example:
+	 *			&lt;pre&gt;
+	 *	    &lt;TMPL_LOOP NAME=&quot;FOO&quot;&gt;
+	 *	       &lt;TMPL_IF NAME=&quot;__FIRST__&quot;&gt;
+	 *	         This only outputs on the first pass.
+	 *	       &lt;/TMPL_IF&gt;
+	 *
+	 *	       &lt;TMPL_IF NAME=&quot;__ODD__&quot;&gt;
+	 *	         This outputs on the odd passes.
+	 *	       &lt;/TMPL_IF&gt;
+	 *
+	 *	       &lt;TMPL_UNLESS NAME=&quot;__ODD__&quot;&gt;
+	 *	         This outputs on the even passes.
+	 *	       &lt;/TMPL_IF&gt;
+	 *
+	 *	       &lt;TMPL_IF NAME=&quot;__INNER__&quot;&gt;
+	 *	         This outputs on passes that are 
+	 *		neither first nor last.
+	 *	       &lt;/TMPL_IF&gt;
+	 *
+	 *	       &lt;TMPL_IF NAME=&quot;__LAST__&quot;&gt;
+	 *	         This only outputs on the last pass.
+	 *	       &lt;TMPL_IF&gt;
+	 *	    &lt;/TMPL_LOOP&gt;
+	 *			&lt;/pre&gt;
+	 *			&lt;p&gt;
+	 *			NOTE: A loop with only a single pass will get 
+	 *			both &lt;code&gt;__FIRST__&lt;/code&gt; and &lt;code&gt;__LAST__&lt;/code&gt;
+	 *			set to true, but not &lt;code&gt;__INNER__&lt;/code&gt;.
+	 *			&lt;p&gt;
+	 *			Default: false
+	 * @param strict	[Optional] if set to false the module will 
+	 *			allow things that look like they might be 
+	 *			TMPL_* tags to get by without throwing
+	 *			an exception.  Example:
+	 *			&lt;pre&gt;
+	 *          &lt;TMPL_HUH NAME=ZUH&gt;
+	 *			&lt;/pre&gt;
+	 *			&lt;p&gt;
+	 *			Would normally cause an error, but if you 
+	 *			create the Template with strict == 0, 
+	 *			HTML.Template will ignore it.
+	 *			&lt;p&gt;
+	 *			Default: true
+	 * @param die_on_bad_params		[Optional] if set to true
+	 *			the module will complain if you try to set
+	 *			tmpl.setParam(&quot;param_name&quot;, &quot;value&quot;) and
+	 *			param_name doesn't exist in the template.
+	 *			&lt;p&gt;
+	 *			This effect doesn't descend into loops. 
+	 *			&lt;p&gt;
+	 *			Default: false (may change in later versions)
+	 * @param global_vars	[Optional] normally variables declared outside
+	 *			a loop are not available inside a loop.  This
+	 *			option makes TMPL_VARs global throughout
+	 *			the template.  It also affects TMPL_IF and TMPL_UNLESS.
+	 *			&lt;pre&gt;
+	 *	    &lt;p&gt;This is a normal variable: &lt;TMPL_VAR NORMAL&gt;.&lt;/p&gt;
+	 *
+	 *	    &lt;TMPL_LOOP NAME=&quot;FROOT_LOOP&gt;
+	 *	       Here it is inside the loop: &lt;TMPL_VAR NORMAL&gt;
+	 *	    &lt;/TMPL_LOOP&gt;
+	 *			&lt;/pre&gt;
+	 *			&lt;p&gt;
+	 *			Normally this wouldn't work as expected, since
+	 *			&lt;TMPL_VAR NORMAL&gt;'s value outside the loop
+	 *			isn't available inside the loop.
+	 *			&lt;p&gt;
+	 *			Default: false (may change in later versions)
+	 * @param max_includes	[Optional] specifies the maximum depth that
+	 *			includes can reach.  Including files to a 
+	 *			depth greater than this value causes an error 
+	 *			message to be displayed.  Set to 0 to disable 
+	 *			this protection.
+	 *			&lt;p&gt;
+	 *			Default: 10
+	 * @param no_includes	[Optional] If set to true, disallows the
+	 *			&lt;TMPL_INCLUDE&gt; tag in the template
+	 *			file.  This can be used to make opening 
+	 *			untrusted templates slightly less dangerous.
+	 *			&lt;p&gt;
+	 *			Default: false
+	 * @param search_path_on_include	[Optional] if set, then the
+	 *			path is searched for included files as well
+	 *			as the template file.  See the path parameter
+	 *			for more information.
+	 *			&lt;p&gt;
+	 *			Default: false
+	 * @param debug		[Optional] setting this option to true causes
+	 *			HTML.Template to print random error messages
+	 *			to STDERR.
+	 *			
+	 * @throws ArrayIndexOutOfBoundsException	If an odd number of
+	 *					parameters is passed.
+	 * @throws FileNotFoundException	If the file specified does not 
+	 *					exist or no filename is passed.
+	 * @throws IllegalArgumentException	If an unknown parameter is
+	 *					passed.
+	 * @throws IllegalStateException	If &lt;tmpl_include&gt; is
+	 *					used when no_includes is in
+	 *					effect.
+	 * @throws IOException			If an input or output Exception 
+	 *					occurred while reading the 
+	 *					template.
+	 */
+	public Template(Object [] args)
+			throws ArrayIndexOutOfBoundsException,
+				FileNotFoundException,
+				IllegalArgumentException,
+				IllegalStateException,
+				IOException
+				
+	{
+		if(args.length%2 != 0)
+			throw new ArrayIndexOutOfBoundsException(&quot;odd number &quot; +
+					&quot;of arguments passed&quot;);
+
+		for(int i=0; i&lt;args.length; i+=2) {
+			parseParam((String)args[i], args[i+1]);
+		}
+
+		init();
+	}
+
+	/**
+	 * Initialises a new Template object, using the values in the
+	 * Hashtable args as defaults.
+	 * &lt;p&gt;
+	 * The parameters passed are the same as in the Template(Object [])
+	 * constructor. Each with its own value.  Any one of filename, 
+	 * scalarref or arrayref must be passed.
+	 * &lt;p&gt;
+	 * Eg:
+	 * &lt;pre&gt;
+	 *	Hashtable args = new Hashtable();
+	 *	args.put(&quot;filename&quot;, &quot;my_template.tmpl&quot;);
+	 *	args.put(&quot;case_sensitive&quot;, &quot;true&quot;);
+	 *	args.put(&quot;loop_context_vars&quot;, Boolean.TRUE);
+	 *	// args.put(&quot;max_includes&quot;, &quot;5&quot;);
+	 *	args.put(&quot;max_includes&quot;, new Integer(5));
+	 *
+	 *	Template t = new Template(args);
+	 * &lt;/pre&gt;
+	 * &lt;p&gt;
+	 * The above code creates a new Template object, initialising
+	 * its input file to my_template.tmpl, turning on case_sensitive
+	 * parameter matching, and the loop context variables __FIRST__,
+	 * __LAST__, __ODD__ and __INNER__, and restricting maximum depth of 
+	 * includes to five.
+	 * &lt;p&gt;
+	 * Parameter values that take boolean values may either be a String
+	 * containing the words true/false, or the Boolean values Boolean.TRUE
+	 * and Boolean.FALSE.  Numeric values may be Strings, or Integers.
+	 *
+	 * @since 0.0.10
+	 *
+	 * @param args		a Hashtable of name/value pairs to initialise
+	 *			this template with.  Valid values are the same
+	 *			as in the Template(Object []) constructor.
+	 *			
+	 * @throws FileNotFoundException	If the file specified does not 
+	 *					exist or no filename is passed.
+	 * @throws IllegalArgumentException	If an unknown parameter is
+	 *					passed.
+	 * @throws IllegalStateException	If &lt;tmpl_include&gt; is
+	 *					used when no_includes is in
+	 *					effect.
+	 * @throws IOException			If an input or output Exception 
+	 *					occurred while reading the 
+	 *					template.
+	 *
+	 * @see #Template(Object [])
+	 */
+	public Template(Hashtable args)
+			throws FileNotFoundException,
+				IllegalArgumentException,
+				IllegalStateException,
+				IOException
+				
+	{
+		Enumeration e = args.keys();
+		while(e.hasMoreElements()) {
+			String key = (String)e.nextElement();
+			Object value = args.get(key);
+
+			parseParam(key, value);
+		}
+
+		init();
+	}
+
+	/**
+	 * Prints the parsed template to the provided PrintWriter.
+	 *
+	 * @param out	the PrintWriter that this template will be printed
+	 *		to
+	 */
+	public void printTo(PrintWriter out) 
+	{
+		out.print(output());
+	}
+
+	/**
+	 * Returns the parsed template as a String.
+	 *
+	 * @return	a string containing the parsed template
+	 */
+	public String output()
+	{
+		return __template__.parse(params);
+	}
+
+	/**
+	 * Sets the values of parameters in this template from a Hashtable.
+	 *
+	 * @param params	a Hashtable containing name/value pairs for
+	 *			this template.  Keys in this hashtable must
+	 *			be Strings and values may be either Strings
+	 *			or Vectors.
+	 *			&lt;p&gt;
+	 *			Parameter names are currently not case
+	 *			sensitive.
+	 *			&lt;p&gt;
+	 *			Parameter names can contain only letters, 
+	 *			digits,	., /, +, - and _ characters.
+	 *			&lt;p&gt;
+	 *			Parameter names starting and ending with
+	 *			a double underscore are not permitted.
+	 *			eg: &lt;code&gt;__myparam__&lt;/code&gt; is illegal.
+	 *
+	 * @return		the number of parameters actually set.
+	 *			Illegal parameters will not be set, but
+	 *			no error/exception will be thrown.
+	 */
+	public int setParams(Hashtable params) 
+	{
+		if(params == null || params.isEmpty())
+			return 0;
+		int count=0;
+		for(Enumeration e = params.keys(); e.hasMoreElements();) {
+			Object key = e.nextElement();
+			if(key.getClass().getName().endsWith(&quot;.String&quot;)) {
+				Object value = params.get(key);
+				try {
+					setParam((String)key, value);
+					count++;
+				} catch (Exception pe) {
+					// key was not a String or Vector
+					// or key was null
+					// don't increment count
+				}
+			}
+		}
+		if(count&gt;0) {
+			dirty=true;
+			Util.debug_print(&quot;Now dirty: set params&quot;);
+		}
+
+		return count;
+	}
+
+	/**
+	 * Sets a single scalar parameter in this template.
+	 *
+	 * @param name	a String containing the name of this parameter.
+	 *		Parameter names are currently not case sensitive.
+	 * @param value	a String containing the value of this parameter	
+	 *
+	 * @return				the value of the parameter set
+	 * @throws IllegalArgumentException 	if the parameter name contains
+	 *					illegal characters
+	 * @throws NullPointerException 	if the parameter name is null
+	 *
+	 * @see #setParams(Hashtable)
+	 */
+	public String setParam(String name, String value)
+			throws IllegalArgumentException, NullPointerException
+	{
+		try {
+			return (String)setParam(name, (Object)value);
+		} catch(ClassCastException iae) {
+			return null;
+		}
+	}
+
+	/**
+	 * Sets a single Integer parameter in this template.
+	 *
+	 * @param name	a String containing the name of this parameter.
+	 *		Parameter names are currently not case sensitive.
+	 * @param value	an Integer containing the value of this parameter	
+	 *
+	 * @return				the value of the parameter set
+	 * @throws IllegalArgumentException 	if the parameter name contains
+	 *					illegal characters
+	 * @throws NullPointerException 	if the parameter name is null
+	 *
+	 * @see #setParams(Hashtable)
+	 */
+	public Integer setParam(String name, Integer value)
+			throws IllegalArgumentException, NullPointerException
+	{
+		try {
+			return (Integer)setParam(name, (Object)value);
+		} catch(ClassCastException iae) {
+			return null;
+		}
+	}
+
+	/**
+	 * Sets a single int parameter in this template.
+	 *
+	 * @param name	a String containing the name of this parameter.
+	 *		Parameter names are currently not case sensitive.
+	 * @param value	an int containing the value of this parameter	
+	 *
+	 * @return				the value of the parameter set
+	 * @throws IllegalArgumentException 	if the parameter name contains
+	 *					illegal characters
+	 * @throws NullPointerException 	if the parameter name is null
+	 *
+	 * @see #setParams(Hashtable)
+	 */
+	public int setParam(String name, int value)
+			throws IllegalArgumentException, NullPointerException
+	{
+		return setParam(name, new Integer(value)).intValue();
+	}
+
+	/**
+	 * Sets a single boolean parameter in this template.
+	 *
+	 * @param name	a String containing the name of this parameter.
+	 *		Parameter names are currently not case sensitive.
+	 * @param value	a boolean containing the value of this parameter	
+	 *
+	 * @return				the value of the parameter set
+	 * @throws IllegalArgumentException 	if the parameter name contains
+	 *					illegal characters
+	 * @throws NullPointerException 	if the parameter name is null
+	 *
+	 * @see #setParams(Hashtable)
+	 */
+	public boolean setParam(String name, boolean value)
+			throws IllegalArgumentException, NullPointerException
+	{
+		return setParam(name, new Boolean(value)).booleanValue();
+	}
+
+	/**
+	 * Sets a single Boolean parameter in this template.
+	 *
+	 * @param name	a String containing the name of this parameter.
+	 *		Parameter names are currently not case sensitive.
+	 * @param value	a Boolean containing the value of this parameter	
+	 *
+	 * @return				the value of the parameter set
+	 * @throws IllegalArgumentException 	if the parameter name contains
+	 *					illegal characters
+	 * @throws NullPointerException 	if the parameter name is null
+	 *
+	 * @see #setParams(Hashtable)
+	 */
+	public Boolean setParam(String name, Boolean value)
+			throws IllegalArgumentException, NullPointerException
+	{
+		try {
+			return (Boolean)setParam(name, (Object)value);
+		} catch(ClassCastException iae) {
+			return null;
+		}
+	}
+
+	/**
+	 * Sets a single list parameter in this template.
+	 *
+	 * @param name	a String containing the name of this parameter.
+	 *		Parameter names are not currently case sensitive.
+	 * @param value	a Vector containing a list of Hashtables of parameters
+	 *
+	 * @return				the value of the parameter set
+	 * @throws IllegalArgumentException 	if the parameter name contains
+	 *					illegal characters
+	 * @throws NullPointerException 	if the parameter name is null
+	 *
+	 * @see #setParams(Hashtable)
+	 */
+	public Vector setParam(String name, Vector value) 
+			throws IllegalArgumentException, NullPointerException
+	{
+		try {
+			return (Vector)setParam(name, (Object)value);
+		} catch(ClassCastException iae) {
+			return null;
+		}
+	}
+
+	/**
+	 * Returns a parameter from this template identified by the given name.
+	 *
+	 * @param name	a String containing the name of the parameter to be 
+	 *		returned.  Parameter names are not currently case
+	 *		sensitive.
+	 *
+	 * @return	the value of the requested parameter.  If the parameter
+	 *		is a scalar, the return value is a String, if the 
+	 *		parameter is a list, the return value is a Vector.
+	 *
+	 * @throws NoSuchElementException	if the parameter does not exist
+	 *					in the template
+	 * @throws NullPointerException		if the parameter name is null
+	 */
+	public Object getParam(String name) 
+			throws NoSuchElementException, NullPointerException
+	{
+		if(name == null)
+			throw new NullPointerException(&quot;name cannot be null&quot;);
+		if(!params.containsKey(name))
+			throw new NoSuchElementException(name + 
+				&quot; is not a parameter in this template&quot;);
+
+		if(case_sensitive)
+			return params.get(name);
+		else
+			return params.get(name.toLowerCase());
+	}
+
+
+	private void parseParam(String key, Object value)
+			throws IllegalStateException
+	{
+		if(key.equals(&quot;case_sensitive&quot;))
+		{
+			this.case_sensitive=boolify(value);
+			Util.debug_print(&quot;case_sensitive: &quot;+value);
+		}
+		else if(key.equals(&quot;strict&quot;))
+		{
+			this.strict=boolify(value);
+			Util.debug_print(&quot;strict: &quot;+value);
+		}
+		else if(key.equals(&quot;global_vars&quot;))
+		{
+			this.global_vars=boolify(value);
+			Util.debug_print(&quot;global_vars: &quot;+value);
+		}
+		else if(key.equals(&quot;die_on_bad_params&quot;))
+		{
+			this.die_on_bad_params=boolify(value);
+			Util.debug_print(&quot;die_obp: &quot;+value);
+		}
+		else if(key.equals(&quot;max_includes&quot;))
+		{
+			this.max_includes=intify(value)+1;
+			Util.debug_print(&quot;max_includes: &quot;+value);
+		}
+		else if(key.equals(&quot;no_includes&quot;))
+		{
+			this.no_includes=boolify(value);
+			Util.debug_print(&quot;no_includes: &quot;+value);
+		}
+		else if(key.equals(&quot;search_path_on_include&quot;))
+		{
+			this.search_path_on_include=boolify(value);
+			Util.debug_print(&quot;path_includes: &quot;+value);
+		}
+		else if(key.equals(&quot;loop_context_vars&quot;))
+		{
+			this.loop_context_vars=boolify(value);
+			Util.debug_print(&quot;loop_c_v: &quot;+value);
+		}
+		else if(key.equals(&quot;debug&quot;))
+		{
+			this.debug=boolify(value);
+			Util.debug=this.debug;
+			Util.debug_print(&quot;debug: &quot;+value);
+		}
+		else if(key.equals(&quot;filename&quot;))
+		{
+			this.filename = (String)value;
+			Util.debug_print(&quot;filename: &quot;+value);
+		}
+		else if(key.equals(&quot;scalarref&quot;))
+		{
+			this.scalarref = (String)value;
+			Util.debug_print(&quot;scalarref&quot;);
+		}
+		else if(key.equals(&quot;arrayref&quot;))
+		{
+			this.arrayref = (String [])value;
+			Util.debug_print(&quot;arrayref&quot;);
+		}
+		else if(key.equals(&quot;path&quot;))
+		{
+			if(value.getClass().getName().startsWith(&quot;[&quot;))
+				this.path = (String [])value;
+			else {
+				this.path = new String[1];
+				this.path[0] = (String)value;
+			}
+			Util.debug_print(&quot;path&quot;);
+			for(int j=0; j&lt;this.path.length; j++)
+				Util.debug_print(this.path[j]);
+		}
+		else if(key.equals(&quot;filter&quot;))
+		{
+			if(value.getClass().getName().startsWith(&quot;[&quot;))
+				this.filters = (Filter [])value;
+			else {
+				this.filters = new Filter[1];
+				this.filters[0] = (Filter)value;
+			}
+			Util.debug_print(&quot;filters set: &quot; + filters.length);
+		}
+		else if(key.equals(&quot;filehandle&quot;))
+		{
+			this.filehandle = (Reader)value;
+			Util.debug_print(&quot;filehandle&quot;);
+		}
+		else
+		{
+			throw new IllegalArgumentException(
+					(String)key);
+		}
+
+	}
+
+	private void init()
+			throws FileNotFoundException, 
+				IllegalStateException,
+				IOException
+	{
+		if(this.filename == null &amp;&amp; 
+				this.scalarref == null &amp;&amp;
+				this.arrayref == null &amp;&amp;
+				this.filehandle == null)
+			throw new FileNotFoundException(&quot;template filename required&quot;);
+		
+		Util.debug = this.debug;
+
+		params.put(&quot;__template__&quot;, &quot;true&quot;);
+
+		String [] parser_params = {
+			&quot;case_sensitive&quot;, 	stringify(case_sensitive),
+			&quot;strict&quot;, 		stringify(strict),
+			&quot;loop_context_vars&quot;, 	stringify(loop_context_vars),
+			&quot;global_vars&quot;, 		stringify(global_vars)
+		};
+
+		parser = new Parser(parser_params);
+
+		if(this.filename != null)
+			read_file(filename);
+		else if(this.arrayref != null)
+			read_line_array(this.arrayref);
+		else if(this.scalarref != null)
+			read_line(this.scalarref);
+		else if(this.filehandle != null)
+			read_fh(this.filehandle);
+
+		if(!elements.empty())
+			//System.err.println(&quot;stack not empty&quot;);
+			Vm.debug(&quot;stack not empty&quot;);
+	}
+
+
+	private Element parseLine(String line, Element e)
+			throws FileNotFoundException,
+				IllegalStateException,
+				IOException, 
+				EmptyStackException
+	{
+		Vector parts;
+		//do filtering of one line
+		if ((filters != null) &amp;&amp; (filters.length &gt; 0)&amp;&amp; (filters[0].format()== Filter.SCALAR)){
+			line = filters[0].parse(line);
+			if ((line == null) || (line.length() == 0)) return e;
+		}
+		parts = parser.parseLine(line);
+		Util.debug_print(&quot;Items: &quot; + parts.size());
+
+		for(Enumeration pt = parts.elements(); pt.hasMoreElements();) 
+		{
+			Object o = pt.nextElement();
+			
+			if(o.getClass().getName().endsWith(&quot;.String&quot;))
+			{
+				if(((String)o).equals(&quot;&quot;))
+					continue;
+
+				e.add((String)o);
+				Util.debug_print(&quot;added: &quot; +(String)o);
+				continue;
+			}
+				
+			// if we come here, then it is an element
+
+			Properties p = (Properties)o;
+			String type=p.getProperty(&quot;type&quot;);
+			Util.debug_print(&quot;adding element: &quot; + type);
+
+			if(type.equals(&quot;include&quot;)) 
+			{
+				if(no_includes)
+					throw new IllegalStateException(
+						&quot;&lt;tmpl_include&gt; not &quot; +
+						&quot;allowed when &quot; +
+						&quot;no_includes in effect&quot;
+					);
+				if(max_includes == 0) {
+					throw new IndexOutOfBoundsException(
+						&quot;include too deep&quot;);
+				} else {
+					// come here if positive 
+					// or negative
+					elements.push(e);
+					read_file(p.getProperty(&quot;name&quot;));
+				}
+			}
+			else if(type.equals(&quot;var&quot;))
+			{
+				String name = p.getProperty(&quot;name&quot;);
+				String escape = p.getProperty(&quot;escape&quot;);
+				String def = p.getProperty(&quot;default&quot;);
+				Util.debug_print(&quot;name: &quot; + name);
+				Util.debug_print(&quot;escape: &quot; + escape);
+				Util.debug_print(&quot;default: &quot; + def);
+				e.add(new Var(name, escape, def));
+			}
+			else if(type.equals(&quot;else&quot;)) 
+			{
+				Util.debug_print(&quot;adding branch&quot;);
+				((Conditional)e).addBranch();
+			}
+			else if(p.getProperty(&quot;close&quot;).equals(&quot;true&quot;)) 
+			{
+				Util.debug_print(&quot;closing tag&quot;);
+				if(!type.equals(e.Type()))
+					throw new EmptyStackException();
+
+				e = (Element)elements.pop();
+			} 
+			else
+			{
+				Element t = parser.getElement(p);
+				e.add(t);
+				elements.push(e);
+				e=t;
+			}
+		}
+		return e;
+	}
+
+	private void read_file(String filename)
+			throws FileNotFoundException, 
+				IllegalStateException,
+				IOException, 
+				EmptyStackException
+	{
+		BufferedReader br=openFile(filename);
+
+		String line;
+
+		Element e = null;
+		if(elements.empty())
+			e = __template__;
+		else
+			e = (Element)elements.pop();
+
+		max_includes--;
+		while((line=br.readLine()) != null) {
+			Util.debug_print(&quot;Line: &quot; + line);
+			e = parseLine(line+&quot;\n&quot;, e);
+		}
+		max_includes++;
+
+		br.close();
+		br=null;
+
+	}
+	
+	private void read_line_array(String [] lines)
+			throws FileNotFoundException, 
+				IllegalStateException,
+				IOException, 
+				EmptyStackException
+	{
+
+		Element e = __template__;
+
+		max_includes--;
+		for(int i=0; i&lt;lines.length; i++) {
+			Util.debug_print(lines[i]);
+			e = parseLine(lines[i], e);
+		}
+		max_includes++;
+	}
+
+	private void read_line(String lines)
+			throws FileNotFoundException, 
+				IllegalStateException,
+				IOException, 
+				EmptyStackException
+	{
+
+		Element e = __template__;
+
+		max_includes--;
+		StringTokenizer st = new StringTokenizer(lines, &quot;\n&quot;);
+		while(st.hasMoreTokens()) {
+			String line = st.nextToken();
+			Util.debug_print(line);
+			e = parseLine(line+&quot;\n&quot;, e);
+		}
+		max_includes++;
+	}
+
+	private void read_fh(Reader handle)
+			throws FileNotFoundException, 
+				IllegalStateException,
+				IOException, 
+				EmptyStackException
+	{
+		BufferedReader br=new BufferedReader(handle);
+
+		String line;
+
+		Element e = null;
+		if(elements.empty())
+			e = __template__;
+		else
+			e = (Element)elements.pop();
+
+		max_includes--;
+		while((line=br.readLine()) != null) {
+			Util.debug_print(&quot;Line: &quot; + line);
+			e = parseLine(line+&quot;\n&quot;, e);
+		}
+		max_includes++;
+
+		br.close();
+		br=null;
+
+	}
+	
+	private Object setParam(String name, Object value)
+			throws ClassCastException,
+				NullPointerException, 
+				IllegalArgumentException
+	{
+		if(name==null)
+			throw new NullPointerException(
+					&quot;parameter name cannot be null&quot;);
+
+
+		if(!Util.isNameChar(name)) {
+			throw new IllegalArgumentException(&quot;parameter name &quot; +
+				&quot;may only contain letters, digits, ., /, +, &quot; +
+				&quot;-, _&quot;);
+		}
+
+		if(name.startsWith(&quot;__&quot;) &amp;&amp; name.endsWith(&quot;__&quot;))
+			throw new IllegalArgumentException(&quot;parameter name &quot; +
+				&quot;may not start and end with a double &quot; +
+				&quot;underscore&quot;);
+
+		if(die_on_bad_params &amp;&amp; !__template__.contains(name))
+			throw new IllegalArgumentException(name + 
+				&quot;is not a valid template entity&quot;);
+
+		if(value==null)
+			value=&quot;&quot;;
+
+		String type = value.getClass().getName();
+		if(type.indexOf(&quot;.&quot;) &gt; 0)
+			type = type.substring(type.lastIndexOf(&quot;.&quot;)+1);
+
+		String valid_types = &quot;,String,Vector,Boolean,Integer,&quot;;
+
+		if(valid_types.indexOf(type) &lt; 0)
+			throw new ClassCastException(
+					&quot;value is neither scalar nor list&quot;);
+
+		name=case_sensitive?name:name.toLowerCase();
+
+		if(!case_sensitive &amp;&amp; type.equals(&quot;Vector&quot;)) {
+			value = lowerCaseAll((Vector)value);
+		}
+			
+		Util.debug_print(&quot;setting: &quot; + name);
+		params.put(name, value);
+
+		dirty=true;
+		return value;
+	}
+
+	private static Vector lowerCaseAll(Vector v)
+	{
+		Vector v2 = new Vector();
+		for(Enumeration e = v.elements(); e.hasMoreElements(); ) {
+			Hashtable h = (Hashtable)e.nextElement();
+			if(h == null) {
+				v2.addElement(h);
+				continue;
+			}
+			Hashtable h2 = new Hashtable();
+			for(Enumeration e2 = h.keys(); e2.hasMoreElements(); ) {
+				String key = (String)e2.nextElement();
+				Object value = h.get(key);
+				String value_type = value.getClass().getName();
+				Util.debug_print(&quot;to lower case: &quot; + key + &quot;(&quot; + value_type + &quot;)&quot;);
+				if(value_type.endsWith(&quot;.Vector&quot;))
+					value = lowerCaseAll((Vector)value);
+				h2.put(key.toLowerCase(), value);
+			}
+			v2.addElement(h2);
+		}
+		return v2;
+	}
+
+	private static boolean boolify(Object o)
+	{
+		String s;
+		if(o.getClass().getName().endsWith(&quot;.Boolean&quot;))
+			return ((Boolean)o).booleanValue();
+		else if(o.getClass().getName().endsWith(&quot;.String&quot;))
+			s = (String)o;
+		else
+			s = o.toString();
+
+		if(s.equals(&quot;0&quot;) || s.equals(&quot;&quot;) || s.equals(&quot;false&quot;))
+			return false;
+		return true;
+	}
+
+	private static int intify(Object o)
+	{
+		String s;
+		if(o.getClass().getName().endsWith(&quot;.Integer&quot;))
+			return ((Integer)o).intValue();
+		else if(o.getClass().getName().endsWith(&quot;.String&quot;))
+			s = (String)o;
+		else
+			s = o.toString();
+
+		try {
+			return Integer.parseInt(s);
+		} catch(NumberFormatException nfe) {
+			return 0;
+		}
+	}
+
+	private static String stringify(boolean b)
+	{
+		if(b)
+			return &quot;1&quot;;
+		else
+			return &quot;&quot;;
+	}
+	
+	private BufferedReader openFile(String filename)
+			throws FileNotFoundException
+	{
+		boolean add_path=true;
+
+		if(!elements.empty() &amp;&amp; !search_path_on_include)
+			add_path=false;
+
+		if(filename.startsWith(&quot;/&quot;))
+			add_path=false;
+
+		if(this.path == null)
+			add_path=false;
+
+		Util.debug_print(&quot;open &quot; + filename);
+		if(!add_path)
+			return new BufferedReader(new FileReader(filename));
+
+		BufferedReader br=null;
+		
+		for(int i=0; i&lt;this.path.length; i++) {
+			try {
+				Util.debug_print(&quot;trying &quot; + this.path[i] +
+						&quot;/&quot; + filename);
+				br = new BufferedReader(
+					new FileReader(
+						this.path[i] + &quot;/&quot; + filename
+					)
+				);
+				break;
+			} catch (FileNotFoundException fnfe) {
+			}
+		}
+
+		if(br == null)
+			throw new FileNotFoundException(filename);
+
+		return br;
+	}
+}

Added: experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Conditional.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Conditional.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Conditional.java
===================================================================
--- experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Conditional.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Conditional.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,167 @@
+/*
+*      HTML.Template:  A module for using HTML Templates with java
+*
+*      Copyright (c) 2002 Philip S Tellis (<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">philip.tellis at iname.com</A>)
+*
+*      This module is free software; you can redistribute it
+*      and/or modify it under the terms of either:
+*
+*      a) the GNU General Public License as published by the Free
+*      Software Foundation; either version 1, or (at your option)
+*      any later version, or
+*
+*      b) the &quot;Artistic License&quot; which comes with this module.
+*
+*      This program is distributed in the hope that it will be
+*      useful, but WITHOUT ANY WARRANTY; without even the implied
+*      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+*      PURPOSE.  See either the GNU General Public License or the
+*      Artistic License for more details.
+*
+*      You should have received a copy of the Artistic License
+*      with this module, in the file ARTISTIC.  If not, I'll be
+*      glad to provide one.
+*
+*      You should have received a copy of the GNU General Public
+*      License along with this program; if not, write to the Free
+*      Software Foundation, Inc., 59 Temple Place, Suite 330,
+*      Boston, MA 02111-1307 USA
+*/
+
+package HTML.Tmpl.Element;
+import java.util.Vector;
+import java.util.Hashtable;
+import java.util.Enumeration;
+import java.util.NoSuchElementException;
+
+public class Conditional extends Element
+{
+	private boolean control_val = false;
+	private Vector [] data;
+
+	public Conditional(String type, String name) 
+			throws IllegalArgumentException
+	{
+		if(type.equalsIgnoreCase(&quot;if&quot;))
+			this.type=&quot;if&quot;;
+		else if(type.equalsIgnoreCase(&quot;unless&quot;))
+			this.type=&quot;unless&quot;;
+		else
+			throw new IllegalArgumentException(
+				&quot;Unrecognised type: &quot; + type);
+
+		this.name = name;
+		this.data = new Vector[2];
+		this.data[0] = new Vector();
+	}
+
+	public void addBranch() throws IndexOutOfBoundsException
+	{
+		if(data[1] != null)
+			throw new IndexOutOfBoundsException(&quot;Already have two branches&quot;);
+
+		if(data[0] == null)
+			data[0] = new Vector();
+		else if(data[1] == null)
+			data[1] = new Vector();
+	}
+
+	public void add(String text)
+	{
+		if(data[1] != null)
+			data[1].addElement(text);
+		else
+			data[0].addElement(text);
+	}
+
+	public void add(Element node)
+	{
+		if(data[1] != null)
+			data[1].addElement(node);
+		else
+			data[0].addElement(node);
+	}
+
+	public void setControlValue(Object control_val)
+			throws IllegalArgumentException
+	{
+		this.control_val = process_var(control_val);
+	}
+
+	public String parse(Hashtable params)
+	{
+		if(!params.containsKey(this.name))
+			this.control_val = false;
+		else	
+			setControlValue(params.get(this.name));
+
+		StringBuffer output = new StringBuffer();
+
+		Enumeration de;
+		if(type.equals(&quot;if&quot;) &amp;&amp; control_val ||
+			type.equals(&quot;unless&quot;) &amp;&amp; !control_val)
+			de = data[0].elements();
+		else if(data[1] != null)
+			de = data[1].elements();
+		else
+			return &quot;&quot;;
+
+		while(de.hasMoreElements()) {
+			Object e = de.nextElement();
+			if(e.getClass().getName().endsWith(&quot;.String&quot;))
+				output.append((String)e);
+			else
+				output.append(((Element)e).parse(params));
+		}
+
+		return output.toString();
+	}
+
+	public String typeOfParam(String param)
+			throws NoSuchElementException
+	{
+		for(int i=0; i&lt;data.length; i++)
+		{
+			if(data[i] == null)
+				continue;
+			for(Enumeration e = data[i].elements(); 
+				e.hasMoreElements();)
+			{
+				Object o = e.nextElement();
+				if(o.getClass().getName().endsWith(&quot;.String&quot;))
+					continue;
+				if(((Element)o).Name().equals(param))
+					return ((Element)o).Type();
+			}
+		}
+		throw new NoSuchElementException(param);
+	}
+
+	private boolean process_var(Object control_val) 
+			throws IllegalArgumentException 
+	{
+		String control_class = &quot;&quot;;
+
+		if(control_val == null)
+			return false;
+		
+		control_class=control_val.getClass().getName();
+		if(control_class.indexOf(&quot;.&quot;) &gt; 0)
+			control_class = control_class.substring(
+					control_class.lastIndexOf(&quot;.&quot;)+1);
+
+		if(control_class.equals(&quot;String&quot;)) {
+			return !(((String)control_val).equals(&quot;&quot;) || 
+				((String)control_val).equals(&quot;0&quot;));
+		} else if(control_class.equals(&quot;Vector&quot;)) {
+			return !((Vector)control_val).isEmpty();
+		} else if(control_class.equals(&quot;Boolean&quot;)) {
+			return ((Boolean)control_val).booleanValue();
+		} else if(control_class.equals(&quot;Integer&quot;)) {
+			return (((Integer)control_val).intValue() != 0);
+		} else {
+			throw new IllegalArgumentException(&quot;Unrecognised type&quot;);
+		}
+	}
+}
+

Added: experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Element.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Element.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Element.java
===================================================================
--- experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Element.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Element.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,66 @@
+/*
+*      HTML.Template:  A module for using HTML Templates with java
+*
+*      Copyright (c) 2002 Philip S Tellis (<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">philip.tellis at iname.com</A>)
+*
+*      This module is free software; you can redistribute it
+*      and/or modify it under the terms of either:
+*
+*      a) the GNU General Public License as published by the Free
+*      Software Foundation; either version 1, or (at your option)
+*      any later version, or
+*
+*      b) the &quot;Artistic License&quot; which comes with this module.
+*
+*      This program is distributed in the hope that it will be
+*      useful, but WITHOUT ANY WARRANTY; without even the implied
+*      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+*      PURPOSE.  See either the GNU General Public License or the
+*      Artistic License for more details.
+*
+*      You should have received a copy of the Artistic License
+*      with this module, in the file ARTISTIC.  If not, I'll be
+*      glad to provide one.
+*
+*      You should have received a copy of the GNU General Public
+*      License along with this program; if not, write to the Free
+*      Software Foundation, Inc., 59 Temple Place, Suite 330,
+*      Boston, MA 02111-1307 USA
+*/
+
+
+package HTML.Tmpl.Element;
+import java.util.Hashtable;
+import java.util.NoSuchElementException;
+
+public abstract class Element
+{
+	protected String type;
+	protected String name=&quot;&quot;;
+
+	public abstract String parse(Hashtable params);
+	public abstract String typeOfParam(String param)
+			throws NoSuchElementException;
+
+	public void add(String data){}
+	public void add(Element node){}
+
+	public boolean contains(String param)
+	{
+		try {
+			return (typeOfParam(param) != null?true:false);
+		} catch(NoSuchElementException nse) {
+			return false;
+		}
+	}
+
+	public final String Type()
+	{
+		return type;
+	}
+
+	public final String Name()
+	{
+		return name;
+	}
+}

Added: experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/If.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/If.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/If.java
===================================================================
--- experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/If.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/If.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,39 @@
+/*
+*      HTML.Template:  A module for using HTML Templates with java
+*
+*      Copyright (c) 2002 Philip S Tellis (<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">philip.tellis at iname.com</A>)
+*
+*      This module is free software; you can redistribute it
+*      and/or modify it under the terms of either:
+*
+*      a) the GNU General Public License as published by the Free
+*      Software Foundation; either version 1, or (at your option)
+*      any later version, or
+*
+*      b) the &quot;Artistic License&quot; which comes with this module.
+*
+*      This program is distributed in the hope that it will be
+*      useful, but WITHOUT ANY WARRANTY; without even the implied
+*      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+*      PURPOSE.  See either the GNU General Public License or the
+*      Artistic License for more details.
+*
+*      You should have received a copy of the Artistic License
+*      with this module, in the file ARTISTIC.  If not, I'll be
+*      glad to provide one.
+*
+*      You should have received a copy of the GNU General Public
+*      License along with this program; if not, write to the Free
+*      Software Foundation, Inc., 59 Temple Place, Suite 330,
+*      Boston, MA 02111-1307 USA
+*/
+
+package HTML.Tmpl.Element;
+
+public class If extends Conditional
+{
+	public If(String control_var) throws IllegalArgumentException
+	{
+		super(&quot;if&quot;, control_var);
+	}
+}

Added: experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Loop.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Loop.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Loop.java
===================================================================
--- experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Loop.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Loop.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,183 @@
+/*
+*      HTML.Template:  A module for using HTML Templates with java
+*
+*      Copyright (c) 2002 Philip S Tellis (<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">philip.tellis at iname.com</A>)
+*
+*      This module is free software; you can redistribute it
+*      and/or modify it under the terms of either:
+*
+*      a) the GNU General Public License as published by the Free
+*      Software Foundation; either version 1, or (at your option)
+*      any later version, or
+*
+*      b) the &quot;Artistic License&quot; which comes with this module.
+*
+*      This program is distributed in the hope that it will be
+*      useful, but WITHOUT ANY WARRANTY; without even the implied
+*      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+*      PURPOSE.  See either the GNU General Public License or the
+*      Artistic License for more details.
+*
+*      You should have received a copy of the Artistic License
+*      with this module, in the file ARTISTIC.  If not, I'll be
+*      glad to provide one.
+*
+*      You should have received a copy of the GNU General Public
+*      License along with this program; if not, write to the Free
+*      Software Foundation, Inc., 59 Temple Place, Suite 330,
+*      Boston, MA 02111-1307 USA
+*/
+
+package HTML.Tmpl.Element;
+import java.util.Vector;
+import java.util.Hashtable;
+import java.util.Enumeration;
+import java.util.NoSuchElementException;
+
+public class Loop extends Element
+{
+	private boolean loop_context_vars=false;
+	private boolean global_vars=false;
+
+	private Vector control_val = null;
+	private Vector data;
+
+	public Loop(String name)
+	{
+		this.type = &quot;loop&quot;;
+		this.name = name;
+		this.data = new Vector();
+	}
+
+	public Loop(String name, boolean loop_context_vars)
+	{
+		this(name);
+		this.loop_context_vars=loop_context_vars;
+	}
+
+	public Loop(String name, boolean loop_context_vars, boolean global_vars)
+	{
+		this(name);
+		this.loop_context_vars=loop_context_vars;
+		this.global_vars=global_vars;
+	}
+
+	public void add(String text)
+	{
+		data.addElement(text);
+	}
+
+	public void add(Element node)
+	{
+		data.addElement(node);
+	}
+
+	public void setControlValue(Vector control_val)
+			throws IllegalArgumentException
+	{
+		this.control_val = process_var(control_val);
+	}
+
+	public String parse(Hashtable p)
+	{
+		if(!p.containsKey(this.name))
+			this.control_val = null;
+		else {
+			Object o = p.get(this.name);
+			if(!o.getClass().getName().endsWith(&quot;.Vector&quot;) &amp;&amp;
+					!o.getClass().getName().endsWith(&quot;.List&quot;))
+				throw new ClassCastException(
+					&quot;Attempt to set &lt;tmpl_loop&gt; with a non-list.  tmpl_loop=&quot; + this.name);
+			setControlValue((Vector)p.get(this.name));
+		}
+
+		if(control_val == null)
+			return &quot;&quot;;
+
+		StringBuffer output = new StringBuffer();
+		Enumeration iterator = control_val.elements();
+
+		boolean first=true;
+		boolean last=false;
+		boolean inner=false;
+		boolean odd=true;
+		int counter=1;
+
+		while(iterator.hasMoreElements()) {
+			Hashtable params = (Hashtable)iterator.nextElement();
+
+			if(params==null)
+				params = new Hashtable();
+
+			if(global_vars) {
+				for(Enumeration e = p.keys(); e.hasMoreElements();) {
+					Object key = e.nextElement();
+					if(!params.containsKey(key))
+						params.put(key, p.get(key));
+				}
+			}
+
+			if(loop_context_vars) {
+				if(!iterator.hasMoreElements())
+					last=true;
+				inner = !first &amp;&amp; !last;
+
+				params.put(&quot;__FIRST__&quot;, first?&quot;1&quot;:&quot;&quot;);
+				params.put(&quot;__LAST__&quot;, last?&quot;1&quot;:&quot;&quot;);
+				params.put(&quot;__ODD__&quot;, odd?&quot;1&quot;:&quot;&quot;);
+				params.put(&quot;__INNER__&quot;, inner?&quot;1&quot;:&quot;&quot;);
+				params.put(&quot;__COUNTER__&quot;, &quot;&quot; + (counter++));
+			}
+				
+			Enumeration de = data.elements();
+			while(de.hasMoreElements()) {
+
+				Object e = de.nextElement();
+				if(e.getClass().getName().indexOf(&quot;String&quot;)&gt;-1)
+					output.append((String)e);
+				else
+					output.append(((Element)e).parse(params));
+			}
+			first = false;
+			odd = !odd;
+		}
+
+		return output.toString();
+	}
+
+	public String typeOfParam(String param)
+			throws NoSuchElementException
+	{
+		for(Enumeration e = data.elements(); e.hasMoreElements();)
+		{
+			Object o = e.nextElement();
+			if(o.getClass().getName().endsWith(&quot;.String&quot;))
+				continue;
+			if(((Element)o).Name().equals(param))
+				return ((Element)o).Type();
+		}
+		throw new NoSuchElementException(param);
+	}
+
+	private Vector process_var(Vector control_val) 
+			throws IllegalArgumentException 
+	{
+		String control_class = &quot;&quot;;
+
+		if(control_val == null)
+			return null;
+		
+		control_class=control_val.getClass().getName();
+
+		if(control_class.indexOf(&quot;Vector&quot;) &gt; -1) {
+			if(control_val.isEmpty())
+				return null;
+		} else {
+			throw new IllegalArgumentException(&quot;Unrecognised type&quot;);
+		}
+
+		return control_val;
+	}
+
+}
+

Added: experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Unless.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Unless.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Unless.java
===================================================================
--- experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Unless.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Unless.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,39 @@
+/*
+*      HTML.Template:  A module for using HTML Templates with java
+*
+*      Copyright (c) 2002 Philip S Tellis (<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">philip.tellis at iname.com</A>)
+*
+*      This module is free software; you can redistribute it
+*      and/or modify it under the terms of either:
+*
+*      a) the GNU General Public License as published by the Free
+*      Software Foundation; either version 1, or (at your option)
+*      any later version, or
+*
+*      b) the &quot;Artistic License&quot; which comes with this module.
+*
+*      This program is distributed in the hope that it will be
+*      useful, but WITHOUT ANY WARRANTY; without even the implied
+*      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+*      PURPOSE.  See either the GNU General Public License or the
+*      Artistic License for more details.
+*
+*      You should have received a copy of the Artistic License
+*      with this module, in the file ARTISTIC.  If not, I'll be
+*      glad to provide one.
+*
+*      You should have received a copy of the GNU General Public
+*      License along with this program; if not, write to the Free
+*      Software Foundation, Inc., 59 Temple Place, Suite 330,
+*      Boston, MA 02111-1307 USA
+*/
+
+package HTML.Tmpl.Element;
+
+public class Unless extends Conditional
+{
+	public Unless(String control_var) throws IllegalArgumentException
+	{
+		super(&quot;unless&quot;, control_var);
+	}
+}

Added: experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Var.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Var.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Var.java
===================================================================
--- experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Var.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/HTML/Tmpl/Element/Var.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,137 @@
+/*
+*      HTML.Template:  A module for using HTML Templates with java
+*
+*      Copyright (c) 2002 Philip S Tellis (<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">philip.tellis at iname.com</A>)
+*
+*      This module is free software; you can redistribute it
+*      and/or modify it under the terms of either:
+*
+*      a) the GNU General Public License as published by the Free
+*      Software Foundation; either version 1, or (at your option)
+*      any later version, or
+*
+*      b) the &quot;Artistic License&quot; which comes with this module.
+*
+*      This program is distributed in the hope that it will be
+*      useful, but WITHOUT ANY WARRANTY; without even the implied
+*      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+*      PURPOSE.  See either the GNU General Public License or the
+*      Artistic License for more details.
+*
+*      You should have received a copy of the Artistic License
+*      with this module, in the file ARTISTIC.  If not, I'll be
+*      glad to provide one.
+*
+*      You should have received a copy of the GNU General Public
+*      License along with this program; if not, write to the Free
+*      Software Foundation, Inc., 59 Temple Place, Suite 330,
+*      Boston, MA 02111-1307 USA
+*/
+
+package HTML.Tmpl.Element;
+import java.util.Hashtable;
+import java.util.NoSuchElementException;
+import HTML.Tmpl.Util;
+
+public class Var extends Element
+{
+	public static final int ESCAPE_NONE  = 0;
+	public static final int ESCAPE_URL   = 1;
+	public static final int ESCAPE_HTML  = 2;
+	public static final int ESCAPE_QUOTE = 4;
+	
+	public Var(String name, int escape, Object default_value)
+			throws IllegalArgumentException
+	{
+		this(name, escape);
+		this.default_value = stringify(default_value);
+	}
+
+	public Var(String name, int escape) 
+			throws IllegalArgumentException
+	{
+		if(name == null)
+			throw new IllegalArgumentException(&quot;tmpl_var must have a name&quot;);
+		this.type = &quot;var&quot;;
+		this.name = name;
+		this.escape = escape;
+	}
+
+	public Var(String name, String escape)
+			throws IllegalArgumentException
+	{
+		this(name, escape, null);
+	}
+
+	public Var(String name, String escape, Object default_value) 
+			throws IllegalArgumentException
+	{
+		this(name, ESCAPE_NONE, default_value);
+
+		if(escape.equalsIgnoreCase(&quot;html&quot;))
+			this.escape = ESCAPE_HTML;
+		else if(escape.equalsIgnoreCase(&quot;url&quot;))
+			this.escape = ESCAPE_URL;
+		else if(escape.equalsIgnoreCase(&quot;quote&quot;))
+			this.escape = ESCAPE_QUOTE;
+	}
+
+	public Var(String name, boolean escape) 
+			throws IllegalArgumentException
+	{
+		this(name, escape?ESCAPE_HTML:ESCAPE_NONE);
+	}
+
+	public String parse(Hashtable params)
+	{
+		String value = null;
+
+		if(params.containsKey(this.name))
+			value = stringify(params.get(this.name));
+		else
+			value = this.default_value;
+
+		if(value == null)
+			return &quot;&quot;;
+
+		if(this.escape == ESCAPE_HTML)
+			return Util.escapeHTML(value);
+		else if(this.escape == ESCAPE_URL)
+			return Util.escapeURL(value);
+		else if(this.escape == ESCAPE_QUOTE)
+			return Util.escapeQuote(value);
+		else
+			return value;
+	}
+
+	public String typeOfParam(String param)
+			throws NoSuchElementException
+	{
+		throw new NoSuchElementException(param);
+	}
+
+	private String stringify(Object o)
+	{
+		if(o == null)
+			return null;
+
+		String cname = o.getClass().getName();
+		if(cname.endsWith(&quot;.String&quot;))
+			return (String)o;
+		else if(cname.endsWith(&quot;.Integer&quot;))
+			return ((Integer)o).toString();
+		else if(cname.endsWith(&quot;.Boolean&quot;))
+			return ((Boolean)o).toString();
+		else if(cname.endsWith(&quot;.Date&quot;))
+			return ((java.util.Date)o).toString();
+		else if(cname.endsWith(&quot;.Vector&quot;))
+			throw new ClassCastException(&quot;Attempt to set &lt;tmpl_var&gt; with a non-scalar. Var name=&quot; + this.name);
+		else
+			throw new ClassCastException(&quot;Unknown object type: &quot; + cname);
+	}
+
+	// Private data starts here
+	private int escape=ESCAPE_NONE;
+	private String default_value=null;
+
+}

Added: experiments/EVE/lib/lib-folder/HTML/Tmpl/Filter.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/HTML/Tmpl/Filter.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/HTML/Tmpl/Parsers/Parser.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/HTML/Tmpl/Parsers/Parser.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/HTML/Tmpl/Parsers/Parser.java
===================================================================
--- experiments/EVE/lib/lib-folder/HTML/Tmpl/Parsers/Parser.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/HTML/Tmpl/Parsers/Parser.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,387 @@
+/*
+*      HTML.Template:  A module for using HTML Templates with java
+*
+*      Copyright (c) 2002 Philip S Tellis (<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">philip.tellis at iname.com</A>)
+*
+*      This module is free software; you can redistribute it
+*      and/or modify it under the terms of either:
+*
+*      a) the GNU General Public License as published by the Free
+*      Software Foundation; either version 1, or (at your option)
+*      any later version, or
+*
+*      b) the &quot;Artistic License&quot; which comes with this module.
+*
+*      This program is distributed in the hope that it will be
+*      useful, but WITHOUT ANY WARRANTY; without even the implied
+*      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+*      PURPOSE.  See either the GNU General Public License or the
+*      Artistic License for more details.
+*
+*      You should have received a copy of the Artistic License
+*      with this module, in the file ARTISTIC.  If not, I'll be
+*      glad to provide one.
+*
+*      You should have received a copy of the GNU General Public
+*      License along with this program; if not, write to the Free
+*      Software Foundation, Inc., 59 Temple Place, Suite 330,
+*      Boston, MA 02111-1307 USA
+*/
+
+
+package HTML.Tmpl.Parsers;
+import java.util.*;
+import HTML.Tmpl.Element.*;
+import HTML.Tmpl.Util;
+
+public class Parser
+{
+	private boolean case_sensitive=false;
+	private boolean strict=true;
+	private boolean loop_context_vars=false;
+	private boolean global_vars=false;
+
+	public Parser()
+	{
+	}
+
+	public Parser(String [] args)
+			throws ArrayIndexOutOfBoundsException,
+				IllegalArgumentException
+	{
+		if(args.length%2 != 0)
+			throw new ArrayIndexOutOfBoundsException(&quot;odd number of arguments passed&quot;);
+
+		for(int i=0; i&lt;args.length; i+=2) {
+			if(args[i].equals(&quot;case_sensitive&quot;)) {
+				String cs = args[i+1];
+				if(cs.equals(&quot;&quot;) || cs.equals(&quot;0&quot;))
+					this.case_sensitive=false;
+				else
+					this.case_sensitive=true;
+			} else if(args[i].equals(&quot;strict&quot;)) {
+				String s = args[i+1];
+				if(s.equals(&quot;&quot;) || s.equals(&quot;0&quot;))
+					this.strict=false;
+				else
+					this.strict=true;
+			} else if(args[i].equals(&quot;loop_context_vars&quot;)) {
+				String s = args[i+1];
+				if(s.equals(&quot;&quot;) || s.equals(&quot;0&quot;))
+					this.loop_context_vars=false;
+				else
+					this.loop_context_vars=true;
+
+			} else if(args[i].equals(&quot;global_vars&quot;)) {
+				String s = args[i+1];
+				if(s.equals(&quot;&quot;) || s.equals(&quot;0&quot;))
+					this.global_vars=false;
+				else
+					this.global_vars=true;
+			} else {
+				throw new IllegalArgumentException(args[i]);
+			}
+		}
+	}
+
+	public Element getElement(Properties p)
+			throws NoSuchElementException
+	{
+		String type = p.getProperty(&quot;type&quot;);
+
+		if(type.equals(&quot;if&quot;))
+			return new If(p.getProperty(&quot;name&quot;));
+		else if(type.equals(&quot;unless&quot;))
+			return new Unless(p.getProperty(&quot;name&quot;));
+		else if(type.equals(&quot;loop&quot;))
+			return new Loop(p.getProperty(&quot;name&quot;), 
+						loop_context_vars, global_vars);
+		else
+			throw new NoSuchElementException(type);
+	}
+
+	public Vector parseLine(String line)
+			throws IllegalArgumentException
+	{
+		//int pos=0, endpos;
+		Vector parts = new Vector();
+
+		char [] c = line.toCharArray();
+		int i=0;
+
+		StringBuffer temp = new StringBuffer();
+
+		for(i=0; i&lt;c.length; i++) {
+			if(c[i] != '&lt;') {
+				temp.append(c[i]);
+			} else {
+				// found a tag
+				Util.debug_print(&quot;line so far: &quot; + temp);
+				StringBuffer tag = new StringBuffer();
+				for(; i&lt;c.length &amp;&amp; c[i] != '&gt;';  i++) {
+					tag.append(c[i]);
+				}
+				// &gt; is not allowed inside a template tag
+				// so we can be sure that if this is a 
+				// template tag, it ends with a &gt;
+
+				// add the closing &gt; as well
+				if(i&lt;c.length)
+					tag.append(c[i]);
+
+				// if this contains more &lt; inside it,
+				// then it could possibly be a template
+				// tag inside a html tag
+				// so remove external tag parts
+
+				while(tag.toString().substring(1).indexOf(&quot;&lt;&quot;) 
+						&gt; -1)
+				{
+					do {
+						temp.append(tag.charAt(0));
+						tag=new StringBuffer(
+							tag.toString().substring(1));
+					} while(tag.charAt(0) != '&lt;');
+				}
+
+				Util.debug_print(&quot;tag: &quot; + tag);
+
+				String test_tag = tag.toString().toLowerCase();
+				// if it doesn't contain tmpl_ it is not
+				// a template tag
+				if(test_tag.indexOf(&quot;tmpl_&quot;) &lt; 0) {
+					String dummy = new String();
+					dummy = tag.toString();
+					temp.append(dummy);
+					continue;
+				}
+
+				// may be a template tag
+				// check if it starts with tmpl_
+				
+				test_tag = cleanTag(test_tag);
+
+				Util.debug_print(&quot;clean: &quot; + test_tag);
+
+				// check if it is a closing tag
+				if(test_tag.startsWith(&quot;/&quot;))
+					test_tag = test_tag.substring(1);
+
+				// if it still doesn't start with tmpl_
+				// then it is not a template tag
+				if(!test_tag.startsWith(&quot;tmpl_&quot;)) {
+					temp.append(tag);
+					continue;
+				}
+
+				// now it must be a template tag
+				String tag_type=getTagType(test_tag);
+
+				if(tag_type == null) {
+					if(strict)
+						throw new 
+						IllegalArgumentException(
+							tag.toString());
+					else
+						temp.append(tag);
+				}
+
+				Util.debug_print(&quot;type: &quot; + tag_type);
+
+				// if this was an invalid key and we've
+				// reached so far, then next iteration
+				if(tag_type == null)
+					continue;
+				
+				// now, push the previous stuff
+				// into the Vector
+				if(temp.length()&gt;0) {
+					parts.addElement(temp.toString());
+					temp = new StringBuffer();
+				}
+
+				// it is a valid template tag
+				// get its properties
+
+				Util.debug_print(&quot;Checking: &quot; + tag);
+				Properties tag_props = 
+					getTagProps(tag.toString());
+
+				if(tag_props.containsKey(&quot;name&quot;))
+					Util.debug_print(&quot;name: &quot; + 
+						tag_props.getProperty(&quot;name&quot;));
+				else
+					Util.debug_print(&quot;no name&quot;);
+
+				parts.addElement(tag_props);
+			}
+		}
+
+		if(temp.length()&gt;0)
+			parts.addElement(temp.toString());
+
+		return parts;
+	}
+
+	private String cleanTag(String tag)
+			throws IllegalArgumentException
+	{
+		String test_tag = new String(tag);
+		// first remove &lt; and &gt;
+		if(test_tag.startsWith(&quot;&lt;&quot;))
+			test_tag = test_tag.substring(1);
+		if(test_tag.endsWith(&quot;&gt;&quot;))
+			test_tag = test_tag.substring(0, test_tag.length()-1);
+		else
+			throw new IllegalArgumentException(&quot;Tags must start &quot; +
+					&quot;and end on the same line&quot;);
+
+		// remove any leading !-- and trailing
+		// -- in case of comment style tags
+		if(test_tag.startsWith(&quot;!--&quot;)) {
+			test_tag=test_tag.substring(3);
+		}
+		if(test_tag.endsWith(&quot;--&quot;)) {
+			test_tag=test_tag.substring(0, test_tag.length()-2);
+		}
+		// then leading and trailing spaces
+		test_tag = test_tag.trim();
+
+		return test_tag;
+	}
+
+	private String getTagType(String tag)
+	{
+		int sp = tag.indexOf(&quot; &quot;);
+		String tag_type=&quot;&quot;;
+		if(sp &lt; 0) {
+			tag_type = tag.toLowerCase();
+		} else {
+			tag_type = tag.substring(0, sp).toLowerCase();
+		}
+		if(tag_type.startsWith(&quot;tmpl_&quot;))
+			tag_type=tag_type.substring(5);
+
+		Util.debug_print(&quot;tag_type: &quot; + tag_type);
+
+		if(tag_type.equals(&quot;var&quot;) ||
+				tag_type.equals(&quot;if&quot;) ||
+				tag_type.equals(&quot;unless&quot;) ||
+				tag_type.equals(&quot;loop&quot;) ||
+				tag_type.equals(&quot;include&quot;) ||
+				tag_type.equals(&quot;else&quot;)) {
+			return tag_type;
+		} else {
+			return null;
+		}
+	}
+
+	private Properties getTagProps(String tag)
+			throws IllegalArgumentException,
+				NullPointerException
+	{
+		Properties p = new Properties();
+
+		tag = cleanTag(tag);
+
+		Util.debug_print(&quot;clean: &quot; + tag);
+		
+		if(tag.startsWith(&quot;/&quot;)) {
+			p.put(&quot;close&quot;, &quot;true&quot;);
+			tag=tag.substring(1);
+		} else {
+			p.put(&quot;close&quot;, &quot;&quot;);
+		}
+
+		Util.debug_print(&quot;close: &quot; + p.getProperty(&quot;close&quot;));
+		
+		p.put(&quot;type&quot;, getTagType(tag));
+
+		Util.debug_print(&quot;type: &quot; + p.getProperty(&quot;type&quot;));
+
+		if(p.getProperty(&quot;type&quot;).equals(&quot;else&quot;) ||
+				p.getProperty(&quot;close&quot;).equals(&quot;true&quot;))
+			return p;
+
+		if(p.getProperty(&quot;type&quot;).equals(&quot;var&quot;))
+			p.put(&quot;escape&quot;, &quot;&quot;);
+
+		int sp = tag.indexOf(&quot; &quot;);
+		// if we've got so far, this must succeed
+
+		tag = tag.substring(sp).trim();
+		Util.debug_print(&quot;checking params: &quot; + tag);
+
+		// now, we should have either name=value pairs
+		// or name space escape in case of old style vars
+
+		if(tag.indexOf(&quot;=&quot;) &lt; 0) {
+			// no = means old style
+			// first will be var name
+			// second if any will be escape
+
+			sp = tag.toLowerCase().indexOf(&quot; escape&quot;);
+			if(sp &lt; 0) {
+				// no escape
+				p.put(&quot;name&quot;, tag);
+				p.put(&quot;escape&quot;, &quot;0&quot;);
+			} else {
+				tag = tag.substring(0, sp);
+				p.put(&quot;name&quot;, tag);
+				p.put(&quot;escape&quot;, &quot;html&quot;);
+			}
+		} else {
+			// = means name=value pairs.
+			// use a StringTokenizer
+			StringTokenizer st = new StringTokenizer(tag, &quot; =&quot;);
+			while(st.hasMoreTokens()) {
+				String key, value;
+				key = st.nextToken().toLowerCase();
+				if(st.hasMoreTokens())
+					value = st.nextToken();
+				else if(key.equals(&quot;escape&quot;))
+					value = &quot;html&quot;;
+				else
+					throw new NullPointerException(
+						&quot;parameter &quot; + key + &quot; has no value&quot;);
+
+				if(value.startsWith(&quot;\&quot;&quot;) &amp;&amp; 
+						value.endsWith(&quot;\&quot;&quot;))
+					value = value.substring(1,
+							value.length()-1);
+				else if(value.startsWith(&quot;'&quot;) &amp;&amp; 
+						value.endsWith(&quot;'&quot;))
+					value = value.substring(1,
+							value.length()-1);
+
+				if(value.length()==0)
+					throw new NullPointerException(
+						&quot;parameter &quot; + key + &quot; has no value&quot;);
+
+				if(key.equals(&quot;escape&quot;))
+					value=value.toLowerCase();
+
+				p.put(key, value);
+			}
+		}
+
+		String name = p.getProperty(&quot;name&quot;);
+		// if not case sensitive, and not special variable, flatten case
+		// never flatten case for includes
+		if(!case_sensitive &amp;&amp; !p.getProperty(&quot;type&quot;).equals(&quot;include&quot;)
+			&amp;&amp; !( name.startsWith(&quot;__&quot;) &amp;&amp; name.endsWith(&quot;__&quot;) ))
+		{
+			p.put(&quot;name&quot;, name.toLowerCase());
+		}
+
+		if(!Util.isNameChar(name))
+			throw new IllegalArgumentException(
+				&quot;parameter name may only contain &quot; +
+				&quot;letters, digits, ., /, +, -, _&quot;);
+		// __var__ is allowed in the template, but not in the
+		// code.  this is so that people can reference __FIRST__,
+		// etc
+
+		return p;
+	}
+}

Added: experiments/EVE/lib/lib-folder/HTML/Tmpl/Util.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/HTML/Tmpl/Util.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/HTML/Tmpl/Util.java
===================================================================
--- experiments/EVE/lib/lib-folder/HTML/Tmpl/Util.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/HTML/Tmpl/Util.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,132 @@
+/*
+*      HTML.Template:  A module for using HTML Templates with java
+*
+*      Copyright (c) 2002 Philip S Tellis (<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">philip.tellis at iname.com</A>)
+*
+*      This module is free software; you can redistribute it
+*      and/or modify it under the terms of either:
+*
+*      a) the GNU General Public License as published by the Free
+*      Software Foundation; either version 1, or (at your option)
+*      any later version, or
+*
+*      b) the &quot;Artistic License&quot; which comes with this module.
+*
+*      This program is distributed in the hope that it will be
+*      useful, but WITHOUT ANY WARRANTY; without even the implied
+*      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+*      PURPOSE.  See either the GNU General Public License or the
+*      Artistic License for more details.
+*
+*      You should have received a copy of the Artistic License
+*      with this module, in the file ARTISTIC.  If not, I'll be
+*      glad to provide one.
+*
+*      You should have received a copy of the GNU General Public
+*      License along with this program; if not, write to the Free
+*      Software Foundation, Inc., 59 Temple Place, Suite 330,
+*      Boston, MA 02111-1307 USA
+*/
+
+
+package HTML.Tmpl;
+import eve.sys.*;
+
+public class Util
+{
+	public static boolean debug=false;
+
+	public static String escapeHTML(String element)
+	{
+		String s = new String(element);	// don't change the original
+		String [] metas = {&quot;&amp;&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;\&quot;&quot;};
+		String [] repls = {&quot;&amp;&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&quot;&quot;};
+		for(int i = 0; i &lt; metas.length; i++) {
+			int pos=0;
+			do {
+				pos = s.indexOf(metas[i], pos);
+				if(pos&lt;0)
+					break;
+
+				s = s.substring(0, pos) + repls[i] + s.substring(pos+1);
+				pos++;
+			} while(pos &gt;= 0);
+		}
+
+		return s;
+	}
+
+	public static String escapeURL(String url)
+	{
+		StringBuffer s = new StringBuffer();
+		String no_escape = &quot;./-_&quot;;
+
+		for(int i=0; i&lt;url.length(); i++)
+		{
+			char c = url.charAt(i);
+			if(!Character.isLetterOrDigit(c) &amp;&amp;
+					no_escape.indexOf(c)&lt;0) 
+			{
+				String h = Integer.toHexString((int)c);
+				s.append(&quot;%&quot;);
+				if(h.length()&lt;2)
+					s.append(&quot;0&quot;);
+				s.append(h);
+			} else {
+				s.append(c);
+			}
+		}
+
+		return s.toString();
+	}
+
+	public static String escapeQuote(String element)
+	{
+		String s = new String(element);	// don't change the original
+		String [] metas = {&quot;\&quot;&quot;, &quot;'&quot;};
+		String [] repls = {&quot;\\\&quot;&quot;, &quot;\\'&quot;};
+		for(int i = 0; i &lt; metas.length; i++) {
+			int pos=0;
+			do {
+				pos = s.indexOf(metas[i], pos);
+				if(pos&lt;0)
+					break;
+
+				s = s.substring(0, pos) + repls[i] + s.substring(pos+1);
+				pos++;
+			} while(pos &gt;= 0);
+		}
+
+		return s;
+	}
+
+	public static boolean isNameChar(char c)
+	{
+		return true;
+	}
+
+	public static boolean isNameChar(String s)
+	{
+		String alt_valid = &quot;./+-_&quot;;
+
+		for(int i=0; i&lt;s.length(); i++)
+			if(!Character.isLetterOrDigit(s.charAt(i)) &amp;&amp;
+					alt_valid.indexOf(s.charAt(i))&lt;0)
+				return false;
+		return true;
+	}
+
+	public static void debug_print(String msg)
+	{
+		if(!debug)
+			return;
+
+		//System.err.println(msg);
+		Vm.debug(msg);
+	}
+
+	public static void debug_print(Object o)
+	{
+		debug_print(o.toString());
+	}
+}

Added: experiments/EVE/lib/lib-folder/com/bbn/openmap/LatLonPoint.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/bbn/openmap/LatLonPoint.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/bbn/openmap/MoreMath.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/bbn/openmap/MoreMath.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/AziDist.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/AziDist.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/Ellipsoid.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/Ellipsoid.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/GreatCircle.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/GreatCircle.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/Length.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/Length.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/Planet.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/Planet.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/Planet.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/Planet.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/Planet.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,115 @@
+// **********************************************************************
+// 
+// &lt;copyright&gt;
+// 
+//  BBN Technologies
+//  10 Moulton Street
+//  Cambridge, MA 02138
+//  (617) 873-8000
+// 
+//  Copyright (C) BBNT Solutions LLC. All rights reserved.
+// 
+// &lt;/copyright&gt;
+// **********************************************************************
+// 
+// $Source: /cvs/distapps/openmap/src/openmap/com/bbn/openmap/proj/Planet.java,v $
+// $RCSfile: Planet.java,v $
+// $Revision: 1.4.2.1 $
+// $Date: 2004/10/14 18:27:37 $
+// $Author: dietrick $
+// 
+// **********************************************************************
+
+package com.bbn.openmap.proj;
+
+import com.bbn.openmap.MoreMath;
+
+/**
+ * Planet datums and parameters. These values are taken from John
+ * Snyder's &lt;i&gt;Map Projections --A Working Manual &lt;/i&gt; You should add
+ * datums as needed, consult the ellips.dat file.
+ */
+public class Planet {
+
+    // Solar system id's. Add new ones as needed.
+    final public static transient int Earth = 3;
+    final public static transient int Mars = 4;
+
+    // WGS84 / GRS80 datums
+    final public static transient float wgs84_earthPolarRadiusMeters = 6356752.3142f;
+    final public static transient double wgs84_earthPolarRadiusMeters_D = 6356752.3142;
+    final public static transient float wgs84_earthEquatorialRadiusMeters = 6378137.0f;
+    final public static transient double wgs84_earthEquatorialRadiusMeters_D = 6378137.0;
+    final public static transient float wgs84_earthFlat = 1 - (wgs84_earthPolarRadiusMeters / wgs84_earthEquatorialRadiusMeters);// 1 -
+                                                                                                                                 // (minor/major)
+                                                                                                                                 // =
+                                                                                                                                 // 1/298.257
+    final public static transient float wgs84_earthEccen = (float) Math.sqrt(2
+            * wgs84_earthFlat - (wgs84_earthFlat * wgs84_earthFlat));// sqrt(2*f
+                                                                     // -
+                                                                     // f^2)
+                                                                     // =
+                                                                     // 0.081819221f
+
+    final public static transient float wgs84_earthEquatorialCircumferenceMeters = MoreMath.TWO_PI
+            * wgs84_earthEquatorialRadiusMeters;
+    final public static transient float wgs84_earthEquatorialCircumferenceKM = wgs84_earthEquatorialCircumferenceMeters / 1000f;
+    final public static transient float wgs84_earthEquatorialCircumferenceMiles = wgs84_earthEquatorialCircumferenceKM * 0.62137119f;//HACK
+                                                                                                                                     // use
+                                                                                                                                     // UNIX
+                                                                                                                                     // units?
+    final public static transient float wgs84_earthEquatorialCircumferenceNMiles = 21600.0f; // 60.0f
+                                                                                             // *
+                                                                                             // 360.0f;
+                                                                                             // //
+                                                                                             // sixty
+                                                                                             // nm
+                                                                                             // per
+                                                                                             // degree
+
+    final public static transient double wgs84_earthEquatorialCircumferenceMeters_D = MoreMath.TWO_PI_D
+            * wgs84_earthEquatorialRadiusMeters_D;
+    final public static transient double wgs84_earthEquatorialCircumferenceKM_D = wgs84_earthEquatorialCircumferenceMeters_D / 1000;
+    final public static transient double wgs84_earthEquatorialCircumferenceMiles_D = wgs84_earthEquatorialCircumferenceKM_D * 0.62137119;//HACK
+                                                                                                                                         // use
+                                                                                                                                         // UNIX
+                                                                                                                                         // units?
+    final public static transient double wgs84_earthEquatorialCircumferenceNMiles_D = 21600.0; // 60.0f
+                                                                                               // *
+                                                                                               // 360.0f;
+                                                                                               // //
+                                                                                               // sixty
+                                                                                               // nm
+                                                                                               // per
+                                                                                               // degree
+
+    //      wgs84_earthEquatorialCircumferenceKM*0.5389892f; // calculated,
+    // same as line above.
+    //      wgs84_earthEquatorialCircumferenceKM*0.5399568f;//HACK use UNIX
+    // units? &lt;&lt; This was wrong.
+
+    // Mars
+    final public static transient float marsEquatorialRadius = 3393400.0f;// meters
+    final public static transient float marsEccen = 0.101929f;// eccentricity
+                                                              // e
+    final public static transient float marsFlat = 0.005208324f;// 1-(1-e^2)^1/2
+
+    // International 1974
+    final public static transient float international1974_earthPolarRadiusMeters = 6356911.946f;
+    final public static transient float international1974_earthEquatorialRadiusMeters = 6378388f;
+    final public static transient float international1974_earthFlat = 1 - (international1974_earthPolarRadiusMeters / international1974_earthEquatorialRadiusMeters);// 1 -
+                                                                                                                                                                     // (minor/major)
+                                                                                                                                                                     // =
+                                                                                                                                                                     // 1/297
+
+    // Extra scale constant for better viewing of maps (do not use
+    // this to
+    // calculate anything but points to be vieved!)
+    public transient static int defaultPixelsPerMeter = 3272;// 3384:
+                                                             // mattserver/Map.C,
+                                                             // 3488:
+                                                             // dcw
+
+    // cannot construct
+    private Planet() {}
+}

Added: experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/ProjMath.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/ProjMath.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/coords/DMSLatLonPoint.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/coords/DMSLatLonPoint.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/coords/MGRSPoint.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/coords/MGRSPoint.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/coords/MGRSPoint.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/coords/MGRSPoint.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/coords/MGRSPoint.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,1162 @@
+// **********************************************************************
+//
+// &lt;copyright&gt;
+//
+// BBN Technologies
+// 10 Moulton Street
+// Cambridge, MA 02138
+// (617) 873-8000
+//
+// Copyright (C) BBNT Solutions LLC. All rights reserved.
+//
+// &lt;/copyright&gt;
+// **********************************************************************
+//
+// $Source: /cvs/distapps/openmap/src/openmap/com/bbn/openmap/proj/coords/MGRSPoint.java,v $
+// $RCSfile: MGRSPoint.java,v $
+// $Revision: 1.5.2.5 $
+// $Date: 2005/02/11 22:51:27 $
+// $Author: dietrick $
+//
+// **********************************************************************
+
+package com.bbn.openmap.proj.coords;
+/*
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.LineNumberReader;
+import java.io.PrintStream;
+*/
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.LineNumberReader;
+import eve.sys.Vm;
+import java.io.PrintWriter;
+
+
+import com.bbn.openmap.LatLonPoint;
+import com.bbn.openmap.proj.Ellipsoid;
+import com.bbn.openmap.util.ArgParser;
+//import com.bbn.openmap.util.Debug;
+
+/**
+ * A class representing a MGRS coordinate that has the ability to
+ * provide the decimal degree lat/lon equivalent, as well as the UTM
+ * equivalent. This class does not do checks to see if the MGRS
+ * coordiantes provided actually make sense. It assumes that the
+ * values are valid.
+ */
+public class MGRSPoint extends UTMPoint {
+
+    /**
+     * UTM zones are grouped, and assigned to one of a group of 6
+     * sets.
+     */
+    protected final static int NUM_100K_SETS = 6;
+    /**
+     * The column letters (for easting) of the lower left value, per
+     * set.
+     */
+    public final static int[] SET_ORIGIN_COLUMN_LETTERS = { 'A', 'J', 'S', 'A',
+            'J', 'S' };
+    /**
+     * The row letters (for northing) of the lower left value, per
+     * set.
+     */
+    public final static int[] SET_ORIGIN_ROW_LETTERS = { 'A', 'F', 'A', 'F',
+            'A', 'F' };
+    /**
+     * The column letters (for easting) of the lower left value, per
+     * set,, for Bessel Ellipsoid.
+     */
+    public final static int[] BESSEL_SET_ORIGIN_COLUMN_LETTERS = { 'A', 'J',
+            'S', 'A', 'J', 'S' };
+    /**
+     * The row letters (for northing) of the lower left value, per
+     * set, for Bessel Ellipsoid.
+     */
+    public final static int[] BESSEL_SET_ORIGIN_ROW_LETTERS = { 'L', 'R', 'L',
+            'R', 'L', 'R' };
+
+    public final static int SET_NORTHING_ROLLOVER = 20000000;
+    /**
+     * Use 5 digits for northing and easting values, for 1 meter
+     * accuracy of coordinate.
+     */
+    public final static int ACCURACY_1_METER = 5;
+    /**
+     * Use 4 digits for northing and easting values, for 10 meter
+     * accuracy of coordinate.
+     */
+    public final static int ACCURACY_10_METER = 4;
+    /**
+     * Use 3 digits for northing and easting values, for 100 meter
+     * accuracy of coordinate.
+     */
+    public final static int ACCURACY_100_METER = 3;
+    /**
+     * Use 2 digits for northing and easting values, for 1000 meter
+     * accuracy of coordinate.
+     */
+    public final static int ACCURACY_1000_METER = 2;
+    /**
+     * Use 1 digits for northing and easting values, for 10000 meter
+     * accuracy of coordinate.
+     */
+    public final static int ACCURACY_10000_METER = 1;
+
+    /** The set origin column letters to use. */
+    protected int[] originColumnLetters = SET_ORIGIN_COLUMN_LETTERS;
+    /** The set origin row letters to use. */
+    protected int[] originRowLetters = SET_ORIGIN_ROW_LETTERS;
+
+    public final static int A = 'A';
+    public final static int I = 'I';
+    public final static int O = 'O';
+    public final static int V = 'V';
+    public final static int Z = 'Z';
+
+    protected boolean DEBUG = false;
+
+    /** The String holding the MGRS coordinate value. */
+    protected String mgrs;
+
+    /**
+     * Controls the number of digits that the MGRS coordinate will
+     * have, which directly affects the accuracy of the coordinate.
+     * Default is ACCURACY_1_METER, which indicates that MGRS
+     * coordinates will have 10 digits (5 easting, 5 northing) after
+     * the 100k two letter code, indicating 1 meter resolution.
+     */
+    protected int accuracy = ACCURACY_1_METER;
+
+    /**
+     * Point to create if you are going to use the static methods to
+     * fill the values in.
+     */
+    public MGRSPoint() {
+//        DEBUG = Debug.debugging(&quot;mgrs&quot;);
+    	//DEBUG = true;
+    }
+
+    /**
+     * Constructs a new MGRS instance from a MGRS String.
+     */
+    public MGRSPoint(String mgrsString) {
+        this();
+        setMGRS(mgrsString);
+    }
+
+    /**
+     * Contructs a new MGRSPoint instance from values in another
+     * MGRSPoint.
+     */
+    public MGRSPoint(MGRSPoint point) {
+        this();
+        mgrs = point.mgrs;
+        northing = point.northing;
+        easting = point.easting;
+        zone_number = point.zone_number;
+        zone_letter = point.zone_letter;
+        accuracy = point.accuracy;
+    }
+
+    /**
+     * Create a MGRSPoint from UTM values;
+     */
+    public MGRSPoint(float northing, float easting, int zoneNumber,
+            char zoneLetter) {
+        super(northing, easting, zoneNumber, zoneLetter);
+    }
+
+    /**
+     * Contruct a MGRSPoint from a LatLonPoint, assuming a WGS_84
+     * ellipsoid.
+     */
+    public MGRSPoint(LatLonPoint llpoint) {
+        this(llpoint, Ellipsoid.WGS_84);
+    }
+
+    /**
+     * Construct a MGRSPoint from a LatLonPoint and a particular
+     * ellipsoid.
+     */
+    public MGRSPoint(LatLonPoint llpoint, Ellipsoid ellip) {
+        this();
+        LLtoMGRS(llpoint, ellip, this);
+    }
+
+    /**
+     * Set the MGRS value for this Point. Will be decoded, and the UTM
+     * values figured out. You can call toLatLonPoint() to translate
+     * it to lat/lon decimal degrees.
+     */
+    public void setMGRS(String mgrsString) {
+        try {
+            mgrs = mgrsString.toUpperCase(); // Just to make sure.
+            decode(mgrs);
+        } catch (StringIndexOutOfBoundsException sioobe) {
+            throw new NumberFormatException(&quot;MGRSPoint has bad string: &quot;
+                    + mgrsString);
+        } catch (NullPointerException npe) {
+            // Blow off
+        }
+    }
+
+    /**
+     * Get the MGRS string value - the honkin' coordinate value.
+     */
+    public String getMGRS() {
+        if (mgrs == null) {
+            resolve();
+        }
+        return mgrs;
+    }
+
+    /**
+     * Convert this MGRSPoint to a LatLonPoint, and assume a WGS_84
+     * ellisoid.
+     */
+    public LatLonPoint toLatLonPoint() {
+        return toLatLonPoint(Ellipsoid.WGS_84, new LatLonPoint());
+    }
+
+    /**
+     * Convert this MGRSPoint to a LatLonPoint, and use the given
+     * ellipsoid.
+     */
+    public LatLonPoint toLatLonPoint(Ellipsoid ellip) {
+        return toLatLonPoint(ellip, new LatLonPoint());
+    }
+
+    /**
+     * Fill in the given LatLonPoint with the converted values of this
+     * MGRSPoint, and use the given ellipsoid.
+     */
+    public LatLonPoint toLatLonPoint(Ellipsoid ellip, LatLonPoint llpoint) {
+        return MGRStoLL(this, ellip, llpoint);
+    }
+
+    /**
+     * Returns a string representation of the object.
+     * 
+     * @return String representation
+     */
+    public String toString() {
+        return &quot;MGRSPoint[&quot; + mgrs + &quot;]&quot;;
+    }
+
+    /**
+     * Create a LatLonPoint from a MGRSPoint.
+     * 
+     * @param mgrsp to convert.
+     * @param ellip Ellipsoid for earth model.
+     * @param llp a LatLonPoint to fill in values for. If null, a new
+     *        LatLonPoint will be returned. If not null, the new
+     *        values will be set in this object, and it will be
+     *        returned.
+     * @return LatLonPoint with values converted from MGRS coordinate.
+     */
+    public static LatLonPoint MGRStoLL(MGRSPoint mgrsp, Ellipsoid ellip,
+                                       LatLonPoint llp) {
+        return UTMtoLL(mgrsp, ellip, llp);
+    }
+
+    /**
+     * Converts a LatLonPoint to a MGRS Point, assuming the WGS_84
+     * ellipsoid.
+     * 
+     * @return MGRSPoint, or null if something bad happened.
+     */
+    public static MGRSPoint LLtoMGRS(LatLonPoint llpoint) {
+        return LLtoMGRS(llpoint, Ellipsoid.WGS_84, new MGRSPoint());
+    }
+
+    /**
+     * Converts a LatLonPoint to a MGRS Point.
+     * 
+     * @param llpoint the LatLonPoint to convert.
+     * @param mgrsp a MGRSPoint to put the results in. If it's null, a
+     *        MGRSPoint will be allocated.
+     * @return MGRSPoint, or null if something bad happened. If a
+     *         MGRSPoint was passed in, it will also be returned on a
+     *         successful conversion.
+     */
+    public static MGRSPoint LLtoMGRS(LatLonPoint llpoint, MGRSPoint mgrsp) {
+        return LLtoMGRS(llpoint, Ellipsoid.WGS_84, mgrsp);
+    }
+
+    /**
+     * Create a MGRSPoint from a LatLonPoint.
+     * 
+     * @param llp LatLonPoint to convert.
+     * @param ellip Ellipsoid for earth model.
+     * @param mgrsp a MGRSPoint to fill in values for. If null, a new
+     *        MGRSPoint will be returned. If not null, the new values
+     *        will be set in this object, and it will be returned.
+     * @return MGRSPoint with values converted from lat/lon.
+     */
+    public static MGRSPoint LLtoMGRS(LatLonPoint llp, Ellipsoid ellip,
+                                     MGRSPoint mgrsp) {
+        mgrsp = (MGRSPoint) LLtoUTM(llp, ellip, mgrsp);
+        mgrsp.resolve();
+        return mgrsp;
+    }
+
+    /**
+     * Convert MGRS zone letter to UTM zone letter, N or S.
+     * @param mgrsZone
+     * @return N of given zone is equal or larger than N, S otherwise.
+     */
+    public static char MGRSZoneToUTMZone(char mgrsZone) {
+        if (Character.toUpperCase(mgrsZone) &gt;= 'N') {
+            return 'N';
+        } else {
+            return 'S';
+        }
+    }
+
+    /**
+     * Method that provides a check for MGRS zone letters. Returns an
+     * uppercase version of any valid letter passed in.
+     */
+    protected char checkZone(char zone) {
+        zone = Character.toUpperCase(zone);
+
+        if (zone &lt;= 'A' || zone == 'B' || zone == 'Y' || zone &gt;= 'Z'
+                || zone == 'I' || zone == 'O') {
+            throw new NumberFormatException(&quot;Invalid MGRSPoint zone letter: &quot;
+                    + zone);
+        }
+
+        return zone;
+    }
+
+    /**
+     * Determines the correct MGRS letter designator for the given
+     * latitude returns 'Z' if latitude is outside the MGRS limits of
+     * 84N to 80S.
+     * 
+     * @param Lat The float value of the latitude.
+     * 
+     * @return A char value which is the MGRS zone letter.
+     */
+    public  char getLetterDesignator(double lat) {
+
+        //This is here as an error flag to show that the Latitude is
+        //outside MGRS limits
+        char LetterDesignator = 'Z';
+
+        if ((84 &gt;= lat) &amp;&amp; (lat &gt;= 72))
+            LetterDesignator = 'X';
+        else if ((72 &gt; lat) &amp;&amp; (lat &gt;= 64))
+            LetterDesignator = 'W';
+        else if ((64 &gt; lat) &amp;&amp; (lat &gt;= 56))
+            LetterDesignator = 'V';
+        else if ((56 &gt; lat) &amp;&amp; (lat &gt;= 48))
+            LetterDesignator = 'U';
+        else if ((48 &gt; lat) &amp;&amp; (lat &gt;= 40))
+            LetterDesignator = 'T';
+        else if ((40 &gt; lat) &amp;&amp; (lat &gt;= 32))
+            LetterDesignator = 'S';
+        else if ((32 &gt; lat) &amp;&amp; (lat &gt;= 24))
+            LetterDesignator = 'R';
+        else if ((24 &gt; lat) &amp;&amp; (lat &gt;= 16))
+            LetterDesignator = 'Q';
+        else if ((16 &gt; lat) &amp;&amp; (lat &gt;= 8))
+            LetterDesignator = 'P';
+        else if ((8 &gt; lat) &amp;&amp; (lat &gt;= 0))
+            LetterDesignator = 'N';
+        else if ((0 &gt; lat) &amp;&amp; (lat &gt;= -8))
+            LetterDesignator = 'M';
+        else if ((-8 &gt; lat) &amp;&amp; (lat &gt;= -16))
+            LetterDesignator = 'L';
+        else if ((-16 &gt; lat) &amp;&amp; (lat &gt;= -24))
+            LetterDesignator = 'K';
+        else if ((-24 &gt; lat) &amp;&amp; (lat &gt;= -32))
+            LetterDesignator = 'J';
+        else if ((-32 &gt; lat) &amp;&amp; (lat &gt;= -40))
+            LetterDesignator = 'H';
+        else if ((-40 &gt; lat) &amp;&amp; (lat &gt;= -48))
+            LetterDesignator = 'G';
+        else if ((-48 &gt; lat) &amp;&amp; (lat &gt;= -56))
+            LetterDesignator = 'F';
+        else if ((-56 &gt; lat) &amp;&amp; (lat &gt;= -64))
+            LetterDesignator = 'E';
+        else if ((-64 &gt; lat) &amp;&amp; (lat &gt;= -72))
+            LetterDesignator = 'D';
+        else if ((-72 &gt; lat) &amp;&amp; (lat &gt;= -80))
+            LetterDesignator = 'C';
+        return LetterDesignator;
+    }
+
+    /**
+     * Set the number of digits to use for easting and northing
+     * numbers in the mgrs string, which reflects the accuracy of the
+     * corrdinate. From 5 (1 meter) to 1 (10,000 meter).
+     */
+    public void setAccuracy(int value) {
+        accuracy = value;
+        mgrs = null;
+    }
+
+    public int getAccuracy() {
+        return accuracy;
+    }
+
+    /**
+     * Set the UTM parameters from a MGRS string.
+     * 
+     * @param mgrsString an UPPERCASE coordinate string is expected.
+     */
+    protected void decode(String mgrsString) throws NumberFormatException {
+
+        if (mgrsString == null || mgrsString.length() == 0) {
+            throw new NumberFormatException(&quot;MGRSPoint coverting from nothing&quot;);
+        }
+
+        int length = mgrsString.length();
+
+        String hunK = null;
+        String seasting = null;
+        String snorthing = null;
+
+        StringBuffer sb = new StringBuffer();
+        char testChar;
+        int i = 0;
+
+        // get Zone number
+        while (!Character.isLetter(testChar = mgrsString.charAt(i))) {
+            if (i &gt; 2) {
+                throw new NumberFormatException(&quot;MGRSPoint bad conversion from: &quot;
+                        + mgrsString);
+            }
+            sb.append(testChar);
+            i++;
+        }
+
+        zone_number = Integer.parseInt(sb.toString());
+
+        if (i == 0 || i + 3 &gt; length) {
+            // A good MGRS string has to be 4-5 digits long,
+            // ##AAA/#AAA at least.
+            throw new NumberFormatException(&quot;MGRSPoint bad conversion from: &quot;
+                    + mgrsString);
+        }
+
+        zone_letter = mgrsString.charAt(i++);
+
+        // Should we check the zone letter here? Why not.
+        if (zone_letter &lt;= 'A' || zone_letter == 'B' || zone_letter == 'Y'
+                || zone_letter &gt;= 'Z' || zone_letter == 'I'
+                || zone_letter == 'O') {
+            throw new NumberFormatException(&quot;MGRSPoint zone letter &quot;
+                    + (char) zone_letter + &quot; not handled: &quot; + mgrsString);
+        }
+
+        hunK = mgrsString.substring(i, i += 2);
+
+        int set = get100kSetForZone(zone_number);
+
+        float east100k = getEastingFromChar(hunK.charAt(0), set);
+        float north100k = getNorthingFromChar(hunK.charAt(1), set);
+
+        // We have a bug where the northing may be 2000000 too low.
+        // How
+        // do we know when to roll over?
+
+        while (north100k &lt; getMinNorthing(zone_letter)) {
+            north100k += 2000000;
+        }
+
+        // calculate the char index for easting/northing separator
+        int remainder = length - i;
+
+        if (remainder % 2 != 0) {
+            throw new NumberFormatException(&quot;MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters&quot;
+                    + mgrsString);
+        }
+
+        int sep = remainder / 2;
+
+        float sepEasting = 0f;
+        float sepNorthing = 0f;
+
+        if (sep &gt; 0) {
+            if (DEBUG)
+                Vm.debug(&quot; calculating e/n from &quot; + mgrs.substring(i));
+            float accuracyBonus = 100000f / (float) Math.pow(10, sep);
+            if (DEBUG)
+                Vm.debug(&quot; calculated accuracy bonus as  &quot; + accuracyBonus);
+            String sepEastingString = mgrsString.substring(i, i + sep);
+            if (DEBUG)
+                Vm.debug(&quot; parsed easting as &quot; + sepEastingString);
+            sepEasting = Float.parseFloat(sepEastingString) * accuracyBonus;
+            String sepNorthingString = mgrsString.substring(i + sep);
+            if (DEBUG)
+                Vm.debug(&quot; parsed northing as &quot; + sepNorthingString);
+            sepNorthing = Float.parseFloat(sepNorthingString) * accuracyBonus;
+        }
+
+        easting = sepEasting + east100k;
+        northing = sepNorthing + north100k;
+
+        if (DEBUG) {
+            Vm.debug(&quot;Decoded &quot; + mgrsString + &quot; as zone number: &quot;
+                    + zone_number + &quot;, zone letter: &quot; + zone_letter
+                    + &quot;, easting: &quot; + easting + &quot;, northing: &quot; + northing
+                    + &quot;, 100k: &quot; + hunK);
+        }
+    }
+
+    /**
+     * Create the mgrs string based on the internal UTM settings,
+     * using the accuracy set in the MGRSPoint.
+     */
+    protected void resolve() {
+        resolve(accuracy);
+    }
+
+    /**
+     * Create the mgrs string based on the internal UTM settings.
+     * 
+     * @param digitAccuracy The number of digits to use for the
+     *        northing and easting numbers. 5 digits reflect a 1 meter
+     *        accuracy, 4 - 10 meter, 3 - 100 meter, 2 - 1000 meter, 1 -
+     *        10,000 meter.
+     */
+    protected void resolve(int digitAccuracy) {
+        if (zone_letter == 'Z') {
+            mgrs = &quot;Latitude limit exceeded&quot;;
+        } else {
+            StringBuffer sb = new StringBuffer(zone_number + &quot;&quot;
+                    + (char) zone_letter
+                    + get100kID(easting, northing, zone_number));
+            StringBuffer seasting = new StringBuffer(Integer.toString((int) easting));
+            StringBuffer snorthing = new StringBuffer(Integer.toString((int) northing));
+
+            if (DEBUG) {
+                Vm.debug(&quot; Resolving MGRS from easting: &quot; + seasting
+                        + &quot; derived from &quot; + easting + &quot;, and northing: &quot;
+                        + snorthing + &quot; derived from &quot; + northing);
+            }
+
+            while (digitAccuracy + 1 &gt; seasting.length()) {
+                seasting.insert(0, '0');
+            }
+
+            // We have to be careful here, the 100k values shouldn't
+            // be
+            // used for calculating stuff here.
+
+            while (digitAccuracy + 1 &gt; snorthing.length()) {
+                snorthing.insert(0, '0');
+            }
+
+            while (snorthing.length() &gt; 6) {
+                snorthing.deleteCharAt(0);
+            }
+
+            if (DEBUG) {
+                Vm.debug(&quot; -- modified easting: &quot; + seasting
+                        + &quot; and northing: &quot; + snorthing);
+            }
+
+            try {
+                sb.append(seasting.substring(1, digitAccuracy + 1)
+                        + snorthing.substring(1, digitAccuracy + 1));
+
+                mgrs = sb.toString();
+            } catch (IndexOutOfBoundsException ioobe) {
+                mgrs = null;
+            }
+        }
+    }
+
+    /**
+     * Given a UTM zone number, figure out the MGRS 100K set it is in.
+     */
+    protected int get100kSetForZone(int i) {
+        int set = i % NUM_100K_SETS;
+        if (set == 0)
+            set = NUM_100K_SETS;
+        return set;
+    }
+
+    /**
+     * Provided so that extensions to this class can provide different
+     * origin letters, in case of different ellipsoids. The int[]
+     * represents all of the first letters in the bottom left corner
+     * of each set box, as shown in an MGRS 100K box layout.
+     */
+    protected int[] getOriginColumnLetters() {
+        return originColumnLetters;
+    }
+
+    /**
+     * Provided so that extensions to this class can provide different
+     * origin letters, in case of different ellipsoids. The int[]
+     * represents all of the first letters in the bottom left corner
+     * of each set box, as shown in an MGRS 100K box layout.
+     */
+    protected void setOriginColumnLetters(int[] letters) {
+        originColumnLetters = letters;
+    }
+
+    /**
+     * Provided so that extensions to this class can provide different
+     * origin letters, in case of different ellipsoids. The int[]
+     * represents all of the second letters in the bottom left corner
+     * of each set box, as shown in an MGRS 100K box layout.
+     */
+    protected int[] getOriginRowLetters() {
+        return originRowLetters;
+    }
+
+    /**
+     * Provided so that extensions to this class can provide different
+     * origin letters, in case of different ellipsoids. The int[]
+     * represents all of the second letters in the bottom left corner
+     * of each set box, as shown in an MGRS 100K box layout.
+     */
+    protected void setOriginRowLetters(int[] letters) {
+        originRowLetters = letters;
+    }
+
+    /**
+     * Get the two letter 100k designator for a given UTM easting,
+     * northing and zone number value.
+     */
+    protected String get100kID(float easting, float northing, int zone_number) {
+        int set = get100kSetForZone(zone_number);
+        int setColumn = ((int) easting / 100000);
+        int setRow = ((int) northing / 100000) % 20;
+        return get100kID(setColumn, setRow, set);
+    }
+
+    /**
+     * Given the first letter from a two-letter MGRS 100k zone, and
+     * given the MGRS table set for the zone number, figure out the
+     * easting value that should be added to the other, secondary
+     * easting value.
+     */
+    protected float getEastingFromChar(char e, int set) {
+        int baseCol[] = getOriginColumnLetters();
+        // colOrigin is the letter at the origin of the set for the
+        // column
+        int curCol = baseCol[set - 1];
+        float eastingValue = 100000f;
+        boolean rewindMarker = false;
+
+        while (curCol != e) {
+            curCol++;
+            if (curCol == I)
+                curCol++;
+            if (curCol == O)
+                curCol++;
+            if (curCol &gt; Z) {
+                if (rewindMarker) {
+                    throw new NumberFormatException(&quot;Bad character: &quot; + e);
+                }
+                curCol = A;
+                rewindMarker = true;
+            }
+            eastingValue += 100000f;
+        }
+
+        if (DEBUG) {
+            Vm.debug(&quot;Easting value for &quot; + (char) e + &quot; from set: &quot; + set
+                    + &quot;, col: &quot; + curCol + &quot; is &quot; + eastingValue);
+        }
+        return eastingValue;
+    }
+
+    /**
+     * Given the second letter from a two-letter MGRS 100k zone, and
+     * given the MGRS table set for the zone number, figure out the
+     * northing value that should be added to the other, secondary
+     * northing value. You have to remember that Northings are
+     * determined from the equator, and the vertical cycle of letters
+     * mean a 2000000 additional northing meters. This happens approx.
+     * every 18 degrees of latitude. This method does *NOT* count any
+     * additional northings. You have to figure out how many 2000000
+     * meters need to be added for the zone letter of the MGRS
+     * coordinate.
+     * 
+     * @param n second letter of the MGRS 100k zone
+     * @param set the MGRS table set number, which is dependent on the
+     *        UTM zone number.
+     */
+    protected float getNorthingFromChar(char n, int set) {
+
+        if (n &gt; 'V') {
+            throw new NumberFormatException(&quot;MGRSPoint given invalid Northing &quot;
+                    + n);
+        }
+
+        int baseRow[] = getOriginRowLetters();
+        // rowOrigin is the letter at the origin of the set for the
+        // column
+        int curRow = baseRow[set - 1];
+        float northingValue = 0f;
+        boolean rewindMarker = false;
+
+        while (curRow != n) {
+            curRow++;
+            if (curRow == I)
+                curRow++;
+            if (curRow == O)
+                curRow++;
+            // fixing a bug making whole application hang in this loop
+            // when 'n' is a wrong character
+            if (curRow &gt; V) {
+                if (rewindMarker) { //making sure that this loop ends
+                    throw new NumberFormatException(&quot;Bad character: &quot; + n);
+                }
+                curRow = A;
+                rewindMarker = true;
+            }
+            northingValue += 100000f;
+        }
+
+        if (DEBUG) {
+            Vm.debug(&quot;Northing value for &quot; + (char) n + &quot; from set: &quot; + set
+                    + &quot;, row: &quot; + curRow + &quot; is &quot; + northingValue);
+        }
+
+        return northingValue;
+    }
+
+    /**
+     * Get the two-letter MGRS 100k designator given information
+     * translated from the UTM northing, easting and zone number.
+     * 
+     * @param setColumn the column index as it relates to the MGRS
+     *        100k set spreadsheet, created from the UTM easting.
+     *        Values are 1-8.
+     * @param setRow the row index as it relates to the MGRS 100k set
+     *        spreadsheet, created from the UTM northing value. Values
+     *        are from 0-19.
+     * @param set the set block, as it relates to the MGRS 100k set
+     *        spreadsheet, created from the UTM zone. Values are from
+     *        1-60.
+     * @return two letter MGRS 100k code.
+     */
+    protected String get100kID(int setColumn, int setRow, int set) {
+
+        if (DEBUG) {
+        	
+            Vm.debug(&quot;set (&quot; + set + &quot;) column = &quot; + setColumn
+                    + &quot;, row = &quot; + setRow);
+        }
+
+        int baseCol[] = getOriginColumnLetters();
+        int baseRow[] = getOriginRowLetters();
+
+        // colOrigin and rowOrigin are the letters at the origin of
+        // the set
+        int colOrigin = baseCol[set - 1];
+        int rowOrigin = baseRow[set - 1];
+
+        if (DEBUG) {
+        	Vm.debug(&quot;starting at = &quot; + (char) colOrigin
+                    + (char) rowOrigin);
+        }
+
+        // colInt and rowInt are the letters to build to return
+        int colInt = colOrigin + setColumn - 1;
+        int rowInt = rowOrigin + setRow;
+        boolean rollover = false;
+
+        if (colInt &gt; Z) {
+            colInt = colInt - Z + A - 1;
+            rollover = true;
+            if (DEBUG)
+                Vm.debug(&quot;rolling over col, new value: &quot;
+                        + (char) colInt);
+        }
+
+        if (colInt == I || (colOrigin &lt; I &amp;&amp; colInt &gt; I)
+                || ((colInt &gt; I || colOrigin &lt; I) &amp;&amp; rollover)) {
+            colInt++;
+            if (DEBUG)
+                Vm.debug(&quot;skipping I in col, new value: &quot;
+                        + (char) colInt);
+        }
+        if (colInt == O || (colOrigin &lt; O &amp;&amp; colInt &gt; O)
+                || ((colInt &gt; O || colOrigin &lt; O) &amp;&amp; rollover)) {
+            colInt++;
+            if (DEBUG)
+                Vm.debug(&quot;skipping O in col, new value: &quot;
+                        + (char) colInt);
+            if (colInt == I) {
+                colInt++;
+                if (DEBUG)
+                    Vm.debug(&quot;  hit I, new value: &quot; + (char) colInt);
+            }
+        }
+
+        if (colInt &gt; Z) {
+            colInt = colInt - Z + A - 1;
+            if (DEBUG)
+                Vm.debug(&quot;rolling(2) col, new value: &quot;
+                        + (char) rowInt);
+        }
+
+        if (rowInt &gt; V) {
+            rowInt = rowInt - V + A - 1;
+            rollover = true;
+            if (DEBUG)
+                Vm.debug(&quot;rolling over row, new value: &quot;
+                        + (char) rowInt);
+        } else {
+            rollover = false;
+        }
+
+        if (rowInt == I || (rowOrigin &lt; I &amp;&amp; rowInt &gt; I)
+                || ((rowInt &gt; I || rowOrigin &lt; I) &amp;&amp; rollover)) {
+            rowInt++;
+            if (DEBUG)
+                Vm.debug(&quot;skipping I in row, new value: &quot;
+                        + (char) rowInt);
+        }
+
+        if (rowInt == O || (rowOrigin &lt; O &amp;&amp; rowInt &gt; O)
+                || ((rowInt &gt; O || rowOrigin &lt; O) &amp;&amp; rollover)) {
+            rowInt++;
+            if (DEBUG)
+                Vm.debug(&quot;skipping O in row, new value: &quot;
+                        + (char) rowInt);
+            if (rowInt == I) {
+                rowInt++;
+                if (DEBUG)
+                    Vm.debug(&quot;  hit I, new value: &quot; + (char) rowInt);
+            }
+        }
+
+        if (rowInt &gt; V) {
+            rowInt = rowInt - V + A - 1;
+            if (DEBUG)
+                Vm.debug(&quot;rolling(2) row, new value: &quot;
+                        + (char) rowInt);
+        }
+
+        String twoLetter = (char) colInt + &quot;&quot; + (char) rowInt;
+
+        if (DEBUG) {
+            Vm.debug(&quot;ending at = &quot; + twoLetter);
+        }
+
+        return twoLetter;
+    }
+
+    /**
+     * Testing method, used to print out the MGRS 100k two letter set
+     * tables.
+     */
+    protected void print100kSets() {
+        StringBuffer sb = null;
+        for (int set = 1; set &lt;= 6; set++) {
+            Vm.debug(&quot;-------------\nFor 100K Set &quot; + set
+                    + &quot;:\n-------------\n&quot;);
+            for (int i = 19; i &gt;= 0; i -= 1) {
+                sb = new StringBuffer((i * 100000) + &quot;\t| &quot;);
+
+                for (int j = 1; j &lt;= 8; j++) {
+                    sb.append(&quot; &quot; + get100kID(j, i, set));
+                }
+
+                sb.append(&quot; |&quot;);
+                Vm.debug(sb.toString());
+            }
+        }
+    }
+
+    /**
+     * The function getMinNorthing returns the minimum northing value
+     * of a MGRS zone.
+     * 
+     * portted from Geotrans' c Lattitude_Band_Value strucure table.
+     * zoneLetter : MGRS zone (input)
+     */
+
+    protected float getMinNorthing(char zoneLetter)
+            throws NumberFormatException {
+        float northing;
+        switch (zoneLetter) {
+        case 'C':
+            northing = 1100000.0f;
+            break;
+        case 'D':
+            northing = 2000000.0f;
+            break;
+        case 'E':
+            northing = 2800000.0f;
+            break;
+        case 'F':
+            northing = 3700000.0f;
+            break;
+        case 'G':
+            northing = 4600000.0f;
+            break;
+        case 'H':
+            northing = 5500000.0f;
+            break;
+        case 'J':
+            northing = 6400000.0f;
+            break;
+        case 'K':
+            northing = 7300000.0f;
+            break;
+        case 'L':
+            northing = 8200000.0f;
+            break;
+        case 'M':
+            northing = 9100000.0f;
+            break;
+        case 'N':
+            northing = 0.0f;
+            break;
+        case 'P':
+            northing = 800000.0f;
+            break;
+        case 'Q':
+            northing = 1700000.0f;
+            break;
+        case 'R':
+            northing = 2600000.0f;
+            break;
+        case 'S':
+            northing = 3500000.0f;
+            break;
+        case 'T':
+            northing = 4400000.0f;
+            break;
+        case 'U':
+            northing = 5300000.0f;
+            break;
+        case 'V':
+            northing = 6200000.0f;
+            break;
+        case 'W':
+            northing = 7000000.0f;
+            break;
+        case 'X':
+            northing = 7900000.0f;
+            break;
+        default:
+            northing = -1.0f;
+        }
+        if (northing &gt;= 0.0) {
+            return northing;
+        } else {
+            throw new NumberFormatException(&quot;Invalid zone letter: &quot;
+                    + zone_letter);
+        }
+
+    }
+    private static void runTests(String fName, String inType) {
+
+        LineNumberReader lnr = null;
+        PrintWriter pos = null;
+//        PrintStream pos = null;
+        String record = null;
+        StringBuffer outStr1 = new StringBuffer();
+        StringBuffer outStr2 = new StringBuffer();
+
+        try {
+
+            /*
+             * File inFile = new File(fName + &quot;.dat&quot;); File outFile =
+             * new File(fName + &quot;.out&quot;); FileInputStream fis = new
+             * FileInputStream(inFile); FileOutputStream fos = new
+             * FileOutputStream(outFile); BufferedInputStream bis =
+             * new BufferedInputStream(fis);
+             */
+        	//pos = new PrintStream(new FileOutputStream(new File(fName + &quot;.out&quot;)));
+        	pos = new PrintWriter(new FileOutputStream(new File(fName + &quot;.out&quot;)));
+
+            lnr = new LineNumberReader(new InputStreamReader(new BufferedInputStream(new FileInputStream(new File(fName)))));
+
+            if (inType.equalsIgnoreCase(&quot;MGRS&quot;)) {
+                outStr1.append(&quot;MGRS to LatLonPoint\n\tMGRS\t\tLatitude   Longitude\n&quot;);
+                outStr2.append(&quot;MGRS to UTM\n\tMGRS\t\tZone Easting Northing\n&quot;);
+            } else if (inType.equalsIgnoreCase(&quot;UTM&quot;)) {
+                outStr1.append(&quot;UTM to LatLonPoint\n\tUTM\t\tLatitude   Longitude\n&quot;);
+                outStr2.append(&quot;UTM to MGRS\n\tUTM\t\tMGRS\n&quot;);
+            } else if (inType.equalsIgnoreCase(&quot;LatLon&quot;)) {
+                outStr1.append(&quot;LatLonPoint to UTM\nLatitude   Longitude\t\tZone Easting Northing     \n&quot;);
+                outStr2.append(&quot;LatLonPoint to MGRS\nLatitude   Longitude\t\tMGRS\n&quot;);
+            }
+
+            while ((record = lnr.readLine()) != null) {
+                if (inType.equalsIgnoreCase(&quot;MGRS&quot;)) {
+                    try {
+                        MGRSPoint mgrsp = new MGRSPoint(record);
+                        record.trim();
+                        mgrsp.decode(record);
+
+                        outStr1.append(record + &quot; is &quot; + mgrsp.toLatLonPoint()
+                                + &quot;\n&quot;);
+                        outStr2.append(record + &quot; to UTM: &quot; + mgrsp.zone_number
+                                + &quot; &quot; + mgrsp.easting + &quot; &quot; + mgrsp.northing
+                                + &quot;\n&quot;);
+                    } catch (NumberFormatException nfe) {
+                        Vm.debug(nfe.getMessage());
+                    }
+
+                } else if (inType.equalsIgnoreCase(&quot;UTM&quot;)) {
+                    MGRSPoint mgrsp;
+                    UTMPoint utmp;
+                    float e, n;
+                    int z;
+                    char zl;
+                    String tmp;
+                    record.trim();
+                    tmp = record.substring(0, 2);
+                    z = Integer.parseInt(tmp);
+                    tmp = record.substring(5, 11);
+                    e = Float.parseFloat(tmp);
+                    tmp = record.substring(12, 19);
+                    n = Float.parseFloat(tmp);
+                    zl = record.charAt(3);
+                    utmp = new UTMPoint(n, e, z, zl);
+                    LatLonPoint llp = utmp.toLatLonPoint();
+                    mgrsp = LLtoMGRS(llp);
+                    outStr1.append(record + &quot; is &quot; + llp + &quot; back to &quot;
+                            + LLtoUTM(llp) + &quot;\n&quot;);
+                    outStr2.append(record + &quot; is &quot; + mgrsp + &quot;\n&quot;);
+                } else if (inType.equalsIgnoreCase(&quot;LatLon&quot;)) {
+                    MGRSPoint mgrsp;
+                    UTMPoint utmp;
+                    LatLonPoint llp;
+                    float lat, lon;
+                    int index;
+                    String tmp;
+                    record.trim();
+                    index = record.indexOf(&quot;\040&quot;);
+                    if (index &lt; 0) {
+                        index = record.indexOf(&quot;\011&quot;);
+                    }
+                    tmp = record.substring(0, index);
+                    lat = Float.parseFloat(tmp);
+                    tmp = record.substring(index);
+                    lon = Float.parseFloat(tmp);
+                    llp = new LatLonPoint(lat, lon);
+                    utmp = LLtoUTM(llp);
+                    mgrsp = LLtoMGRS(llp);
+                    outStr1.append(record + &quot; to UTM: &quot; + mgrsp.zone_number
+                            + &quot; &quot; + mgrsp.easting + &quot; &quot; + mgrsp.northing + &quot;\n&quot;);
+                    outStr2.append(record + &quot;    -&gt;    &quot; + mgrsp.mgrs + &quot;\n&quot;);
+                }
+
+            }
+
+        } catch (IOException e) {
+            // catch io errors from FileInputStream or readLine()
+            Vm.debug(&quot;IO error: &quot; + e.getMessage());
+
+        } finally {
+            if (pos != null) {
+                pos.print(outStr1.toString());
+                pos.print(&quot;\n&quot;);
+                pos.print(outStr2.toString());
+                pos.close();
+            }
+            // if the file opened okay, make sure we close it
+            if (lnr != null) {
+                try {
+                    lnr.close();
+                } catch (IOException ioe) {
+                }
+            }
+
+        }
+
+    }
+
+    public static void main(String[] argv) {
+//        Debug.init();
+
+        ArgParser ap = new ArgParser(&quot;MGRSPoint&quot;);
+        ap.add(&quot;mgrs&quot;, &quot;Print Latitude and Longitude for MGRS value&quot;, 1);
+        ap.add(&quot;latlon&quot;,
+                &quot;Print MGRS for Latitude and Longitude values&quot;,
+                2,
+                true);
+        ap.add(&quot;sets&quot;, &quot;Print the MGRS 100k table&quot;);
+        ap.add(&quot;altsets&quot;, &quot;Print the MGRS 100k table for the Bessel ellipsoid&quot;);
+        ap.add(&quot;rtc&quot;,
+                &quot;Run test case, with filename and input data type [MGRS | UTM | LatLon]&quot;,
+                2);
+
+        if (!ap.parse(argv)) {
+            ap.printUsage();
+            System.exit(0);
+        }
+
+        String arg[];
+        arg = ap.getArgValues(&quot;sets&quot;);
+        if (arg != null) {
+            new MGRSPoint().print100kSets();
+        }
+
+        arg = ap.getArgValues(&quot;altsets&quot;);
+        if (arg != null) {
+            MGRSPoint mgrsp = new MGRSPoint();
+            mgrsp.setOriginColumnLetters(BESSEL_SET_ORIGIN_COLUMN_LETTERS);
+            mgrsp.setOriginRowLetters(BESSEL_SET_ORIGIN_ROW_LETTERS);
+            mgrsp.print100kSets();
+        }
+
+        arg = ap.getArgValues(&quot;mgrs&quot;);
+        if (arg != null) {
+            try {
+                MGRSPoint mgrsp = new MGRSPoint(arg[0]);
+                Vm.debug(arg[0] + &quot; is &quot; + mgrsp.toLatLonPoint());
+            } catch (NumberFormatException nfe) {
+                Vm.debug(nfe.getMessage());
+            }
+        }
+
+        arg = ap.getArgValues(&quot;latlon&quot;);
+        if (arg != null) {
+            try {
+
+                float lat = Float.parseFloat(arg[0]);
+                float lon = Float.parseFloat(arg[1]);
+
+                LatLonPoint llp = new LatLonPoint(lat, lon);
+                MGRSPoint mgrsp = LLtoMGRS(llp);
+                UTMPoint utmp = LLtoUTM(llp);
+
+                if (utmp.zone_letter == 'Z') {
+                    Vm.debug(llp + &quot;to UTM: latitude limit exceeded.&quot;);
+                } else {
+                    Vm.debug(llp + &quot; is &quot; + utmp);
+                }
+
+                Vm.debug(llp + &quot; is &quot; + mgrsp);
+
+            } catch (NumberFormatException nfe) {
+                Vm.debug(&quot;The numbers provided:  &quot; + argv[0] + &quot;, &quot;
+                        + argv[1] + &quot; aren't valid&quot;);
+            }
+        }
+
+        arg = ap.getArgValues(&quot;rtc&quot;);
+        if (arg != null) {
+            runTests(arg[0], arg[1]);
+        }
+
+    }
+}
+

Added: experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/coords/UTMPoint.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/bbn/openmap/proj/coords/UTMPoint.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/bbn/openmap/util/ArgParser$Arg.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/bbn/openmap/util/ArgParser$Arg.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/bbn/openmap/util/ArgParser$HelpArg.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/bbn/openmap/util/ArgParser$HelpArg.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/bbn/openmap/util/ArgParser.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/bbn/openmap/util/ArgParser.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/bbn/openmap/util/ArgParser.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/bbn/openmap/util/ArgParser.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/bbn/openmap/util/ArgParser.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,455 @@
+// **********************************************************************
+// 
+// &lt;copyright&gt;
+// 
+//  BBN Technologies
+//  10 Moulton Street
+//  Cambridge, MA 02138
+//  (617) 873-8000
+// 
+//  Copyright (C) BBNT Solutions LLC. All rights reserved.
+// 
+// &lt;/copyright&gt;
+// **********************************************************************
+// 
+// $Source: /cvs/distapps/openmap/src/openmap/com/bbn/openmap/util/ArgParser.java,v $
+// $RCSfile: ArgParser.java,v $
+// $Revision: 1.2.2.3 $
+// $Date: 2005/01/10 17:08:43 $
+// $Author: dietrick $
+// 
+// **********************************************************************
+
+package com.bbn.openmap.util;
+
+//import java.util.Vector;
+import java.lang.*;
+import java.util.Vector;
+import eve.sys.Vm;
+/**
+ * A simple class to manage the line arguments of a program. Takes the
+ * String[] argv that is provided to the main method of a class, and
+ * separates them out, depending on the options given to the
+ * ArgParser. After you create the parser, add your options that you
+ * want.
+ */
+public class ArgParser {
+    /**
+     * The length to submit if you want a variable length list at the
+     * end of the command line, like all the arguments left over.
+     */
+    public final static int TO_END = -1;
+    /** The program name that's using the parser. */
+    protected String programName;
+    /** The Args that the parser is looking for. */
+    protected Vector args;
+    /** The String array that holds all of the leftover argvs. */
+    protected String[] rest = new String[0];
+    /** The character flag for an option. */
+    protected char option = '-';
+    /**
+     * Tells the Args to accept the first letter of their name for
+     * argv options specified with one letter.
+     */
+    protected boolean allowAbbr = true;
+
+    /**
+     * Create a parser for the named program. Automatically adds the
+     * -help option.
+     * 
+     * @param pName the program name.
+     */
+    public ArgParser(String pName) {
+        programName = pName;
+        args = new Vector();
+        args.add(new HelpArg());
+    }
+
+    /**
+     * Add a argument to the parser. Don't include the '-' in the
+     * argName, that's added automatically. Assumes that the option
+     * expects no arguments.
+     * 
+     * @param argName the command line option
+     * @param desc a help line description.
+     */
+    public void add(String argName, String desc) {
+        add(argName, desc, 0);
+    }
+
+    /**
+     * Add a argument to the parser. Don't include the '-' in the
+     * argName, that's added automatically.
+     * 
+     * @param argName the command line option
+     * @param desc a help line description.
+     * @param expectedNumberOfArguments the number of option
+     *        parameters expected for this option.
+     */
+    public void add(String argName, String desc, int expectedNumberOfArguments) {
+        add(argName, desc, expectedNumberOfArguments, false);
+    }
+
+    /**
+     * Add a argument to the parser. Don't include the '-' in the
+     * argName, that's added automatically.
+     * 
+     * @param argName the command line option
+     * @param desc a help line description.
+     * @param expectedNumberOfArguments the number of option
+     *        parameters expected for this option.
+     * @param expectDashedArguments tell the parser that this option
+     *        may have arguments that may start with dashes, for
+     *        instance, a negative number. False by default.
+     */
+    public void add(String argName, String desc, int expectedNumberOfArguments,
+                    boolean expectDashedArguments) {
+        Arg newArg = new Arg(argName, desc, expectedNumberOfArguments, expectDashedArguments);
+        args.add(newArg);
+//        if (Debug.debugging(&quot;parse&quot;)) {
+        if (true) {
+            Vm.debug(&quot;ArgParser: adding &quot; + argName);
+        }
+    }
+
+    /**
+     * Parse and organize the array of Strings. If something goes
+     * wrong, bail() may be called.
+     * 
+     * @return true if everything goes well, false if not.
+     */
+    public boolean parse(String[] argv) {
+        try {
+            if (argv == null || argv.length == 0) {
+                return false;
+            }
+            for (int i = 0; i &lt; argv.length; i++) {
+                boolean hit = false;
+                if (argv[i].charAt(0) == option) {
+                    String eval = argv[i].substring(1);
+                    for (int j = 0; j &lt; args.size(); j++) {
+                        Arg curArg = (Arg) args.elementAt(j);
+                        if (curArg.is(eval, allowAbbr)) {
+//                            if (Debug.debugging(&quot;parse&quot;)) {
+                        	if (true) {
+                                Vm.debug(&quot;ArgParser: arg &quot; + curArg.name
+                                        + &quot; reading values.&quot;);
+                            }
+                            if (!curArg.readArgs(argv, ++i)) {
+                                // Something's wrong with the
+                                // arguments.
+                                bail(&quot;ArgParser: Unexpected arguments with option &quot;
+                                        + curArg.name + &quot;.&quot;,
+                                        true);
+                            }
+                            hit = true;
+                            if (curArg.numExpectedValues != TO_END) {
+                                i += (curArg.numExpectedValues - 1);
+                            } else {
+                                i = argv.length;
+                            }
+                        }
+                    }
+                    if (hit == false) {
+                        //option flagged, but option unknown.
+                        bail(programName + &quot;: unknown option &quot; + argv[i], false);
+                    }
+                }
+
+                if (hit == false) {
+                    if (i == 0) {
+                        rest = argv;
+                    } else {
+                        int diff = argv.length - i;
+                        rest = new String[diff];
+                        for (int k = 0; k &lt; diff; k++) {
+                            rest[k] = argv[i + k];
+                            if (rest[k].charAt(0) == option) {
+                                bail(&quot;ArgParser: Not expecting option in list of arguments.&quot;,
+                                        true);
+                            }
+                        }
+                    }
+//                    if (Debug.debugging(&quot;parse&quot;)) {
+                    if (true) {
+                        Vm.debug(&quot;ArgParser: adding &quot; + rest.length
+                                + &quot; strings to the leftover list.&quot;);
+                    }
+
+                    return true;
+                }
+            }
+        } catch (ArrayIndexOutOfBoundsException aioobe) {
+            bail(&quot;Expecting more arguments for option&quot;, true);
+//        } catch (NegativeArraySizeException nase) {
+//            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Called if something is messed up. Prints a message, and the
+     * usage statement, if desired.
+     * 
+     * @param message a message to display.
+     * @param printUsageStatement true to display a list of available
+     *        options.
+     */
+    public void bail(String message, boolean printUsageStatement) {
+        Vm.debug(message);
+        if (printUsageStatement)
+            printUsage();
+        System.exit(0);
+    }
+
+    /**
+     * Tell the parser to accept first-letter representations of the
+     * options.
+     */
+    public void setAllowAbbr(boolean set) {
+        allowAbbr = set;
+    }
+
+    /**
+     * Tells whether the parser accepts first-letter representations
+     * of the options.
+     */
+    public boolean getAllowAbbr() {
+        return allowAbbr;
+    }
+
+    /**
+     * Returns a Vector of Arg objects.
+     */
+    public Vector getArgs() {
+        return args;
+    }
+
+    /**
+     * Return a Arg object with a particular name.
+     */
+    public Arg getArg(String name) {
+        for (int i = 0; i &lt; args.size(); i++) {
+            ArgParser.Arg arg = (ArgParser.Arg) args.elementAt(i);
+            if (name.equalsIgnoreCase(arg.name)) {
+                return arg;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Given an Arg name, return the values. Returns a zero length
+     * array (non-null) value for options that don't require
+     * arguments. Returns null if the option name wasn't found in the
+     * list, or if the option wasn't chosen in the parsed array of
+     * Strings.
+     */
+    public String[] getArgValues(String name) {
+        for (int i = 0; i &lt; args.size(); i++) {
+            ArgParser.Arg arg = (ArgParser.Arg) args.elementAt(i);
+            if (name.equalsIgnoreCase(arg.name)) {
+                if (arg.flagged) {
+                    return arg.values;
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Get the String[] that makes up the trailing Strings after the
+     * options were parsed.
+     */
+    public String[] getRest() {
+        return rest;
+    }
+
+    /**
+     * Print a list of options added to the parser.
+     */
+    public void printUsage() {
+        Vm.debug(programName + &quot; Arguments:&quot;);
+        for (int i = 0; i &lt; args.size(); i++) {
+            ArgParser.Arg arg = (ArgParser.Arg) args.elementAt(i);
+            StringBuffer sb = new StringBuffer();
+            sb.append(&quot;  -&quot; + arg.name + &quot;  \t&quot; + arg.description);
+            if (arg.numExpectedValues == TO_END) {
+                sb.append(&quot; (Variable number of arguments expected)&quot;);
+            } else if (arg.numExpectedValues == 1) {
+                sb.append(&quot; (1 argument expected)&quot;);
+            } else {
+                sb.append(&quot; (&quot; + arg.numExpectedValues + &quot; arguments expected)&quot;);
+            }
+            Vm.debug(sb.toString());
+        }
+    }
+
+    public static void main(String[] argv) {
+//        Debug.init();
+        ArgParser ap = new ArgParser(&quot;ArgParser&quot;);
+        ap.add(&quot;first&quot;, &quot;First test argument, no parameters expected&quot;);
+        ap.add(&quot;second&quot;, &quot;Second test argument, two parameters expected&quot;, 2);
+        ap.add(&quot;third&quot;, &quot;Third test argument, no parameters expected&quot;);
+        ap.add(&quot;fourth&quot;, &quot;Fourth test argument, one parameter expected&quot;, 1);
+
+        if (!ap.parse(argv)) {
+            ap.printUsage();
+            System.exit(0);
+        }
+
+        int i;
+        Vector args = ap.getArgs();
+        for (i = 0; i &lt; args.size(); i++) {
+            ArgParser.Arg a = (ArgParser.Arg) args.elementAt(i);
+            Vm.debug(a.toString());
+        }
+
+        String[] rest = ap.getRest();
+        Vm.debug(&quot;Rest:&quot;);
+        for (i = 0; i &lt; rest.length; i++) {
+            Vm.debug(rest[i]);
+        }
+    }
+
+    /**
+     * A default version of the Arg class used to represent options
+     * for the ArgParser to use.
+     */
+    public class Arg {
+        public String name;
+        public String description;
+        public int numExpectedValues;
+        public String[] values = null;
+        public char c;
+        public boolean flagged = false;
+        public boolean dashedArguments = false;
+
+        /**
+         * Create an Arg with a name and help line description.
+         */
+        public Arg(String aName, String desc) {
+            this(aName, desc, 0);
+        }
+
+        /**
+         * Create an Arg with a name and help line description, along
+         * with a number of expected arguments to follow this option.
+         */
+        public Arg(String aName, String desc, int expectedNumberOfArguments) {
+            this(aName, desc, expectedNumberOfArguments, false);
+        }
+
+        /**
+         * Create an Arg with a name and help line description, along
+         * with a number of expected arguments to follow this option.
+         * Has an argument to not check for arguments that may start
+         * with dashes, in case one of the arguements may be a
+         * negative number.
+         */
+        public Arg(String aName, String desc, int expectedNumberOfArguments,
+                boolean expectDashedArguments) {
+            name = aName;
+            description = desc;
+            numExpectedValues = expectedNumberOfArguments;
+            c = name.charAt(0);
+            dashedArguments = expectDashedArguments;
+        }
+
+        /**
+         * Returns true if the atg string matches the name of the Arg,
+         * or, if allowAbbr is true, returns true if the arg length is
+         * one and it matches the first letter of the arg name.
+         */
+        public boolean is(String arg, boolean allowAbbr) {
+            if (name.equalsIgnoreCase(arg)) {
+                return true;
+            }
+
+            if (allowAbbr &amp;&amp; arg.length() == 1) {
+                if (arg.charAt(0) == c) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        /**
+         * Runs through the array of Strings, starting at the
+         * argIndex, and creates the values array from it. Uses the
+         * expected number of arguments to tell when it's done.
+         * Returns true if everything happens as expected.
+         * 
+         * @param argv the entire array passed to the parser.
+         * @param argIndex the index of the first option argument
+         *        value.
+         * @return true if what was read was what was expected.
+         */
+        public boolean readArgs(String[] argv, int argIndex)
+                throws ArrayIndexOutOfBoundsException
+//                ,NegativeArraySizeException 
+                {
+
+            if (numExpectedValues != TO_END) {
+                values = new String[numExpectedValues];
+            } else {
+                values = new String[argv.length - argIndex];
+            }
+
+            for (int i = 0; i &lt; values.length; i++) {
+                values[i] = argv[argIndex + i];
+                if (values[i].charAt(0) == option &amp;&amp; !dashedArguments) {
+                    if (numExpectedValues != TO_END) {
+                        Vm.debug(&quot;ArgParser: Option &quot;
+                                + name
+                                + &quot; expects &quot;
+                                + numExpectedValues
+                                + (numExpectedValues == 1 ? &quot; argument.&quot;
+                                        : &quot; arguments.&quot;));
+
+                    } else {
+                        Vm.debug(&quot;ArgParser: Option &quot; + name
+                                + &quot; not expecting options after its values.&quot;);
+                    }
+                    return false; // Unexpected argument.
+                }
+            }
+            flagged = true;
+            return true;
+        }
+
+        public String toString() {
+            StringBuffer sb = new StringBuffer();
+            sb.append(&quot;Arg: &quot; + name + &quot; expects &quot; + numExpectedValues
+                    + (numExpectedValues == 1 ? &quot; value.\n&quot; : &quot; values.\n&quot;));
+            if (values != null) {
+                sb.append(&quot;Values: &quot;);
+                for (int i = 0; i &lt; values.length; i++) {
+                    sb.append(&quot;[&quot; + values[i] + &quot;]&quot;);
+                }
+                sb.append(&quot;\n&quot;);
+            }
+            return sb.toString();
+        }
+    }
+
+    /**
+     * A Arg class to spur off help messages. Gets added automatically
+     * to the parser.
+     */
+    public class HelpArg extends ArgParser.Arg {
+
+        public HelpArg() {
+            super(&quot;help&quot;, &quot;Print usage statement, with arguments.&quot;, 0);
+        }
+
+        public boolean is(String arg, boolean allowAbbr) {
+            boolean askingForHelp = super.is(arg, allowAbbr);
+            if (askingForHelp) {
+                ArgParser.this.bail(&quot;&quot;, true);
+            }
+            return false;
+        }
+    }
+
+}

Added: experiments/EVE/lib/lib-folder/com/bbn/openmap/util/Assert.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/bbn/openmap/util/Assert.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/bbn/openmap/util/AssertionException.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/bbn/openmap/util/AssertionException.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/AmpersandRule.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/AmpersandRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/AmpersandRule.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/AmpersandRule.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/AmpersandRule.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,20 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** This implements the $&amp; element of the second argument to
+  * Regex.
+  * @see com.stevesoft.eve_pat.ReplaceRule
+  */
+public final class AmpersandRule extends ReplaceRule {
+    public AmpersandRule() {}
+    public void apply(StringBufferLike sb,RegRes res) {
+        sb.append(res.stringMatched());
+    }
+    public String toString1() { return &quot;$&amp;&quot;; }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Any.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Any.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Any.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Any.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Any.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,28 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Hashtable;
+
+/** This is the '.' character in a Pattern.  It
+ matches any character. */
+class Any extends Pattern {
+    public int matchInternal(int pos,Pthings pt) {
+        if(pos &lt; pt.src.length())
+            if(pt.dotDoesntMatchCR) {
+                if(pt.src.charAt(pos) != '\n')
+                    return nextMatch(pos+1,pt);
+            } else return nextMatch(pos+1,pt);
+        return -1;
+    }
+    public String toString() {
+        return &quot;.&quot;+nextString();
+    }
+    public patInt minChars() { return new patInt(1); }
+    public patInt maxChars() { return new patInt(1); }
+    public Pattern clone1(Hashtable h) { return new Any(); }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackG.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackG.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackG.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackG.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackG.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,26 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Hashtable;
+
+/** This class represents the \G pattern element. */
+class BackG extends Pattern {
+    char c,altc,altc2;
+    int mask;
+    public BackG() {
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        return pos==pt.lastPos ? nextMatch(pos,pt) : -1;
+    }
+    public String toString() {
+        return &quot;\\G&quot;+nextString();
+    }
+    public patInt minChars() { return new patInt(1); }
+    public patInt maxChars() { return new patInt(1); }
+    Pattern clone1(Hashtable h) { return new BackG(); }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackMatch.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackMatch.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackMatch.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackMatch.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackMatch.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,33 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Hashtable;
+
+/** Provides the ability to match a backreference from within
+  * a Pattern.
+  */
+class BackMatch extends Pattern {
+    int id;
+    BackMatch(int id) { this.id = id; }
+    public String toString() { return &quot;\\&quot;+(id)+nextString(); }
+    public int matchInternal(int pos,Pthings p) {
+        int i1 = p.marks[id];
+        int i2 = p.marks[id+p.nMarks];
+        int imax = i2-i1;
+        if(i1&lt;0||imax &lt; 0||pos+imax&gt;p.src.length()) return -1;
+        int ns = p.src.length()-pos;
+        if(imax &lt; ns) ns = imax;
+        for(int i=0;i&lt;ns;i++) {
+            if(p.src.charAt(i+i1) != p.src.charAt(pos+i))
+                return -1;
+        }
+        return nextMatch(pos+imax,p);
+    }
+    Pattern clone1(Hashtable h) { return new BackMatch(id); }
+}
+

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackRefRule.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackRefRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackRefRule.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackRefRule.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BackRefRule.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,23 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** This method implements the pattern elements $1, $2, etc in
+    a substitution rule. The apply(StringBufferLike sb,RegRes rr) method of this ReplaceRule
+    simply appends the contents of rr.stringMatched(n), where n is
+    the integer supplied to the constructor. */
+public class BackRefRule extends ReplaceRule {
+    int n;
+    public BackRefRule(int n) { this.n = n; }
+    public void apply(StringBufferLike sb,RegRes res) {
+        String x = res.stringMatched(n);
+        sb.append(x == null ? &quot;&quot; : x);
+    }
+    public String toString1() { return &quot;$&quot;+n; }
+    public Object clone1() { return new BackRefRule(n); }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Backup.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Backup.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Backup.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Backup.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Backup.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,27 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Hashtable;
+
+/** Implements the (?&lt;number) Pattern, where number is
+ an integer telling us how far to back up in the Pattern.
+ Not in perl 5. It also allows (?&gt;number). */
+class Backup extends Pattern {
+    int bk;
+    Backup(int ii) { bk = ii; }
+    public String toString() {
+        return &quot;(?&quot; + (bk &lt; 0 ? &quot;&gt;&quot; + (-bk) : &quot;&lt;&quot; + bk) + &quot;)&quot; + nextString();
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        if(pos &lt; bk) return -1;
+        return nextMatch(pos-bk,pt);
+    }
+    public patInt minChars() { return new patInt(-bk); }
+    public patInt maxChars() { return new patInt(-bk); }
+    public Pattern clone1(Hashtable h) { return new Backup(bk); }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BadRangeArgs.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BadRangeArgs.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BasicStringBufferLike.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BasicStringBufferLike.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BasicStringBufferLike.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BasicStringBufferLike.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BasicStringBufferLike.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,18 @@
+package//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+com.stevesoft.eve_pat;
+
+/** An abstraction of the StringBuffer which only
+    implements a subset of StringBuffer's methods.
+    */
+public interface BasicStringBufferLike {
+  public void append(char c);
+  public void append(String s);
+  public StringLike toStringLike();
+  public Object unwrap();
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BitSet.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BitSet.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BitSet.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BitSet.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/BitSet.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,744 @@
+/* BitSet.java -- A vector of bits.
+   Copyright (C) 1998, 1999, 2000, 2001, 2004  Free Software Foundation, Inc.
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+02111-1307 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+package com.stevesoft.eve_pat;
+
+/* Written using &quot;Java Class Libraries&quot;, 2nd edition, ISBN 0-201-31002-3
+ * hashCode algorithm taken from JDK 1.2 docs.
+ */
+
+/**
+ * This class can be thought of in two ways.  You can see it as a
+ * vector of bits or as a set of non-negative integers.  The name
+ * &lt;code&gt;BitSet&lt;/code&gt; is a bit misleading.
+ *
+ * It is implemented by a bit vector, but its equally possible to see
+ * it as set of non-negative integer; each integer in the set is
+ * represented by a set bit at the corresponding index.  The size of
+ * this structure is determined by the highest integer in the set.
+ *
+ * You can union, intersect and build (symmetric) remainders, by
+ * invoking the logical operations and, or, andNot, resp. xor.
+ *
+ * This implementation is NOT synchronized against concurrent access from
+ * multiple threads. Specifically, if one thread is reading from a bitset
+ * while another thread is simultaneously modifying it, the results are
+ * undefined.
+ *
+ * @author Jochen Hoenicke
+ * @author Tom Tromey &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">tromey at cygnus.com</A>&gt;
+ * @author Eric Blake &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">ebb9 at email.byu.edu</A>&gt;
+ * @status updated to 1.4
+ */
+public class BitSet implements Cloneable
+{
+  /**
+   * Compatible with JDK 1.0.
+   */
+  private static final long serialVersionUID = 7997698588986878753L;
+
+  /**
+   * A common mask.
+   */
+  private static final int LONG_MASK = 0x3f;
+
+  /**
+   * The actual bits.
+   * @serial the i'th bit is in bits[i/64] at position i%64 (where position
+   *         0 is the least significant).
+   */
+  private long[] bits;
+
+  /**
+   * Create a new empty bit set. All bits are initially false.
+   */
+  public BitSet()
+  {
+    this(64);
+  }
+
+  /**
+   * Create a new empty bit set, with a given size.  This
+   * constructor reserves enough space to represent the integers
+   * from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;nbits-1&lt;/code&gt;.
+   *
+   * @param nbits the initial size of the bit set
+   * @throws IllegalArgumentException if nbits &lt; 0
+   */
+  public BitSet(int nbits)
+  {
+    if (nbits &lt; 0)
+      throw new IllegalArgumentException();
+    
+    int length = nbits &gt;&gt;&gt; 6;
+    if ((nbits &amp; LONG_MASK) != 0)
+      ++length;
+    bits = new long[length];
+  }
+
+  /**
+   * Performs the logical AND operation on this bit set and the
+   * given &lt;code&gt;set&lt;/code&gt;.  This means it builds the intersection
+   * of the two sets.  The result is stored into this bit set.
+   *
+   * @param set the second bit set
+   * @throws NullPointerException if set is null
+   */
+  public void and(BitSet bs)
+  {
+    int max = Math.min(bits.length, bs.bits.length);
+    int i;
+    for (i = 0; i &lt; max; ++i)
+      bits[i] &amp;= bs.bits[i];
+    while (i &lt; bits.length)
+      bits[i++] = 0;
+  }
+
+  /**
+   * Performs the logical AND operation on this bit set and the
+   * complement of the given &lt;code&gt;set&lt;/code&gt;.  This means it
+   * selects every element in the first set, that isn't in the
+   * second set.  The result is stored into this bit set and is
+   * effectively the set difference of the two.
+   *
+   * @param set the second bit set
+   * @throws NullPointerException if set is null
+   * @since 1.2
+   */
+  public void andNot(BitSet bs)
+  {
+    int i = Math.min(bits.length, bs.bits.length);
+    while (--i &gt;= 0)
+      bits[i] &amp;= ~bs.bits[i];
+  }
+
+  /**
+   * Returns the number of bits set to true.
+   *
+   * @return the number of true bits
+   * @since 1.4
+   */
+  public int cardinality()
+  {
+    int card = 0;
+    for (int i = bits.length - 1; i &gt;= 0; i--)
+      {
+        long a = bits[i];
+        // Take care of common cases.
+        if (a == 0)
+          continue;
+        if (a == -1)
+          {
+            card += 64;
+            continue;
+          }
+
+        // Successively collapse alternating bit groups into a sum.
+        a = ((a &gt;&gt; 1) &amp; 0x5555555555555555L) + (a &amp; 0x5555555555555555L);
+        a = ((a &gt;&gt; 2) &amp; 0x3333333333333333L) + (a &amp; 0x3333333333333333L);
+        int b = (int) ((a &gt;&gt;&gt; 32) + a);
+        b = ((b &gt;&gt; 4) &amp; 0x0f0f0f0f) + (b &amp; 0x0f0f0f0f);
+        b = ((b &gt;&gt; 8) &amp; 0x00ff00ff) + (b &amp; 0x00ff00ff);
+        card += ((b &gt;&gt; 16) &amp; 0x0000ffff) + (b &amp; 0x0000ffff);
+      }
+    return card;
+  }
+
+  /**
+   * Sets all bits in the set to false.
+   *
+   * @since 1.4
+   */
+  /*
+  public void clear()
+  {
+    Arrays.fill(bits, 0);
+  }
+*/
+  /**
+   * Removes the integer &lt;code&gt;bitIndex&lt;/code&gt; from this set. That is
+   * the corresponding bit is cleared.  If the index is not in the set,
+   * this method does nothing.
+   *
+   * @param bitIndex a non-negative integer
+   * @throws IndexOutOfBoundsException if bitIndex &lt; 0
+   */
+  public void clear(int pos)
+  {
+    int offset = pos &gt;&gt; 6;
+    ensure(offset);
+    // ArrayIndexOutOfBoundsException subclasses IndexOutOfBoundsException,
+    // so we'll just let that be our exception.
+    bits[offset] &amp;= ~(1L &lt;&lt; pos);
+  }
+
+  /**
+   * Sets the bits between from (inclusive) and to (exclusive) to false.
+   *
+   * @param from the start range (inclusive)
+   * @param to the end range (exclusive)
+   * @throws IndexOutOfBoundsException if from &lt; 0 || to &lt; 0 ||
+   *         from &gt; to
+   * @since 1.4
+   */
+  public void clear(int from, int to)
+  {
+    if (from &lt; 0 || from &gt; to)
+      throw new IndexOutOfBoundsException();
+    if (from == to)
+      return;
+    int lo_offset = from &gt;&gt;&gt; 6;
+    int hi_offset = to &gt;&gt;&gt; 6;
+    ensure(hi_offset);
+    if (lo_offset == hi_offset)
+      {
+        bits[hi_offset] &amp;= ((1L &lt;&lt; from) - 1) | (-1L &lt;&lt; to);
+        return;
+      }
+
+    bits[lo_offset] &amp;= (1L &lt;&lt; from) - 1;
+    bits[hi_offset] &amp;= -1L &lt;&lt; to;
+    for (int i = lo_offset + 1; i &lt; hi_offset; i++)
+      bits[i] = 0;
+  }
+
+  /**
+   * Create a clone of this bit set, that is an instance of the same
+   * class and contains the same elements.  But it doesn't change when
+   * this bit set changes.
+   *
+   * @return the clone of this object.
+   */
+  public Object clone()
+  {
+    try
+      {
+        BitSet bs = (BitSet) super.clone();
+        bs.bits = (long[]) bits.clone();
+        return bs;
+      }
+    catch (CloneNotSupportedException e)
+      {
+        // Impossible to get here.
+        return null;
+      }
+  }
+
+  /**
+   * Returns true if the &lt;code&gt;obj&lt;/code&gt; is a bit set that contains
+   * exactly the same elements as this bit set, otherwise false.
+   *
+   * @param obj the object to compare to
+   * @return true if obj equals this bit set
+   */
+  public boolean equals(Object obj)
+  {
+    if (!(obj instanceof BitSet))
+      return false;
+    BitSet bs = (BitSet) obj;
+    int max = Math.min(bits.length, bs.bits.length);
+    int i;
+    for (i = 0; i &lt; max; ++i)
+      if (bits[i] != bs.bits[i])
+        return false;
+    // If one is larger, check to make sure all extra bits are 0.
+    for (int j = i; j &lt; bits.length; ++j)
+      if (bits[j] != 0)
+        return false;
+    for (int j = i; j &lt; bs.bits.length; ++j)
+      if (bs.bits[j] != 0)
+        return false;
+    return true;
+  }
+
+  /**
+   * Sets the bit at the index to the opposite value.
+   *
+   * @param index the index of the bit
+   * @throws IndexOutOfBoundsException if index is negative
+   * @since 1.4
+   */
+  public void flip(int index)
+  {
+    int offset = index &gt;&gt; 6;
+    ensure(offset);
+    // ArrayIndexOutOfBoundsException subclasses IndexOutOfBoundsException,
+    // so we'll just let that be our exception.
+    bits[offset] ^= 1L &lt;&lt; index;
+  }
+
+  /**
+   * Sets a range of bits to the opposite value.
+   *
+   * @param from the low index (inclusive)
+   * @param to the high index (exclusive)
+   * @throws IndexOutOfBoundsException if from &gt; to || from &lt; 0 ||
+   *         to &lt; 0
+   * @since 1.4
+   */
+  public void flip(int from, int to)
+  {
+    if (from &lt; 0 || from &gt; to)
+      throw new IndexOutOfBoundsException();
+    if (from == to)
+      return;
+    int lo_offset = from &gt;&gt;&gt; 6;
+    int hi_offset = to &gt;&gt;&gt; 6;
+    ensure(hi_offset);
+    if (lo_offset == hi_offset)
+      {
+        bits[hi_offset] ^= (-1L &lt;&lt; from) &amp; ((1L &lt;&lt; to) - 1);
+        return;
+      }
+
+    bits[lo_offset] ^= -1L &lt;&lt; from;
+    bits[hi_offset] ^= (1L &lt;&lt; to) - 1;
+    for (int i = lo_offset + 1; i &lt; hi_offset; i++)
+      bits[i] ^= -1;
+  }
+
+  /**
+   * Returns true if the integer &lt;code&gt;bitIndex&lt;/code&gt; is in this bit
+   * set, otherwise false.
+   *
+   * @param pos a non-negative integer
+   * @return the value of the bit at the specified index
+   * @throws IndexOutOfBoundsException if the index is negative
+   */
+  public boolean get(int pos)
+  {
+    int offset = pos &gt;&gt; 6;
+    if (offset &gt;= bits.length)
+      return false;
+    // ArrayIndexOutOfBoundsException subclasses IndexOutOfBoundsException,
+    // so we'll just let that be our exception.
+    return (bits[offset] &amp; (1L &lt;&lt; pos)) != 0;
+  }
+
+  /**
+   * Returns a new &lt;code&gt;BitSet&lt;/code&gt; composed of a range of bits from
+   * this one.
+   *
+   * @param from the low index (inclusive)
+   * @param to the high index (exclusive)
+   * @throws IndexOutOfBoundsException if from &gt; to || from &lt; 0 ||
+   *         to &lt; 0
+   * @since 1.4
+   */
+  public BitSet get(int from, int to)
+  {
+    if (from &lt; 0 || from &gt; to)
+      throw new IndexOutOfBoundsException();
+    BitSet bs = new BitSet(to - from);
+    int lo_offset = from &gt;&gt;&gt; 6;
+    if (lo_offset &gt;= bits.length)
+      return bs;
+
+    int lo_bit = from &amp; LONG_MASK;
+    int hi_offset = to &gt;&gt;&gt; 6;
+    if (lo_bit == 0)
+      {
+        int len = Math.min(hi_offset - lo_offset + 1, bits.length - lo_offset);
+        System.arraycopy(bits, lo_offset, bs.bits, 0, len);
+        if (hi_offset &lt; bits.length)
+          bs.bits[hi_offset - lo_offset] &amp;= (1L &lt;&lt; to) - 1;
+        return bs;
+      }
+
+    int len = Math.min(hi_offset, bits.length - 1);
+    int reverse = ~lo_bit;
+    int i;
+    for (i = 0; lo_offset &lt; len; lo_offset++, i++)
+      bs.bits[i] = ((bits[lo_offset] &gt;&gt;&gt; lo_bit)
+                    | (bits[lo_offset + 1] &lt;&lt; reverse));
+    if ((to &amp; LONG_MASK) &gt; lo_bit)
+      bs.bits[i++] = bits[lo_offset] &gt;&gt;&gt; lo_bit;
+    if (hi_offset &lt; bits.length)
+      bs.bits[i - 1] &amp;= (1L &lt;&lt; (to - from)) - 1;
+    return bs;
+  }
+
+  /**
+   * Returns a hash code value for this bit set.  The hash code of
+   * two bit sets containing the same integers is identical.  The algorithm
+   * used to compute it is as follows:
+   *
+   * Suppose the bits in the BitSet were to be stored in an array of
+   * long integers called &lt;code&gt;bits&lt;/code&gt;, in such a manner that
+   * bit &lt;code&gt;k&lt;/code&gt; is set in the BitSet (for non-negative values
+   * of &lt;code&gt;k&lt;/code&gt;) if and only if
+   *
+   * &lt;code&gt;((k/64) &lt; bits.length)
+   * &amp;&amp; ((bits[k/64] &amp; (1L &lt;&lt; (bit % 64))) != 0)
+   * &lt;/code&gt;
+   *
+   * Then the following definition of the hashCode method
+   * would be a correct implementation of the actual algorithm:
+   *
+   * 
+&lt;pre&gt;public int hashCode()
+{
+  long h = 1234;
+  for (int i = bits.length-1; i &gt;= 0; i--)
+  {
+    h ^= bits[i] * (i + 1);
+  }
+
+  return (int)((h &gt;&gt; 32) ^ h);
+}&lt;/pre&gt;
+   *
+   * Note that the hash code values changes, if the set is changed.
+   *
+   * @return the hash code value for this bit set.
+   */
+  public int hashCode()
+  {
+    long h = 1234;
+    for (int i = bits.length; i &gt; 0; )
+      h ^= i * bits[--i];
+    return (int) ((h &gt;&gt; 32) ^ h);
+  }
+
+  /**
+   * Returns true if the specified BitSet and this one share at least one
+   * common true bit.
+   *
+   * @param set the set to check for intersection
+   * @return true if the sets intersect
+   * @throws NullPointerException if set is null
+   * @since 1.4
+   */
+  public boolean intersects(BitSet set)
+  {
+    int i = Math.min(bits.length, set.bits.length);
+    while (--i &gt;= 0)
+      if ((bits[i] &amp; set.bits[i]) != 0)
+        return true;
+    return false;
+  }
+
+  /**
+   * Returns true if this set contains no true bits.
+   *
+   * @return true if all bits are false
+   * @since 1.4
+   */
+  public boolean isEmpty()
+  {
+    for (int i = bits.length - 1; i &gt;= 0; i--)
+      if (bits[i] != 0)
+        return false;
+    return true;
+  }
+
+  /**
+   * Returns the logical number of bits actually used by this bit
+   * set.  It returns the index of the highest set bit plus one.
+   * Note that this method doesn't return the number of set bits.
+   *
+   * @return the index of the highest set bit plus one.
+   */
+  public int length()
+  {
+    // Set i to highest index that contains a non-zero value.
+    int i;
+    for (i = bits.length - 1; i &gt;= 0 &amp;&amp; bits[i] == 0; --i)
+      ;
+
+    // if i &lt; 0 all bits are cleared.
+    if (i &lt; 0)
+      return 0;
+
+    // Now determine the exact length.
+    long b = bits[i];
+    int len = (i + 1) * 64;
+    // b &gt;= 0 checks if the highest bit is zero.
+    while (b &gt;= 0)
+      {
+        --len;
+        b &lt;&lt;= 1;
+      }
+
+    return len;
+  }
+
+  /**
+   * Returns the index of the next false bit, from the specified bit
+   * (inclusive).
+   *
+   * @param from the start location
+   * @return the first false bit
+   * @throws IndexOutOfBoundsException if from is negative
+   * @since 1.4
+   */
+  public int nextClearBit(int from)
+  {
+    int offset = from &gt;&gt; 6;
+    long mask = 1L &lt;&lt; from;
+    while (offset &lt; bits.length)
+      {
+        // ArrayIndexOutOfBoundsException subclasses IndexOutOfBoundsException,
+        // so we'll just let that be our exception.
+        long h = bits[offset];
+        do
+          {
+            if ((h &amp; mask) == 0)
+              return from;
+            mask &lt;&lt;= 1;
+            from++;
+          }
+        while (mask != 0);
+        mask = 1;
+        offset++;
+      }
+    return from;
+  }
+
+  /**
+   * Returns the index of the next true bit, from the specified bit
+   * (inclusive). If there is none, -1 is returned. You can iterate over
+   * all true bits with this loop:&lt;br&gt;
+   * 
+&lt;pre&gt;for (int i = bs.nextSetBit(0); i &gt;= 0; i = bs.nextSetBit(i + 1))
+{
+  // operate on i here
+}&lt;/pre&gt;
+   *
+   * @param from the start location
+   * @return the first true bit, or -1
+   * @throws IndexOutOfBoundsException if from is negative
+   * @since 1.4
+   */
+  public int nextSetBit(int from)
+  {
+    int offset = from &gt;&gt; 6;
+    long mask = 1L &lt;&lt; from;
+    while (offset &lt; bits.length)
+      {
+        // ArrayIndexOutOfBoundsException subclasses IndexOutOfBoundsException,
+        // so we'll just let that be our exception.
+        long h = bits[offset];
+        do
+          {
+            if ((h &amp; mask) != 0)
+              return from;
+            mask &lt;&lt;= 1;
+            from++;
+          }
+        while (mask != 0);
+        mask = 1;
+        offset++;
+      }
+    return -1;
+  }
+
+  /**
+   * Performs the logical OR operation on this bit set and the
+   * given &lt;code&gt;set&lt;/code&gt;.  This means it builds the union
+   * of the two sets.  The result is stored into this bit set, which
+   * grows as necessary.
+   *
+   * @param bs the second bit set
+   * @throws NullPointerException if bs is null
+   */
+  public void or(BitSet bs)
+  {
+    ensure(bs.bits.length - 1);
+    for (int i = bs.bits.length - 1; i &gt;= 0; i--)
+      bits[i] |= bs.bits[i];
+  }
+
+  /**
+   * Add the integer &lt;code&gt;bitIndex&lt;/code&gt; to this set.  That is
+   * the corresponding bit is set to true.  If the index was already in
+   * the set, this method does nothing.  The size of this structure
+   * is automatically increased as necessary.
+   *
+   * @param pos a non-negative integer.
+   * @throws IndexOutOfBoundsException if pos is negative
+   */
+  public void set(int pos)
+  {
+    int offset = pos &gt;&gt; 6;
+    ensure(offset);
+    // ArrayIndexOutOfBoundsException subclasses IndexOutOfBoundsException,
+    // so we'll just let that be our exception.
+    bits[offset] |= 1L &lt;&lt; pos;
+  }
+
+  /**
+   * Sets the bit at the given index to the specified value. The size of
+   * this structure is automatically increased as necessary.
+   *
+   * @param index the position to set
+   * @param value the value to set it to
+   * @throws IndexOutOfBoundsException if index is negative
+   * @since 1.4
+   */
+  public void set(int index, boolean value)
+  {
+    if (value)
+      set(index);
+    else
+      clear(index);
+  }
+
+  /**
+   * Sets the bits between from (inclusive) and to (exclusive) to true.
+   *
+   * @param from the start range (inclusive)
+   * @param to the end range (exclusive)
+   * @throws IndexOutOfBoundsException if from &lt; 0 || from &gt; to ||
+   *         to &lt; 0
+   * @since 1.4
+   */
+  public void set(int from, int to)
+  {
+    if (from &lt; 0 || from &gt; to)
+      throw new IndexOutOfBoundsException();
+    if (from == to)
+      return;
+    int lo_offset = from &gt;&gt;&gt; 6;
+    int hi_offset = to &gt;&gt;&gt; 6;
+    ensure(hi_offset);
+    if (lo_offset == hi_offset)
+      {
+        bits[hi_offset] |= (-1L &lt;&lt; from) &amp; ((1L &lt;&lt; to) - 1);
+        return;
+      }
+
+    bits[lo_offset] |= -1L &lt;&lt; from;
+    bits[hi_offset] |= (1L &lt;&lt; to) - 1;
+    for (int i = lo_offset + 1; i &lt; hi_offset; i++)
+      bits[i] = -1;
+  }
+
+  /**
+   * Sets the bits between from (inclusive) and to (exclusive) to the
+   * specified value.
+   *
+   * @param from the start range (inclusive)
+   * @param to the end range (exclusive)
+   * @param value the value to set it to
+   * @throws IndexOutOfBoundsException if from &lt; 0 || from &gt; to ||
+   *         to &lt; 0
+   * @since 1.4
+   */
+  public void set(int from, int to, boolean value)
+  {
+    if (value)
+      set(from, to);
+    else
+      clear(from, to);
+  }
+
+  /**
+   * Returns the number of bits actually used by this bit set.  Note
+   * that this method doesn't return the number of set bits, and that
+   * future requests for larger bits will make this automatically grow.
+   *
+   * @return the number of bits currently used.
+   */
+  public int size()
+  {
+    return bits.length * 64;
+  }
+
+  /**
+   * Returns the string representation of this bit set.  This
+   * consists of a comma separated list of the integers in this set
+   * surrounded by curly braces.  There is a space after each comma.
+   * A sample string is thus &quot;{1, 3, 53}&quot;.
+   * @return the string representation.
+   */
+  public String toString()
+  {
+    StringBuffer r = new StringBuffer(&quot;{&quot;);
+    boolean first = true;
+    for (int i = 0; i &lt; bits.length; ++i)
+      {
+        long bit = 1;
+        long word = bits[i];
+        if (word == 0)
+          continue;
+        for (int j = 0; j &lt; 64; ++j)
+          {
+            if ((word &amp; bit) != 0)
+              {
+                if (! first)
+                  r.append(&quot;, &quot;);
+                r.append(64 * i + j);
+                first = false;
+              }
+            bit &lt;&lt;= 1;
+          }
+      }
+    return r.append(&quot;}&quot;).toString();
+  }
+
+  /**
+   * Performs the logical XOR operation on this bit set and the
+   * given &lt;code&gt;set&lt;/code&gt;.  This means it builds the symmetric
+   * remainder of the two sets (the elements that are in one set,
+   * but not in the other).  The result is stored into this bit set,
+   * which grows as necessary.
+   *
+   * @param bs the second bit set
+   * @throws NullPointerException if bs is null
+   */
+  public void xor(BitSet bs)
+  {
+    ensure(bs.bits.length - 1);
+    for (int i = bs.bits.length - 1; i &gt;= 0; i--)
+      bits[i] ^= bs.bits[i];
+  }
+
+  /**
+   * Make sure the vector is big enough.
+   *
+   * @param lastElt the size needed for the bits array
+   */
+  private void ensure(int lastElt)
+  {
+    if (lastElt &gt;= bits.length)
+      {
+        long[] nd = new long[lastElt + 1];
+        System.arraycopy(bits, 0, nd, 0, bits.length);
+        bits = nd;
+      }
+  }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Bits.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Bits.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Bits.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Bits.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Bits.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,3071 @@
+package//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+com.stevesoft.eve_pat;
+
+
+public class Bits {
+  char[] carray;
+  Bits(char[] carray) {
+    this.carray = carray;
+  }
+  public boolean get(int i) {
+    return ((carray[i&gt;&gt;4]) &amp; (1&lt;&lt;(i&amp;15))) != 0;
+  }
+  public void set(int i,boolean b) {
+    if(b) {
+      carray[i&gt;&gt;4] |= (char) 1&lt;&lt;(i&amp;15);
+    } else {
+      carray[i&gt;&gt;4] &amp;= (char)~(1&lt;&lt;(i&amp;15));
+    }
+  }
+
+  /*
+  public static String n4(char c) {
+    String s = Integer.toHexString(c);
+    while(s.length()&lt;4)
+      s = &quot;0&quot;+s;
+    return s;
+  }
+  static abstract class Tester {
+    abstract boolean test(char c);
+  }
+  public static void main(String[] args) throws Exception {
+    //pw_s.println(&quot;  static {&quot;);
+    FileWriter fw = new FileWriter(&quot;x.out&quot;);
+    fw.close();
+    test(&quot;upper&quot;,new Tester() {
+      boolean test(char c) {
+        return Character.isUpperCase(c);
+      }
+    });
+    test(&quot;lower&quot;,new Tester() {
+      boolean test(char c) {
+        return Character.isLowerCase(c);
+      }
+    });
+    test(&quot;title&quot;,new Tester() {
+      boolean test(char c) {
+        return Character.isLowerCase(c);
+      }
+    });
+    test(&quot;currency&quot;,new Tester() {
+      boolean test(char c) {
+        return Character.getType(c)==Character.CURRENCY_SYMBOL;
+      }
+    });
+    test(&quot;decimal_digit&quot;,new Tester() {
+      boolean test(char c) {
+        return Character.getType(c)==Character.DECIMAL_DIGIT_NUMBER;
+      }
+    });
+    test(&quot;math&quot;,new Tester() {
+      boolean test(char c) {
+        return Character.getType(c)==Character.MATH_SYMBOL;
+      }
+    });
+    test(&quot;letter&quot;,new Tester() {
+      boolean test(char c) {
+        return Character.isLetter(c);
+      }
+    });
+    test(&quot;white&quot;,new Tester() {
+      boolean test(char c) {
+        return Character.isWhitespace(c);
+      }
+    });
+    test(&quot;punct&quot;,new Tester() {
+      boolean test(char c) {
+	boolean r = false;
+        switch(Character.getType(c)) {
+        case Character.DASH_PUNCTUATION:
+        case Character.START_PUNCTUATION:
+        case Character.END_PUNCTUATION:
+        case Character.CONNECTOR_PUNCTUATION:
+        case Character.OTHER_PUNCTUATION:
+	  r = true;
+	  break;
+	default:
+	  r = false;
+	  break;
+	}
+	return r;
+      }
+    });
+    //pw_s.println(&quot;  }&quot;);
+    fw = new FileWriter(&quot;x.out&quot;,true);
+    fw.write(sw.toString());
+    fw.close();
+  }
+  static StringWriter sw = new StringWriter();
+  static PrintWriter pw_s = new PrintWriter(sw,true);
+  public static void test(String var,Tester t) throws Exception {
+
+    char[] ca = new char[(66536 &gt;&gt; 4)+1];
+    Bits b = new Bits(ca);
+    FileWriter fw = new FileWriter(&quot;x.out&quot;,true);
+    PrintWriter pw = new PrintWriter(fw);
+
+    //pw_s.println(&quot;    &quot;+var+&quot;_f();&quot;);
+    pw.println(&quot;  public static Bits &quot;+var+&quot;;&quot;);
+    pw.println(&quot;  static void &quot;+var+&quot;_f() {&quot;);
+    pw.println(&quot;    char[] data = new char[&quot;+ca.length+&quot;];&quot;);
+    pw.println(&quot;    &quot;+var+&quot; = new Bits(data);&quot;);
+    for(int i=0;i&lt;66536;i++) {
+      char c = (char)i;
+      //b.set(i,Character.getType(c)==Character.CURRENCY_SYMBOL);
+      b.set(i,t.test(c));
+    }
+    for(int i=0;i&lt;ca.length;i++) {
+      if(ca[i] != 0) {
+        pw.println(&quot;    data[&quot;+i+&quot;]=(char)0x&quot;+n4(ca[i])+&quot;;&quot;);
+      }
+    }
+    pw.println();
+    pw.println(&quot;  }&quot;);
+
+    pw.close();
+  }
+  */
+  public static Bits upper;
+  static void upper_f() {
+    char[] data = new char[4159];
+    upper = new Bits(data);
+    data[4]=(char)0xfffe;
+    data[5]=(char)0x07ff;
+    data[12]=(char)0xffff;
+    data[13]=(char)0x7f7f;
+    data[16]=(char)0x5555;
+    data[17]=(char)0x5555;
+    data[18]=(char)0x5555;
+    data[19]=(char)0xaa55;
+    data[20]=(char)0x54aa;
+    data[21]=(char)0x5555;
+    data[22]=(char)0x5555;
+    data[23]=(char)0x2b55;
+    data[24]=(char)0xced6;
+    data[25]=(char)0xb1db;
+    data[26]=(char)0xd2d5;
+    data[27]=(char)0x11ae;
+    data[28]=(char)0xa490;
+    data[29]=(char)0x4aaa;
+    data[30]=(char)0x5555;
+    data[31]=(char)0x5412;
+    data[32]=(char)0x5555;
+    data[33]=(char)0x0055;
+    data[56]=(char)0xd740;
+    data[57]=(char)0xfffe;
+    data[58]=(char)0x0ffb;
+    data[61]=(char)0x541c;
+    data[62]=(char)0x5555;
+    data[64]=(char)0xdffe;
+    data[65]=(char)0xffff;
+    data[66]=(char)0xffff;
+    data[70]=(char)0x5555;
+    data[71]=(char)0x5555;
+    data[72]=(char)0x0001;
+    data[73]=(char)0x5555;
+    data[74]=(char)0x5555;
+    data[75]=(char)0x5555;
+    data[76]=(char)0x088a;
+    data[77]=(char)0x5555;
+    data[78]=(char)0x4555;
+    data[79]=(char)0x0115;
+    data[83]=(char)0xfffe;
+    data[84]=(char)0xffff;
+    data[85]=(char)0x007f;
+    data[266]=(char)0xffff;
+    data[267]=(char)0xffff;
+    data[268]=(char)0x003f;
+    data[480]=(char)0x5555;
+    data[481]=(char)0x5555;
+    data[482]=(char)0x5555;
+    data[483]=(char)0x5555;
+    data[484]=(char)0x5555;
+    data[485]=(char)0x5555;
+    data[486]=(char)0x5555;
+    data[487]=(char)0x5555;
+    data[488]=(char)0x5555;
+    data[489]=(char)0x0015;
+    data[490]=(char)0x5555;
+    data[491]=(char)0x5555;
+    data[492]=(char)0x5555;
+    data[493]=(char)0x5555;
+    data[494]=(char)0x5555;
+    data[495]=(char)0x0155;
+    data[496]=(char)0xff00;
+    data[497]=(char)0x3f00;
+    data[498]=(char)0xff00;
+    data[499]=(char)0xff00;
+    data[500]=(char)0x3f00;
+    data[501]=(char)0xaa00;
+    data[502]=(char)0xff00;
+    data[504]=(char)0xff00;
+    data[505]=(char)0xff00;
+    data[506]=(char)0xff00;
+    data[507]=(char)0x5f00;
+    data[508]=(char)0x1f00;
+    data[509]=(char)0x0f00;
+    data[510]=(char)0x1f00;
+    data[511]=(char)0x1f00;
+    data[528]=(char)0x3884;
+    data[529]=(char)0x3f27;
+    data[530]=(char)0x3d50;
+    data[531]=(char)0x000b;
+    data[4082]=(char)0xfffe;
+    data[4083]=(char)0x07ff;
+    data[4100]=(char)0xfffe;
+    data[4101]=(char)0x07ff;
+    data[4108]=(char)0xffff;
+    data[4109]=(char)0x7f7f;
+    data[4112]=(char)0x5555;
+    data[4113]=(char)0x5555;
+    data[4114]=(char)0x5555;
+    data[4115]=(char)0xaa55;
+    data[4116]=(char)0x54aa;
+    data[4117]=(char)0x5555;
+    data[4118]=(char)0x5555;
+    data[4119]=(char)0x2b55;
+    data[4120]=(char)0xced6;
+    data[4121]=(char)0xb1db;
+    data[4122]=(char)0xd2d5;
+    data[4123]=(char)0x11ae;
+    data[4124]=(char)0xa490;
+    data[4125]=(char)0x4aaa;
+    data[4126]=(char)0x5555;
+    data[4127]=(char)0x5412;
+    data[4128]=(char)0x5555;
+    data[4129]=(char)0x0055;
+    data[4152]=(char)0xd740;
+    data[4153]=(char)0xfffe;
+    data[4154]=(char)0x0ffb;
+    data[4157]=(char)0x541c;
+    data[4158]=(char)0x0055;
+
+  }
+  public static Bits lower;
+  static void lower_f() {
+    char[] data = new char[4159];
+    lower = new Bits(data);
+    data[6]=(char)0xfffe;
+    data[7]=(char)0x07ff;
+    data[10]=(char)0x0400;
+    data[11]=(char)0x0420;
+    data[13]=(char)0x8000;
+    data[14]=(char)0xffff;
+    data[15]=(char)0xff7f;
+    data[16]=(char)0xaaaa;
+    data[17]=(char)0xaaaa;
+    data[18]=(char)0xaaaa;
+    data[19]=(char)0x55aa;
+    data[20]=(char)0xab55;
+    data[21]=(char)0xaaaa;
+    data[22]=(char)0xaaaa;
+    data[23]=(char)0xd4aa;
+    data[24]=(char)0x3129;
+    data[25]=(char)0x4e24;
+    data[26]=(char)0x292a;
+    data[27]=(char)0x2651;
+    data[28]=(char)0x5240;
+    data[29]=(char)0xb555;
+    data[30]=(char)0xaaaa;
+    data[31]=(char)0xa829;
+    data[32]=(char)0xaaaa;
+    data[33]=(char)0x00aa;
+    data[37]=(char)0xffff;
+    data[38]=(char)0xffff;
+    data[39]=(char)0xffff;
+    data[40]=(char)0xffff;
+    data[41]=(char)0xffff;
+    data[42]=(char)0x01ff;
+    data[57]=(char)0x0001;
+    data[58]=(char)0xf000;
+    data[59]=(char)0xffff;
+    data[60]=(char)0x7fff;
+    data[61]=(char)0x0063;
+    data[62]=(char)0xaaa8;
+    data[63]=(char)0x0007;
+    data[67]=(char)0xffff;
+    data[68]=(char)0xffff;
+    data[69]=(char)0xdffe;
+    data[70]=(char)0xaaaa;
+    data[71]=(char)0xaaaa;
+    data[72]=(char)0x0002;
+    data[73]=(char)0xaaaa;
+    data[74]=(char)0xaaaa;
+    data[75]=(char)0xaaaa;
+    data[76]=(char)0x1114;
+    data[77]=(char)0xaaaa;
+    data[78]=(char)0x8aaa;
+    data[79]=(char)0x022a;
+    data[86]=(char)0xfffe;
+    data[87]=(char)0xffff;
+    data[88]=(char)0x00ff;
+    data[269]=(char)0xffff;
+    data[270]=(char)0xffff;
+    data[271]=(char)0x007f;
+    data[480]=(char)0xaaaa;
+    data[481]=(char)0xaaaa;
+    data[482]=(char)0xaaaa;
+    data[483]=(char)0xaaaa;
+    data[484]=(char)0xaaaa;
+    data[485]=(char)0xaaaa;
+    data[486]=(char)0xaaaa;
+    data[487]=(char)0xaaaa;
+    data[488]=(char)0xaaaa;
+    data[489]=(char)0x0fea;
+    data[490]=(char)0xaaaa;
+    data[491]=(char)0xaaaa;
+    data[492]=(char)0xaaaa;
+    data[493]=(char)0xaaaa;
+    data[494]=(char)0xaaaa;
+    data[495]=(char)0x02aa;
+    data[496]=(char)0x00ff;
+    data[497]=(char)0x003f;
+    data[498]=(char)0x00ff;
+    data[499]=(char)0x00ff;
+    data[500]=(char)0x003f;
+    data[501]=(char)0x00ff;
+    data[502]=(char)0x00ff;
+    data[503]=(char)0x3fff;
+    data[504]=(char)0x00ff;
+    data[505]=(char)0x00ff;
+    data[506]=(char)0x00ff;
+    data[507]=(char)0x00df;
+    data[508]=(char)0x00dc;
+    data[509]=(char)0x00cf;
+    data[510]=(char)0x00ff;
+    data[511]=(char)0x00dc;
+    data[519]=(char)0x8000;
+    data[528]=(char)0xc400;
+    data[529]=(char)0x0008;
+    data[530]=(char)0xc000;
+    data[531]=(char)0x0010;
+    data[4016]=(char)0x007f;
+    data[4017]=(char)0x00f8;
+    data[4084]=(char)0xfffe;
+    data[4085]=(char)0x07ff;
+    data[4102]=(char)0xfffe;
+    data[4103]=(char)0x07ff;
+    data[4106]=(char)0x0400;
+    data[4107]=(char)0x0420;
+    data[4109]=(char)0x8000;
+    data[4110]=(char)0xffff;
+    data[4111]=(char)0xff7f;
+    data[4112]=(char)0xaaaa;
+    data[4113]=(char)0xaaaa;
+    data[4114]=(char)0xaaaa;
+    data[4115]=(char)0x55aa;
+    data[4116]=(char)0xab55;
+    data[4117]=(char)0xaaaa;
+    data[4118]=(char)0xaaaa;
+    data[4119]=(char)0xd4aa;
+    data[4120]=(char)0x3129;
+    data[4121]=(char)0x4e24;
+    data[4122]=(char)0x292a;
+    data[4123]=(char)0x2651;
+    data[4124]=(char)0x5240;
+    data[4125]=(char)0xb555;
+    data[4126]=(char)0xaaaa;
+    data[4127]=(char)0xa829;
+    data[4128]=(char)0xaaaa;
+    data[4129]=(char)0x00aa;
+    data[4133]=(char)0xffff;
+    data[4134]=(char)0xffff;
+    data[4135]=(char)0xffff;
+    data[4136]=(char)0xffff;
+    data[4137]=(char)0xffff;
+    data[4138]=(char)0x01ff;
+    data[4153]=(char)0x0001;
+    data[4154]=(char)0xf000;
+    data[4155]=(char)0xffff;
+    data[4156]=(char)0x7fff;
+    data[4157]=(char)0x0063;
+    data[4158]=(char)0x00a8;
+
+  }
+  public static Bits title;
+  static void title_f() {
+    char[] data = new char[4159];
+    title = new Bits(data);
+    data[6]=(char)0xfffe;
+    data[7]=(char)0x07ff;
+    data[10]=(char)0x0400;
+    data[11]=(char)0x0420;
+    data[13]=(char)0x8000;
+    data[14]=(char)0xffff;
+    data[15]=(char)0xff7f;
+    data[16]=(char)0xaaaa;
+    data[17]=(char)0xaaaa;
+    data[18]=(char)0xaaaa;
+    data[19]=(char)0x55aa;
+    data[20]=(char)0xab55;
+    data[21]=(char)0xaaaa;
+    data[22]=(char)0xaaaa;
+    data[23]=(char)0xd4aa;
+    data[24]=(char)0x3129;
+    data[25]=(char)0x4e24;
+    data[26]=(char)0x292a;
+    data[27]=(char)0x2651;
+    data[28]=(char)0x5240;
+    data[29]=(char)0xb555;
+    data[30]=(char)0xaaaa;
+    data[31]=(char)0xa829;
+    data[32]=(char)0xaaaa;
+    data[33]=(char)0x00aa;
+    data[37]=(char)0xffff;
+    data[38]=(char)0xffff;
+    data[39]=(char)0xffff;
+    data[40]=(char)0xffff;
+    data[41]=(char)0xffff;
+    data[42]=(char)0x01ff;
+    data[57]=(char)0x0001;
+    data[58]=(char)0xf000;
+    data[59]=(char)0xffff;
+    data[60]=(char)0x7fff;
+    data[61]=(char)0x0063;
+    data[62]=(char)0xaaa8;
+    data[63]=(char)0x0007;
+    data[67]=(char)0xffff;
+    data[68]=(char)0xffff;
+    data[69]=(char)0xdffe;
+    data[70]=(char)0xaaaa;
+    data[71]=(char)0xaaaa;
+    data[72]=(char)0x0002;
+    data[73]=(char)0xaaaa;
+    data[74]=(char)0xaaaa;
+    data[75]=(char)0xaaaa;
+    data[76]=(char)0x1114;
+    data[77]=(char)0xaaaa;
+    data[78]=(char)0x8aaa;
+    data[79]=(char)0x022a;
+    data[86]=(char)0xfffe;
+    data[87]=(char)0xffff;
+    data[88]=(char)0x00ff;
+    data[269]=(char)0xffff;
+    data[270]=(char)0xffff;
+    data[271]=(char)0x007f;
+    data[480]=(char)0xaaaa;
+    data[481]=(char)0xaaaa;
+    data[482]=(char)0xaaaa;
+    data[483]=(char)0xaaaa;
+    data[484]=(char)0xaaaa;
+    data[485]=(char)0xaaaa;
+    data[486]=(char)0xaaaa;
+    data[487]=(char)0xaaaa;
+    data[488]=(char)0xaaaa;
+    data[489]=(char)0x0fea;
+    data[490]=(char)0xaaaa;
+    data[491]=(char)0xaaaa;
+    data[492]=(char)0xaaaa;
+    data[493]=(char)0xaaaa;
+    data[494]=(char)0xaaaa;
+    data[495]=(char)0x02aa;
+    data[496]=(char)0x00ff;
+    data[497]=(char)0x003f;
+    data[498]=(char)0x00ff;
+    data[499]=(char)0x00ff;
+    data[500]=(char)0x003f;
+    data[501]=(char)0x00ff;
+    data[502]=(char)0x00ff;
+    data[503]=(char)0x3fff;
+    data[504]=(char)0x00ff;
+    data[505]=(char)0x00ff;
+    data[506]=(char)0x00ff;
+    data[507]=(char)0x00df;
+    data[508]=(char)0x00dc;
+    data[509]=(char)0x00cf;
+    data[510]=(char)0x00ff;
+    data[511]=(char)0x00dc;
+    data[519]=(char)0x8000;
+    data[528]=(char)0xc400;
+    data[529]=(char)0x0008;
+    data[530]=(char)0xc000;
+    data[531]=(char)0x0010;
+    data[4016]=(char)0x007f;
+    data[4017]=(char)0x00f8;
+    data[4084]=(char)0xfffe;
+    data[4085]=(char)0x07ff;
+    data[4102]=(char)0xfffe;
+    data[4103]=(char)0x07ff;
+    data[4106]=(char)0x0400;
+    data[4107]=(char)0x0420;
+    data[4109]=(char)0x8000;
+    data[4110]=(char)0xffff;
+    data[4111]=(char)0xff7f;
+    data[4112]=(char)0xaaaa;
+    data[4113]=(char)0xaaaa;
+    data[4114]=(char)0xaaaa;
+    data[4115]=(char)0x55aa;
+    data[4116]=(char)0xab55;
+    data[4117]=(char)0xaaaa;
+    data[4118]=(char)0xaaaa;
+    data[4119]=(char)0xd4aa;
+    data[4120]=(char)0x3129;
+    data[4121]=(char)0x4e24;
+    data[4122]=(char)0x292a;
+    data[4123]=(char)0x2651;
+    data[4124]=(char)0x5240;
+    data[4125]=(char)0xb555;
+    data[4126]=(char)0xaaaa;
+    data[4127]=(char)0xa829;
+    data[4128]=(char)0xaaaa;
+    data[4129]=(char)0x00aa;
+    data[4133]=(char)0xffff;
+    data[4134]=(char)0xffff;
+    data[4135]=(char)0xffff;
+    data[4136]=(char)0xffff;
+    data[4137]=(char)0xffff;
+    data[4138]=(char)0x01ff;
+    data[4153]=(char)0x0001;
+    data[4154]=(char)0xf000;
+    data[4155]=(char)0xffff;
+    data[4156]=(char)0x7fff;
+    data[4157]=(char)0x0063;
+    data[4158]=(char)0x00a8;
+
+  }
+  public static Bits currency;
+  static void currency_f() {
+    char[] data = new char[4159];
+    currency = new Bits(data);
+    data[2]=(char)0x0010;
+    data[10]=(char)0x003c;
+    data[159]=(char)0x000c;
+    data[227]=(char)0x8000;
+    data[522]=(char)0x1fff;
+    data[4070]=(char)0x0200;
+    data[4080]=(char)0x0010;
+    data[4094]=(char)0x0063;
+    data[4098]=(char)0x0010;
+    data[4106]=(char)0x003c;
+
+  }
+  public static Bits decimal_digit;
+  static void decimal_digit_f() {
+    char[] data = new char[4159];
+    decimal_digit = new Bits(data);
+    data[3]=(char)0x03ff;
+    data[102]=(char)0x03ff;
+    data[111]=(char)0x03ff;
+    data[150]=(char)0xffc0;
+    data[158]=(char)0xffc0;
+    data[166]=(char)0xffc0;
+    data[174]=(char)0xffc0;
+    data[182]=(char)0xffc0;
+    data[190]=(char)0xff80;
+    data[198]=(char)0xffc0;
+    data[206]=(char)0xffc0;
+    data[214]=(char)0xffc0;
+    data[229]=(char)0x03ff;
+    data[237]=(char)0x03ff;
+    data[242]=(char)0x03ff;
+    data[4081]=(char)0x03ff;
+    data[4099]=(char)0x03ff;
+
+  }
+  public static Bits math;
+  static void math_f() {
+    char[] data = new char[4159];
+    math = new Bits(data);
+    data[2]=(char)0x0800;
+    data[3]=(char)0x7000;
+    data[7]=(char)0x5000;
+    data[10]=(char)0x1000;
+    data[11]=(char)0x0002;
+    data[13]=(char)0x0080;
+    data[15]=(char)0x0080;
+    data[516]=(char)0x0010;
+    data[519]=(char)0x1c00;
+    data[520]=(char)0x1c00;
+    data[537]=(char)0x001f;
+    data[541]=(char)0x0014;
+    data[544]=(char)0xffff;
+    data[545]=(char)0xffff;
+    data[546]=(char)0xffff;
+    data[547]=(char)0xffff;
+    data[548]=(char)0xffff;
+    data[549]=(char)0xffff;
+    data[550]=(char)0xffff;
+    data[551]=(char)0xffff;
+    data[552]=(char)0xffff;
+    data[553]=(char)0xffff;
+    data[554]=(char)0xffff;
+    data[555]=(char)0xffff;
+    data[556]=(char)0xffff;
+    data[557]=(char)0xffff;
+    data[558]=(char)0xffff;
+    data[559]=(char)0x0003;
+    data[560]=(char)0x0f00;
+    data[562]=(char)0x0003;
+    data[4018]=(char)0x0200;
+    data[4070]=(char)0x0074;
+    data[4080]=(char)0x0800;
+    data[4081]=(char)0x7000;
+    data[4085]=(char)0x5000;
+    data[4094]=(char)0x1f04;
+    data[4098]=(char)0x0800;
+    data[4099]=(char)0x7000;
+    data[4103]=(char)0x5000;
+    data[4106]=(char)0x1000;
+    data[4107]=(char)0x0002;
+    data[4109]=(char)0x0080;
+    data[4111]=(char)0x0080;
+
+  }
+  public static Bits letter;
+  static void letter_f() {
+    char[] data = new char[4159];
+    letter = new Bits(data);
+    data[4]=(char)0xfffe;
+    data[5]=(char)0x07ff;
+    data[6]=(char)0xfffe;
+    data[7]=(char)0x07ff;
+    data[10]=(char)0x0400;
+    data[11]=(char)0x0420;
+    data[12]=(char)0xffff;
+    data[13]=(char)0xff7f;
+    data[14]=(char)0xffff;
+    data[15]=(char)0xff7f;
+    data[16]=(char)0xffff;
+    data[17]=(char)0xffff;
+    data[18]=(char)0xffff;
+    data[19]=(char)0xffff;
+    data[20]=(char)0xffff;
+    data[21]=(char)0xffff;
+    data[22]=(char)0xffff;
+    data[23]=(char)0xffff;
+    data[24]=(char)0xffff;
+    data[25]=(char)0xffff;
+    data[26]=(char)0xffff;
+    data[27]=(char)0xffff;
+    data[28]=(char)0xffff;
+    data[29]=(char)0xffff;
+    data[30]=(char)0xffff;
+    data[31]=(char)0xfc3f;
+    data[32]=(char)0xffff;
+    data[33]=(char)0x00ff;
+    data[37]=(char)0xffff;
+    data[38]=(char)0xffff;
+    data[39]=(char)0xffff;
+    data[40]=(char)0xffff;
+    data[41]=(char)0xffff;
+    data[42]=(char)0x01ff;
+    data[43]=(char)0xf9ff;
+    data[44]=(char)0x0003;
+    data[45]=(char)0x0003;
+    data[46]=(char)0x001f;
+    data[55]=(char)0x0400;
+    data[56]=(char)0xd740;
+    data[57]=(char)0xffff;
+    data[58]=(char)0xfffb;
+    data[59]=(char)0xffff;
+    data[60]=(char)0x7fff;
+    data[61]=(char)0x547f;
+    data[62]=(char)0xfffd;
+    data[63]=(char)0x000f;
+    data[64]=(char)0xdffe;
+    data[65]=(char)0xffff;
+    data[66]=(char)0xffff;
+    data[67]=(char)0xffff;
+    data[68]=(char)0xffff;
+    data[69]=(char)0xdffe;
+    data[70]=(char)0xffff;
+    data[71]=(char)0xffff;
+    data[72]=(char)0x0003;
+    data[73]=(char)0xffff;
+    data[74]=(char)0xffff;
+    data[75]=(char)0xffff;
+    data[76]=(char)0x199f;
+    data[77]=(char)0xffff;
+    data[78]=(char)0xcfff;
+    data[79]=(char)0x033f;
+    data[83]=(char)0xfffe;
+    data[84]=(char)0xffff;
+    data[85]=(char)0x027f;
+    data[86]=(char)0xfffe;
+    data[87]=(char)0xffff;
+    data[88]=(char)0x00ff;
+    data[93]=(char)0xffff;
+    data[94]=(char)0x07ff;
+    data[95]=(char)0x0007;
+    data[98]=(char)0xfffe;
+    data[99]=(char)0x07ff;
+    data[100]=(char)0x07ff;
+    data[103]=(char)0xfffe;
+    data[104]=(char)0xffff;
+    data[105]=(char)0xffff;
+    data[106]=(char)0xffff;
+    data[107]=(char)0x7cff;
+    data[108]=(char)0x7fff;
+    data[109]=(char)0x002f;
+    data[110]=(char)0x0060;
+    data[144]=(char)0xffe0;
+    data[145]=(char)0xffff;
+    data[146]=(char)0xffff;
+    data[147]=(char)0x23ff;
+    data[149]=(char)0xff00;
+    data[150]=(char)0x0003;
+    data[152]=(char)0x9fe0;
+    data[153]=(char)0xfff9;
+    data[154]=(char)0xfdff;
+    data[155]=(char)0x03c5;
+    data[157]=(char)0xb000;
+    data[158]=(char)0x0003;
+    data[159]=(char)0x0003;
+    data[160]=(char)0x87e0;
+    data[161]=(char)0xfff9;
+    data[162]=(char)0xfdff;
+    data[163]=(char)0x036d;
+    data[165]=(char)0x5e00;
+    data[167]=(char)0x001c;
+    data[168]=(char)0xafe0;
+    data[169]=(char)0xfffb;
+    data[170]=(char)0xfdff;
+    data[171]=(char)0x23ed;
+    data[174]=(char)0x0001;
+    data[176]=(char)0x9fe0;
+    data[177]=(char)0xfff9;
+    data[178]=(char)0xfdff;
+    data[179]=(char)0x23cd;
+    data[181]=(char)0xb000;
+    data[182]=(char)0x0003;
+    data[184]=(char)0xc7e0;
+    data[185]=(char)0xd63d;
+    data[186]=(char)0xc718;
+    data[187]=(char)0x03bf;
+    data[192]=(char)0xdfe0;
+    data[193]=(char)0xfffd;
+    data[194]=(char)0xfdff;
+    data[195]=(char)0x03ef;
+    data[198]=(char)0x0003;
+    data[200]=(char)0xdfe0;
+    data[201]=(char)0xfffd;
+    data[202]=(char)0xfdff;
+    data[203]=(char)0x03ef;
+    data[205]=(char)0x4000;
+    data[206]=(char)0x0003;
+    data[208]=(char)0xdfe0;
+    data[209]=(char)0xfffd;
+    data[210]=(char)0xfdff;
+    data[211]=(char)0x03ff;
+    data[214]=(char)0x0003;
+    data[224]=(char)0xfffe;
+    data[225]=(char)0xffff;
+    data[226]=(char)0x7fff;
+    data[227]=(char)0x000d;
+    data[228]=(char)0x007f;
+    data[232]=(char)0x2596;
+    data[233]=(char)0xfef0;
+    data[234]=(char)0x6cae;
+    data[235]=(char)0x200d;
+    data[236]=(char)0x005f;
+    data[237]=(char)0x3000;
+    data[244]=(char)0xfeff;
+    data[245]=(char)0xffff;
+    data[246]=(char)0x03ff;
+    data[266]=(char)0xffff;
+    data[267]=(char)0xffff;
+    data[268]=(char)0x003f;
+    data[269]=(char)0xffff;
+    data[270]=(char)0xffff;
+    data[271]=(char)0x007f;
+    data[272]=(char)0xffff;
+    data[273]=(char)0xffff;
+    data[274]=(char)0xffff;
+    data[275]=(char)0xffff;
+    data[276]=(char)0xffff;
+    data[277]=(char)0x83ff;
+    data[278]=(char)0xffff;
+    data[279]=(char)0xffff;
+    data[280]=(char)0xffff;
+    data[281]=(char)0xffff;
+    data[282]=(char)0xff07;
+    data[283]=(char)0xffff;
+    data[284]=(char)0xffff;
+    data[285]=(char)0xffff;
+    data[286]=(char)0xffff;
+    data[287]=(char)0x03ff;
+    data[480]=(char)0xffff;
+    data[481]=(char)0xffff;
+    data[482]=(char)0xffff;
+    data[483]=(char)0xffff;
+    data[484]=(char)0xffff;
+    data[485]=(char)0xffff;
+    data[486]=(char)0xffff;
+    data[487]=(char)0xffff;
+    data[488]=(char)0xffff;
+    data[489]=(char)0x0fff;
+    data[490]=(char)0xffff;
+    data[491]=(char)0xffff;
+    data[492]=(char)0xffff;
+    data[493]=(char)0xffff;
+    data[494]=(char)0xffff;
+    data[495]=(char)0x03ff;
+    data[496]=(char)0xffff;
+    data[497]=(char)0x3f3f;
+    data[498]=(char)0xffff;
+    data[499]=(char)0xffff;
+    data[500]=(char)0x3f3f;
+    data[501]=(char)0xaaff;
+    data[502]=(char)0xffff;
+    data[503]=(char)0x3fff;
+    data[504]=(char)0xffff;
+    data[505]=(char)0xffff;
+    data[506]=(char)0xffff;
+    data[507]=(char)0x5fdf;
+    data[508]=(char)0x1fdc;
+    data[509]=(char)0x0fcf;
+    data[510]=(char)0x1fff;
+    data[511]=(char)0x1fdc;
+    data[519]=(char)0x8000;
+    data[528]=(char)0xfc84;
+    data[529]=(char)0x3f2f;
+    data[530]=(char)0xfd50;
+    data[531]=(char)0x01fb;
+    data[768]=(char)0x0020;
+    data[771]=(char)0x003e;
+    data[772]=(char)0xfffe;
+    data[773]=(char)0xffff;
+    data[774]=(char)0xffff;
+    data[775]=(char)0xffff;
+    data[776]=(char)0xffff;
+    data[777]=(char)0x781f;
+    data[778]=(char)0xfffe;
+    data[779]=(char)0xffff;
+    data[780]=(char)0xffff;
+    data[781]=(char)0xffff;
+    data[782]=(char)0xffff;
+    data[783]=(char)0x77ff;
+    data[784]=(char)0xffe0;
+    data[785]=(char)0xffff;
+    data[786]=(char)0x1fff;
+    data[787]=(char)0xfffe;
+    data[788]=(char)0xffff;
+    data[789]=(char)0xffff;
+    data[790]=(char)0xffff;
+    data[791]=(char)0xffff;
+    data[792]=(char)0x7fff;
+    data[1248]=(char)0xffff;
+    data[1249]=(char)0xffff;
+    data[1250]=(char)0xffff;
+    data[1251]=(char)0xffff;
+    data[1252]=(char)0xffff;
+    data[1253]=(char)0xffff;
+    data[1254]=(char)0xffff;
+    data[1255]=(char)0xffff;
+    data[1256]=(char)0xffff;
+    data[1257]=(char)0xffff;
+    data[1258]=(char)0xffff;
+    data[1259]=(char)0xffff;
+    data[1260]=(char)0xffff;
+    data[1261]=(char)0xffff;
+    data[1262]=(char)0xffff;
+    data[1263]=(char)0xffff;
+    data[1264]=(char)0xffff;
+    data[1265]=(char)0xffff;
+    data[1266]=(char)0xffff;
+    data[1267]=(char)0xffff;
+    data[1268]=(char)0xffff;
+    data[1269]=(char)0xffff;
+    data[1270]=(char)0xffff;
+    data[1271]=(char)0xffff;
+    data[1272]=(char)0xffff;
+    data[1273]=(char)0xffff;
+    data[1274]=(char)0xffff;
+    data[1275]=(char)0xffff;
+    data[1276]=(char)0xffff;
+    data[1277]=(char)0xffff;
+    data[1278]=(char)0xffff;
+    data[1279]=(char)0xffff;
+    data[1280]=(char)0xffff;
+    data[1281]=(char)0xffff;
+    data[1282]=(char)0xffff;
+    data[1283]=(char)0xffff;
+    data[1284]=(char)0xffff;
+    data[1285]=(char)0xffff;
+    data[1286]=(char)0xffff;
+    data[1287]=(char)0xffff;
+    data[1288]=(char)0xffff;
+    data[1289]=(char)0xffff;
+    data[1290]=(char)0xffff;
+    data[1291]=(char)0xffff;
+    data[1292]=(char)0xffff;
+    data[1293]=(char)0xffff;
+    data[1294]=(char)0xffff;
+    data[1295]=(char)0xffff;
+    data[1296]=(char)0xffff;
+    data[1297]=(char)0xffff;
+    data[1298]=(char)0xffff;
+    data[1299]=(char)0xffff;
+    data[1300]=(char)0xffff;
+    data[1301]=(char)0xffff;
+    data[1302]=(char)0xffff;
+    data[1303]=(char)0xffff;
+    data[1304]=(char)0xffff;
+    data[1305]=(char)0xffff;
+    data[1306]=(char)0xffff;
+    data[1307]=(char)0xffff;
+    data[1308]=(char)0xffff;
+    data[1309]=(char)0xffff;
+    data[1310]=(char)0xffff;
+    data[1311]=(char)0xffff;
+    data[1312]=(char)0xffff;
+    data[1313]=(char)0xffff;
+    data[1314]=(char)0xffff;
+    data[1315]=(char)0xffff;
+    data[1316]=(char)0xffff;
+    data[1317]=(char)0xffff;
+    data[1318]=(char)0xffff;
+    data[1319]=(char)0xffff;
+    data[1320]=(char)0xffff;
+    data[1321]=(char)0xffff;
+    data[1322]=(char)0xffff;
+    data[1323]=(char)0xffff;
+    data[1324]=(char)0xffff;
+    data[1325]=(char)0xffff;
+    data[1326]=(char)0xffff;
+    data[1327]=(char)0xffff;
+    data[1328]=(char)0xffff;
+    data[1329]=(char)0xffff;
+    data[1330]=(char)0xffff;
+    data[1331]=(char)0xffff;
+    data[1332]=(char)0xffff;
+    data[1333]=(char)0xffff;
+    data[1334]=(char)0xffff;
+    data[1335]=(char)0xffff;
+    data[1336]=(char)0xffff;
+    data[1337]=(char)0xffff;
+    data[1338]=(char)0xffff;
+    data[1339]=(char)0xffff;
+    data[1340]=(char)0xffff;
+    data[1341]=(char)0xffff;
+    data[1342]=(char)0xffff;
+    data[1343]=(char)0xffff;
+    data[1344]=(char)0xffff;
+    data[1345]=(char)0xffff;
+    data[1346]=(char)0xffff;
+    data[1347]=(char)0xffff;
+    data[1348]=(char)0xffff;
+    data[1349]=(char)0xffff;
+    data[1350]=(char)0xffff;
+    data[1351]=(char)0xffff;
+    data[1352]=(char)0xffff;
+    data[1353]=(char)0xffff;
+    data[1354]=(char)0xffff;
+    data[1355]=(char)0xffff;
+    data[1356]=(char)0xffff;
+    data[1357]=(char)0xffff;
+    data[1358]=(char)0xffff;
+    data[1359]=(char)0xffff;
+    data[1360]=(char)0xffff;
+    data[1361]=(char)0xffff;
+    data[1362]=(char)0xffff;
+    data[1363]=(char)0xffff;
+    data[1364]=(char)0xffff;
+    data[1365]=(char)0xffff;
+    data[1366]=(char)0xffff;
+    data[1367]=(char)0xffff;
+    data[1368]=(char)0xffff;
+    data[1369]=(char)0xffff;
+    data[1370]=(char)0xffff;
+    data[1371]=(char)0xffff;
+    data[1372]=(char)0xffff;
+    data[1373]=(char)0xffff;
+    data[1374]=(char)0xffff;
+    data[1375]=(char)0xffff;
+    data[1376]=(char)0xffff;
+    data[1377]=(char)0xffff;
+    data[1378]=(char)0xffff;
+    data[1379]=(char)0xffff;
+    data[1380]=(char)0xffff;
+    data[1381]=(char)0xffff;
+    data[1382]=(char)0xffff;
+    data[1383]=(char)0xffff;
+    data[1384]=(char)0xffff;
+    data[1385]=(char)0xffff;
+    data[1386]=(char)0xffff;
+    data[1387]=(char)0xffff;
+    data[1388]=(char)0xffff;
+    data[1389]=(char)0xffff;
+    data[1390]=(char)0xffff;
+    data[1391]=(char)0xffff;
+    data[1392]=(char)0xffff;
+    data[1393]=(char)0xffff;
+    data[1394]=(char)0xffff;
+    data[1395]=(char)0xffff;
+    data[1396]=(char)0xffff;
+    data[1397]=(char)0xffff;
+    data[1398]=(char)0xffff;
+    data[1399]=(char)0xffff;
+    data[1400]=(char)0xffff;
+    data[1401]=(char)0xffff;
+    data[1402]=(char)0xffff;
+    data[1403]=(char)0xffff;
+    data[1404]=(char)0xffff;
+    data[1405]=(char)0xffff;
+    data[1406]=(char)0xffff;
+    data[1407]=(char)0xffff;
+    data[1408]=(char)0xffff;
+    data[1409]=(char)0xffff;
+    data[1410]=(char)0xffff;
+    data[1411]=(char)0xffff;
+    data[1412]=(char)0xffff;
+    data[1413]=(char)0xffff;
+    data[1414]=(char)0xffff;
+    data[1415]=(char)0xffff;
+    data[1416]=(char)0xffff;
+    data[1417]=(char)0xffff;
+    data[1418]=(char)0xffff;
+    data[1419]=(char)0xffff;
+    data[1420]=(char)0xffff;
+    data[1421]=(char)0xffff;
+    data[1422]=(char)0xffff;
+    data[1423]=(char)0xffff;
+    data[1424]=(char)0xffff;
+    data[1425]=(char)0xffff;
+    data[1426]=(char)0xffff;
+    data[1427]=(char)0xffff;
+    data[1428]=(char)0xffff;
+    data[1429]=(char)0xffff;
+    data[1430]=(char)0xffff;
+    data[1431]=(char)0xffff;
+    data[1432]=(char)0xffff;
+    data[1433]=(char)0xffff;
+    data[1434]=(char)0xffff;
+    data[1435]=(char)0xffff;
+    data[1436]=(char)0xffff;
+    data[1437]=(char)0xffff;
+    data[1438]=(char)0xffff;
+    data[1439]=(char)0xffff;
+    data[1440]=(char)0xffff;
+    data[1441]=(char)0xffff;
+    data[1442]=(char)0xffff;
+    data[1443]=(char)0xffff;
+    data[1444]=(char)0xffff;
+    data[1445]=(char)0xffff;
+    data[1446]=(char)0xffff;
+    data[1447]=(char)0xffff;
+    data[1448]=(char)0xffff;
+    data[1449]=(char)0xffff;
+    data[1450]=(char)0xffff;
+    data[1451]=(char)0xffff;
+    data[1452]=(char)0xffff;
+    data[1453]=(char)0xffff;
+    data[1454]=(char)0xffff;
+    data[1455]=(char)0xffff;
+    data[1456]=(char)0xffff;
+    data[1457]=(char)0xffff;
+    data[1458]=(char)0xffff;
+    data[1459]=(char)0xffff;
+    data[1460]=(char)0xffff;
+    data[1461]=(char)0xffff;
+    data[1462]=(char)0xffff;
+    data[1463]=(char)0xffff;
+    data[1464]=(char)0xffff;
+    data[1465]=(char)0xffff;
+    data[1466]=(char)0xffff;
+    data[1467]=(char)0xffff;
+    data[1468]=(char)0xffff;
+    data[1469]=(char)0xffff;
+    data[1470]=(char)0xffff;
+    data[1471]=(char)0xffff;
+    data[1472]=(char)0xffff;
+    data[1473]=(char)0xffff;
+    data[1474]=(char)0xffff;
+    data[1475]=(char)0xffff;
+    data[1476]=(char)0xffff;
+    data[1477]=(char)0xffff;
+    data[1478]=(char)0xffff;
+    data[1479]=(char)0xffff;
+    data[1480]=(char)0xffff;
+    data[1481]=(char)0xffff;
+    data[1482]=(char)0xffff;
+    data[1483]=(char)0xffff;
+    data[1484]=(char)0xffff;
+    data[1485]=(char)0xffff;
+    data[1486]=(char)0xffff;
+    data[1487]=(char)0xffff;
+    data[1488]=(char)0xffff;
+    data[1489]=(char)0xffff;
+    data[1490]=(char)0xffff;
+    data[1491]=(char)0xffff;
+    data[1492]=(char)0xffff;
+    data[1493]=(char)0xffff;
+    data[1494]=(char)0xffff;
+    data[1495]=(char)0xffff;
+    data[1496]=(char)0xffff;
+    data[1497]=(char)0xffff;
+    data[1498]=(char)0xffff;
+    data[1499]=(char)0xffff;
+    data[1500]=(char)0xffff;
+    data[1501]=(char)0xffff;
+    data[1502]=(char)0xffff;
+    data[1503]=(char)0xffff;
+    data[1504]=(char)0xffff;
+    data[1505]=(char)0xffff;
+    data[1506]=(char)0xffff;
+    data[1507]=(char)0xffff;
+    data[1508]=(char)0xffff;
+    data[1509]=(char)0xffff;
+    data[1510]=(char)0xffff;
+    data[1511]=(char)0xffff;
+    data[1512]=(char)0xffff;
+    data[1513]=(char)0xffff;
+    data[1514]=(char)0xffff;
+    data[1515]=(char)0xffff;
+    data[1516]=(char)0xffff;
+    data[1517]=(char)0xffff;
+    data[1518]=(char)0xffff;
+    data[1519]=(char)0xffff;
+    data[1520]=(char)0xffff;
+    data[1521]=(char)0xffff;
+    data[1522]=(char)0xffff;
+    data[1523]=(char)0xffff;
+    data[1524]=(char)0xffff;
+    data[1525]=(char)0xffff;
+    data[1526]=(char)0xffff;
+    data[1527]=(char)0xffff;
+    data[1528]=(char)0xffff;
+    data[1529]=(char)0xffff;
+    data[1530]=(char)0xffff;
+    data[1531]=(char)0xffff;
+    data[1532]=(char)0xffff;
+    data[1533]=(char)0xffff;
+    data[1534]=(char)0xffff;
+    data[1535]=(char)0xffff;
+    data[1536]=(char)0xffff;
+    data[1537]=(char)0xffff;
+    data[1538]=(char)0xffff;
+    data[1539]=(char)0xffff;
+    data[1540]=(char)0xffff;
+    data[1541]=(char)0xffff;
+    data[1542]=(char)0xffff;
+    data[1543]=(char)0xffff;
+    data[1544]=(char)0xffff;
+    data[1545]=(char)0xffff;
+    data[1546]=(char)0xffff;
+    data[1547]=(char)0xffff;
+    data[1548]=(char)0xffff;
+    data[1549]=(char)0xffff;
+    data[1550]=(char)0xffff;
+    data[1551]=(char)0xffff;
+    data[1552]=(char)0xffff;
+    data[1553]=(char)0xffff;
+    data[1554]=(char)0xffff;
+    data[1555]=(char)0xffff;
+    data[1556]=(char)0xffff;
+    data[1557]=(char)0xffff;
+    data[1558]=(char)0xffff;
+    data[1559]=(char)0xffff;
+    data[1560]=(char)0xffff;
+    data[1561]=(char)0xffff;
+    data[1562]=(char)0xffff;
+    data[1563]=(char)0xffff;
+    data[1564]=(char)0xffff;
+    data[1565]=(char)0xffff;
+    data[1566]=(char)0xffff;
+    data[1567]=(char)0xffff;
+    data[1568]=(char)0xffff;
+    data[1569]=(char)0xffff;
+    data[1570]=(char)0xffff;
+    data[1571]=(char)0xffff;
+    data[1572]=(char)0xffff;
+    data[1573]=(char)0xffff;
+    data[1574]=(char)0xffff;
+    data[1575]=(char)0xffff;
+    data[1576]=(char)0xffff;
+    data[1577]=(char)0xffff;
+    data[1578]=(char)0xffff;
+    data[1579]=(char)0xffff;
+    data[1580]=(char)0xffff;
+    data[1581]=(char)0xffff;
+    data[1582]=(char)0xffff;
+    data[1583]=(char)0xffff;
+    data[1584]=(char)0xffff;
+    data[1585]=(char)0xffff;
+    data[1586]=(char)0xffff;
+    data[1587]=(char)0xffff;
+    data[1588]=(char)0xffff;
+    data[1589]=(char)0xffff;
+    data[1590]=(char)0xffff;
+    data[1591]=(char)0xffff;
+    data[1592]=(char)0xffff;
+    data[1593]=(char)0xffff;
+    data[1594]=(char)0xffff;
+    data[1595]=(char)0xffff;
+    data[1596]=(char)0xffff;
+    data[1597]=(char)0xffff;
+    data[1598]=(char)0xffff;
+    data[1599]=(char)0xffff;
+    data[1600]=(char)0xffff;
+    data[1601]=(char)0xffff;
+    data[1602]=(char)0xffff;
+    data[1603]=(char)0xffff;
+    data[1604]=(char)0xffff;
+    data[1605]=(char)0xffff;
+    data[1606]=(char)0xffff;
+    data[1607]=(char)0xffff;
+    data[1608]=(char)0xffff;
+    data[1609]=(char)0xffff;
+    data[1610]=(char)0xffff;
+    data[1611]=(char)0xffff;
+    data[1612]=(char)0xffff;
+    data[1613]=(char)0xffff;
+    data[1614]=(char)0xffff;
+    data[1615]=(char)0xffff;
+    data[1616]=(char)0xffff;
+    data[1617]=(char)0xffff;
+    data[1618]=(char)0xffff;
+    data[1619]=(char)0xffff;
+    data[1620]=(char)0xffff;
+    data[1621]=(char)0xffff;
+    data[1622]=(char)0xffff;
+    data[1623]=(char)0xffff;
+    data[1624]=(char)0xffff;
+    data[1625]=(char)0xffff;
+    data[1626]=(char)0xffff;
+    data[1627]=(char)0xffff;
+    data[1628]=(char)0xffff;
+    data[1629]=(char)0xffff;
+    data[1630]=(char)0xffff;
+    data[1631]=(char)0xffff;
+    data[1632]=(char)0xffff;
+    data[1633]=(char)0xffff;
+    data[1634]=(char)0xffff;
+    data[1635]=(char)0xffff;
+    data[1636]=(char)0xffff;
+    data[1637]=(char)0xffff;
+    data[1638]=(char)0xffff;
+    data[1639]=(char)0xffff;
+    data[1640]=(char)0xffff;
+    data[1641]=(char)0xffff;
+    data[1642]=(char)0xffff;
+    data[1643]=(char)0xffff;
+    data[1644]=(char)0xffff;
+    data[1645]=(char)0xffff;
+    data[1646]=(char)0xffff;
+    data[1647]=(char)0xffff;
+    data[1648]=(char)0xffff;
+    data[1649]=(char)0xffff;
+    data[1650]=(char)0xffff;
+    data[1651]=(char)0xffff;
+    data[1652]=(char)0xffff;
+    data[1653]=(char)0xffff;
+    data[1654]=(char)0xffff;
+    data[1655]=(char)0xffff;
+    data[1656]=(char)0xffff;
+    data[1657]=(char)0xffff;
+    data[1658]=(char)0xffff;
+    data[1659]=(char)0xffff;
+    data[1660]=(char)0xffff;
+    data[1661]=(char)0xffff;
+    data[1662]=(char)0xffff;
+    data[1663]=(char)0xffff;
+    data[1664]=(char)0xffff;
+    data[1665]=(char)0xffff;
+    data[1666]=(char)0xffff;
+    data[1667]=(char)0xffff;
+    data[1668]=(char)0xffff;
+    data[1669]=(char)0xffff;
+    data[1670]=(char)0xffff;
+    data[1671]=(char)0xffff;
+    data[1672]=(char)0xffff;
+    data[1673]=(char)0xffff;
+    data[1674]=(char)0xffff;
+    data[1675]=(char)0xffff;
+    data[1676]=(char)0xffff;
+    data[1677]=(char)0xffff;
+    data[1678]=(char)0xffff;
+    data[1679]=(char)0xffff;
+    data[1680]=(char)0xffff;
+    data[1681]=(char)0xffff;
+    data[1682]=(char)0xffff;
+    data[1683]=(char)0xffff;
+    data[1684]=(char)0xffff;
+    data[1685]=(char)0xffff;
+    data[1686]=(char)0xffff;
+    data[1687]=(char)0xffff;
+    data[1688]=(char)0xffff;
+    data[1689]=(char)0xffff;
+    data[1690]=(char)0xffff;
+    data[1691]=(char)0xffff;
+    data[1692]=(char)0xffff;
+    data[1693]=(char)0xffff;
+    data[1694]=(char)0xffff;
+    data[1695]=(char)0xffff;
+    data[1696]=(char)0xffff;
+    data[1697]=(char)0xffff;
+    data[1698]=(char)0xffff;
+    data[1699]=(char)0xffff;
+    data[1700]=(char)0xffff;
+    data[1701]=(char)0xffff;
+    data[1702]=(char)0xffff;
+    data[1703]=(char)0xffff;
+    data[1704]=(char)0xffff;
+    data[1705]=(char)0xffff;
+    data[1706]=(char)0xffff;
+    data[1707]=(char)0xffff;
+    data[1708]=(char)0xffff;
+    data[1709]=(char)0xffff;
+    data[1710]=(char)0xffff;
+    data[1711]=(char)0xffff;
+    data[1712]=(char)0xffff;
+    data[1713]=(char)0xffff;
+    data[1714]=(char)0xffff;
+    data[1715]=(char)0xffff;
+    data[1716]=(char)0xffff;
+    data[1717]=(char)0xffff;
+    data[1718]=(char)0xffff;
+    data[1719]=(char)0xffff;
+    data[1720]=(char)0xffff;
+    data[1721]=(char)0xffff;
+    data[1722]=(char)0xffff;
+    data[1723]=(char)0xffff;
+    data[1724]=(char)0xffff;
+    data[1725]=(char)0xffff;
+    data[1726]=(char)0xffff;
+    data[1727]=(char)0xffff;
+    data[1728]=(char)0xffff;
+    data[1729]=(char)0xffff;
+    data[1730]=(char)0xffff;
+    data[1731]=(char)0xffff;
+    data[1732]=(char)0xffff;
+    data[1733]=(char)0xffff;
+    data[1734]=(char)0xffff;
+    data[1735]=(char)0xffff;
+    data[1736]=(char)0xffff;
+    data[1737]=(char)0xffff;
+    data[1738]=(char)0xffff;
+    data[1739]=(char)0xffff;
+    data[1740]=(char)0xffff;
+    data[1741]=(char)0xffff;
+    data[1742]=(char)0xffff;
+    data[1743]=(char)0xffff;
+    data[1744]=(char)0xffff;
+    data[1745]=(char)0xffff;
+    data[1746]=(char)0xffff;
+    data[1747]=(char)0xffff;
+    data[1748]=(char)0xffff;
+    data[1749]=(char)0xffff;
+    data[1750]=(char)0xffff;
+    data[1751]=(char)0xffff;
+    data[1752]=(char)0xffff;
+    data[1753]=(char)0xffff;
+    data[1754]=(char)0xffff;
+    data[1755]=(char)0xffff;
+    data[1756]=(char)0xffff;
+    data[1757]=(char)0xffff;
+    data[1758]=(char)0xffff;
+    data[1759]=(char)0xffff;
+    data[1760]=(char)0xffff;
+    data[1761]=(char)0xffff;
+    data[1762]=(char)0xffff;
+    data[1763]=(char)0xffff;
+    data[1764]=(char)0xffff;
+    data[1765]=(char)0xffff;
+    data[1766]=(char)0xffff;
+    data[1767]=(char)0xffff;
+    data[1768]=(char)0xffff;
+    data[1769]=(char)0xffff;
+    data[1770]=(char)0xffff;
+    data[1771]=(char)0xffff;
+    data[1772]=(char)0xffff;
+    data[1773]=(char)0xffff;
+    data[1774]=(char)0xffff;
+    data[1775]=(char)0xffff;
+    data[1776]=(char)0xffff;
+    data[1777]=(char)0xffff;
+    data[1778]=(char)0xffff;
+    data[1779]=(char)0xffff;
+    data[1780]=(char)0xffff;
+    data[1781]=(char)0xffff;
+    data[1782]=(char)0xffff;
+    data[1783]=(char)0xffff;
+    data[1784]=(char)0xffff;
+    data[1785]=(char)0xffff;
+    data[1786]=(char)0xffff;
+    data[1787]=(char)0xffff;
+    data[1788]=(char)0xffff;
+    data[1789]=(char)0xffff;
+    data[1790]=(char)0xffff;
+    data[1791]=(char)0xffff;
+    data[1792]=(char)0xffff;
+    data[1793]=(char)0xffff;
+    data[1794]=(char)0xffff;
+    data[1795]=(char)0xffff;
+    data[1796]=(char)0xffff;
+    data[1797]=(char)0xffff;
+    data[1798]=(char)0xffff;
+    data[1799]=(char)0xffff;
+    data[1800]=(char)0xffff;
+    data[1801]=(char)0xffff;
+    data[1802]=(char)0xffff;
+    data[1803]=(char)0xffff;
+    data[1804]=(char)0xffff;
+    data[1805]=(char)0xffff;
+    data[1806]=(char)0xffff;
+    data[1807]=(char)0xffff;
+    data[1808]=(char)0xffff;
+    data[1809]=(char)0xffff;
+    data[1810]=(char)0xffff;
+    data[1811]=(char)0xffff;
+    data[1812]=(char)0xffff;
+    data[1813]=(char)0xffff;
+    data[1814]=(char)0xffff;
+    data[1815]=(char)0xffff;
+    data[1816]=(char)0xffff;
+    data[1817]=(char)0xffff;
+    data[1818]=(char)0xffff;
+    data[1819]=(char)0xffff;
+    data[1820]=(char)0xffff;
+    data[1821]=(char)0xffff;
+    data[1822]=(char)0xffff;
+    data[1823]=(char)0xffff;
+    data[1824]=(char)0xffff;
+    data[1825]=(char)0xffff;
+    data[1826]=(char)0xffff;
+    data[1827]=(char)0xffff;
+    data[1828]=(char)0xffff;
+    data[1829]=(char)0xffff;
+    data[1830]=(char)0xffff;
+    data[1831]=(char)0xffff;
+    data[1832]=(char)0xffff;
+    data[1833]=(char)0xffff;
+    data[1834]=(char)0xffff;
+    data[1835]=(char)0xffff;
+    data[1836]=(char)0xffff;
+    data[1837]=(char)0xffff;
+    data[1838]=(char)0xffff;
+    data[1839]=(char)0xffff;
+    data[1840]=(char)0xffff;
+    data[1841]=(char)0xffff;
+    data[1842]=(char)0xffff;
+    data[1843]=(char)0xffff;
+    data[1844]=(char)0xffff;
+    data[1845]=(char)0xffff;
+    data[1846]=(char)0xffff;
+    data[1847]=(char)0xffff;
+    data[1848]=(char)0xffff;
+    data[1849]=(char)0xffff;
+    data[1850]=(char)0xffff;
+    data[1851]=(char)0xffff;
+    data[1852]=(char)0xffff;
+    data[1853]=(char)0xffff;
+    data[1854]=(char)0xffff;
+    data[1855]=(char)0xffff;
+    data[1856]=(char)0xffff;
+    data[1857]=(char)0xffff;
+    data[1858]=(char)0xffff;
+    data[1859]=(char)0xffff;
+    data[1860]=(char)0xffff;
+    data[1861]=(char)0xffff;
+    data[1862]=(char)0xffff;
+    data[1863]=(char)0xffff;
+    data[1864]=(char)0xffff;
+    data[1865]=(char)0xffff;
+    data[1866]=(char)0xffff;
+    data[1867]=(char)0xffff;
+    data[1868]=(char)0xffff;
+    data[1869]=(char)0xffff;
+    data[1870]=(char)0xffff;
+    data[1871]=(char)0xffff;
+    data[1872]=(char)0xffff;
+    data[1873]=(char)0xffff;
+    data[1874]=(char)0xffff;
+    data[1875]=(char)0xffff;
+    data[1876]=(char)0xffff;
+    data[1877]=(char)0xffff;
+    data[1878]=(char)0xffff;
+    data[1879]=(char)0xffff;
+    data[1880]=(char)0xffff;
+    data[1881]=(char)0xffff;
+    data[1882]=(char)0xffff;
+    data[1883]=(char)0xffff;
+    data[1884]=(char)0xffff;
+    data[1885]=(char)0xffff;
+    data[1886]=(char)0xffff;
+    data[1887]=(char)0xffff;
+    data[1888]=(char)0xffff;
+    data[1889]=(char)0xffff;
+    data[1890]=(char)0xffff;
+    data[1891]=(char)0xffff;
+    data[1892]=(char)0xffff;
+    data[1893]=(char)0xffff;
+    data[1894]=(char)0xffff;
+    data[1895]=(char)0xffff;
+    data[1896]=(char)0xffff;
+    data[1897]=(char)0xffff;
+    data[1898]=(char)0xffff;
+    data[1899]=(char)0xffff;
+    data[1900]=(char)0xffff;
+    data[1901]=(char)0xffff;
+    data[1902]=(char)0xffff;
+    data[1903]=(char)0xffff;
+    data[1904]=(char)0xffff;
+    data[1905]=(char)0xffff;
+    data[1906]=(char)0xffff;
+    data[1907]=(char)0xffff;
+    data[1908]=(char)0xffff;
+    data[1909]=(char)0xffff;
+    data[1910]=(char)0xffff;
+    data[1911]=(char)0xffff;
+    data[1912]=(char)0xffff;
+    data[1913]=(char)0xffff;
+    data[1914]=(char)0xffff;
+    data[1915]=(char)0xffff;
+    data[1916]=(char)0xffff;
+    data[1917]=(char)0xffff;
+    data[1918]=(char)0xffff;
+    data[1919]=(char)0xffff;
+    data[1920]=(char)0xffff;
+    data[1921]=(char)0xffff;
+    data[1922]=(char)0xffff;
+    data[1923]=(char)0xffff;
+    data[1924]=(char)0xffff;
+    data[1925]=(char)0xffff;
+    data[1926]=(char)0xffff;
+    data[1927]=(char)0xffff;
+    data[1928]=(char)0xffff;
+    data[1929]=(char)0xffff;
+    data[1930]=(char)0xffff;
+    data[1931]=(char)0xffff;
+    data[1932]=(char)0xffff;
+    data[1933]=(char)0xffff;
+    data[1934]=(char)0xffff;
+    data[1935]=(char)0xffff;
+    data[1936]=(char)0xffff;
+    data[1937]=(char)0xffff;
+    data[1938]=(char)0xffff;
+    data[1939]=(char)0xffff;
+    data[1940]=(char)0xffff;
+    data[1941]=(char)0xffff;
+    data[1942]=(char)0xffff;
+    data[1943]=(char)0xffff;
+    data[1944]=(char)0xffff;
+    data[1945]=(char)0xffff;
+    data[1946]=(char)0xffff;
+    data[1947]=(char)0xffff;
+    data[1948]=(char)0xffff;
+    data[1949]=(char)0xffff;
+    data[1950]=(char)0xffff;
+    data[1951]=(char)0xffff;
+    data[1952]=(char)0xffff;
+    data[1953]=(char)0xffff;
+    data[1954]=(char)0xffff;
+    data[1955]=(char)0xffff;
+    data[1956]=(char)0xffff;
+    data[1957]=(char)0xffff;
+    data[1958]=(char)0xffff;
+    data[1959]=(char)0xffff;
+    data[1960]=(char)0xffff;
+    data[1961]=(char)0xffff;
+    data[1962]=(char)0xffff;
+    data[1963]=(char)0xffff;
+    data[1964]=(char)0xffff;
+    data[1965]=(char)0xffff;
+    data[1966]=(char)0xffff;
+    data[1967]=(char)0xffff;
+    data[1968]=(char)0xffff;
+    data[1969]=(char)0xffff;
+    data[1970]=(char)0xffff;
+    data[1971]=(char)0xffff;
+    data[1972]=(char)0xffff;
+    data[1973]=(char)0xffff;
+    data[1974]=(char)0xffff;
+    data[1975]=(char)0xffff;
+    data[1976]=(char)0xffff;
+    data[1977]=(char)0xffff;
+    data[1978]=(char)0xffff;
+    data[1979]=(char)0xffff;
+    data[1980]=(char)0xffff;
+    data[1981]=(char)0xffff;
+    data[1982]=(char)0xffff;
+    data[1983]=(char)0xffff;
+    data[1984]=(char)0xffff;
+    data[1985]=(char)0xffff;
+    data[1986]=(char)0xffff;
+    data[1987]=(char)0xffff;
+    data[1988]=(char)0xffff;
+    data[1989]=(char)0xffff;
+    data[1990]=(char)0xffff;
+    data[1991]=(char)0xffff;
+    data[1992]=(char)0xffff;
+    data[1993]=(char)0xffff;
+    data[1994]=(char)0xffff;
+    data[1995]=(char)0xffff;
+    data[1996]=(char)0xffff;
+    data[1997]=(char)0xffff;
+    data[1998]=(char)0xffff;
+    data[1999]=(char)0xffff;
+    data[2000]=(char)0xffff;
+    data[2001]=(char)0xffff;
+    data[2002]=(char)0xffff;
+    data[2003]=(char)0xffff;
+    data[2004]=(char)0xffff;
+    data[2005]=(char)0xffff;
+    data[2006]=(char)0xffff;
+    data[2007]=(char)0xffff;
+    data[2008]=(char)0xffff;
+    data[2009]=(char)0xffff;
+    data[2010]=(char)0xffff;
+    data[2011]=(char)0xffff;
+    data[2012]=(char)0xffff;
+    data[2013]=(char)0xffff;
+    data[2014]=(char)0xffff;
+    data[2015]=(char)0xffff;
+    data[2016]=(char)0xffff;
+    data[2017]=(char)0xffff;
+    data[2018]=(char)0xffff;
+    data[2019]=(char)0xffff;
+    data[2020]=(char)0xffff;
+    data[2021]=(char)0xffff;
+    data[2022]=(char)0xffff;
+    data[2023]=(char)0xffff;
+    data[2024]=(char)0xffff;
+    data[2025]=(char)0xffff;
+    data[2026]=(char)0xffff;
+    data[2027]=(char)0xffff;
+    data[2028]=(char)0xffff;
+    data[2029]=(char)0xffff;
+    data[2030]=(char)0xffff;
+    data[2031]=(char)0xffff;
+    data[2032]=(char)0xffff;
+    data[2033]=(char)0xffff;
+    data[2034]=(char)0xffff;
+    data[2035]=(char)0xffff;
+    data[2036]=(char)0xffff;
+    data[2037]=(char)0xffff;
+    data[2038]=(char)0xffff;
+    data[2039]=(char)0xffff;
+    data[2040]=(char)0xffff;
+    data[2041]=(char)0xffff;
+    data[2042]=(char)0xffff;
+    data[2043]=(char)0xffff;
+    data[2044]=(char)0xffff;
+    data[2045]=(char)0xffff;
+    data[2046]=(char)0xffff;
+    data[2047]=(char)0xffff;
+    data[2048]=(char)0xffff;
+    data[2049]=(char)0xffff;
+    data[2050]=(char)0xffff;
+    data[2051]=(char)0xffff;
+    data[2052]=(char)0xffff;
+    data[2053]=(char)0xffff;
+    data[2054]=(char)0xffff;
+    data[2055]=(char)0xffff;
+    data[2056]=(char)0xffff;
+    data[2057]=(char)0xffff;
+    data[2058]=(char)0xffff;
+    data[2059]=(char)0xffff;
+    data[2060]=(char)0xffff;
+    data[2061]=(char)0xffff;
+    data[2062]=(char)0xffff;
+    data[2063]=(char)0xffff;
+    data[2064]=(char)0xffff;
+    data[2065]=(char)0xffff;
+    data[2066]=(char)0xffff;
+    data[2067]=(char)0xffff;
+    data[2068]=(char)0xffff;
+    data[2069]=(char)0xffff;
+    data[2070]=(char)0xffff;
+    data[2071]=(char)0xffff;
+    data[2072]=(char)0xffff;
+    data[2073]=(char)0xffff;
+    data[2074]=(char)0xffff;
+    data[2075]=(char)0xffff;
+    data[2076]=(char)0xffff;
+    data[2077]=(char)0xffff;
+    data[2078]=(char)0xffff;
+    data[2079]=(char)0xffff;
+    data[2080]=(char)0xffff;
+    data[2081]=(char)0xffff;
+    data[2082]=(char)0xffff;
+    data[2083]=(char)0xffff;
+    data[2084]=(char)0xffff;
+    data[2085]=(char)0xffff;
+    data[2086]=(char)0xffff;
+    data[2087]=(char)0xffff;
+    data[2088]=(char)0xffff;
+    data[2089]=(char)0xffff;
+    data[2090]=(char)0xffff;
+    data[2091]=(char)0xffff;
+    data[2092]=(char)0xffff;
+    data[2093]=(char)0xffff;
+    data[2094]=(char)0xffff;
+    data[2095]=(char)0xffff;
+    data[2096]=(char)0xffff;
+    data[2097]=(char)0xffff;
+    data[2098]=(char)0xffff;
+    data[2099]=(char)0xffff;
+    data[2100]=(char)0xffff;
+    data[2101]=(char)0xffff;
+    data[2102]=(char)0xffff;
+    data[2103]=(char)0xffff;
+    data[2104]=(char)0xffff;
+    data[2105]=(char)0xffff;
+    data[2106]=(char)0xffff;
+    data[2107]=(char)0xffff;
+    data[2108]=(char)0xffff;
+    data[2109]=(char)0xffff;
+    data[2110]=(char)0xffff;
+    data[2111]=(char)0xffff;
+    data[2112]=(char)0xffff;
+    data[2113]=(char)0xffff;
+    data[2114]=(char)0xffff;
+    data[2115]=(char)0xffff;
+    data[2116]=(char)0xffff;
+    data[2117]=(char)0xffff;
+    data[2118]=(char)0xffff;
+    data[2119]=(char)0xffff;
+    data[2120]=(char)0xffff;
+    data[2121]=(char)0xffff;
+    data[2122]=(char)0xffff;
+    data[2123]=(char)0xffff;
+    data[2124]=(char)0xffff;
+    data[2125]=(char)0xffff;
+    data[2126]=(char)0xffff;
+    data[2127]=(char)0xffff;
+    data[2128]=(char)0xffff;
+    data[2129]=(char)0xffff;
+    data[2130]=(char)0xffff;
+    data[2131]=(char)0xffff;
+    data[2132]=(char)0xffff;
+    data[2133]=(char)0xffff;
+    data[2134]=(char)0xffff;
+    data[2135]=(char)0xffff;
+    data[2136]=(char)0xffff;
+    data[2137]=(char)0xffff;
+    data[2138]=(char)0xffff;
+    data[2139]=(char)0xffff;
+    data[2140]=(char)0xffff;
+    data[2141]=(char)0xffff;
+    data[2142]=(char)0xffff;
+    data[2143]=(char)0xffff;
+    data[2144]=(char)0xffff;
+    data[2145]=(char)0xffff;
+    data[2146]=(char)0xffff;
+    data[2147]=(char)0xffff;
+    data[2148]=(char)0xffff;
+    data[2149]=(char)0xffff;
+    data[2150]=(char)0xffff;
+    data[2151]=(char)0xffff;
+    data[2152]=(char)0xffff;
+    data[2153]=(char)0xffff;
+    data[2154]=(char)0xffff;
+    data[2155]=(char)0xffff;
+    data[2156]=(char)0xffff;
+    data[2157]=(char)0xffff;
+    data[2158]=(char)0xffff;
+    data[2159]=(char)0xffff;
+    data[2160]=(char)0xffff;
+    data[2161]=(char)0xffff;
+    data[2162]=(char)0xffff;
+    data[2163]=(char)0xffff;
+    data[2164]=(char)0xffff;
+    data[2165]=(char)0xffff;
+    data[2166]=(char)0xffff;
+    data[2167]=(char)0xffff;
+    data[2168]=(char)0xffff;
+    data[2169]=(char)0xffff;
+    data[2170]=(char)0xffff;
+    data[2171]=(char)0xffff;
+    data[2172]=(char)0xffff;
+    data[2173]=(char)0xffff;
+    data[2174]=(char)0xffff;
+    data[2175]=(char)0xffff;
+    data[2176]=(char)0xffff;
+    data[2177]=(char)0xffff;
+    data[2178]=(char)0xffff;
+    data[2179]=(char)0xffff;
+    data[2180]=(char)0xffff;
+    data[2181]=(char)0xffff;
+    data[2182]=(char)0xffff;
+    data[2183]=(char)0xffff;
+    data[2184]=(char)0xffff;
+    data[2185]=(char)0xffff;
+    data[2186]=(char)0xffff;
+    data[2187]=(char)0xffff;
+    data[2188]=(char)0xffff;
+    data[2189]=(char)0xffff;
+    data[2190]=(char)0xffff;
+    data[2191]=(char)0xffff;
+    data[2192]=(char)0xffff;
+    data[2193]=(char)0xffff;
+    data[2194]=(char)0xffff;
+    data[2195]=(char)0xffff;
+    data[2196]=(char)0xffff;
+    data[2197]=(char)0xffff;
+    data[2198]=(char)0xffff;
+    data[2199]=(char)0xffff;
+    data[2200]=(char)0xffff;
+    data[2201]=(char)0xffff;
+    data[2202]=(char)0xffff;
+    data[2203]=(char)0xffff;
+    data[2204]=(char)0xffff;
+    data[2205]=(char)0xffff;
+    data[2206]=(char)0xffff;
+    data[2207]=(char)0xffff;
+    data[2208]=(char)0xffff;
+    data[2209]=(char)0xffff;
+    data[2210]=(char)0xffff;
+    data[2211]=(char)0xffff;
+    data[2212]=(char)0xffff;
+    data[2213]=(char)0xffff;
+    data[2214]=(char)0xffff;
+    data[2215]=(char)0xffff;
+    data[2216]=(char)0xffff;
+    data[2217]=(char)0xffff;
+    data[2218]=(char)0xffff;
+    data[2219]=(char)0xffff;
+    data[2220]=(char)0xffff;
+    data[2221]=(char)0xffff;
+    data[2222]=(char)0xffff;
+    data[2223]=(char)0xffff;
+    data[2224]=(char)0xffff;
+    data[2225]=(char)0xffff;
+    data[2226]=(char)0xffff;
+    data[2227]=(char)0xffff;
+    data[2228]=(char)0xffff;
+    data[2229]=(char)0xffff;
+    data[2230]=(char)0xffff;
+    data[2231]=(char)0xffff;
+    data[2232]=(char)0xffff;
+    data[2233]=(char)0xffff;
+    data[2234]=(char)0xffff;
+    data[2235]=(char)0xffff;
+    data[2236]=(char)0xffff;
+    data[2237]=(char)0xffff;
+    data[2238]=(char)0xffff;
+    data[2239]=(char)0xffff;
+    data[2240]=(char)0xffff;
+    data[2241]=(char)0xffff;
+    data[2242]=(char)0xffff;
+    data[2243]=(char)0xffff;
+    data[2244]=(char)0xffff;
+    data[2245]=(char)0xffff;
+    data[2246]=(char)0xffff;
+    data[2247]=(char)0xffff;
+    data[2248]=(char)0xffff;
+    data[2249]=(char)0xffff;
+    data[2250]=(char)0xffff;
+    data[2251]=(char)0xffff;
+    data[2252]=(char)0xffff;
+    data[2253]=(char)0xffff;
+    data[2254]=(char)0xffff;
+    data[2255]=(char)0xffff;
+    data[2256]=(char)0xffff;
+    data[2257]=(char)0xffff;
+    data[2258]=(char)0xffff;
+    data[2259]=(char)0xffff;
+    data[2260]=(char)0xffff;
+    data[2261]=(char)0xffff;
+    data[2262]=(char)0xffff;
+    data[2263]=(char)0xffff;
+    data[2264]=(char)0xffff;
+    data[2265]=(char)0xffff;
+    data[2266]=(char)0xffff;
+    data[2267]=(char)0xffff;
+    data[2268]=(char)0xffff;
+    data[2269]=(char)0xffff;
+    data[2270]=(char)0xffff;
+    data[2271]=(char)0xffff;
+    data[2272]=(char)0xffff;
+    data[2273]=(char)0xffff;
+    data[2274]=(char)0xffff;
+    data[2275]=(char)0xffff;
+    data[2276]=(char)0xffff;
+    data[2277]=(char)0xffff;
+    data[2278]=(char)0xffff;
+    data[2279]=(char)0xffff;
+    data[2280]=(char)0xffff;
+    data[2281]=(char)0xffff;
+    data[2282]=(char)0xffff;
+    data[2283]=(char)0xffff;
+    data[2284]=(char)0xffff;
+    data[2285]=(char)0xffff;
+    data[2286]=(char)0xffff;
+    data[2287]=(char)0xffff;
+    data[2288]=(char)0xffff;
+    data[2289]=(char)0xffff;
+    data[2290]=(char)0xffff;
+    data[2291]=(char)0xffff;
+    data[2292]=(char)0xffff;
+    data[2293]=(char)0xffff;
+    data[2294]=(char)0xffff;
+    data[2295]=(char)0xffff;
+    data[2296]=(char)0xffff;
+    data[2297]=(char)0xffff;
+    data[2298]=(char)0xffff;
+    data[2299]=(char)0xffff;
+    data[2300]=(char)0xffff;
+    data[2301]=(char)0xffff;
+    data[2302]=(char)0xffff;
+    data[2303]=(char)0xffff;
+    data[2304]=(char)0xffff;
+    data[2305]=(char)0xffff;
+    data[2306]=(char)0xffff;
+    data[2307]=(char)0xffff;
+    data[2308]=(char)0xffff;
+    data[2309]=(char)0xffff;
+    data[2310]=(char)0xffff;
+    data[2311]=(char)0xffff;
+    data[2312]=(char)0xffff;
+    data[2313]=(char)0xffff;
+    data[2314]=(char)0xffff;
+    data[2315]=(char)0xffff;
+    data[2316]=(char)0xffff;
+    data[2317]=(char)0xffff;
+    data[2318]=(char)0xffff;
+    data[2319]=(char)0xffff;
+    data[2320]=(char)0xffff;
+    data[2321]=(char)0xffff;
+    data[2322]=(char)0xffff;
+    data[2323]=(char)0xffff;
+    data[2324]=(char)0xffff;
+    data[2325]=(char)0xffff;
+    data[2326]=(char)0xffff;
+    data[2327]=(char)0xffff;
+    data[2328]=(char)0xffff;
+    data[2329]=(char)0xffff;
+    data[2330]=(char)0xffff;
+    data[2331]=(char)0xffff;
+    data[2332]=(char)0xffff;
+    data[2333]=(char)0xffff;
+    data[2334]=(char)0xffff;
+    data[2335]=(char)0xffff;
+    data[2336]=(char)0xffff;
+    data[2337]=(char)0xffff;
+    data[2338]=(char)0xffff;
+    data[2339]=(char)0xffff;
+    data[2340]=(char)0xffff;
+    data[2341]=(char)0xffff;
+    data[2342]=(char)0xffff;
+    data[2343]=(char)0xffff;
+    data[2344]=(char)0xffff;
+    data[2345]=(char)0xffff;
+    data[2346]=(char)0xffff;
+    data[2347]=(char)0xffff;
+    data[2348]=(char)0xffff;
+    data[2349]=(char)0xffff;
+    data[2350]=(char)0xffff;
+    data[2351]=(char)0xffff;
+    data[2352]=(char)0xffff;
+    data[2353]=(char)0xffff;
+    data[2354]=(char)0xffff;
+    data[2355]=(char)0xffff;
+    data[2356]=(char)0xffff;
+    data[2357]=(char)0xffff;
+    data[2358]=(char)0xffff;
+    data[2359]=(char)0xffff;
+    data[2360]=(char)0xffff;
+    data[2361]=(char)0xffff;
+    data[2362]=(char)0xffff;
+    data[2363]=(char)0xffff;
+    data[2364]=(char)0xffff;
+    data[2365]=(char)0xffff;
+    data[2366]=(char)0xffff;
+    data[2367]=(char)0xffff;
+    data[2368]=(char)0xffff;
+    data[2369]=(char)0xffff;
+    data[2370]=(char)0xffff;
+    data[2371]=(char)0xffff;
+    data[2372]=(char)0xffff;
+    data[2373]=(char)0xffff;
+    data[2374]=(char)0xffff;
+    data[2375]=(char)0xffff;
+    data[2376]=(char)0xffff;
+    data[2377]=(char)0xffff;
+    data[2378]=(char)0xffff;
+    data[2379]=(char)0xffff;
+    data[2380]=(char)0xffff;
+    data[2381]=(char)0xffff;
+    data[2382]=(char)0xffff;
+    data[2383]=(char)0xffff;
+    data[2384]=(char)0xffff;
+    data[2385]=(char)0xffff;
+    data[2386]=(char)0xffff;
+    data[2387]=(char)0xffff;
+    data[2388]=(char)0xffff;
+    data[2389]=(char)0xffff;
+    data[2390]=(char)0xffff;
+    data[2391]=(char)0xffff;
+    data[2392]=(char)0xffff;
+    data[2393]=(char)0xffff;
+    data[2394]=(char)0xffff;
+    data[2395]=(char)0xffff;
+    data[2396]=(char)0xffff;
+    data[2397]=(char)0xffff;
+    data[2398]=(char)0xffff;
+    data[2399]=(char)0xffff;
+    data[2400]=(char)0xffff;
+    data[2401]=(char)0xffff;
+    data[2402]=(char)0xffff;
+    data[2403]=(char)0xffff;
+    data[2404]=(char)0xffff;
+    data[2405]=(char)0xffff;
+    data[2406]=(char)0xffff;
+    data[2407]=(char)0xffff;
+    data[2408]=(char)0xffff;
+    data[2409]=(char)0xffff;
+    data[2410]=(char)0xffff;
+    data[2411]=(char)0xffff;
+    data[2412]=(char)0xffff;
+    data[2413]=(char)0xffff;
+    data[2414]=(char)0xffff;
+    data[2415]=(char)0xffff;
+    data[2416]=(char)0xffff;
+    data[2417]=(char)0xffff;
+    data[2418]=(char)0xffff;
+    data[2419]=(char)0xffff;
+    data[2420]=(char)0xffff;
+    data[2421]=(char)0xffff;
+    data[2422]=(char)0xffff;
+    data[2423]=(char)0xffff;
+    data[2424]=(char)0xffff;
+    data[2425]=(char)0xffff;
+    data[2426]=(char)0xffff;
+    data[2427]=(char)0xffff;
+    data[2428]=(char)0xffff;
+    data[2429]=(char)0xffff;
+    data[2430]=(char)0xffff;
+    data[2431]=(char)0xffff;
+    data[2432]=(char)0xffff;
+    data[2433]=(char)0xffff;
+    data[2434]=(char)0xffff;
+    data[2435]=(char)0xffff;
+    data[2436]=(char)0xffff;
+    data[2437]=(char)0xffff;
+    data[2438]=(char)0xffff;
+    data[2439]=(char)0xffff;
+    data[2440]=(char)0xffff;
+    data[2441]=(char)0xffff;
+    data[2442]=(char)0xffff;
+    data[2443]=(char)0xffff;
+    data[2444]=(char)0xffff;
+    data[2445]=(char)0xffff;
+    data[2446]=(char)0xffff;
+    data[2447]=(char)0xffff;
+    data[2448]=(char)0xffff;
+    data[2449]=(char)0xffff;
+    data[2450]=(char)0xffff;
+    data[2451]=(char)0xffff;
+    data[2452]=(char)0xffff;
+    data[2453]=(char)0xffff;
+    data[2454]=(char)0xffff;
+    data[2455]=(char)0xffff;
+    data[2456]=(char)0xffff;
+    data[2457]=(char)0xffff;
+    data[2458]=(char)0xffff;
+    data[2459]=(char)0xffff;
+    data[2460]=(char)0xffff;
+    data[2461]=(char)0xffff;
+    data[2462]=(char)0xffff;
+    data[2463]=(char)0xffff;
+    data[2464]=(char)0xffff;
+    data[2465]=(char)0xffff;
+    data[2466]=(char)0xffff;
+    data[2467]=(char)0xffff;
+    data[2468]=(char)0xffff;
+    data[2469]=(char)0xffff;
+    data[2470]=(char)0xffff;
+    data[2471]=(char)0xffff;
+    data[2472]=(char)0xffff;
+    data[2473]=(char)0xffff;
+    data[2474]=(char)0xffff;
+    data[2475]=(char)0xffff;
+    data[2476]=(char)0xffff;
+    data[2477]=(char)0xffff;
+    data[2478]=(char)0xffff;
+    data[2479]=(char)0xffff;
+    data[2480]=(char)0xffff;
+    data[2481]=(char)0xffff;
+    data[2482]=(char)0xffff;
+    data[2483]=(char)0xffff;
+    data[2484]=(char)0xffff;
+    data[2485]=(char)0xffff;
+    data[2486]=(char)0xffff;
+    data[2487]=(char)0xffff;
+    data[2488]=(char)0xffff;
+    data[2489]=(char)0xffff;
+    data[2490]=(char)0xffff;
+    data[2491]=(char)0xffff;
+    data[2492]=(char)0xffff;
+    data[2493]=(char)0xffff;
+    data[2494]=(char)0xffff;
+    data[2495]=(char)0xffff;
+    data[2496]=(char)0xffff;
+    data[2497]=(char)0xffff;
+    data[2498]=(char)0xffff;
+    data[2499]=(char)0xffff;
+    data[2500]=(char)0xffff;
+    data[2501]=(char)0xffff;
+    data[2502]=(char)0xffff;
+    data[2503]=(char)0xffff;
+    data[2504]=(char)0xffff;
+    data[2505]=(char)0xffff;
+    data[2506]=(char)0xffff;
+    data[2507]=(char)0xffff;
+    data[2508]=(char)0xffff;
+    data[2509]=(char)0xffff;
+    data[2510]=(char)0xffff;
+    data[2511]=(char)0xffff;
+    data[2512]=(char)0xffff;
+    data[2513]=(char)0xffff;
+    data[2514]=(char)0xffff;
+    data[2515]=(char)0xffff;
+    data[2516]=(char)0xffff;
+    data[2517]=(char)0xffff;
+    data[2518]=(char)0xffff;
+    data[2519]=(char)0xffff;
+    data[2520]=(char)0xffff;
+    data[2521]=(char)0xffff;
+    data[2522]=(char)0xffff;
+    data[2523]=(char)0xffff;
+    data[2524]=(char)0xffff;
+    data[2525]=(char)0xffff;
+    data[2526]=(char)0xffff;
+    data[2527]=(char)0xffff;
+    data[2528]=(char)0xffff;
+    data[2529]=(char)0xffff;
+    data[2530]=(char)0xffff;
+    data[2531]=(char)0xffff;
+    data[2532]=(char)0xffff;
+    data[2533]=(char)0xffff;
+    data[2534]=(char)0xffff;
+    data[2535]=(char)0xffff;
+    data[2536]=(char)0xffff;
+    data[2537]=(char)0xffff;
+    data[2538]=(char)0xffff;
+    data[2539]=(char)0xffff;
+    data[2540]=(char)0xffff;
+    data[2541]=(char)0xffff;
+    data[2542]=(char)0xffff;
+    data[2543]=(char)0xffff;
+    data[2544]=(char)0xffff;
+    data[2545]=(char)0xffff;
+    data[2546]=(char)0xffff;
+    data[2547]=(char)0xffff;
+    data[2548]=(char)0xffff;
+    data[2549]=(char)0xffff;
+    data[2550]=(char)0xffff;
+    data[2551]=(char)0xffff;
+    data[2552]=(char)0xffff;
+    data[2553]=(char)0xffff;
+    data[2554]=(char)0x003f;
+    data[2752]=(char)0xffff;
+    data[2753]=(char)0xffff;
+    data[2754]=(char)0xffff;
+    data[2755]=(char)0xffff;
+    data[2756]=(char)0xffff;
+    data[2757]=(char)0xffff;
+    data[2758]=(char)0xffff;
+    data[2759]=(char)0xffff;
+    data[2760]=(char)0xffff;
+    data[2761]=(char)0xffff;
+    data[2762]=(char)0xffff;
+    data[2763]=(char)0xffff;
+    data[2764]=(char)0xffff;
+    data[2765]=(char)0xffff;
+    data[2766]=(char)0xffff;
+    data[2767]=(char)0xffff;
+    data[2768]=(char)0xffff;
+    data[2769]=(char)0xffff;
+    data[2770]=(char)0xffff;
+    data[2771]=(char)0xffff;
+    data[2772]=(char)0xffff;
+    data[2773]=(char)0xffff;
+    data[2774]=(char)0xffff;
+    data[2775]=(char)0xffff;
+    data[2776]=(char)0xffff;
+    data[2777]=(char)0xffff;
+    data[2778]=(char)0xffff;
+    data[2779]=(char)0xffff;
+    data[2780]=(char)0xffff;
+    data[2781]=(char)0xffff;
+    data[2782]=(char)0xffff;
+    data[2783]=(char)0xffff;
+    data[2784]=(char)0xffff;
+    data[2785]=(char)0xffff;
+    data[2786]=(char)0xffff;
+    data[2787]=(char)0xffff;
+    data[2788]=(char)0xffff;
+    data[2789]=(char)0xffff;
+    data[2790]=(char)0xffff;
+    data[2791]=(char)0xffff;
+    data[2792]=(char)0xffff;
+    data[2793]=(char)0xffff;
+    data[2794]=(char)0xffff;
+    data[2795]=(char)0xffff;
+    data[2796]=(char)0xffff;
+    data[2797]=(char)0xffff;
+    data[2798]=(char)0xffff;
+    data[2799]=(char)0xffff;
+    data[2800]=(char)0xffff;
+    data[2801]=(char)0xffff;
+    data[2802]=(char)0xffff;
+    data[2803]=(char)0xffff;
+    data[2804]=(char)0xffff;
+    data[2805]=(char)0xffff;
+    data[2806]=(char)0xffff;
+    data[2807]=(char)0xffff;
+    data[2808]=(char)0xffff;
+    data[2809]=(char)0xffff;
+    data[2810]=(char)0xffff;
+    data[2811]=(char)0xffff;
+    data[2812]=(char)0xffff;
+    data[2813]=(char)0xffff;
+    data[2814]=(char)0xffff;
+    data[2815]=(char)0xffff;
+    data[2816]=(char)0xffff;
+    data[2817]=(char)0xffff;
+    data[2818]=(char)0xffff;
+    data[2819]=(char)0xffff;
+    data[2820]=(char)0xffff;
+    data[2821]=(char)0xffff;
+    data[2822]=(char)0xffff;
+    data[2823]=(char)0xffff;
+    data[2824]=(char)0xffff;
+    data[2825]=(char)0xffff;
+    data[2826]=(char)0xffff;
+    data[2827]=(char)0xffff;
+    data[2828]=(char)0xffff;
+    data[2829]=(char)0xffff;
+    data[2830]=(char)0xffff;
+    data[2831]=(char)0xffff;
+    data[2832]=(char)0xffff;
+    data[2833]=(char)0xffff;
+    data[2834]=(char)0xffff;
+    data[2835]=(char)0xffff;
+    data[2836]=(char)0xffff;
+    data[2837]=(char)0xffff;
+    data[2838]=(char)0xffff;
+    data[2839]=(char)0xffff;
+    data[2840]=(char)0xffff;
+    data[2841]=(char)0xffff;
+    data[2842]=(char)0xffff;
+    data[2843]=(char)0xffff;
+    data[2844]=(char)0xffff;
+    data[2845]=(char)0xffff;
+    data[2846]=(char)0xffff;
+    data[2847]=(char)0xffff;
+    data[2848]=(char)0xffff;
+    data[2849]=(char)0xffff;
+    data[2850]=(char)0xffff;
+    data[2851]=(char)0xffff;
+    data[2852]=(char)0xffff;
+    data[2853]=(char)0xffff;
+    data[2854]=(char)0xffff;
+    data[2855]=(char)0xffff;
+    data[2856]=(char)0xffff;
+    data[2857]=(char)0xffff;
+    data[2858]=(char)0xffff;
+    data[2859]=(char)0xffff;
+    data[2860]=(char)0xffff;
+    data[2861]=(char)0xffff;
+    data[2862]=(char)0xffff;
+    data[2863]=(char)0xffff;
+    data[2864]=(char)0xffff;
+    data[2865]=(char)0xffff;
+    data[2866]=(char)0xffff;
+    data[2867]=(char)0xffff;
+    data[2868]=(char)0xffff;
+    data[2869]=(char)0xffff;
+    data[2870]=(char)0xffff;
+    data[2871]=(char)0xffff;
+    data[2872]=(char)0xffff;
+    data[2873]=(char)0xffff;
+    data[2874]=(char)0xffff;
+    data[2875]=(char)0xffff;
+    data[2876]=(char)0xffff;
+    data[2877]=(char)0xffff;
+    data[2878]=(char)0xffff;
+    data[2879]=(char)0xffff;
+    data[2880]=(char)0xffff;
+    data[2881]=(char)0xffff;
+    data[2882]=(char)0xffff;
+    data[2883]=(char)0xffff;
+    data[2884]=(char)0xffff;
+    data[2885]=(char)0xffff;
+    data[2886]=(char)0xffff;
+    data[2887]=(char)0xffff;
+    data[2888]=(char)0xffff;
+    data[2889]=(char)0xffff;
+    data[2890]=(char)0xffff;
+    data[2891]=(char)0xffff;
+    data[2892]=(char)0xffff;
+    data[2893]=(char)0xffff;
+    data[2894]=(char)0xffff;
+    data[2895]=(char)0xffff;
+    data[2896]=(char)0xffff;
+    data[2897]=(char)0xffff;
+    data[2898]=(char)0xffff;
+    data[2899]=(char)0xffff;
+    data[2900]=(char)0xffff;
+    data[2901]=(char)0xffff;
+    data[2902]=(char)0xffff;
+    data[2903]=(char)0xffff;
+    data[2904]=(char)0xffff;
+    data[2905]=(char)0xffff;
+    data[2906]=(char)0xffff;
+    data[2907]=(char)0xffff;
+    data[2908]=(char)0xffff;
+    data[2909]=(char)0xffff;
+    data[2910]=(char)0xffff;
+    data[2911]=(char)0xffff;
+    data[2912]=(char)0xffff;
+    data[2913]=(char)0xffff;
+    data[2914]=(char)0xffff;
+    data[2915]=(char)0xffff;
+    data[2916]=(char)0xffff;
+    data[2917]=(char)0xffff;
+    data[2918]=(char)0xffff;
+    data[2919]=(char)0xffff;
+    data[2920]=(char)0xffff;
+    data[2921]=(char)0xffff;
+    data[2922]=(char)0xffff;
+    data[2923]=(char)0xffff;
+    data[2924]=(char)0xffff;
+    data[2925]=(char)0xffff;
+    data[2926]=(char)0xffff;
+    data[2927]=(char)0xffff;
+    data[2928]=(char)0xffff;
+    data[2929]=(char)0xffff;
+    data[2930]=(char)0xffff;
+    data[2931]=(char)0xffff;
+    data[2932]=(char)0xffff;
+    data[2933]=(char)0xffff;
+    data[2934]=(char)0xffff;
+    data[2935]=(char)0xffff;
+    data[2936]=(char)0xffff;
+    data[2937]=(char)0xffff;
+    data[2938]=(char)0xffff;
+    data[2939]=(char)0xffff;
+    data[2940]=(char)0xffff;
+    data[2941]=(char)0xffff;
+    data[2942]=(char)0xffff;
+    data[2943]=(char)0xffff;
+    data[2944]=(char)0xffff;
+    data[2945]=(char)0xffff;
+    data[2946]=(char)0xffff;
+    data[2947]=(char)0xffff;
+    data[2948]=(char)0xffff;
+    data[2949]=(char)0xffff;
+    data[2950]=(char)0xffff;
+    data[2951]=(char)0xffff;
+    data[2952]=(char)0xffff;
+    data[2953]=(char)0xffff;
+    data[2954]=(char)0xffff;
+    data[2955]=(char)0xffff;
+    data[2956]=(char)0xffff;
+    data[2957]=(char)0xffff;
+    data[2958]=(char)0xffff;
+    data[2959]=(char)0xffff;
+    data[2960]=(char)0xffff;
+    data[2961]=(char)0xffff;
+    data[2962]=(char)0xffff;
+    data[2963]=(char)0xffff;
+    data[2964]=(char)0xffff;
+    data[2965]=(char)0xffff;
+    data[2966]=(char)0xffff;
+    data[2967]=(char)0xffff;
+    data[2968]=(char)0xffff;
+    data[2969]=(char)0xffff;
+    data[2970]=(char)0xffff;
+    data[2971]=(char)0xffff;
+    data[2972]=(char)0xffff;
+    data[2973]=(char)0xffff;
+    data[2974]=(char)0xffff;
+    data[2975]=(char)0xffff;
+    data[2976]=(char)0xffff;
+    data[2977]=(char)0xffff;
+    data[2978]=(char)0xffff;
+    data[2979]=(char)0xffff;
+    data[2980]=(char)0xffff;
+    data[2981]=(char)0xffff;
+    data[2982]=(char)0xffff;
+    data[2983]=(char)0xffff;
+    data[2984]=(char)0xffff;
+    data[2985]=(char)0xffff;
+    data[2986]=(char)0xffff;
+    data[2987]=(char)0xffff;
+    data[2988]=(char)0xffff;
+    data[2989]=(char)0xffff;
+    data[2990]=(char)0xffff;
+    data[2991]=(char)0xffff;
+    data[2992]=(char)0xffff;
+    data[2993]=(char)0xffff;
+    data[2994]=(char)0xffff;
+    data[2995]=(char)0xffff;
+    data[2996]=(char)0xffff;
+    data[2997]=(char)0xffff;
+    data[2998]=(char)0xffff;
+    data[2999]=(char)0xffff;
+    data[3000]=(char)0xffff;
+    data[3001]=(char)0xffff;
+    data[3002]=(char)0xffff;
+    data[3003]=(char)0xffff;
+    data[3004]=(char)0xffff;
+    data[3005]=(char)0xffff;
+    data[3006]=(char)0xffff;
+    data[3007]=(char)0xffff;
+    data[3008]=(char)0xffff;
+    data[3009]=(char)0xffff;
+    data[3010]=(char)0xffff;
+    data[3011]=(char)0xffff;
+    data[3012]=(char)0xffff;
+    data[3013]=(char)0xffff;
+    data[3014]=(char)0xffff;
+    data[3015]=(char)0xffff;
+    data[3016]=(char)0xffff;
+    data[3017]=(char)0xffff;
+    data[3018]=(char)0xffff;
+    data[3019]=(char)0xffff;
+    data[3020]=(char)0xffff;
+    data[3021]=(char)0xffff;
+    data[3022]=(char)0xffff;
+    data[3023]=(char)0xffff;
+    data[3024]=(char)0xffff;
+    data[3025]=(char)0xffff;
+    data[3026]=(char)0xffff;
+    data[3027]=(char)0xffff;
+    data[3028]=(char)0xffff;
+    data[3029]=(char)0xffff;
+    data[3030]=(char)0xffff;
+    data[3031]=(char)0xffff;
+    data[3032]=(char)0xffff;
+    data[3033]=(char)0xffff;
+    data[3034]=(char)0xffff;
+    data[3035]=(char)0xffff;
+    data[3036]=(char)0xffff;
+    data[3037]=(char)0xffff;
+    data[3038]=(char)0xffff;
+    data[3039]=(char)0xffff;
+    data[3040]=(char)0xffff;
+    data[3041]=(char)0xffff;
+    data[3042]=(char)0xffff;
+    data[3043]=(char)0xffff;
+    data[3044]=(char)0xffff;
+    data[3045]=(char)0xffff;
+    data[3046]=(char)0xffff;
+    data[3047]=(char)0xffff;
+    data[3048]=(char)0xffff;
+    data[3049]=(char)0xffff;
+    data[3050]=(char)0xffff;
+    data[3051]=(char)0xffff;
+    data[3052]=(char)0xffff;
+    data[3053]=(char)0xffff;
+    data[3054]=(char)0xffff;
+    data[3055]=(char)0xffff;
+    data[3056]=(char)0xffff;
+    data[3057]=(char)0xffff;
+    data[3058]=(char)0xffff;
+    data[3059]=(char)0xffff;
+    data[3060]=(char)0xffff;
+    data[3061]=(char)0xffff;
+    data[3062]=(char)0xffff;
+    data[3063]=(char)0xffff;
+    data[3064]=(char)0xffff;
+    data[3065]=(char)0xffff;
+    data[3066]=(char)0xffff;
+    data[3067]=(char)0xffff;
+    data[3068]=(char)0xffff;
+    data[3069]=(char)0xffff;
+    data[3070]=(char)0xffff;
+    data[3071]=(char)0xffff;
+    data[3072]=(char)0xffff;
+    data[3073]=(char)0xffff;
+    data[3074]=(char)0xffff;
+    data[3075]=(char)0xffff;
+    data[3076]=(char)0xffff;
+    data[3077]=(char)0xffff;
+    data[3078]=(char)0xffff;
+    data[3079]=(char)0xffff;
+    data[3080]=(char)0xffff;
+    data[3081]=(char)0xffff;
+    data[3082]=(char)0xffff;
+    data[3083]=(char)0xffff;
+    data[3084]=(char)0xffff;
+    data[3085]=(char)0xffff;
+    data[3086]=(char)0xffff;
+    data[3087]=(char)0xffff;
+    data[3088]=(char)0xffff;
+    data[3089]=(char)0xffff;
+    data[3090]=(char)0xffff;
+    data[3091]=(char)0xffff;
+    data[3092]=(char)0xffff;
+    data[3093]=(char)0xffff;
+    data[3094]=(char)0xffff;
+    data[3095]=(char)0xffff;
+    data[3096]=(char)0xffff;
+    data[3097]=(char)0xffff;
+    data[3098]=(char)0xffff;
+    data[3099]=(char)0xffff;
+    data[3100]=(char)0xffff;
+    data[3101]=(char)0xffff;
+    data[3102]=(char)0xffff;
+    data[3103]=(char)0xffff;
+    data[3104]=(char)0xffff;
+    data[3105]=(char)0xffff;
+    data[3106]=(char)0xffff;
+    data[3107]=(char)0xffff;
+    data[3108]=(char)0xffff;
+    data[3109]=(char)0xffff;
+    data[3110]=(char)0xffff;
+    data[3111]=(char)0xffff;
+    data[3112]=(char)0xffff;
+    data[3113]=(char)0xffff;
+    data[3114]=(char)0xffff;
+    data[3115]=(char)0xffff;
+    data[3116]=(char)0xffff;
+    data[3117]=(char)0xffff;
+    data[3118]=(char)0xffff;
+    data[3119]=(char)0xffff;
+    data[3120]=(char)0xffff;
+    data[3121]=(char)0xffff;
+    data[3122]=(char)0xffff;
+    data[3123]=(char)0xffff;
+    data[3124]=(char)0xffff;
+    data[3125]=(char)0xffff;
+    data[3126]=(char)0xffff;
+    data[3127]=(char)0xffff;
+    data[3128]=(char)0xffff;
+    data[3129]=(char)0xffff;
+    data[3130]=(char)0xffff;
+    data[3131]=(char)0xffff;
+    data[3132]=(char)0xffff;
+    data[3133]=(char)0xffff;
+    data[3134]=(char)0xffff;
+    data[3135]=(char)0xffff;
+    data[3136]=(char)0xffff;
+    data[3137]=(char)0xffff;
+    data[3138]=(char)0xffff;
+    data[3139]=(char)0xffff;
+    data[3140]=(char)0xffff;
+    data[3141]=(char)0xffff;
+    data[3142]=(char)0xffff;
+    data[3143]=(char)0xffff;
+    data[3144]=(char)0xffff;
+    data[3145]=(char)0xffff;
+    data[3146]=(char)0xffff;
+    data[3147]=(char)0xffff;
+    data[3148]=(char)0xffff;
+    data[3149]=(char)0xffff;
+    data[3150]=(char)0xffff;
+    data[3151]=(char)0xffff;
+    data[3152]=(char)0xffff;
+    data[3153]=(char)0xffff;
+    data[3154]=(char)0xffff;
+    data[3155]=(char)0xffff;
+    data[3156]=(char)0xffff;
+    data[3157]=(char)0xffff;
+    data[3158]=(char)0xffff;
+    data[3159]=(char)0xffff;
+    data[3160]=(char)0xffff;
+    data[3161]=(char)0xffff;
+    data[3162]=(char)0xffff;
+    data[3163]=(char)0xffff;
+    data[3164]=(char)0xffff;
+    data[3165]=(char)0xffff;
+    data[3166]=(char)0xffff;
+    data[3167]=(char)0xffff;
+    data[3168]=(char)0xffff;
+    data[3169]=(char)0xffff;
+    data[3170]=(char)0xffff;
+    data[3171]=(char)0xffff;
+    data[3172]=(char)0xffff;
+    data[3173]=(char)0xffff;
+    data[3174]=(char)0xffff;
+    data[3175]=(char)0xffff;
+    data[3176]=(char)0xffff;
+    data[3177]=(char)0xffff;
+    data[3178]=(char)0xffff;
+    data[3179]=(char)0xffff;
+    data[3180]=(char)0xffff;
+    data[3181]=(char)0xffff;
+    data[3182]=(char)0xffff;
+    data[3183]=(char)0xffff;
+    data[3184]=(char)0xffff;
+    data[3185]=(char)0xffff;
+    data[3186]=(char)0xffff;
+    data[3187]=(char)0xffff;
+    data[3188]=(char)0xffff;
+    data[3189]=(char)0xffff;
+    data[3190]=(char)0xffff;
+    data[3191]=(char)0xffff;
+    data[3192]=(char)0xffff;
+    data[3193]=(char)0xffff;
+    data[3194]=(char)0xffff;
+    data[3195]=(char)0xffff;
+    data[3196]=(char)0xffff;
+    data[3197]=(char)0xffff;
+    data[3198]=(char)0xffff;
+    data[3199]=(char)0xffff;
+    data[3200]=(char)0xffff;
+    data[3201]=(char)0xffff;
+    data[3202]=(char)0xffff;
+    data[3203]=(char)0xffff;
+    data[3204]=(char)0xffff;
+    data[3205]=(char)0xffff;
+    data[3206]=(char)0xffff;
+    data[3207]=(char)0xffff;
+    data[3208]=(char)0xffff;
+    data[3209]=(char)0xffff;
+    data[3210]=(char)0xffff;
+    data[3211]=(char)0xffff;
+    data[3212]=(char)0xffff;
+    data[3213]=(char)0xffff;
+    data[3214]=(char)0xffff;
+    data[3215]=(char)0xffff;
+    data[3216]=(char)0xffff;
+    data[3217]=(char)0xffff;
+    data[3218]=(char)0xffff;
+    data[3219]=(char)0xffff;
+    data[3220]=(char)0xffff;
+    data[3221]=(char)0xffff;
+    data[3222]=(char)0xffff;
+    data[3223]=(char)0xffff;
+    data[3224]=(char)0xffff;
+    data[3225]=(char)0xffff;
+    data[3226]=(char)0xffff;
+    data[3227]=(char)0xffff;
+    data[3228]=(char)0xffff;
+    data[3229]=(char)0xffff;
+    data[3230]=(char)0xffff;
+    data[3231]=(char)0xffff;
+    data[3232]=(char)0xffff;
+    data[3233]=(char)0xffff;
+    data[3234]=(char)0xffff;
+    data[3235]=(char)0xffff;
+    data[3236]=(char)0xffff;
+    data[3237]=(char)0xffff;
+    data[3238]=(char)0xffff;
+    data[3239]=(char)0xffff;
+    data[3240]=(char)0xffff;
+    data[3241]=(char)0xffff;
+    data[3242]=(char)0xffff;
+    data[3243]=(char)0xffff;
+    data[3244]=(char)0xffff;
+    data[3245]=(char)0xffff;
+    data[3246]=(char)0xffff;
+    data[3247]=(char)0xffff;
+    data[3248]=(char)0xffff;
+    data[3249]=(char)0xffff;
+    data[3250]=(char)0xffff;
+    data[3251]=(char)0xffff;
+    data[3252]=(char)0xffff;
+    data[3253]=(char)0xffff;
+    data[3254]=(char)0xffff;
+    data[3255]=(char)0xffff;
+    data[3256]=(char)0xffff;
+    data[3257]=(char)0xffff;
+    data[3258]=(char)0xffff;
+    data[3259]=(char)0xffff;
+    data[3260]=(char)0xffff;
+    data[3261]=(char)0xffff;
+    data[3262]=(char)0xffff;
+    data[3263]=(char)0xffff;
+    data[3264]=(char)0xffff;
+    data[3265]=(char)0xffff;
+    data[3266]=(char)0xffff;
+    data[3267]=(char)0xffff;
+    data[3268]=(char)0xffff;
+    data[3269]=(char)0xffff;
+    data[3270]=(char)0xffff;
+    data[3271]=(char)0xffff;
+    data[3272]=(char)0xffff;
+    data[3273]=(char)0xffff;
+    data[3274]=(char)0xffff;
+    data[3275]=(char)0xffff;
+    data[3276]=(char)0xffff;
+    data[3277]=(char)0xffff;
+    data[3278]=(char)0xffff;
+    data[3279]=(char)0xffff;
+    data[3280]=(char)0xffff;
+    data[3281]=(char)0xffff;
+    data[3282]=(char)0xffff;
+    data[3283]=(char)0xffff;
+    data[3284]=(char)0xffff;
+    data[3285]=(char)0xffff;
+    data[3286]=(char)0xffff;
+    data[3287]=(char)0xffff;
+    data[3288]=(char)0xffff;
+    data[3289]=(char)0xffff;
+    data[3290]=(char)0xffff;
+    data[3291]=(char)0xffff;
+    data[3292]=(char)0xffff;
+    data[3293]=(char)0xffff;
+    data[3294]=(char)0xffff;
+    data[3295]=(char)0xffff;
+    data[3296]=(char)0xffff;
+    data[3297]=(char)0xffff;
+    data[3298]=(char)0xffff;
+    data[3299]=(char)0xffff;
+    data[3300]=(char)0xffff;
+    data[3301]=(char)0xffff;
+    data[3302]=(char)0xffff;
+    data[3303]=(char)0xffff;
+    data[3304]=(char)0xffff;
+    data[3305]=(char)0xffff;
+    data[3306]=(char)0xffff;
+    data[3307]=(char)0xffff;
+    data[3308]=(char)0xffff;
+    data[3309]=(char)0xffff;
+    data[3310]=(char)0xffff;
+    data[3311]=(char)0xffff;
+    data[3312]=(char)0xffff;
+    data[3313]=(char)0xffff;
+    data[3314]=(char)0xffff;
+    data[3315]=(char)0xffff;
+    data[3316]=(char)0xffff;
+    data[3317]=(char)0xffff;
+    data[3318]=(char)0xffff;
+    data[3319]=(char)0xffff;
+    data[3320]=(char)0xffff;
+    data[3321]=(char)0xffff;
+    data[3322]=(char)0xffff;
+    data[3323]=(char)0xffff;
+    data[3324]=(char)0xffff;
+    data[3325]=(char)0xffff;
+    data[3326]=(char)0xffff;
+    data[3327]=(char)0xffff;
+    data[3328]=(char)0xffff;
+    data[3329]=(char)0xffff;
+    data[3330]=(char)0xffff;
+    data[3331]=(char)0xffff;
+    data[3332]=(char)0xffff;
+    data[3333]=(char)0xffff;
+    data[3334]=(char)0xffff;
+    data[3335]=(char)0xffff;
+    data[3336]=(char)0xffff;
+    data[3337]=(char)0xffff;
+    data[3338]=(char)0xffff;
+    data[3339]=(char)0xffff;
+    data[3340]=(char)0xffff;
+    data[3341]=(char)0xffff;
+    data[3342]=(char)0xffff;
+    data[3343]=(char)0xffff;
+    data[3344]=(char)0xffff;
+    data[3345]=(char)0xffff;
+    data[3346]=(char)0xffff;
+    data[3347]=(char)0xffff;
+    data[3348]=(char)0xffff;
+    data[3349]=(char)0xffff;
+    data[3350]=(char)0xffff;
+    data[3351]=(char)0xffff;
+    data[3352]=(char)0xffff;
+    data[3353]=(char)0xffff;
+    data[3354]=(char)0xffff;
+    data[3355]=(char)0xffff;
+    data[3356]=(char)0xffff;
+    data[3357]=(char)0xffff;
+    data[3358]=(char)0xffff;
+    data[3359]=(char)0xffff;
+    data[3360]=(char)0xffff;
+    data[3361]=(char)0xffff;
+    data[3362]=(char)0xffff;
+    data[3363]=(char)0xffff;
+    data[3364]=(char)0xffff;
+    data[3365]=(char)0xffff;
+    data[3366]=(char)0xffff;
+    data[3367]=(char)0xffff;
+    data[3368]=(char)0xffff;
+    data[3369]=(char)0xffff;
+    data[3370]=(char)0xffff;
+    data[3371]=(char)0xffff;
+    data[3372]=(char)0xffff;
+    data[3373]=(char)0xffff;
+    data[3374]=(char)0xffff;
+    data[3375]=(char)0xffff;
+    data[3376]=(char)0xffff;
+    data[3377]=(char)0xffff;
+    data[3378]=(char)0xffff;
+    data[3379]=(char)0xffff;
+    data[3380]=(char)0xffff;
+    data[3381]=(char)0xffff;
+    data[3382]=(char)0xffff;
+    data[3383]=(char)0xffff;
+    data[3384]=(char)0xffff;
+    data[3385]=(char)0xffff;
+    data[3386]=(char)0xffff;
+    data[3387]=(char)0xffff;
+    data[3388]=(char)0xffff;
+    data[3389]=(char)0xffff;
+    data[3390]=(char)0xffff;
+    data[3391]=(char)0xffff;
+    data[3392]=(char)0xffff;
+    data[3393]=(char)0xffff;
+    data[3394]=(char)0xffff;
+    data[3395]=(char)0xffff;
+    data[3396]=(char)0xffff;
+    data[3397]=(char)0xffff;
+    data[3398]=(char)0xffff;
+    data[3399]=(char)0xffff;
+    data[3400]=(char)0xffff;
+    data[3401]=(char)0xffff;
+    data[3402]=(char)0xffff;
+    data[3403]=(char)0xffff;
+    data[3404]=(char)0xffff;
+    data[3405]=(char)0xffff;
+    data[3406]=(char)0xffff;
+    data[3407]=(char)0xffff;
+    data[3408]=(char)0xffff;
+    data[3409]=(char)0xffff;
+    data[3410]=(char)0xffff;
+    data[3411]=(char)0xffff;
+    data[3412]=(char)0xffff;
+    data[3413]=(char)0xffff;
+    data[3414]=(char)0xffff;
+    data[3415]=(char)0xffff;
+    data[3416]=(char)0xffff;
+    data[3417]=(char)0xffff;
+    data[3418]=(char)0xffff;
+    data[3419]=(char)0xffff;
+    data[3420]=(char)0xffff;
+    data[3421]=(char)0xffff;
+    data[3422]=(char)0xffff;
+    data[3423]=(char)0xffff;
+    data[3424]=(char)0xffff;
+    data[3425]=(char)0xffff;
+    data[3426]=(char)0xffff;
+    data[3427]=(char)0xffff;
+    data[3428]=(char)0xffff;
+    data[3429]=(char)0xffff;
+    data[3430]=(char)0xffff;
+    data[3431]=(char)0xffff;
+    data[3432]=(char)0xffff;
+    data[3433]=(char)0xffff;
+    data[3434]=(char)0xffff;
+    data[3435]=(char)0xffff;
+    data[3436]=(char)0xffff;
+    data[3437]=(char)0xffff;
+    data[3438]=(char)0xffff;
+    data[3439]=(char)0xffff;
+    data[3440]=(char)0xffff;
+    data[3441]=(char)0xffff;
+    data[3442]=(char)0xffff;
+    data[3443]=(char)0xffff;
+    data[3444]=(char)0xffff;
+    data[3445]=(char)0xffff;
+    data[3446]=(char)0xffff;
+    data[3447]=(char)0xffff;
+    data[3448]=(char)0xffff;
+    data[3449]=(char)0xffff;
+    data[3450]=(char)0x000f;
+    data[3984]=(char)0xffff;
+    data[3985]=(char)0xffff;
+    data[3986]=(char)0xffff;
+    data[3987]=(char)0xffff;
+    data[3988]=(char)0xffff;
+    data[3989]=(char)0xffff;
+    data[3990]=(char)0xffff;
+    data[3991]=(char)0xffff;
+    data[3992]=(char)0xffff;
+    data[3993]=(char)0xffff;
+    data[3994]=(char)0xffff;
+    data[3995]=(char)0xffff;
+    data[3996]=(char)0xffff;
+    data[3997]=(char)0xffff;
+    data[3998]=(char)0xffff;
+    data[3999]=(char)0xffff;
+    data[4000]=(char)0xffff;
+    data[4001]=(char)0xffff;
+    data[4002]=(char)0x3fff;
+    data[4016]=(char)0x007f;
+    data[4017]=(char)0x80f8;
+    data[4018]=(char)0xfdff;
+    data[4019]=(char)0x5f7f;
+    data[4020]=(char)0xffdb;
+    data[4021]=(char)0xffff;
+    data[4022]=(char)0xffff;
+    data[4023]=(char)0xffff;
+    data[4024]=(char)0xffff;
+    data[4025]=(char)0xffff;
+    data[4026]=(char)0xffff;
+    data[4027]=(char)0x0003;
+    data[4029]=(char)0xfff8;
+    data[4030]=(char)0xffff;
+    data[4031]=(char)0xffff;
+    data[4032]=(char)0xffff;
+    data[4033]=(char)0xffff;
+    data[4034]=(char)0xffff;
+    data[4035]=(char)0xffff;
+    data[4036]=(char)0xffff;
+    data[4037]=(char)0xffff;
+    data[4038]=(char)0xffff;
+    data[4039]=(char)0xffff;
+    data[4040]=(char)0xffff;
+    data[4041]=(char)0xffff;
+    data[4042]=(char)0xffff;
+    data[4043]=(char)0xffff;
+    data[4044]=(char)0xffff;
+    data[4045]=(char)0xffff;
+    data[4046]=(char)0xffff;
+    data[4047]=(char)0xffff;
+    data[4048]=(char)0xffff;
+    data[4049]=(char)0xffff;
+    data[4050]=(char)0xffff;
+    data[4051]=(char)0x3fff;
+    data[4053]=(char)0xffff;
+    data[4054]=(char)0xffff;
+    data[4055]=(char)0xffff;
+    data[4056]=(char)0xffff;
+    data[4057]=(char)0xfffc;
+    data[4058]=(char)0xffff;
+    data[4059]=(char)0xffff;
+    data[4060]=(char)0x00ff;
+    data[4063]=(char)0x0fff;
+    data[4071]=(char)0xffd7;
+    data[4072]=(char)0xffff;
+    data[4073]=(char)0xffff;
+    data[4074]=(char)0xffff;
+    data[4075]=(char)0xffff;
+    data[4076]=(char)0xffff;
+    data[4077]=(char)0xffff;
+    data[4078]=(char)0xffff;
+    data[4079]=(char)0x1fff;
+    data[4082]=(char)0xfffe;
+    data[4083]=(char)0x07ff;
+    data[4084]=(char)0xfffe;
+    data[4085]=(char)0x07ff;
+    data[4086]=(char)0xffc0;
+    data[4087]=(char)0xffff;
+    data[4088]=(char)0xffff;
+    data[4089]=(char)0xffff;
+    data[4090]=(char)0xffff;
+    data[4091]=(char)0x7fff;
+    data[4092]=(char)0xfcfc;
+    data[4093]=(char)0x1cfc;
+    data[4100]=(char)0xfffe;
+    data[4101]=(char)0x07ff;
+    data[4102]=(char)0xfffe;
+    data[4103]=(char)0x07ff;
+    data[4106]=(char)0x0400;
+    data[4107]=(char)0x0420;
+    data[4108]=(char)0xffff;
+    data[4109]=(char)0xff7f;
+    data[4110]=(char)0xffff;
+    data[4111]=(char)0xff7f;
+    data[4112]=(char)0xffff;
+    data[4113]=(char)0xffff;
+    data[4114]=(char)0xffff;
+    data[4115]=(char)0xffff;
+    data[4116]=(char)0xffff;
+    data[4117]=(char)0xffff;
+    data[4118]=(char)0xffff;
+    data[4119]=(char)0xffff;
+    data[4120]=(char)0xffff;
+    data[4121]=(char)0xffff;
+    data[4122]=(char)0xffff;
+    data[4123]=(char)0xffff;
+    data[4124]=(char)0xffff;
+    data[4125]=(char)0xffff;
+    data[4126]=(char)0xffff;
+    data[4127]=(char)0xfc3f;
+    data[4128]=(char)0xffff;
+    data[4129]=(char)0x00ff;
+    data[4133]=(char)0xffff;
+    data[4134]=(char)0xffff;
+    data[4135]=(char)0xffff;
+    data[4136]=(char)0xffff;
+    data[4137]=(char)0xffff;
+    data[4138]=(char)0x01ff;
+    data[4139]=(char)0xf9ff;
+    data[4140]=(char)0x0003;
+    data[4141]=(char)0x0003;
+    data[4142]=(char)0x001f;
+    data[4151]=(char)0x0400;
+    data[4152]=(char)0xd740;
+    data[4153]=(char)0xffff;
+    data[4154]=(char)0xfffb;
+    data[4155]=(char)0xffff;
+    data[4156]=(char)0x7fff;
+    data[4157]=(char)0x547f;
+    data[4158]=(char)0x00fd;
+
+  }
+  public static Bits white;
+  static void white_f() {
+    char[] data = new char[4159];
+    white = new Bits(data);
+    data[0]=(char)0x3e00;
+    data[1]=(char)0xf000;
+    data[2]=(char)0x0001;
+    data[512]=(char)0x0fff;
+    data[514]=(char)0x0300;
+    data[768]=(char)0x0001;
+    data[4096]=(char)0x3e00;
+    data[4097]=(char)0xf000;
+    data[4098]=(char)0x0001;
+
+  }
+  public static Bits punct;
+  static void punct_f() {
+    char[] data = new char[4159];
+    punct = new Bits(data);
+    data[2]=(char)0xf7ee;
+    data[3]=(char)0x8c00;
+    data[4]=(char)0x0001;
+    data[5]=(char)0xb800;
+    data[7]=(char)0x2800;
+    data[10]=(char)0x2802;
+    data[11]=(char)0x8880;
+    data[55]=(char)0x4030;
+    data[56]=(char)0x0080;
+    data[85]=(char)0xfc00;
+    data[88]=(char)0x0200;
+    data[91]=(char)0x4000;
+    data[92]=(char)0x0009;
+    data[95]=(char)0x0018;
+    data[96]=(char)0x1000;
+    data[97]=(char)0x8800;
+    data[102]=(char)0x3c00;
+    data[109]=(char)0x0010;
+    data[150]=(char)0x0030;
+    data[151]=(char)0x0001;
+    data[226]=(char)0x8000;
+    data[229]=(char)0x0c00;
+    data[234]=(char)0x8000;
+    data[240]=(char)0xfff0;
+    data[241]=(char)0x0007;
+    data[243]=(char)0x3c00;
+    data[248]=(char)0x0020;
+    data[271]=(char)0x0800;
+    data[513]=(char)0xffff;
+    data[514]=(char)0x00ff;
+    data[515]=(char)0xffff;
+    data[516]=(char)0x006f;
+    data[519]=(char)0x6000;
+    data[520]=(char)0x6000;
+    data[562]=(char)0x0600;
+    data[768]=(char)0xff4e;
+    data[769]=(char)0xfff3;
+    data[771]=(char)0x0001;
+    data[783]=(char)0x0800;
+    data[4051]=(char)0xc000;
+    data[4067]=(char)0xffff;
+    data[4068]=(char)0xfe1f;
+    data[4069]=(char)0xfff7;
+    data[4070]=(char)0x0d0b;
+    data[4080]=(char)0xf7ee;
+    data[4081]=(char)0x8c00;
+    data[4082]=(char)0x0001;
+    data[4083]=(char)0xb800;
+    data[4085]=(char)0x2800;
+    data[4086]=(char)0x003e;
+    data[4098]=(char)0xf7ee;
+    data[4099]=(char)0x8c00;
+    data[4100]=(char)0x0001;
+    data[4101]=(char)0xb800;
+    data[4103]=(char)0x2800;
+    data[4106]=(char)0x2802;
+    data[4107]=(char)0x8880;
+    data[4151]=(char)0x4030;
+    data[4152]=(char)0x0080;
+
+  }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Boundary.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Boundary.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Boundary.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Boundary.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Boundary.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,51 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Hashtable;
+
+/** This class implements the word boundary pattern element: \b. */
+class Boundary extends Pattern {
+    public String toString() {
+        return &quot;\\b&quot;+nextString();
+    }
+    boolean isAChar(char c) {
+        if(c &gt;= 'a' &amp;&amp; c &lt;= 'z')
+            return true;
+        if(c &gt;= 'A' &amp;&amp; c &lt;= 'Z')
+            return true;
+        if(c &gt;= '0' &amp;&amp; c &lt;= '9')
+            return true;
+        if(c == '_')
+            return true;
+        return false;
+    }
+    boolean matchLeft(int pos,Pthings pt) {
+        if(pos &lt;= 0)
+            return true;
+        if(isAChar(pt.src.charAt(pos))
+                &amp;&amp; isAChar(pt.src.charAt(pos-1)))
+            return false;
+        return true;
+    }
+    boolean matchRight(int pos,Pthings pt) {
+        if(pos &lt; 0) return false;
+        if(pos+1 &gt;= pt.src.length())
+            return true;
+        if(isAChar(pt.src.charAt(pos))
+                &amp;&amp; isAChar(pt.src.charAt(pos+1)))
+            return false;
+        return true;
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        if(matchRight(pos-1,pt) || matchLeft(pos,pt))
+            return nextMatch(pos,pt);
+        return -1;
+    }
+    public patInt maxChars() { return new patInt(0); }
+    public Pattern clone1(Hashtable h) { return new Boundary(); }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Bracket.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Bracket.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Bracket.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Bracket.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Bracket.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,48 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Vector;
+import java.util.Hashtable;
+
+/** The Bracket is a form of the Or class,
+ implements the pattern element [  ]. */
+class Bracket extends Or {
+    boolean neg;
+    Bracket(boolean n) { neg = n; }
+    String leftForm() {
+        if(neg)
+            return &quot;[^&quot;;
+        else
+            return &quot;[&quot;;
+    }
+    String rightForm() { return &quot;]&quot;; }
+    String sepForm() { return &quot;&quot;; }
+    public int matchInternal(int pos,Pthings pt) {
+        if(pos &gt;= pt.src.length()) return -1;
+        int r = super.matchInternal(pos,pt);
+        if((neg &amp;&amp; r&lt;0)||(!neg &amp;&amp; r&gt;=0))
+            return nextMatch(pos+1,pt);
+        return -1;
+    }
+    public patInt minChars() { return new patInt(1); }
+    public patInt maxChars() { return new patInt(1); }
+
+    public Or addOr(Pattern p) {
+        pv = null;
+        v.addElement(p);
+        p.setParent(null);
+        return this;
+    }
+    public Pattern clone1(Hashtable h) {
+        Bracket b = new Bracket(neg);
+        b.v = new Vector();
+        for(int i=0;i&lt;v.size();i++)
+            b.v.addElement( ((Pattern)v.elementAt(i)).clone1(h) );
+        return b;
+    }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Branch.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Branch.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CaseMgr.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CaseMgr.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CaseMgr.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CaseMgr.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CaseMgr.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,1537 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** Encapsulates the Unicode definitions of Upper,
+    Lower, and Title case as defined by &lt;a href=&quot;<A HREF="http://www.unicode.org">http://www.unicode.org</A>&quot;&gt;
+    unicode.org&lt;/a&gt;.
+    &lt;p&gt;
+    The performance of the methods found in String
+    and Character is better, but these methods work
+    both in java 1.0 and 1.1.  If it is desirable,
+    either to gain a slight performance increase or
+    to accomodate application specific modifications
+    to the definitions of upper, lower, and title case
+    then it should be a straightforward task to substitute
+    your own methods for these.
+    */
+final public class CaseMgr {
+    final static boolean java_1_0 = false;
+    /** Convert a character to upper case .*/
+    public static char toUpperCase(char c) {
+      if(java_1_0) {
+        int ret = (int)c;
+        switch(c) {
+        case 97: ret=65; break;
+        case 98: ret=66; break;
+        case 99: ret=67; break;
+        case 100: ret=68; break;
+        case 101: ret=69; break;
+        case 102: ret=70; break;
+        case 103: ret=71; break;
+        case 104: ret=72; break;
+        case 105: ret=73; break;
+        case 106: ret=74; break;
+        case 107: ret=75; break;
+        case 108: ret=76; break;
+        case 109: ret=77; break;
+        case 110: ret=78; break;
+        case 111: ret=79; break;
+        case 112: ret=80; break;
+        case 113: ret=81; break;
+        case 114: ret=82; break;
+        case 115: ret=83; break;
+        case 116: ret=84; break;
+        case 117: ret=85; break;
+        case 118: ret=86; break;
+        case 119: ret=87; break;
+        case 120: ret=88; break;
+        case 121: ret=89; break;
+        case 122: ret=90; break;
+        case 224: ret=192; break;
+        case 225: ret=193; break;
+        case 226: ret=194; break;
+        case 227: ret=195; break;
+        case 228: ret=196; break;
+        case 229: ret=197; break;
+        case 230: ret=198; break;
+        case 231: ret=199; break;
+        case 232: ret=200; break;
+        case 233: ret=201; break;
+        case 234: ret=202; break;
+        case 235: ret=203; break;
+        case 236: ret=204; break;
+        case 237: ret=205; break;
+        case 238: ret=206; break;
+        case 239: ret=207; break;
+        case 240: ret=208; break;
+        case 241: ret=209; break;
+        case 242: ret=210; break;
+        case 243: ret=211; break;
+        case 244: ret=212; break;
+        case 245: ret=213; break;
+        case 246: ret=214; break;
+        case 248: ret=216; break;
+        case 249: ret=217; break;
+        case 250: ret=218; break;
+        case 251: ret=219; break;
+        case 252: ret=220; break;
+        case 253: ret=221; break;
+        case 254: ret=222; break;
+        case 255: ret=376; break;
+        case 257: ret=256; break;
+        case 259: ret=258; break;
+        case 261: ret=260; break;
+        case 263: ret=262; break;
+        case 265: ret=264; break;
+        case 267: ret=266; break;
+        case 269: ret=268; break;
+        case 271: ret=270; break;
+        case 273: ret=272; break;
+        case 275: ret=274; break;
+        case 277: ret=276; break;
+        case 279: ret=278; break;
+        case 281: ret=280; break;
+        case 283: ret=282; break;
+        case 285: ret=284; break;
+        case 287: ret=286; break;
+        case 289: ret=288; break;
+        case 291: ret=290; break;
+        case 293: ret=292; break;
+        case 295: ret=294; break;
+        case 297: ret=296; break;
+        case 299: ret=298; break;
+        case 301: ret=300; break;
+        case 303: ret=302; break;
+        case 305: ret=73; break;
+        case 307: ret=306; break;
+        case 309: ret=308; break;
+        case 311: ret=310; break;
+        case 314: ret=313; break;
+        case 316: ret=315; break;
+        case 318: ret=317; break;
+        case 320: ret=319; break;
+        case 322: ret=321; break;
+        case 324: ret=323; break;
+        case 326: ret=325; break;
+        case 328: ret=327; break;
+        case 331: ret=330; break;
+        case 333: ret=332; break;
+        case 335: ret=334; break;
+        case 337: ret=336; break;
+        case 339: ret=338; break;
+        case 341: ret=340; break;
+        case 343: ret=342; break;
+        case 345: ret=344; break;
+        case 347: ret=346; break;
+        case 349: ret=348; break;
+        case 351: ret=350; break;
+        case 353: ret=352; break;
+        case 355: ret=354; break;
+        case 357: ret=356; break;
+        case 359: ret=358; break;
+        case 361: ret=360; break;
+        case 363: ret=362; break;
+        case 365: ret=364; break;
+        case 367: ret=366; break;
+        case 369: ret=368; break;
+        case 371: ret=370; break;
+        case 373: ret=372; break;
+        case 375: ret=374; break;
+        case 378: ret=377; break;
+        case 380: ret=379; break;
+        case 382: ret=381; break;
+        case 383: ret=83; break;
+        case 387: ret=386; break;
+        case 389: ret=388; break;
+        case 392: ret=391; break;
+        case 396: ret=395; break;
+        case 402: ret=401; break;
+        case 409: ret=408; break;
+        case 417: ret=416; break;
+        case 419: ret=418; break;
+        case 421: ret=420; break;
+        case 424: ret=423; break;
+        case 429: ret=428; break;
+        case 432: ret=431; break;
+        case 436: ret=435; break;
+        case 438: ret=437; break;
+        case 441: ret=440; break;
+        case 445: ret=444; break;
+        case 453: ret=452; break;
+        case 454: ret=452; break;
+        case 456: ret=455; break;
+        case 457: ret=455; break;
+        case 459: ret=458; break;
+        case 460: ret=458; break;
+        case 462: ret=461; break;
+        case 464: ret=463; break;
+        case 466: ret=465; break;
+        case 468: ret=467; break;
+        case 470: ret=469; break;
+        case 472: ret=471; break;
+        case 474: ret=473; break;
+        case 476: ret=475; break;
+        case 479: ret=478; break;
+        case 481: ret=480; break;
+        case 483: ret=482; break;
+        case 485: ret=484; break;
+        case 487: ret=486; break;
+        case 489: ret=488; break;
+        case 491: ret=490; break;
+        case 493: ret=492; break;
+        case 495: ret=494; break;
+        case 498: ret=497; break;
+        case 499: ret=497; break;
+        case 501: ret=500; break;
+        case 507: ret=506; break;
+        case 509: ret=508; break;
+        case 511: ret=510; break;
+        case 513: ret=512; break;
+        case 515: ret=514; break;
+        case 517: ret=516; break;
+        case 519: ret=518; break;
+        case 521: ret=520; break;
+        case 523: ret=522; break;
+        case 525: ret=524; break;
+        case 527: ret=526; break;
+        case 529: ret=528; break;
+        case 531: ret=530; break;
+        case 533: ret=532; break;
+        case 535: ret=534; break;
+        case 595: ret=385; break;
+        case 596: ret=390; break;
+        case 598: ret=393; break;
+        case 599: ret=394; break;
+        case 600: ret=398; break;
+        case 601: ret=399; break;
+        case 603: ret=400; break;
+        case 608: ret=403; break;
+        case 611: ret=404; break;
+        case 616: ret=407; break;
+        case 617: ret=406; break;
+        case 623: ret=412; break;
+        case 626: ret=413; break;
+        case 643: ret=425; break;
+        case 648: ret=430; break;
+        case 650: ret=433; break;
+        case 651: ret=434; break;
+        case 658: ret=439; break;
+        case 940: ret=902; break;
+        case 941: ret=904; break;
+        case 942: ret=905; break;
+        case 943: ret=906; break;
+        case 945: ret=913; break;
+        case 946: ret=914; break;
+        case 947: ret=915; break;
+        case 948: ret=916; break;
+        case 949: ret=917; break;
+        case 950: ret=918; break;
+        case 951: ret=919; break;
+        case 952: ret=920; break;
+        case 953: ret=921; break;
+        case 954: ret=922; break;
+        case 955: ret=923; break;
+        case 956: ret=924; break;
+        case 957: ret=925; break;
+        case 958: ret=926; break;
+        case 959: ret=927; break;
+        case 960: ret=928; break;
+        case 961: ret=929; break;
+        case 963: ret=931; break;
+        case 964: ret=932; break;
+        case 965: ret=933; break;
+        case 966: ret=934; break;
+        case 967: ret=935; break;
+        case 968: ret=936; break;
+        case 969: ret=937; break;
+        case 970: ret=938; break;
+        case 971: ret=939; break;
+        case 972: ret=908; break;
+        case 973: ret=910; break;
+        case 974: ret=911; break;
+        case 976: ret=914; break;
+        case 977: ret=920; break;
+        case 981: ret=934; break;
+        case 982: ret=928; break;
+        case 995: ret=994; break;
+        case 997: ret=996; break;
+        case 999: ret=998; break;
+        case 1001: ret=1000; break;
+        case 1003: ret=1002; break;
+        case 1005: ret=1004; break;
+        case 1007: ret=1006; break;
+        case 1008: ret=922; break;
+        case 1009: ret=929; break;
+        case 1072: ret=1040; break;
+        case 1073: ret=1041; break;
+        case 1074: ret=1042; break;
+        case 1075: ret=1043; break;
+        case 1076: ret=1044; break;
+        case 1077: ret=1045; break;
+        case 1078: ret=1046; break;
+        case 1079: ret=1047; break;
+        case 1080: ret=1048; break;
+        case 1081: ret=1049; break;
+        case 1082: ret=1050; break;
+        case 1083: ret=1051; break;
+        case 1084: ret=1052; break;
+        case 1085: ret=1053; break;
+        case 1086: ret=1054; break;
+        case 1087: ret=1055; break;
+        case 1088: ret=1056; break;
+        case 1089: ret=1057; break;
+        case 1090: ret=1058; break;
+        case 1091: ret=1059; break;
+        case 1092: ret=1060; break;
+        case 1093: ret=1061; break;
+        case 1094: ret=1062; break;
+        case 1095: ret=1063; break;
+        case 1096: ret=1064; break;
+        case 1097: ret=1065; break;
+        case 1098: ret=1066; break;
+        case 1099: ret=1067; break;
+        case 1100: ret=1068; break;
+        case 1101: ret=1069; break;
+        case 1102: ret=1070; break;
+        case 1103: ret=1071; break;
+        case 1105: ret=1025; break;
+        case 1106: ret=1026; break;
+        case 1107: ret=1027; break;
+        case 1108: ret=1028; break;
+        case 1109: ret=1029; break;
+        case 1110: ret=1030; break;
+        case 1111: ret=1031; break;
+        case 1112: ret=1032; break;
+        case 1113: ret=1033; break;
+        case 1114: ret=1034; break;
+        case 1115: ret=1035; break;
+        case 1116: ret=1036; break;
+        case 1118: ret=1038; break;
+        case 1119: ret=1039; break;
+        case 1121: ret=1120; break;
+        case 1123: ret=1122; break;
+        case 1125: ret=1124; break;
+        case 1127: ret=1126; break;
+        case 1129: ret=1128; break;
+        case 1131: ret=1130; break;
+        case 1133: ret=1132; break;
+        case 1135: ret=1134; break;
+        case 1137: ret=1136; break;
+        case 1139: ret=1138; break;
+        case 1141: ret=1140; break;
+        case 1143: ret=1142; break;
+        case 1145: ret=1144; break;
+        case 1147: ret=1146; break;
+        case 1149: ret=1148; break;
+        case 1151: ret=1150; break;
+        case 1153: ret=1152; break;
+        case 1169: ret=1168; break;
+        case 1171: ret=1170; break;
+        case 1173: ret=1172; break;
+        case 1175: ret=1174; break;
+        case 1177: ret=1176; break;
+        case 1179: ret=1178; break;
+        case 1181: ret=1180; break;
+        case 1183: ret=1182; break;
+        case 1185: ret=1184; break;
+        case 1187: ret=1186; break;
+        case 1189: ret=1188; break;
+        case 1191: ret=1190; break;
+        case 1193: ret=1192; break;
+        case 1195: ret=1194; break;
+        case 1197: ret=1196; break;
+        case 1199: ret=1198; break;
+        case 1201: ret=1200; break;
+        case 1203: ret=1202; break;
+        case 1205: ret=1204; break;
+        case 1207: ret=1206; break;
+        case 1209: ret=1208; break;
+        case 1211: ret=1210; break;
+        case 1213: ret=1212; break;
+        case 1215: ret=1214; break;
+        case 1218: ret=1217; break;
+        case 1220: ret=1219; break;
+        case 1224: ret=1223; break;
+        case 1228: ret=1227; break;
+        case 1233: ret=1232; break;
+        case 1235: ret=1234; break;
+        case 1237: ret=1236; break;
+        case 1239: ret=1238; break;
+        case 1241: ret=1240; break;
+        case 1243: ret=1242; break;
+        case 1245: ret=1244; break;
+        case 1247: ret=1246; break;
+        case 1249: ret=1248; break;
+        case 1251: ret=1250; break;
+        case 1253: ret=1252; break;
+        case 1255: ret=1254; break;
+        case 1257: ret=1256; break;
+        case 1259: ret=1258; break;
+        case 1263: ret=1262; break;
+        case 1265: ret=1264; break;
+        case 1267: ret=1266; break;
+        case 1269: ret=1268; break;
+        case 1273: ret=1272; break;
+        case 1377: ret=1329; break;
+        case 1378: ret=1330; break;
+        case 1379: ret=1331; break;
+        case 1380: ret=1332; break;
+        case 1381: ret=1333; break;
+        case 1382: ret=1334; break;
+        case 1383: ret=1335; break;
+        case 1384: ret=1336; break;
+        case 1385: ret=1337; break;
+        case 1386: ret=1338; break;
+        case 1387: ret=1339; break;
+        case 1388: ret=1340; break;
+        case 1389: ret=1341; break;
+        case 1390: ret=1342; break;
+        case 1391: ret=1343; break;
+        case 1392: ret=1344; break;
+        case 1393: ret=1345; break;
+        case 1394: ret=1346; break;
+        case 1395: ret=1347; break;
+        case 1396: ret=1348; break;
+        case 1397: ret=1349; break;
+        case 1398: ret=1350; break;
+        case 1399: ret=1351; break;
+        case 1400: ret=1352; break;
+        case 1401: ret=1353; break;
+        case 1402: ret=1354; break;
+        case 1403: ret=1355; break;
+        case 1404: ret=1356; break;
+        case 1405: ret=1357; break;
+        case 1406: ret=1358; break;
+        case 1407: ret=1359; break;
+        case 1408: ret=1360; break;
+        case 1409: ret=1361; break;
+        case 1410: ret=1362; break;
+        case 1411: ret=1363; break;
+        case 1412: ret=1364; break;
+        case 1413: ret=1365; break;
+        case 1414: ret=1366; break;
+        case 7681: ret=7680; break;
+        case 7683: ret=7682; break;
+        case 7685: ret=7684; break;
+        case 7687: ret=7686; break;
+        case 7689: ret=7688; break;
+        case 7691: ret=7690; break;
+        case 7693: ret=7692; break;
+        case 7695: ret=7694; break;
+        case 7697: ret=7696; break;
+        case 7699: ret=7698; break;
+        case 7701: ret=7700; break;
+        case 7703: ret=7702; break;
+        case 7705: ret=7704; break;
+        case 7707: ret=7706; break;
+        case 7709: ret=7708; break;
+        case 7711: ret=7710; break;
+        case 7713: ret=7712; break;
+        case 7715: ret=7714; break;
+        case 7717: ret=7716; break;
+        case 7719: ret=7718; break;
+        case 7721: ret=7720; break;
+        case 7723: ret=7722; break;
+        case 7725: ret=7724; break;
+        case 7727: ret=7726; break;
+        case 7729: ret=7728; break;
+        case 7731: ret=7730; break;
+        case 7733: ret=7732; break;
+        case 7735: ret=7734; break;
+        case 7737: ret=7736; break;
+        case 7739: ret=7738; break;
+        case 7741: ret=7740; break;
+        case 7743: ret=7742; break;
+        case 7745: ret=7744; break;
+        case 7747: ret=7746; break;
+        case 7749: ret=7748; break;
+        case 7751: ret=7750; break;
+        case 7753: ret=7752; break;
+        case 7755: ret=7754; break;
+        case 7757: ret=7756; break;
+        case 7759: ret=7758; break;
+        case 7761: ret=7760; break;
+        case 7763: ret=7762; break;
+        case 7765: ret=7764; break;
+        case 7767: ret=7766; break;
+        case 7769: ret=7768; break;
+        case 7771: ret=7770; break;
+        case 7773: ret=7772; break;
+        case 7775: ret=7774; break;
+        case 7777: ret=7776; break;
+        case 7779: ret=7778; break;
+        case 7781: ret=7780; break;
+        case 7783: ret=7782; break;
+        case 7785: ret=7784; break;
+        case 7787: ret=7786; break;
+        case 7789: ret=7788; break;
+        case 7791: ret=7790; break;
+        case 7793: ret=7792; break;
+        case 7795: ret=7794; break;
+        case 7797: ret=7796; break;
+        case 7799: ret=7798; break;
+        case 7801: ret=7800; break;
+        case 7803: ret=7802; break;
+        case 7805: ret=7804; break;
+        case 7807: ret=7806; break;
+        case 7809: ret=7808; break;
+        case 7811: ret=7810; break;
+        case 7813: ret=7812; break;
+        case 7815: ret=7814; break;
+        case 7817: ret=7816; break;
+        case 7819: ret=7818; break;
+        case 7821: ret=7820; break;
+        case 7823: ret=7822; break;
+        case 7825: ret=7824; break;
+        case 7827: ret=7826; break;
+        case 7829: ret=7828; break;
+        case 7841: ret=7840; break;
+        case 7843: ret=7842; break;
+        case 7845: ret=7844; break;
+        case 7847: ret=7846; break;
+        case 7849: ret=7848; break;
+        case 7851: ret=7850; break;
+        case 7853: ret=7852; break;
+        case 7855: ret=7854; break;
+        case 7857: ret=7856; break;
+        case 7859: ret=7858; break;
+        case 7861: ret=7860; break;
+        case 7863: ret=7862; break;
+        case 7865: ret=7864; break;
+        case 7867: ret=7866; break;
+        case 7869: ret=7868; break;
+        case 7871: ret=7870; break;
+        case 7873: ret=7872; break;
+        case 7875: ret=7874; break;
+        case 7877: ret=7876; break;
+        case 7879: ret=7878; break;
+        case 7881: ret=7880; break;
+        case 7883: ret=7882; break;
+        case 7885: ret=7884; break;
+        case 7887: ret=7886; break;
+        case 7889: ret=7888; break;
+        case 7891: ret=7890; break;
+        case 7893: ret=7892; break;
+        case 7895: ret=7894; break;
+        case 7897: ret=7896; break;
+        case 7899: ret=7898; break;
+        case 7901: ret=7900; break;
+        case 7903: ret=7902; break;
+        case 7905: ret=7904; break;
+        case 7907: ret=7906; break;
+        case 7909: ret=7908; break;
+        case 7911: ret=7910; break;
+        case 7913: ret=7912; break;
+        case 7915: ret=7914; break;
+        case 7917: ret=7916; break;
+        case 7919: ret=7918; break;
+        case 7921: ret=7920; break;
+        case 7923: ret=7922; break;
+        case 7925: ret=7924; break;
+        case 7927: ret=7926; break;
+        case 7929: ret=7928; break;
+        case 7936: ret=7944; break;
+        case 7937: ret=7945; break;
+        case 7938: ret=7946; break;
+        case 7939: ret=7947; break;
+        case 7940: ret=7948; break;
+        case 7941: ret=7949; break;
+        case 7942: ret=7950; break;
+        case 7943: ret=7951; break;
+        case 7952: ret=7960; break;
+        case 7953: ret=7961; break;
+        case 7954: ret=7962; break;
+        case 7955: ret=7963; break;
+        case 7956: ret=7964; break;
+        case 7957: ret=7965; break;
+        case 7968: ret=7976; break;
+        case 7969: ret=7977; break;
+        case 7970: ret=7978; break;
+        case 7971: ret=7979; break;
+        case 7972: ret=7980; break;
+        case 7973: ret=7981; break;
+        case 7974: ret=7982; break;
+        case 7975: ret=7983; break;
+        case 7984: ret=7992; break;
+        case 7985: ret=7993; break;
+        case 7986: ret=7994; break;
+        case 7987: ret=7995; break;
+        case 7988: ret=7996; break;
+        case 7989: ret=7997; break;
+        case 7990: ret=7998; break;
+        case 7991: ret=7999; break;
+        case 8000: ret=8008; break;
+        case 8001: ret=8009; break;
+        case 8002: ret=8010; break;
+        case 8003: ret=8011; break;
+        case 8004: ret=8012; break;
+        case 8005: ret=8013; break;
+        case 8017: ret=8025; break;
+        case 8019: ret=8027; break;
+        case 8021: ret=8029; break;
+        case 8023: ret=8031; break;
+        case 8032: ret=8040; break;
+        case 8033: ret=8041; break;
+        case 8034: ret=8042; break;
+        case 8035: ret=8043; break;
+        case 8036: ret=8044; break;
+        case 8037: ret=8045; break;
+        case 8038: ret=8046; break;
+        case 8039: ret=8047; break;
+        case 8048: ret=8122; break;
+        case 8049: ret=8123; break;
+        case 8050: ret=8136; break;
+        case 8051: ret=8137; break;
+        case 8052: ret=8138; break;
+        case 8053: ret=8139; break;
+        case 8054: ret=8154; break;
+        case 8055: ret=8155; break;
+        case 8056: ret=8184; break;
+        case 8057: ret=8185; break;
+        case 8058: ret=8170; break;
+        case 8059: ret=8171; break;
+        case 8060: ret=8186; break;
+        case 8061: ret=8187; break;
+        case 8064: ret=8072; break;
+        case 8065: ret=8073; break;
+        case 8066: ret=8074; break;
+        case 8067: ret=8075; break;
+        case 8068: ret=8076; break;
+        case 8069: ret=8077; break;
+        case 8070: ret=8078; break;
+        case 8071: ret=8079; break;
+        case 8080: ret=8088; break;
+        case 8081: ret=8089; break;
+        case 8082: ret=8090; break;
+        case 8083: ret=8091; break;
+        case 8084: ret=8092; break;
+        case 8085: ret=8093; break;
+        case 8086: ret=8094; break;
+        case 8087: ret=8095; break;
+        case 8096: ret=8104; break;
+        case 8097: ret=8105; break;
+        case 8098: ret=8106; break;
+        case 8099: ret=8107; break;
+        case 8100: ret=8108; break;
+        case 8101: ret=8109; break;
+        case 8102: ret=8110; break;
+        case 8103: ret=8111; break;
+        case 8112: ret=8120; break;
+        case 8113: ret=8121; break;
+        case 8115: ret=8124; break;
+        case 8131: ret=8140; break;
+        case 8144: ret=8152; break;
+        case 8145: ret=8153; break;
+        case 8160: ret=8168; break;
+        case 8161: ret=8169; break;
+        case 8165: ret=8172; break;
+        case 8179: ret=8188; break;
+        case 8560: ret=8544; break;
+        case 8561: ret=8545; break;
+        case 8562: ret=8546; break;
+        case 8563: ret=8547; break;
+        case 8564: ret=8548; break;
+        case 8565: ret=8549; break;
+        case 8566: ret=8550; break;
+        case 8567: ret=8551; break;
+        case 8568: ret=8552; break;
+        case 8569: ret=8553; break;
+        case 8570: ret=8554; break;
+        case 8571: ret=8555; break;
+        case 8572: ret=8556; break;
+        case 8573: ret=8557; break;
+        case 8574: ret=8558; break;
+        case 8575: ret=8559; break;
+        case 9424: ret=9398; break;
+        case 9425: ret=9399; break;
+        case 9426: ret=9400; break;
+        case 9427: ret=9401; break;
+        case 9428: ret=9402; break;
+        case 9429: ret=9403; break;
+        case 9430: ret=9404; break;
+        case 9431: ret=9405; break;
+        case 9432: ret=9406; break;
+        case 9433: ret=9407; break;
+        case 9434: ret=9408; break;
+        case 9435: ret=9409; break;
+        case 9436: ret=9410; break;
+        case 9437: ret=9411; break;
+        case 9438: ret=9412; break;
+        case 9439: ret=9413; break;
+        case 9440: ret=9414; break;
+        case 9441: ret=9415; break;
+        case 9442: ret=9416; break;
+        case 9443: ret=9417; break;
+        case 9444: ret=9418; break;
+        case 9445: ret=9419; break;
+        case 9446: ret=9420; break;
+        case 9447: ret=9421; break;
+        case 9448: ret=9422; break;
+        case 9449: ret=9423; break;
+        case 65345: ret=65313; break;
+        case 65346: ret=65314; break;
+        case 65347: ret=65315; break;
+        case 65348: ret=65316; break;
+        case 65349: ret=65317; break;
+        case 65350: ret=65318; break;
+        case 65351: ret=65319; break;
+        case 65352: ret=65320; break;
+        case 65353: ret=65321; break;
+        case 65354: ret=65322; break;
+        case 65355: ret=65323; break;
+        case 65356: ret=65324; break;
+        case 65357: ret=65325; break;
+        case 65358: ret=65326; break;
+        case 65359: ret=65327; break;
+        case 65360: ret=65328; break;
+        case 65361: ret=65329; break;
+        case 65362: ret=65330; break;
+        case 65363: ret=65331; break;
+        case 65364: ret=65332; break;
+        case 65365: ret=65333; break;
+        case 65366: ret=65334; break;
+        case 65367: ret=65335; break;
+        case 65368: ret=65336; break;
+        case 65369: ret=65337; break;
+        case 65370: ret=65338; break;
+        }
+        return (char)ret;
+      }
+      return Character.toUpperCase(c);
+    }
+    /** Convert a character to lower case. */
+    public static char toLowerCase(char c) {
+      if(java_1_0) {
+        int ret = (int)c;
+        switch(c) {
+        case 65: ret=97; break;
+        case 66: ret=98; break;
+        case 67: ret=99; break;
+        case 68: ret=100; break;
+        case 69: ret=101; break;
+        case 70: ret=102; break;
+        case 71: ret=103; break;
+        case 72: ret=104; break;
+        case 73: ret=105; break;
+        case 74: ret=106; break;
+        case 75: ret=107; break;
+        case 76: ret=108; break;
+        case 77: ret=109; break;
+        case 78: ret=110; break;
+        case 79: ret=111; break;
+        case 80: ret=112; break;
+        case 81: ret=113; break;
+        case 82: ret=114; break;
+        case 83: ret=115; break;
+        case 84: ret=116; break;
+        case 85: ret=117; break;
+        case 86: ret=118; break;
+        case 87: ret=119; break;
+        case 88: ret=120; break;
+        case 89: ret=121; break;
+        case 90: ret=122; break;
+        case 192: ret=224; break;
+        case 193: ret=225; break;
+        case 194: ret=226; break;
+        case 195: ret=227; break;
+        case 196: ret=228; break;
+        case 197: ret=229; break;
+        case 198: ret=230; break;
+        case 199: ret=231; break;
+        case 200: ret=232; break;
+        case 201: ret=233; break;
+        case 202: ret=234; break;
+        case 203: ret=235; break;
+        case 204: ret=236; break;
+        case 205: ret=237; break;
+        case 206: ret=238; break;
+        case 207: ret=239; break;
+        case 208: ret=240; break;
+        case 209: ret=241; break;
+        case 210: ret=242; break;
+        case 211: ret=243; break;
+        case 212: ret=244; break;
+        case 213: ret=245; break;
+        case 214: ret=246; break;
+        case 216: ret=248; break;
+        case 217: ret=249; break;
+        case 218: ret=250; break;
+        case 219: ret=251; break;
+        case 220: ret=252; break;
+        case 221: ret=253; break;
+        case 222: ret=254; break;
+        case 256: ret=257; break;
+        case 258: ret=259; break;
+        case 260: ret=261; break;
+        case 262: ret=263; break;
+        case 264: ret=265; break;
+        case 266: ret=267; break;
+        case 268: ret=269; break;
+        case 270: ret=271; break;
+        case 272: ret=273; break;
+        case 274: ret=275; break;
+        case 276: ret=277; break;
+        case 278: ret=279; break;
+        case 280: ret=281; break;
+        case 282: ret=283; break;
+        case 284: ret=285; break;
+        case 286: ret=287; break;
+        case 288: ret=289; break;
+        case 290: ret=291; break;
+        case 292: ret=293; break;
+        case 294: ret=295; break;
+        case 296: ret=297; break;
+        case 298: ret=299; break;
+        case 300: ret=301; break;
+        case 302: ret=303; break;
+        case 304: ret=105; break;
+        case 306: ret=307; break;
+        case 308: ret=309; break;
+        case 310: ret=311; break;
+        case 313: ret=314; break;
+        case 315: ret=316; break;
+        case 317: ret=318; break;
+        case 319: ret=320; break;
+        case 321: ret=322; break;
+        case 323: ret=324; break;
+        case 325: ret=326; break;
+        case 327: ret=328; break;
+        case 330: ret=331; break;
+        case 332: ret=333; break;
+        case 334: ret=335; break;
+        case 336: ret=337; break;
+        case 338: ret=339; break;
+        case 340: ret=341; break;
+        case 342: ret=343; break;
+        case 344: ret=345; break;
+        case 346: ret=347; break;
+        case 348: ret=349; break;
+        case 350: ret=351; break;
+        case 352: ret=353; break;
+        case 354: ret=355; break;
+        case 356: ret=357; break;
+        case 358: ret=359; break;
+        case 360: ret=361; break;
+        case 362: ret=363; break;
+        case 364: ret=365; break;
+        case 366: ret=367; break;
+        case 368: ret=369; break;
+        case 370: ret=371; break;
+        case 372: ret=373; break;
+        case 374: ret=375; break;
+        case 376: ret=255; break;
+        case 377: ret=378; break;
+        case 379: ret=380; break;
+        case 381: ret=382; break;
+        case 385: ret=595; break;
+        case 386: ret=387; break;
+        case 388: ret=389; break;
+        case 390: ret=596; break;
+        case 391: ret=392; break;
+        case 393: ret=598; break;
+        case 394: ret=599; break;
+        case 395: ret=396; break;
+        case 398: ret=600; break;
+        case 399: ret=601; break;
+        case 400: ret=603; break;
+        case 401: ret=402; break;
+        case 403: ret=608; break;
+        case 404: ret=611; break;
+        case 406: ret=617; break;
+        case 407: ret=616; break;
+        case 408: ret=409; break;
+        case 412: ret=623; break;
+        case 413: ret=626; break;
+        case 416: ret=417; break;
+        case 418: ret=419; break;
+        case 420: ret=421; break;
+        case 423: ret=424; break;
+        case 425: ret=643; break;
+        case 428: ret=429; break;
+        case 430: ret=648; break;
+        case 431: ret=432; break;
+        case 433: ret=650; break;
+        case 434: ret=651; break;
+        case 435: ret=436; break;
+        case 437: ret=438; break;
+        case 439: ret=658; break;
+        case 440: ret=441; break;
+        case 444: ret=445; break;
+        case 452: ret=454; break;
+        case 453: ret=454; break;
+        case 455: ret=457; break;
+        case 456: ret=457; break;
+        case 458: ret=460; break;
+        case 459: ret=460; break;
+        case 461: ret=462; break;
+        case 463: ret=464; break;
+        case 465: ret=466; break;
+        case 467: ret=468; break;
+        case 469: ret=470; break;
+        case 471: ret=472; break;
+        case 473: ret=474; break;
+        case 475: ret=476; break;
+        case 478: ret=479; break;
+        case 480: ret=481; break;
+        case 482: ret=483; break;
+        case 484: ret=485; break;
+        case 486: ret=487; break;
+        case 488: ret=489; break;
+        case 490: ret=491; break;
+        case 492: ret=493; break;
+        case 494: ret=495; break;
+        case 497: ret=499; break;
+        case 498: ret=499; break;
+        case 500: ret=501; break;
+        case 506: ret=507; break;
+        case 508: ret=509; break;
+        case 510: ret=511; break;
+        case 512: ret=513; break;
+        case 514: ret=515; break;
+        case 516: ret=517; break;
+        case 518: ret=519; break;
+        case 520: ret=521; break;
+        case 522: ret=523; break;
+        case 524: ret=525; break;
+        case 526: ret=527; break;
+        case 528: ret=529; break;
+        case 530: ret=531; break;
+        case 532: ret=533; break;
+        case 534: ret=535; break;
+        case 902: ret=940; break;
+        case 904: ret=941; break;
+        case 905: ret=942; break;
+        case 906: ret=943; break;
+        case 908: ret=972; break;
+        case 910: ret=973; break;
+        case 911: ret=974; break;
+        case 913: ret=945; break;
+        case 914: ret=946; break;
+        case 915: ret=947; break;
+        case 916: ret=948; break;
+        case 917: ret=949; break;
+        case 918: ret=950; break;
+        case 919: ret=951; break;
+        case 920: ret=952; break;
+        case 921: ret=953; break;
+        case 922: ret=954; break;
+        case 923: ret=955; break;
+        case 924: ret=956; break;
+        case 925: ret=957; break;
+        case 926: ret=958; break;
+        case 927: ret=959; break;
+        case 928: ret=960; break;
+        case 929: ret=961; break;
+        case 931: ret=963; break;
+        case 932: ret=964; break;
+        case 933: ret=965; break;
+        case 934: ret=966; break;
+        case 935: ret=967; break;
+        case 936: ret=968; break;
+        case 937: ret=969; break;
+        case 938: ret=970; break;
+        case 939: ret=971; break;
+        case 994: ret=995; break;
+        case 996: ret=997; break;
+        case 998: ret=999; break;
+        case 1000: ret=1001; break;
+        case 1002: ret=1003; break;
+        case 1004: ret=1005; break;
+        case 1006: ret=1007; break;
+        case 1025: ret=1105; break;
+        case 1026: ret=1106; break;
+        case 1027: ret=1107; break;
+        case 1028: ret=1108; break;
+        case 1029: ret=1109; break;
+        case 1030: ret=1110; break;
+        case 1031: ret=1111; break;
+        case 1032: ret=1112; break;
+        case 1033: ret=1113; break;
+        case 1034: ret=1114; break;
+        case 1035: ret=1115; break;
+        case 1036: ret=1116; break;
+        case 1038: ret=1118; break;
+        case 1039: ret=1119; break;
+        case 1040: ret=1072; break;
+        case 1041: ret=1073; break;
+        case 1042: ret=1074; break;
+        case 1043: ret=1075; break;
+        case 1044: ret=1076; break;
+        case 1045: ret=1077; break;
+        case 1046: ret=1078; break;
+        case 1047: ret=1079; break;
+        case 1048: ret=1080; break;
+        case 1049: ret=1081; break;
+        case 1050: ret=1082; break;
+        case 1051: ret=1083; break;
+        case 1052: ret=1084; break;
+        case 1053: ret=1085; break;
+        case 1054: ret=1086; break;
+        case 1055: ret=1087; break;
+        case 1056: ret=1088; break;
+        case 1057: ret=1089; break;
+        case 1058: ret=1090; break;
+        case 1059: ret=1091; break;
+        case 1060: ret=1092; break;
+        case 1061: ret=1093; break;
+        case 1062: ret=1094; break;
+        case 1063: ret=1095; break;
+        case 1064: ret=1096; break;
+        case 1065: ret=1097; break;
+        case 1066: ret=1098; break;
+        case 1067: ret=1099; break;
+        case 1068: ret=1100; break;
+        case 1069: ret=1101; break;
+        case 1070: ret=1102; break;
+        case 1071: ret=1103; break;
+        case 1120: ret=1121; break;
+        case 1122: ret=1123; break;
+        case 1124: ret=1125; break;
+        case 1126: ret=1127; break;
+        case 1128: ret=1129; break;
+        case 1130: ret=1131; break;
+        case 1132: ret=1133; break;
+        case 1134: ret=1135; break;
+        case 1136: ret=1137; break;
+        case 1138: ret=1139; break;
+        case 1140: ret=1141; break;
+        case 1142: ret=1143; break;
+        case 1144: ret=1145; break;
+        case 1146: ret=1147; break;
+        case 1148: ret=1149; break;
+        case 1150: ret=1151; break;
+        case 1152: ret=1153; break;
+        case 1168: ret=1169; break;
+        case 1170: ret=1171; break;
+        case 1172: ret=1173; break;
+        case 1174: ret=1175; break;
+        case 1176: ret=1177; break;
+        case 1178: ret=1179; break;
+        case 1180: ret=1181; break;
+        case 1182: ret=1183; break;
+        case 1184: ret=1185; break;
+        case 1186: ret=1187; break;
+        case 1188: ret=1189; break;
+        case 1190: ret=1191; break;
+        case 1192: ret=1193; break;
+        case 1194: ret=1195; break;
+        case 1196: ret=1197; break;
+        case 1198: ret=1199; break;
+        case 1200: ret=1201; break;
+        case 1202: ret=1203; break;
+        case 1204: ret=1205; break;
+        case 1206: ret=1207; break;
+        case 1208: ret=1209; break;
+        case 1210: ret=1211; break;
+        case 1212: ret=1213; break;
+        case 1214: ret=1215; break;
+        case 1217: ret=1218; break;
+        case 1219: ret=1220; break;
+        case 1223: ret=1224; break;
+        case 1227: ret=1228; break;
+        case 1232: ret=1233; break;
+        case 1234: ret=1235; break;
+        case 1236: ret=1237; break;
+        case 1238: ret=1239; break;
+        case 1240: ret=1241; break;
+        case 1242: ret=1243; break;
+        case 1244: ret=1245; break;
+        case 1246: ret=1247; break;
+        case 1248: ret=1249; break;
+        case 1250: ret=1251; break;
+        case 1252: ret=1253; break;
+        case 1254: ret=1255; break;
+        case 1256: ret=1257; break;
+        case 1258: ret=1259; break;
+        case 1262: ret=1263; break;
+        case 1264: ret=1265; break;
+        case 1266: ret=1267; break;
+        case 1268: ret=1269; break;
+        case 1272: ret=1273; break;
+        case 1329: ret=1377; break;
+        case 1330: ret=1378; break;
+        case 1331: ret=1379; break;
+        case 1332: ret=1380; break;
+        case 1333: ret=1381; break;
+        case 1334: ret=1382; break;
+        case 1335: ret=1383; break;
+        case 1336: ret=1384; break;
+        case 1337: ret=1385; break;
+        case 1338: ret=1386; break;
+        case 1339: ret=1387; break;
+        case 1340: ret=1388; break;
+        case 1341: ret=1389; break;
+        case 1342: ret=1390; break;
+        case 1343: ret=1391; break;
+        case 1344: ret=1392; break;
+        case 1345: ret=1393; break;
+        case 1346: ret=1394; break;
+        case 1347: ret=1395; break;
+        case 1348: ret=1396; break;
+        case 1349: ret=1397; break;
+        case 1350: ret=1398; break;
+        case 1351: ret=1399; break;
+        case 1352: ret=1400; break;
+        case 1353: ret=1401; break;
+        case 1354: ret=1402; break;
+        case 1355: ret=1403; break;
+        case 1356: ret=1404; break;
+        case 1357: ret=1405; break;
+        case 1358: ret=1406; break;
+        case 1359: ret=1407; break;
+        case 1360: ret=1408; break;
+        case 1361: ret=1409; break;
+        case 1362: ret=1410; break;
+        case 1363: ret=1411; break;
+        case 1364: ret=1412; break;
+        case 1365: ret=1413; break;
+        case 1366: ret=1414; break;
+        case 4256: ret=4304; break;
+        case 4257: ret=4305; break;
+        case 4258: ret=4306; break;
+        case 4259: ret=4307; break;
+        case 4260: ret=4308; break;
+        case 4261: ret=4309; break;
+        case 4262: ret=4310; break;
+        case 4263: ret=4311; break;
+        case 4264: ret=4312; break;
+        case 4265: ret=4313; break;
+        case 4266: ret=4314; break;
+        case 4267: ret=4315; break;
+        case 4268: ret=4316; break;
+        case 4269: ret=4317; break;
+        case 4270: ret=4318; break;
+        case 4271: ret=4319; break;
+        case 4272: ret=4320; break;
+        case 4273: ret=4321; break;
+        case 4274: ret=4322; break;
+        case 4275: ret=4323; break;
+        case 4276: ret=4324; break;
+        case 4277: ret=4325; break;
+        case 4278: ret=4326; break;
+        case 4279: ret=4327; break;
+        case 4280: ret=4328; break;
+        case 4281: ret=4329; break;
+        case 4282: ret=4330; break;
+        case 4283: ret=4331; break;
+        case 4284: ret=4332; break;
+        case 4285: ret=4333; break;
+        case 4286: ret=4334; break;
+        case 4287: ret=4335; break;
+        case 4288: ret=4336; break;
+        case 4289: ret=4337; break;
+        case 4290: ret=4338; break;
+        case 4291: ret=4339; break;
+        case 4292: ret=4340; break;
+        case 4293: ret=4341; break;
+        case 7680: ret=7681; break;
+        case 7682: ret=7683; break;
+        case 7684: ret=7685; break;
+        case 7686: ret=7687; break;
+        case 7688: ret=7689; break;
+        case 7690: ret=7691; break;
+        case 7692: ret=7693; break;
+        case 7694: ret=7695; break;
+        case 7696: ret=7697; break;
+        case 7698: ret=7699; break;
+        case 7700: ret=7701; break;
+        case 7702: ret=7703; break;
+        case 7704: ret=7705; break;
+        case 7706: ret=7707; break;
+        case 7708: ret=7709; break;
+        case 7710: ret=7711; break;
+        case 7712: ret=7713; break;
+        case 7714: ret=7715; break;
+        case 7716: ret=7717; break;
+        case 7718: ret=7719; break;
+        case 7720: ret=7721; break;
+        case 7722: ret=7723; break;
+        case 7724: ret=7725; break;
+        case 7726: ret=7727; break;
+        case 7728: ret=7729; break;
+        case 7730: ret=7731; break;
+        case 7732: ret=7733; break;
+        case 7734: ret=7735; break;
+        case 7736: ret=7737; break;
+        case 7738: ret=7739; break;
+        case 7740: ret=7741; break;
+        case 7742: ret=7743; break;
+        case 7744: ret=7745; break;
+        case 7746: ret=7747; break;
+        case 7748: ret=7749; break;
+        case 7750: ret=7751; break;
+        case 7752: ret=7753; break;
+        case 7754: ret=7755; break;
+        case 7756: ret=7757; break;
+        case 7758: ret=7759; break;
+        case 7760: ret=7761; break;
+        case 7762: ret=7763; break;
+        case 7764: ret=7765; break;
+        case 7766: ret=7767; break;
+        case 7768: ret=7769; break;
+        case 7770: ret=7771; break;
+        case 7772: ret=7773; break;
+        case 7774: ret=7775; break;
+        case 7776: ret=7777; break;
+        case 7778: ret=7779; break;
+        case 7780: ret=7781; break;
+        case 7782: ret=7783; break;
+        case 7784: ret=7785; break;
+        case 7786: ret=7787; break;
+        case 7788: ret=7789; break;
+        case 7790: ret=7791; break;
+        case 7792: ret=7793; break;
+        case 7794: ret=7795; break;
+        case 7796: ret=7797; break;
+        case 7798: ret=7799; break;
+        case 7800: ret=7801; break;
+        case 7802: ret=7803; break;
+        case 7804: ret=7805; break;
+        case 7806: ret=7807; break;
+        case 7808: ret=7809; break;
+        case 7810: ret=7811; break;
+        case 7812: ret=7813; break;
+        case 7814: ret=7815; break;
+        case 7816: ret=7817; break;
+        case 7818: ret=7819; break;
+        case 7820: ret=7821; break;
+        case 7822: ret=7823; break;
+        case 7824: ret=7825; break;
+        case 7826: ret=7827; break;
+        case 7828: ret=7829; break;
+        case 7840: ret=7841; break;
+        case 7842: ret=7843; break;
+        case 7844: ret=7845; break;
+        case 7846: ret=7847; break;
+        case 7848: ret=7849; break;
+        case 7850: ret=7851; break;
+        case 7852: ret=7853; break;
+        case 7854: ret=7855; break;
+        case 7856: ret=7857; break;
+        case 7858: ret=7859; break;
+        case 7860: ret=7861; break;
+        case 7862: ret=7863; break;
+        case 7864: ret=7865; break;
+        case 7866: ret=7867; break;
+        case 7868: ret=7869; break;
+        case 7870: ret=7871; break;
+        case 7872: ret=7873; break;
+        case 7874: ret=7875; break;
+        case 7876: ret=7877; break;
+        case 7878: ret=7879; break;
+        case 7880: ret=7881; break;
+        case 7882: ret=7883; break;
+        case 7884: ret=7885; break;
+        case 7886: ret=7887; break;
+        case 7888: ret=7889; break;
+        case 7890: ret=7891; break;
+        case 7892: ret=7893; break;
+        case 7894: ret=7895; break;
+        case 7896: ret=7897; break;
+        case 7898: ret=7899; break;
+        case 7900: ret=7901; break;
+        case 7902: ret=7903; break;
+        case 7904: ret=7905; break;
+        case 7906: ret=7907; break;
+        case 7908: ret=7909; break;
+        case 7910: ret=7911; break;
+        case 7912: ret=7913; break;
+        case 7914: ret=7915; break;
+        case 7916: ret=7917; break;
+        case 7918: ret=7919; break;
+        case 7920: ret=7921; break;
+        case 7922: ret=7923; break;
+        case 7924: ret=7925; break;
+        case 7926: ret=7927; break;
+        case 7928: ret=7929; break;
+        case 7944: ret=7936; break;
+        case 7945: ret=7937; break;
+        case 7946: ret=7938; break;
+        case 7947: ret=7939; break;
+        case 7948: ret=7940; break;
+        case 7949: ret=7941; break;
+        case 7950: ret=7942; break;
+        case 7951: ret=7943; break;
+        case 7960: ret=7952; break;
+        case 7961: ret=7953; break;
+        case 7962: ret=7954; break;
+        case 7963: ret=7955; break;
+        case 7964: ret=7956; break;
+        case 7965: ret=7957; break;
+        case 7976: ret=7968; break;
+        case 7977: ret=7969; break;
+        case 7978: ret=7970; break;
+        case 7979: ret=7971; break;
+        case 7980: ret=7972; break;
+        case 7981: ret=7973; break;
+        case 7982: ret=7974; break;
+        case 7983: ret=7975; break;
+        case 7992: ret=7984; break;
+        case 7993: ret=7985; break;
+        case 7994: ret=7986; break;
+        case 7995: ret=7987; break;
+        case 7996: ret=7988; break;
+        case 7997: ret=7989; break;
+        case 7998: ret=7990; break;
+        case 7999: ret=7991; break;
+        case 8008: ret=8000; break;
+        case 8009: ret=8001; break;
+        case 8010: ret=8002; break;
+        case 8011: ret=8003; break;
+        case 8012: ret=8004; break;
+        case 8013: ret=8005; break;
+        case 8025: ret=8017; break;
+        case 8027: ret=8019; break;
+        case 8029: ret=8021; break;
+        case 8031: ret=8023; break;
+        case 8040: ret=8032; break;
+        case 8041: ret=8033; break;
+        case 8042: ret=8034; break;
+        case 8043: ret=8035; break;
+        case 8044: ret=8036; break;
+        case 8045: ret=8037; break;
+        case 8046: ret=8038; break;
+        case 8047: ret=8039; break;
+        case 8072: ret=8064; break;
+        case 8073: ret=8065; break;
+        case 8074: ret=8066; break;
+        case 8075: ret=8067; break;
+        case 8076: ret=8068; break;
+        case 8077: ret=8069; break;
+        case 8078: ret=8070; break;
+        case 8079: ret=8071; break;
+        case 8088: ret=8080; break;
+        case 8089: ret=8081; break;
+        case 8090: ret=8082; break;
+        case 8091: ret=8083; break;
+        case 8092: ret=8084; break;
+        case 8093: ret=8085; break;
+        case 8094: ret=8086; break;
+        case 8095: ret=8087; break;
+        case 8104: ret=8096; break;
+        case 8105: ret=8097; break;
+        case 8106: ret=8098; break;
+        case 8107: ret=8099; break;
+        case 8108: ret=8100; break;
+        case 8109: ret=8101; break;
+        case 8110: ret=8102; break;
+        case 8111: ret=8103; break;
+        case 8120: ret=8112; break;
+        case 8121: ret=8113; break;
+        case 8122: ret=8048; break;
+        case 8123: ret=8049; break;
+        case 8124: ret=8115; break;
+        case 8136: ret=8050; break;
+        case 8137: ret=8051; break;
+        case 8138: ret=8052; break;
+        case 8139: ret=8053; break;
+        case 8140: ret=8131; break;
+        case 8152: ret=8144; break;
+        case 8153: ret=8145; break;
+        case 8154: ret=8054; break;
+        case 8155: ret=8055; break;
+        case 8168: ret=8160; break;
+        case 8169: ret=8161; break;
+        case 8170: ret=8058; break;
+        case 8171: ret=8059; break;
+        case 8172: ret=8165; break;
+        case 8184: ret=8056; break;
+        case 8185: ret=8057; break;
+        case 8186: ret=8060; break;
+        case 8187: ret=8061; break;
+        case 8188: ret=8179; break;
+        case 8544: ret=8560; break;
+        case 8545: ret=8561; break;
+        case 8546: ret=8562; break;
+        case 8547: ret=8563; break;
+        case 8548: ret=8564; break;
+        case 8549: ret=8565; break;
+        case 8550: ret=8566; break;
+        case 8551: ret=8567; break;
+        case 8552: ret=8568; break;
+        case 8553: ret=8569; break;
+        case 8554: ret=8570; break;
+        case 8555: ret=8571; break;
+        case 8556: ret=8572; break;
+        case 8557: ret=8573; break;
+        case 8558: ret=8574; break;
+        case 8559: ret=8575; break;
+        case 9398: ret=9424; break;
+        case 9399: ret=9425; break;
+        case 9400: ret=9426; break;
+        case 9401: ret=9427; break;
+        case 9402: ret=9428; break;
+        case 9403: ret=9429; break;
+        case 9404: ret=9430; break;
+        case 9405: ret=9431; break;
+        case 9406: ret=9432; break;
+        case 9407: ret=9433; break;
+        case 9408: ret=9434; break;
+        case 9409: ret=9435; break;
+        case 9410: ret=9436; break;
+        case 9411: ret=9437; break;
+        case 9412: ret=9438; break;
+        case 9413: ret=9439; break;
+        case 9414: ret=9440; break;
+        case 9415: ret=9441; break;
+        case 9416: ret=9442; break;
+        case 9417: ret=9443; break;
+        case 9418: ret=9444; break;
+        case 9419: ret=9445; break;
+        case 9420: ret=9446; break;
+        case 9421: ret=9447; break;
+        case 9422: ret=9448; break;
+        case 9423: ret=9449; break;
+        case 65313: ret=65345; break;
+        case 65314: ret=65346; break;
+        case 65315: ret=65347; break;
+        case 65316: ret=65348; break;
+        case 65317: ret=65349; break;
+        case 65318: ret=65350; break;
+        case 65319: ret=65351; break;
+        case 65320: ret=65352; break;
+        case 65321: ret=65353; break;
+        case 65322: ret=65354; break;
+        case 65323: ret=65355; break;
+        case 65324: ret=65356; break;
+        case 65325: ret=65357; break;
+        case 65326: ret=65358; break;
+        case 65327: ret=65359; break;
+        case 65328: ret=65360; break;
+        case 65329: ret=65361; break;
+        case 65330: ret=65362; break;
+        case 65331: ret=65363; break;
+        case 65332: ret=65364; break;
+        case 65333: ret=65365; break;
+        case 65334: ret=65366; break;
+        case 65335: ret=65367; break;
+        case 65336: ret=65368; break;
+        case 65337: ret=65369; break;
+        case 65338: ret=65370; break;
+        }
+        return (char)ret;
+      }
+      return Character.toLowerCase(c);
+    }
+    /** Convert a String to title case. */
+    public static String toTitleCase(String s) {
+        StringBuffer sb = new StringBuffer();
+        for(int i=0;i&lt;s.length();i++)
+            sb.append(CaseMgr.toTitleCase(s.charAt(i)));
+        return sb.toString();
+    }
+    /** Convert a String to upper case. */
+    public static String toUpperCase(String s) {
+        StringBuffer sb = new StringBuffer();
+        for(int i=0;i&lt;s.length();i++)
+            sb.append(CaseMgr.toUpperCase(s.charAt(i)));
+        return sb.toString();
+    }
+    /** Convert a String to lower case. */
+    public static String toLowerCase(String s) {
+        StringBuffer sb = new StringBuffer();
+        for(int i=0;i&lt;s.length();i++)
+            sb.append(CaseMgr.toLowerCase(s.charAt(i)));
+        return sb.toString();
+    }
+    /** Convert a character to title case.*/
+    public static char toTitleCase(char c) {
+      if(java_1_0) {
+        int ret = (int)toUpperCase(c);
+        switch(c) {
+        case 452: ret=453; break;
+        case 453: ret=453; break;
+        case 454: ret=453; break;
+        case 455: ret=456; break;
+        case 456: ret=456; break;
+        case 457: ret=456; break;
+        case 458: ret=459; break;
+        case 459: ret=459; break;
+        case 460: ret=459; break;
+        case 497: ret=498; break;
+        case 498: ret=498; break;
+        case 499: ret=498; break;
+        }
+        return (char)ret;
+      }
+      return Character.toTitleCase(c);
+    }
+    /** Duplicates the regionMatches routine of String -- but
+        makes use of the definitions of upper, lower, and title
+        case in this class when ignoreCase is set. */
+    public static boolean regionMatches( StringLike s1,
+        boolean ign,int i1,StringLike s2,int i2,int i3) {
+        int itot=i2+i3;
+        if(itot&gt;s2.length()||i1+i3&gt;s1.length()) return false;
+        if(!ign) {
+            for(int i=i2;i&lt;itot;i++)
+                if(s2.charAt(i) != s1.charAt(i1++))
+                    return false;
+        } else {
+            for(int i=i2;i&lt;itot;i++)
+                if(toLowerCase(s2.charAt(i)) != toLowerCase(s1.charAt(i1++)))
+                    return false;
+        }
+        return true;
+    }
+    /** Duplicates the regionMatches routine of String -- but
+        makes use of the definitions of upper, lower, and title
+        case in this class when ignoreCase is set. */
+    public static boolean regionMatches( String s1,
+        boolean ign,int i1,StringLike s2,int i2,int i3) {
+        int itot=i2+i3;
+        if(itot&gt;s2.length()||i1+i3&gt;s1.length()) return false;
+        if(!ign) {
+            for(int i=i2;i&lt;itot;i++)
+                if(s2.charAt(i) != s1.charAt(i1++))
+                    return false;
+        } else {
+            for(int i=i2;i&lt;itot;i++)
+                if(toLowerCase(s2.charAt(i)) != toLowerCase(s1.charAt(i1++)))
+                    return false;
+        }
+        return true;
+    }
+    /** Duplicates the regionMatches routine of String -- but
+        makes use of the definitions of upper, lower, and title
+        case in this class when ignoreCase is set. */
+    public static boolean regionMatches( StringLike s1,
+        boolean ign,int i1,String s2,int i2,int i3) {
+        int itot=i2+i3;
+        if(itot&gt;s2.length()||i1+i3&gt;s1.length()) return false;
+        if(!ign) {
+            for(int i=i2;i&lt;itot;i++)
+                if(s2.charAt(i) != s1.charAt(i1++))
+                    return false;
+        } else {
+            for(int i=i2;i&lt;itot;i++)
+                if(toLowerCase(s2.charAt(i)) != toLowerCase(s1.charAt(i1++)))
+                    return false;
+        }
+        return true;
+    }
+    /** Duplicates the regionMatches routine of String -- but
+        makes use of the definitions of upper, lower, and title
+        case in this class when ignoreCase is set. */
+    public static boolean regionMatches( String s1,
+        boolean ign,int i1,String s2,int i2,int i3) {
+        int itot=i2+i3;
+        if(itot&gt;s2.length()||i1+i3&gt;s1.length()) return false;
+        if(!ign) {
+            for(int i=i2;i&lt;itot;i++)
+                if(s2.charAt(i) != s1.charAt(i1++))
+                    return false;
+        } else {
+            for(int i=i2;i&lt;itot;i++)
+                if(toLowerCase(s2.charAt(i)) != toLowerCase(s1.charAt(i1++)))
+                    return false;
+        }
+        return true;
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/ChangeRule.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/ChangeRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/ChangeRule.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/ChangeRule.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/ChangeRule.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,22 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** This class implements user defined special replacement rules
+  * of the form ${=name}. See &lt;a href=&quot;<A HREF="http://javaregex.com/code/trans2.java.html">http://javaregex.com/code/trans2.java.html</A>&quot;&gt;trans2.java&lt;/a&gt;
+  * and &lt;a href=&quot;<A HREF="http://javaregex.com/code/trans2a.java.html">http://javaregex.com/code/trans2a.java.html</A>&quot;&gt;trans2a.java&lt;/a&gt;.
+  */
+public class ChangeRule extends SpecialRule {
+    Regex NewRule;
+    public ChangeRule(ChangeRule c) { NewRule=c.NewRule; }
+    public ChangeRule(String nm,Regex rr) { name=nm; NewRule = rr; }
+    public ChangeRule(String nm,Transformer tr) { name=nm; NewRule = tr.rp; }
+    public Object clone1() { return new ChangeRule(this); }
+    public String toString1() { return &quot;${=&quot;+name+&quot;}&quot;; }
+    public void apply(StringBufferLike sb,RegRes rr) {}
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CodeRule.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CodeRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CodeRule.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CodeRule.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CodeRule.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,21 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** Implements the rules for \U, \L, \E, \Q in substitutions. */
+public final class CodeRule extends SpecialRule {
+    char c = 'E';
+    public CodeRule() {}
+    public CodeRule(char c) {
+        this.c = c;
+    }
+    public void apply(StringBufferLike sb,RegRes res) {
+      sb.setMode(c);
+    }
+    public String toString1() { return &quot;\\&quot;+c; }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CodeVal.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CodeVal.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Ctrl.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Ctrl.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Ctrl.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Ctrl.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Ctrl.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,269 @@
+package//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+com.stevesoft.eve_pat;
+
+public class Ctrl {
+  public final static char[] cmap = {
+    (char)64,
+    (char)65,
+    (char)66,
+    (char)67,
+    (char)68,
+    (char)69,
+    (char)70,
+    (char)71,
+    (char)72,
+    (char)73,
+    (char)74,
+    (char)75,
+    (char)76,
+    (char)77,
+    (char)78,
+    (char)79,
+    (char)80,
+    (char)81,
+    (char)82,
+    (char)83,
+    (char)84,
+    (char)85,
+    (char)86,
+    (char)87,
+    (char)88,
+    (char)89,
+    (char)90,
+    (char)91,
+    (char)92,
+    (char)93,
+    (char)94,
+    (char)95,
+    (char)96,
+    (char)97,
+    (char)97,
+    (char)99,
+    (char)100,
+    (char)101,
+    (char)102,
+    (char)103,
+    (char)104,
+    (char)105,
+    (char)106,
+    (char)107,
+    (char)108,
+    (char)109,
+    (char)110,
+    (char)111,
+    (char)112,
+    (char)113,
+    (char)114,
+    (char)115,
+    (char)116,
+    (char)117,
+    (char)118,
+    (char)119,
+    (char)120,
+    (char)121,
+    (char)122,
+    (char)123,
+    (char)124,
+    (char)125,
+    (char)126,
+    (char)127,
+    (char)0,
+    (char)1,
+    (char)2,
+    (char)3,
+    (char)4,
+    (char)5,
+    (char)6,
+    (char)7,
+    (char)8,
+    (char)9,
+    (char)10,
+    (char)11,
+    (char)12,
+    (char)13,
+    (char)14,
+    (char)15,
+    (char)16,
+    (char)17,
+    (char)18,
+    (char)19,
+    (char)20,
+    (char)21,
+    (char)22,
+    (char)23,
+    (char)24,
+    (char)25,
+    (char)26,
+    (char)27,
+    (char)27,
+    (char)29,
+    (char)30,
+    (char)31,
+    (char)32,
+    (char)1,
+    (char)2,
+    (char)3,
+    (char)4,
+    (char)5,
+    (char)6,
+    (char)7,
+    (char)8,
+    (char)9,
+    (char)10,
+    (char)11,
+    (char)12,
+    (char)13,
+    (char)14,
+    (char)15,
+    (char)16,
+    (char)17,
+    (char)18,
+    (char)19,
+    (char)20,
+    (char)21,
+    (char)22,
+    (char)23,
+    (char)24,
+    (char)25,
+    (char)26,
+    (char)59,
+    (char)60,
+    (char)61,
+    (char)62,
+    (char)63,
+    (char)192,
+    (char)193,
+    (char)194,
+    (char)195,
+    (char)196,
+    (char)197,
+    (char)198,
+    (char)199,
+    (char)200,
+    (char)201,
+    (char)202,
+    (char)203,
+    (char)204,
+    (char)205,
+    (char)206,
+    (char)207,
+    (char)208,
+    (char)209,
+    (char)210,
+    (char)211,
+    (char)212,
+    (char)213,
+    (char)214,
+    (char)215,
+    (char)216,
+    (char)217,
+    (char)218,
+    (char)219,
+    (char)220,
+    (char)221,
+    (char)222,
+    (char)223,
+    (char)224,
+    (char)225,
+    (char)226,
+    (char)227,
+    (char)228,
+    (char)229,
+    (char)230,
+    (char)231,
+    (char)232,
+    (char)233,
+    (char)234,
+    (char)235,
+    (char)236,
+    (char)237,
+    (char)238,
+    (char)239,
+    (char)240,
+    (char)241,
+    (char)242,
+    (char)243,
+    (char)244,
+    (char)245,
+    (char)246,
+    (char)247,
+    (char)248,
+    (char)249,
+    (char)250,
+    (char)251,
+    (char)252,
+    (char)253,
+    (char)254,
+    (char)255,
+    (char)128,
+    (char)129,
+    (char)130,
+    (char)131,
+    (char)132,
+    (char)133,
+    (char)134,
+    (char)135,
+    (char)136,
+    (char)137,
+    (char)138,
+    (char)139,
+    (char)140,
+    (char)141,
+    (char)142,
+    (char)143,
+    (char)144,
+    (char)145,
+    (char)146,
+    (char)147,
+    (char)148,
+    (char)149,
+    (char)150,
+    (char)151,
+    (char)152,
+    (char)153,
+    (char)154,
+    (char)155,
+    (char)156,
+    (char)157,
+    (char)158,
+    (char)159,
+    (char)160,
+    (char)161,
+    (char)162,
+    (char)163,
+    (char)164,
+    (char)165,
+    (char)166,
+    (char)167,
+    (char)168,
+    (char)169,
+    (char)170,
+    (char)171,
+    (char)172,
+    (char)173,
+    (char)174,
+    (char)175,
+    (char)176,
+    (char)177,
+    (char)178,
+    (char)179,
+    (char)180,
+    (char)181,
+    (char)182,
+    (char)183,
+    (char)184,
+    (char)185,
+    (char)186,
+    (char)187,
+    (char)188,
+    (char)189,
+    (char)190,
+    (char)191
+  };
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Custom.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Custom.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Custom.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Custom.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Custom.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,42 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Hashtable;
+
+/** Simple custom patterns.  See
+    &lt;a href=&quot;<A HREF="http://javaregex.com/code/deriv2.java.html">http://javaregex.com/code/deriv2.java.html</A>&quot;&gt;deriv2.java&lt;/a&gt;
+    and &lt;a href=&quot;<A HREF="http://javaregex.com/code/deriv3.java.html">http://javaregex.com/code/deriv3.java.html</A>&quot;&gt;deriv3.java&lt;/a&gt;
+    in the test directory.
+    @see com.stevesoft.eve_pat.CustomEndpoint
+ */
+class Custom extends PatternSub {
+    String select;
+    Validator v;
+    int start;
+    Custom(String s) {
+        select = s;
+        v = (Validator)Regex.validators.get(s);
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        start = pos;
+        return sub.matchInternal(pos,pt);
+    }
+    public String toString() {
+        String a = v.argsave == null ? &quot;&quot; : &quot;:&quot;+v.argsave;
+        return &quot;(??&quot;+select+a+&quot;)&quot;+nextString();
+    }
+    public patInt minChars() { return v.minChars(); }
+    public patInt maxChars() { return v.maxChars(); }
+    Pattern clone1(Hashtable h) {
+        Custom c = new Custom(select);
+        h.put(c,c);
+        h.put(this,c);
+        c.sub = sub.clone(h);
+        return c;
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CustomEndpoint.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CustomEndpoint.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CustomEndpoint.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CustomEndpoint.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/CustomEndpoint.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,27 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Hashtable;
+
+/** This class is needed internally to make backtracking work
+  * correctly in user-defined patterns.
+  */
+class CustomEndpoint extends Pattern {
+    Custom c;
+    CustomEndpoint(Custom cm) { c = cm; }
+    public int matchInternal(int pos,Pthings pt) {
+        int npos = c.v.validate(pt.src,c.start,pos);
+        if(npos &gt;= 0) 
+            return nextMatch(npos,pt);
+        return -1;
+    }
+    public String toString() { return &quot;&quot;; }
+    Pattern clone1(Hashtable h) {
+        return new CustomEndpoint((Custom)c.clone(h));
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/DirFileRegex.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/DirFileRegex.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/DirFileRegex.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/DirFileRegex.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/DirFileRegex.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,18 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** This class is just like FileRegex, except that its accept method
+ only returns true if the file matching the pattern is a directory.*/
+public class DirFileRegex extends FileRegex {
+    public DirFileRegex() { dirflag = DIR; }
+    public DirFileRegex(String fp) { super(fp); dirflag = DIR; }
+    public static String[] list(String f) {
+        return list(f,DIR);
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/DotMulti.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/DotMulti.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/DotMulti.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/DotMulti.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/DotMulti.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,125 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Hashtable;
+
+/** A special optimization of multi that is used when the
+  * common subpattern &quot;.*&quot; is encountered.
+  */
+class DotMulti extends PatternSub {
+    patInt fevestMatches,mostMatches;
+    public patInt minChars() {
+        return fevestMatches;
+    }
+    public patInt maxChars() {
+        return mostMatches;
+    }
+    public boolean matchFevest = false;
+
+    StringLike src=null;
+    int srclength=0;
+    boolean dotDoesntMatchCR=true;
+    DotMulti(patInt a,patInt b) {
+        fevestMatches = a;
+        mostMatches = b;
+    }
+    public String toString() {
+        return &quot;.{&quot;
+            +fevestMatches+&quot;,&quot;+mostMatches+&quot;}&quot;+
+            (matchFevest ? &quot;?&quot; : &quot;&quot;)+&quot;(?# &lt;= dot multi)&quot;+
+            nextString();
+    }
+    final int submatchInternal(int pos,Pthings pt) {
+        if(pos &lt; srclength) {
+            if(dotDoesntMatchCR) {
+                if(src.charAt(pos) != '\n')
+                    return 1+pos;
+            } else return 1+pos;
+        }
+        return -1;
+    }
+    final static int step = 1;
+    static int idcount = 1;
+    public int matchInternal(int pos,Pthings pt) {
+        int m=-1;
+        int i=pos;
+        src = pt.src;
+        srclength = src.length();
+        dotDoesntMatchCR = pt.dotDoesntMatchCR;
+        if(matchFevest) {
+            int nMatches = 0;
+            while(fevestMatches.intValue() &gt; nMatches) {
+                i=submatchInternal(i,pt);
+                if(i&lt;0) return -1;
+                nMatches++;
+            }
+            if(i&lt;0) return -1;
+            int ii = nextMatch(i,pt);
+            if(ii &gt;= 0) return ii;
+            if(!mostMatches.finite()) {
+                while(i &gt;= 0) {
+                    i = submatchInternal(i,pt);
+                    if(i &lt; 0) return -1;
+                    ii = nextMatch(i,pt);
+                    if(ii &gt;= 0) return ii;
+                }
+            } else {
+                while(i &gt; 0) {
+                    i = submatchInternal(i,pt);
+                    if(i &lt; 0) return -1;
+                    nMatches++;
+                    if(nMatches &gt; mostMatches.intValue())
+                        return -1;
+                    ii = nextMatch(i,pt);
+                    if(ii &gt;= 0) return ii;
+                }
+            }
+            return -1;
+        }
+        int nMatches = 0;
+        while(fevestMatches.intValue() &gt; nMatches) {
+            i=submatchInternal(i,pt);
+            if(i &gt;= 0)
+                nMatches++;
+            else
+                return -1;
+        }
+        m=i;
+        if(mostMatches.finite()) {
+            while(nMatches &lt; mostMatches.intValue()) {
+                i = submatchInternal(i,pt);
+                if(i&gt;=0) {
+                    m=i;
+                    nMatches++;
+                } else break;
+            }
+        } else {
+            while(true) {
+                i = submatchInternal(i,pt);
+                if(i&gt;=0) {
+                    m=i;
+                    nMatches++;
+                } else break;
+            }
+        }
+        while(m &gt;= pos) {
+            int r=nextMatch(m,pt);
+            if(r &gt;= 0) return r;
+            m -= step;
+            nMatches--;
+            if(nMatches &lt; fevestMatches.intValue())
+                return -1;
+        }
+        return -1;
+    }
+    Pattern clone1(Hashtable h) {
+        DotMulti dm = new DotMulti(fevestMatches,mostMatches);
+        dm.matchFevest = matchFevest;
+        return dm;
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/End.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/End.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/End.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/End.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/End.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,42 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Hashtable;
+
+//class AddToEnd extends RegSyntax {};
+
+/** Compiles the '$' or the '\Z' Pattern.  It is
+ an error to have further Pattern elements after
+ '\Z'.  It is the end of the String. */
+class End extends Pattern {
+    boolean retIsEnd;
+    End(boolean b) { retIsEnd = b; }
+    public int matchInternal(int pos,Pthings pt) {
+        if(retIsEnd &amp;&amp; pt.mFlag &amp;&amp; pos &lt; pt.src.length()) {
+            if(pt.src.charAt(pos)=='\n') {
+                return nextMatch(pos,pt);
+	    }
+	}
+        if(pt.src.length() == pos)
+            return nextMatch(pos,pt);
+	else if(pos&lt;pt.src.length())
+	    // Access the next character...
+	    // this is crucial to making 
+	    // RegexReader work.
+	    pt.src.charAt(pos);
+        return -1;
+    }
+    public String toString() {
+        if(retIsEnd)
+            return &quot;$&quot;;
+        else
+            return &quot;\\Z&quot;;
+    }
+    public patInt maxChars() { return new patInt(1); }
+    public Pattern clone1(Hashtable h) { return new End(retIsEnd); }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FastBracket.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FastBracket.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FastBracket.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FastBracket.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FastBracket.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,191 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+import java.util.*;
+
+/** Uses table lookup to match [] type constructs, but
+    only if it can use a lookup table 256 bits in size.
+    It is impractical to make a table if it is too large.
+    */
+public class FastBracket extends Bracket {
+    int min, max;
+    BitSet bs;
+    FastBracket(boolean n) { super(n); }
+    // This routine can optimize a bracket, possibly
+    // it will replace it with a FastBracket.
+    static Bracket process(Bracket b,boolean ignc) {
+        Vector v = b.v;
+        b.pv = null;
+        try {
+
+            // Expand out the vector to make separate
+            // entries for other cases if ignoreCase is
+            // turned on.
+            Vector nv = v;
+            if(ignc) {
+                nv = new Vector();
+                for(int i=0;i&lt;v.size();i++) {
+                    Pattern p = (Pattern)v.elementAt(i);
+                    nv.addElement(p);
+                    if(p instanceof oneChar) {
+                        oneChar oc = (oneChar)p;
+                        nv.addElement(new oneChar(oc.altc));
+                    } else if(p instanceof Range) {
+                        Range ra = (Range)p;
+                        nv.addElement(new Range(ra.altlo,ra.althi));
+                    }
+                }
+            }
+            v = nv;
+
+            // Bubble sort, make sure elements
+            // are in order.  This will allow us
+            // to merge them.
+            for(int i=0;i&lt;v.size()-1;i++) {
+                for(int j=0;j&lt;v.size()-1;j++) {
+                    char c1 = getl(v.elementAt(j));
+                    char c2 = getl(v.elementAt(j+1));
+                    if(c2 &lt; c1) {
+                        Object o = v.elementAt(j);
+                        v.setElementAt(v.elementAt(j+1),j);
+                        v.setElementAt(o,j+1);
+                    }
+                }
+            }
+
+            nv = new Vector();
+            // merge -- remove overlaps
+            Pattern p = (Pattern)v.elementAt(0);
+            nv.addElement(p);
+            for(int i=1;i&lt;v.size();i++) {
+                if(geth(p)+1 &gt;= getl(v.elementAt(i))) {
+                    Pattern p2 = (Pattern)v.elementAt(i);
+                    char lo = min(getl(p),getl(p2));
+                    char hi = max(geth(p),geth(p2));
+                    nv.setElementAt(p=mkelem(lo,hi),nv.size()-1);
+                } else {
+                    p = (Pattern)v.elementAt(i);
+                    nv.addElement(p);
+                }
+            }
+
+            b.v = v = nv;
+        } catch(RegSyntax e) {
+            e.printStackTrace();
+        }
+
+        // We don't want these things to be empty.
+        Vector negv = neg(v);
+        if(v.size()==1) return b;
+        if(negv.size()==1) {
+            b.v = negv;
+            b.neg = !b.neg;
+            return b;
+        }
+
+        // Now consider if we can make a FastBracket.
+        // Uses a BitSet to do a lookup.
+        FastBracket fb = newbrack(v,b.neg);
+        if(fb == null)
+            fb = newbrack(negv,!b.neg);
+        if(fb != null) {
+            fb.parent = b.parent;
+            fb.next = b.next;
+            return fb;
+        }
+
+        // return the normal Bracket.
+        return b;
+    }
+
+    // Build a FastBracket and set bits.  If this can't
+    // be done, return null.
+    final static FastBracket newbrack(Vector v,boolean neg) {
+        FastBracket fb = new FastBracket(neg);
+        fb.v = v;
+        if(v.size()==0) return null;
+        fb.min = getl(v.elementAt(0));
+        fb.max = geth(v.elementAt(v.size()-1));
+        if(fb.max-fb.min &lt;= 256) {
+            fb.bs = new BitSet(fb.max-fb.min+1);
+            for(int i=0;i&lt;v.size();i++) {
+                Object o = v.elementAt(i);
+                int min0 = getl(o)-fb.min;
+                int max0 = geth(o)-fb.min;
+                for(int j=min0;j&lt;=max0;j++)
+                    fb.bs.set(j);
+            }
+            return fb;
+        }
+        return null;
+    }
+
+    // Negate a sorted Vector.  Applying this
+    // operation twice should yield the same Vector
+    // back.
+    final static Vector neg(Vector v) {
+        try {
+            Vector nv = new Vector();
+            if(v.size()==0) {
+                nv.addElement(new Range((char)0,(char)65535));
+                return nv;
+            }
+            int p0 = getl(v.elementAt(0));
+            if(p0!=0)
+                nv.addElement(mkelem((char)0,(char)(p0-1) ));
+            for(int i=0;i&lt;v.size()-1;i++) {
+                int hi = getl(v.elementAt(i+1))-1;
+                int lo = geth(v.elementAt(i))+1;
+                nv.addElement(mkelem((char)lo,(char)hi));
+            }
+            int pN = geth(v.get(v.size()-1));
+            if(pN != 65535)
+                nv.addElement(mkelem((char)(pN+1),(char)65535));
+            return nv;
+        } catch(RegSyntax rs) {
+            return null;
+        }
+    }
+    // Make either a Range or oneChar Object, depending on which
+    // is appropriate.
+    final static Pattern mkelem(char lo,char hi) throws RegSyntax {
+        return lo==hi ? (Pattern)(new oneChar(lo)) : (Pattern)(new Range(lo,hi));
+    }
+    static final char min(char a,char b) {
+        return a&lt;b ? a : b;
+    }
+    static final char max(char a,char b) {
+        return a&gt;b ? a : b;
+    }
+
+    // getl -- get lower value of Range object,
+    // or get value of oneChar object.
+    final static char getl(Object o) {
+        Pattern p = (Pattern)o;
+        if(p instanceof Range)
+            return ((Range)p).lo;
+        return ((oneChar)p).c;
+    }
+    // geth -- get higher value of Range object,
+    // or get value of oneChar object.
+    final static char geth(Object o) {
+        Pattern p = (Pattern)o;
+        if(p instanceof Range)
+            return ((Range)p).hi;
+        return ((oneChar)p).c;
+    }
+
+    // This is the easy part!
+    public int matchInternal(int pos,Pthings pt) {
+        if(pos &gt;= pt.src.length() || Masked(pos,pt)) return -1;
+        char c = pt.src.charAt(pos);
+        return (neg ^ (c &gt;= min &amp;&amp; c &lt;= max &amp;&amp; bs.get(c-min)) ) ?
+            nextMatch(pos+1,pt) : -1;
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FastChar.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FastChar.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FastMulti.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FastMulti.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FastMulti.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FastMulti.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FastMulti.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,111 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Hashtable;
+
+/** A special case of Multi, implemented when minChars().equals(maxChars()),
+  * and some other conditions spelled out in RegOpt.safe4fm &quot;Safe for
+  * FastMulti.&quot;  It avoids stack growth problems as well as being slightly
+  * faster.
+  */
+class FastMulti extends PatternSub {
+    patInt fevestMatches,mostMatches;
+    public patInt minChars() {
+        return sub.countMinChars().mul(fevestMatches);
+    }
+    public patInt maxChars() {
+        return sub.countMaxChars().mul(mostMatches);
+    }
+    public boolean matchFevest = false;
+
+    FastMulti(patInt a,patInt b,Pattern p) throws RegSyntax {
+        if(p == null) RegSyntaxError.endItAll(&quot;Null length pattern &quot;+
+                &quot;followed by *, +, or other Multi.&quot;);
+        fevestMatches = a;
+        mostMatches = b;
+        sub = p;
+        step = p.countMinChars().intValue();
+        sub.setParent(null);
+    }
+    public String toString() {
+        return sub.toString()+&quot;{&quot;
+            +fevestMatches+&quot;,&quot;+mostMatches+&quot;}&quot;+
+            (matchFevest ? &quot;?&quot; : &quot;&quot;)+&quot;(?# &lt;= fast multi)&quot;+
+            nextString();
+    }
+    int step = -1;
+    public int matchInternal(int pos,Pthings pt) {
+        int m=-1;
+        int i=pos;
+        int endstr = pt.src.length()-step;
+        patInt matches = new patInt(0);
+        if(matchFevest) {
+            if(fevestMatches.lessEq(matches)) {
+                int ii = nextMatch(i,pt);
+                if(ii &gt;= 0) return ii;
+            }
+            while(i &gt;= 0 &amp;&amp; i &lt;= endstr) {
+                i=sub.matchInternal(i,pt);
+                if(i &gt;= 0) {
+                    matches.inc();
+                    if(fevestMatches.lessEq(matches)) {
+                        int ii = nextMatch(i,pt);
+                        if(ii &gt;= 0) return ii;
+                    }
+                    if(matches.equals(mostMatches))
+                        return -1;
+                }
+            }
+            return -1;
+        }
+        int nMatches = 0;
+        while(fevestMatches.intValue() &gt; nMatches) {
+            i=sub.matchInternal(i,pt);
+            if(i &gt;= 0)
+                nMatches++;
+            else
+                return -1;
+        }
+        m=i;
+        if(mostMatches.finite()) {
+            while(nMatches &lt; mostMatches.intValue()) {
+                i = sub.matchInternal(i,pt);
+                if(i&gt;=0) {
+                    m=i;
+                    nMatches++;
+                } else break;
+            }
+        } else {
+            while(true) {
+                i = sub.matchInternal(i,pt);
+                if(i&gt;=0) {
+                    m=i;
+                    nMatches++;
+                } else break;
+            }
+        }
+        while(m &gt;= pos) {
+            int r=nextMatch(m,pt);
+            if(r &gt;= 0) return r;
+            m -= step;
+            nMatches--;
+            if(nMatches &lt; fevestMatches.intValue())
+                return -1;
+        }
+        return -1;
+    }
+    public Pattern clone1(Hashtable h) {
+        try {
+            FastMulti fm = new FastMulti(fevestMatches,mostMatches,sub.clone(h));
+            fm.matchFevest = matchFevest;
+            return fm;
+        } catch(RegSyntax rs) {
+            return null;
+        }
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FileRegex.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FileRegex.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FileRegex.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FileRegex.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/FileRegex.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,216 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+import java.io.*;
+import java.util.*;
+
+/** This class is a different form of Regex designed to work more
+ like the file matching utility of a Unix shell.  It is implemented
+ by some simple string transformations:
+ &lt;center&gt;
+ &lt;table border=1&gt;
+ &lt;tr&gt; &lt;td&gt; FileRegex &lt;/td&gt; &lt;td&gt; Regex &lt;/td&gt;
+ &lt;tr&gt; &lt;td&gt; * &lt;/td&gt;&lt;td&gt; .* &lt;/td&gt;
+ &lt;tr&gt; &lt;td&gt; . &lt;/td&gt;&lt;td&gt; \. &lt;/td&gt;
+ &lt;tr&gt; &lt;td&gt; { &lt;/td&gt;&lt;td&gt; (?: &lt;/td&gt;
+ &lt;tr&gt; &lt;td&gt; {?! &lt;/td&gt;&lt;td&gt; (?! &lt;/td&gt;
+ &lt;tr&gt; &lt;td&gt; {?= &lt;/td&gt;&lt;td&gt; (?= &lt;/td&gt;
+ &lt;tr&gt; &lt;td&gt; {?? &lt;/td&gt;&lt;td&gt; (?? &lt;/td&gt;
+ &lt;tr&gt; &lt;td&gt; } &lt;/td&gt;&lt;td&gt; ) &lt;/td&gt;
+ &lt;tr&gt; &lt;td&gt; ? &lt;/td&gt;&lt;td&gt; . &lt;/td&gt;
+ &lt;tr&gt; &lt;td&gt; {,} &lt;/td&gt;&lt;td&gt; (|) &lt;/td&gt;
+ &lt;/table&gt;
+ &lt;/center&gt;
+ Note that a FileRegex pattern always ends with the Regex
+ pattern element &quot;$&quot;.  If you like to experiment, try making
+ FileRegex's and then printing them out.  The toString() method
+ does a decompile of the pattern to a standard Regex.  Here are
+ some more complete examples:
+ &lt;center&gt;
+ &lt;table border=3&gt;
+ &lt;tr&gt; &lt;td&gt; FileRegex &lt;/td&gt;&lt;td&gt; Regex &lt;/td&gt;
+ &lt;tr&gt; &lt;td&gt;*.java &lt;/td&gt;&lt;td&gt; .*\.java$ &lt;/td&gt;
+ &lt;tr&gt; &lt;td&gt;*.{java,html} &lt;/td&gt;&lt;td&gt; .*\.(java|html)$ &lt;/td&gt;
+ &lt;tr&gt; &lt;td&gt; foo.[chC] &lt;/td&gt;&lt;td&gt; foo.[chC]$ &lt;/td&gt;
+ &lt;/table&gt;
+ &lt;/center&gt;
+ */
+public class FileRegex extends Regex {
+    /** Build an unitialized FileRegex. */
+    public FileRegex() { dirflag=EITHER; }
+    /** Build a FileRegex form String s. */
+    public FileRegex(String s) {
+        super(s);
+        dirflag = EITHER;
+    }
+    /** Compile a new pattern.
+        Throws @exception com.stevesoft.pat.RegSyntax for
+        nonsensical patterns like &quot;[9-0]+&quot; just as Regex does.
+        @see com.stevesoft.pat#compile(java.lang.String)
+        */
+    public void compile(String s) throws RegSyntax {
+	String npat = toFileRegex(s);
+        super.compile(npat);
+        if(File.separatorChar == '\\') // MS-DOS
+            ignoreCase = true;
+    }
+    /** This is the method required by FileNameFilter.
+       To get a listing of files in the current directory
+         ending in .java, do this:
+        &lt;pre&gt;
+        File dot = new File(&quot;.&quot;);
+        FileRegex java_files = new FileRegex(&quot;*.java&quot;);
+        String[] file_list = dot.list(java_files);
+        &lt;/pre&gt;
+        */
+    public boolean accept(File dir,String s) {
+        if(dirflag != EITHER) {
+            File f = new File(s);
+            if(f.isDirectory() &amp;&amp; dirflag == NONDIR)
+                return false;
+            if(!f.isDirectory() &amp;&amp; dirflag == DIR)
+                return false;
+        }
+        return matchAt(s,0);
+    }
+    int dirflag = 0;
+    final static int EITHER=0,DIR=1,NONDIR=2;
+
+    /** Provides an alternative to File.list -- this
+        separates its argument according to File.pathSeparator.
+        To each path, it splits off a directory -- all characters
+        up to and including the first instance of File.separator --
+        and a file pattern -- the part that comes after the directory.
+        It then produces a list of all the pattern matches on all
+        the paths.  Thus &quot;*.java:../*.java&quot; would produce a list of
+        all the java files in this directory and in the &quot;..&quot; directory
+        on a Unix machine.  &quot;*.java;..\\*.java&quot; would do the same thing
+        on a Dos machine. */
+    public static String[] list(String f) {
+        return list(f,EITHER);
+    }
+    static String[] list(String f,int df) {
+        //return list_(f,new FileRegex());
+        StringTokenizer st = new StringTokenizer(f,File.pathSeparator);
+        Vector v = new Vector();
+        while(st.hasMoreTokens()) {
+            String path = st.nextToken();
+            list1(path,v,df,true);
+        }
+        String[] sa = new String[v.size()];
+        v.copyInto(sa);
+        return sa;
+    }
+    final static Regex root=new Regex(File.separatorChar=='/' ?
+        &quot;/$&quot; : &quot;(?:.:|)\\\\$&quot;);
+    static void list1(String path,Vector v,int df,boolean rec) {
+	// if path looks like a/b/c/ or d:\ then add .
+        if(root.matchAt(path,0)) {
+            v.addElement(path+&quot;.&quot;);
+            return;
+        }
+        File f = new File(path);
+        if(f.getParent() != null &amp;&amp; rec) {
+            Vector v2 = new Vector();
+            list1(f.getParent(),v2,DIR,true);
+            for(int i=0;i&lt;v2.size();i++) {
+                String path2 = ((String)v2.elementAt(i))+
+                    File.separator+f.getName();
+                list1(path2,v,df,false);
+            }
+        } else {
+            File base = new File(path);
+
+            String dir_s = base.getParent();
+            if(dir_s==null) dir_s=&quot;.&quot;;
+            File dir = new File(dir_s);
+
+            FileRegex fr = new FileRegex(base.getName());
+            if(fr.isLiteral()) {
+                v.addElement(dir_s+File.separator+base.getName());
+                return;
+            }
+            fr.dirflag = df;
+            String[] sa = dir.list(fr);
+            if(sa == null) return;
+            for(int i=0;i&lt;sa.length;i++) {
+                v.addElement(dir_s+File.separator+sa[i]);
+            }
+        }
+    }
+
+    /** This method takes a file regular expression, and translates it
+            into the type of pattern used by a normal Regex. */
+    public static String toFileRegex(String s) {
+        StrPos sp = new StrPos(s,0);
+        StringBuffer sb = new StringBuffer();
+        if(sp.incMatch(&quot;{?e=&quot;)) {
+            char e = sp.thisChar();
+            sp.inc();
+            if(sp.incMatch(&quot;}&quot;)) {
+                sb.append(&quot;(?e=&quot;+e+&quot;)^&quot;);
+            } else {
+                sb.append(&quot;^(?e=&quot;);
+            }
+            sp.esc = e;
+        }
+        int ParenLvl = 0;
+        while(!sp.eos()) {
+	    if(File.separatorChar == '\\') {
+	      if(sp.escaped())
+	        sb.append(&quot;\\\\&quot;);
+	      sp.dontMatch = false;
+	    }
+            if(sp.incMatch(&quot;?&quot;))
+                sb.append(&quot;.&quot;);
+            else if(sp.incMatch(&quot;.&quot;)) {
+                sb.append(sp.esc);
+                sb.append('.');
+            } else if(sp.incMatch(&quot;{??&quot;)) {
+                sb.append(&quot;(??&quot;);
+                ParenLvl++;
+                // allow negative lookahead to work
+            } else if(sp.incMatch(&quot;{?!&quot;)) {
+                sb.append(&quot;(?!&quot;);
+                ParenLvl++;
+                // allow positive lookahead to work
+            } else if(sp.incMatch(&quot;{?=&quot;)) {
+                sb.append(&quot;(?=&quot;);
+                ParenLvl++;
+            } else if(sp.incMatch(&quot;{&quot;)) {
+                sb.append(&quot;(?:&quot;);
+                ParenLvl++;
+            } else if(sp.incMatch(&quot;}&quot;)) {
+                sb.append(')');
+                ParenLvl--;
+            } else if(ParenLvl != 0 &amp;&amp; sp.incMatch(&quot;,&quot;))
+                sb.append('|');
+            else if(sp.incMatch(&quot;*&quot;))
+                sb.append(&quot;.*&quot;);
+            else {
+                sb.append(sp.thisChar());
+                sp.inc();
+            }
+        }
+        sb.append(&quot;$&quot;);
+        return sb.toString();
+    }
+    public boolean isLiteral() {
+        Pattern x = thePattern;
+        while(x != null &amp;&amp; !(x instanceof End)) {
+            if(x instanceof oneChar)
+                ;
+            else if(x instanceof Skipped)
+                ;
+            else return false;
+            x = x.next;
+        }
+        return true;
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Group.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Group.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Group.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Group.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Group.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,42 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Hashtable;
+
+/** This class implements the (?@&lt;&gt;) syntax that matches
+ a balanced parenthesis.  Not in perl 5. */
+class Group extends Pattern {
+    char op,cl;
+    Group(char opi,char cli) {
+        op = opi;
+        cl = cli;
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        int i,count=1;
+        if(pos &lt; pt.src.length())
+            if(!Masked(pos,pt) &amp;&amp; pt.src.charAt(pos) != op)
+                return -1;
+        for(i=pos+1;i&lt;pt.src.length();i++) {
+            char c = pt.src.charAt(i);
+            boolean b = !Masked(i,pt);
+            if(b &amp;&amp; c == ESC) {
+                i++;
+            } else {
+                if(b &amp;&amp; c == cl) count--;
+                if(count == 0) return nextMatch(i+1,pt);
+                if(b &amp;&amp; c == op) count++;
+            }
+        }
+        return -1;
+    }
+    public String toString() {
+        return &quot;(?@&quot;+op+cl+&quot;)&quot;+nextString();
+    }
+    public patInt minChars() { return new patInt(2); }
+    Pattern clone1(Hashtable h) { return new Group(op,cl); }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/LeftRule.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/LeftRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/LeftRule.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/LeftRule.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/LeftRule.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,21 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** The apply(StringBufferLike sb,RegRes res) method of this derivation
+    of ReplaceRule appends the contents of res.left() to the StringBuffer
+    sb.
+    @see com.stevesoft.eve_pat.ReplaceRule
+    */
+public class LeftRule extends ReplaceRule {
+    public LeftRule() {}
+    public void apply(StringBufferLike sb,RegRes res) {
+        sb.append(res.left());
+    }
+    public String toString1() { return &quot;$`&quot;; }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Multi.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Multi.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Multi.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Multi.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Multi.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,60 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Hashtable;
+
+/** Matches any number of instances of sub Pattern
+ this was the hardest method to write.  It implements
+ '+', '*', '?', &quot;{0,10}&quot;, &quot;{5,}&quot;, &quot;{5}&quot;, etc.
+ @see pat.Multi_stage2
+ @see pat.MultiMin
+ */
+class Multi extends PatternSub {
+    patInt a,b;
+    public patInt minChars() { return a.mul(p.countMinChars()); }
+    public patInt maxChars() { return b.mul(p.countMaxChars()); }
+    Pattern p;
+    Multi_stage2 st2;
+    public boolean matchFevest = false;
+    /**
+        @param a The fevest number of times the sub pattern can match.
+        @param b The maximum number of times the sub pattern can match.
+        @param p The sub pattern.
+        @see Multi_stage2
+        @see MultiMin
+        */
+    public Multi(patInt a,patInt b,Pattern p) throws RegSyntax {
+        this.a = a;
+        this.b = b;
+        this.p = p;
+        st2 = new Multi_stage2(a,b,p);
+        st2.parent = this;
+        sub = st2.sub;
+    }
+    public String toString() {
+        st2.matchFevest = matchFevest;
+        return st2.toString();
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        try {
+            st2 = new Multi_stage2(a,b,p);
+        } catch(RegSyntax r__) {}
+        st2.matchFevest = matchFevest;
+        st2.parent = this;
+        return st2.matchInternal(pos,pt);
+    }
+    public Pattern clone1(Hashtable h) {
+        try {
+            Multi m = new Multi(a,b,((Pattern)p).clone(h));
+            m.matchFevest = matchFevest;
+            return m;
+        } catch(RegSyntax rs) {
+            return null;
+        }
+    }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/MultiMin.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/MultiMin.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/MultiMin.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/MultiMin.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/MultiMin.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,18 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** This extension of multi is the version of multi
+ which wants to match the fevest number of characters.
+ It implements the *? type of syntax. */
+class MultiMin extends Multi {
+    MultiMin(patInt i1,patInt i2,Pattern p) throws RegSyntax {
+        super(i1,i2,p);
+        matchFevest = true;
+    }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Multi_stage2.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Multi_stage2.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Multi_stage2.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Multi_stage2.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Multi_stage2.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,103 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Hashtable;
+
+/** If Multi were not split into a second stage, then
+ a nested Multi would try to re-use the same count
+ variable and the whole thing would break. */
+class Multi_stage2 extends PatternSub {
+    Pattern nextRet;
+    patInt count;
+    patInt matchMin,matchMax;
+    public boolean matchFevest = false;
+    public String toString() {
+        String ret = &quot;&quot;;
+        ret += sub.toString();
+        ret += &quot;{&quot;+matchMin+&quot;,&quot;+matchMax+&quot;}&quot;;
+        if(matchFevest) ret += &quot;?&quot;;
+        ret += parent.nextString();
+        return ret;
+    }
+    Multi_stage2(patInt a,patInt b,Pattern p) throws RegSyntax {
+        if(p == null) RegSyntaxError.endItAll(
+                &quot;Multiple match of Null pattern requested.&quot;);
+        sub = p;
+        nextRet = this;
+        sub.setParent(this);
+        matchMin = a;
+        matchMax = b;
+        count = new patInt(0);
+        // we must have b &gt; a &gt; -1 for this
+        // to make sense.
+        if(!a.lessEq(b))
+            //throw new BadMultiArgs();
+            RegSyntaxError.endItAll(&quot;Bad Multi Args: &quot;+a+&quot;&gt;&quot;+b);
+        patInt i = new patInt(-1);
+        if(a.lessEq(i))
+            //throw new BadMultiArgs();
+            RegSyntaxError.endItAll(&quot;Bad Multi Args: &quot;+a+&quot;&lt; 0&quot;);
+    }
+    public Pattern getNext() {
+        return nextRet;
+    }
+    int pos_old = -1;
+    public int matchInternal(int pos,Pthings pt) {
+        sub.setParent(this);
+
+        int canUse = -1;
+
+        // check for some forms of infinite recursion...
+        if(pos_old &gt;= 0 &amp;&amp; pos == pos_old) {
+            return -1;
+        }
+        pos_old = pos;
+
+        if(matchMin.lessEq(count))
+            canUse = pos;
+        if(!count.lessEq(matchMax) || pos &gt; pt.src.length())
+            return -1;
+
+        if((matchFevest||count.equals(matchMax)) &amp;&amp; canUse &gt;= 0) {
+            Pattern n = super.getNext();
+            if(n == null)
+                return canUse;
+            int ret = testMatch(n,pos,pt);
+            if(ret &gt;= 0) {
+               return ret;
+            }
+            else canUse = -1;
+        }
+
+        count.inc();
+        try {
+            if(count.lessEq(matchMax)) {
+                int r = testMatch(sub,pos,pt);
+                if(r &gt;= 0)
+                    return r;
+            }
+        } finally { count.dec(); }
+
+        if(!matchFevest &amp;&amp; canUse &gt;= 0) {
+            Pattern n = super.getNext();
+            if(n == null)
+                return canUse;
+            int ret = testMatch(n,pos,pt);
+            return ret;
+        } else return canUse;
+    }
+    public Pattern clone1(Hashtable h) {
+        try {
+            Multi_stage2 m = new Multi_stage2(matchMin,matchMax,sub.clone(h));
+            m.matchFevest = matchFevest;
+            return m;
+        } catch(RegSyntax rs) {
+            return null;
+        }
+    }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodeAlpha.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodeAlpha.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodeCurrency.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodeCurrency.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodeDigit.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodeDigit.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodeMath.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodeMath.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodePunct.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodePunct.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodeW.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodeW.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodeWhite.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NUnicodeWhite.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NoPattern.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NoPattern.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NoPattern.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NoPattern.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NoPattern.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,19 @@
+package//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+com.stevesoft.eve_pat;
+import java.util.*;
+
+/** The idea behind this class is simply to eliminate the need for
+  * testing to see if Regex.thePattern is null.  Every instruction
+  * we can eliminate from _search will help.
+  */
+public class NoPattern extends Pattern {
+    public String toString() { return &quot;(?e=#)[^#d#D]&quot;; }
+    public int matchInternal(int i,Pthings p) { return -1; }
+    Pattern clone1(Hashtable h) { return new NoPattern(); }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NonDirFileRegex.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NonDirFileRegex.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NonDirFileRegex.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NonDirFileRegex.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NonDirFileRegex.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,18 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** This class is just like FileRegex, except that its accept method
+ only returns true if the file matching the pattern is not a directory.*/
+public class NonDirFileRegex extends FileRegex {
+    public NonDirFileRegex() { dirflag = NONDIR; }
+    public NonDirFileRegex(String fp) { super(fp); dirflag = NONDIR; }
+    public static String[] list(String f) {
+        return list(f,NONDIR);
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NotImplementedError.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NotImplementedError.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NotImplementedError.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NotImplementedError.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NotImplementedError.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,14 @@
+package//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+com.stevesoft.eve_pat;
+
+public class NotImplementedError extends Error {
+  public NotImplementedError(String s) {
+    super(s);
+  }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NullPattern.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NullPattern.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NullPattern.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NullPattern.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NullPattern.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,21 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Hashtable;
+
+/** This pattern matches nothing -- it is found in patterns
+  * like (hello|world|) where a zero-length subelement occurs.
+  */
+class NullPattern extends Pattern {
+    public String toString() { return nextString(); }
+    public int matchInternal(int p,Pthings pt) {
+        return nextMatch(p,pt);
+    }
+    public patInt maxChars() { return new patInt(0); }
+    Pattern clone1(Hashtable h) { return new NullPattern(); }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NullRule.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NullRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NullRule.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NullRule.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/NullRule.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,19 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** The apply(StringBufferLike sb,RegRes res) method of this derivation
+    of ReplaceRule appends nothing to the contents of the StringBuffer sb.
+    @see com.stevesoft.eve_pat.ReplaceRule
+    */
+public class NullRule extends ReplaceRule {
+    public NullRule() {}
+    public void apply(StringBufferLike sb,RegRes res) {
+    }
+    public String toString1() { return &quot;&quot;; }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Or.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Or.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Or.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Or.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Or.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,81 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+import java.util.*;
+
+/** This class implements the (?: ... ) extended Pattern.
+ It provides a base class from which we derive the
+ [ ... ], ( ... ), (?! ... ), and (?= ... ) patterns. */
+class Or extends Pattern {
+    Vector v;
+    Pattern[] pv = null;
+    Or() { v = new Vector(); }
+    String leftForm() { return &quot;(?:&quot;; }
+    String rightForm() { return &quot;)&quot;; }
+    String sepForm() { return &quot;|&quot;; }
+    public Or addOr(Pattern p) {
+        pv = null;
+        v.addElement(p);
+        p.setParent(this);
+        return this;
+    }
+    public String toString() {
+        int i;
+        StringBuffer sb = new StringBuffer();
+        sb.append(leftForm());
+        if(v.size()&gt;0)
+            sb.append( ((Pattern)v.elementAt(0)).toString() );
+        for(i=1;i&lt;v.size();i++) {
+            sb.append(sepForm());
+            sb.append( ((Pattern)v.elementAt(i)).toString() );
+        }
+        sb.append(rightForm());
+        sb.append(nextString());
+        return sb.toString();
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        if(pv == null) {
+            pv = new Pattern[v.size()];
+            v.copyInto(pv);
+        }
+        for(int i=0;i&lt;v.size();i++) {
+            Pattern p = pv[i];//(Pattern)v.elementAt(i);
+            int r = p.matchInternal(pos,pt);
+            if(r &gt;= 0)
+                return r;
+        }
+        return -1;
+    }
+    public patInt minChars() {
+        if(v.size()==0) return new patInt(0);
+        patInt m = ((Pattern)v.elementAt(0)).countMinChars();
+        for(int i=1;i&lt;v.size();i++) {
+            Pattern p = (Pattern)v.elementAt(i);
+            m.mineq(p.countMinChars());
+        }
+        return m;
+    }
+    public patInt maxChars() {
+        if(v.size()==0) return new patInt(0);
+        patInt m = ((Pattern)v.elementAt(0)).countMaxChars();
+        for(int i=1;i&lt;v.size();i++) {
+            Pattern p = (Pattern)v.elementAt(i);
+            m.maxeq(p.countMaxChars());
+        }
+        return m;
+    }
+    Pattern clone1(Hashtable h) {
+        Or o=new Or();
+        h.put(this,o);
+        h.put(o,o);
+        for(int i=0;i&lt;v.size();i++)
+            o.v.addElement( ((Pattern)v.elementAt(i)).clone(h) );
+        return o;
+    }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/OrMark.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/OrMark.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/OrMark.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/OrMark.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/OrMark.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,50 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Hashtable;
+
+/** Implements the parenthesis pattern subelement.*/
+class OrMark extends Or {
+    SubMark sm = new SubMark();
+    int id;
+    OrMark(int i) {
+        sm.om = this;
+        id = i;
+    }
+    String leftForm() { return &quot;(&quot;; }
+    public Pattern getNext() {
+        return sm;
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        sm.next = super.getNext();
+        if(pt.marks == null) {
+            int n2 = 2 * pt.nMarks+2;
+            pt.marks = new int[n2];
+            for(int i=0;i&lt;n2;i++)
+                pt.marks[i] = -1;
+        }
+        pt.marks[id] = pos;
+        int ret = super.matchInternal(pos,pt);
+        if(ret &lt; 0)
+            pt.marks[id] = -1;
+        else if(pt.marks[id] &gt; pt.marks[id+pt.nMarks]) {
+            int swap = pt.marks[id];
+            pt.marks[id] = pt.marks[id+pt.nMarks]+1;
+            pt.marks[id+pt.nMarks] = swap+1;
+        }
+        return ret;
+    }
+    public Pattern clone1(Hashtable h) {
+        OrMark om = new OrMark(id);
+        h.put(om,om);
+        h.put(this,om);
+        for(int i=0;i&lt;v.size();i++)
+            om.v.addElement( ((Pattern)v.elementAt(i)).clone(h) );
+        return om;
+    }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PartialBuffer.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PartialBuffer.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PartialBuffer.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PartialBuffer.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PartialBuffer.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,82 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** This class allows you to match on a partial string.
+    If the allowOverRun flag is true, then the
+    length() method returns a number 1 larger than
+    is actually contained by the class.
+    &lt;p&gt;
+    If one attempts to access the last character as
+    follows:
+    &lt;pre&gt;
+    StringBuffer sb = ...;
+    ...
+    PartialBuffer pb = new PartialBuffer(sb);
+    char c = pb.charAt(pb.length()-1);
+    &lt;/pre&gt;
+    then two things happen.  First, a zero is returned
+    into the variable c.  Second, the overRun flag is
+    set to &quot;true.&quot;  Accessing data beyond the end of
+    the buffer is considered an &quot;overRun&quot; of the data.
+    &lt;p&gt;
+    This can be helpful in determining whether more
+    characters are required for a match to occur, as
+    the pseudo-code below illustrates.
+    &lt;pre&gt;
+    int i = ...;
+    Regex r = new Regex(&quot;some pattern&quot;);
+    pb.allowOverRun = true;
+    pb.overRun = true;
+    boolean result = r.matchAt(pb,i);
+    if(pb.overRun) {
+      // The result of the match is not relevant, regardless
+      // of whether result is true or false.  We need to
+      // append more data to the buffer and try again.
+      ....
+      sb.append(more data);
+    }
+    &lt;/pre&gt;
+    */
+class PartialBuffer implements StringLike {
+  int off;
+  public boolean allowOverRun = true;
+  public boolean overRun = false;
+  StringBuffer sb;
+  PartialBuffer(StringBuffer sb) {
+    this.sb = sb;
+  }
+  public char charAt(int n) {
+    n += off;
+    if(n == sb.length()) {
+      overRun = true;
+      return 0;
+    }
+    return sb.charAt(n);
+  }
+  public int length() {
+    return allowOverRun ? sb.length()+1 : sb.length();
+  }
+  public int indexOf(char c) {
+    for(int i=0;i&lt;sb.length();i++)
+      if(sb.charAt(i)==c)
+        return i;
+    return -1;
+  }
+  public Object unwrap() { return sb; }
+  public String substring(int i1,int i2) {
+    StringBuffer sb = new StringBuffer(i2-i1);
+    for(int i=i1;i&lt;i2;i++)
+      sb.append(charAt(i));
+    return sb.toString();
+  }
+  /** Just returns null. */
+  public BasicStringBufferLike newStringBufferLike() {
+    return null;
+  }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Pattern.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Pattern.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Pattern.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Pattern.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Pattern.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,193 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.*;
+/**
+        Shareware: package pat
+   &lt;a href=&quot;copyright.html&quot;&gt;Copyright 2001, Steven R. Brandt&lt;/a&gt;
+*/ /**
+Class Pattern is the base class on which all the other pattern
+elements are built. */
+
+public abstract class Pattern {
+    /** The ESC character, the user can provide his own value
+            for the escape character through regex.esc */
+    public final static char ESC = '\\';
+    final static String PROTECT_THESE = &quot;[]{}(),$,-\&quot;^.&quot;;
+
+    /** The interal match function, it must be provided by any
+        class which wishes to extend Pattern. */
+    public abstract int matchInternal(int i,Pthings p);
+    public abstract String toString();
+
+    // Class Pattern is a singly linked list
+    // chained together by member next.  The member
+    // parent is used so that sub patterns can access
+    // the chain they are branching from.
+    Pattern next=null,parent=null;
+
+    /** This gets the next element of a Pattern that
+            we wish to match.  If we are at the end of a
+            subchain of patterns, it will return us to the
+            parent chain. */
+    public Pattern getNext() {
+        return next != null ? next :
+        (parent == null ? null : parent.getNext());
+    }
+    /** Call this method if you have a pattern element that
+            takes a sub pattern (such as Or), and
+            after you have added a sub pattern to the current
+            pattern element. */
+    public void setParent(Pattern p) {
+        if(next != null) next.setParent(p);
+        else parent = p;
+    }
+    /** This determines if the remainder of a Pattern
+            matches.  Type &quot;return nextMatch&quot; from within
+            matchInternal if the current
+            Pattern matches.  Otherwise, return a -1.*/
+    public int nextMatch(int i,Pthings pt) {
+        Pattern p = getNext();
+        /*if(p == null) return i;
+                return p.matchInternal(i,pt);*/
+        return p==null ? i : p.matchInternal(i,pt);
+    }
+    /** This is a toString() for the remainder
+            of the Pattern elements after this one.
+            use this when overriding toString(). Called from
+            within toString(). */
+    public String nextString() {
+        if(next == null) return &quot;&quot;;
+        return next.toString();
+    }
+
+    /** a method to detect whether char c is in String s */
+    final static boolean inString(char c,String s) {
+        int i;
+        for(i=0;i&lt;s.length();i++)
+            if(s.charAt(i)==c)
+                return true;
+        return false;
+    }
+
+    /** A method to create a string that protects the characters
+            listed in PROTECT_THESE by prepending the esc character.
+            The esc character itself is automatically protected. */
+    final static
+        String protect(String s,String PROTECT_THESE,char esc) {
+        int i;
+        StringBuffer sb = new StringBuffer();
+        String p = PROTECT_THESE+esc;
+        for(i=0;i&lt;s.length();i++) {
+            char c = s.charAt(i);
+            if(inString(c,p))
+                sb.append(esc);
+            sb.append(c);
+        }
+        return sb.toString();
+    }
+
+    /** This can be used to perform a match test from
+            within class Pattern. */
+    public int match(StringLike s,Pthings pt) {
+        return matchAt(s,0,pt);
+    }
+    /** This can be used to perform a match test from
+            within class Pattern. */
+    public int matchAt(StringLike s,int i,Pthings pt) {
+        pt.src = s;
+        int r = matchInternal(i,pt);
+        if(r &lt; 0) return -1;
+        mfrom = r&lt;i ? r+1 : i;
+        return r&lt;i ? i-r-1 : r-i;
+    }
+    int mfrom=0;
+
+    // Detect masked characters
+    final boolean Masked(int i,Pthings pt) {
+        return pt.cbits == null ? false : pt.cbits.get(i);
+    }
+
+    /** add a Pattern to the singly-linked Pattern chain. */
+    public Pattern add(Pattern p) {
+        if(next == null) {
+            if(p==null) return this;
+            next = p;
+            p.parent = parent;
+            parent = null;
+        } else next.add(p);
+        return this;
+    }
+    /** The minimum number of characters which
+        this pattern element can match. */
+    public patInt minChars() { return new patInt(0); }
+    /** The maximum number of characters which
+        this pattern element can match. */
+    public patInt maxChars() { return new patInf(); }
+    /** return minimum number of characters in pattern */
+    public final patInt countMinChars() {
+        Pattern p = this;
+        patInt sum = new patInt(0);
+        while(p != null) {
+            sum.pluseq(p.minChars());
+            p = p.next;
+        }
+        return sum;
+    }
+    /** return maximum number of characters in pattern */
+    public final patInt countMaxChars() {
+        Pattern p = this;
+        patInt sum = new patInt(0);
+        while(p != null) {
+            sum.pluseq(p.maxChars());
+            p = p.next;
+        }
+        return sum;
+    }
+
+    // This method is only needed by Multi_stage2 so far...
+    // the reason is that it may try something else after a
+    // match succeeds.  OrMark will only record the last thing
+    // tried in marks, so we need to backup the result of the
+    // last successful match and restore it if the next one
+    // does not succeed.
+    final int testMatch(Pattern p,int pos,Pthings pt) {
+        int[] tab = null;
+        if(pt.marks != null) try {
+                tab = new int[pt.marks.length];
+                for(int i=0;i&lt;tab.length;i++)
+                    tab[i] = pt.marks[i];
+            } catch(Throwable t) {}
+        int ret = p.matchInternal(pos,pt);
+        if(ret &lt; 0) pt.marks = tab;
+        return ret;
+    }
+
+    /** Clones this pattern elements without cloning others in the
+        linked list. */
+    Pattern clone1(Hashtable h) {
+        throw new Error(&quot;No such method as clone1 for &quot;+getClass().getName());
+    }
+    Pattern clone(Hashtable h) {
+        Pattern p = (Pattern)h.get(this);
+        if(p != null) {
+            return p;
+        }
+        p=clone1(h);
+        if(p==null)throw new Error(&quot;Null from clone1!&quot;);
+        h.put(this,p);
+        h.put(p,p);
+        if(next != null) p.next = next.clone(h);
+        if(parent != null) p.parent = parent.clone(h);
+        return p;
+    }
+    public boolean equals(Object o) {
+        return o == this;
+    }
+};
+

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PatternSub.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PatternSub.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PatternSub.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PatternSub.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PatternSub.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,15 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** This is simply a subclass of pattern that
+  * contains a sub pattern.
+  */
+abstract class PatternSub extends Pattern {
+    Pattern sub;
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PopRule.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PopRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PopRule.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PopRule.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PopRule.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,16 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** Implements substitution rule $POP. See the example
+  * file &lt;a href=&quot;<A HREF="http://javaregex.com/code/trans3.java.html">http://javaregex.com/code/trans3.java.html</A>&quot;&gt;trans3.html&lt;/a&gt;.
+  */
+public class PopRule extends SpecialRule {
+    public PopRule() {}
+    public String toString1() { return &quot;${POP}&quot;; }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Prop.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Prop.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Prop.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Prop.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Prop.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,52 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** Get Unicode properties for a character.  See
+&lt;a href=&quot;<A HREF="http://unicode.org">http://unicode.org</A>&quot;&gt;<A HREF="http://unicode.org&lt;/a">http://unicode.org&lt;/a</A>&gt;. */
+public class Prop {
+    /** Is this a &quot;Decimal Digit&quot; according to Unicode? */
+    public final static boolean isDecimalDigit(char c) {
+      if(Bits.decimal_digit == null)
+        Bits.decimal_digit_f();
+      return Bits.decimal_digit.get(c);
+    }
+    /** Is this a &quot;Alphabetic&quot; according to Unicode? */
+    public final static boolean isAlphabetic(char c) {
+      if(Bits.letter == null)
+        Bits.letter_f();
+      return Bits.letter.get(c);
+    }
+    /** Is this a &quot;Math&quot; according to Unicode? */
+    public final static boolean isMath(char c) {
+      if(Bits.math == null)
+        Bits.math_f();
+      return Bits.math.get(c);
+    }
+
+    /** Is this a &quot;Currency&quot; according to Unicode? */
+    public final static boolean isCurrency(char c) {
+      if(Bits.currency == null)
+        Bits.currency_f();
+      return Bits.currency.get(c);
+    }
+
+    /** Is c a white space character according to Unicode? */
+    public final static boolean isWhite(char c) {
+      if(Bits.white == null)
+        Bits.white_f();
+      return Bits.white.get(c);
+    }
+
+    /** Is c a punctuation character according to Unicode? */
+    public final static boolean isPunct(char c) {
+      if(Bits.punct == null)
+        Bits.punct_f();
+      return Bits.punct.get(c);
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Pthings.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Pthings.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Pthings.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Pthings.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Pthings.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,32 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** 
+Things that need to be kept track of during a
+ match.  Passed along with Pattern.matchInternal. */
+public class Pthings {
+    /** The current text we are attempting to match. */
+    public StringLike src;
+    /** Whether we should ignore the case of letters in
+        this match. */
+    public boolean ignoreCase;
+    public boolean mFlag;
+    /** The mask to use when dontMatchInQuotes is set. */
+    public BitSet cbits;
+    /** Used to keep track of backreferences. */
+    //public Hashtable marks;
+    public int[] marks;
+    public int nMarks;
+    /** Used to set the behavior of &quot;.&quot;  By default, it
+        now fails to match the '\n' character. */
+    public boolean dotDoesntMatchCR;
+    /** Determine if Skipped strings need to be checked. */
+    public boolean no_check;
+    int lastPos;
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PushRule.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PushRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PushRule.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PushRule.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/PushRule.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,22 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** See the example file
+    &lt;a href=&quot;<A HREF="http://javaregex.com/code/trans3.java.html">http://javaregex.com/code/trans3.java.html</A>&quot;&gt;trans3.java&lt;/a&gt; for
+    further examples of how this is used.  You will probably not
+    want to call it directly. */
+public class PushRule extends SpecialRule {
+    Regex NewRule;
+    public PushRule(PushRule p) { NewRule = p.NewRule; }
+    public PushRule(String nm,Regex rr) { name=nm; NewRule = rr; }
+    public PushRule(String nm,Transformer tr) { name = nm; NewRule = tr.rp; }
+    public Object clone1() { return new PushRule(this); }
+    public String String1() { return &quot;${+&quot;+name+&quot;}&quot;; }
+    public void apply(StringBufferLike sbl,RegRes rr) {}
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RBuffer.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RBuffer.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RBuffer.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RBuffer.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RBuffer.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,33 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** This class is used internally by RegexReader to
+    store blocks of data. */
+class RBuffer {
+  boolean done = false;
+  StringBuffer sb;
+  int pos,epos;
+  RBuffer next;
+  RBuffer() {}
+  RBuffer(StringBuffer sb) { this.sb = sb; }
+  public String toString() {
+    return &quot;sb=&quot;+sb.toString().replace('\n',' ')+
+      &quot; pos=&quot;+pos+&quot; epos=&quot;+epos+
+      &quot; sb.length()=&quot;+sb.length()+
+      &quot;\n&quot;+sp(pos+3)+&quot;^&quot;+sp(epos-pos-1)+&quot;^&quot;;
+  }
+  String sp(int n) {
+    if(n&lt;=0)
+      return &quot;&quot;;
+    StringBuffer sb = new StringBuffer(n);
+    for(int i=0;i&lt;n;i++)
+      sb.append(' ');
+    return sb.toString();
+  }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Range.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Range.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Range.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Range.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Range.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,61 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Hashtable;
+
+/** Thrown when one encounters things like [z-a] */
+class BadRangeArgs extends RegSyntax {};
+
+/** Implments a subelement (ranges) of the [] pattern element.
+For example, [a-z023] is implemented using a range and tree oneChar
+classes.
<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">+ at see</A> Bracket
<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">+ at see</A> oneChar
+*/
+class Range extends Pattern {
+    char lo,hi,altlo,althi;
+    boolean printBrackets = false;
+    public String toString() {
+        String s=protect(&quot;&quot;+lo,PROTECT_THESE,ESC)+&quot;-&quot;
+            +protect(&quot;&quot;+hi,PROTECT_THESE,ESC);
+        if(!printBrackets)
+            return s;
+        return &quot;[&quot;+s+&quot;]&quot;;
+    }
+    Range(char loi,char hii) throws RegSyntax {
+        lo = loi; hi = hii;
+        oneChar o = null;
+        if(lo &gt;= hi)
+            //throw new BadRangeArgs();
+            RegSyntaxError.endItAll(&quot;Badly formed []'s : &quot;+lo+&quot; &gt;= &quot;+hi);
+        o = new oneChar(lo);
+        altlo = o.altc;
+        o = new oneChar(hi);
+        althi = o.altc;
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        if(pos &gt;= pt.src.length()) return -1;
+        if(Masked(pos,pt)) return -1;
+        char c = pt.src.charAt(pos);
+        if(lo &lt;= c &amp;&amp; c &lt;= hi ||
+                (pt.ignoreCase &amp;&amp; (altlo &lt;= c &amp;&amp; c &lt;= althi)))
+            return nextMatch(pos+1,pt);
+        return -1;
+    }
+    public patInt minChars() { return new patInt(1); }
+    public patInt maxChars() { return new patInt(1); }
+    public Pattern clone1(Hashtable h) {
+        try {
+            Range r = new Range(lo,hi);
+            r.printBrackets = printBrackets;
+            return r;
+        } catch(RegSyntax rs) {
+            return null;
+        }
+    }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegHolder.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegHolder.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegOpt.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegOpt.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegOpt.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegOpt.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegOpt.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,339 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Enumeration;
+import java.util.Hashtable;
+import java.util.Vector;
+
+/** This class is just like oneChar, but doesn't worry about case. */
+class FastChar extends oneChar {
+    FastChar(char c) { super(c); }
+    public int matchInternal(int p,Pthings pt) {
+        return (p &lt; pt.src.length()
+            &amp;&amp; pt.src.charAt(p)==c) ?
+            nextMatch(p+1,pt) : -1;
+    }
+    Pattern clone1(Hashtable h) {
+        return new FastChar(c);
+    }
+}
+
+/** This class is a hashtable keyed by Character
+  * Objects.  It is used to match things of the
+  * form (?:a..|b..|c..|..) match with greater efficiency --
+  * by using a Hashtable that indexes into the group
+  * of patterns.
+  */
+class Branch extends Pattern {
+    Hashtable h = new Hashtable();
+    // We need to keep track of the order
+    // of the keys -- if we don't then
+    // recompiling the output of toString
+    // may produce errors by re-ordering
+    // ()'s and changing the id number of
+    // the backreference associated with
+    // a subpattern.
+    Vector keys = new Vector();
+    Branch() {}
+    Pattern clone1(Hashtable x) {
+        Branch b = new Branch();
+        for (int i=0; i&lt;keys.size(); i++)
+           b.keys.add(keys.elementAt(i));
+        //b.keys = (Vector)keys.getCopy();
+        x.put(this,b);
+        x.put(b,b);
+
+        for(int i=0;i&lt;keys.size();i++) {
+            Pattern p = (Pattern)h.get(keys.elementAt(i));
+            b.h.put(keys.elementAt(i),p.clone(x));
+        }
+        return b;
+    }
+
+    // this function eliminates Branches with 0 or 1 elements.
+    final Pattern reduce(boolean ignoreCase,boolean dontMinQ) {
+        if(h.size()==1) {
+            Enumeration e = h.keys();
+            Character c = (Character)e.nextElement();
+            Pattern oc;
+            if(ignoreCase||dontMinQ)
+                oc=new oneChar(c.charValue());
+            else oc=new FastChar(c.charValue());
+            oc.next = (Pattern)h.get(c);
+            oc.add(next);
+            return oc;
+        } else if(h.size()==0) return null;
+        return this;
+    }
+    public patInt maxChars() {
+        Enumeration e = h.keys();
+        patInt count = new patInt(0);
+        while(e.hasMoreElements()) {
+            Object key = e.nextElement();
+            Pattern pa = (Pattern)h.get(key);
+            patInt pi = pa.maxChars();
+            pi.inc();
+            count.maxeq(pi);
+        }
+        return count;
+    }
+    public patInt minChars() {
+        Enumeration e = h.keys();
+        patInt count = new patInt(0);
+        while(e.hasMoreElements()) {
+            Object key = e.nextElement();
+            Pattern pa = (Pattern)h.get(key);
+            patInt pi = pa.minChars();
+            pi.inc();
+            count.mineq(pi);
+        }
+        return count;
+    }
+
+    // adds a oneChar object to this Branch
+    void addc(oneChar o,boolean ignoreCase,boolean dontMinQ) {
+        Pattern n = o.next;
+        if(n == null)
+            n = new NullPattern();
+        else
+            n = RegOpt.opt(n,ignoreCase,dontMinQ);
+        n.setParent(this);
+        set(new Character(o.c),n,ignoreCase,dontMinQ);
+        if(ignoreCase) {
+            if(o.c != o.altc)
+                set(new Character(o.altc),n,ignoreCase,dontMinQ);
+            if(o.c != o.altc2 &amp;&amp; o.altc != o.altc2)
+                set(new Character(o.altc2),n,ignoreCase,dontMinQ);
+        }
+    }
+    void set(Character c,Pattern n,boolean igc,boolean dontMinQ) {
+        Pattern p = (Pattern)h.get(c);
+        next = null;
+        // This letter is not yet used in the Branch object.
+        // We need to add it.
+        if(p==null) {
+            if(n instanceof Or) {
+                // A NullPattern is prepended to an Or
+                // to prevent confusing this object.
+                // For example: (boo|bug) =&gt; (b(?:oo|ug))
+                // during this process.  However, we
+                // want (b(?:oo|ell)|bug)
+                NullPattern np = new NullPattern();
+                np.add(n);
+                h.put(c,np);
+            } else {
+                h.put(c,n);
+            }
+            // Make sure we remember the order things were
+            // added into the Branch object so that we can
+            // properly convert it to a String.
+            keys.addElement(c);
+        } else if(p instanceof Or) {
+            ((Or)p).addOr(n);
+        } else if(p instanceof oneChar &amp;&amp; n instanceof oneChar
+                &amp;&amp; ((oneChar)p).c != ((oneChar)n).c) {
+            Branch b = new Branch();
+            b.addc((oneChar)p,igc,dontMinQ);
+            b.addc((oneChar)n,igc,dontMinQ);
+            h.put(c,b);
+            b.setParent(this);
+        } else if(p instanceof Branch &amp;&amp; n instanceof oneChar) {
+            ((Branch)p).addc((oneChar)n,igc,dontMinQ);
+            n.setParent(p);
+        } else {
+            // Create an Or object to receive the variety
+            // of branches in the pattern if the current letter
+            // is matched.  We do not attempt to make these
+            // sub-branches into a Branch object yet.
+            Or o = new Or();
+            o.setParent(this);
+
+            // Remove NullPattern from p -- it's no longer needed.
+            if(p instanceof NullPattern
+                    &amp;&amp; p.parent == null &amp;&amp; p.next != null) {
+                o.addOr(p.next);
+            } else {
+                o.addOr(p);
+            }
+            o.addOr(n);
+
+            Pattern optpat = RegOpt.opt(o,igc,dontMinQ);
+            h.put(c,optpat);
+            optpat.setParent(this);
+        }
+    }
+    public String toString() {
+        StringBuffer sb = new StringBuffer();
+        // should protect this...
+        sb.append(&quot;(?:(?#branch)&quot;);// Hashtable)&quot;);
+        for(int i=0;i&lt;keys.size();i++) {
+            Character c = (Character)keys.elementAt(i);
+            sb.append(c);
+            sb.append(h.get(c));
+            if(i+1&lt;keys.size())
+                sb.append(&quot;|&quot;);
+        }
+        sb.append(&quot;)&quot;);
+        sb.append(nextString());
+        return sb.toString();
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        if(pos &gt;= pt.src.length()) return -1;
+        Pattern n = (Pattern)h.get(new Character(pt.src.charAt(pos)));
+        if(n == null) return -1;
+        if(pt.cbits != null &amp;&amp; pt.cbits.get(pos)) return -1;
+        return n.matchInternal(pos+1,pt);
+    }
+}
+
+/** This is just a place to put the optimizing function.
+    It is never instantiated as an Object.  It just sorts
+    through the RegOpt looking for things it can change
+    and make faster. */
+public class RegOpt {
+    static Pattern opt(Pattern p,boolean ignoreCase,
+        boolean dontMinQ) {
+        if(p == null) return p;
+        if(p instanceof Bracket) {
+            Bracket b = (Bracket)p;
+            // FastBracket is the only special
+            // optimized class to have its own
+            // source file.
+            p = FastBracket.process(b,ignoreCase);
+            //if(!(p instanceof FastBracket)
+            //p = Switch.process(b,ignoreCase);
+            p.next = b.next;
+            p.parent = b.parent;
+        } else if(p instanceof oneChar &amp;&amp; !ignoreCase
+                &amp;&amp; !dontMinQ) {
+            oneChar o = (oneChar)p;
+            p = new FastChar(o.c);
+            p.next = o.next;
+            p.parent = o.parent;
+        } else if(p instanceof Or
+                &amp;&amp; ((Or)p).leftForm().equals(&quot;(?:&quot;)
+                &amp;&amp; ((Or)p).v.size()==1) { // Eliminate this Or Object.
+            Or o = (Or)p;
+            p = (Pattern)o.v.elementAt(0);
+            p.setParent(null);
+            p = RegOpt.opt(p,ignoreCase,dontMinQ);
+            p.add(o.next);
+        } else if(p instanceof Or) {
+            Or o = (Or)p;
+            o.pv = null;
+            Vector v = o.v;
+            o.v = new Vector();
+            Branch b = new Branch();
+            b.parent = o.parent;
+            for(int i=0;i&lt;v.size();i++) {
+                Pattern pp = (Pattern)v.elementAt(i);
+                // We want to have at least two oneChar's in
+                // the Or Object to consider making a Branch.
+                if(pp instanceof oneChar &amp;&amp; (b.h.size()&gt;=1 ||
+                        (i+1&lt;v.size() &amp;&amp; v.elementAt(i+1) instanceof oneChar)))
+                    b.addc((oneChar)pp,ignoreCase,dontMinQ);
+                else {
+                    if(b.keys.size() &gt; 0) {
+                        Pattern p2 = (Pattern)b.reduce(ignoreCase,dontMinQ);
+                        if(p2 != null) {
+                            o.addOr(p2);
+                            b = new Branch();
+                            b.parent = o.parent;
+                        }
+                    }
+                    o.addOr(opt(pp,ignoreCase,dontMinQ));
+                }
+            }
+            if(b.keys.size()&gt;0) {
+                Pattern p2=(Pattern)b.reduce(ignoreCase,dontMinQ);
+                if(p2 != null)
+                    o.addOr(p2);
+            }
+            if(o.v.size()==1
+                    &amp;&amp; o.leftForm().equals(&quot;(?:&quot;)) { // Eliminate Or Object
+                p = (Pattern)o.v.elementAt(0);
+                p.setParent(null);
+                p = RegOpt.opt(p,ignoreCase,dontMinQ);
+                p.add(o.next);
+            }
+        } else if(p instanceof FastMulti) {
+            PatternSub ps = (PatternSub)p;
+            ps.sub = RegOpt.opt(ps.sub,ignoreCase,dontMinQ);
+        } else if(p instanceof Multi &amp;&amp; safe4fm( ((PatternSub)p).sub )) {
+            Multi m = (Multi)p;
+            FastMulti fm = null;
+            try {
+                fm = new FastMulti(m.a,m.b,
+                    opt(m.sub,ignoreCase,dontMinQ));
+            } catch(RegSyntax rs) {}
+            fm.parent = m.parent;
+            fm.matchFevest = m.matchFevest;
+            fm.next = m.next;
+            p = fm;
+        }
+        if(p.next != null)
+            p.next = opt(p.next,ignoreCase,dontMinQ);
+        return p;
+    }
+    final static boolean safe4fm(Pattern x) {
+        while(x != null) {
+            if(x instanceof Bracket)
+                ;
+            else if(x instanceof Range)
+                ;
+            else if(x instanceof oneChar)
+                ;
+            else if(x instanceof Any)
+                ;
+            else if(x instanceof Custom
+                    &amp;&amp; ((Custom)x).v instanceof UniValidator)
+                ;
+            else if(x instanceof Or) {
+                Or o = (Or)x;
+                if(!o.leftForm().equals(&quot;(?:&quot;))
+                    return false;
+                patInt lo = o.countMinChars();
+                patInt hi = o.countMaxChars();
+                if(!lo.equals(hi))
+                    return false;
+                for(int i=0;i&lt;o.v.size();i++)
+                    if(!safe4fm((Pattern)o.v.elementAt(i)) )
+                        return false;
+            } else return false;
+            x = x.next;
+        }
+        return true;
+    }
+    /*
+    public static void setParents(Regex r) {
+      setParents(r.thePattern,null);
+    }
+    static void setParents(Pattern p,Pattern x) {
+      if(p instanceof PatternSub &amp;&amp; !(p instanceof FastMulti)
+      &amp;&amp; !(p instanceof DotMulti))
+        RegOpt.setParents( ((PatternSub)p).sub, p);
+      else if(p instanceof Or &amp;&amp; !(p instanceof Bracket)) {
+        Or o = (Or)p;
+        for(int i=0;i&lt;o.v.size();i++)
+          RegOpt.setParents((Pattern)o.v.elementAt(i),o);
+      } else if(p instanceof Branch) {
+        Branch b = (Branch)p;
+        Enumeration e = b.h.keys();
+        while(e.hasMoreElements()) {
+          Object o = e.nextElement();
+          RegOpt.setParents( (Pattern)b.h.get(o), b);
+        }
+      }
+      if(p.next == null)
+        p.parent = x;
+      else {
+        p.parent = null;
+        RegOpt.setParents(p.next,x);
+      }
+    }*/
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegRes.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegRes.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegRes.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegRes.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegRes.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,165 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** 
+        Shareware: package pat
+   &lt;a href=&quot;copyright.html&quot;&gt;Copyright 2001, Steven R. Brandt&lt;/a&gt;
+*/ /**
+This class is used to store a result from Regex */
+public class RegRes implements Cloneable {
+    protected int[] marks = null;
+    protected boolean didMatch_ = false;
+    protected StringLike src=null;
+
+    /** Obtain the text String that was matched against. */
+    public String getString() { return src.toString(); }
+    /** Obtain the source StringLike object. */
+    public StringLike getStringLike() { return src; }
+    protected int charsMatched_=0,matchFrom_=0,numSubs_=0;
+    public String toString() {
+        StringBuffer sb = new StringBuffer();
+        sb.append(&quot;match=&quot;+matchedFrom()+&quot;:&quot;+charsMatched());
+        if(!didMatch()) return sb.toString();
+        for(int i=0;i&lt;numSubs();i++) {
+            int n = i + 1;
+            sb.append(&quot; sub(&quot;+n+&quot;)=&quot;+matchedFrom(n)+
+                &quot;:&quot;+charsMatched(n));
+        }
+        return sb.toString();
+    }
+    public RegRes() {}
+    public RegRes(RegRes r) {
+      copyOutOf(r);
+    }
+    public void copyOutOf(RegRes r) {
+        if(r.marks == null)
+            marks = null;
+        else try {
+                //marks = (Hashtable)r.marks.clone();
+                marks = new int[r.marks.length];
+                for(int i=0;i&lt;marks.length;i++)
+                    marks[i]=r.marks[i];
+                //marks = (int[])r.marks.clone();
+            } catch (Throwable t) {}
+        didMatch_ = r.didMatch_;
+        src = r.src;
+        charsMatched_ = r.charsMatched_;
+        matchFrom_ = r.matchFrom_;
+        numSubs_ = r.numSubs_;
+    }
+    public Object clone() { return new RegRes(this); }
+    public boolean equals(RegRes r) {
+        if(charsMatched_!=r.charsMatched_
+                || matchFrom_   !=r.matchFrom_
+                || didMatch_    !=r.didMatch_
+                || numSubs_     !=r.numSubs_
+                || !src.unwrap().equals(r.src.unwrap()))
+            return false;
+        if(marks==null &amp;&amp; r.marks!=null)
+            return false;
+        if(marks!=null &amp;&amp; r.marks==null)
+            return false;
+        for(int i=1;i&lt;=numSubs_;i++) {
+            if(matchedFrom(i) != r.matchedFrom(i))
+                return false;
+            else if(charsMatched(i) != r.charsMatched(i))
+                return false;
+        }
+        return true;
+    }
+    /** Obtains the match if successful, null otherwise.*/
+    public String stringMatched() {
+        int mf=matchedFrom(), cm = charsMatched();
+        return !didMatch_ || mf&lt;0 || cm&lt;0 ? null :
+        src.substring(mf,mf+cm);
+    }
+    /** Obtains the position backreference number i begins to match, or
+         -1 if backreference i was not matched. */
+    public int matchedFrom(int i) {
+        if(marks==null||i&gt;numSubs_) return -1;
+        //Integer in=(Integer)marks.get(&quot;left&quot;+i);
+        //return in == null ? -1 : in.intValue();
+        return marks[i];
+    }
+    /** Obtains the number of characters matched by backreference i, or
+         -1 if backreference i was not matched. */
+    public int charsMatched(int i) {
+        if(marks==null||i&gt;numSubs_||!didMatch_) return -1;
+        //Integer in = (Integer)marks.get(&quot;right&quot;+i);
+        //int i2 = in==null ? -1 : in.intValue();
+        int mf = matchedFrom(i);
+        return mf &lt; 0 ? -1 : marks[i+numSubs_]-matchedFrom(i);
+    }
+    /** This is either equal to matchedFrom(i)+charsMatched(i) if the match
+        was successful, or -1 if it was not. */
+    public int matchedTo(int i) {
+        if(marks==null||i&gt;numSubs_||!didMatch_) return -1;
+        return marks[i+numSubs_];
+    }
+    /** Obtains a substring matching the nth set
+                of parenthesis from the pattern. See
+                numSubs(void), or null if the nth backrefence did
+                not match. */
+    public String stringMatched(int i) {
+        int mf = matchedFrom(i), cm = charsMatched(i);
+        return !didMatch_ || mf&lt;0 || cm&lt;0 ? null :
+        src.substring(mf,mf+cm);
+    }
+    /** This returns the part of the string that preceeds the match,
+         or null if the match failed.*/
+    public String left() {
+        int mf = matchedFrom();
+        return !didMatch_ || (mf&lt;0) ? null : src.substring(0,mf);
+    }
+    /** This returns the part of the string that follows the ith
+                backreference, or null if the backreference did not match. */
+    public String left(int i) {
+        int mf = matchedFrom(i);
+        return !didMatch_ || (mf&lt;0) ? null : src.substring(0,mf);
+    }
+    /** This returns the part of the string that follows the match,
+         or null if the backreference did not match.*/
+    public String right() {
+        int mf = matchedFrom(), cm = charsMatched();
+        return !didMatch_ || mf&lt;0 || cm&lt;0 ? null : src.substring(mf+
+            cm,src.length());
+    }
+    /** This returns the string to the right of the ith backreference,
+         or null if the backreference did not match. */
+    public String right(int i) {
+        int mf = matchedFrom(i), cm = charsMatched(i);
+        return !didMatch_ || mf&lt;0 || cm&lt;0 ? null :
+        src.substring(mf+cm,src.length());
+    }
+    /** After a successful match, this returns the location of
+                the first matching character, or -1 if the match failed.*/
+    public int matchedFrom() { return !didMatch_ ? -1 : matchFrom_; }
+    /** After a successful match, this returns the number of
+                characters in the match, or -1 if the match failed. */
+    public int charsMatched() { return !didMatch_||matchFrom_&lt;0 ? -1 : charsMatched_; }
+    /** This is matchedFrom()+charsMatched() after a successful match,
+        or -1 otherwise. */
+    public int matchedTo() { return !didMatch_ ? -1 : matchFrom_+charsMatched_;}
+    /** This returns the number of
+                backreferences (parenthesis) in the pattern,
+                i.e. the pattern &quot;(ab)&quot; has
+                one, the pattern &quot;(a)(b)&quot; has two, etc. */
+    public int numSubs() { return numSubs_; }
+    /** Contains true if the last match was successful. */
+    public boolean didMatch() { return didMatch_; }
+
+    /** An older name for matchedFrom. */
+    public int matchFrom() { return matchedFrom(); }
+    /** An older name for stringMatched(). */
+    public String substring() { return stringMatched(); }
+    /** An older name for matchedFrom. */
+    public int matchFrom(int i) { return matchedFrom(i); }
+    /** An older name for stringMatched. */
+    public String substring(int i) { return stringMatched(i); }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegSyntax.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegSyntax.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegSyntax.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegSyntax.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegSyntax.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,24 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/*
+        Shareware: package pat
+   &lt;a href=&quot;copyright.html&quot;&gt;Copyright 2001, Steven R. Brandt&lt;/a&gt;
+*/
+/**
+This type of syntax error is thrown whenever a syntax error
+ is encountered in the pattern. It may not be caught directly, as
+ it is not in the throws clause of any method.  To detect it, catch
+ Throwable, and use instanceof to see if it is a RegSyntax. */
+public class RegSyntax extends Exception {
+    RegSyntax() {}
+    RegSyntax(String msg) {
+        super(msg);
+    }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegSyntaxError.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegSyntaxError.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegSyntaxError.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegSyntaxError.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegSyntaxError.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,29 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** When enabled, this class is thrown instead of
+    the normal RegSyntax.  Thus, enabling of this
+    class will make your debugging easier -- but
+    if you leave it on and forget to catch RegSyntaxError
+    a user-supplied pattern could generate a
+    RegSyntaxError that will kill your application.
+
+    I strongly recommend turning this flag on, however,
+    as I think it is more likely to help than to hurt
+    your programming efforts.
+    */
+public class RegSyntaxError extends Error {
+    public static boolean RegSyntaxErrorEnabled = false;
+    public RegSyntaxError() {}
+    public RegSyntaxError(String s) { super(s); }
+    final static void endItAll(String s) throws RegSyntax {
+        if(RegSyntaxErrorEnabled) throw new RegSyntaxError(s);
+        throw new RegSyntax(s);
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Regex.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Regex.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Regex.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Regex.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Regex.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,1430 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.*;
+import java.io.*;
+
+import com.stevesoft.eve_pat.wrap.StringWrap;
+
+
+/** Matches a Unicode punctuation character. */
+class UnicodePunct extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from&lt;s.length() &amp;&amp; Prop.isPunct(s.charAt(from)) ? to : -1;
+    }
+}
+
+/** Matches a Unicode white space character. */
+class UnicodeWhite extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from&lt;s.length() &amp;&amp; Prop.isWhite(s.charAt(from)) ? to : -1;
+    }
+}
+
+/** Matches a character that is not a Unicode punctuation
+  * character.
+  */
+class NUnicodePunct extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from&lt;s.length() &amp;&amp; !Prop.isPunct(s.charAt(from)) ? to : -1;
+    }
+}
+
+/** Matches a character that is not a
+  * Unicode white space character.
+  */
+class NUnicodeWhite extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from&lt;s.length() &amp;&amp; !Prop.isWhite(s.charAt(from)) ? to : -1;
+    }
+}
+
+/** Matches a Unicode word character: an alphanumeric or underscore. */
+class UnicodeW extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        if(from &gt;= s.length()) return -1;
+        char c = s.charAt(from);
+        return (Prop.isAlphabetic(c)||Prop.isDecimalDigit(c)||c=='_') ? to : -1;
+    }
+}
+
+/** Matches a character that is not a Unicode alphanumeric or underscore. */
+class NUnicodeW extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        if(from &gt;= s.length()) return -1;
+        char c = s.charAt(from);
+        return !(Prop.isAlphabetic(c)||Prop.isDecimalDigit(c)||c=='_') ? to : -1;
+    }
+}
+
+/** Matches a Unicode decimal digit. */
+class UnicodeDigit extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from&lt;s.length() &amp;&amp; Prop.isDecimalDigit(s.charAt(from)) ? to : -1;
+    }
+}
+/** Matches a character that is not a Unicode digit.*/
+class NUnicodeDigit extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from&lt;s.length() &amp;&amp; !Prop.isDecimalDigit(s.charAt(from)) ? to : -1;
+    }
+}
+
+/** Matches a Unicode math character. */
+class UnicodeMath extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from&lt;s.length() &amp;&amp; Prop.isMath(s.charAt(from)) ? to : -1;
+    }
+}
+/** Matches a non-math Unicode character. */
+class NUnicodeMath extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from&lt;s.length() &amp;&amp; !Prop.isMath(s.charAt(from)) ? to : -1;
+    }
+}
+
+/** Matches a Unicode currency symbol. */
+class UnicodeCurrency extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from&lt;s.length() &amp;&amp; Prop.isCurrency(s.charAt(from)) ? to : -1;
+    }
+}
+/** Matches a non-currency symbol Unicode character. */
+class NUnicodeCurrency extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from&lt;s.length() &amp;&amp; !Prop.isCurrency(s.charAt(from)) ? to : -1;
+    }
+}
+
+/** Matches a Unicode alphabetic character. */
+class UnicodeAlpha extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from&lt;s.length() &amp;&amp; Prop.isAlphabetic(s.charAt(from)) ? to : -1;
+    }
+}
+
+/** Matches a non-alphabetic Unicode character. */
+class NUnicodeAlpha extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from&lt;s.length() &amp;&amp; !Prop.isAlphabetic(s.charAt(from)) ? to : -1;
+    }
+}
+
+/** Matches an upper case Unicode character. */
+class UnicodeUpper extends UniValidator {
+  public int validate(StringLike s,int from,int to) {
+    return from&lt;s.length() &amp;&amp; isUpper(s.charAt(from)) ? to : -1;
+  }
+  final boolean isUpper(char c) {
+    return c == CaseMgr.toUpperCase(c) &amp;&amp; c != CaseMgr.toLowerCase(c);
+  }
+}
+
+/** Matches an upper case Unicode character. */
+class UnicodeLower extends UniValidator {
+  public int validate(StringLike s,int from,int to) {
+    return from&lt;s.length() &amp;&amp; isLower(s.charAt(from)) ? to : -1;
+  }
+  final boolean isLower(char c) {
+    return c != CaseMgr.toUpperCase(c) &amp;&amp; c == CaseMgr.toLowerCase(c);
+  }
+}
+
+/**
+Regex provides the parser which constructs the linked list of
+Pattern classes from a String.
+&lt;p&gt;
+For the purpose of this documentation, the fact that java interprets the
+backslash will be ignored.  In practice, however, you will need a
+double backslash to obtain a string that contains a single backslash
+character.  Thus, the example pattern &quot;\b&quot; should really be typed
+as &quot;\\b&quot; inside java code.
+&lt;p&gt;
+Note that Regex is part of package &quot;com.stevesoft.pat&quot;.
+To use it, simply import
+com.stevesoft.pat.Regex at the top of your file.
+&lt;p&gt;
+Regex is made with a constructor that takes a String that defines
+the regular expression.  Thus, for example
+&lt;pre&gt;
+      Regex r = new Regex(&quot;[a-c]*&quot;);
+&lt;/pre&gt;
+matches any number of characters so long as the are 'a', 'b', or 'c').
+&lt;p&gt;
+To attempt to match the Pattern to a given string, you can use either
+the search(String) member function, or the matchAt(String,int position)
+member function.  These functions return a boolean which tells you
+whether or not the thing worked, and sets the methods &quot;charsMatched()&quot;
+and &quot;matchedFrom()&quot; in the Regex object appropriately.
+&lt;p&gt;
+The portion of the string before the match can be obtained by the
+left() member, and the portion after the match can be obtained
+by the right() member.
+&lt;p&gt;
+Essentially, this package implements a syntax that is very much
+like the perl 5 regular expression syntax.
+
+Longer example:
+&lt;pre&gt;
+        Regex r = new Regex(&quot;x(a|b)y&quot;);
+        r.matchAt(&quot;xay&quot;,0);
+        eve.sys.Vm.out().println(&quot;sub = &quot;+r.stringMatched(1));
+&lt;/pre&gt;
+The above would print &quot;sub = a&quot;.
+&lt;pre&gt;
+        r.left() // would return &quot;x&quot;
+        r.right() // would return &quot;y&quot;
+&lt;/pre&gt;
+&lt;p&gt;
+Differences between this package and perl5:&lt;br&gt;
+The extended Pattern for setting flags, is now supported,
+but the flags are different.  &quot;(?i)&quot; tells the pattern to
+ignore case, &quot;(?Q)&quot; sets the &quot;dontMatchInQuotes&quot; flag, and
+&quot;(?iQ)&quot; sets them both.  You can change the escape character.
+The pattern &lt;pre&gt;(?e=#)#d+&lt;/pre&gt; is the same as &lt;pre&gt;\d+&lt;/pre&gt;,
+but note that the sequence &lt;pre&gt;(?e=#)&lt;/pre&gt; &lt;b&gt;must&lt;/b&gt; occur
+at the very beginning of the pattern.  There may be other small
+differences as well.  I will either make my package conform
+or note them as I become aware of them.
+&lt;p&gt;
+This package supports additional patterns not in perl5:
+&lt;center&gt;
+&lt;table border=1&gt;
+&lt;tr&gt;&lt;td&gt;(?@())&lt;/td&gt;&lt;td&gt;Group&lt;/td&gt;&lt;td&gt;This matches all characters between
+the '(' character and the balancing ')' character.  Thus, it will
+match &quot;()&quot; as well as &quot;(())&quot;.  The balancing characters are
+arbitrary, thus (?@{}) matches on &quot;{}&quot; and &quot;{{}}&quot;.&lt;/td&gt;
+&lt;tr&gt;&lt;td&gt;(?&amp;lt1)&lt;/td&gt;&lt;td&gt;Backup&lt;/td&gt;&lt;td&gt;Moves the pointer backwards within the text.
+This allows you to make a &quot;look behind.&quot;  It fails if it
+attempts to move to a position before the beginning of the string.
+&quot;x(?&amp;lt1)&quot; is equivalent to &quot;(?=x)&quot;.  The number, 1 in this example,
+is the number of characters to move backwards.&lt;/td&gt;
+&lt;/table&gt;
+&lt;/center&gt;
+&lt;/dl&gt;
<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">+ at author</A> Steven R. Brandt
<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">+ at version</A> package com.stevesoft.pat, release 1.5.3
<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">+ at see</A> Pattern
+*/
+public class Regex extends RegRes implements FilenameFilter {
+    /** BackRefOffset gives the identity number of the first
+        pattern.  Version 1.0 used zero, version 1.1 uses 1 to be
+        more compatible with perl. */
+    static int BackRefOffset = 1;
+    private static Pattern none = new NoPattern();
+    Pattern thePattern = none;
+    patInt minMatch = new patInt(0);
+
+    static Hashtable validators = new Hashtable();
+    static {
+        define(&quot;p&quot;,&quot;(?&gt;1)&quot;,new UnicodePunct());
+        define(&quot;P&quot;,&quot;(?&gt;1)&quot;,new NUnicodePunct());
+        define(&quot;s&quot;,&quot;(?&gt;1)&quot;,new UnicodeWhite());
+        define(&quot;S&quot;,&quot;(?&gt;1)&quot;,new NUnicodeWhite());
+        define(&quot;w&quot;,&quot;(?&gt;1)&quot;,new UnicodeW());
+        define(&quot;W&quot;,&quot;(?&gt;1)&quot;,new NUnicodeW());
+        define(&quot;d&quot;,&quot;(?&gt;1)&quot;,new UnicodeDigit());
+        define(&quot;D&quot;,&quot;(?&gt;1)&quot;,new NUnicodeDigit());
+        define(&quot;m&quot;,&quot;(?&gt;1)&quot;,new UnicodeMath());
+        define(&quot;M&quot;,&quot;(?&gt;1)&quot;,new NUnicodeMath());
+        define(&quot;c&quot;,&quot;(?&gt;1)&quot;,new UnicodeCurrency());
+        define(&quot;C&quot;,&quot;(?&gt;1)&quot;,new NUnicodeCurrency());
+        define(&quot;a&quot;,&quot;(?&gt;1)&quot;,new UnicodeAlpha());
+        define(&quot;A&quot;,&quot;(?&gt;1)&quot;,new NUnicodeAlpha());
+        define(&quot;uc&quot;,&quot;(?&gt;1)&quot;,new UnicodeUpper());
+        define(&quot;lc&quot;,&quot;(?&gt;1)&quot;,new UnicodeLower());
+    }
+
+    /** Set the dontMatch in quotes flag. */
+    public void setDontMatchInQuotes(boolean b) {
+      dontMatchInQuotes = b;
+    }
+    /** Find out if the dontMatchInQuotes flag is enabled. */
+    public boolean getDontMatchInQuotes() {
+      return dontMatchInQuotes;
+    }
+    boolean dontMatchInQuotes = false;
+
+    /** Set the state of the ignoreCase flag.  If set to true, then
+        the pattern matcher will ignore case when searching for a
+        match. */
+    public void setIgnoreCase(boolean b) {
+        ignoreCase = b;
+    }
+    /** Get the state of the ignoreCase flag.  Returns true if we
+        are ignoring the case of the pattern, false otherwise. */
+    public boolean getIgnoreCase() {
+        return ignoreCase;
+    }
+    boolean ignoreCase = false;
+    
+    static boolean defaultMFlag = false;
+    /** Set the default value of the m flag.  If it
+        is set to true, then the MFlag will be on
+	for any regex search executed. */
+    public static void setDefaultMFlag(boolean mFlag) {
+      defaultMFlag = mFlag;
+    }
+    /** Get the default value of the m flag.  If it
+        is set to true, then the MFlag will be on
+	for any regex search executed. */
+    public static boolean getDefaultMFlag() {
+      return defaultMFlag;
+    }
+
+    /** Initializes the object without a Pattern. To supply a Pattern
+        use compile(String s).
+         @see com.stevesoft.eve_pat.Regex#compile(java.lang.String)
+                 */
+    public Regex() {}
+    /** Create and compile a Regex, but do not throw any exceptions.
+        If you wish to have exceptions thrown for syntax errors,
+        you must use the Regex(void) constructor to create the
+        Regex object, and then call the compile method.  Therefore, you
+        should only call this method when you know your pattern is right.
+        I will probably become more like
+         @see com.stevesoft.eve_pat.Regex#search(java.lang.String)
+         @see com.stevesoft.eve_pat.Regex#compile(java.lang.String)
+         */
+    public Regex(String s) {
+        try {
+            compile(s);
+        } catch(RegSyntax rs) {}
+    }
+
+    ReplaceRule rep = null;
+    /** Create and compile both a Regex and a ReplaceRule.
+        @see com.stevesoft.eve_pat.ReplaceRule
+	@see com.stevesoft.eve_pat.Regex#compile(java.lang.String)
+        */
+    public Regex(String s,String rp) {
+        this(s);
+        rep = ReplaceRule.perlCode(rp);
+    }
+    /** Create and compile a Regex, but give it the ReplaceRule
+        specified.  This allows the user finer control of the
+        Replacement process, if that is desired.
+        @see com.stevesoft.eve_pat.ReplaceRule
+	@see com.stevesoft.eve_pat.Regex#compile(java.lang.String)
+        */
+    public Regex(String s,ReplaceRule rp) {
+        this(s);
+        rep = rp;
+    }
+
+    /** Change the ReplaceRule of this Regex by compiling
+        a new one using String rp. */
+    public void setReplaceRule(String rp) {
+        rep = ReplaceRule.perlCode(rp);
+        repr = null; // Clear Replacer history
+    }
+
+    /** Change the ReplaceRule of this Regex to rp. */
+    public void setReplaceRule(ReplaceRule rp) {
+        rep = rp;
+    }
+    /** Test to see if a custom defined rule exists.
+        @see com.stevesoft.pat#define(java.lang.String,java.lang.String,Validator)
+        */
+    public static boolean isDefined(String nm) {
+        return validators.get(nm) != null;
+    }
+    /** Removes a custom defined rule.
+        @see com.stevesoft.pat#define(java.lang.String,java.lang.String,Validator)
+        */
+    public static void undefine(String nm) {
+        validators.remove(nm);
+    }
+    /** Defines a method to create a new rule.  See test/deriv2.java
+        and test/deriv3.java for examples of how to use it. */
+    public static void define(String nm,String pat,Validator v) {
+        v.pattern = pat;
+        validators.put(nm,v);
+    }
+    /** Defines a shorthand for a pattern.  The pattern will be
+        invoked by a string that has the form &quot;(??&quot;+nm+&quot;)&quot;.
+        */
+    public static void define(String nm,String pat) {
+        validators.put(nm,pat);
+    }
+
+    /** Get the current ReplaceRule. */
+    public ReplaceRule getReplaceRule() { return rep; }
+
+    Replacer repr = null;
+    final Replacer _getReplacer() {
+        return repr==null ? repr=new Replacer() : repr;
+    }
+    public Replacer getReplacer() {
+        if(repr == null)
+            repr = new Replacer();
+        repr.rh.me = this;
+        repr.rh.prev = null;
+        return repr;
+    }
+    /** Replace the first occurence of this pattern in String s
+        according to the ReplaceRule.
+        @see com.stevesoft.eve_pat.ReplaceRule
+        @see com.stevesoft.eve_pat.Regex#getReplaceRule()
+        */
+    public String replaceFirst(String s) {
+        return _getReplacer().replaceFirstRegion(s,this,0,s.length()).toString();
+    }
+    /** Replace the first occurence of this pattern in String s
+        beginning with position pos according to the ReplaceRule.
+        @see com.stevesoft.eve_pat.ReplaceRule
+        @see com.stevesoft.eve_pat.Regex#getReplaceRule()
+        */
+    public String replaceFirstFrom(String s,int pos) {
+        return _getReplacer().replaceFirstRegion(s,this,pos,s.length()).toString();
+    }
+    /** Replace the first occurence of this pattern in String s
+        beginning with position start and ending with end
+        according to the ReplaceRule.
+        @see com.stevesoft.eve_pat.ReplaceRule
+        @see com.stevesoft.eve_pat.Regex#getReplaceRule()
+        */
+    public String replaceFirstRegion(String s,int start,int end) {
+        return _getReplacer().replaceFirstRegion(s,this,start,end).toString();
+    }
+
+    /** Replace all occurences of this pattern in String s
+        according to the ReplaceRule.
+        @see com.stevesoft.eve_pat.ReplaceRule
+        @see com.stevesoft.eve_pat.Regex#getReplaceRule()
+        */
+    public String replaceAll(String s) {
+        return _getReplacer().replaceAllRegion(s,this,0,s.length()).toString();
+    }
+    public StringLike replaceAll(StringLike s) {
+        return _getReplacer().replaceAllRegion(s,this,0,s.length());
+    }
+    /** Replace all occurences of this pattern in String s
+        beginning with position pos according to the ReplaceRule.
+        @see com.stevesoft.eve_pat.ReplaceRule
+        @see com.stevesoft.eve_pat.Regex#getReplaceRule()
+        */
+    public String replaceAllFrom(String s,int pos) {
+        return _getReplacer().replaceAllRegion(s,this,pos,s.length()).toString();
+    }
+    /** Replace all occurences of this pattern in String s
+        beginning with position start and ending with end
+        according to the ReplaceRule.
+        @see com.stevesoft.eve_pat.ReplaceRule
+        @see com.stevesoft.eve_pat.Regex#getReplaceRule()
+        */
+    public String replaceAllRegion(String s,int start,int end) {
+        return _getReplacer().replaceAllRegion(s,this,start,end).toString();
+    }
+
+
+    /** Essentially clones the Regex object */
+    public Regex(Regex r) {
+        super((RegRes)r);
+        dontMatchInQuotes = r.dontMatchInQuotes;
+        esc = r.esc;
+        ignoreCase = r.ignoreCase;
+        gFlag = r.gFlag;
+        if(r.rep==null)
+            rep = null;
+        else
+            rep = (ReplaceRule)r.rep.clone();
+        /* try {
+            compile(r.toString());
+        } catch(RegSyntax r_) {} */
+        thePattern = r.thePattern.clone(new Hashtable());
+        minMatch = r.minMatch;
+        skipper = r.skipper;
+    }
+
+    /** By default,
+                the escape character is the backslash, but you can
+                make it anything you want by setting this variable. */
+    public char esc = Pattern.ESC;
+    /** This method compiles a regular expression, making it
+         possible to call the search or matchAt methods.
+                @exception com.stevesoft.eve_pat.RegSyntax
+                is thrown if a syntax error is encountered
+		in the pattern.
+                 For example, &quot;x{3,1}&quot; or &quot;*a&quot; are not valid
+		 patterns.
+                @see com.stevesoft.eve_pat.Regex#search
+                @see com.stevesoft.eve_pat.Regex#matchAt
+                */
+    public void compile(String prepat) throws RegSyntax {
+        String postpat = parsePerl.codify(prepat,true);
+        String pat = postpat==null ? prepat : postpat;
+        minMatch = null;
+        ignoreCase = false;
+        dontMatchInQuotes = false;
+        Rthings mk = new Rthings(this);
+        int offset = mk.val;
+        String newpat = pat;
+        thePattern = none;
+        p = null;
+        or = null;
+        minMatch = new patInt(0);
+        StrPos sp = new StrPos(pat,0);
+        if(sp.incMatch(&quot;(?e=&quot;)) {
+            char nevesc = sp.c;
+            sp.inc();
+            if(sp.match(')'))
+                newpat = reEscape(pat.substring(6),
+                    nevesc,Pattern.ESC);
+        } else if(esc != Pattern.ESC)
+            newpat = reEscape(pat,esc,Pattern.ESC);
+        thePattern = _compile(newpat,mk);
+        numSubs_ = mk.val-offset;
+        mk.set(this);
+    }
+
+    /*  If a Regex is compared against a Regex, a check is
+        done to see that the patterns are equal as well as
+        the most recent match.  If a Regex is compare with
+        a RegRes, only the result of the most recent match
+        is compared. */
+    public boolean equals(Object o) {
+        if(o instanceof Regex) {
+            if(toString().equals(o.toString()))
+                return super.equals(o);
+            else
+                return false;
+        } else return super.equals(o);
+    }
+
+    /** A clone by any other name would smell as sweet. */
+    public Object clone() {
+        return new Regex(this);
+    }
+    /** Return a clone of the underlying RegRes object. */
+    public RegRes result() {
+      return (RegRes)super.clone();
+    }
+
+    // prep sets global variables of class
+    // Pattern so that it can access them
+    // during an attempt at a match
+    Pthings pt = new Pthings();
+    final Pthings prep(StringLike s) {
+	//if(gFlag)
+          pt.lastPos = matchedTo();
+        if(pt.lastPos &lt; 0) pt.lastPos = 0;
+        if( (s==null ? null : s.unwrap()) != (src==null ? null : s.unwrap()) )
+          pt.lastPos = 0;
+        src = s;
+        pt.dotDoesntMatchCR=dotDoesntMatchCR &amp;&amp; (!sFlag);
+	pt.mFlag = (mFlag | defaultMFlag);
+        pt.ignoreCase = ignoreCase;
+        pt.no_check = false;
+        if(pt.marks != null)
+            for(int i=0;i&lt;pt.marks.length;i++)
+                pt.marks[i]=-1;
+	pt.marks = null;
+        pt.nMarks = numSubs_;
+        pt.src = s;
+        if(dontMatchInQuotes)
+            setCbits(s,pt);
+        else
+            pt.cbits = null;
+        return pt;
+    }
+    /** Attempt to match a Pattern beginning
+        at a specified location within the string.
+        @see com.stevesoft.eve_pat.Regex#search
+        */
+    public boolean matchAt(String s,int start_pos) {
+        return _search(s,start_pos,start_pos);
+    }
+    /** Attempt to match a Pattern beginning
+        at a specified location within the StringLike.
+        @see com.stevesoft.eve_pat.Regex#search
+        */
+    public boolean matchAt(StringLike s,int start_pos) {
+        return _search(s,start_pos,start_pos);
+    }
+
+
+    /** Search through a String for the first
+        occurrence of a match.
+        @see com.stevesoft.eve_pat.Regex#searchFrom
+        @see com.stevesoft.eve_pat.Regex#matchAt
+        */
+    public boolean search(String s) {
+        if(s==null)
+            throw new NullPointerException(&quot;Null String Given to Regex.search&quot;);
+        return _search(s,0,s.length());
+    }
+    public boolean search(StringLike sl) {
+        if(sl==null)
+            throw new NullPointerException(&quot;Null StringLike Given to Regex.search&quot;);
+        return _search(sl,0,sl.length());
+    }
+    public boolean reverseSearch(String s) {
+        if(s==null)
+            throw new NullPointerException(&quot;Null String Given to Regex.reverseSearch&quot;);
+        return _reverseSearch(s,0,s.length());
+    }
+    public boolean reverseSearch(StringLike sl) {
+        if(sl==null)
+            throw new NullPointerException(&quot;Null StringLike Given to Regex.reverseSearch&quot;);
+        return _reverseSearch(sl,0,sl.length());
+    }
+    /** Search through a String for the first
+                occurence of a match, but start at position &lt;pre&gt;start&lt;/pre&gt;*/
+    public boolean searchFrom(String s,int start) {
+        if(s==null)
+            throw new NullPointerException(&quot;Null String Given to Regex.searchFrom&quot;);
+        return _search(s,start,s.length());
+    }
+    public boolean searchFrom(StringLike s,int start) {
+        if(s==null)
+            throw new NullPointerException(&quot;Null String Given to Regex.searchFrom&quot;);
+        return _search(s,start,s.length());
+    }
+    /** Search through a region of a String
+        for the first occurence of a match. */
+    public boolean searchRegion(String s,int start,int end) {
+        if(s==null)
+            throw new NullPointerException(&quot;Null String Given to Regex.searchRegion&quot;);
+        return _search(s,start,end);
+    }
+    /** Set this to change the default behavior of the &quot;.&quot; pattern.
+                By default it now matches perl's behavior and fails to
+                match the '\n' character. */
+    public static boolean dotDoesntMatchCR = true;
+    StringLike gFlags;
+    int gFlagto = 0;
+    boolean gFlag = false;
+    /** Set the 'g' flag */
+    public void setGFlag(boolean b) {
+      gFlag = b;
+    }
+    /** Get the state of the 'g' flag. */
+    public boolean getGFlag() {
+      return gFlag;
+    }
+    boolean sFlag = false;
+    /** Get the state of the sFlag */
+    public boolean getSFlag() {
+      return sFlag;
+    }
+    boolean mFlag = false;
+    /** Get the state of the sFlag */
+    public boolean getMFlag() {
+      return mFlag;
+    }
+
+    final boolean _search(String s,int start,int end) {
+        return _search(new StringWrap(s),start,end);
+    }
+    final boolean _search(StringLike s,int start,int end) {
+        if(gFlag &amp;&amp; gFlagto &gt; 0 &amp;&amp; gFlags!=null &amp;&amp; s.unwrap()==gFlags.unwrap())
+            start = gFlagto;
+        gFlags = null;
+
+        Pthings pt=prep(s);
+
+        int up = (minMatch == null ? end : end-minMatch.i);
+
+        if(up &lt; start &amp;&amp; end &gt;= start) up = start;
+
+        if(skipper == null) {
+            for(int i=start;i&lt;=up;i++) {
+                charsMatched_ = thePattern.matchAt(s,i,pt);
+                if(charsMatched_ &gt;= 0) {
+                    matchFrom_ = thePattern.mfrom;
+                    marks = pt.marks;
+                    gFlagto = matchFrom_+charsMatched_;
+                    gFlags = s;
+                    return didMatch_=true;
+                }
+            }
+        } else {
+            pt.no_check = true;
+            for(int i=start;i&lt;=up;i++) {
+                i = skipper.find(src,i,up);
+                if(i&lt;0) {
+                    charsMatched_ = matchFrom_ = -1;
+                    return didMatch_ = false;
+                }
+                charsMatched_ = thePattern.matchAt(s,i,pt);
+                if(charsMatched_ &gt;= 0) {
+                    matchFrom_ = thePattern.mfrom;
+                    marks = pt.marks;
+                    gFlagto = matchFrom_+charsMatched_;
+                    gFlags = s;
+                    return didMatch_=true;
+                }
+            }
+        }
+        return didMatch_=false;
+    }
+    /*final boolean _search(LongStringLike s,long start,long end) {
+        if(gFlag &amp;&amp; gFlagto &gt; 0 &amp;&amp; s==gFlags)
+            start = gFlagto;
+        gFlags = null;
+
+        Pthings pt=prep(s);
+
+        int up = end;//(minMatch == null ? end : end-minMatch.i);
+
+        if(up &lt; start &amp;&amp; end &gt;= start) up = start;
+
+        if(skipper == null) {
+            for(long i=start;i&lt;=up;i++) {
+                charsMatched_ = thePattern.matchAt(s,i,pt);
+                if(charsMatched_ &gt;= 0) {
+                    matchFrom_ = thePattern.mfrom;
+                    marks = pt.marks;
+                    gFlagto = matchFrom_+charsMatched_;
+                    return didMatch_=true;
+                }
+            }
+        } else {
+            pt.no_check = true;
+            for(long i=start;i&lt;=up;i++) {
+                i = skipper.find(src,i,up);
+                if(i&lt;0) {
+                    charsMatched_ = matchFrom_ = -1;
+                    return didMatch_ = false;
+                }
+                charsMatched_ = thePattern.matchAt(s,i,pt);
+                if(charsMatched_ &gt;= 0) {
+                    matchFrom_ = thePattern.mfrom;
+                    marks = pt.marks;
+                    gFlagto = matchFrom_+charsMatched_;
+                    gFlags = s;
+                    return didMatch_=true;
+                } else {
+                  i = s.adjustIndex(i);
+                  up = s.adjustEnd(i);
+                }
+            }
+        }
+        return didMatch_=false;
+    }*/
+
+    boolean _reverseSearch(String s,int start,int end) {
+        return _reverseSearch(new StringWrap(s),start,end);
+    }
+    boolean _reverseSearch(StringLike s,int start,int end) {
+        if(gFlag &amp;&amp; gFlagto &gt; 0 &amp;&amp; s.unwrap()==gFlags.unwrap())
+            end = gFlagto;
+        gFlags = null;
+        Pthings pt=prep(s);
+        for(int i=end;i&gt;=start;i--) {
+            charsMatched_ = thePattern.matchAt(s,i,pt);
+            if(charsMatched_ &gt;= 0) {
+                matchFrom_ = thePattern.mfrom;
+                marks = pt.marks;
+                gFlagto = matchFrom_-1;
+                gFlags = s;
+                return didMatch_=true;
+            }
+        }
+        return didMatch_=false;
+    }
+
+    // This routine sets the cbits variable
+    // of class Pattern.  Cbits is true for
+    // the bit corresponding to a character inside
+    // a set of quotes.
+    static StringLike lasts=null;
+    static BitSet lastbs=null;
+    static void setCbits(StringLike s,Pthings pt) {
+        if(s == lasts) {
+            pt.cbits = lastbs;
+            return;
+        }
+        BitSet bs = new BitSet(s.length());
+        char qc = ' ';
+        boolean setBit = false;
+        for(int i=0;i&lt;s.length();i++) {
+            if(setBit) bs.set(i);
+            char c = s.charAt(i);
+            if(!setBit &amp;&amp; c == '&quot;') {
+                qc = c;
+                setBit = true;
+                bs.set(i);
+            } else if(!setBit &amp;&amp; c == '\'') {
+                qc = c;
+                setBit = true;
+                bs.set(i);
+            } else if(setBit &amp;&amp; c == qc) {
+                setBit = false;
+            } else if(setBit &amp;&amp; c == '\\' &amp;&amp; i+1&lt;s.length()) {
+                i++;
+                if(setBit) bs.set(i);
+            }
+        }
+        pt.cbits = lastbs = bs;
+        lasts = s;
+    }
+
+    // Wanted user to over-ride this in alpha version,
+    // but it wasn't really necessary because of this trick:
+    Regex newRegex() {
+        try {
+            return (Regex)getClass().newInstance();
+        } catch(InstantiationException ie) {
+            return null;
+        } catch(IllegalAccessException iae) {
+            return null;
+        }
+    }
+    /** Only needed for creating your own extensions of
+         Regex.  This method adds the next Pattern in the chain
+         of patterns or sets the Pattern if it is the first call. */
+    protected void add(Pattern p2) {
+        if(p == null)
+            p = p2;
+        else {
+            p.add(p2);
+            p2 = p;
+        }
+    }
+
+    /** You only need to use this method if you are creating
+        your own extentions to Regex.
+        compile1 compiles one Pattern element, it can be
+        over-ridden to allow the Regex compiler to understand
+        new syntax.  See deriv.java for an example.  This routine
+        is the heart of class Regex. Rthings has one integer
+        member called intValue, it is used to keep track of the number
+        of ()'s in the Pattern.
+        @exception com.stevesoft.eve_pat.RegSyntax is thrown when a nonsensensical
+        pattern is supplied.  For example, a pattern beginning
+        with *. */
+    protected void compile1(StrPos sp,Rthings mk) throws RegSyntax {
+        if(sp.match('[')) {
+            sp.inc();
+            add(matchBracket(sp));
+        } else if(sp.match('|')) {
+            if(or == null)
+                or = new Or();
+            if(p == null) p=new NullPattern();
+            or.addOr(p);
+            p = null;
+        } else if(sp.incMatch(&quot;(?&lt;&quot;)) {
+            patInt i = sp.getPatInt();
+            if(i==null) RegSyntaxError.endItAll(&quot;No int after (?&lt;&quot;);
+            add(new Backup(i.intValue()));
+            if(!sp.match(')')) RegSyntaxError.endItAll(&quot;No ) after (?&lt;&quot;);
+        } else if(sp.incMatch(&quot;(?&gt;&quot;)) {
+            patInt i = sp.getPatInt();
+            if(i==null) RegSyntaxError.endItAll(&quot;No int after (?&gt;&quot;);
+            add(new Backup(-i.intValue()));
+            if(!sp.match(')')) RegSyntaxError.endItAll(&quot;No ) after (?&lt;&quot;);
+        } else if(sp.incMatch(&quot;(?@&quot;)) {
+            char op = sp.c;
+            sp.inc();
+            char cl = sp.c;
+            sp.inc();
+            if(!sp.match(')'))
+                RegSyntaxError.endItAll(
+                    &quot;(?@ does not have closing paren&quot;);
+            add(new Group(op,cl));
+        } else if(sp.incMatch(&quot;(?#&quot;)) {
+            while(!sp.match(')'))
+                sp.inc();
+        } else if(sp.dontMatch &amp;&amp; sp.c == 'w') {
+            Regex r = new Regex();
+            //r._compile(&quot;[a-zA-Z0-9_]&quot;,mk);
+            //add(new Goop(&quot;\\w&quot;,r.thePattern));
+            Bracket b = new Bracket(false);
+            b.addOr(new Range('a','z'));
+            b.addOr(new Range('A','Z'));
+            b.addOr(new Range('0','9'));
+            b.addOr(new oneChar('_'));
+            add(b);
+        } else if(sp.dontMatch &amp;&amp; sp.c == 'G') {
+            add(new BackG());
+        } else if(sp.dontMatch &amp;&amp; sp.c == 's') {
+            //Regex r = new Regex();
+            //r._compile(&quot;[ \t\n\r\b]&quot;,mk);
+            //add(new Goop(&quot;\\s&quot;,r.thePattern));
+            Bracket b = new Bracket(false);
+            b.addOr(new oneChar((char)32));
+            b.addOr(new Range((char)8,(char)10));
+            b.addOr(new oneChar((char)13));
+            add(b);
+        } else if(sp.dontMatch &amp;&amp; sp.c == 'd') {
+            Regex r = new Regex();
+            //r._compile(&quot;[0-9]&quot;,mk);
+            //add(new Goop(&quot;\\d&quot;,r.thePattern));
+            Range digit = new Range('0','9');
+            digit.printBrackets = true;
+            add(digit);
+        } else if(sp.dontMatch &amp;&amp; sp.c == 'W') {
+            Regex r = new Regex();
+            //r._compile(&quot;[^a-zA-Z0-9_]&quot;,mk);
+            //add(new Goop(&quot;\\W&quot;,r.thePattern));
+            Bracket b = new Bracket(true);
+            b.addOr(new Range('a','z'));
+            b.addOr(new Range('A','Z'));
+            b.addOr(new Range('0','9'));
+            b.addOr(new oneChar('_'));
+            add(b);
+        } else if(sp.dontMatch &amp;&amp; sp.c == 'S') {
+            //Regex r = new Regex();
+            //r._compile(&quot;[^ \t\n\r\b]&quot;,mk);
+            //add(new Goop(&quot;\\S&quot;,r.thePattern));
+            Bracket b = new Bracket(true);
+            b.addOr(new oneChar((char)32));
+            b.addOr(new Range((char)8,(char)10));
+            b.addOr(new oneChar((char)13));
+            add(b);
+        } else if(sp.dontMatch &amp;&amp; sp.c == 'D') {
+            //Regex r = new Regex();
+            //r._compile(&quot;[^0-9]&quot;,mk);
+            //add(new Goop(&quot;\\D&quot;,r.thePattern));
+            Bracket b = new Bracket(true);
+            b.addOr(new Range('0','9'));
+            add(b);
+        } else if(sp.dontMatch &amp;&amp; sp.c == 'B') {
+            Regex r = new Regex();
+            r._compile(&quot;(?!&quot;+back_slash+&quot;b)&quot;,mk);
+            add(r.thePattern);
+	} else if(isOctalString(sp)) {
+	    int d = sp.c - '0';
+	    sp.inc();
+	    d = 8*d + sp.c - '0';
+	    StrPos sp2 = new StrPos(sp);
+	    sp2.inc();
+	    if(isOctalDigit(sp2,false)) {
+	      sp.inc();
+	      d = 8*d + sp.c - '0';
+	    }
+	    add(new oneChar((char)d));
+        } else if(sp.dontMatch &amp;&amp; sp.c &gt;= '1' &amp;&amp; sp.c &lt;= '9') {
+            int iv = sp.c-'0';
+            StrPos s2 = new StrPos(sp);
+            s2.inc();
+            if(!s2.dontMatch &amp;&amp; s2.c &gt;= '0' &amp;&amp; s2.c &lt;= '9') {
+                iv = 10*iv+(s2.c-'0');
+                sp.inc();
+            }
+            add(new BackMatch(iv));
+        } else if(sp.dontMatch &amp;&amp; sp.c == 'b') {
+            add(new Boundary());
+        } else if(sp.match('\b')) {
+            add(new Boundary());
+        } else if(sp.match('$')) {
+            add(new End(true));
+        } else if(sp.dontMatch &amp;&amp; sp.c == 'Z') {
+            add(new End(false));
+        } else if(sp.match('.')) {
+            add(new Any());
+        } else if(sp.incMatch(&quot;(??&quot;)) {
+            StringBuffer sb = new StringBuffer();
+            StringBuffer sb2 = new StringBuffer();
+            while(!sp.match(')') &amp;&amp; !sp.match(':')) {
+                sb.append(sp.c);
+                sp.inc();
+            }
+            if(sp.incMatch(&quot;:&quot;)) {
+                while(!sp.match(')')) {
+                    sb2.append(sp.c);
+                    sp.inc();
+                }
+            }
+            String sbs = sb.toString();
+            if(validators.get(sbs) instanceof String) {
+                String pat = (String)validators.get(sbs);
+                Regex r = newRegex();
+		Rthings rth = new Rthings(this);
+		rth.noBackRefs = true;
+                r._compile(pat,rth);
+                add(r.thePattern);
+            } else {
+                Custom cm = new Custom(sb.toString());
+                if(cm.v != null) {
+                    Validator v2 = cm.v.arg(sb2.toString());
+                    if(v2 != null) {
+                        v2.argsave = sb2.toString();
+                        String p = cm.v.pattern;
+                        cm.v = v2;
+                        v2.pattern = p;
+                    }
+                    Regex r = newRegex();
+		    Rthings rth = new Rthings(this);
+		    rth.noBackRefs = true;
+                    r._compile(cm.v.pattern,rth);
+                    cm.sub = r.thePattern;
+                    cm.sub.add(new CustomEndpoint(cm));
+                    cm.sub.setParent(cm);
+                    add(cm);
+                }
+            }
+        } else if(sp.match('(')) {
+            mk.parenLevel++;
+            Regex r = newRegex();
+            // r.or = new Or();
+            sp.inc();
+            if(sp.incMatch(&quot;?:&quot;)) {
+                r.or = new Or();
+            } else if(sp.incMatch(&quot;?=&quot;)) {
+                r.or = new lookAhead(false);
+            } else if(sp.incMatch(&quot;?!&quot;)) {
+                r.or = new lookAhead(true);
+            } else if(sp.match('?')) {
+                sp.inc();
+                do {
+                    if(sp.c=='i')mk.ignoreCase = true;
+                    if(sp.c=='Q')mk.dontMatchInQuotes = true;
+                    if(sp.c=='o')mk.optimizeMe = true;
+                    if(sp.c=='g')mk.gFlag = true;
+                    if(sp.c=='s')mk.sFlag = true;
+		    if(sp.c=='m')mk.mFlag = true;
+                    sp.inc();
+                } while(!sp.match(')') &amp;&amp; !sp.eos);
+                r = null;
+                mk.parenLevel--;
+                if(sp.eos) //throw new RegSyntax
+                    RegSyntaxError.endItAll(&quot;Unclosed ()&quot;);
+            } else { // just ordinary parenthesis
+                r.or = mk.noBackRefs ? new Or() : new OrMark(mk.val++);
+            }
+            if(r != null) add(r._compile(sp,mk));
+        } else if(sp.match('^')) {
+            add(new Start(true));
+        } else if(sp.dontMatch &amp;&amp; sp.c=='A') {
+            add(new Start(false));
+        } else if(sp.match('*')) {
+            addMulti(new patInt(0),new patInf());
+        } else if(sp.match('+')) {
+            addMulti(new patInt(1),new patInf());
+        } else if(sp.match('?')) {
+            addMulti(new patInt(0),new patInt(1));
+        } else if(sp.match('{')) {
+            boolean bad = false;
+            StrPos sp2 = new StrPos(sp);
+            StringBuffer sb = new StringBuffer();
+            sp.inc();
+            patInt i1 = sp.getPatInt();
+            patInt i2 = null;
+            if(sp.match('}')) {
+                i2 = i1;
+            } else {
+                if(!sp.match(','))/*
+                    RegSyntaxError.endItAll(
+                       &quot;String \&quot;{&quot;+i2+
+                       &quot;\&quot; should be followed with , or }&quot;);*/
+                    bad = true;
+                sp.inc();
+                if(sp.match('}'))
+                    i2 = new patInf();
+                else
+                    i2 = sp.getPatInt();
+            }
+            if(i1 == null || i2 == null) /*
+                                throw new RegSyntax(&quot;Badly formatted Multi: &quot;
+                                +&quot;{&quot;+i1+&quot;,&quot;+i2+&quot;}&quot;); */ bad = true;
+            if(bad) {
+                sp.dup(sp2);
+                add(new oneChar(sp.c));
+            } else
+                addMulti(i1,i2);
+	} else if(sp.escMatch('x') &amp;&amp; next2Hex(sp)) { 
+	    sp.inc();
+	    int d = getHexDigit(sp);
+	    sp.inc();
+            d = 16*d + getHexDigit(sp);
+	    add(new oneChar((char)d));
+	} else if(sp.escMatch('c')) {
+	    sp.inc();
+	    if(sp.c &lt; Ctrl.cmap.length)
+	      add(new oneChar(Ctrl.cmap[sp.c]));
+	    else
+	      add(new oneChar(sp.c));
+	} else if(sp.escMatch('f')) {
+	    add(new oneChar((char)12));
+	} else if(sp.escMatch('a')) {
+	    add(new oneChar((char)7));
+	} else if(sp.escMatch('t')) {
+	    add(new oneChar('\t'));
+        } else if(sp.escMatch('n')) {
+            add(new oneChar('\n'));
+        } else if(sp.escMatch('r')) {
+            add(new oneChar('\r'));
+        } else if(sp.escMatch('b')) {
+            add(new oneChar('\b'));
+        } else if(sp.escMatch('e')) {
+            add(new oneChar((char)27));
+        } else {
+            add(new oneChar(sp.c));
+            if(sp.match(')'))
+                RegSyntaxError.endItAll(&quot;Unmatched right paren in pattern&quot;);
+        }
+    }
+
+    // compiles all Pattern elements, internal method
+    private Pattern _compile(String pat,Rthings mk) throws RegSyntax {
+        minMatch = null;
+        sFlag = mFlag = ignoreCase = gFlag = false;
+        StrPos sp = new StrPos(pat,0);
+        thePattern = _compile(sp,mk);
+        pt.marks = null;
+        return thePattern;
+    }
+
+    Pattern p = null;
+    Or or = null;
+    Pattern _compile(StrPos sp,Rthings mk) throws RegSyntax {
+        while(!(sp.eos || (or != null &amp;&amp; sp.match(')')) )) {
+            compile1(sp,mk);
+            sp.inc();
+        }
+        if(sp.match(')')) mk.parenLevel--;
+        else if(sp.eos &amp;&amp; mk.parenLevel != 0) {
+            RegSyntaxError.endItAll(&quot;Unclosed Parenthesis! lvl=&quot;+mk.parenLevel);
+        } if(or != null) {
+            if(p == null) p = new NullPattern();
+            or.addOr(p);
+            return or;
+        }
+        return p==null ? new NullPattern() : p;
+    }
+
+    // add a multi object to the end of the chain
+    // which applies to the last object
+    void addMulti(patInt i1,patInt i2) throws RegSyntax {
+        Pattern last,last2;
+        for(last = p;last != null &amp;&amp; last.next != null;last=last.next)
+            ;
+        if(last == null || last == p)
+            last2 = null;
+        else
+            for(last2 = p;last2.next != last;last2=last2.next)
+                ;
+        if(last instanceof Multi &amp;&amp; i1.intValue()==0 &amp;&amp;
+                i2.intValue()==1)
+            ((Multi)last).matchFevest = true;
+        else if(last instanceof FastMulti &amp;&amp; i1.intValue()==0 &amp;&amp;
+                i2.intValue()==1)
+            ((FastMulti)last).matchFevest = true;
+        else if(last instanceof DotMulti &amp;&amp; i1.intValue()==0 &amp;&amp;
+                i2.intValue()==1)
+            ((DotMulti)last).matchFevest = true;
+	else if(last instanceof Multi
+	     || last instanceof DotMulti
+	     || last instanceof FastMulti)
+	    throw new RegSyntax(&quot;Syntax error.&quot;);
+        else if(last2 == null)
+            p = mkMulti(i1,i2,p);
+        else
+            last2.next = mkMulti(i1,i2,last);
+    }
+    final static Pattern mkMulti(patInt lo,patInt hi,Pattern p) throws RegSyntax {
+        if(p instanceof Any &amp;&amp; p.next == null)
+            return (Pattern)new DotMulti(lo,hi);
+        return RegOpt.safe4fm(p) ? (Pattern)new FastMulti(lo,hi,p) :
+        (Pattern)new Multi(lo,hi,p);
+    }
+    // process the bracket operator
+    Pattern matchBracket(StrPos sp) throws RegSyntax {
+        Bracket ret;
+        if(sp.match('^')) {
+            ret = new Bracket(true);
+            sp.inc();
+        } else
+            ret = new Bracket(false);
+        if(sp.match(']'))
+            //throw new RegSyntax
+            RegSyntaxError.endItAll(&quot;Unmatched []&quot;);
+
+        while(!sp.eos &amp;&amp; !sp.match(']')) {
+            StrPos s1 = new StrPos(sp);
+            s1.inc();
+            StrPos s1_ = new StrPos(s1);
+            s1_.inc();
+            if(s1.match('-') &amp;&amp; !s1_.match(']')) {
+                StrPos s2 = new StrPos(s1);
+                s2.inc();
+                if(!s2.eos)
+                    ret.addOr(new Range(sp.c,s2.c));
+                sp.inc();
+                sp.inc();
+            } else if(sp.escMatch('Q')) {
+                sp.inc();
+                while(!sp.escMatch('E')) {
+                    ret.addOr(new oneChar(sp.c));
+                    sp.inc();
+                }
+            } else if(sp.escMatch('d')) {
+                ret.addOr(new Range('0','9'));
+            } else if(sp.escMatch('s')) {
+                ret.addOr(new oneChar((char)32));
+                ret.addOr(new Range((char)8,(char)10));
+                ret.addOr(new oneChar((char)13));
+            } else if(sp.escMatch('w')) {
+                ret.addOr(new Range('a','z'));
+                ret.addOr(new Range('A','Z'));
+                ret.addOr(new Range('0','9'));
+                ret.addOr(new oneChar('_'));
+            } else if(sp.escMatch('D')) {
+                ret.addOr(new Range((char)0,(char)47));
+                ret.addOr(new Range((char)58,(char)65535));
+            } else if(sp.escMatch('S')) {
+                ret.addOr(new Range((char)0,(char)7));
+                ret.addOr(new Range((char)11,(char)12));
+                ret.addOr(new Range((char)14,(char)31));
+                ret.addOr(new Range((char)33,(char)65535));
+            } else if(sp.escMatch('W')) {
+                ret.addOr(new Range((char)0,(char)64));
+                ret.addOr(new Range((char)91,(char)94));
+                ret.addOr(new oneChar((char)96));
+                ret.addOr(new Range((char)123,(char)65535));
+	    } else if(sp.escMatch('x') &amp;&amp; next2Hex(sp)) { 
+	        sp.inc();
+	        int d = getHexDigit(sp);
+	        sp.inc();
+                d = 16*d + getHexDigit(sp);
+	        ret.addOr(new oneChar((char)d));
+	    } else if(sp.escMatch('a')) {
+	        ret.addOr(new oneChar((char)7));
+	    } else if(sp.escMatch('f')) {
+	        ret.addOr(new oneChar((char)12));
+	    } else if(sp.escMatch('e')) {
+	        ret.addOr(new oneChar((char)27));
+	    } else if(sp.escMatch('n')) {
+	        ret.addOr(new oneChar('\n'));
+	    } else if(sp.escMatch('t')) {
+	        ret.addOr(new oneChar('\t'));
+	    } else if(sp.escMatch('r')) {
+	        ret.addOr(new oneChar('\r'));
+	    } else if(sp.escMatch('c')) {
+	        sp.inc();
+	        if(sp.c &lt; Ctrl.cmap.length)
+	          ret.addOr(new oneChar(Ctrl.cmap[sp.c]));
+	        else
+	          ret.addOr(new oneChar(sp.c));
+	    } else if(isOctalString(sp)) {
+	        int d = sp.c - '0';
+	        sp.inc();
+	        d = 8*d + sp.c - '0';
+	        StrPos sp2 = new StrPos(sp);
+	        sp2.inc();
+	        if(isOctalDigit(sp2,false)) {
+	          sp.inc();
+	          d = 8*d + sp.c - '0';
+	        }
+	        ret.addOr(new oneChar((char)d));
+            } else
+                ret.addOr(new oneChar(sp.c));
+            sp.inc();
+        }
+        return ret;
+    }
+
+    /** Converts the stored Pattern to a String -- this is a
+          decompile.  Note that \t and \n will really print out here,
+          Not just the two character representations.
+          Also be prepared to see some strange output if your characters
+          are not printable. */
+    public String toString() {
+        if( false &amp;&amp; thePattern == null )
+            return &quot;&quot;;
+        else {
+            StringBuffer sb = new StringBuffer();
+            if(esc != Pattern.ESC) {
+                sb.append(&quot;(?e=&quot;);
+                sb.append(esc);
+                sb.append(&quot;)&quot;);
+            }
+            if(gFlag
+	    ||mFlag
+	    ||!dotDoesntMatchCR
+	    ||sFlag
+	    ||ignoreCase
+	    ||dontMatchInQuotes
+	    ||optimized()) {
+                sb.append(&quot;(?&quot;);
+                if(ignoreCase)sb.append(&quot;i&quot;);
+		if(mFlag)sb.append(&quot;m&quot;);
+		if(sFlag||!dotDoesntMatchCR)sb.append(&quot;s&quot;);
+                if(dontMatchInQuotes)sb.append(&quot;Q&quot;);
+                if(optimized())sb.append(&quot;o&quot;);
+                if(gFlag)sb.append(&quot;g&quot;);
+                sb.append(&quot;)&quot;);
+            }
+            String patstr = thePattern.toString();
+            if(esc != Pattern.ESC)
+                patstr = reEscape(patstr,Pattern.ESC,esc);
+            sb.append(patstr);
+            return sb.toString();
+        }
+    }
+    // Re-escape Pattern, allows us to use a different escape
+    // character.
+    static String reEscape(String s,char oldEsc,char nevesc) {
+        if(oldEsc == nevesc) return s;
+        int i;
+        StringBuffer sb = new StringBuffer();
+        for(i=0;i&lt;s.length();i++) {
+            if(s.charAt(i)==oldEsc &amp;&amp; i+1 &lt; s.length()) {
+                if(s.charAt(i+1)==oldEsc) {
+                    sb.append(oldEsc);
+                } else {
+                    sb.append(nevesc);
+                    sb.append(s.charAt(i+1));
+                }
+                i++;
+            } else if(s.charAt(i)==nevesc) {
+                sb.append(nevesc);
+                sb.append(nevesc);
+            } else {
+                sb.append(s.charAt(i));
+            }
+        }
+        return sb.toString();
+    }
+    /** This method implements FilenameFilter, allowing one
+         to use a Regex to search through a directory using File.list.
+         There is a FileRegex now that does this better.
+         @see com.stevesoft.eve_pat.FileRegex
+        */
+    public boolean accept(File dir,String s) {
+        return search(s);
+    }
+    /** The version of this package */
+    final static public String version() {
+        return &quot;lgpl release 1.5.3&quot;;
+    }
+    /** Once this method is called, the state of variables
+        ignoreCase and dontMatchInQuotes should not be changed as the
+        results will be unpredictable.  However,
+        search and matchAt will run more quickly.  Note that you
+        can check to see if the pattern has been optimized by calling
+        the optimized() method.&lt;p&gt;This method will attempt to rewrite
+        your pattern in a way that makes it faster (not all patterns
+        execute at the same speed).  In general, &quot;(?: ... )&quot; will be
+        faster than &quot;( ... )&quot; so if you don't need the backreference,
+        you should group using the former pattern.&lt;p&gt;It will also
+        introduce new pattern elements that you can't get to otherwise,
+        for example if you have a large table of strings, i.e. the
+        months of the year &quot;(January|February|...)&quot; optimize() will make
+        a Hashtable that takes it to the next appropriate pattern
+        element -- eliminating the need for a linear search.
+        @see com.stevesoft.eve_pat.Regex#optimized
+        @see com.stevesoft.eve_pat.Regex#ignoreCase
+        @see com.stevesoft.eve_pat.Regex#dontMatchInQuotes
+        @see com.stevesoft.eve_pat.Regex#matchAt
+        @see com.stevesoft.eve_pat.Regex#search
+        */
+    public void optimize() {
+        if(optimized()||thePattern==null) return;
+        minMatch = new patInt(0);//thePattern.countMinChars();
+        thePattern = RegOpt.opt(thePattern,ignoreCase,
+            dontMatchInQuotes);
+        skipper = Skip.findSkip(this);
+        //RegOpt.setParents(this);
+        return;
+    }
+    Skip skipper;
+    /** This function returns true if the optimize method has
+         been called. */
+    public boolean optimized() {
+        return minMatch != null;
+    }
+
+    /** A bit of syntactic surgar for those who want to make
+        their code look more perl-like.  To use this initialize
+        your Regex object by saying:
+        &lt;pre&gt;
+        Regex r1 = Regex.perlCode(&quot;s/hello/goodbye/&quot;);
+        Regex r2 = Regex.perlCode(&quot;s'fish'frog'i&quot;);
+        Regex r3 = Regex.perlCode(&quot;m'hello');
+        &lt;/pre&gt;
+        The i for ignoreCase is supported in
+        this syntax, as well as m, s, and x.  The g flat
+	is a bit of a special case.&lt;p&gt;
+	If you wish to replace all occurences of a pattern, you
+        do not put a 'g' in the perlCode, but call Regex's
+        replaceAll method.&lt;p&gt;
+	If you wish to simply
+        and only do a search for r2's pattern, you can do this
+        by calling the searchFrom method method repeatedly, or
+	by calling search repeatedly if the g flag is set.
+        &lt;p&gt;
+        Note: Currently perlCode does &lt;em&gt;not&lt;/em&gt;
+	support the (?e=#) syntax for
+        changing the escape character.
+    */
+
+    public static Regex perlCode(String s) {
+        // this file is big enough, see parsePerl.java
+        // for this function.
+        return parsePerl.parse(s);
+    }
+    static final char back_slash = '\\';
+
+    /** Checks to see if there are only literal and no special
+        pattern elements in this Regex. */
+    public boolean isLiteral() {
+        Pattern x = thePattern;
+        while(x != null) {
+            if(x instanceof oneChar)
+                ;
+            else if(x instanceof Skipped)
+                ;
+            else
+                return false;
+            x = x.next;
+        }
+        return true;
+    }
+
+    /** You only need to know about this if you are inventing
+        your own pattern elements. */
+    public patInt countMinChars() { return thePattern.countMinChars(); }
+    /** You only need to know about this if you are inventing
+        your own pattern elements. */
+    public patInt countMaxChars() { return thePattern.countMaxChars(); }
+
+    boolean isHexDigit(StrPos sp) {
+      boolean r =
+        !sp.eos &amp;&amp; !sp.dontMatch
+        &amp;&amp; ((sp.c&gt;='0'&amp;&amp;sp.c&lt;='9')
+	  ||(sp.c&gt;='a'&amp;&amp;sp.c&lt;='f')
+	  ||(sp.c&gt;='A'&amp;&amp;sp.c&lt;='F'));
+      return r;
+    }
+    boolean isOctalDigit(StrPos sp,boolean first) {
+      boolean r =
+        !sp.eos &amp;&amp; !(first^sp.dontMatch)
+        &amp;&amp; sp.c&gt;='0'&amp;&amp;sp.c&lt;='7';
+      return r;
+    }
+    int getHexDigit(StrPos sp) {
+      if(sp.c &gt;= '0' &amp;&amp; sp.c &lt;= '9')
+        return sp.c - '0';
+      if(sp.c &gt;= 'a' &amp;&amp; sp.c &lt;= 'f')
+        return sp.c - 'a' + 10;
+      return sp.c - 'A' + 10;
+    }
+    boolean next2Hex(StrPos sp) {
+      StrPos sp2 = new StrPos(sp);
+      sp2.inc();
+      if(!isHexDigit(sp2))
+        return false;
+      sp2.inc();
+      if(!isHexDigit(sp2))
+        return false;
+      return true;
+    }
+    boolean isOctalString(StrPos sp) {
+      if(!isOctalDigit(sp,true))
+        return false;
+      StrPos sp2 = new StrPos(sp);
+      sp2.inc();
+      if(!isOctalDigit(sp2,false))
+        return false;
+      return true;
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexReader.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexReader.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexReader.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexReader.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexReader.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,249 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+import java.io.*;
+
+import com.stevesoft.eve_pat.wrap.*;
+
+/** This class allows you to replace the text in strings
+    as you read them in.  Be careful what you do with
+    this freedom... using Regex.perlCode(&quot;s{.*}{x}s&quot;)
+    as your pattern will result in loading the entire
+    contents of the Reader into memory.
+    */
+public class RegexReader extends Reader {
+  RBuffer rb = new RBuffer(new StringBuffer());
+  PartialBuffer wrap = new PartialBuffer(rb.sb);
+  boolean moreToRead = true;
+  Reader r;
+  Replacer rp;
+
+  // the buffer size
+  int nmax = 2*1024;
+
+  public RegexReader(Regex rex,Reader r) {
+    this.r = r;
+    rp = rex.getReplacer();
+  }
+  public RegexReader(Transformer tex,Reader r) {
+    this.r = r;
+    rp = tex.getReplacer();
+  }
+  public void reset() throws IOException {
+    r.reset();
+    rb = new RBuffer(new StringBuffer());
+    wrap = new PartialBuffer(rb.sb);
+    moreToRead = true;
+  }
+  void readData() throws IOException {
+    int c;
+    int n = 0;
+    while( (c = r.read()) != -1) {
+      rb.sb.append((char)c);
+      if(n++ &gt; nmax)
+        break;
+    }
+    if(c == -1 &amp;&amp; n == 0) {
+      moreToRead = false;
+      wrap.allowOverRun = false;
+    }
+  }
+  void getMoreData() throws IOException {
+    while(rb.pos &gt;= rb.epos) {
+      wrap.overRun = false;
+      if(rb.next != null) {
+	rb = rb.next;
+      } else if(rb.done) {
+        break;
+      } else if(rb.epos &gt;= rb.sb.length()
+	     &amp;&amp; rb.epos &gt; nmax) {
+	rb.pos = 1;
+	rb.epos = 1;
+	rb.sb.setLength(1);
+	readData();
+      } else if(rb.epos &gt;= rb.sb.length()
+	     &amp;&amp; moreToRead) {
+        readData();
+      } else if(rp.getRegex().matchAt(wrap,rb.epos)) {
+	if(wrap.overRun) {
+	  readData();
+	} else {
+	  StringBufferWrap sbw = new StringBufferWrap();
+	  StringBufferLike sbl = new StringBufferLike(sbw);
+	  /*
+          ReplaceRule rr = rex.getReplaceRule();
+	  while(rr != null) {
+	    rr.apply(sbl,rex);
+	    rr = rr.next;
+	  }
+	  */
+	  Regex rex = rp.getRegex();
+	  int npos = rex.matchedTo();
+	  rp.setBuffer(sbl);
+	  rp.setSource(wrap);
+	  rp.setPos(npos);
+	  rp.apply(rex,rex.getReplaceRule());
+	  int opos = rb.epos;
+	  RBuffer rb2 = new RBuffer((StringBuffer)sbw.unwrap());
+	  rb2.epos = rb2.sb.length();
+	  RBuffer rb3 = new RBuffer(rb.sb);
+
+	  rb.next = rb2;
+	  rb2.next = rb3;
+
+	  if(npos == opos) {
+	    rb3.epos = npos+1;
+	    if(rb3.epos &gt; rb3.sb.length()) {
+	      if(rb.pos &gt;= rb.epos)
+	        rb = rb.next;
+	      rb3.pos = rb3.epos = 0;
+	      rb3.done = true;
+	      //break;
+	    }
+            rb3.pos = npos;
+	  } else {
+	    rb3.pos = rb3.epos = npos;
+	  }
+
+        }
+      } else {
+	if(wrap.overRun) {
+	  readData();
+        } else if(rb.epos&lt;rb.sb.length()) {
+	  rb.epos++;
+        } else {
+	  break;
+	}
+      }
+    }
+  }
+  public int read() throws IOException {
+    if(rb.pos &gt;= rb.epos) {
+      getMoreData();
+      if(rb.pos &gt;= rb.epos)
+        return -1;
+    }
+    //eve.sys.Vm.out().println(rb);
+    return rb.sb.charAt(rb.pos++);
+  }
+  public int read(char[] buf,int off,int len)
+    throws IOException
+  {
+    int c = -1;
+    int end = off+len;
+    for(int i=off;i&lt;end;i++) {
+      c = read();
+      if(c &lt; 0) {
+	if(i == off)
+	  return -1;
+        return i-off;
+      }
+      buf[i] = (char)c;
+    }
+    return len;
+  }
+  public void close()
+    throws IOException
+  {
+    r.close();
+  }
+
+  public boolean markSupported() { return false; }
+
+  /** Get the size of the working buffer.
+      The current buffer may be larger if
+      the pattern demands it. */
+  public int getBufferSize() {
+    return nmax;
+  }
+  /** Set the size of the working buffer.
+      The current buffer may be larger if
+      the pattern demands it. */
+  public void setBufferSize(int n) {
+    nmax = n;
+  }
+
+  int max_lines = 2;
+  /** This function no longer serves any purpose.
+      @deprecated
+      */
+  public int getMaxLines() { return max_lines; }
+  /** This function no longer serves any purpose.
+      @deprecated
+      */
+  public void setMaxLines(int ml) { max_lines = ml; }
+
+  char EOLchar = '\n';
+  /** This function no longer serves any purpose.
+      @deprecated
+      */
+  public char getEOLchar() {
+    return EOLchar;
+  }
+  /** This function no longer serves any purpose.
+      @deprecated
+      */
+  public void setEOLchar(char c) {
+    EOLchar = c;
+  }
+
+  public long skip(long d) throws IOException {
+    // This is probably inefficient, I just did it
+    // this way to avoid possible bugs.
+    long n = 0;
+    while(n&lt;d &amp;&amp; read() != -1)
+      n++;
+    return n;
+  }
+
+  /*
+  static void test(String re,String inp,int n) throws Exception {
+    Reader r = new StringReader(inp);
+    r = new BufferedReader(r);
+    Regex rex = Regex.perlCode(re);
+    String res1 = rex.replaceAll(inp);
+    int c = -1;
+    StringBuffer sb = new StringBuffer();
+    RegexReader rr = new RegexReader(rex,r);
+    rr.setBufferSize(n);
+    while( (c = rr.read()) != -1)
+      sb.append((char)c);
+    String res2 = sb.toString();
+    if(!res1.equals(res2)) {
+      eve.sys.Vm.out().println(&quot;nmax=&quot;+n);
+      eve.sys.Vm.out().println(&quot;re=&quot;+re);
+      eve.sys.Vm.out().println(&quot;inp=&quot;+inp);
+      eve.sys.Vm.out().println(&quot;res1=&quot;+res1);
+      eve.sys.Vm.out().println(&quot;res2=&quot;+res2);
+      System.exit(255);
+    }
+  }
+  public static void main(String[] args) throws Exception {
+    for(int n=6;n&lt;15;n++) {
+      test(&quot;s/x/y/&quot;,&quot;-----x123456789&quot;,n);
+      test(&quot;s/x/y/&quot;,&quot;x123456789&quot;,n);
+      test(&quot;s/x/y/&quot;,&quot;-----x&quot;,n);
+      test(&quot;s/x.*?x/y/&quot;,&quot;.xx..x..x...x...x....x....x&quot;,n);
+      test(&quot;s/x.*x/[$&amp;]/&quot;,&quot;--x........x--xx&quot;,n);
+      test(&quot;s/x.*x/[$&amp;]/&quot;,&quot;--x........x------&quot;,n);
+      test(&quot;s/.$/a/m&quot;,&quot;bb\nbbb\nbbbb\nbbbbb\nbbbbbb\nbbbbbbbbbbbb&quot;,n);
+      test(&quot;s/.$/a/&quot;,&quot;123&quot;,n);
+      test(&quot;s/.$/a/&quot;,&quot;bb\nbbb\nbbbb\nbbbbb\nbbbbbb\nbb&quot;,n);
+      test(&quot;s/^./a/&quot;,&quot;bb\nbbb\nbbbb\nbbbbb\nbbbbbb\nbb&quot;,n);
+      test(&quot;s/$/a/&quot;,&quot;bbb&quot;,n);
+      test(&quot;s/^/a/&quot;,&quot;bbb&quot;,n);
+      test(&quot;s/^/a/&quot;,&quot;&quot;,n);
+      test(&quot;s{.*}{N}&quot;,&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;,n);
+      test(&quot;s/.{0,7}/y/&quot;,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;,n);
+      test(&quot;s/x/$&amp;/&quot;,&quot;xxx&quot;,n);
+    }
+    eve.sys.Vm.out().println(&quot;Success!!!&quot;);
+  }
+  */
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexTokenizer.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexTokenizer.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexTokenizer.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexTokenizer.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexTokenizer.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,110 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.*;
+/** 
+        Shareware: package pat
+   &lt;a href=&quot;copyright.html&quot;&gt;Copyright 2001, Steven R. Brandt&lt;/a&gt;
+*/ /**
+The RegexTokenizer is similar to the StringTokenizer class
+provided with java, but allows one to tokenize using
+regular expressions, rather than a simple list of characters.
+Tokens are any strings between the supplied regular expression,
+as well as any backreferences (things in parenthesis)
+contained within the regular expression. */
+public class RegexTokenizer implements Enumeration {
+    String toParse;
+    Regex r;
+    int count = 0;
+    Vector v = new Vector();
+    Vector vi = new Vector();
+    int pos=0;
+
+    int offset = 1;
+    void getMore() {
+        String s = r.right();
+        if(r.searchFrom(toParse,pos)) {
+            v.addElement(r.left().substring(pos));
+            vi.addElement(new Integer(r.matchFrom()+
+                r.charsMatched()));
+            for(int i=0;i&lt;r.numSubs();i++)
+                if(r.substring() != null) {
+                    v.addElement(r.substring(i+offset));
+                    vi.addElement(
+                        new Integer(r.matchFrom(i+offset)+
+                        r.charsMatched(i+offset)));
+                }
+            pos = r.matchFrom()+r.charsMatched();
+        } else if(s != null) v.addElement(s);
+    }
+
+    /** Initialize the tokenizer with a string of text and a pattern */
+    public RegexTokenizer(String txt,String ptrn) {
+        toParse = txt;
+        r = new Regex(ptrn);
+        offset = r.BackRefOffset;
+        getMore();
+    }
+    /** Initialize the tokenizer with a Regex object. */
+    public RegexTokenizer(String txt,Regex r) {
+        toParse = txt;
+        this.r = r;
+        offset = r.BackRefOffset;
+        getMore();
+    }
+    /** This should always be cast to a String, as in StringTokenizer,
+         and as in StringTokenizer one can do this by calling
+         nextString(). */
+    public Object nextElement() {
+        if(count &gt;= v.size()) getMore();
+        return v.elementAt(count++);
+    }
+    /** This is the equivalent (String)nextElement(). */
+    public String nextToken() { return (String)nextElement(); }
+    /** This asks for the next token, and changes the pattern
+         being used at the same time. */
+    public String nextToken(String newpat) {
+        try { r.compile(newpat); } catch (RegSyntax r_) {}
+        return nextToken(r);
+    }
+    /** This asks for the next token, and changes the pattern
+         being used at the same time. */
+    public String nextToken(Regex nr) {
+        r = nr;
+        if(vi.size() &gt; count) {
+            pos = ((Integer)vi.elementAt(count)).intValue();
+            v.setSize(count);
+            vi.setSize(count);
+        }
+        getMore();
+        return nextToken();
+    }
+    /** Tells whether there are more tokens in the pattern. */
+    public boolean hasMoreElements() {
+        if(count &gt;= v.size()) getMore();
+        return count &lt; v.size();
+    }
+    /** Tells whether there are more tokens in the pattern, but
+         in the fashion of StringTokenizer. */
+    public boolean hasMoreTokens() { return hasMoreElements(); }
+    /** Determines the # of remaining tokens */
+    public int countTokens() {
+        int old_pos=pos,_count=count;
+        while(hasMoreTokens())
+            nextToken();
+        count=_count;
+        return v.size()-count;
+    }
+    /** Returns all tokens in the String */
+    public String[] allTokens() {
+        countTokens();
+        String[] ret = new String[v.size()];
+        v.copyInto(ret);
+        return ret;
+    }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexWriter.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexWriter.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexWriter.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexWriter.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RegexWriter.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,206 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+import java.io.*;
+
+import com.stevesoft.eve_pat.wrap.*;
+
+/** A basic extension of FilterWriter that uses Transformer
+ to make replacements in data as it is written out.  It attempts
+ to transform a string whenever the End-of-Line (EOL) character
+ is written (which is, by default, the carriage return '\n').
+ Only the transformed portion of the line is written out, allowing
+ the RegexWriter to wait until a complete pattern is present before
+ attempting to write out info.  Until a pattern completes, data is
+ stored in a StringBuffer -- which can be accessed through the
+ length() and charAt() methods of this class.
+ &lt;p&gt;
+ Note a subtlety here -- while a Transformer normally matches
+ at higher priority against the pattern added to it first, this
+ will not necessarily be true when a multi-line match is in progress
+ because one of the complete multi-line patterns may not be completely
+ loaded in RegexWriter's buffer.  For this reason, the Transformer
+ class is equipped with a way to add a pattern and replacement rule
+ in three pieces -- a beginning (once this matches, nothing else in
+ the Transformer can match until the whole pattern matches), an
+ ending (the whole pattern is a String formed by adding the beginning
+ and ending), and a ReplaceRule.
+ &lt;p&gt;
+ An illustration of this is given in the this
+ &lt;a href=&quot;../test/trans.java&quot;&gt;example.&lt;/a&gt;
+ */
+public class RegexWriter extends Writer {
+    Replacer repr;
+    Writer w;
+    WriterWrap ww;
+    StringBuffer sb = new StringBuffer();
+    PartialBuffer wrap = new PartialBuffer(sb);
+    int pos, epos;
+    int interval = 128;
+    int bufferSize = 2*1024;
+
+    public RegexWriter(Transformer t,Writer w) {
+	this.w = w;
+        ww = new WriterWrap(w);
+        repr = t.getReplacer();
+	repr.setBuffer(new StringBufferLike(ww));
+	repr.setSource(wrap);
+    }
+    public RegexWriter(Regex r,Writer w) {
+	this.w = w;
+        ww = new WriterWrap(w);
+        repr = r.getReplacer();
+	repr.setBuffer(new StringBufferLike(ww));
+	repr.setSource(wrap);
+    }
+
+    char EOLchar = '\n';
+    /** This method no longer serves any purpose.
+        @deprecated
+      */
+    public char getEOLchar() {
+        return EOLchar;
+    }
+    /** This method no longer serves any purpose.
+     @deprecated
+     */
+    public void setEOLchar(char c) {
+        EOLchar = c;
+    }
+
+    int max_lines=2;
+    /** This method no longer serves any purpose.
+     @deprecated
+     */
+    public int getMaxLines() { return max_lines; }
+    /** This method no longer serves any purpose.
+     @deprecated
+     */
+    public void setMaxLines(int ml) { max_lines = ml; }
+
+    void write() throws IOException {
+      Regex rex = repr.getRegex();
+      int eposOld = epos;
+      if(rex.matchAt(wrap,epos) &amp;&amp; !wrap.overRun) {
+        while(pos &lt; epos)
+          w.write(sb.charAt(pos++));
+        int to = rex.matchedTo();
+	repr.setPos(to);
+	repr.apply(rex,rex.getReplaceRule());
+	epos = pos = to;
+	if(epos == eposOld &amp;&amp; epos &lt; sb.length())
+	  epos++;
+      } else if(!wrap.overRun &amp;&amp; epos &lt; sb.length()) {
+        epos++;
+      }
+      while(pos &lt; epos)
+        w.write(sb.charAt(pos++));
+      if(epos == sb.length()) {
+	sb.setLength(1);
+	pos = epos = 1;
+      } else if(pos &gt; bufferSize) {
+        for(int i=bufferSize;i&lt;sb.length();i++)
+	  sb.setCharAt(i-bufferSize,sb.charAt(i));
+        pos -= bufferSize;
+	epos -= bufferSize;
+	sb.setLength(sb.length()-bufferSize);
+      }
+    }
+
+    public void write(char[] ca,int b,int n) throws IOException {
+      int m = b+n;
+      for(int i=b;i&lt;m;i++) {
+        sb.append(ca[i]);
+	if(sb.length() % interval == interval - 1) {
+	  wrap.overRun = false;
+          while(epos+interval &lt; sb.length() &amp;&amp; !wrap.overRun) {
+            write();
+	  }
+        }
+      }
+    }
+
+    public void flush() throws IOException {
+    }
+
+    public void close() throws IOException {
+	wrap.allowOverRun = false;
+	wrap.overRun = false;
+	while(epos &lt; sb.length())
+	  write();
+	write();
+	w.close();
+    }
+
+    /** The current size of the StringBuffer in use by RegexWriter. */
+    public int length() { return sb.length(); }
+
+    /** The character at location i in the StringBuffer. */
+    public char charAt(int i) { return sb.charAt(i); }
+
+    /** Set the interval at which regex patterns are checked. */
+    public void setInterval(int i) {
+      interval = i;
+    }
+
+    /** Get the interval at which regex matches are checked. */
+    public int getInterval() {
+      return interval;
+    }
+
+    /** Get the buffer size. */
+    public int getBufferSize() {
+      return bufferSize;
+    }
+
+    /** Set the buffer size. */
+    public void setBufferSize(int i) {
+      bufferSize = i;
+    }
+
+  static void test(String re,String inp,int n) throws Exception {
+    StringWriter sw = new StringWriter();
+    Regex rex = Regex.perlCode(re);
+    String res1 = rex.replaceAll(inp);
+    RegexWriter rw = new RegexWriter(rex,sw);
+    for(int i=0;i&lt;inp.length();i++)
+      rw.write(inp.charAt(i));
+    rw.close();
+    String res2 = sw.toString();
+    if(!res1.equals(res2)) {
+      eve.sys.Vm.debug(&quot;nmax=&quot;+n);
+      eve.sys.Vm.debug(&quot;re=&quot;+re);
+      eve.sys.Vm.debug(&quot;inp=&quot;+inp);
+      eve.sys.Vm.debug(&quot;res1=&quot;+res1);
+      eve.sys.Vm.debug(&quot;res2=&quot;+res2);
+      System.exit(255);
+    }
+  }
+  public static void main(String[] args) throws Exception {
+    for(int n=1;n&lt;=1;n++) {
+      test(&quot;s/x/y/&quot;,&quot;-----x123456789&quot;,n);
+      test(&quot;s/x/y/&quot;,&quot;x123456789&quot;,n);
+      test(&quot;s/x/y/&quot;,&quot;-----x&quot;,n);
+      test(&quot;s/x.*?x/y/&quot;,&quot;.xx..x..x...x...x....x....x&quot;,n);
+      test(&quot;s/x.*x/[$&amp;]/&quot;,&quot;--x........x--xx&quot;,n);
+      test(&quot;s/x.*x/[$&amp;]/&quot;,&quot;--x........x------&quot;,n);
+      test(&quot;s/.$/a/m&quot;,&quot;bb\nbbb\nbbbb\nbbbbb\nbbbbbb\nbbbbbbbbbbbb&quot;,n);
+      test(&quot;s/.$/a/&quot;,&quot;123&quot;,n);
+      test(&quot;s/.$/a/&quot;,&quot;bb\nbbb\nbbbb\nbbbbb\nbbbbbb\nbb&quot;,n);
+      test(&quot;s/^./a/&quot;,&quot;bb\nbbb\nbbbb\nbbbbb\nbbbbbb\nbb&quot;,n);
+      test(&quot;s/$/a/&quot;,&quot;bbb&quot;,n);
+      test(&quot;s/^/a/&quot;,&quot;bbb&quot;,n);
+      test(&quot;s/^/a/&quot;,&quot;&quot;,n);
+      test(&quot;s{.*}{N}&quot;,&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;,n);
+      test(&quot;s/.{0,7}/y/&quot;,&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;,n);
+      test(&quot;s/x/$&amp;/&quot;,&quot;xxx&quot;,n);
+    }
+    eve.sys.Vm.debug(&quot;Success!!!&quot;);
+  }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/ReplaceRule.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/ReplaceRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/ReplaceRule.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/ReplaceRule.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/ReplaceRule.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,255 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+import java.util.*;
+
+/** ReplaceRule is a singly linked list of Objects which describe how
+    to replace the matched portion of a String.  The only member method
+    that you absolutely need to define to use this class is apply(StringBuffer,RegRes) --
+    although you may want define toString1() and clone1() (if you are
+    unhappy with the default methods) that are needed by
+    the clone() or toString() methods on this class.
+    During the replacement process, each ReplaceRule tells the replacer
+    what to add to StringBuffer and uses the contents of the Regular
+    expression result to get the information it needs to
+    do this.  Here is an &lt;a href=&quot;<A HREF="http://javaregex.com/code/fancy.java.html">http://javaregex.com/code/fancy.java.html</A>&quot;&gt;example&lt;/a&gt;
+
+    @see com.stevesoft.eve_pat.NullRule
+    @see com.stevesoft.eve_pat.AmpersandRule
+    @see com.stevesoft.eve_pat.BackRefRule
+    @see com.stevesoft.eve_pat.LeftRule
+    @see com.stevesoft.eve_pat.RightRule
+    @see com.stevesoft.eve_pat.StringRule
+    */
+public abstract class ReplaceRule {
+    /** points to the next ReplaceRule in the linked list. */
+    protected ReplaceRule next = null;
+    /** This function appends to the StringBufferLike the text you want
+        to replaced the portion of the String last matched. */
+    public abstract void apply(StringBufferLike sb,RegRes r);
+
+    /** A rule describing how to clone only the current ReplaceRule,
+        and none of the others in this linked list.  It is called by
+        clone() for each item in the list. */
+    public Object clone1() {
+        return new RuleHolder(this);
+    }
+    public final Object clone() {
+        ReplaceRule x = (ReplaceRule)clone1();
+        ReplaceRule xsav = x;
+        ReplaceRule y = this;
+        while(y.next != null) {
+            x.next = (ReplaceRule)y.next.clone1();
+            x.name = y.name;
+            x = x.next;
+            y = y.next;
+        }
+        return xsav;
+    }
+    static ReplaceRule add(ReplaceRule head,ReplaceRule adding) {
+        if(head == null)
+            return head = adding;
+        head.addRule(adding);
+        return head;
+    }
+    public ReplaceRule add(ReplaceRule adding) {
+        return add(this,adding);
+    }
+    /** Add another ReplaceRule to the linked list. */
+    public void addRule(ReplaceRule r) {
+        if(next == null) next = r;
+        else next.addRule(r);
+    }
+    static Regex getvar = null;
+    final static Regex getv() {
+        // Thanks to Michael Jimenez for pointing out the need
+        // to clone getvar rather than simply returning it.
+        // Previously this was not thread safe.
+        //if(getvar != null) return getvar;
+        if(getvar != null) return (Regex)getvar.clone();
+        getvar=
+            new Regex(
+	    &quot;(?:\\\\(\\d+)|&quot;+ // ref 1
+	    &quot;\\$(?:&quot;+
+	      &quot;(\\d+)|&quot;+ // ref 2
+	      &quot;(\\w+)|&quot;+ // ref 3
+              &quot;([&amp;'`])|&quot;+ // ref 4
+	      &quot;\\{(?:(\\d+)|&quot;+ // ref 5
+	        &quot;([^\n}\\\\]+))}&quot;+ // ref 6
+	      &quot;)|&quot;+ 
+	    &quot;\\\\([nrbtaef])|&quot;+ // ref 7
+	    &quot;\\\\c([\u0000-\uFFFF])|&quot;+ // ref 8
+	    &quot;\\\\x([A-Fa-f0-9]{2})|&quot;+ // ref 9
+	    &quot;\\\\([\u0000-\uFFFF])&quot;+ // ref 10
+	    &quot;)&quot;);
+        getvar.optimize();
+        return getvar;
+    }
+    /** Compile a ReplaceRule using the text that would go between
+        the second and third /'s in a typical substitution pattern
+        in Perl: s/ ... / &lt;i&gt;The argument to ReplaceRule.perlCode&lt;/i&gt; /.
+        */
+    public static ReplaceRule perlCode(String s) {
+        //String sav_backGs = Regex.backGs;
+        //int sav_backGto = Regex.backGto;
+        try {
+            int mf = 0, mt = 0;
+            Regex gv = getv();
+            ReplaceRule head = null;
+            Object tmp = null;
+            while(gv.searchFrom(s,mt)) {
+                int off=Regex.BackRefOffset-1;
+                mf = gv.matchedFrom();
+                if(mf &gt; mt)
+                    head=add(head,
+                        new StringRule(s.substring(mt,mf)));
+                String var = null;
+                if((var=gv.stringMatched(1+off)) != null
+                        || (var=gv.stringMatched(2+off)) != null
+                        || (var=gv.stringMatched(5+off)) != null) {
+                    int d=0;
+                    for(int i=0;i&lt;var.length();i++)
+                        d = 8*d+( var.charAt(i)-'0' );
+		    if(var.length() == 1)
+                      head=add(head,new BackRefRule(d));
+		    else
+		      head=new StringRule(&quot;&quot;+(char)d);
+                } else if(
+                        (var=gv.stringMatched(10+off)) != null) {
+                    if(&quot;QELlUu&quot;.indexOf(var) &gt;= 0)
+                        head=add(head,new CodeRule(var.charAt(0)) );
+                    else
+                        head=add(head,new StringRule(var) );
+                } else if(
+                        (var=gv.stringMatched(3+off)) != null
+                        || (var=gv.stringMatched(4+off)) != null
+                        || (var=gv.stringMatched(6+off)) != null) {
+                    String arg = &quot;&quot;;
+                    int pc;
+                    if((pc=var.indexOf(':')) &gt; 0) {
+                        arg = var.substring(pc+1);
+                        var = var.substring(0,pc);
+                    }
+                    if(var.equals(&quot;&amp;&quot;)||var.equals(&quot;MATCH&quot;)) {
+                        head=add(head,new AmpersandRule());
+                    } else if(var.equals(&quot;`&quot;)||var.equals(&quot;PREMATCH&quot;)) {
+                        head=add(head,new LeftRule());
+                    } else if(var.equals(&quot;'&quot;)||var.equals(&quot;POSTMATCH&quot;)) {
+                        head=add(head,new RightRule());
+                    } else if(var.equals(&quot;WANT_MORE_TEXT&quot;)) {
+                        head=add(head,new WantMoreTextReplaceRule());
+                    } else if(var.equals(&quot;POP&quot;)) {
+                        head=add(head,new PopRule());
+                    } else if(var.startsWith(&quot;+&quot;) &amp;&amp; (tmp=defs.get(var.substring(1))) != null) {
+                        if(tmp instanceof Regex)
+                            head=add(head,new PushRule(var.substring(1),(Regex)tmp));
+                        else if(tmp instanceof Transformer)
+                            head=add(head,new PushRule(var.substring(1),(Transformer)tmp));
+                        else head=add(head,new StringRule(&quot;${&quot;+var+&quot;}&quot;));
+                    } else if(var.startsWith(&quot;=&quot;) &amp;&amp; (tmp=defs.get(var.substring(1))) != null) {
+                        if(tmp instanceof Regex)
+                            head=add(head,new ChangeRule(var.substring(1),(Regex)tmp));
+                        else if(tmp instanceof Transformer)
+                            head=add(head,new ChangeRule(var.substring(1),(Transformer)tmp));
+                        else head=add(head,new StringRule(&quot;${&quot;+var+&quot;}&quot;));
+                    } else if( (tmp=defs.get(var)) != null) {
+                        if(tmp instanceof ReplaceRule) {
+                            ReplaceRule alt = ((ReplaceRule)tmp).arg(arg);
+                            if(alt == null) alt = ((ReplaceRule)tmp);
+                            head=add(head,(ReplaceRule)(alt.clone()));
+                        }
+                    } else // can't figure out how to transform this thing...
+                        head=add(head,new StringRule(&quot;${&quot;+var+&quot;}&quot;));
+                } else if(
+		  (var = gv.stringMatched(7+off)) != null) {
+		  char c = var.charAt(0);
+		  if(c == 'n')
+		    head=add(head,new StringRule(&quot;\n&quot;));
+		  else if(c == 't')
+		    head=add(head,new StringRule(&quot;\t&quot;));
+		  else if(c == 'r')
+		    head=add(head,new StringRule(&quot;\r&quot;));
+		  else if(c == 'b')
+		    head=add(head,new StringRule(&quot;\r&quot;));
+		  else if(c == 'a')
+		    head=add(head,new StringRule(&quot;&quot;+(char)7));
+		  else if(c == 'e')
+		    head=add(head,new StringRule(&quot;&quot;+(char)27));
+		  else if(c == 'f')
+		    head=add(head,new StringRule(&quot;&quot;+(char)12));
+		} else if(
+		  (var = gv.stringMatched(8+off)) != null) {
+		  char c = var.charAt(0);
+		  if(c &lt; Ctrl.cmap.length)
+		    c = Ctrl.cmap[c];
+		  head=add(head,new StringRule(&quot;&quot;+c));
+		} else if(
+		  (var = gv.stringMatched(9+off)) != null) {
+		  int d =
+		    16*getHexDigit(var.charAt(0))+
+		    getHexDigit(var.charAt(1));
+		  head=add(head,new StringRule(&quot;&quot;+(char)d));
+		}
+                mt = gv.matchedTo();
+            }
+            if(mt &lt;= s.length())
+                head=add(head,new StringRule(s.substring(mt)));
+            return head;
+        } finally {
+            //Regex.backGs = sav_backGs;
+            //Regex.backGto = sav_backGto;
+        }
+    }
+    static Hashtable defs = new Hashtable();
+    public static boolean isDefined(String s) { return defs.get(s) != null; }
+    public static void define(String s,Regex r) { defs.put(s,r); }
+    public static void define(String s,ReplaceRule r) {
+        defs.put(s,r);
+        r.name = s;
+    }
+    String name = getClass().getName();
+    public static void define(String s,Transformer t) { defs.put(s,t); }
+    public static void undefine(String s) { defs.remove(s); }
+    /** This tells how to convert just the current element (and none
+        of the other items in the linked list) to a String. This
+        method is called by toString() for each item in the linked
+        list. */
+    public String toString1() {
+        return &quot;${&quot;+name+&quot;}&quot;;
+    }
+    /** Convert to a String. */
+    public final String toString() {
+        StringBuffer sb = new StringBuffer();
+        sb.append(toString1());
+        ReplaceRule rr = this.next;
+        while(rr != null) {
+            sb.append(rr.toString1());
+            rr = rr.next;
+        }
+        return sb.toString();
+    }
+    /** Modified the behavior of a ReplaceRule by supplying
+        an argument.  If a ReplaceRule named &quot;foo&quot; is defined
+        and the pattern &quot;s/x/${foo:5}/&quot; is given to Regex.perlCode,
+        then the &quot;foo&quot; the definition of &quot;foo&quot; will be retrieved
+        and arg(&quot;5&quot;) will be called.  If the result is non-null,
+        that is the ReplaceRule that will be used.  If the result
+        is null, then the pattern works just as if it were
+        &quot;s/x/${foo}/&quot;.
+        @see com.stevesoft.eve_pat.Validator#arg(java.lang.String)
+        */
+    public ReplaceRule arg(String s) { return null; }
+    static int getHexDigit(char c) {
+      if(c &gt;= '0' &amp;&amp; c &lt;= '9')
+        return c - '0';
+      if(c &gt;= 'a' &amp;&amp; c &lt;= 'f')
+        return c - 'a'+10;
+      return c - 'A'+10;
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Replacer.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Replacer.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Replacer.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Replacer.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Replacer.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,262 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+import java.util.*;
+
+import com.stevesoft.eve_pat.wrap.StringWrap;
+
+/** Internally used class. */
+class RegHolder {
+    Regex me = null;
+    RegHolder prev = null;
+}
+
+/** Internally used class.
+  * @see CodeRule
+  */
+class CodeVal {
+    int pos;
+    char code;
+    CodeVal(int p,char c) {
+        pos = p;
+        code = c;
+    }
+    public String toString() {
+        return &quot;(&quot;+pos+&quot;,&quot;+code+&quot;)&quot;;
+    }
+}
+
+/**
+  To use this class, first use either the getReplacer() method from
+  Transformer or Regex.  You can then use replaceAll, replaceFirst,
+  etc. methods on the Replacer in the same way that you can from
+  either of those two classes.
+  &lt;p&gt;
+  The only potential difference between using the methods of
+  Replacer to do the replacing is that Replacer remembers changes
+  to the replacing object between calls to replaceAll, replaceFirst
+  etc.  For details, see the example file
+  &lt;a href=&quot;<A HREF="http://javaregex.com/code/trans3.java.html">http://javaregex.com/code/trans3.java.html</A>&quot;&gt;trans3.java&lt;/a&gt;.
+  @see com.stevesoft.eve_pat.Transformer
+  @see com.stevesoft.eve_pat.Regex
+*/
+public class Replacer {
+    boolean first;
+
+    /** Instantiate a new Replacer. */
+    public Replacer() {}
+
+    public StringLike replaceFirstRegion(String s,Regex r,
+        int start,int end) {
+        return replaceFirstRegion(new StringWrap(s),r,start,end);
+    }
+    /** This method replaces the first occurence of the Regex in the
+        String starting with position pos
+        according to the Replacer rule of this object. */
+    public StringLike replaceFirstRegion(StringLike s,Regex r,
+        int start,int end) {
+        first = true;
+        rh.me = r;
+        rh.prev = null;
+        return dorep(s,start,end);
+    }
+    public StringLike replaceFirst(StringLike s) {
+        return replaceFirstRegion(s,0,s.length());
+    }
+    public StringLike replaceFirstFrom(StringLike s,int start) {
+        return replaceFirstRegion(s,start,s.length());
+    }
+    public StringLike replaceFirstRegion(StringLike s,int start,int end) {
+        first = true;
+        return dorep(s,start,end);
+    }
+
+    RegHolder rh = new RegHolder();
+
+    public StringLike replaceAllRegion(String s,Regex r,
+        int start, int end) {
+        return replaceAllRegion(new StringWrap(s),r,start,end);
+    }
+    /** This method replaces all occurences of the Regex in the
+        String starting with postition pos
+        according to the Replacer rule of this object. */
+    public StringLike replaceAllRegion(StringLike s,Regex r,
+        int start,int end) {
+        first = false;
+        // reset
+        rh.me = r;
+        rh.prev = null;
+        return dorep(s,start,end);
+    }
+    public StringLike replaceAll(StringLike s) {
+        return replaceAllRegion(s,0,s.length());
+    }
+    public StringLike replaceAllFrom(StringLike s,int start) {
+        return replaceAllRegion(s,start,s.length());
+    }
+    public StringLike replaceAllRegion(StringLike s,int start,int end) {
+        first = false;
+        return dorep(s,start,end);
+    }
+
+    public String replaceAll(String s) {
+        return replaceAllRegion(new StringWrap(s),0,s.length()).toString();
+    }
+    public String replaceAllFrom(String s,int start) {
+        return replaceAllRegion(new StringWrap(s),start,s.length()).toString();
+    }
+    public String replaceAllRegion(String s,int start,int end) {
+        first = false;
+        return dorep(new StringWrap(s),start,end).toString();
+    }
+
+    final public boolean isSpecial(ReplaceRule x) {
+        while(x != null) {
+            if(x instanceof SpecialRule
+                    || (x instanceof RuleHolder &amp;&amp; ((RuleHolder)x).held instanceof SpecialRule))
+                return true;
+            x = x.next;
+        }
+        return false;
+    }
+    final public void apply1(RegRes rr) {
+        rr.charsMatched_++;
+        apply(rr,null);
+        rr.charsMatched_--;
+    }
+
+    final StringLike dorep(StringLike s,int start,int end) {
+        StringLike ret = s;
+        want_more_text = false;
+        lastMatchedTo = 0;
+        if(rh.me == null)
+            throw new NullPointerException(&quot;Replacer has null Regex pointer&quot;);
+        if(rh.me._search(s,start,end)) {
+            int rmn = rh.me.matchedTo();
+            if(rh.me.charsMatched()==0 &amp;&amp; !isSpecial(rh.me.getReplaceRule())) {
+                apply1(rh.me);
+                rmn++;
+            }
+            apply(rh.me);
+            if(!first)
+                for(int i=rmn;
+                        !want_more_text &amp;&amp; rh.me._search(s,i,end);i=rmn) {
+                    rmn = rh.me.matchedTo();
+                    if(rh.me.charsMatched()==0) {
+                        if(!isSpecial(rh.me.getReplaceRule()))
+                            apply1(rh.me);
+                        rmn++;
+                    }
+                    apply(rh.me);
+                }
+            ret = finish();
+            ret = ret == null ? s : ret;
+        }
+        return ret;
+    }
+
+    StringBufferLike sb = null;
+    StringLike src = null;
+    int pos = 0;
+    /** This method allows you to apply the results of several
+        matches in a sequence to modify a String of text.  Each
+        call in the sequence must operate on the same piece of
+        text and the matchedFrom() of each RegRes given to this
+        method must be greater in value than the preceeding
+        RegRes's matchedTo() value.
+        */
+    public void apply(RegRes r,ReplaceRule rp) {
+        if(rp==null ||(rp.next == null &amp;&amp; rp instanceof AmpersandRule))
+            return;
+        if(r.didMatch()) {
+            if(src == null)
+                src = r.getStringLike();
+	    if(sb == null)
+                sb = new StringBufferLike(src.newStringBufferLike());
+            int rmf = r.matchedFrom();
+            for(int ii=pos;ii&lt;rmf;ii++)
+              sb.append(src.charAt(ii));
+
+            Vector v = new Vector();
+            for(ReplaceRule x=rp;x != null;x=x.next) {
+                x.apply(sb,r);
+                if(x instanceof SpecialRule) {
+                    if(x instanceof WantMoreTextReplaceRule
+                            &amp;&amp; want_more_text_enable)
+                        want_more_text = true;
+                    else if(x instanceof PushRule) {
+                        RegHolder rh2 = new RegHolder();
+                        rh2.me = ( (PushRule)x ).NewRule;
+                        rh2.prev = rh;
+                        rh = rh2;
+                    } else if(x instanceof PopRule) {
+                        if(rh.prev != null)
+                            rh = rh.prev;
+                    } else if(x instanceof ChangeRule) {
+                        rh.me = ( (ChangeRule) x).NewRule;
+                    }
+                }
+            }
+            if(!want_more_text)
+                pos = r.matchedTo();
+        }
+    }
+    boolean want_more_text = false, want_more_text_enable = false;
+    public boolean WantMoreText() { return want_more_text; }
+    /** Another form of apply, it is the same as
+        apply(r,r.getReplaceRule()). */
+    public void apply(Regex r) { apply(r,r.getReplaceRule()); }
+
+    /** This finishes the replacement, appending the right() part of
+        the last RegRes given to substitute(RegRes).  After this method
+        is called, the Replace object is reset to perform another
+        substitution. If no RegRes objects with a true didMatch are
+        applied, this returns null. */
+    public StringLike finish() {
+        if(src==null)
+            return null;
+        //sb.append(src.substring(pos,src.length()));
+        int s_end = src.length();
+        for(int ii=pos;ii&lt;s_end;ii++)
+          sb.append(src.charAt(ii));
+        src = null;
+        lastMatchedTo = pos;
+        pos = 0;
+        StringLike retstr = sb.toStringLike();
+        sb = null;
+        return retstr;
+    }
+    int lastMatchedTo = 0;
+    public Object clone() {
+        Replacer r = new Replacer();
+        r.first = first;
+        r.src = src;
+        r.sb = sb;
+        r.pos = pos;
+        r.lastMatchedTo = lastMatchedTo;
+        r.want_more_text = want_more_text;
+        r.want_more_text_enable = want_more_text_enable;
+        r.rh.me = rh.me;
+        r.rh.prev = rh.prev;
+        return r;
+    }
+    public int lastMatchedTo() { return lastMatchedTo; }
+    public Regex getRegex() {
+      return rh.me;
+    }
+    public void setSource(StringLike sl) {
+      src = sl;
+    }
+    public void setBuffer(StringBufferLike sbl) {
+      sb = sbl;
+    }
+    public void setPos(int pos) {
+      this.pos = pos;
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RightRule.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RightRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RightRule.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RightRule.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RightRule.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,22 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** The apply(StringBufferLike sb,RegRes res) method of this derivation
+    of ReplaceRule appends the contents of res.right() to the     StringBufferLike sb.
+    @see com.stevesoft.eve_pat.ReplaceRule
+    */
+public class RightRule extends ReplaceRule {
+    public RightRule() {}
+    public void apply(StringBufferLike sb,RegRes res) {
+        sb.append(res.right());
+    }
+    public String toString1() {
+        return &quot;$'&quot;;
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Rthings.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Rthings.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Rthings.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Rthings.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Rthings.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,44 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** 
+        Shareware: package pat
+   &lt;a href=&quot;copyright.html&quot;&gt;Copyright 2001, Steven R. Brandt&lt;/a&gt;
+*/ /**
+This class only exists to store data needed during the
+compilation of a regular expression. */
+public class Rthings {
+    /** The numeric identity of the next () to be encountered
+         while compiling the pattern. */
+    public int val=Regex.BackRefOffset;
+    /** Needed in case (?i) is encountered, to pass back the
+         message that ignoreCase should be set. */
+    public boolean ignoreCase;
+    /** Needed in case (?Q) is encountered, to pass back the
+         message that dontMatchInQuotes should be set. */
+    public boolean dontMatchInQuotes;
+    public boolean optimizeMe = false;
+    public boolean noBackRefs = false;
+    public int parenLevel = 0;
+    boolean gFlag = false, mFlag = false, sFlag = false;
+    Pattern p;
+    Or o;
+    Rthings(Regex r) {
+        ignoreCase = r.ignoreCase;
+        dontMatchInQuotes = r.dontMatchInQuotes;
+    }
+    void set(Regex r) {
+        r.gFlag = gFlag;
+	r.mFlag = mFlag;
+	r.sFlag = sFlag;
+        r.ignoreCase = ignoreCase;
+        r.dontMatchInQuotes = dontMatchInQuotes;
+        if(optimizeMe) r.optimize();
+    }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RuleHolder.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RuleHolder.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RuleHolder.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RuleHolder.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/RuleHolder.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,20 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+/** This class is used internally. */
+class RuleHolder extends ReplaceRule {
+    ReplaceRule held = null;
+    RuleHolder() {}
+    RuleHolder(ReplaceRule h) { held = h; }
+    public Object clone1() { return new RuleHolder(held); }
+    public String toString1() { return held.toString1(); }
+    public void apply(StringBufferLike sb,RegRes rr) {
+        held.apply(sb,rr);
+    }
+    public ReplaceRule arg(String s) { return new RuleHolder(held.arg(s)); }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skip.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skip.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skip.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skip.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skip.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,127 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** This class is used internally to search ahead for some
+    optimized Regex objects.  It searches within a String
+    for occrences of a given String -- like a more flexible
+    version of String.indexOf.
+    @see com.stevesoft.eve_pat.Skip2
+    @see com.stevesoft.eve_pat.SkipBMH
+    */
+public class Skip {
+    static int mkmask(int c) {
+        char x = (char)c;
+        return ~( CaseMgr.toUpperCase(x) |
+            CaseMgr.toLowerCase(x) |
+            CaseMgr.toTitleCase(x));
+    }
+    static { int x = Regex.BackRefOffset; }
+    String src;
+    int c,mask;
+    int offset;
+    boolean ign,m1;
+    /** Examine a Regex to determine what String it will
+        attempt to skip to when searching for patterns.
+        Return -1 if we aren't doing this. */
+    public static String string(Regex r) {
+        return r.skipper == null ? null : r.skipper.src;
+    }
+    /** Determine the offset of the String within the pattern
+        that we are skipping to. Return -1 if we aren't doing
+        this.  */
+    public static int offset(Regex r) {
+        return r.skipper == null ? -1 : r.skipper.offset;
+    }
+    /** Initialize, give it a String to search for, tell it
+        whether or not to ignoreCase, and what the offset is
+        of the String within the String to be searched. */
+    public Skip(String s,boolean ign,int o) {
+        src = s;
+        c = s.charAt(0);
+        if(ign) {
+            mask = mkmask(c);
+        } else mask = 0;
+        offset = o;
+        this.ign = ign;
+        m1 = (s.length()==1);
+    }
+    /** The same as find(s,0,s.length()) */
+    public final int find(StringLike s) {
+        return find(s,0,s.length());
+    }
+    static final int min(int a,int b) { return a&lt;b ? a : b; }
+    /** Searches a given region of text beginning at position start
+        and ending at position end for the skip object. */
+    public int find(StringLike s,int start,int end) {
+        if(start &gt; end) return -1;
+        start += offset;
+        int vend = min(s.length()-1,end+offset);
+        if(mask != c) {
+            for(int i=start;i&lt;=vend;i++)
+                if(0 == (s.charAt(i) &amp; mask))
+                    //if(m1||s.regionMatches(ign,i,src,0,src.length()) )
+                    if(m1||CaseMgr.regionMatches(s,ign,i,src,0,src.length()) )
+                        return i-offset;
+        } else {
+            for(int i=start;i&lt;=vend;i++)
+                if(c == s.charAt(i))
+                    //if(m1||s.regionMatches(ign,i,src,0,src.length()) )
+                    if(m1||CaseMgr.regionMatches(s,ign,i,src,0,src.length()) )
+                        return i-offset;
+        }
+        return -1;
+    }
+    static Skip findSkip(Regex r) {
+        return findSkip(r.thePattern,r.ignoreCase,!r.dontMatchInQuotes);
+    }
+    // look for things that can be skipped
+    static Skip findSkip(Pattern p,boolean ignoreCase,boolean trnc) {
+        StringBuffer sb = new StringBuffer();
+        Skip subsk = null;
+        int offset = 0;
+        int skipc = -1,skipoff=0;
+        for(;p != null;p = p.next) {
+            if(p instanceof oneChar) {
+                skipc = ((oneChar)p).c;
+                skipoff = offset;
+            }
+            if(p instanceof oneChar &amp;&amp; p.next instanceof oneChar) {
+                Pattern psav = p;
+                sb.append(((oneChar)p).c);
+                while(p.next instanceof oneChar) {
+                    sb.append(((oneChar)p.next).c);
+                    p = p.next;
+                }
+                String st = sb.toString();
+                char c0 = st.charAt(0), c1 = st.charAt(1);
+                Skip sk=null;
+                if(st.length()&gt;2)
+                    sk = new SkipBMH(st,ignoreCase,offset);
+                else
+                    sk = new Skip2(st,ignoreCase,offset);
+                if(trnc &amp;&amp; st.length()&gt;2) { // chop out a whole string...
+                    psav.next = new Skipped(st.substring(1));
+                    psav.next.next = p.next;
+                    psav.next.parent = p.parent;
+                }
+                return sk;
+            } else if(p instanceof Or &amp;&amp; ((Or)p).v.size()==1
+                    &amp;&amp; !((Or)p).leftForm().equals(&quot;(?!&quot;)
+                    &amp;&amp; null != (subsk=
+                    findSkip( (Pattern)((Or)p).v.elementAt(0),ignoreCase,trnc) )) {
+                subsk.offset += offset;
+                return subsk;
+            } else if(p.minChars().equals(p.maxChars())) {
+                offset += p.minChars().intValue();
+            } else return skipc &lt; 0 ? null :
+                new Skip(&quot;&quot;+(char)skipc,ignoreCase,skipoff);
+        }
+        return null;
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skip2.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skip2.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skip2.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skip2.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skip2.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,38 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** This is the same as Skip, except it needs a minimum
+    of two characters in the initializing String.
+    @see com.stevesoft.eve_pat.Skip
+    @see com.stevesoft.eve_pat.SkipBMH
+    */
+public class Skip2 extends Skip {
+    int c1,mask1;
+    public Skip2(String s,boolean ign,int offset) {
+        super(s,ign,offset);
+        c1 = s.charAt(1);
+        m1 = 2==s.length();
+        if(ign) {
+            mask1=mkmask(c1);
+        } else
+            mask1 = 0;
+    }
+    public int find(StringLike s,int start,int end) {
+        if(start &gt; end) return -1;
+        start += offset;
+        int vend = min(s.length()-2,end+offset);
+        for(int i=start;i&lt;=vend;i++)
+            if(0 == (s.charAt(i)&amp;mask) &amp;&amp; 0 == (s.charAt(i+1)&amp;mask1)) {
+                //if(m1||s.regionMatches(ign,i,src,0,src.length()) )
+                if(m1||CaseMgr.regionMatches(s,ign,i,src,0,src.length()) )
+                    return i-offset;
+            }
+        return -1;
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SkipBMH.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SkipBMH.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SkipBMH.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SkipBMH.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SkipBMH.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,183 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+import com.stevesoft.eve_pat.wrap.StringWrap;
+
+/** Like Skip, but implements a
+    &lt;a href=&quot;<A HREF="http://www.dcc.uchile.cl/~rbaeza/handbook/algs/7/713b.srch.p.html">http://www.dcc.uchile.cl/~rbaeza/handbook/algs/7/713b.srch.p.html</A>&quot;&gt;
+    Boyer-Moore-Horspool&lt;/a&gt; type search
+    method that has been modified to be more like a &quot;T-search&quot; (see
+    the Michael Tamm''s article in &lt;i&gt;C'T, magazin fuer computer und technic&lt;/i&gt;, August 97
+    p 292).  Yet another important source of information for me was
+    the &lt;a href=&quot;<A HREF="http://www.go2net.com/people/paulp/deep/1997/05/14/">http://www.go2net.com/people/paulp/deep/1997/05/14/</A>&quot;&gt;
+    Deep Magic&lt;/a&gt; article on string searching.  As of this writing, I can
+    beat String's indexOf method in many cases.
+    @see com.stevesoft.eve_pat.Skip
+    @see com.stevesoft.eve_pat.Skip2
+    */
+public class SkipBMH extends Skip {
+    // This number could be 256, but I think it's
+    // big enough.  Note, it must be a power of 2.
+    final int MAX_CHAR = 64;
+    final char[] skip = new char[MAX_CHAR];
+    int sm1;
+    int jump_ahead = 0;
+    char uc,lc,tc,x;
+    final boolean exact(char c) {
+        return (ign &amp;&amp; anyc(c))||c==x;
+    }
+    final boolean anyc(char c) {
+        return c==uc||c==lc||c==tc;
+    }
+    public SkipBMH(String pt,boolean ign) { this(pt,ign,0); }
+    public SkipBMH(String pt) { this(pt,false,0); }
+    public SkipBMH(String pt,boolean ign,int offset) {
+        super(pt,ign,offset);
+        for(int k=0;k&lt;MAX_CHAR;k++)
+            skip[k] = (char)src.length();
+
+        sm1 = src.length()-1;
+        x = src.charAt(sm1);
+        uc=CaseMgr.toUpperCase(x);
+        lc=CaseMgr.toLowerCase(x);
+        tc=CaseMgr.toTitleCase(x);
+
+        // We don't really want 65536 long arrays in skip[],
+        // so we mask of the higher bits.  This can be combined
+        // with ignore case, so accounting for upper
+        // case costs us nothing extra.
+        for(int k=0;k&lt;src.length()-1;k++) {
+            char x_ = src.charAt(k);
+            if(ign) {
+                char uc_ = CaseMgr.toUpperCase(x_);
+                char lc_ = CaseMgr.toLowerCase(x_);
+                char tc_ = CaseMgr.toTitleCase(x_);
+                skip[uc_ &amp; (MAX_CHAR-1)]=(char)(src.length()-k-1);
+                skip[lc_ &amp; (MAX_CHAR-1)]=(char)(src.length()-k-1);
+                skip[tc_ &amp; (MAX_CHAR-1)]=(char)(src.length()-k-1);
+            } else
+                skip[x_ &amp; (MAX_CHAR-1)] = (char)(src.length()-k-1);
+        }
+
+        // This trick can be found in the July issue of
+        // C-T magazine.  This makes the method a type of
+        // &quot;T-search.&quot;
+        jump_ahead = src.length()-1;
+        for(int k=0;k&lt;src.length()-1;k++) {
+            char y=src.charAt(sm1-k-1);
+            if(exact(y)) {
+                jump_ahead = k;
+                break;
+            }
+        }
+    }
+    /** Set to true if you only want to compare two of the
+        characters in the String. */
+    final public int searchRegion(String s,int start,int end) {
+        return find(s,start,end);
+    }
+    final public int searchFrom(String s,int start) {
+        return find(s,start,s.length());
+    }
+    final public int search(String s) { return find(s,0,s.length()); }
+    public int find(String s,int start,int end) {
+        start += offset+sm1;
+        int vend = min(s.length()-1,end+sm1+offset),k;
+        int vend1 = vend-jump_ahead;
+        if(ign) {
+            for(k=start; k &lt;= vend1;k += skip[s.charAt(k) &amp; (MAX_CHAR-1)] ) {
+                // table look-up is expensive, avoid it if possible
+                if( anyc(s.charAt(k)) ) {
+                    if(CaseMgr.regionMatches(src,ign,0,s,k-sm1,sm1))
+                        return k-sm1-offset;
+                    k += jump_ahead;
+                }
+            }
+            for(; k &lt;= vend;k += skip[s.charAt(k) &amp; (MAX_CHAR-1)] ) {
+                // table look-up is expensive, avoid it if possible
+                if( anyc(s.charAt(k)) ) {
+                    if(CaseMgr.regionMatches(src,ign,0,s,k-sm1,sm1))
+                        return k-sm1-offset;
+                    k += jump_ahead;
+                    if(k &gt; vend) return -1;
+                }
+            }
+        } else {
+            for(k=start; k &lt;= vend1;k += skip[s.charAt(k) &amp; (MAX_CHAR-1)] ) {
+                // table look-up is expensive, avoid it if possible
+                if( x==s.charAt(k) ) {
+                    //if(src.regionMatches(0,s,k-sm1,sm1))
+                    if(CaseMgr.regionMatches(src,false,0,s,k-sm1,sm1))
+                        return k-sm1-offset;
+                    k += jump_ahead;
+                }
+            }
+            for(; k &lt;= vend;k += skip[s.charAt(k) &amp; (MAX_CHAR-1)] ) {
+                // table look-up is expensive, avoid it if possible
+                if( x==s.charAt(k) ) {
+                    //if(src.regionMatches(0,s,k-sm1,sm1))
+                    if(CaseMgr.regionMatches(src,false,0,s,k-sm1,sm1))
+                        return k-sm1-offset;
+                    k += jump_ahead;
+                    if(k &gt; vend) return -1;
+                }
+            }
+        }
+
+        return -1;
+    }
+    public int find(StringLike s,int start,int end) {
+        if(s instanceof StringWrap)
+          return find(s.toString(),start,end);
+        start += offset+sm1;
+        int vend = min(s.length()-1,end+sm1+offset),k;
+        int vend1 = vend-jump_ahead;
+        if(ign) {
+            for(k=start; k &lt;= vend1;k += skip[s.charAt(k) &amp; (MAX_CHAR-1)] ) {
+                // table look-up is expensive, avoid it if possible
+                if( anyc(s.charAt(k)) ) {
+                    if(CaseMgr.regionMatches(src,ign,0,s,k-sm1,sm1))
+                        return k-sm1-offset;
+                    k += jump_ahead;
+                }
+            }
+            for(; k &lt;= vend;k += skip[s.charAt(k) &amp; (MAX_CHAR-1)] ) {
+                // table look-up is expensive, avoid it if possible
+                if( anyc(s.charAt(k)) ) {
+                    if(CaseMgr.regionMatches(src,ign,0,s,k-sm1,sm1))
+                        return k-sm1-offset;
+                    k += jump_ahead;
+                    if(k &gt; vend) return -1;
+                }
+            }
+        } else {
+            for(k=start; k &lt;= vend1;k += skip[s.charAt(k) &amp; (MAX_CHAR-1)] ) {
+                // table look-up is expensive, avoid it if possible
+                if( x==s.charAt(k) ) {
+                    //if(src.regionMatches(0,s,k-sm1,sm1))
+                    if(CaseMgr.regionMatches(src,false,0,s,k-sm1,sm1))
+                        return k-sm1-offset;
+                    k += jump_ahead;
+                }
+            }
+            for(; k &lt;= vend;k += skip[s.charAt(k) &amp; (MAX_CHAR-1)] ) {
+                // table look-up is expensive, avoid it if possible
+                if( x==s.charAt(k) ) {
+                    //if(src.regionMatches(0,s,k-sm1,sm1))
+                    if(CaseMgr.regionMatches(src,false,0,s,k-sm1,sm1))
+                        return k-sm1-offset;
+                    k += jump_ahead;
+                    if(k &gt; vend) return -1;
+                }
+            }
+        }
+
+        return -1;
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skipped.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skipped.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skipped.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skipped.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Skipped.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,27 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Hashtable;
+
+/** Implements the (?&lt;number) Pattern, where number is
+ an integer telling us how far to back up in the Pattern.
+ Not in perl 5. */
+class Skipped extends Pattern {
+    String s;
+    Skipped(String s) { this.s = s; }
+    public String toString() { return s+nextString(); }
+    public int matchInternal(int pos,Pthings pt) {
+        //if(pt.no_check || s.regionMatches(pt.ignoreCase,0,pt.src,pos,s.length()))
+        if(pt.no_check || CaseMgr.regionMatches(s,pt.ignoreCase,0,pt.src,pos,s.length()))
+            return nextMatch(pos+s.length(),pt);
+        return -1;
+    }
+    public patInt minChars() { return new patInt(s.length()); }
+    public patInt maxChars() { return new patInt(s.length()); }
+    Pattern clone1(Hashtable h) { return new Skipped(s); }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SpecialRule.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SpecialRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SpecialRule.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SpecialRule.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SpecialRule.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,13 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+public class SpecialRule extends ReplaceRule {
+    public SpecialRule() {}
+    public void apply(StringBufferLike sb,RegRes rr) {}
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Start.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Start.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Start.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Start.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Start.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,31 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Hashtable;
+
+/** The '^' or the '\A' Pattern, matches the start of a string. */
+class Start extends Pattern {
+    boolean retIsStart;
+    Start(boolean b) { retIsStart = b; }
+    public int matchInternal(int pos,Pthings pt) {
+        if(retIsStart
+	&amp;&amp; pt.mFlag
+	&amp;&amp; pos &gt; 0 &amp;&amp; pt.src.charAt(pos-1)=='\n')
+            return nextMatch(pos,pt);
+        if(pos == 0) return nextMatch(pos,pt);
+        return -1;
+    }
+    public String toString() {
+        if(retIsStart)
+            return &quot;^&quot;+nextString();
+        else
+            return &quot;\\A&quot;+nextString();
+    }
+    public patInt maxChars() { return new patInt(0); }
+    Pattern clone1(Hashtable h) { return new Start(retIsStart); }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StrPos.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StrPos.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StrPos.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StrPos.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StrPos.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,117 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+/** 
+        Shareware: package pat
+   &lt;a href=&quot;copyright.html&quot;&gt;Copyright 2001, Steven R. Brandt&lt;/a&gt;
+*/ /**
+StrPos is used internally by regex to parse the regular expression. */
+public class StrPos {
+    String s;
+    int pos;
+    /** Return the position in the string pointed to */
+    public int pos() { return pos; }
+
+    /** This contains the escape character, which is \ by default. */
+    public char esc=Pattern.ESC;
+    char c;
+    /** Returns the current, possibly escaped, character. */
+    public char thisChar() { return c; }
+
+    boolean dontMatch,eos;
+
+    /** tell whether we are at end of string */
+    public boolean eos() { return eos; }
+    /** initialize a StrPos from another StrPos. */
+    public StrPos(StrPos sp) {
+        dup(sp);
+    }
+    /** copy a StrPos from sp to this. */
+    public void dup(StrPos sp) {
+        s = sp.s;
+        pos = sp.pos;
+        c = sp.c;
+        dontMatch = sp.dontMatch;
+        eos = sp.eos;
+    }
+    /** Initialize a StrPos by giving it a String, and a
+         position within the String. */
+    public StrPos(String s,int pos) {
+        this.s=s;
+        this.pos=pos-1;
+        inc();
+    }
+    /** Advance the place where StrPos points within the String.
+         Counts a backslash as part of the next character. */
+    public StrPos inc() {
+        pos++;
+        if(pos &gt;= s.length()) {
+            eos = true;
+            return this;
+        }
+        eos = false;
+        c = s.charAt(pos);
+        if(c == esc &amp;&amp; pos+1&lt;s.length()) {
+            pos++;
+            c = s.charAt(pos);
+            if(c != esc)
+                dontMatch = true;
+            else
+                dontMatch = false;
+        } else
+            dontMatch = false;
+        return this;
+    }
+    /** Compare the (possibly escaped) character
+         pointed to by StrPos.  Return true if they are the
+         same, but lways return if character pointed to is escaped. */
+    public boolean match(char ch) {
+        if(dontMatch || eos) return false;
+        return c == ch;
+    }
+    /** As match, but only matches if the character is escaped. */
+    public boolean escMatch(char ch) {
+        if(!dontMatch || eos) return false;
+        return c == ch;
+    }
+
+    /** Returns true if the current
+        character is escaped (preceeded by &quot;\&quot;). */
+    public boolean escaped() { return dontMatch; }
+    /** Increment the string pointer by each character in
+         &lt;pre&gt;st&lt;/pre&gt; that matches a non-escaped
+         character. */
+    public boolean incMatch(String st) {
+        StrPos sp = new StrPos(this);
+        int i;
+        for(i=0;i&lt;st.length();i++) {
+            if(!sp.match(st.charAt(i)) )
+                return false;
+            sp.inc();
+        }
+        dup(sp);
+        return true;
+    }
+    /** Read in an integer. */
+    public patInt getPatInt() {
+        patInt pi = null;
+        if(incMatch(&quot;inf&quot;))
+            return new patInf();
+        int i,cnt=0;
+        StrPos sp = new StrPos(this);
+        for(i=0;!sp.eos &amp;&amp; sp.c &gt;= '0' &amp;&amp; sp.c &lt;= '9';i++) {
+            cnt = 10*cnt+sp.c-'0';
+            sp.inc();
+        }
+        if(i==0) return null;
+        dup(sp);
+        return new patInt(cnt);
+    }
+    /** get the string that we are processing. */
+    public String getString() { return s; }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringBufferLike.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringBufferLike.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringBufferLike.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringBufferLike.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringBufferLike.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,63 @@
+package//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+com.stevesoft.eve_pat;
+
+/** A tool that is used to make the \E, \U, \L, and \Q
+    elements of a substitution. */
+public class StringBufferLike implements BasicStringBufferLike {
+  BasicStringBufferLike sbl;
+  public StringBufferLike(BasicStringBufferLike sbl) {
+    this.sbl = sbl;
+  }
+  char mode = 'E', altMode = ' ';
+  public StringLike toStringLike() {
+    return sbl.toStringLike();
+  }
+  public String toString() {
+    return sbl.toString();
+  }
+  public void append(char c) {
+    
+    switch(mode) {
+    case 'u':
+      mode = altMode;
+      altMode = ' ';
+    case 'U':
+      sbl.append(CaseMgr.toUpperCase(c));
+      break;
+    case 'l':
+      mode = altMode;
+      altMode = ' ';
+    case 'L':
+      sbl.append(CaseMgr.toLowerCase(c));
+      break;
+    case 'Q':
+      if((c &gt;= 'a' &amp;&amp; c &lt;= 'z')
+      || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')
+      || (c &gt;= '0' &amp;&amp; c &lt;= '9'))
+        ;
+      else
+        sbl.append('\\');
+    default:
+      sbl.append(c);
+      break;
+    }
+  }
+  public void append(String s) {
+    for(int i=0;i&lt;s.length();i++)
+      append(s.charAt(i));
+  }
+  public void setMode(char c) {
+    if(c == 'u' || c == 'l')
+      if(altMode == ' ') altMode = mode;
+    mode = c;
+  }
+  public Object unwrap() {
+    return sbl.unwrap();
+  }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringLike.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringLike.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringLike.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringLike.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringLike.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,37 @@
+package//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+com.stevesoft.eve_pat;
+
+/** Package pat can search anything that implements this
+    interface.  Package pat assumes the following:
+    &lt;ul&gt;
+    &lt;li&gt;The StringLike object will not change.  Calls to
+        charAt(int) will not vary with time.
+    &lt;li&gt;The length of the object being searched is known
+        before the search begins and does not vary with time.
+    &lt;/ul&gt;
+    Note that searching String is probably faster than searching
+    other objects, so searching String is still preferred if
+    possible.
+*/
+public interface StringLike {
+    public char charAt(int i);
+    public String toString();
+    public int length();
+    public String substring(int i1,int i2);
+    /** Obtain the underlying object, be it a String, char[],
+        RandomAccessFile, whatever. */
+    public Object unwrap();
+    /** By default, the result is put in a String or char[]
+        when a replace is done.  If you wish to save the result
+        in some other StringBufferLike then you can do this
+        by implementing this method, or over-riding it's behavior
+        from an existing class. */
+    public BasicStringBufferLike newStringBufferLike();
+    public int indexOf(char c);
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringRule.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringRule.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringRule.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/StringRule.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,22 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** The apply method of this ReplaceRule simply appends the text
+    it was initialized with to the StringBufferLike.
+    @see com.stevesoft.eve_pat.ReplaceRule
+    */
+public class StringRule extends ReplaceRule {
+    String s;
+    public StringRule(String s) { this.s = s; }
+    public void apply(StringBufferLike sb,RegRes res) {
+        sb.append(s);
+    }
+    public String toString1() { return s; }
+    public Object clone1() { return new StringRule(s); }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SubMark.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SubMark.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SubMark.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SubMark.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/SubMark.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,22 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** OrMark and SubMark together implement ( ... ) */
+class SubMark extends Pattern {
+    int end_pos,start_pos;
+    OrMark om;
+    public String toString() { return &quot;&quot;; }
+    public int matchInternal(int i,Pthings pt) {
+        pt.marks[om.id+pt.nMarks] = i;
+        int ret=nextMatch(i,pt);
+        if(ret &lt; 0)
+            pt.marks[om.id+pt.nMarks] = -1;
+        return ret;
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/TransPat.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/TransPat.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/TransPat.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/TransPat.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/TransPat.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,39 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+
+/** This class is used to implement the Transformer
+    @see com.stevesoft.eve_pat.Transform
+    */
+class TransPat extends Pattern {
+    Regex[] ra = new Regex[10];
+    int ra_len = 0;
+    int pn = -1;
+    public String toString() {
+        return &quot;(?#TransPat)&quot;;
+    }
+
+    TransPat() {}
+
+    int lastMatchedTo = -1;
+    public int matchInternal(int pos,Pthings pt) {
+        for(int i=0;i&lt;ra_len;i++) {
+            pt.ignoreCase = ra[i].ignoreCase;
+            pt.mFlag = ra[i].mFlag;
+            pt.dotDoesntMatchCR = ra[i].dotDoesntMatchCR;
+            int r = ra[i].thePattern.matchInternal(pos,pt);
+            if(r &gt;= 0) {
+                pn = i;
+                return r;
+            }
+        }
+        pn = -1;
+        return -1;
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/TransRepRule.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/TransRepRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Transformer.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Transformer.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Transformer.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Transformer.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Transformer.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,154 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+import com.stevesoft.eve_pat.wrap.StringWrap;
+
+/** Replacement rule used by the Transformer.
+    @see com.stevesoft.eve_pat.Transformer
+    */
+class TransRepRule extends ReplaceRule {
+    Transformer t;
+    TransRepRule(Transformer t) { this.t = t; }
+    public String toString1() { return &quot;&quot;; }
+    public Object clone1() { return new TransRepRule(t); }
+    public void apply(StringBufferLike sb,RegRes rr) {
+        // get the ReplaceRule of the Regex that matched.
+        next = t.tp.ra[t.tp.pn].getReplaceRule();
+    }
+}
+
+/** Sometimes you want to replace a whole bunch of things
+  that might occur within a single line of text.  One efficient
+  way to do this, both in terms of performance and programming
+  ease, is with Transformer. The Transformer contains an array
+  of Regex's and uses the Regex that matches earliest within the
+  text to do the replacing, if two Regex's match at the same
+  time it uses the one put in the Transformer first.
+  &lt;p&gt;
+  This feature can be used to prevent transformations from
+  occurring in certain regions. For example, if I add the rule
+  s'//.*'$&amp;' and then add the
+  rule s/hello/goodbye/ the Transformer will replace &quot;hello&quot;
+  with &quot;goodbye&quot; except when it occurs inside a double-slash
+  style of comment.   The transformation on the comment goes first,
+  does nothing, and precludes transformation on the same region
+  of text as the s/hello/goodbye/ rule.
+  &lt;p&gt;
+  So far, at least, this class does not have the capability of
+  turning into a giant robot :-)
+  */
+public class Transformer {
+    TransPat tp;
+    Regex rp = new Regex();
+    boolean auto_optimize;
+
+    /** Get a replacer to that works with the current Regex.
+     @see com.stevesoft.eve_pat.Replacer
+     */
+    public Replacer getReplacer() { return rp.getReplacer(); }
+
+    /** Instantiate a new Transformer object. */
+    public Transformer(boolean auto) {
+        auto_optimize = auto;
+        tp = new TransPat();
+        rp.setReplaceRule(new TransRepRule(this));
+        rp.thePattern = tp;
+    }
+
+    /** Add a new Regex to the set of Regex's. */
+    public void add(Regex r) {
+        if(auto_optimize) r.optimize();
+        tp.ra[tp.ra_len++] = r;
+        if(tp.ra.length==tp.ra_len) {
+            Regex[] ra2 = new Regex[tp.ra_len+10];
+            for(int i=0;i&lt;tp.ra_len;i++)
+                ra2[i] = tp.ra[i];
+            tp.ra = ra2;
+        }
+        rp.numSubs_ = r.numSubs_ &gt; rp.numSubs_ ? r.numSubs_ : rp.numSubs_;
+    }
+
+    /** Returns the number of Regex's in this Transformer. */
+    public int patterns() { return tp.ra_len; }
+
+    /** Get the Regex at position i in this Transformer. */
+    public Regex getRegexAt(int i) {
+        if(i &gt;= tp.ra_len)
+            throw new ArrayIndexOutOfBoundsException(&quot;i=&quot;+i+&quot;&gt;=&quot;+patterns());
+        if(i &lt; 0)
+            throw new ArrayIndexOutOfBoundsException(&quot;i=&quot;+i+&quot;&lt; 0&quot;);
+        return tp.ra[i];
+    }
+    /** Set the Regex at position i in this Transformer. */
+    public void setRegexAt(Regex rx,int i) {
+        if(i &gt;= tp.ra_len)
+            throw new ArrayIndexOutOfBoundsException(&quot;i=&quot;+i+&quot;&gt;=&quot;+patterns());
+        if(i &lt; 0)
+            throw new ArrayIndexOutOfBoundsException(&quot;i=&quot;+i+&quot;&lt; 0&quot;);
+        tp.ra[i] = rx;
+    }
+
+    /** Add a new Regex by calling Regex.perlCode
+        @see com.stevesoft.eve_pat.Regex#perlCode(java.lang.String)
+        */
+    public void add(String rs) {
+        Regex r = Regex.perlCode(rs);
+        if(r == null) throw new NullPointerException(&quot;bad pattern to Regex.perlCode: &quot;+rs);
+        add(r);
+    }
+    /** Add an array of Strings (which will be converted to
+        Regex's via the Regex.perlCode method.
+        @see com.stevesoft.eve_pat.Regex#perlCode(java.lang.String)
+        */
+    public void add(String[] array) {
+        for(int i=0;i&lt;array.length;i++)
+            add(array[i]);
+    }
+    /** Replace all matches in the current String. */
+    public String replaceAll(String s) {
+        return dorep(s,0,s.length());
+    }
+    public StringLike replaceAll(StringLike s) {
+        return dorep(s,0,s.length());
+    }
+    /** Replace all matching patterns beginning at position start. */
+    public String replaceAllFrom(String s,int start) {
+        return dorep(s,start,s.length());
+    }
+    /** Replace all matching patterns beginning between the positions
+        start and end inclusive. */
+    public String replaceAllRegion(String s,int start,int end) {
+        return dorep(s,start,end);
+    }
+
+    Replacer repr = new Replacer();
+    final StringLike dorep(StringLike s,int start,int end) {
+        StringLike tfmd = repr.replaceAllRegion(s,rp,start,end);
+        tp.lastMatchedTo = repr.lastMatchedTo;
+        return tfmd;
+    }
+    final String dorep(String s,int start,int end) {
+        return dorep(new StringWrap(s),start,end).toString();
+    }
+
+    /** Replace the first matching pattern in String s. */
+    public String replaceFirst(String s) {
+        return dorep(s,0,s.length());
+    }
+    /** Replace the first matching pattern after position start in
+        String s. */
+    public String replaceFirstFrom(String s,int start) {
+        return dorep(s,start,s.length());
+    }
+    /** Replace the first matching pattern that begins between
+        start and end inclusive. */
+    public String replaceFirstRegion(String s,int start,int end) {
+        return dorep(s,start,end);
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UniValidator.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UniValidator.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UniValidator.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UniValidator.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UniValidator.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,16 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** This provides a base class for all the Unicode character
+  * matching rules.
+  */
+class UniValidator extends Validator {
+    public patInt minChars() { return new patInt(1); }
+    public patInt maxChars() { return new patInt(1); }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeAlpha.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeAlpha.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeCurrency.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeCurrency.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeDigit.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeDigit.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeLower.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeLower.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeMath.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeMath.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodePunct.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodePunct.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeUpper.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeUpper.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeW.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeW.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeWhite.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/UnicodeWhite.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Validator.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Validator.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Validator.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Validator.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/Validator.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,58 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** This class makes it easy to create your own patterns
+and integrate them into Regex.  For more detail, see the
+example file &lt;a href=&quot;<A HREF="http://javaregex.com/code/deriv2.java.html">http://javaregex.com/code/deriv2.java.html</A>&quot;&gt;deriv2.java&lt;/a&gt; or
+&lt;a href=&quot;<A HREF="http://javaregex.com/code/deriv3.java.html">http://javaregex.com/code/deriv3.java.html</A>&quot;&gt;deriv3.java&lt;/a&gt;. */
+
+public class Validator {
+    String argsave = null;
+    String pattern = &quot;.&quot;;
+    /**
+    This method does extra checking on a matched section of
+    a String beginning at position start and ending at end.
+    The idea is that you can do extra checking with this
+    that you don't know how to do with a standard Regex.
+
+    If this method is successful, it returns the location
+    of the end of this pattern element -- that may be the
+    value end provided or some other value.  A negative
+    value signifies that a match failure.
+    
+    By default, this method just returns end and thus
+    does nothing.
+    @see com.stevesoft.eve_pat.Regex#define(java.lang.String,java.lang.String,com.stevesoft.pat.Validator)
+    */
+    public int validate(StringLike src,int start,int end) {
+        return end;
+    }
+    /* This method allows you to modify the behavior of this
+    validator by making a new Validator object.  If a Validator
+    named &quot;foo&quot; is defined, then the pattern &quot;{??foo:bar}&quot; will
+    cause Regex to first get the Validator given to Regex.define
+    and then to call its arg method with the string &quot;bar&quot;.
+    If this method returns a null (the default) you get the same
+    behavior as the pattern &quot;{??foo}&quot; would supply. */
+    public Validator arg(String s) { return null; }
+
+    /** For optimization it is helpful, but not necessary, that
+    you define the minimum number of characters this validator
+    will allow to match.  To do this 
+    return new patInt(number) where number is the smallest
+    number of characters that can match. */
+    public patInt minChars() { return new patInt(0); }
+
+    /** For optimization it is helpful, but not necessary, that
+    you define the maximum number of characters this validator
+    will allow to match.  To do this either
+    return new patInt(number), or new patInf() if an infinite
+    number of characters may match. */
+    public patInt maxChars() { return new patInf(); }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/WantMoreTextReplaceRule.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/WantMoreTextReplaceRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/WantMoreTextReplaceRule.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/WantMoreTextReplaceRule.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/WantMoreTextReplaceRule.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,19 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** Triggers the reading of another line of text, allowing a longer
+    pattern to match -- for details see
+    &lt;a href=&quot;<A HREF="http://javaregex.com/code/WantMore.java.html">http://javaregex.com/code/WantMore.java.html</A>&quot;&gt;WantMore.java&lt;/a&gt;.
+    */
+public class WantMoreTextReplaceRule extends SpecialRule {
+    public WantMoreTextReplaceRule() {}
+    public void apply(StringBufferLike sb,RegRes res) {
+    }
+    public String toString1() { return &quot;${WANT_MORE_TEXT}&quot;; }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/lookAhead.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/lookAhead.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/lookAhead.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/lookAhead.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/lookAhead.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,46 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Hashtable;
+
+/** Implements &quot;(?=  )&quot; and &quot;(?! )&quot; */
+class lookAhead extends Or {
+    boolean reverse;
+    lookAhead(boolean b) { reverse = b; }
+    public Pattern getNext() { return null; }
+    public int nextMatch(int pos,Pthings pt) {
+        Pattern p = super.getNext();
+        if(p != null) return p.matchInternal(pos,pt);
+        else return pos;
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        if(super.matchInternal(pos,pt) &gt;= 0) {
+            if(reverse) return -1;
+            else return nextMatch(pos,pt);
+        } else {
+            if(reverse) return nextMatch(pos,pt);
+            else return -1;
+        }
+    }
+    String leftForm() {
+        if(reverse)
+            return &quot;(?!&quot;;
+        else
+            return &quot;(?=&quot;;
+    }
+    public patInt minChars() { return new patInt(0); }
+    public patInt maxChars() { return new patInt(0); }
+    Pattern clone1(Hashtable h) {
+        lookAhead la=new lookAhead(reverse);
+        h.put(this,la);
+        h.put(la,la);
+        for(int i=0;i&lt;v.size();i++)
+            la.v.addElement( ((Pattern)v.elementAt(i)).clone(h) );
+        return la;
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/oneChar.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/oneChar.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/oneChar.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/oneChar.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/oneChar.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,48 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+import java.util.Hashtable;
+
+/** This class matches a single character. */
+class oneChar extends Pattern {
+    char c,altc,altc2;
+    int mask;
+    public oneChar(char ci) {
+        c = ci;
+        char cu,cl,ct;
+        cu = CaseMgr.toUpperCase(c);
+        cl = CaseMgr.toLowerCase(c);
+        ct = CaseMgr.toTitleCase(c);
+        if(c == cu) {
+            altc = cl;
+            altc2 = ct;
+        } else if(c == cl) {
+            altc = cu;
+            altc2 = ct;
+        } else {
+            altc = cl;
+            altc2 = cu;
+        }
+        mask = c &amp; altc &amp; altc2;
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        char p;
+        int ret=-1;
+        if (pos &lt; pt.src.length() &amp;&amp; !Masked(pos,pt)
+                &amp;&amp; ((p=pt.src.charAt(pos))==c ||
+                (pt.ignoreCase&amp;&amp; (p==altc||p==altc2) ) ))
+            ret = nextMatch(pos+1,pt);
+        return ret;
+    }
+    public String toString() {
+        return protect(&quot;&quot;+c,PROTECT_THESE,ESC)+nextString();
+    }
+    public patInt minChars() { return new patInt(1); }
+    public patInt maxChars() { return new patInt(1); }
+    Pattern clone1(Hashtable h) { return new oneChar(c); }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/parsePerl.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/parsePerl.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/parsePerl.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/parsePerl.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/parsePerl.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,266 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** This class provides a method for parsing the &quot;s/.../.../&quot; constructs
+of Regex.perlCode.
<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">+ at see</A> Regex#perlCode
+*/
+class parsePerl {
+    final static char close(char c) {
+        // This switch statement does not behave
+        // properly when compiled with jdk1.1.5
+        // and the -O flag.
+        /*
+        switch(c) {
+        case '[':
+          return ']';
+        case '(':
+          return ')';
+        case '{':
+          return '}';
+        }
+        return c;*/
+	if(c == '&lt;')
+	    return '&gt;';
+        if(c == '[')
+            return ']';
+        if(c == '(')
+            return ')';
+        if(c == '{')
+            return '}';
+        return c;
+    }
+
+    final public static String codify(String s,boolean keepbs) {
+        return codify(s,0,s.length(),keepbs);
+    }
+    final public static String codify(String s,int i0,int iN,boolean keepbs) {
+        StringBuffer sb = new StringBuffer();
+        boolean ucmode = false, lcmode = false, litmode = false;
+        boolean uc1 = false, lc1 = false;
+        boolean modified = false;
+        for(int i=i0;i&lt;iN;i++) {
+            char c = s.charAt(i);
+            boolean mf = true, app=true;
+            if(c=='\\') {
+                app=false;
+                i++;
+                if(i&lt;s.length()) {
+                    char c2 = s.charAt(i);
+                    switch(c2) {
+                    case 'Q':
+                        litmode = true;
+                        break;
+                    case 'U':
+                        ucmode = true;
+                        break;
+                    case 'L':
+                        lcmode = true;
+                        break;
+                    case 'u':
+                        uc1 = true;
+                        break;
+                    case 'l':
+                        lc1 = true;
+                        break;
+                    case 'E':
+                        uc1=lc1=ucmode=lcmode=litmode=false;
+                        break;
+                    default:
+                        if(keepbs)
+                            sb.append('\\');
+                        c=c2;
+                        if(keepbs) mf = false;
+                        app = true;
+                        break;
+                    }
+                    modified |= mf;
+                }
+            }
+            if(app) {
+                if(lc1) {
+                    c=lc(c);
+                    lc1=false;
+                } else if(uc1) {
+                    c=uc(c);
+                    uc1=false;
+                } else if(ucmode) {
+                    c=uc(c);
+                } else if(lcmode) {
+                    c=lc(c);
+                }
+                if(litmode &amp;&amp; needbs(c))
+                    sb.append('\\');
+                sb.append(c);
+            }
+        }
+        return modified ? sb.toString() : s;
+    }
+    final static char uc(char c) {
+        return CaseMgr.toUpperCase(c);
+    }
+    final static char lc(char c) {
+        return CaseMgr.toLowerCase(c);
+    }
+    final static boolean needbs(char c) {
+        if(c &gt;= 'a' &amp;&amp; c &lt;= 'z')
+            return false;
+        if(c &gt;= 'A' &amp;&amp; c &lt;= 'Z')
+            return false;
+        if(c &gt;= '0' &amp;&amp; c &lt;= '9')
+            return false;
+        if(c == '_')
+            return false;
+        return true;
+    }
+    final static Regex parse(String s) {
+        boolean igncase = false, optim = false, gFlag = false;
+        boolean sFlag = false, mFlag = false, xFlag = false;
+
+        StringBuffer s1 = new StringBuffer();
+        StringBuffer s2 = new StringBuffer();
+        int i=0,count=0;
+        char mode,delim='/',cdelim='/';
+        if(s.length() &gt;= 3 &amp;&amp; s.charAt(0)=='s') {
+            mode = 's';
+            delim = s.charAt(1);
+            cdelim = close(delim);
+            i=2;
+        } else if(s.length() &gt;= 2 &amp;&amp; s.charAt(0)=='m') {
+            mode = 'm';
+            delim = s.charAt(1);
+            cdelim = close(delim);
+            i=2;
+        } else if(s.length() &gt;= 1 &amp;&amp; s.charAt(0)=='/') {
+            mode = 'm';
+            i=1;
+        } else {
+            try {
+                RegSyntaxError.endItAll(
+		    &quot;Regex.perlCode should be of the &quot;+
+                    &quot;form s/// or m// or //&quot;);
+            } catch(RegSyntax rs) {}
+            return null;
+        }
+        for(;i&lt;s.length();i++) {
+            if(s.charAt(i)=='\\') {
+                s1.append('\\');
+                i++;
+            } else if(s.charAt(i)==cdelim &amp;&amp; count==0) {
+                i++;
+                break;
+            } else if(s.charAt(i)==delim &amp;&amp; cdelim != delim) {
+                count++;
+            } else if(s.charAt(i)==cdelim &amp;&amp; cdelim != delim) {
+                count--;
+            }
+            s1.append(s.charAt(i));
+        }
+        if(mode=='s' &amp;&amp; cdelim != delim) {
+            while(i&lt;s.length() &amp;&amp; Prop.isWhite(s.charAt(i)) )
+                i++;
+            if(i&gt;=s.length()) {
+                try {
+                    RegSyntaxError.endItAll(&quot;&quot;+mode+delim+&quot; needs &quot;+cdelim);
+                } catch(RegSyntax rs) {}
+                return null;
+            }
+            cdelim = close(delim = s.charAt(i));
+            i++;
+        }
+        count=0;
+        if(mode=='s') {
+            for(;i&lt;s.length();i++) {
+                if(s.charAt(i)=='\\') {
+                    s2.append('\\');
+                    i++;
+                } else if(s.charAt(i)==cdelim &amp;&amp; count==0) {
+                    i++;
+                    break;
+                } else if(s.charAt(i)==delim &amp;&amp; cdelim != delim) {
+                    count++;
+                } else if(s.charAt(i)==cdelim &amp;&amp; cdelim != delim) {
+                    count--;
+                }
+                s2.append(s.charAt(i));
+            }
+        }
+        for(;i&lt;s.length();i++) {
+            char c = s.charAt(i);
+            switch(c) {
+	    case 'x':
+	        xFlag = true;
+		break;
+            case 'i':
+                igncase = true;
+                break;
+            case 'o':
+                optim = true;
+                break;
+            case 's':
+                sFlag = true;
+                break;
+            case 'm':
+		mFlag = true;
+                break;
+            case 'g':
+                gFlag = true;
+                break;
+            default:
+                // syntax error!
+                try {
+                    RegSyntaxError.endItAll(&quot;Illegal flag to pattern: &quot;+c);
+                } catch(RegSyntax rs) {}
+                return null;
+            }
+        }
+        Regex r = new Regex();
+        try {
+            String pat=s1.toString(),reprul=s2.toString();
+	    if(xFlag) {
+	      pat = strip(pat);
+	      reprul = strip(reprul);
+	    }
+            r.compile(pat);
+            r.ignoreCase |= igncase;
+            r.gFlag |= gFlag;
+            r.sFlag |= sFlag;
+	    r.mFlag |= mFlag;
+            if(optim) r.optimize();
+	    if(delim=='\'')
+              r.setReplaceRule(new StringRule(reprul));
+	    else
+              r.setReplaceRule(ReplaceRule.perlCode(reprul));
+        } catch(RegSyntax rs) {
+            r = null;
+        }
+        return r;
+    }
+    static String strip(String s) {
+      StringBuffer sb = new StringBuffer();
+      for(int i=0;i&lt;s.length();i++) {
+        char c = s.charAt(i);
+	if(Prop.isWhite(c)) {
+	  ;
+	} else if(c == '#') {
+	  i++;
+	  while(i&lt;s.length()) {
+	    if(s.charAt(i) == '\n')
+	      break;
+	    i++;
+	  }
+        } else if(c == '\\') {
+	  sb.append(c);
+	  sb.append(s.charAt(++i));
+	} else
+	  sb.append(c);
+      }
+      return sb.toString();
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/patInf.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/patInf.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/patInf.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/patInf.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/patInf.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,12 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+final class patInf extends patInt {
+    patInf() { inf = true; }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/patInt.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/patInt.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/patInt.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/patInt.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/patInt.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,88 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat;
+
+/** This is just an integer that can have infinite value.
+    It is used internally to implement the *, and + parts
+    of regular expressions.
+*/
+public class patInt {
+    int i;
+    boolean inf;
+    /** Initialize to zero. */
+    public patInt() { i = 0; inf = false; }
+    /** Initialize to the value of init. */
+    public patInt(int init) { i = init; inf = false; }
+    /** Initialize to the value of p. */
+    public patInt(patInt p) { i = p.i; inf = p.inf; }
+    /** set this int to infinity. */
+    public void setInf(boolean b) {
+        inf = b;
+        if(b) i = Integer.MAX_VALUE;
+    }
+    /** Increment the value of this by 1. */
+    public final void inc() {
+        if(!inf) i++;
+    }
+    /** Decrement the value of this by 1. */
+    public final void dec() {
+        if(!inf) i--;
+    }
+    /** Test to see if this is less than or equal to j. */
+    public final boolean lessEq(patInt j) { /*
+                if(inf) return false;
+                if(j.inf) return true;
+                return i &lt;= j.i; */
+        return !inf &amp;&amp; (j.inf || i &lt;= j.i);
+    }
+    /** Test to see if two patterns are equal. */
+    public final boolean equals(patInt j) {
+        return !j.inf &amp;&amp; !inf &amp;&amp; i==j.i;
+    }
+    /** Formats the pattern as a String.  Contrary to
+         what you might expect, infinity is formatted as &quot;&quot; */
+    final public String toString() {
+        if(inf) return &quot;&quot;;
+        else return &quot;&quot;+i;
+    }
+    /** This would be operator+=(patInt) if I were programming
+         in C++. */
+    public final patInt pluseq(patInt p) {
+        if(inf||p.inf) setInf(true);
+        else i += p.i;
+        return this;
+    }
+    /** Returns a patInt with value equal to the product
+         of the value of p and this. */
+    public final patInt mul(patInt p) {
+        if(inf||p.inf) return new patInf();
+        return new patInt(i*p.i);
+    }
+    /** If the argument p has a smaller value than this,
+         then set this Object equal to p. */
+    public final patInt mineq(patInt p) {
+        if(p.inf) return this;
+        if(inf) i = p.i;
+        else if(p.i &lt; i) i = p.i;
+        setInf(false);
+        return this;
+    }
+    /** If the argument p has a greater than this,
+         then set this object equal to p. */
+    public final patInt maxeq(patInt p) {
+        if(inf || p.inf) { setInf(true); return this; }
+        if(p.i &gt; i) i = p.i;
+        return this;
+    }
+    /** Tests to see if this represents an infinite quantity. */
+    public boolean finite() { return !inf; }
+    /** Converts to a patInt to an int.  Infinity is
+         mapped Integer.MAX_VALUE;
+        */
+    public int intValue() { return inf ? Integer.MAX_VALUE : i; }
+};

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/CharArrayBufferWrap.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/CharArrayBufferWrap.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/CharArrayBufferWrap.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/CharArrayBufferWrap.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/CharArrayBufferWrap.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,38 @@
+package//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+com.stevesoft.eve_pat.wrap;
+
+import com.stevesoft.eve_pat.*;
+
+/** Allows the outcome of a replaceAll() or replaceFirst()
+    to be an array of characters rather than a String.
+    */
+public class CharArrayBufferWrap
+  implements BasicStringBufferLike
+  {
+  StringBuffer sb = new StringBuffer();
+  public void append(char c) {
+    sb.append(c);
+  }
+  public void append(String s) {
+    sb.append(s);
+  }
+  public StringLike toStringLike() {
+    char[] ca = new char[sb.length()];
+    for(int i=0;i&lt;ca.length;i++)
+      ca[i] = sb.charAt(i);
+    return new CharArrayWrap(ca);
+  }
+  public int length() { return sb.length(); }
+  public String toString() {
+    return sb.toString();
+  }
+  public Object unwrap() {
+    return sb;
+  }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/CharArrayWrap.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/CharArrayWrap.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/CharArrayWrap.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/CharArrayWrap.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/CharArrayWrap.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,39 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat.wrap;
+
+import com.stevesoft.eve_pat.*;
+
+/** This provides a wrapper for a char array so that
+    it can be searched by Regex. */
+public class CharArrayWrap implements StringLike {
+    char[] ca;
+    public char[] getCharArray() { return ca; }
+    public CharArrayWrap(char[] ca) { this.ca = ca; }
+    public String toString() {
+      return new String(ca);
+    }
+    public char charAt(int i) { return ca[i]; }
+    public int length() { return ca.length; }
+    public String substring(int i1,int i2) {
+        StringBuffer sb = new StringBuffer();
+        for(int i=i1;i&lt;i2;i++)
+            sb.append(ca[i]);
+        return sb.toString();
+    }
+    public Object unwrap() { return ca; }
+    public BasicStringBufferLike newStringBufferLike() {
+      return new CharArrayBufferWrap();
+    }
+    public int indexOf(char c) {
+      for(int i=0;i&lt;ca.length;i++)
+        if(ca[i] == c)
+          return i;
+      return -1;
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/RandomAccessFileWrap.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/RandomAccessFileWrap.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/RandomAccessFileWrap.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/RandomAccessFileWrap.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/RandomAccessFileWrap.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,117 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat.wrap;
+
+import com.stevesoft.eve_pat.*;
+
+import java.io.*;
+
+/** Provides a wrapper for a RandomAccessFile so that it
+    can be searched by Regex. */
+public class RandomAccessFileWrap implements StringLike {
+
+    long offset = 0;
+    public void setOffset(long o) {
+      offset = o;
+      i0 = iend = 0;
+    }
+    public long getOffset() {
+      return offset;
+    }
+    RandomAccessFile raf;
+    int i0=0,iend=0;
+    byte[] buf = new byte[1024];
+
+    public int getBufferSize() {
+      return buf.length;
+    }
+
+    public void setBufferSize(int bs) {
+      buf = new byte[bs];
+      i0 = iend = 0;
+    }
+
+    public RandomAccessFileWrap(String file) throws IOException {
+        this.raf = new RandomAccessFile(file,&quot;r&quot;);
+    }
+    public RandomAccessFileWrap(RandomAccessFile raf) {
+        this.raf = raf;
+    }
+
+    public char charAt(int i) {
+        if(i &gt;= i0 &amp;&amp; i &lt; iend)
+            return (char)buf[i-i0];
+
+        try {
+            i0 = i-5;
+            //if(i0+offset&lt;0) i0=(int)(-offset);
+            if(i0&lt;0) i0=0;
+            raf.seek(i0+offset);
+            iend = i0+raf.read(buf,0,buf.length);
+
+            if(i &gt;= i0 &amp;&amp; i &lt; iend)
+                return (char)buf[i-i0];
+        } catch(Throwable t) {}
+
+        throw new ArrayIndexOutOfBoundsException(&quot;Out of bounds for file:&quot;+
+          &quot; i=&quot;+i+
+          &quot;, Final Buffer: i0=&quot;+i0+
+          &quot; iend=&quot;+iend);
+    }
+
+    public String toString() { throw new Error(&quot;Not implemented&quot;); }
+    public int length() {
+      try {
+        long len = raf.length()-offset;
+        if(len &gt; Integer.MAX_VALUE)
+          return Integer.MAX_VALUE;
+        return (int)len;
+      } catch(IOException ioe) {
+        return 0;
+      }
+    }
+    public String substring(int i1,int i2) {
+        StringBuffer sb = new StringBuffer();
+        for(int i=i1;i&lt;i2;i++)
+            sb.append(charAt(i));
+        return sb.toString();
+    }
+    public Object unwrap() { return raf; }
+
+    public static void main(String[] files) throws IOException {
+      for(int i=0;i&lt;files.length;i++) {
+        RandomAccessFileWrap fw =
+          new RandomAccessFileWrap(new RandomAccessFile(files[i],&quot;r&quot;));
+        Regex r = new Regex(&quot;toString\\(\\) *(?@{})&quot;);
+        r.setGFlag(true);
+        r.optimize();
+        eve.sys.Vm.debug(files[i]+&quot; &quot;);
+        int j=0;
+        do {
+          if(r.searchFrom(fw,j)) {
+            eve.sys.Vm.debug(&quot;Matched at index: &quot;+
+             r.matchedFrom());
+            j=r.matchedTo();
+          } else
+            eve.sys.Vm.debug(&quot;not found&quot;);
+          eve.sys.Vm.debug(r.stringMatched());
+        } while(r.didMatch());
+      }
+    }
+
+    public BasicStringBufferLike newStringBufferLike() {
+      return new StringBufferWrap();
+    }
+
+    public int indexOf(char c) {
+      for(int i=0;i&lt;length();i++)
+        if(charAt(i)==c)
+          return i;
+      return -1;
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/StringBufferWrap.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/StringBufferWrap.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/StringBufferWrap.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/StringBufferWrap.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/StringBufferWrap.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,36 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat.wrap;
+
+import com.stevesoft.eve_pat.*;
+
+/** This provides a wrapper for StringBuffer to
+    capture the output of a replacement. */
+public class StringBufferWrap
+    implements BasicStringBufferLike
+  {
+  StringBuffer sb = new StringBuffer();
+  public void append(char c) {
+    sb.append(c);
+  }
+  public void append(String s) {
+    sb.append(s);
+  }
+  public int length() {
+    return sb.length();
+  }
+  public String toString() {
+    return sb.toString();
+  }
+  public StringLike toStringLike() {
+    return new StringWrap(sb.toString());
+  }
+  public Object unwrap() {
+    return sb;
+  }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/StringWrap.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/StringWrap.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/StringWrap.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/StringWrap.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/StringWrap.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,33 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat.wrap;
+
+import com.stevesoft.eve_pat.*;
+
+/** A basic wrapper for the String object. Regex does
+    not search String directly any longer, it searches StringLike. */
+public class StringWrap implements StringLike {
+    String s;
+    public StringWrap(String s) {
+      this.s = s;
+    }
+    public String toString() { return s; }
+    public char charAt(int i) { return s.charAt(i); }
+    public int length() { return s.length(); }
+    public String substring(int i1,int i2) {
+        return s.substring(i1,i2);
+    }
+    public Object unwrap() { return s; }
+    public BasicStringBufferLike newStringBufferLike() {
+      return new StringBufferWrap();
+    }
+
+    public int indexOf(char c) {
+      return s.indexOf(c);
+    }
+}

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/WriterWrap.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/WriterWrap.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/WriterWrap.java
===================================================================
--- experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/WriterWrap.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/com/stevesoft/eve_pat/wrap/WriterWrap.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,46 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// <A HREF="http://www.gnu.org/copyleft/lesser.txt">http://www.gnu.org/copyleft/lesser.txt</A> for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.eve_pat.wrap;
+
+import com.stevesoft.eve_pat.*;
+
+import java.io.*;
+
+/** Allows the outcome of a replaceAll() or replaceFirst()
+    to be directed to a Writer rather than a String.
+    &lt;p&gt;
+    The method toStringLike() cannot work, however.
+    This means that the return value of replaceAll() will
+    be null if this Object is used as the StringBufferLike.*/
+public class WriterWrap
+  implements BasicStringBufferLike
+  {
+  Writer w;
+  public WriterWrap(Writer w) {
+    this.w = w;
+  }
+  public void append(char c) {
+    try {
+      w.write((int)c);
+    } catch(IOException ioe) {}
+  }
+  public void append(String s) {
+    try {
+      w.write(s);
+    } catch(IOException ioe) {}
+  }
+
+  /** This operation can't really be done. */
+  public StringLike toStringLike() {
+    return null;
+  }
+
+  public Object unwrap() {
+    return w;
+  }
+}

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/DocumentHandler.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/ewesoft/xml/DocumentHandler.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/DocumentHandler.java
===================================================================
--- experiments/EVE/lib/lib-folder/ewesoft/xml/DocumentHandler.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/ewesoft/xml/DocumentHandler.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,12 @@
+//package org.minml;
+package ewesoft.xml;
+
+import java.io.Writer;
+import ewesoft.xml.sax.SAXException;
+import ewesoft.xml.sax.AttributeList;
+
+public interface DocumentHandler extends ewesoft.xml.sax.DocumentHandler {
+  Writer startDocument(final Writer writer) throws SAXException;
+  Writer startElement(final String name, final AttributeList attributes, final Writer writer)
+        throws SAXException;
+}

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/MinML$1.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/ewesoft/xml/MinML$1.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/MinML$MinMLBuffer.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/ewesoft/xml/MinML$MinMLBuffer.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/MinML.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/ewesoft/xml/MinML.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/MinML.java
===================================================================
--- experiments/EVE/lib/lib-folder/ewesoft/xml/MinML.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/ewesoft/xml/MinML.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,777 @@
+// Copyright (c) 2000, 2001 The Wilson Partnership.
+// All Rights Reserved.
+// @(#)MinML.java, 1.7, 18th November 2001
+// Author: John Wilson - <A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">tug at wilson.co.uk</A>
+
+//package org.minml;
+package ewesoft.xml;
+
+/*
+Copyright (c) 2000, 2001 John Wilson (<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">tug at wilson.co.uk</A>).
+All rights reserved.
+Redistribution and use in source and binary forms,
+with or without modification, are permitted provided
+that the following conditions are met:
+
+Redistributions of source code must retain the above
+copyright notice, this list of conditions and the
+following disclaimer.
+
+Redistributions in binary form must reproduce the
+above copyright notice, this list of conditions and
+the following disclaimer in the documentation and/or
+other materials provided with the distribution.
+
+All advertising materials mentioning features or use
+of this software must display the following acknowledgement:
+
+This product includes software developed by John Wilson.
+The name of John Wilson may not be used to endorse or promote
+products derived from this software without specific prior
+written permission.
+
+THIS SOFTWARE IS PROVIDED BY JOHN WILSON ``AS IS'' AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JOHN WILSON
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+OF THE POSSIBILITY OF SUCH DAMAGE
+*/
+
+import java.io.Reader;
+import java.io.Writer;
+import java.io.InputStreamReader;
+import java.io.IOException;
+
+
+import eve.sys.Locale;
+import java.util.Vector;
+import java.util.Stack;
+import java.util.EmptyStackException;
+import ewesoft.xml.sax.EntityResolver;
+import ewesoft.xml.sax.DTDHandler;
+import ewesoft.xml.sax.ErrorHandler;
+import ewesoft.xml.sax.Locator;
+import ewesoft.xml.sax.InputSource;
+import ewesoft.xml.sax.AttributeList;
+import ewesoft.xml.sax.SAXException;
+import ewesoft.xml.sax.SAXParseException;
+
+public class MinML implements Parser, Locator, DocumentHandler, ErrorHandler {
+  public static final int endStartName = 0;
+  public static final int emitStartElement = 1;
+  public static final int emitEndElement = 2;
+  public static final int possiblyEmitCharacters = 3;
+  public static final int emitCharacters = 4;
+  public static final int emitCharactersSave = 5;
+  public static final int saveAttributeName = 6;
+  public static final int saveAttributeValue = 7;
+  public static final int startComment = 8;
+  public static final int endComment = 9;
+  public static final int incLevel = 10;
+  public static final int decLevel = 11;
+  public static final int startCDATA = 12;
+  public static final int endCDATA = 13;
+  public static final int processCharRef = 14;
+  public static final int writeCdata = 15;
+  public static final int exitParser = 16;
+  public static final int parseError = 17;
+  public static final int discardAndChange = 18;
+  public static final int discardSaveAndChange = 19;
+  public static final int saveAndChange = 20;
+  public static final int change = 21;
+
+  public static final int inSkipping = 0;
+  public static final int inSTag = 1;
+  public static final int inPossiblyAttribute = 2;
+  public static final int inNextAttribute = 3;
+  public static final int inAttribute = 4;
+  public static final int inAttribute1 = 5;
+  public static final int inAttributeValue = 6;
+  public static final int inAttributeQuoteValue = 7;
+  public static final int inAttributeQuotesValue = 8;
+  public static final int inETag = 9;
+  public static final int inETag1 = 10;
+  public static final int inMTTag = 11;
+  public static final int inTag = 12;
+  public static final int inTag1 = 13;
+  public static final int inPI = 14;
+  public static final int inPI1 = 15;
+  public static final int inPossiblySkipping = 16;
+  public static final int inCharData = 17;
+  public static final int inCDATA = 18;
+  public static final int inCDATA1 = 19;
+  public static final int inComment =20;
+  public static final int inDTD = 21;
+
+  public MinML(final int initialBufferSize, final int bufferIncrement) {
+    this.initialBufferSize = initialBufferSize;
+    this.bufferIncrement = bufferIncrement;
+  }
+
+  public MinML() {
+    this(256, 128);
+  }
+
+  public void parse(final Reader in) throws SAXException, IOException {
+  final Vector attributeNames = new Vector();
+  final Vector attributeValues = new Vector();
+
+  final AttributeList attrs = new AttributeList() {
+    public int getLength() {
+      return attributeNames.size();
+    }
+
+    public String getName(final int i) {
+      return (String)attributeNames.elementAt(i);
+    }
+
+    public String getType(final int i) {
+      return &quot;CDATA&quot;;
+    }
+
+    public String getValue(final int i) {
+      return (String)attributeValues.elementAt(i);
+    }
+
+    public String getType(final String name) {
+      return &quot;CDATA&quot;;
+    }
+
+    public String getValue(final String name) {
+    final int index = attributeNames.indexOf(name);
+
+      return (index == -1) ? null : (String)attributeValues.elementAt(index);
+    }
+    public String toString()
+    {
+    	StringBuffer sb = new StringBuffer();
+    	sb.append(&quot;{&quot;);
+    	int len = getLength();
+    	for (int i = 0; i&lt;len; i++){
+    		if (i != 0) sb.append(&quot;, &quot;);
+    		sb.append(getName(i)+&quot;=&quot;+getValue(i));
+    	}
+    	sb.append(&quot;}&quot;);
+    	return sb.toString();
+    }
+  };
+
+  final MinMLBuffer buffer = new MinMLBuffer(in);
+  int currentChar = 0, charCount = 0;
+  int level = 0;
+  int mixedContentLevel = -1;
+  String elementName = null;
+  String state = operands[inSkipping];
+
+    this.lineNumber = 1;
+    this.columnNumber = 0;
+
+    try {
+      while(true) {
+        charCount++;
+
+        //
+        // this is to try and make the loop a bit faster
+        // currentChar = buffer.read(); is simpler but is a bit slower.
+        //
+        currentChar = (buffer.nextIn == buffer.lastIn) ? buffer.read() : buffer.chars[buffer.nextIn++];
+
+        final int transition;
+
+        if (currentChar &gt; ']') {
+          transition = state.charAt(14);
+        } else {
+        final int charClass = charClasses[currentChar + 1];
+
+          if (charClass == -1) fatalError(&quot;Document contains illegal control character with value &quot; + currentChar, this.lineNumber, this.columnNumber);
+
+          if (charClass == 12) {
+            if (currentChar == '\r') {
+              currentChar = '\n';
+              charCount = -1;
+            }
+
+            if (currentChar == '\n') {
+              if (charCount == 0) continue;  // preceeded by '\r' so ignore
+
+              if (charCount != -1) charCount = 0;
+
+              this.lineNumber++;
+              this.columnNumber = 0;
+            }
+          }
+
+          transition = state.charAt(charClass);
+       }
+
+        this.columnNumber++;
+
+        final String operand = operands[transition &gt;&gt;&gt; 8];
+
+        switch (transition &amp; 0XFF) {
+          case endStartName:
+          // end of start element name
+            elementName = buffer.getString();
+            if (currentChar != '&gt;' &amp;&amp; currentChar != '/') break;  // change state to operand
+            // drop through to emit start element (we have no attributes)
+
+          case emitStartElement:
+          // emit start element
+
+          final Writer newWriter = this.extDocumentHandler.startElement(elementName, attrs,
+                                                                        (this.tags.empty()) ?
+                                                                          this.extDocumentHandler.startDocument(buffer)
+                                                                        :
+                                                                          buffer.getWriter());
+
+            buffer.pushWriter(newWriter);
+            this.tags.push(elementName);
+
+            attributeValues.removeAllElements();
+            attributeNames.removeAllElements();
+
+            if (mixedContentLevel != -1) mixedContentLevel++;
+
+            if (currentChar != '/') break;  // change state to operand
+
+            // &lt;element/&gt; drop through
+
+          case emitEndElement:
+          // emit end element
+
+            try {
+            final String begin = (String)this.tags.pop();
+
+              buffer.popWriter();
+              elementName = buffer.getString();
+
+              if (currentChar != '/' &amp;&amp; !elementName.equals(begin)) {
+               fatalError(&quot;end tag &lt;/&quot; + elementName + &quot;&gt; does not match begin tag &lt;&quot; + begin + &quot;&gt;&quot;,
+                           this.lineNumber, this.columnNumber);
+              } else {
+                this.documentHandler.endElement(begin);
+
+                if (this.tags.empty()) {
+                  this.documentHandler.endDocument();
+                  return;
+                }
+              }
+            }
+            catch (final EmptyStackException e) {
+              fatalError(&quot;end tag at begining of document&quot;, this.lineNumber, this.columnNumber);
+            }
+
+            if (mixedContentLevel != -1) --mixedContentLevel;
+
+            break;  // change state to operand
+
+          case emitCharacters:
+          // emit characters
+
+            buffer.flush();
+            break;  // change state to operand
+
+          case emitCharactersSave:
+          // emit characters and save current character
+
+            if (mixedContentLevel == -1) mixedContentLevel = 0;
+
+            buffer.flush();
+
+            buffer.saveChar((char)currentChar);
+
+            break;  // change state to operand
+
+          case possiblyEmitCharacters:
+          // write any skipped whitespace if in mixed content
+
+            if (mixedContentLevel != -1) buffer.flush();
+            break;  // change state to operand
+
+          case saveAttributeName:
+          // save attribute name
+
+            attributeNames.addElement(buffer.getString());
+            break;  // change state to operand
+
+          case saveAttributeValue:
+          // save attribute value
+
+            attributeValues.addElement(buffer.getString());
+            break;  // change state to operand
+
+          case startComment:
+          // change state if we have found &quot;&lt;!--&quot;
+
+            if (buffer.read() != '-') continue; // not &quot;&lt;!--&quot;
+
+            break;  // change state to operand
+
+          case endComment:
+          // change state if we find &quot;--&gt;&quot;
+
+            if ((currentChar = buffer.read()) == '-') {
+              // deal with the case where we might have &quot;-------&gt;&quot;
+              while ((currentChar = buffer.read()) == '-');
+
+              if (currentChar == '&gt;') break;  // end of comment, change state to operand
+            }
+
+            continue;   // not end of comment, don't change state
+
+          case incLevel:
+
+            level++;
+
+            break;
+
+          case decLevel:
+
+            if (level == 0) break; // outer level &lt;&gt; change state
+
+            level--;
+
+            continue; // in nested &lt;&gt;, don't change state
+
+          case startCDATA:
+          // change state if we have found &quot;&lt;![CDATA[&quot;
+
+            if (buffer.read() != 'C') continue;   // don't change state
+            if (buffer.read() != 'D') continue;   // don't change state
+            if (buffer.read() != 'A') continue;   // don't change state
+            if (buffer.read() != 'T') continue;   // don't change state
+            if (buffer.read() != 'A') continue;   // don't change state
+            if (buffer.read() != '[') continue;   // don't change state
+            break;  // change state to operand
+
+          case endCDATA:
+          // change state if we find &quot;]]&gt;&quot;
+
+            if ((currentChar = buffer.read()) == ']') {
+              // deal with the case where we might have &quot;]]]]]]]&gt;&quot;
+              while ((currentChar = buffer.read()) == ']') buffer.write(']');
+
+              if (currentChar == '&gt;') break;  // end of CDATA section, change state to operand
+
+              buffer.write(']');
+            }
+
+            buffer.write(']');
+            buffer.write(currentChar);
+            continue;   // not end of CDATA section, don't change state
+
+          case processCharRef:
+          // process character entity
+
+            int crefState = 0;
+
+            currentChar = buffer.read();
+
+            while (true) {
+              if (&quot;#amp;&pos;'quot;\&quot;gt;&gt;lt;&lt;&quot;.charAt(crefState) == currentChar) {
+                crefState++;
+
+                if (currentChar == ';') {
+                  buffer.write(&quot;#amp;&pos;'quot;\&quot;gt;&gt;lt;&lt;&quot;.charAt(crefState));
+                  break;
+
+                } else if (currentChar == '#') {
+                final int radix;
+
+                  currentChar = buffer.read();
+
+                  if (currentChar == 'x') {
+                    radix = 16;
+                    currentChar = buffer.read();
+                  } else {
+                    radix = 10;
+                  }
+
+                  int charRef = Character.digit((char)currentChar, radix);
+
+                  while (true) {
+                    currentChar = buffer.read();
+
+                    final int digit = Character.digit((char)currentChar, radix);
+
+                    if (digit == -1) break;
+
+                    charRef = (char)((charRef * radix) + digit);
+                  }
+
+                  if (currentChar == ';' &amp;&amp; charRef != -1) {
+                    buffer.write(charRef);
+                    break;
+                  }
+
+                  fatalError(&quot;invalid Character Entitiy&quot;, this.lineNumber, this.columnNumber);
+                } else {
+                  currentChar = buffer.read();
+                }
+              } else {
+                crefState = (&quot;\u0001\u000b\u0006\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff&quot; +
+//                               #     a     m     p     ;     &amp;     p     o     s     ;     '
+//                               0     1     2     3     4     5     6     7     8     9     a
+                             &quot;\u0011\u00ff\u00ff\u00ff\u00ff\u00ff\u0015\u00ff\u00ff\u00ff&quot; +
+//                               q     u     o     t     ;     &quot;     g     t     ;     &gt;
+//                               b     b     d     e     f     10    11    12    13    14
+                             &quot;\u00ff\u00ff\u00ff&quot;).charAt(crefState);
+//                               l     t     ;
+//                               15    16    17
+
+                if (crefState == 255) fatalError(&quot;invalid Character Entitiy&quot;, this.lineNumber, this.columnNumber);
+              }
+            }
+
+            break;
+
+          case parseError:
+          // report fatal error
+
+            fatalError(operand, this.lineNumber, this.columnNumber);
+            // drop through to exit parser
+
+          case exitParser:
+          // exit parser
+
+            return;
+
+          case writeCdata:
+          // write character data
+          // this will also write any skipped whitespace
+
+            buffer.write(currentChar);
+            break;  // change state to operand
+
+          case discardAndChange:
+          // throw saved characters away and change state
+
+            buffer.reset();
+            break;  // change state to operand
+
+          case discardSaveAndChange:
+          // throw saved characters away, save character and change state
+
+            buffer.reset();
+            // drop through to save character and change state
+
+          case saveAndChange:
+          // save character and change state
+
+            buffer.saveChar((char)currentChar);
+            break;  // change state to operand
+
+          case change:
+          // change state to operand
+
+            break;  // change state to operand
+        }
+
+        state = operand;
+      }
+    }
+    catch (final IOException e) {
+      this.errorHandler.fatalError(new SAXParseException(e.toString(), null, null, this.lineNumber, this.columnNumber, e));
+    }
+    finally {
+      this.errorHandler = this;
+      this.documentHandler = this.extDocumentHandler = this;
+      this.tags.clear();
+    }
+  }
+  public void parse(final InputSource source) throws SAXException, IOException {
+    if (source.getCharacterStream() != null)
+      parse(source.getCharacterStream());
+    else if (source.getByteStream() != null)
+      parse(new InputStreamReader(source.getByteStream()));
+		else
+			throw new SAXException(&quot;Input source not supported.&quot;);
+		/*
+    else
+     parse(new InputStreamReader(new URL(source.getSystemId()).openStream()));
+		*/
+  }
+  public void parse(final String systemId) throws SAXException, IOException {
+    parse(new InputSource(systemId));
+  }
+
+  public void setLocale(final Locale locale) throws SAXException {
+    throw new SAXException(&quot;Not supported&quot;);
+  }
+
+  public void setEntityResolver(final EntityResolver resolver) {
+    // not supported
+  }
+
+  public void setDTDHandler(final DTDHandler handler) {
+    // not supported
+  }
+
+  public void setDocumentHandler(final ewesoft.xml.sax.DocumentHandler handler) {
+   this.documentHandler = (handler == null) ? this : handler;
+   this.extDocumentHandler = this;
+  }
+
+  public void setDocumentHandler(final DocumentHandler handler) {
+   this.documentHandler = this.extDocumentHandler = (handler == null) ? this : handler;
+   this.documentHandler.setDocumentLocator(this);
+  }
+
+  public void setErrorHandler(final ErrorHandler handler) {
+   this.errorHandler = (handler == null) ? this : handler;
+  }
+
+  public void setDocumentLocator(final Locator locator) {
+  }
+
+  public void startDocument() throws SAXException {
+  }
+
+  public Writer startDocument(final Writer writer) throws SAXException {
+    this.documentHandler.startDocument();
+    return writer;
+  }
+
+  public void endDocument() throws SAXException {
+  }
+
+  public void startElement(final String name, final AttributeList attributes) throws SAXException {
+  }
+
+  public Writer startElement(final String name, final AttributeList attributes, final Writer writer)
+        throws SAXException
+  {
+    this.documentHandler.startElement(name, attributes);
+    return writer;
+  }
+
+  public void endElement(final String name) throws SAXException {
+  }
+
+  public void characters(final char ch[], final int start, final int length) throws SAXException {
+  }
+
+  public void ignorableWhitespace(final char ch[], final int start, final int length) throws SAXException {
+  }
+
+  public void processingInstruction(final String target, final String data) throws SAXException {
+  }
+
+  public void warning(final SAXParseException e) throws SAXException {
+  }
+
+  public void error(final SAXParseException e) throws SAXException {
+  }
+
+  public void fatalError(final SAXParseException e) throws SAXException {
+    throw e;
+  }
+
+  public String getPublicId() {
+    return &quot;&quot;;
+  }
+
+
+  public String getSystemId() {
+    return &quot;&quot;;
+  }
+
+  public int getLineNumber () {
+    return this.lineNumber;
+  }
+
+  public int getColumnNumber () {
+    return this.columnNumber;
+  }
+
+  private void fatalError(final String msg, final int lineNumber, final int columnNumber) throws SAXException {
+    this.errorHandler.fatalError(new SAXParseException(msg, null, null, lineNumber, columnNumber));
+  }
+
+  private class MinMLBuffer extends Writer {
+    public MinMLBuffer(final Reader in) {
+      this.in = in;
+    }
+
+    public void close() throws IOException {
+      flush();
+    }
+
+    public void flush() throws IOException {
+      try {
+        _flush();
+        if (writer != this) writer.flush();
+      }
+      finally {
+        flushed = true;
+      }
+    }
+
+    public void write(final int c) throws IOException {
+      written = true;
+      chars[count++] = (char)c;
+    }
+
+    public void write(final char[] cbuf, final int off, final int len) throws IOException {
+      written = true;
+      System.arraycopy(cbuf, off, chars, count, len);
+      count += len;
+    }
+
+    public void saveChar(final char c) {
+      written = false;
+      chars[count++] = c;
+    }
+
+    public void pushWriter(final Writer writer) {
+      MinML.this.tags.push(this.writer);
+
+      this.writer = (writer == null) ? this : writer;
+
+      flushed = written = false;
+    }
+
+    public Writer getWriter() {
+      return writer;
+    }
+
+    public void popWriter() throws IOException {
+      try {
+        if (!flushed &amp;&amp; writer != this) writer.flush();
+      }
+      finally {
+        writer = (Writer)MinML.this.tags.pop();
+        flushed = written = false;
+      }
+    }
+
+    public String getString() {
+    final String result = new String(chars, 0, count);
+
+      count = 0;
+      return result;
+    }
+
+    public void reset() {
+      count = 0;
+    }
+
+    public int read() throws IOException {
+      if (nextIn == lastIn) {
+        if (count != 0) {
+          if (written) {
+            _flush();
+          } else if (count &gt;= (chars.length - MinML.this.bufferIncrement)) {
+          final char[] newChars = new char[chars.length + MinML.this.bufferIncrement];
+
+            System.arraycopy(chars, 0, newChars, 0, count);
+            chars = newChars;
+          }
+        }
+
+        final int numRead = in.read(chars, count, chars.length - count);
+
+        if (numRead == -1) return -1;
+
+        nextIn = count;
+        lastIn = count + numRead;
+      }
+
+      return chars[nextIn++];
+    }
+
+    private void _flush() throws IOException {
+      if (count != 0) {
+        try {
+          if (writer == this) {
+            try {
+              MinML.this.documentHandler.characters(chars, 0, count);
+            }
+            catch (final SAXException e) {
+              throw new IOException(e.toString());
+            }
+          } else {
+            writer.write(chars, 0, count);
+          }
+        }
+        finally {
+          count = 0;
+        }
+      }
+    }
+
+    private int nextIn = 0, lastIn = 0;
+    private char[] chars = new char[MinML.this.initialBufferSize];
+    private final Reader in;
+    private int count = 0;
+    private Writer writer = this;
+    private boolean flushed = false;
+    private boolean written = false;
+  }
+
+  private DocumentHandler extDocumentHandler = this;
+  private ewesoft.xml.sax.DocumentHandler documentHandler = this;
+  private ErrorHandler errorHandler = this;
+  private final Stack tags = new Stack();
+  private int lineNumber = 1;
+  private int columnNumber = 0;
+  private final int initialBufferSize;
+  private final int bufferIncrement;
+
+  private static final byte[] charClasses = {
+  //  EOF
+      13,
+  //                                      \t  \n          \r
+      -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, 12, -1, -1, 12, -1, -1,
+  //
+      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  //  SP   !   &quot;   #   $   %   &amp;   '   (   )   *   +   ,   -   .   /
+      12,  8,  7, 14, 14, 14,  3,  6, 14, 14, 14, 14, 14, 11, 14,  2,
+  //   0   1   2   3   4   5   6   7   8   9   :   ;   &lt;   =   &gt;   ?
+      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,  0,  5,  1,  4,
+  //
+      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+  //                                               [   \   ]
+      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,  9, 14, 10
+  };
+
+  private static final String[] operands = {
+    &quot;\u0d15\u1611\u1611\u1611\u1611\u1611\u1611\u1611\u1611\u1611\u1611\u1611\u0015\u0010\u1611&quot;,
+    &quot;\u1711\u1000\u0b00\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u0114\u0200\u1811\u0114&quot;,
+    &quot;\u1711\u1001\u0b01\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u0215\u1811\u0414&quot;,
+    &quot;\u1711\u1001\u0b01\u1711\u1911\u1911\u1911\u1911\u1911\u1911\u1911\u1911\u0315\u1811\u0414&quot;,
+    &quot;\u1911\u1911\u1911\u1911\u1911\u0606\u1911\u1911\u1911\u1911\u1911\u0414\u0515\u1811\u0414&quot;,
+    &quot;\u1911\u1911\u1911\u1911\u1911\u0606\u1911\u1911\u1911\u1911\u1911\u1911\u0515\u1811\u1911&quot;,
+    &quot;\u1a11\u1a11\u1a11\u1a11\u1a11\u1a11\u0715\u0815\u1a11\u1a11\u1a11\u1a11\u0615\u1811\u1a11&quot;,
+    &quot;\u0714\u0714\u0714\u070e\u0714\u0714\u0307\u0714\u0714\u0714\u0714\u0714\u0714\u1811\u0714&quot;,
+    &quot;\u0814\u0814\u0814\u080e\u0814\u0814\u0814\u0307\u0814\u0814\u0814\u0814\u0814\u1811\u0814&quot;,
+    &quot;\u1711\u1002\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u0914\u0915\u1811\u0914&quot;,
+    &quot;\u1b11\u1b11\u0904\u1b11\u1b11\u1b11\u1b11\u1b11\u1215\u1b11\u1b11\u1b11\u1b11\u1811\u0105&quot;,
+    &quot;\u1711\u1012\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1811\u1711&quot;,
+    &quot;\u1711\u1c11\u0912\u1711\u0e12\u1711\u1711\u1711\u1212\u1711\u1711\u1711\u1711\u1811\u0113&quot;,
+    &quot;\u1711\u1c11\u0912\u1711\u0e12\u1711\u1711\u1711\u1212\u1711\u1711\u1711\u1711\u1811\u0113&quot;,
+    &quot;\u0e15\u0e15\u0e15\u0e15\u0f15\u0e15\u0e15\u0e15\u0e15\u0e15\u0e15\u0e15\u0e15\u1811\u0e15&quot;,
+    &quot;\u0e15\u0015\u0e15\u0e15\u0f15\u0e15\u0e15\u0e15\u0e15\u0e15\u0e15\u0e15\u0e15\u1811\u0e15&quot;,
+    &quot;\u0c03\u110f\u110f\u110e\u110f\u110f\u110f\u110f\u110f\u110f\u110f\u110f\u1014\u1811\u110f&quot;,
+    &quot;\u0a15\u110f\u110f\u110e\u110f\u110f\u110f\u110f\u110f\u110f\u110f\u110f\u110f\u1811\u110f&quot;,
+    &quot;\u1d11\u1d11\u1d11\u1d11\u1d11\u1d11\u1d11\u1d11\u1d11\u130c\u1d11\u1408\u1d11\u1811\u1515&quot;,
+    &quot;\u130f\u130f\u130f\u130f\u130f\u130f\u130f\u130f\u130f\u130f\u110d\u130f\u130f\u1811\u130f&quot;,
+    &quot;\u1415\u1415\u1415\u1415\u1415\u1415\u1415\u1415\u1415\u1415\u1415\u0009\u1415\u1811\u1415&quot;,
+    &quot;\u150a\u000b\u1515\u1515\u1515\u1515\u1515\u1515\u1515\u1515\u1515\u1515\u1515\u1811\u1515&quot;,
+    &quot;expected Element&quot;,
+    &quot;unexpected character in tag&quot;,
+    &quot;unexpected end of file found&quot;,
+    &quot;attribute name not followed by '='&quot;,
+    &quot;invalid attribute value&quot;,
+    &quot;expecting end tag&quot;,
+    &quot;empty tag&quot;,
+    &quot;unexpected character after &lt;!&quot;
+  };
+}

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/Parser.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/ewesoft/xml/Parser.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/XMLDecoder.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/ewesoft/xml/XMLDecoder.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/XMLDecoder.java
===================================================================
--- experiments/EVE/lib/lib-folder/ewesoft/xml/XMLDecoder.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/ewesoft/xml/XMLDecoder.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,91 @@
+/*
+ * Created on Jan 20, 2005
+ *
+ */
+package ewesoft.xml;
+
+import ewesoft.xml.sax.AttributeList;
+import ewesoft.xml.sax.SAXException;
+import java.util.Vector;
+import eve.data.PropertyList;
+
+/**
+ * This class will fully decode an XML document from a Reader.
+ * It parses the XML document and creates a tree of XMLElement
+ * objects, with the root of the tree being the &lt;b&gt;document&lt;/b&gt;
+ * element of the XMLDecoder.
+ * &lt;p&gt;
+ * To use simply create a Reader to provide the characters of the
+ * XML document and then call parse() on that reader. 
+ * @author Michael Brereton, Ewesoft.com.
+ */
+public class XMLDecoder extends MinML {
+
+	/**
+	 * This is the XMLElement that represents the entire document.
+	 * It will be valid only after the parse() method has completed
+	 * successfully.
+	 */
+	public XMLElement document;
+	
+	private XMLElement current;
+
+	/* (non-Javadoc)
+	 * @see ewesoft.xml.sax.DocumentHandler#startElement(java.lang.String, ewesoft.xml.sax.AttributeList)
+	 */
+	public void startElement(String name, AttributeList atts)
+			throws SAXException {
+		if (current == null){
+			current = document = new XMLElement();
+		}else{
+			XMLElement xe = new XMLElement();
+			current.subElements.add(xe);
+			xe.parent = current;
+			current = xe;
+		}
+		current.tag = name;
+		if (atts != null &amp;&amp; atts.getLength() == 0)
+			atts = null;
+		if (atts != null){
+			current.attributes = new PropertyList();
+			int max = atts.getLength();
+			for (int i = 0; i&lt;max; i++)
+				current.attributes.add(atts.getName(i),atts.getValue(i));
+		}
+	}
+
+	/* (non-Javadoc)
+	 * @see ewesoft.xml.sax.DocumentHandler#endElement(java.lang.String)
+	 */
+	public void endElement(String name) throws SAXException {
+		current = current.parent;
+	}
+
+	/* (non-Javadoc)
+	 * @see ewesoft.xml.sax.DocumentHandler#characters(char[], int, int)
+	 */
+	public void characters(char[] ch, int start, int length)
+			throws SAXException {
+		current.text += new String(ch,start,length);
+	}
+/**
+ * This main() method takes the argument from the command line
+ * as the name of an XMLFile. It then attempts to open and parse
+ * the file. If successful, it will then call format() on the
+ * document XMLElement produced and then display this on the
+ * console.
+ * @param args
+ * @throws ewe.io.IOException
+ * @throws SAXException
+ */
+	public static void main(String[] args) throws java.io.IOException, SAXException
+	{
+		eve.ui.Application.startApplication(args);
+		java.io.Reader r = new java.io.InputStreamReader(new java.io.FileInputStream(args[0]));
+		XMLDecoder xd = new XMLDecoder();
+		xd.parse(r);
+		r.close();
+		eve.sys.Vm.debug(xd.document.format());
+		eve.ui.Application.exit(0);
+	}
+}

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/XMLElement.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/ewesoft/xml/XMLElement.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/XMLElement.java
===================================================================
--- experiments/EVE/lib/lib-folder/ewesoft/xml/XMLElement.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/ewesoft/xml/XMLElement.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,69 @@
+/*
+ * Created on Jan 20, 2005
+ */
+package ewesoft.xml;
+import java.util.Vector;
+import eve.data.PropertyList;
+/**
+ * This class represents the data within the open and close tags
+ * of an XML entry. It holds the name of the entry (the &lt;b&gt;tag&lt;/b&gt;)
+ * and either the text for the entry, or the sub-elements within
+ * that entry.
+ * @author Michael L Brereton, Ewesoft.com.
+ */
+public class XMLElement {
+	/**
+	 * This is the tag for this XMLElement.
+	 */
+	public String tag;
+	/**
+	 * If there is any text within the XML tags, then this value
+	 * will be set to be that text, otherwise it will be an empty String. 
+	 */
+	public String text = &quot;&quot;;
+	/**
+	 * If there are any sub-elements within this element, then
+	 * they are stored in this Vector. Otherwise this Vector will
+	 * be null.
+	 */
+	public Vector subElements;
+	/**
+	 * If there are any attributes for the XML element, they
+	 * will be placed here.
+	 */
+	public PropertyList attributes;
+	/**
+	 * This holds the parent XMLElement as determined during
+	 * parsing. The root element will have no parent.
+	 */
+	public XMLElement parent;
+	/**
+	 * Format the XMLElement and its children into a String.
+	 * @param prefix tabs or spaces to put in front of the format. 
+	 * @return the XMLElement and its children into a String.
+	 */
+	public String format(String prefix)
+	{
+		String ret = new String();
+		ret += prefix+&quot;&lt;&quot;+tag+&quot;&gt;&quot;;
+		if (prefix.length() == 0) prefix += &quot; &quot;;
+		else prefix += prefix.charAt(0);
+		if (attributes != null) ret += attributes;
+		ret += &quot;\n&quot;;
+		if (text.length() != 0) ret += prefix+&quot;\&quot;&quot;+text+&quot;\&quot;&quot;+&quot;\n&quot;;
+		if (subElements != null){
+			for (int i = 0; i&lt;subElements.size(); i++)
+				ret += ((XMLElement)subElements.get(i)).format(prefix);
+		}
+		return ret;
+	}
+	/**
+	 * Format the XMLElement and its children into a String, with
+	 * each sub-element prefixed by increasing numbers of spaces.
+	 * @return the XMLElement and its children into a String.
+	 */
+	public String format()
+	{
+		return format(&quot;&quot;);
+	}
+}

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/AttributeList.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/AttributeList.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/DTDHandler.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/DTDHandler.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/DocumentHandler.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/DocumentHandler.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/EntityResolver.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/EntityResolver.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/EntityResolver.java
===================================================================
--- experiments/EVE/lib/lib-folder/ewesoft/xml/sax/EntityResolver.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/ewesoft/xml/sax/EntityResolver.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,105 @@
+// SAX entity resolver.
+// No warranty; no copyright -- use this as you will.
+// $Id: EntityResolver.java,v 1.2 2004/09/13 21:00:18 damon Exp $
+
+package ewesoft.xml.sax;
+
+import java.io.IOException;
+
+
+/**
+  * Basic interface for resolving entities.
+  *
+  * &lt;p&gt;If a SAX application needs to implement customized handling
+  * for external entities, it must implement this interface and
+  * register an instance with the SAX parser using the parser's
+  * setEntityResolver method.&lt;/p&gt;
+  *
+  * &lt;p&gt;The parser will then allow the application to intercept any
+  * external entities (including the external DTD subset and external
+  * parameter entities, if any) before including them.&lt;/p&gt;
+  *
+  * &lt;p&gt;Many SAX applications will not need to implement this interface,
+  * but it will be especially useful for applications that build
+  * XML documents from databases or other specialised input sources,
+  * or for applications that use URI types other than URLs.&lt;/p&gt;
+  *
+  * &lt;p&gt;The following resolver would provide the application
+  * with a special character stream for the entity with the system
+  * identifier &quot;<A HREF="http://www.myhost.com/today">http://www.myhost.com/today</A>&quot;:&lt;/p&gt;
+  *
+  * &lt;pre&gt;
+  * import ewesoft.xml.sax.EntityResolver;
+  * import ewesoft.xml.sax.InputSource;
+  *
+  * public class MyResolver implements EntityResolver {
+  *   public InputSource resolveEntity (String publicId, String systemId)
+  *   {
+  *     if (systemId.equals(&quot;<A HREF="http://www.myhost.com/today">http://www.myhost.com/today</A>&quot;)) {
+  *              // return a special input source
+  *       MyReader reader = new MyReader();
+  *       return new InputSource(reader);
+  *     } else {
+  *              // use the default behaviour
+  *       return null;
+  *     }
+  *   }
+  * }
+  * &lt;/pre&gt;
+  *
+  * &lt;p&gt;The application can also use this interface to redirect system
+  * identifiers to local URIs or to look up replacements in a catalog
+  * (possibly by using the public identifier).&lt;/p&gt;
+  *
+  * &lt;p&gt;The HandlerBase class implements the default behaviour for
+  * this interface, which is simply always to return null (to request
+  * that the parser use the default system identifier).&lt;/p&gt;
+  *
+  * @author David Megginson (<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">ak117 at freenet.carleton.ca</A>)
+  * @version 1.0
+  * @see ewesoft.xml.sax.Parser#setEntityResolver
+  * @see ewesoft.xml.sax.InputSource
+  * @see ewesoft.xml.sax.HandlerBase 
+  */
+public interface EntityResolver {
+
+
+  /**
+    * Allow the application to resolve external entities.
+    *
+    * &lt;p&gt;The Parser will call this method before opening any external
+    * entity except the top-level document entity (including the
+    * external DTD subset, external entities referenced within the
+    * DTD, and external entities referenced within the document
+    * element): the application may request that the parser resolve
+    * the entity itself, that it use an alternative URI, or that it
+    * use an entirely different input source.&lt;/p&gt;
+    *
+    * &lt;p&gt;Application writers can use this method to redirect external
+    * system identifiers to secure and/or local URIs, to look up
+    * public identifiers in a catalogue, or to read an entity from a
+    * database or other input source (including, for example, a dialog
+    * box).&lt;/p&gt;
+    *
+    * &lt;p&gt;If the system identifier is a URL, the SAX parser must
+    * resolve it fully before reporting it to the application.&lt;/p&gt;
+    *
+    * @param publicId The public identifier of the external entity
+    *        being referenced, or null if none was supplied.
+    * @param systemId The system identifier of the external entity
+    *        being referenced.
+    * @return An InputSource object describing the new input source,
+    *         or null to request that the parser open a regular
+    *         URI connection to the system identifier.
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @exception java.io.IOException A Java-specific IO exception,
+    *            possibly the result of creating a new InputStream
+    *            or Reader for the InputSource.
+    * @see ewesoft.xml.sax.InputSource
+    */
+  public abstract InputSource resolveEntity (String publicId,
+					     String systemId)
+    throws SAXException, IOException;
+
+}

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/ErrorHandler.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/ErrorHandler.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/HandlerBase.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/HandlerBase.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/InputSource.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/InputSource.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/InputSource.java
===================================================================
--- experiments/EVE/lib/lib-folder/ewesoft/xml/sax/InputSource.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/ewesoft/xml/sax/InputSource.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,311 @@
+// SAX input source.
+// No warranty; no copyright -- use this as you will.
+// $Id: InputSource.java,v 1.2 2004/09/13 21:00:18 damon Exp $
+
+package ewesoft.xml.sax;
+
+import java.io.Reader;
+import java.io.InputStream;
+
+/**
+  * A single input source for an XML entity.
+  *
+  * &lt;p&gt;This class allows a SAX application to encapsulate information
+  * about an input source in a single object, which may include
+  * a public identifier, a system identifier, a byte stream (possibly
+  * with a specified encoding), and/or a character stream.&lt;/p&gt;
+  *
+  * &lt;p&gt;There are two places that the application will deliver this
+  * input source to the parser: as the argument to the Parser.parse
+  * method, or as the return value of the EntityResolver.resolveEntity
+  * method.&lt;/p&gt;
+  *
+  * &lt;p&gt;The SAX parser will use the InputSource object to determine how
+  * to read XML input.  If there is a character stream available, the
+  * parser will read that stream directly; if not, the parser will use
+  * a byte stream, if available; if neither a character stream nor a
+  * byte stream is available, the parser will attempt to open a URI
+  * connection to the resource identified by the system
+  * identifier.&lt;/p&gt;
+  *
+  * &lt;p&gt;An InputSource object belongs to the application: the SAX parser
+  * shall never modify it in any way (it may modify a copy if 
+  * necessary).&lt;/p&gt;
+  *
+  * @author David Megginson (<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">ak117 at freenet.carleton.ca</A>)
+  * @version 1.0
+  * @see ewesoft.xml.sax.Parser#parse
+  * @see ewesoft.xml.sax.EntityResolver#resolveEntity
+  * @see java.io.InputStream
+  * @see java.io.Reader
+  */
+public class InputSource {
+
+  /**
+    * Zero-argument default constructor.
+    *
+    * @see #setPublicId
+    * @see #setSystemId
+    * @see #setByteStream
+    * @see #setCharacterStream
+    * @see #setEncoding
+    */
+  public InputSource ()
+  {
+  }
+
+
+  /**
+    * Create a new input source with a system identifier.
+    *
+    * &lt;p&gt;Applications may use setPublicId to include a 
+    * public identifier as well, or setEncoding to specify
+    * the character encoding, if known.&lt;/p&gt;
+    *
+    * &lt;p&gt;If the system identifier is a URL, it must be full resolved.&lt;/p&gt;
+    *
+    * @param systemId The system identifier (URI).
+    * @see #setPublicId
+    * @see #setSystemId
+    * @see #setByteStream
+    * @see #setEncoding
+    * @see #setCharacterStream
+    */
+  public InputSource (String systemId)
+  {
+    setSystemId(systemId);
+  }
+
+
+  /**
+    * Create a new input source with a byte stream.
+    *
+    * &lt;p&gt;Application writers may use setSystemId to provide a base 
+    * for resolving relative URIs, setPublicId to include a 
+    * public identifier, and/or setEncoding to specify the object's
+    * character encoding.&lt;/p&gt;
+    *
+    * @param byteStream The raw byte stream containing the document.
+    * @see #setPublicId
+    * @see #setSystemId
+    * @see #setEncoding
+    * @see #setByteStream
+    * @see #setCharacterStream
+    */
+  public InputSource (InputStream byteStream)
+  {
+    setByteStream(byteStream);
+  }
+
+
+  /**
+    * Create a new input source with a character stream.
+    *
+    * &lt;p&gt;Application writers may use setSystemId() to provide a base 
+    * for resolving relative URIs, and setPublicId to include a 
+    * public identifier.&lt;/p&gt;
+    *
+    * &lt;p&gt;The character stream shall not include a byte order mark.&lt;/p&gt;
+    *
+    * @see #setPublicId
+    * @see #setSystemId
+    * @see #setByteStream
+    * @see #setCharacterStream
+    */
+  public InputSource (Reader characterStream)
+  {
+    setCharacterStream(characterStream);
+  }
+
+
+  /**
+    * Set the public identifier for this input source.
+    *
+    * &lt;p&gt;The public identifier is always optional: if the application
+    * writer includes one, it will be provided as part of the
+    * location information.&lt;/p&gt;
+    *
+    * @param publicId The public identifier as a string.
+    * @see #getPublicId
+    * @see ewesoft.xml.sax.Locator#getPublicId
+    * @see ewesoft.xml.sax.SAXParseException#getPublicId
+    */
+  public void setPublicId (String publicId)
+  {
+    this.publicId = publicId;
+  }
+
+
+  /**
+    * Get the public identifier for this input source.
+    *
+    * @return The public identifier, or null if none was supplied.
+    * @see #setPublicId
+    */
+  public String getPublicId ()
+  {
+    return publicId;
+  }
+
+
+  /**
+    * Set the system identifier for this input source.
+    *
+    * &lt;p&gt;The system identifier is optional if there is a byte stream
+    * or a character stream, but it is still useful to provide one,
+    * since the application can use it to resolve relative URIs
+    * and can include it in error messages and warnings (the parser
+    * will attempt to open a connection to the URI only if
+    * there is no byte stream or character stream specified).&lt;/p&gt;
+    *
+    * &lt;p&gt;If the application knows the character encoding of the
+    * object pointed to by the system identifier, it can register
+    * the encoding using the setEncoding method.&lt;/p&gt;
+    *
+    * &lt;p&gt;If the system ID is a URL, it must be fully resolved.&lt;/p&gt;
+    *
+    * @param systemId The system identifier as a string.
+    * @see #setEncoding
+    * @see #getSystemId
+    * @see ewesoft.xml.sax.Locator#getSystemId
+    * @see ewesoft.xml.sax.SAXParseException#getSystemId
+    */
+  public void setSystemId (String systemId)
+  {
+    this.systemId = systemId;
+  }
+
+
+  /**
+    * Get the system identifier for this input source.
+    *
+    * &lt;p&gt;The getEncoding method will return the character encoding
+    * of the object pointed to, or null if unknown.&lt;/p&gt;
+    *
+    * &lt;p&gt;If the system ID is a URL, it will be fully resolved.&lt;/p&gt;
+    *
+    * @return The system identifier.
+    * @see #setSystemId
+    * @see #getEncoding
+    */
+  public String getSystemId ()
+  {
+    return systemId;
+  }
+
+
+  /**
+    * Set the byte stream for this input source.
+    *
+    * &lt;p&gt;The SAX parser will ignore this if there is also a character
+    * stream specified, but it will use a byte stream in preference
+    * to opening a URI connection itself.&lt;/p&gt;
+    *
+    * &lt;p&gt;If the application knows the character encoding of the
+    * byte stream, it should set it with the setEncoding method.&lt;/p&gt;
+    *
+    * @param byteStream A byte stream containing an XML document or
+    *        other entity.
+    * @see #setEncoding
+    * @see #getByteStream
+    * @see #getEncoding
+    * @see java.io.InputStream
+    */
+  public void setByteStream (InputStream byteStream)
+  {
+    this.byteStream = byteStream;
+  }
+
+
+  /**
+    * Get the byte stream for this input source.
+    *
+    * &lt;p&gt;The getEncoding method will return the character
+    * encoding for this byte stream, or null if unknown.&lt;/p&gt;
+    *
+    * @return The byte stream, or null if none was supplied.
+    * @see #getEncoding
+    * @see #setByteStream
+    */
+  public InputStream getByteStream ()
+  {
+    return byteStream;
+  }
+
+
+  /** 
+    * Set the character encoding, if known.
+    *
+    * &lt;p&gt;The encoding must be a string acceptable for an
+    * XML encoding declaration (see section 4.3.3 of the XML 1.0
+    * recommendation).&lt;/p&gt;
+    *
+    * &lt;p&gt;This method has no effect when the application provides a
+    * character stream.&lt;/p&gt;
+    *
+    * @param encoding A string describing the character encoding.
+    * @see #setSystemId
+    * @see #setByteStream
+    * @see #getEncoding
+    */
+  public void setEncoding (String encoding)
+  {
+    this.encoding = encoding;
+  }
+
+
+  /**
+    * Get the character encoding for a byte stream or URI.
+    *
+    * @return The encoding, or null if none was supplied.
+    * @see #setByteStream
+    * @see #getSystemId
+    * @see #getByteStream
+    */
+  public String getEncoding ()
+  {
+    return encoding;
+  }
+
+
+  /**
+    * Set the character stream for this input source.
+    *
+    * &lt;p&gt;If there is a character stream specified, the SAX parser
+    * will ignore any byte stream and will not attempt to open
+    * a URI connection to the system identifier.&lt;/p&gt;
+    *
+    * @param characterStream The character stream containing the
+    *        XML document or other entity.
+    * @see #getCharacterStream
+    * @see java.io.Reader
+    */
+  public void setCharacterStream (Reader characterStream)
+  {
+    this.characterStream = characterStream;
+  }
+
+
+  /**
+    * Get the character stream for this input source.
+    *
+    * @return The character stream, or null if none was supplied.
+    * @see #setCharacterStream
+    */
+  public Reader getCharacterStream ()
+  {
+    return characterStream;
+  }
+
+
+  //////////////////////////////////////////////////////////////////////
+  // Internal state.
+  //////////////////////////////////////////////////////////////////////
+
+  private String publicId;
+  private String systemId;
+  private InputStream byteStream;
+  private String encoding;
+  private Reader characterStream;
+
+}

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/Locator.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/Locator.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/Parser.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/Parser.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/Parser.java
===================================================================
--- experiments/EVE/lib/lib-folder/ewesoft/xml/sax/Parser.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/ewesoft/xml/sax/Parser.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,190 @@
+// SAX parser interface.
+// No warranty; no copyright -- use this as you will.
+// $Id: Parser.java,v 1.2 2004/09/13 21:00:18 damon Exp $
+
+package ewesoft.xml.sax;
+
+import java.io.IOException;
+import eve.sys.Locale;
+
+
+/**
+  * Basic interface for SAX (Simple API for XML) parsers.
+  *
+  * &lt;p&gt;All SAX parsers must implement this basic interface: it allows
+  * applications to register handlers for different types of events
+  * and to initiate a parse from a URI, or a character stream.&lt;/p&gt;
+  *
+  * &lt;p&gt;All SAX parsers must also implement a zero-argument constructor
+  * (though other constructors are also allowed).&lt;/p&gt;
+  *
+  * &lt;p&gt;SAX parsers are reusable but not re-entrant: the application
+  * may reuse a parser object (possibly with a different input source)
+  * once the first parse has completed successfully, but it may not
+  * invoke the parse() methods recursively within a parse.&lt;/p&gt;
+  *
+  * @author David Megginson (<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">ak117 at freenet.carleton.ca</A>)
+  * @version 1.0
+  * @see ewesoft.xml.sax.EntityResolver
+  * @see ewesoft.xml.sax.DTDHandler
+  * @see ewesoft.xml.sax.DocumentHandler
+  * @see ewesoft.xml.sax.ErrorHandler
+  * @see ewesoft.xml.sax.HandlerBase
+  * @see ewesoft.xml.sax.InputSource
+  */
+public interface Parser 
+{
+
+  /**
+    * Allow an application to request a locale for errors and warnings.
+    *
+    * &lt;p&gt;SAX parsers are not required to provide localisation for errors
+    * and warnings; if they cannot support the requested locale,
+    * however, they must throw a SAX exception.  Applications may
+    * not request a locale change in the middle of a parse.&lt;/p&gt;
+    *
+    * @param locale A Java Locale object.
+    * @exception ewesoft.xml.sax.SAXException Throws an exception
+    *            (using the previous or default locale) if the 
+    *            requested locale is not supported.
+    * @see ewesoft.xml.sax.SAXException
+    * @see ewesoft.xml.sax.SAXParseException
+    */
+  public abstract void setLocale (Locale locale)
+    throws SAXException;
+
+
+  /**
+    * Allow an application to register a custom entity resolver.
+    *
+    * &lt;p&gt;If the application does not register an entity resolver, the
+    * SAX parser will resolve system identifiers and open connections
+    * to entities itself (this is the default behaviour implemented in
+    * HandlerBase).&lt;/p&gt;
+    *
+    * &lt;p&gt;Applications may register a new or different entity resolver
+    * in the middle of a parse, and the SAX parser must begin using
+    * the new resolver immediately.&lt;/p&gt;
+    *
+    * @param resolver The object for resolving entities.
+    * @see EntityResolver
+    * @see HandlerBase
+    */
+  public abstract void setEntityResolver (EntityResolver resolver);
+
+
+  /**
+    * Allow an application to register a DTD event handler.
+    *
+    * &lt;p&gt;If the application does not register a DTD handler, all DTD
+    * events reported by the SAX parser will be silently
+    * ignored (this is the default behaviour implemented by
+    * HandlerBase).&lt;/p&gt;
+    *
+    * &lt;p&gt;Applications may register a new or different
+    * handler in the middle of a parse, and the SAX parser must
+    * begin using the new handler immediately.&lt;/p&gt;
+    *
+    * @param handler The DTD handler.
+    * @see DTDHandler
+    * @see HandlerBase
+    */
+  public abstract void setDTDHandler (DTDHandler handler);
+
+
+  /**
+    * Allow an application to register a document event handler.
+    *
+    * &lt;p&gt;If the application does not register a document handler, all
+    * document events reported by the SAX parser will be silently
+    * ignored (this is the default behaviour implemented by
+    * HandlerBase).&lt;/p&gt;
+    *
+    * &lt;p&gt;Applications may register a new or different handler in the
+    * middle of a parse, and the SAX parser must begin using the new
+    * handler immediately.&lt;/p&gt;
+    *
+    * @param handler The document handler.
+    * @see DocumentHandler
+    * @see HandlerBase
+    */
+  public abstract void setDocumentHandler (DocumentHandler handler);
+
+
+  /**
+    * Allow an application to register an error event handler.
+    *
+    * &lt;p&gt;If the application does not register an error event handler,
+    * all error events reported by the SAX parser will be silently
+    * ignored, except for fatalError, which will throw a SAXException
+    * (this is the default behaviour implemented by HandlerBase).&lt;/p&gt;
+    *
+    * &lt;p&gt;Applications may register a new or different handler in the
+    * middle of a parse, and the SAX parser must begin using the new
+    * handler immediately.&lt;/p&gt;
+    *
+    * @param handler The error handler.
+    * @see ErrorHandler
+    * @see SAXException
+    * @see HandlerBase
+    */
+  public abstract void setErrorHandler (ErrorHandler handler);
+
+
+  /**
+    * Parse an XML document.
+    *
+    * &lt;p&gt;The application can use this method to instruct the SAX parser
+    * to begin parsing an XML document from any valid input
+    * source (a character stream, a byte stream, or a URI).&lt;/p&gt;
+    *
+    * &lt;p&gt;Applications may not invoke this method while a parse is in
+    * progress (they should create a new Parser instead for each
+    * additional XML document).  Once a parse is complete, an
+    * application may reuse the same Parser object, possibly with a
+    * different input source.&lt;/p&gt;
+    *
+    * @param source The input source for the top-level of the
+    *        XML document.
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @exception java.io.IOException An IO exception from the parser,
+    *            possibly from a byte stream or character stream
+    *            supplied by the application.
+    * @see ewesoft.xml.sax.InputSource
+    * @see #parse(java.lang.String)
+    * @see #setEntityResolver
+    * @see #setDTDHandler
+    * @see #setDocumentHandler
+    * @see #setErrorHandler
+    */
+  public abstract void parse (InputSource source)
+    throws SAXException, IOException;
+
+
+  /**
+    * Parse an XML document from a system identifier (URI).
+    *
+    * &lt;p&gt;This method is a shortcut for the common case of reading a
+    * document from a system identifier.  It is the exact
+    * equivalent of the following:&lt;/p&gt;
+    *
+    * &lt;pre&gt;
+    * parse(new InputSource(systemId));
+    * &lt;/pre&gt;
+    *
+    * &lt;p&gt;If the system identifier is a URL, it must be fully resolved
+    * by the application before it is passed to the parser.&lt;/p&gt;
+    *
+    * @param systemId The system identifier (URI).
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @exception java.io.IOException An IO exception from the parser,
+    *            possibly from a byte stream or character stream
+    *            supplied by the application.
+    * @see #parse(ewesoft.xml.sax.InputSource)
+    */
+  public abstract void parse (String systemId)
+    throws SAXException, IOException;
+
+}

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/SAXException.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/SAXException.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/SAXException.java
===================================================================
--- experiments/EVE/lib/lib-folder/ewesoft/xml/sax/SAXException.java	2008-10-17 20:42:57 UTC (rev 1541)
+++ experiments/EVE/lib/lib-folder/ewesoft/xml/sax/SAXException.java	2008-10-17 20:45:24 UTC (rev 1542)
@@ -0,0 +1,128 @@
+// SAX exception class.
+// No warranty; no copyright -- use this as you will.
+// $Id: SAXException.java,v 1.2 2004/09/13 21:00:18 damon Exp $
+
+package ewesoft.xml.sax;
+
+/**
+  * Encapsulate a general SAX error or warning.
+  *
+  * &lt;p&gt;This class can contain basic error or warning information from
+  * either the XML parser or the application: a parser writer or
+  * application writer can subclass it to provide additional
+  * functionality.  SAX handlers may throw this exception or
+  * any exception subclassed from it.&lt;/p&gt;
+  *
+  * &lt;p&gt;If the application needs to pass through other types of
+  * exceptions, it must wrap those exceptions in a SAXException
+  * or an exception derived from a SAXException.&lt;/p&gt;
+  *
+  * &lt;p&gt;If the parser or application needs to include information about a
+  * specific location in an XML document, it should use the
+  * SAXParseException subclass.&lt;/p&gt;
+  *
+  * @author David Megginson (<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">ak117 at freenet.carleton.ca</A>)
+  * @version 1.0
+  * @see ewesoft.xml.sax.SAXParseException
+  */
+public class SAXException extends Exception {
+
+
+  /**
+    * Create a new SAXException.
+    *
+    * @param message The error or warning message.
+    * @see ewesoft.xml.sax.Parser#setLocale
+    */
+  public SAXException (String message) {
+    super();
+    this.message = message;
+    this.exception = null;
+  }
+
+
+  /**
+    * Create a new SAXException wrapping an existing exception.
+    *
+    * &lt;p&gt;The existing exception will be embedded in the new
+    * one, and its message will become the default message for
+    * the SAXException.&lt;/p&gt;
+    *
+    * @param e The exception to be wrapped in a SAXException.
+    */
+  public SAXException (Exception e)
+  {
+    super();
+    this.message = null;
+    this.exception = e;
+  }
+
+
+  /**
+    * Create a new SAXException from an existing exception.
+    *
+    * &lt;p&gt;The existing exception will be embedded in the new
+    * one, but the new exception will have its own message.&lt;/p&gt;
+    *
+    * @param message The detail message.
+    * @param e The exception to be wrapped in a SAXException.
+    * @see ewesoft.xml.sax.Parser#setLocale
+    */
+  public SAXException (String message, Exception e)
+  {
+    super();
+    this.message = message;
+    this.exception = e;
+  }
+
+
+  /**
+    * Return a detail message for this exception.
+    *
+    * &lt;p&gt;If there is a embedded exception, and if the SAXException
+    * has no detail message of its own, this method will return
+    * the detail message from the embedded exception.&lt;/p&gt;
+    *
+    * @return The error or warning message.
+    * @see ewesoft.xml.sax.Parser#setLocale
+    */
+  public String getMessage ()
+  {
+    if (message == null &amp;&amp; exception != null) {
+      return exception.getMessage();
+    } else {
+      return this.message;
+    }
+  }
+
+
+  /**
+    * Return the embedded exception, if any.
+    *
+    * @return The embedded exception, or null if there is none.
+    */
+  public Exception getException ()
+  {
+    return exception;
+  }
+
+
+  /**
+    * Convert this exception to a string.
+    *
+    * @return A string version of this exception.
+    */
+  public String toString ()
+  {
+    return getMessage();
+  }
+
+
+  //////////////////////////////////////////////////////////////////////
+  // Internal state.
+  //////////////////////////////////////////////////////////////////////
+
+  private String message;
+  private Exception exception;
+
+}

Added: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/SAXParseException.class
===================================================================
(Binary files differ)


Property changes on: experiments/EVE/lib/lib-folder/ewesoft/xml/sax/SAXParseException.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001435.html">[Cachewolf-svn] r1541 - experiments/EVE/lib/lib-folder
</A></li>
	<LI>Next message: <A HREF="001437.html">[Cachewolf-svn] r1543 - experiments/EVE/src/cachewolf/imp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1436">[ date ]</a>
              <a href="thread.html#1436">[ thread ]</a>
              <a href="subject.html#1436">[ subject ]</a>
              <a href="author.html#1436">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
