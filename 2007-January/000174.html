<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r418 - in trunk: resources src/CacheWolf
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2007-January/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r418%20-%20in%20trunk%3A%20resources%20src/CacheWolf&In-Reply-To=%3C200701202303.l0KN3Ima010123%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000173.html">
   <LINK REL="Next"  HREF="000175.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r418 - in trunk: resources src/CacheWolf</H1>
    <B>salzkammergut at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r418%20-%20in%20trunk%3A%20resources%20src/CacheWolf&In-Reply-To=%3C200701202303.l0KN3Ima010123%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r418 - in trunk: resources src/CacheWolf">salzkammergut at mail.berlios.de
       </A><BR>
    <I>Sun Jan 21 00:03:18 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000173.html">[Cachewolf-svn] [Feature #2953] Filtereinstellungen speichern
</A></li>
        <LI>Next message: <A HREF="000175.html">[Cachewolf-svn] [Feature #3065] MovingMap: Anzeige von Zoom-Modus
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#174">[ date ]</a>
              <a href="thread.html#174">[ thread ]</a>
              <a href="subject.html#174">[ subject ]</a>
              <a href="author.html#174">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: salzkammergut
Date: 2007-01-21 00:03:13 +0100 (Sun, 21 Jan 2007)
New Revision: 418

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/Parser.java
   trunk/src/CacheWolf/SolverPanel.java
Log:
Update Solver. Keine weiteren Aenderungen mehr geplant.
Neue Funktionen, Direktbefehl

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-20 21:36:52 UTC (rev 417)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-20 23:03:13 UTC (rev 418)
@@ -240,7 +240,7 @@
 		1618=Ignoriere Fehler in Cache:+
 		1619=: konnte Bild von folgender URL nicht downloaden:+
 		1620=download eingebundener Bilder:+
-		1621=Fehler beim Interpretieren\n der Update-Datei,\nDies ist vermutlich ein Fehler bei Opencaching.de\nSp&#228;ter erneut versuchen\n Status:
+		1621=Fehler beim Interpretieren\n der Update-Datei,\nDies ist vermutlich ein Fehler bei Opencaching.de\nSp%e4ter erneut versuchen\n Status:
 		1700=Fehler in Zeile: 
 		1701=Spalte: 
 		1702=Variable nicht definiert: 
@@ -249,11 +249,11 @@
 		1705=Fehlendes ENDIF
 		1706=Erwartet: 
 		1707=Gefunden: 
-		1708=Uneindeutiger Funktionsname: 
+		1708=Funktionsname nicht eindeutig: 
 		1709=Unbekannte Funktion: 
 		1710=Kann leere Zeichenkette nicht z&#228;hlen
 		1711=Ersatzzeichenketten m%fcssen gleiche L%e4nge haben
-		1712=Unzul&#228;ssige Koordinate: 
+		1712=Unzul%e4ssige Koordinate: 
 		1713=Falsches Koordinatenformat. Erlaubt sind CW/DD/DMM/DMS/UTM
 		1714=Goto: Wegpunkt existiert nicht: 
 		1715=instr: Startposition nicht in Zeichenkette
@@ -262,8 +262,6 @@
 		1718=Kann keine negative Distanz projizieren
 		1719=Winkel muss im Bereich [0;360] sein
 		1720=Kann die Wurzel einer negativen Zahl nicht berechnen
-		1721=substring: Ganzzahliger Parameter erwartet
-		1722=substring: Parameter ausserhalb des erlaubten Bereichs
 		1723=Vergleichsoperator erwartet
 		1724=Variable hat keinen Wert: 
 		1725=Unerwartete(s) Zeichen: 
@@ -272,8 +270,9 @@
 		1728=Funktion noch nicht implementiert: 
 		1729=Division durch 0
 		1730=Fehlendes &quot; am Ende der Zeichenkette
-		1731=Unerlaubtes Formatierungzeichen
-		1732=Unerlaubtes Zeichen		
+		1731=Nicht erlaubtes Formatierungzeichen
+		1732=Nicht erlaubtes Zeichen
+		1733=Befehl eingeben		
 		1800=Georeferenzierte Karten herunterladen
 		1801=Kacheln herunterladen
 		2000=GPX Export
@@ -554,8 +553,6 @@
 		1718=Cannot project a negative distance
 		1719=Projection degrees must be in interval [0;360]
 		1720=Cannot calculate square root of a negative number
-		1721=substring: Integer argument expected
-		1722=substring: Argument out of range
 		1723=Comparison operator expected
 		1724=Variable not set: 
 		1725=Unexpected character(s): 
@@ -565,7 +562,8 @@
 		1729=Division by 0
 		1730=Unterminated string
 		1731=Invalid format character
-		1732=Invalid character		
+		1732=Invalid character
+		1733=Input command		
 		1800=Download georeferenced maps
 		1801=Download tiles
 		2000=GPX Export

Modified: trunk/src/CacheWolf/Parser.java
===================================================================
--- trunk/src/CacheWolf/Parser.java	2007-01-20 21:36:52 UTC (rev 417)
+++ trunk/src/CacheWolf/Parser.java	2007-01-20 23:03:13 UTC (rev 418)
@@ -92,13 +92,18 @@
     	new fnType(&quot;acos&quot;,&quot;acos&quot;,2),
     	new fnType(&quot;asin&quot;,&quot;asin&quot;,2),
     	new fnType(&quot;atan&quot;,&quot;atan&quot;,2),
+      	new fnType(&quot;bearing&quot;,&quot;bearing&quot;,4),
+    	new fnType(&quot;center&quot;,&quot;center&quot;,3),
     	new fnType(&quot;cls&quot;,&quot;cls&quot;,1),
     	new fnType(&quot;clearscreen&quot;,&quot;cls&quot;,1),
     	new fnType(&quot;cos&quot;,&quot;cos&quot;,2),
     	new fnType(&quot;count&quot;,&quot;count&quot;,4),
+     	new fnType(&quot;cp&quot;,&quot;cp&quot;,1),
     	new fnType(&quot;crosstotal&quot;,&quot;ct&quot;,6),
     	new fnType(&quot;ct&quot;,&quot;ct&quot;,2),
-    	new fnType(&quot;encode&quot;,&quot;encode&quot;,8),
+     	new fnType(&quot;curpos&quot;,&quot;cp&quot;,1),
+     	new fnType(&quot;distance&quot;,&quot;distance&quot;,2),
+     	new fnType(&quot;encode&quot;,&quot;encode&quot;,8),
     	new fnType(&quot;format&quot;,&quot;format&quot;,6),
     	new fnType(&quot;goto&quot;,&quot;goto&quot;,6),
     	new fnType(&quot;ic&quot;,&quot;ic&quot;,3),
@@ -107,24 +112,26 @@
     	new fnType(&quot;lcase&quot;,&quot;lc&quot;,2),
     	new fnType(&quot;length&quot;,&quot;len&quot;,2),
     	new fnType(&quot;mid&quot;,&quot;mid&quot;,12),
+     	new fnType(&quot;pc&quot;,&quot;pz&quot;,3),
+     	new fnType(&quot;profilecenter&quot;,&quot;pz&quot;,3),
+     	new fnType(&quot;profilzentrum&quot;,&quot;pz&quot;,3),
     	new fnType(&quot;project&quot;,&quot;project&quot;,8),
+     	new fnType(&quot;pz&quot;,&quot;pz&quot;,3),
     	new fnType(&quot;quersumme&quot;,&quot;ct&quot;,6),
-//    	new fnType(&quot;requiresemicolon&quot;,&quot;rs&quot;,3),
     	new fnType(&quot;replace&quot;,&quot;replace&quot;,8),
     	new fnType(&quot;reverse&quot;,&quot;reverse&quot;,2),
     	new fnType(&quot;rot13&quot;,&quot;rot13&quot;,2),
-//    	new fnType(&quot;rs&quot;,&quot;rs&quot;,3),
     	new fnType(&quot;show&quot;,&quot;show&quot;,2),
     	new fnType(&quot;sin&quot;,&quot;sin&quot;,2),
     	new fnType(&quot;sqrt&quot;,&quot;sqrt&quot;,2),
-    	new fnType(&quot;substring&quot;,&quot;substring&quot;,12),
     	new fnType(&quot;sval&quot;,&quot;sval&quot;,2),
     	new fnType(&quot;tolowercase&quot;,&quot;lc&quot;,2),
     	new fnType(&quot;touppercase&quot;,&quot;uc&quot;,2),
     	new fnType(&quot;tan&quot;,&quot;tan&quot;,2),
     	new fnType(&quot;ucase&quot;,&quot;uc&quot;,2),
-    	new fnType(&quot;val&quot;,&quot;val&quot;,2)
-    	};
+    	new fnType(&quot;val&quot;,&quot;val&quot;,2),
+     	new fnType(&quot;zentrum&quot;,&quot;center&quot;,3)
+     	    	};
 	private static int scanpos = 0;
 	CWPoint cwPt=new CWPoint();
 	Vector calcStack=new Vector();
@@ -152,10 +159,27 @@
 	private void err(String str) throws Exception {
     	messageStack.add(MyLocale.getMsg(1700,&quot;Error on line: &quot;) + thisToken.line + &quot;  &quot;+MyLocale.getMsg(1701,&quot;position: &quot;) + thisToken.position);
     	messageStack.add(str);
+    	// move cursor to error location
+    	Global.mainTab.solverP.mText.setSelectionRange(thisToken.position-1,thisToken.line-1,thisToken.position+thisToken.token.length()-1,thisToken.line-1);
     	throw new Exception(&quot;Error &quot;+str);
     }
     
-    /** Clears the symbol table of all non-global symbols (those not starting with $) */
+    /** Shows global symbols */
+    private void showGlobals() throws Exception {
+    	Iterator it=symbolTable.entries();
+    	while (it.hasNext()) {
+    		String varName=((String)((ewe.util.Map.MapEntry) it.next()).getKey());
+    		if (varName.startsWith(&quot;$&quot;)) {
+    			String value=(String) getVariable(varName);
+    			if (java.lang.Double.isNaN(toNumber(value)))
+    				messageStack.add(varName+&quot; = \&quot;&quot;+STRreplace.replace(value.toString(),&quot;\&quot;&quot;,&quot;\&quot;\&quot;&quot;)+&quot;\&quot;&quot;);
+    			else
+    				messageStack.add(varName+&quot; = &quot;+value);
+    		}
+    	}
+    }
+
+	/** Clears the symbol table of all non-global symbols (those not starting with $) */
     private void clearLocalSymbols() {
     	Iterator it=symbolTable.entries();
     	while (it.hasNext()) {
@@ -179,6 +203,18 @@
     }
     
 	private Object getVariable(String varName) throws Exception {
+		if (varName.startsWith(&quot;$&quot;)) { // Potential coordinate
+			int idx=Global.getProfile().getCacheIndex(varName.substring(1));
+			if (idx!=-1) { // Found it!
+				CacheHolder ch=(CacheHolder)Global.getProfile().cacheDB.get(idx);
+				// Check whether coordinates are valid
+				cwPt.set(ch.LatLon);
+				if (cwPt.isValid() ) 
+					return ch.LatLon;
+				else
+					return &quot;&quot;; // Convert invalid coordinates (N 0 0.0 E 0 0.0) into empty string
+			}
+		}
 		Object result = symbolTable.get(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
 		if(result == null) {
 			// If it is a global variable, add it with a default value
@@ -191,17 +227,22 @@
 		return result;
 	}
 	
-	private Double getNumber(String str) throws Exception {
-		java.lang.Double ret=null;
+	private double toNumber(String str) {
 		try {
 			if (Global.getPref().digSeparator.equals(&quot;,&quot;))	str = str.replace('.', ',');
-			ret=new java.lang.Double(java.lang.Double.parseDouble(str));
+			 return java.lang.Double.parseDouble(str);
 		} catch (NumberFormatException e) {
-			err(MyLocale.getMsg(1703,&quot;Not a valid number: &quot;) + str);
+			 return java.lang.Double.NaN;
 		}
-		return ret;
 	}
 	
+	private Double getNumber(String str) throws Exception {
+		double ret=toNumber(str);
+		if (java.lang.Double.isNaN(ret))
+			err(MyLocale.getMsg(1703,&quot;Not a valid number: &quot;) + str);
+		return new java.lang.Double(ret);
+	}
+	
 	/** Get the top element of the calculation stack and try and convert it to a number if it is a string */
 	private double popCalcStackAsNumber(double defaultForEmptyString) throws Exception {
 		double num;
@@ -242,7 +283,7 @@
 		} while (thisToken.token.equals(&quot;;&quot;));	
 	}
 
-	private void skipPastEndif() throws Exception {
+	private void skipPastEndif(TokenObj ifToken) throws Exception {
 		while(scanpos &lt; tokenStack.size()){
 			thisToken = (TokenObj)tokenStack.get(scanpos);
 			scanpos++;
@@ -251,6 +292,7 @@
 				return;
 			}
 		}
+		thisToken=ifToken;
 		err(MyLocale.getMsg(1705,&quot;Missing ENDIF&quot;));
 	}
 	private TokenObj lookAheadToken() {
@@ -283,6 +325,17 @@
 //  FUNCTIONS
 ///////////////////////////////////////////
     
+	/** Get or set the current center */
+	private void funcCenter(int nargs) throws Exception {
+		if (nargs==0) {
+			calcStack.add(Global.getPref().curCentrePt.toString());
+		} else {
+	    	String coordA=popCalcStackAsString();
+			if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordA);
+			Global.getPref().curCentrePt.set(coordA);
+		}
+	}
+	
 	/** Clear Screen */
 	private void funcCls() {
 		// OutputPanel is private, so need to cast to base class
@@ -310,9 +363,13 @@
     			res+=s2.charAt(i)+&quot;=&quot;+funcCountChar(s1,s2.charAt(i))+&quot; &quot;;
     		}
     		calcStack.add(res);
-    	}
+    	} 
     }
     
+    private String funcCp(){
+    	return Global.mainTab.gotoP.gpsPosition.toString();
+    }
+    
     private double funcCrossTotal(int nargs) throws Exception {
     	int cycles=1;
 		if (nargs==2) cycles=(int)popCalcStackAsNumber(1);
@@ -331,6 +388,25 @@
     	}return a;
     }
     
+    /** Calculate distance between 2 points */
+    private double funcDistance() throws Exception {
+    	String coordB=popCalcStackAsString();
+    	String coordA=popCalcStackAsString();
+    	cwPt.set(coordA);
+		if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordA);
+		if (!isValidCoord(coordB)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordB);
+    	return cwPt.getDistance(new CWPoint(coordB));
+    }
+    
+    /** Calculate brearing from one point to the next */
+    private double funcBearing() throws Exception {
+    	String coordB=popCalcStackAsString();
+    	String coordA=popCalcStackAsString();
+    	cwPt.set(coordA);
+		if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordA);
+		if (!isValidCoord(coordB)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordB);
+    	return cwPt.getBearing(new CWPoint(coordB));
+    }
     /**
      * Encode a string by replacing all characters in a string with their corresponding characters in
      * another string
@@ -435,6 +511,17 @@
     		return s.substring((int)start-1,end);
     	}
     }
+ 
+	/** Get or set the profile center */
+	private void funcPz(int nargs) throws Exception {
+		if (nargs==0) {
+			calcStack.add(Global.getProfile().centre.toString());
+		} else {
+	    	String coordA=popCalcStackAsString();
+			if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordA);
+			Global.getProfile().centre.set(coordA);
+		}
+	}
     
     /** Project a waypoint at some angle and some distance */
     private String funcProject() throws Exception {
@@ -464,39 +551,12 @@
     	return res;
     }
     
-    /*   private void funcRequireSemicolon(int nargs) throws Exception {
-	if (nargs==0) 
-		calcStack.add(&quot;&quot;+Global.getPref().solverRequireSemicolon);
-	else {
-		Global.getPref().solverRequireSemicolon=(popCalcStackAsNumber(0)!=0)?true:false;
-	}
-}
-*/  
-    
     private double funcSqrt() throws Exception {
     	double a=popCalcStackAsNumber(0);
     	if (a&lt;0) err(MyLocale.getMsg(1720,&quot;Cannot calculate square root of a negative number&quot;));
     	return java.lang.Math.sqrt(a);
     }
     
-    /** Java-like substring */
-    private String funcSubstring(int nargs) throws Exception {
-    	if (nargs==2) {
-        	double start=popCalcStackAsNumber(0);
-    		String s=popCalcStackAsString();
-    		if (!isInteger(start)) err(MyLocale.getMsg(1721,&quot;substring: Integer argument expected&quot;));
-    		if (start&lt;0 || start&gt;s.length()) err(MyLocale.getMsg(1722,&quot;substring: Argument out of range&quot;));
-    		return s.substring((int)start);
-    	} else {
-        	double end=popCalcStackAsNumber(0);
-        	double start=popCalcStackAsNumber(0);
-    		String s=popCalcStackAsString();
-    		if (!isInteger(start) || !isInteger(end)) err(MyLocale.getMsg(1721,&quot;substring: Integer argument expected&quot;));
-    		if (start&lt;0 || start&gt;s.length() || start&gt;end || end&gt;s.length()) err(MyLocale.getMsg(1722,&quot;substring: Argument out of range&quot;));
-    		return s.substring((int)start,(int)end);
-    	}
-    }
-    
     /** Replace each character by its number A=1, B=2 etc. and put result into a string */
     private String funcSval(String s) {
        	s=s.toLowerCase();
@@ -544,7 +604,10 @@
 
 	private void parseSimpleCommand() throws Exception{
 		if (thisToken.tt==TokenObj.TT_STOP) throw new Exception(&quot;STOP&quot;);  // Terminate without error message
-		if (thisToken.tt==TokenObj.TT_VARIABLE &amp;&amp; lookAheadToken().tt==TokenObj.TT_EQ) 
+		if (thisToken.token.equals(&quot;$&quot;)) {
+			showGlobals();
+			getToken();
+		} else if (thisToken.tt==TokenObj.TT_VARIABLE &amp;&amp; lookAheadToken().tt==TokenObj.TT_EQ) 
 			parseAssign();
 		else 
 			parseStringExp();		
@@ -553,6 +616,7 @@
 	private void parseIf() throws Exception{
 		int compOp;
 		boolean compRes=false;
+		TokenObj ifToken=thisToken;
 		getToken();
 		parseStringExp();
 		compOp=thisToken.tt;
@@ -597,7 +661,7 @@
 			}
 			getToken();
 		} else // comparison failed
-			skipPastEndif();
+			skipPastEndif(ifToken);
 	}
 	
 	private void parseAssign() throws Exception  {
@@ -608,6 +672,21 @@
 		// we can fill the data progressively during a multicache
 		if (thisToken.tt==TokenObj.TT_ENDIF || thisToken.token.equals(&quot;;&quot;)) return;
 		parseStringExp();
+		if (varName.startsWith(&quot;$&quot;)) { // Potential coordinate
+			int idx=Global.getProfile().getCacheIndex(varName.substring(1));
+			if (idx!=-1) { // Yes, is a coordinate
+				CacheHolder ch=(CacheHolder)Global.getProfile().cacheDB.get(idx);
+				// Check whether new coordinates are valid
+				String coord=popCalcStackAsString();
+				cwPt.set(coord);
+				if (cwPt.isValid() || coord.equals(&quot;&quot;)) { // Can clear coord with empty string
+					ch.LatLon=cwPt.toString(CWPoint.CW);
+				    return;
+				} else
+					err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coord);
+			}
+			// Name starts with $ but is not a waypoint, fall through and set it as global variable
+		}
 		symbolTable.put(varName, popCalcStackAsString());
 	}
 	
@@ -746,10 +825,14 @@
 	 	else if (funcDef.alias.equals(&quot;abs&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.abs(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals(&quot;acos&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.acos(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals(&quot;atan&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.atan(popCalcStackAsNumber(0))));
+	    else if (funcDef.alias.equals(&quot;bearing&quot;)) calcStack.add(new java.lang.Double(funcBearing()));
+	    else if (funcDef.alias.equals(&quot;center&quot;)) funcCenter(nargs);
 	    else if (funcDef.alias.equals(&quot;cls&quot;)) funcCls();
 	    else if (funcDef.alias.equals(&quot;cos&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.cos(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals(&quot;count&quot;)) funcCount();
+	    else if (funcDef.alias.equals(&quot;cp&quot;)) funcCp();     
 	    else if (funcDef.alias.equals(&quot;ct&quot;)) calcStack.add(new java.lang.Double(funcCrossTotal(nargs)));
+	    else if (funcDef.alias.equals(&quot;distance&quot;)) calcStack.add(new java.lang.Double(funcDistance()));
 	    else if (funcDef.alias.equals(&quot;encode&quot;)) calcStack.add(funcEncode());
 	    else if (funcDef.alias.equals(&quot;format&quot;)) calcStack.add(funcFormat(nargs));
 	    else if (funcDef.alias.equals(&quot;goto&quot;)) funcGoto(nargs);
@@ -759,6 +842,7 @@
 	    else if (funcDef.alias.equals(&quot;len&quot;)) calcStack.add(new Double(popCalcStackAsString().length()));
 	    else if (funcDef.alias.equals(&quot;mid&quot;)) calcStack.add(funcMid(nargs));
 	    else if (funcDef.alias.equals(&quot;project&quot;)) calcStack.add(funcProject());     
+	    else if (funcDef.alias.equals(&quot;pz&quot;)) funcPz(nargs);     
 	    else if (funcDef.alias.equals(&quot;replace&quot;)) calcStack.add(funcReplace());
 	    else if (funcDef.alias.equals(&quot;reverse&quot;)) calcStack.add(funcReverse(popCalcStackAsString()));
 	    else if (funcDef.alias.equals(&quot;rot13&quot;)) calcStack.add(Common.rot13(popCalcStackAsString()));
@@ -766,7 +850,6 @@
 	    else if (funcDef.alias.equals(&quot;show&quot;));
 	    else if (funcDef.alias.equals(&quot;sin&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.sin(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals(&quot;sqrt&quot;)) calcStack.add(new java.lang.Double(funcSqrt())); 
-	    else if (funcDef.alias.equals(&quot;substring&quot;)) calcStack.add(funcSubstring(nargs)); 
 	    else if (funcDef.alias.equals(&quot;sval&quot;)) calcStack.add(funcSval(popCalcStackAsString()));
 	    else if (funcDef.alias.equals(&quot;tan&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.tan(popCalcStackAsNumber(0))));
 	    else if (funcDef.alias.equals(&quot;uc&quot;)) calcStack.add(popCalcStackAsString().toUpperCase());

Modified: trunk/src/CacheWolf/SolverPanel.java
===================================================================
--- trunk/src/CacheWolf/SolverPanel.java	2007-01-20 21:36:52 UTC (rev 417)
+++ trunk/src/CacheWolf/SolverPanel.java	2007-01-20 23:03:13 UTC (rev 418)
@@ -49,7 +49,16 @@
 				super.popupMenuEvent(selectedItem);
 		}
 	}
-	
+	private class InputPanel extends mTextPad {
+
+		public void  penDoubleClicked(Point where) {
+			execDirectCommand();
+		}
+	}
+	private class InpScreen extends InputBox {
+		InpScreen(String title) {super(title); }
+		String getInput() { return getInputValue();}
+	}
 	CellPanel programPanel, outputPanel;
 	
 	public SolverPanel (Preferences p, Profile prof){
@@ -61,7 +70,7 @@
 		outputPanel = split.getNextPanel();
 		split.setSplitter(PanelSplitter.AFTER|PanelSplitter.HIDDEN,PanelSplitter.BEFORE|PanelSplitter.HIDDEN,0);
 
-		programPanel.addLast(new ScrollBarPanel(mText = new mTextPad()));
+		programPanel.addLast(new ScrollBarPanel(mText = new InputPanel()));
 		programPanel.addNext(mBtSolve= new mButton(&quot;Solve!&quot;),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		programPanel.addNext(btnLoad= new mButton(&quot;Load&quot;),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
 		programPanel.addNext(btnSave= new mButton(&quot;Save&quot;),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
@@ -75,17 +84,29 @@
 		currCh=ch;
 	}
 
+	private void execDirectCommand() {
+		InpScreen boxInp=new InpScreen(MyLocale.getMsg(1733,&quot;Input command&quot;));
+		boxInp.input(parent.getFrame(),&quot;&quot;,100); //,MyLocale.getScreenWidth()*4/5);
+		String s=boxInp.getInput();
+		if (s.equals(&quot;&quot;)) return;
+		processCommand(s);
+	}
+	
+    private void processCommand(String s) {
+		msgFIFO.clear();
+		tokenizer.tokenizeSource(s, msgFIFO); // Tokenizer sets message if an error occurred
+		if (msgFIFO.size()==0) parser.parse(tokenizer.TokenStack, msgFIFO);
+		String msgStr = &quot;&quot;;
+		for(int i = 0; i &lt; msgFIFO.size(); i++){
+			msgStr = msgStr + msgFIFO.get(i) + &quot;\n&quot;;
+		}
+		mOutput.appendText(msgStr,true);
+    }
+	
 	public void onEvent(Event ev){
 		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
 			if(ev.target == mBtSolve){
-				msgFIFO.clear();
-				tokenizer.tokenizeSource(mText.getText(), msgFIFO); // Tokenizer sets message if an error occurred
-				if (msgFIFO.size()==0) parser.parse(tokenizer.TokenStack, msgFIFO);
-				String msgStr = &quot;&quot;;
-				for(int i = 0; i &lt; msgFIFO.size(); i++){
-					msgStr = msgStr + msgFIFO.get(i) + &quot;\n&quot;;
-				}
-				mOutput.appendText(msgStr,true);
+				processCommand(mText.getText());
 			}
 			if(ev.target == btnLoad){
 				FileChooser fc = new FileChooser(FileChooser.OPEN, profile.dataDir);
@@ -135,4 +156,5 @@
 			
 		}
 	}
+	
 }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000173.html">[Cachewolf-svn] [Feature #2953] Filtereinstellungen speichern
</A></li>
	<LI>Next message: <A HREF="000175.html">[Cachewolf-svn] [Feature #3065] MovingMap: Anzeige von Zoom-Modus
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#174">[ date ]</a>
              <a href="thread.html#174">[ thread ]</a>
              <a href="subject.html#174">[ subject ]</a>
              <a href="author.html#174">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
