<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r414 - in trunk: resources src/CacheWolf
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2007-January/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r414%20-%20in%20trunk%3A%20resources%20src/CacheWolf&In-Reply-To=%3C200701202115.l0KLFglE002331%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000168.html">
   <LINK REL="Next"  HREF="000170.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r414 - in trunk: resources src/CacheWolf</H1>
    <B>pfeffer at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r414%20-%20in%20trunk%3A%20resources%20src/CacheWolf&In-Reply-To=%3C200701202115.l0KLFglE002331%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r414 - in trunk: resources src/CacheWolf">pfeffer at mail.berlios.de
       </A><BR>
    <I>Sat Jan 20 22:15:42 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000168.html">[Cachewolf-svn] r413 - trunk/resources
</A></li>
        <LI>Next message: <A HREF="000170.html">[Cachewolf-svn] r415 - in trunk: resources src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#169">[ date ]</a>
              <a href="thread.html#169">[ thread ]</a>
              <a href="subject.html#169">[ subject ]</a>
              <a href="author.html#169">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: pfeffer
Date: 2007-01-20 22:15:30 +0100 (Sat, 20 Jan 2007)
New Revision: 414

Added:
   trunk/resources/lupe_activated.png
Modified:
   trunk/src/CacheWolf/GotoPanel.java
   trunk/src/CacheWolf/MovingMap.java
Log:
MovingMap: Lupe wird gr?\195?\188n, wenn man drauf klickt
MovingMap: rechts-klick bzw. lange dr?\195?\188cken ?\195?\182ffnet Kontext menue (mit bisher 1 Eintrag: gehe zu)

Added: trunk/resources/lupe_activated.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/lupe_activated.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/src/CacheWolf/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/GotoPanel.java	2007-01-20 20:44:38 UTC (rev 413)
+++ trunk/src/CacheWolf/GotoPanel.java	2007-01-20 21:15:30 UTC (rev 414)
@@ -314,6 +314,10 @@
 		toPoint.set(dest);
 		if (!toPoint.isValid()) (new MessageBox(&quot;Error&quot;, &quot;coordinates are out of range: \n&quot;+&quot;latitude: &quot;+toPoint.latDec+&quot;\n longditue: &quot;+toPoint.lonDec, MessageBox.OKB)).execute();
 		btnGoto.setText(getGotoBtnText());
+		if (mmp != null) { 
+			mmp.setGotoPosition(dest.latDec, dest.lonDec);
+			mmp.repaintNow();
+		}
 		updateDistance();
 	}
 	
@@ -609,6 +613,7 @@
 			if (ev.target == btnSave){
 				CacheHolder ch = new CacheHolder();
 				ch.LatLon = gpsPosition.toString();
+				ch.pos = new CWPoint(gpsPosition);
 				detP.newWaypoint(ch,mainT, pref, profile);
 			}
 			// change destination waypoint

Modified: trunk/src/CacheWolf/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/MovingMap.java	2007-01-20 20:44:38 UTC (rev 413)
+++ trunk/src/CacheWolf/MovingMap.java	2007-01-20 21:15:30 UTC (rev 414)
@@ -18,7 +18,7 @@
 	final static int noGPSData = 2; // red
 	final static int noGPS = 1; // no GPS-Position marker, manually disconnected 
 	final static int ignoreGPS = -1; // ignore even changes in GPS-signal (eg. from lost fix to gotFix) this is wanted when the map is moved manually
-	
+
 	public MapSymbol gotoPos = null;
 	public int GpsStatus;
 	Preferences pref;
@@ -32,7 +32,7 @@
 	Vector tracks;
 	MapInfoObject currentMap;
 	String mapPath;
-	
+
 	AniImage mapImage1to1;
 	ArrowsOnMap directionArrows = new ArrowsOnMap();
 	AniImage statusImageHaveSignal = new AniImage(&quot;position_green.png&quot;);
@@ -42,6 +42,7 @@
 	AniImage bottonImageChooseMap = new AniImage(&quot;choose_map.gif&quot;); 
 	AniImage buttonImageGpsOn = new AniImage(&quot;snap2gps.gif&quot;);
 	AniImage buttonImageLens = new AniImage(&quot;lupe.png&quot;);
+	AniImage buttonImageLensActivated = new AniImage(&quot;lupe_activated.png&quot;);
 	AniImage buttonImageZoom1to1 = new AniImage(&quot;zoom1to1.png&quot;);
 	/*AniImage arrowUp = new AniImage(&quot;arrow_up.png&quot;);
 	AniImage arrowDown = new AniImage(&quot;arrow_down.png&quot;);
@@ -95,6 +96,8 @@
 		mmp.addImage(directionArrows);
 		buttonImageLens.setLocation(Global.getPref().myAppWidth - buttonImageLens.getWidth()-10, Global.getPref().myAppHeight/2 - buttonImageLens.getHeight()/2 );
 		buttonImageLens.properties = AniImage.AlwaysOnTop;
+		buttonImageLensActivated.setLocation(Global.getPref().myAppWidth - buttonImageLens.getWidth()-10, Global.getPref().myAppHeight/2 - buttonImageLens.getHeight()/2 );
+		buttonImageLensActivated.properties = AniImage.AlwaysOnTop;
 		mmp.addImage(buttonImageLens);
 		buttonImageZoom1to1.setLocation(Global.getPref().myAppWidth - buttonImageZoom1to1.getWidth()-10, Global.getPref().myAppHeight/2 - buttonImageLens.getHeight()/2 - buttonImageZoom1to1.getHeight() -10);
 		buttonImageZoom1to1.properties = AniImage.AlwaysOnTop;
@@ -177,7 +180,7 @@
 
 	public void forceMapLoad() {
 		forceMapLoad = true;
-		updatePosition(lastUpatePosition.latDec, lastUpatePosition.lonDec);
+		updatePosition(lastUpatePosition.latDec, lastUpatePosition.lonDec); // this sets forceMapLoad to false after loading a map
 	}
 
 	public final FormFrame myExec() {
@@ -212,7 +215,7 @@
 		if (tracks == null) return; // no tracks
 		addMissingOverlays();
 	}
-	
+
 	public void destroyOverlaySet() {
 		if (TrackOverlays != null) {
 			for (int i=0; i&lt; TrackOverlays.length; i++) {	destroyOverlay(i);	}
@@ -235,7 +238,7 @@
 					TrackOverlays[i].move(0, 0);
 					TrackOverlays[i].tracks = this.tracks;
 					TrackOverlays[i].paintTracks();
-				//	mmp.addImage(TrackOverlays[i]);
+					//	mmp.addImage(TrackOverlays[i]);
 				}
 			}
 		}
@@ -374,705 +377,764 @@
 		}
 	}
 
-		public void updateOverlayPos() {
-			if (TrackOverlays == null || TrackOverlays[4] == null) return;
-			updateOverlayOnlyPos();
-			if (TrackOverlays[0].location.x&gt;pref.myAppWidth || TrackOverlays[0].location.x + 3*pref.myAppWidth &lt; 0 || // testForNeedToRearange
-					TrackOverlays[0].location.y&gt;pref.myAppHeight || TrackOverlays[0].location.y + 3*pref.myAppHeight &lt;0) {
-				rearangeOverlays();
-				addMissingOverlays();
-				// updateOverlayOnlyPos(); is called from addMissingOverlays 
-			}
+	public void updateOverlayPos() {
+		if (TrackOverlays == null || TrackOverlays[4] == null) return;
+		updateOverlayOnlyPos();
+		if (TrackOverlays[0].location.x&gt;pref.myAppWidth || TrackOverlays[0].location.x + 3*pref.myAppWidth &lt; 0 || // testForNeedToRearange
+				TrackOverlays[0].location.y&gt;pref.myAppHeight || TrackOverlays[0].location.y + 3*pref.myAppHeight &lt;0) {
+			rearangeOverlays();
+			addMissingOverlays();
+			// updateOverlayOnlyPos(); is called from addMissingOverlays 
 		}
+	}
 
-		private int getBestMap(double lat, double lon) { // finds the map which is next (center of the map) to the gps-position / could be a good idea to seachr only maps which show the current position (use InBound)
-			// maps, gotoPanel.gpsPosition.latDec != 0, gotoPanel.gpsPosition
-			MapInfoObject mi = new MapInfoObject();
-			MapInfoObject bestMap = new MapInfoObject();
-			double minDistLat = 1000000000000000000000000000000000000000000000.0;
-			double minDistLon = 1000000000000000000000000000000000000000000000.0;
-			boolean latNearer, lonNearer;
-			int minDistMap = -1;
-			boolean better = false;
-			for (int i=0; i&lt;maps.size() ;i++) {
-				better = false;
-				mi=(MapInfoObject)maps.get(i);
-				latNearer=java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm &lt; minDistLat ;
-				lonNearer=java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm &lt; minDistLon;
-				if ( latNearer &amp;&amp; lonNearer) better = true;
-				if ( !better &amp;&amp; (latNearer || lonNearer )) { 
-					if ( mi.center.getDistanceRad(lat, lon) &lt; bestMap.center.getDistanceRad(lat, lon) ) better = true;
-				}
-				if (better) {
-					minDistLat = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm;
-					minDistLon = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm;
-					minDistMap = i;
-					bestMap = mi;
-					// Vm.debug(&quot;better&quot;+ i);
-				}
+	/**
+	 * find the best map for lat/lon in the list of maps
+	 * currently the best map is the one, whose center is nearest to
+	 * lat/lon
+	 * @param lat
+	 * @param lon
+	 * @return
+	 */
+	private int getBestMap(double lat, double lon) { // finds the map which is next (center of the map) to the gps-position / could be a good idea to seachr only maps which show the current position (use InBound)
+		// maps, gotoPanel.gpsPosition.latDec != 0, gotoPanel.gpsPosition
+		MapInfoObject mi = new MapInfoObject();
+		MapInfoObject bestMap = new MapInfoObject();
+		double minDistLat = 1000000000000000000000000000000000000000000000.0;
+		double minDistLon = 1000000000000000000000000000000000000000000000.0;
+		boolean latNearer, lonNearer;
+		int minDistMap = -1;
+		boolean better = false;
+		for (int i=0; i&lt;maps.size() ;i++) {
+			better = false;
+			mi=(MapInfoObject)maps.get(i);
+			latNearer=java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm &lt; minDistLat ;
+			lonNearer=java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm &lt; minDistLon;
+			if ( latNearer &amp;&amp; lonNearer) better = true;
+			if ( !better &amp;&amp; (latNearer || lonNearer )) { 
+				if ( mi.center.getDistanceRad(lat, lon) &lt; bestMap.center.getDistanceRad(lat, lon) ) better = true;
 			}
-			//	tmp = secBestMap.center.getDistance(gotoPanel.gpsPosition.latDec, gotoPanel.gpsPosition.lonDec)/secBestMap.sizeKm; // quasi second return value 
-			return minDistMap ;
+			if (better) {
+				minDistLat = java.lang.Math.abs(lat - mi.center.latDec)/mi.sizeKm;
+				minDistLon = java.lang.Math.abs(lon - mi.center.lonDec)/mi.sizeKm;
+				minDistMap = i;
+				bestMap = mi;
+				// Vm.debug(&quot;better&quot;+ i);
+			}
 		}
+		//	tmp = secBestMap.center.getDistance(gotoPanel.gpsPosition.latDec, gotoPanel.gpsPosition.lonDec)/secBestMap.sizeKm; // quasi second return value 
+		return minDistMap ;
+	}
 
 
+	/**
+	 * move posCircle to the Center of the Screen
+	 *
+	 */
+	public void resetCenterOfMap() {
+		posCircleX = pref.myAppWidth/2; // maybe this could /should be repleced to windows size
+		posCircleY = pref.myAppHeight/2;
+		posCircle.properties &amp;= ~AniImage.IsInvisible;
+		posCircle.setLocation(posCircleX-posCircle.getWidth()/2, posCircleY-posCircle.getHeight()/2);
+	}
 
-		public void resetCenterOfMap() {
-			posCircleX = pref.myAppWidth/2; // maybe this could /should be repleced to windows size
-			posCircleY = pref.myAppHeight/2;
+	public void movePosCircleToLatLon(CWPoint p) {
+		moveScreenXYtoLatLon(new Point(posCircleX, posCircleY), p);
+	}
+
+	public void setCenterOfScreen (CWPoint c) {
+		moveScreenXYtoLatLon(new Point (this.width/2, this.height/2), c);
+	}
+
+	public void moveScreenXYtoLatLon(Point s, CWPoint c) {
+		Point mappos = getMapPositionOnScreen();
+		Point onscreenpos = getXYonScreen(c.latDec, c.lonDec);
+		if (mmp != null &amp;&amp; mmp.mapImage != null) mmp.mapImage.move(mappos.x - onscreenpos.x + s.x, mappos.y - onscreenpos.y + s.y);
+		mapMoved(s.x - onscreenpos.x, s.y - onscreenpos.y);
+
+	}
+
+	public void mapMoved(int diffX, int diffY) {
+		int w = posCircle.getWidth();
+		int h = posCircle.getHeight();
+		int npx = posCircleX-w/2+diffX; 
+		int npy = posCircleY-h/2+diffY;
+		if (npx+w &gt;= 0 &amp;&amp; npx &lt;= this.width &amp;&amp; npy+h &gt;= 0 &amp;&amp; npy &lt; this.height)	
+		{
 			posCircle.properties &amp;= ~AniImage.IsInvisible;
-			posCircle.setLocation(posCircleX-posCircle.getWidth()/2, posCircleY-posCircle.getHeight()/2);
+			posCircle.move(npx, npy);
+		} else {
+			posCircle.properties |= AniImage.IsInvisible;
+			posCircle.move(0,0);
 		}
-		
-		public void setCenterOfScreen (CWPoint c) {
-			moveScreenXYtoLatLon(new Point (this.width/2, this.height/2), c);
-		}
-		
-		public void moveScreenXYtoLatLon(Point s, CWPoint c) {
-			Point mappos = getMapPositionOnScreen();
-			Point onscreenpos = getXYonScreen(c.latDec, c.lonDec);
-			if (mmp != null &amp;&amp; mmp.mapImage != null) mmp.mapImage.move(mappos.x - onscreenpos.x + s.x, mappos.y - onscreenpos.y + s.y);
-			mapMoved(s.x - onscreenpos.x, s.y - onscreenpos.y);
-			
-		}
-		
-		public void mapMoved(int diffX, int diffY) {
-			int w = posCircle.getWidth();
-			int h = posCircle.getHeight();
-			int npx = posCircleX-w/2+diffX; 
-			int npy = posCircleY-h/2+diffY;
-			if (npx+w &gt;= 0 &amp;&amp; npx &lt;= this.width &amp;&amp; npy+h &gt;= 0 &amp;&amp; npy &lt; this.height)	
-				{
-				posCircle.properties &amp;= ~AniImage.IsInvisible;
-				posCircle.move(npx, npy);
-				} else {
-					posCircle.properties |= AniImage.IsInvisible;
-					posCircle.move(0,0);
-				}
-			posCircleX = posCircleX+diffX;
-			posCircleY = posCircleY+diffY;
-			updateSymbolPositions();
-			updateOverlayPos();
-		}
+		posCircleX = posCircleX+diffX;
+		posCircleY = posCircleY+diffY;
+		updateSymbolPositions();
+		updateOverlayPos();
+	}
 
-		/**
-		 * get upper left corner of map on window
-		 * returns the same as mmp.mapImage.getLocation(mapPos);
-		 * but also works if mmp == null and is used to move the map to the correct point
-		 * @return
-		 */
-		public Point getMapPositionOnScreen() {
-			Point mapPos = new Point(); 
-			//if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
-			//else {
-			Point mapposint = currentMap.calcMapXY(posCircleLat, posCircleLon);
-			mapPos.x = posCircleX - mapposint.x;
-			mapPos.y = posCircleY - mapposint.y;
-			//}
-			return mapPos;
-		}
+	/**
+	 * get upper left corner of map on window
+	 * this is called when the map needs to be moved / the position of the map is wanted
+	 * the map-position is calculated relativ to posCircle (x,y and lat/lon)
+	 * returns the same as mmp.mapImage.getLocation(mapPos);
+	 * but also works if mmp == null and is used to move the map to the correct point
+	 * @return
+	 */
+	public Point getMapPositionOnScreen() {
+		Point mapPos = new Point(); 
+		//if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
+		//else {
+		Point mapposint = currentMap.calcMapXY(posCircleLat, posCircleLon);
+		mapPos.x = posCircleX - mapposint.x;
+		mapPos.y = posCircleY - mapposint.y;
+		//}
+		return mapPos;
+	}
 
-		public Point getXYonScreen(double lat, double lon){
-			Point coords = currentMap.calcMapXY(lat, lon);
-			Point mapPos = getMapPositionOnScreen();
-			//		Vm.debug(&quot;getXYinMap, posCiLat: &quot;+posCircleLat+&quot;poscLOn: &quot;+ posCircleLon+&quot;gotoLat: &quot;+ lat + &quot;gotoLon: &quot;+ lon+&quot; mapPosX: &quot;+mapPos.x+&quot;mapposY&quot;+mapPos.y);
-			return new Point(coords.x + mapPos.x, coords.y + mapPos.y);
-		}
-		
-		public CWPoint ScreenXY2LatLon (int x, int y){
-			Point mapPos = getMapPositionOnScreen();
-			return currentMap.calcLatLon(x - mapPos.x, y - mapPos.y);
-		}
-		
-		public void updateSymbolPositions() {
-			if (symbols == null) return;
-			Point pOnScreen;
-			MapSymbol symb;
-			Dimension ws = mmp.getSize(null);
-			int ww = ws.width;
-			int wh = ws.height;
-			int w, h;
-			for (int i=symbols.size()-1; i&gt;=0; i--) {
-				symb = (MapSymbol)symbols.get(i);
-				pOnScreen = getXYonScreen(symb.lat, symb.lon);
-				w=symb.pic.getWidth();
-				h=symb.pic.getHeight();
-				if (pOnScreen.x+w &gt;= 0 &amp;&amp; pOnScreen.x &lt;= ww &amp;&amp; pOnScreen.y+h &gt;= 0 &amp;&amp;  pOnScreen.y &lt;= wh) 
-				{
-					symb.pic.properties &amp;= ~mImage.IsInvisible;
-					symb.pic.move(pOnScreen.x-w/2, pOnScreen.y-h/2);
-				}
-				else 
-				{symb.pic.properties |= mImage.IsInvisible;
-				symb.pic.move(30, 30);
-				}
-				//symb.pic.move(ww+1, wh+1);
+	/**
+	 * 
+	 * @param lat
+	 * @param lon
+	 * @return
+	 */
+	public Point getXYonScreen(double lat, double lon){
+		Point coords = currentMap.calcMapXY(lat, lon);
+		Point mapPos = getMapPositionOnScreen();
+		//		Vm.debug(&quot;getXYinMap, posCiLat: &quot;+posCircleLat+&quot;poscLOn: &quot;+ posCircleLon+&quot;gotoLat: &quot;+ lat + &quot;gotoLon: &quot;+ lon+&quot; mapPosX: &quot;+mapPos.x+&quot;mapposY&quot;+mapPos.y);
+		return new Point(coords.x + mapPos.x, coords.y + mapPos.y);
+	}
+
+	public CWPoint ScreenXY2LatLon (int x, int y){
+		Point mapPos = getMapPositionOnScreen();
+		return currentMap.calcLatLon(x - mapPos.x, y - mapPos.y);
+	}
+
+
+	public void updateSymbolPositions() {
+		if (symbols == null) return;
+		Point pOnScreen;
+		MapSymbol symb;
+		Dimension ws = mmp.getSize(null);
+		int ww = ws.width;
+		int wh = ws.height;
+		int w, h;
+		for (int i=symbols.size()-1; i&gt;=0; i--) {
+			symb = (MapSymbol)symbols.get(i);
+			pOnScreen = getXYonScreen(symb.lat, symb.lon);
+			w=symb.pic.getWidth();
+			h=symb.pic.getHeight();
+			if (pOnScreen.x+w &gt;= 0 &amp;&amp; pOnScreen.x &lt;= ww &amp;&amp; pOnScreen.y+h &gt;= 0 &amp;&amp;  pOnScreen.y &lt;= wh) 
+			{
+				symb.pic.properties &amp;= ~mImage.IsInvisible;
+				symb.pic.move(pOnScreen.x-w/2, pOnScreen.y-h/2);
 			}
+			else 
+			{symb.pic.properties |= mImage.IsInvisible;
+			symb.pic.move(30, 30);
+			}
+			//symb.pic.move(ww+1, wh+1);
 		}
+	}
 
-		public MapSymbol addSymbol(String name, String filename, double lat, double lon) {
-			if (symbols==null) symbols=new Vector();
-			MapSymbol ms = new MapSymbol(name, filename, lat, lon);
-			ms.loadImage();
-			Point pOnScreen=getXYonScreen(lat, lon);
-			ms.pic.setLocation(pOnScreen.x-ms.pic.getWidth()/2, pOnScreen.y-ms.pic.getHeight()/2);
-			symbols.add(ms);
-			mmp.addImage(ms.pic);
-			return ms;
-		}
-		public void addSymbol(String name, AniImage imSymb, double lat, double lon) {
-			if (symbols==null) symbols=new Vector();
-			MapSymbol ms = new MapSymbol(name, &quot; &quot;, lat, lon);
-			ms.pic = imSymb;
-			ms.pic.properties = AniImage.AlwaysOnTop;
-			Point pOnScreen=getXYonScreen(lat, lon);
-			ms.pic.setLocation(pOnScreen.x-ms.pic.getWidth()/2, pOnScreen.y-ms.pic.getHeight()/2);
-			symbols.add(ms);
-			mmp.addImage(ms.pic);
-		}
+	public MapSymbol addSymbol(String name, String filename, double lat, double lon) {
+		if (symbols==null) symbols=new Vector();
+		MapSymbol ms = new MapSymbol(name, filename, lat, lon);
+		ms.loadImage();
+		Point pOnScreen=getXYonScreen(lat, lon);
+		ms.pic.setLocation(pOnScreen.x-ms.pic.getWidth()/2, pOnScreen.y-ms.pic.getHeight()/2);
+		symbols.add(ms);
+		mmp.addImage(ms.pic);
+		return ms;
+	}
+	public void addSymbol(String name, AniImage imSymb, double lat, double lon) {
+		if (symbols==null) symbols=new Vector();
+		MapSymbol ms = new MapSymbol(name, &quot; &quot;, lat, lon);
+		ms.pic = imSymb;
+		ms.pic.properties = AniImage.AlwaysOnTop;
+		Point pOnScreen=getXYonScreen(lat, lon);
+		ms.pic.setLocation(pOnScreen.x-ms.pic.getWidth()/2, pOnScreen.y-ms.pic.getHeight()/2);
+		symbols.add(ms);
+		mmp.addImage(ms.pic);
+	}
 
-		public void setGotoPosition(double lat, double lon) {
-			removeGotoPosition();
-			gotoPos=addSymbol(&quot;goto&quot;, &quot;goto_map.png&quot;, lat, lon);
-		}
-		
-		public void removeGotoPosition() {
-			removeMapSymbol(&quot;goto&quot;);
-		}
+	public void setGotoPosition(double lat, double lon) {
+		removeGotoPosition();
+		gotoPos=addSymbol(&quot;goto&quot;, &quot;goto_map.png&quot;, lat, lon);
+	}
 
-		public CWPoint getGotoPos(){
-			if (gotoPos == null) return null;
-			return new CWPoint(gotoPos.lat, gotoPos.lon);
-		}
+	public void removeGotoPosition() {
+		removeMapSymbol(&quot;goto&quot;);
+	}
 
-		public void removeAllMapSymbolsButGoto(){
-			if (symbols == null) return;
-			symbols.removeAllElements();
-			if (gotoPos != null) symbols.add(gotoPos);
-/*			for (int i=symbols.size()-1; i&gt;=0; i--) {
+	public CWPoint getGotoPos(){
+		if (gotoPos == null) return null;
+		return new CWPoint(gotoPos.lat, gotoPos.lon);
+	}
+
+	public void removeAllMapSymbolsButGoto(){
+		if (symbols == null) return;
+		symbols.removeAllElements();
+		if (gotoPos != null) symbols.add(gotoPos);
+		/*			for (int i=symbols.size()-1; i&gt;=0; i--) {
 				if (((MapSymbol)symbols.get(i)).name != &quot;goto&quot;) removeMapSymbol(i);
 			}
-	*/	}
+		 */	}
 
-		public void removeMapSymbol(String name) {
-			int symbNr = findMapSymbol(name);
-			if (symbNr != -1) removeMapSymbol(symbNr);
-		}
+	public void removeMapSymbol(String name) {
+		int symbNr = findMapSymbol(name);
+		if (symbNr != -1) removeMapSymbol(symbNr);
+	}
 
-		public void removeMapSymbol(int SymNr) {
-			mmp.removeImage(((MapSymbol)symbols.get(SymNr)).pic);
-			symbols.removeElementAt(SymNr);
-		}
+	public void removeMapSymbol(int SymNr) {
+		mmp.removeImage(((MapSymbol)symbols.get(SymNr)).pic);
+		symbols.removeElementAt(SymNr);
+	}
 
-		public int findMapSymbol(String name) {
-			if (symbols == null) return -1;
-			MapSymbol ms;
-			for (int i = 0; i &lt; symbols.size(); i++) {
-				ms= (MapSymbol)symbols.get(i);
-				if (ms.name == name) return i;
-			}
-			return -1;
+	public int findMapSymbol(String name) {
+		if (symbols == null) return -1;
+		MapSymbol ms;
+		for (int i = 0; i &lt; symbols.size(); i++) {
+			ms= (MapSymbol)symbols.get(i);
+			if (ms.name == name) return i;
 		}
+		return -1;
+	}
 
-		/**
-		 * Move the map so that the posCircle is at lat/lon
-		 * 
-		 * @param lat &amp;&amp; lon == -361 -&gt; ignore lat/lon, set map position to upperleft corner of window 
-		 */
-		public void updateOnlyPosition(double lat, double lon, boolean updateOverlay){
-			Point mapPos = new Point(0,0);
-			Point oldMapPos = getMapPositionOnScreen();
-			if (lat != -361.0 || lon != -361.0) {
-				posCircleLat = lat;
-				posCircleLon = lon;
-				mapPos = getMapPositionOnScreen();
-			}
-			//Vm.debug(&quot;mapx = &quot; + mapx);
-			//Vm.debug(&quot;mapy = &quot; + mapy);
-			if (forceMapLoad || (java.lang.Math.abs(oldMapPos.x - mapPos.x) &gt; 1 || java.lang.Math.abs(oldMapPos.y - mapPos.y) &gt; 1)) {
-				if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x,mapPos.y);
-				updateSymbolPositions();
-				if (updateOverlay &amp;&amp; TrackOverlays != null) updateOverlayPos();
-				//}
-				mmp.repaintNow(); // TODO test if the &quot;if&quot; above can be used
-			}
-			//Vm.debug(&quot;update only position&quot;);			
+	/**
+	 * Move the map so that the posCircle is at lat/lon
+	 * 
+	 * @param lat &amp;&amp; lon == -361 -&gt; ignore lat/lon, set map position to upperleft corner of window 
+	 */
+	public void updateOnlyPosition(double lat, double lon, boolean updateOverlay){
+
+		Point mapPos = new Point(0,0);
+		Point oldMapPos = getMapPositionOnScreen();
+		if (lat != -361.0 || lon != -361.0) {
+			posCircleLat = lat;
+			posCircleLon = lon;
+			mapPos = getMapPositionOnScreen();
 		}
-		/**
-		 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
-		 */
-		public void updatePosition(double lat, double lon){
-			if (!mapsloaded) loadMaps(mapPath, lat);
-			lastUpatePosition.latDec=lat;
-			lastUpatePosition.lonDec=lon;
-			if(!ignoreGps || forceMapLoad){
-				updateOnlyPosition(lat, lon, true);
-				if (autoSelectMap || forceMapLoad) {
-					Point mapPos = getMapPositionOnScreen();
-					if (forceMapLoad || (mmp.mapImage != null &amp;&amp; ( mapPos.y &gt; 0 || mapPos.x &gt; 0 || mapPos.y+mmp.mapImage.getHeight()&lt;this.height	|| mapPos.x+mmp.mapImage.getWidth()&lt;this.width) 
-							|| 	mmp.mapImage == null )) 	{
-						//Vm.debug(&quot;Screen not completly covered by map&quot;);
-						if (forceMapLoad || (java.lang.Math.abs(lastCompareX-mapPos.x) &gt; MyLocale.getScreenWidth()/10 || java.lang.Math.abs(lastCompareY-mapPos.y) &gt; MyLocale.getScreenHeight()/10)) {
-							// more then 1/10 of screen moved since last time we tried to find a better map
-							lastCompareX = mapPos.x;
-							lastCompareY = mapPos.y;
-//							Vm.debug(&quot;look for a bettermap&quot;);
-							int newMapN=getBestMap(lat, lon); // this is independet of the Position of the PosCircle on the windows -&gt; may be it would be better to call it with the coos of the center of the window?, nein, es k&#246;nnte st&#246;ren, wenn man manuell die Karte bewegt und er st&#228;ndig ne neue l&#228;d... bleibt erstmal so
-							MapInfoObject newmap ;
-							newmap = (MapInfoObject) maps.get(newMapN);
-							if (!(currentMap.mapName == newmap.mapName)) {
-								setMap(newmap, lat, lon);
-								Vm.debug(&quot;better map found&quot;);
-								// use new map
-							}
-							forceMapLoad = false;
+		//Vm.debug(&quot;mapx = &quot; + mapx);
+		//Vm.debug(&quot;mapy = &quot; + mapy);
+		if (forceMapLoad || (java.lang.Math.abs(oldMapPos.x - mapPos.x) &gt; 1 || java.lang.Math.abs(oldMapPos.y - mapPos.y) &gt; 1)) {
+			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x,mapPos.y);
+			updateSymbolPositions();
+			if (updateOverlay &amp;&amp; TrackOverlays != null) updateOverlayPos();
+			//}
+			mmp.repaintNow(); // TODO test if the &quot;if&quot; above can be used
+		}
+		//Vm.debug(&quot;update only position&quot;);			
+	}
+	/**
+	 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
+	 */
+	public void updatePosition(double lat, double lon){
+		if (!mapsloaded) loadMaps(mapPath, lat);
+		lastUpatePosition.latDec=lat;
+		lastUpatePosition.lonDec=lon;
+		if(!ignoreGps || forceMapLoad){
+			updateOnlyPosition(lat, lon, true);
+			if (autoSelectMap || forceMapLoad) {
+				Point mapPos = getMapPositionOnScreen();
+				if (forceMapLoad || (mmp.mapImage != null &amp;&amp; ( mapPos.y &gt; 0 || mapPos.x &gt; 0 || mapPos.y+mmp.mapImage.getHeight()&lt;this.height	|| mapPos.x+mmp.mapImage.getWidth()&lt;this.width) 
+						|| 	mmp.mapImage == null )) 	{
+					//Vm.debug(&quot;Screen not completly covered by map&quot;);
+					if (forceMapLoad || (java.lang.Math.abs(lastCompareX-mapPos.x) &gt; MyLocale.getScreenWidth()/10 || java.lang.Math.abs(lastCompareY-mapPos.y) &gt; MyLocale.getScreenHeight()/10)) {
+						// more then 1/10 of screen moved since last time we tried to find a better map
+						lastCompareX = mapPos.x;
+						lastCompareY = mapPos.y;
+//						Vm.debug(&quot;look for a bettermap&quot;);
+						int newMapN=getBestMap(lat, lon); // this is independet of the Position of the PosCircle on the windows -&gt; may be it would be better to call it with the coos of the center of the window?, nein, es k&#246;nnte st&#246;ren, wenn man manuell die Karte bewegt und er st&#228;ndig ne neue l&#228;d... bleibt erstmal so
+						MapInfoObject newmap ;
+						newmap = (MapInfoObject) maps.get(newMapN);
+						if (!(currentMap.mapName == newmap.mapName)) {
+							setMap(newmap, lat, lon);
+							Vm.debug(&quot;better map found&quot;);
+							// use new map
 						}
+						forceMapLoad = false;
 					}
 				}
 			}
 		}
+	}
 
-		public void setGpsStatus (int status) {
-			if ((status == GpsStatus) || ignoreGpsStatutsChanges) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
-			GpsStatus = status;
-			ignoreGps = false;
-			switch (status) {
-			case noGPS: 	{ posCircle.change(null); ignoreGps = true; break; }
-			case gotFix:    { posCircle.change(statusImageHaveSignal); break; }
-			case lostFix:   { posCircle.change(statusImageNoSignal); break; }
-			case noGPSData: { posCircle.change(statusImageNoGps); break; }
-			}
-			posCircle.refreshNow();
+	public void setGpsStatus (int status) {
+		if ((status == GpsStatus) || ignoreGpsStatutsChanges) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
+		GpsStatus = status;
+		ignoreGps = false;
+		switch (status) {
+		case noGPS: 	{ posCircle.change(null); ignoreGps = true; break; }
+		case gotFix:    { posCircle.change(statusImageHaveSignal); break; }
+		case lostFix:   { posCircle.change(statusImageNoSignal); break; }
+		case noGPSData: { posCircle.change(statusImageNoGps); break; }
 		}
+		posCircle.refreshNow();
+	}
 
-		public void SnapToGps() {
-			resetCenterOfMap();
-			ignoreGps = false;
-			ignoreGpsStatutsChanges = false;
+	public void SnapToGps() {
+		resetCenterOfMap();
+		ignoreGps = false;
+		ignoreGpsStatutsChanges = false;
+		lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
+		lastCompareY = Integer.MAX_VALUE;
+		autoSelectMap = true;
+		forceMapLoad = true;
+		showMap();
+//		updatePosition(gotoPanel.gpsPosition.latDec, gotoPanel.gpsPosition.latDec); is called from GotoPanel.ticked
+	}
+
+	/** sets and displays the map
+	 * 
+	 * @param newmap
+	 * @param lat move map so that lat/lon is in the center / -361: don't adust to lat/lon
+	 * @param lon -361: don't adust to lat/lon
+	 */
+	public void setMap(MapInfoObject newmap, double lat, double lon) {
+		if (newmap.mapName == currentMap.mapName &amp;&amp; !forceMapLoad) {
+			updateOnlyPosition(lat, lon, true); 
+			return;
+		}
+		Vm.showWait(true);
+		boolean saveIgnoreStatus;
+		saveIgnoreStatus = ignoreGps;
+		ignoreGps = true;  // make updatePosition ignore calls during loading new map
+		InfoBox inf;
+		inf = new InfoBox(&quot;Info&quot;, &quot;Loading map...&quot;);
+		inf.show();
+		try {
+			this.currentMap = newmap; 
+			this.title = currentMap.mapName;
 			lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
 			lastCompareY = Integer.MAX_VALUE;
-			autoSelectMap = true;
-			forceMapLoad = true;
-			showMap();
-//			updatePosition(gotoPanel.gpsPosition.latDec, gotoPanel.gpsPosition.latDec); is called from GotoPanel.ticked
-		}
+			if (! (mmp.mapImage == null) ) {
+				//Vm.debug(&quot;free: &quot;+Vm.getUsedMemory(false)+&quot;classMemory: &quot;+Vm.getClassMemory()+ &quot;after garbage collection: &quot;+Vm.getUsedMemory(false));
+				mmp.removeImage(mmp.mapImage); mmp.mapImage.free(); mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
 
-		/** sets and displays the map
-		 * 
-		 * @param newmap
-		 * @param lat move map so that lat/lon is in the center / -361: don't adust to lat/lon
-		 * @param lon -361: don't adust to lat/lon
-		 */
-		public void setMap(MapInfoObject newmap, double lat, double lon) {
-			if (newmap.mapName == currentMap.mapName) {
-				updateOnlyPosition(lat, lon, true); 
-				return;
+				//Vm.debug(&quot;free: &quot;+Vm.getUsedMemory(false)+&quot;classMemory: &quot;+Vm.getClassMemory()+ &quot;after garbage collection: &quot;+Vm.getUsedMemory(false));
+				Vm.getUsedMemory(true); // calls the garbage collection
+			} // give memory free before loading the new map to avoid out of memory error
+			if (currentMap.getImageFilename() == null ) {
+				mmp.mapImage = new AniImage();
+				(new MessageBox(&quot;Error&quot;, &quot;Could not find image associated with: \n&quot;+currentMap.fileNameWFL, MessageBox.OKB)).execute();
 			}
-			Vm.showWait(true);
-			boolean saveIgnoreStatus;
-			saveIgnoreStatus = ignoreGps;
-			ignoreGps = true;  // make updatePosition ignore calls during loading new map
-			InfoBox inf;
-			inf = new InfoBox(&quot;Info&quot;, &quot;Loading map...&quot;);
-			inf.show();
-			try {
-				this.currentMap = newmap; 
-				this.title = currentMap.mapName;
-//				transXlat
+			else { 
+				if (currentMap.getImageFilename().length()&gt;0) mmp.mapImage = new AniImage(currentMap.getImageFilename()); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
+				else mmp.mapImage = new AniImage();
+			}
+			mapImage1to1 = mmp.mapImage;
+			mmp.mapImage.properties = mmp.mapImage.properties | AniImage.IsMoveable;
+			if (mapHidden) mmp.mapImage.properties |= AniImage.IsInvisible;
+			mmp.mapImage.move(0,0);
+			mmp.addImage(mmp.mapImage);
+			mmp.images.moveToBack(mmp.mapImage);
+			addOverlaySet();
+			forceMapLoad = true; // forces updateOnlyPosition to redraw
+			updateOnlyPosition(lat, lon, false);
+			forceMapLoad = false;
+			directionArrows.setMap(currentMap);
+			inf.close(0);  // this doesn't work in a ticked-thread in the ewe-vm. That's why i made a new mThread in gotoPanel for ticked
+			Vm.showWait(false);
+			ignoreGps = saveIgnoreStatus;
+		} catch (IllegalArgumentException e) { // thrown by new AniImage() in ewe-vm if file not found;
+			if (mmp.mapImage != null) {
+				mmp.removeImage(mmp.mapImage); 
+				mmp.mapImage.free();
+				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+			}
+			addOverlaySet();
+			updateOnlyPosition(lat, lon, false);
+			inf.close(0);
+			Vm.showWait(false);
+			(new MessageBox(&quot;Error&quot;, &quot;Could not load map: &quot;+ newmap.getImageFilename(), MessageBox.OKB)).execute();
+			ignoreGps = saveIgnoreStatus;
+		} catch (OutOfMemoryError e) {
+			if (mmp.mapImage != null) {
+				mmp.removeImage(mmp.mapImage); 
+				mmp.mapImage.free();
+				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+			}
+			addOverlaySet();
+			updateOnlyPosition(lat, lon, false);
+			inf.close(0);
+			Vm.showWait(false);
+			(new MessageBox(&quot;Error&quot;, &quot;Not enough memory to load map: &quot;+ newmap.getImageFilename()+&quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;, MessageBox.OKB)).execute();
+			ignoreGps = saveIgnoreStatus;
+		}catch (SystemResourceException e) {
+			if (mmp.mapImage != null) {
+				mmp.removeImage(mmp.mapImage); 
+				mmp.mapImage.free();
+				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+			}
+			addOverlaySet();
+			updateOnlyPosition(lat, lon, false);
+			inf.close(0);
+			Vm.showWait(false);
+			(new MessageBox(&quot;Error&quot;, &quot;Not enough ressources to load map: &quot;+ newmap.getImageFilename()+&quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;, MessageBox.OKB)).execute();
+			ignoreGps = saveIgnoreStatus;
+		}
+	}
 
-				lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
-				lastCompareY = Integer.MAX_VALUE;
-				if (! (mmp.mapImage == null) ) {
-					//Vm.debug(&quot;free: &quot;+Vm.getUsedMemory(false)+&quot;classMemory: &quot;+Vm.getClassMemory()+ &quot;after garbage collection: &quot;+Vm.getUsedMemory(false));
-					mmp.removeImage(mmp.mapImage); mmp.mapImage.free(); mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
+	public void hideMap() {
+		if (mmp != null &amp;&amp; mmp.mapImage != null)
+			mmp.mapImage.properties |= AniImage.IsInvisible;
+		mapHidden = true;
+		repaintNow();
+	}
 
-					//Vm.debug(&quot;free: &quot;+Vm.getUsedMemory(false)+&quot;classMemory: &quot;+Vm.getClassMemory()+ &quot;after garbage collection: &quot;+Vm.getUsedMemory(false));
-					Vm.getUsedMemory(true); // calls the garbage collection
-				} // give memory free before loading the new map to avoid out of memory error
-				if (currentMap.getImageFilename() == null ) {
-					mmp.mapImage = new AniImage();
-					(new MessageBox(&quot;Error&quot;, &quot;Could not find image associated with: \n&quot;+currentMap.fileNameWFL, MessageBox.OKB)).execute();
-				}
-				else { 
-					if (currentMap.getImageFilename().length()&gt;0) mmp.mapImage = new AniImage(currentMap.getImageFilename()); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
-					else mmp.mapImage = new AniImage();
-				}
-				mapImage1to1 = mmp.mapImage;
-				mmp.mapImage.properties = mmp.mapImage.properties | AniImage.IsMoveable;
-				if (mapHidden) mmp.mapImage.properties |= AniImage.IsInvisible;
-				mmp.mapImage.move(0,0);
-				mmp.addImage(mmp.mapImage);
-				mmp.images.moveToBack(mmp.mapImage);
-				addOverlaySet();
-				forceMapLoad = true; // forces updateOnlyPosition to redraw
-				updateOnlyPosition(lat, lon, false);
-				forceMapLoad = false;
-				directionArrows.setMap(currentMap);
-				inf.close(0);  // this doesn't work in a ticked-thread in the ewe-vm. That's why i made a new mThread in gotoPanel for ticked
-				Vm.showWait(false);
-				ignoreGps = saveIgnoreStatus;
-			} catch (IllegalArgumentException e) { // thrown by new AniImage() in ewe-vm if file not found;
-				if (mmp.mapImage != null) {
-					mmp.removeImage(mmp.mapImage); 
-					mmp.mapImage.free();
-					mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
-				}
-				addOverlaySet();
-				updateOnlyPosition(lat, lon, false);
-				inf.close(0);
-				Vm.showWait(false);
-				(new MessageBox(&quot;Error&quot;, &quot;Could not load map: &quot;+ newmap.getImageFilename(), MessageBox.OKB)).execute();
-				ignoreGps = saveIgnoreStatus;
-			} catch (OutOfMemoryError e) {
-				if (mmp.mapImage != null) {
-					mmp.removeImage(mmp.mapImage); 
-					mmp.mapImage.free();
-					mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
-				}
-				addOverlaySet();
-				updateOnlyPosition(lat, lon, false);
-				inf.close(0);
-				Vm.showWait(false);
-				(new MessageBox(&quot;Error&quot;, &quot;Not enough memory to load map: &quot;+ newmap.getImageFilename()+&quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;, MessageBox.OKB)).execute();
-				ignoreGps = saveIgnoreStatus;
-			}catch (SystemResourceException e) {
-				if (mmp.mapImage != null) {
-					mmp.removeImage(mmp.mapImage); 
-					mmp.mapImage.free();
-					mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
-				}
-				addOverlaySet();
-				updateOnlyPosition(lat, lon, false);
-				inf.close(0);
-				Vm.showWait(false);
-				(new MessageBox(&quot;Error&quot;, &quot;Not enough ressources to load map: &quot;+ newmap.getImageFilename()+&quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;, MessageBox.OKB)).execute();
-				ignoreGps = saveIgnoreStatus;
-			}
+	public void showMap() {
+		if (mmp != null &amp;&amp; mmp.mapImage != null)
+			mmp.mapImage.properties &amp;= ~AniImage.IsInvisible;
+		mapHidden = false;
+		repaintNow();
+	}
+
+	public void setZoomingMode() {
+		mmp.removeImage(buttonImageLens);
+		mmp.addImage(buttonImageLensActivated);
+		repaintNow();
+		zoomingMode = true;
+	}
+
+	/**
+	 * zommes in if w&gt;0 and out if w&lt;0
+	 * @param firstclickpoint
+	 * @param w
+	 * @param h
+	 */
+	public void zoomScreenRect(Point firstclickpoint, int w, int h) {
+		int newImageWidth = (int) (this.width *  (this.width  &lt; 481 ? 2 : 1.6)); // (maximal) size of the zoomed image 
+		int newImageHeight= (int) (this.height * (this.width &lt; 481 ?  2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors 
+		CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y + h/2);
+		float zoomFactor;
+		if (w &gt; 0)  zoomFactor = (float)this.width / (float)w; // zoom in
+		else {
+			w = java.lang.Math.abs(w);
+			firstclickpoint.x = firstclickpoint.x - w; // make firstclickedpoint the upper left corner
+			zoomFactor = (float)w / (float)this.width;
 		}
-		
-		public void hideMap() {
-			if (mmp != null &amp;&amp; mmp.mapImage != null)
-				mmp.mapImage.properties |= AniImage.IsInvisible;
-			mapHidden = true;
-			repaintNow();
+		if (h &lt; 0) {
+			h = java.lang.Math.abs(h);
+			firstclickpoint.y = firstclickpoint.y - h;
 		}
-		
-		public void showMap() {
-			if (mmp != null &amp;&amp; mmp.mapImage != null)
-				mmp.mapImage.properties &amp;= ~AniImage.IsInvisible;
-			mapHidden = false;
-			repaintNow();
+		// calculate rect in unzoomed image in a way that the center of the new image is the center of selected area but give priority to the prefered image size of the scaled image
+		newImageHeight = (int) (newImageHeight / zoomFactor / currentMap.zoomFactor);
+		newImageWidth = (int) (newImageWidth / zoomFactor / currentMap.zoomFactor);
+		Point mappos = getMapPositionOnScreen();
+		int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w/2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth /2);
+		int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h/2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight /2);
+		Rect newImageRect = new Rect(xinunscaledimage , yinunscaledimage, newImageWidth, newImageHeight);
+		if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.image != null)
+		{
+			// try to avoid overlapping by shifting
+			if (newImageRect.x &lt; 0) 
+				newImageRect.x = 0; // align left if left overlapping
+			if (newImageRect.y &lt; 0) 
+				newImageRect.y = 0;
+			if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth()) 
+				newImageRect.x = mapImage1to1.getWidth()- newImageWidth; // align right if right overlaping
+			if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight()) 
+				newImageRect.y = mapImage1to1.getHeight()- newImageHeight;
+			// crop if after shifting still overlapping
+			if (newImageRect.x &lt; 0) 
+				newImageRect.x = 0;
+			if (newImageRect.y &lt; 0) 
+				newImageRect.y = 0;
+			if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth()) 
+				newImageRect.width = mapImage1to1.getWidth() - newImageRect.x;
+			if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight()) 
+				newImageRect.height= mapImage1to1.getHeight()- newImageRect.y;
 		}
-		
-		public void setZoomingMode() {
-			zoomingMode = true;
-		}
-		
-		/**
-		 * zommes in if w&gt;0 and out if w&lt;0
-		 * @param firstclickpoint
-		 * @param w
-		 * @param h
-		 */
-		public void zoomScreenRect(Point firstclickpoint, int w, int h) {
-			int newImageWidth = (int) (this.width *  (this.width  &lt; 481 ? 2 : 1.6)); // (maximal) size of the zoomed image 
-			int newImageHeight= (int) (this.height * (this.width &lt; 481 ?  2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors 
-			CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y + h/2);
-			float zoomFactor;
-			if (w &gt; 0)  zoomFactor = (float)this.width / (float)w; // zoom in
-			else {
-				w = java.lang.Math.abs(w);
-				firstclickpoint.x = firstclickpoint.x - w; // make firstclickedpoint the upper left corner
-				zoomFactor = (float)w / (float)this.width;
+		zoomFromUnscaled(zoomFactor * currentMap.zoomFactor, newImageRect, center);
+	}
+
+	public void zoom1to1() {
+		CWPoint center = ScreenXY2LatLon(this.width /2 , this.height/2);
+		zoomFromUnscaled(1, new Rect(0,0,mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
+	}
+
+	/**
+	 * do the actual scaling
+	 * @param zoomFactor relative to original image
+	 * @param newImageRect Rect in the 1:1 image that contains the area to be zoomed into
+	 * @param center
+	 */		
+	public void zoomFromUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
+		Vm.showWait(true);
+		boolean savegpsstatus = ignoreGps;
+		if (mapImage1to1 != null) {
+			ignoreGps = true; // avoid multi-thread problems
+			int saveprop = AniImage.IsMoveable;
+			AniImage tmp = null; // = mmp.mapImage;
+			if (mmp.mapImage != null) {
+				saveprop = mmp.mapImage.properties;
+				mmp.removeImage(mmp.mapImage);
+				if (mmp.mapImage != mapImage1to1) {
+					mmp.mapImage .free();
+					mmp.mapImage = null;
+				} else tmp = mapImage1to1;
 			}
-			if (h &lt; 0) {
-				h = java.lang.Math.abs(h);
-				firstclickpoint.y = firstclickpoint.y - h;
-			}
-			// calculate rect in unzoomed image in a way that the center of the new image is the center of selected area but give priority to the prefered image size of the scaled image
-			newImageHeight = (int) (newImageHeight / zoomFactor / currentMap.zoomFactor);
-			newImageWidth = (int) (newImageWidth / zoomFactor / currentMap.zoomFactor);
-			Point mappos = getMapPositionOnScreen();
-			int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w/2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth /2);
-			int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h/2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight /2);
-			Rect newImageRect = new Rect(xinunscaledimage , yinunscaledimage, newImageWidth, newImageHeight);
+			Vm.getUsedMemory(true);
+			try {
+				tmp = new AniImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor), (int)(newImageRect.height*zoomFactor), newImageRect, 0));
+				currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
+			} catch (OutOfMemoryError e) {
+				(new MessageBox(&quot;Error&quot;, &quot;Out of memory error&quot;, MessageBox.OKB)).execute();}
+			Vm.getUsedMemory(true);
+			mmp.mapImage = tmp; // use unscaled or no image in case of OutOfMemoryError
+			mmp.mapImage.properties = saveprop;
+			mmp.addImage(mmp.mapImage);
+			mmp.images.moveToBack(mmp.mapImage);
 			if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.image != null)
 			{
-				// try to avoid overlapping by shifting
-				if (newImageRect.x &lt; 0) 
-					newImageRect.x = 0; // align left if left overlapping
-				if (newImageRect.y &lt; 0) 
-					newImageRect.y = 0;
-				if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth()) 
-					newImageRect.x = mapImage1to1.getWidth()- newImageWidth; // align right if right overlaping
-				if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight()) 
-					newImageRect.y = mapImage1to1.getHeight()- newImageHeight;
-				// crop if after shifting still overlapping
-				if (newImageRect.x &lt; 0) 
-					newImageRect.x = 0;
-				if (newImageRect.y &lt; 0) 
-					newImageRect.y = 0;
-				if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth()) 
-					newImageRect.width = mapImage1to1.getWidth() - newImageRect.x;
-				if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight()) 
-					newImageRect.height= mapImage1to1.getHeight()- newImageRect.y;
+				Point mappos = getMapPositionOnScreen();
+				mmp.mapImage.move(mappos.x,mappos.y);
 			}
-			zoomFromUnscaled(zoomFactor * currentMap.zoomFactor, newImageRect, center);
+		} else // no map image loaded 
+		{ currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y); }
+
+		destroyOverlaySet();
+		Vm.getUsedMemory(true); // call garbage collection
+		setCenterOfScreen(center);
+		addOverlaySet();
+		this.repaintNow();
+		Vm.showWait(false);
+		ignoreGps = savegpsstatus;
+	}
+
+
+	public void onEvent(Event ev){
+		if(ev instanceof FormEvent &amp;&amp; (ev.type == FormEvent.CLOSED )){
+			gotoPanel.runMovingMap = false;
+		}  
+		if(ev instanceof KeyEvent &amp;&amp; ev.target == this &amp;&amp; ((KeyEvent)ev).key == IKeys.ESCAPE) {
+			this.close(0);
+			ev.consumed = true;
 		}
+		super.onEvent(ev);
+	}
+}
 
-		public void zoom1to1() {
-			CWPoint center = ScreenXY2LatLon(this.width /2 , this.height/2);
-			zoomFromUnscaled(1, new Rect(0,0,mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
-		}
-		
 /**
- * do the actual scaling
- * @param zoomFactor relative to original image
- * @param newImageRect Rect in the 1:1 image that contains the area to be zoomed into
- * @param center
- */		
-		public void zoomFromUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
-			Vm.showWait(true);
-			boolean savegpsstatus = ignoreGps;
-			if (mapImage1to1 != null) {
-				ignoreGps = true; // avoid multi-thread problems
-				int saveprop = AniImage.IsMoveable;
-				AniImage tmp = null; // = mmp.mapImage;
-				if (mmp.mapImage != null) {
-					saveprop = mmp.mapImage.properties;
-					mmp.removeImage(mmp.mapImage);
-					if (mmp.mapImage != mapImage1to1) {
-						mmp.mapImage .free();
-						mmp.mapImage = null;
-					} else tmp = mapImage1to1;
-				}
-				Vm.getUsedMemory(true);
-				try {
-					tmp = new AniImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor), (int)(newImageRect.height*zoomFactor), newImageRect, 0));
-					currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
-				} catch (OutOfMemoryError e) {
-					(new MessageBox(&quot;Error&quot;, &quot;Out of memory error&quot;, MessageBox.OKB)).execute();}
-				Vm.getUsedMemory(true);
-				mmp.mapImage = tmp; // use unscaled or no image in case of OutOfMemoryError
-				mmp.mapImage.properties = saveprop;
-				mmp.addImage(mmp.mapImage);
-				mmp.images.moveToBack(mmp.mapImage);
-				if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.image != null)
-				{
-					Point mappos = getMapPositionOnScreen();
-					mmp.mapImage.move(mappos.x,mappos.y);
-				}
-			} else // no map image loaded 
-				{ currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y); }
+ *	Class to display the map bitmap and to select another bitmap to display.
+ */
+class MovingMapPanel extends InteractivePanel implements EventListener {
+	Menu mapsMenu;
+	Menu kontextMenu;
+	MenuItem gotoMenuItem;
+	MovingMap mm;
+	AniImage mapImage;
+	Point saveMapLoc = null;
+	boolean saveGpsIgnoreStatus;
+	boolean paintingZoomArea;
+	ImageList saveImageList = null;
+	int lastZoomWidth , lastZoomHeight;
+	public MovingMapPanel(MovingMap f){
+		this.mm = f;
+		set(Control.WantHoldDown, true); // want to get simulated right-clicks
+		gotoMenuItem = new MenuItem(&quot;Goto here&quot;, 0, null);
 
-			destroyOverlaySet();
-			Vm.getUsedMemory(true);
-			setCenterOfScreen(center);
-			addOverlaySet();
-			this.repaintNow();
-			Vm.showWait(false);
-			ignoreGps = savegpsstatus;
-		}
+	}
 
-
-		public void onEvent(Event ev){
-			if(ev instanceof FormEvent &amp;&amp; (ev.type == FormEvent.CLOSED )){
-				gotoPanel.runMovingMap = false;
-			}
-			super.onEvent(ev);
+	public boolean imageBeginDragged(AniImage which,Point pos) {
+		if (mm.zoomingMode == true) {
+			saveMapLoc = pos;
+			mm.ignoreGps = true;
+			return false;
 		}
+		if (!(which == null || which == mapImage || which instanceof TrackOverlay) ) return false;
+		saveGpsIgnoreStatus = mm.ignoreGps; 
+		mm.ignoreGps = true;
+		saveMapLoc = pos;
+		bringMapToTop();
+		return super.imageBeginDragged(mapImage, pos);
 	}
 
-	/**
-	 *	Class to display the map bitmap and to select another bitmap to display.
-	 */
-	class MovingMapPanel extends InteractivePanel implements EventListener {
-		Menu mapsMenu;
-		MovingMap mm;
-		AniImage mapImage;
-		Point saveMapLoc = null;
-		boolean saveGpsIgnoreStatus;
-		boolean paintingZoomArea;
-		ImageList saveImageList = null;
-		int lastZoomWidth , lastZoomHeight;
-		public MovingMapPanel(MovingMap f){
-			this.mm = f;
+	public boolean imageNotDragged(ImageDragContext dc,Point pos){
+		boolean ret = super.imageNotDragged(dc, pos);
+		mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
+		mm.ignoreGps = saveGpsIgnoreStatus;
+		bringMaptoBack();
+		this.repaintNow();
+		return ret;
+	}
+
+	public void onPenEvent(PenEvent ev) {
+		if (!mm.zoomingMode &amp;&amp; ev.type == PenEvent.PEN_DOWN) {
+			saveMapLoc = new Point (ev.x, ev.y);
 		}
-		public boolean imageBeginDragged(AniImage which,Point pos) {
-			if (mm.zoomingMode == true) {
-				saveMapLoc = pos;
-				mm.ignoreGps = true;
-				return false;
-			}
-			if (!(which == null || which == mapImage || which instanceof TrackOverlay) ) return false;
-			saveGpsIgnoreStatus = mm.ignoreGps; 
-			mm.ignoreGps = true;
-			saveMapLoc = pos;
-			bringMapToTop();
-			return super.imageBeginDragged(mapImage, pos);
+		if (mm.zoomingMode &amp;&amp; ev.type == PenEvent.PEN_DOWN) {
+			saveMapLoc = new Point (ev.x, ev.y);
+			paintingZoomArea = true;
+			mm.zoomingMode = true;
 		}
-		
-		public boolean imageNotDragged(ImageDragContext dc,Point pos){
-			boolean ret = super.imageNotDragged(dc, pos);
-			mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
-			mm.ignoreGps = saveGpsIgnoreStatus;
-			bringMaptoBack();
-			this.repaintNow();
-			return ret;
+		if (!mm.zoomingMode &amp;&amp; ev.type == PenEvent.PEN_DOWN &amp;&amp; ev.modifiers == PenEvent.RIGHT_BUTTON) {
+			penHeld(new Point (ev.x, ev.y));
 		}
-		
-		public void onPenEvent(PenEvent ev) {
-			if (mm.zoomingMode &amp;&amp; ev.type == PenEvent.PEN_DOWN) {
-				saveMapLoc = new Point (ev.x, ev.y);
-				paintingZoomArea = true;
-				mm.zoomingMode = true;
+		if (mm.zoomingMode &amp;&amp; ev.type == PenEvent.PEN_UP ) {
+			paintingZoomArea = false;
+			mm.zoomingMode = false;
+			removeImage(mm.buttonImageLensActivated);
+			addImage(mm.buttonImageLens);
+			if (java.lang.Math.abs(lastZoomWidth) &lt; 15 || java.lang.Math.abs(lastZoomHeight) &lt; 15)  {
+				repaintNow();
+				return; // dont make to big zoom jumps - it is most probable not an intentional zoom
 			}
-			if (mm.zoomingMode &amp;&amp; ev.type == PenEvent.PEN_UP ) {
-				paintingZoomArea = false;
-				mm.zoomingMode = false;
-				if (java.lang.Math.abs(lastZoomWidth) &lt; 15 || java.lang.Math.abs(lastZoomHeight) &lt; 15)  {
-					repaintNow();
-					return; // dont make to big zoom jumps - it is most probable not an intentional zoom
-				}
-				mm.zoomScreenRect(saveMapLoc, lastZoomWidth, lastZoomHeight);
-			}
-			
-			if (mm.zoomingMode &amp;&amp; paintingZoomArea &amp;&amp; (ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {
-				int left, top;
-				Graphics dr = this.getGraphics();
-				if (lastZoomWidth &lt; 0)left = saveMapLoc.x + lastZoomWidth;
-				else left = saveMapLoc.x;
-				if (lastZoomHeight &lt; 0)top = saveMapLoc.y + lastZoomHeight;
-				else top = saveMapLoc.y;
-				this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight)));
-				dr.setColor(Color.LightGreen);
-				lastZoomWidth = ev.x - saveMapLoc.x;
-				lastZoomHeight =  ev.y - saveMapLoc.y;
-				if (lastZoomWidth &lt; 0) left = saveMapLoc.x + lastZoomWidth;
-				else left = saveMapLoc.x;
-				if (lastZoomHeight &lt; 0)top = saveMapLoc.y + lastZoomHeight;
-				else top = saveMapLoc.y;
-				dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth) , java.lang.Math.abs(lastZoomHeight), 2);
-			}
-			super.onPenEvent(ev);
+			mm.zoomScreenRect(saveMapLoc, lastZoomWidth, lastZoomHeight);
 		}
-		
-		private void bringMapToTop() {
-			if (mapImage == null || (mapImage.properties &amp; AniImage.IsInvisible) &gt; 0 ) return;
-			saveImageList = new ImageList();
-			saveImageList.copyFrom(images);
-			images.removeAllElements();
-			//images.remove(mapImage);
-			//mapImage.properties |= AniImage.AlwaysOnTop;
-			images.add(mapImage);
+
+		if (mm.zoomingMode &amp;&amp; paintingZoomArea &amp;&amp; (ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {
+			int left, top;
+			Graphics dr = this.getGraphics();
+			if (lastZoomWidth &lt; 0)left = saveMapLoc.x + lastZoomWidth;
+			else left = saveMapLoc.x;
+			if (lastZoomHeight &lt; 0)top = saveMapLoc.y + lastZoomHeight;
+			else top = saveMapLoc.y;
+			this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight)));
+			dr.setColor(Color.LightGreen);
+			lastZoomWidth = ev.x - saveMapLoc.x;
+			lastZoomHeight =  ev.y - saveMapLoc.y;
+			if (lastZoomWidth &lt; 0) left = saveMapLoc.x + lastZoomWidth;
+			else left = saveMapLoc.x;
+			if (lastZoomHeight &lt; 0)top = saveMapLoc.y + lastZoomHeight;
+			else top = saveMapLoc.y;
+			dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth) , java.lang.Math.abs(lastZoomHeight), 2);
 		}
-		private void bringMaptoBack() {
-			//mapImage.properties &amp;= ~AniImage.AlwaysOnTop;
-			//images.moveToBack(mapImage);
-			if (saveImageList == null) return;
-			images=saveImageList;
-			saveImageList = null;
+		super.onPenEvent(ev);
+	}
+
+	private void bringMapToTop() {
+		if (mapImage == null || (mapImage.properties &amp; AniImage.IsInvisible) &gt; 0 ) return;
+		saveImageList = new ImageList();
+		saveImageList.copyFrom(images);
+		images.removeAllElements();
+		//images.remove(mapImage);
+		//mapImage.properties |= AniImage.AlwaysOnTop;
+		images.add(mapImage);
+	}
+	private void bringMaptoBack() {
+		//mapImage.properties &amp;= ~AniImage.AlwaysOnTop;
+		//images.moveToBack(mapImage);
+		if (saveImageList == null) return;
+		images=saveImageList;
+		saveImageList = null;
+	}
+
+	public void moveMap(int diffX, int diffY) {
+		Point p = new Point();
+		if (mapImage!= null) {
+			p = mapImage.getLocation(null);
+			mapImage.move(p.x+diffX,p.y+diffY);
 		}
-		
-		public void moveMap(int diffX, int diffY) {
-			Point p = new Point();
-			if (mapImage!= null) {
-				p = mapImage.getLocation(null);
-				mapImage.move(p.x+diffX,p.y+diffY);
-			}
-			mapMoved(diffX, diffY);
-		}
+		mapMoved(diffX, diffY);
+	}
 
-		public void mapMoved(int diffX, int diffY){
-			mm.mapMoved(diffX, diffY);
-			this.repaintNow();
-		}
-		
-		public void doPaint(Graphics g,Rect area) {
-			super.doPaint(g, area);
-			if (mm.gotoPos != null) {
+	public void mapMoved(int diffX, int diffY){
+		mm.mapMoved(diffX, diffY);
+		this.repaintNow();
+	}
+
+	public void doPaint(Graphics g,Rect area) {
+		super.doPaint(g, area);
+		if (mm.gotoPos != null) {
 			Point dest = mm.getXYonScreen(mm.gotoPos.lat, mm.gotoPos.lon);
 			g.setPen(new Pen(Color.MediumBlue, Pen.SOLID, 3));
 			g.drawLine(mm.posCircleX, mm.posCircleY, dest.x, dest.y);
+		}
+	}
+
+	public void chooseMap() {
+		CWPoint gpspos;
+		if (mm.gotoPanel.gpsPosition.Fix &gt; 0) gpspos = new CWPoint(mm.gotoPanel.gpsPosition.latDec, mm.gotoPanel.gpsPosition.lonDec);
+		else gpspos = null;
+		ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos());
+		if(l.execute() == FormBase.IDOK){
+//			Vm.debug(&quot;Trying map: &quot; + l.selectedMap.fileName);
+			mm.autoSelectMap = false;
+			if (l.selectedMap.inBound(mm.posCircleLat, mm.posCircleLon) || l.selectedMap.getImageFilename().length()==0) {
+				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon);
+				mm.ignoreGpsStatutsChanges = false;
+			} else {
+				mm.ignoreGpsStatutsChanges = false;
+				mm.setGpsStatus(MovingMap.noGPS);
+				mm.ignoreGpsStatutsChanges = true;
+				mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon); // don't adjust Image to lat/lon
+				mm.setCenterOfScreen(l.selectedMap.center);
+				//Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
+				//double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4]; 
+				//mm.posCircleX = 0; // place map to the upper left corner of windows
+				//mm.posCircleY = 0;
+				//mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
 			}
 		}
-		
-		public void chooseMap() {
-			CWPoint gpspos;
-			if (mm.gotoPanel.gpsPosition.Fix &gt; 0) gpspos = new CWPoint(mm.gotoPanel.gpsPosition.latDec, mm.gotoPanel.gpsPosition.lonDec);
-			else gpspos = null;
-			ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos());
-			if(l.execute() == FormBase.IDOK){
-//				Vm.debug(&quot;Trying map: &quot; + l.selectedMap.fileName);
-				mm.autoSelectMap = false;
-				if (l.selectedMap.inBound(mm.posCircleLat, mm.posCircleLon) || l.selectedMap.getImageFilename().length()==0) {
-					mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon);
-					mm.ignoreGpsStatutsChanges = false;
-				} else {
-					mm.ignoreGpsStatutsChanges = false;
-					mm.setGpsStatus(MovingMap.noGPS);
-					mm.ignoreGpsStatutsChanges = true;
-					mm.setMap(l.selectedMap, mm.posCircleLat, mm.posCircleLon); // don't adjust Image to lat/lon
-					mm.setCenterOfScreen(l.selectedMap.center);
-//					Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
-					//			double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4]; 
-					mm.posCircleX = 0; // place map to the upper left corner of windows
-					mm.posCircleY = 0;
-					mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
-				}
+	}
+
+	/**
+	 *	Method to react to user.
+	 */
+	public void imageClicked(AniImage which, Point pos){
+		if (which == mm.bottonImageChooseMap){
+			mapsMenu = new Menu(new String[]{&quot;Select a map manually$s&quot;, &quot;Change map directory$c&quot;}, &quot;map choice&quot;);
+			if (!mm.noMapsAvailable) 
+			{
+				if (mm.mapHidden) mapsMenu.addItem(&quot;show map&quot;);
+				else mapsMenu.addItem(&quot;hide map&quot;);
 			}
+			//m.set(Menu., status)
+			mapsMenu.exec(this, new Point(which.location.x, which.location.y), this);
 		}
+		if (which == mm.buttonImageGpsOn) {
+			if (mm.gotoPanel.serThread == null || !mm.gotoPanel.serThread.isAlive()) {
+				mm.gotoPanel.startGps();
+				mm.addTrack(mm.gotoPanel.currTrack); // use new track when gps now started
+			} 
+			mm.SnapToGps();
+		}
+		if (which == mm.buttonImageLens) {
+			mm.setZoomingMode();
+		}
+		if (which == mm.buttonImageZoom1to1) {
+			mm.zoom1to1();
+		}
+		if (which == mm.bottonImageClose) {
+			WindowEvent tmp = new WindowEvent();
+			tmp.type = WindowEvent.CLOSE;
+			mm.postEvent(tmp);
+		}
 
-		/**
-		 *	Method to react to user.
-		 */
-		public void imageClicked(AniImage which, Point pos){
-			if (which == mm.bottonImageChooseMap){
-				mapsMenu = new Menu(new String[]{&quot;Select a map manually$s&quot;, &quot;Change map directory$c&quot;}, &quot;map choice&quot;);
-				if (!mm.noMapsAvailable) 
-				{
-					if (mm.mapHidden) mapsMenu.addItem(&quot;show map&quot;);
-					else mapsMenu.addItem(&quot;hide map&quot;);
-				}
-				//m.set(Menu., status)
-				mapsMenu.exec(this, new Point(which.location.x, which.location.y), this);
-			}
-			if (which == mm.buttonImageGpsOn) {
-				if (mm.gotoPanel.serThread == null || !mm.gotoPanel.serThread.isAlive()) {
-					mm.gotoPanel.startGps();
-					mm.addTrack(mm.gotoPanel.currTrack); // use new track when gps now started
-				} 
-				mm.SnapToGps();
-			}
-			if (which == mm.buttonImageLens) {
-				mm.setZoomingMode();
-			}
-			if (which == mm.buttonImageZoom1to1) {
-				mm.zoom1to1();
-			}
-			if (which == mm.bottonImageClose) {
-				WindowEvent tmp = new WindowEvent();
-				tmp.type = WindowEvent.CLOSE;
-				mm.postEvent(tmp);
-			}
-				
-			/*if (which == mm.arrowRight)	{	moveMap(-10,0);	}
+		/*if (which == mm.arrowRight)	{	moveMap(-10,0);	}
 		if (which == mm.arrowLeft)	{	moveMap(+10,0);	}
 		if (which == mm.arrowDown)	{	moveMap(0,-10);	}
 		if (which == mm.arrowUp)	{	moveMap(0,+10);	} */
+	}
+
+	public void penHeld(Point p){
+		//	if (!menuIsActive()) doMenu(p);
+		if (!mm.zoomingMode) // &amp;&amp; ev instanceof PenEvent &amp;&amp; (
+			//( (ev.type == PenEvent.PEN_DOWN) &amp;&amp; ((PenEvent)ev).modifiers == PenEvent.RIGHT_BUTTON)
+		{ //|| ((ev.type == PenEvent.RIGHT_BUTTON) ) )){
+			kontextMenu = new Menu();
+			kontextMenu.addItem(gotoMenuItem);
+			kontextMenu.exec(this, new Point(p.x, p.y), this);
 		}
-		public void onEvent(Event ev){
-			if (mapsMenu != null &amp;&amp; ev instanceof PenEvent &amp;&amp; ev.type == PenEvent.PEN_DOWN &amp;&amp; ev.target == this) mapsMenu.close();
-			if (ev instanceof ControlEvent ) { 
-				if (ev.target == mapsMenu &amp;&amp; ev.type == MenuEvent.SELECTED ) {
-					if (ev.type == MenuEvent.ABORTED || ev.type == MenuEvent.CANCELLED || ev.type == MenuEvent.FOCUS_OUT) mapsMenu.close();
+	}
+
+	public void onEvent(Event ev){
+		if (mapsMenu != null &amp;&amp; ev instanceof PenEvent &amp;&amp; ev.type == PenEvent.PEN_DOWN &amp;&amp; ev.target == this) {mapsMenu.close(); mapsMenu = null;}
+		if (kontextMenu != null &amp;&amp; ev instanceof PenEvent &amp;&amp; ev.type == PenEvent.PEN_DOWN &amp;&amp; ev.target == this) {kontextMenu.close(); kontextMenu = null; }
+
+		if (ev instanceof MenuEvent) { 
+			if (ev.target == mapsMenu) {
+				if (ev.type == MenuEvent.ABORTED || ev.type == MenuEvent.CANCELLED || ev.type == MenuEvent.FOCUS_OUT) mapsMenu.close(); // TODO menuIsActive() benutzen? 
+				if (ev.type == MenuEvent.SELECTED ) {
 					if (mapsMenu.getSelectedItem() != null) {
-						if (mapsMenu.getSelectedItem() != null &amp;&amp; mapsMenu.getSelectedItem().toString().equalsIgnoreCase(&quot;Select a map manually&quot;) )
+						if (mapsMenu.getSelectedItem().toString().equalsIgnoreCase(&quot;Select a map manually&quot;) )
 						{ 
 							mapsMenu.close();
 							chooseMap();
 						}
-						if (mapsMenu.getSelectedItem() != null &amp;&amp; mapsMenu.getSelectedItem().toString().equalsIgnoreCase(&quot;Change map directory&quot;) )
+						if (mapsMenu.getSelectedItem().toString().equalsIgnoreCase(&quot;Change map directory&quot;) )
 						{
 							mapsMenu.close();
 							FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, Global.getPref().baseDir+&quot;/maps&quot;);
@@ -1085,7 +1147,7 @@
 							}
 						}
 						//dont show map
-						if (mapsMenu.getSelectedItem() != null &amp;&amp; mapsMenu.getSelectedItem().toString().equalsIgnoreCase(&quot;hide map&quot;) )
+						if (mapsMenu.getSelectedItem().toString().equalsIgnoreCase(&quot;hide map&quot;) )
 						{
 							mapsMenu.close();
 							mm.hideMap();
@@ -1096,256 +1158,264 @@
 							mapsMenu.close();
 							mm.showMap();
 						}
-
 					}
 				}
-			}
-			super.onEvent(ev);
-		}
+			} // if (ev.target == mapsMenu)
+			if (ev.target == kontextMenu) {
+				if ((((MenuEvent)ev).type==MenuEvent.SELECTED)) {
+					if (kontextMenu.getSelectedItem() == gotoMenuItem) {
+						kontextMenu.close();
+						mm.gotoPanel.setDestination(mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y));	
+					}
+				}
+			} // if (ev.target == kontextMenu)
+		} // if (ev instanceof ControlEvent ) 
+		super.onEvent(ev);
 	}
+}
 
 
-	/**
-	 *	Class to display maps to choose from
-	 */
-	class ListBox extends Form{
-		public MapInfoObject selectedMap = new MapInfoObject();
-		mButton cancelButton, okButton;
-		mList list = new mList(4,1,false);
-		public boolean selected = false;
-		Vector maps;
+/**
+ *	Class to display maps to choose from
+ */
+class ListBox extends Form{
+	public MapInfoObject selectedMap = new MapInfoObject();
+	mButton cancelButton, okButton;
+	mList list = new mList(4,1,false);
+	public boolean selected = false;
+	Vector maps;
 
-		public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos){
-			this.title = &quot;Maps&quot;;
-			// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else 
-			this.setPreferredSize(MyLocale.getScreenWidth()*3/4, MyLocale.getScreenHeight()*3/4);
-			this.maps = maps;
-			MapInfoObject map;
-			ScrollBarPanel scb;
-			boolean[] inList = new boolean[maps.size()];
-			if (gotopos != null &amp;&amp; Gps != null) {
-				list.addItem(&quot;--- Karten von akt. Position und Ziel ---&quot;);
-				for(int i = 0; i&lt;maps.size();i++){
-					map = new MapInfoObject();
-					map = (MapInfoObject)maps.get(i);
-					if( map.inBound(Gps.latDec, Gps.lonDec) &amp;&amp; map.inBound(gotopos) ) 
-					{
-						list.addItem(i + &quot;: &quot; + map.mapName);
-						inList[i] = true;
-					} else inList[i] = false;
-				}
+	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos){
+		this.title = &quot;Maps&quot;;
+		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else 
+		this.setPreferredSize(MyLocale.getScreenWidth()*3/4, MyLocale.getScreenHeight()*3/4);
+		this.maps = maps;
+		MapInfoObject map;
+		ScrollBarPanel scb;
+		boolean[] inList = new boolean[maps.size()];
+		if (gotopos != null &amp;&amp; Gps != null) {
+			list.addItem(&quot;--- Karten von akt. Position und Ziel ---&quot;);
+			for(int i = 0; i&lt;maps.size();i++){
+				map = new MapInfoObject();
+				map = (MapInfoObject)maps.get(i);
+				if( map.inBound(Gps.latDec, Gps.lonDec) &amp;&amp; map.inBound(gotopos) ) 
+				{
+					list.addItem(i + &quot;: &quot; + map.mapName);
+					inList[i] = true;
+				} else inList[i] = false;
 			}
-			if (Gps != null) {
-				list.addItem(&quot;--- Karten der aktuellen Position ---&quot;);
-				for(int i = 0; i&lt;maps.size();i++){
-					map = new MapInfoObject();
-					map = (MapInfoObject)maps.get(i);
-					if(map.inBound(Gps.latDec, Gps.lonDec) == true) 
-					{
-						list.addItem(i + &quot;: &quot; + map.mapName);
-						inList[i] = true;
-					}
+		}
+		if (Gps != null) {
+			list.addItem(&quot;--- Karten der aktuellen Position ---&quot;);
+			for(int i = 0; i&lt;maps.size();i++){
+				map = new MapInfoObject();
+				map = (MapInfoObject)maps.get(i);
+				if(map.inBound(Gps.latDec, Gps.lonDec) == true) 
+				{
+					list.addItem(i + &quot;: &quot; + map.mapName);
+					inList[i] = true;
 				}
 			}
-			if (gotopos != null) {
-				list.addItem(&quot;--- Karten des Ziels ---&quot;);
-				for(int i = 0; i&lt;maps.size();i++){
-					map = new MapInfoObject();
-					map = (MapInfoObject)maps.get(i);
-					if(map.inBound(gotopos)) {
-						list.addItem(i + &quot;: &quot; + map.mapName);
-						inList[i] = true;
-					}
-				}
-			}
-			list.addItem(&quot;--- andere Karten ---&quot;);
+		}
+		if (gotopos != null) {
+			list.addItem(&quot;--- Karten des Ziels ---&quot;);
 			for(int i = 0; i&lt;maps.size();i++){
 				map = new MapInfoObject();
 				map = (MapInfoObject)maps.get(i);
-				if(!inList[i]) list.addItem(i + &quot;: &quot; + map.mapName);
+				if(map.inBound(gotopos)) {
+					list.addItem(i + &quot;: &quot; + map.mapName);
+					inList[i] = true;
+				}
 			}
-
-			this.addLast(scb = new ScrollBarPanel(list),CellConstants.STRETCH, CellConstants.FILL);
-			cancelButton = new mButton(&quot;Cancel&quot;);
-			cancelButton.setHotKey(0, KeyEvent.getCancelKey(true));
-			this.addNext(cancelButton,CellConstants.STRETCH, CellConstants.FILL);
-			okButton = new mButton(&quot;Select&quot;);
-			okButton.setHotKey(0, KeyEvent.getActionKey(true));
-			this.addLast(okButton,CellConstants.STRETCH, CellConstants.FILL);
 		}
-		private boolean mapIsInList(int mapNr){ // it is not used  anymore could be deleted
-			String testitem = new String();
-			int testitemnr;
-			for (int i=0; i&lt;list.countListItems(); i++) {
-				try { 
-					testitem = ((MenuItem)list.items.get(i)).label;
-					testitemnr = Convert.toInt(testitem.substring(0,testitem.indexOf(':')));
-					if ( testitemnr == mapNr) return true;
-				} catch (IndexOutOfBoundsException e) {} // happens on a seperator line because it doesn't contain &quot;:&quot;
-				catch (NegativeArraySizeException e) {} // happens on a seperator line because it doesn't contain &quot;:&quot;
-			}
-			return false;
+		list.addItem(&quot;--- andere Karten ---&quot;);
+		for(int i = 0; i&lt;maps.size();i++){
+			map = new MapInfoObject();
+			map = (MapInfoObject)maps.get(i);
+			if(!inList[i]) list.addItem(i + &quot;: &quot; + map.mapName);
 		}
 
+		this.addLast(scb = new ScrollBarPanel(list),CellConstants.STRETCH, CellConstants.FILL);
+		cancelButton = new mButton(&quot;Cancel&quot;);
+		cancelButton.setHotKey(0, KeyEvent.getCancelKey(true));
+		this.addNext(cancelButton,CellConstants.STRETCH, CellConstants.FILL);
+		okButton = new mButton(&quot;Select&quot;);
+		okButton.setHotKey(0, KeyEvent.getActionKey(true));
+		this.addLast(okButton,CellConstants.STRETCH, CellConstants.FILL);
+	}
+	private boolean mapIsInList(int mapNr){ // it is not used  anymore could be deleted
+		String testitem = new String();
+		int testitemnr;
+		for (int i=0; i&lt;list.countListItems(); i++) {
+			try { 
+				testitem = ((MenuItem)list.items.get(i)).label;
+				testitemnr = Convert.toInt(testitem.substring(0,testitem.indexOf(':')));
+				if ( testitemnr == mapNr) return true;
+			} catch (IndexOutOfBoundsException e) {} // happens on a seperator line because it doesn't contain &quot;:&quot;
+			catch (NegativeArraySizeException e) {} // happens on a seperator line because it doesn't contain &quot;:&quot;
+		}
+		return false;
+	}
 
-		public int myExecute() {
-			if (this.maps.size()==1) {
-				//this.selectedMap = 1;
-				this.selectedMap = (MapInfoObject) maps.get(0);
-				return FormBase.IDOK;
-			}
-			return execute();
+
+	public int myExecute() {
+		if (this.maps.size()==1) {
+			//this.selectedMap = 1;
+			this.selectedMap = (MapInfoObject) maps.get(0);
+			return FormBase.IDOK;
 		}
+		return execute();
+	}
 
 
-		public void onEvent(Event ev){
-			if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
-				if (ev.target == cancelButton){
+	public void onEvent(Event ev){
+		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (ev.target == cancelButton){
+				selectedMap = null;
+				selected = false;
+				this.close(FormBase.IDCANCEL);
+			}
+			if (ev.target == okButton){
+				try {
 					selectedMap = null;
-					selected = false;
-					this.close(FormBase.IDCANCEL);
-				}
-				if (ev.target == okButton){
-					try {
-						selectedMap = null;
-						int mapNum = 0;
-						String it = new String();
-						it = list.getText();
-						if (it != &quot;&quot;){
-							it = it.substring(0,it.indexOf(':'));
-							mapNum = Convert.toInt(it);
-							//	Vm.debug(&quot;Kartennummer: &quot; + mapNum);
-							selectedMap = (MapInfoObject)maps.get(mapNum);
-							selected = true;
-							this.close(FormBase.IDOK);
-						}
-						else {
-							selected = false;
-							this.close(FormBase.IDCANCEL);
-						}
-					}catch (NegativeArraySizeException e) {} // happens in substring when a dividing line selected 
-				}
+					int mapNum = 0;
+					String it = new String();
+					it = list.getText();
+					if (it != &quot;&quot;){
+						it = it.substring(0,it.indexOf(':'));
+						mapNum = Convert.toInt(it);
+						//	Vm.debug(&quot;Kartennummer: &quot; + mapNum);
+						selectedMap = (MapInfoObject)maps.get(mapNum);
+						selected = true;
+						this.close(FormBase.IDOK);
+					}
+					else {
+						selected = false;
+						this.close(FormBase.IDCANCEL);
+					}
+				}catch (NegativeArraySizeException e) {} // happens in substring when a dividing line selected 
 			}
-			super.onEvent(ev);
 		}
+		super.onEvent(ev);
 	}
+}
 
-	class MapSymbol {
-		String name;
-		String filename;
-		double lat, lon;
-		AniImage pic;
-		public MapSymbol(String namei, String filenamei, double lati, double loni) {
-			name = namei;
-			filename = filenamei;
-			lat = lati;
-			lon = loni;
-		}
-		public void loadImage(){
-			pic = new AniImage(filename);
-			pic.properties = AniImage.AlwaysOnTop;
-		}
+class MapSymbol {
+	String name;
+	String filename;
+	double lat, lon;
+	AniImage pic;
+	public MapSymbol(String namei, String filenamei, double lati, double loni) {
+		name = namei;
+		filename = filenamei;
+		lat = lati;
+		lon = loni;
 	}
+	public void loadImage(){
+		pic = new AniImage(filename);
+		pic.properties = AniImage.AlwaysOnTop;
+	}
+}
 
-	class ArrowsOnMap extends AniImage {
-		float gotoDir = -361;
-		float sunDir = -361;
-		float moveDir = -361;
-		
-		int minY;
-		Graphics draw;
-		private MapInfoObject map=null;
-		public boolean dirsChanged = true;
-		
-		final static Color RED = new Color(255,0,0);
-		final static Color YELLOW = new Color(255,255,0);
-		final static Color GREEN = new Color(0,255,0);
-		final static Color BLUE = new Color(0,255,255);
-		/**
-		 * @param gd goto direction
-		 * @param sd sun direction
-		 * @param md moving direction
-		 */
-		public ArrowsOnMap(){
-			super();
-			newImage();
+class ArrowsOnMap extends AniImage {
+	float gotoDir = -361;
+	float sunDir = -361;
+	float moveDir = -361;
+
+	int minY;
+	Graphics draw;
+	private MapInfoObject map=null;
+	public boolean dirsChanged = true;
+
+	final static Color RED = new Color(255,0,0);
+	final static Color YELLOW = new Color(255,255,0);
+	final static Color GREEN = new Color(0,255,0);
+	final static Color BLUE = new Color(0,255,255);
+	/**
+	 * @param gd goto direction
+	 * @param sd sun direction
+	 * @param md moving direction
+	 */
+	public ArrowsOnMap(){
+		super();
+		newImage();
 		//	setDirections(90, 180, -90);
-		}
-		
-		public void newImage() {
-			setImage(new Image(80,80), Color.White);
-			draw = new Graphics(image);
-		}
-		public void setMap(MapInfoObject m) {
-			map = m;
-		}
+	}
 
-		public void setDirections(float gd, float sd, float md ) {
-			if (java.lang.Math.abs(gotoDir - gd) &gt; 1 // to save cpu-usage only update if the is a change of directions of more than 1 degree
-					|| java.lang.Math.abs(sunDir - sd) &gt; 1
-					|| java.lang.Math.abs(moveDir - md) &gt; 1)
-			{
-				dirsChanged = true;
-				gotoDir = gd;
-				sunDir = sd;
-				moveDir = md;
-				refresh();
-			}
+	public void newImage() {
+		setImage(new Image(80,80), Color.White);
+		draw = new Graphics(image);
+	}
+	public void setMap(MapInfoObject m) {
+		map = m;
+	}
+
+	public void setDirections(float gd, float sd, float md ) {
+		if (java.lang.Math.abs(gotoDir - gd) &gt; 1 // to save cpu-usage only update if the is a change of directions of more than 1 degree
+				|| java.lang.Math.abs(sunDir - sd) &gt; 1
+				|| java.lang.Math.abs(moveDir - md) &gt; 1)
+		{
+			dirsChanged = true;
+			gotoDir = gd;
+			sunDir = sd;
+			moveDir = md;
+			refresh();
 		}
+	}
 
-		/**
-		 * draw arrows for the directions of movement and destination waypoint
-		 * @param ctrl the control to paint on
-		 * @param moveDir degrees of movement
-		 * @param destDir degrees of destination waypoint
-		 */
+	/**
+	 * draw arrows for the directions of movement and destination waypoint
+	 * @param ctrl the control to paint on
+	 * @param moveDir degrees of movement
+	 * @param destDir degrees of destination waypoint
+	 */
 
-		public void doDraw(Graphics g,int options) {
-			if (map == null) return;
-			if (!dirsChanged) {
-				g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
-				return;
-			}
-			dirsChanged = false;
-			//super.doDraw(g, options);
-			draw.setColor(Color.White);
-			draw.fillRect(0, 0, location.width, location.height);
-			minY = Integer.MAX_VALUE;
-			drawArrows(draw);
-			draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw 
+	public void doDraw(Graphics g,int options) {
+		if (map == null) return;
+		if (!dirsChanged) {
 			g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
+			return;
 		}
+		dirsChanged = false;
+		//super.doDraw(g, options);
+		draw.setColor(Color.White);
+		draw.fillRect(0, 0, location.width, location.height);
+		minY = Integer.MAX_VALUE;
+		drawArrows(draw);
+		draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw 
+		g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
+	}
 
-		private void drawArrows(Graphics g){
-			
-			if (g != null) {
-				// draw only valid arrows
-				if (moveDir &lt; 360 &amp;&amp; moveDir &gt; -360) drawArrow(g, moveDir, RED);
-				if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360) drawArrow(g, gotoDir, BLUE);
-				if (sunDir &lt; 360 &amp;&amp; sunDir&gt; -360) drawArrow(g, sunDir, YELLOW);
-				drawArrow(g, 0, Color.DarkBlue); // north direction
-			}
+	private void drawArrows(Graphics g){
+
+		if (g != null) {
+			// draw only valid arrows
+			if (moveDir &lt; 360 &amp;&amp; moveDir &gt; -360) drawArrow(g, moveDir, RED);
+			if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360) drawArrow(g, gotoDir, BLUE);
+			if (sunDir &lt; 360 &amp;&amp; sunDir&gt; -360) drawArrow(g, sunDir, YELLOW);
+			drawArrow(g, 0, Color.DarkBlue); // north direction
 		}
+	}
 
-		/**
-		 * draw single arrow 
-		 * @param g handle for drawing
-		 * @param angle angle of arrow
-		 * @param col color of arrow
-		 */
-		private void drawArrow(Graphics g, float angle, Color col) {
-			float angleRad;
-			int x, y, centerX = location.width/2, centerY = location.height/2;
+	/**
+	 * draw single arrow 
+	 * @param g handle for drawing
+	 * @param angle angle of arrow
+	 * @param col color of arrow
+	 */
+	private void drawArrow(Graphics g, float angle, Color col) {
+		float angleRad;
+		int x, y, centerX = location.width/2, centerY = location.height/2;
 
-			angleRad = angle * (float)java.lang.Math.PI / 180 + map.rotationRad;
-			x = centerX + new Float(centerX * java.lang.Math.sin(angleRad)).intValue();
-			y = centerY - new Float(centerY * java.lang.Math.cos(angleRad)).intValue();
+		angleRad = angle * (float)java.lang.Math.PI / 180 + map.rotationRad;
+		x = centerX + new Float(centerX * java.lang.Math.sin(angleRad)).intValue();
+		y = centerY - new Float(centerY * java.lang.Math.cos(angleRad)).intValue();
 		//	g.setPen(new Pen(Color.Black,Pen.SOLID,7));
 		//	g.drawLine(centerX,centerY,x,y);
-			g.setPen(new Pen(col,Pen.SOLID,3));
-			g.drawLine(centerX,centerY,x,y);
-			if (y &lt; minY) minY = y;
-			if (centerY &lt; minY) minY = centerY;
-		}
+		g.setPen(new Pen(col,Pen.SOLID,3));
+		g.drawLine(centerX,centerY,x,y);
+		if (y &lt; minY) minY = y;
+		if (centerY &lt; minY) minY = centerY;
 	}
+}
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000168.html">[Cachewolf-svn] r413 - trunk/resources
</A></li>
	<LI>Next message: <A HREF="000170.html">[Cachewolf-svn] r415 - in trunk: resources src/CacheWolf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#169">[ date ]</a>
              <a href="thread.html#169">[ thread ]</a>
              <a href="subject.html#169">[ subject ]</a>
              <a href="author.html#169">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
