<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r406 - in trunk: . resources src src/CacheWolf	src/exp
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2007-January/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r406%20-%20in%20trunk%3A%20.%20resources%20src%20src/CacheWolf%0A%09src/exp&In-Reply-To=%3C200701191913.l0JJDkQQ017842%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000156.html">
   <LINK REL="Next"  HREF="000158.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r406 - in trunk: . resources src src/CacheWolf	src/exp</H1>
    <B>kalli at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r406%20-%20in%20trunk%3A%20.%20resources%20src%20src/CacheWolf%0A%09src/exp&In-Reply-To=%3C200701191913.l0JJDkQQ017842%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r406 - in trunk: . resources src src/CacheWolf	src/exp">kalli at mail.berlios.de
       </A><BR>
    <I>Fri Jan 19 20:13:46 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000156.html">[Cachewolf-svn] [Bug #10043] be 401 Map.java
</A></li>
        <LI>Next message: <A HREF="000158.html">[Bug #10069] MovingMap: Import l&#228;uft ins falsche (alte) Verzeichnis
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#157">[ date ]</a>
              <a href="thread.html#157">[ thread ]</a>
              <a href="subject.html#157">[ subject ]</a>
              <a href="author.html#157">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kalli
Date: 2007-01-19 20:13:11 +0100 (Fri, 19 Jan 2007)
New Revision: 406

Added:
   trunk/resources/POIIcons.zip
   trunk/src/exp/
   trunk/src/exp/ASCExporter.java
   trunk/src/exp/Exporter.java
   trunk/src/exp/GPXExporter.java
   trunk/src/exp/HTMLExporter.java
   trunk/src/exp/KMLExporter.java
   trunk/src/exp/MSARCSVExporter.java
   trunk/src/exp/OVLExporter.java
   trunk/src/exp/OziExporter.java
   trunk/src/exp/PCX5Exporter.java
   trunk/src/exp/TPLExporter.java
   trunk/src/exp/TomTomExporter.java
   trunk/src/exp/TomTomExporterScreen.java
Removed:
   trunk/src/CacheWolf/ASCExporter.java
   trunk/src/CacheWolf/CacheReaderWriter.java
   trunk/src/CacheWolf/GPXExporter.java
   trunk/src/CacheWolf/HTMLExporter.java
   trunk/src/CacheWolf/KMLExporter.java
   trunk/src/CacheWolf/LOCReader.java
   trunk/src/CacheWolf/MSARCSVExporter.java
   trunk/src/CacheWolf/OVLExporter.java
   trunk/src/CacheWolf/OziExporter.java
   trunk/src/CacheWolf/PCX5Exporter.java
   trunk/src/CacheWolf/TPLExporter.java
   trunk/src/CacheWolf/TomTomASCExporter.java
   trunk/src/CacheWolf/TomTomOV2Exporter.java
Modified:
   trunk/compile.bat
   trunk/compile.sh
   trunk/cwberlios.jnf
   trunk/getRes.sh
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/CWPoint.java
   trunk/src/CacheWolf/MainMenu.java
Log:
Exporter umgebaut, neues Package exp
Feature 3039: Prefix und Icons fuer TomTomExport

Modified: trunk/compile.bat
===================================================================
--- trunk/compile.bat	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/compile.bat	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,2 +1,3 @@
 if not exist bin\CacheWolf mkdir bin\CacheWolf
-javac -cp ./lib/CompileEwe.zip;./lib/ewesoft.zip;./lib/EwesoftRegex.zip;./lib/HTML.zip;./lib/openmap.jar  -d ./bin/ -deprecation ./src/CacheWolf/*.java 
\ No newline at end of file
+if not exist bin\exp mkdir bin\exp
+javac -cp ./lib/CompileEwe.zip;./lib/ewesoft.zip;./lib/EwesoftRegex.zip;./lib/HTML.zip;./lib/openmap.jar  -d ./bin/ -deprecation ./src/CacheWolf/*.java ./src/exp/*.java 
\ No newline at end of file

Modified: trunk/compile.sh
===================================================================
--- trunk/compile.sh	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/compile.sh	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,2 +1,2 @@
 #!/bin/bash
-javac -cp ./lib/CompileEwe.zip:./lib/ewesoft.zip:./lib/EwesoftRegex.zip:./lib/HTML.zip:./lib/openmap.jar  -d ./bin/ -deprecation -nowarn  ./src/CacheWolf/*.java
+javac -cp ./lib/CompileEwe.zip:./lib/ewesoft.zip:./lib/EwesoftRegex.zip:./lib/HTML.zip:./lib/openmap.jar  -d ./bin/ -deprecation -nowarn  ./src/CacheWolf/*.java ./src/exp/*.java

Modified: trunk/cwberlios.jnf
===================================================================
--- trunk/cwberlios.jnf	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/cwberlios.jnf	2007-01-19 19:13:11 UTC (rev 406)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D&amp;eweFiles=&amp;targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DPocketPC%25252B2003%252526%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&amp;createWithPnf=true&amp;eweInfo=outputFile%3D./work/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources%252526mask%25253D*.gif;*.png%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./lib%252526mask%25253D*.class%252526includeSubd!
 irectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources/%252526mask%25253Dcachewolf.Languages.cfg%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D_config/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources%252526mask%25253D*.html%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&amp;icon=(Def!
 ault)
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D&amp;eweFiles=&amp;targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2%252526%25253DPocketPC%25252B2003%252526%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&amp;createWithPnf=true&amp;eweInfo=outputFile%3D./work/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./bin/exp/%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253Dexp/%2526ew!
 esoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources%252526mask%25253D*.gif;*.png%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./lib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources/%252526mask%25253Dcachewolf.Languages.cfg%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D_config/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253D./resources%252526mask%25253D*.html%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526locale%253D%2526useResources%2!
 53Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D%26inst!
 all%3Dti
tle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&amp;icon=(Default)

Modified: trunk/getRes.sh
===================================================================
--- trunk/getRes.sh	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/getRes.sh	2007-01-19 19:13:11 UTC (rev 406)
@@ -7,6 +7,6 @@
 rm ./work/*.ico
 # get ressources
 cp resources/*.* work
-mv work/cachewolf.Languages.cfg work/_config
+mv work/cachewolf.Languages.cfg work/_config/cachewolf.Languages.cfg
 
 

Added: trunk/resources/POIIcons.zip
===================================================================
(Binary files differ)


Property changes on: trunk/resources/POIIcons.zip
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/resources/cachewolf.Languages.cfg	2007-01-19 19:13:11 UTC (rev 406)
@@ -6,7 +6,7 @@
 		102=nach TOP50 ASCII
 		103=nach GPX
 		104=nach ASC
-		105=nach TomTom ASC
+		105=nach TomTom
 		106=nach MS AutoRoute CSV
 		107=Export
 		108=Pr%e4ferenzen
@@ -303,7 +303,7 @@
 		102=to TOP50 ASCII
 		103=to GPX
 		104=to ASC
-		105=to TomTom ASC
+		105=to TomTom
 		106=to MS AutoRoute CSV
 		107=Export
 		108=Preferences

Deleted: trunk/src/CacheWolf/ASCExporter.java
===================================================================
--- trunk/src/CacheWolf/ASCExporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/ASCExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,54 +0,0 @@
-package CacheWolf;
-import ewe.util.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-
-/**
-*	Class to export cache database to an ASCII (CSV!) file.
-*   This file can be used by I2C's POI Converter to generate
-*   POIs for different routing programmes, especially for
-*	Destinator ;-) !
-*/
-public class ASCExporter{
-	//TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-	
-	public ASCExporter(Preferences p,Profile prof){
-		pref = p;
-		profile=prof;
-		cacheDB = prof.cacheDB;
-	}
-	
-	public void doIt(){
-		String str;
-		String dummy;
-		CacheHolder holder;
-		ParseLatLon pll;
-		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
-		fc.setTitle(&quot;Select target file:&quot;);
-		fc.addMask(&quot;*.csv&quot;);
-		fc.defaultExtension=&quot;csv&quot;;
-		if(fc.execute() != FileChooser.IDCANCEL){
-			File saveTo = fc.getChosenFile();
-			try{
-				PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
-				for(int i = 0; i&lt;cacheDB.size(); i++){
-					holder=(CacheHolder)cacheDB.get(i);
-					if(holder.is_black == false &amp;&amp; holder.is_filtered == false){
-						pll = new ParseLatLon(holder.LatLon, &quot;.&quot;);
-						pll.parse();
-						dummy = holder.CacheName;
-						dummy = dummy.replace(',', ' ');
-						str = dummy+&quot;,&quot;+dummy+&quot;,&quot;+ pll.getLonDeg()+&quot;,&quot; + pll.getLatDeg()+&quot;,,,,&quot;;
-						outp.print(str+&quot;\r\n&quot;);
-					}//if
-				}//for
-				outp.close();
-			}catch (Exception e){
-				ewe.sys.Vm.debug(&quot;Problem writing to ASC file! &quot;+e.toString());
-			}//try
-		} //if else {
-		}
-	}

Modified: trunk/src/CacheWolf/CWPoint.java
===================================================================
--- trunk/src/CacheWolf/CWPoint.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/CWPoint.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -25,12 +25,12 @@
 	MGRSPoint utm = new MGRSPoint();
 	boolean utmValid = false;
 
-	static protected final int DD = 0;
-	static protected final int DMM = 1;
-	static protected final int DMS = 2;
-	static protected final int UTM = 3;
-	static protected final int CW = 4;
-	static protected final int REGEX = 5;
+	public static final int DD = 0;
+	public static final int DMM = 1;
+	public static final int DMS = 2;
+	public static final int UTM = 3;
+	public static final int CW = 4;
+	public static final int REGEX = 5;
 	
 	/**
 	 * Create CWPoint by using lat and lon 

Deleted: trunk/src/CacheWolf/CacheReaderWriter.java
===================================================================
--- trunk/src/CacheWolf/CacheReaderWriter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/CacheReaderWriter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,14 +0,0 @@
-package CacheWolf;
-
-import ewe.util.*;
-import ewe.io.*;
-import ewe.sys.*;
-
-/**
- * REDUNDANT CLASS - DELETE 
- * Methods moved to classes @see CacheHolder and @see Profile
-*/
-public class CacheReaderWriter {
-	
-}
-

Deleted: trunk/src/CacheWolf/GPXExporter.java
===================================================================
--- trunk/src/CacheWolf/GPXExporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/GPXExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,119 +0,0 @@
-package CacheWolf;
-import ewe.util.*;
-import ewe.sys.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-import ewe.ui.*;
-import ewe.util.*;
-/**
-*	Class to export the cache database to a GPX file with gc.com
-*	extensions.&lt;br&gt;
-*	Export of logs is not that nice. The cause is that CacheWolf does not spider
-*	logs individually, rather all logs as a single entity.
-*	ClassID = 2000
-*/
-public class GPXExporter{
-//	TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-	ProgressBarForm pbf = new ProgressBarForm();
-	
-	public GPXExporter(Preferences p, Profile prof){
-		pref = p;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-	}
-	
-	public void doIt(int variant){
-		CacheHolder ch;
-		String cwd= File.getProgramDirectory();
-		File saveTo = new File(cwd + &quot;/temp.gpx&quot;);
-		if(variant == 1) {
-			FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
-			fc.setTitle(&quot;Select target file:&quot;);
-			if(fc.execute() != FormBase.IDCANCEL) saveTo = fc.getChosenFile();
-		}
-		try{
-			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
-			outp.print(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;\r\n&quot;);
-			outp.print(&quot;&lt;gpx xmlns:xsd=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema\">http://www.w3.org/2001/XMLSchema\</A>&quot; xmlns:xsi=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance\">http://www.w3.org/2001/XMLSchema-instance\</A>&quot; version=\&quot;1.0\&quot; creator=\&quot;Groundspeak Pocket Query\&quot; xsi:schemaLocation=\&quot;<A HREF="http://www.topografix.com/GPX/1/0">http://www.topografix.com/GPX/1/0</A> <A HREF="http://www.topografix.com/GPX/1/0/gpx.xsd">http://www.topografix.com/GPX/1/0/gpx.xsd</A> <A HREF="http://www.groundspeak.com/cache/1/0">http://www.groundspeak.com/cache/1/0</A> <A HREF="http://www.groundspeak.com/cache/1/0/cache.xsd\">http://www.groundspeak.com/cache/1/0/cache.xsd\</A>&quot; xmlns=\&quot;<A HREF="http://www.topografix.com/GPX/1/0\">http://www.topografix.com/GPX/1/0\</A>&quot;&gt;\r\n&quot;);
-			outp.print(&quot;  &lt;desc&gt;Geocache file generated by CacheWolf&lt;/desc&gt;\r\n&quot;);
-			outp.print(&quot;  &lt;author&gt;CacheWolf&lt;/author&gt;\r\n&quot;);
-			outp.print(&quot;  &lt;email&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">test at test.com</A>&lt;/email&gt;\r\n&quot;);
-			Time tim = new Time();
-			tim = tim.setFormat(&quot;yyyy-MM-dd&quot;);
-			tim = tim.setToCurrentTime();
-			outp.print(&quot; &lt;time&gt;&quot;+tim.toString()+&quot;T00:00:00.0000000-07:00&lt;/time&gt;\r\n&quot;);
-			ParseLatLon pll;
-			String msg;
-			for(int i = 0; i&lt;cacheDB.size(); i++){
-				if (i%5 == 0){
-					msg = &quot;Export &quot; + Convert.toString(i) + &quot; of &quot; + Convert.toString(cacheDB.size());
-					pbf.display(&quot;GPX Export&quot;,msg,null);
-				}
-				ch=(CacheHolder)cacheDB.get(i);
-				if(ch.is_black == false &amp;&amp; ch.is_filtered == false){
-					//KHF read cachedata only if needed 
-					ch.readCache(profile.dataDir);
-					pll = new ParseLatLon(ch.LatLon, &quot;.&quot;);
-					pll.parse();
-					outp.print(&quot;  &lt;wpt lat=\&quot;&quot;+pll.getLatDeg()+&quot;\&quot; lon=\&quot;&quot;+pll.getLonDeg()+&quot;\&quot;&gt;\r\n&quot;);
-					if (ch.DateHidden.length()&gt; 0){
-						tim.parse(ch.DateHidden, &quot;M/d/y&quot;);
-					}
-					else {
-						tim.setText(&quot;2000-01-01&quot;);
-					}
-					outp.print(&quot;    &lt;time&gt;&quot;+tim.toString()+&quot;T00:00:00.0000000-07:00&lt;/time&gt;\r\n&quot;);
-					outp.print(&quot;    &lt;name&gt;&quot;+ch.wayPoint+&quot;&lt;/name&gt;\r\n&quot;);
-					outp.print(&quot;    &lt;desc&gt;&quot;+SafeXML.cleanGPX(ch.CacheName)+&quot; by &quot;+SafeXML.cleanGPX(ch.CacheOwner)+&quot;&lt;/desc&gt;\r\n&quot;);
-					outp.print(&quot;    &lt;url&gt;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot;+ch.wayPoint+&quot;&amp;Submit6=Find&lt;/url&gt;\r\n&quot;);
-					outp.print(&quot;    &lt;urlname&gt;&quot;+SafeXML.cleanGPX(ch.CacheName)+&quot; by &quot;+SafeXML.cleanGPX(ch.CacheOwner)+&quot;&lt;/urlname&gt;\r\n&quot;);
-					outp.print(&quot;    &lt;sym&gt;Geocache&lt;/sym&gt;\r\n&quot;);
-					outp.print(&quot;    &lt;type&gt;Geocache|&quot;+CacheType.transType(ch.type)+&quot;&lt;/type&gt;\r\n&quot;);
-					//outp.print(&quot;    &lt;type&gt;Geocache|Geocache&lt;/type&gt;\r\n&quot;);
-					String dummyAvailable = ch.is_available ? &quot;True&quot;:&quot;False&quot;;
-					String dummyArchived = ch.is_archived ? &quot;True&quot;:&quot;False&quot;;
-					outp.print(&quot;    &lt;groundspeak:cache available=\&quot;&quot;+ dummyAvailable + &quot;\&quot; archived=\&quot;&quot; + dummyArchived+ &quot;\&quot; xmlns:groundspeak=\&quot;<A HREF="http://www.groundspeak.com/cache/1/0\">http://www.groundspeak.com/cache/1/0\</A>&quot;&gt;\r\n&quot;);
-					outp.print(&quot;      &lt;groundspeak:name&gt;&quot;+SafeXML.cleanGPX(ch.CacheName)+&quot;&lt;/groundspeak:name&gt;\r\n&quot;);
-					outp.print(&quot;      &lt;groundspeak:placed_by&gt;&quot;+SafeXML.cleanGPX(ch.CacheOwner)+&quot;&lt;/groundspeak:placed_by&gt;\r\n&quot;);
-					outp.print(&quot;      &lt;groundspeak:owner&gt;&quot;+SafeXML.cleanGPX(ch.CacheOwner)+&quot;&lt;/groundspeak:owner&gt;\r\n&quot;);
-					outp.print(&quot;      &lt;groundspeak:type&gt;&quot;+CacheType.transType(ch.type)+&quot;&lt;/groundspeak:type&gt;\r\n&quot;);
-					outp.print(&quot;      &lt;groundspeak:container&gt;&quot;+ch.CacheSize+&quot;&lt;/groundspeak:container&gt;\r\n&quot;);
-					//KHF use '.' instead of ','
-					outp.print(&quot;      &lt;groundspeak:difficulty&gt;&quot;+ch.hard.replace(',','.')+&quot;&lt;/groundspeak:difficulty&gt;\r\n&quot;);
-					outp.print(&quot;      &lt;groundspeak:terrain&gt;&quot;+ch.terrain.replace(',','.')+&quot;&lt;/groundspeak:terrain&gt;\r\n&quot;);
-					String dummyHTML = ch.is_HTML ? &quot;True&quot;:&quot;False&quot;;
-					outp.print(&quot;      &lt;groundspeak:long_description html=\&quot;&quot; + dummyHTML + &quot;\&quot;&gt;\r\n&quot;);
-					outp.print(&quot;      &quot;+SafeXML.cleanGPX(ch.LongDescription));
-					outp.print(&quot;      \n&lt;/groundspeak:long_description&gt;\r\n&quot;);
-					outp.print(&quot;	  &lt;groundspeak:encoded_hints&gt;&quot;+SafeXML.cleanGPX(Common.rot13(ch.Hints))+&quot;&lt;/groundspeak:encoded_hints&gt;\r\n&quot;);
-					outp.print(&quot;      &lt;groundspeak:logs&gt;\r\n&quot;);
-					/*
-					for(int j = 0; j&lt;holder.CacheLogs.size(); j++){
-						outp.print(&quot;	    &lt;groundspeak:log&gt;\r\n&quot;);
-						outp.print(&quot;            &lt;groundspeak:date&gt;&quot;);
-						outp.print(&quot;T08:00:00&lt;/groundspeak:date&gt;\r\n&quot;);
-						outp.print(&quot;&lt;groundspeak:finder&gt;&quot;);
-						outp.print(&quot;&lt;/groundspeak:finder&gt;&quot;);
-						outp.print(&quot;		&lt;groundspeak:text encoded=\&quot;False\&quot;&gt;\r\n&quot;);
-						outp.print(&quot;		&lt;/groundspeak:text&gt;\r\n&quot;);
-						outp.print(&quot;	    &lt;/groundspeak:log&gt;\r\n&quot;);
-					}
-					*/
-					outp.print(&quot;      &lt;/groundspeak:logs&gt;\r\n&quot;);
-					outp.print(&quot;      &lt;groundspeak:travelbugs /&gt;\r\n&quot;);
-					outp.print(&quot;    &lt;/groundspeak:cache&gt;\r\n&quot;);
-					outp.print(&quot;  &lt;/wpt&gt;\r\n&quot;);
-				} // if holder ==
-			}//for
-			pbf.clear();
-			outp.print(&quot;&lt;/gpx&gt;&quot;);
-			outp.close();
-		}catch(Exception e){
-			Vm.debug(&quot;Problem writing to GPX file&quot;);
-			e.printStackTrace();
-		}//try
-	}
-}

Deleted: trunk/src/CacheWolf/HTMLExporter.java
===================================================================
--- trunk/src/CacheWolf/HTMLExporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/HTMLExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,371 +0,0 @@
-package CacheWolf;
-import ewe.util.*;
-import ewe.sys.*;
-import ewe.io.*;
-import ewe.ui.*;
-import ewe.filechooser.*;
-import HTML.*;
-
-/**
-*	Class to export cache information to individual HTML files.&lt;br&gt;
-*	It uses the HTML package to parse template files. This makes the export
-*	very flexible; enabling the user to customise the HTML files according
-*	to thier liking.
-*/
-public class HTMLExporter{
-//	TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-	String [] template_init_index = {
-	 		&quot;filename&quot;,  &quot;index.tpl&quot;,
-	 		&quot;case_sensitive&quot;, &quot;true&quot;,
-	 		&quot;max_includes&quot;,   &quot;5&quot;
-	 		//,&quot;debug&quot;, &quot;true&quot;
-	 	};
-	String [] template_init_page = {
-	 		&quot;filename&quot;,  &quot;page.tpl&quot;,
-	 		&quot;case_sensitive&quot;, &quot;true&quot;,
-	 		&quot;max_includes&quot;,   &quot;5&quot;
-	 	};
-	public HTMLExporter(Preferences p, Profile prof){
-		pref = p;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-	}
-	
-	public void doIt(){
-//		ProgressBarForm pbf = new ProgressBarForm();
-		CacheHolder holder = new CacheHolder();
-		//need directory only!!!!
-		String dummy = new String();
-		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, profile.dataDir);
-		fc.setTitle(&quot;Select target directory:&quot;);
-		String targetDir;
-		if(fc.execute() != FileChooser.IDCANCEL){
-			targetDir = fc.getChosen() + &quot;/&quot;;
-			Vector cache_index = new Vector();
-			Vector cacheImg = new Vector();
-			Vector logImg = new Vector();
-			Vector mapImg = new Vector();
-			Vector usrImg = new Vector();
-			
-
-			Hashtable varParams;
-			Hashtable imgParams;
-			Hashtable logImgParams;
-			Hashtable usrImgParams;
-			Hashtable mapImgParams;
-
-			//Generate index page
-			int counter = 0;
-			for(int i = 0; i&lt;cacheDB.size();i++){
-				holder = (CacheHolder)cacheDB.get(i);
-				if(holder.is_black == false &amp;&amp; holder.is_filtered == false) counter++;
-			}
-			for(int i = 0; i&lt;counter;i++){
-				if (i%5 == 0){
-					ProgressBarForm.display(&quot;Exporting...&quot;, &quot;Exporting &quot; + Convert.toString(i) + &quot; of &quot; + counter, null);
-				}
-				holder = (CacheHolder)cacheDB.get(i);
-				if(holder.is_black == false &amp;&amp; holder.is_filtered == false){
-					//KHF read cachedata only if needed
-					try{
-						holder.readCache( profile.dataDir);
-					}catch(Exception e){
-						//Vm.debug(&quot;Problem reading cache page&quot;);
-					}
-					varParams = new Hashtable();
-					varParams.put(&quot;TYPE&quot;, CacheType.transType(holder.type));
-					varParams.put(&quot;SIZE&quot;, holder.CacheSize);
-					varParams.put(&quot;WAYPOINT&quot;, holder.wayPoint);
-					varParams.put(&quot;NAME&quot;, holder.CacheName);
-					varParams.put(&quot;OWNER&quot;, holder.CacheOwner);
-					varParams.put(&quot;DIFFICULTY&quot;, holder.hard);
-					varParams.put(&quot;TERRAIN&quot;, holder.terrain);
-					varParams.put(&quot;DISTANCE&quot;, holder.distance);
-					varParams.put(&quot;BEARING&quot;, holder.bearing);
-					varParams.put(&quot;LATLON&quot;, holder.LatLon);
-					varParams.put(&quot;STATUS&quot;, holder.CacheStatus);
-					cache_index.add(varParams);
-					//We can generate the individual page here!
-					try{
-						Template page_tpl = new Template(template_init_page);
-						page_tpl.setParam(&quot;TYPE&quot;, CacheType.transType(holder.type));
-						page_tpl.setParam(&quot;SIZE&quot;, holder.CacheSize);
-						page_tpl.setParam(&quot;WAYPOINT&quot;, holder.wayPoint);
-						page_tpl.setParam(&quot;NAME&quot;, holder.CacheName);
-						page_tpl.setParam(&quot;OWNER&quot;, holder.CacheOwner);
-						page_tpl.setParam(&quot;DIFFICULTY&quot;, holder.hard);
-						page_tpl.setParam(&quot;TERRAIN&quot;, holder.terrain);
-						page_tpl.setParam(&quot;DISTANCE&quot;, holder.distance);
-						page_tpl.setParam(&quot;BEARING&quot;, holder.bearing);
-						page_tpl.setParam(&quot;LATLON&quot;, holder.LatLon);
-						page_tpl.setParam(&quot;STATUS&quot;, holder.CacheStatus);
-						if (holder.is_HTML)
-							page_tpl.setParam(&quot;DESCRIPTION&quot;, holder.LongDescription);
-						else {
-							String dummyText = new String();
-							dummyText = STRreplace.replace(holder.LongDescription, &quot;\n&quot;, &quot;&lt;br&gt;&quot;);
-							page_tpl.setParam(&quot;DESCRIPTION&quot;,dummyText);
-							
-						}
-						page_tpl.setParam(&quot;HINTS&quot;, holder.Hints);
-						page_tpl.setParam(&quot;DECRYPTEDHINTS&quot;, Common.rot13(holder.Hints));
-						dummy = new String();
-						for(int j = 0; j&lt;holder.CacheLogs.size(); j++){
-							dummy = dummy + (String)holder.CacheLogs.get(j)+&quot;&lt;br&gt;&quot;;
-						}
-						page_tpl.setParam(&quot;LOGS&quot;, dummy);
-						page_tpl.setParam(&quot;NOTES&quot;, STRreplace.replace(holder.CacheNotes, &quot;\n&quot;,&quot;&lt;br&gt;&quot;));
-						// Cache Images
-						cacheImg.clear();
-						for(int j = 0; j&lt;holder.Images.size(); j++){
-							imgParams = new Hashtable();
-							String imgFile = new String((String)holder.Images.get(j));
-							imgParams.put(&quot;FILE&quot;, imgFile);
-							if (j &lt; holder.ImagesText.size())
-								imgParams.put(&quot;TEXT&quot;,(String)holder.ImagesText.get(j));
-							else
-								imgParams.put(&quot;TEXT&quot;,imgFile);
-							DataMover.copy(profile.dataDir + imgFile,targetDir + imgFile);
-							cacheImg.add(imgParams);
-						}
-						page_tpl.setParam(&quot;cacheImg&quot;, cacheImg);
-						// Log images
-						logImg.clear();
-						for(int j = 0; j&lt;holder.LogImages.size(); j++){
-							logImgParams = new Hashtable();
-							String logImgFile = new String((String)holder.LogImages.get(j));
-							logImgParams.put(&quot;FILE&quot;, logImgFile);
-							if (j &lt; holder.LogImagesText.size())
-								logImgParams.put(&quot;TEXT&quot;,(String)holder.LogImagesText.get(j));
-							else
-								logImgParams.put(&quot;TEXT&quot;,logImgFile);
-							DataMover.copy(profile.dataDir + logImgFile,targetDir + logImgFile);
-							logImg.add(logImgParams);
-						}
-						page_tpl.setParam(&quot;logImg&quot;, logImg);
-						// User images
-						usrImg.clear();
-						for(int j = 0; j&lt;holder.UserImages.size(); j++){
-							usrImgParams = new Hashtable();
-							String usrImgFile = new String((String)holder.UserImages.get(j));
-							usrImgParams.put(&quot;FILE&quot;, usrImgFile);
-							if (j &lt; holder.UserImagesText.size())
-								usrImgParams.put(&quot;TEXT&quot;,(String)holder.UserImagesText.get(j));
-							else
-								usrImgParams.put(&quot;TEXT&quot;,usrImgFile);
-							DataMover.copy(profile.dataDir + usrImgFile,targetDir + usrImgFile);
-							usrImg.add(usrImgParams);
-						}
-						page_tpl.setParam(&quot;userImg&quot;, usrImg);
-
-						// Map images
-						mapImg.clear();
-						mapImgParams = new Hashtable();
-						String mapImgFile = new String((String)holder.wayPoint + &quot;_map.gif&quot;);
-						// check if map file exists
-						File test = new File(profile.dataDir + mapImgFile);
-						if (test.exists()) {
-							mapImgParams.put(&quot;FILE&quot;, mapImgFile);
-							mapImgParams.put(&quot;TEXT&quot;,mapImgFile);
-							DataMover.copy(profile.dataDir + mapImgFile,targetDir + mapImgFile);
-							mapImg.add(mapImgParams);
-							
-							mapImgParams = new Hashtable();
-							mapImgFile = (String)holder.wayPoint + &quot;_map_2.gif&quot;;
-							mapImgParams.put(&quot;FILE&quot;, mapImgFile);
-							mapImgParams.put(&quot;TEXT&quot;,mapImgFile);
-							DataMover.copy(profile.dataDir + mapImgFile,targetDir + mapImgFile);
-							mapImg.add(mapImgParams);
-	
-							page_tpl.setParam(&quot;mapImg&quot;, mapImg);
-						}
-
-						
-						PrintWriter pagefile = new PrintWriter(new BufferedWriter(new FileWriter(targetDir + holder.wayPoint+&quot;.html&quot;)));
-						pagefile.print(page_tpl.output());
-						pagefile.close();
-					}catch(Exception e){
-						Vm.debug(&quot;Problem writing waypoint html file&quot;);
-					}
-				}//if is black, filtered
-			}
-			try{
-				Template tpl = new Template(template_init_index);
-				tpl.setParam(&quot;cache_index&quot;, cache_index);
-				PrintWriter detfile; 
-				detfile = new PrintWriter(new BufferedWriter(new FileWriter(targetDir + &quot;/index.html&quot;)));
-				detfile.print(tpl.output());
-				detfile.close();
-				// sort by waypoint
-				sortAndPrintIndex(tpl, cache_index,targetDir + &quot;/index_wp.html&quot;, &quot;WAYPOINT&quot;);
-				// sort by name
-				sortAndPrintIndex(tpl, cache_index,targetDir + &quot;/index_alpha.html&quot;, &quot;NAME&quot;, false);
-				// sort by type
-				sortAndPrintIndex(tpl, cache_index,targetDir + &quot;/index_type.html&quot;, &quot;TYPE&quot;, true);
-				// sort by size
-				sortAndPrintIndex(tpl, cache_index,targetDir + &quot;/index_size.html&quot;, &quot;SIZE&quot;, true);
-				// sort by distance
-				sortAndPrintIndex(tpl, cache_index,targetDir + &quot;/index_dist.html&quot;, &quot;DISTANCE&quot;, 10.0);
-			}catch(Exception e){
-				Vm.debug(&quot;Problem writing HTML files\n&quot;);
-				e.printStackTrace();
-			}//try
-			
-		}//if
-		ProgressBarForm.clear();
-	}
-	private void sortAndPrintIndex(Template tmpl, Vector list, String file, String field){
-		Vector navi_index;
-		PrintWriter detfile; 
-		
-		list.sort(new HTMLComparer(field),false);
-		try {
-			detfile = new PrintWriter(new BufferedWriter(new FileWriter(file)));
-			detfile.print(tmpl.output());
-			detfile.close();
-		} catch (IOException e) {
-			Vm.debug(&quot;Problem writing HTML files\n&quot;);
-			e.printStackTrace();
-		}
-	}
-
-	
-	private void sortAndPrintIndex(Template tmpl, Vector list, String file, String field, boolean fullCompare){
-		Vector navi_index;
-		PrintWriter detfile; 
-		
-		list.sort(new HTMLComparer(field),false);
-		navi_index = addAnchorString(list,field, fullCompare);
-		if (navi_index != null){
-			tmpl.setParam(&quot;navi_index&quot;,navi_index);
-		}
-		try {
-			detfile = new PrintWriter(new BufferedWriter(new FileWriter(file)));
-			detfile.print(tmpl.output());
-			detfile.close();
-		} catch (IOException e) {
-			Vm.debug(&quot;Problem writing HTML files\n&quot;);
-			e.printStackTrace();
-		}
-	}
-	
-	private void sortAndPrintIndex(Template tmpl, Vector list, String file, String field, double diff){
-		Vector navi_index;
-		PrintWriter detfile; 
-		
-		list.sort(new HTMLComparer(field),false);
-		navi_index = addAnchorString(list,field, diff);
-		if (navi_index != null){
-			tmpl.setParam(&quot;navi_index&quot;,navi_index);
-		}
-		try {
-			detfile = new PrintWriter(new BufferedWriter(new FileWriter(file)));
-			detfile.print(tmpl.output());
-			detfile.close();
-		} catch (IOException e) {
-			Vm.debug(&quot;Problem writing HTML files\n&quot;);
-			e.printStackTrace();
-		}
-		
-	}
-
-
-	private Vector addAnchorString(Vector list, String field, boolean fullCompare){
-		Vector topIndex = new Vector();
-		Hashtable topIndexParms, currEntry;
-		String lastValue, currValue;
-		
-		if (list.size() == 0) return null;
-		
-		currEntry = (Hashtable) list.get(0);
-		lastValue = (String) currEntry.get(field);
-		if (lastValue == null || lastValue.length() == 0) lastValue = &quot;  &quot;;
-		lastValue = lastValue.toUpperCase();
-		
-		for (int i=1; i&lt;list.size(); i++){
-			currEntry = (Hashtable) list.get(i);
-			currValue = (String) currEntry.get(field);
-			currValue = currValue.toUpperCase();
-			if (currValue == null || currValue == &quot;&quot;) continue;
-			try {
-				if (fullCompare) {
-					if (lastValue.compareTo(currValue)!= 0){
-						// Values for navigation line 
-						topIndexParms = new Hashtable();
-						topIndexParms.put(&quot;HREF&quot;, Convert.toString(i));
-						topIndexParms.put(&quot;TEXT&quot;, currValue);
-						topIndex.add(topIndexParms);
-						// add anchor entry to list
-						currEntry.put(&quot;ANCHORNAME&quot;, Convert.toString(i));
-						currEntry.put(&quot;ANCHORTEXT&quot;, currValue);
-					}
-					else {
-						// clear value from previous run
-						currEntry.put(&quot;ANCHORNAME&quot;, &quot;&quot;);
-						currEntry.put(&quot;ANCHORTEXT&quot;, &quot;&quot;);
-					}
-				}
-				else {
-					if (lastValue.charAt(0)!= currValue.charAt(0)){
-						// Values for navigation line 
-						topIndexParms = new Hashtable();
-						topIndexParms.put(&quot;HREF&quot;, Convert.toString(i));
-						topIndexParms.put(&quot;TEXT&quot;, currValue.charAt(0)+ &quot; &quot;);
-						topIndex.add(topIndexParms);
-						// add anchor entry to list
-						currEntry.put(&quot;ANCHORNAME&quot;, Convert.toString(i));
-						currEntry.put(&quot;ANCHORTEXT&quot;, currValue.charAt(0)+ &quot; &quot;);
-					}
-					else {
-						// clear value from previous run
-						currEntry.put(&quot;ANCHORNAME&quot;, &quot;&quot;);
-						currEntry.put(&quot;ANCHORTEXT&quot;, &quot;&quot;);
-					}
-				}
-				list.set(i,currEntry);
-				lastValue = currValue;
-			} catch (Exception e){
-				continue;
-			}
-		}
-		return topIndex;
-	}
-	private Vector addAnchorString(Vector list, String field, double diff){
-		Vector topIndex = new Vector();
-		Hashtable topIndexParms, currEntry;
-		double lastValue, currValue;
-		
-		if (list.size() == 0) return null;
-		
-		currEntry = (Hashtable) list.get(0);
-		lastValue = Common.parseDouble((String) currEntry.get(field)) + diff;
-		
-		for (int i=1; i&lt;list.size(); i++){
-			currEntry = (Hashtable) list.get(i);
-			currValue = Common.parseDouble((String) currEntry.get(field));
-			if (currValue &gt;= lastValue ){
-				// Values for navigation line 
-				topIndexParms = new Hashtable();
-				topIndexParms.put(&quot;HREF&quot;, Convert.toString(i));
-				topIndexParms.put(&quot;TEXT&quot;, Convert.toString(lastValue));
-				topIndex.add(topIndexParms);
-				// add anchor entry to list
-				currEntry.put(&quot;ANCHORNAME&quot;, Convert.toString(i));
-				currEntry.put(&quot;ANCHORTEXT&quot;, Convert.toString(lastValue));
-				lastValue = currValue + diff;
-			}
-			else {
-				// clear value from previous run
-				currEntry.put(&quot;ANCHORNAME&quot;, &quot;&quot;);
-				currEntry.put(&quot;ANCHORTEXT&quot;, &quot;&quot;);
-			}
-			list.set(i,currEntry);
-		}
-		return topIndex;
-	}
-
-	
-}

Deleted: trunk/src/CacheWolf/KMLExporter.java
===================================================================
--- trunk/src/CacheWolf/KMLExporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/KMLExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,68 +0,0 @@
-package CacheWolf;
-import ewe.util.*;
-import ewe.sys.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-
-/**
-*	Class to export the cache database (index) to an KML-File
-*	which can be read by Google Earth   
-*   
-*/
-public class KMLExporter{
-//	TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-	
-	public KMLExporter(Preferences p, Profile prof){
-		pref = p;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-	}
-	
-	public void doIt(){
-		CacheHolder holder;
-		ParseLatLon pll;
-		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
-		fc.setTitle(&quot;Select target file:&quot;);
-		if(fc.execute() != fc.IDCANCEL){
-			File saveTo = fc.getChosenFile();
-			try{
-				PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
-				//Create Header for KML-File
-				outp.println(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&quot;);
-				outp.println(&quot;&lt;kml xmlns=\&quot;<A HREF="http://earth.google.com/kml/2.0\">http://earth.google.com/kml/2.0\</A>&quot;&gt;&quot;);
-				outp.println(&quot;&lt;Folder&gt;&quot;);
-				outp.println(&quot;&lt;name&gt;CacheWolf&lt;/name&gt;&quot;);
-				outp.println(&quot;&lt;open&gt;1&lt;/open&gt;&quot;);
-				//loop through database
-				for(int i = 0; i&lt;cacheDB.size(); i++){
-					holder=(CacheHolder)cacheDB.get(i);
-					if(holder.is_black == false &amp;&amp; holder.is_filtered == false){
-						pll = new ParseLatLon(holder.LatLon,&quot;.&quot;);
-						pll.parse();
-						outp.println(&quot;   &lt;Placemark&gt;&quot;);
-						outp.println(&quot;      &lt;description&gt;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot;+holder.wayPoint+&quot;&lt;/description&gt;&quot;);
-						outp.println(&quot;      &lt;name&gt;&quot;+ holder.wayPoint + &quot; - &quot; + SafeXML.clean(holder.CacheName) +&quot;&lt;/name&gt;&quot;);
-						outp.println(&quot;      &lt;LookAt&gt;&quot;);
-						outp.println(&quot;         &lt;latitude&gt;&quot; + pll.getLatDeg() + &quot;&lt;/latitude&gt;&quot;);
-						outp.println(&quot;         &lt;longitude&gt;&quot; + pll.getLonDeg() + &quot;&lt;/longitude&gt;&quot;);
-						outp.println(&quot;         &lt;range&gt;10000&lt;/range&gt;&lt;tilt&gt;0&lt;/tilt&gt;&lt;heading&gt;0&lt;/heading&gt;&quot;);
-						outp.println(&quot;      &lt;/LookAt&gt;&quot;);
-						outp.println(&quot;      &lt;Point&gt;&quot;);
-						outp.println(&quot;         &lt;coordinates&gt;&quot;  + pll.getLonDeg() + &quot;,&quot; + pll.getLatDeg() + &quot;&lt;/coordinates&gt;&quot;);
-						outp.println(&quot;      &lt;/Point&gt;&quot;);
-						outp.println(&quot;   &lt;/Placemark&gt;&quot;);
-					}//if holder...
-				}//for ... i &lt; cacheDB ...			
-				// footer
-				outp.println(&quot;&lt;/Folder&gt;&quot;);
-				outp.println(&quot;&lt;/kml&gt;&quot;);
-				outp.close();
-			}catch(Exception e){
-				//Vm.debug(&quot;Error writing to OVL file!&quot;);
-			}
-		} // if execute
-	}
-}

Deleted: trunk/src/CacheWolf/LOCReader.java
===================================================================
--- trunk/src/CacheWolf/LOCReader.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/LOCReader.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,52 +0,0 @@
-package CacheWolf;
-import ewe.filechooser.*;
-import ewe.io.*;
-import ewe.util.*;
-import ewe.sys.*;
-
-/**
-*	This class analyses the gc.com loc filesa and extracts the cache waypoint 
-*	names. When run it offers the user a file chooser screen from which the user
-*	defines the directory the loc files are stored in. It searches the directory
-*	for the loc files and extractes the data from each loc file.	
-*/
-public class LOCReader{
-	private String dir = new String();
-	
-	public LOCReader(String d){
-		dir = d;
-	}
-	
-	public Vector doIt(){
-		Vector data = new Vector();
-		//need directory only!!!!
-		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, dir);
-		fc.setTitle(&quot;Select source directory:&quot;);
-		String sourceDir; 
-		String text = new String();
-		String dummy = new String();
-		if(fc.execute() != fc.IDCANCEL){
-			sourceDir = fc.getChosen();
-			//identify all loc files
-			File path = new File(sourceDir);
-			FileReader in;
-			Extractor ex;
-			String[] files = path.list(&quot;*.loc&quot;, FileBase.LIST_DONT_SORT);
-			for(int i = 0; i&lt;files.length;i++){
-				try{
-					in = new FileReader(sourceDir + &quot;/&quot; + files[i]);
-					text = in.readAll();
-				}catch(Exception e){
-					//Vm.debug(&quot;Problem reading LOC file&quot;);
-				}
-				ex = new Extractor(text, &quot;&lt;name id=\&quot;&quot;, &quot;\&quot;&gt;&quot;, 0, true);
-				dummy = ex.findNext();
-				while(ex.endOfSearch() == false){
-					data.add(dummy);
-					dummy = ex.findNext();
-				}
-			} //for
-		}//if execute
-		return data;
-	}
-}

Deleted: trunk/src/CacheWolf/MSARCSVExporter.java
===================================================================
--- trunk/src/CacheWolf/MSARCSVExporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/MSARCSVExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,68 +0,0 @@
-package CacheWolf;
-import ewe.util.*;
-import ewe.sys.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-
-/**
-*	Class to export the cache database (index) to an CSV File
-*	which can bei easy importet bei MS AutoRoute (testet with AR 2001 German)   
-*   Format of the file:
-*   Name;Breitengrad;L&#228;ngengrad;Typ1;Typ2;Waypoint;Datum;Hyperlink
-*   
-*/
-public class MSARCSVExporter{
-//	TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-	
-	public MSARCSVExporter(Preferences p, Profile prof){
-		pref = p;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-	}
-	
-	public void doIt(){
-		CacheHolder holder;
-		ParseLatLon pll;
-		int symCounter = 0;
-		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
-		fc.setTitle(&quot;Select target file:&quot;);
-		if(fc.execute() != FileChooser.IDCANCEL){
-			File saveTo = fc.getChosenFile();
-			try{
-				PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
-				//Create Header for German Version
-				outp.println(&quot;Name;Breitengrad;L&#228;ngengrad;Typ1;Typ2;Waypoint;Datum;Hyperlink\r&quot;);
-				//loop through database
-				for(int i = 0; i&lt;cacheDB.size(); i++){
-					holder=(CacheHolder)cacheDB.get(i);
-					if(holder.is_black == false &amp;&amp; holder.is_filtered == false){
-						try{
-							holder.readCache(profile.dataDir); // Need this for URL
-						}catch(Exception e){
-							//Vm.debug(&quot;Problem reading cache page&quot;);
-						}
-						pll = new ParseLatLon(holder.LatLon, &quot;.&quot;);
-						pll.parse();
-						outp.print(&quot;\&quot;&quot; + holder.wayPoint + &quot; - &quot; + holder.CacheName + &quot;\&quot;;&quot;);
-						outp.print(pll.getLatDeg().replace('.',',') + &quot;;&quot;);
-						outp.print(pll.getLonDeg().replace('.',',') + &quot;;&quot;);
-						outp.print(&quot;\&quot;&quot; + CacheType.transType(holder.type) + &quot;\&quot;;&quot;);
-						outp.print(&quot;\&quot;&quot; + holder.CacheSize + &quot;\&quot;;&quot;);
-						outp.print(&quot;\&quot;&quot; + holder.wayPoint + &quot;\&quot;;&quot;);
-						outp.print(&quot;\&quot;&quot; + holder.DateHidden + &quot;\&quot;;&quot;);
-						outp.print(&quot;\&quot;&quot; + holder.URL + &quot;\&quot;\r\n&quot;);
-						symCounter++;
-					}//if holder...
-				}//for ... i &lt; cacheDB ...			
-				// overlay section
-				
-				outp.close();
-			}catch(Exception e){
-				//Vm.debug(&quot;Error writing to OVL file!&quot;);
-			}
-		} // if execute
-	}
-}

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/MainMenu.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -8,6 +8,7 @@
 //import ewe.util.*;
 import ewe.io.*;
 import ewe.filechooser.*;
+import exp.*;
 
 /**
 *	This class creates the menu for cachewolf. It is also responsible
@@ -23,8 +24,8 @@
 	private MenuItem downloadmap, kalibmap, importmap;
 	private MenuItem spider, chkVersion;
 	private MenuItem about, wolflang, sysinfo, legend;
-	private MenuItem exportpcx5, exporthtml, exporttop50, exportGPX, exportASC, exportTomTomASC, exportMSARCSV;
-	private MenuItem exportOZI, exportKML, exportTomTomOVL, exportTPL;
+	private MenuItem exportpcx5, exporthtml, exporttop50, exportGPX, exportASC, exportTomTom, exportMSARCSV;
+	private MenuItem exportOZI, exportKML, exportTPL;
 	private MenuItem filtCreate, filtClear, filtInvert, filtSelected, filtBlack;
 	private MenuItem exportGPS, exportCacheMate,mnuSeparator;
 	private MenuItem orgCopy, orgMove, orgDelete;
@@ -48,14 +49,14 @@
 		///////////////////////////////////////////////////////////////////////
 		// subMenu for export, part of &quot;Application&quot; menu below
 		///////////////////////////////////////////////////////////////////////
-		MenuItem[] exitems = new MenuItem[13];
+		MenuItem[] exitems = new MenuItem[12];
 		//Vm.debug(&quot;Hi in MainMenu &quot;+lr);
 		exitems[0] = exporthtml = new MenuItem(MyLocale.getMsg(100,&quot;to HTML&quot;));
 		exitems[1] = exportpcx5 = new MenuItem(MyLocale.getMsg(101,&quot;to PCX5 Mapsource&quot;));
 		exitems[2] = exporttop50 = new MenuItem(MyLocale.getMsg(102,&quot;to TOP50 ASCII&quot;));
 		exitems[3] = exportGPX = new MenuItem(MyLocale.getMsg(103,&quot;to GPX&quot;));
 		exitems[4] = exportASC = new MenuItem(MyLocale.getMsg(104,&quot;to ASC&quot;));
-		exitems[5] = exportTomTomASC = new MenuItem(MyLocale.getMsg(105,&quot;to TomTom ASC&quot;));
+		exitems[5] = exportTomTom = new MenuItem(MyLocale.getMsg(105,&quot;to TomTom&quot;));
 		exitems[6] = exportMSARCSV = new MenuItem(MyLocale.getMsg(106,&quot;to MS AutoRoute CSV&quot;));
 		exitems[7] = exportGPS = new MenuItem(MyLocale.getMsg(122,&quot;to GPS&quot;));
 		if(!(new File(cwd + &quot;/gpsbabel.exe&quot;)).exists()) exitems[7].modifiers = MenuItem.Disabled;
@@ -63,8 +64,7 @@
 		if(!(new File(cwd + &quot;/cmconvert/cmconvert.exe&quot;)).exists()) exitems[8].modifiers = MenuItem.Disabled;
 		exitems[9] = exportOZI = new MenuItem(MyLocale.getMsg(124,&quot;to OZI&quot;));
 		exitems[10] = exportKML = new MenuItem(MyLocale.getMsg(125,&quot;to Google Earth&quot;));
-		exitems[11] = exportTomTomOVL = new MenuItem(MyLocale.getMsg(126,&quot;to TomTom OV2&quot;));
-		exitems[12] = exportTPL = new MenuItem(MyLocale.getMsg(128,&quot;via Template&quot;));
+		exitems[11] = exportTPL = new MenuItem(MyLocale.getMsg(128,&quot;via Template&quot;));
 		Menu exportMenu = new Menu(exitems, MyLocale.getMsg(107,&quot;Export&quot;));
 
 		///////////////////////////////////////////////////////////////////////
@@ -275,23 +275,21 @@
 				Vm.showWait(true);
 				PCX5Exporter pcx = new PCX5Exporter(pref, profile);
 				pcx.doIt(PCX5Exporter.MODE_AUTO);
-				ProgressBarForm pbf = new ProgressBarForm();
-				pbf.display(MyLocale.getMsg(950,&quot;Transfer&quot;),MyLocale.getMsg(951,&quot;Sending to GPS&quot;), null);
+				ProgressBarForm.display(MyLocale.getMsg(950,&quot;Transfer&quot;),MyLocale.getMsg(951,&quot;Sending to GPS&quot;), null);
 				String cwd = File.getProgramDirectory() + &quot;/temp.pcx&quot;;
 				try{
 					ewe.sys.Process p = Vm.exec(&quot;gpsbabel -s -i pcx -f &quot;+ cwd +&quot; -o garmin -F &quot; + pref.garminConn +&quot;:&quot;);
 					Vm.debug(&quot;gpsbabel -s -i pcx -f &quot;+ cwd +&quot; -o garmin -F &quot; + pref.garminConn +&quot;:&quot;);
 					p.waitFor();
 				}catch(IOException ioex){};
-				pbf.clear();
+				ProgressBarForm.clear();
 				Vm.showWait(false);
 			}
 			if(mev.selectedItem == exportCacheMate){
 				Vm.showWait(true);
 				GPXExporter htm = new GPXExporter( pref, profile);
 				htm.doIt(0);
-				ProgressBarForm pbf = new ProgressBarForm();
-				pbf.display(&quot;CMCONVERT&quot;, MyLocale.getMsg(952,&quot;Converting...&quot;), null);
+				ProgressBarForm.display(&quot;CMCONVERT&quot;, MyLocale.getMsg(952,&quot;Converting...&quot;), null);
 				String cwd = new String();
 				cwd = File.getProgramDirectory() + &quot;/temp.gpx&quot;;
 				// add surrounding &quot;
@@ -303,7 +301,7 @@
 				}catch(IOException ioex){
 					//Vm.debug(&quot;Scheint ein Problem zu geben&quot;);
 				};
-				pbf.clear();
+				ProgressBarForm.clear();
 				Vm.showWait(false);
 			}
 			if(mev.selectedItem == filtClear){
@@ -343,9 +341,9 @@
 				ASCExporter asc = new ASCExporter(pref,profile);
 				asc.doIt();
 			}
-			if(mev.selectedItem == exportTomTomASC){
-				TomTomASCExporter asc = new TomTomASCExporter(pref, profile);
-				asc.doIt();
+			if(mev.selectedItem == exportTomTom){
+				TomTomExporter tt = new TomTomExporter();
+				tt.doIt();
 			}
 			if(mev.selectedItem == exportMSARCSV){
 				MSARCSVExporter msar = new MSARCSVExporter(pref,profile);
@@ -363,10 +361,6 @@
 				OziExporter ozi = new OziExporter( pref, profile);
 				ozi.doIt();
 			}
-			if(mev.selectedItem == exportTomTomOVL){
-				TomTomOV2Exporter tomovl = new TomTomOV2Exporter( pref, profile);
-				tomovl.doIt();
-			}
 			if(mev.selectedItem == exportKML){
 				KMLExporter kml = new KMLExporter( pref, profile);
 				kml.doIt();

Deleted: trunk/src/CacheWolf/OVLExporter.java
===================================================================
--- trunk/src/CacheWolf/OVLExporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/OVLExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,89 +0,0 @@
-package CacheWolf;
-import ewe.util.*;
-import ewe.sys.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-
-/**
-*	Class to export the cache database (index) to an ascii overlay file for
-*	the TOP50 map products (mainly available in german speaking countries).
-*/
-public class OVLExporter{
-//	TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
-	Preferences myPreferences;
-	Profile profile;
-	
-	public OVLExporter(Preferences p, Profile prof){
-		myPreferences = p;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-	}
-	
-	public void doIt(){
-		CacheHolder holder;
-		ParseLatLon pll;
-		int symCounter = 1;
-		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
-		fc.setTitle(&quot;Select target file:&quot;);
-		if(fc.execute() != FileChooser.IDCANCEL){
-			File saveTo = fc.getChosenFile();
-			try{
-				PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
-				//symbols section, loop through database
-				//a circle and text per cache is created
-				for(int i = 0; i&lt;cacheDB.size(); i++){
-					holder=(CacheHolder)cacheDB.get(i);
-					if(holder.is_black == false &amp;&amp; holder.is_filtered == false){
-						pll = new ParseLatLon(holder.LatLon,&quot;.&quot;);
-						pll.parse();
-						//the circle!
-						outp.print(&quot;[Symbol &quot;+Convert.toString(symCounter)+&quot;]\r\n&quot;);
-						outp.print(&quot;Typ=6\r\n&quot;);
-						outp.print(&quot;Width=15\r\n&quot;);
-						outp.print(&quot;Height=15\r\n&quot;);
-						outp.print(&quot;Col=1\r\n&quot;);
-						outp.print(&quot;Zoom=1\r\n&quot;);
-						outp.print(&quot;Size=2\r\n&quot;);
-						outp.print(&quot;Area=2\r\n&quot;);
-						outp.print(&quot;XKoord=&quot;+pll.getLonDeg()+&quot;\r\n&quot;);
-						outp.print(&quot;YKoord=&quot;+pll.getLatDeg()+&quot;\r\n&quot;);
-						symCounter++;
-						//the text
-						outp.print(&quot;[Symbol &quot;+Convert.toString(symCounter)+&quot;]\r\n&quot;);
-						outp.print(&quot;Typ=2\r\n&quot;);
-						outp.print(&quot;Col=1\r\n&quot;);
-						outp.print(&quot;Zoom=1\r\n&quot;);
-						outp.print(&quot;Size=2\r\n&quot;);
-						outp.print(&quot;Area=2\r\n&quot;);
-						outp.print(&quot;Font=3\r\n&quot;);
-						outp.print(&quot;Dir=1\r\n&quot;);
-						outp.print(&quot;XKoord=&quot;+Convert.toString(pll.lon2+0.002).replace(',', '.')+&quot;\r\n&quot;);
-						outp.print(&quot;YKoord=&quot;+Convert.toString(pll.lat2+0.001).replace(',', '.')+&quot;\r\n&quot;);
-						outp.print(&quot;Text=&quot;+holder.wayPoint+&quot;\r\n&quot;);
-						symCounter++;
-					}//if holder...
-				}//for ... i &lt; cacheDB ...			
-				// overlay section
-				outp.print(&quot;[Overlay]\r\n&quot;);
-				outp.print(&quot;Symbols=&quot;+Convert.toString(symCounter-1)+&quot;\r\n&quot;);
-				// maplage section
-				outp.print(&quot;[MapLage]\r\n&quot;);
-				outp.print(&quot;MapName=Gesamtes Bundesgebiet (D1000)\r\n&quot;);
-				outp.print(&quot;DimmFc=100\r\n&quot;);
-				outp.print(&quot;ZoomFc=100\r\n&quot;);
-				outp.print(&quot;CenterLat=&quot;+myPreferences.curCentrePt.getLatDeg(CWPoint.CW)+&quot;.00\r\n&quot;);
-				outp.print(&quot;CenterLong=&quot;+myPreferences.curCentrePt.getLonDeg(CWPoint.CW)+&quot;.00\r\n&quot;);
-				outp.print(&quot;RefColor=255\r\n&quot;);
-				outp.print(&quot;RefRad=58\r\n&quot;);
-				outp.print(&quot;RefLine=6\r\n&quot;);
-				outp.print(&quot;RefOn=0\r\n&quot;);
-				outp.print(&quot;\r\n&quot;);
-				
-				outp.close();
-			}catch(Exception e){
-				Vm.debug(&quot;Error writing to OVL file! &quot;+e.toString());
-			}
-		} // if execute
-	}
-}

Deleted: trunk/src/CacheWolf/OziExporter.java
===================================================================
--- trunk/src/CacheWolf/OziExporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/OziExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,112 +0,0 @@
-package CacheWolf;
-import ewe.util.*;
-import ewe.sys.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-
-/**
-*	Class to export the cache database (index) to an TomTom ASC File
-*   Format of the file:
-*   Lon,Lat,&quot;Description&quot;
-*   
-*   Example for one entry:
-*	8.635,50.386,&quot;Adlerhorst&quot;
-*/
-public class OziExporter{
-//	TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-	
-	public OziExporter(Preferences p, Profile prof){
-		pref = p;
-		profile=prof;
-		cacheDB = prof.cacheDB;
-	}
-	
-	public void doIt(){
-		CacheHolder holder;
-		ParseLatLon pll;
-		int symCounter = 0;
-		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
-		fc.setTitle(&quot;Select target file:&quot;);
-		if(fc.execute() != fc.IDCANCEL){
-			File saveTo = fc.getChosenFile();
-			try{
-				PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
-				//header
-				outp.println(&quot;OziExplorer CE Waypoint File Version 1.2&quot;);
-				outp.println(&quot;WGS 84&quot;);
-				outp.println(&quot;Reserved 2&quot;);
-				outp.println(&quot;Reserved 3&quot;);
-				//loop through database
-				for(int i = 0; i&lt;cacheDB.size(); i++){
-					holder=(CacheHolder)cacheDB.get(i);
-					if(holder.is_black == false &amp;&amp; holder.is_filtered == false){
-						pll = new ParseLatLon(holder.LatLon,&quot;.&quot;);
-						pll.parse();
-						// Field 1 : Number - this is the location in the array (max 1000), must be unique, 
-						// usually start at 1 and increment. Can be set to -1 (minus 1) and the number will be auto generated.
-						outp.print(&quot;-1,&quot;);
-						// Field 2 : Name - the waypoint name, use the correct length name to suit the GPS type.
-						outp.print(holder.wayPoint + &quot;,&quot;);
-						// Field 3 : Latitude - decimal degrees.
-						outp.print(pll.getLatDeg()+&quot;,&quot;);
-						// Field 4 : Longitude - decimal degrees.
-						outp.print(pll.getLonDeg()+&quot;,&quot;);
-						// Field 5 : Date - see Date Format below, if blank a preset date will be used
-						outp.print(&quot;,&quot;);
-						// Field 6 : Symbol - 0 to number of symbols in GPS
-						outp.print(&quot;0,&quot;);
-						// Field 7 : Status - always set to 1
-						outp.print(&quot;1,&quot;);
-						// Field 8 : Map Display Format
-						outp.print(&quot;0,&quot;);
-						// Field 9 : Foreground Color (RGB value)
-						outp.print(&quot;0,&quot;);
-						// Field 10 : Background Color (RGB value)
-						outp.print(&quot;16777215,&quot;);
-						// Field 11 : Description (max 40), no commas
-						if (holder.CacheName.length() &lt;= 40){
-							outp.print(holder.CacheName + &quot;,&quot;);
-						}
-						else {
-							outp.print(holder.CacheName.substring(0,40) + &quot;,&quot;);
-						}
-						// Field 12 : Pointer Direction
-						outp.print(&quot;0,&quot;);
-						// Field 13 : Garmin Display Format
-						outp.print(&quot;0,&quot;);
-						// Field 14 : Proximity Distance - 0 is off any other number is valid
-						outp.print(&quot;0,&quot;);
-						// Field 15 : Altitude - in feet (-777 if not valid)
-						outp.print(&quot;-777,&quot;);
-						// Field 16 : Font Size - in points
-						outp.print(&quot;8,&quot;);
-						// Field 17 : Font Style - 0 is normal, 1 is bold.
-						outp.print(&quot;1,&quot;);
-						// Field 18 : Symbol Size - 17 is normal size
-						outp.print(&quot;17,&quot;);
-						// Field 19 : Proximity Symbol Position
-						outp.print(&quot;0,&quot;);
-						// Field 20 : Proximity Time
-						outp.print(&quot;  10.0,&quot;);
-					    // Field 21 : Proximity or Route or Both
-						outp.print(&quot;2,&quot;);
-						// Field 22 : File Attachment Name
-						outp.print(&quot;,&quot;);
-						// Field 23 : Proximity File Attachment Name
-						outp.print(&quot;,&quot;);
-						// Field 24 : Proximity Symbol Name
-						outp.println(&quot; &quot;);
-					}//if holder...
-				}//for ... i &lt; cacheDB ...			
-				// overlay section
-				
-				outp.close();
-			}catch(Exception e){
-				//Vm.debug(&quot;Error writing to OZI file!&quot;);
-			}
-		} // if execute
-	}
-}

Deleted: trunk/src/CacheWolf/PCX5Exporter.java
===================================================================
--- trunk/src/CacheWolf/PCX5Exporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/PCX5Exporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,104 +0,0 @@
-package CacheWolf;
-import ewe.filechooser.*;
-import ewe.io.*;
-import ewe.sys.*;
-import ewe.util.*;
-
-/**
-*	Class to export the cache database into an ascii file that may be imported
-*	ba Mapsource (c) by Garmin.
-*/
-public class PCX5Exporter{
-//	TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-
-	public static int MODE_AUTO = 0;
-	public static int MODE_ASK = 1;
-	
-	public PCX5Exporter(Preferences p, Profile prof){
-		pref = p;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-	}
-
-	
-	public void doIt(int mode){
-		CacheHolder holder = new CacheHolder();
-		String saveStr = new String();
-		String latlonstr = new String();
-		String dummy = new String();
-		String cwd = new String();
-		cwd = File.getProgramDirectory();
-		File saveTo = new File(cwd + &quot;/temp.pcx&quot;);
-		if(mode == MODE_ASK) {
-			FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
-			fc.setTitle(&quot;Select target file:&quot;);
-			if(fc.execute() != fc.IDCANCEL) saveTo = fc.getChosenFile();
-		}
-		try{
-			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
-			outp.print(&quot;H  SOFTWARE NAME &amp; VERSION\n&quot;);
-			outp.print(&quot;I  PCX5 2.09\n&quot;);
-			outp.print(&quot;\n&quot;);
-			outp.print(&quot;H  R DATUM                IDX DA            DF            DX            DY            DZ\n&quot;);
-			outp.print(&quot;M  G WGS 84               121 +0.000000e+00 +0.000000e+00 +0.000000e+00 +0.000000e+00 +0.000000e+00\n&quot;);
-			outp.print(&quot;\n&quot;);
-			outp.print(&quot;H  COORDINATE SYSTEM\n&quot;);
-			outp.print(&quot;U  LAT LON DM\n&quot;);
-			outp.print(&quot;\n&quot;);
-			outp.print(&quot;H  IDNT   LATITUDE  LONGITUDE      DATE      TIME     ALT   DESCRIPTION                              PROXIMITY     SYMBOL ;waypts\r\n&quot;);
-			
-			for(int i = 0; i&lt;cacheDB.size(); i++){
-				holder=(CacheHolder)cacheDB.get(i);
-				if(holder.is_black == false &amp;&amp; holder.is_filtered == false){
-					  //Vm.debug(Convert.toString(i));
-					  //dummy = holder.CacheName;
-					  //dummy = replace(dummy, &quot;,&quot;, &quot;&quot;);
-					  //dummy = Reducer.convert(dummy, true, 6);
-					  saveStr = &quot;W  &quot; + holder.wayPoint + &quot; &quot;;
-					  latlonstr = replace(holder.LatLon, &quot;&#176;&quot;, &quot; &quot;);
-					  latlonstr = replace(latlonstr, &quot; &quot;, &quot;&quot;);
-					  latlonstr = replace(latlonstr, &quot;E&quot;, &quot; E&quot;);
-					  latlonstr = replace(latlonstr, &quot;W&quot;, &quot; W&quot;);
-					  saveStr = saveStr + latlonstr + &quot;     &quot;;
-					  latlonstr = holder.CacheName;
-					  // has 42 characters
-					  while(latlonstr.length() &lt; 41){
-						  latlonstr = latlonstr + &quot; &quot;;
-					  }
-					  if(latlonstr.length() &gt; 41){
-						  latlonstr = latlonstr.substring(0,40);
-					  }
-					  saveStr = saveStr + &quot;01-JAN-04 01:00:00 -0000 &quot; + latlonstr + &quot; 0.000000e+000  &quot;;
-					  if(holder.is_found){
-						saveStr = saveStr +&quot;8256\r\n&quot;;
-					  } else {
-						saveStr = saveStr +&quot;8255\r\n&quot;;
-					  }
-					  outp.print(saveStr);
-				  } //if
-				} // for
-				outp.close();
-		} catch (Exception e){
-			//Vm.debug(&quot;Problem exporting to pcx5 file&quot;);
-		}
-	} //end of method
-		
-	private String replace( String s, String f, String r )
-	{
-	   if (s == null)  return s;
-	   if (f == null)  return s;
-	   if (r == null)  r = &quot;&quot;;
-	
-	   int index01 = s.indexOf( f );
-	   while (index01 != -1)
-	   {
-		  s = s.substring(0,index01) + r + s.substring(index01+f.length());
-		  index01 += r.length();
-		  index01 = s.indexOf( f, index01 );
-	   }
-	   return s;
-	}
-}

Deleted: trunk/src/CacheWolf/TPLExporter.java
===================================================================
--- trunk/src/CacheWolf/TPLExporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/TPLExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,226 +0,0 @@
-/*
-    CacheWolf is a software for PocketPC, Win and Linux that 
-    enables paperless caching. 
-    It supports the sites geocaching.com and opencaching.de
-    
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-		<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation version 2 of the License.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
-
-package CacheWolf;
-
-import HTML.Template;
-import ewe.filechooser.FileChooser;
-import ewe.io.*;
-import ewe.sys.*;
-import ewe.ui.ProgressBarForm;
-import ewe.util.*;
-import com.stevesoft.ewe_pat.*;
-
-/**
- * @author Kalle
- * class to export cachedata using a template
- */
-class TplFilter implements HTML.Tmpl.Filter
-{
-	private int type=SCALAR;
-	private String newLine=&quot;\n&quot;;
-	TextCodec codec = new AsciiCodec();
-	String badChars;
-	String decSep = &quot;.&quot;;
-	
-
-	public TplFilter(){
-		codec = new AsciiCodec(AsciiCodec.STRIP_CR);
-		return;
-	}
-	
-	public int format() {
-		return this.type;
-	}
-	
-	public String parse(String t) {
-		//Vm.debug(t);
-		Regex rex, rex1;
-		String param, value;
-		// Filter newlines 
-		rex = new Regex(&quot;(?m)\n$&quot;,&quot;&quot;);
-		t = rex.replaceAll(t);
-
-		// Filter comments &lt;#-- and --&gt;
-		rex = new Regex(&quot;&lt;#--.*--&gt;&quot;,&quot;&quot;);
-		t = rex.replaceAll(t);
-
-		// replace &lt;br&gt; or &lt;br /&gt; with newline
-		rex = new Regex(&quot;&lt;br.*&gt;&quot;,&quot;&quot;);
-		rex.search(t);
-		if (rex.didMatch()){
-			t = rex.replaceAll(t);
-			t += newLine;
-		}
-		
-		// search for parameters
-		rex = new Regex(&quot;(?i)&lt;tmpl_par.*&gt;&quot;);
-		rex.search(t);
-		if (rex.didMatch()){
-			// get parameter
-			rex1 = new Regex(&quot;(?i)name=\&quot;(.*)\&quot;\\svalue=\&quot;(.*)\&quot;[?\\s&gt;]&quot;);
-			rex1.search(t);
-			param = rex1.stringMatched(1);
-			value = rex1.stringMatched(2);
-			//Vm.debug(&quot;param=&quot; + param + &quot;\nvalue=&quot; + value);
-			//clear t, because we allow only one parameter per line
-			t = &quot;&quot;;
-			
-			// get the values
-			if (param.equals(&quot;charset&quot;)) {
-				if (value.equals(&quot;ASCII&quot;)) codec = new AsciiCodec();
-				if (value.equals(&quot;UTF8&quot;)) codec = new JavaUtf8Codec();
-			}
-			if (param.equals(&quot;badchars&quot;)) {
-				badChars = value;
-			}
-			if (param.equals(&quot;newline&quot;)){
-				newLine = &quot;&quot;;
-				if (value.indexOf(&quot;CR&quot;) &gt;= 0) newLine += &quot;\r&quot;;
-				if (value.indexOf(&quot;LF&quot;) &gt;= 0) newLine += &quot;\n&quot;;
-			}
-			if (param.equals(&quot;decsep&quot;)) {
-				decSep = value;
-			}
-
-
-		}
-		return t;
-	}
-		
-	
-	public String [] parse(String [] t) {
-		throw new UnsupportedOperationException();
-	}
-}
- 
-
-public class TPLExporter {
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-	String tplFile;
-
-	public TPLExporter(Preferences p, Profile prof, String tpl){
-		pref = p;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-		tplFile = tpl;
-	}
-	
-	public void doIt(){
-		CacheHolder holder;
-		ProgressBarForm pbf = new ProgressBarForm();
-		ewe.sys.Handle h = new ewe.sys.Handle();
-		Vector cache_index = new Vector();
-		Hashtable varParams;
-		TplFilter myFilter;
-
-		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
-		fc.setTitle(&quot;Select target file:&quot;);
-		if(fc.execute() == FileChooser.IDCANCEL) return;
-		File saveTo = fc.getChosenFile();
-		
-		int counter = 0;
-		for(int i = 0; i&lt;cacheDB.size();i++){
-			holder = (CacheHolder)cacheDB.get(i);
-			if(holder.is_black == false &amp;&amp; holder.is_filtered == false) counter++;
-		}
-		pbf.showMainTask = false;
-		pbf.setTask(h,&quot;Exporting ...&quot;);
-		pbf.exec();
-		
-		Hashtable args = new Hashtable();
-		myFilter = new TplFilter();
-		//args.put(&quot;debug&quot;, &quot;true&quot;);
-		args.put(&quot;filename&quot;, tplFile);
-		args.put(&quot;case_sensitive&quot;, &quot;true&quot;);
-		args.put(&quot;loop_context_vars&quot;, Boolean.TRUE);
-		args.put(&quot;max_includes&quot;, new Integer(5));
-		args.put(&quot;filter&quot;, myFilter);
-		try {
-			Template tpl = new Template(args);
-
-			for(int i = 0; i&lt;counter;i++){
-				holder = (CacheHolder)cacheDB.get(i);
-				h.progress = (float)i/(float)counter;
-				h.changed();
-				if(holder.is_black == false &amp;&amp; holder.is_filtered == false){
-					try{
-						holder.readCache(profile.dataDir);
-					}catch(Exception e){
-						Vm.debug(&quot;Problem reading cache page&quot;);
-					}
-					try {
-						CWPoint point = new CWPoint(holder.LatLon, CWPoint.CW);
-						Regex dec = new Regex(&quot;[,.]&quot;,myFilter.decSep);
-						varParams = new Hashtable();
-						varParams.put(&quot;TYPE&quot;, CacheType.transType(holder.type));
-						varParams.put(&quot;SHORTTYPE&quot;, CacheType.transType(holder.type).substring(0,1));
-						varParams.put(&quot;SIZE&quot;, holder.CacheSize);
-						varParams.put(&quot;SHORTSIZE&quot;, holder.CacheSize.substring(0,1));
-						varParams.put(&quot;WAYPOINT&quot;, holder.wayPoint);
-						if (myFilter.badChars != null) {
-							Regex rex = new Regex(&quot;[&quot;+myFilter.badChars+&quot;]&quot;,&quot;&quot;);
-							varParams.put(&quot;NAME&quot;, rex.replaceAll(holder.CacheName));
-						}
-						else {
-							varParams.put(&quot;NAME&quot;, holder.CacheName);
-						}
-						varParams.put(&quot;OWNER&quot;, holder.CacheOwner);
-						varParams.put(&quot;DIFFICULTY&quot;, dec.replaceAll(holder.hard));
-						varParams.put(&quot;TERRAIN&quot;, dec.replaceAll(holder.terrain));
-						varParams.put(&quot;DISTANCE&quot;, dec.replaceAll(holder.distance));
-						varParams.put(&quot;BEARING&quot;, holder.bearing);
-						varParams.put(&quot;LATLON&quot;, holder.LatLon);
-						varParams.put(&quot;LAT&quot;, dec.replaceAll(point.getLatDeg(CWPoint.DD)));
-						varParams.put(&quot;LON&quot;, dec.replaceAll(point.getLonDeg(CWPoint.DD)));
-						varParams.put(&quot;STATUS&quot;, holder.CacheStatus);
-						varParams.put(&quot;DATE&quot;, holder.DateHidden);
-						varParams.put(&quot;URL&quot;, holder.URL);
-						cache_index.add(varParams);
-					}catch(Exception e){
-						Vm.debug(&quot;Problem getting Parameter, Cache: &quot; + holder.wayPoint);
-						e.printStackTrace();
-					}
-				}
-			}
-
-			tpl.setParam(&quot;cache_index&quot;, cache_index);
-			PrintWriter detfile; 
-			FileWriter fw = new FileWriter(saveTo);
-			fw.codec = myFilter.codec;
-			detfile = new PrintWriter(new BufferedWriter(fw));
-			tpl.printTo(detfile);
-			//detfile.print(tpl.output());
-			detfile.close();
-		} catch (Exception e) {
-			e.printStackTrace();
-		}
-		pbf.exit(0);
-	}
-
-
-}

Deleted: trunk/src/CacheWolf/TomTomASCExporter.java
===================================================================
--- trunk/src/CacheWolf/TomTomASCExporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/TomTomASCExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,57 +0,0 @@
-package CacheWolf;
-import ewe.util.*;
-import ewe.sys.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-
-/**
-*	Class to export the cache database (index) to an TomTom ASC File
-*   Format of the file:
-*   Lon,Lat,&quot;Description&quot;
-*   
-*   Example for one entry:
-*	8.635,50.386,&quot;Adlerhorst&quot;
-*/
-public class TomTomASCExporter{
-//	TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-	
-	public TomTomASCExporter(Preferences p, Profile prof){
-		pref = p;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-	}
-	
-	public void doIt(){
-		CacheHolder holder;
-		ParseLatLon pll;
-		int symCounter = 0;
-		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
-		fc.setTitle(&quot;Select target file:&quot;);
-		if(fc.execute() != fc.IDCANCEL){
-			File saveTo = fc.getChosenFile();
-			try{
-				PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
-				//loop through database
-				for(int i = 0; i&lt;cacheDB.size(); i++){
-					holder=(CacheHolder)cacheDB.get(i);
-					if(holder.is_black == false &amp;&amp; holder.is_filtered == false){
-						pll = new ParseLatLon(holder.LatLon, &quot;.&quot;);
-						pll.parse();
-						outp.print(pll.getLonDeg()+&quot;,&quot;);
-						outp.print(pll.getLatDeg()+&quot;,&quot;);
-						outp.println(&quot;\&quot;&quot; + holder.CacheName.replace(',',' ') + &quot;\&quot;\r&quot;);
-						symCounter++;
-					}//if holder...
-				}//for ... i &lt; cacheDB ...			
-				// overlay section
-				
-				outp.close();
-			}catch(Exception e){
-				//Vm.debug(&quot;Error writing to OVL file!&quot;);
-			}
-		} // if execute
-	}
-}

Deleted: trunk/src/CacheWolf/TomTomOV2Exporter.java
===================================================================
--- trunk/src/CacheWolf/TomTomOV2Exporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/CacheWolf/TomTomOV2Exporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -1,134 +0,0 @@
-package CacheWolf;
-import ewe.ui.mChoice;
-import ewe.util.*;
-import ewe.io.*;
-import ewe.filechooser.*;
-import ewe.sys.*;
-
-/**
-*
-*	Class to export the cache database (index) to an TomTom OV2 File
-*
-**/
-public class TomTomOV2Exporter{
-//	TODO Exportanzahl anpassen: Bug: 7351
-	Vector cacheDB;
-	Preferences pref;
-	Profile profile;
-	
-	public TomTomOV2Exporter(Preferences p, Profile prof){
-		pref = p;
-		profile=prof;
-		cacheDB = profile.cacheDB;
-	}
-	
-	public void doIt(){
-		CacheHolder holder;
-		ParseLatLon pll;
-		int symCounter = 0;
-		double latlon;
-		int a,b,c,d,data;
-		RandomAccessFile outp;
-		File dfile; 
-		String[] wayType = {&quot;Custom&quot;, &quot;Traditional&quot;, &quot;Multi&quot;, &quot;Virtual&quot;, &quot;Letterbox&quot;, &quot;Event&quot;, &quot;Mega Event&quot;, &quot;Mystery&quot;, &quot;Webcam&quot;, &quot;Locationless&quot;, &quot;CITO&quot;, &quot;Earthcache&quot;, &quot;Parking&quot;, &quot;Stage&quot;, &quot;Question&quot;, &quot;Final&quot;,&quot;Trailhead&quot;,&quot;Reference&quot;};
-		String ctype = &quot;&quot;;
-		//need directory only!!!!
-		String dummy = new String();
-		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, profile.dataDir);
-		fc.setTitle(&quot;Select Tomtom Map directory:&quot;);
-		String targetDir;
-		if(fc.execute() != fc.IDCANCEL){
-			targetDir = fc.getChosen();
-			try{
-				//loop through type
-				for(int j = 0; j &lt;= 15; j++){
-					switch (j){
-						case 0: ctype = &quot;0&quot;; break;
-						case 1: ctype = &quot;2&quot;; break;
-						case 2: ctype = &quot;3&quot;; break;
-						case 3: ctype = &quot;4&quot;; break;
-						case 4: ctype = &quot;5&quot;; break;
-						case 5: ctype = &quot;6&quot;; break;
-						case 6: ctype = &quot;453&quot;; break;
-						case 7: ctype = &quot;8&quot;; break;
-						case 8: ctype = &quot;11&quot;; break;
-						case 9: ctype = &quot;12&quot;; break;
-						case 10: ctype = &quot;13&quot;; break;
-						case 11: ctype = &quot;137&quot;; break;
-						case 12: ctype = &quot;50&quot;;break;
-						case 13: ctype = &quot;51&quot;;break;
-						case 14: ctype = &quot;52&quot;;break;
-						case 15: ctype = &quot;53&quot;;break;
-						case 16: ctype = &quot;54&quot;;break;
-						case 17: ctype = &quot;55&quot;;break;
-					} 
-					dfile = new File(targetDir + &quot;/GC-&quot; + wayType[j] + &quot;.ov2&quot;);
-					dfile.delete();
-					outp =  new RandomAccessFile(targetDir + &quot;/GC-&quot; + wayType[j] + &quot;.ov2&quot;,&quot;rw&quot;);
-					//loop through database
-					for(int i = 0; i&lt;cacheDB.size(); i++){
-						holder=(CacheHolder)cacheDB.get(i);
-						if( ctype.equals(holder.type) &amp;&amp; holder.is_black == false &amp;&amp; holder.is_filtered == false){
-							pll = new ParseLatLon(holder.LatLon);
-							pll.parse();
-							d = 2;
-							outp.writeByte((byte)d);
-							data = holder.wayPoint.length()+holder.CacheName.length()+holder.CacheOwner.length()+holder.hard.length()+holder.terrain.length()+holder.CacheSize.length()+27;
-							d = 0;
-							c = data / 65536;
-							b = (data - c *65536) / 256;
-							a = (data - c * 65536 - b * 256);
-							outp.writeByte((byte)a);
-							outp.writeByte((byte)b);
-							outp.writeByte((byte)c);
-							outp.writeByte((byte)d);
-							latlon = Float.valueOf(pll.getLonDeg()).floatValue();
-							latlon *=100000;
-							data = (int) latlon;
-							d = 0;
-							c = data / 65536;
-							b = (data - c *65536) / 256;
-							a = (data - c * 65536 - b * 256);
-							outp.writeByte((byte)a);
-							outp.writeByte((byte)b);
-							outp.writeByte((byte)c);
-							outp.writeByte((byte)d);
-							latlon = Float.valueOf(pll.getLatDeg()).floatValue();
-							latlon *=100000;
-							data = (int) latlon;
-							d = 0;
-							c = data / 65536;
-							b = (data - c *65536) / 256;
-							a = (data - c * 65536 - b * 256);
-							outp.writeByte((byte)a);
-							outp.writeByte((byte)b);
-							outp.writeByte((byte)c);
-							outp.writeByte((byte)d);
-							outp.writeBytes(holder.wayPoint);
-							outp.writeBytes(&quot; - &quot;);
-							outp.writeBytes(holder.CacheName);
-							outp.writeBytes(&quot; by &quot;);
-							outp.writeBytes(holder.CacheOwner);
-							//Wenn Leerzeichen am Ende von Cache.Owner entfernt: 
-							//Hier wieder einf&#252;gen
-							//und data = holder.wayPoint.length()+holder.CacheName.length()+.....
-							//wider um 1 erh&#246;hen
-							outp.writeBytes(&quot;- &quot;);             
-							outp.writeBytes(holder.hard);
-							outp.writeBytes(&quot;/&quot;);
-							outp.writeBytes(holder.terrain);
-							outp.writeBytes(&quot; - &quot;);
-							outp.writeBytes(holder.CacheSize);
-							outp.writeByte((byte)d);
-							symCounter++;
-						}//if holder...
-					}//for ... i &lt; cacheDB ...			
-					// overlay section
-					outp.close();
-				}
-			}catch(Exception e){
-				//Vm.debug(&quot;Error writing to OVL file!&quot;);
-			}
-		} // if execute
-	}
-}

Copied: trunk/src/exp/ASCExporter.java (from rev 367, trunk/src/CacheWolf/ASCExporter.java)
===================================================================
--- trunk/src/CacheWolf/ASCExporter.java	2007-01-08 02:25:38 UTC (rev 367)
+++ trunk/src/exp/ASCExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,37 @@
+package exp;
+import CacheWolf.*;
+
+/**
+*	Class to export cache database to an ASCII (CSV!) file.
+*   This file can be used by I2C's POI Converter to generate
+*   POIs for different routing programmes, especially for
+*	Destinator ;-) !
+*/
+public class ASCExporter extends Exporter{
+	
+	public ASCExporter(){
+		super();
+		this.setMask(&quot;*.csv&quot;);
+		this.setHowManyParams(LAT_LON);
+	}
+	
+	public ASCExporter(Preferences p,Profile prof){
+		this();
+	}
+	
+	public String record (CacheHolder holder, String lat, String lon){
+		StringBuffer strBuf = new StringBuffer(100);
+		String dummy;
+		dummy = holder.CacheName;
+		dummy = dummy.replace(',', ' ');
+		strBuf.append(dummy);
+		strBuf.append(&quot;,&quot;);
+		strBuf.append(dummy);
+		strBuf.append(&quot;,&quot;);
+		strBuf.append(lon);
+		strBuf.append(&quot;,&quot;);
+		strBuf.append(lat);
+		strBuf.append(&quot;,,,,\r\n&quot;);
+		return strBuf.toString();
+	}
+}

Added: trunk/src/exp/Exporter.java
===================================================================
--- trunk/src/exp/Exporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/exp/Exporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,185 @@
+package exp;
+
+import CacheWolf.*;
+import CacheWolf.CWPoint;
+import ewe.sys.*;
+import ewe.filechooser.FileChooser;
+import ewe.io.BufferedWriter;
+import ewe.io.File;
+import ewe.io.FileWriter;
+import ewe.io.PrintWriter;
+import ewe.ui.ProgressBarForm;
+import ewe.util.*;
+
+/**
+ * @author Kalle
+ * Base class for exporter, handles basic things like selecting
+ * outputfile, display a counter etc.
+ * 
+ */
+public class Exporter {
+	final static int TMP_FILE = 0;
+	final static int ASK_FILE = 1;
+	
+	final static int NO_PARAMS 	= 0;
+	final static int LAT_LON 	= 1;
+	final static int COUNT 		= 2;
+	
+	Vector cacheDB;
+	Preferences pref;
+	Profile profile;
+	String mask = &quot;*.*&quot;;
+	String tmpFileName;
+	char decimalSeparator='.';
+	boolean needCacheDetails = false;
+	int howManyParams = 0;
+	
+	public Exporter() {
+		profile = Global.getProfile();
+		pref = Global.getPref();
+		cacheDB = profile.cacheDB;
+		howManyParams = LAT_LON;
+	}
+	
+	public void doIt(){
+		this.doIt(ASK_FILE);
+	}
+
+	
+	public void doIt(int variant){
+		File outFile;
+		String str;
+		CacheHolder holder;
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+		CWPoint coords = new CWPoint();
+
+
+		if (variant == ASK_FILE) {
+			outFile = getOutputFile();
+			if (outFile == null) return;
+		} else {
+			outFile = new File(tmpFileName);
+		}
+
+		pbf.showMainTask = false;
+		pbf.setTask(h,&quot;Exporting ...&quot;);
+		pbf.exec();
+
+		int counter = 0;
+		int expCount = 0;
+		for(int i = 0; i&lt;cacheDB.size();i++){
+			holder = (CacheHolder)cacheDB.get(i);
+			if(holder.is_black == false &amp;&amp; holder.is_filtered == false) counter++;
+		}
+
+		try{
+			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(outFile)));
+			str = this.header();
+			if (str != null) outp.print(str);
+			for(int i = 0; i&lt;cacheDB.size(); i++){
+				holder=(CacheHolder)cacheDB.get(i);
+				if(holder.is_black == false &amp;&amp; holder.is_filtered == false){
+					expCount++;
+					h.progress = (float)expCount/(float)counter;
+					h.changed();
+					if (needCacheDetails) holder.readCache(profile.dataDir);
+					switch (this.howManyParams) {
+					case NO_PARAMS: 
+						str = record(holder);
+						break;
+					case LAT_LON:	
+						coords.set(holder.LatLon, CWPoint.CW);
+						str = record(holder, coords.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+						             		 coords.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+						break;
+					case LAT_LON|COUNT: 
+						coords.set(holder.LatLon, CWPoint.CW);
+						str = record(holder, coords.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+											 coords.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator),
+											 i);
+						break;
+					default:
+						str = null;
+						break;
+					}
+					if (str != null) outp.print(str);
+				}//if
+			}//for
+			switch (this.howManyParams &amp; COUNT) {
+			case NO_PARAMS: 
+				str = trailer();
+				break;
+			case COUNT:
+				str = trailer(counter);
+				break;
+			default:
+				str = null;
+				break;
+			}
+			if (str != null) outp.print(str);
+			outp.close();
+			pbf.exit(0);
+		}catch (Exception e){
+			Vm.debug(&quot;Problem writing to file! &quot;+e.toString());
+		}//try
+	}
+	
+	public void setMask(String mask){
+		this.mask = mask;
+	}
+	
+	public void setDecimalSeparator (char sep){
+		this.decimalSeparator = sep;
+	}
+	
+	public void setNeedCacheDetails(boolean how){
+		this.needCacheDetails = how;
+	}
+	
+	public void setHowManyParams(int paramBits){
+		this.howManyParams = paramBits;
+	}
+	
+	public void setTmpFileName(String fName){
+		this.tmpFileName = fName;
+	}
+
+	
+	public File getOutputFile (){
+		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
+		fc.setTitle(&quot;Select target file:&quot;);
+		fc.addMask(mask);
+		if(fc.execute() != FileChooser.IDCANCEL){
+			return  fc.getChosenFile();
+		} else {
+			return null;
+		}
+	}
+		
+	public String header () {
+		return null;
+	}
+	
+	public String record(CacheHolder ch){
+		return null;
+	}
+
+	public String record(CacheHolder ch, String lat, String lon){
+		return null;
+	}
+	
+	public String record(CacheHolder ch, String lat, String lon, int count){
+		return null;
+	}
+	
+	public String trailer(){
+		return null;
+	}
+	
+	public String trailer(int total){
+		return null;
+	}
+
+
+}

Copied: trunk/src/exp/GPXExporter.java (from rev 367, trunk/src/CacheWolf/GPXExporter.java)
===================================================================
--- trunk/src/CacheWolf/GPXExporter.java	2007-01-08 02:25:38 UTC (rev 367)
+++ trunk/src/exp/GPXExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,97 @@
+package exp;
+import ewe.sys.*;
+import ewe.io.File;
+import CacheWolf.*;
+/**
+*	Class to export the cache database to a GPX file with gc.com
+*	extensions.&lt;br&gt;
+*	Export of logs is not that nice. The cause is that CacheWolf does not spider
+*	logs individually, rather all logs as a single entity.
+*	ClassID = 2000
+*/
+public class GPXExporter extends Exporter{
+	
+	public GPXExporter(){
+		super();
+		this.setMask(&quot;*.gpx&quot;);
+		this.setNeedCacheDetails(true);
+		this.setHowManyParams(LAT_LON);
+		this.setTmpFileName(File.getProgramDirectory() + &quot;/temp.gpx&quot;);
+	}
+	
+	public GPXExporter(Preferences p, Profile prof){
+		super();
+		this.setMask(&quot;*.gpx&quot;);
+		this.setNeedCacheDetails(true);
+		this.setHowManyParams(LAT_LON);
+		this.setTmpFileName(File.getProgramDirectory() + &quot;/temp.gpx&quot;);
+	}
+	
+	public String header() {
+		StringBuffer strBuf = new StringBuffer(200);
+		Time tim = new Time();
+		
+		strBuf.append(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;\r\n&quot;);
+		strBuf.append(&quot;&lt;gpx xmlns:xsd=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema\">http://www.w3.org/2001/XMLSchema\</A>&quot; xmlns:xsi=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance\">http://www.w3.org/2001/XMLSchema-instance\</A>&quot; version=\&quot;1.0\&quot; creator=\&quot;Groundspeak Pocket Query\&quot; xsi:schemaLocation=\&quot;<A HREF="http://www.topografix.com/GPX/1/0">http://www.topografix.com/GPX/1/0</A> <A HREF="http://www.topografix.com/GPX/1/0/gpx.xsd">http://www.topografix.com/GPX/1/0/gpx.xsd</A> <A HREF="http://www.groundspeak.com/cache/1/0">http://www.groundspeak.com/cache/1/0</A> <A HREF="http://www.groundspeak.com/cache/1/0/cache.xsd\">http://www.groundspeak.com/cache/1/0/cache.xsd\</A>&quot; xmlns=\&quot;<A HREF="http://www.topografix.com/GPX/1/0\">http://www.topografix.com/GPX/1/0\</A>&quot;&gt;\r\n&quot;);
+		strBuf.append(&quot;  &lt;desc&gt;Geocache file generated by CacheWolf&lt;/desc&gt;\r\n&quot;);
+		strBuf.append(&quot;  &lt;author&gt;CacheWolf&lt;/author&gt;\r\n&quot;);
+		strBuf.append(&quot;  &lt;email&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">test at test.com</A>&lt;/email&gt;\r\n&quot;);
+		tim = tim.setFormat(&quot;yyyy-MM-dd&quot;);
+		tim = tim.setToCurrentTime();
+		strBuf.append(&quot; &lt;time&gt;&quot;+tim.toString()+&quot;T00:00:00.0000000-07:00&lt;/time&gt;\r\n&quot;);
+
+		return strBuf.toString();
+	}
+	
+	public String record(CacheHolder ch, String lat, String lon) {
+		StringBuffer strBuf = new StringBuffer(1000);
+		Time tim = new Time();
+
+		try{
+			strBuf.append(&quot;  &lt;wpt lat=\&quot;&quot;+lat+&quot;\&quot; lon=\&quot;&quot;+lon+&quot;\&quot;&gt;\r\n&quot;);
+			if (ch.DateHidden.length()&gt; 0){
+				tim.parse(ch.DateHidden, &quot;M/d/y&quot;);
+			}
+			else {
+				tim.setText(&quot;2000-01-01&quot;);
+			}
+			strBuf.append(&quot;    &lt;time&gt;&quot;+tim.toString()+&quot;T00:00:00.0000000-07:00&lt;/time&gt;\r\n&quot;);
+			strBuf.append(&quot;    &lt;name&gt;&quot;+ch.wayPoint+&quot;&lt;/name&gt;\r\n&quot;);
+			strBuf.append(&quot;    &lt;desc&gt;&quot;+SafeXML.cleanGPX(ch.CacheName)+&quot; by &quot;+SafeXML.cleanGPX(ch.CacheOwner)+&quot;&lt;/desc&gt;\r\n&quot;);
+			strBuf.append(&quot;    &lt;url&gt;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot;+ch.wayPoint+&quot;&amp;Submit6=Find&lt;/url&gt;\r\n&quot;);
+			strBuf.append(&quot;    &lt;urlname&gt;&quot;+SafeXML.cleanGPX(ch.CacheName)+&quot; by &quot;+SafeXML.cleanGPX(ch.CacheOwner)+&quot;&lt;/urlname&gt;\r\n&quot;);
+			strBuf.append(&quot;    &lt;sym&gt;Geocache&lt;/sym&gt;\r\n&quot;);
+			strBuf.append(&quot;    &lt;type&gt;Geocache|&quot;+CacheType.transType(ch.type)+&quot;&lt;/type&gt;\r\n&quot;);
+			String dummyAvailable = ch.is_available ? &quot;True&quot;:&quot;False&quot;;
+			String dummyArchived = ch.is_archived ? &quot;True&quot;:&quot;False&quot;;
+			strBuf.append(&quot;    &lt;groundspeak:cache available=\&quot;&quot;+ dummyAvailable + &quot;\&quot; archived=\&quot;&quot; + dummyArchived+ &quot;\&quot; xmlns:groundspeak=\&quot;<A HREF="http://www.groundspeak.com/cache/1/0\">http://www.groundspeak.com/cache/1/0\</A>&quot;&gt;\r\n&quot;);
+			strBuf.append(&quot;      &lt;groundspeak:name&gt;&quot;+SafeXML.cleanGPX(ch.CacheName)+&quot;&lt;/groundspeak:name&gt;\r\n&quot;);
+			strBuf.append(&quot;      &lt;groundspeak:placed_by&gt;&quot;+SafeXML.cleanGPX(ch.CacheOwner)+&quot;&lt;/groundspeak:placed_by&gt;\r\n&quot;);
+			strBuf.append(&quot;      &lt;groundspeak:owner&gt;&quot;+SafeXML.cleanGPX(ch.CacheOwner)+&quot;&lt;/groundspeak:owner&gt;\r\n&quot;);
+			strBuf.append(&quot;      &lt;groundspeak:type&gt;&quot;+CacheType.transType(ch.type)+&quot;&lt;/groundspeak:type&gt;\r\n&quot;);
+			strBuf.append(&quot;      &lt;groundspeak:container&gt;&quot;+ch.CacheSize+&quot;&lt;/groundspeak:container&gt;\r\n&quot;);
+			strBuf.append(&quot;      &lt;groundspeak:difficulty&gt;&quot;+ch.hard.replace(',','.')+&quot;&lt;/groundspeak:difficulty&gt;\r\n&quot;);
+			strBuf.append(&quot;      &lt;groundspeak:terrain&gt;&quot;+ch.terrain.replace(',','.')+&quot;&lt;/groundspeak:terrain&gt;\r\n&quot;);
+			String dummyHTML = ch.is_HTML ? &quot;True&quot;:&quot;False&quot;;
+			strBuf.append(&quot;      &lt;groundspeak:long_description html=\&quot;&quot; + dummyHTML + &quot;\&quot;&gt;\r\n&quot;);
+			strBuf.append(&quot;      &quot;+SafeXML.cleanGPX(ch.LongDescription));
+			strBuf.append(&quot;      \n&lt;/groundspeak:long_description&gt;\r\n&quot;);
+			strBuf.append(&quot;	  &lt;groundspeak:encoded_hints&gt;&quot;+SafeXML.cleanGPX(Common.rot13(ch.Hints))+&quot;&lt;/groundspeak:encoded_hints&gt;\r\n&quot;);
+			strBuf.append(&quot;      &lt;groundspeak:logs&gt;\r\n&quot;);
+			strBuf.append(&quot;      &lt;/groundspeak:logs&gt;\r\n&quot;);
+			strBuf.append(&quot;      &lt;groundspeak:travelbugs /&gt;\r\n&quot;);
+			strBuf.append(&quot;    &lt;/groundspeak:cache&gt;\r\n&quot;);
+			strBuf.append(&quot;  &lt;/wpt&gt;\r\n&quot;);
+		}catch(Exception e){
+			e.printStackTrace();
+			return null;
+		}//try
+
+		return strBuf.toString();
+	}
+	
+	public String trailer() {
+		return &quot;&lt;/gpx&gt;&quot;;
+	}
+	
+}

Copied: trunk/src/exp/HTMLExporter.java (from rev 374, trunk/src/CacheWolf/HTMLExporter.java)
===================================================================
--- trunk/src/CacheWolf/HTMLExporter.java	2007-01-09 22:12:11 UTC (rev 374)
+++ trunk/src/exp/HTMLExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,379 @@
+package exp;
+import CacheWolf.*;
+import ewe.util.*;
+import ewe.sys.*;
+import ewe.io.*;
+import ewe.ui.*;
+import ewe.filechooser.*;
+import HTML.*;
+
+/**
+*	Class to export cache information to individual HTML files.&lt;br&gt;
+*	It uses the HTML package to parse template files. This makes the export
+*	very flexible; enabling the user to customise the HTML files according
+*	to thier liking.
+*/
+public class HTMLExporter{
+//	TODO Exportanzahl anpassen: Bug: 7351
+	Vector cacheDB;
+	Preferences pref;
+	Profile profile;
+	String [] template_init_index = {
+	 		&quot;filename&quot;,  &quot;index.tpl&quot;,
+	 		&quot;case_sensitive&quot;, &quot;true&quot;,
+	 		&quot;max_includes&quot;,   &quot;5&quot;
+	 		//,&quot;debug&quot;, &quot;true&quot;
+	 	};
+	String [] template_init_page = {
+	 		&quot;filename&quot;,  &quot;page.tpl&quot;,
+	 		&quot;case_sensitive&quot;, &quot;true&quot;,
+	 		&quot;max_includes&quot;,   &quot;5&quot;
+	 	};
+	public HTMLExporter(Preferences p, Profile prof){
+		pref = p;
+		profile=prof;
+		cacheDB = profile.cacheDB;
+	}
+	
+	public void doIt(){
+		CacheHolder holder = new CacheHolder();
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+
+		//need directory only!!!!
+		String dummy = new String();
+		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, profile.dataDir);
+		fc.setTitle(&quot;Select target directory:&quot;);
+		String targetDir;
+		if(fc.execute() != FileChooser.IDCANCEL){
+			targetDir = fc.getChosen() + &quot;/&quot;;
+			Vector cache_index = new Vector();
+			Vector cacheImg = new Vector();
+			Vector logImg = new Vector();
+			Vector mapImg = new Vector();
+			Vector usrImg = new Vector();
+			
+
+			Hashtable varParams;
+			Hashtable imgParams;
+			Hashtable logImgParams;
+			Hashtable usrImgParams;
+			Hashtable mapImgParams;
+
+			//Generate index page
+			int counter = 0;
+			for(int i = 0; i&lt;cacheDB.size();i++){
+				holder = (CacheHolder)cacheDB.get(i);
+				if(holder.is_black == false &amp;&amp; holder.is_filtered == false) counter++;
+			}
+			
+			pbf.showMainTask = false;
+			pbf.setTask(h,&quot;Exporting ...&quot;);
+			pbf.exec();
+
+			for(int i = 0; i&lt;counter;i++){
+				h.progress = (float)(i+1)/(float)counter;
+				h.changed();
+
+				holder = (CacheHolder)cacheDB.get(i);
+				if(holder.is_black == false &amp;&amp; holder.is_filtered == false){
+					//KHF read cachedata only if needed
+					try{
+						holder.readCache( profile.dataDir);
+					}catch(Exception e){
+						//Vm.debug(&quot;Problem reading cache page&quot;);
+					}
+					varParams = new Hashtable();
+					varParams.put(&quot;TYPE&quot;, CacheType.transType(holder.type));
+					varParams.put(&quot;SIZE&quot;, holder.CacheSize);
+					varParams.put(&quot;WAYPOINT&quot;, holder.wayPoint);
+					varParams.put(&quot;NAME&quot;, holder.CacheName);
+					varParams.put(&quot;OWNER&quot;, holder.CacheOwner);
+					varParams.put(&quot;DIFFICULTY&quot;, holder.hard);
+					varParams.put(&quot;TERRAIN&quot;, holder.terrain);
+					varParams.put(&quot;DISTANCE&quot;, holder.distance);
+					varParams.put(&quot;BEARING&quot;, holder.bearing);
+					varParams.put(&quot;LATLON&quot;, holder.LatLon);
+					varParams.put(&quot;STATUS&quot;, holder.CacheStatus);
+					cache_index.add(varParams);
+					//We can generate the individual page here!
+					try{
+						Template page_tpl = new Template(template_init_page);
+						page_tpl.setParam(&quot;TYPE&quot;, CacheType.transType(holder.type));
+						page_tpl.setParam(&quot;SIZE&quot;, holder.CacheSize);
+						page_tpl.setParam(&quot;WAYPOINT&quot;, holder.wayPoint);
+						page_tpl.setParam(&quot;NAME&quot;, holder.CacheName);
+						page_tpl.setParam(&quot;OWNER&quot;, holder.CacheOwner);
+						page_tpl.setParam(&quot;DIFFICULTY&quot;, holder.hard);
+						page_tpl.setParam(&quot;TERRAIN&quot;, holder.terrain);
+						page_tpl.setParam(&quot;DISTANCE&quot;, holder.distance);
+						page_tpl.setParam(&quot;BEARING&quot;, holder.bearing);
+						page_tpl.setParam(&quot;LATLON&quot;, holder.LatLon);
+						page_tpl.setParam(&quot;STATUS&quot;, holder.CacheStatus);
+						if (holder.is_HTML)
+							page_tpl.setParam(&quot;DESCRIPTION&quot;, holder.LongDescription);
+						else {
+							String dummyText = new String();
+							dummyText = STRreplace.replace(holder.LongDescription, &quot;\n&quot;, &quot;&lt;br&gt;&quot;);
+							page_tpl.setParam(&quot;DESCRIPTION&quot;,dummyText);
+							
+						}
+						page_tpl.setParam(&quot;HINTS&quot;, holder.Hints);
+						page_tpl.setParam(&quot;DECRYPTEDHINTS&quot;, Common.rot13(holder.Hints));
+						dummy = new String();
+						for(int j = 0; j&lt;holder.CacheLogs.size(); j++){
+							dummy = dummy + (String)holder.CacheLogs.get(j)+&quot;&lt;br&gt;&quot;;
+						}
+						page_tpl.setParam(&quot;LOGS&quot;, dummy);
+						page_tpl.setParam(&quot;NOTES&quot;, STRreplace.replace(holder.CacheNotes, &quot;\n&quot;,&quot;&lt;br&gt;&quot;));
+						// Cache Images
+						cacheImg.clear();
+						for(int j = 0; j&lt;holder.Images.size(); j++){
+							imgParams = new Hashtable();
+							String imgFile = new String((String)holder.Images.get(j));
+							imgParams.put(&quot;FILE&quot;, imgFile);
+							if (j &lt; holder.ImagesText.size())
+								imgParams.put(&quot;TEXT&quot;,(String)holder.ImagesText.get(j));
+							else
+								imgParams.put(&quot;TEXT&quot;,imgFile);
+							DataMover.copy(profile.dataDir + imgFile,targetDir + imgFile);
+							cacheImg.add(imgParams);
+						}
+						page_tpl.setParam(&quot;cacheImg&quot;, cacheImg);
+						// Log images
+						logImg.clear();
+						for(int j = 0; j&lt;holder.LogImages.size(); j++){
+							logImgParams = new Hashtable();
+							String logImgFile = new String((String)holder.LogImages.get(j));
+							logImgParams.put(&quot;FILE&quot;, logImgFile);
+							if (j &lt; holder.LogImagesText.size())
+								logImgParams.put(&quot;TEXT&quot;,(String)holder.LogImagesText.get(j));
+							else
+								logImgParams.put(&quot;TEXT&quot;,logImgFile);
+							DataMover.copy(profile.dataDir + logImgFile,targetDir + logImgFile);
+							logImg.add(logImgParams);
+						}
+						page_tpl.setParam(&quot;logImg&quot;, logImg);
+						// User images
+						usrImg.clear();
+						for(int j = 0; j&lt;holder.UserImages.size(); j++){
+							usrImgParams = new Hashtable();
+							String usrImgFile = new String((String)holder.UserImages.get(j));
+							usrImgParams.put(&quot;FILE&quot;, usrImgFile);
+							if (j &lt; holder.UserImagesText.size())
+								usrImgParams.put(&quot;TEXT&quot;,(String)holder.UserImagesText.get(j));
+							else
+								usrImgParams.put(&quot;TEXT&quot;,usrImgFile);
+							DataMover.copy(profile.dataDir + usrImgFile,targetDir + usrImgFile);
+							usrImg.add(usrImgParams);
+						}
+						page_tpl.setParam(&quot;userImg&quot;, usrImg);
+
+						// Map images
+						mapImg.clear();
+						mapImgParams = new Hashtable();
+						String mapImgFile = new String((String)holder.wayPoint + &quot;_map.gif&quot;);
+						// check if map file exists
+						File test = new File(profile.dataDir + mapImgFile);
+						if (test.exists()) {
+							mapImgParams.put(&quot;FILE&quot;, mapImgFile);
+							mapImgParams.put(&quot;TEXT&quot;,mapImgFile);
+							DataMover.copy(profile.dataDir + mapImgFile,targetDir + mapImgFile);
+							mapImg.add(mapImgParams);
+							
+							mapImgParams = new Hashtable();
+							mapImgFile = (String)holder.wayPoint + &quot;_map_2.gif&quot;;
+							mapImgParams.put(&quot;FILE&quot;, mapImgFile);
+							mapImgParams.put(&quot;TEXT&quot;,mapImgFile);
+							DataMover.copy(profile.dataDir + mapImgFile,targetDir + mapImgFile);
+							mapImg.add(mapImgParams);
+	
+							page_tpl.setParam(&quot;mapImg&quot;, mapImg);
+						}
+
+						
+						PrintWriter pagefile = new PrintWriter(new BufferedWriter(new FileWriter(targetDir + holder.wayPoint+&quot;.html&quot;)));
+						pagefile.print(page_tpl.output());
+						pagefile.close();
+					}catch(Exception e){
+						Vm.debug(&quot;Problem writing waypoint html file&quot;);
+					}
+				}//if is black, filtered
+			}
+			try{
+				Template tpl = new Template(template_init_index);
+				tpl.setParam(&quot;cache_index&quot;, cache_index);
+				PrintWriter detfile; 
+				detfile = new PrintWriter(new BufferedWriter(new FileWriter(targetDir + &quot;/index.html&quot;)));
+				detfile.print(tpl.output());
+				detfile.close();
+				// sort by waypoint
+				sortAndPrintIndex(tpl, cache_index,targetDir + &quot;/index_wp.html&quot;, &quot;WAYPOINT&quot;);
+				// sort by name
+				sortAndPrintIndex(tpl, cache_index,targetDir + &quot;/index_alpha.html&quot;, &quot;NAME&quot;, false);
+				// sort by type
+				sortAndPrintIndex(tpl, cache_index,targetDir + &quot;/index_type.html&quot;, &quot;TYPE&quot;, true);
+				// sort by size
+				sortAndPrintIndex(tpl, cache_index,targetDir + &quot;/index_size.html&quot;, &quot;SIZE&quot;, true);
+				// sort by distance
+				sortAndPrintIndex(tpl, cache_index,targetDir + &quot;/index_dist.html&quot;, &quot;DISTANCE&quot;, 10.0);
+			}catch(Exception e){
+				Vm.debug(&quot;Problem writing HTML files\n&quot;);
+				e.printStackTrace();
+			}//try
+			
+		}//if
+		pbf.exit(0);
+	}
+	private void sortAndPrintIndex(Template tmpl, Vector list, String file, String field){
+		Vector navi_index;
+		PrintWriter detfile; 
+		
+		list.sort(new HTMLComparer(field),false);
+		try {
+			detfile = new PrintWriter(new BufferedWriter(new FileWriter(file)));
+			detfile.print(tmpl.output());
+			detfile.close();
+		} catch (IOException e) {
+			Vm.debug(&quot;Problem writing HTML files\n&quot;);
+			e.printStackTrace();
+		}
+	}
+
+	
+	private void sortAndPrintIndex(Template tmpl, Vector list, String file, String field, boolean fullCompare){
+		Vector navi_index;
+		PrintWriter detfile; 
+		
+		list.sort(new HTMLComparer(field),false);
+		navi_index = addAnchorString(list,field, fullCompare);
+		if (navi_index != null){
+			tmpl.setParam(&quot;navi_index&quot;,navi_index);
+		}
+		try {
+			detfile = new PrintWriter(new BufferedWriter(new FileWriter(file)));
+			detfile.print(tmpl.output());
+			detfile.close();
+		} catch (IOException e) {
+			Vm.debug(&quot;Problem writing HTML files\n&quot;);
+			e.printStackTrace();
+		}
+	}
+	
+	private void sortAndPrintIndex(Template tmpl, Vector list, String file, String field, double diff){
+		Vector navi_index;
+		PrintWriter detfile; 
+		
+		list.sort(new HTMLComparer(field),false);
+		navi_index = addAnchorString(list,field, diff);
+		if (navi_index != null){
+			tmpl.setParam(&quot;navi_index&quot;,navi_index);
+		}
+		try {
+			detfile = new PrintWriter(new BufferedWriter(new FileWriter(file)));
+			detfile.print(tmpl.output());
+			detfile.close();
+		} catch (IOException e) {
+			Vm.debug(&quot;Problem writing HTML files\n&quot;);
+			e.printStackTrace();
+		}
+		
+	}
+
+
+	private Vector addAnchorString(Vector list, String field, boolean fullCompare){
+		Vector topIndex = new Vector();
+		Hashtable topIndexParms, currEntry;
+		String lastValue, currValue;
+		
+		if (list.size() == 0) return null;
+		
+		currEntry = (Hashtable) list.get(0);
+		lastValue = (String) currEntry.get(field);
+		if (lastValue == null || lastValue.length() == 0) lastValue = &quot;  &quot;;
+		lastValue = lastValue.toUpperCase();
+		
+		for (int i=1; i&lt;list.size(); i++){
+			currEntry = (Hashtable) list.get(i);
+			currValue = (String) currEntry.get(field);
+			currValue = currValue.toUpperCase();
+			if (currValue == null || currValue == &quot;&quot;) continue;
+			try {
+				if (fullCompare) {
+					if (lastValue.compareTo(currValue)!= 0){
+						// Values for navigation line 
+						topIndexParms = new Hashtable();
+						topIndexParms.put(&quot;HREF&quot;, Convert.toString(i));
+						topIndexParms.put(&quot;TEXT&quot;, currValue);
+						topIndex.add(topIndexParms);
+						// add anchor entry to list
+						currEntry.put(&quot;ANCHORNAME&quot;, Convert.toString(i));
+						currEntry.put(&quot;ANCHORTEXT&quot;, currValue);
+					}
+					else {
+						// clear value from previous run
+						currEntry.put(&quot;ANCHORNAME&quot;, &quot;&quot;);
+						currEntry.put(&quot;ANCHORTEXT&quot;, &quot;&quot;);
+					}
+				}
+				else {
+					if (lastValue.charAt(0)!= currValue.charAt(0)){
+						// Values for navigation line 
+						topIndexParms = new Hashtable();
+						topIndexParms.put(&quot;HREF&quot;, Convert.toString(i));
+						topIndexParms.put(&quot;TEXT&quot;, currValue.charAt(0)+ &quot; &quot;);
+						topIndex.add(topIndexParms);
+						// add anchor entry to list
+						currEntry.put(&quot;ANCHORNAME&quot;, Convert.toString(i));
+						currEntry.put(&quot;ANCHORTEXT&quot;, currValue.charAt(0)+ &quot; &quot;);
+					}
+					else {
+						// clear value from previous run
+						currEntry.put(&quot;ANCHORNAME&quot;, &quot;&quot;);
+						currEntry.put(&quot;ANCHORTEXT&quot;, &quot;&quot;);
+					}
+				}
+				list.set(i,currEntry);
+				lastValue = currValue;
+			} catch (Exception e){
+				continue;
+			}
+		}
+		return topIndex;
+	}
+	private Vector addAnchorString(Vector list, String field, double diff){
+		Vector topIndex = new Vector();
+		Hashtable topIndexParms, currEntry;
+		double lastValue, currValue;
+		
+		if (list.size() == 0) return null;
+		
+		currEntry = (Hashtable) list.get(0);
+		lastValue = Common.parseDouble((String) currEntry.get(field)) + diff;
+		
+		for (int i=1; i&lt;list.size(); i++){
+			currEntry = (Hashtable) list.get(i);
+			currValue = Common.parseDouble((String) currEntry.get(field));
+			if (currValue &gt;= lastValue ){
+				// Values for navigation line 
+				topIndexParms = new Hashtable();
+				topIndexParms.put(&quot;HREF&quot;, Convert.toString(i));
+				topIndexParms.put(&quot;TEXT&quot;, Convert.toString(lastValue));
+				topIndex.add(topIndexParms);
+				// add anchor entry to list
+				currEntry.put(&quot;ANCHORNAME&quot;, Convert.toString(i));
+				currEntry.put(&quot;ANCHORTEXT&quot;, Convert.toString(lastValue));
+				lastValue = currValue + diff;
+			}
+			else {
+				// clear value from previous run
+				currEntry.put(&quot;ANCHORNAME&quot;, &quot;&quot;);
+				currEntry.put(&quot;ANCHORTEXT&quot;, &quot;&quot;);
+			}
+			list.set(i,currEntry);
+		}
+		return topIndex;
+	}
+
+	
+}

Copied: trunk/src/exp/KMLExporter.java (from rev 374, trunk/src/CacheWolf/KMLExporter.java)
===================================================================
--- trunk/src/CacheWolf/KMLExporter.java	2007-01-09 22:12:11 UTC (rev 374)
+++ trunk/src/exp/KMLExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,107 @@
+package exp;
+import CacheWolf.*;
+
+/**
+*	Class to export the cache database (index) to an KML-File
+*	which can be read by Google Earth   
+*   
+*/
+public class KMLExporter extends Exporter {
+
+	public KMLExporter(){
+		super();
+		this.setMask(&quot;*.kml&quot;);
+		this.setHowManyParams(LAT_LON);
+	}
+
+	
+	public KMLExporter(Preferences p, Profile prof){
+			super();
+			this.setMask(&quot;*.kml&quot;);
+	}
+	
+	public String header () {
+		StringBuffer strBuf = new StringBuffer(200);
+				
+		strBuf.append(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&quot;);
+		strBuf.append(&quot;&lt;kml xmlns=\&quot;<A HREF="http://earth.google.com/kml/2.0\">http://earth.google.com/kml/2.0\</A>&quot;&gt;&quot;);
+		strBuf.append(&quot;&lt;Folder&gt;&quot;);
+		strBuf.append(&quot;&lt;name&gt;CacheWolf&lt;/name&gt;&quot;);
+		strBuf.append(&quot;&lt;open&gt;1&lt;/open&gt;&quot;);
+
+		return strBuf.toString();
+	}
+	
+	public String record(CacheHolder ch, String lat, String lon){
+		StringBuffer strBuf = new StringBuffer(200);
+		
+		strBuf.append(&quot;   &lt;Placemark&gt;\r\n&quot;);
+		strBuf.append(&quot;      &lt;description&gt;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot;+ch.wayPoint+&quot;&lt;/description&gt;\r\n&quot;);
+		strBuf.append(&quot;      &lt;name&gt;&quot;+ ch.wayPoint + &quot; - &quot; + SafeXML.clean(ch.CacheName) +&quot;&lt;/name&gt;\r\n&quot;);
+		strBuf.append(&quot;      &lt;LookAt&gt;\r\n&quot;);
+		strBuf.append(&quot;         &lt;latitude&gt;&quot; + lat + &quot;&lt;/latitude&gt;\r\n&quot;);
+		strBuf.append(&quot;         &lt;longitude&gt;&quot; + lon + &quot;&lt;/longitude&gt;\r\n&quot;);
+		strBuf.append(&quot;         &lt;range&gt;10000&lt;/range&gt;&lt;tilt&gt;0&lt;/tilt&gt;&lt;heading&gt;0&lt;/heading&gt;\r\n&quot;);
+		strBuf.append(&quot;      &lt;/LookAt&gt;\r\n&quot;);
+		strBuf.append(&quot;      &lt;Point&gt;\r\n&quot;);
+		strBuf.append(&quot;         &lt;coordinates&gt;&quot;  + lon + &quot;,&quot; + lat + &quot;&lt;/coordinates&gt;\r\n&quot;);
+		strBuf.append(&quot;      &lt;/Point&gt;\r\n&quot;);
+		strBuf.append(&quot;   &lt;/Placemark&gt;\r\n&quot;);
+
+		return strBuf.toString();
+	}
+	
+	public String trailer(){
+		StringBuffer strBuf = new StringBuffer(50);
+
+		strBuf.append(&quot;&lt;/Folder&gt;&quot;);
+		strBuf.append(&quot;&lt;/kml&gt;&quot;);
+
+		return strBuf.toString();
+	}
+	
+/*	public void doIt(){
+		CacheHolder holder;
+		ParseLatLon pll;
+		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
+		fc.setTitle(&quot;Select target file:&quot;);
+		if(fc.execute() != fc.IDCANCEL){
+			File saveTo = fc.getChosenFile();
+			try{
+				PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
+				//Create Header for KML-File
+				outp.println(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&quot;);
+				outp.println(&quot;&lt;kml xmlns=\&quot;<A HREF="http://earth.google.com/kml/2.0\">http://earth.google.com/kml/2.0\</A>&quot;&gt;&quot;);
+				outp.println(&quot;&lt;Folder&gt;&quot;);
+				outp.println(&quot;&lt;name&gt;CacheWolf&lt;/name&gt;&quot;);
+				outp.println(&quot;&lt;open&gt;1&lt;/open&gt;&quot;);
+				//loop through database
+				for(int i = 0; i&lt;cacheDB.size(); i++){
+					holder=(CacheHolder)cacheDB.get(i);
+					if(holder.is_black == false &amp;&amp; holder.is_filtered == false){
+						pll = new ParseLatLon(holder.LatLon,&quot;.&quot;);
+						pll.parse();
+						outp.println(&quot;   &lt;Placemark&gt;&quot;);
+						outp.println(&quot;      &lt;description&gt;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot;+holder.wayPoint+&quot;&lt;/description&gt;&quot;);
+						outp.println(&quot;      &lt;name&gt;&quot;+ holder.wayPoint + &quot; - &quot; + SafeXML.clean(holder.CacheName) +&quot;&lt;/name&gt;&quot;);
+						outp.println(&quot;      &lt;LookAt&gt;&quot;);
+						outp.println(&quot;         &lt;latitude&gt;&quot; + pll.getLatDeg() + &quot;&lt;/latitude&gt;&quot;);
+						outp.println(&quot;         &lt;longitude&gt;&quot; + pll.getLonDeg() + &quot;&lt;/longitude&gt;&quot;);
+						outp.println(&quot;         &lt;range&gt;10000&lt;/range&gt;&lt;tilt&gt;0&lt;/tilt&gt;&lt;heading&gt;0&lt;/heading&gt;&quot;);
+						outp.println(&quot;      &lt;/LookAt&gt;&quot;);
+						outp.println(&quot;      &lt;Point&gt;&quot;);
+						outp.println(&quot;         &lt;coordinates&gt;&quot;  + pll.getLonDeg() + &quot;,&quot; + pll.getLatDeg() + &quot;&lt;/coordinates&gt;&quot;);
+						outp.println(&quot;      &lt;/Point&gt;&quot;);
+						outp.println(&quot;   &lt;/Placemark&gt;&quot;);
+					}//if holder...
+				}//for ... i &lt; cacheDB ...			
+				// footer
+				outp.println(&quot;&lt;/Folder&gt;&quot;);
+				outp.println(&quot;&lt;/kml&gt;&quot;);
+				outp.close();
+			}catch(Exception e){
+				//Vm.debug(&quot;Error writing to OVL file!&quot;);
+			}
+		} // if execute
+	}
+*/}

Copied: trunk/src/exp/MSARCSVExporter.java (from rev 376, trunk/src/CacheWolf/MSARCSVExporter.java)
===================================================================
--- trunk/src/CacheWolf/MSARCSVExporter.java	2007-01-10 18:57:52 UTC (rev 376)
+++ trunk/src/exp/MSARCSVExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,37 @@
+package exp;
+
+import CacheWolf.*;
+
+/**
+ * Class to export the cache database (index) to an CSV File which can bei easy
+ * importet bei MS AutoRoute (testet with AR 2001 German) Format of the file:
+ * Name;Breitengrad;L&#228;ngengrad;Typ1;Typ2;Waypoint;Datum;Hyperlink
+ * 
+ */
+public class MSARCSVExporter extends Exporter {
+
+	public MSARCSVExporter(Preferences p, Profile prof) {
+		super();
+		this.setMask(&quot;*.csv&quot;);
+		this.setDecimalSeparator(',');
+		this.setNeedCacheDetails(true);
+		this.setHowManyParams(LAT_LON);
+	}
+
+	public String header() {
+		return &quot;Name;Breitengrad;L\u00E4ngengrad;Typ1;Typ2;Waypoint;Datum;Hyperlink\r&quot;;
+	}
+
+	public String record(CacheHolder ch, String lat, String lon) {
+		StringBuffer str = new StringBuffer(200);
+		str.append(&quot;\&quot;&quot; + ch.wayPoint + &quot; - &quot; + ch.CacheName + &quot;\&quot;;&quot;);
+		str.append(lat + &quot;;&quot; + lon +&quot;;&quot;);
+		str.append(&quot;\&quot;&quot; + CacheType.transType(ch.type)+ &quot;\&quot;;&quot;);
+		str.append(&quot;\&quot;&quot; + ch.CacheSize + &quot;\&quot;;&quot;);
+		str.append(&quot;\&quot;&quot; + ch.wayPoint + &quot;\&quot;;&quot;);
+		str.append(&quot;\&quot;&quot; + ch.DateHidden + &quot;\&quot;;&quot;);
+		str.append(&quot;\&quot;&quot; + ch.URL + &quot;\&quot;\r\n&quot;);
+
+		return str.toString();
+	}
+}

Copied: trunk/src/exp/OVLExporter.java (from rev 380, trunk/src/CacheWolf/OVLExporter.java)
===================================================================
--- trunk/src/CacheWolf/OVLExporter.java	2007-01-11 04:13:15 UTC (rev 380)
+++ trunk/src/exp/OVLExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,137 @@
+package exp;
+import CacheWolf.*;
+import ewe.sys.*;
+
+/**
+*	Class to export the cache database (index) to an ascii overlay file for
+*	the TOP50 map products (mainly available in german speaking countries).
+*/
+public class OVLExporter extends Exporter{
+	
+	public OVLExporter(Preferences p, Profile prof){
+		super();
+		this.setMask(&quot;*.ovl&quot;);
+		this.setHowManyParams(LAT_LON|COUNT);
+	}
+	
+	public String record(CacheHolder ch, String lat, String lon, int counter){
+		StringBuffer str = new StringBuffer(200);
+		double tmp;
+		str.append(&quot;[Symbol &quot;+Convert.toString(2*counter + 1)+&quot;]\r\n&quot;);
+		str.append(&quot;Typ=6\r\n&quot;);
+		str.append(&quot;Width=15\r\n&quot;);
+		str.append(&quot;Height=15\r\n&quot;);
+		str.append(&quot;Col=1\r\n&quot;);
+		str.append(&quot;Zoom=1\r\n&quot;);
+		str.append(&quot;Size=2\r\n&quot;);
+		str.append(&quot;Area=2\r\n&quot;);
+		str.append(&quot;XKoord=&quot;+lon+&quot;\r\n&quot;);
+		str.append(&quot;YKoord=&quot;+lat+&quot;\r\n&quot;);
+		//the text
+		str.append(&quot;[Symbol &quot;+Convert.toString(2*counter + 2)+&quot;]\r\n&quot;);
+		str.append(&quot;Typ=2\r\n&quot;);
+		str.append(&quot;Col=1\r\n&quot;);
+		str.append(&quot;Zoom=1\r\n&quot;);
+		str.append(&quot;Size=2\r\n&quot;);
+		str.append(&quot;Area=2\r\n&quot;);
+		str.append(&quot;Font=3\r\n&quot;);
+		str.append(&quot;Dir=1\r\n&quot;);
+		tmp = Common.parseDouble(lon);
+		tmp += 0.002;
+		str.append(&quot;XKoord=&quot;+Convert.toString(tmp).replace(',', '.')+&quot;\r\n&quot;);
+		tmp = Common.parseDouble(lat);
+		tmp += 0.002;
+		str.append(&quot;YKoord=&quot;+Convert.toString(tmp).replace(',', '.')+&quot;\r\n&quot;);
+		str.append(&quot;Text=&quot;+ch.wayPoint+&quot;\r\n&quot;);
+
+		return str.toString();
+	}
+	
+	public String trailer(int counter){
+		StringBuffer str = new StringBuffer(200);
+
+		str.append(&quot;[Overlay]\r\n&quot;);
+		str.append(&quot;Symbols=&quot;+Convert.toString(counter*2)+&quot;\r\n&quot;);
+		// maplage section
+		str.append(&quot;[MapLage]\r\n&quot;);
+		str.append(&quot;MapName=Gesamtes Bundesgebiet (D1000)\r\n&quot;);
+		str.append(&quot;DimmFc=100\r\n&quot;);
+		str.append(&quot;ZoomFc=100\r\n&quot;);
+		str.append(&quot;CenterLat=&quot;+pref.curCentrePt.getLatDeg(CWPoint.CW)+&quot;.00\r\n&quot;);
+		str.append(&quot;CenterLong=&quot;+pref.curCentrePt.getLonDeg(CWPoint.CW)+&quot;.00\r\n&quot;);
+		str.append(&quot;RefColor=255\r\n&quot;);
+		str.append(&quot;RefRad=58\r\n&quot;);
+		str.append(&quot;RefLine=6\r\n&quot;);
+		str.append(&quot;RefOn=0\r\n&quot;);
+		str.append(&quot;\r\n&quot;);
+		return str.toString();
+	}
+
+	
+/*	public void doIt(){
+		CacheHolder holder;
+		ParseLatLon pll;
+		int symCounter = 1;
+		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
+		fc.setTitle(&quot;Select target file:&quot;);
+		if(fc.execute() != FileChooser.IDCANCEL){
+			File saveTo = fc.getChosenFile();
+			try{
+				PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(saveTo)));
+				//symbols section, loop through database
+				//a circle and text per cache is created
+				for(int i = 0; i&lt;cacheDB.size(); i++){
+					holder=(CacheHolder)cacheDB.get(i);
+					if(holder.is_black == false &amp;&amp; holder.is_filtered == false){
+						pll = new ParseLatLon(holder.LatLon,&quot;.&quot;);
+						pll.parse();
+						//the circle!
+						outp.print(&quot;[Symbol &quot;+Convert.toString(symCounter)+&quot;]\r\n&quot;);
+						outp.print(&quot;Typ=6\r\n&quot;);
+						outp.print(&quot;Width=15\r\n&quot;);
+						outp.print(&quot;Height=15\r\n&quot;);
+						outp.print(&quot;Col=1\r\n&quot;);
+						outp.print(&quot;Zoom=1\r\n&quot;);
+						outp.print(&quot;Size=2\r\n&quot;);
+						outp.print(&quot;Area=2\r\n&quot;);
+						outp.print(&quot;XKoord=&quot;+pll.getLonDeg()+&quot;\r\n&quot;);
+						outp.print(&quot;YKoord=&quot;+pll.getLatDeg()+&quot;\r\n&quot;);
+						symCounter++;
+						//the text
+						outp.print(&quot;[Symbol &quot;+Convert.toString(symCounter)+&quot;]\r\n&quot;);
+						outp.print(&quot;Typ=2\r\n&quot;);
+						outp.print(&quot;Col=1\r\n&quot;);
+						outp.print(&quot;Zoom=1\r\n&quot;);
+						outp.print(&quot;Size=2\r\n&quot;);
+						outp.print(&quot;Area=2\r\n&quot;);
+						outp.print(&quot;Font=3\r\n&quot;);
+						outp.print(&quot;Dir=1\r\n&quot;);
+						outp.print(&quot;XKoord=&quot;+Convert.toString(pll.lon2+0.002).replace(',', '.')+&quot;\r\n&quot;);
+						outp.print(&quot;YKoord=&quot;+Convert.toString(pll.lat2+0.001).replace(',', '.')+&quot;\r\n&quot;);
+						outp.print(&quot;Text=&quot;+holder.wayPoint+&quot;\r\n&quot;);
+						symCounter++;
+					}//if holder...
+				}//for ... i &lt; cacheDB ...			
+				// overlay section
+				outp.print(&quot;[Overlay]\r\n&quot;);
+				outp.print(&quot;Symbols=&quot;+Convert.toString(symCounter-1)+&quot;\r\n&quot;);
+				// maplage section
+				outp.print(&quot;[MapLage]\r\n&quot;);
+				outp.print(&quot;MapName=Gesamtes Bundesgebiet (D1000)\r\n&quot;);
+				outp.print(&quot;DimmFc=100\r\n&quot;);
+				outp.print(&quot;ZoomFc=100\r\n&quot;);
+				outp.print(&quot;CenterLat=&quot;+myPreferences.curCentrePt.getLatDeg(CWPoint.CW)+&quot;.00\r\n&quot;);
+				outp.print(&quot;CenterLong=&quot;+myPreferences.curCentrePt.getLonDeg(CWPoint.CW)+&quot;.00\r\n&quot;);
+				outp.print(&quot;RefColor=255\r\n&quot;);
+				outp.print(&quot;RefRad=58\r\n&quot;);
+				outp.print(&quot;RefLine=6\r\n&quot;);
+				outp.print(&quot;RefOn=0\r\n&quot;);
+				outp.print(&quot;\r\n&quot;);
+				
+				outp.close();
+			}catch(Exception e){
+				Vm.debug(&quot;Error writing to OVL file! &quot;+e.toString());
+			}
+		} // if execute
+	}
+*/}

Copied: trunk/src/exp/OziExporter.java (from rev 380, trunk/src/CacheWolf/OziExporter.java)
===================================================================
--- trunk/src/CacheWolf/OziExporter.java	2007-01-11 04:13:15 UTC (rev 380)
+++ trunk/src/exp/OziExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,86 @@
+package exp;
+import CacheWolf.*;
+
+/**
+*	Class to export the cache database (index) to an OziExplorer File
+*/
+public class OziExporter extends Exporter{
+	
+	public OziExporter(Preferences p, Profile prof){
+		super();
+		this.setHowManyParams(LAT_LON);
+		this.setMask(&quot;*.wpt&quot;);
+	}
+	
+	public String header () {
+		StringBuffer strBuf = new StringBuffer(200);
+		
+		strBuf.append(&quot;OziExplorer CE Waypoint File Version 1.2\r\n&quot;);
+		strBuf.append(&quot;WGS 84\r\n&quot;);
+		strBuf.append(&quot;Reserved 2\r\n&quot;);
+		strBuf.append(&quot;Reserved 3\r\n&quot;);
+
+		return strBuf.toString();
+	}
+
+	public String record(CacheHolder ch, String lat, String lon){
+		StringBuffer strBuf = new StringBuffer(200);
+
+		// Field 1 : Number - this is the location in the array (max 1000), must be unique, 
+		// usually start at 1 and increment. Can be set to -1 (minus 1) and the number will be auto generated.
+		strBuf.append(&quot;-1,&quot;);
+		// Field 2 : Name - the waypoint name, use the correct length name to suit the GPS type.
+		strBuf.append(ch.wayPoint + &quot;,&quot;);
+		// Field 3 : Latitude - decimal degrees.
+		strBuf.append(lat+&quot;,&quot;);
+		// Field 4 : Longitude - decimal degrees.
+		strBuf.append(lon+&quot;,&quot;);
+		// Field 5 : Date - see Date Format below, if blank a preset date will be used
+		strBuf.append(&quot;,&quot;);
+		// Field 6 : Symbol - 0 to number of symbols in GPS
+		strBuf.append(&quot;0,&quot;);
+		// Field 7 : Status - always set to 1
+		strBuf.append(&quot;1,&quot;);
+		// Field 8 : Map Display Format
+		strBuf.append(&quot;0,&quot;);
+		// Field 9 : Foreground Color (RGB value)
+		strBuf.append(&quot;0,&quot;);
+		// Field 10 : Background Color (RGB value)
+		strBuf.append(&quot;16777215,&quot;);
+		// Field 11 : Description (max 40), no commas
+		if (ch.CacheName.length() &lt;= 40){
+			strBuf.append(ch.CacheName + &quot;,&quot;);
+		}
+		else {
+			strBuf.append(ch.CacheName.substring(0,40) + &quot;,&quot;);
+		}
+		// Field 12 : Pointer Direction
+		strBuf.append(&quot;0,&quot;);
+		// Field 13 : Garmin Display Format
+		strBuf.append(&quot;0,&quot;);
+		// Field 14 : Proximity Distance - 0 is off any other number is valid
+		strBuf.append(&quot;0,&quot;);
+		// Field 15 : Altitude - in feet (-777 if not valid)
+		strBuf.append(&quot;-777,&quot;);
+		// Field 16 : Font Size - in points
+		strBuf.append(&quot;8,&quot;);
+		// Field 17 : Font Style - 0 is normal, 1 is bold.
+		strBuf.append(&quot;1,&quot;);
+		// Field 18 : Symbol Size - 17 is normal size
+		strBuf.append(&quot;17,&quot;);
+		// Field 19 : Proximity Symbol Position
+		strBuf.append(&quot;0,&quot;);
+		// Field 20 : Proximity Time
+		strBuf.append(&quot;  10.0,&quot;);
+	    // Field 21 : Proximity or Route or Both
+		strBuf.append(&quot;2,&quot;);
+		// Field 22 : File Attachment Name
+		strBuf.append(&quot;,&quot;);
+		// Field 23 : Proximity File Attachment Name
+		strBuf.append(&quot;,&quot;);
+		// Field 24 : Proximity Symbol Name
+		strBuf.append(&quot; \r\n&quot;);
+
+		return strBuf.toString();
+	}
+}

Copied: trunk/src/exp/PCX5Exporter.java (from rev 380, trunk/src/CacheWolf/PCX5Exporter.java)
===================================================================
--- trunk/src/CacheWolf/PCX5Exporter.java	2007-01-11 04:13:15 UTC (rev 380)
+++ trunk/src/exp/PCX5Exporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,65 @@
+package exp;
+import CacheWolf.*;
+import ewe.io.File;
+
+/**
+*	Class to export the cache database into an ascii file that may be imported
+*	ba Mapsource (c) by Garmin.
+*/
+public class PCX5Exporter extends Exporter{
+	public static int MODE_AUTO = TMP_FILE;
+	public static int MODE_ASK = ASK_FILE;
+	
+	public PCX5Exporter(Preferences p, Profile prof){
+		super();
+		this.setMask(&quot;*.wpt&quot;);
+		this.setTmpFileName(File.getProgramDirectory() + &quot;/temp.pcx&quot;);
+		this.setHowManyParams(NO_PARAMS);
+	}
+	
+	public String header () {
+		StringBuffer strBuf = new StringBuffer(200);
+
+		strBuf.append(&quot;H  SOFTWARE NAME &amp; VERSION\n&quot;);
+		strBuf.append(&quot;I  PCX5 2.09\n&quot;);
+		strBuf.append(&quot;\n&quot;);
+		strBuf.append(&quot;H  R DATUM                IDX DA            DF            DX            DY            DZ\n&quot;);
+		strBuf.append(&quot;M  G WGS 84               121 +0.000000e+00 +0.000000e+00 +0.000000e+00 +0.000000e+00 +0.000000e+00\n&quot;);
+		strBuf.append(&quot;\n&quot;);
+		strBuf.append(&quot;H  COORDINATE SYSTEM\n&quot;);
+		strBuf.append(&quot;U  LAT LON DM\n&quot;);
+		strBuf.append(&quot;\n&quot;);
+		strBuf.append(&quot;H  IDNT   LATITUDE  LONGITUDE      DATE      TIME     ALT   DESCRIPTION                              PROXIMITY     SYMBOL ;waypts\r\n&quot;);
+		
+		return strBuf.toString();
+	}
+	
+	public String record(CacheHolder ch){
+		StringBuffer strBuf = new StringBuffer(200);
+		String latlonstr, dummy;
+
+		  strBuf.append(&quot;W  &quot; + ch.wayPoint + &quot; &quot;);
+		  latlonstr = STRreplace.replace(ch.LatLon, &quot;&#176;&quot;, &quot; &quot;);
+		  latlonstr = STRreplace.replace(latlonstr, &quot; &quot;, &quot;&quot;);
+		  latlonstr = STRreplace.replace(latlonstr, &quot;E&quot;, &quot; E&quot;);
+		  latlonstr = STRreplace.replace(latlonstr, &quot;W&quot;, &quot; W&quot;);
+		  strBuf.append(latlonstr + &quot;     &quot;);
+		  strBuf.append(&quot;01-JAN-04 01:00:00 -0000 &quot;);
+		  // has 42 characters
+		  dummy = ch.CacheName;
+		  if (dummy.length() &lt; 40){
+			  strBuf.append(dummy);
+			  int i = 40 - dummy.length();
+			  for (; i &gt; 0; i--){
+				  strBuf.append(' ');
+			  }
+		  } else {
+			  strBuf.append(dummy.substring(0,40));
+		  }
+		  strBuf.append(&quot; 0.000000e+000 &quot;);
+		  if(ch.is_found) strBuf.append(&quot;  8256\r\n&quot;);
+		  else  		  strBuf.append(&quot;  8255\r\n&quot;);
+		return strBuf.toString();
+	}
+	
+}

Copied: trunk/src/exp/TPLExporter.java (from rev 380, trunk/src/CacheWolf/TPLExporter.java)
===================================================================
--- trunk/src/CacheWolf/TPLExporter.java	2007-01-11 04:13:15 UTC (rev 380)
+++ trunk/src/exp/TPLExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,234 @@
+/*
+    CacheWolf is a software for PocketPC, Win and Linux that 
+    enables paperless caching. 
+    It supports the sites geocaching.com and opencaching.de
+    
+    Copyright (C) 2006  CacheWolf development team
+    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+    for more information.
+    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+		<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation version 2 of the License.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+    */
+
+package exp;
+
+import CacheWolf.CWPoint;
+import CacheWolf.CacheHolder;
+import CacheWolf.CacheType;
+import CacheWolf.Preferences;
+import CacheWolf.Profile;
+import CacheWolf.STRreplace;
+import HTML.Template;
+import ewe.filechooser.FileChooser;
+import ewe.io.*;
+import ewe.sys.*;
+import ewe.ui.*;
+import ewe.util.*;
+import com.stevesoft.ewe_pat.*;
+
+/**
+ * @author Kalle
+ * class to export cachedata using a template
+ */
+class TplFilter implements HTML.Tmpl.Filter
+{
+	private int type=SCALAR;
+	private String newLine=&quot;\n&quot;;
+	TextCodec codec = new AsciiCodec();
+	String badChars;
+	String decSep = &quot;.&quot;;
+	
+
+	public TplFilter(){
+		codec = new AsciiCodec(AsciiCodec.STRIP_CR);
+		return;
+	}
+	
+	public int format() {
+		return this.type;
+	}
+	
+	public String parse(String t) {
+		//Vm.debug(t);
+		Regex rex, rex1;
+		String param, value;
+		// Filter newlines 
+		rex = new Regex(&quot;(?m)\n$&quot;,&quot;&quot;);
+		t = rex.replaceAll(t);
+
+		// Filter comments &lt;#-- and --&gt;
+		rex = new Regex(&quot;&lt;#--.*--&gt;&quot;,&quot;&quot;);
+		t = rex.replaceAll(t);
+
+		// replace &lt;br&gt; or &lt;br /&gt; with newline
+		rex = new Regex(&quot;&lt;br.*&gt;&quot;,&quot;&quot;);
+		rex.search(t);
+		if (rex.didMatch()){
+			t = rex.replaceAll(t);
+			t += newLine;
+		}
+		
+		// search for parameters
+		rex = new Regex(&quot;(?i)&lt;tmpl_par.*&gt;&quot;);
+		rex.search(t);
+		if (rex.didMatch()){
+			// get parameter
+			rex1 = new Regex(&quot;(?i)name=\&quot;(.*)\&quot;\\svalue=\&quot;(.*)\&quot;[?\\s&gt;]&quot;);
+			rex1.search(t);
+			param = rex1.stringMatched(1);
+			value = rex1.stringMatched(2);
+			//Vm.debug(&quot;param=&quot; + param + &quot;\nvalue=&quot; + value);
+			//clear t, because we allow only one parameter per line
+			t = &quot;&quot;;
+			
+			// get the values
+			if (param.equals(&quot;charset&quot;)) {
+				if (value.equals(&quot;ASCII&quot;)) codec = new AsciiCodec();
+				if (value.equals(&quot;UTF8&quot;)) codec = new JavaUtf8Codec();
+			}
+			if (param.equals(&quot;badchars&quot;)) {
+				badChars = value;
+			}
+			if (param.equals(&quot;newline&quot;)){
+				newLine = &quot;&quot;;
+				if (value.indexOf(&quot;CR&quot;) &gt;= 0) newLine += &quot;\r&quot;;
+				if (value.indexOf(&quot;LF&quot;) &gt;= 0) newLine += &quot;\n&quot;;
+			}
+			if (param.equals(&quot;decsep&quot;)) {
+				decSep = value;
+			}
+
+
+		}
+		return t;
+	}
+		
+	
+	public String [] parse(String [] t) {
+		throw new UnsupportedOperationException();
+	}
+}
+ 
+
+public class TPLExporter {
+	Vector cacheDB;
+	Preferences pref;
+	Profile profile;
+	String tplFile;
+
+	public TPLExporter(Preferences p, Profile prof, String tpl){
+		pref = p;
+		profile=prof;
+		cacheDB = profile.cacheDB;
+		tplFile = tpl;
+	}
+	
+	public void doIt(){
+		CacheHolder holder;
+		ProgressBarForm pbf = new ProgressBarForm();
+		ewe.sys.Handle h = new ewe.sys.Handle();
+		Vector cache_index = new Vector();
+		Hashtable varParams;
+		TplFilter myFilter;
+
+		FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
+		fc.setTitle(&quot;Select target file:&quot;);
+		if(fc.execute() == FileChooser.IDCANCEL) return;
+		File saveTo = fc.getChosenFile();
+		
+		int counter = 0;
+		for(int i = 0; i&lt;cacheDB.size();i++){
+			holder = (CacheHolder)cacheDB.get(i);
+			if(holder.is_black == false &amp;&amp; holder.is_filtered == false) counter++;
+		}
+		pbf.showMainTask = false;
+		pbf.setTask(h,&quot;Exporting ...&quot;);
+		pbf.exec();
+		
+		Hashtable args = new Hashtable();
+		myFilter = new TplFilter();
+		//args.put(&quot;debug&quot;, &quot;true&quot;);
+		args.put(&quot;filename&quot;, tplFile);
+		args.put(&quot;case_sensitive&quot;, &quot;true&quot;);
+		args.put(&quot;loop_context_vars&quot;, Boolean.TRUE);
+		args.put(&quot;max_includes&quot;, new Integer(5));
+		args.put(&quot;filter&quot;, myFilter);
+		try {
+			Template tpl = new Template(args);
+
+			for(int i = 0; i&lt;counter;i++){
+				holder = (CacheHolder)cacheDB.get(i);
+				h.progress = (float)i/(float)counter;
+				h.changed();
+				if(holder.is_black == false &amp;&amp; holder.is_filtered == false){
+					try{
+						holder.readCache(profile.dataDir);
+					}catch(Exception e){
+						Vm.debug(&quot;Problem reading cache page&quot;);
+					}
+					try {
+						CWPoint point = new CWPoint(holder.LatLon, CWPoint.CW);
+						Regex dec = new Regex(&quot;[,.]&quot;,myFilter.decSep);
+						varParams = new Hashtable();
+						varParams.put(&quot;TYPE&quot;, CacheType.transType(holder.type));
+						varParams.put(&quot;SHORTTYPE&quot;, CacheType.transType(holder.type).substring(0,1));
+						varParams.put(&quot;SIZE&quot;, holder.CacheSize);
+						varParams.put(&quot;SHORTSIZE&quot;, holder.CacheSize.substring(0,1));
+						varParams.put(&quot;WAYPOINT&quot;, holder.wayPoint);
+						if (myFilter.badChars != null) {
+							Regex rex = new Regex(&quot;[&quot;+myFilter.badChars+&quot;]&quot;,&quot;&quot;);
+							varParams.put(&quot;NAME&quot;, rex.replaceAll(holder.CacheName));
+						}
+						else {
+							varParams.put(&quot;NAME&quot;, holder.CacheName);
+						}
+						varParams.put(&quot;OWNER&quot;, holder.CacheOwner);
+						varParams.put(&quot;DIFFICULTY&quot;, dec.replaceAll(holder.hard));
+						varParams.put(&quot;TERRAIN&quot;, dec.replaceAll(holder.terrain));
+						varParams.put(&quot;DISTANCE&quot;, dec.replaceAll(holder.distance));
+						varParams.put(&quot;BEARING&quot;, holder.bearing);
+						varParams.put(&quot;LATLON&quot;, holder.LatLon);
+						varParams.put(&quot;LAT&quot;, dec.replaceAll(point.getLatDeg(CWPoint.DD)));
+						varParams.put(&quot;LON&quot;, dec.replaceAll(point.getLonDeg(CWPoint.DD)));
+						varParams.put(&quot;STATUS&quot;, holder.CacheStatus);
+						varParams.put(&quot;DATE&quot;, holder.DateHidden);
+						varParams.put(&quot;URL&quot;, holder.URL);
+						varParams.put(&quot;NOTES&quot;, holder.CacheNotes);
+						varParams.put(&quot;DESCRIPTION&quot;, holder.LongDescription);
+						cache_index.add(varParams);
+					}catch(Exception e){
+						Vm.debug(&quot;Problem getting Parameter, Cache: &quot; + holder.wayPoint);
+						e.printStackTrace();
+					}
+				}
+			}
+
+			tpl.setParam(&quot;cache_index&quot;, cache_index);
+			PrintWriter detfile; 
+			FileWriter fw = new FileWriter(saveTo);
+			fw.codec = myFilter.codec;
+			detfile = new PrintWriter(new BufferedWriter(fw));
+			tpl.printTo(detfile);
+			//detfile.print(tpl.output());
+			detfile.close();
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+		pbf.exit(0);
+	}
+
+
+}

Added: trunk/src/exp/TomTomExporter.java
===================================================================
--- trunk/src/exp/TomTomExporter.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/exp/TomTomExporter.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,281 @@
+package exp;
+
+
+import CacheWolf.*;
+import ewe.ui.*;
+import ewe.util.*;
+import ewe.util.zip.*;
+import ewe.filechooser.FileChooser;
+import ewe.io.*;
+import ewe.sys.*;
+
+public class TomTomExporter {
+	public final static int TT_ASC = 0;
+	public final static int TT_OV2 = 1;
+	public final static int TT_WPT_TEXT = 0;
+	public final static int TT_WPT_NUM = 1;
+
+	Vector cacheDB;
+	Preferences pref;
+	Profile profile;
+
+	
+	String[][] wayType = {{&quot;Custom&quot;,&quot;0&quot;},{&quot;Traditional&quot;,&quot;2&quot;},
+						{&quot;Multi&quot;,&quot;3&quot;}, {&quot;Virtual&quot;,&quot;4&quot;},
+						{&quot;Letterbox&quot;,&quot;5&quot;},{&quot;Event&quot;,&quot;6&quot;},
+						{&quot;Mega Event&quot;,&quot;453&quot;}, {&quot;Mystery&quot;,&quot;8&quot;},
+						{&quot;Webcam&quot;,&quot;11&quot;},{&quot;Locationless&quot;,&quot;12&quot;},
+						{&quot;CITO&quot;,&quot;13&quot;},{&quot;Earthcache&quot;,&quot;137&quot;},
+						{&quot;Parking&quot;,&quot;50&quot;},{&quot;Stage&quot;,&quot;51&quot;},
+						{&quot;Question&quot;,&quot;52&quot;},{&quot;Final&quot;,&quot;53&quot;},
+						{&quot;Trailhead&quot;,&quot;54&quot;},{&quot;Reference&quot;,&quot;55&quot;}};
+
+	
+	public TomTomExporter() {
+		profile = Global.getProfile();
+		pref = Global.getPref();
+		cacheDB = profile.cacheDB;
+	}
+	
+	public void doIt(){
+		String fileName, dirName, prefix;
+		int fileFormat;
+
+		TomTomExporterScreen infoScreen = new TomTomExporterScreen(&quot;TomTomExport&quot;);
+		if (infoScreen.execute() == Form.IDCANCEL) return;
+		fileFormat = infoScreen.getFormat();
+		
+		if (infoScreen.oneFilePerType()==true){
+			FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, profile.dataDir);
+			fc.setTitle(&quot;Select target dir:&quot;);
+			if(fc.execute() == FileChooser.IDCANCEL) return;
+			dirName = fc.getChosen();
+			prefix = infoScreen.getPrefix();
+			writeOneFilePerType(fileFormat, dirName, prefix);
+		} else{
+			FileChooser fc = new FileChooser(FileChooser.SAVE, profile.dataDir);
+			fc.setTitle(&quot;Select target file:&quot;);
+	
+			if (fileFormat == TT_ASC) fc.addMask(&quot;*.asc&quot;);
+			else fc.addMask(&quot;*.ov2&quot;);
+			
+			if(fc.execute() == FileChooser.IDCANCEL) return;
+			fileName = fc.getChosen();
+			writeSingleFile(fileFormat, fileName);
+		}
+	}
+	
+	public void writeOneFilePerType(int format, String dirName, String prefix){
+		RandomAccessFile out = null;
+		File dfile;
+		String ext, fileName = null;
+
+		CacheHolder holder;
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+		int currExp, counter;
+		CWPoint coords = new CWPoint();
+		
+		pbf.showMainTask = false;
+		pbf.setTask(h,&quot;Exporting ...&quot;);
+		pbf.exec();
+		
+		currExp = 0;
+		counter = 0;
+		for(int i = 0; i&lt;cacheDB.size();i++){
+			holder = (CacheHolder)cacheDB.get(i);
+			if(holder.is_black == false &amp;&amp; holder.is_filtered == false) counter++;
+		}
+		
+		ext = format==TT_ASC?&quot;.asc&quot;:&quot;.ov2&quot;;
+		try{
+			//loop through type
+			for(int j = 0; j &lt; wayType.length; j++){
+				fileName = dirName + &quot;/&quot; + prefix + wayType[j][TT_WPT_TEXT]+ ext;
+				dfile = new File(fileName);
+				dfile.delete();
+				out =  new RandomAccessFile(fileName,&quot;rw&quot;);
+				for(int i = 0; i&lt;cacheDB.size(); i++){
+					holder=(CacheHolder)cacheDB.get(i);
+					if(holder.type.equals(wayType[j][TT_WPT_NUM]) &amp;&amp; holder.is_black == false &amp;&amp; holder.is_filtered == false){
+						currExp++;
+						h.progress = (float)currExp/(float)counter;
+						h.changed();
+						coords.set(holder.LatLon, CWPoint.CW);
+						if (format == TT_ASC){
+							writeRecordASCII(out, holder,coords.getLatDeg(CWPoint.DD),coords.getLonDeg(CWPoint.DD));
+						} else {
+							writeRecordBinary(out, holder,coords.getLatDeg(CWPoint.DD),coords.getLonDeg(CWPoint.DD));
+						}
+					}//if
+				}//for cacheDB
+				out.close();
+				// check for empty files and delete them
+				dfile = new File(fileName);
+				if (dfile.length()==0) {
+					dfile.delete();
+				} else {
+					copyIcon(j, dirName + &quot;/&quot; + prefix + wayType[j][TT_WPT_TEXT]); 
+				}
+			}//for wayType
+			pbf.exit(0);
+		} catch (IOException e){
+			Vm.debug(&quot;Problem creating file! &quot; + fileName);
+			e.printStackTrace();
+		}//try
+		
+	}
+	
+	public void writeSingleFile(int format, String fileName){
+		RandomAccessFile out = null;
+		File dfile;
+
+		CacheHolder holder;
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+		CWPoint coords = new CWPoint();
+
+		pbf.showMainTask = false;
+		pbf.setTask(h,&quot;Exporting ...&quot;);
+		pbf.exec();
+
+		int counter = 0;
+		int expCount = 0;
+		for(int i = 0; i&lt;cacheDB.size();i++){
+			holder = (CacheHolder)cacheDB.get(i);
+			if(holder.is_black == false &amp;&amp; holder.is_filtered == false) counter++;
+		}
+
+		try{
+			dfile = new File(fileName);
+			dfile.delete();
+			out =  new RandomAccessFile(fileName,&quot;rw&quot;);
+			for(int i = 0; i&lt;cacheDB.size(); i++){
+				holder=(CacheHolder)cacheDB.get(i);
+				if(holder.is_black == false &amp;&amp; holder.is_filtered == false){
+					expCount++;
+					h.progress = (float)expCount/(float)counter;
+					h.changed();
+					coords.set(holder.LatLon, CWPoint.CW);
+					if (format == TT_ASC){
+						writeRecordASCII(out, holder,coords.getLatDeg(CWPoint.DD),coords.getLonDeg(CWPoint.DD));
+					} else {
+						writeRecordBinary(out, holder,coords.getLatDeg(CWPoint.DD),coords.getLonDeg(CWPoint.DD));
+					}
+				}//if
+			}//for
+			out.close();
+			copyIcon(0, fileName.substring(0,fileName.indexOf(&quot;.&quot;)));
+			pbf.exit(0);
+		}catch (Exception e){
+			Vm.debug(&quot;Problem writing to file! &quot; + fileName);
+			e.printStackTrace();
+		}//try
+	}
+	
+	
+	public void writeRecordASCII(RandomAccessFile outp, CacheHolder ch, String lat, String lon){
+		try {
+			outp.writeBytes(lon);
+			outp.writeBytes(&quot;,&quot;);
+			outp.writeBytes(lat);
+			outp.writeBytes(&quot;,&quot;);
+			outp.writeBytes(&quot;\&quot;&quot; + ch.CacheName.replace(',',' ') + &quot;\&quot;\r\n&quot;);
+		} catch (IOException e) {
+			Vm.debug(&quot;Error writing to file&quot;);
+			e.printStackTrace();
+		}
+		return;
+	}
+
+	
+	public void writeRecordBinary(RandomAccessFile outp, CacheHolder ch, String lat, String lon){
+		int d,data;
+		double latlon;
+		
+		try {
+			d = 2;
+			outp.writeByte((byte)d);
+			data = ch.wayPoint.length()+ch.CacheName.length()+ch.CacheOwner.length()+ch.hard.length()+ch.terrain.length()+ch.CacheSize.length()+27;
+			writeIntBinary(outp, data);
+			latlon = Common.parseDouble(lon);
+			latlon *=100000;
+			writeIntBinary(outp, (int) latlon);
+			latlon = Common.parseDouble(lat);;
+			latlon *=100000;
+			writeIntBinary(outp, (int) latlon);
+			outp.writeBytes(ch.wayPoint);
+			outp.writeBytes(&quot; - &quot;);
+			outp.writeBytes(ch.CacheName);
+			outp.writeBytes(&quot; by &quot;);
+			outp.writeBytes(ch.CacheOwner);
+			//Wenn Leerzeichen am Ende von Cache.Owner entfernt: 
+			//Hier wieder einf&#252;gen
+			//und data = holder.wayPoint.length()+holder.CacheName.length()+.....
+			//wider um 1 erh&#246;hen
+			outp.writeBytes(&quot;- &quot;);             
+			outp.writeBytes(ch.hard);
+			outp.writeBytes(&quot;/&quot;);
+			outp.writeBytes(ch.terrain);
+			outp.writeBytes(&quot; - &quot;);
+			outp.writeBytes(ch.CacheSize);
+			d = 0;
+			outp.writeByte((byte)d);
+		} catch (IOException e) {
+			Vm.debug(&quot;Error writing to file&quot;);
+			e.printStackTrace();
+		}
+
+		return;
+	}
+
+	public void writeIntBinary(RandomAccessFile outp, int data){
+		int a,b,c,d;
+		d = 0;
+		c = data / 65536;
+		b = (data - c *65536) / 256;
+		a = (data - c * 65536 - b * 256);
+
+		try {
+			outp.writeByte((byte)a);
+			outp.writeByte((byte)b);
+			outp.writeByte((byte)c);
+			outp.writeByte((byte)d);
+		} catch (IOException e) {
+			Vm.debug(&quot;Error writing to file&quot;);
+			e.printStackTrace();
+		}
+		return;
+	}
+	
+	public void copyIcon(int intWayType, String filename){
+		try {
+			ZipFile zif = new ZipFile (File.getProgramDirectory() + &quot;/POIIcons.zip&quot;);
+			ZipEntry zipEnt;
+			int len;
+			String entName; 
+			
+			entName = &quot;TomTomIcons/&quot;+ &quot;GC-&quot; + wayType[intWayType][TT_WPT_TEXT] + &quot;.bmp&quot;;
+			zipEnt = zif.getEntry(entName);
+			if (zipEnt == null) return;
+			
+		    byte[] buff = new byte[ (int) zipEnt.getSize() ];
+		    InputStream  fis = zif.getInputStream(zipEnt);
+		    FileOutputStream fos = new FileOutputStream( filename + &quot;.bmp&quot;);
+		    while( 0 &lt; (len = fis.read( buff )) )
+		      fos.write( buff, 0, len );
+		    fos.flush();
+		    fos.close();
+		    fis.close();
+		} catch (ZipException e) {
+			Vm.debug(&quot;Problem copying Icon&quot; + &quot;GC-&quot; + wayType[intWayType][TT_WPT_TEXT] + &quot;.bmp&quot; );
+			e.printStackTrace();
+		} catch (IOException e) {
+			Vm.debug(&quot;Problem copying Icon&quot; + &quot;GC-&quot; + wayType[intWayType][TT_WPT_TEXT] + &quot;.bmp&quot; );
+			e.printStackTrace();
+		}
+
+		
+	}
+	
+}

Added: trunk/src/exp/TomTomExporterScreen.java
===================================================================
--- trunk/src/exp/TomTomExporterScreen.java	2007-01-19 12:14:00 UTC (rev 405)
+++ trunk/src/exp/TomTomExporterScreen.java	2007-01-19 19:13:11 UTC (rev 406)
@@ -0,0 +1,81 @@
+package exp;
+
+import CacheWolf.MyLocale;
+import ewe.ui.*;
+
+public class TomTomExporterScreen extends Form {
+	mButton cancelB, okB;
+	mCheckBox chkASC, chkOV2, chkOneFilePerType;
+	CheckBoxGroup chkGroupFormat;
+	mInput inpPrefix;
+	
+	public TomTomExporterScreen(String title){
+		super();
+		this.title = title;
+
+		// checkboxgroup for fileformat
+		chkGroupFormat = new CheckBoxGroup();
+		chkASC = new mCheckBox(&quot;.asc&quot;);
+		chkASC.setGroup(chkGroupFormat);
+		chkOV2 = new mCheckBox(&quot;.ov2&quot;);
+		chkOV2.setGroup(chkGroupFormat);
+		chkGroupFormat.selectIndex(TomTomExporter.TT_OV2);
+		
+		this.addLast(new mLabel(&quot;Fileformat&quot;));
+		this.addNext(chkASC);
+		this.addLast(chkOV2);
+		
+		// checkbox for one file for all or one file per cachetype
+		chkOneFilePerType = new mCheckBox(&quot;Eine Datei pro Cachetyp&quot;);
+		chkOneFilePerType.setState(true);
+		this.addLast(chkOneFilePerType);
+		
+		//prefix for files, if one file per cachetype
+		inpPrefix = new mInput(&quot;GC-&quot;);
+		activateInpPrefix();
+		this.addLast(inpPrefix);
+		
+		// cancel and ok Button
+		cancelB = new mButton(MyLocale.getMsg(1604,&quot;Cancel&quot;));
+		cancelB.setHotKey(0, IKeys.ESCAPE);
+		this.addNext(cancelB,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		okB = new mButton(MyLocale.getMsg(1605,&quot;OK&quot;));
+		okB.setHotKey(0, IKeys.ACTION);
+		okB.setHotKey(0, IKeys.ENTER);
+		this.addLast(okB,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+	}
+	
+	public int getFormat() {
+		return chkGroupFormat.getSelectedIndex();
+	}
+	
+	public boolean oneFilePerType(){
+		return chkOneFilePerType.getState();
+	}
+	
+	public String getPrefix(){
+		return inpPrefix.getText();
+	}
+	
+	private void activateInpPrefix(){
+		if (chkOneFilePerType.getState()) inpPrefix.modify(0, ControlConstants.Disabled);
+		else inpPrefix.modify(ControlConstants.Disabled,0);
+		inpPrefix.repaintNow();
+	}
+
+	public void onEvent(Event ev){
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+			if (ev.target == cancelB){
+				this.close(Form.IDCANCEL);
+			}
+			if (ev.target == okB){
+				this.close(Form.IDOK);
+			}
+			if (ev.target == chkOneFilePerType){
+				activateInpPrefix(); 
+			}
+		}
+		super.onEvent(ev);
+	}
+
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000156.html">[Cachewolf-svn] [Bug #10043] be 401 Map.java
</A></li>
	<LI>Next message: <A HREF="000158.html">[Bug #10069] MovingMap: Import l&#228;uft ins falsche (alte) Verzeichnis
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#157">[ date ]</a>
              <a href="thread.html#157">[ thread ]</a>
              <a href="subject.html#157">[ subject ]</a>
              <a href="author.html#157">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
