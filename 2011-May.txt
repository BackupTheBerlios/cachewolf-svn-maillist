From araber95 at mail.berlios.de  Mon May  2 01:29:01 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Mon,  2 May 2011 01:29:01 PM +0200
Subject: [Cachewolf-svn] r2993 - trunk/res_noewe/webmapservices
Message-ID: <20110502112901.A14CB481255@sheep.berlios.de>

Author: araber95
Date: 2011-05-02 13:29:01 +0200 (Mon, 02 May 2011)
New Revision: 2993

Added:
   trunk/res_noewe/webmapservices/fr_t.wms
Log:
new wms for france inc oversee

Added: trunk/res_noewe/webmapservices/fr_t.wms
===================================================================
--- trunk/res_noewe/webmapservices/fr_t.wms	                        (rev 0)
+++ trunk/res_noewe/webmapservices/fr_t.wms	2011-05-02 11:29:01 UTC (rev 2993)
@@ -0,0 +1,90 @@
+?TakenFromUrl:       http://mapdmz.brgm.fr/cgi-bin/mapserv?map=/carto/infoterre/mapFiles/geocat_metr.map&
+GetCapabilitiesUrl: http://mapdmz.brgm.fr/cgi-bin/mapserv54?map=/carto/infoterre/mapFiles/geocat_metr.map&SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
+Name:               fr + (Guadeloupe..Polynesie) t
+MapType:                        topo
+MainUrl:            http://mapdmz.brgm.fr/cgi-bin/mapserv54?map=/carto/infoterre/mapFiles/geocat_metr.map&
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=METROPOLE|Fonds Geosignal|1.24725712107409|0
+#LayersUrlPart:     LAYERS=raster_geosignal|raster_geosignal||
+#LayersUrlPart:     LAYERS=WORLD_COUNTRIES_FR|Limites du monde|1496.70854528891|0
+#LayersUrlPart:     LAYERS=HydroSurf|Hydrographie surfacique - France metropolitaine|0|37.4182125350712
+#LayersUrlPart:     LAYERS=HydroLigne|Hydrographie lineaire - France metropolitaine|0|37.4182125350712
+#LayersUrlPart:     LAYERS=Routes|Reseau routier - France metropolitaine|0|37.4182125350712
+#LayersUrlPart:     LAYERS=fer|Reseau ferre - France metropolitaine|0|37.4182125350712
+#LayersUrlPart:     LAYERS=Communes|Communes - France metropolitaine|0|37.4182125350712
+
+#LayersUrlPart:     LAYERS=RASTER4000k|Raster Metropole 1/4 000 000|997.805696859274|4989.02848429637
+#LayersUrlPart:     LAYERS=RASTER1000k|Raster Metropole 1/1 000 000|374.177136322228|997.805696859274
+#LayersUrlPart:     LAYERS=RASTER500k_01|Raster Metropole 1/500 000|199.561139371855|374.177136322228
+#LayersUrlPart:     LAYERS=RASTER250k_01|Raster Metropole 1/250 000|99.7805696859274|199.561139371855
+#LayersUrlPart:     LAYERS=RASTER175k|Raster Metropole 1/175 000|62.3628560537046|99.7805696859274
+#LayersUrlPart:     LAYERS=RASTER100k_01|Raster Metropole 1/100 000|37.4177136322228|62.3628560537046
+#LayersUrlPart:     LAYERS=RASTER50k_01|Raster Metropole 1/50 000|17.4615996950373|37.4177136322228
+#LayersUrlPart:     LAYERS=RASTER25k_01|Raster Metropole 1/25 000|6.23628560537046|17.4615996950373
+#LayersUrlPart:     LAYERS=RASTER10k|Raster Metropole 1/10 000|3.74177136322228|6.23628560537046
+#LayersUrlPart:     LAYERS=RASTER5k_01|Raster Metropole 1/5 000|0|3.74177136322228
+
+#LayersUrlPart:     LAYERS=RASTER500k_02|Raster Guadeloupe 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_02|Raster Guadeloupe 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_02|Raster Guadeloupe 1/100 000|37.4177136322228|74.8354272644456
+#LayersUrlPart:     LAYERS=RASTER50k_02|Raster Guadeloupe 1/50 000|17.4615996950373|37.4177136322228
+#LayersUrlPart:     LAYERS=RASTER25k_02|Raster Guadeloupe 1/25 000|7.48354272644456|17.4615996950373
+#LayersUrlPart:     LAYERS=RASTER12_5k_01|Raster Guadeloupe 1/12 500|3.74177136322228|7.48354272644456
+#LayersUrlPart:     LAYERS=RASTER5k_02|Raster Guadeloupe 1/5 000|0|3.74177136322228
+
+#LayersUrlPart:     LAYERS=RASTER500k_03|Raster Guyane 1/500 000|174.615996950373|4989.02848429637
+#LayersUrlPart:     LAYERS=RASTER250k_03|Raster Guyane 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_03|Raster Guyane 1/100 000|37.4177136322228|74.8354272644456
+#LayersUrlPart:     LAYERS=RASTER50k_03|Raster Guyane 1/50 000|17.4615996950373|37.4177136322228
+#LayersUrlPart:     LAYERS=RASTER25k_03|Raster Guyane 1/25 000|7.48354272644456|17.4615996950373
+#LayersUrlPart:     LAYERS=RASTER12_5k_02|Raster Guyane 1/12 500|3.74177136322228|7.48354272644456
+#LayersUrlPart:     LAYERS=RASTER5k_03|Raster Guyane 1/5 000|0|3.74177136322228
+
+#LayersUrlPart:     LAYERS=RASTER500k_04|Raster Martinique 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_04|Raster Martinique 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_04|Raster Martinique 1/100 000|37.4177136322228|74.8354272644456
+#LayersUrlPart:     LAYERS=RASTER50k_04|Raster Martinique 1/50 000|17.4615996950373|37.4177136322228
+#LayersUrlPart:     LAYERS=RASTER25k_04|Raster Martinique 1/25 000|7.48354272644456|17.4615996950373
+#LayersUrlPart:     LAYERS=RASTER12_5k_03|Raster Martinique 1/12 500|3.74177136322228|7.48354272644456
+#LayersUrlPart:     LAYERS=RASTER5k_04|Raster Martinique 1/5 000|0|3.74177136322228
+
+#LayersUrlPart:     LAYERS=RASTER500k_05|Raster La Reunion 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_05|Raster La Reunion 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_05|Raster La Reunion 1/100 000|37.4177136322228|74.8354272644456
+#LayersUrlPart:     LAYERS=RASTER50k_05|Raster La Reunion 1/50 000|17.4615996950373|37.4177136322228
+#LayersUrlPart:     LAYERS=RASTER25k_05|Raster La Reunion 1/25 000|7.48354272644456|17.4615996950373
+#LayersUrlPart:     LAYERS=RASTER12_5k_04|Raster La Reunion 1/12 500|3.74177136322228|7.48354272644456
+#LayersUrlPart:     LAYERS=RASTER5k_05|Raster La Reunion 1/5 000|0|7.48354272644456
+
+#LayersUrlPart:     LAYERS=RASTER500k_06|Raster Mayotte 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_06|Raster Mayotte 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_06|Raster Mayotte 1/100 000|0|74.8354272644456
+
+#LayersUrlPart:     LAYERS=RASTER500k_07|Raster caledonie 1/500 000|174.615996950373|1496.70854528891
+#LayersUrlPart:     LAYERS=RASTER250k_07|Raster caledonie 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_07|Raster caledonie 1/100 000|0|74.8354272644456
+
+#LayersUrlPart:     LAYERS=RASTER500k_08|Raster Polynesie 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_08|Raster Polynesie 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_08|Raster Polynesie 1/100 000|0|1496.70854528891
+#LayersUrlPart:     LAYERS=RASTER500k_09|Raster Polynesie 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_09|Raster Polynesie 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_09|Raster Polynesie 1/100 000|0|1496.70854528891
+
+#LayersUrlPart:     LAYERS=RASTER500k_10|Raster Saint-Pierre et Miquelon 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_10|Raster Saint-Pierre et Miquelon 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_10|Raster Saint-Pierre et Miquelon 1/100 000|0|74.8354272644456
+LayersUrlPart:     LAYERS=raster_geosignal
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+#BoundingBoxTopLeftWGS84: N 51.1007 W 5.8482
+#BoundingBoxBottomRightWGS84: N 41.1326 E 11.1984
+#BBox_Mitte: N 46.11665 E 2.67511
+MinScale:   0
+MaxScale:   100
+RecommendedScale:   1 5
+ImageFileExtension: .jpg



From araber95 at mail.berlios.de  Mon May  2 01:30:16 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Mon,  2 May 2011 01:30:16 PM +0200
Subject: [Cachewolf-svn] r2994 - trunk/res_noewe/webmapservices
Message-ID: <20110502113016.C2BDF481255@sheep.berlios.de>

Author: araber95
Date: 2011-05-02 13:30:16 +0200 (Mon, 02 May 2011)
New Revision: 2994

Removed:
   trunk/res_noewe/webmapservices/fr_t25.wms
   trunk/res_noewe/webmapservices/fr_t5.wms
   trunk/res_noewe/webmapservices/fr_t50.wms
Log:
replaced by fr_t.wms

Deleted: trunk/res_noewe/webmapservices/fr_t25.wms
===================================================================
--- trunk/res_noewe/webmapservices/fr_t25.wms	2011-05-02 11:29:01 UTC (rev 2993)
+++ trunk/res_noewe/webmapservices/fr_t25.wms	2011-05-02 11:30:16 UTC (rev 2994)
@@ -1,55 +0,0 @@
-TakenFromUrl:       http://www.geosignal.org/cgi-bin/wmsmap?version=1.1.1&service=WMS&request=GetLegendGraphic&layer=Voirie&format=image/png
-GetCapabilitiesUrl: http://www.geosignal.org/cgi-bin/wmsmap?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
-Name:               fr t25 SF=3..7
-MapType:                        topo
-MainUrl:            http://www.geosignal.org/cgi-bin/wmsmap?
-ServiceTypeUrlPart: SERVICE=WMS
-VersionUrlPart:     VERSION=1.1.1
-CoordinateReferenceSystemCacheWolf:  4326
-CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
-#CoordinateReferenceSystemCacheWolf:  27582
-#CoordinateReferenceSystemUrlPart: SRS=EPSG:27582 
-#      <SRS>EPSG:27582</SRS>
-#      <SRS>EPSG:27572</SRS>
-#      <SRS>EPSG:27563</SRS>
-#      <SRS>EPSG:27561</SRS>
-#      <SRS>EPSG:4269</SRS>
-#      <SRS>EPSG:4326</SRS>
-RequestUrlPart:     REQUEST=GetMap
-#LayersUrlPart:     LAYERS=Serveur Geosignal|Serveur Geosignal||
-#LayersUrlPart:     LAYERS=Monde|Pays du monde||
-#LayersUrlPart:     LAYERS=RASTER4000k|Raster France 1/4 000 000|935.443|0
-#LayersUrlPart:     LAYERS=RASTER1000k|Raster France 1/1 000 000|280.633|935.443
-#LayersUrlPart:     LAYERS=RASTER500k|Raster France 1/500 000|140.316|280.633
-#LayersUrlPart:     LAYERS=RASTER250k|Raster France 1/250 000|65.481|140.316
-#LayersUrlPart:     LAYERS=RASTER100k|Raster France 1/100 000|28.0633|65.481
-#LayersUrlPart:     LAYERS=RASTER50k|Raster France 1/50 000|14.0316|28.0633
-#LayersUrlPart:     LAYERS=RASTER25k|Raster France 1/25 000|5.61266|14.0316
-#LayersUrlPart:     LAYERS=RASTER5k|Raster France 1/5 000|0.374177|5.61266
-#LayersUrlPart:     LAYERS=Communes|Communes||
-#LayersUrlPart:     LAYERS=Cantons|Cantons||
-#LayersUrlPart:     LAYERS=Arrondissements|Arrondissements||
-#LayersUrlPart:     LAYERS=Departements|Departements||
-#LayersUrlPart:     LAYERS=Regions|Regions||
-#LayersUrlPart:     LAYERS=Voirie|Voirie urbaine|1|5|Highways
-#LayersUrlPart:     LAYERS=Autres|Autres equipements routiers||
-#LayersUrlPart:     LAYERS=Secondaires|Routes Secondaires||
-#LayersUrlPart:     LAYERS=Departementales|Routes Departementales||
-#LayersUrlPart:     LAYERS=Nationales|Routes Nationales||
-#LayersUrlPart:     LAYERS=Autoroutes|Autoroutes||
-#LayersUrlPart:     LAYERS=CommunesXY|Ponctuels des communes||
-#LayersUrlPart:     LAYERS=Communes,Cantons,Arrondissements,Departements,Regions,Autres,Secondaires,Departementales,Nationales,Autoroutes,CommunesXY
-# working
-#LayersUrlPart:     LAYERS=RASTER5k SF=1(..2,5)
-#LayersUrlPart:     LAYERS=RASTER25k SF=3..7 ausgew?hlte St?dte?
-#LayersUrlPart:     LAYERS=RASTER50k SF=8..14
-#LayersUrlPart:     LAYERS=Voirie SF 1..10..
-LayersUrlPart:     LAYERS=RASTER25k
-StylesUrlPart:     STYLES=
-ImageFormatUrlPart:FORMAT=image/png
-BoundingBoxTopLeftWGS84: N 51.2918 W 6.06258
-BoundingBoxBottomRightWGS84: N 41.1632 E 10.8783
-#MinScale:   0
-#MaxScale:   45
-RecommendedScale:   1
-ImageFileExtension: .png

Deleted: trunk/res_noewe/webmapservices/fr_t5.wms
===================================================================
--- trunk/res_noewe/webmapservices/fr_t5.wms	2011-05-02 11:29:01 UTC (rev 2993)
+++ trunk/res_noewe/webmapservices/fr_t5.wms	2011-05-02 11:30:16 UTC (rev 2994)
@@ -1,55 +0,0 @@
-TakenFromUrl:       http://www.geosignal.org/cgi-bin/wmsmap?version=1.1.1&service=WMS&request=GetLegendGraphic&layer=Voirie&format=image/png
-GetCapabilitiesUrl: http://www.geosignal.org/cgi-bin/wmsmap?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
-Name:               fr t5 SF=1
-MapType:                        topo
-MainUrl:            http://www.geosignal.org/cgi-bin/wmsmap?
-ServiceTypeUrlPart: SERVICE=WMS
-VersionUrlPart:     VERSION=1.1.1
-CoordinateReferenceSystemCacheWolf:  4326
-CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
-#CoordinateReferenceSystemCacheWolf:  27582
-#CoordinateReferenceSystemUrlPart: SRS=EPSG:27582 
-#      <SRS>EPSG:27582</SRS>
-#      <SRS>EPSG:27572</SRS>
-#      <SRS>EPSG:27563</SRS>
-#      <SRS>EPSG:27561</SRS>
-#      <SRS>EPSG:4269</SRS>
-#      <SRS>EPSG:4326</SRS>
-RequestUrlPart:     REQUEST=GetMap
-#LayersUrlPart:     LAYERS=Serveur Geosignal|Serveur Geosignal||
-#LayersUrlPart:     LAYERS=Monde|Pays du monde||
-#LayersUrlPart:     LAYERS=RASTER4000k|Raster France 1/4 000 000|935.443|0
-#LayersUrlPart:     LAYERS=RASTER1000k|Raster France 1/1 000 000|280.633|935.443
-#LayersUrlPart:     LAYERS=RASTER500k|Raster France 1/500 000|140.316|280.633
-#LayersUrlPart:     LAYERS=RASTER250k|Raster France 1/250 000|65.481|140.316
-#LayersUrlPart:     LAYERS=RASTER100k|Raster France 1/100 000|28.0633|65.481
-#LayersUrlPart:     LAYERS=RASTER50k|Raster France 1/50 000|14.0316|28.0633
-#LayersUrlPart:     LAYERS=RASTER25k|Raster France 1/25 000|5.61266|14.0316
-#LayersUrlPart:     LAYERS=RASTER5k|Raster France 1/5 000|0.374177|5.61266
-#LayersUrlPart:     LAYERS=Communes|Communes||
-#LayersUrlPart:     LAYERS=Cantons|Cantons||
-#LayersUrlPart:     LAYERS=Arrondissements|Arrondissements||
-#LayersUrlPart:     LAYERS=Departements|Departements||
-#LayersUrlPart:     LAYERS=Regions|Regions||
-#LayersUrlPart:     LAYERS=Voirie|Voirie urbaine|1|5|Highways
-#LayersUrlPart:     LAYERS=Autres|Autres equipements routiers||
-#LayersUrlPart:     LAYERS=Secondaires|Routes Secondaires||
-#LayersUrlPart:     LAYERS=Departementales|Routes Departementales||
-#LayersUrlPart:     LAYERS=Nationales|Routes Nationales||
-#LayersUrlPart:     LAYERS=Autoroutes|Autoroutes||
-#LayersUrlPart:     LAYERS=CommunesXY|Ponctuels des communes||
-#LayersUrlPart:     LAYERS=Communes,Cantons,Arrondissements,Departements,Regions,Autres,Secondaires,Departementales,Nationales,Autoroutes,CommunesXY
-# working
-#LayersUrlPart:     LAYERS=RASTER5k SF=1(..2,5)
-#LayersUrlPart:     LAYERS=RASTER25k SF=3..7
-#LayersUrlPart:     LAYERS=RASTER50k SF=8..14
-#LayersUrlPart:     LAYERS=Voirie SF 1..10..
-LayersUrlPart:     LAYERS=RASTER5k
-StylesUrlPart:     STYLES=
-ImageFormatUrlPart:FORMAT=image/png
-BoundingBoxTopLeftWGS84: N 51.2918 W 6.06258
-BoundingBoxBottomRightWGS84: N 41.1632 E 10.8783
-#MinScale:   0
-#MaxScale:   45
-RecommendedScale:   1
-ImageFileExtension: .png

Deleted: trunk/res_noewe/webmapservices/fr_t50.wms
===================================================================
--- trunk/res_noewe/webmapservices/fr_t50.wms	2011-05-02 11:29:01 UTC (rev 2993)
+++ trunk/res_noewe/webmapservices/fr_t50.wms	2011-05-02 11:30:16 UTC (rev 2994)
@@ -1,55 +0,0 @@
-TakenFromUrl:       http://www.geosignal.org/cgi-bin/wmsmap?version=1.1.1&service=WMS&request=GetLegendGraphic&layer=Voirie&format=image/png
-GetCapabilitiesUrl: http://www.geosignal.org/cgi-bin/wmsmap?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities
-Name:               fr t50 SF=8..14
-MapType:                        topo
-MainUrl:            http://www.geosignal.org/cgi-bin/wmsmap?
-ServiceTypeUrlPart: SERVICE=WMS
-VersionUrlPart:     VERSION=1.1.1
-CoordinateReferenceSystemCacheWolf:  4326
-CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
-#CoordinateReferenceSystemCacheWolf:  27582
-#CoordinateReferenceSystemUrlPart: SRS=EPSG:27582 
-#      <SRS>EPSG:27582</SRS>
-#      <SRS>EPSG:27572</SRS>
-#      <SRS>EPSG:27563</SRS>
-#      <SRS>EPSG:27561</SRS>
-#      <SRS>EPSG:4269</SRS>
-#      <SRS>EPSG:4326</SRS>
-RequestUrlPart:     REQUEST=GetMap
-#LayersUrlPart:     LAYERS=Serveur Geosignal|Serveur Geosignal||
-#LayersUrlPart:     LAYERS=Monde|Pays du monde||
-#LayersUrlPart:     LAYERS=RASTER4000k|Raster France 1/4 000 000|935.443|0
-#LayersUrlPart:     LAYERS=RASTER1000k|Raster France 1/1 000 000|280.633|935.443
-#LayersUrlPart:     LAYERS=RASTER500k|Raster France 1/500 000|140.316|280.633
-#LayersUrlPart:     LAYERS=RASTER250k|Raster France 1/250 000|65.481|140.316
-#LayersUrlPart:     LAYERS=RASTER100k|Raster France 1/100 000|28.0633|65.481
-#LayersUrlPart:     LAYERS=RASTER50k|Raster France 1/50 000|14.0316|28.0633
-#LayersUrlPart:     LAYERS=RASTER25k|Raster France 1/25 000|5.61266|14.0316
-#LayersUrlPart:     LAYERS=RASTER5k|Raster France 1/5 000|0.374177|5.61266
-#LayersUrlPart:     LAYERS=Communes|Communes||
-#LayersUrlPart:     LAYERS=Cantons|Cantons||
-#LayersUrlPart:     LAYERS=Arrondissements|Arrondissements||
-#LayersUrlPart:     LAYERS=Departements|Departements||
-#LayersUrlPart:     LAYERS=Regions|Regions||
-#LayersUrlPart:     LAYERS=Voirie|Voirie urbaine|1|5|Highways
-#LayersUrlPart:     LAYERS=Autres|Autres equipements routiers||
-#LayersUrlPart:     LAYERS=Secondaires|Routes Secondaires||
-#LayersUrlPart:     LAYERS=Departementales|Routes Departementales||
-#LayersUrlPart:     LAYERS=Nationales|Routes Nationales||
-#LayersUrlPart:     LAYERS=Autoroutes|Autoroutes||
-#LayersUrlPart:     LAYERS=CommunesXY|Ponctuels des communes||
-#LayersUrlPart:     LAYERS=Communes,Cantons,Arrondissements,Departements,Regions,Autres,Secondaires,Departementales,Nationales,Autoroutes,CommunesXY
-# working
-#LayersUrlPart:     LAYERS=RASTER5k SF=1(..2,5)
-#LayersUrlPart:     LAYERS=RASTER25k SF=3..7 ausgew?hlte St?dte?
-#LayersUrlPart:     LAYERS=RASTER50k SF=8..14
-#LayersUrlPart:     LAYERS=Voirie SF 1..10..
-LayersUrlPart:     LAYERS=RASTER50k
-StylesUrlPart:     STYLES=
-ImageFormatUrlPart:FORMAT=image/png
-BoundingBoxTopLeftWGS84: N 51.2918 W 6.06258
-BoundingBoxBottomRightWGS84: N 41.1632 E 10.8783
-#MinScale:   0
-#MaxScale:   45
-RecommendedScale:   1
-ImageFileExtension: .png



From araber95 at mail.berlios.de  Fri May  6 05:11:39 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Fri,  6 May 2011 05:11:39 PM +0200
Subject: [Cachewolf-svn] r2995 - in trunk: res_noewe src/CacheWolf
	src/CacheWolf/imp src/CacheWolf/navi
Message-ID: <20110506151139.F36404812A2@sheep.berlios.de>

Author: araber95
Date: 2011-05-06 17:11:39 +0200 (Fri, 06 May 2011)
New Revision: 2995

Modified:
   trunk/res_noewe/spider.def
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/PreferencesScreen.java
   trunk/src/CacheWolf/UrlFetcher.java
   trunk/src/CacheWolf/imp/SpiderGC.java
   trunk/src/CacheWolf/navi/MapInfoObject.java
Log:
 first adaption of gc-changes : 
 1. using userID cause login with https not yet implemented.
 2. update import definitions. (spider.def)
 3. using new map for "quick import"
smal corrt in mapInfoObject

Modified: trunk/res_noewe/spider.def
===================================================================
--- trunk/res_noewe/spider.def	2011-05-02 11:30:16 UTC (rev 2994)
+++ trunk/res_noewe/spider.def	2011-05-06 15:11:39 UTC (rev 2995)
@@ -53,7 +53,8 @@
 # * When entering spaces into a string ensure to escape them or write them as \\u0020
 # * Be sure that you have no hidden spaces at the end of a line or the patterns will not match!
 #------------------------------------------------------------
-loginPage          = http://www.geocaching.com/login/default.aspx
+#loginPage          = http://www.geocaching.com/login/default.aspx
+loginPage          = https://www.geocaching.com/login/default.aspx
 loginSuccess       = You\ are\ logged\ in\ as
 nextPage           = /login/default.aspx
 waypoint           = http://www.geocaching.com/seek/cache_details.aspx?wp=
@@ -67,8 +68,8 @@
 maxDistance        = &dist=
 nextListPage       = /seek/nearest.aspx
 # Regex to search for cachenames
-listBlockRex       = <table id="ctl00_ContentBody_dlResults"((?s).*?)</table>
-lineRex            = <tr\ bgcolor='#.{6}'\\s*class="Data\ BorderTop">((?s).*?)</tr>
+listBlockRex       = <table\ class="SearchResultsTable\ Table">((?s).*?)</table>
+lineRex            = Data\ BorderTop">((?s).*?)</tr>
 logDateRex         = <td valign="top">\\s*(.*?)<br\ />
 availableRex       = class="lnk\ \ Strike">
 archivedRex        = class="lnk\ OldWarning\ Strike\ Strike">
@@ -78,7 +79,7 @@
 distRex            = (.*?)(?:km|mi|ft)
 DTSRex             = v=(.*?)"
 DTSCodeKey         = hbM9fjmrxy7z42LFD58BkKgPGdHscvCqNnw3ptO6lJ
-waypointRex        = \\(GC(.*?)\\)<br\ />
+waypointRex        = \\|\\s+GC(.*?)\\s+
 TypeRex            = www.geocaching.com/images/wpttypes/sm/(.*?)\\.gif
 found              = class="Success"
 own                = /WptTypes/name_tag.gif
@@ -109,9 +110,8 @@
 cacheArchived      = class="OldWarning"><li>This\ cache\ has\ been\ archived
 premiumCachepage   = class="Warning">listing\ visible\ to\ Premium
 latLonRex          = tBody_LatLon"\ style="font-weight:bold;">((?s).*?)</span>
-#latLonRex          = tBody_LatLon"><b>((?s).*?)</b></span>
 shortDescRex       = tBody_ShortDescription">((?s).*?)</span>
-longDescRex        = tBody_LongDescription">((?s).*?)<td\ valign="top"\ width="10%">\\s*&nbsp;\\s*</td
+longDescRex        = tBody_LongDescription">((?s).*?)</span>\\s+</div>
 cacheNameRex       = tBody_CacheName">((?s).*?)</span>
 cacheOwnerRex      = &wid(?:(?s).*?)>((?s).*?)<
 dateHiddenRex      = (?:Hidden|Event\ Date)\\s*:\\s*((?s).*?)<
@@ -126,7 +126,7 @@
 #Section2a: Logs
 #--------------------------------------
 # blockRex extrahiert zun?chst aus der gesamten Seite den Logbereich
-blockRex           = <table class="LogsTable Table">((?s).*?)<td></td></tr></table>
+blockRex           = <table class="LogsTable">((?s).*?)</table>\\s+<p>\\s+</p>
 # singleLogEx extrahiert in einer Schleife alle Logs aus dem Logbereich
 singleLogExStart   = ><strong><img src=
 singleLogExEnd     = <small><a\ href="
@@ -161,8 +161,8 @@
 bugLinkEnd         = "\ class="lnk">
 bugNameExStart     = <span>
 bugNameExEnd       = </span>
-bugDetailsStart    = "og:description"\ content="
-bugDetailsEnd      = "\ property="og:desc
+bugDetailsStart    = <meta\ name="og:description"\ content="
+bugDetailsEnd      = "\ property="og:description"
 getBugByName       = http://www.geocaching.com/track/search.aspx?k=
 getBugByGuid       = http://www.geocaching.com/track/details.aspx?guid=
 getBugById         = http://www.geocaching.com/track/details.aspx?id=

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2011-05-02 11:30:16 UTC (rev 2994)
+++ trunk/src/CacheWolf/Preferences.java	2011-05-06 15:11:39 UTC (rev 2995)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.Metrics;
@@ -51,30 +51,28 @@
 import ewe.util.Enumeration;
 import ewe.util.Hashtable;
 import ewe.util.Iterator;
+import ewe.util.Map.MapEntry;
 import ewe.util.StringTokenizer;
 import ewe.util.Utils;
-import ewe.util.Map.MapEntry;
 import ewesoft.xml.MinML;
 import ewesoft.xml.sax.AttributeList;
 
 /**
- *	A class to hold the preferences that were loaded upon start up of CacheWolf.
- *	This class is also capable of parsing the prefs.xml file as well as
- *	saving the current settings of preferences.
+ * A class to hold the preferences that were loaded upon start up of CacheWolf. This class is also capable of parsing the prefs.xml file as well as saving the current settings of preferences.
  */
-public class Preferences extends MinML{
+public class Preferences extends MinML {
 
-	public final int DEFAULT_MAX_LOGS_TO_SPIDER=250;
-	public final int DEFAULT_LOGS_PER_PAGE=5;
-	public final int DEFAULT_INITIAL_HINT_HEIGHT=10;
-	public final int DEFAULT_GPSD_PORT=2947;
-	public static final int GPSD_DISABLED   = 0; // do not use gpsd
+	public final int DEFAULT_MAX_LOGS_TO_SPIDER = 250;
+	public final int DEFAULT_LOGS_PER_PAGE = 5;
+	public final int DEFAULT_INITIAL_HINT_HEIGHT = 10;
+	public final int DEFAULT_GPSD_PORT = 2947;
+	public static final int GPSD_DISABLED = 0; // do not use gpsd
 	public static final int GPSD_FORMAT_OLD = 1; // use old protocol
 	public static final int GPSD_FORMAT_NEW = 2; // use new protocol (JSON)
 	public static final int YES = 0;
 	public static final int NO = 1;
 	public static final int ASK = 2;
-	public static String NEWLINE="\n";
+	public static String NEWLINE = "\n";
 	// Hashtable is saving filter data objects the user wants to save
 	private Hashtable filterList = new Hashtable(15);
 	/** screen is big enough to hold additional information like cache notes */
@@ -83,12 +81,13 @@
 	// TODO: make this configurable via pref.xml
 	public boolean useBigIcons;
 
-	//////////////////////////////////////////////////////////////////////////////////////
-    // Constructor
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Constructor
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	/**
 	 * Singleton pattern - return reference to Preferences
+	 * 
 	 * @return Singleton Preferences object
 	 */
 	public static Preferences getPrefObject() {
@@ -104,81 +103,75 @@
 
 	/**
 	 * Call this method to set the path of the config file <br>
-	 * If you call it with null it defaults to [program-dir]/pref.xml
-	 * if p is a directory "pref.xml" will automatically appended
+	 * If you call it with null it defaults to [program-dir]/pref.xml if p is a directory "pref.xml" will automatically appended
+	 * 
 	 * @param p
 	 */
 	public void setPathToConfigFile(String p) {
 		String p_;
 		if (p == null) {
 			/*
-			String test;
-			test = Vm.getenv("APPDATA", "/"); // returns in java-vm on win xp: c:\<dokumente und Einstellungen>\<username>\<application data>
-			log("Vm.getenv(APPDATA: " + test); // this works also in win32.exe (ewe-vm on win xp)
-			test = Vm.getenv("HOME", "/"); // This should return on *nix system the home dir
-			log("Vm.getenv(HOME: " + test);
-			test = System.getProperty("user.dir"); // return in java-vm on win xp: <working dir> or maybe <program dir>
-			log("System.getProperty(user.dir: " + test); // in win32.exe -> null
-			test = System.getProperty("user.home"); // in MS-java-VM env variable $HOME is ignored and always <windir>\java returned, see http://support.microsoft.com/kb/177181/en-us/
-			log("System.getProperty(user.home: " + test); // in win32.exe -> null
-			// "user.dir"              User's current working directory
-			// "user.home"             User home directory (taken from http://scv.bu.edu/Doc/Java/tutorial/java/system/properties.html )
+			 * String test; test = Vm.getenv("APPDATA", "/"); // returns in java-vm on win xp: c:\<dokumente und Einstellungen>\<username>\<application data> log("Vm.getenv(APPDATA: " + test); // this works also in win32.exe (ewe-vm on win xp) test =
+			 * Vm.getenv("HOME", "/"); // This should return on *nix system the home dir log("Vm.getenv(HOME: " + test); test = System.getProperty("user.dir"); // return in java-vm on win xp: <working dir> or maybe <program dir>
+			 * log("System.getProperty(user.dir: " + test); // in win32.exe -> null test = System.getProperty("user.home"); // in MS-java-VM env variable $HOME is ignored and always <windir>\java returned, see
+			 * http://support.microsoft.com/kb/177181/en-us/ log("System.getProperty(user.home: " + test); // in win32.exe -> null // "user.dir" User's current working directory // "user.home" User home directory (taken from
+			 * http://scv.bu.edu/Doc/Java/tutorial/java/system/properties.html )
 			 */
 			p_ = FileBase.makePath(FileBase.getProgramDirectory(), "pref.xml");
+		} else {
+			if (new FileBugfix(p).isDirectory())
+				p_ = FileBase.makePath(p, "pref.xml");
+			else
+				p_ = p;
 		}
-		else {
-			if (new FileBugfix(p).isDirectory()) p_ = FileBase.makePath(p, "pref.xml");
-			else p_ = p;
-		}
 		pathToConfigFile = STRreplace.replace(p_, "//", "/"); // this is necessary in case that the root dir is the dir where the pref.xml is stored
 		pathToConfigFile = pathToConfigFile.replace('\\', '/');
-		p=System.getProperty("os.name");
-		if (p==null || p.indexOf("indows")!=-1) {
+		p = System.getProperty("os.name");
+		if (p == null || p.indexOf("indows") != -1) {
 			NEWLINE = "\r\n";
-		} 
+		}
 	}
 
 	/**
 	 * Constructor is private for a singleton object
 	 */
-	private Preferences(){
+	private Preferences() {
 		mySPO.bits = 8;
 		mySPO.parity = SerialPort.NOPARITY;
 		mySPO.stopBits = 1;
 		mySPO.baudRate = 4800;
-		if ( ((ewe.fx.Rect) (Window.getGuiInfo(WindowConstants.INFO_SCREEN_RECT,null,new ewe.fx.Rect(),0))).height > 400) {
+		if (((ewe.fx.Rect) (Window.getGuiInfo(WindowConstants.INFO_SCREEN_RECT, null, new ewe.fx.Rect(), 0))).height > 400) {
 			if (Vm.getPlatform().equals("Unix"))
 				fontSize = 12;
-			else{
+			else {
 				// Default on VGA-PDAs: fontSize 21 + adjust ColWidth
-				if (Vm.isMobile()){
+				if (Vm.isMobile()) {
 					fontSize = 21;
-					listColWidth="20,20,30,30,92,177,144,83,60,105,50,104,22,30,30";
-				}
-				else
+					listColWidth = "20,20,30,30,92,177,144,83,60,105,50,104,22,30,30";
+				} else
 					fontSize = 16;
 			}
 		} else
 			fontSize = 11;
 	}
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Public fields stored in pref.xml
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Public fields stored in pref.xml
+	// ////////////////////////////////////////////////////////////////////////////////////
 
-	/** The base directory contains one subdirectory for each profile*/
+	/** The base directory contains one subdirectory for each profile */
 	private String baseDir = "";
 	public String absoluteBaseDir = "";
 	/** Name of last used profile */
-	public String lastProfile="";
+	public String lastProfile = "";
 	/** If true, the last profile is reloaded automatically without a dialogue */
-	public boolean autoReloadLastProfile=false;
-	/** If true current cetre will be set from gps position	 */
-	public boolean setCurrentCentreFromGPSPosition=true;
+	public boolean autoReloadLastProfile = false;
+	/** If true current cetre will be set from gps position */
+	public boolean setCurrentCentreFromGPSPosition = true;
 	/** This is the login alias for geocaching.com and opencaching.de */
 	public String myAlias = "";
 	/** Optional password */
-	public String password="";
+	public String password = "";
 	/** This is an alternative alias used to identify found caches (i.e. if using multiple IDs) */
 	public String myAlias2 = "";
 	/** The path to the browser */
@@ -188,7 +181,7 @@
 	/** HTTP proxy port when spidering */
 	public String myproxyport = "";
 	/** Flag whether proxy is to be used */
-	public boolean proxyActive=false;
+	public boolean proxyActive = false;
 	/** Serial port name and baudrate */
 	public SerialPortOptions mySPO = new SerialPortOptions();
 	/** True if the GPS data should be forwarded to an IP address */
@@ -210,65 +203,67 @@
 	public String fontName;
 	// These settings govern where the menu and the tabs are displayed and whether the statusbas is shown
 	/** True if the menu is to be displayed at the top of the screen */
-	public boolean menuAtTop=true;
+	public boolean menuAtTop = true;
 	/** True if the tabs are to be displayed at the top of the screen */
-	public boolean tabsAtTop=true;
+	public boolean tabsAtTop = true;
 	/** True if the status bar is to be displayed (hidden if false) */
-	public boolean showStatus=true;
-	//public boolean noTabs=false;
-	/** True if the application can be closed by clicking on the close button in the top line.
-	 * This can be set to avoid accidental closing of the application */
-	public boolean hasCloseButton=true;
+	public boolean showStatus = true;
+	// public boolean noTabs=false;
+	/**
+	 * True if the application can be closed by clicking on the close button in the top line. This can be set to avoid accidental closing of the application
+	 */
+	public boolean hasCloseButton = true;
 	/** True if the SIP is always visible */
 	public boolean fixSIP = false;
 	/** The list of visible columns in the list view */
-	public String listColMap="0,1,2,3,4,5,6,7,8,9,10,11,12";
+	public String listColMap = "0,1,2,3,4,5,6,7,8,9,10,11,12";
 	/** The widths for each column in list view */
-	public String listColWidth="15,20,20,25,92,177,144,83,60,105,50,104,22,30,30,30,30,30,30,30";
+	public String listColWidth = "15,20,20,25,92,177,144,83,60,105,50,104,22,30,30,30,30,30,30,30";
 	/** The columns which are to be displayed in TravelbugsJourneyScreen. See also TravelbugJourney */
-	public String travelbugColMap="1,4,5,6,8,9,10,7";
+	public String travelbugColMap = "1,4,5,6,8,9,10,7";
 	/** The column widths for the travelbug journeys. */
-	public String travelbugColWidth="212,136,62,90,50,56,90,38,50,50,94,50";
+	public String travelbugColWidth = "212,136,62,90,50,56,90,38,50,50,94,50";
 	/** If this flag is true, only non-logged travelbug journeys will be shown */
-	public boolean travelbugShowOnlyNonLogged=false;
+	public boolean travelbugShowOnlyNonLogged = false;
 	/** If this is true, deleted images are shown with a ? in the imagepanel */
-	public boolean showDeletedImages=true;
+	public boolean showDeletedImages = true;
 	/** This setting determines how many logs are shown per page of hintlogs (default 5) */
-	public int logsPerPage=DEFAULT_LOGS_PER_PAGE;
+	public int logsPerPage = DEFAULT_LOGS_PER_PAGE;
 	/** Initial height of hints field (set to 0 to hide them initially) */
-	public int initialHintHeight=DEFAULT_INITIAL_HINT_HEIGHT;
+	public int initialHintHeight = DEFAULT_INITIAL_HINT_HEIGHT;
 	/** Maximum logs to spider */
 	public int maxLogsToSpider = DEFAULT_MAX_LOGS_TO_SPIDER;
 	/** True if the Solver should ignore the case of variables */
-	public boolean solverIgnoreCase=true;
+	public boolean solverIgnoreCase = true;
 	/** True if the solver expects arguments for trigonometric functions in degrees */
-	public boolean solverDegMode=true;
+	public boolean solverDegMode = true;
 	/** True if the description panel should show images */
-	public boolean descShowImg=true;
+	public boolean descShowImg = true;
 	/** The type of connection which GPSBABEL uses: com1 OR usb. */
-	public String garminConn="com1";
+	public String garminConn = "com1";
 	/** Additional options for GPSBabel, i.e. -s to synthethise short names */
-	public String garminGPSBabelOptions="";
+	public String garminGPSBabelOptions = "";
 	/** Max. length for Garmin waypoint names (for etrex which can only accept 6 chars) */
-	public int garminMaxLen=0;
+	public int garminMaxLen = 0;
 	/** OC true = alle neu Laden false = wenn ?nderungsdatum neuer */
 	public boolean downloadAllOC = false;
-	public String lastOCSite=OC.OCSites[0][OC.OC_HOSTNAME];
-	/** The currently used centre point, can be different from the profile's centrepoint. This is used
-	 *  for spidering */
-	private CWPoint curCentrePt=new CWPoint();
+	public String lastOCSite = OC.OCSites[0][OC.OC_HOSTNAME];
+	/**
+	 * The currently used centre point, can be different from the profile's centrepoint. This is used for spidering
+	 */
+	private CWPoint curCentrePt = new CWPoint();
 	/** True if a login screen is displayed on each spider operation */
-	public boolean forceLogin=true;
+	public boolean forceLogin = true;
 	/** True if the goto panel is North centered */
 	public boolean northCenteredGoto = true;
 	/** If not null, a customs map path has been specified by the user */
-	private String customMapsPath=null;
+	private String customMapsPath = null;
 	/** Number of CacheHolder details that are kept in memory */
-	public int maxDetails=50;
+	public int maxDetails = 50;
 	/** Number of details to delete when maxDetails have been stored in cachesWithLoadedDetails */
-	public int deleteDetails=5;
+	public int deleteDetails = 5;
 	/** The locale code (DE, EN, ...) */
-	public String language="";
+	public String language = "";
 	/** The metric system to use */
 	public int metricSystem = Metrics.METRIC;
 	/** Load updated caches while spidering */
@@ -282,26 +277,27 @@
 	/** The own GC member ID */
 	public String gcMemberId = "";
 	/** Premium Member ? */
-	public boolean isPremium=true;
+	public boolean isPremium = true;
 	/** The maximum number of logs to export */
 	public int numberOfLogsToExport = 5;
 	/** Add Travelbugs when exporting */
 	public boolean exportTravelbugs = false;
 	/** Try to make a MyFinds GPX when exporting to GPX */
 	public boolean exportGpxAsMyFinds = true;
-	/** Check if lastFound is newer than saved log*/
-	public boolean checkLog=false;
-	/** Check if presence of TBs changed*/
-	public boolean checkTBs=true;
-	/** Check if presence of DTS changed*/
-	public boolean checkDTS=true;
-	/** menu of spider along a route exists*/
-	public boolean spiderRoute=false;
+	/** Check if lastFound is newer than saved log */
+	public boolean checkLog = false;
+	/** Check if presence of TBs changed */
+	public boolean checkTBs = true;
+	/** Check if presence of DTS changed */
+	public boolean checkDTS = true;
+	/** menu of spider along a route exists */
+	public boolean spiderRoute = false;
 	/** Download images when loading cache data */
 	public boolean downloadPics = true;
 	/** Download TB information when loading cache data */
 	public boolean downloadTBs = true;
-	/** Last mode select in the DataMover for processing cache*/
+	public String userID = "";
+	/** Last mode select in the DataMover for processing cache */
 	public int processorMode = 0;
 	/** maximum number of logs to store in cache details */
 	public int maxLogsToKeep = DEFAULT_MAX_LOGS_TO_SPIDER;
@@ -309,46 +305,49 @@
 	public boolean alwaysKeepOwnLogs = true;
 
 	/** Determines whether to fill the white areas on the map */
-	public boolean fillWhiteArea=false;
+	public boolean fillWhiteArea = false;
 
-    /** Selected Size of map tiles */
-    public int mapTileSize=1;
-    /** How many should maptiles overlap */
-    public int mapOverlapping=100;
-    /** Width and height of free defined tile size */
-    public int tilewidth;
-    public int tileheight;
-    
-    /** ShowCachesOnMap */
-    public boolean showCachesOnMap=true;
+	/** Selected Size of map tiles */
+	public int mapTileSize = 1;
+	/** How many should maptiles overlap */
+	public int mapOverlapping = 100;
+	/** Width and height of free defined tile size */
+	public int tilewidth;
+	public int tileheight;
 
-    /** SortingGroupedByCache */
-    public boolean SortingGroupedByCache=true;
+	/** ShowCachesOnMap */
+	public boolean showCachesOnMap = true;
 
-    /** useOwnSymbols */
-    public boolean useOwnSymbols=true;
+	/** SortingGroupedByCache */
+	public boolean SortingGroupedByCache = true;
 
-    /** TRUE if we want automatic sorting **/
-    public boolean sortAutomatic = true;
+	/** useOwnSymbols */
+	public boolean useOwnSymbols = true;
 
-	//////////////////////////////////////////////
-	/** The debug switch (Can be used to activate dormant code) by adding
-	 * the line: <pre><debug value="true" /></pre>
+	/** TRUE if we want automatic sorting **/
+	public boolean sortAutomatic = true;
+
+	// ////////////////////////////////////////////
+	/**
+	 * The debug switch (Can be used to activate dormant code) by adding the line:
+	 * 
+	 * <pre>
+	 * <debug value="true" />
+	 * </pre>
+	 * 
 	 * to the pref.xml file.
 	 */
 	public boolean debug = false;
-	//////////////////////////////////////////////
+	// ////////////////////////////////////////////
 
 	/**
-	 * This switches the behaviour of GUI-Element factories. If set to true, it will construct alternative Forms.
-	 * It can only be set in the Preference-File directly, not by user-interaction now.
-	 * Add  <MobileGui value="true"/> to your pref.xml
+	 * This switches the behaviour of GUI-Element factories. If set to true, it will construct alternative Forms. It can only be set in the Preference-File directly, not by user-interaction now. Add <MobileGui value="true"/> to your pref.xml
 	 */
 	public boolean mobileGUI = false;
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Public fields not stored in pref.xml
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Public fields not stored in pref.xml
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	/** The height of the application */
 	public int myAppHeight = 600;
@@ -359,28 +358,27 @@
 
 	private String pathToProfile;
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Read pref.xml file
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Read pref.xml file
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	/**
-	 * Method to open and parse the config file (pref.xml). Results are stored in the
-	 * public variables of this class.
-	 * If you want to specify a non default config file call setPathToConfigFile() first.
+	 * Method to open and parse the config file (pref.xml). Results are stored in the public variables of this class. If you want to specify a non default config file call setPathToConfigFile() first.
 	 */
-	public void readPrefFile(){
-		if (pathToConfigFile == null) setPathToConfigFile(null); // this sets the default value
-		try{
+	public void readPrefFile() {
+		if (pathToConfigFile == null)
+			setPathToConfigFile(null); // this sets the default value
+		try {
 			ewe.io.Reader r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(pathToConfigFile));
 			parse(r);
 			r.close();
-		}catch(IOException e){
+		} catch (IOException e) {
 			log("IOException reading config file: " + pathToConfigFile, e, true);
 			browser = getDefaultBrowser();
 			(new MessageBox(MyLocale.getMsg(327, "Information"), MyLocale.getMsg(176, "First start - using default preferences \n For experts only: \n Could not read preferences file:\n") + pathToConfigFile, FormBase.OKB)).execute();
-		}catch(Exception e){
+		} catch (Exception e) {
 			if (e instanceof NullPointerException)
-				log("Error reading pref.xml: NullPointerException in Element "+lastName +". Wrong attribute?",e,true);
+				log("Error reading pref.xml: NullPointerException in Element " + lastName + ". Wrong attribute?", e, true);
 			else
 				log("Error reading pref.xml: ", e);
 		}
@@ -388,37 +386,33 @@
 		isBigScreen = (MyLocale.getScreenWidth() >= 400) && (MyLocale.getScreenHeight() >= 600);
 	}
 
-/**
- * Tries to find a executable browser
- * return "" if no browser found
- * @return
- */
+	/**
+	 * Tries to find a executable browser return "" if no browser found
+	 * 
+	 * @return
+	 */
 	private String getDefaultBrowser() {
 		String pf = Vm.getPlatform();
 		String testlist[] = null;
 		if (pf.equals("Java") || pf.equals("Win32")) {
 			String progdir = Vm.getenv("ProgramFiles", null); // at least in java-Win XP this is set
-			String homedir=Vm.getenv("HOMEPATH", "");
+			String homedir = Vm.getenv("HOMEPATH", "");
 			if (progdir != null) {
-				String test[] = {
-						homedir+"/Lokale Einstellungen/Anwendungsdaten/Google/Chrome/Application/chrome.exe",
-						progdir+"/Firefox/firefox.exe",
-						progdir+"/Opera/opera.exe",
-						progdir+"/Internet Explorer/iexplore.exe"};
+				String test[] = { homedir + "/Lokale Einstellungen/Anwendungsdaten/Google/Chrome/Application/chrome.exe", progdir + "/Firefox/firefox.exe", progdir + "/Opera/opera.exe", progdir + "/Internet Explorer/iexplore.exe" };
 				testlist = test;
 			} else {
 				String test[] = { // this part is not tested
-						"/opt/firefox/firefox", // default path in ubuntu
-						"/usr/bin/firefox"};
+				"/opt/firefox/firefox", // default path in ubuntu
+						"/usr/bin/firefox" };
 				testlist = test;
 			}
 		}
 		if (pf.equals("WinCE")) {
-			String test[] = {"/windows/iexplore.exe"};
+			String test[] = { "/windows/iexplore.exe" };
 			testlist = test;
 		}
 		if (testlist != null) {
-			for (int i=0; i < testlist.length; i++)
+			for (int i = 0; i < testlist.length; i++)
 				if ((new FileBugfix(testlist[i])).exists()) {
 					return testlist[i];
 				}
@@ -427,10 +421,11 @@
 	}
 
 	/** Helper variables for XML parser */
-	private StringBuffer collectElement=null;
+	private StringBuffer collectElement = null;
 	private String lastName; // The string to the last XML that was processed
+
 	private long getLongAttr(AttributeList atts, String name) {
-		String stmp=atts.getValue(name);
+		String stmp = atts.getValue(name);
 		long ret = 0l;
 		if (stmp != null) {
 			ret = Convert.parseLong(stmp);
@@ -441,182 +436,181 @@
 	/**
 	 * Method that gets called when a new element has been identified in pref.xml
 	 */
-	public void startElement(String name, AttributeList atts){
-		lastName=name;
+	public void startElement(String name, AttributeList atts) {
+		lastName = name;
 		String tmp;
-		if(name.equals("browser")) {
+		if (name.equals("browser")) {
 			browser = atts.getValue("name");
-			if (browser == null || browser.length() == 0) browser = getDefaultBrowser();
-		}
-		else if(name.equals("fixedsip")) {
-			if(atts.getValue("state").equals("true")) {
+			if (browser == null || browser.length() == 0)
+				browser = getDefaultBrowser();
+		} else if (name.equals("fixedsip")) {
+			if (atts.getValue("state").equals("true")) {
 				fixSIP = true;
 			}
-		}
-		else if(name.equals("font")) {
+		} else if (name.equals("font")) {
 			fontSize = Convert.toInt(atts.getValue("size"));
 			fontName = atts.getValue("name");
-			if (fontName == null) fontName=mApp.findFont("gui").getName();
-		}
-		else if(name.equals("alias")) {
+			if (fontName == null)
+				fontName = mApp.findFont("gui").getName();
+		} else if (name.equals("alias")) {
 			myAlias = SafeXML.cleanback(atts.getValue("name"));
 			tmp = SafeXML.cleanback(atts.getValue("password"));
-			if (tmp != null) password=tmp;
-		}
-		else if(name.equals("alias2")) myAlias2 = SafeXML.cleanback(atts.getValue("name"));
-		else if(name.equals("gcmemberid")) {
+			if (tmp != null)
+				password = tmp;
+		} else if (name.equals("alias2"))
+			myAlias2 = SafeXML.cleanback(atts.getValue("name"));
+		else if (name.equals("gcmemberid")) {
 			gcMemberId = atts.getValue("name");
-			tmp=atts.getValue("Premium");
-			if (tmp != null) isPremium=Boolean.valueOf(tmp).booleanValue();
-		}
-		else if(name.equals("location")){
-			curCentrePt.set(atts.getValue("lat")+" "+atts.getValue("long"));
-		}
-		else if(name.equals("port")){
+			tmp = atts.getValue("Premium");
+			if (tmp != null)
+				isPremium = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals("location")) {
+			curCentrePt.set(atts.getValue("lat") + " " + atts.getValue("long"));
+		} else if (name.equals("port")) {
 			mySPO.portName = atts.getValue("portname");
 			mySPO.baudRate = Convert.toInt(atts.getValue("baud"));
-		}
-		else if(name.equals("portforward")) {
+		} else if (name.equals("portforward")) {
 			forwardGPS = Convert.toBoolean(atts.getValue("active"));
 			forwardGpsHost = atts.getValue("destinationHost");
-		}
-		else if(name.equals("gpsd")) {
+		} else if (name.equals("gpsd")) {
 			useGPSD = Convert.toInt(atts.getValue("active"));
 			gpsdHost = atts.getValue("host");
 			gpsdPort = Convert.toInt(atts.getValue("port"));
-		}
-		else if(name.equals("portlog")) {
+		} else if (name.equals("portlog")) {
 			logGPS = Convert.toBoolean(atts.getValue("active"));
 			logGPSTimer = atts.getValue("logTimer");
-		}
-		else if (name.equals("lastprofile")) {
-			collectElement=new StringBuffer(50);
-			if (atts.getValue("autoreload").equals("true")) autoReloadLastProfile=true;
-		}
-		else if (name.equals("CurrentCentre")) {
-			setCurrentCentreFromGPSPosition=Boolean.valueOf(atts.getValue("FromGPSPosition")).booleanValue();
-		}
-		else if(name.equals("basedir")) {
+		} else if (name.equals("lastprofile")) {
+			collectElement = new StringBuffer(50);
+			if (atts.getValue("autoreload").equals("true"))
+				autoReloadLastProfile = true;
+		} else if (name.equals("CurrentCentre")) {
+			setCurrentCentreFromGPSPosition = Boolean.valueOf(atts.getValue("FromGPSPosition")).booleanValue();
+		} else if (name.equals("basedir")) {
 			setBaseDir(atts.getValue("dir"));
-		}
-		else if (name.equals("opencaching")) {
-			tmp=atts.getValue("lastSite");
-			if (!(tmp == null) && OC.getSiteIndex(tmp)>=0 ) lastOCSite=tmp;
-			tmp=atts.getValue("downloadMissing");
-			if (!(tmp == null)) downloadAllOC = Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals("listview")) {
-			listColMap=atts.getValue("colmap");
-			listColWidth=atts.getValue("colwidths");
-			while ((new StringTokenizer(listColWidth,",")).countTokens()<myTableModel.N_COLUMNS) listColWidth+=",30"; // for older versions
-		}
-		else if(name.equals("proxy")) {
+		} else if (name.equals("opencaching")) {
+			tmp = atts.getValue("lastSite");
+			if (!(tmp == null) && OC.getSiteIndex(tmp) >= 0)
+				lastOCSite = tmp;
+			tmp = atts.getValue("downloadMissing");
+			if (!(tmp == null))
+				downloadAllOC = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals("listview")) {
+			listColMap = atts.getValue("colmap");
+			listColWidth = atts.getValue("colwidths");
+			while ((new StringTokenizer(listColWidth, ",")).countTokens() < myTableModel.N_COLUMNS)
+				listColWidth += ",30"; // for older versions
+		} else if (name.equals("proxy")) {
 			myproxy = atts.getValue("prx");
 			myproxyport = atts.getValue("prt");
 			tmp = atts.getValue("active");
-			if (tmp != null) proxyActive=Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals("garmin")) {
-			garminConn=atts.getValue("connection");
+			if (tmp != null)
+				proxyActive = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals("garmin")) {
+			garminConn = atts.getValue("connection");
 			tmp = atts.getValue("GPSBabelOptions");
-			if (tmp != null) garminGPSBabelOptions=tmp;
+			if (tmp != null)
+				garminGPSBabelOptions = tmp;
 			tmp = atts.getValue("MaxWaypointLength");
-			if (tmp != null) garminMaxLen=Convert.toInt(tmp);
+			if (tmp != null)
+				garminMaxLen = Convert.toInt(tmp);
 			tmp = atts.getValue("addDetailsToWaypoint");
-			if (tmp != null) addDetailsToWaypoint = Boolean.valueOf(tmp).booleanValue();
+			if (tmp != null)
+				addDetailsToWaypoint = Boolean.valueOf(tmp).booleanValue();
 			tmp = atts.getValue("addDetailsToName");
-			if (tmp != null) addDetailsToName = Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals("imagepanel")) {
+			if (tmp != null)
+				addDetailsToName = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals("imagepanel")) {
 			showDeletedImages = Boolean.valueOf(atts.getValue("showdeletedimages")).booleanValue();
-		}
-		else if (name.equals("descpanel")) {
+		} else if (name.equals("descpanel")) {
 			descShowImg = Boolean.valueOf(atts.getValue("showimages")).booleanValue();
-		}
-		else if (name.equals("screen")) {
-			menuAtTop=Boolean.valueOf(atts.getValue("menuattop")).booleanValue();
-			tabsAtTop=Boolean.valueOf(atts.getValue("tabsattop")).booleanValue();
-			showStatus=Boolean.valueOf(atts.getValue("showstatus")).booleanValue();
-			if (atts.getValue("hasclosebutton")!=null)
-				hasCloseButton=Boolean.valueOf(atts.getValue("hasclosebutton")).booleanValue();
-			if (atts.getValue("h")!=null) {
-				myAppHeight=Convert.toInt(atts.getValue("h"));
-				myAppWidth=Convert.toInt(atts.getValue("w"));
+		} else if (name.equals("screen")) {
+			menuAtTop = Boolean.valueOf(atts.getValue("menuattop")).booleanValue();
+			tabsAtTop = Boolean.valueOf(atts.getValue("tabsattop")).booleanValue();
+			showStatus = Boolean.valueOf(atts.getValue("showstatus")).booleanValue();
+			if (atts.getValue("hasclosebutton") != null)
+				hasCloseButton = Boolean.valueOf(atts.getValue("hasclosebutton")).booleanValue();
+			if (atts.getValue("h") != null) {
+				myAppHeight = Convert.toInt(atts.getValue("h"));
+				myAppWidth = Convert.toInt(atts.getValue("w"));
 			}
-		}
-		else if (name.equals("hintlogpanel")) {
+		} else if (name.equals("hintlogpanel")) {
 			logsPerPage = Convert.parseInt(atts.getValue("logsperpage"));
-			String strInitialHintHeight=atts.getValue("initialhintheight");
-			if (strInitialHintHeight!=null) initialHintHeight=Convert.parseInt(strInitialHintHeight);
-			String strMaxLogsToSpider=atts.getValue("maxspiderlogs");
-			if (strMaxLogsToSpider!=null) maxLogsToSpider=Convert.parseInt(strMaxLogsToSpider);
-		}
-		else if (name.equals("solver")) {
-			solverIgnoreCase=Boolean.valueOf(atts.getValue("ignorevariablecase")).booleanValue();
+			String strInitialHintHeight = atts.getValue("initialhintheight");
+			if (strInitialHintHeight != null)
+				initialHintHeight = Convert.parseInt(strInitialHintHeight);
+			String strMaxLogsToSpider = atts.getValue("maxspiderlogs");
+			if (strMaxLogsToSpider != null)
+				maxLogsToSpider = Convert.parseInt(strMaxLogsToSpider);
+		} else if (name.equals("solver")) {
+			solverIgnoreCase = Boolean.valueOf(atts.getValue("ignorevariablecase")).booleanValue();
 			tmp = atts.getValue("degMode");
-			if (tmp != null) solverDegMode=Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals("mapspath")) {
-			customMapsPath=SafeXML.cleanback(atts.getValue("dir")).replace('\\', '/');
-		}
-		else if (name.equals("debug")) debug=Boolean.valueOf(atts.getValue("value")).booleanValue();
+			if (tmp != null)
+				solverDegMode = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals("mapspath")) {
+			customMapsPath = SafeXML.cleanback(atts.getValue("dir")).replace('\\', '/');
+		} else if (name.equals("debug"))
+			debug = Boolean.valueOf(atts.getValue("value")).booleanValue();
 
-		else if (name.equals("expPath")){
-			exporterPaths.put(atts.getValue("key"),atts.getValue("value"));
-		}
-		else if (name.equals("impPath")) {
+		else if (name.equals("expPath")) {
+			exporterPaths.put(atts.getValue("key"), atts.getValue("value"));
+		} else if (name.equals("impPath")) {
 			importerPaths.put(atts.getValue("key"), atts.getValue("value"));
-		}
-		else if (name.equals("travelbugs")) {
-			travelbugColMap=atts.getValue("colmap");
-			travelbugColWidth=atts.getValue("colwidths");
-			travelbugShowOnlyNonLogged=Boolean.valueOf(atts.getValue("shownonlogged")).booleanValue();
-		}
-		else if (name.equals("gotopanel")) {
+		} else if (name.equals("travelbugs")) {
+			travelbugColMap = atts.getValue("colmap");
+			travelbugColWidth = atts.getValue("colwidths");
+			travelbugShowOnlyNonLogged = Boolean.valueOf(atts.getValue("shownonlogged")).booleanValue();
+		} else if (name.equals("gotopanel")) {
 			northCenteredGoto = Boolean.valueOf(atts.getValue("northcentered")).booleanValue();
-		}
-		else if (name.equals("spider")) {
+		} else if (name.equals("spider")) {
 			forceLogin = Boolean.valueOf(atts.getValue("forcelogin")).booleanValue();
-			checkLog = Boolean.valueOf(atts.getValue("checkLog")).booleanValue();      
+			checkLog = Boolean.valueOf(atts.getValue("checkLog")).booleanValue();
 			tmp = atts.getValue("checkTBs");
-			if (tmp != null) checkTBs=Boolean.valueOf(atts.getValue("checkTBs")).booleanValue();
+			if (tmp != null)
+				checkTBs = Boolean.valueOf(atts.getValue("checkTBs")).booleanValue();
 			tmp = atts.getValue("checkDTS");
-			if (tmp != null) checkDTS=Boolean.valueOf(atts.getValue("checkDTS")).booleanValue();
+			if (tmp != null)
+				checkDTS = Boolean.valueOf(atts.getValue("checkDTS")).booleanValue();
 			spiderRoute = Boolean.valueOf(atts.getValue("spiderRoute")).booleanValue();
 			tmp = atts.getValue("spiderUpdates");
-			if (tmp != null) spiderUpdates=Convert.parseInt(tmp);
+			if (tmp != null)
+				spiderUpdates = Convert.parseInt(tmp);
 			tmp = atts.getValue("maxSpiderNumber");
-			if (tmp != null) maxSpiderNumber=Convert.parseInt(tmp);
+			if (tmp != null)
+				maxSpiderNumber = Convert.parseInt(tmp);
 			tmp = atts.getValue("downloadPics");
-			if (tmp != null) downloadPics=Boolean.valueOf(tmp).booleanValue();
+			if (tmp != null)
+				downloadPics = Boolean.valueOf(tmp).booleanValue();
 			tmp = atts.getValue("downloadTBs");
-			if (tmp != null) downloadTBs=Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals("details")) {
-			maxDetails=Common.parseInt(atts.getValue("cacheSize"));
-			deleteDetails=Common.parseInt(atts.getValue("delete"));
-			if (maxDetails<2) maxDetails=2;
-			if (deleteDetails<1) deleteDetails=1;
-		}
-		else if (name.equals("metric")) {
-			metricSystem=Common.parseInt(atts.getValue("type"));
-			if (metricSystem != Metrics.METRIC &&
-					metricSystem != Metrics.IMPERIAL) {
+			if (tmp != null)
+				downloadTBs = Boolean.valueOf(tmp).booleanValue();
+			userID = atts.getValue("UserID");
+			if (userID == null)
+				userID = "";
+		} else if (name.equals("details")) {
+			maxDetails = Common.parseInt(atts.getValue("cacheSize"));
+			deleteDetails = Common.parseInt(atts.getValue("delete"));
+			if (maxDetails < 2)
+				maxDetails = 2;
+			if (deleteDetails < 1)
+				deleteDetails = 1;
+		} else if (name.equals("metric")) {
+			metricSystem = Common.parseInt(atts.getValue("type"));
+			if (metricSystem != Metrics.METRIC && metricSystem != Metrics.IMPERIAL) {
 				metricSystem = Metrics.METRIC;
 			}
-		}
-		else if (name.equals("export")) {
+		} else if (name.equals("export")) {
 			tmp = atts.getValue("numberOfLogsToExport");
-			if (tmp != null) numberOfLogsToExport=Convert.parseInt(tmp);
+			if (tmp != null)
+				numberOfLogsToExport = Convert.parseInt(tmp);
 			tmp = atts.getValue("exportTravelbugs");
-			if (tmp != null) exportTravelbugs = Boolean.valueOf(tmp).booleanValue();
+			if (tmp != null)
+				exportTravelbugs = Boolean.valueOf(tmp).booleanValue();
 			tmp = atts.getValue("exportGpxAsMyFinds");
-			if (tmp != null) exportGpxAsMyFinds = Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals("locale")) {
+			if (tmp != null)
+				exportGpxAsMyFinds = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals("locale")) {
 			language = atts.getValue("language");
-		}
-		else if (name.equals("FILTERDATA")) {
+		} else if (name.equals("FILTERDATA")) {
 			// Creating a filter object and reading the saved data
 			String id = SafeXML.cleanback(atts.getValue("id"));
 			FilterData data = new FilterData();
@@ -627,7 +621,7 @@
 			data.setFilterDiff(atts.getValue("diff"));
 			data.setFilterTerr(atts.getValue("terr"));
 			data.setFilterSize(atts.getValue("size"));
-			long[] filterAttr = { 0l,0l,0l,0l };
+			long[] filterAttr = { 0l, 0l, 0l, 0l };
 			filterAttr[0] = getLongAttr(atts, "attributesYes");
 			filterAttr[1] = getLongAttr(atts, "attributesYes1");
 			filterAttr[2] = getLongAttr(atts, "attributesNo");
@@ -638,95 +632,93 @@
 			data.setUseRegexp(Boolean.valueOf(atts.getValue("useRegexp")).booleanValue());
 			tmp = atts.getValue("noCoord");
 			if (tmp != null) {
-			  data.setFilterNoCoord(Boolean.valueOf(tmp).booleanValue());
-      } else {
-			  data.setFilterNoCoord(true);
-      }
+				data.setFilterNoCoord(Boolean.valueOf(tmp).booleanValue());
+			} else {
+				data.setFilterNoCoord(true);
+			}
 			// Filter object is remembered under the given ID
 			this.addFilter(id, data);
-		}
-		else if (name.equals ("datamover")){
+		} else if (name.equals("datamover")) {
 			tmp = atts.getValue("processorMode");
-			if (tmp != null){
-				processorMode=Convert.parseInt(tmp);
+			if (tmp != null) {
+				processorMode = Convert.parseInt(tmp);
 			}
-		}
-		else if (name.equals("logkeeping")) {
+		} else if (name.equals("logkeeping")) {
 			tmp = atts.getValue("maximum");
 			if (tmp != null)
 				maxLogsToKeep = Convert.parseInt(tmp);
-			if (maxLogsToKeep < 0) maxLogsToKeep = 0;
+			if (maxLogsToKeep < 0)
+				maxLogsToKeep = 0;
 
 			tmp = atts.getValue("keepown");
 			if (tmp != null)
 				alwaysKeepOwnLogs = Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals("fillWhiteArea")){
+		} else if (name.equals("fillWhiteArea")) {
 			tmp = atts.getValue("on");
 			fillWhiteArea = tmp != null && tmp.equalsIgnoreCase("true");
-		}
-		else if (name.equals("mapLoader")){
-			     tmp = atts.getValue("tileSize");
-			     if (tmp == null || tmp.length() == 0) tmp = "1";
-			     mapTileSize = Convert.parseInt(tmp);
-                 tmp = atts.getValue("overlapping");
-			     if (tmp == null || tmp.length() == 0) tmp = "100";
-			     mapOverlapping = Convert.parseInt(tmp);
-			     tmp = atts.getValue("tilewidth");
-			     tilewidth= (tmp != null && tmp.length() > 0)?Convert.parseInt(tmp):0;
-			     tmp = atts.getValue("tileheight");
-			     tileheight= (tmp != null && tmp.length() > 0)?Convert.parseInt(tmp):0;			    	 
-		}
-		else if (name.equals("showCachesOnMap")){
+		} else if (name.equals("mapLoader")) {
+			tmp = atts.getValue("tileSize");
+			if (tmp == null || tmp.length() == 0)
+				tmp = "1";
+			mapTileSize = Convert.parseInt(tmp);
+			tmp = atts.getValue("overlapping");
+			if (tmp == null || tmp.length() == 0)
+				tmp = "100";
+			mapOverlapping = Convert.parseInt(tmp);
+			tmp = atts.getValue("tilewidth");
+			tilewidth = (tmp != null && tmp.length() > 0) ? Convert.parseInt(tmp) : 0;
+			tmp = atts.getValue("tileheight");
+			tileheight = (tmp != null && tmp.length() > 0) ? Convert.parseInt(tmp) : 0;
+		} else if (name.equals("showCachesOnMap")) {
 			tmp = atts.getValue("on");
 			showCachesOnMap = tmp != null && tmp.equalsIgnoreCase("true");
-		}
-		else if (name.equals("SortingGroupedByCache")){
+		} else if (name.equals("SortingGroupedByCache")) {
 			tmp = atts.getValue("on");
 			SortingGroupedByCache = tmp != null && tmp.equalsIgnoreCase("true");
-		}
-		else if (name.equals("Symbols")) {
-			useOwnSymbols=Boolean.valueOf(atts.getValue("useOwnSymbols")).booleanValue();
-		}
-		else if (name.equals("MobileGui")) mobileGUI=Boolean.valueOf(atts.getValue("value")).booleanValue();
+		} else if (name.equals("Symbols")) {
+			useOwnSymbols = Boolean.valueOf(atts.getValue("useOwnSymbols")).booleanValue();
+		} else if (name.equals("MobileGui"))
+			mobileGUI = Boolean.valueOf(atts.getValue("value")).booleanValue();
 	}
 
-	public void characters( char ch[], int start, int length ) {
-		if (collectElement!=null) {
-			collectElement.append(ch,start,length); // Collect the name of the last profile
+	public void characters(char ch[], int start, int length) {
+		if (collectElement != null) {
+			collectElement.append(ch, start, length); // Collect the name of the last profile
 		}
 	}
 
 	/**
 	 * Method that gets called when the end of an element has been identified in pref.xml
 	 */
-	public void endElement(String tag){
+	public void endElement(String tag) {
 		if (tag.equals("lastprofile")) {
-			if (collectElement!=null) lastProfile=collectElement.toString();
+			if (collectElement != null)
+				lastProfile = collectElement.toString();
 		}
-		collectElement=null;
+		collectElement = null;
 	}
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Write pref.xml file
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Write pref.xml file
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	/**
 	 * Method to save current preferences in the pref.xml file
 	 */
-	public void savePreferences(){
-		if (pathToConfigFile == null) setPathToConfigFile(null); // this sets the default value
-		try{
-			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(pathToConfigFile)));
+	public void savePreferences() {
+		if (pathToConfigFile == null)
+			setPathToConfigFile(null); // this sets the default value
+		try {
+			PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(pathToConfigFile)));
 			outp.print("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
 			outp.print("<preferences>\n");
 			outp.print("    <locale language=\"" + SafeXML.clean(language) + "\"/>\n");
 			outp.print("    <basedir dir = \"" + SafeXML.clean(getBaseDir()) + "\"/>\n");
-			outp.print("    <lastprofile autoreload=\"" + SafeXML.strxmlencode(autoReloadLastProfile) + "\">" + SafeXML.clean(lastProfile) + "</lastprofile>\n"); //RB
+			outp.print("    <lastprofile autoreload=\"" + SafeXML.strxmlencode(autoReloadLastProfile) + "\">" + SafeXML.clean(lastProfile) + "</lastprofile>\n"); // RB
 			outp.print("    <CurrentCentre FromGPSPosition=\"" + SafeXML.clean(Convert.toString(setCurrentCentreFromGPSPosition)) + "\"/>\n");
-			outp.print("    <alias name =\""+ SafeXML.clean(myAlias) +"\" password=\""+SafeXML.clean(password)+"\" />\n");
-			outp.print("    <alias2 name =\""+ SafeXML.clean(myAlias2) +"\"/>\n");
-			outp.print("    <gcmemberid name =\""+ SafeXML.clean(gcMemberId) + "\"" + " Premium =\""+ SafeXML.strxmlencode(isPremium) +"\"/>\n");
+			outp.print("    <alias name =\"" + SafeXML.clean(myAlias) + "\" password=\"" + SafeXML.clean(password) + "\" />\n");
+			outp.print("    <alias2 name =\"" + SafeXML.clean(myAlias2) + "\"/>\n");
+			outp.print("    <gcmemberid name =\"" + SafeXML.clean(gcMemberId) + "\"" + " Premium =\"" + SafeXML.strxmlencode(isPremium) + "\"/>\n");
 			outp.print("    <browser name = \"" + SafeXML.clean(browser) + "\"/>\n");
 			outp.print("    <proxy prx = \"" + SafeXML.clean(myproxy) + "\" prt = \"" + SafeXML.clean(myproxyport) + "\" active = \"" + SafeXML.strxmlencode(proxyActive) + "\" />\n");
 			outp.print("    <port portname = \"" + SafeXML.clean(mySPO.portName) + "\" baud = \"" + SafeXML.strxmlencode(mySPO.baudRate) + "\"/>\n");
@@ -734,8 +726,7 @@
 			outp.print("    <gpsd active= \"" + SafeXML.strxmlencode(useGPSD) + "\" host = \"" + SafeXML.clean(gpsdHost) + "\" port = \"" + SafeXML.strxmlencode(gpsdPort) + "\"/>\n");
 			outp.print("    <portlog active= \"" + SafeXML.clean(Convert.toString(logGPS)) + "\" logTimer = \"" + SafeXML.clean(logGPSTimer) + "\"/>\n");
 			outp.print("    <font name=\"" + fontName + "\" size=\"" + SafeXML.strxmlencode(fontSize) + "\"/>\n");
-			outp.print("    <screen menuattop=\""+menuAtTop+"\" tabsattop=\""+tabsAtTop+"\" showstatus=\""+showStatus+"\" hasclosebutton=\""+hasCloseButton+
-	                "\" h=\""+myAppHeight+"\" w=\""+myAppWidth+"\" />\n");
+			outp.print("    <screen menuattop=\"" + menuAtTop + "\" tabsattop=\"" + tabsAtTop + "\" showstatus=\"" + showStatus + "\" hasclosebutton=\"" + hasCloseButton + "\" h=\"" + myAppHeight + "\" w=\"" + myAppWidth + "\" />\n");
 			outp.print("    <fixedsip state = \"" + SafeXML.strxmlencode(fixSIP) + "\"/>\n");
 			outp.print("    <listview colmap=\"" + SafeXML.clean(listColMap) + "\" colwidths=\"" + SafeXML.clean(listColWidth) + "\" />\n");
 			outp.print("    <travelbugs colmap=\"" + SafeXML.clean(travelbugColMap) + "\" colwidths=\"" + SafeXML.clean(travelbugColWidth) + "\" shownonlogged=\"" + SafeXML.strxmlencode(travelbugShowOnlyNonLogged) + "\" />\n");
@@ -743,85 +734,83 @@
 			outp.print("    <imagepanel showdeletedimages=\"" + SafeXML.strxmlencode(showDeletedImages) + "\"/>\n");
 			outp.print("    <hintlogpanel logsperpage=\"" + SafeXML.strxmlencode(logsPerPage) + "\" initialhintheight=\"" + SafeXML.strxmlencode(initialHintHeight) + "\"  maxspiderlogs=\"" + SafeXML.strxmlencode(maxLogsToSpider) + "\" />\n");
 			outp.print("    <solver ignorevariablecase=\"" + SafeXML.strxmlencode(solverIgnoreCase) + "\" degMode=\"" + SafeXML.strxmlencode(solverDegMode) + "\" />\n");
-			outp.print("    <garmin connection = \"" + SafeXML.clean(garminConn) + "\" GPSBabelOptions = \"" + SafeXML.clean(garminGPSBabelOptions) + "\" MaxWaypointLength = \"" + SafeXML.strxmlencode(garminMaxLen) +
-					        "\" addDetailsToWaypoint = \"" + SafeXML.strxmlencode(addDetailsToWaypoint) + "\" addDetailsToName = \"" + SafeXML.strxmlencode(addDetailsToName) + "\" />\n");
-			outp.print("    <opencaching lastSite=\""+lastOCSite+"\" downloadMissing=\"" + SafeXML.strxmlencode(downloadAllOC) + "\"/>\n");
+			outp.print("    <garmin connection = \"" + SafeXML.clean(garminConn) + "\" GPSBabelOptions = \"" + SafeXML.clean(garminGPSBabelOptions) + "\" MaxWaypointLength = \"" + SafeXML.strxmlencode(garminMaxLen) + "\" addDetailsToWaypoint = \""
+					+ SafeXML.strxmlencode(addDetailsToWaypoint) + "\" addDetailsToName = \"" + SafeXML.strxmlencode(addDetailsToName) + "\" />\n");
+			outp.print("    <opencaching lastSite=\"" + lastOCSite + "\" downloadMissing=\"" + SafeXML.strxmlencode(downloadAllOC) + "\"/>\n");
 			outp.print("    <location lat = \"" + SafeXML.clean(curCentrePt.getLatDeg(TransformCoordinates.DD)) + "\" long = \"" + SafeXML.clean(curCentrePt.getLonDeg(TransformCoordinates.DD)) + "\"/>\n");
-			outp.print("    <spider"+
-					" forcelogin=\"" + SafeXML.strxmlencode(forceLogin) + "\""+
-					" spiderUpdates=\"" + SafeXML.strxmlencode(spiderUpdates) + "\""+
-					" checkLog=\"" + SafeXML.strxmlencode(checkLog) + "\""+
-					" checkTBs=\"" + SafeXML.strxmlencode(checkTBs) + "\""+
-					" checkDTS=\"" + SafeXML.strxmlencode(checkDTS) + "\""+
-					" spiderRoute=\"" + SafeXML.strxmlencode(spiderRoute) + "\""+
-					" maxSpiderNumber=\"" + SafeXML.strxmlencode(maxSpiderNumber) + "\""+
-					" downloadPics=\"" + SafeXML.strxmlencode(downloadPics) + "\""+
-					" downloadTBs=\"" + SafeXML.strxmlencode(downloadTBs) +"\""+
-					"/>\n");
+			outp.print("    <spider" + " forcelogin=\"" + SafeXML.strxmlencode(forceLogin) + "\"" + " spiderUpdates=\"" + SafeXML.strxmlencode(spiderUpdates) + "\"" + " checkLog=\"" + SafeXML.strxmlencode(checkLog) + "\"" + " checkTBs=\""
+					+ SafeXML.strxmlencode(checkTBs) + "\"" + " checkDTS=\"" + SafeXML.strxmlencode(checkDTS) + "\"" + " spiderRoute=\"" + SafeXML.strxmlencode(spiderRoute) + "\"" + " maxSpiderNumber=\"" + SafeXML.strxmlencode(maxSpiderNumber) + "\""
+					+ " downloadPics=\"" + SafeXML.strxmlencode(downloadPics) + "\"" + " downloadTBs=\"" + SafeXML.strxmlencode(downloadTBs) + "\"" + " UserID=\"" + SafeXML.clean(userID) + "\"" + "/>\n");
 			outp.print("    <gotopanel northcentered=\"" + SafeXML.strxmlencode(northCenteredGoto) + "\" />\n");
 			outp.print("    <details cacheSize=\"" + SafeXML.strxmlencode(maxDetails) + "\" delete=\"" + SafeXML.strxmlencode(deleteDetails) + "\"/>\n");
 			outp.print("    <metric type=\"" + SafeXML.strxmlencode(metricSystem) + "\"/>\n");
-			outp.print("    <export numberOfLogsToExport=\"" + SafeXML.strxmlencode(numberOfLogsToExport) + "\" exportTravelbugs=\"" + SafeXML.strxmlencode(exportTravelbugs) + "\" exportGpxAsMyFinds=\"" + SafeXML.strxmlencode(exportGpxAsMyFinds) + "\"/>\n");
+			outp.print("    <export numberOfLogsToExport=\"" + SafeXML.strxmlencode(numberOfLogsToExport) + "\" exportTravelbugs=\"" + SafeXML.strxmlencode(exportTravelbugs) + "\" exportGpxAsMyFinds=\"" + SafeXML.strxmlencode(exportGpxAsMyFinds)
+					+ "\"/>\n");
 			outp.print("    <datamover processorMode=\"" + SafeXML.strxmlencode(processorMode) + "\" />\n");
-			if (customMapsPath!=null) outp.print("    <mapspath dir = \"" + SafeXML.clean(customMapsPath.replace('\\','/')) + "\"/>\n");
+			if (customMapsPath != null)
+				outp.print("    <mapspath dir = \"" + SafeXML.clean(customMapsPath.replace('\\', '/')) + "\"/>\n");
 			// Saving filters
 			String[] filterIDs = this.getFilterIDs();
-			for (int i=0; i<filterIDs.length; i++){
+			for (int i = 0; i < filterIDs.length; i++) {
 				outp.print(this.getFilter(filterIDs[i]).toXML(filterIDs[i]));
 			}
-			if (debug) outp.print("    <debug value=\"true\" />\n"); // Keep the debug switch if it is set
+			if (debug)
+				outp.print("    <debug value=\"true\" />\n"); // Keep the debug switch if it is set
 			// save last path of different exporters
 			Iterator itPath = exporterPaths.entries();
 			MapEntry entry;
-			while(itPath.hasNext()){
+			while (itPath.hasNext()) {
 				entry = (MapEntry) itPath.next();
 				outp.print("    <expPath key = \"" + SafeXML.clean(entry.getKey().toString()) + "\" value = \"" + SafeXML.clean(entry.getValue().toString().replace('\\', '/')) + "\"/>\n");
 			}
 			itPath = importerPaths.entries();
-			while(itPath.hasNext()){
+			while (itPath.hasNext()) {
 				entry = (MapEntry) itPath.next();
 				outp.print("    <impPath key = \"" + SafeXML.clean(entry.getKey().toString()) + "\" value = \"" + SafeXML.clean(entry.getValue().toString().replace('\\', '/')) + "\"/>\n");
 			}
-			outp.print("    <logkeeping maximum=\""+SafeXML.strxmlencode(maxLogsToKeep)+"\" keepown=\""+SafeXML.strxmlencode(alwaysKeepOwnLogs)+"\" />\n");
-			outp.print("    <fillWhiteArea on=\""+SafeXML.strxmlencode(fillWhiteArea)+"\"/>\n");
-			outp.print("    <mapLoader tileSize=\""+SafeXML.strxmlencode(mapTileSize)+"\" overlapping=\""+SafeXML.strxmlencode(mapOverlapping)+"\" tilewidth=\""+SafeXML.strxmlencode(tilewidth)+"\" tileheight=\""+SafeXML.strxmlencode(tileheight)+"\"/>\n");
-			outp.print("    <showCachesOnMap on=\""+SafeXML.strxmlencode(showCachesOnMap)+"\"/>\n");
-			outp.print("    <SortingGroupedByCache on=\""+SafeXML.strxmlencode(SortingGroupedByCache)+"\"/>\n");
+			outp.print("    <logkeeping maximum=\"" + SafeXML.strxmlencode(maxLogsToKeep) + "\" keepown=\"" + SafeXML.strxmlencode(alwaysKeepOwnLogs) + "\" />\n");
+			outp.print("    <fillWhiteArea on=\"" + SafeXML.strxmlencode(fillWhiteArea) + "\"/>\n");
+			outp.print("    <mapLoader tileSize=\"" + SafeXML.strxmlencode(mapTileSize) + "\" overlapping=\"" + SafeXML.strxmlencode(mapOverlapping) + "\" tilewidth=\"" + SafeXML.strxmlencode(tilewidth) + "\" tileheight=\""
+					+ SafeXML.strxmlencode(tileheight) + "\"/>\n");
+			outp.print("    <showCachesOnMap on=\"" + SafeXML.strxmlencode(showCachesOnMap) + "\"/>\n");
+			outp.print("    <SortingGroupedByCache on=\"" + SafeXML.strxmlencode(SortingGroupedByCache) + "\"/>\n");
 			outp.print("    <Symbols useOwnSymbols=\"" + SafeXML.strxmlencode(useOwnSymbols) + "\"/>\n");
-			if (mobileGUI) outp.print("    <MobileGui value=\"true\" />\n"); // Keep the vmgui switch if it is set
+			if (mobileGUI)
+				outp.print("    <MobileGui value=\"true\" />\n"); // Keep the vmgui switch if it is set
 			outp.print("</preferences>");
 			outp.close();
 		} catch (Exception e) {
-			log("Problem saving: " +pathToConfigFile,e,true);
+			log("Problem saving: " + pathToConfigFile, e, true);
 		}
 	}
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Maps
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Maps
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	private static final String mapsPath = "maps/standard";
 
 	/**
 	 * custom = set by the user
+	 * 
 	 * @return custom Maps Path, null if not set
 	 */
 	public String getCustomMapsPath() {
-	   String rCMP = Global.getProfile().getRelativeCustomMapsPath();
-	   if (rCMP.equals("")) {
-		   return customMapsPath;
+		String rCMP = Global.getProfile().getRelativeCustomMapsPath();
+		if (rCMP.equals("")) {
+			return customMapsPath;
 		} else {
-			return absoluteBaseDir+"maps"+rCMP;
+			return absoluteBaseDir + "maps" + rCMP;
 		}
 	}
 
 	public void saveCustomMapsPath(String mapspath_) {
 		if (customMapsPath == null || !customMapsPath.equals(mapspath_)) {
-			customMapsPath=new String(mapspath_).replace('\\', '/');
+			customMapsPath = new String(mapspath_).replace('\\', '/');
 			savePreferences();
-			String s = absoluteBaseDir+"maps";
-			if (customMapsPath.indexOf(s)==0) {
-				String t=customMapsPath.substring(s.length(), customMapsPath.length());
+			String s = absoluteBaseDir + "maps";
+			if (customMapsPath.indexOf(s) == 0) {
+				String t = customMapsPath.substring(s.length(), customMapsPath.length());
 				Global.getProfile().setRelativeCustomMapsPath(t);
 			} else {
 				Global.getProfile().setRelativeCustomMapsPath("");
@@ -830,34 +819,37 @@
 	}
 
 	private myTableModel tableMod;
-	public void setMyTableModel(myTableModel myTableModel) {tableMod=myTableModel;}
-	public CWPoint getCurCentrePt() {return curCentrePt;}
+
+	public void setMyTableModel(myTableModel myTableModel) {
+		tableMod = myTableModel;
+	}
+
+	public CWPoint getCurCentrePt() {
+		return curCentrePt;
+	}
+
 	public void setCurCentrePt(CWPoint newCentre) {
 		Vm.showWait(true);
 		curCentrePt.set(newCentre);
 		Global.getProfile().updateBearingDistance();
 		if (tableMod != null) {
 			// corresponding column for "distance" is column 10
-			if (tableMod.sortedBy == 10) tableMod.isSorted = false;
+			if (tableMod.sortedBy == 10)
+				tableMod.isSorted = false;
 			if (tableMod.sortedBy == 10 && this.sortAutomatic) {
 				tableMod.sortTable(tableMod.sortedBy, tableMod.sortAscending);
 				// or ??? TablePanel.refreshTable();
-			}
-			else tableMod.tcControl.repaint();
+			} else
+				tableMod.tcControl.repaint();
 		}
 		Vm.showWait(false);
 	}
 
 	/**
-	 * gets the path to the calibrated maps
-	 * it first tries if there are manually imported maps
-	 * in <baseDir>/maps/standard then it tries
-	 * the legacy dir: <program-dir>/maps
-	 * In case in both locations are no .wfl-files
-	 * it returns  <baseDir>/maps/expedia - the place where
-	 * the automatically downloaded maps are placed.
-	 *
-	 *
+	 * gets the path to the calibrated maps it first tries if there are manually imported maps in <baseDir>/maps/standard then it tries the legacy dir: <program-dir>/maps In case in both locations are no .wfl-files it returns <baseDir>/maps/expedia - the
+	 * place where the automatically downloaded maps are placed.
+	 * 
+	 * 
 	 */
 	public String getMapLoadPath() {
 		saveCustomMapsPath(getMapLoadPathInternal());
@@ -868,18 +860,21 @@
 		// here could also a list of map-types displayed...
 		// standard dir
 		String ret = getCustomMapsPath();
-		if (ret != null) return ret;
+		if (ret != null)
+			return ret;
 		ret = getMapManuallySavePath(false);
 		File t = new FileBugfix(ret);
 		String[] f = t.list("*.wfl", FileBase.LIST_FILES_ONLY);
-		if (f != null && f.length > 0) return  absoluteBaseDir + mapsPath;
+		if (f != null && f.length > 0)
+			return absoluteBaseDir + mapsPath;
 		f = t.list("*.wfl", FileBase.LIST_DIRECTORIES_ONLY | FileBase.LIST_ALWAYS_INCLUDE_DIRECTORIES);
 		if (f != null && f.length > 0) { // see if in a subdir of <baseDir>/maps/standard are .wfl files
 			String[] f2;
-			for (int i = 0; i< f.length; i++) {
-				t.set(null, ret+"/"+f[i]);
+			for (int i = 0; i < f.length; i++) {
+				t.set(null, ret + "/" + f[i]);
 				f2 = t.list("*.wfl", FileBase.LIST_FILES_ONLY);
-				if (f2 != null && f2.length > 0) return  ret;
+				if (f2 != null && f2.length > 0)
+					return ret;
 			}
 		}
 		// lagacy dir
@@ -887,45 +882,47 @@
 		t.set(null, ret);
 		f = t.list("*.wfl", FileBase.LIST_FILES_ONLY);
 		if (f != null && f.length > 0) {
-			MessageBox inf = new MessageBox("Information", "The directory for calibrated maps \nhas moved in this program version\n to '<profiles directory>/maps/standard'\n Do you want to move your calibrated maps there now?", FormBase.YESB | FormBase.NOB);
+			MessageBox inf = new MessageBox("Information", "The directory for calibrated maps \nhas moved in this program version\n to '<profiles directory>/maps/standard'\n Do you want to move your calibrated maps there now?", FormBase.YESB
+					| FormBase.NOB);
 			if (inf.execute() == FormBase.IDYES) {
 				String sp = getMapManuallySavePath(false);
 				FileBugfix spF = new FileBugfix(sp);
-				if (!spF.exists()) spF.mkdirs();
+				if (!spF.exists())
+					spF.mkdirs();
 				String image;
 				String lagacypath = ret;
-				for (int i=0; i<f.length; i++) {
-					t.set(null, lagacypath+f[i]);
-					spF.set(null, sp+"/"+f[i]);
+				for (int i = 0; i < f.length; i++) {
+					t.set(null, lagacypath + f[i]);
+					spF.set(null, sp + "/" + f[i]);
 					t.move(spF);
-					image = Common.getImageName(lagacypath+f[i].substring(0, f[i].lastIndexOf(".")));
+					image = Common.getImageName(lagacypath + f[i].substring(0, f[i].lastIndexOf(".")));
 					t.set(null, image);
-					spF.set(null, sp+"/"+t.getFileExt());
+					spF.set(null, sp + "/" + t.getFileExt());
 					t.move(spF);
 				}
 				t.set(null, lagacypath);
 				t.delete();
 				return sp;
-			}
-			else return  ret;
+			} else
+				return ret;
 		}
 		// expedia dir
 		// return getMapExpediaLoadPath();
 
-		//whole maps directory
+		// whole maps directory
 		return Global.getPref().absoluteBaseDir.replace('\\', '/') + "maps";
 	}
 
 	/**
-	 * @param create if true the directory if it doesn't exist will be created
-	 * @return the path where manually imported maps should be stored
-	 * this should be adjustable in preferences...
+	 * @param create
+	 *            if true the directory if it doesn't exist will be created
+	 * @return the path where manually imported maps should be stored this should be adjustable in preferences...
 	 */
 	public String getMapManuallySavePath(boolean create) {
 		String mapsDir = absoluteBaseDir + mapsPath;
 		if (create && !(new FileBugfix(mapsDir).isDirectory())) { // dir exists?
 			if (new FileBugfix(mapsDir).mkdirs() == false) {// dir creation failed?
-				(new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(172,"Error: cannot create maps directory: \n")+mapsDir, FormBase.OKB)).exec();
+				(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(172, "Error: cannot create maps directory: \n") + mapsDir, FormBase.OKB)).exec();
 				return null;
 			}
 		}
@@ -937,11 +934,12 @@
 	 */
 	public String getMapDownloadSavePath(String mapkind) {
 		String subdir = Global.getProfile().dataDir.substring(Global.getPref().absoluteBaseDir.length()).replace('\\', '/');
-		String mapsDir = Global.getPref().absoluteBaseDir + "maps/" + Common.ClearForFileName(mapkind)+ "/" + subdir;
+		String mapsDir = Global.getPref().absoluteBaseDir + "maps/" + Common.ClearForFileName(mapkind) + "/" + subdir;
 		if (!(new FileBugfix(mapsDir).isDirectory())) { // dir exists?
 			if (new FileBugfix(mapsDir).mkdirs() == false) // dir creation failed?
-			{(new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(172,"Error: cannot create maps directory: \n")+new FileBugfix(mapsDir).getParentFile(), FormBase.OKB)).exec();
-			return null;
+			{
+				(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(172, "Error: cannot create maps directory: \n") + new FileBugfix(mapsDir).getParentFile(), FormBase.OKB)).exec();
+				return null;
 			}
 		}
 		return mapsDir;
@@ -951,18 +949,17 @@
 		return Global.getPref().absoluteBaseDir.replace('\\', '/') + "maps/expedia"; // baseDir has trailing /
 	}
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Profile Selector
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Profile Selector
+	// ////////////////////////////////////////////////////////////////////////////////////
 
-	static protected final int PROFILE_SELECTOR_FORCED_ON=0;
-	static protected final int PROFILE_SELECTOR_FORCED_OFF=1;
-	static protected final int PROFILE_SELECTOR_ONOROFF=2;
+	static protected final int PROFILE_SELECTOR_FORCED_ON = 0;
+	static protected final int PROFILE_SELECTOR_FORCED_OFF = 1;
+	static protected final int PROFILE_SELECTOR_ONOROFF = 2;
 
 	/**
-	 * tries to get the home data dir of the user
-	 * e.g. "c:\documents and...\<user>\my documents" or "/home/<user>" in linux
-	 * if none could be identified, "/" is returned.
+	 * tries to get the home data dir of the user e.g. "c:\documents and...\<user>\my documents" or "/home/<user>" in linux if none could be identified, "/" is returned.
+	 * 
 	 * @return
 	 */
 	public String getHomeDir() {
@@ -971,79 +968,83 @@
 		log("[Preferences:getHomeDir]" + test); // this works also in win32.exe (ewe-vm on win xp)
 		test += Vm.getenv("HOMEPATH", ""); // returns in java-vm on win xp: c:\<dokumente und Einstellungen>\<username>\<application data>
 		log("[Preferences:getHomeDir]" + test); // this works also in win32.exe (ewe-vm on win xp)
-		if (test.length() == 0)	test = Vm.getenv("HOME", ""); // This should return on *nix system the home dir
-		if (test.length() == 0)	test = "/";
+		if (test.length() == 0)
+			test = Vm.getenv("HOME", ""); // This should return on *nix system the home dir
+		if (test.length() == 0)
+			test = "/";
 		return test;
 	}
 
 	private void checkAbsoluteBaseDir() {
 		// If datadir is empty, ask for one
-		if (absoluteBaseDir.length()==0 || !(new FileBugfix(absoluteBaseDir)).exists()) {
+		if (absoluteBaseDir.length() == 0 || !(new FileBugfix(absoluteBaseDir)).exists()) {
 			do {
 				FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, getHomeDir());
-				fc.title = MyLocale.getMsg(170,"Select base directory for cache data");
+				fc.title = MyLocale.getMsg(170, "Select base directory for cache data");
 				// If no base directory given, terminate
-				if (fc.execute() == FormBase.IDCANCEL) ewe.sys.Vm.exit(0);
+				if (fc.execute() == FormBase.IDCANCEL)
+					ewe.sys.Vm.exit(0);
 				setBaseDir(fc.getChosenFile().toString());
-			}while (!(new FileBugfix(absoluteBaseDir)).exists());
+			} while (!(new FileBugfix(absoluteBaseDir)).exists());
 		}
 	}
 
 	/**
 	 * Open Profile selector screen
+	 * 
 	 * @param prof
 	 * @param showProfileSelector
 	 * @return True if a profile was selected
 	 */
 	public boolean selectProfile(Profile prof, int showProfileSelector, boolean hasNewButton) {
 		checkAbsoluteBaseDir();
-		boolean profileExists=true;  // Assume that the profile exists
+		boolean profileExists = true; // Assume that the profile exists
 		do {
-			if(!profileExists || (showProfileSelector==PROFILE_SELECTOR_FORCED_ON) ||
-					(showProfileSelector==PROFILE_SELECTOR_ONOROFF && !autoReloadLastProfile)){ // Ask for the profile
-				ProfilesForm f = new ProfilesForm(absoluteBaseDir,lastProfile,!profileExists || hasNewButton ? 0 : 1);
+			if (!profileExists || (showProfileSelector == PROFILE_SELECTOR_FORCED_ON) || (showProfileSelector == PROFILE_SELECTOR_ONOROFF && !autoReloadLastProfile)) { // Ask for the profile
+				ProfilesForm f = new ProfilesForm(absoluteBaseDir, lastProfile, !profileExists || hasNewButton ? 0 : 1);
 				int code = f.execute();
 				// If no profile chosen (includes a new one), terminate
-				if (code==-1) return false; // Cancel pressed
+				if (code == -1)
+					return false; // Cancel pressed
 				CWPoint savecenter = new CWPoint(prof.centre);
 				prof.clearProfile();
 				prof.setCenterCoords(savecenter);
-				//prof.hasUnsavedChanges = true;
-				//curCentrePt.set(0,0); // No centre yet
-				lastProfile=f.newSelectedProfile;
+				// prof.hasUnsavedChanges = true;
+				// curCentrePt.set(0,0); // No centre yet
+				lastProfile = f.newSelectedProfile;
 			}
-			profileExists=(new FileBugfix(absoluteBaseDir+lastProfile)).exists();
-			if (!profileExists) (new MessageBox(MyLocale.getMsg(144,"Warning"),
-					           MyLocale.getMsg(171,"Profile does not exist: ")+lastProfile,FormBase.MBOK)).execute();
-		} while (profileExists==false);
+			profileExists = (new FileBugfix(absoluteBaseDir + lastProfile)).exists();
+			if (!profileExists)
+				(new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(171, "Profile does not exist: ") + lastProfile, FormBase.MBOK)).execute();
+		} while (profileExists == false);
 		// Now we are sure that baseDir exists and basDir+profile exists
-		prof.name=lastProfile;
-		prof.dataDir=absoluteBaseDir+lastProfile;
-		prof.dataDir=prof.dataDir.replace('\\','/');
-		if (!prof.dataDir.endsWith("/")) prof.dataDir+='/';
-		pathToProfile=prof.dataDir;
+		prof.name = lastProfile;
+		prof.dataDir = absoluteBaseDir + lastProfile;
+		prof.dataDir = prof.dataDir.replace('\\', '/');
+		if (!prof.dataDir.endsWith("/"))
+			prof.dataDir += '/';
+		pathToProfile = prof.dataDir;
 		savePreferences();
 		return true;
 	}
 
 	static public boolean deleteDirectory(FileBugfix path) {
-	    if( path.exists() ) {
-	    	String[] files = path.list();
-	    	for(int i=0; i<files.length; i++) {
-	    		FileBugfix f = new FileBugfix(path.getFullPath() + "/" + files[i]);
-		        if(f.isDirectory()) {
-		        	deleteDirectory(f);
-		        }
-		        else {
-		        	f.delete();
-		        }
-		     }
-		    }
-	    return( path.delete() );
+		if (path.exists()) {
+			String[] files = path.list();
+			for (int i = 0; i < files.length; i++) {
+				FileBugfix f = new FileBugfix(path.getFullPath() + "/" + files[i]);
+				if (f.isDirectory()) {
+					deleteDirectory(f);
+				} else {
+					f.delete();
+				}
+			}
+		}
+		return (path.delete());
 	}
 
 	static public boolean renameDirectory(FileBugfix OldPath, FileBugfix NewPath) {
-	    return OldPath.renameTo(NewPath);
+		return OldPath.renameTo(NewPath);
 	}
 
 	/*
@@ -1052,147 +1053,165 @@
 	public void editProfile(int operation, int ErrorMsgActive, int ErrorMsg) {
 		checkAbsoluteBaseDir(); // perhaps not necessary
 		// select profile
-		ProfilesForm f = new ProfilesForm(absoluteBaseDir,"",operation);
-		if (f.execute()==-1) return ; // no select
+		ProfilesForm f = new ProfilesForm(absoluteBaseDir, "", operation);
+		if (f.execute() == -1)
+			return; // no select
 		// check selection
 		if (lastProfile.equals(f.newSelectedProfile)) {
 			// aktives Profil kann nicht gel?scht / umbenannt werden;
-			new MessageBox(MyLocale.getMsg(321,"Error"),MyLocale.getMsg(ErrorMsgActive,"[Profile active...]"),FormBase.MBOK).execute();
-		}
-		else {
-			boolean err=true;
-			if (operation==3) {
-				String newName = new InputBox("Bitte neuen Verzeichnisnamen eingeben : ").input("",50);
+			new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(ErrorMsgActive, "[Profile active...]"), FormBase.MBOK).execute();
+		} else {
+			boolean err = true;
+			if (operation == 3) {
+				String newName = new InputBox("Bitte neuen Verzeichnisnamen eingeben : ").input("", 50);
 				if (!newName.equals(null)) {
-					err=!renameDirectory(new FileBugfix(absoluteBaseDir+f.newSelectedProfile),new FileBugfix(absoluteBaseDir+newName));
+					err = !renameDirectory(new FileBugfix(absoluteBaseDir + f.newSelectedProfile), new FileBugfix(absoluteBaseDir + newName));
 				}
-			}
-			else
-			if (operation==2){
+			} else if (operation == 2) {
 				Profile p = new Profile();
-				p.dataDir=absoluteBaseDir+f.newSelectedProfile+"/";
+				p.dataDir = absoluteBaseDir + f.newSelectedProfile + "/";
 				p.readIndex();
-				String mapsPath=absoluteBaseDir+"maps"+p.getRelativeCustomMapsPath();
-				int answer=new MessageBox("",mapsPath+" "+MyLocale.getMsg(143,"l?schen ?"),FormBase.MBYESNO).execute();
-				if (answer==1) {
+				String mapsPath = absoluteBaseDir + "maps" + p.getRelativeCustomMapsPath();
+				int answer = new MessageBox("", mapsPath + " " + MyLocale.getMsg(143, "l?schen ?"), FormBase.MBYESNO).execute();
+				if (answer == 1) {
 					deleteDirectory(new FileBugfix(mapsPath));
 				}
-				err=!deleteDirectory(new FileBugfix(absoluteBaseDir+f.newSelectedProfile));
+				err = !deleteDirectory(new FileBugfix(absoluteBaseDir + f.newSelectedProfile));
 				// ? wait until deleted ?
 			}
-			if (err) {new MessageBox(MyLocale.getMsg(321,"Error"),MyLocale.getMsg(ErrorMsg,"[Profile Error...]"),FormBase.MBOK).execute();}
+			if (err) {
+				new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(ErrorMsg, "[Profile Error...]"), FormBase.MBOK).execute();
+			}
 		}
 	}
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Log functions
-	//////////////////////////////////////////////////////////////////////////////////////
 
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Log functions
+	// ////////////////////////////////////////////////////////////////////////////////////
+
 	// FIXME: should use path to config file instead of program directory
 	/** Log file is in program directory and called log.txt */
-	private final String LOGFILENAME=FileBase.getProgramDirectory()+"/log.txt";
+	private final String LOGFILENAME = FileBase.getProgramDirectory() + "/log.txt";
 
 	/**
-	 * Method to delete an existing log file. Called on every SpiderGC.
-	 * The log file is also cleared when Preferences is created and the filesize > 60KB
+	 * Method to delete an existing log file. Called on every SpiderGC. The log file is also cleared when Preferences is created and the filesize > 60KB
 	 */
-	public void logInit(){
+	public void logInit() {
 		File logFile = new FileBugfix(LOGFILENAME);
 		logFile.delete();
-		log("CW Version "+Version.getReleaseDetailed(),null,true);
-		
-		if (System.getProperty("os.name")!=null) log("Operating system: "+System.getProperty("os.name")+"/"+System.getProperty("os.arch"),null,true);
-		if (System.getProperty("java.vendor")!=null) log("Java: "+System.getProperty("java.vendor")+"/"+System.getProperty("java.version"),null,true);
-		
+		log("CW Version " + Version.getReleaseDetailed(), null, true);
+
+		if (System.getProperty("os.name") != null)
+			log("Operating system: " + System.getProperty("os.name") + "/" + System.getProperty("os.arch"), null, true);
+		if (System.getProperty("java.vendor") != null)
+			log("Java: " + System.getProperty("java.vendor") + "/" + System.getProperty("java.version"), null, true);
+
 	}
 
 	boolean forceLog = false;
-	
+
 	/**
-	 * Method to log messages to a file called log.txt
-	 * It will always append to an existing file.
-	 * To show the message on the console, the global variable debug must be set.
-	 * This can be done by adding
-	 * <pre>&lt;debug value="true"&gt;</pre>
+	 * Method to log messages to a file called log.txt It will always append to an existing file. To show the message on the console, the global variable debug must be set. This can be done by adding
+	 * 
+	 * <pre>
+	 * &lt;debug value="true"&gt;
+	 * </pre>
+	 * 
 	 * to the pref.xml file
-	 * @param text to log
+	 * 
+	 * @param text
+	 *            to log
 	 */
-	public void log(String text){
+	public void log(String text) {
 		if (debug || forceLog) {
-			if (debug) Vm.debug(text);
+			if (debug)
+				Vm.debug(text);
 			Time dtm = new Time();
 			dtm.getTime();
 			dtm.setFormat("dd.MM.yyyy'/'HH:mm:ss.SSS");
-			text = dtm.toString()+ ": "+ text;
+			text = dtm.toString() + ": " + text;
 			FileWriter logFile = null;
-			try{
+			try {
 				logFile = new FileWriter(LOGFILENAME, true);
-				//Stream strout = null;
-				//strout = logFile.toWritableStream(true);
-				logFile.print(text+NEWLINE);
-			}catch(Exception ex){
+				// Stream strout = null;
+				// strout = logFile.toWritableStream(true);
+				logFile.print(text + NEWLINE);
+			} catch (Exception ex) {
 				Vm.debug("Error writing to log file!");
-			}finally{
-				if (logFile != null) try {logFile.close(); } catch (IOException ioe) {
-					// log("Ignored Exception", ioe, true);
-				}
+			} finally {
+				if (logFile != null)
+					try {
+						logFile.close();
+					} catch (IOException ioe) {
+						// log("Ignored Exception", ioe, true);
+					}
 			}
 		}
 	}
 
-	/** Log an exception to the log file with or without a stack trace
-	 *
-	 * @param text Optional message (Can be empty string)
-	 * @param e The exception
-	 * @param withStackTrace If true and the debug switch is true, the stack trace is appended to the log
-	 * The debug switch can be set by including the line <i>&lt;debug value="true"&gt;&lt;/debug&gt;</i> in the pref.xml file
-	 * or by manually setting it (i.e. in BE versions or RC versions) by including the line
-	 * <pre>Global.getPref().debug=true;</pre>
-	 * in Version.getRelease()
+	/**
+	 * Log an exception to the log file with or without a stack trace
+	 * 
+	 * @param text
+	 *            Optional message (Can be empty string)
+	 * @param e
+	 *            The exception
+	 * @param withStackTrace
+	 *            If true and the debug switch is true, the stack trace is appended to the log The debug switch can be set by including the line <i>&lt;debug value="true"&gt;&lt;/debug&gt;</i> in the pref.xml file or by manually setting it (i.e. in BE
+	 *            versions or RC versions) by including the line
+	 * 
+	 *            <pre>
+	 * Global.getPref().debug = true;
+	 * </pre>
+	 * 
+	 *            in Version.getRelease()
 	 */
-	public void log(String text,Throwable e, boolean withStackTrace) {
-		if (e!=null) {
-			text+=Preferences.NEWLINE;
+	public void log(String text, Throwable e, boolean withStackTrace) {
+		if (e != null) {
+			text += Preferences.NEWLINE;
 			if (withStackTrace)
-				text+=ewe.sys.Vm.getAStackTrace(e);
+				text += ewe.sys.Vm.getAStackTrace(e);
 			else
-				text+=e.toString();
+				text += e.toString();
 		}
-		forceLog=true;
+		forceLog = true;
 		log(text);
-		forceLog=false;
+		forceLog = false;
 	}
 
-	/** Log an exception to the log file without a stack trace, i.e.
-	 * where a stack trace is not needed because the location/cause of the error is clear
-	 *
-	 * @param message Optional message (Can be empty string)
-	 * @param e The exception
+	/**
+	 * Log an exception to the log file without a stack trace, i.e. where a stack trace is not needed because the location/cause of the error is clear
+	 * 
+	 * @param message
+	 *            Optional message (Can be empty string)
+	 * @param e
+	 *            The exception
 	 */
-	public void log(String message,Exception e) {
-		log (message,e,false);
+	public void log(String message, Exception e) {
+		log(message, e, false);
 	}
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Exporter path functions
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Exporter path functions
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	/** Hashtable for storing the last export path */
 	private Hashtable exporterPaths = new Hashtable();
 
-	public void setExportPath(String exporter,String path){
+	public void setExportPath(String exporter, String path) {
 		exporterPaths.put(exporter, path);
 		savePreferences();
 	}
 
-	public void setExportPathFromFileName(String exporter,String filename){
-		File tmpfile = new FileBugfix (filename);
+	public void setExportPathFromFileName(String exporter, String filename) {
+		File tmpfile = new FileBugfix(filename);
 		exporterPaths.put(exporter, tmpfile.getPath());
 		savePreferences();
 	}
 
-	public String getExportPath(String exporter){
+	public String getExportPath(String exporter) {
 		String dir = (String) exporterPaths.get(exporter);
-		if (dir == null){
+		if (dir == null) {
 			dir = Global.getProfile().dataDir;
 		}
 		return dir;
@@ -1207,14 +1226,16 @@
 
 	public String getImporterPath(String importer) {
 		String dir = (String) importerPaths.get(importer);
-		if (null == dir) dir = Global.getProfile().dataDir;
+		if (null == dir)
+			dir = Global.getProfile().dataDir;
 		return dir;
 	}
 
 	/**
-	 * <code>True</code> or <code>false</code>, depending if a filter with the given ID is
-	 * saved in the preferences.
-	 * @param filterID ID of the filter to check
+	 * <code>True</code> or <code>false</code>, depending if a filter with the given ID is saved in the preferences.
+	 * 
+	 * @param filterID
+	 *            ID of the filter to check
 	 * @return True or false
 	 */
 	public boolean hasFilter(String filterID) {
@@ -1222,29 +1243,33 @@
 	}
 
 	/**
-	 * Returns the FilterData object saved with the given ID. The ID is not saved in the object,
-	 * so it may be resaved under another ID.
-	 * @param filterID ID of the FilterData object
+	 * Returns the FilterData object saved with the given ID. The ID is not saved in the object, so it may be resaved under another ID.
+	 * 
+	 * @param filterID
+	 *            ID of the FilterData object
 	 * @return FilterData object
 	 */
 	public FilterData getFilter(String filterID) {
-		return (FilterData)this.filterList.get(filterID);
+		return (FilterData) this.filterList.get(filterID);
 	}
 
 	/**
-	 * Adds a FilterData object to the list. If a FilterData object is already saved unter the
-	 * given ID, the old object is removed and the new one is set at its place.
-	 * @param filterID ID to associate with the filter object
-	 * @param filter FilterData object
+	 * Adds a FilterData object to the list. If a FilterData object is already saved unter the given ID, the old object is removed and the new one is set at its place.
+	 * 
+	 * @param filterID
+	 *            ID to associate with the filter object
+	 * @param filter
+	 *            FilterData object
 	 */
 	public void addFilter(String filterID, FilterData filter) {
 		this.filterList.put(filterID, filter);
 	}
 
 	/**
-	 * Removed the FilterData object which is saved with the given ID. If no such FilterData object
-	 * exists, nothing happens.
-	 * @param filterID ID of FilterData object to remove
+	 * Removed the FilterData object which is saved with the given ID. If no such FilterData object exists, nothing happens.
+	 * 
+	 * @param filterID
+	 *            ID of FilterData object to remove
 	 */
 	public void removeFilter(String filterID) {
 		this.filterList.remove(filterID);
@@ -1252,13 +1277,14 @@
 
 	/**
 	 * Returns a alphabetically sorted array of ID of saved FilterData objects.
+	 * 
 	 * @return Array of IDs
 	 */
 	public String[] getFilterIDs() {
 		String[] result;
 		result = new String[this.filterList.size()];
 		Enumeration en = this.filterList.keys();
-		int i=0;
+		int i = 0;
 		while (en.hasMoreElements()) {
 			result[i++] = (String) en.nextElement();
 		}
@@ -1275,26 +1301,28 @@
 	public String gpsbabel = null;
 
 	public void setgpsbabel() {
-		try{
+		try {
 			ewe.sys.Process p = Vm.exec("gpsbabel -V");
 			p.waitFor();
-			gpsbabel="gpsbabel";
-		}catch(IOException ioex){
+			gpsbabel = "gpsbabel";
+		} catch (IOException ioex) {
 			// Most of the time there will be an exception, so don't complain
 		}
-		if ( gpsbabel == null ) {
-			try{
+		if (gpsbabel == null) {
+			try {
 				ewe.sys.Process p = Vm.exec("gpsbabel.exe -V");
 				p.waitFor();
 				gpsbabel = "gpsbabel.exe";
-			}catch(IOException ioex){
+			} catch (IOException ioex) {
 				// Most of the time there will be an exception, so don't complain
 			}
 		}
 	}
 
-	/** get directory where pref.xml is stored<br>
-	 *  use this if you need a path where the user has sufficient rights to create a file */
+	/**
+	 * get directory where pref.xml is stored<br>
+	 * use this if you need a path where the user has sufficient rights to create a file
+	 */
 	public String getPathToConfigFile() {
 		return pathToConfigFile;
 	}
@@ -1305,11 +1333,13 @@
 
 	public void setBaseDir(String dir) {
 		baseDir = dir;
-		baseDir=baseDir.replace('\\','/');
-		if (!baseDir.endsWith("/")) baseDir+="/";
+		baseDir = baseDir.replace('\\', '/');
+		if (!baseDir.endsWith("/"))
+			baseDir += "/";
 		absoluteBaseDir = new FileBugfix(baseDir).getAbsolutePath();
-		absoluteBaseDir=absoluteBaseDir.replace('\\','/');
-		if (!absoluteBaseDir.endsWith("/")) absoluteBaseDir+="/";
+		absoluteBaseDir = absoluteBaseDir.replace('\\', '/');
+		if (!absoluteBaseDir.endsWith("/"))
+			absoluteBaseDir += "/";
 	}
 
 }

Modified: trunk/src/CacheWolf/PreferencesScreen.java
===================================================================
--- trunk/src/CacheWolf/PreferencesScreen.java	2011-05-02 11:30:16 UTC (rev 2994)
+++ trunk/src/CacheWolf/PreferencesScreen.java	2011-05-06 15:11:39 UTC (rev 2995)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.Metrics;
@@ -54,351 +54,326 @@
 import ewe.ui.mTabbedPanel;
 
 /**
-*	This class displays a user interface allowing the user to change and set
-*	preferences. It also provides a method to save the changed preferences that
-*	are saved immediatly when the user presses "Apply".
-*	Class ID=600
-*/
+ * This class displays a user interface allowing the user to change and set preferences. It also provides a method to save the changed preferences that are saved immediatly when the user presses "Apply". Class ID=600
+ */
 public class PreferencesScreen extends Form {
 	mButton cancelB, applyB, brwBt, gpsB;
 	mChoice inpLanguage, inpMetric, inpSpiderUpdates;
-	mInput DataDir, Proxy, ProxyPort, Alias, nLogs, Browser, fontName, fontSize, 
-	       inpLogsPerPage,inpMaxLogsToSpider,inpPassword,inpGcMemberID;
-	mCheckBox chkAutoLoad, chkShowDeletedImg, chkMenuAtTop, chkTabsAtTop, chkShowStatus,chkHasCloseButton,
-	          chkSynthShort,chkProxyActive, chkDescShowImg, chkAddDetailsToWaypoint, chkAddDetailsToName, 
-	          chkSetCurrentCentreFromGPSPosition,chkSortingGroupedByCache,chkuseOwnSymbols,chkDebug,chkPM;
+	mInput DataDir, Proxy, ProxyPort, Alias, nLogs, Browser, fontName, fontSize, inpLogsPerPage, inpMaxLogsToSpider, inpPassword, inpGcMemberID, inpUserID;
+	mCheckBox chkAutoLoad, chkShowDeletedImg, chkMenuAtTop, chkTabsAtTop, chkShowStatus, chkHasCloseButton, chkSynthShort, chkProxyActive, chkDescShowImg, chkAddDetailsToWaypoint, chkAddDetailsToName, chkSetCurrentCentreFromGPSPosition,
+			chkSortingGroupedByCache, chkuseOwnSymbols, chkDebug, chkPM;
 	mTabbedPanel mTab;
 	mChoice chcGarminPort;
 	mLabel lblGarmin;
-	TableColumnChooser tccBugs,tccList;
-	
+	TableColumnChooser tccBugs, tccList;
+
 	Preferences pref;
-	
+
 	CellPanel pnlGeneral = new CellPanel();
 	CellPanel pnlDisplay = new CellPanel();
 	CellPanel pnlMore = new CellPanel();
 	CellPanel pnlTB = new CellPanel();
 
 	// ScrollBarPanel scp;
-	String [] garminPorts= new String[]{"com1","com2","com3","com4","com5","com6","com7","usb"};
-	
-	public PreferencesScreen (Preferences p){
+	String[] garminPorts = new String[] { "com1", "com2", "com3", "com4", "com5", "com6", "com7", "usb" };
+
+	public PreferencesScreen(Preferences p) {
 		int sw = MyLocale.getScreenWidth();
 		int sh = MyLocale.getScreenHeight();
 
-		mTab=new mTabbedPanel();
-		
+		mTab = new mTabbedPanel();
+
 		pref = p;
-		this.title = MyLocale.getMsg(600,"Preferences");
+		this.title = MyLocale.getMsg(600, "Preferences");
 		if ((sw > 240) && (sh > 240))
 			this.resizable = true;
-		//this.moveable = true;
-		//this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
+		// this.moveable = true;
+		// this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
 
 		// set dialog-width according to fontsize
-		if((pref.fontSize <= 13)||(sw <= 240)||(sh <= 240)){
-			setPreferredSize(240,240);
-		}
-		else if(pref.fontSize <= 28){
+		if ((pref.fontSize <= 13) || (sw <= 240) || (sh <= 240)) {
+			setPreferredSize(240, 240);
+		} else if (pref.fontSize <= 28) {
 			// was for <=16 setPreferredSize(288,252);
-			setPreferredSize(pref.fontSize*20,pref.fontSize*18);
+			setPreferredSize(pref.fontSize * 20, pref.fontSize * 18);
+		} else if (pref.fontSize <= 20) {
+			setPreferredSize(352, 302);
+		} else if (pref.fontSize <= 24) {
+			setPreferredSize(420, 350);
+		} else if (pref.fontSize <= 28) {
+			setPreferredSize(480, 390);
+		} else {
+			setPreferredSize(576, 512);
 		}
-		else if(pref.fontSize <= 20){
-			setPreferredSize(352,302);
-		}
-		else if(pref.fontSize <= 24){
-			setPreferredSize(420,350);
-		}
-		else if(pref.fontSize <= 28){
-			setPreferredSize(480,390);
-		}
-		else{
-			setPreferredSize(576,512);
-		}
-		
-		//scp = new ScrollBarPanel(pnlGeneral);
-		
-		/////////////////////////////////////////////////////////
+
+		// scp = new ScrollBarPanel(pnlGeneral);
+
+		// ///////////////////////////////////////////////////////
 		// First panel - General
-		/////////////////////////////////////////////////////////
-		CellPanel cpDataDir=new CellPanel();
-		cpDataDir.addNext(new mLabel(MyLocale.getMsg(603,"Data Directory:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		// ///////////////////////////////////////////////////////
+		CellPanel cpDataDir = new CellPanel();
+		cpDataDir.addNext(new mLabel(MyLocale.getMsg(603, "Data Directory:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		DataDir = new mInput();
 		DataDir.setText(pref.getBaseDir());
-		cpDataDir.addNext(DataDir,CellConstants.STRETCH, (CellConstants.FILL|CellConstants.LEFT));
-		cpDataDir.addLast(brwBt = new mButton(MyLocale.getMsg(604,"Browse")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.RIGHT));
-		cpDataDir.addNext(chkAutoLoad = new mCheckBox(MyLocale.getMsg(629,"Autoload last profile")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		if (pref.autoReloadLastProfile) chkAutoLoad.setState(true);
-		cpDataDir.addNext(chkSetCurrentCentreFromGPSPosition = new mCheckBox(MyLocale.getMsg(646,"centre from GPS")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.RIGHT));
-		if (pref.setCurrentCentreFromGPSPosition) chkSetCurrentCentreFromGPSPosition.setState(true);
-		pnlGeneral.addLast(separator(cpDataDir),HSTRETCH,HFILL);
-		
-		CellPanel cpBrowser=new CellPanel();
-		cpBrowser.addNext(new mLabel("Browser:"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		cpBrowser.addLast(Browser = new mInput(pref.browser),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.LEFT));
-		cpBrowser.addNext(new mLabel(MyLocale.getMsg(601,"Your Alias:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		
-		cpBrowser.addNext(Alias = new mInput(pref.myAlias),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		cpBrowser.addNext(new mLabel(MyLocale.getMsg(594,"Pwd")));
-		cpBrowser.addLast(inpPassword=new mInput(pref.password),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		inpPassword.setToolTip(MyLocale.getMsg(593,"Password is optional here.\nEnter only if you want to store it in pref.xml"));
-		inpPassword.isPassword=true;
-		cpBrowser.addNext(chkPM=new mCheckBox("PM"));
-		if (pref.isPremium) chkPM.setState(true);
-		cpBrowser.addNext(new mLabel(MyLocale.getMsg(650,"GcMemberID:")));
-		cpBrowser.addLast(inpGcMemberID=new mInput(pref.gcMemberId),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		
-		pnlGeneral.addLast(separator(cpBrowser),HSTRETCH,HFILL);
-		
-		CellPanel cpGPS=new CellPanel();
-		cpGPS.addNext(new mLabel("GPS: "),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		cpGPS.addLast(gpsB = new mButton(MyLocale.getMsg(600,"Preferences")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		// "GPS: " + (pref.useGPSD ? "gpsd " + pref.gpsdHost : pref.mySPO.portName+"/"+pref.mySPO.baudRate) 
-		pnlGeneral.addLast(separator(cpGPS),HSTRETCH,HFILL);
+		cpDataDir.addNext(DataDir, CellConstants.STRETCH, (CellConstants.FILL | CellConstants.LEFT));
+		cpDataDir.addLast(brwBt = new mButton(MyLocale.getMsg(604, "Browse")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.RIGHT));
+		cpDataDir.addNext(chkAutoLoad = new mCheckBox(MyLocale.getMsg(629, "Autoload last profile")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		if (pref.autoReloadLastProfile)
+			chkAutoLoad.setState(true);
+		cpDataDir.addNext(chkSetCurrentCentreFromGPSPosition = new mCheckBox(MyLocale.getMsg(646, "centre from GPS")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.RIGHT));
+		if (pref.setCurrentCentreFromGPSPosition)
+			chkSetCurrentCentreFromGPSPosition.setState(true);
+		pnlGeneral.addLast(separator(cpDataDir), HSTRETCH, HFILL);
 
+		CellPanel cpBrowser = new CellPanel();
+		cpBrowser.addNext(new mLabel("Browser:"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		cpBrowser.addLast(Browser = new mInput(pref.browser), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.LEFT));
+		cpBrowser.addNext(new mLabel(MyLocale.getMsg(601, "Your Alias:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		cpBrowser.addNext(Alias = new mInput(pref.myAlias), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		cpBrowser.addNext(new mLabel(MyLocale.getMsg(594, "Pwd")));
+		cpBrowser.addLast(inpPassword = new mInput(pref.password), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		inpPassword.setToolTip(MyLocale.getMsg(593, "Password is optional here.\nEnter only if you want to store it in pref.xml"));
+		inpPassword.isPassword = true;
+		cpBrowser.addNext(chkPM = new mCheckBox("PM"));
+		if (pref.isPremium)
+			chkPM.setState(true);
+		cpBrowser.addNext(new mLabel(MyLocale.getMsg(650, "GcMemberID:")));
+		cpBrowser.addLast(inpGcMemberID = new mInput(pref.gcMemberId), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		cpBrowser.addNext(new mLabel("UserID"));
+		cpBrowser.addLast(inpUserID = new mInput(pref.userID), CellConstants.DONTSTRETCH, (CellConstants.HFILL | CellConstants.LEFT));
+
+		pnlGeneral.addLast(separator(cpBrowser), HSTRETCH, HFILL);
+
+		CellPanel cpGPS = new CellPanel();
+		cpGPS.addNext(new mLabel("GPS: "), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		cpGPS.addLast(gpsB = new mButton(MyLocale.getMsg(600, "Preferences")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		// "GPS: " + (pref.useGPSD ? "gpsd " + pref.gpsdHost : pref.mySPO.portName+"/"+pref.mySPO.baudRate)
+		pnlGeneral.addLast(separator(cpGPS), HSTRETCH, HFILL);
+
 		// Garmin and GPSBabel
-		CellPanel cpBabel=new CellPanel();
-		cpBabel.addNext(lblGarmin=new mLabel(MyLocale.getMsg(173,"Garmin:  PC Port:")),DONTSTRETCH,LEFT);
-		cpBabel.addNext(chcGarminPort=new mChoice(garminPorts,0),DONTSTRETCH,RIGHT);
+		CellPanel cpBabel = new CellPanel();
+		cpBabel.addNext(lblGarmin = new mLabel(MyLocale.getMsg(173, "Garmin:  PC Port:")), DONTSTRETCH, LEFT);
+		cpBabel.addNext(chcGarminPort = new mChoice(garminPorts, 0), DONTSTRETCH, RIGHT);
 		chcGarminPort.selectItem(pref.garminConn);
-		cpBabel.addLast(chkSynthShort=new mCheckBox(MyLocale.getMsg(174,"Short Names")),STRETCH,LEFT);
+		cpBabel.addLast(chkSynthShort = new mCheckBox(MyLocale.getMsg(174, "Short Names")), STRETCH, LEFT);
 		chkSynthShort.setState(!pref.garminGPSBabelOptions.equals(""));
-		cpBabel.addNext(new mLabel(MyLocale.getMsg(643,"Append cache details to:")),DONTSTRETCH,LEFT);
-		cpBabel.addNext(chkAddDetailsToWaypoint=new mCheckBox(MyLocale.getMsg(644,"waypoints")),DONTSTRETCH,RIGHT);
+		cpBabel.addNext(new mLabel(MyLocale.getMsg(643, "Append cache details to:")), DONTSTRETCH, LEFT);
+		cpBabel.addNext(chkAddDetailsToWaypoint = new mCheckBox(MyLocale.getMsg(644, "waypoints")), DONTSTRETCH, RIGHT);
 		chkAddDetailsToWaypoint.setState(pref.addDetailsToWaypoint);
-		cpBabel.addLast(chkAddDetailsToName=new mCheckBox(MyLocale.getMsg(645,"names")),STRETCH,LEFT);
+		cpBabel.addLast(chkAddDetailsToName = new mCheckBox(MyLocale.getMsg(645, "names")), STRETCH, LEFT);
 		chkAddDetailsToName.setState(pref.addDetailsToName);
-		pnlGeneral.addLast(cpBabel,HSTRETCH,HFILL);
-		
-		/////////////////////////////////////////////////////////
+		pnlGeneral.addLast(cpBabel, HSTRETCH, HFILL);
+
+		// ///////////////////////////////////////////////////////
 		// Second panel - Screen
-		/////////////////////////////////////////////////////////
-		
-		CellPanel pnlScreen=new CellPanel();
-		Frame frmScreen=new Frame();
-		frmScreen.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER;
-		pnlScreen.addNext(new mLabel(MyLocale.getMsg(625,"Screen (needs restart):")));
-		pnlScreen.addNext(new mLabel("Font"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		pnlScreen.addNext(fontName = new mInput(),CellConstants.STRETCH, (CellConstants.HFILL|CellConstants.LEFT));
-		fontName.maxLength=50;
+		// ///////////////////////////////////////////////////////
+
+		CellPanel pnlScreen = new CellPanel();
+		Frame frmScreen = new Frame();
+		frmScreen.borderStyle = UIConstants.BDR_RAISEDOUTER | UIConstants.BDR_SUNKENINNER;
+		pnlScreen.addNext(new mLabel(MyLocale.getMsg(625, "Screen (needs restart):")));
+		pnlScreen.addNext(new mLabel("Font"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		pnlScreen.addNext(fontName = new mInput(), CellConstants.STRETCH, (CellConstants.HFILL | CellConstants.LEFT));
+		fontName.maxLength = 50;
 		fontName.setText(pref.fontName);
-		pnlScreen.addLast(fontSize = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.LEFT));
-		fontSize.maxLength=2;
-		fontSize.setPreferredSize(2*pref.fontSize,-1);
+		pnlScreen.addLast(fontSize = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.HFILL | CellConstants.LEFT));
+		fontSize.maxLength = 2;
+		fontSize.setPreferredSize(2 * pref.fontSize, -1);
 		fontSize.setText(Convert.toString(pref.fontSize));
-		frmScreen.addLast(pnlScreen,HSTRETCH,HFILL);
-		
-		frmScreen.addLast(chkHasCloseButton=new mCheckBox(MyLocale.getMsg(631,"PDA has close Button")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));	
-    	//lblTitle.setTag(INSETS,new Insets(2,0,0,0));
-        chkHasCloseButton.setState(pref.hasCloseButton);
-		frmScreen.addNext(chkMenuAtTop = new mCheckBox(MyLocale.getMsg(626,"Menu top")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		chkMenuAtTop.setTag(INSETS,new Insets(0,0,2,0));
+		frmScreen.addLast(pnlScreen, HSTRETCH, HFILL);
+
+		frmScreen.addLast(chkHasCloseButton = new mCheckBox(MyLocale.getMsg(631, "PDA has close Button")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		// lblTitle.setTag(INSETS,new Insets(2,0,0,0));
+		chkHasCloseButton.setState(pref.hasCloseButton);
+		frmScreen.addNext(chkMenuAtTop = new mCheckBox(MyLocale.getMsg(626, "Menu top")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		chkMenuAtTop.setTag(INSETS, new Insets(0, 0, 2, 0));
 		chkMenuAtTop.setState(pref.menuAtTop);
-		frmScreen.addNext(chkTabsAtTop = new mCheckBox(MyLocale.getMsg(627,"Tabs top")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		frmScreen.addNext(chkTabsAtTop = new mCheckBox(MyLocale.getMsg(627, "Tabs top")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkTabsAtTop.setState(pref.tabsAtTop);
-		chkTabsAtTop.setTag(INSETS,new Insets(0,0,2,0));
-		frmScreen.addLast(chkShowStatus = new mCheckBox(MyLocale.getMsg(628,"Status")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		chkTabsAtTop.setTag(INSETS, new Insets(0, 0, 2, 0));
+		frmScreen.addLast(chkShowStatus = new mCheckBox(MyLocale.getMsg(628, "Status")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkShowStatus.setState(pref.showStatus);
-		chkShowStatus.setTag(INSETS,new Insets(0,0,2,0));
-		pnlDisplay.addLast(frmScreen,CellConstants.HSTRETCH,CellConstants.FILL);
-		
-		Frame frmImages=new Frame();
-		frmImages.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_TOP|UIConstants.BF_BOTTOM;
-		//frmImages.addNext(new mLabel(MyLocale.getMsg(623,"Images:")),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		frmImages.addLast(chkShowDeletedImg = new mCheckBox(MyLocale.getMsg(624,"Show deleted images")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		chkShowDeletedImg.setTag(INSETS,new Insets(2,0,0,0));
-		if (pref.showDeletedImages) chkShowDeletedImg.setState(true);
-		//mLabel dummy;
-		//frmImages.addNext(dummy=new mLabel(""),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT|CellConstants.NORTH));
-		//dummy.setTag(INSETS,new Insets(0,0,2,0));
-		frmImages.addLast(chkDescShowImg = new mCheckBox(MyLocale.getMsg(638,"Show pictures in description")),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT|CellConstants.NORTH));
-		chkDescShowImg.setTag(INSETS,new Insets(0,0,2,0));
-		if (pref.descShowImg) chkDescShowImg.setState(true);
-		pnlDisplay.addLast(frmImages,CellConstants.STRETCH,CellConstants.FILL);
+		chkShowStatus.setTag(INSETS, new Insets(0, 0, 2, 0));
+		pnlDisplay.addLast(frmScreen, CellConstants.HSTRETCH, CellConstants.FILL);
 
-		Frame frmHintLog=new Frame();
-		//frmHintLog.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_BOTTOM;
-		frmHintLog.addNext(new mLabel(MyLocale.getMsg(630,"HintLogPanel:  Logs per page ")),CellConstants.DONTSTRETCH,CellConstants.DONTFILL);	
-		frmHintLog.addLast(inpLogsPerPage=new mInput(),CellConstants.DONTSTRETCH,CellConstants.DONTFILL|CellConstants.RIGHT);
+		Frame frmImages = new Frame();
+		frmImages.borderStyle = UIConstants.BDR_RAISEDOUTER | UIConstants.BDR_SUNKENINNER | UIConstants.BF_TOP | UIConstants.BF_BOTTOM;
+		// frmImages.addNext(new mLabel(MyLocale.getMsg(623,"Images:")),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		frmImages.addLast(chkShowDeletedImg = new mCheckBox(MyLocale.getMsg(624, "Show deleted images")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		chkShowDeletedImg.setTag(INSETS, new Insets(2, 0, 0, 0));
+		if (pref.showDeletedImages)
+			chkShowDeletedImg.setState(true);
+		// mLabel dummy;
+		// frmImages.addNext(dummy=new mLabel(""),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT|CellConstants.NORTH));
+		// dummy.setTag(INSETS,new Insets(0,0,2,0));
+		frmImages.addLast(chkDescShowImg = new mCheckBox(MyLocale.getMsg(638, "Show pictures in description")), CellConstants.VSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT | CellConstants.NORTH));
+		chkDescShowImg.setTag(INSETS, new Insets(0, 0, 2, 0));
+		if (pref.descShowImg)
+			chkDescShowImg.setState(true);
+		pnlDisplay.addLast(frmImages, CellConstants.STRETCH, CellConstants.FILL);
+
+		Frame frmHintLog = new Frame();
+		// frmHintLog.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_BOTTOM;
+		frmHintLog.addNext(new mLabel(MyLocale.getMsg(630, "HintLogPanel:  Logs per page ")), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		frmHintLog.addLast(inpLogsPerPage = new mInput(), CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.RIGHT);
 		inpLogsPerPage.setText(Convert.toString(pref.logsPerPage));
-		inpLogsPerPage.setPreferredSize(40,-1);
-		//inpLogsPerPage.setTag(INSETS,new Insets(0,0,2,0));
-		//lblHlP.setTag(INSETS,new Insets(6,0,2,0));
+		inpLogsPerPage.setPreferredSize(40, -1);
+		// inpLogsPerPage.setTag(INSETS,new Insets(0,0,2,0));
+		// lblHlP.setTag(INSETS,new Insets(6,0,2,0));
 
-		frmHintLog.addNext(new mLabel(MyLocale.getMsg(633,"Max. logs to spider")),CellConstants.DONTSTRETCH,CellConstants.DONTFILL);	
-		frmHintLog.addLast(inpMaxLogsToSpider=new mInput(),CellConstants.DONTSTRETCH,CellConstants.DONTFILL|CellConstants.RIGHT);
+		frmHintLog.addNext(new mLabel(MyLocale.getMsg(633, "Max. logs to spider")), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		frmHintLog.addLast(inpMaxLogsToSpider = new mInput(), CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.RIGHT);
 		inpMaxLogsToSpider.setText(Convert.toString(pref.maxLogsToSpider));
-		inpMaxLogsToSpider.setPreferredSize(40,-1);
-		
-		String [] spiderUpdateOptions = { MyLocale.getMsg(640,"Yes"), MyLocale.getMsg(641,"No"), MyLocale.getMsg(642,"Ask") };
-		frmHintLog.addNext(new mLabel( MyLocale.getMsg(639,"Update caches when spidering?") ),DONTSTRETCH,DONTFILL|LEFT);
-		frmHintLog.addLast(inpSpiderUpdates=new mChoice(spiderUpdateOptions, pref.spiderUpdates),DONTSTRETCH,DONTFILL|LEFT);
-		pnlDisplay.addLast(frmHintLog,CellConstants.STRETCH,CellConstants.FILL);
+		inpMaxLogsToSpider.setPreferredSize(40, -1);
 
-		/////////////////////////////////////////////////////////
+		String[] spiderUpdateOptions = { MyLocale.getMsg(640, "Yes"), MyLocale.getMsg(641, "No"), MyLocale.getMsg(642, "Ask") };
+		frmHintLog.addNext(new mLabel(MyLocale.getMsg(639, "Update caches when spidering?")), DONTSTRETCH, DONTFILL | LEFT);
+		frmHintLog.addLast(inpSpiderUpdates = new mChoice(spiderUpdateOptions, pref.spiderUpdates), DONTSTRETCH, DONTFILL | LEFT);
+		pnlDisplay.addLast(frmHintLog, CellConstants.STRETCH, CellConstants.FILL);
+
+		// ///////////////////////////////////////////////////////
 		// Third panel - More
-		/////////////////////////////////////////////////////////
-		CellPanel pnlProxy=new CellPanel();
-		pnlProxy.addNext(new mLabel("Proxy"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		pnlProxy.addLast(Proxy = new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.LEFT)).setTag(SPAN,new Dimension(2,1));
+		// ///////////////////////////////////////////////////////
+		CellPanel pnlProxy = new CellPanel();
+		pnlProxy.addNext(new mLabel("Proxy"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		pnlProxy.addLast(Proxy = new mInput(), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.LEFT)).setTag(SPAN, new Dimension(2, 1));
 		Proxy.setText(pref.myproxy);
-		pnlProxy.addNext(new mLabel("Port"),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		pnlProxy.addLast(ProxyPort = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		pnlProxy.addNext(new mLabel("Port"), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		pnlProxy.addLast(ProxyPort = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		ProxyPort.setText(pref.myproxyport);
-		pnlProxy.addNext(new mLabel(""),HSTRETCH,HFILL);
-		pnlProxy.addLast(chkProxyActive=new mCheckBox(MyLocale.getMsg(634,"use Proxy")));
+		pnlProxy.addNext(new mLabel(""), HSTRETCH, HFILL);
+		pnlProxy.addLast(chkProxyActive = new mCheckBox(MyLocale.getMsg(634, "use Proxy")));
 		chkProxyActive.setState(pref.proxyActive);
-		pnlMore.addLast(pnlProxy,HSTRETCH,HFILL);
-		pnlMore.addNext(new mLabel(MyLocale.getMsg(592,"Language (needs restart)")),DONTSTRETCH,DONTFILL|LEFT);
-		String[] tmp = (new FileBugfix(FileBase.getProgramDirectory()+"/languages").list("*.cfg", FileBase.LIST_FILES_ONLY)); //"*.xyz" doesn't work on some systems -> use FileBugFix
-		if (tmp == null) tmp = new String[0];
-		String [] langs = new String[tmp.length +1];
+		pnlMore.addLast(pnlProxy, HSTRETCH, HFILL);
+		pnlMore.addNext(new mLabel(MyLocale.getMsg(592, "Language (needs restart)")), DONTSTRETCH, DONTFILL | LEFT);
+		String[] tmp = (new FileBugfix(FileBase.getProgramDirectory() + "/languages").list("*.cfg", FileBase.LIST_FILES_ONLY)); // "*.xyz" doesn't work on some systems -> use FileBugFix
+		if (tmp == null)
+			tmp = new String[0];
+		String[] langs = new String[tmp.length + 1];
 		langs[0] = "auto";
 		int curlang = 0;
 		for (int i = 0; i < tmp.length; i++) {
-			langs[i+1] = tmp[i].substring(0, tmp[i].lastIndexOf('.'));
-			if (langs[i+1].equalsIgnoreCase(MyLocale.language)) curlang = i+1 ;
+			langs[i + 1] = tmp[i].substring(0, tmp[i].lastIndexOf('.'));
+			if (langs[i + 1].equalsIgnoreCase(MyLocale.language))
+				curlang = i + 1;
 		}
-		//ewe.sys.Vm.copyArray(tmp, 0, langs, 1, tmp.length);
-		pnlMore.addLast(inpLanguage=new mChoice(langs, curlang),DONTSTRETCH,DONTFILL|LEFT);
-		//inpLanguage.setPreferredSize(20,-1);
-		inpLanguage.setToolTip(MyLocale.getMsg(591,"Select \"auto\" for system language or select your preferred language, e.g. DE or EN"));
-		String [] metriken = {MyLocale.getMsg(589, "Metric (km)"), 
-				              MyLocale.getMsg(590, "Imperial (mi)")};
-		pnlMore.addNext(new mLabel(MyLocale.getMsg(588, "Length units")),DONTSTRETCH,DONTFILL|LEFT);
+		// ewe.sys.Vm.copyArray(tmp, 0, langs, 1, tmp.length);
+		pnlMore.addLast(inpLanguage = new mChoice(langs, curlang), DONTSTRETCH, DONTFILL | LEFT);
+		// inpLanguage.setPreferredSize(20,-1);
+		inpLanguage.setToolTip(MyLocale.getMsg(591, "Select \"auto\" for system language or select your preferred language, e.g. DE or EN"));
+		String[] metriken = { MyLocale.getMsg(589, "Metric (km)"), MyLocale.getMsg(590, "Imperial (mi)") };
+		pnlMore.addNext(new mLabel(MyLocale.getMsg(588, "Length units")), DONTSTRETCH, DONTFILL | LEFT);
 		int currMetrik = pref.metricSystem == Metrics.METRIC ? 0 : 1;
-		pnlMore.addLast(inpMetric=new mChoice(metriken, currMetrik),DONTSTRETCH,DONTFILL|LEFT);
-		pnlMore.addLast(chkSortingGroupedByCache=new mCheckBox(MyLocale.getMsg(647,"Sorting grouped by Cache")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));	
+		pnlMore.addLast(inpMetric = new mChoice(metriken, currMetrik), DONTSTRETCH, DONTFILL | LEFT);
+		pnlMore.addLast(chkSortingGroupedByCache = new mCheckBox(MyLocale.getMsg(647, "Sorting grouped by Cache")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkSortingGroupedByCache.setState(pref.SortingGroupedByCache);
-		pnlMore.addLast(chkuseOwnSymbols=new mCheckBox(MyLocale.getMsg(649,"use own symbols")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));	
+		pnlMore.addLast(chkuseOwnSymbols = new mCheckBox(MyLocale.getMsg(649, "use own symbols")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkuseOwnSymbols.setState(pref.useOwnSymbols);
-		pnlMore.addLast(chkDebug=new mCheckBox(MyLocale.getMsg(648,"Debug Mode")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));	
+		pnlMore.addLast(chkDebug = new mCheckBox(MyLocale.getMsg(648, "Debug Mode")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkDebug.setState(pref.debug);
 
-		/////////////////////////////////////////////////////////
+		// ///////////////////////////////////////////////////////
 		// Fourth/Fifth panel - Listview and Travelbugs
-		/////////////////////////////////////////////////////////
+		// ///////////////////////////////////////////////////////
 
-        mTab.addCard(pnlGeneral,MyLocale.getMsg(621,"General"),null);
-		mTab.addCard(pnlDisplay,MyLocale.getMsg(622,"Screen"),null);
-		mTab.addCard(pnlMore,MyLocale.getMsg(632,"More"),null);
-		mTab.addCard(tccList=new TableColumnChooser(new String[] {
-				MyLocale.getMsg(599,"checkbox"),
-				MyLocale.getMsg(598,"type"),
-				MyLocale.getMsg(606,"Difficulty"),
-				MyLocale.getMsg(607,"Terrain"),
-				MyLocale.getMsg(597,"waypoint"),
-				MyLocale.getMsg(596,"name"),
-				MyLocale.getMsg(608,"Location"),
-				MyLocale.getMsg(609,"Owner"),
-				MyLocale.getMsg(610,"Hidden"),
-				MyLocale.getMsg(611,"Status"),
-				MyLocale.getMsg(612,"Distance"),
-				MyLocale.getMsg(613,"Bearing"),
-				MyLocale.getMsg(635,"Size"),
-				MyLocale.getMsg(636,"OC Empfehlungen"),
-				MyLocale.getMsg(637,"OC Index"),
-				MyLocale.getMsg(1039,"Solver exists"),
-				MyLocale.getMsg(1041,"Note exists"),
-				MyLocale.getMsg(1046,"# Additionals"),
-				MyLocale.getMsg(1048, "# DNF Logs"),
-				MyLocale.getMsg(1051, "Last sync date")
-				},pref.listColMap),MyLocale.getMsg(595,"List"),null);
+		mTab.addCard(pnlGeneral, MyLocale.getMsg(621, "General"), null);
+		mTab.addCard(pnlDisplay, MyLocale.getMsg(622, "Screen"), null);
+		mTab.addCard(pnlMore, MyLocale.getMsg(632, "More"), null);
+		mTab.addCard(tccList = new TableColumnChooser(new String[] { MyLocale.getMsg(599, "checkbox"), MyLocale.getMsg(598, "type"), MyLocale.getMsg(606, "Difficulty"), MyLocale.getMsg(607, "Terrain"), MyLocale.getMsg(597, "waypoint"),
+				MyLocale.getMsg(596, "name"), MyLocale.getMsg(608, "Location"), MyLocale.getMsg(609, "Owner"), MyLocale.getMsg(610, "Hidden"), MyLocale.getMsg(611, "Status"), MyLocale.getMsg(612, "Distance"), MyLocale.getMsg(613, "Bearing"),
+				MyLocale.getMsg(635, "Size"), MyLocale.getMsg(636, "OC Empfehlungen"), MyLocale.getMsg(637, "OC Index"), MyLocale.getMsg(1039, "Solver exists"), MyLocale.getMsg(1041, "Note exists"), MyLocale.getMsg(1046, "# Additionals"),
+				MyLocale.getMsg(1048, "# DNF Logs"), MyLocale.getMsg(1051, "Last sync date") }, pref.listColMap), MyLocale.getMsg(595, "List"), null);
 
-		mTab.addCard(tccBugs=new TableColumnChooser(new String[] {
-				MyLocale.getMsg(6000,"Guid"),
-				MyLocale.getMsg(6001,"Name"),
-				MyLocale.getMsg(6002,"track#"),
-				MyLocale.getMsg(6003,"Mission"),
-				MyLocale.getMsg(6004,"From Prof"),
-				MyLocale.getMsg(6005,"From Wpt"),
-				MyLocale.getMsg(6006,"From Date"),
-				MyLocale.getMsg(6007,"From Log"),
-				MyLocale.getMsg(6008,"To Prof"),
-				MyLocale.getMsg(6009,"To Wpt"),
-				MyLocale.getMsg(6010,"To Date"),
-				MyLocale.getMsg(6011,"To Log")},pref.travelbugColMap),"T-bugs",null);
-		
+		mTab.addCard(tccBugs = new TableColumnChooser(new String[] { MyLocale.getMsg(6000, "Guid"), MyLocale.getMsg(6001, "Name"), MyLocale.getMsg(6002, "track#"), MyLocale.getMsg(6003, "Mission"), MyLocale.getMsg(6004, "From Prof"),
+				MyLocale.getMsg(6005, "From Wpt"), MyLocale.getMsg(6006, "From Date"), MyLocale.getMsg(6007, "From Log"), MyLocale.getMsg(6008, "To Prof"), MyLocale.getMsg(6009, "To Wpt"), MyLocale.getMsg(6010, "To Date"),
+				MyLocale.getMsg(6011, "To Log") }, pref.travelbugColMap), "T-bugs", null);
+
 		this.addLast(mTab);
-		cancelB = new mButton(MyLocale.getMsg(614,"Cancel"));
+		cancelB = new mButton(MyLocale.getMsg(614, "Cancel"));
 		cancelB.setHotKey(0, IKeys.ESCAPE);
-		addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		applyB = new mButton(MyLocale.getMsg(615,"Apply"));
+		addNext(cancelB, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		applyB = new mButton(MyLocale.getMsg(615, "Apply"));
 		applyB.setHotKey(0, IKeys.ACTION);
-		addLast(applyB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		addLast(applyB, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 	}
-	
+
 	private CellPanel separator(CellPanel pnl) {
 		CellPanel outerPnl = new CellPanel();
-		pnl.setTag(INSETS,new Insets(0,0,2,0));
-		outerPnl.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_BOTTOM;
-		outerPnl.setTag(INSETS,new Insets(0,0,2,0));
-		outerPnl.addLast(pnl,HSTRETCH,HFILL);
+		pnl.setTag(INSETS, new Insets(0, 0, 2, 0));
+		outerPnl.borderStyle = UIConstants.BDR_RAISEDOUTER | UIConstants.BDR_SUNKENINNER | UIConstants.BF_BOTTOM;
+		outerPnl.setTag(INSETS, new Insets(0, 0, 2, 0));
+		outerPnl.addLast(pnl, HSTRETCH, HFILL);
 		return outerPnl;
 	}
-	public void onEvent(Event ev){
-		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelB){
+
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
+			if (ev.target == cancelB) {
 				this.close(0);
 			}
-			if (ev.target == applyB){
+			if (ev.target == applyB) {
 				pref.setBaseDir(DataDir.getText());
 				pref.fontSize = Convert.toInt(fontSize.getText());
-				if (pref.fontSize<6) pref.fontSize=11;
-				pref.fontName=fontName.getText();
-				pref.logsPerPage=Common.parseInt(inpLogsPerPage.getText());
-				if (pref.logsPerPage==0) pref.logsPerPage=pref.DEFAULT_LOGS_PER_PAGE;
-				pref.maxLogsToSpider=Common.parseInt(inpMaxLogsToSpider.getText());
-				if (pref.maxLogsToSpider==0) pref.maxLogsToSpider=pref.DEFAULT_MAX_LOGS_TO_SPIDER;
-				
+				if (pref.fontSize < 6)
+					pref.fontSize = 11;
+				pref.fontName = fontName.getText();
+				pref.logsPerPage = Common.parseInt(inpLogsPerPage.getText());
+				if (pref.logsPerPage == 0)
+					pref.logsPerPage = pref.DEFAULT_LOGS_PER_PAGE;
+				pref.maxLogsToSpider = Common.parseInt(inpMaxLogsToSpider.getText());
+				if (pref.maxLogsToSpider == 0)
+					pref.maxLogsToSpider = pref.DEFAULT_MAX_LOGS_TO_SPIDER;
+
 				Font defaultGuiFont = mApp.findFont("gui");
 				int sz = (pref.fontSize);
-				Font newGuiFont = new Font(defaultGuiFont.getName(), defaultGuiFont.getStyle(), sz); 
-				mApp.addFont(newGuiFont, "gui"); 
+				Font newGuiFont = new Font(defaultGuiFont.getName(), defaultGuiFont.getStyle(), sz);
+				mApp.addFont(newGuiFont, "gui");
 				mApp.fontsChanged();
 				mApp.mainApp.font = newGuiFont;
-				
+
 				pref.myAlias = Alias.getText().trim();
-				pref.password= inpPassword.getText().trim();
-				pref.gcMemberId=inpGcMemberID.getText().trim();
-				MyLocale.saveLanguage(MyLocale.language=inpLanguage.getText().toUpperCase().trim());
+				pref.password = inpPassword.getText().trim();
+				pref.gcMemberId = inpGcMemberID.getText().trim();
+				pref.userID = inpUserID.getText().trim();
+				MyLocale.saveLanguage(MyLocale.language = inpLanguage.getText().toUpperCase().trim());
 				pref.browser = Browser.getText();
 				pref.myproxy = Proxy.getText();
 				pref.myproxyport = ProxyPort.getText();
-				pref.proxyActive=chkProxyActive.getState();
+				pref.proxyActive = chkProxyActive.getState();
 				HttpConnection.setProxy(pref.myproxy, Common.parseInt(pref.myproxyport), pref.proxyActive); // TODO generate an error message if proxy port is not a number
-				pref.autoReloadLastProfile=chkAutoLoad.getState();
-				pref.isPremium=chkPM.getState();
-				pref.setCurrentCentreFromGPSPosition=chkSetCurrentCentreFromGPSPosition.getState();
-				pref.showDeletedImages=chkShowDeletedImg.getState();
-				pref.garminConn=chcGarminPort.getSelectedItem().toString();
-				pref.garminGPSBabelOptions=chkSynthShort.state?"-s":"";
-				pref.menuAtTop=chkMenuAtTop.getState();
-				pref.tabsAtTop=chkTabsAtTop.getState();
-				pref.showStatus=chkShowStatus.getState();
-				pref.hasCloseButton=chkHasCloseButton.getState();
-				pref.travelbugColMap=tccBugs.getSelectedCols();
-				pref.listColMap=tccList.getSelectedCols();
-				pref.descShowImg=chkDescShowImg.getState();
+				pref.autoReloadLastProfile = chkAutoLoad.getState();
+				pref.isPremium = chkPM.getState();
+				pref.setCurrentCentreFromGPSPosition = chkSetCurrentCentreFromGPSPosition.getState();
+				pref.showDeletedImages = chkShowDeletedImg.getState();
+				pref.garminConn = chcGarminPort.getSelectedItem().toString();
+				pref.garminGPSBabelOptions = chkSynthShort.state ? "-s" : "";
+				pref.menuAtTop = chkMenuAtTop.getState();
+				pref.tabsAtTop = chkTabsAtTop.getState();
+				pref.showStatus = chkShowStatus.getState();
+				pref.hasCloseButton = chkHasCloseButton.getState();
+				pref.travelbugColMap = tccBugs.getSelectedCols();
+				pref.listColMap = tccList.getSelectedCols();
+				pref.descShowImg = chkDescShowImg.getState();
 				Global.mainTab.tbP.myMod.setColumnNamesAndWidths();
 				pref.metricSystem = inpMetric.getInt() == 0 ? Metrics.METRIC : Metrics.IMPERIAL;
 				pref.spiderUpdates = inpSpiderUpdates.getInt();
 				pref.addDetailsToWaypoint = chkAddDetailsToWaypoint.getState();
 				pref.addDetailsToName = chkAddDetailsToName.getState();
-				pref.SortingGroupedByCache=chkSortingGroupedByCache.getState();
-				pref.useOwnSymbols=chkuseOwnSymbols.getState();
-				pref.debug=chkDebug.getState();
+				pref.SortingGroupedByCache = chkSortingGroupedByCache.getState();
+				pref.useOwnSymbols = chkuseOwnSymbols.getState();
+				pref.debug = chkDebug.getState();
 
 				pref.savePreferences();
 				pref.dirty = true; // Need to update table in case columns were enabled/disabled
 				this.close(0);
 			}
-			if(ev.target == brwBt){
+			if (ev.target == brwBt) {
 				FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, pref.getBaseDir());
-				fc.setTitle(MyLocale.getMsg(616,"Select directory"));
-				if(fc.execute() != FormBase.IDCANCEL)	DataDir.setText(fc.getChosen()+"/");
+				fc.setTitle(MyLocale.getMsg(616, "Select directory"));
+				if (fc.execute() != FormBase.IDCANCEL)
+					DataDir.setText(fc.getChosen() + "/");
 			}
-			if (ev.target == gpsB){
+			if (ev.target == gpsB) {
 				GPSPortOptions gpo = new GPSPortOptions();
 				gpo.portName = pref.mySPO.portName;
 				gpo.baudRate = pref.mySPO.baudRate;
@@ -406,36 +381,36 @@
 				gpo.forwardGpsChkB.setState(pref.forwardGPS);
 				gpo.inputBoxForwardHost.setText(pref.forwardGpsHost);
 				gpo.chcUseGpsd.select(pref.useGPSD);
-				if(pref.gpsdPort!=pref.DEFAULT_GPSD_PORT){
+				if (pref.gpsdPort != pref.DEFAULT_GPSD_PORT) {
 					gpo.inputBoxGpsdHost.setText(pref.gpsdHost + ":" + Convert.toString(pref.gpsdPort));
-				}else{
+				} else {
 					gpo.inputBoxGpsdHost.setText(pref.gpsdHost);
 				}
 				gpo.logGpsChkB.setState(pref.logGPS);
 				gpo.inputBoxLogTimer.setText(pref.logGPSTimer);
 				Gui.setOKCancel(s);
-				if (s.execute()== FormBase.IDOK) {
-					pref.mySPO.portName = gpo.portName; 
+				if (s.execute() == FormBase.IDOK) {
+					pref.mySPO.portName = gpo.portName;
 					pref.mySPO.baudRate = gpo.baudRate;
 					pref.forwardGPS = gpo.forwardGpsChkB.getState();
 					pref.forwardGpsHost = gpo.inputBoxForwardHost.getText();
 					pref.useGPSD = gpo.chcUseGpsd.getInt();
-					String gpsdHostString = gpo.inputBoxGpsdHost.getText();	// hostname[:port]
+					String gpsdHostString = gpo.inputBoxGpsdHost.getText(); // hostname[:port]
 					int posColon = gpsdHostString.indexOf(':');
-					if(posColon>=0){
-						pref.gpsdHost=gpsdHostString.substring(0,posColon);
-						pref.gpsdPort=Convert.toInt(gpsdHostString.substring(posColon+1));
-					}else{
-						pref.gpsdHost=gpsdHostString;
-						pref.gpsdPort=pref.DEFAULT_GPSD_PORT;
+					if (posColon >= 0) {
+						pref.gpsdHost = gpsdHostString.substring(0, posColon);
+						pref.gpsdPort = Convert.toInt(gpsdHostString.substring(posColon + 1));
+					} else {
+						pref.gpsdHost = gpsdHostString;
+						pref.gpsdPort = pref.DEFAULT_GPSD_PORT;
 					}
 					pref.logGPS = gpo.logGpsChkB.getState();
 					pref.logGPSTimer = gpo.inputBoxLogTimer.getText();
-					gpsB.setText("GPS: " + pref.mySPO.portName+"/"+pref.mySPO.baudRate);
+					gpsB.setText("GPS: " + pref.mySPO.portName + "/" + pref.mySPO.baudRate);
 				}
 			}
 		}
 		super.onEvent(ev);
 	}
-	
+
 }

Modified: trunk/src/CacheWolf/UrlFetcher.java
===================================================================
--- trunk/src/CacheWolf/UrlFetcher.java	2011-05-02 11:30:16 UTC (rev 2994)
+++ trunk/src/CacheWolf/UrlFetcher.java	2011-05-06 15:11:39 UTC (rev 2995)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import ewe.data.PropertyList;
@@ -31,7 +31,6 @@
 import ewe.io.FileOutputStream;
 import ewe.io.IOException;
 import ewe.io.JavaUtf8Codec;
-import ewe.net.URL;
 import ewe.util.ByteArray;
 import ewe.util.CharArray;
 
@@ -40,103 +39,136 @@
 	static int maxRedirections = 5;
 	static PropertyList requestorProperties = null;
 	static PropertyList permanentRequestorProperties = null;
-	static String postData=null;
-	static String urltmp=null;
-	static String realUrl=null;
-	static boolean forceRedirect=false;
-	
+	static String postData = null;
+	static String urltmp = null;
+	static String realUrl = null;
+	static boolean forceRedirect = false;
+
 	public static PropertyList getDocumentProperties() {
-		if (conn != null) 
+		if (conn != null)
 			return conn.documentProperties;
-		else return null;
+		else
+			return null;
 	}
-	public static String getRealUrl() { return realUrl; };
-	public static void setMaxRedirections(int value) { maxRedirections=value; };
-	public static void setForceRedirect() { forceRedirect=true; };
-	public static void setRequestorProperties(PropertyList value) { requestorProperties=value; };
+
+	public static String getRealUrl() {
+		return realUrl;
+	};
+
+	public static void setMaxRedirections(int value) {
+		maxRedirections = value;
+	};
+
+	public static void setForceRedirect() {
+		forceRedirect = true;
+	};
+
+	public static void setRequestorProperties(PropertyList value) {
+		requestorProperties = value;
+	};
+
 	public static void setRequestorProperty(String name, String property) {
-		if (requestorProperties == null) requestorProperties = new PropertyList();
-		requestorProperties.set(name,property);
+		if (requestorProperties == null)
+			requestorProperties = new PropertyList();
+		requestorProperties.set(name, property);
 	}
+
 	private static void initPermanentRequestorProperty() {
 		permanentRequestorProperties = new PropertyList();
 		permanentRequestorProperties.add("User-Agent", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0");
-		permanentRequestorProperties.add("Connection", "keep-alive");		
+		permanentRequestorProperties.add("Connection", "keep-alive");
 	}
+
 	public static void setPermanentRequestorProperty(String name, String property) {
-		if (permanentRequestorProperties == null) initPermanentRequestorProperty();
-		if (property != null) 
-			permanentRequestorProperties.set(name,property);
+		if (permanentRequestorProperties == null)
+			initPermanentRequestorProperty();
+		if (property != null)
+			permanentRequestorProperties.set(name, property);
 		else {
 			int index = permanentRequestorProperties.find(name);
-			if ( index >= 0 ) permanentRequestorProperties.del(index);			
+			if (index >= 0)
+				permanentRequestorProperties.del(index);
 		}
 	}
-	public static void setpostData(String value) { 
-		postData=value;
+
+	public static void setpostData(String value) {
+		postData = value;
 	};
+
 	public static String fetch(String address) throws IOException {
 		ByteArray daten = fetchByteArray(address);
 		JavaUtf8Codec codec = new JavaUtf8Codec();
 		CharArray c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
 		return c_data.toString();
-	}	
+	}
+
 	public static ByteArray fetchData(String address) throws IOException {
 		return fetchByteArray(address);
 	}
+
 	public static void fetchDataFile(String address, String target) throws IOException {
-		FileOutputStream outp =  new FileOutputStream(new File(target));
+		FileOutputStream outp = new FileOutputStream(new File(target));
 		outp.write(fetchByteArray(address).toBytes());
 		outp.close();
 	}
+
 	/**
 	 * @param url
 	 * @return ByteArray
 	 * @throws IOException
 	 */
-	public static ByteArray fetchByteArray(String url) throws IOException {	
-		int i=0;
-		conn = new HttpConnection(url); //todo reuse: don#t reuse, some params are not correctly reset with SetUrl		
+	public static ByteArray fetchByteArray(String url) throws IOException {
+		int i = 0;
+		conn = new HttpConnection(url); // todo reuse: don#t reuse, some params are not correctly reset with SetUrl
 		urltmp = url;
-		do  { // allow max 5 redirections (http 302 location)
+		do { // allow max 5 redirections (http 302 location)
 			i++;
 			if (urltmp == null) {
-				// hack for expedia, doing the original url again. 
+				// hack for expedia, doing the original url again.
 				// expedia always must redirect >=1 time, but sometimes that is missed
 				// see also: http://www.geoclub.de/viewtopic.php?p=305071#305071
-				urltmp=url;
-				i=i-1;
+				urltmp = url;
+				i = i - 1;
 			}
-			realUrl=urltmp;
+			realUrl = urltmp;
 			conn.setUrl(urltmp);
 			conn.documentIsEncoded = isUrlEncoded(urltmp);
-			if (permanentRequestorProperties == null) initPermanentRequestorProperty();
+			if (permanentRequestorProperties == null)
+				initPermanentRequestorProperty();
 			if (postData != null) {
 				conn.setPostData(postData);
-				conn.setRequestorProperty("Content-Type","application/x-www-form-urlencoded");
+				conn.setRequestorProperty("Content-Type", "application/x-www-form-urlencoded");
 			}
 			conn.setRequestorProperty(permanentRequestorProperties);
-			if (requestorProperties != null) conn.setRequestorProperty(requestorProperties);
+			if (requestorProperties != null)
+				conn.setRequestorProperty(requestorProperties);
 			conn.connect();
-			if (conn.responseCode >= 400) throw new IOException("URL: "+ urltmp + "\nhttp response code: " + conn.responseCode);
+			if (conn.responseCode >= 400) {
+				maxRedirections = 5;
+				requestorProperties = null;
+				postData = null;
+				forceRedirect = false;
+				throw new IOException("URL: " + urltmp + "\nhttp response code: " + conn.responseCode);
+			}
 			urltmp = conn.getRedirectTo();
-			if(urltmp!=null){
+			if (urltmp != null) {
 				conn.disconnect();
-				conn=conn.getRedirectedConnection(urltmp);
-				forceRedirect=false; // one time or more redirected
+				conn = conn.getRedirectedConnection(urltmp);
+				forceRedirect = false; // one time or more redirected
 			}
-		} while (((urltmp != null) || (urltmp == null) && forceRedirect) && i <= maxRedirections );	
-		if (i > maxRedirections) throw new IOException("too many http redirections while trying to fetch: "+url + " only "+maxRedirections+" are allowed");
+		} while (((urltmp != null) || (urltmp == null) && forceRedirect) && i <= maxRedirections);
+		if (i > maxRedirections)
+			throw new IOException("too many http redirections while trying to fetch: " + url + " only " + maxRedirections + " are allowed");
 		ByteArray daten;
 		if (conn.isOpen()) {
 			daten = conn.readData();
 			conn.disconnect();
-		}
-		else daten=null;
+		} else
+			daten = null;
 		maxRedirections = 5;
 		requestorProperties = null;
-		postData=null;
-		forceRedirect=false;
+		postData = null;
+		forceRedirect = false;
 		return daten;
 	}
 
@@ -145,26 +177,23 @@
 	 * @return true, if the string seems to be already URL encoded (that is, it contains only url-allowd chars), false otherwise
 	 */
 	private static boolean isUrlEncoded(String url) {
-		final String allowed = new String ("-_.~!*'();:@&=+$,/?%#[]");
-		char [] src = ewe.sys.Vm.getStringChars(url);
+		final String allowed = new String("-_.~!*'();:@&=+$,/?%#[]");
+		char[] src = ewe.sys.Vm.getStringChars(url);
 		char c;
-		for (int i = 0; i<src.length; i++){
+		for (int i = 0; i < src.length; i++) {
 			c = src[i];
-			if (       (c >= 'A' && c <= 'Z') 
-					|| (c >= 'a' && c <= 'z') 
-					|| (c >= '0' && c <= '9')
-					|| (allowed.indexOf(c) >= 0)
-			) continue;
-			else return false;
+			if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || (allowed.indexOf(c) >= 0))
+				continue;
+			else
+				return false;
 		}
 		return true;
 	}
+
 	/**
-	 * This method encodes an URL containing special characters
-	 * using the UTF-8 codec in %nn%nn notation<br>
-	 * Note that the encoding for URLs is not generally defined. Usually
-	 * cp1252 or UTF-8 is used. It depends on what the server expects,
-	 * what encoding you must use.
+	 * This method encodes an URL containing special characters using the UTF-8 codec in %nn%nn notation<br>
+	 * Note that the encoding for URLs is not generally defined. Usually cp1252 or UTF-8 is used. It depends on what the server expects, what encoding you must use.
+	 * 
 	 * @param cc
 	 * @return
 	 * @throws IOException
@@ -178,34 +207,36 @@
 		asciicod.decodeText(utf8.data, 0, utf8.length, true, utf8bytes);
 		return encodeURL(utf8bytes.toString(), false);
 	}
-	
+
 	final static String hex = ewe.util.TextEncoder.hex;
+
 	/**
-	 * Encode the URL using %## notation.
-	 * Note: this fixes a bug in ewe.net.URL.encodeURL(): that routine
-	 * assumes all chars to be < 127.
-	 * This method is mainly copied from there
-	 * @param url The unencoded URL.
-	 * @param spaceToPlus true if you wish a space to be encoded as a '+', false to encode it as %20
+	 * Encode the URL using %## notation. Note: this fixes a bug in ewe.net.URL.encodeURL(): that routine assumes all chars to be < 127. This method is mainly copied from there
+	 * 
+	 * @param url
+	 *            The unencoded URL.
+	 * @param spaceToPlus
+	 *            true if you wish a space to be encoded as a '+', false to encode it as %20
 	 * @return The encoded URL.
 	 */
-	//===================================================================
-	private static String encodeURL(String url, boolean spaceToPlus)
-	//===================================================================
+	// ===================================================================
+	public static String encodeURL(String url, boolean spaceToPlus)
+	// ===================================================================
 	{
-		char [] what = ewe.sys.Vm.getStringChars(url);
+		char[] what = ewe.sys.Vm.getStringChars(url);
 		int max = what.length;
-		char [] dest = new char[max+max/2];
+		char[] dest = new char[max + max / 2];
 		char d = 0;
-		for (int i = 0; i<max; i++){
-			if (d >= dest.length-2) {
-				char [] n = new char[dest.length+dest.length/2+3];
-				ewe.sys.Vm.copyArray(dest,0,n,0,d);
+		for (int i = 0; i < max; i++) {
+			if (d >= dest.length - 2) {
+				char[] n = new char[dest.length + dest.length / 2 + 3];
+				ewe.sys.Vm.copyArray(dest, 0, n, 0, d);
 				dest = n;
 			}
 			char c = what[i];
-			if (spaceToPlus && c == ' ') c = '+';
-			else if (c <= ' ' || c >= 127 || c == '+' || c == '&' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}'){
+			if (spaceToPlus && c == ' ')
+				c = '+';
+			else if (c <= ' ' || c >= 127 || c == '+' || c == '&' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}') {
 				dest[d++] = '%';
 				dest[d++] = hex.charAt((c >> 4) & 0xf);
 				dest[d++] = hex.charAt(c & 0xf);
@@ -213,7 +244,7 @@
 			}
 			dest[d++] = c;
 		}
-		return new String(dest,0,d);
+		return new String(dest, 0, d);
 	}
 
 }
\ No newline at end of file

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-02 11:30:16 UTC (rev 2994)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-06 15:11:39 UTC (rev 2995)
@@ -109,11 +109,11 @@
 	/**
 	 * This is the pattern for inlined smilies
 	 */
-	private static final String 		string = "<img src=\"/images/icons/";
+	private static final String string = "<img src=\"/images/icons/";
 
 	private static int ERR_LOGIN = -10;
 	private static Preferences pref;
-	private Profile profile;
+	private final Profile profile;
 
 	private static String cookie = "";
 	private static double minDistance = 0;
@@ -121,8 +121,8 @@
 	private static String direction = "";
 	private static String[] directions;
 
-	private CacheDB cacheDB;
-	private Vector cachesToLoad = new Vector();
+	private final CacheDB cacheDB;
+	private final Vector cachesToLoad = new Vector();
 	private InfoBox infB;
 	private static SpiderProperties p = null;
 	// following filled at doit
@@ -136,13 +136,23 @@
 	private byte restrictedCacheType = 0;
 	private String fileName = "";
 	private String userToken = "";
+	private String sessionToken = "";
 
 	private static String propFirstPage;
 	private static String propFirstPage2;
 	private static String propFirstPageFinds;
 	private static String gotoNextPage = "ctl00$ContentBody$pgrTop$ctl08";
-	private static String gotoNextBlock = "ctl00$ContentBody$pgrTop$ctl06";  // change to the block (10pages) of the wanted page
-	private static String gotoPage = "ctl00$ContentBody$pgrTop$lbGoToPage_"; // add pagenumber
+	private static String gotoNextBlock = "ctl00$ContentBody$pgrTop$ctl06"; // change
+																			// to
+																			// the
+																			// block
+																			// (10pages)
+																			// of
+																			// the
+																			// wanted
+																			// page
+	private static String gotoPage = "ctl00$ContentBody$pgrTop$lbGoToPage_"; // add
+																				// pagenumber
 	private static String propMaxDistance;
 	private static String propShowOnlyFound;
 	private static Regex RexPropListBlock;
@@ -202,15 +212,17 @@
 	public void doIt(boolean _spiderAllFinds) {
 		cachesToLoad.clear();
 		spiderAllFinds = _spiderAllFinds;
-		origin = pref.getCurCentrePt(); // No need to copy curCentrePt as it is only read and not written
+		origin = pref.getCurCentrePt(); // No need to copy curCentrePt as it is
+										// only read and not written
 		if (!spiderAllFinds && !origin.isValid()) {
-			(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5509,"Coordinates for centre must be set"), FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5509, "Coordinates for centre must be set"), FormBase.OKB)).execute();
 			return;
 		}
 
-		// Reset states for all caches when spidering (http://tinyurl.com/dzjh7p)
+		// Reset states for all caches when spidering
+		// (http://tinyurl.com/dzjh7p)
 		for (int i = 0; i < cacheDB.size(); i++) {
-			CacheHolder ch = cacheDB.get(i);
+			final CacheHolder ch = cacheDB.get(i);
 			if (ch.mainCache == null)
 				ch.initStates(false);
 		}
@@ -221,30 +233,23 @@
 			infB = new InfoBox("Status", MyLocale.getMsg(5502, "Fetching first page..."));
 			infB.exec();
 
-			pref.log( "ListPages Properties : " + Preferences.NEWLINE
-					+ "minDistance          : " + minDistance + Preferences.NEWLINE
-					+ "maxDistance          : " + maxDistance + Preferences.NEWLINE
-					+ "directions           : " + direction + Preferences.NEWLINE
-					+ "maxNew               : " + pref.maxSpiderNumber + Preferences.NEWLINE
-					+ "maxUpdate            : " + maxUpdate + Preferences.NEWLINE
-					+ "with Founds          : " + (doNotgetFound ? "no" : "yes") + Preferences.NEWLINE 
-					+ "alias is premium memb: "	+ (!pref.isPremium ? "no" : "yes") + Preferences.NEWLINE
-					+ "Update if new Log    : " + (pref.checkLog ? "yes" : "no") + Preferences.NEWLINE
-					+ "Update if TB changed : " + (pref.checkTBs ? "yes" : "no") + Preferences.NEWLINE
-					+ "Update if DTS changed: " + (pref.checkDTS ? "yes" : "no") + Preferences.NEWLINE
-					, null);
+			pref.log("ListPages Properties : " + Preferences.NEWLINE + "minDistance          : " + minDistance + Preferences.NEWLINE + "maxDistance          : " + maxDistance + Preferences.NEWLINE + "directions           : " + direction
+					+ Preferences.NEWLINE + "maxNew               : " + pref.maxSpiderNumber + Preferences.NEWLINE + "maxUpdate            : " + maxUpdate + Preferences.NEWLINE + "with Founds          : " + (doNotgetFound ? "no" : "yes")
+					+ Preferences.NEWLINE + "alias is premium memb: " + (!pref.isPremium ? "no" : "yes") + Preferences.NEWLINE + "Update if new Log    : " + (pref.checkLog ? "yes" : "no") + Preferences.NEWLINE + "Update if TB changed : "
+					+ (pref.checkTBs ? "yes" : "no") + Preferences.NEWLINE + "Update if DTS changed: " + (pref.checkDTS ? "yes" : "no") + Preferences.NEWLINE, null);
 
 			Hashtable cachesToUpdate = new Hashtable(cacheDB.size());
 
-			cachesToUpdate = fillDownloadLists(pref.maxSpiderNumber, maxUpdate,
-					maxDistance, minDistance, directions, cachesToUpdate);
-			if (cachesToUpdate == null) { cachesToUpdate = new Hashtable(); };
+			cachesToUpdate = fillDownloadLists(pref.maxSpiderNumber, maxUpdate, maxDistance, minDistance, directions, cachesToUpdate);
+			if (cachesToUpdate == null) {
+				cachesToUpdate = new Hashtable();
+			}
+			;
 			if (!infB.isClosed) {
-				infB.setInfo(MyLocale.getMsg(5511, "Found ")
-						+ cachesToLoad.size()
-						+ MyLocale.getMsg(5512, " caches"));
+				infB.setInfo(MyLocale.getMsg(5511, "Found ") + cachesToLoad.size() + MyLocale.getMsg(5512, " caches"));
 			}
-			// continue to update index to changed cache.xml things (size,terrain,difficulty,...?) 
+			// continue to update index to changed cache.xml things
+			// (size,terrain,difficulty,...?)
 
 			// =======
 			// Now ready to spider each cache in the lists
@@ -256,7 +261,7 @@
 					cachesToUpdate.clear();
 					break;
 				case Preferences.ASK:
-					MessageBox mBox = new MessageBox(MyLocale.getMsg(5517,"Spider Updates?"), cachesToUpdate.size() + MyLocale.getMsg(5518," caches in database need an update. Update now?") , FormBase.IDYES |FormBase.IDNO);
+					final MessageBox mBox = new MessageBox(MyLocale.getMsg(5517, "Spider Updates?"), cachesToUpdate.size() + MyLocale.getMsg(5518, " caches in database need an update. Update now?"), FormBase.IDYES | FormBase.IDNO);
 					if (mBox.execute() != FormBase.IDOK) {
 						cachesToUpdate.clear();
 					}
@@ -265,17 +270,10 @@
 			}
 
 			int spiderErrors = 0;
-			int totalCachesToLoad = cachesToLoad.size() + cachesToUpdate.size();
-			boolean loadAllLogs = (pref.maxLogsToSpider > 5) || spiderAllFinds;
-			pref.log("Download properties : " + Preferences.NEWLINE
-					+ "maxLogs: "
-					+ (loadAllLogs ? "completepage " : "shortpage") + "nr.:"
-					+ pref.maxLogsToSpider + Preferences.NEWLINE
-					+ "with pictures     : "
-					+ (!pref.downloadPics ? "no" : "yes") + Preferences.NEWLINE
-					+ "with tb           : "
-					+ (!pref.downloadTBs ? "no" : "yes") + Preferences.NEWLINE,
-					null);
+			final int totalCachesToLoad = cachesToLoad.size() + cachesToUpdate.size();
+			final boolean loadAllLogs = (pref.maxLogsToSpider > 5) || spiderAllFinds;
+			pref.log("Download properties : " + Preferences.NEWLINE + "maxLogs: " + (loadAllLogs ? "completepage " : "shortpage") + "nr.:" + pref.maxLogsToSpider + Preferences.NEWLINE + "with pictures     : " + (!pref.downloadPics ? "no" : "yes")
+					+ Preferences.NEWLINE + "with tb           : " + (!pref.downloadTBs ? "no" : "yes") + Preferences.NEWLINE, null);
 
 			if (Global.mainTab.statBar != null)
 				Global.mainTab.statBar.updateDisplay("");
@@ -286,14 +284,11 @@
 			}
 
 			if (spiderErrors > 0) {
-				new MessageBox(MyLocale.getMsg(5500, "Error"),
-						spiderErrors + MyLocale.getMsg(5516," cache descriptions%0acould not be loaded."),
-						FormBase.DEFOKB).execute();
+				new MessageBox(MyLocale.getMsg(5500, "Error"), spiderErrors + MyLocale.getMsg(5516, " cache descriptions%0acould not be loaded."), FormBase.DEFOKB).execute();
 			}
 			if (maxNumberAbort) {
-				new MessageBox(MyLocale.getMsg(5519, "Information"),
-						MyLocale.getMsg(5520,"Only the given maximum of caches were loaded.%0aRepeat spidering later to load more caches.%0aNo already existing caches were updated."),
-						FormBase.DEFOKB).execute();
+				new MessageBox(MyLocale.getMsg(5519, "Information"), MyLocale.getMsg(5520, "Only the given maximum of caches were loaded.%0aRepeat spidering later to load more caches.%0aNo already existing caches were updated."), FormBase.DEFOKB)
+						.execute();
 			}
 			Global.getProfile().restoreFilter();
 			Global.getProfile().saveIndex(Global.getPref(), true);
@@ -308,62 +303,65 @@
 	public void doItAlongARoute() {
 		Area sq;
 		Vector points = null;
-		Navigate nav=Global.mainTab.nav;
-		MovingMap mm=Global.mainTab.mm;
+		final Navigate nav = Global.mainTab.nav;
+		MovingMap mm = Global.mainTab.mm;
 
 		if (!doDownloadGui(1))
 			return;
 
 		CWPoint startPos = pref.getCurCentrePt();
 		if (!fileName.equals("")) {
-			RouteImporter ri = new RouteImporter(fileName);
-			points = ri.doIt();			
+			final RouteImporter ri = new RouteImporter(fileName);
+			points = ri.doIt();
 			if (points.size() > 0) {
-				if (nav!=null) {
-					if (mm==null) {
+				if (nav != null) {
+					if (mm == null) {
 						Global.mainTab.mm = new MovingMap(nav, profile.cacheDB);
-						mm=Global.mainTab.mm;
+						mm = Global.mainTab.mm;
 						nav.setMovingMap(Global.mainTab.mm);
 					}
 					if (nav.curTrack == null) {
-						nav.curTrack=new Track(nav.trackColor);
+						nav.curTrack = new Track(nav.trackColor);
 						mm.addTrack(nav.curTrack);
 					}
 					for (int i = 0; i < points.size(); i++) {
 						try {
 							nav.curTrack.add((TrackPoint) points.get(i));
-						} catch (IndexOutOfBoundsException e) { // track full -> create a new one
-							nav.curTrack=new Track(nav.trackColor);
+						} catch (final IndexOutOfBoundsException e) { // track
+																		// full
+																		// ->
+																		// create
+																		// a new
+																		// one
+							nav.curTrack = new Track(nav.trackColor);
 							nav.curTrack.add((TrackPoint) points.get(i));
-							if (mm != null) mm.addTrack(nav.curTrack);
+							if (mm != null)
+								mm.addTrack(nav.curTrack);
 						}
 
 					}
 				}
-				TrackPoint tp = (TrackPoint) points.get(0);
+				final TrackPoint tp = (TrackPoint) points.get(0);
 				startPos = new CWPoint(tp.latDec, tp.lonDec);
 			} else
 				startPos = null;
 		}
 
-		int answer = new MessageBox(MyLocale.getMsg(651, "Question"),
-				MyLocale.getMsg(652,"Update caches with all details?"),
-				MessageBox.YESB | MessageBox.NOB | MessageBox.CANCELB).execute();
-		boolean complete = answer == MessageBox.YESB;
-		if ( answer == MessageBox.IDCANCEL) {
-			if (startPos != null) pref.setCurCentrePt(startPos);
+		final int answer = new MessageBox(MyLocale.getMsg(651, "Question"), MyLocale.getMsg(652, "Update caches with all details?"), MessageBox.YESB | MessageBox.NOB | MessageBox.CANCELB).execute();
+		final boolean complete = answer == MessageBox.YESB;
+		if (answer == MessageBox.IDCANCEL) {
+			if (startPos != null)
+				pref.setCurCentrePt(startPos);
 			return;
 		}
 
 		if (startPos != null && !startPos.isValid()) {
-			(new MessageBox(MyLocale.getMsg(5500, "Error"),
-					MyLocale.getMsg(5509, "Coordinates for centre must be set"), FormBase.OKB))
-					.execute();
+			(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5509, "Coordinates for centre must be set"), FormBase.OKB)).execute();
 			return; //
 		}
 
 		Vm.showWait(true);
-		infB = new InfoBox("Status", MyLocale.getMsg(5502,"Fetching pages..."));
+		infB = new InfoBox("Status", MyLocale.getMsg(5502, "Fetching pages..."));
 		infB.exec();
 
 		if (!loggedIn || pref.forceLogin) {
@@ -374,15 +372,14 @@
 		// Reset states for all caches when spidering
 		// (http://tinyurl.com/dzjh7p)
 		for (int i = 0; i < cacheDB.size(); i++) {
-			CacheHolder ch = cacheDB.get(i);
+			final CacheHolder ch = cacheDB.get(i);
 			if (ch.mainCache == null)
 				ch.initStates(false);
 		}
 
 		double lateralDistance = maxDistance; // Seitenabstand in km
 		if (pref.metricSystem == Metrics.IMPERIAL) {
-			lateralDistance = Metrics.convertUnit(maxDistance, Metrics.MILES,
-					Metrics.KILOMETER);
+			lateralDistance = Metrics.convertUnit(maxDistance, Metrics.MILES, Metrics.KILOMETER);
 		}
 		cachesToLoad.clear();
 
@@ -394,9 +391,8 @@
 				nextPos = nextRoutePoint(startPos, lateralDistance);
 			} else {
 				double tmpDistance = 0;
-				while (tmpDistance < lateralDistance
-						&& pointsIndex < points.size()) {
-					TrackPoint tp = (TrackPoint) points.get(pointsIndex);
+				while (tmpDistance < lateralDistance && pointsIndex < points.size()) {
+					final TrackPoint tp = (TrackPoint) points.get(pointsIndex);
 					nextPos = new CWPoint(tp.latDec, tp.lonDec);
 					tmpDistance = nextPos.getDistance(startPos);
 					pointsIndex++;
@@ -405,33 +401,24 @@
 					nextPos = null;
 				else {
 					if (Global.mainTab.statBar != null)
-						Global.mainTab.statBar.updateDisplay("GC pages: "
-								+ page_number + " Caches added to CW: "
-								+ num_added + " at "
-								+ pointsIndex+"("+points.size()+")"
-								+ nextPos
-								);
+						Global.mainTab.statBar.updateDisplay("GC pages: " + page_number + " Caches added to CW: " + num_added + " at " + pointsIndex + "(" + points.size() + ")" + nextPos);
 				}
 			}
 
-
 			if (nextPos != null) {
 				sq = getSquare(startPos, lateralDistance);
-				getCaches(sq.topleft.latDec, sq.topleft.lonDec,
-						sq.bottomright.latDec, sq.bottomright.lonDec, complete);
+				getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.bottomright.latDec, sq.bottomright.lonDec, complete);
 				// pref.log("next WP = " + startPos.toString(), null);
 
-				double degrees = startPos.getBearing(nextPos);
-				double distanceToNextCache = startPos.getDistance(nextPos);
-				double anzCheckPoints = distanceToNextCache / lateralDistance;
+				final double degrees = startPos.getBearing(nextPos);
+				final double distanceToNextCache = startPos.getDistance(nextPos);
+				final double anzCheckPoints = distanceToNextCache / lateralDistance;
 				for (int i = 1; i < anzCheckPoints; i++) {
-					CWPoint nextCheckPoint = startPos.project(degrees,
-							lateralDistance);
+					final CWPoint nextCheckPoint = startPos.project(degrees, lateralDistance);
 					startPos = nextCheckPoint;
 					origin = nextCheckPoint;
 					sq = getSquare(origin, lateralDistance);
-					getCaches(sq.topleft.latDec, sq.topleft.lonDec,
-							sq.bottomright.latDec, sq.bottomright.lonDec, complete);
+					getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.bottomright.latDec, sq.bottomright.lonDec, complete);
 					// pref.log("next CP = " + origin.toString(), null);
 					if (infB.isClosed) {
 						break;
@@ -444,42 +431,36 @@
 			}
 		}
 		sq = getSquare(startPos, lateralDistance);
-		getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.bottomright.latDec,
-				sq.bottomright.lonDec, complete);
+		getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.bottomright.latDec, sq.bottomright.lonDec, complete);
 		// pref.log("last WP = " + startPos.toString(), null);
 		if (infB.isClosed) {
 			Vm.showWait(false);
 			return;
 		} // or ask for download of intermediate result
-		
+
 		int spiderErrors = 0;
 		if (complete) {
 			for (int i = 0; i < cachesToLoad.size(); i++) {
 				String wpt = (String) cachesToLoad.get(i);
-				boolean is_found = wpt.indexOf("found") != -1;
+				final boolean is_found = wpt.indexOf("found") != -1;
 				if (is_found)
 					wpt = wpt.substring(0, wpt.indexOf("found"));
-				int j = cacheDB.getIndex(wpt);
+				final int j = cacheDB.getIndex(wpt);
 				if (j != -1)
 					cacheDB.removeElementAt(j);
 			}
 			spiderErrors = downloadCaches(cachesToLoad, spiderErrors, cachesToLoad.size(), true);
 
+		} else {
 		}
-		else {
-		}
 
 		infB.close(0);
 		Vm.showWait(false);
 		if (spiderErrors > 0) {
-			new MessageBox(MyLocale.getMsg(5500, "Error"),
-					spiderErrors + MyLocale.getMsg(5516," cache descriptions%0acould not be loaded."),
-					FormBase.DEFOKB).execute();
+			new MessageBox(MyLocale.getMsg(5500, "Error"), spiderErrors + MyLocale.getMsg(5516, " cache descriptions%0acould not be loaded."), FormBase.DEFOKB).execute();
 		}
 		if (maxNumberAbort) {
-			new MessageBox(MyLocale.getMsg(5519,"Information"),
-					MyLocale.getMsg(5520,"Only the given maximum of caches were loaded.\nRepeat spidering later to load more caches.\nNo already existing caches were updated."),
-					FormBase.DEFOKB).execute();
+			new MessageBox(MyLocale.getMsg(5519, "Information"), MyLocale.getMsg(5520, "Only the given maximum of caches were loaded.\nRepeat spidering later to load more caches.\nNo already existing caches were updated."), FormBase.DEFOKB).execute();
 		}
 		Global.getProfile().restoreFilter();
 		Global.getProfile().saveIndex(Global.getPref(), true);
@@ -494,8 +475,8 @@
 		for (int i = 0; i < cacheDB.size(); i++) {
 			ch = cacheDB.get(i);
 			if (ch.is_Checked && ch.pos.isValid()) {
-				CWPoint tmpPos = ch.pos;
-				double tmpDistance = tmpPos.getDistance(startPos);
+				final CWPoint tmpPos = ch.pos;
+				final double tmpDistance = tmpPos.getDistance(startPos);
 				if (nextDistance == 0) {
 					// Startwert
 					index = i;
@@ -523,12 +504,12 @@
 	}
 
 	private Area getSquare(CWPoint centre, double halfSideLengthKm) {
-		int north = 0;
-		int east = 1;
-		int south = 2;
-		int west = 3;
-		double halfSideLength = halfSideLengthKm * 1000.0; // in meters
-		Area ret = new Area();
+		final int north = 0;
+		final int east = 1;
+		final int south = 2;
+		final int west = 3;
+		final double halfSideLength = halfSideLengthKm * 1000.0; // in meters
+		final Area ret = new Area();
 		ret.topleft.latDec = centre.latDec;
 		ret.topleft.lonDec = centre.lonDec;
 		ret.topleft.shift(halfSideLength, north);
@@ -542,13 +523,11 @@
 		return ret;
 	}
 
-	public void doItQuickFillFromMapList() {
+	public void doItQuickFillFromOldMapList() {
 
-		CWPoint origin = pref.getCurCentrePt();
+		final CWPoint origin = pref.getCurCentrePt();
 		if (!origin.isValid()) {
-			(new MessageBox(MyLocale.getMsg(5500, "Error"),
-					MyLocale.getMsg(5509, "Coordinates for centre must be set"),
-					FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5509, "Coordinates for centre must be set"), FormBase.OKB)).execute();
 			return; //
 		}
 		if (!doDownloadGui(2))
@@ -561,15 +540,15 @@
 		// Reset states for all caches when spidering
 		// (http://tinyurl.com/dzjh7p)
 		for (int i = 0; i < cacheDB.size(); i++) {
-			CacheHolder ch = cacheDB.get(i);
+			final CacheHolder ch = cacheDB.get(i);
 			if (ch.mainCache == null)
 				ch.initStates(false);
 		}
 
-		double halfSideLength = maxDistance; // halbe Seitenl?nge eines Quadrats ums Zentrum in km
+		double halfSideLength = maxDistance; // halbe Seitenl?nge eines Quadrats
+												// ums Zentrum in km
 		if (pref.metricSystem == Metrics.IMPERIAL) {
-			halfSideLength = Metrics.convertUnit(maxDistance, Metrics.MILES,
-					Metrics.KILOMETER);
+			halfSideLength = Metrics.convertUnit(maxDistance, Metrics.MILES, Metrics.KILOMETER);
 		}
 
 		if (!loggedIn || pref.forceLogin) {
@@ -580,9 +559,8 @@
 		page_number = 0;
 		num_added = 0;
 
-		Area sq = getSquare(origin, halfSideLength);
-		getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.bottomright.latDec,
-				sq.bottomright.lonDec, false);
+		final Area sq = getSquare(origin, halfSideLength);
+		getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.bottomright.latDec, sq.bottomright.lonDec, false);
 
 		if (!infB.isClosed)
 			infB.close(0);
@@ -593,26 +571,24 @@
 
 	}
 
-	private void getCaches(double north, double west, double south,
-			double east, boolean setCachesToLoad) {
+	private void getCaches(double north, double west, double south, double east, boolean setCachesToLoad) {
 		if (infB.isClosed)
 			return;
-		double lm = (north + south) / 2.0;
-		CWPoint middle = new CWPoint(lm, (west + east) / 2.0);
-		CWPoint rm = new CWPoint(lm, east);
-		double len = middle.getDistance(rm) * 2.0;
+		final double lm = (north + south) / 2.0;
+		final CWPoint middle = new CWPoint(lm, (west + east) / 2.0);
+		final CWPoint rm = new CWPoint(lm, east);
+		final double len = middle.getDistance(rm) * 2.0;
 		page_number++;
-		String listPage = getMapListPage(middle, north, west, south, east);
-		int i = listPage.indexOf("\"count\\\":"); // \"count\":
-		if (i==-1) {
-			pref.log("[getCaches:getMapListPage]got nothing!"+listPage,null);
+		final String listPage = getMapListPage(middle, north, west, south, east);
+		final int i = listPage.indexOf("\"count\\\":"); // \"count\":
+		if (i == -1) {
+			pref.log("[getCaches:getMapListPage]got nothing!" + listPage, null);
 			return;
 		}
 		pref.log("" + north + " " + west + " " + south + " " + east + " " + listPage.substring(i) + "\n len=" + len);
-		if ((listPage.indexOf("\"count\\\":501") > -1)
-		||  (listPage.indexOf("\"count\\\":0") > -1 && len > 30)) {
-			double northsouthmiddle = (north + south) / 2.0;
-			double westeastmiddle = (west + east) / 2.0;
+		if ((listPage.indexOf("\"count\\\":501") > -1) || (listPage.indexOf("\"count\\\":0") > -1 && len > 30)) {
+			final double northsouthmiddle = (north + south) / 2.0;
+			final double westeastmiddle = (west + east) / 2.0;
 			getCaches(north, west, northsouthmiddle, westeastmiddle, setCachesToLoad);
 			getCaches(north, westeastmiddle, northsouthmiddle, east, setCachesToLoad);
 			getCaches(northsouthmiddle, west, south, westeastmiddle, setCachesToLoad);
@@ -623,48 +599,52 @@
 	}
 
 	private void addCaches(String listPage, boolean setCachesToLoad) {
-		String[] caches = mString.split(listPage, '{');
-		//int posId=0;        //id egal
-		//int posName=1;      //nn
-		
-		//positions decreased by 2, because we cut away the name to prevent parsing errors
-		int posWP=0;        //gc 
-		int posLat=1;       //lat
-		int posLon=2;       //lon
-		int posType=3;      //ctid
-		int posFound=4;     //f
-		int posOwn=5;       //o
-		int posAvailable=6; //ia
+		final String[] caches = mString.split(listPage, '{');
+		// int posId=0; //id egal
+		// int posName=1; //nn
+
+		// positions decreased by 2, because we cut away the name to prevent
+		// parsing errors
+		final int posWP = 0; // gc
+		final int posLat = 1; // lat
+		final int posLon = 2; // lon
+		final int posType = 3; // ctid
+		final int posFound = 4; // f
+		final int posOwn = 5; // o
+		final int posAvailable = 6; // ia
 		// ignoring first 3 lines
 		for (int i = 4; i < caches.length; i++) {
-			if (infB.isClosed) return;
-			
-			//cut away name to prevent parsing errors			
-			int WpIndex = caches[i].indexOf("\"gc\\\"");
-			String elements[] = mString.split(caches[i].substring(WpIndex), ',');
-			
-			boolean found = (elements[posFound].indexOf("true") > -1 ? true : false);
-			if (found && doNotgetFound)	continue;
-			
-			byte cacheType = CacheType.gcSpider2CwType(mString.split(elements[posType], ':')[1]);
+			if (infB.isClosed)
+				return;
+
+			// cut away name to prevent parsing errors
+			final int WpIndex = caches[i].indexOf("\"gc\\\"");
+			final String elements[] = mString.split(caches[i].substring(WpIndex), ',');
+
+			final boolean found = (elements[posFound].indexOf("true") > -1 ? true : false);
+			if (found && doNotgetFound)
+				continue;
+
+			final byte cacheType = CacheType.gcSpider2CwType(mString.split(elements[posType], ':')[1]);
 			if (restrictedCacheType != CacheType.CW_TYPE_ERROR) {
-				if (restrictedCacheType != cacheType) continue;
+				if (restrictedCacheType != cacheType)
+					continue;
 			}
 
 			String wp = mString.split(elements[posWP], '\"')[3];
-			wp=wp.substring(0, wp.length()-1);
+			wp = wp.substring(0, wp.length() - 1);
 			CacheHolder ch = cacheDB.get(wp);
 			if (ch == null) {
 
-				String lat = mString.split(elements[posLat], ':')[1];
-				String lon = mString.split(elements[posLon], ':')[1];
-				String own = mString.split(elements[posOwn], ':')[1];
-				boolean available = (elements[posAvailable].indexOf("true") > -1 ? true : false);
-				
-				int NameIndex = caches[i].indexOf("\"nn\\\"");
-				String cacheName = caches[i].substring (NameIndex + 8, WpIndex - 4 );
-				cacheName = STRreplace.replace(cacheName, "\\\"", "\"" );
+				final String lat = mString.split(elements[posLat], ':')[1];
+				final String lon = mString.split(elements[posLon], ':')[1];
+				final String own = mString.split(elements[posOwn], ':')[1];
+				final boolean available = (elements[posAvailable].indexOf("true") > -1 ? true : false);
 
+				final int NameIndex = caches[i].indexOf("\"nn\\\"");
+				String cacheName = caches[i].substring(NameIndex + 8, WpIndex - 4);
+				cacheName = STRreplace.replace(cacheName, "\\\"", "\"");
+
 				ch = new CacheHolder();
 				ch.setWayPoint(wp);
 				ch.setLatLon(lat + " " + lon);
@@ -684,13 +664,11 @@
 				if (setCachesToLoad) {
 					cachesToLoad.add(wp + "found");
 				} else {
-					ch.getCacheDetails(false).URL="http://www.geocaching.com/seek/cache_details.aspx?wp="+wp;
+					ch.getCacheDetails(false).URL = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + wp;
 					ch.save();
 				}
 				if (Global.mainTab.statBar != null)
-					Global.mainTab.statBar.updateDisplay("GC pages: "
-							+ page_number + " Caches added to CW: "
-							+ num_added);
+					Global.mainTab.statBar.updateDisplay("GC pages: " + page_number + " Caches added to CW: " + num_added);
 			} else {
 			}
 		}
@@ -701,13 +679,8 @@
 		OCXMLImporterScreen options;
 		direction = "";
 		if (menu == 0 && spiderAllFinds) {
-			options = new OCXMLImporterScreen(MyLocale.getMsg(217,
-					"Spider all finds from geocaching.com"),
-					OCXMLImporterScreen.ISGC | OCXMLImporterScreen.MAXNUMBER
-							| OCXMLImporterScreen.MAXUPDATE
-							| OCXMLImporterScreen.IMAGES
-							| OCXMLImporterScreen.TRAVELBUGS
-							| OCXMLImporterScreen.MAXLOGS);
+			options = new OCXMLImporterScreen(MyLocale.getMsg(217, "Spider all finds from geocaching.com"), OCXMLImporterScreen.ISGC | OCXMLImporterScreen.MAXNUMBER | OCXMLImporterScreen.MAXUPDATE | OCXMLImporterScreen.IMAGES
+					| OCXMLImporterScreen.TRAVELBUGS | OCXMLImporterScreen.MAXLOGS);
 			// setting defaults for input
 			options.maxNumberUpdates.setText("0");
 			// doing the input
@@ -718,16 +691,8 @@
 			maxDistance = 1.0;
 			minDistance = 0.0;
 		} else if (menu == 0) {
-			options = new OCXMLImporterScreen(MyLocale.getMsg(131,
-					"Download from geocaching.com"), OCXMLImporterScreen.ISGC
-					| OCXMLImporterScreen.MAXNUMBER
-					| OCXMLImporterScreen.MAXUPDATE
-					| OCXMLImporterScreen.MINDIST | OCXMLImporterScreen.DIST
-					| OCXMLImporterScreen.DIRECTION
-					| OCXMLImporterScreen.INCLUDEFOUND
-					| OCXMLImporterScreen.IMAGES
-					| OCXMLImporterScreen.TRAVELBUGS
-					| OCXMLImporterScreen.MAXLOGS | OCXMLImporterScreen.TYPE);
+			options = new OCXMLImporterScreen(MyLocale.getMsg(131, "Download from geocaching.com"), OCXMLImporterScreen.ISGC | OCXMLImporterScreen.MAXNUMBER | OCXMLImporterScreen.MAXUPDATE | OCXMLImporterScreen.MINDIST | OCXMLImporterScreen.DIST
+					| OCXMLImporterScreen.DIRECTION | OCXMLImporterScreen.INCLUDEFOUND | OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.TRAVELBUGS | OCXMLImporterScreen.MAXLOGS | OCXMLImporterScreen.TYPE);
 			// setting defaults for input
 			if (pref.spiderUpdates == Preferences.NO) {
 				options.maxNumberUpdates.setText("0");
@@ -738,27 +703,20 @@
 			}
 			// setting default values for options not used (if necessary)
 
-			String minDist = options.minDistanceInput.getText();
+			final String minDist = options.minDistanceInput.getText();
 			minDistance = Common.parseDouble(minDist);
 			profile.setMinDistGC(Double.toString(minDistance).replace(',', '.'));
 
 			direction = options.directionInput.getText();
 			directions = mString.split(direction, '-');
-			
+
 			doNotgetFound = options.foundCheckBox.getState();
 			profile.setDirectionGC(direction);
 
 		} else if (menu == 1) { // menu = 1 input values for get Caches along a
 								// route
-			options = new OCXMLImporterScreen(MyLocale.getMsg(137,
-					"Download along a Route from geocaching.com"),
-					OCXMLImporterScreen.ISGC | OCXMLImporterScreen.DIST
-							| OCXMLImporterScreen.INCLUDEFOUND
-							| OCXMLImporterScreen.TRAVELBUGS
-							| OCXMLImporterScreen.IMAGES
-							| OCXMLImporterScreen.MAXLOGS
-							| OCXMLImporterScreen.FILENAME
-							| OCXMLImporterScreen.TYPE);
+			options = new OCXMLImporterScreen(MyLocale.getMsg(137, "Download along a Route from geocaching.com"), OCXMLImporterScreen.ISGC | OCXMLImporterScreen.DIST | OCXMLImporterScreen.INCLUDEFOUND | OCXMLImporterScreen.TRAVELBUGS
+					| OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.MAXLOGS | OCXMLImporterScreen.FILENAME | OCXMLImporterScreen.TYPE);
 			// setting defaults for input
 			// doing the input
 			if (options.execute() == FormBase.IDCANCEL) {
@@ -770,11 +728,7 @@
 			maxUpdate = 0;
 			fileName = options.fileName;
 		} else { // if (menu == 2) {
-			options = new OCXMLImporterScreen(MyLocale.getMsg(138,
-					"Qick Import"), OCXMLImporterScreen.ISGC
-					| OCXMLImporterScreen.DIST
-					| OCXMLImporterScreen.INCLUDEFOUND
-					| OCXMLImporterScreen.TYPE);
+			options = new OCXMLImporterScreen(MyLocale.getMsg(138, "Qick Import"), OCXMLImporterScreen.ISGC | OCXMLImporterScreen.DIST | OCXMLImporterScreen.INCLUDEFOUND | OCXMLImporterScreen.TYPE);
 			// setting defaults for input doing the input
 			if (options.execute() == FormBase.IDCANCEL) {
 				return false;
@@ -785,7 +739,7 @@
 		if (menu == 0) {
 
 			int maxNew = -1;
-			String maxNumberString = options.maxNumberInput.getText();
+			final String maxNumberString = options.maxNumberInput.getText();
 			if (maxNumberString.length() != 0) {
 				maxNew = Common.parseInt(maxNumberString);
 			}
@@ -798,7 +752,7 @@
 			}
 
 			maxUpdate = -1;
-			String maxUpdateString = options.maxNumberUpdates.getText();
+			final String maxUpdateString = options.maxNumberUpdates.getText();
 			if (maxUpdateString.length() != 0) {
 				maxUpdate = Common.parseInt(maxUpdateString);
 			}
@@ -809,10 +763,13 @@
 		// options for all
 
 		if (options.maxDistanceInput != null) {
-			String maxDist = options.maxDistanceInput.getText();
+			final String maxDist = options.maxDistanceInput.getText();
 			maxDistance = Common.parseDouble(maxDist);
-			if (maxDistance == 0) return false;
-			if (maxDistance < 0.5) maxDistance = 0.5; // zur Sicherheit bei "along the route" mindenstens 500 meter Umkreis
+			if (maxDistance == 0)
+				return false;
+			if (maxDistance < 0.5)
+				maxDistance = 0.5; // zur Sicherheit bei "along the route"
+									// mindenstens 500 meter Umkreis
 			profile.setDistGC(Double.toString(maxDistance));
 		}
 
@@ -826,9 +783,7 @@
 
 	}
 
-	private Hashtable fillDownloadLists(int maxNew, int maxUpdate,
-			double toDistance, double fromDistance, String[] directions,
-			Hashtable cExpectedForUpdate) {
+	private Hashtable fillDownloadLists(int maxNew, int maxUpdate, double toDistance, double fromDistance, String[] directions, Hashtable cExpectedForUpdate) {
 		if (!loggedIn || pref.forceLogin) {
 			if (login() != FormBase.IDOK)
 				return null;
@@ -836,18 +791,18 @@
 
 		int numFinds;
 		int startPage = 1;
-		// get pagenumber of page with fromDistance , to skip reading of pages < fromDistance
+		// get pagenumber of page with fromDistance , to skip reading of pages <
+		// fromDistance
 		if (fromDistance > 0) {
 			// distance in miles for URL
 			int fromDistanceInMiles = (int) java.lang.Math.ceil(fromDistance);
 			if (pref.metricSystem != Metrics.IMPERIAL) {
-				fromDistanceInMiles = (int) java.lang.Math.ceil(Metrics
-						.convertUnit(fromDistance, Metrics.KILOMETER,
-								Metrics.MILES));
+				fromDistanceInMiles = (int) java.lang.Math.ceil(Metrics.convertUnit(fromDistance, Metrics.KILOMETER, Metrics.MILES));
 			}
 			// - a mile to be save to get a page with fromDistance
 			getFirstListPage(java.lang.Math.max(fromDistanceInMiles - 1, 1));
-			numFinds = getNumFound(htmlListPage); // Number of caches from gc Listpage
+			numFinds = getNumFound(htmlListPage); // Number of caches from gc
+													// Listpage
 			// calc the number of the startpage
 			startPage = (int) java.lang.Math.ceil(numFinds / 20);
 		}
@@ -855,13 +810,14 @@
 		// max distance in miles for URL, so we can get more than 80km
 		int toDistanceInMiles = (int) java.lang.Math.ceil(toDistance);
 		if (pref.metricSystem != Metrics.IMPERIAL) {
-			toDistanceInMiles = (int) java.lang.Math.ceil(Metrics.convertUnit(
-					toDistance, Metrics.KILOMETER, Metrics.MILES));
+			toDistanceInMiles = (int) java.lang.Math.ceil(Metrics.convertUnit(toDistance, Metrics.KILOMETER, Metrics.MILES));
 		}
-		// add a mile to be save from different distance calculations in CW and at GC
+		// add a mile to be save from different distance calculations in CW and
+		// at GC
 		toDistanceInMiles++;
 		getFirstListPage(toDistanceInMiles);
-		numFinds = getNumFound(htmlListPage); // Number of caches from gc first Listpage
+		numFinds = getNumFound(htmlListPage); // Number of caches from gc first
+												// Listpage
 
 		if (fromDistance > 0) {
 			// skip (most of) the pages with distance < fromDistance
@@ -875,9 +831,7 @@
 		int numFoundInDB = 0; // Number of GC-founds already in this profile
 		if (spiderAllFinds) {
 			numFoundInDB = getFoundInDB();
-			pref.log((spiderAllFinds ? "all Finds (DB/GC)" + numFoundInDB + "/"
-					+ numFinds : "new and update Caches")
-					+ Preferences.NEWLINE, null);
+			pref.log((spiderAllFinds ? "all Finds (DB/GC)" + numFoundInDB + "/" + numFinds : "new and update Caches") + Preferences.NEWLINE, null);
 			maxNew = java.lang.Math.min(numFinds - numFoundInDB, maxNew);
 			if (maxUpdate == 0 && maxNew == 0) {
 				Vm.showWait(false);
@@ -889,40 +843,37 @@
 		if (maxUpdate > 0) {
 			double distanceInKm = toDistance;
 			if (pref.metricSystem == Metrics.IMPERIAL) {
-				distanceInKm = Metrics.convertUnit(toDistance, Metrics.MILES,
-						Metrics.KILOMETER);
+				distanceInKm = Metrics.convertUnit(toDistance, Metrics.MILES, Metrics.KILOMETER);
 			}
 			// expecting all are changed (archived caches remain always)
 			for (int i = 0; i < cacheDB.size(); i++) {
-				CacheHolder ch = cacheDB.get(i);
+				final CacheHolder ch = cacheDB.get(i);
 				if (spiderAllFinds) {
-					if ((ch.getWayPoint().substring(0, 2)
-							.equalsIgnoreCase("GC"))
-							&& !ch.is_black()) {
+					if ((ch.getWayPoint().substring(0, 2).equalsIgnoreCase("GC")) && !ch.is_black()) {
 						cExpectedForUpdate.put(ch.getWayPoint(), ch);
 					}
 				} else {
-					if ((!ch.is_archived())
-							&& (ch.kilom <= distanceInKm)
-							&& !(doNotgetFound && (ch.is_found() || ch
-									.is_owned()))
-							&& (ch.getWayPoint().substring(0, 2)
-									.equalsIgnoreCase("GC"))
-							&& ((restrictedCacheType == CacheType.CW_TYPE_ERROR) || (ch
-									.getType() == restrictedCacheType))
-							&& !ch.is_black()) {
+					if ((!ch.is_archived()) && (ch.kilom <= distanceInKm) && !(doNotgetFound && (ch.is_found() || ch.is_owned())) && (ch.getWayPoint().substring(0, 2).equalsIgnoreCase("GC"))
+							&& ((restrictedCacheType == CacheType.CW_TYPE_ERROR) || (ch.getType() == restrictedCacheType)) && !ch.is_black()) {
 						cExpectedForUpdate.put(ch.getWayPoint(), ch);
 					}
 				}
 			}
 		}
-		int startSize = cExpectedForUpdate.size(); // for save reasons
+		final int startSize = cExpectedForUpdate.size(); // for save reasons
 
-		Hashtable cFoundForUpdate = new Hashtable(cacheDB.size()); // for don't loose the already done work
+		final Hashtable cFoundForUpdate = new Hashtable(cacheDB.size()); // for
+																			// don't
+																			// loose
+																			// the
+																			// already
+																			// done
+																			// work
 		page_number = 1;
 		int found_on_page = 0;
 		try {
-			// Loop pages till maximum distance has been found or no more caches are in the list
+			// Loop pages till maximum distance has been found or no more caches
+			// are in the list
 			while (toDistance > 0) {
 				RexPropListBlock.search(htmlListPage);
 				String tableOfHtmlListPage;
@@ -941,29 +892,28 @@
 					}
 					found_on_page++;
 					if (Global.mainTab.statBar != null)
-						Global.mainTab.statBar.updateDisplay("working "
-								+ page_number + " / " + found_on_page);
-					String CacheDescriptionGC = RexPropLine.stringMatched(1);
-					double[] DistanceAndDirection = getDistanceAndDirection(CacheDescriptionGC);
+						Global.mainTab.statBar.updateDisplay("working " + page_number + " / " + found_on_page);
+					final String CacheDescriptionGC = RexPropLine.stringMatched(1);
+					final double[] DistanceAndDirection = getDistanceAndDirection(CacheDescriptionGC);
 					String chWaypoint = getWP(CacheDescriptionGC);
 					if (DistanceAndDirection[0] <= toDistance) {
-						CacheHolder ch = cacheDB.get(chWaypoint);
+						final CacheHolder ch = cacheDB.get(chWaypoint);
 						if (ch == null) { // not in DB
-							if (DistanceAndDirection[0] >= fromDistance
-									&& directionOK(directions, DistanceAndDirection[1])
-									&& doPMCache(chWaypoint, CacheDescriptionGC)
-									&& cachesToLoad.size() < maxNew) {
-								if (CacheDescriptionGC.indexOf(propFound) != -1) chWaypoint = chWaypoint + "found";
-								if (!cachesToLoad.contains(chWaypoint)) { cachesToLoad.add(chWaypoint);	}
+							if (DistanceAndDirection[0] >= fromDistance && directionOK(directions, DistanceAndDirection[1]) && doPMCache(chWaypoint, CacheDescriptionGC) && cachesToLoad.size() < maxNew) {
+								if (CacheDescriptionGC.indexOf(propFound) != -1)
+									chWaypoint = chWaypoint + "found";
+								if (!cachesToLoad.contains(chWaypoint)) {
+									cachesToLoad.add(chWaypoint);
+								}
 							} else {
-								// pref.log("no load of (Premium Cache/other direction/short Distance ?) " + chWaypoint);
+								// pref.log("no load of (Premium Cache/other direction/short Distance ?) "
+								// + chWaypoint);
 								cExpectedForUpdate.remove(chWaypoint);
 							}
 						} else {
 							if (maxUpdate > 0) { // regardless of fromDistance
 								if (!ch.is_black()) {
-									if (doPMCache(chWaypoint, CacheDescriptionGC)
-										&& updateExists(ch, CacheDescriptionGC)) {
+									if (doPMCache(chWaypoint, CacheDescriptionGC) && updateExists(ch, CacheDescriptionGC)) {
 										if (cFoundForUpdate.size() < maxUpdate) {
 											cFoundForUpdate.put(chWaypoint, ch);
 										} else
@@ -979,33 +929,32 @@
 								toDistance = 0;
 								cExpectedForUpdate.clear();
 							} else {
-								if (cExpectedForUpdate.size() <= cFoundForUpdate
-										.size()) {
+								if (cExpectedForUpdate.size() <= cFoundForUpdate.size()) {
 									toDistance = 0;
 								}
 							}
 						}
 					} else
 						toDistance = 0; // finish listing
-					// get next row of table (next Cache Description) of this htmlListPage
-					RexPropLine.searchFrom(tableOfHtmlListPage, RexPropLine
-							.matchedTo());
+					// get next row of table (next Cache Description) of this
+					// htmlListPage
+					RexPropLine.searchFrom(tableOfHtmlListPage, RexPropLine.matchedTo());
 					if (infB.isClosed) {
 						toDistance = 0;
 						break;
 					}
 				} // next Cache
-				infB.setInfo(MyLocale.getMsg(5511, "Found ")
-						+ cachesToLoad.size() + " / " + cFoundForUpdate.size()
-						+ MyLocale.getMsg(5512, " caches"));
+				infB.setInfo(MyLocale.getMsg(5511, "Found ") + cachesToLoad.size() + " / " + cFoundForUpdate.size() + MyLocale.getMsg(5512, " caches"));
 				if (found_on_page < 20) {
 					if (spiderAllFinds) {
-						// check all pages ( seen a gc-account with found_on_page less 20 and not on end )
+						// check all pages ( seen a gc-account with
+						// found_on_page less 20 and not on end )
 						if (((page_number - 1) * 20 + found_on_page) >= numFinds) {
 							toDistance = 0;
 						}
 					} else
-						toDistance = 0; // last page (has less than 20 entries!?) to check reached
+						toDistance = 0; // last page (has less than 20
+										// entries!?) to check reached
 				}
 				if (toDistance > 0) {
 					getAListPage(toDistanceInMiles, gotoNextPage);
@@ -1014,53 +963,42 @@
 				}
 			} // loop pages
 		} // try
-		catch (Exception ex) {
+		catch (final Exception ex) {
 			pref.log("Download error : ", ex, true);
 			infB.close(0);
 			Vm.showWait(false);
 			cExpectedForUpdate.clear();
 		}
-		pref.log("Checked " + page_number + " pages"+Preferences.NEWLINE+
-				"with " + ((page_number-1)*20+found_on_page) + " caches"+Preferences.NEWLINE+
-				"Found " + cachesToLoad.size() + " new caches"+Preferences.NEWLINE+
-				"Found " + cExpectedForUpdate.size() + "/" + cFoundForUpdate.size() + " caches for update"+Preferences.NEWLINE+
-				"Found " + numAvailableUpdates + " caches with changed available status."+Preferences.NEWLINE+
-				"Found " + numLogUpdates + " caches with new found in log."+Preferences.NEWLINE+
-				"Found " + (cExpectedForUpdate.size()-numAvailableUpdates-numLogUpdates) + " caches possibly archived."+Preferences.NEWLINE+
-				"Found " + cFoundForUpdate.size() + " ?= " + (numFoundUpdates+numArchivedUpdates+numAvailableUpdates+numArchivedUpdates) + " caches to update."+Preferences.NEWLINE+
-				"Found " + numPrivate + " Premium Caches (for non Premium Member.)",null);
-		if(spiderAllFinds){
-			pref.log("Found " + numFoundUpdates + " caches with no found in profile."+Preferences.NEWLINE+
-			"Found " + numArchivedUpdates + " caches with changed archived status."+Preferences.NEWLINE,null);
+		pref.log("Checked " + page_number + " pages" + Preferences.NEWLINE + "with " + ((page_number - 1) * 20 + found_on_page) + " caches" + Preferences.NEWLINE + "Found " + cachesToLoad.size() + " new caches" + Preferences.NEWLINE + "Found "
+				+ cExpectedForUpdate.size() + "/" + cFoundForUpdate.size() + " caches for update" + Preferences.NEWLINE + "Found " + numAvailableUpdates + " caches with changed available status." + Preferences.NEWLINE + "Found " + numLogUpdates
+				+ " caches with new found in log." + Preferences.NEWLINE + "Found " + (cExpectedForUpdate.size() - numAvailableUpdates - numLogUpdates) + " caches possibly archived." + Preferences.NEWLINE + "Found " + cFoundForUpdate.size() + " ?= "
+				+ (numFoundUpdates + numArchivedUpdates + numAvailableUpdates + numArchivedUpdates) + " caches to update." + Preferences.NEWLINE + "Found " + numPrivate + " Premium Caches (for non Premium Member.)", null);
+		if (spiderAllFinds) {
+			pref.log("Found " + numFoundUpdates + " caches with no found in profile." + Preferences.NEWLINE + "Found " + numArchivedUpdates + " caches with changed archived status." + Preferences.NEWLINE, null);
 		}
 
 		if (cExpectedForUpdate.size() == startSize)
 			cExpectedForUpdate.clear(); // there must be something wrong
-		if (cExpectedForUpdate.size() == 0
-				|| cExpectedForUpdate.size() > maxUpdate)
+		if (cExpectedForUpdate.size() == 0 || cExpectedForUpdate.size() > maxUpdate)
 			cExpectedForUpdate = cFoundForUpdate;
 		return cExpectedForUpdate;
 
 	}
 
-	private int downloadCaches(Vector cachesToLoad, int spiderErrors,
-			int totalCachesToLoad, boolean loadAllLogs) {
+	private int downloadCaches(Vector cachesToLoad, int spiderErrors, int totalCachesToLoad, boolean loadAllLogs) {
 		for (int i = 0; i < cachesToLoad.size(); i++) {
 			if (infB.isClosed)
 				break;
 			String wpt = (String) cachesToLoad.get(i);
-			boolean is_found = wpt.indexOf("found") != -1;
+			final boolean is_found = wpt.indexOf("found") != -1;
 			if (is_found)
 				wpt = wpt.substring(0, wpt.indexOf("found"));
 			// Get only caches not already available in the DB
 			if (cacheDB.getIndex(wpt) == -1) {
-				infB.setInfo(MyLocale.getMsg(5513, "Loading: ") + wpt + " ("
-						+ (i + 1) + " / " + totalCachesToLoad + ")");
-				CacheHolder holder = new CacheHolder();
+				infB.setInfo(MyLocale.getMsg(5513, "Loading: ") + wpt + " (" + (i + 1) + " / " + totalCachesToLoad + ")");
+				final CacheHolder holder = new CacheHolder();
 				holder.setWayPoint(wpt);
-				int test = getCacheByWaypointName(holder, false,
-						pref.downloadPics, pref.downloadTBs, doNotgetFound,
-						loadAllLogs || is_found |!doNotgetFound);
+				final int test = getCacheByWaypointName(holder, false, pref.downloadPics, pref.downloadTBs, doNotgetFound, loadAllLogs || is_found | !doNotgetFound);
 				if (test == SPIDER_CANCEL) {
 					infB.close(0);
 					break;
@@ -1078,18 +1016,15 @@
 
 	private int updateCaches(Hashtable cachesToUpdate, int spiderErrors, int totalCachesToLoad, boolean loadAllLogs) {
 		int j = 1;
-		for (Enumeration e = cachesToUpdate.elements(); e.hasMoreElements(); j++) {
+		for (final Enumeration e = cachesToUpdate.elements(); e.hasMoreElements(); j++) {
 			if (infB.isClosed)
 				break;
-			CacheHolder ch = (CacheHolder) e.nextElement();
-			infB.setInfo(MyLocale.getMsg(5513, "Loading: ") + ch.getWayPoint()
-					+ " (" + (cachesToLoad.size() + j) + " / "
-					+ totalCachesToLoad + ")");
-			int test = spiderSingle(cacheDB.getIndex(ch), infB, false, loadAllLogs);
+			final CacheHolder ch = (CacheHolder) e.nextElement();
+			infB.setInfo(MyLocale.getMsg(5513, "Loading: ") + ch.getWayPoint() + " (" + (cachesToLoad.size() + j) + " / " + totalCachesToLoad + ")");
+			final int test = spiderSingle(cacheDB.getIndex(ch), infB, false, loadAllLogs);
 			if (test == SPIDER_CANCEL) {
 				break;
-			} 
-			else {
+			} else {
 				if (test == SPIDER_ERROR) {
 					spiderErrors++;
 					pref.log("[updateCaches] could not spider " + ch.getWayPoint(), null);
@@ -1102,17 +1037,14 @@
 	}
 
 	/**
-	 * Method to spider a single cache. It assumes a login has already been
-	 * performed!
+	 * Method to spider a single cache. It assumes a login has already been performed!
 	 * 
-	 * @return 1 if spider was successful, -1 if spider was cancelled by closing
-	 *         the infobox, 0 error, but continue with next cache
+	 * @return 1 if spider was successful, -1 if spider was cancelled by closing the infobox, 0 error, but continue with next cache
 	 */
-	public int spiderSingle(int number, InfoBox pInfB, boolean forceLogin,
-			boolean loadAllLogs) {
+	public int spiderSingle(int number, InfoBox pInfB, boolean forceLogin, boolean loadAllLogs) {
 		int ret = -1;
 		this.infB = pInfB;
-		CacheHolder ch = new CacheHolder(); // cacheDB.get(number);
+		final CacheHolder ch = new CacheHolder(); // cacheDB.get(number);
 		ch.setWayPoint(cacheDB.get(number).getWayPoint());
 		if (ch.isAddiWpt())
 			return -1; // No point re-spidering an addi waypoint, comes with
@@ -1126,11 +1058,10 @@
 		}
 		try {
 			// Read the cache data from GC.COM and compare to old data
-			ret = getCacheByWaypointName(ch, true, pref.downloadPics,
-					pref.downloadTBs, false, loadAllLogs);
+			ret = getCacheByWaypointName(ch, true, pref.downloadPics, pref.downloadTBs, false, loadAllLogs);
 			// Save the spidered data
 			if (ret == SPIDER_OK) {
-				CacheHolder cacheInDB = cacheDB.get(number);
+				final CacheHolder cacheInDB = cacheDB.get(number);
 				cacheInDB.initStates(false);
 				if (cacheInDB.is_found() && !ch.is_found() && !loadAllLogs) {
 					// If the number of logs to spider is 5 or less, then the
@@ -1144,18 +1075,15 @@
 				ch.setNumRecommended(cacheInDB.getNumRecommended());
 				if (pref.downloadPics) {
 					// delete obsolete images when we have current set
-					CacheImages.cleanupOldImages(cacheInDB
-							.getCacheDetails(true).images, ch
-							.getCacheDetails(false).images);
+					CacheImages.cleanupOldImages(cacheInDB.getCacheDetails(true).images, ch.getCacheDetails(false).images);
 				} else {
 					// preserve images if not downloaded
-					ch.getCacheDetails(false).images = cacheInDB
-							.getCacheDetails(true).images;
+					ch.getCacheDetails(false).images = cacheInDB.getCacheDetails(true).images;
 				}
 				cacheInDB.update(ch);
 				cacheInDB.save();
 			}
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[spiderSingle] Error spidering " + ch.getWayPoint() + " in spiderSingle", ex);
 		}
 		return ret;
@@ -1178,13 +1106,13 @@
 				return "";
 			}
 		}
-		InfoBox localInfB = new InfoBox("Info", "Loading", InfoBox.PROGRESS_WITH_WARNINGS);
+		final InfoBox localInfB = new InfoBox("Info", "Loading", InfoBox.PROGRESS_WITH_WARNINGS);
 		localInfB.exec();
 		try {
-			String doc = p.getProp("waypoint") + wayPoint;
+			final String doc = p.getProp("waypoint") + wayPoint;
 			completeWebPage = UrlFetcher.fetch(doc);
 			pref.log("Fetched " + wayPoint);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			localInfB.close(0);
 			pref.log("[getCacheCoordinates] Could not fetch " + wayPoint, ex);
 			return "";
@@ -1192,34 +1120,43 @@
 		localInfB.close(0);
 		try {
 			return getLatLon(completeWebPage);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			return "????";
 		}
 	} // getCacheCoordinates
 
 	/**
-	 * Method to login the user to gc.com It will request a password and use the
-	 * alias defined in preferences If the login page cannot be fetched, the
-	 * password is cleared. If the login fails, an appropriate message is
-	 * displayed.
+	 * Method to login the user to gc.com It will request a password and use the alias defined in preferences If the login page cannot be fetched, the password is cleared. If the login fails, an appropriate message is displayed.
 	 */
 	private int login() {
-		if (cookie.length() > 0) 
-			UrlFetcher.setPermanentRequestorProperty("Cookie", cookie);
-		else
+		if (pref.userID.length() > 0) {
 			UrlFetcher.setPermanentRequestorProperty("Cookie", null);
+			loggedIn = switchToEnglish();
+			if (loggedIn)
+				return FormBase.IDOK;
+			else {
+				(new MessageBox("Login", "Check UserID in preferences| Einstellungen.", FormBase.OKB)).execute();
+				return ERR_LOGIN;
+			}
+		} else {
+			UrlFetcher.setPermanentRequestorProperty("Cookie", null);
+			if (true) {
+				(new MessageBox("Login", "Check UserID in preferences| Einstellungen.", FormBase.OKB)).execute();
+				return ERR_LOGIN; // until SSL/https works
+			}
+		}
 		loggedIn = false;
 		String loginPage, loginPageUrl, loginSuccess;
 		try {
 			loginPageUrl = p.getProp("loginPage");
 			loginSuccess = p.getProp("loginSuccess");
-		} catch (Exception ex) { // Tag not found in spider.def
+		} catch (final Exception ex) { // Tag not found in spider.def
 			return ERR_LOGIN;
 		}
 
 		// **0 Get password
 		String passwort = pref.password;
-		InfoBox localInfB = new InfoBox(MyLocale.getMsg(5506, "Password"),MyLocale.getMsg(5505, "Enter Password"), InfoBox.INPUT);
+		InfoBox localInfB = new InfoBox(MyLocale.getMsg(5506, "Password"), MyLocale.getMsg(5505, "Enter Password"), InfoBox.INPUT);
 		localInfB.feedback.setText(passwort);
 		localInfB.feedback.isPassword = true;
 		int code = FormBase.IDOK;
@@ -1228,8 +1165,9 @@
 			passwort = localInfB.getInput();
 		}
 		localInfB.close(0);
-		if (code != FormBase.IDOK) return code;
-		
+		if (code != FormBase.IDOK)
+			return code;
+
 		// **1 now we have user and password for login
 		localInfB = new InfoBox(MyLocale.getMsg(5507, "Status"), MyLocale.getMsg(5508, "Logging in..."));
 		localInfB.exec();
@@ -1237,48 +1175,40 @@
 			loginPage = UrlFetcher.fetch(loginPageUrl); // http://www.geocaching.com/login/default.aspx
 			if (loginPage.equals("")) {
 				localInfB.close(0);
-				(new MessageBox(MyLocale.getMsg(5500, "Error"),
-						MyLocale.getMsg(5499,"Error loading login page.%0aPlease check your internet connection."),
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5499, "Error loading login page.%0aPlease check your internet connection."), FormBase.OKB)).execute();
 				pref.log("[login]:Could not fetch: gc.com login page " + loginPageUrl, null);
 				return ERR_LOGIN;
 			}
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			localInfB.close(0);
-			(new MessageBox(MyLocale.getMsg(5500, "Error"),
-					MyLocale.getMsg(5499, "Error loading login page.%0aPlease check your internet connection."),
-					FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5499, "Error loading login page.%0aPlease check your internet connection."), FormBase.OKB)).execute();
 			pref.log("[login]:Could not fetch: gc.com login page", ex);
 			return ERR_LOGIN;
 		}
-		
+
 		// **2 now we can check the loginpage if logged in else log in
 		if (!localInfB.isClosed) {
-			if (loginPage.indexOf(loginSuccess) > 0)  {
+			if (loginPage.indexOf(loginSuccess) > 0) {
 				if (loginPage.indexOf(pref.myAlias) > 0) {
 					loggedIn = true;
 					// assume language is already set to EN
 					pref.log("[login]:Already logged in as " + pref.myAlias);
-				}
-				else {
+				} else {
 					// it is another user, whom we should logout
 					try {
-						loginPage = UrlFetcher.fetch("http://www.geocaching.com/login/default.aspx?RESETCOMPLETE=Y");						
-					} catch (Exception ex) {
+						loginPage = UrlFetcher.fetch("http://www.geocaching.com/login/default.aspx?RESETCOMPLETE=Y");
+					} catch (final Exception ex) {
 						localInfB.close(0);
-						(new MessageBox(MyLocale.getMsg(5500, "Error"),
-								MyLocale.getMsg(5499, "Error loading login page.%0aPlease check your internet connection."),
-								FormBase.OKB)).execute();
+						(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5499, "Error loading login page.%0aPlease check your internet connection."), FormBase.OKB)).execute();
 						pref.log("[login]:Could not fetch: gc.com login page", ex);
 						return ERR_LOGIN;
 					}
-					
+
 				}
 			}
-			if (!loggedIn)
-				{
+			if (!loggedIn) {
 				try {
-					Regex rexViewstate = new Regex("id=\"__VIEWSTATE\" value=\"(.*?)\" />");
+					final Regex rexViewstate = new Regex("id=\"__VIEWSTATE\" value=\"(.*?)\" />");
 					String viewstate = "";
 					rexViewstate.search(loginPage);
 					if (rexViewstate.didMatch()) {
@@ -1286,15 +1216,16 @@
 					} else {
 						localInfB.close(0);
 						pref.log("[login]:__VIEWSTATE not found (before login): no login possible.", null);
-						// we need the __VIEWSTATE for sending loginData, so we should abort here
+						// we need the __VIEWSTATE for sending loginData, so we
+						// should abort here
 						return ERR_LOGIN;
 					}
-					StringBuffer sb = new StringBuffer(1000);
-					sb.append("__VIEWSTATE="+URL.encodeURL(viewstate, false));
+					final StringBuffer sb = new StringBuffer(1000);
+					sb.append("__VIEWSTATE=" + URL.encodeURL(viewstate, false));
 					sb.append("&ctl00%24ContentBody%24");
-					sb.append("myUsername="+encodeUTF8URL(Utils.encodeJavaUtf8String(pref.myAlias)));
+					sb.append("myUsername=" + encodeUTF8URL(Utils.encodeJavaUtf8String(pref.myAlias)));
 					sb.append("&ctl00%24ContentBody%24");
-					sb.append("myPassword="+encodeUTF8URL(Utils.encodeJavaUtf8String(passwort)));
+					sb.append("myPassword=" + encodeUTF8URL(Utils.encodeJavaUtf8String(passwort)));
 					sb.append("&ctl00%24ContentBody%24");
 					sb.append("cookie=on");
 					sb.append("&ctl00%24ContentBody%24");
@@ -1303,83 +1234,56 @@
 					loginPage = UrlFetcher.fetch(loginPageUrl);
 					if (loginPage.indexOf(loginSuccess) > 0) {
 						pref.log("Login successful: " + pref.myAlias);
-						// **3 now we are logged in and get the Cookie (there are two)
-						PropertyList pl = UrlFetcher.getDocumentProperties();
+						// **3 now we are logged in and get the Cookie (there
+						// are two)
+						final PropertyList pl = UrlFetcher.getDocumentProperties();
 						String docprops = "";
 						for (int i = 0; i < pl.size(); i++) {
-							Property p = (Property) pl.get(i);
+							final Property p = (Property) pl.get(i);
 							if (p.name.equalsIgnoreCase("Set-Cookie")) {
-								docprops+=p.value;
+								docprops += p.value;
 							}
 						}
-						Regex rexCookieSession = new Regex("(?i)ASP.NET_SessionId=(.*?);.*");
+						final Regex rexCookieSession = new Regex("(?i)ASP.NET_SessionId=(.*?);.*");
 						rexCookieSession.search(docprops);
 						if (rexCookieSession.didMatch()) {
 							cookie = "ASP.NET_SessionId=" + rexCookieSession.stringMatched(1);
-						} 
-						else {
+						} else {
 							localInfB.close(0);
 							pref.log("[login]:SessionID not found.", null);
 							return ERR_LOGIN;
 						}
-						Regex rexCookieID = new Regex("(?i)userid=(.*?);.*");
+						final Regex rexCookieID = new Regex("(?i)userid=(.*?);.*");
 						rexCookieID.search(docprops);
 						if (rexCookieID.didMatch()) {
 							cookie += "; userid=" + rexCookieID.stringMatched(1);
-						} 
-						else {
+						} else {
 							localInfB.close(0);
 							pref.log("[login]:userID not found.", null);
 							return ERR_LOGIN;
 						}
 						UrlFetcher.setPermanentRequestorProperty("Cookie", cookie);
-
-						// **4 change language to EN 
-						rexViewstate.search(loginPage);
-						if (rexViewstate.didMatch()) {
-							viewstate = rexViewstate.stringMatched(1);
-						} 
-						else {
-							localInfB.close(0);
-							pref.log("[login]:__VIEWSTATE not found (before Language=EN): can't change language.", null);
-							return ERR_LOGIN;
-						}
-						String strEnglishPage = "ctl00$uxLocaleList$uxLocaleList$ctl01$uxLocaleItem";
-						String postStr = "__EVENTTARGET="+ URL.encodeURL(strEnglishPage, false)
-										+ "&__EVENTARGUMENT="
-										+ "&__VIEWSTATE=" + URL.encodeURL(viewstate, false);
-						try {
-							UrlFetcher.setpostData(postStr);
-							loginPage = UrlFetcher.fetch(loginPageUrl);
-							// there is no real check if switched
-							pref.log("Switched to English");
-						} catch (Exception ex) {
-							pref.log("Error switching to English: check/n" + loginPageUrl + "/n" + postStr, ex);
-						}
-					}
-					else {
+					} else {
 						pref.log("Login failed. Wrong Account or Password? " + pref.myAlias, null);
 						pref.log("[login.url]:" + loginPageUrl, null);
 						pref.log("[login.postData]:" + sb.toString(), null);
 						pref.log("[login.Answer]:" + loginPage, null);
 						localInfB.close(0);
-						(new MessageBox(MyLocale.getMsg(5500, "Error"),
-								MyLocale.getMsg(5501,"Login failed! Wrong account or password?"),
-								FormBase.OKB)).execute();
+						(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5501, "Login failed! Wrong account or password?"), FormBase.OKB)).execute();
 						return ERR_LOGIN;
 					}
-				} catch (Exception ex) {
+					if (!this.switchToEnglish())
+						return ERR_LOGIN;
+				} catch (final Exception ex) {
 					pref.log("[login]:Login failed with exception.", ex);
 					localInfB.close(0);
-					(new MessageBox(MyLocale.getMsg(5500, "Error"),
-							MyLocale.getMsg(5501,"Login failed. Error loading page after login."),
-							FormBase.OKB)).execute();
+					(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5501, "Login failed. Error loading page after login."), FormBase.OKB)).execute();
 					return ERR_LOGIN;
 				}
 			}
 		}
-		
-		boolean loginAborted = localInfB.isClosed;
+
+		final boolean loginAborted = localInfB.isClosed;
 		localInfB.close(0);
 		if (loginAborted)
 			return FormBase.IDCANCEL;
@@ -1388,6 +1292,77 @@
 			return FormBase.IDOK;
 		}
 	}
+
+	private boolean switchToEnglish() {
+		// change language to EN , further operations relay on English
+		String url = "http://www.geocaching.com/my/default.aspx";
+		String page = "";
+		String loggedInEnglish = "Sign Out";
+		String userID = "userid=" + pref.userID;
+		try {
+			UrlFetcher.setPermanentRequestorProperty("Cookie", userID);
+			page = UrlFetcher.fetch(url); // getting the sessionid
+			if (page.length() == 0)
+				return false;
+		} catch (final Exception ex) {
+			return false;
+		}
+		final PropertyList pl = UrlFetcher.getDocumentProperties();
+		String docprops = "";
+		for (int i = 0; i < pl.size(); i++) {
+			final Property p = (Property) pl.get(i);
+			if (p.name.equalsIgnoreCase("Set-Cookie")) {
+				docprops += p.value;
+			}
+		}
+		final Regex rexCookieSession = new Regex("(?i)ASP.NET_SessionId=(.*?);.*");
+		rexCookieSession.search(docprops);
+		if (rexCookieSession.didMatch()) {
+			cookie = "ASP.NET_SessionId=" + rexCookieSession.stringMatched(1) + "; " + userID;
+			UrlFetcher.setPermanentRequestorProperty("Cookie", cookie);
+		} else {
+			pref.log("[switchToEnglish]:SessionID not found.", null);
+			return false;
+		}
+		try {
+			page = UrlFetcher.fetch(url);
+			if (page.length() == 0)
+				return false;
+		} catch (IOException e) {
+			return false;
+		}
+		if (page.indexOf(loggedInEnglish) > -1) {
+			pref.log("already English");
+			return true;
+		}
+		// todo next doesn't work correct don't know why
+		// switch to english now goes into profile (is permanent, must be reset)
+		final Regex rexViewstate = new Regex("id=\"__VIEWSTATE\" value=\"(.*?)\" />");
+		String viewstate = "";
+		rexViewstate.search(page);
+		if (rexViewstate.didMatch()) {
+			viewstate = rexViewstate.stringMatched(1);
+		} else
+			return false;
+		final String strEnglishPage = "ctl00$uxLocaleList$uxLocaleList$ctl01$uxLocaleItem";
+		final String postStr = "__EVENTTARGET=" + UrlFetcher.encodeURL(strEnglishPage, false) + "&__EVENTARGUMENT=" + "&__VIEWSTATE=" + UrlFetcher.encodeURL(viewstate, false);
+		try {
+			UrlFetcher.setpostData(postStr);
+			page = UrlFetcher.fetch(url);
+			if (page.indexOf(loggedInEnglish) > -1) {
+				pref.log("Switched to English");
+				return true;
+			} else {
+				pref.log(page, null);
+				return false;
+			}
+		} catch (final Exception ex) {
+			pref.log("Error switching to English: check/n" + url + "/n" + postStr, ex);
+			return false;
+		}
+
+	}
+
 	/*
 	 *
 	 */
@@ -1426,7 +1401,7 @@
 			icon_camera = p.getProp("icon_camera");
 			icon_attended = p.getProp("icon_attended");
 			RexCacheType = new Regex(p.getProp("cacheTypeRex"));
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("Error fetching Properties.", ex);
 		}
 	}
@@ -1441,25 +1416,20 @@
 		if (spiderAllFinds) {
 			url = propFirstPageFinds + encodeUTF8URL(Utils.encodeJavaUtf8String(pref.myAlias));
 		} else {
-			url = propFirstPage + origin.getLatDeg(TransformCoordinates.DD)
-				+ propFirstPage2
-				+ origin.getLonDeg(TransformCoordinates.DD)
-				+ propMaxDistance + Integer.toString(distance);
+			url = propFirstPage + origin.getLatDeg(TransformCoordinates.DD) + propFirstPage2 + origin.getLonDeg(TransformCoordinates.DD) + propMaxDistance + Integer.toString(distance);
 			if (doNotgetFound)
 				url = url + propShowOnlyFound;
 		}
 		url = url + cacheTypeRestriction;
-		
+
 		try {
 			htmlListPage = UrlFetcher.fetch(url);
 			pref.log("[getFirstListPage] Got first page " + url);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[getFirstListPage] Error fetching first list page " + url, ex, true);
 			Vm.showWait(false);
 			infB.close(0);
-			(new MessageBox(MyLocale.getMsg(5500, "Error"), 
-					MyLocale.getMsg(5503, "Error fetching first list page."),
-					FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5503, "Error fetching first list page."), FormBase.OKB)).execute();
 			return;
 		}
 	}
@@ -1472,16 +1442,13 @@
 		if (spiderAllFinds) {
 			url = propFirstPage;
 		} else {
-			url = propFirstPage + origin.getLatDeg(TransformCoordinates.DD)
-				+ propFirstPage2
-				+ origin.getLonDeg(TransformCoordinates.DD)
-				+ propMaxDistance + Integer.toString(distance);
+			url = propFirstPage + origin.getLatDeg(TransformCoordinates.DD) + propFirstPage2 + origin.getLonDeg(TransformCoordinates.DD) + propMaxDistance + Integer.toString(distance);
 			if (doNotgetFound)
 				url = url + propShowOnlyFound;
 		}
 		url = url + cacheTypeRestriction;
 
-		Regex rexViewstate = new Regex("id=\"__VIEWSTATE\" value=\"(.*?)\" />");
+		final Regex rexViewstate = new Regex("id=\"__VIEWSTATE\" value=\"(.*?)\" />");
 		String viewstate;
 		rexViewstate.search(htmlListPage);
 		if (rexViewstate.didMatch()) {
@@ -1491,7 +1458,7 @@
 			pref.log("[getAListPage] check rexViewstate in SpiderGC.java" + Preferences.NEWLINE + htmlListPage);
 		}
 
-		Regex rexViewstate1 = new Regex("id=\"__VIEWSTATE1\" value=\"(.*?)\" />");
+		final Regex rexViewstate1 = new Regex("id=\"__VIEWSTATE1\" value=\"(.*?)\" />");
 		String viewstate1;
 		rexViewstate1.search(htmlListPage);
 		if (rexViewstate1.didMatch()) {
@@ -1501,16 +1468,13 @@
 			pref.log("[getAListPage] check rexViewstate1 in SpiderGC.java" + Preferences.NEWLINE + htmlListPage);
 		}
 
-		String postData = "__EVENTTARGET=" + URL.encodeURL(whatPage, false) + "&" +
-						  "__EVENTARGUMENT=" + "&" +
-						  "__VIEWSTATEFIELDCOUNT=2" + "&" +
-						  "__VIEWSTATE=" + URL.encodeURL(viewstate, false) + "&" +
-						  "__VIEWSTATE1=" + URL.encodeURL(viewstate1, false);
+		final String postData = "__EVENTTARGET=" + URL.encodeURL(whatPage, false) + "&" + "__EVENTARGUMENT=" + "&" + "__VIEWSTATEFIELDCOUNT=2" + "&" + "__VIEWSTATE=" + URL.encodeURL(viewstate, false) + "&" + "__VIEWSTATE1="
+				+ URL.encodeURL(viewstate1, false);
 		try {
 			UrlFetcher.setpostData(postData);
 			htmlListPage = UrlFetcher.fetch(url);
 			pref.log("[getAListPage] Got list page: " + url);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[getAListPage] Error getting a list page" + url, ex);
 		}
 	}
@@ -1518,47 +1482,294 @@
 	/* */
 	private String getMapListPage(CWPoint middle, double north, double west, double south, double east) {
 		String ret;
-		
-		String referer = "http://www.geocaching.com/map/default.aspx" + 
-		"?lat="	+ middle.getLatDeg(TransformCoordinates.DD) + 
-		"&lng="	+ middle.getLonDeg(TransformCoordinates.DD);
 
+		final String referer = "http://www.geocaching.com/map/default.aspx" + "?lat=" + middle.getLatDeg(TransformCoordinates.DD) + "&lng=" + middle.getLonDeg(TransformCoordinates.DD);
+
 		if (userToken.equals("")) {
 			try {
 				ret = UrlFetcher.fetch(referer);
-			} catch (IOException e) {
-				ret="";
+			} catch (final IOException e) {
+				ret = "";
 			}
 			int i = ret.indexOf("userToken = '");
-			i=i+13;
-			int j = ret.indexOf("'", i);
-			userToken = ret.substring(i,j);
+			i = i + 13;
+			final int j = ret.indexOf("'", i);
+			userToken = ret.substring(i, j);
 		}
-		
-		String url = "http://www.geocaching.com/map/default.aspx/MapAction";
 
-		String strLeft = MyLocale.formatDouble(west, "#0.00000").replace(',','.');
-		String strUp = MyLocale.formatDouble(north, "#0.00000").replace(',','.');
-		String strRight = MyLocale.formatDouble(east, "#0.00000").replace(',','.');
-		String strDown = MyLocale.formatDouble(south, "#0.00000").replace(',','.');
-		String param1 = "{\"dto\":{\"data\":{\"c\":1,\"m\":\"\",\"d\":\"";
-		String param2 = strUp + "|" + strDown + "|" + strRight + "|" + strLeft;
-		String param3 = "\"},\"ut\":\"";
-		String param4 = "\"}}";
-		String postData = param1+param2+param3+userToken+param4;
+		final String url = "http://www.geocaching.com/map/default.aspx/MapAction";
 
+		final String strLeft = MyLocale.formatDouble(west, "#0.00000").replace(',', '.');
+		final String strUp = MyLocale.formatDouble(north, "#0.00000").replace(',', '.');
+		final String strRight = MyLocale.formatDouble(east, "#0.00000").replace(',', '.');
+		final String strDown = MyLocale.formatDouble(south, "#0.00000").replace(',', '.');
+		final String param1 = "{\"dto\":{\"data\":{\"c\":1,\"m\":\"\",\"d\":\"";
+		final String param2 = strUp + "|" + strDown + "|" + strRight + "|" + strLeft;
+		final String param3 = "\"},\"ut\":\"";
+		final String param4 = "\"}}";
+		final String postData = param1 + param2 + param3 + userToken + param4;
+
 		try {
 			UrlFetcher.setpostData(postData);
 			UrlFetcher.setRequestorProperty("Content-Type", "application/json; charset=UTF-8");
-			ret=UrlFetcher.fetch(url);			
+			ret = UrlFetcher.fetch(url);
 
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			ret = "";
 			pref.log("[SpiderGC:getMapListPage] Error getting map Cachepage" + url + postData, ex);
 		}
 		return ret;
- 	}
+	}
 
+	/* */
+	public void doItQuickFillFromMapList() {
+
+		final CWPoint origin = pref.getCurCentrePt();
+		if (!origin.isValid()) {
+			(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5509, "Coordinates for centre must be set"), FormBase.OKB)).execute();
+			return; //
+		}
+		if (!doDownloadGui(2))
+			return;
+
+		Vm.showWait(true);
+		infB = new InfoBox("Status", MyLocale.getMsg(1609, "getting the caches."));
+		infB.exec();
+
+		// Reset states for all caches when spidering (http://tinyurl.com/dzjh7p)
+		for (int i = 0; i < cacheDB.size(); i++) {
+			final CacheHolder ch = cacheDB.get(i);
+			if (ch.mainCache == null)
+				ch.initStates(false);
+		}
+
+		double halfSideLength = maxDistance; // halbe Seitenl?nge eines Quadrats ums Zentrum in km
+		if (pref.metricSystem == Metrics.IMPERIAL) {
+			halfSideLength = Metrics.convertUnit(maxDistance, Metrics.MILES, Metrics.KILOMETER);
+		}
+
+		if (!loggedIn || pref.forceLogin) {
+			if (login() != FormBase.IDOK)
+				return;
+		}
+
+		page_number = 0;
+		num_added = 0;
+
+		final Area sq = getSquare(origin, halfSideLength);
+
+		getCachesNewMap(sq, false);
+
+		if (!infB.isClosed)
+			infB.close(0);
+		Vm.showWait(false);
+
+		Global.getProfile().restoreFilter();
+		Global.getProfile().saveIndex(Global.getPref(), true);
+
+	}
+
+	private void getCachesNewMap(Area square, boolean setCachesToLoad) {
+
+		if (userToken.equals("")) {
+			String url;
+			String ret;
+			try {
+				page_number++;
+				url = "http://www.geocaching.com/map/beta/default.aspx" + "?lat=" + square.topleft.getLatDeg(TransformCoordinates.DD) + "&lng=" + square.topleft.getLonDeg(TransformCoordinates.DD) + "&z=15";
+				ret = UrlFetcher.fetch(url);
+			} catch (final IOException e) {
+				ret = "";
+			}
+			int i = ret.indexOf("GSPK.UserSession('");
+			i = i + 18;
+			int j = ret.indexOf("'", i);
+			userToken = ret.substring(i, j);
+			i = ret.indexOf("sessionToken:'", i);
+			i = i + 14;
+			j = ret.indexOf("'", i);
+			sessionToken = ret.substring(i, j);
+		}
+		TrackPoint tl;
+		TrackPoint br;
+		int lonmin;
+		int lonmax;
+		int latmin;
+		int latmax;
+		int scale = 19;
+		do {
+			scale = scale - 1;
+			tl = getKachelLatLon(square.topleft, scale);
+			br = getKachelLatLon(square.bottomright, scale);
+			lonmin = (int) tl.lonDec;
+			lonmax = (int) br.lonDec;
+			latmin = (int) tl.latDec;
+			latmax = (int) br.latDec;
+		} while ((lonmax - lonmin > 1) && (latmax - latmin > 1) && (scale > 16));
+
+		String cachelist;
+
+		for (int i = lonmin; i <= lonmax; i++) {
+			for (int j = latmin; j <= latmax; j++) {
+				cachelist = getNewMapListPage("" + j, "" + i, scale);
+				if (cachelist.length() > 0) {
+					final String[] caches = mString.split(cachelist, '{');
+					final double baseX = Common.parseDouble(caches[1].substring(8, caches[1].indexOf(',')));
+					final double baseY = Common.parseDouble(caches[1].substring(caches[1].indexOf(',') + 1, caches[1].indexOf(']')));
+					for (int k = 2; k < caches.length; k++) {
+						final String[] cacheInfos = mString.split(STRreplace.replace(caches[k], "\\\"", ""), '\"');
+						final String cacheID = cacheInfos[3];
+						final String cacheXY = cacheInfos[10];
+						final String[] xy = mString.split(cacheXY, ',');
+						final int cacheX = Common.parseInt(xy[0].substring(2));
+						final int cacheY = Common.parseInt(xy[1].substring(0, xy[1].indexOf(']')));
+						final CWPoint p = getLatLon(baseX, baseY, cacheX, cacheY, scale);
+						if (square.isInBound(p)) {
+							String cachePage = getCacheInfoNewMap(cacheID);
+							addCacheNewMap(cachePage, p, setCachesToLoad);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	private TrackPoint getKachelLatLon(CWPoint p, int scale) {
+		double lat = p.latDec;
+		double lon = p.lonDec;
+		if (lon > 180.0) {
+			lon -= 360.0;
+		}
+		lat = 0.5 - Math.log(Math.tan((Math.PI / 4.0) + ((Math.PI * lat) / (2.0 * 180.0)))) / (2.0 * Math.PI);
+		lon = (180.0 + lon) / 360.0;
+
+		final int f = 1 << scale; // 2**scale
+		lat = lat * f;
+		lon = lon * f;
+		return new TrackPoint(lat, lon); // TrackPoint only for returning values
+	}
+
+	private CWPoint getLatLon(double basex, double basey, int offsetx, int offsety, int scale) {
+
+		double anzPixelX = basex + offsetx;
+		double anzPixelY = basey + offsety;
+
+		final CWPoint p = new CWPoint();
+
+		final double maxPixels = 1 << (scale + 8); // 2**scale*256
+		final double gpp = 360.0 / maxPixels; // Grad pro Pixel
+		final double leftLon = (anzPixelX * gpp); // Grad
+		p.lonDec = leftLon - 180.0; // 0 ist bei greenwich
+
+		final double lat = 1.0 / maxPixels;
+		final double latM = Math.PI * (1.0 + 2.0 * anzPixelY * lat);
+		p.latDec = (180.0 / Math.PI) * ((2.0 * Math.atan(Math.exp(latM))) - (Math.PI / 2.0));
+
+		return p;
+	}
+
+	private String getNewMapListPage(String strLat, String strLon, int scale) {
+		String ret;
+		String url = "";
+
+		try {
+			page_number++;
+			url = "http://www.geocaching.com/map/beta/map.info?" + "x=" + strLon + "&y=" + strLat + "&z=" + scale + "&k=" + userToken + "&st=" + sessionToken + "&ep=1";
+			UrlFetcher.setRequestorProperty("Content-Type", "application/json; charset=UTF-8");
+			ret = UrlFetcher.fetch(url);
+
+		} catch (final Exception ex) {
+			ret = "";
+			pref.log("[SpiderGC:getMapListPage] Error getting map Cachepage" + url + ex);
+		}
+		return ret;
+	}
+
+	private String getCacheInfoNewMap(String cacheID) {
+		String ret;
+		String url = "";
+
+		try {
+			page_number++;
+			url = "http://www.geocaching.com/map/beta/map.details?" + "wptid=" + cacheID + "&k=" + userToken + "&st=" + sessionToken + "&ep=1";
+			UrlFetcher.setRequestorProperty("Content-Type", "application/json; charset=UTF-8");
+			ret = UrlFetcher.fetch(url);
+
+		} catch (final Exception ex) {
+			ret = "";
+			pref.log("[SpiderGC:getCacheInfoNewMap] Error getting map Cachepage" + url + ex);
+		}
+		return ret;
+	}
+
+	private void addCacheNewMap(String page, CWPoint p, boolean setCachesToLoad) {
+
+		final int WpIndex = page.indexOf("\"gc\":");
+		final String[] elements = mString.split(page.substring(WpIndex), '\"');
+
+		final int posWP = 3; // gc
+		final int posDisabled = 6; // disabled
+		final int posDiff = 10; // difficulty
+		final int posTerr = 18; // terrain
+		final int posHidden = 25; // hidden date
+		final int posSize = 31; // size
+		final int posType = 44; // type
+		final int posOwner = 49; // owner
+		final int posGUID = 53; // guid
+
+		// final boolean found = (elements[posFound].indexOf("true") > -1 ? true
+		// : false);
+		// if (found && doNotgetFound) return;
+
+		final byte cacheType = CacheType.gcSpider2CwType(elements[posType].substring(1, elements[posType].length() - 2));
+		if (restrictedCacheType != CacheType.CW_TYPE_ERROR) {
+			if (restrictedCacheType != cacheType)
+				return;
+		}
+
+		String wp = elements[posWP];
+		CacheHolder ch = cacheDB.get(wp);
+		if (ch == null) {
+
+			ch = new CacheHolder();
+			ch.setWayPoint(wp);
+			ch.pos = p;
+			final String owner = elements[posOwner];
+			ch.setCacheOwner(owner);
+			// wird nicht mehr geliefert , todo aus Grafik extrahieren.
+			if (owner.equals(pref.myAlias) || owner.equals(pref.myAlias2)) {
+				ch.setOwned(true);
+			} else {
+				if (false) {
+					ch.setFound(true);
+					ch.setCacheStatus(ch.getFoundText());
+				}
+			}
+
+			final int NameIndex = page.indexOf("\"name\":\"");
+			String cacheName = page.substring(NameIndex + 8, WpIndex - 2);
+			cacheName = STRreplace.replace(cacheName, "\\\"", "\"");
+			ch.setCacheName(cacheName);
+			ch.setAvailable((elements[posDisabled].indexOf("true") > -1 ? false : true));
+			ch.setDateHidden(DateFormat.MDY2YMD(elements[posHidden]));
+			ch.setHard(CacheTerrDiff.v1Converter(elements[posDiff].substring(1, elements[posDiff].length() - 1)));
+			ch.setTerrain(CacheTerrDiff.v1Converter(elements[posTerr].substring(1, elements[posTerr].length() - 1)));
+			ch.setCacheSize(CacheSize.gcGpxString2Cw(elements[posSize]));
+			ch.setType(cacheType);
+			num_added++;
+			cacheDB.add(ch);
+			if (setCachesToLoad) {
+				cachesToLoad.add(wp + "found");
+			} else {
+				ch.getCacheDetails(false).URL = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + wp;
+				ch.save();
+			}
+			if (Global.mainTab.statBar != null)
+				Global.mainTab.statBar.updateDisplay("GC pages: " + page_number + " Caches added to CW: " + num_added);
+		} else {
+		}
+	}
+
 	/**
 	 * check if new Update exists
 	 * 
@@ -1573,7 +1784,7 @@
 		boolean save = false;
 		boolean is_archived_GC = false;
 		boolean is_found_GC = false;
-		CacheHolderDetail chd = ch.getCacheDetails(false);
+		final CacheHolderDetail chd = ch.getCacheDetails(false);
 		if (spiderAllFinds) {
 			if (!ch.is_found()) {
 				ch.setFound(true);
@@ -1599,8 +1810,7 @@
 		if (ch.is_found() && chd.OwnLogId.equals("")) {
 			ret = true;
 		} // missing ownLogID
-		boolean is_available_GC = !is_archived_GC
-				&& CacheDescription.indexOf(propAvailable) == -1;
+		final boolean is_available_GC = !is_archived_GC && CacheDescription.indexOf(propAvailable) == -1;
 		if (is_available_GC != ch.is_available()) {
 			ch.setAvailable(is_available_GC);
 			save = true;
@@ -1612,9 +1822,9 @@
 			ret = true;
 		}
 		if (pref.checkDTS) {
-			String dts[]=mString.split(getDTS(CacheDescription),'/');
+			final String dts[] = mString.split(getDTS(CacheDescription), '/');
 			if (dts.length == 3) {
-				if (difficultyChanged(ch,  CacheTerrDiff.v1Converter(dts[0]))) {
+				if (difficultyChanged(ch, CacheTerrDiff.v1Converter(dts[0]))) {
 					save = true;
 					ret = true;
 					pref.log("difficultyChanged");
@@ -1629,12 +1839,11 @@
 					ret = true;
 					pref.log("sizeChanged");
 				}
-			}
-			else {
+			} else {
 				pref.log("check DTS calculation", null);
 			}
 		}
-		if (newFoundExists(ch,  CacheDescription)) {
+		if (newFoundExists(ch, CacheDescription)) {
 			numLogUpdates++;
 			ret = true;
 		}
@@ -1658,8 +1867,7 @@
 		if (RexNumFinds.didMatch()) {
 			return Common.parseInt(RexNumFinds.stringMatched(1));
 		} else {
-			pref.log("check RexNumFinds in SpiderGC.java / initialiseProperties" 
-					+ Preferences.NEWLINE + doc);
+			pref.log("check RexNumFinds in SpiderGC.java / initialiseProperties" + Preferences.NEWLINE + doc);
 			return 0;
 		}
 	}
@@ -1676,53 +1884,58 @@
 		}
 		return counter;
 	}
-	
+
 	private String decodeXor(String input, String key) {
-	  byte ctmp[] = input.getBytes();
-		byte ckey[] = key.getBytes();
-		int codeLength = input.length();
-		int keyLength = key.length();
-		for (int i=0; i<codeLength; i++) {
-		  ctmp[i]^=ckey[i%keyLength];
-    }
+		final byte ctmp[] = input.getBytes();
+		final byte ckey[] = key.getBytes();
+		final int codeLength = input.length();
+		final int keyLength = key.length();
+		for (int i = 0; i < codeLength; i++) {
+			ctmp[i] ^= ckey[i % keyLength];
+		}
 		return new String(ctmp);
-  }
+	}
+
 	private double[] getDistanceAndDirection(String doc) {
-		double[] distanceAndDirection={(0.0),(0.0)};
-		if (spiderAllFinds) return distanceAndDirection;
+		final double[] distanceAndDirection = { (0.0), (0.0) };
+		if (spiderAllFinds)
+			return distanceAndDirection;
 		RexPropDistanceCode.search(doc);
 		if (!RexPropDistanceCode.didMatch()) {
 			pref.log("check distRex" + Preferences.NEWLINE + doc);
-			distanceAndDirection[0]=-1.0; // Abbruch
+			distanceAndDirection[0] = -1.0; // Abbruch
 			return distanceAndDirection;
 		}
-		String stmp = ewe.net.URL.decodeURL(RexPropDistanceCode.stringMatched(1));
-		String ret = decodeXor( stmp, DistanceCodeKey).replace('|', ' ');
-		RexPropDistance.search(ret); // km oder mi oder ft		
+		final String stmp = ewe.net.URL.decodeURL(RexPropDistanceCode.stringMatched(1));
+		String ret = decodeXor(stmp, DistanceCodeKey).replace('|', ' ');
+		RexPropDistance.search(ret); // km oder mi oder ft
 		if (!RexPropDistance.didMatch()) {
-			if (ret.indexOf("ere") > -1) return distanceAndDirection; // zur Zeit " Here -1"
+			if (ret.indexOf("ere") > -1)
+				return distanceAndDirection; // zur Zeit " Here -1"
 			// Versuch den DistanceCodeKey automatisch zu bestimmen
 			// da dieser von gc mal wieder ge?ndert wurde.
-			// todo Ben?tigt ev noch weitere Anpassungen: | am Anfang, and calc of keylength
+			// todo Ben?tigt ev noch weitere Anpassungen: | am Anfang, and calc
+			// of keylength
 
 			// String thereitis="|0.34 km|102.698";
-			// String page = fetchText("http://www.geocaching.com/seek/nearest.aspx?lat=48.48973&lng=009.26313&dist=2&f=1",false);
-			String thereitis="|0.08 km|223.968";
+			// String page =
+			// fetchText("http://www.geocaching.com/seek/nearest.aspx?lat=48.48973&lng=009.26313&dist=2&f=1",false);
+			final String thereitis = "|0.08 km|223.968";
 			String page;
 			try {
-				page = UrlFetcher.fetch("http://www.geocaching.com/seek/nearest.aspx?lat=45.29152&lng=-122.41262&dist=1");
-			} catch (IOException e) {
-				page="";
+				page = UrlFetcher.fetch("http://www.geocaching.com/seek/nearest.aspx?lat=45.292&lng=-122.41262&dist=1");
+			} catch (final IOException e) {
+				page = "";
 			}
-			//  
+			//
 			RexPropListBlock.search(page);
-			String table="";
+			String table = "";
 			if (RexPropListBlock.didMatch()) {
 				table = RexPropListBlock.stringMatched(1);
 			}
-			
+
 			RexPropLine.search(table);
-			String row="";
+			String row = "";
 			if (RexPropLine.didMatch()) {
 				row = RexPropLine.stringMatched(1);
 			}
@@ -1732,11 +1945,12 @@
 				pref.log("Didn't get DistanceCodeKey automaticly." + Preferences.NEWLINE);
 				return distanceAndDirection;
 			}
-			String coded = ewe.net.URL.decodeURL(RexPropDistanceCode.stringMatched(1));
-			String newkey=decodeXor(coded,thereitis);
-			int keylength=13; // wenn nicht 13 dann newkey auf wiederholung pr?fen
-			DistanceCodeKey=newkey.substring(0, keylength);
-			ret = decodeXor( stmp, DistanceCodeKey).replace('|', ' ');
+			final String coded = ewe.net.URL.decodeURL(RexPropDistanceCode.stringMatched(1));
+			final String newkey = decodeXor(coded, thereitis);
+			final int keylength = 13; // wenn nicht 13 dann newkey auf
+										// wiederholung pr?fen
+			DistanceCodeKey = newkey.substring(0, keylength);
+			ret = decodeXor(stmp, DistanceCodeKey).replace('|', ' ');
 			pref.log("Automatic key: " + DistanceCodeKey + " result: " + ret + Preferences.NEWLINE);
 			RexPropDistance.search(ret); // km oder mi
 		}
@@ -1744,23 +1958,31 @@
 		if (RexPropDistance.didMatch()) {
 			if (MyLocale.getDigSeparator().equals(",")) {
 				distanceAndDirection[0] = Convert.toDouble(RexPropDistance.stringMatched(1).replace('.', ','));
-				String r = RexPropDistance.right(1).substring(3);  //3 expexts 2 char which are at moment "km" or "mi"
+				final String r = RexPropDistance.right(1).substring(3); // 3
+																		// expexts
+																		// 2
+																		// char
+																		// which
+																		// are
+																		// at
+																		// moment
+																		// "km"
+																		// or
+																		// "mi"
 				distanceAndDirection[1] = Convert.toDouble(r.replace('.', ','));
-			}
-			else {
-				distanceAndDirection[0] =  Convert.toDouble(RexPropDistance.stringMatched(1));
-				String r = RexPropDistance.right(1).substring(3);
+			} else {
+				distanceAndDirection[0] = Convert.toDouble(RexPropDistance.stringMatched(1));
+				final String r = RexPropDistance.right(1).substring(3);
 				distanceAndDirection[1] = Convert.toDouble(r);
 			}
-			if (ret.indexOf("ft")>0) {
+			if (ret.indexOf("ft") > 0) {
 				// Umrechnung in miles
-				distanceAndDirection[0]=distanceAndDirection[0] / 5280.0;				
+				distanceAndDirection[0] = distanceAndDirection[0] / 5280.0;
 			}
-		}
-		else {
+		} else {
 			pref.log("(gc Code change ?) check distCodeKey in spider.def" + Preferences.NEWLINE + doc);
 		}
-		
+
 		return distanceAndDirection;
 	}
 
@@ -1791,7 +2013,7 @@
 		} else {
 			numPrivate = numPrivate + 1;
 			if (spiderAllFinds) {
-				pref.log(chWaypoint+" is private.",null);
+				pref.log(chWaypoint + " is private.", null);
 			}
 			return false;
 		}
@@ -1818,169 +2040,79 @@
 		pref.log("check TypeRex in spider.def" + Preferences.NEWLINE + toCheck);
 		return false;
 	}
-	
+
 	private String getDTS(String toCheck) {
 		RexPropDTS.search(toCheck);
 		if (RexPropDTS.didMatch()) {
-			String code=RexPropDTS.stringMatched(1);
+			final String code = RexPropDTS.stringMatched(1);
 			/* */
-			String address = "http://www.geocaching.com/ImgGen/seek/CacheInfo.ashx?v="+code;
+			final String address = "http://www.geocaching.com/ImgGen/seek/CacheInfo.ashx?v=" + code;
 			ByteArray doc;
 			try {
 				doc = UrlFetcher.fetchData(address);
-			} catch (IOException e) {
+			} catch (final IOException e) {
 				return "";
 			}
-			Image idoc = new Image(doc,0,null,0,0);
+			final Image idoc = new Image(doc, 0, null, 0, 0);
 			/*
-			FileOutputStream fos;
-			try {
-				fos = new FileOutputStream(new File("temp.png"));
-				fos.write(doc.toBytes());
-				fos.close();
-			} catch (IOException e) {
-			}
-			finally {
-			}
-			*/
-			String ret = getDTfromImage(idoc) + "/" + getSizeFromImage(idoc);
-			return ret; 
-			//*/
+			 * FileOutputStream fos; try { fos = new FileOutputStream(new File("temp.png")); fos.write(doc.toBytes()); fos.close(); } catch (IOException e) { } finally { }
+			 */
+			final String ret = getDTfromImage(idoc) + "/" + getSizeFromImage(idoc);
+			return ret;
+			// */
 
 			/*
-			int decoded = 0;
-			int pwr = 1;
-			for (int i = code.length()-1 ; i >= 0; i--) {
-				decoded = decoded + DTSCodeKey.indexOf(code.substring(i,i+1)) * pwr;
-				pwr = pwr * 42;
-			}
-			decoded = (decoded - 131586) % 16777216;
-			// size 0=not choosen 1=Micro 3=Regular 5=Large 7=Virtual 8=Unknown 12=Small
-			int sizecode = decoded / 74088; // 42 ^ 3
-			int sizeremove;
-			byte size;
-			switch (sizecode) {
-			case 0: size=CacheSize.CW_SIZE_NOTCHOSEN; sizeremove=0; break;
-			case 1: size=CacheSize.CW_SIZE_MICRO; sizeremove=131072; break;
-			case 3: size=CacheSize.CW_SIZE_REGULAR; sizeremove=262144; break;
-			case 5: size=CacheSize.CW_SIZE_LARGE; sizeremove=393217; break;
-			case 7: size=CacheSize.CW_SIZE_VIRTUAL; sizeremove=524288; break;
-			case 8: size=CacheSize.CW_SIZE_OTHER; sizeremove=655360; break;
-			case 12: size=CacheSize.CW_SIZE_SMALL; sizeremove=917504; break;
-			default: size=CacheSize.CW_SIZE_ERROR; sizeremove=0; break;
-			}
-			decoded = decoded - sizeremove;
-			int terraincode = decoded / 252;
-			// terrain 0=1 1=1.5 2=2 3=2.5 4=3 5=3.5 6=4 7=4.5 8=5
-			String terrain = "" + (1 + terraincode / 2.0 ); 
-			// difficulty 0=1 1=1.5 2=2 3=2.5 4=3 5=3.5 6=4 7=4.5 8=5
-			String difficulty = "" + (1+((decoded % 42) - (terraincode * 4)) / 2.0);
-			if (difficulty.equals("0.5")) {
-				difficulty = "5";
-			}
-			return difficulty+"/"+terrain+"/"+size;
-			*/
+			 * int decoded = 0; int pwr = 1; for (int i = code.length()-1 ; i >= 0; i--) { decoded = decoded + DTSCodeKey.indexOf(code.substring(i,i+1)) * pwr; pwr = pwr * 42; } decoded = (decoded - 1386) % 16777216; // size 0=not choosen 1=Micro
+			 * 3=Regular 5=Large 7=Virtual 8=Unknown 12=Small int sizecode = decoded / 74088; // 42 ^ 3 int sizeremove; byte size; switch (sizecode) { case 0: size=CacheSize.CW_SIZE_NOTCHOSEN; sizeremove=0; break; case 1: size=CacheSize.CW_SIZE_MICRO;
+			 * sizeremove=131072; break; case 3: size=CacheSize.CW_SIZE_REGULAR; sizeremove=262144; break; case 5: size=CacheSize.CW_SIZE_LARGE; sizeremove=393217; break; case 7: size=CacheSize.CW_SIZE_VIRTUAL; sizeremove=524288; break; case 8:
+			 * size=CacheSize.CW_SIZE_OTHER; sizeremove=655360; break; case 12: size=CacheSize.CW_SIZE_SMALL; sizeremove=917504; break; default: size=CacheSize.CW_SIZE_ERROR; sizeremove=0; break; } decoded = decoded - sizeremove; int terraincode =
+			 * decoded / 252; // terrain 0=1 1=1.5 2=2 3=2.5 4=3 5=3.5 6=4 7=4.5 8=5 String terrain = "" + (1 + terraincode / 2.0 ); // difficulty 0=1 1=1.5 2=2 3=2.5 4=3 5=3.5 6=4 7=4.5 8=5 String difficulty = "" + (1+((decoded % 42) - (terraincode *
+			 * 4)) / 2.0); if (difficulty.equals("0.5")) { difficulty = "5"; } return difficulty+"/"+terrain+"/"+size;
+			 */
 		}
 		pref.log("check DTSRex in spider.def" + Preferences.NEWLINE + toCheck);
 		return "";
 	}
 
 	static Hashtable validChars = new Hashtable();
-	
+
 	static {
-		validChars.put(".", new int[][] {
-				{0, 0, 0 },
-				{0, 0, 0 },
-				{0, 0, 0 },
-				{0, 0, 0 },
-				{0, 0, 0 },
-				{0, 0, 0 },
-				{0, 1, 0 },
-				{0, 1, 0 }
-		});
-		validChars.put("/", new int[][] {
-				{0, 0, 0, 0, 1},
-				{0, 0, 0, 1, 0},
-				{0, 0, 0, 1, 0},
-				{0, 0, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{0, 1, 0, 0, 0},
-				{0, 1, 0, 0, 0},
-				{1, 0, 0, 0, 0}
-		});
-		validChars.put("1", new int[][] {
-				{0, 0, 1, 0, 0},
-				{1, 1, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{1, 1, 1, 1, 1}
-		});
-		validChars.put("2", new int[][] {
-				{0, 1, 1, 1, 0},
-				{1, 0, 0, 0, 1},
-				{0, 0, 0, 0, 1},
-				{0, 0, 0, 1, 0},
-				{0, 0, 1, 0, 0},
-				{0, 1, 0, 0, 0},
-				{1, 0, 0, 0, 0},
-				{1, 1, 1, 1, 1}
-		});
-		validChars.put("3", new int[][] {
-				{0, 1, 1, 1, 0},
-				{1, 0, 0, 0, 1},
-				{0, 0, 0, 0, 1},
-				{0, 0, 1, 1, 0},
-				{0, 0, 0, 0, 1},
-				{0, 0, 0, 0, 1},
-				{1, 0, 0, 0, 1},
-				{0, 1, 1, 1, 0}
-		});
-		validChars.put("4", new int[][] {
-				{0, 0, 0, 0, 1, 0},
-				{0, 0, 0, 1, 1, 0},
-				{0, 0, 1, 0, 1, 0},
-				{0, 1, 0, 0, 1, 0},
-				{1, 0, 0, 0, 1, 0},
-				{1, 1, 1, 1, 1, 1},
-				{0, 0, 0, 0, 1, 0},
-				{0, 0, 0, 0, 1, 0}
-		});
-		validChars.put("5", new int[][] {
-				{1, 1, 1, 1, 1},
-				{1, 0, 0, 0, 0},
-				{1, 0, 0, 0, 0},
-				{1, 1, 1, 1, 0},
-				{0, 0, 0, 0, 1},
-				{0, 0, 0, 0, 1},
-				{1, 0, 0, 0, 1},
-				{0, 1, 1, 1, 0}
-		});
+		validChars.put(".", new int[][] { { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 1, 0 }, { 0, 1, 0 } });
+		validChars.put("/", new int[][] { { 0, 0, 0, 0, 1 }, { 0, 0, 0, 1, 0 }, { 0, 0, 0, 1, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 0, 1, 0, 0, 0 }, { 0, 1, 0, 0, 0 }, { 1, 0, 0, 0, 0 } });
+		validChars.put("1", new int[][] { { 0, 0, 1, 0, 0 }, { 1, 1, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 1, 1, 1, 1, 1 } });
+		validChars.put("2", new int[][] { { 0, 1, 1, 1, 0 }, { 1, 0, 0, 0, 1 }, { 0, 0, 0, 0, 1 }, { 0, 0, 0, 1, 0 }, { 0, 0, 1, 0, 0 }, { 0, 1, 0, 0, 0 }, { 1, 0, 0, 0, 0 }, { 1, 1, 1, 1, 1 } });
+		validChars.put("3", new int[][] { { 0, 1, 1, 1, 0 }, { 1, 0, 0, 0, 1 }, { 0, 0, 0, 0, 1 }, { 0, 0, 1, 1, 0 }, { 0, 0, 0, 0, 1 }, { 0, 0, 0, 0, 1 }, { 1, 0, 0, 0, 1 }, { 0, 1, 1, 1, 0 } });
+		validChars.put("4", new int[][] { { 0, 0, 0, 0, 1, 0 }, { 0, 0, 0, 1, 1, 0 }, { 0, 0, 1, 0, 1, 0 }, { 0, 1, 0, 0, 1, 0 }, { 1, 0, 0, 0, 1, 0 }, { 1, 1, 1, 1, 1, 1 }, { 0, 0, 0, 0, 1, 0 }, { 0, 0, 0, 0, 1, 0 } });
+		validChars.put("5", new int[][] { { 1, 1, 1, 1, 1 }, { 1, 0, 0, 0, 0 }, { 1, 0, 0, 0, 0 }, { 1, 1, 1, 1, 0 }, { 0, 0, 0, 0, 1 }, { 0, 0, 0, 0, 1 }, { 1, 0, 0, 0, 1 }, { 0, 1, 1, 1, 0 } });
 	}
 
 	private static byte getSizeFromImage(Image bild) {
 		int[] argb = bild.getPixels(null, 0, 5, 23, 1, 1, 0);
-		if (argb[0] == -7005927) return CacheSize.CW_SIZE_MICRO;
+		if (argb[0] == -7005927)
+			return CacheSize.CW_SIZE_MICRO;
 		argb = bild.getPixels(null, 0, 10, 23, 1, 1, 0);
-		if (argb[0] == -7005927) return CacheSize.CW_SIZE_SMALL;
+		if (argb[0] == -7005927)
+			return CacheSize.CW_SIZE_SMALL;
 		argb = bild.getPixels(null, 0, 17, 23, 1, 1, 0);
-		if (argb[0] == -7005927) return CacheSize.CW_SIZE_REGULAR;
+		if (argb[0] == -7005927)
+			return CacheSize.CW_SIZE_REGULAR;
 		argb = bild.getPixels(null, 0, 26, 23, 1, 1, 0);
-		if (argb[0] == -7005927) return CacheSize.CW_SIZE_LARGE;
+		if (argb[0] == -7005927)
+			return CacheSize.CW_SIZE_LARGE;
 		argb = bild.getPixels(null, 0, 40, 23, 1, 1, 0);
-		if (argb[0] == -6735302) return CacheSize.CW_SIZE_NOTCHOSEN;
+		if (argb[0] == -6735302)
+			return CacheSize.CW_SIZE_NOTCHOSEN;
 		argb = bild.getPixels(null, 0, 41, 24, 1, 1, 0);
-		if (argb[0] == -7005927) return CacheSize.CW_SIZE_OTHER;
+		if (argb[0] == -7005927)
+			return CacheSize.CW_SIZE_OTHER;
 		return CacheSize.CW_SIZE_ERROR;
 	}
 
 	private static String getDTfromImage(Image bild) {
-		StringBuffer sb = new StringBuffer();
+		final StringBuffer sb = new StringBuffer();
 		for (int startX = 0; startX < bild.getWidth(); startX++) {
-			for (Enumeration e = validChars.keys(); e.hasMoreElements();) {
-				String key=(String) e.nextElement();
+			for (final Enumeration e = validChars.keys(); e.hasMoreElements();) {
+				final String key = (String) e.nextElement();
 				if (testValidChar(bild, startX, 4, (int[][]) validChars.get(key))) {
 					sb.append(key);
 				}
@@ -1991,17 +2123,18 @@
 
 	private static boolean testValidChar(Image bild, int startX, int startY, int[][] validChar) {
 		for (int y = 0; y < validChar.length; y++) {
-			if (bild.getHeight() > startY+y) {
+			if (bild.getHeight() > startY + y) {
 				for (int x = 0; x < validChar[0].length; x++) {
-					if (bild.getWidth() > startX+x) {
-						// int[] alpha = bild.getAlphaRaster().getPixel(startX+x, startY+y, new int[1]);
-						int[] argb = bild.getPixels(null, 0, startX+x, startY+y, 1, 1, 0);
-						if ((argb[0] == 0 && validChar[y][x] == 0) ||
-								(argb[0] != 0 && validChar[y][x] > 0)) {
+					if (bild.getWidth() > startX + x) {
+						// int[] alpha =
+						// bild.getAlphaRaster().getPixel(startX+x, startY+y,
+						// new int[1]);
+						final int[] argb = bild.getPixels(null, 0, startX + x, startY + y, 1, 1, 0);
+						if ((argb[0] == 0 && validChar[y][x] == 0) || (argb[0] != 0 && validChar[y][x] > 0)) {
 							// matches
 						} else {
 							return false;
-						} 
+						}
 					} else {
 						return false;
 					}
@@ -2024,6 +2157,7 @@
 			return true;
 		}
 	}
+
 	/*
 	 * check for changed Terrain
 	 */
@@ -2035,6 +2169,7 @@
 			return true;
 		}
 	}
+
 	/*
 	 * check for changed CacheSize
 	 */
@@ -2053,18 +2188,21 @@
 	private boolean directionOK(String[] directions, double toCheck) {
 		if (directions == null || directions.length == 0)
 			return true; // nothing means all
-		int lowerLimit = Common.parseInt(directions[0]);
-		int upperLimit = Common.parseInt(directions[1]);
+		final int lowerLimit = Common.parseInt(directions[0]);
+		final int upperLimit = Common.parseInt(directions[1]);
 		if (lowerLimit <= upperLimit) {
-			if ((toCheck>=lowerLimit) && (toCheck<=upperLimit))
-			{return true;}
-			else {return false;}
+			if ((toCheck >= lowerLimit) && (toCheck <= upperLimit)) {
+				return true;
+			} else {
+				return false;
+			}
+		} else {
+			if ((toCheck >= lowerLimit) || (toCheck <= upperLimit)) {
+				return true;
+			} else {
+				return false;
+			}
 		}
-		else {
-			if ((toCheck>=lowerLimit) || (toCheck<=upperLimit))
-			{return true;}
-			else {return false;}
-		}
 	}
 
 	/*
@@ -2075,18 +2213,18 @@
 	 * @return boolean newLogExists
 	 */
 	private boolean newFoundExists(CacheHolder ch, String cacheDescription) {
-		if (!pref.checkLog || pref.maxLogsToSpider==0)
+		if (!pref.checkLog || pref.maxLogsToSpider == 0)
 			return false;
-		Time lastLogCW = new Time();
-		Log lastLog = ch.getCacheDetails(true).CacheLogs.getLog(0);
+		final Time lastLogCW = new Time();
+		final Log lastLog = ch.getCacheDetails(true).CacheLogs.getLog(0);
 		if (lastLog == null)
 			return true;
-		String slastLogCW = lastLog.getDate();
+		final String slastLogCW = lastLog.getDate();
 		if (slastLogCW.equals("") || slastLogCW.equals("1900-00-00"))
 			return true; // or check cacheDescGC also no log?
 		lastLogCW.parse(slastLogCW, "yyyy-MM-dd");
 
-		Time lastLogGC = new Time(); // is current time
+		final Time lastLogGC = new Time(); // is current time
 		lastLogGC.hour = 0;
 		lastLogGC.minute = 0;
 		lastLogGC.second = 0;
@@ -2102,13 +2240,11 @@
 		}
 		if (stmp.indexOf("day") > 0) {
 			// simplyfied (update if not newer than last week)
-			lastLogGC.setTime(lastLogGC.getTime() - 691200000L); 
+			lastLogGC.setTime(lastLogGC.getTime() - 691200000L);
 		} else if (stmp.equals("")) {
 			return false; // no log yet
 		} else {
-			final String monthNames[] = { "January", "February", "March",
-					"April", "May", "June", "July", "August", "September",
-					"October", "November", "December" };
+			final String monthNames[] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
 			SDate = mString.split(stmp, ' ');
 			lastLogGC.day = Common.parseInt(SDate[0]);
 			for (int m = 0; m < 12; m++) {
@@ -2119,57 +2255,44 @@
 			}
 			lastLogGC.year = 2000 + Common.parseInt(SDate[2].substring(0, 2));
 		}
-		boolean ret = lastLogCW.compareTo(lastLogGC) < 0;
+		final boolean ret = lastLogCW.compareTo(lastLogGC) < 0;
 		return ret;
 	}
+
 	private boolean TBchanged(CacheHolder ch, String cacheDescription) {
-		// simplified Version: only presence is checked 
-		if (pref.downloadTBs && pref.checkTBs ) {
-			boolean hasTB=cacheDescription.indexOf("data-tbcount") > -1;
+		// simplified Version: only presence is checked
+		if (pref.downloadTBs && pref.checkTBs) {
+			final boolean hasTB = cacheDescription.indexOf("data-tbcount") > -1;
 			return ch.has_bugs() != (hasTB);
 		}
 		return false;
 	}
 
 	/**
-	 * Read a complete cachepage from geocaching.com including all logs. This is
-	 * used both when updating already existing caches (via spiderSingle) and
-	 * when spidering around a centre. It is also used when reading a GPX file
-	 * and fetching the images.
+	 * Read a complete cachepage from geocaching.com including all logs. This is used both when updating already existing caches (via spiderSingle) and when spidering around a centre. It is also used when reading a GPX file and fetching the images.
 	 * 
 	 * This is the workhorse function of the spider.
 	 * 
 	 * @param CacheHolderDetail
 	 *            chD The element wayPoint must be set to the name of a waypoint
-	 * @param boolean isUpdate True if an existing cache is being updated, false
-	 *        if it is a new cache
+	 * @param boolean isUpdate True if an existing cache is being updated, false if it is a new cache
 	 * @param boolean fetchImages True if the pictures are to be fetched
 	 * @param boolean fetchTBs True if the TBs are to be fetched
-	 * @param boolean doNotGetFound True if the cache is not to be spidered if
-	 *        it has already been found
-	 * @param boolean fetchAllLogs True if all logs are to be fetched (by adding
-	 *        option '&logs=y' to command line). This is normally false when
-	 *        spidering from GPXImport as the logs are part of the GPX file, and
-	 *        true otherwise
-	 * @return -1 if the infoBox was closed (cancel spidering), 0 if there was
-	 *         an error (continue with next cache), 1 if everything ok
+	 * @param boolean doNotGetFound True if the cache is not to be spidered if it has already been found
+	 * @param boolean fetchAllLogs True if all logs are to be fetched (by adding option '&logs=y' to command line). This is normally false when spidering from GPXImport as the logs are part of the GPX file, and true otherwise
+	 * @return -1 if the infoBox was closed (cancel spidering), 0 if there was an error (continue with next cache), 1 if everything ok
 	 */
-	private int getCacheByWaypointName(CacheHolder ch, boolean isUpdate,
-			boolean fetchImages, boolean fetchTBs, boolean doNotGetFound,
-			boolean fetchAllLogs) {
+	private int getCacheByWaypointName(CacheHolder ch, boolean isUpdate, boolean fetchImages, boolean fetchTBs, boolean doNotGetFound, boolean fetchAllLogs) {
 		int ret = SPIDER_OK; // initialize value;
 		while (true) { // retry even if failure
 			pref.log(""); // new line for more overview
 			String completeWebPage;
 			int spiderTrys = 0;
-			int MAX_SPIDER_TRYS = 3;
+			final int MAX_SPIDER_TRYS = 3;
 			while (spiderTrys++ < MAX_SPIDER_TRYS) {
 				ret = SPIDER_OK; // initialize value;
 				try {
-					String doc = p.getProp("getPageByName")
-							+ ch.getWayPoint()
-							+ ((fetchAllLogs || ch.is_found()) ? p
-									.getProp("fetchAllLogs") : "");
+					final String doc = p.getProp("getPageByName") + ch.getWayPoint() + ((fetchAllLogs || ch.is_found()) ? p.getProp("fetchAllLogs") : "");
 					completeWebPage = UrlFetcher.fetch(doc);
 					pref.log("Fetched: " + ch.getWayPoint());
 					if (completeWebPage.equals("")) {
@@ -2181,7 +2304,7 @@
 							return SPIDER_CANCEL;
 						}
 					}
-				} catch (Exception ex) {
+				} catch (final Exception ex) {
 					pref.log("Could not fetch " + ch.getWayPoint(), ex);
 					if (!infB.isClosed) {
 						continue;
@@ -2198,7 +2321,7 @@
 
 						// first check if coordinates are available to prevent
 						// deleting existing coordinates
-						String latLon = getLatLon(completeWebPage);
+						final String latLon = getLatLon(completeWebPage);
 						if (latLon.equals("???")) {
 							if (completeWebPage.indexOf(p.getProp("premiumCachepage")) > 0) {
 								// Premium cache spidered by non premium member
@@ -2223,10 +2346,8 @@
 						ch.addiWpts.clear();
 						ch.getCacheDetails(false).images.clear();
 
-						ch.setAvailable(!(completeWebPage.indexOf(p
-								.getProp("cacheUnavailable")) >= 0));
-						ch.setArchived(completeWebPage.indexOf(p
-								.getProp("cacheArchived")) >= 0);
+						ch.setAvailable(!(completeWebPage.indexOf(p.getProp("cacheUnavailable")) >= 0));
+						ch.setArchived(completeWebPage.indexOf(p.getProp("cacheArchived")) >= 0);
 						// ==========
 						// Logs first (for check early for break)
 						// ==========
@@ -2247,27 +2368,21 @@
 						ch.setLatLon(latLon);
 						pref.log("LatLon: " + ch.getLatLon());
 
-						String longDesc = getLongDesc(completeWebPage);
+						final String longDesc = getLongDesc(completeWebPage);
 						ch.getCacheDetails(false).setLongDescription(longDesc);
 						pref.log("Got description");
 
-						ch.setCacheName(SafeXML
-								.cleanback(getName(completeWebPage)));
+						ch.setCacheName(SafeXML.cleanback(getName(completeWebPage)));
 						pref.log("Name: " + ch.getCacheName());
 
-						String location = getLocation(completeWebPage);
+						final String location = getLocation(completeWebPage);
 						if (location.length() != 0) {
-							int countryStart = location.indexOf(",");
+							final int countryStart = location.indexOf(",");
 							if (countryStart > -1) {
-								ch.getCacheDetails(false).Country = SafeXML
-										.cleanback(location.substring(
-												countryStart + 1).trim());
-								ch.getCacheDetails(false).State = SafeXML
-										.cleanback(location.substring(0,
-												countryStart).trim());
+								ch.getCacheDetails(false).Country = SafeXML.cleanback(location.substring(countryStart + 1).trim());
+								ch.getCacheDetails(false).State = SafeXML.cleanback(location.substring(0, countryStart).trim());
 							} else {
-								ch.getCacheDetails(false).Country = location
-										.trim();
+								ch.getCacheDetails(false).Country = location.trim();
 								ch.getCacheDetails(false).State = "";
 							}
 							pref.log("Got location (country/state)");
@@ -2279,31 +2394,23 @@
 						String owner = getOwner(completeWebPage);
 						owner = SafeXML.cleanback(owner).trim();
 						ch.setCacheOwner(owner);
-						if (ch.getCacheOwner().equals(pref.myAlias)
-							|| (pref.myAlias2.length() > 0 && ch.getCacheOwner().equals(pref.myAlias2)))
+						if (ch.getCacheOwner().equals(pref.myAlias) || (pref.myAlias2.length() > 0 && ch.getCacheOwner().equals(pref.myAlias2)))
 							ch.setOwned(true);
-						pref.log("Owner: " + ch.getCacheOwner()
-								+ "; is_owned = " + ch.is_owned()
-								+ ";  alias1,2 = [" + pref.myAlias + "|"
-								+ pref.myAlias2 + "]");
+						pref.log("Owner: " + ch.getCacheOwner() + "; is_owned = " + ch.is_owned() + ";  alias1,2 = [" + pref.myAlias + "|" + pref.myAlias2 + "]");
 
-						ch.setDateHidden(DateFormat
-								.MDY2YMD(getDateHidden(completeWebPage)));
+						ch.setDateHidden(DateFormat.MDY2YMD(getDateHidden(completeWebPage)));
 						pref.log("Hidden: " + ch.getDateHidden());
 
-						ch.getCacheDetails(false).setHints(
-								getHints(completeWebPage));
+						ch.getCacheDetails(false).setHints(getHints(completeWebPage));
 						pref.log("Hints: " + ch.getCacheDetails(false).Hints);
 
-						ch.setCacheSize(CacheSize
-								.gcSpiderString2Cw(getSize(completeWebPage)));
+						ch.setCacheSize(CacheSize.gcSpiderString2Cw(getSize(completeWebPage)));
 						pref.log("Size: " + ch.getCacheSize());
 
 						ch.setHard(CacheTerrDiff.v1Converter(getDiff(completeWebPage)));
 						pref.log("Hard: " + ch.getHard());
 
-						ch.setTerrain(CacheTerrDiff
-								.v1Converter(getTerr(completeWebPage)));
+						ch.setTerrain(CacheTerrDiff.v1Converter(getTerr(completeWebPage)));
 						pref.log("Terr: " + ch.getTerrain());
 
 						ch.setType(getType(completeWebPage));
@@ -2313,27 +2420,24 @@
 						// ==========
 						if (fetchTBs)
 							getBugs(ch.getCacheDetails(false), completeWebPage);
-						ch.setHas_bugs(ch.getCacheDetails(false).Travelbugs
-								.size() > 0);
+						ch.setHas_bugs(ch.getCacheDetails(false).Travelbugs.size() > 0);
 						pref.log("Got TBs");
 						// ==========
 						// Images
 						// ==========
 						if (fetchImages) {
-							getImages(completeWebPage, ch.getCacheDetails(false),true);
+							getImages(completeWebPage, ch.getCacheDetails(false), true);
 							pref.log("Got images");
 						}
 						// ==========
 						// Addi waypoints
 						// ==========
-						getAddWaypoints(completeWebPage, ch.getWayPoint(), ch
-								.is_found());
+						getAddWaypoints(completeWebPage, ch.getWayPoint(), ch.is_found());
 						pref.log("Got additional waypoints");
 						// ==========
 						// Attributes
 						// ==========
-						getAttributes(completeWebPage, ch
-								.getCacheDetails(false));
+						getAttributes(completeWebPage, ch.getCacheDetails(false));
 						pref.log("Got attributes");
 						// ==========
 						// Last sync date
@@ -2342,7 +2446,7 @@
 						ch.setIncomplete(false);
 						pref.log("ready " + ch.getWayPoint() + " : " + ch.getLastSync());
 						break;
-					} catch (Exception ex) {
+					} catch (final Exception ex) {
 						pref.log("[getCacheByWaypointName: ]Error reading cache: " + ch.getWayPoint(), ex);
 					}
 				} else {
@@ -2351,10 +2455,7 @@
 			} // spiderTrys
 			if ((spiderTrys >= MAX_SPIDER_TRYS) && (ret == SPIDER_OK)) {
 				pref.log(">>> Failed to spider cache. Number of retrys exhausted.", null);
-				int decision = (new MessageBox(MyLocale.getMsg(5500, "Error"),
-						MyLocale.getMsg(5515,"Failed to load cache.%0aPleas check your internet connection.%0aRetry?"),
-						FormBase.DEFOKB | FormBase.NOB | FormBase.CANCELB))
-						.execute();
+				final int decision = (new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(55, "Failed to load cache.%0aPleas check your internet connection.%0aRetry?"), FormBase.DEFOKB | FormBase.NOB | FormBase.CANCELB)).execute();
 				if (decision == FormBase.IDOK) {
 					continue; // retry even if failure
 				} else if (decision == FormBase.IDNO) {
@@ -2380,11 +2481,10 @@
 	 * @return Cache coordinates
 	 */
 	private String getLatLon(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp("latLonRex"));
+		final Regex inRex = new Regex(p.getProp("latLonRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log("check latLonRex in spider.def" 
-					+ Preferences.NEWLINE + doc);
+			pref.log("check latLonRex in spider.def" + Preferences.NEWLINE + doc);
 			return "???";
 		}
 		return inRex.stringMatched(1);
@@ -2401,13 +2501,13 @@
 	 */
 	private String getLongDesc(String doc) throws Exception {
 		String res = "";
-		Regex shortDescRex = new Regex(p.getProp("shortDescRex"));
-		Regex longDescRex = new Regex(p.getProp("longDescRex"));
+		final Regex shortDescRex = new Regex(p.getProp("shortDescRex"));
+		final Regex longDescRex = new Regex(p.getProp("longDescRex"));
 		shortDescRex.search(doc);
 		if (!shortDescRex.didMatch()) {
 			if (shortDescRex_not_yet_found)
 				pref.log("no shortDesc or check shortDescRex in spider.def");
-				//		+ Preferences.NEWLINE + doc);
+			// + Preferences.NEWLINE + doc);
 		} else {
 			res = shortDescRex.stringMatched(1);
 			shortDescRex_not_yet_found = false;
@@ -2415,12 +2515,11 @@
 		res += "<br>";
 		longDescRex.search(doc);
 		if (!longDescRex.didMatch()) {
-			pref.log("check longDescRex in spider.def" 
-					+ Preferences.NEWLINE + doc);
+			pref.log("check longDescRex in spider.def" + Preferences.NEWLINE + doc);
 		} else {
 			res += longDescRex.stringMatched(1);
 		}
-		int spanEnd = res.lastIndexOf("</span>");
+		final int spanEnd = res.lastIndexOf("</span>");
 		if (spanEnd >= 0) {
 			res = res.substring(0, spanEnd);
 		}
@@ -2437,11 +2536,10 @@
 	 * @return the location (country and state) of the cache
 	 */
 	private String getLocation(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp("cacheLocationRex"));
+		final Regex inRex = new Regex(p.getProp("cacheLocationRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log("check cacheLocationRex in spider.def"
-					+ Preferences.NEWLINE + doc);
+			pref.log("check cacheLocationRex in spider.def" + Preferences.NEWLINE + doc);
 			return "";
 		}
 		return inRex.stringMatched(1);
@@ -2455,11 +2553,10 @@
 	 * @return the name of the cache
 	 */
 	private String getName(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp("cacheNameRex"));
+		final Regex inRex = new Regex(p.getProp("cacheNameRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log("check cacheNameRex in spider.def" 
-					+ Preferences.NEWLINE + doc);
+			pref.log("check cacheNameRex in spider.def" + Preferences.NEWLINE + doc);
 			return "???";
 		}
 		return inRex.stringMatched(1);
@@ -2473,11 +2570,10 @@
 	 * @return the cache owner
 	 */
 	private String getOwner(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp("cacheOwnerRex"));
+		final Regex inRex = new Regex(p.getProp("cacheOwnerRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log("check cacheOwnerRex in spider.def" 
-					+ Preferences.NEWLINE + doc);
+			pref.log("check cacheOwnerRex in spider.def" + Preferences.NEWLINE + doc);
 			return "???";
 		}
 		return inRex.stringMatched(1);
@@ -2491,11 +2587,10 @@
 	 * @return Hidden date
 	 */
 	private String getDateHidden(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp("dateHiddenRex"));
+		final Regex inRex = new Regex(p.getProp("dateHiddenRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log("check dateHiddenRex in spider.def" 
-					+ Preferences.NEWLINE + doc);
+			pref.log("check dateHiddenRex in spider.def" + Preferences.NEWLINE + doc);
 			return "???";
 		}
 		return inRex.stringMatched(1);
@@ -2509,11 +2604,10 @@
 	 * @return Cachehints
 	 */
 	private String getHints(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp("hintsRex"));
+		final Regex inRex = new Regex(p.getProp("hintsRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log("check hintsRex in spider.def"
-					+ Preferences.NEWLINE + doc);
+			pref.log("check hintsRex in spider.def" + Preferences.NEWLINE + doc);
 			return "";
 		}
 		return inRex.stringMatched(1);
@@ -2527,13 +2621,12 @@
 	 * @return Cache size
 	 */
 	private String getSize(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp("sizeRex"));
+		final Regex inRex = new Regex(p.getProp("sizeRex"));
 		inRex.search(doc);
 		if (inRex.didMatch())
 			return inRex.stringMatched(1);
 		else {
-			pref.log("check sizeRex in spider.def"
-					+ Preferences.NEWLINE + doc);
+			pref.log("check sizeRex in spider.def" + Preferences.NEWLINE + doc);
 			return "None";
 		}
 	}
@@ -2546,13 +2639,12 @@
 	 * @return The cache difficulty
 	 */
 	private String getDiff(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp("difficultyRex"));
+		final Regex inRex = new Regex(p.getProp("difficultyRex"));
 		inRex.search(doc);
 		if (inRex.didMatch())
 			return inRex.stringMatched(1);
 		else {
-			pref.log("check difficultyRex in spider.def" 
-					+ Preferences.NEWLINE + doc);
+			pref.log("check difficultyRex in spider.def" + Preferences.NEWLINE + doc);
 			return "-1";
 		}
 	}
@@ -2565,13 +2657,12 @@
 	 * @return Terrain rating
 	 */
 	private String getTerr(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp("terrainRex"));
+		final Regex inRex = new Regex(p.getProp("terrainRex"));
 		inRex.search(doc);
 		if (inRex.didMatch())
 			return inRex.stringMatched(1);
 		else {
-			pref.log("check terrainRex in spider.def" 
-					+ Preferences.NEWLINE + doc);
+			pref.log("check terrainRex in spider.def" + Preferences.NEWLINE + doc);
 			return "-1";
 		}
 	}
@@ -2588,8 +2679,7 @@
 		if (RexCacheType.didMatch())
 			return CacheType.gcSpider2CwType(RexCacheType.stringMatched(1));
 		else {
-			pref.log("check cacheTypeRex in spider.def" 
-					+ Preferences.NEWLINE + doc);
+			pref.log("check cacheTypeRex in spider.def" + Preferences.NEWLINE + doc);
 			return 0;
 		}
 	}
@@ -2603,19 +2693,18 @@
 	 *            Cache Details
 	 * @return A HTML string containing the logs
 	 */
-	private void getLogs(String completeWebPage, CacheHolderDetail chD)
-			throws Exception {
+	private void getLogs(String completeWebPage, CacheHolderDetail chD) throws Exception {
 		String icon = "";
 		String name = "";
 		String logText = "";
 		String logId = "";
 		String singleLog = "";
-		LogList reslts = chD.CacheLogs;
+		final LogList reslts = chD.CacheLogs;
 		RexLogBlock.search(completeWebPage);
 		if (!RexLogBlock.didMatch()) {
 			pref.log("check blockRex in spider.def" + Preferences.NEWLINE + completeWebPage);
 		}
-		String LogBlock = RexLogBlock.stringMatched(1);
+		final String LogBlock = RexLogBlock.stringMatched(1);
 		exSingleLog.setSource(LogBlock);
 		singleLog = exSingleLog.findNext();
 		exIcon.setSource(singleLog);
@@ -2630,18 +2719,19 @@
 			// pref.log(singleLog);
 			nLogs++;
 			icon = exIcon.findNext();
-			icon=icon.substring(0, icon.length() - 1); // ' changes to " in UMTS-connection! first char in iconExEnd.
+			icon = icon.substring(0, icon.length() - 1); // ' changes to " in
+															// UMTS-connection!
+															// first char in
+															// iconExEnd.
 			name = exName.findNext();
 			logText = exLog.findNext();
-			logText = correctSmilies (logText);
+			logText = correctSmilies(logText);
 			logId = exLogId.findNext();
-			String ed=exDate.findNext();
-			String d = DateFormat.logdate2YMD(ed);
+			final String ed = exDate.findNext();
+			final String d = DateFormat.logdate2YMD(ed);
 			// pref.log("Lognr:"+nLogs+"|"+icon+"|"+name+"-|-"+SafeXML.clean(pref.myAlias)+"|"+logId,null);
 			// if this log says this Cache is found by me
-			if ((icon.equals(icon_smile) || icon.equals(icon_camera) || icon.equals(icon_attended))	&&
-					(name.equalsIgnoreCase(SafeXML.clean(pref.myAlias)) ||
-					( pref.myAlias2.length() > 0 && name.equalsIgnoreCase(SafeXML.clean(pref.myAlias2))))) {
+			if ((icon.equals(icon_smile) || icon.equals(icon_camera) || icon.equals(icon_attended)) && (name.equalsIgnoreCase(SafeXML.clean(pref.myAlias)) || (pref.myAlias2.length() > 0 && name.equalsIgnoreCase(SafeXML.clean(pref.myAlias2))))) {
 				chD.getParent().setFound(true);
 				chD.getParent().setCacheStatus(d);
 				chD.OwnLogId = logId;
@@ -2674,14 +2764,15 @@
 
 	/**
 	 * This methods cleans up the path for inlined smilies in logtexts.
+	 * 
 	 * @param logText
 	 * @return
 	 */
 	private String correctSmilies(String logText) {
 		int indexOf = logText.indexOf(string);
 		while (indexOf >= 0) {
-			String prefix = logText.substring(0, indexOf);
-			String postFix = logText.substring(indexOf + string.length());
+			final String prefix = logText.substring(0, indexOf);
+			final String postFix = logText.substring(indexOf + string.length());
 			logText = prefix + "<img src=\"" + postFix;
 			indexOf = logText.indexOf(string);
 		}
@@ -2689,59 +2780,41 @@
 	}
 
 	/**
-	 * Read the travelbug names from a previously fetched Cache page and then
-	 * read the travelbug purpose for each travelbug
+	 * Read the travelbug names from a previously fetched Cache page and then read the travelbug purpose for each travelbug
 	 * 
 	 * @param doc
 	 *            The previously fetched cachepage
 	 * @return A HTML formatted string with bug names and there purpose
 	 */
 	public void getBugs(CacheHolderDetail chD, String doc) throws Exception {
-		Extractor exBlock = new Extractor(doc, 
-				p.getProp("blockExStart"), 
-				p.getProp("blockExEnd"), 
-				0, Extractor.EXCLUDESTARTEND);
-		String bugBlock = exBlock.findNext();
-		Extractor exBug = new Extractor(bugBlock, 
-				p.getProp("bugExStart"), 
-				p.getProp("bugExEnd"), 
-				0, Extractor.EXCLUDESTARTEND);
+		final Extractor exBlock = new Extractor(doc, p.getProp("blockExStart"), p.getProp("blockExEnd"), 0, Extractor.EXCLUDESTARTEND);
+		final String bugBlock = exBlock.findNext();
+		final Extractor exBug = new Extractor(bugBlock, p.getProp("bugExStart"), p.getProp("bugExEnd"), 0, Extractor.EXCLUDESTARTEND);
 		String link, bug, linkPlusBug, bugDetails;
-		String oldInfoBox = infB.getInfo();
+		final String oldInfoBox = infB.getInfo();
 		chD.Travelbugs.clear();
 		while (!exBug.endOfSearch()) {
 			if (infB.isClosed)
 				break; // Allow user to cancel by closing progress form
 			linkPlusBug = exBug.findNext();
-			int idx = linkPlusBug.indexOf(p.getProp("bugLinkEnd"));
+			final int idx = linkPlusBug.indexOf(p.getProp("bugLinkEnd"));
 			if (idx < 0)
 				break; // No link/bug pair found
 			link = linkPlusBug.substring(0, idx);
-			Extractor exBugName = new Extractor(linkPlusBug, 
-					p.getProp("bugNameExStart"), 
-					p.getProp("bugNameExEnd"), 
-					0, Extractor.EXCLUDESTARTEND);
+			final Extractor exBugName = new Extractor(linkPlusBug, p.getProp("bugNameExStart"), p.getProp("bugNameExEnd"), 0, Extractor.EXCLUDESTARTEND);
 			bug = exBugName.findNext();
 			if (bug.length() > 0) { // Found a bug, get its details
-				Travelbug tb = new Travelbug(bug);
+				final Travelbug tb = new Travelbug(bug);
 				try {
-					infB.setInfo(oldInfoBox
-							+ MyLocale.getMsg(5514, "\nGetting bug: ")
-							+ SafeXML.cleanback(bug));
+					infB.setInfo(oldInfoBox + MyLocale.getMsg(5514, "\nGetting bug: ") + SafeXML.cleanback(bug));
 					bugDetails = UrlFetcher.fetch(link);
 					pref.log("[getBugs] Fetched TB details: " + bug);
-					Extractor exDetails = new Extractor(bugDetails, p
-							.getProp("bugDetailsStart"), p
-							.getProp("bugDetailsEnd"),
-							0, Extractor.EXCLUDESTARTEND);
+					final Extractor exDetails = new Extractor(bugDetails, p.getProp("bugDetailsStart"), p.getProp("bugDetailsEnd"), 0, Extractor.EXCLUDESTARTEND);
 					tb.setMission(exDetails.findNext());
-					Extractor exGuid = new Extractor(bugDetails,
-							"action=\"details.aspx?guid=",
-							"\" id=\"aspnetForm",
-							0, Extractor.EXCLUDESTARTEND);
+					final Extractor exGuid = new Extractor(bugDetails, "action=\"details.aspx?guid=", "\" id=\"aspnetForm", 0, Extractor.EXCLUDESTARTEND);
 					tb.setGuid(exGuid.findNext());
 					chD.Travelbugs.add(tb);
-				} catch (Exception ex) {
+				} catch (final Exception ex) {
 					pref.log("[getBugs] Could not fetch bug details", ex);
 				}
 			}
@@ -2750,9 +2823,7 @@
 	}
 
 	/**
-	 * Get the images for a previously fetched cache page. Images are extracted
-	 * from two areas: The long description and the pictures section (including
-	 * the spoiler)
+	 * Get the images for a previously fetched cache page. Images are extracted from two areas: The long description and the pictures section (including the spoiler)
 	 * 
 	 * @param doc
 	 *            The previously fetched cachepage
@@ -2763,14 +2834,14 @@
 		int imgCounter = 0;
 		int spiderCounter = 0;
 		String fileName, imgName, imgType, imgUrl, imgComment;
-		Vector spideredUrls = new Vector(15);
+		final Vector spideredUrls = new Vector();
 		ImageInfo imageInfo = null;
 		Extractor exImgBlock, exImgComment;
 		int idxUrl; // Index of already spidered Url in list of spideredUrls
 		CacheImages lastImages = null;
 
 		// First: Get current image object of waypoint before spidering images.
-		CacheHolder oldCh = Global.getProfile().cacheDB.get(chD.getParent().getWayPoint());
+		final CacheHolder oldCh = Global.getProfile().cacheDB.get(chD.getParent().getWayPoint());
 		if (oldCh != null) {
 			lastImages = oldCh.getCacheDetails(false).images;
 		}
@@ -2785,7 +2856,7 @@
 			longDesc = STRreplace.replace(longDesc, "src=", "SRC=");
 			longDesc = STRreplace.replace(longDesc, "'", "\"");
 			exImgBlock = new Extractor(longDesc, p.getProp("imgBlockExStart"), p.getProp("imgBlockExEnd"), 0, false);
-		} catch (Exception ex) {// Missing property in spider.def
+		} catch (final Exception ex) {// Missing property in spider.def
 			return;
 		}
 		String tst;
@@ -2794,27 +2865,22 @@
 		while (exImgBlock.endOfSearch() == false) {
 			imgUrl = exImgSrc.findNext();
 			if (imgUrl.length() > 0) {
-				// Optimize: img.groundspeak.com -> img.geocaching.com (for better caching purposes)
+				// Optimize: img.groundspeak.com -> img.geocaching.com (for
+				// better caching purposes)
 				imgUrl = CacheImages.optimizeLink("http://" + imgUrl);
 				try {
 					imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + "    ").substring(0, 4).trim();
 					// imgType is now max 4 chars, starting with .
-					if (imgType.startsWith(".png")
-							|| imgType.startsWith(".jpg")
-							|| imgType.startsWith(".gif")) {
+					if (imgType.startsWith(".png") || imgType.startsWith(".jpg") || imgType.startsWith(".gif")) {
 						// Check whether image was already spidered for this
 						// cache
 						idxUrl = spideredUrls.find(imgUrl);
-						imgName = chD.getParent().getWayPoint() + "_"
-								+ Convert.toString(imgCounter);
+						imgName = chD.getParent().getWayPoint() + "_" + Convert.toString(imgCounter);
 						imageInfo = null;
 						if (idxUrl < 0) { // New image
-							fileName = chD.getParent().getWayPoint()
-									.toLowerCase()
-									+ "_" + Convert.toString(spiderCounter);
+							fileName = chD.getParent().getWayPoint().toLowerCase() + "_" + Convert.toString(spiderCounter);
 							if (lastImages != null) {
-								imageInfo = lastImages.needsSpidering(imgUrl,
-										fileName + imgType);
+								imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
 							}
 							if (imageInfo == null) {
 								imageInfo = new ImageInfo();
@@ -2828,9 +2894,7 @@
 							spideredUrls.add(imgUrl);
 							spiderCounter++;
 						} else { // Image already spidered as wayPoint_'idxUrl'
-							fileName = chD.getParent().getWayPoint()
-									.toLowerCase()
-									+ "_" + Convert.toString(idxUrl);
+							fileName = chD.getParent().getWayPoint().toLowerCase() + "_" + Convert.toString(idxUrl);
 							pref.log("[getImages] Already loaded image: " + imgUrl + " as " + fileName + imgType);
 							imageInfo = new ImageInfo();
 							imageInfo.setFilename(fileName + imgType);
@@ -2841,7 +2905,7 @@
 						imgCounter++;
 						chD.images.add(imageInfo);
 					}
-				} catch (IndexOutOfBoundsException e) {
+				} catch (final IndexOutOfBoundsException e) {
 					pref.log("[getImages] Problem loading image. imgURL:" + imgUrl, e);
 				}
 			}
@@ -2857,7 +2921,7 @@
 			exImgName = new Extractor(tst, p.getProp("imgNameExStart"), p.getProp("imgNameExEnd"), 0, true);
 			exImgSrc = new Extractor(tst, p.getProp("imgSrcExStart"), p.getProp("imgSrcExEnd"), 0, true);
 			exImgComment = new Extractor(tst, p.getProp("imgCommentExStart"), p.getProp("imgCommentExEnd"), 0, true);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			return;
 		}
 		while (!exImgSrc.endOfSearch()) {
@@ -2866,12 +2930,9 @@
 			if (imgUrl.length() > 0) {
 				imgUrl = "http://" + imgUrl;
 				try {
-					imgType = (imgUrl.substring(imgUrl.lastIndexOf('.'))
-							.toLowerCase() + "    ").substring(0, 4).trim();
+					imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + "    ").substring(0, 4).trim();
 					// imgType is now max 4 chars, starting with .
-					if (imgType.startsWith(".png")
-							|| imgType.startsWith(".jpg")
-							|| imgType.startsWith(".gif")) {
+					if (imgType.startsWith(".png") || imgType.startsWith(".jpg") || imgType.startsWith(".gif")) {
 						// Check whether image was already spidered for this
 						// cache
 						idxUrl = spideredUrls.find(imgUrl);
@@ -2908,7 +2969,7 @@
 						imageInfo.setComment(imgComment);
 						chD.images.add(imageInfo);
 					}
-				} catch (IndexOutOfBoundsException e) {
+				} catch (final IndexOutOfBoundsException e) {
 					pref.log("[getImages] IndexOutOfBoundsException in image span. imgURL:" + imgUrl, e);
 				}
 			}
@@ -2916,23 +2977,21 @@
 		// ========
 		// Final sweep to check for images in hrefs
 		// ========
-		Extractor exFinal = new Extractor(longDesc, "http://", "\"", 0, true);
+		final Extractor exFinal = new Extractor(longDesc, "http://", "\"", 0, true);
 		while (!exFinal.endOfSearch()) {
 			imgUrl = exFinal.findNext();
 			if (imgUrl.length() > 0) {
-				// Optimize: img.groundspeak.com -> img.geocaching.com (for better caching purposes)
+				// Optimize: img.groundspeak.com -> img.geocaching.com (for
+				// better caching purposes)
 				imgUrl = CacheImages.optimizeLink("http://" + imgUrl);
 				try {
 					imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + "    ").substring(0, 4).trim();
 					// imgType is now max 4 chars, starting with . Delete
 					// characters in URL after the image extension
-					imgUrl = imgUrl.substring(0, imgUrl.lastIndexOf('.')
-							+ imgType.length());
-					if (imgType.startsWith(".jpg")
-							|| imgType.startsWith(".bmp")
-							|| imgType.startsWith(".png")
-							|| imgType.startsWith(".gif")) {
-						// Check whether image was already spidered for this cache
+					imgUrl = imgUrl.substring(0, imgUrl.lastIndexOf('.') + imgType.length());
+					if (imgType.startsWith(".jpg") || imgType.startsWith(".bmp") || imgType.startsWith(".png") || imgType.startsWith(".gif")) {
+						// Check whether image was already spidered for this
+						// cache
 						idxUrl = spideredUrls.find(imgUrl);
 						if (idxUrl < 0) { // New image
 							imgName = chD.getParent().getWayPoint() + "_" + Convert.toString(imgCounter);
@@ -2956,7 +3015,7 @@
 							chD.images.add(imageInfo);
 						}
 					}
-				} catch (IndexOutOfBoundsException e) {
+				} catch (final IndexOutOfBoundsException e) {
 					pref.log("[getImages] Problem loading image. imgURL:" + imgUrl, e);
 				}
 			}
@@ -2974,11 +3033,11 @@
 	private void spiderImage(String address, String fn) {
 		try {
 			UrlFetcher.fetchDataFile(address, profile.dataDir + fn);
-		} catch (UnknownHostException e) {
+		} catch (final UnknownHostException e) {
 			pref.log("[spiderImage] Host not there...", e);
-		} catch (IOException ioex) {
+		} catch (final IOException ioex) {
 			pref.log("[spiderImage] File not found!", ioex);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[spiderImage] Some other problem while fetching image", ex);
 		} finally {
 			// Continue with the spider
@@ -2993,61 +3052,44 @@
 	 * @param wayPoint
 	 *            The name of the cache
 	 * @param is_found
-	 *            Found status of the cached (is inherited by the additional
-	 *            waypoints)
+	 *            Found status of the cached (is inherited by the additional waypoints)
 	 */
 	boolean koords_not_yet_found = true;
 
-	private void getAddWaypoints(String doc, String wayPoint, boolean is_found)
-			throws Exception {
-		Extractor exWayBlock = new Extractor(doc, 
-				p.getProp("wayBlockExStart"),
-				p.getProp("wayBlockExEnd"), 
-				0, false);
+	private void getAddWaypoints(String doc, String wayPoint, boolean is_found) throws Exception {
+		final Extractor exWayBlock = new Extractor(doc, p.getProp("wayBlockExStart"), p.getProp("wayBlockExEnd"), 0, false);
 		String wayBlock = "";
 		String rowBlock = "";
 		wayBlock = exWayBlock.findNext();
-		Regex nameRex = new Regex(p.getProp("nameRex"));
-		Regex koordRex = new Regex(p.getProp("koordRex"));
-		Regex descRex = new Regex(p.getProp("descRex"));
-		Regex typeRex = new Regex(p.getProp("typeRex"));
+		final Regex nameRex = new Regex(p.getProp("nameRex"));
+		final Regex koordRex = new Regex(p.getProp("koordRex"));
+		final Regex descRex = new Regex(p.getProp("descRex"));
+		final Regex typeRex = new Regex(p.getProp("typeRex"));
 		int counter = 0;
-		if (!exWayBlock.endOfSearch()
-				&& wayBlock.indexOf("No additional waypoints to display.") < 0) {
-			Extractor exRowBlock = new Extractor(wayBlock, 
-					p.getProp("rowBlockExStart"), 
-					p.getProp("rowBlockExEnd"),
-					0, false);
+		if (!exWayBlock.endOfSearch() && wayBlock.indexOf("No additional waypoints to display.") < 0) {
+			final Extractor exRowBlock = new Extractor(wayBlock, p.getProp("rowBlockExStart"), p.getProp("rowBlockExEnd"), 0, false);
 			rowBlock = exRowBlock.findNext();
 			rowBlock = exRowBlock.findNext();
 			while (!exRowBlock.endOfSearch()) {
 				CacheHolder hd = null;
 
 				/*
-				 * String[] AddiBlock=mString.split(rowBlock,'\n'); int
-				 * linePrefix=8; if(AddiBlock.length < linePrefix + 1) { (new
-				 * MessageBox(MyLocale.getMsg(5500,"Error"),
-				 * "GC changed table output \nCW must be changed too!",
-				 * FormBase.OKB)).execute(); break; } String
-				 * prefix=AddiBlock[linePrefix].trim();
+				 * String[] AddiBlock=mString.split(rowBlock,'\n'); int linePrefix=8; if(AddiBlock.length < linePrefix + 1) { (new MessageBox(MyLocale.getMsg(5500,"Error"), "GC changed table output \nCW must be changed too!", FormBase.OKB)).execute();
+				 * break; } String prefix=AddiBlock[linePrefix].trim();
 				 */
 
 				// Extractor exPrefix=new
 				// Extractor(AddiBlock[linePrefix].trim(),p.getProp("prefixExStart"),p.getProp("prefixExEnd"),0,true);
-				Extractor exPrefix = new Extractor(rowBlock, 
-						p.getProp("prefixExStart"),
-						p.getProp("prefixExEnd"), 
-						0, true);
-				String prefix = exPrefix.findNext();
+				final Extractor exPrefix = new Extractor(rowBlock, p.getProp("prefixExStart"), p.getProp("prefixExEnd"), 0, true);
+				final String prefix = exPrefix.findNext();
 
 				String adWayPoint;
 				if (prefix.length() == 2)
 					adWayPoint = prefix + wayPoint.substring(2);
 				else
-					adWayPoint = MyLocale.formatLong(counter, "00")
-							+ wayPoint.substring(2);
+					adWayPoint = MyLocale.formatLong(counter, "00") + wayPoint.substring(2);
 				counter++;
-				int idx = profile.getCacheIndex(adWayPoint);
+				final int idx = profile.getCacheIndex(adWayPoint);
 				if (idx >= 0) {
 					// Creating new CacheHolder, but accessing old cache.xml
 					// file
@@ -3064,8 +3106,7 @@
 				if (nameRex.didMatch()) {
 					hd.setCacheName(nameRex.stringMatched(1));
 				} else {
-					pref.log("check nameRex in spider.def"
-							+ Preferences.NEWLINE + rowBlock);
+					pref.log("check nameRex in spider.def" + Preferences.NEWLINE + rowBlock);
 				}
 				koordRex.search(rowBlock);
 				typeRex.search(rowBlock);
@@ -3073,25 +3114,22 @@
 					hd.setLatLon(koordRex.stringMatched(1));
 					koords_not_yet_found = false;
 				} else {
-					if (koords_not_yet_found)
-						pref.log("check koordRex in spider.def"
-								+ Preferences.NEWLINE + rowBlock);
+					if (koords_not_yet_found) {
+						koords_not_yet_found = false;
+						pref.log("check koordRex in spider.def" + Preferences.NEWLINE + rowBlock);
+					}
 				}
 				if (typeRex.didMatch()) {
-					hd.setType(CacheType.gpxType2CwType("Waypoint|"
-							+ typeRex.stringMatched(1)));
+					hd.setType(CacheType.gpxType2CwType("Waypoint|" + typeRex.stringMatched(1)));
 				} else {
-					pref.log("check typeRex in spider.def"
-							+ Preferences.NEWLINE + rowBlock);
+					pref.log("check typeRex in spider.def" + Preferences.NEWLINE + rowBlock);
 				}
 				rowBlock = exRowBlock.findNext();
 				descRex.search(rowBlock);
 				if (descRex.didMatch()) {
-					hd.getCacheDetails(false).setLongDescription(
-							descRex.stringMatched(1).trim());
+					hd.getCacheDetails(false).setLongDescription(descRex.stringMatched(1).trim());
 				} else {
-					pref.log("check descRex in spider.def"
-							+ Preferences.NEWLINE + rowBlock);
+					pref.log("check descRex in spider.def" + Preferences.NEWLINE + rowBlock);
 				}
 				hd.setFound(is_found);
 				hd.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
@@ -3101,8 +3139,8 @@
 					cacheDB.add(hd);
 					hd.save();
 				} else {
-					CacheHolder cx = cacheDB.get(idx);
-					boolean checked = cx.is_Checked;
+					final CacheHolder cx = cacheDB.get(idx);
+					final boolean checked = cx.is_Checked;
 					cx.initStates(false);
 					cx.update(hd);
 					cx.is_Checked = checked;
@@ -3114,13 +3152,10 @@
 		}
 	}
 
-	public void getAttributes(String doc, CacheHolderDetail chD)
-			throws Exception {
-		Extractor attBlock = new Extractor(doc, p.getProp("attBlockExStart"), 
-				p.getProp("attBlockExEnd"), 0, true);
-		String atts = attBlock.findNext();
-		Extractor attEx = new Extractor(atts, p.getProp("attExStart"), 
-				p.getProp("attExEnd"), 0, true);
+	public void getAttributes(String doc, CacheHolderDetail chD) throws Exception {
+		final Extractor attBlock = new Extractor(doc, p.getProp("attBlockExStart"), p.getProp("attBlockExEnd"), 0, true);
+		final String atts = attBlock.findNext();
+		final Extractor attEx = new Extractor(atts, p.getProp("attExStart"), p.getProp("attExEnd"), 0, true);
 		String attribute = attEx.findNext();
 		chD.attributes.clear();
 		while (!attEx.endOfSearch()) {
@@ -3133,14 +3168,14 @@
 	final static String hex = ewe.util.TextEncoder.hex;
 
 	public String encodeUTF8URL(byte[] what) {
-		int max = what.length;
-		char[] dest = new char[6 * max]; // Assume each char is a UTF char and
-											// encoded into 6 chars
+		final int max = what.length;
+		final char[] dest = new char[6 * max]; // Assume each char is a UTF char
+												// and
+												// encoded into 6 chars
 		char d = 0;
 		for (int i = 0; i < max; i++) {
-			char c = (char) what[i];
-			if (c <= ' ' || c == '+' || c == '&' || c == '%' || c == '='
-					|| c == '|' || c == '{' || c == '}' || c > 0x7f) {
+			final char c = (char) what[i];
+			if (c <= ' ' || c == '+' || c == '&' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}' || c > 0x7f) {
 				dest[d++] = '%';
 				dest[d++] = hex.charAt((c >> 4) & 0xf);
 				dest[d++] = hex.charAt(c & 0xf);
@@ -3151,9 +3186,7 @@
 	}
 
 	/**
-	 * Load the bug id for a given name. This method is not ideal, as there are
-	 * sometimes several bugs with identical names but different IDs. Normally
-	 * the bug GUID is used which can be obtained from the cache page.<br>
+	 * Load the bug id for a given name. This method is not ideal, as there are sometimes several bugs with identical names but different IDs. Normally the bug GUID is used which can be obtained from the cache page.<br>
 	 * Note that each bug has both an ID and a GUID.
 	 * 
 	 * @param name
@@ -3166,40 +3199,30 @@
 			// infB.setInfo(oldInfoBox+"\nGetting bug: "+bug);
 			bugList = UrlFetcher.fetch(p.getProp("getBugByName") + STRreplace.replace(SafeXML.clean(name), " ", "+"));
 			pref.log("[getBugId] Fetched bugId: " + name);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[getBugId] Could not fetch bug list" + name, ex);
 			bugList = "";
 		}
 		try {
-			if (bugList.equals("")
-					|| bugList.indexOf(p.getProp("bugNotFound")) >= 0) {
-				(new MessageBox(MyLocale.getMsg(5500, "Error"), 
-						MyLocale.getMsg(6020, "Travelbug not found."),
-						FormBase.OKB)).execute();
+			if (bugList.equals("") || bugList.indexOf(p.getProp("bugNotFound")) >= 0) {
+				(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(6020, "Travelbug not found."), FormBase.OKB)).execute();
 				return "";
 			}
 			if (bugList.indexOf(p.getProp("bugTotalRecords")) < 0) {
-				(new MessageBox(MyLocale.getMsg(5500, "Error"),
-						MyLocale.getMsg(6021, "More than one travelbug found. Specify name more precisely."),
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(6021, "More than one travelbug found. Specify name more precisely."), FormBase.OKB)).execute();
 				return "";
 			}
-			Extractor exGuid = new Extractor(bugList, 
-					p.getProp("bugGuidExStart"), 
-					p.getProp("bugGuidExEnd"), 
-					0, Extractor.EXCLUDESTARTEND); 
+			final Extractor exGuid = new Extractor(bugList, p.getProp("bugGuidExStart"), p.getProp("bugGuidExEnd"), 0, Extractor.EXCLUDESTARTEND);
 			// TODO Replace with spider.def
 			return exGuid.findNext();
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[getBugId] Error getting TB", ex);
 			return "";
 		}
 	}
 
 	/**
-	 * Fetch a bug's mission for a given GUID or ID. If the guid String is
-	 * longer than 10 characters it is assumed to be a GUID, otherwise it is an
-	 * ID.
+	 * Fetch a bug's mission for a given GUID or ID. If the guid String is longer than 10 characters it is assumed to be a GUID, otherwise it is an ID.
 	 * 
 	 * @param guid
 	 *            the guid or id of the travelbug
@@ -3214,23 +3237,18 @@
 			else
 				bugDetails = UrlFetcher.fetch(p.getProp("getBugById") + guid);
 			pref.log("[getBugMissionByGuid] Fetched TB detailsById: " + guid);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[getBugMissionByGuid] Could not fetch TB details " + guid, ex);
 			bugDetails = "";
 		}
 		try {
 			if (bugDetails.indexOf(p.getProp("bugNotFound")) >= 0) {
-				(new MessageBox(MyLocale.getMsg(5500, "Error"),
-						MyLocale.getMsg(6020, "Travelbug not found."),
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(6020, "Travelbug not found."), FormBase.OKB)).execute();
 				return "";
 			}
-			Extractor exDetails = new Extractor(bugDetails, 
-					p.getProp("bugDetailsStart"), 
-					p.getProp("bugDetailsEnd"),
-					0, Extractor.EXCLUDESTARTEND);
+			final Extractor exDetails = new Extractor(bugDetails, p.getProp("bugDetailsStart"), p.getProp("bugDetailsEnd"), 0, Extractor.EXCLUDESTARTEND);
 			return exDetails.findNext();
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[getBugMissionByGuid] Error getting TB " + guid, ex);
 			return "";
 		}
@@ -3248,7 +3266,7 @@
 		try {
 			bugDetails = UrlFetcher.fetch(p.getProp("getBugByTrackNr") + trackNr);
 			pref.log("[getBugMissionByTrackNr] Fetched bug detailsByTrackNr: " + trackNr);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[getBugMissionByTrackNr] getBugByTrackNr " + trackNr, ex);
 			bugDetails = "";
 		}
@@ -3260,12 +3278,9 @@
 				// MessageBox.OKB)).execute();
 				return "";
 			}
-			Extractor exDetails = new Extractor(bugDetails, 
-					p.getProp("bugDetailsStart"), 
-					p.getProp("bugDetailsEnd"),
-					0, Extractor.EXCLUDESTARTEND);
+			final Extractor exDetails = new Extractor(bugDetails, p.getProp("bugDetailsStart"), p.getProp("bugDetailsEnd"), 0, Extractor.EXCLUDESTARTEND);
 			return exDetails.findNext();
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[getBugMissionByTrackNr] TB Details, bugNotFound " + trackNr, ex);
 			return "";
 		}
@@ -3280,11 +3295,11 @@
 	 */
 	public boolean getBugMissionAndNameByTrackNr(Travelbug TB) {
 		String bugDetails;
-		String trackNr = TB.getTrackingNo();
+		final String trackNr = TB.getTrackingNo();
 		try {
 			bugDetails = UrlFetcher.fetch(p.getProp("getBugByTrackNr") + trackNr);
 			pref.log("[getBugMissionAndNameByTrackNr] Fetched TB getBugByTrackNr: " + trackNr);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[getBugMissionAndNameByTrackNr] Could not fetch bug details: " + trackNr, ex);
 			bugDetails = "";
 		}
@@ -3296,16 +3311,12 @@
 				// MessageBox.OKB)).execute();
 				return false;
 			}
-			Extractor exDetails = new Extractor(bugDetails, 
-					p.getProp("bugDetailsStart"), p.getProp("bugDetailsEnd"), 0,
-					Extractor.EXCLUDESTARTEND);
+			final Extractor exDetails = new Extractor(bugDetails, p.getProp("bugDetailsStart"), p.getProp("bugDetailsEnd"), 0, Extractor.EXCLUDESTARTEND);
 			TB.setMission(exDetails.findNext());
-			Extractor exName = new Extractor(bugDetails, 
-					p.getProp("bugNameStart"), p.getProp("bugNameEnd"), 0,
-					Extractor.EXCLUDESTARTEND);
+			final Extractor exName = new Extractor(bugDetails, p.getProp("bugNameStart"), p.getProp("bugNameEnd"), 0, Extractor.EXCLUDESTARTEND);
 			TB.setName(exName.findNext());
 			return true;
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log("[getBugMissionAndNameByTrackNr] TB Details, bugNotFound: " + trackNr, ex);
 			return false;
 		}
@@ -3316,11 +3327,9 @@
 			super();
 			try {
 				load(new FileInputStream(FileBase.getProgramDirectory() + "/spider.def"));
-			} catch (Exception ex) {
+			} catch (final Exception ex) {
 				pref.log("Failed to load spider.def from " + FileBase.getProgramDirectory(), ex);
-				(new MessageBox(MyLocale.getMsg(5500, "Error"), 
-						MyLocale.getMsg(5504, "Could not load 'spider.def'"),
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5504, "Could not load 'spider.def'"), FormBase.OKB)).execute();
 			}
 		}
 
@@ -3334,11 +3343,9 @@
 		 *             When a key is requested which doesn't exist
 		 */
 		public String getProp(String key) throws Exception {
-			String s = super.getProperty(key);
+			final String s = super.getProperty(key);
 			if (s == null) {
-				(new MessageBox(MyLocale.getMsg(5500, "Error"),
-						MyLocale.getMsg(5497, "Error missing tag in spider.def")+ ": " + key,
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5497, "Error missing tag in spider.def") + ": " + key, FormBase.OKB)).execute();
 				pref.log("Missing tag in spider.def: " + key);
 				throw new Exception("Missing tag in spider.def: " + key);
 			}
@@ -3372,16 +3379,16 @@
 				parse(r);
 				r.close();
 				rFIS.close();
-			} catch (Exception e) {
+			} catch (final Exception e) {
 			}
 			return _routePoints;
 		}
 
 		public void startElement(String name, AttributeList atts) {
-			if (name.equals("trkpt")|| name.equals("rtept")|| name.equals("gpxx:rpt")) {
-				double lat = Common.parseDouble(atts.getValue("lat"));
-				double lon = Common.parseDouble(atts.getValue("lon"));
-				TrackPoint tp = new TrackPoint(lat, lon);
+			if (name.equals("trkpt") || name.equals("rtept") || name.equals("gpxx:rpt")) {
+				final double lat = Common.parseDouble(atts.getValue("lat"));
+				final double lon = Common.parseDouble(atts.getValue("lon"));
+				final TrackPoint tp = new TrackPoint(lat, lon);
 				if (tp.isValid())
 					_routePoints.add(tp);
 				return;
@@ -3393,4 +3400,3 @@
 		}
 	}
 }
-

Modified: trunk/src/CacheWolf/navi/MapInfoObject.java
===================================================================
--- trunk/src/CacheWolf/navi/MapInfoObject.java	2011-05-02 11:30:16 UTC (rev 2994)
+++ trunk/src/CacheWolf/navi/MapInfoObject.java	2011-05-06 15:11:39 UTC (rev 2995)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -40,16 +40,14 @@
 import ewe.io.PrintWriter;
 import ewe.sys.Convert;
 
-
 /**
- * class to read, save and do the calculations for calibrated and 
- * calibrating maps
- * start offset for language file: 4300
+ * class to read, save and do the calculations for calibrated and calibrating maps start offset for language file: 4300
+ * 
  * @author pfeffer
- *
+ * 
  */
 public class MapInfoObject extends Area {
-	//World file:
+	// World file:
 	// x scale
 	// y scale
 	// x rotation
@@ -59,89 +57,95 @@
 	// lon of lower right corner of image
 	// lat of lower right corner of image
 
-	private double[] affine = {0,0,0,0};
+	private final double[] affine = { 0, 0, 0, 0 };
 	private CWPoint affineTopleft = new CWPoint();;
-	private double transLatX, transLatY, transLonX, transLonY; // this are needed for the inervers calculation from lat/lon to x/y
+	// this are needed for the inervers calculation from lat/lon to x/y
+	private double transLatX, transLatY, transLonX, transLonY;
 	public CWPoint center = new CWPoint();
 	public float sizeKm = 0; // diagonale
-	public float scale; // in meters per pixel, note: it is assumed that this scale identifying the scale of the map, automatically adjusted when zooming
-	public float zoomFactor = 1; // if the image is zoomed, direct after laoding always 1
-	public Point shift = new Point (0,0);
-	public CWPoint origAffineUpperLeft; // this is only valid after zooming 
+	// in meters per pixel, note: it is assumed that this scale identifying the scale of the map,
+	// automatically adjusted when zooming
+	public float scale;
+	// if the image is zoomed, direct after laoding always 1
+	public float zoomFactor = 1;
+	public Point shift = new Point(0, 0);
+	public CWPoint origAffineUpperLeft; // this is only valid after zooming
 	public float rotationRad; // contains the rotation of the map == north direction in rad
-	/** full path to the respective worldfile, including ".wfl"*/
+	/** full path to the respective worldfile, including ".wfl" */
 	public String fileNameWFL = "";
 	/** filename wihout directory */
-//	public String fileName = new String();
-	/** name of the map, introduced to allow 'maps' without an image (empty maps) */ 
+	// public String fileName = new String();
+	/**
+	 * name of the map, introduced to allow 'maps' without an image (empty maps)
+	 */
 	public String mapName = "";
-	//private Character digSep = new Character(' ');
+	// private Character digSep = new Character(' ');
 	static private String digSep = MyLocale.getDigSeparator();
-	private int coordTrans = 0; 
+	private int coordTrans = 0;
 
 	public MapInfoObject() { // Public constructor
 	}
 
 	public MapInfoObject(MapInfoObject map) {
-		super (map.topleft, map.bottomright);
+		super(map.topleft, map.bottomright);
 		mapName = map.mapName;
 		affine[0] = map.affine[0];
 		affine[1] = map.affine[1];
 		affine[2] = map.affine[2];
 		affine[3] = map.affine[3];
-		origAffineUpperLeft = new CWPoint (map.origAffineUpperLeft);
+		origAffineUpperLeft = new CWPoint(map.origAffineUpperLeft);
 		affineTopleft = new CWPoint(map.affineTopleft);
 		zoomFactor = map.zoomFactor;
 		shift.set(map.shift);
 		coordTrans = map.coordTrans;
-		//	fileName = new String(map.fileName);
+		// fileName = new String(map.fileName);
 		fileNameWFL = new String(map.fileNameWFL);
 		mapName = new String(mapName);
 		doCalculations();
 	}
 
 	/**
-	 * constructes an MapInfoObject without an associated map
-	 * but with 1 Pixel = scale meters
+	 * constructes an MapInfoObject without an associated map but with 1 Pixel = scale meters
 	 */
 	public MapInfoObject(double scalei, double lat) {
-		super(new CWPoint(1,0), new CWPoint(0,1));
-		mapName=MyLocale.getMsg(4300, "empty 1 Pixel = ") + scalei + MyLocale.getMsg(4301,"meters");
-		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double pixel2deg = meters2deg * scalei;
-		affine[0]=0; //x2lat
-		affine[1]=pixel2deg / java.lang.Math.cos(lat*java.lang.Math.PI / 180); //x2lon
-		affine[2]=-pixel2deg; //y2lat
-		affine[3]=0; //y2lon
-		topleft.latDec=1; //top
-		topleft.lonDec=0; //left
-		bottomright.latDec = 0; //bottom
-		bottomright.lonDec = 1; //right
+		super(new CWPoint(1, 0), new CWPoint(0, 1));
+		mapName = MyLocale.getMsg(4300, "empty 1 Pixel = ") + scalei + MyLocale.getMsg(4301, "meters");
+		final double meters2deg = 1 / (1000 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
+		final double pixel2deg = meters2deg * scalei;
+		affine[0] = 0; // x2lat
+		affine[1] = pixel2deg / java.lang.Math.cos(lat * java.lang.Math.PI / 180); // x2lon
+		affine[2] = -pixel2deg; // y2lat
+		affine[3] = 0; // y2lon
+		topleft.latDec = 1; // top
+		topleft.lonDec = 0; // left
+		bottomright.latDec = 0; // bottom
+		bottomright.lonDec = 1; // right
 		affineTopleft.set(topleft);
 		doCalculations();
 		origAffineUpperLeft = new CWPoint(affineTopleft);
 	}
 
 	/**
-	 * constructs an MapInfoObject with an associated map
-	 * with 1 Pixel = scale meters, centre and width, hight in pixels
-	 * @param name path and filename of .wfl file without the extension (it is needed because the image will be searched in the same directory)
+	 * constructs an MapInfoObject with an associated map with 1 Pixel = scale meters, centre and width, hight in pixels
+	 * 
+	 * @param name
+	 *            path and filename of .wfl file without the extension (it is needed because the image will be searched in the same directory)
 	 */
 	public MapInfoObject(double scalei, CWPoint center, int width, int hight, String name) {
 		super();
-		mapName = name+".wfl";
-		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double pixel2deg = meters2deg * scalei;
-		double pixel2deghorizontal = pixel2deg / java.lang.Math.cos(center.latDec*java.lang.Math.PI / 180); 
-		affine[0]=0; //x2lat
-		affine[1]=pixel2deghorizontal; //x2lon
-		affine[2]=-pixel2deg; //y2lat
-		affine[3]=0; //y2lon
-		topleft.latDec=center.latDec + hight / 2 *pixel2deg; //top
-		topleft.lonDec=center.lonDec - width / 2 *pixel2deghorizontal; //left
+		mapName = name + ".wfl";
+		final double meters2deg = 1 / (1000 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
+		final double pixel2deg = meters2deg * scalei;
+		final double pixel2deghorizontal = pixel2deg / java.lang.Math.cos(center.latDec * java.lang.Math.PI / 180);
+		affine[0] = 0; // x2lat
+		affine[1] = pixel2deghorizontal; // x2lon
+		affine[2] = -pixel2deg; // y2lat
+		affine[3] = 0; // y2lon
+		topleft.latDec = center.latDec + hight / 2 * pixel2deg; // top
+		topleft.lonDec = center.lonDec - width / 2 * pixel2deghorizontal; // left
 		affineTopleft.set(topleft);
-		bottomright.latDec = center.latDec - hight / 2 *pixel2deg; //bottom
-		bottomright.lonDec = center.lonDec + width / 2 *pixel2deghorizontal; //right
+		bottomright.latDec = center.latDec - hight / 2 * pixel2deg; // bottom
+		bottomright.lonDec = center.lonDec + width / 2 * pixel2deghorizontal; // right
 		fileNameWFL = name;
 		origAffineUpperLeft = new CWPoint(affineTopleft);
 		doCalculations();
@@ -154,42 +158,51 @@
 
 	/**
 	 * 
-	 * @param path including trailing "/"
-	 * @param n without ".wfl"
+	 * @param path
+	 *            including trailing "/"
+	 * @param n
+	 *            without ".wfl"
 	 * @return name of the map including fast-find-prefix
 	 */
 	public String setName(String path, String n) {
-		String pref = getFfPrefix();
+		final String pref = getFfPrefix();
 		mapName = pref + n;
 		fileNameWFL = path + pref + mapName + ".wfl";
 		return mapName;
 	}
 
-	/** 
+	/**
 	 * @return the filename of the associated map image, "" if no file is associated, null if associated file could not be found
 	 */
 	public String getImageFilename() {
-		// if (fileName == null || fileName.length() > 0) return fileName; 
-		if (fileNameWFL.length() == 0) return ""; // no image associated (empty map)
-		String n = fileNameWFL.substring(0, fileNameWFL.lastIndexOf('.'));
+		// if (fileName == null || fileName.length() > 0) return fileName;
+		if (fileNameWFL.length() == 0)
+			return ""; // no image associated (empty map)
+		final String n = fileNameWFL.substring(0, fileNameWFL.lastIndexOf('.'));
 		return Common.getImageName(CacheWolf.STRreplace.replace(n, "//", "/"));
 	}
 
 	/**
 	 * Method to load a .wfl-file
-	 * @param mapsPath path to the map inclunding / at the end
-	 * @param thisMap name of the map without extension
-	 * @throws IOException when there was a problem reading .wfl-file
-	 * @throws IOException when lat/lon were out of range
-	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
+	 * 
+	 * @param mapsPath
+	 *            path to the map inclunding / at the end
+	 * @param thisMap
+	 *            name of the map without extension
+	 * @throws IOException
+	 *             when there was a problem reading .wfl-file
+	 * @throws IOException
+	 *             when lat/lon were out of range
+	 * @throws ArithmeticException
+	 *             when affine data is not correct, e.g. it is not possible to inverse affine-transformation
 	 */
 	public void loadwfl(String mapsPath, String thisMap) throws IOException, ArithmeticException {
-		FileInputStream instream = new FileInputStream (CacheWolf.STRreplace.replace(mapsPath + thisMap + ".wfl", "//", "/"));
-		InputStreamReader in = new InputStreamReader(instream);
-		
+		final FileInputStream instream = new FileInputStream(CacheWolf.STRreplace.replace(mapsPath + thisMap + ".wfl", "//", "/"));
+		final InputStreamReader in = new InputStreamReader(instream);
+
 		String line = "";
 		try {
-			for(int i = 0; i<4;i++){
+			for (int i = 0; i < 4; i++) {
 				line = in.readLine();
 				affine[i] = Common.parseDoubleException(line);
 			}
@@ -201,20 +214,28 @@
 			bottomright.latDec = Common.parseDoubleException(line);
 			line = in.readLine();
 			bottomright.lonDec = Common.parseDoubleException(line);
-			line = in.readLine(); // readLine returns null, if End of File reached
-			if (line != null) coordTrans = Common.parseInt(line);
-			else coordTrans = 0;
+			line = in.readLine(); // readLine returns null, if End of File
+									// reached
+			if (line != null)
+				coordTrans = Common.parseInt(line);
+			else
+				coordTrans = 0;
 			fileNameWFL = mapsPath + thisMap + ".wfl";
-//			fileName = ""; //mapsPath + thisMap + ".png";
+			// fileName = ""; //mapsPath + thisMap + ".png";
 			mapName = thisMap;
 			in.close();
-			if( !bottomright.isValid() ) {
-				affine[0] = 0; affine[1] = 0; affine[2] = 0; affine[3] = 0; 
+			if (!bottomright.isValid()) {
+				affine[0] = 0;
+				affine[1] = 0;
+				affine[2] = 0;
+				affine[3] = 0;
 				topleft.makeInvalid();
-				throw (new IOException(MyLocale.getMsg(4301, "Lat/Lon out of range while reading ")+mapsPath + thisMap + ".wfl"));
+				throw (new IOException(MyLocale.getMsg(4301, "Lat/Lon out of range while reading ") + mapsPath + thisMap + ".wfl"));
 			}
-		} catch (NullPointerException e) { // in.readline liefert null zur?ck, wenn keine Daten mehr vorhanden sind
-			throw (new IOException(MyLocale.getMsg(4303, "not enough lines in file ")+mapsPath + thisMap + ".wfl"));
+		} catch (final NullPointerException e) { // in.readline liefert null
+													// zur?ck, wenn keine Daten
+													// mehr vorhanden sind
+			throw (new IOException(MyLocale.getMsg(4303, "not enough lines in file ") + mapsPath + thisMap + ".wfl"));
 		}
 		doCalculations();
 		origAffineUpperLeft = new CWPoint(affineTopleft);
@@ -223,24 +244,30 @@
 	public void evalGCP(ewe.util.Vector GCPs, int imageWidth, int imageHeight) throws IllegalArgumentException {
 		evalGCP(GCPs, imageWidth, imageHeight, 0);
 	}
-		/**
-	 *	Method to evaluate ground control points (georeferenced points) and identify the parameters
-	 *	for the affine transformation
-	 *  @throws IllegalArgumentException when less than 3 georeferenced points were given in GCPs
+
+	/**
+	 * Method to evaluate ground control points (georeferenced points) and identify the parameters for the affine transformation
+	 * 
+	 * @throws IllegalArgumentException
+	 *             when less than 3 georeferenced points were given in GCPs
 	 */
 
 	public void evalGCP(ewe.util.Vector GCPs, int imageWidth, int imageHeight, int epsg_code) throws IllegalArgumentException {
-		//N 48 16.000 E 11 32.000
-		//N 48 16.000 E 11 50.000
-		//N 48 9.000 E 11 32.000
-		if (GCPs.size() < 3 ) throw new IllegalArgumentException(MyLocale.getMsg(4304, "not enough points to calibrate the map"));
+		// N 48 16.000 E 11 32.000
+		// N 48 16.000 E 11 50.000
+		// N 48 9.000 E 11 32.000
+		if (GCPs.size() < 3)
+			throw new IllegalArgumentException(MyLocale.getMsg(4304, "not enough points to calibrate the map"));
 		GCPoint gcp = new GCPoint();
-		//Calculate parameters for latitutde affine transformation (affine 0,2,4)
-		Matrix X = new Matrix(GCPs.size(),3);
-		Matrix trg = new Matrix(GCPs.size(),1);
-		for(int i = 0; i < GCPs.size();i++){
-			gcp = (GCPoint)GCPs.get(i);
-			X.matrix[i][0] = 1; X.matrix[i][1] = gcp.bitMapX; X.matrix[i][2] = gcp.bitMapY;
+		// Calculate parameters for latitutde affine transformation (affine
+		// 0,2,4)
+		Matrix X = new Matrix(GCPs.size(), 3);
+		Matrix trg = new Matrix(GCPs.size(), 1);
+		for (int i = 0; i < GCPs.size(); i++) {
+			gcp = (GCPoint) GCPs.get(i);
+			X.matrix[i][0] = 1;
+			X.matrix[i][1] = gcp.bitMapX;
+			X.matrix[i][2] = gcp.bitMapY;
 			trg.matrix[i][0] = gcp.latDec;
 		}
 		Matrix Xtran = new Matrix(X);
@@ -256,11 +283,12 @@
 		affine[2] = beta.matrix[2][0];
 		affineTopleft.latDec = beta.matrix[0][0];
 
-		//Calculate parameters for longitude affine transformation (affine 1,3,5)
-		X = new Matrix(GCPs.size(),3);
-		trg = new Matrix(GCPs.size(),1);
-		for(int i = 0; i < GCPs.size();i++){
-			gcp = (GCPoint)GCPs.get(i);
+		// Calculate parameters for longitude affine transformation (affine
+		// 1,3,5)
+		X = new Matrix(GCPs.size(), 3);
+		trg = new Matrix(GCPs.size(), 1);
+		for (int i = 0; i < GCPs.size(); i++) {
+			gcp = (GCPoint) GCPs.get(i);
 			X.matrix[i][0] = 1;
 			X.matrix[i][1] = gcp.bitMapX;
 			X.matrix[i][2] = gcp.bitMapY;
@@ -285,56 +313,71 @@
 
 	/**
 	 * calculates centre, diagonal size of the map and inverse to affine transformation
-	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
+	 * 
+	 * @throws ArithmeticException
+	 *             when affine data is not correct, e.g. it is not possible to inverse affine-transformation
 	 */
 
 	private void doCalculations() throws ArithmeticException {
 		try {
 			topleft.set(calcLatLon(0, 0));
-			center.set((bottomright.latDec + topleft.latDec)/2,(bottomright.lonDec + topleft.lonDec)/2);
-			sizeKm = java.lang.Math.abs((float)center.getDistance(bottomright)) *2;
+			center.set((bottomright.latDec + topleft.latDec) / 2, (bottomright.lonDec + topleft.lonDec) / 2);
+			sizeKm = java.lang.Math.abs((float) center.getDistance(bottomright)) * 2;
 
-			//calculate reverse affine
-			double nenner=(-affine[1]*affine[2]+affine[0]*affine[3]);
-			transLatX = affine[3]/nenner; // nenner == 0 cannot happen as long als affine is correct
-			transLonX = -affine[2]/nenner;
-			transLatY = -affine[1]/nenner;
-			transLonY = affine[0]/nenner;
+			// calculate reverse affine
+			final double nenner = (-affine[1] * affine[2] + affine[0] * affine[3]);
+			transLatX = affine[3] / nenner; // nenner == 0 cannot happen as long
+											// als affine is correct
+			transLonX = -affine[2] / nenner;
+			transLatY = -affine[1] / nenner;
+			transLonY = affine[0] / nenner;
 
 			// calculate north direction
-			Point c = calcMapXY(center);
-			int heightpixel = c.y * 2;
+			final Point c = calcMapXY(center);
+			final int heightpixel = c.y * 2;
 			c.y -= 1000;
-			rotationRad = (float) (center.getBearing(calcLatLon(c)) / 180 * Math.PI);  // note: the direction of nord can vary across the image. In Gau?-Kr?ger Projection it does change about 1 degree per 10km! //(float)java.lang.Math.atan(rotationX2y);
-			if (rotationRad > Math.PI) rotationRad -= 2* Math.PI;
+			rotationRad = (float) (center.getBearing(calcLatLon(c)) / 180 * Math.PI);
+			// note: the direction of nord can vary across the image.
+			// In Gau?-Kr?ger Projection it does change about 1 degree per 10km!
+			// (float)java.lang.Math.atan(rotationX2y);
+			if (rotationRad > Math.PI)
+				rotationRad -= 2 * Math.PI;
 
 			// calculate scale in meters per pixel
-			double heightkm = calcLatLon(0, heightpixel).getDistance(topleft);
+			final double heightkm = calcLatLon(0, heightpixel).getDistance(topleft);
 			scale = (float) (heightkm * 1000 / heightpixel);
-		} catch (ArithmeticException ex) { throw new ArithmeticException(MyLocale.getMsg(4305, "Not allowed values in affine\n (matrix cannot be inverted)\n in file \n") + fileNameWFL); }
+		} catch (final ArithmeticException ex) {
+			throw new ArithmeticException(MyLocale.getMsg(4305, "Not allowed values in affine\n (matrix cannot be inverted)\n in file \n") + fileNameWFL);
+		}
 	}
 
 	public void saveWFL() throws IOException, IllegalArgumentException {
-		File dateiF = new FileBugfix(fileNameWFL);
-		String tmp = dateiF.getDrivePath(); // contains the name and the extension
+		final File dateiF = new FileBugfix(fileNameWFL);
+		final String tmp = dateiF.getDrivePath(); // contains the name and the
+													// extension
 		saveWFL(tmp, mapName);
 	}
 
 	/**
-	 *	Method to save a world file (.wfl)
-	 * @param mapsPath without "/" at the end
-	 * @param mapFileName without file extension
-	 * @throws IOException when there was a problem writing .wfl-file
-	 * @throws IllegalArgumentException when affine[x] for all x == 0 ("map not calibrated").
+	 * Method to save a world file (.wfl)
+	 * 
+	 * @param mapsPath
+	 *            without "/" at the end
+	 * @param mapFileName
+	 *            without file extension
+	 * @throws IOException
+	 *             when there was a problem writing .wfl-file
+	 * @throws IllegalArgumentException
+	 *             when affine[x] for all x == 0 ("map not calibrated").
 	 */
 	public void saveWFL(String mapsPath, String mapFileName) throws IOException, IllegalArgumentException {
 		if (mapsPath.endsWith("/")) {
-			mapsPath=mapsPath.substring(0, mapsPath.length()-1);
+			mapsPath = mapsPath.substring(0, mapsPath.length() - 1);
 		}
-		if (affine[0]==0 && affine[1]==0 && affine[2]==0 && affine[3]==0 && 
-				!topleft.isValid()) throw (new IllegalArgumentException(MyLocale.getMsg(4306, "map not calibrated")));
-		PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(mapsPath + "/" + mapFileName + ".wfl")));
-		StringBuffer towriteB=new StringBuffer(400);
+		if (affine[0] == 0 && affine[1] == 0 && affine[2] == 0 && affine[3] == 0 && !topleft.isValid())
+			throw (new IllegalArgumentException(MyLocale.getMsg(4306, "map not calibrated")));
+		final PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(mapsPath + "/" + mapFileName + ".wfl")));
+		final StringBuffer towriteB = new StringBuffer(400);
 		towriteB.append(Convert.toString(affine[0])).append("\n");
 		towriteB.append(Convert.toString(affine[1])).append("\n");
 		towriteB.append(Convert.toString(affine[2])).append("\n");
@@ -343,69 +386,77 @@
 		towriteB.append(Convert.toString(affineTopleft.lonDec)).append("\n");
 		towriteB.append(Convert.toString(bottomright.latDec)).append("\n");
 		towriteB.append(Convert.toString(bottomright.lonDec)).append("\n");
-		towriteB.append(((coordTrans == 0 || coordTrans == TransformCoordinates.EPSG_WGS84) ? "" : Convert.toString(coordTrans)+"\n"));
+		towriteB.append(((coordTrans == 0 || coordTrans == TransformCoordinates.EPSG_WGS84) ? "" : Convert.toString(coordTrans) + "\n"));
 		String towrite = towriteB.toString();
-		if (digSep.equals(",")) towrite=towrite.replace(',', '.');
+		if (digSep.equals(","))
+			towrite = towrite.replace(',', '.');
 		outp.print(towrite);
 		outp.close();
-//		this.fileName = ""; // this will be set in getImageFilenam //mapsPath + "/" + mapFileName + ".png";
+		// this.fileName = ""; // this will be set in getImageFilenam //mapsPath
+		// + "/" + mapFileName + ".png";
 		this.fileNameWFL = mapsPath + "/" + mapFileName + ".wfl";
 		this.mapName = mapFileName;
 	}
 
-
 	/**
 	 * zoom in / out
-	 * @param zf zf > 1 == zoom in, zoom is relative to original unscaled image
-	 * @param diffX shift of map in pixels (if the map was cropped while zooming) in the not zoomed image
+	 * 
+	 * @param zf
+	 *            zf > 1 == zoom in, zoom is relative to original unscaled image
+	 * @param diffX
+	 *            shift of map in pixels (if the map was cropped while zooming) in the not zoomed image
 	 * @param diffY
 	 */
 	public void zoom(float zf, int diffX, int diffY) {
 		// restore original values to calculate corret shift (upperleft)
 		affineTopleft.latDec = origAffineUpperLeft.latDec;
 		affineTopleft.lonDec = origAffineUpperLeft.lonDec;
-		affine[0] = affine[0] * zoomFactor; 
-		affine[1] = affine[1] * zoomFactor; 
+		affine[0] = affine[0] * zoomFactor;
+		affine[1] = affine[1] * zoomFactor;
 		affine[2] = affine[2] * zoomFactor;
 		affine[3] = affine[3] * zoomFactor;
 		TrackPoint upperleft = calcLatLon(diffX, diffY);
-		if (coordTrans != 0) upperleft = TransformCoordinatesProperties.fromWgs84(upperleft, coordTrans);
-		affineTopleft.latDec = upperleft.latDec; // TODO nachdenken affineTopleft
+		if (coordTrans != 0)
+			upperleft = TransformCoordinatesProperties.fromWgs84(upperleft, coordTrans);
+		affineTopleft.latDec = upperleft.latDec; // TODO nachdenken
+													// affineTopleft
 		affineTopleft.lonDec = upperleft.lonDec;
-		affine[0] = affine[0] / zf ; 
-		affine[1] = affine[1] / zf ; 
-		affine[2] = affine[2] / zf ; 
-		affine[3] = affine[3] / zf ; 
-		zoomFactor = zf ;
+		affine[0] = affine[0] / zf;
+		affine[1] = affine[1] / zf;
+		affine[2] = affine[2] / zf;
+		affine[3] = affine[3] / zf;
+		zoomFactor = zf;
 		shift.x = diffX;
 		shift.y = diffY;
 		doCalculations(); // TODO lowlat neu berechnen?
 	}
 
 	/**
-	 * Method to calculate bitmap x,y of the current map using
-	 * lat and lon target coordinates. There ist no garanty that
-	 * the returned coordinates are inside of the map. They can be negative.
+	 * Method to calculate bitmap x,y of the current map using lat and lon target coordinates. There ist no garanty that the returned coordinates are inside of the map. They can be negative.
+	 * 
 	 * @param lat
 	 * @param lon
 	 */
-	public Point calcMapXY(TrackPoint ll){
+	public Point calcMapXY(TrackPoint ll) {
 		TrackPoint t;
-		if (coordTrans != 0) t = TransformCoordinatesProperties.fromWgs84(ll, coordTrans);
-		else t = ll;
-		Point coords = new Point();
+		if (coordTrans != 0)
+			t = TransformCoordinatesProperties.fromWgs84(ll, coordTrans);
+		else
+			t = ll;
+		final Point coords = new Point();
 		double b0, b1;
 		b0 = t.latDec - affineTopleft.latDec;
 		b1 = t.lonDec - affineTopleft.lonDec;
-		double mapx = transLatX * b0 + transLonX * b1;
-		double mapy = transLatY * b0 + transLonY * b1;
-		coords.x = (int)Math.round(mapx);
-		coords.y = (int)Math.round(mapy);
+		final double mapx = transLatX * b0 + transLonX * b1;
+		final double mapy = transLatY * b0 + transLonY * b1;
+		coords.x = (int) Math.round(mapx);
+		coords.y = (int) Math.round(mapy);
 		return coords;
 	}
 
 	/**
 	 * gives back lat/lon from x, y in map
+	 * 
 	 * @param x
 	 * @param y
 	 * @return
@@ -418,51 +469,49 @@
 			ll = TransformCoordinatesProperties.toWgs84(ll, coordTrans);
 		return ll;
 	}
-	
+
 	public CWPoint calcLatLon(Point p) {
 		return calcLatLon(p.x, p.y);
 	}
 
 	/**
-	 * Get the prefix used for easy and fast finding of the best map
-	 * The filname of the .wfl and respective image should start with this
-	 * prefix in order to make finding the best map much faster 
+	 * Get the prefix used for easy and fast finding of the best map The filname of the .wfl and respective image should start with this prefix in order to make finding the best map much faster
+	 * 
 	 * @return
 	 */
 	public String getFfPrefix() {
-		return "FF1"+getEasyFindString()+"E-";
+		return "FF1" + getEasyFindString() + "E-";
 	}
 }
 
-	/**
-	 *	Class based on CWPoint but intended to handle bitmap x and y
-	 *	Used for georeferencing bitmaps.
-	 */
-	class GCPoint extends CWPoint{
-		public int bitMapX = 0;
-		public int bitMapY = 0;
+/**
+ * Class based on CWPoint but intended to handle bitmap x and y Used for georeferencing bitmaps.
+ */
+class GCPoint extends CWPoint {
+	public int bitMapX = 0;
+	public int bitMapY = 0;
 
-		public GCPoint(){ // Public constructor
-		}
+	public GCPoint() { // Public constructor
+	}
 
-		public GCPoint(CWPoint p) {
-			super(p);
-		}
+	public GCPoint(CWPoint p) {
+		super(p);
+	}
 
-		/**
-		 * If you are using Gau?-Kr?ger, put lat = northing, lon = easting 
-		 * @param lat
-		 * @param lon
-		 */
-		public GCPoint(double lat, double lon){
-			this.latDec = lat;
-			this.lonDec = lon;
-		}
-		
-		public GCPoint(CWPoint ll, Point px) {
-			super(ll);
-			bitMapX = px.x;
-			bitMapY = px.y;
-		}
+	/**
+	 * If you are using Gau?-Kr?ger, put lat = northing, lon = easting
+	 * 
+	 * @param lat
+	 * @param lon
+	 */
+	public GCPoint(double lat, double lon) {
+		this.latDec = lat;
+		this.lonDec = lon;
 	}
-	
\ No newline at end of file
+
+	public GCPoint(CWPoint ll, Point px) {
+		super(ll);
+		bitMapX = px.x;
+		bitMapY = px.y;
+	}
+}



From araber95 at mail.berlios.de  Sun May  8 01:30:44 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Sun,  8 May 2011 01:30:44 PM +0200
Subject: [Cachewolf-svn] r2996 - in trunk: res_noewe src/CacheWolf
	src/CacheWolf/imp
Message-ID: <20110508113044.7679748129D@sheep.berlios.de>

Author: araber95
Date: 2011-05-08 13:30:44 +0200 (Sun, 08 May 2011)
New Revision: 2996

Modified:
   trunk/res_noewe/spider.def
   trunk/src/CacheWolf/UrlFetcher.java
   trunk/src/CacheWolf/imp/SpiderGC.java
Log:


Modified: trunk/res_noewe/spider.def
===================================================================
--- trunk/res_noewe/spider.def	2011-05-06 15:11:39 UTC (rev 2995)
+++ trunk/res_noewe/spider.def	2011-05-08 11:30:44 UTC (rev 2996)
@@ -70,7 +70,7 @@
 # Regex to search for cachenames
 listBlockRex       = <table\ class="SearchResultsTable\ Table">((?s).*?)</table>
 lineRex            = Data\ BorderTop">((?s).*?)</tr>
-logDateRex         = <td valign="top">\\s*(.*?)<br\ />
+logDateRex         = </span>\\s+</td>\\s+<td\ valign="top"\ width="70">\\s+<span\ class="small">\\s+(.*?)<br\ />
 availableRex       = class="lnk\ \ Strike">
 archivedRex        = class="lnk\ OldWarning\ Strike\ Strike">
 PMRex              = small_profile.gif
@@ -80,7 +80,7 @@
 DTSRex             = v=(.*?)"
 DTSCodeKey         = hbM9fjmrxy7z42LFD58BkKgPGdHscvCqNnw3ptO6lJ
 waypointRex        = \\|\\s+GC(.*?)\\s+
-TypeRex            = www.geocaching.com/images/wpttypes/sm/(.*?)\\.gif
+TypeRex            = www.geocaching.com/images/wpttypes/(.*?)\\.gif
 found              = class="Success"
 own                = /WptTypes/name_tag.gif
 TBRex              = /wpttypes/([0-9]+).gif" alt="(.*?)"

Modified: trunk/src/CacheWolf/UrlFetcher.java
===================================================================
--- trunk/src/CacheWolf/UrlFetcher.java	2011-05-06 15:11:39 UTC (rev 2995)
+++ trunk/src/CacheWolf/UrlFetcher.java	2011-05-08 11:30:44 UTC (rev 2996)
@@ -236,7 +236,7 @@
 			char c = what[i];
 			if (spaceToPlus && c == ' ')
 				c = '+';
-			else if (c <= ' ' || c >= 127 || c == '+' || c == '&' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}') {
+			else if (c <= '/' || c >= 127 || c == '+' || c == '&' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}') {
 				dest[d++] = '%';
 				dest[d++] = hex.charAt((c >> 4) & 0xf);
 				dest[d++] = hex.charAt(c & 0xf);

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-06 15:11:39 UTC (rev 2995)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-08 11:30:44 UTC (rev 2996)
@@ -862,13 +862,8 @@
 		}
 		final int startSize = cExpectedForUpdate.size(); // for save reasons
 
-		final Hashtable cFoundForUpdate = new Hashtable(cacheDB.size()); // for
-																			// don't
-																			// loose
-																			// the
-																			// already
-																			// done
-																			// work
+		// for don't loose the already done work
+		final Hashtable cFoundForUpdate = new Hashtable(cacheDB.size());
 		page_number = 1;
 		int found_on_page = 0;
 		try {
@@ -1135,7 +1130,7 @@
 			if (loggedIn)
 				return FormBase.IDOK;
 			else {
-				(new MessageBox("Login", "Check UserID in preferences| Einstellungen.", FormBase.OKB)).execute();
+				(new MessageBox("Login", "Check UserID in preferences | Einstellungen, or check GC-Language. Must be English.", FormBase.OKB)).execute();
 				return ERR_LOGIN;
 			}
 		} else {
@@ -1295,9 +1290,9 @@
 
 	private boolean switchToEnglish() {
 		// change language to EN , further operations relay on English
-		String url = "http://www.geocaching.com/my/default.aspx";
+		String url = "http://www.geocaching.com/";
 		String page = "";
-		String loggedInEnglish = "Sign Out";
+		String loggedInEnglish = ">Sign Out<";
 		String userID = "userid=" + pref.userID;
 		try {
 			UrlFetcher.setPermanentRequestorProperty("Cookie", userID);
@@ -1307,7 +1302,7 @@
 		} catch (final Exception ex) {
 			return false;
 		}
-		final PropertyList pl = UrlFetcher.getDocumentProperties();
+		PropertyList pl = UrlFetcher.getDocumentProperties();
 		String docprops = "";
 		for (int i = 0; i < pl.size(); i++) {
 			final Property p = (Property) pl.get(i);
@@ -1336,7 +1331,7 @@
 			return true;
 		}
 		// todo next doesn't work correct don't know why
-		// switch to english now goes into profile (is permanent, must be reset)
+		// switch to english now goes into gc account Display Preferences (is permanent, must be reset)
 		final Regex rexViewstate = new Regex("id=\"__VIEWSTATE\" value=\"(.*?)\" />");
 		String viewstate = "";
 		rexViewstate.search(page);
@@ -1348,16 +1343,21 @@
 		final String postStr = "__EVENTTARGET=" + UrlFetcher.encodeURL(strEnglishPage, false) + "&__EVENTARGUMENT=" + "&__VIEWSTATE=" + UrlFetcher.encodeURL(viewstate, false);
 		try {
 			UrlFetcher.setpostData(postStr);
+			/*
+			 * UrlFetcher.setRequestorProperty("Referer", url); UrlFetcher.setRequestorProperty("Origin", "http://www.geocaching.com"); UrlFetcher.setRequestorProperty("Cache-Control", "max-age=0"); UrlFetcher.setRequestorProperty("Accept-Charset",
+			 * "ISO-8859-1,utf-8;q=0.7,*;q=0.3"); UrlFetcher.setRequestorProperty("Accept-Language", "de-DE,de;q=0.8,en-US;q=0.6,en;q=0.4"); cookie =
+			 * "company_history=%5B%5B%22http%3A//feedback.geocaching.com/geocaching%22%2C%22Geocaching%22%5D%5D; Send2GPS=garmin; __qca=P0-675333427-1299837942815; " + cookie; UrlFetcher.setPermanentRequestorProperty("Cookie", cookie);
+			 */
 			page = UrlFetcher.fetch(url);
 			if (page.indexOf(loggedInEnglish) > -1) {
 				pref.log("Switched to English");
 				return true;
 			} else {
-				pref.log(page, null);
+				pref.log("couldn't switch to english", null);
 				return false;
 			}
 		} catch (final Exception ex) {
-			pref.log("Error switching to English: check/n" + url + "/n" + postStr, ex);
+			pref.log("Error switching to English: check " + url + " : " + postStr, ex);
 			return false;
 		}
 
@@ -2246,14 +2246,58 @@
 		} else {
 			final String monthNames[] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
 			SDate = mString.split(stmp, ' ');
-			lastLogGC.day = Common.parseInt(SDate[0]);
-			for (int m = 0; m < 12; m++) {
-				if (monthNames[m].startsWith(SDate[1])) {
-					lastLogGC.month = m + 1;
-					m = 12;
+			if (SDate.length == 1) {
+				SDate = mString.split(stmp, '/');
+				// trying to determine Dateformat
+				int v0 = Common.parseInt(SDate[0]);
+				int v1 = Common.parseInt(SDate[1]);
+				int v2 = Common.parseInt(SDate[2]);
+				int dd, mm, yy;
+				if (v0 > 31) {
+					// yyyy mm dd
+					yy = v0;
+					mm = v1;
+					dd = v2;
+				} else {
+					yy = v2;
+					if ((v0 == 0) || (v1 == 0)) {
+						// month as text
+						String month;
+						if (v0 == 0) {
+							month = SDate[0];
+							dd = v1;
+						} else {
+							month = SDate[1];
+							dd = v0;
+						}
+						mm = 12;
+						for (int m = 0; m < 12; m++) {
+							if (monthNames[m].startsWith(month)) {
+								mm = m + 1;
+								m = 12;
+							}
+						}
+					} else {
+						// mm dd yyyy
+						mm = v0;
+						dd = v1;
+					}
+
 				}
+				lastLogGC.month = mm;
+				lastLogGC.day = dd;
+				lastLogGC.year = yy;
+			} else {
+				// Format till may 2011
+				lastLogGC.day = Common.parseInt(SDate[0]);
+				for (int m = 0; m < 12; m++) {
+					if (monthNames[m].startsWith(SDate[1])) {
+						lastLogGC.month = m + 1;
+						m = 12;
+					}
+				}
+				lastLogGC.year = 2000 + Common.parseInt(SDate[2].substring(0, 2));
 			}
-			lastLogGC.year = 2000 + Common.parseInt(SDate[2].substring(0, 2));
 		}
 		final boolean ret = lastLogCW.compareTo(lastLogGC) < 0;
 		return ret;



From araber95 at mail.berlios.de  Tue May 10 11:54:53 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Tue, 10 May 2011 11:54:53 PM +0200
Subject: [Cachewolf-svn] r2997 - in trunk: res_noewe/attributes
	res_noewe/languages src/CacheWolf src/CacheWolf/imp
Message-ID: <20110510215454.32447481270@sheep.berlios.de>

Author: araber95
Date: 2011-05-10 23:54:53 +0200 (Tue, 10 May 2011)
New Revision: 2997

Added:
   trunk/res_noewe/attributes/sponsored-no.gif
   trunk/res_noewe/attributes/sponsored-non.gif
   trunk/res_noewe/attributes/sponsored-yes.gif
Modified:
   trunk/res_noewe/languages/DE.cfg
   trunk/res_noewe/languages/EN.cfg
   trunk/res_noewe/languages/FR.cfg
   trunk/res_noewe/languages/NL.cfg
   trunk/res_noewe/languages/PL.cfg
   trunk/res_noewe/languages/SV.cfg
   trunk/src/CacheWolf/Attribute.java
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/DateFormat.java
   trunk/src/CacheWolf/imp/SpiderGC.java
Log:
1. add Attribute "sponsored cache), id and gpx text guessed (todo correct values)
2. date format can be set to one of the formats of gc
3.  quick import with new map fixed (gc changed infos)

Added: trunk/res_noewe/attributes/sponsored-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/res_noewe/attributes/sponsored-no.gif
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/res_noewe/attributes/sponsored-non.gif
===================================================================
(Binary files differ)


Property changes on: trunk/res_noewe/attributes/sponsored-non.gif
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/res_noewe/attributes/sponsored-yes.gif
===================================================================
(Binary files differ)


Property changes on: trunk/res_noewe/attributes/sponsored-yes.gif
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Modified: trunk/res_noewe/languages/DE.cfg
===================================================================
--- trunk/res_noewe/languages/DE.cfg	2011-05-08 11:30:44 UTC (rev 2996)
+++ trunk/res_noewe/languages/DE.cfg	2011-05-10 21:54:53 UTC (rev 2997)
@@ -793,6 +793,8 @@
 2682=RFID, CHIRP / Funk Ausr??stung
 2683=keine Erste Hilfe 
 2684=Erste Hilfe nahebei
+2685=nicht gesponsert
+2686=gesponsert
 3000=Schlie??en
 4000=Geladene Caches:+
 4001=GPX-Dateien von Opencaching enthalten keine Informationen zu Bildern, sie werden nicht heruntergeladen. Am besten Caches von Opencaching holen per Men?? /Anwendung/Import/von Opencaching

Modified: trunk/res_noewe/languages/EN.cfg
===================================================================
--- trunk/res_noewe/languages/EN.cfg	2011-05-08 11:30:44 UTC (rev 2996)
+++ trunk/res_noewe/languages/EN.cfg	2011-05-10 21:54:53 UTC (rev 2997)
@@ -793,6 +793,8 @@
 2682 = RFID, CHIRP / radio equipment
 2683 = No emergency
 2684 = First Aid nearby
+2685=not sponsored
+2686=sponsored
 3000=Close
 4000=Loaded caches:+
 4001=GPX files from opencaching don't contain information of images, they cannot be loaded. Best you get caches from opencaching by menu /Application/Import/Download from Opencaching

Modified: trunk/res_noewe/languages/FR.cfg
===================================================================
--- trunk/res_noewe/languages/FR.cfg	2011-05-08 11:30:44 UTC (rev 2996)
+++ trunk/res_noewe/languages/FR.cfg	2011-05-10 21:54:53 UTC (rev 2997)
@@ -793,6 +793,8 @@
 2682 = RFID, CHIRP ??quipement radio /
 2683 = Pas d'urgence
 2684 = First Aid ?? proximit??
+2685 = non parrain??
+2686 = parrain??
 3000=Fermer
 4000=Caches charg??es:
 4001=GPX fichiers ?? partir Opencaching ne contiennent pas d'informations d'images, ils ne peuvent pas ??tre charg??. Pour le meilleur vous obtenez des caches de Opencaching par le menu /Application/importation/Download from Opencaching

Modified: trunk/res_noewe/languages/NL.cfg
===================================================================
--- trunk/res_noewe/languages/NL.cfg	2011-05-08 11:30:44 UTC (rev 2996)
+++ trunk/res_noewe/languages/NL.cfg	2011-05-10 21:54:53 UTC (rev 2997)
@@ -793,6 +793,8 @@
 2682 = RFID, CHIRP / radio-apparatuur
 2683 = Geen spoed
 2684 = Eerste Hulp in de buurt
+2685 = niet gesponsord
+2686 = gesponsord
 3000=Sluiten
 4000=Geladen caches
 4001=GPX bestanden uit opencaching bevatten geen informatie van beelden, kunnen zij niet worden downloaden. Beste je caches van opencaching menu /Application/Import/Download from Opencaching

Modified: trunk/res_noewe/languages/PL.cfg
===================================================================
--- trunk/res_noewe/languages/PL.cfg	2011-05-08 11:30:44 UTC (rev 2996)
+++ trunk/res_noewe/languages/PL.cfg	2011-05-10 21:54:53 UTC (rev 2997)
@@ -793,6 +793,8 @@
 2682 = RFID, CHIRP / urz??dze?? radiowych
 2683 = Nie awaryjne
 2684 = Pierwsza pomoc w pobli??u
+2685 = nie sponsorowane
+2686 = sponsorowane
 3000=Zamknij
 4000=Wczytaj skrzynki:+
 4001=Pliki GPX z opencaching nie zawieraja informacji o obrazach, nie moga byc one wczytane. Najlepiej pobierz skrzynki z opencaching przez menu /Aplikacja/Importuj/Sciagnij Z Opencaching

Modified: trunk/res_noewe/languages/SV.cfg
===================================================================
--- trunk/res_noewe/languages/SV.cfg	2011-05-08 11:30:44 UTC (rev 2996)
+++ trunk/res_noewe/languages/SV.cfg	2011-05-10 21:54:53 UTC (rev 2997)
@@ -793,6 +793,8 @@
 2682 = RFID,CHIRP / tr??dl??s utrustning
 2683 = Ingen akut
 2684 = F??rsta hj??lpen i n??rheten
+2685 = inte sponsras
+2686 = sponsrade
 3000=St??ng
 4000=Loaded cachar:+
 4001=GPX filer fr??n opencaching inte inneh??ller n??gon information av bilder, kan de inte laoded. B??st du cachar fr??n opencaching genom menyn / Application / Import / Download fr??n Opencaching

Modified: trunk/src/CacheWolf/Attribute.java
===================================================================
--- trunk/src/CacheWolf/Attribute.java	2011-05-08 11:30:44 UTC (rev 2996)
+++ trunk/src/CacheWolf/Attribute.java	2011-05-10 21:54:53 UTC (rev 2997)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import ewe.fx.mImage;
@@ -30,332 +30,372 @@
 
 /**
  * This class represents a single attribute
+ * 
  * @author skg
- *
+ * 
  */
 public class Attribute {
 	// Constructors
-	public Attribute(int id, int inc) {_Id=id;setInc(inc);setIdBit();}
-	public Attribute(String attributeName) { attName2attNo(attributeName); setIdBit();}
-	public Attribute(int attIdOC) { OCAttNo2attNo(attIdOC); setIdBit();}
-	public Attribute(int attIdGC, String Yes1No0) { GCAttNo2attNo(attIdGC, Yes1No0); setIdBit();}
+	public Attribute(int id, int inc) {
+		_Id = id;
+		setInc(inc);
+		setIdBit();
+	}
+
+	public Attribute(String attributeName) {
+		attName2attNo(attributeName);
+		setIdBit();
+	}
+
+	public Attribute(int attIdOC) {
+		OCAttNo2attNo(attIdOC);
+		setIdBit();
+	}
+
+	public Attribute(int attIdGC, String Yes1No0) {
+		GCAttNo2attNo(attIdGC, Yes1No0);
+		setIdBit();
+	}
+
 	// Constructors end
 	private int _Id;
 	private int _Inc; // Yes=1 No=0 non=2
 	private String _ImageName;
-	private long[] _bit = {0l,0l};
+	private long[] _bit = { 0l, 0l };
+
 	// for GC Constructor Spider
 	private void attName2attNo(String attributeName) {
-    	for (int i=0; i<maxAttRef; i++) {
-    		if (attributeName.toLowerCase().startsWith(attRef[i][PIC_NAME])) {
-				_Id=i;
-				_Inc=attributeName.toLowerCase().endsWith("-no.gif") ? 0 : 1;
-				_ImageName=attRef[i][PIC_NAME]+(_Inc==0 ? "-no.gif" : "-yes.gif");
+		for (int i = 0; i < maxAttRef; i++) {
+			if (attributeName.toLowerCase().startsWith(attRef[i][PIC_NAME])) {
+				_Id = i;
+				_Inc = attributeName.toLowerCase().endsWith("-no.gif") ? 0 : 1;
+				_ImageName = attRef[i][PIC_NAME] + (_Inc == 0 ? "-no.gif" : "-yes.gif");
 				return;
-    		}
-    	}
-    	_Id=-1; // Error
-    	_ImageName="error.gif";
-    	}
+			}
+		}
+		_Id = -1; // Error
+		_ImageName = "error.gif";
+	}
+
 	// for OC Constructor
-    private void OCAttNo2attNo(int attIdOC) {
-    	for (int i=0; i<maxAttRef; i++) {
-    		if (attIdOC == Common.parseInt(attRef[i][OC_ID])) {
-				_Id=i;
-				_Inc=1;
-				_ImageName=attRef[i][PIC_NAME]+"-yes.gif";
+	private void OCAttNo2attNo(int attIdOC) {
+		for (int i = 0; i < maxAttRef; i++) {
+			if (attIdOC == Common.parseInt(attRef[i][OC_ID])) {
+				_Id = i;
+				_Inc = 1;
+				_ImageName = attRef[i][PIC_NAME] + "-yes.gif";
 				return;
-    		}
-    	}
-    	_Id=-1; // Error
-    	_ImageName="error.gif";
-    }
-    // for GC Constructor gpx-Import
-    private void GCAttNo2attNo(int attIdGC, String Yes1No0 ) {
-    	for (int i=0; i<maxAttRef; i++) {
-    		if (attIdGC == Common.parseInt(attRef[i][GC_ID])) {
-				_Id=i;
-    			_Inc=Yes1No0.equals("1") ? 1 : 0;
-				_ImageName=attRef[i][PIC_NAME]+(_Inc==0 ? "-no.gif" : "-yes.gif");
-				return;				
-    		}
-    	}
-    	_Id=-1; // Error
-    	_ImageName="error.gif";
-    }
-    // used by all Constructors
-    private void setIdBit() {
-    	_bit=getIdBit(_Id);
-    }
-    // checking for array limits (caus -1 is possible value)
-    private static String attRef(int row, int column ) {
-    	if (row > -1 && row < maxAttRef) {
-    		return attRef[row][column];
-    	}
-    	else {
-    		return "";
-    	}
-    }
-    // *** public part
-    public static long[] getIdBit(int id) {
-    	long [] bit = new long[2];
-    	if (id>-1 && id<maxAttRef) {
-        	int b = Common.parseInt(attRef[id][BIT_NR]);
-    		bit[0] = b>63 ? 0l : (1L << b);
-    		bit[1] = b>63 ? (1L << b-64) : 0;
-    	}
-    	else {
-        	bit[0]=0;
-        	bit[1]=0;
-    	}
-    	return bit;
-    }    
-    /**
-     * get GC_TEXT string
+			}
+		}
+		_Id = -1; // Error
+		_ImageName = "error.gif";
+	}
+
+	// for GC Constructor gpx-Import
+	private void GCAttNo2attNo(int attIdGC, String Yes1No0) {
+		for (int i = 0; i < maxAttRef; i++) {
+			if (attIdGC == Common.parseInt(attRef[i][GC_ID])) {
+				_Id = i;
+				_Inc = Yes1No0.equals("1") ? 1 : 0;
+				_ImageName = attRef[i][PIC_NAME] + (_Inc == 0 ? "-no.gif" : "-yes.gif");
+				return;
+			}
+		}
+		_Id = -1; // Error
+		_ImageName = "error.gif";
+	}
+
+	// used by all Constructors
+	private void setIdBit() {
+		_bit = getIdBit(_Id);
+	}
+
+	// checking for array limits (caus -1 is possible value)
+	private static String attRef(int row, int column) {
+		if (row > -1 && row < maxAttRef) {
+			return attRef[row][column];
+		} else {
+			return "";
+		}
+	}
+
+	// *** public part
+	public static long[] getIdBit(int id) {
+		long[] bit = new long[2];
+		if (id > -1 && id < maxAttRef) {
+			int b = Common.parseInt(attRef[id][BIT_NR]);
+			bit[0] = b > 63 ? 0l : (1L << b);
+			bit[1] = b > 63 ? (1L << b - 64) : 0;
+		} else {
+			bit[0] = 0;
+			bit[1] = 0;
+		}
+		return bit;
+	}
+
+	/**
+	 * get GC_TEXT string
 	 */
-    public String getGCText () { return attRef(_Id,GC_TEXT); }
-    /*
+	public String getGCText() {
+		return attRef(_Id, GC_TEXT);
+	}
+
+	/*
      * 
      */
-    public static String getIdFromGCText(String t) {
-    	for (int i = 0; i < maxAttRef; i++) {
-    		if 	(attRef[i] [GC_TEXT].equals(t)) {
-    			return attRef[i][GC_ID];
-    		}
-    	}
-    	return "-1";
-    }
-    /**
-     * get GC_ID string
+	public static String getIdFromGCText(String t) {
+		for (int i = 0; i < maxAttRef; i++) {
+			if (attRef[i][GC_TEXT].equals(t)) {
+				return attRef[i][GC_ID];
+			}
+		}
+		return "-1";
+	}
+
+	/**
+	 * get GC_ID string
 	 */
-    public String getGCId () { return attRef(_Id,GC_ID); }
-    /**
-     * getting attribute given=1,negative=0,not specified=2  
-     */
-	public int getInc () { return _Inc; }
-    /**
-     * getting CW internal attribute number (-1..127)  
-     */
-	public int getId () { return _Id; }
-    /**
-     * setting/changing attribute given=1,negative=0,not specified=2  
-     */
-    public void setInc(int inc) {
-    	_Inc=inc;
-    	if (_Id<0 || _Id>=maxAttRef) {
-    		_ImageName="error.gif";
-    	}
-    	else {
-    		_ImageName=attRef(_Id,PIC_NAME);
-    		if (inc==0) _ImageName+="-no.gif";
-    		else if (inc==1) _ImageName+="-yes.gif";
-    		else _ImageName+="-non.gif";
-    	}
-    }
-    /**
-     * getting name of corresponding image stored in attributes subdirectory 
-     */
-    public String getImageName() {
-    	return _ImageName;
-    }   
-    /**
-     * getting path+name of corresponding image stored in attributes subdirectory 
-     */
-    public String getPathAndImageName() {
-    	return IMAGEDIR+_ImageName;
-    }
-    /**
-     * set/unset the bit in the long array that belongs to the Id of the attribute  
-     */
-    public long[] getYesBit(long[] yes) {
-    	if (_Inc==1) {
-    		yes[0]|=_bit[0];
-    		yes[1]|=_bit[1];    		
-    	}
-    	else {
-    		yes[0]&=~_bit[0];
-    		yes[1]&=~_bit[1];    		
-    	}
-    	return yes;
-    }
-    /**
-     * set/unset the bit in the long array that belongs to the Id of the attribute  
-     */
-    public long[] getNoBit(long[] no) {
-    	if (_Inc==0) {
-    		no[0]|=_bit[0];
-    		no[1]|=_bit[1];
-    	}
-    	else {
-    		no[0]&=~_bit[0];
-    		no[1]&=~_bit[1];    		
-    	}
-    	return no;
-    }
-    /**
-     * get the language dependant description of the attribute  
-     */
-    public String getMsg() {
-    	return getMsg(_Id,_Inc);
-    }
-	
-	private final static int BIT_NR = 0; 
+	public String getGCId() {
+		return attRef(_Id, GC_ID);
+	}
+
+	/**
+	 * getting attribute given=1,negative=0,not specified=2
+	 */
+	public int getInc() {
+		return _Inc;
+	}
+
+	/**
+	 * getting CW internal attribute number (-1..127)
+	 */
+	public int getId() {
+		return _Id;
+	}
+
+	/**
+	 * setting/changing attribute given=1,negative=0,not specified=2
+	 */
+	public void setInc(int inc) {
+		_Inc = inc;
+		if (_Id < 0 || _Id >= maxAttRef) {
+			_ImageName = "error.gif";
+		} else {
+			_ImageName = attRef(_Id, PIC_NAME);
+			if (inc == 0)
+				_ImageName += "-no.gif";
+			else if (inc == 1)
+				_ImageName += "-yes.gif";
+			else
+				_ImageName += "-non.gif";
+		}
+	}
+
+	/**
+	 * getting name of corresponding image stored in attributes subdirectory
+	 */
+	public String getImageName() {
+		return _ImageName;
+	}
+
+	/**
+	 * getting path+name of corresponding image stored in attributes subdirectory
+	 */
+	public String getPathAndImageName() {
+		return IMAGEDIR + _ImageName;
+	}
+
+	/**
+	 * set/unset the bit in the long array that belongs to the Id of the attribute
+	 */
+	public long[] getYesBit(long[] yes) {
+		if (_Inc == 1) {
+			yes[0] |= _bit[0];
+			yes[1] |= _bit[1];
+		} else {
+			yes[0] &= ~_bit[0];
+			yes[1] &= ~_bit[1];
+		}
+		return yes;
+	}
+
+	/**
+	 * set/unset the bit in the long array that belongs to the Id of the attribute
+	 */
+	public long[] getNoBit(long[] no) {
+		if (_Inc == 0) {
+			no[0] |= _bit[0];
+			no[1] |= _bit[1];
+		} else {
+			no[0] &= ~_bit[0];
+			no[1] &= ~_bit[1];
+		}
+		return no;
+	}
+
+	/**
+	 * get the language dependant description of the attribute
+	 */
+	public String getMsg() {
+		return getMsg(_Id, _Inc);
+	}
+
+	private final static int BIT_NR = 0;
 	private final static int MSG_NR = 1;
 	private final static int PIC_NAME = 2;
 	private final static int OC_ID = 3; // OC - XML
 	private final static int GC_ID = 4; // auch OC neues gpx
-	private final static int GC_TEXT = 5; // for export , didn't extract by myself, copied from forum	
-	private static final String[][] attRef = {
-		{"00","2502","available","38","13","Available at all times"},//02 available 24-7
-		{"01","2504","bicycles","0","32","Bicycles"},//04 bikes allowed
-		{"02","2506","boat","52","4","Boat"},//06 Wasserfahrzeug
-		// {"03","2508","cactus","0","0",""},//08 removed 14.08.10 araber95
-		{"04","2510","campfires","0","38","Campfires"},//10 campfires allowed
-		{"05","2512","camping","0","31","Camping available"},//12 Camping allowed
-		{"06","2514","cliff","11","21","Cliff / falling rocks"},//14 falling-rocks nearby
-		{"07","2516","climbing","28","10","Difficult climbing"},//16 easy climbing(OC-28), difficult climbing(GC-10) 
-		{"08","2518","compass","47","147","Compass"}, //OC special
-		{"09","2520","cow","0","43","Watch for livestock"},//20 watch for livestock
-		{"10","2522","danger","9","23","Dangerous area"},//22 dangerous area
-		{"11","2524","dogs","0","1","Dogs"},//24 dogs allowed
-		{"12","2526","fee","36","2","Access or parking fee"},//26 access/parking fees
-		// {"13","2528","hiking","0","9","Significant hike"},//28 significant hike : removed
-		{"13","2528","hiking","25","125","Long walk"}, //OC special
-		{"14","2530","horses","0","37","Horses"},//30 horses allowed
-		{"15","2532","hunting","12","22","Hunting"},//32 hunting area
-		{"16","2534","jeeps","0","35","Off-road vehicles"},//34 off-road vehicles allowed
-		{"17","2536","kids","59","6","Recommended for kids"},//36 kid friendly
-		{"18","2538","mine","15","20","Abandoned mines"},//38
-		{"19","2540","motorcycles","0","33","Motorcycles"},//40 motorcycles allowed
-		{"20","2542","night","1","14","Recommended at night"},//42 recommended at night
-		{"21","2544","onehour","0","7","Takes less than an hour"},//44 takes less than one hour
-		{"22","2546","parking","18","25","Parking available"},//46 parking available
-		{"23","2548","phone","22","29","Telephone nearby"},//48 telephone nearby
-		{"24","2550","picnic","0","30","Picnic tables nearby"},//50 picnic tables available
-		{"25","2552","poisonoak","16","17","Poison plants"},//52 Giftige Pflanzen
-		{"26","2554","public","19","26","Public transportation"},//54 public transit available
-		{"27","2556","quads","0","34","Quads"},//56 quads allowed
-		{"28","2558","rappelling","49","3","Climbing gear"},//58 climbing gear Kletterausr?stung
-		{"29","2560","restrooms","21","28","Public restrooms nearby"},//60 restrooms available
-		{"30","2562","scenic","0","8","Scenic view"},//62 scenic view
-		{"31","2564","scuba","51","5","Scuba gear"},//64 Tauchausr?stung
-		// {"32","2566","snakes","0","18","Snakes"},//66 araber95 replaced by Dangerous Animals 14.08.10
-		{"32","2566","dangerousanimals","0","18","Dangerous Animals"},//66
-		{"33","2568","snowmobiles","0","36","Snowmobiles"},//68
-		{"34","2570","stealth","0","40","Stealth required"},//70 stealth required (Heimlich,List,Schl?ue)
-		{"35","2572","stroller","0","41","Stroller accessible"},//72 stroller accessible	
-		{"36","2574","swimming","29","12","May require swimming"},//74
-		{"37","2576","thorn","13","39","Thorns"},//76 thorns!
-		{"38","2578","ticks","14","19","Ticks"},//78 ticks!
-		{"39","2580","wading","26","11","May require wading"},//80 may require wading
-		{"40","2582","water","20","27","Drinking water nearby"},//82 drinking water nearby
-		{"41","2584","wheelchair","0","24","Wheelchair accessible"},//84 wheelchair accessible
-		{"42","2586","winter","44","15","Available during winter"},//86 available in winter 132 Schneesicheres Versteck
-		{"43","2588","firstaid","0","42","Firstaid"}, // GC: Cachewartung notwendig (Auto Attribut) , OC: erste Hilfe 
-		{"44","2590","flashlight","48","44","Flashlight required"}, // 90 Flashlight required
-		{"45","2592","aircraft","53","153","Aircraft"}, //OC special //38 GC removed
-		{"46","2594","animals","17","0",""},// 94 Giftige/gef%e4hrliche Tiere
-		{"47","2596","arith_prob","56","156","Arithmetical problem"}, //OC special
-		{"48","2598","ask","58","158","Ask owner for start conditions"}, //OC special
-		{"49","2600","car","24","0",""},// 100 Nahe beim Auto
-		{"50","2602","cave","50","150","Cave equipment"}, //OC special
-		{"51","2604","date","42","142","All seasons"}, //OC special
-		{"52","2606","day","40","140","by day only"}, //OC special 
-		{"53","2608","indoor","33","133","Within enclosed rooms (caves, buildings etc.)"}, //OC special
-		{"54","2610","interestsign","30","130","Point of interest"}, //OC special
-		{"55","2612","letter","8","108","Letterbox (needs stamp)"}, //OC special
-		{"56","2614","moving","31","131","Moving target"}, //OC special
-		{"57","2616","naturschutz","43","143","Breeding season / protected nature"}, //OC special
-		{"58","2618","nogps","35","135","Without GPS (letterboxes, cistes, compass juggling ...)"}, //OC special
-		{"59","2620","oconly","6","106","Only loggable at Opencaching"},// 120 Nur bei Opencaching logbar
-		{"60","2622","othercache","57","157","Other cache type"}, //OC special
-		{"61","2624","overnight","37","137","Overnight stay necessary"}, //OC special
-		{"62","2644","train","10","110","Active railway nearby"}, //OC special
-		{"63","2630","riddle","55","0",""},// 130 R?tsel
-		{"64","2646","webcam","32","132","Webcam"}, //OC special
-		{"65","2634","steep","27","127","Hilly area"}, //OC special
-		{"66","2636","submerged","34","134","In the water"}, //OC special
-		{"67","2638","tide","41","141","Tide"}, //OC special
-		{"68","2640","time","39","139","Only available at specified times"}, //OC special
-		{"69","2642","tools","46","0","Special Tool required"},// 142 Spezielle Ausr?stung
-		{"70","2648","wiki","54","154","Investigation"}, //OC special
-		{"71","2650","wwwlink","7","107","Hyperlink to another caching portal only"}, //OC special
-		{"72","2652","landf","0","45","Lost And Found Tour"}, // thx to Kappler and MiK
-		{"73","2654","rv","0","46","Truck Driver/RV"},// changed by Moorteufel 12.07.10 
-		{"74","2656","field_puzzle","0","47","Field Puzzle"},// changed by Moorteufel 12.07.10
-		{"75","2658","uv","0","48","UV Light required"}, // added by araber95 14.8.10
-		{"76","2660","snowshoes","0","49","Snowshoes"}, // added by araber95 14.8.10"
-		{"77","2662","skiis","0","50","Cross Country Skis"}, // added by araber95 14.8.10
-		{"78","2664","s-tool","0","51","Special Tool required"}, // added by araber95 14.8.10
-		{"79","2666","nightcache","0","52","Night Cache"}, // added by araber95 14.8.10
-		{"80","2668","parkngrab","0","53","Park and grab"}, // added by araber95 14.8.10
-		{"81","2670","abandonedbuilding","0","54","Abandoned structure"}, // added by araber95 14.8.10
-		{"82","2672","hike_short","0","55","Short hike"}, // added by araber95 14.8.10
-		{"83","2674","hike_med","0","56","Medium Hike"}, // added by araber95 14.8.10
-		{"84","2676","hike_long","0","57","Long Hike"}, // added by araber95 14.8.10
-		{"85","2678","fuel","0","58","Fuel nearby"}, // changed by araber95 14.08.10 
-		{"86","2680","food","0","59","Food nearby"}, // changed by araber95 14.08.10
-		{"87","2681","wirelessbeacon","0","60","Wireless Beacon"}, // added by araber95 27.10.10		
-		{"88","2588","firstaid","23","123","First aid available"}, //OC special
-		// {"-1","2500","error","0","0",""}, //
+	private final static int GC_TEXT = 5; // for export , didn't extract by myself, copied from forum
+	private static final String[][] attRef = { { "00", "2502", "available", "38", "13", "Available at all times" },// 02 available 24-7
+			{ "01", "2504", "bicycles", "0", "32", "Bicycles" },// 04 bikes allowed
+			{ "02", "2506", "boat", "52", "4", "Boat" },// 06 Wasserfahrzeug
+			// {"03","2508","cactus","0","0",""},//08 removed 14.08.10 araber95
+			{ "04", "2510", "campfires", "0", "38", "Campfires" },// 10 campfires allowed
+			{ "05", "2512", "camping", "0", "31", "Camping available" },// 12 Camping allowed
+			{ "06", "2514", "cliff", "11", "21", "Cliff / falling rocks" },// 14 falling-rocks nearby
+			{ "07", "2516", "climbing", "28", "10", "Difficult climbing" },// 16 easy climbing(OC-28), difficult climbing(GC-10)
+			{ "08", "2518", "compass", "47", "147", "Compass" }, // OC special
+			{ "09", "2520", "cow", "0", "43", "Watch for livestock" },// 20 watch for livestock
+			{ "10", "2522", "danger", "9", "23", "Dangerous area" },// 22 dangerous area
+			{ "11", "2524", "dogs", "0", "1", "Dogs" },// 24 dogs allowed
+			{ "12", "2526", "fee", "36", "2", "Access or parking fee" },// 26 access/parking fees
+			// {"13","2528","hiking","0","9","Significant hike"},//28 significant hike : removed
+			{ "13", "2528", "hiking", "25", "125", "Long walk" }, // OC special
+			{ "14", "2530", "horses", "0", "37", "Horses" },// 30 horses allowed
+			{ "15", "2532", "hunting", "12", "22", "Hunting" },// 32 hunting area
+			{ "16", "2534", "jeeps", "0", "35", "Off-road vehicles" },// 34 off-road vehicles allowed
+			{ "17", "2536", "kids", "59", "6", "Recommended for kids" },// 36 kid friendly
+			{ "18", "2538", "mine", "15", "20", "Abandoned mines" },// 38
+			{ "19", "2540", "motorcycles", "0", "33", "Motorcycles" },// 40 motorcycles allowed
+			{ "20", "2542", "night", "1", "14", "Recommended at night" },// 42 recommended at night
+			{ "21", "2544", "onehour", "0", "7", "Takes less than an hour" },// 44 takes less than one hour
+			{ "22", "2546", "parking", "18", "25", "Parking available" },// 46 parking available
+			{ "23", "2548", "phone", "22", "29", "Telephone nearby" },// 48 telephone nearby
+			{ "24", "2550", "picnic", "0", "30", "Picnic tables nearby" },// 50 picnic tables available
+			{ "25", "2552", "poisonoak", "16", "17", "Poison plants" },// 52 Giftige Pflanzen
+			{ "26", "2554", "public", "19", "26", "Public transportation" },// 54 public transit available
+			{ "27", "2556", "quads", "0", "34", "Quads" },// 56 quads allowed
+			{ "28", "2558", "rappelling", "49", "3", "Climbing gear" },// 58 climbing gear Kletterausr?stung
+			{ "29", "2560", "restrooms", "21", "28", "Public restrooms nearby" },// 60 restrooms available
+			{ "30", "2562", "scenic", "0", "8", "Scenic view" },// 62 scenic view
+			{ "31", "2564", "scuba", "51", "5", "Scuba gear" },// 64 Tauchausr?stung
+			// {"32","2566","snakes","0","18","Snakes"},//66 araber95 replaced by Dangerous Animals 14.08.10
+			{ "32", "2566", "dangerousanimals", "0", "18", "Dangerous Animals" },// 66
+			{ "33", "2568", "snowmobiles", "0", "36", "Snowmobiles" },// 68
+			{ "34", "2570", "stealth", "0", "40", "Stealth required" },// 70 stealth required (Heimlich,List,Schl?ue)
+			{ "35", "2572", "stroller", "0", "41", "Stroller accessible" },// 72 stroller accessible
+			{ "36", "2574", "swimming", "29", "12", "May require swimming" },// 74
+			{ "37", "2576", "thorn", "13", "39", "Thorns" },// 76 thorns!
+			{ "38", "2578", "ticks", "14", "19", "Ticks" },// 78 ticks!
+			{ "39", "2580", "wading", "26", "11", "May require wading" },// 80 may require wading
+			{ "40", "2582", "water", "20", "27", "Drinking water nearby" },// 82 drinking water nearby
+			{ "41", "2584", "wheelchair", "0", "24", "Wheelchair accessible" },// 84 wheelchair accessible
+			{ "42", "2586", "winter", "44", "15", "Available during winter" },// 86 available in winter 132 Schneesicheres Versteck
+			{ "43", "2588", "firstaid", "0", "42", "Firstaid" }, // GC: Cachewartung notwendig (Auto Attribut) , OC: erste Hilfe
+			{ "44", "2590", "flashlight", "48", "44", "Flashlight required" }, // 90 Flashlight required
+			{ "45", "2592", "aircraft", "53", "153", "Aircraft" }, // OC special //38 GC removed
+			{ "46", "2594", "animals", "17", "0", "" },// 94 Giftige/gef%e4hrliche Tiere
+			{ "47", "2596", "arith_prob", "56", "156", "Arithmetical problem" }, // OC special
+			{ "48", "2598", "ask", "58", "158", "Ask owner for start conditions" }, // OC special
+			{ "49", "2600", "car", "24", "0", "" },// 100 Nahe beim Auto
+			{ "50", "2602", "cave", "50", "150", "Cave equipment" }, // OC special
+			{ "51", "2604", "date", "42", "142", "All seasons" }, // OC special
+			{ "52", "2606", "day", "40", "140", "by day only" }, // OC special
+			{ "53", "2608", "indoor", "33", "133", "Within enclosed rooms (caves, buildings etc.)" }, // OC special
+			{ "54", "2610", "interestsign", "30", "130", "Point of interest" }, // OC special
+			{ "55", "2612", "letter", "8", "108", "Letterbox (needs stamp)" }, // OC special
+			{ "56", "2614", "moving", "31", "131", "Moving target" }, // OC special
+			{ "57", "2616", "naturschutz", "43", "143", "Breeding season / protected nature" }, // OC special
+			{ "58", "2618", "nogps", "35", "135", "Without GPS (letterboxes, cistes, compass juggling ...)" }, // OC special
+			{ "59", "2620", "oconly", "6", "106", "Only loggable at Opencaching" },// 120 Nur bei Opencaching logbar
+			{ "60", "2622", "othercache", "57", "157", "Other cache type" }, // OC special
+			{ "61", "2624", "overnight", "37", "137", "Overnight stay necessary" }, // OC special
+			{ "62", "2644", "train", "10", "110", "Active railway nearby" }, // OC special
+			{ "63", "2630", "riddle", "55", "0", "" },// 130 R?tsel
+			{ "64", "2646", "webcam", "32", "132", "Webcam" }, // OC special
+			{ "65", "2634", "steep", "27", "127", "Hilly area" }, // OC special
+			{ "66", "2636", "submerged", "34", "134", "In the water" }, // OC special
+			{ "67", "2638", "tide", "41", "141", "Tide" }, // OC special
+			{ "68", "2640", "time", "39", "139", "Only available at specified times" }, // OC special
+			{ "69", "2642", "tools", "46", "0", "Special Tool required" },// 142 Spezielle Ausr?stung
+			{ "70", "2648", "wiki", "54", "154", "Investigation" }, // OC special
+			{ "71", "2650", "wwwlink", "7", "107", "Hyperlink to another caching portal only" }, // OC special
+			{ "72", "2652", "landf", "0", "45", "Lost And Found Tour" }, // thx to Kappler and MiK
+			{ "73", "2654", "rv", "0", "46", "Truck Driver/RV" },// changed by Moorteufel 12.07.10
+			{ "74", "2656", "field_puzzle", "0", "47", "Field Puzzle" },// changed by Moorteufel 12.07.10
+			{ "75", "2658", "uv", "0", "48", "UV Light required" }, // added by araber95 14.8.10
+			{ "76", "2660", "snowshoes", "0", "49", "Snowshoes" }, // added by araber95 14.8.10"
+			{ "77", "2662", "skiis", "0", "50", "Cross Country Skis" }, // added by araber95 14.8.10
+			{ "78", "2664", "s-tool", "0", "51", "Special Tool required" }, // added by araber95 14.8.10
+			{ "79", "2666", "nightcache", "0", "52", "Night Cache" }, // added by araber95 14.8.10
+			{ "80", "2668", "parkngrab", "0", "53", "Park and grab" }, // added by araber95 14.8.10
+			{ "81", "2670", "abandonedbuilding", "0", "54", "Abandoned structure" }, // added by araber95 14.8.10
+			{ "82", "2672", "hike_short", "0", "55", "Short hike" }, // added by araber95 14.8.10
+			{ "83", "2674", "hike_med", "0", "56", "Medium Hike" }, // added by araber95 14.8.10
+			{ "84", "2676", "hike_long", "0", "57", "Long Hike" }, // added by araber95 14.8.10
+			{ "85", "2678", "fuel", "0", "58", "Fuel nearby" }, // changed by araber95 14.08.10
+			{ "86", "2680", "food", "0", "59", "Food nearby" }, // changed by araber95 14.08.10
+			{ "87", "2681", "wirelessbeacon", "0", "60", "Wireless Beacon" }, // added by araber95 27.10.10
+			{ "88", "2588", "firstaid", "23", "123", "First aid available" }, // OC special
+			{ "89", "2685", "sponsored", "0", "61", "Sponsored Cache" },
+	// {"-1","2500","error","0","0",""}, //
 
 	};
-    public static int maxAttRef=attRef.length;	
-    private static String IMAGEDIR=STRreplace.replace(FileBase.getProgramDirectory()+"/attributes/", "//", "/");
-    /*
-    private static String getImageName(int cw_Id, int cw_Inc){
-		if (cw_Id<0 || cw_Id>maxAttRef)
-			return "error.gif";
-		else {
-			switch (cw_Inc) {
-			case 1: return attRef[cw_Id][PIC_NAME]+"-yes.gif";
-			case 0: return attRef[cw_Id][PIC_NAME]+"-no.gif";
-			case 2: return attRef[cw_Id][PIC_NAME]+"-non.gif";
-			default:return "error.gif";
-			}
+	public static int maxAttRef = attRef.length;
+	private static String IMAGEDIR = STRreplace.replace(FileBase.getProgramDirectory() + "/attributes/", "//", "/");
+
+	/*
+	 * private static String getImageName(int cw_Id, int cw_Inc){ if (cw_Id<0 || cw_Id>maxAttRef) return "error.gif"; else { switch (cw_Inc) { case 1: return attRef[cw_Id][PIC_NAME]+"-yes.gif"; case 0: return attRef[cw_Id][PIC_NAME]+"-no.gif"; case 2:
+	 * return attRef[cw_Id][PIC_NAME]+"-non.gif"; default:return "error.gif"; } } }
+	 */
+	private static String getMsg(int cw_Id, int cw_Inc) {
+		if (cw_Id < 0 || cw_Id >= maxAttRef) {
+			return MyLocale.getMsg(2500, "error attribute");
 		}
-	}
-	*/
-    private static String getMsg(int cw_Id, int cw_Inc){
-    	if (cw_Id<0 || cw_Id>=maxAttRef) {
-    		return MyLocale.getMsg(2500,"error attribute");
-    	}
-		if (cw_Inc==0)
-			return MyLocale.getMsg(Common.parseInt(attRef[cw_Id][MSG_NR])-1,"");
+		if (cw_Inc == 0)
+			return MyLocale.getMsg(Common.parseInt(attRef[cw_Id][MSG_NR]) - 1, "");
 		else
-			return MyLocale.getMsg(Common.parseInt(attRef[cw_Id][MSG_NR]),"");
+			return MyLocale.getMsg(Common.parseInt(attRef[cw_Id][MSG_NR]), "");
 	}
-    private static mImage[] yesImages=new mImage[maxAttRef];
-	private static mImage[] noImages=new mImage[maxAttRef];
-	private static mImage[] nonImages=new mImage[maxAttRef];
-	private static final mImage errorImage=new mImage(IMAGEDIR+"error.gif");	
+
+	private static mImage[] yesImages = new mImage[maxAttRef];
+	private static mImage[] noImages = new mImage[maxAttRef];
+	private static mImage[] nonImages = new mImage[maxAttRef];
+	private static final mImage errorImage = new mImage(IMAGEDIR + "error.gif");
+
 	/**
 	 * Returns the width of the attribute icons
-	 * @return The width of the images 
+	 * 
+	 * @return The width of the images
 	 */
 	public static int getImageWidth() {
 		return errorImage.image.getWidth();
-	}	
-    /**
-     * Get the image for a given attribute number. 
-     * We use lazy initialisation here, i.e. the images are only loaded when they are requested. 
-     * @return
-     */
-    public mImage getImage() {
-    	if (_Id<0 || _Id>=maxAttRef) {
-    		return errorImage;
-    	}
-    	if (_Inc==1) {
-    		if (yesImages[_Id]==null) {yesImages[_Id]=new mImage(IMAGEDIR+getImageName());}
-    		return yesImages[_Id];
-    	}
-    	else if (_Inc==0) {
-    		if (noImages[_Id]==null) {noImages[_Id]=new mImage(IMAGEDIR+getImageName());}
-    		return noImages[_Id];
-    	} 
-    	else {
-    		if (nonImages[_Id]==null) {nonImages[_Id]=new mImage(IMAGEDIR+getImageName());}
-    		return nonImages[_Id];
-    	}
-    }	
+	}
+
+	/**
+	 * Get the image for a given attribute number. We use lazy initialisation here, i.e. the images are only loaded when they are requested.
+	 * 
+	 * @return
+	 */
+	public mImage getImage() {
+		if (_Id < 0 || _Id >= maxAttRef) {
+			return errorImage;
+		}
+		if (_Inc == 1) {
+			if (yesImages[_Id] == null) {
+				yesImages[_Id] = new mImage(IMAGEDIR + getImageName());
+			}
+			return yesImages[_Id];
+		} else if (_Inc == 0) {
+			if (noImages[_Id] == null) {
+				noImages[_Id] = new mImage(IMAGEDIR + getImageName());
+			}
+			return noImages[_Id];
+		} else {
+			if (nonImages[_Id] == null) {
+				nonImages[_Id] = new mImage(IMAGEDIR + getImageName());
+			}
+			return nonImages[_Id];
+		}
+	}
 }

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2011-05-08 11:30:44 UTC (rev 2996)
+++ trunk/src/CacheWolf/CacheHolder.java	2011-05-10 21:54:53 UTC (rev 2997)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.exp.Exporter;
@@ -45,12 +45,11 @@
 import ewe.util.Vector;
 
 /**
- *	A class to hold information on a cache.<br>
- *	Not all attributes are filled at once. You will have to look at other
- *	classes and methods to get more information.
- *	
+ * A class to hold information on a cache.<br>
+ * Not all attributes are filled at once. You will have to look at other classes and methods to get more information.
+ * 
  */
-public class CacheHolder{
+public class CacheHolder {
 	protected static final String NOBEARING = "?";
 	protected static final String EMPTY = "";
 
@@ -79,12 +78,12 @@
 	private String bearing = NOBEARING;
 	/** The angle (0=North, 180=South) from the current centre to this point */
 	public double degrees = 0;
-	/** The difficulty of the cache from 1 to 5 in .5 incements */ 
+	/** The difficulty of the cache from 1 to 5 in .5 incements */
 	private byte hard = CacheTerrDiff.CW_DT_UNSET;
 	/** The terrain rating of the cache from 1 to 5 in .5 incements */
 	private byte terrain = CacheTerrDiff.CW_DT_UNSET;
-	/** The cache type (@see CacheType for translation table)  */
-	private byte type; 
+	/** The cache type (@see CacheType for translation table) */
+	private byte type;
 	/** True if the cache has been archived */
 	private boolean archived = false;
 	/** True if the cache is available for searching */
@@ -97,7 +96,7 @@
 	private boolean filtered = false;
 	/** True if the number of logs for this cache has changed */
 	private boolean log_updated = false;
-	/** True if cache details have changed: longDescription, Hints,  */
+	/** True if cache details have changed: longDescription, Hints, */
 	private boolean cache_updated = false;
 	/** True if the cache data is incomplete (e.g. an error occurred during spidering */
 	private boolean incomplete = false;
@@ -119,7 +118,7 @@
 	private int numRecommended = 0;
 	/** Number of Founds since start of recommendations system */
 	private int numFoundsSinceRecommendation = 0;
-	/** Recommendation score: calculated as rations  numRecommended / numLogsSinceRecommendation * 100 */
+	/** Recommendation score: calculated as rations numRecommended / numLogsSinceRecommendation * 100 */
 	public int recommendationScore = 0;
 	/** True if this cache has travelbugs */
 	private boolean bugs = false;
@@ -127,7 +126,7 @@
 	private boolean html = true;
 	/** List of additional waypoints associated with this waypoint */
 	public Vector addiWpts = new Vector();
-	/** in range is used by the route filter to identify caches in range of a segment*/
+	/** in range is used by the route filter to identify caches in range of a segment */
 	public boolean in_range = false;
 	/** If this is an additional waypoint, this links back to the main waypoint */
 	public CacheHolder mainCache;
@@ -138,304 +137,297 @@
 	/** True if a note is entered for the cache */
 	private boolean hasNote = false;
 	private CacheHolderDetail details = null;
-	/** When sorting the cacheDB this field is used. The relevant field is copied here and
-	 *  the sort is always done on this field to speed up the sorting process 
+	/**
+	 * When sorting the cacheDB this field is used. The relevant field is copied here and the sort is always done on this field to speed up the sorting process
 	 */
 	public String sort;
-	private static StringBuffer sb=new StringBuffer(530); // Used in toXML()
+	private static StringBuffer sb = new StringBuffer(530); // Used in toXML()
 
-	private long[] attributesBits = {0l,0l,0l,0l};
-	
+	private long[] attributesBits = { 0l, 0l, 0l, 0l };
+
 	private IconAndText iconAndTextWP = null;
 	private int iconAndTextWPLevel = 0;
 
-	static char decSep,notDecSep;
+	static char decSep, notDecSep;
 	static {
-		decSep=MyLocale.getDigSeparator().charAt(0);
-		notDecSep = (decSep == '.'?',':'.');
+		decSep = MyLocale.getDigSeparator().charAt(0);
+		notDecSep = (decSep == '.' ? ',' : '.');
 	}
 
 	public CacheHolder() {
 		// do nothing
 	}
-	
+
 	public CacheHolder(String wp) {
 		wayPoint = wp;
-		type=CacheType.CW_TYPE_ERROR;
-    }
-	
+		type = CacheType.CW_TYPE_ERROR;
+	}
+
 	public CacheHolder(String xmlString, int version) {
-		int start,end;
-	        try {
-				if (version == 1) {
-			        start = xmlString.indexOf('"');
-			        end = xmlString.indexOf('"', start + 1);
-			        setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-			        
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-			        
-			        // Assume coordinates are in decimal format
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
-			                notDecSep, decSep));
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
-			                notDecSep, decSep));
-			        pos = new CWPoint(lat, lon);
-			        LatLon = pos.toString();
-			        
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setDateHidden(xmlString.substring(start + 1, end));
-			        // Convert the US format to YYYY-MM-DD if necessary
-			        if (getDateHidden().indexOf('/') > -1)
-				        setDateHidden(DateFormat.MDY2YMD(getDateHidden()));
-			        
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-			        
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setCacheStatus(xmlString.substring(start + 1, end));
-			        
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-		        	setType(CacheType.v1Converter((xmlString.substring(start + 1, end))));
-		            
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        if (isAddiWpt() || isCustomWpt()) {
-			        	setHard(CacheTerrDiff.CW_DT_UNSET);
-			        } else {
-				        try {
-				        	setHard(CacheTerrDiff.v1Converter(xmlString.substring(start + 1, end)));
-				        } catch (IllegalArgumentException ex) {
-				        	setHard(CacheTerrDiff.CW_DT_ERROR);
-				        	setIncomplete(true);
-				        	Global.getPref().log(wayPoint, ex, true);
-				        }
-			        }
-			        start = xmlString.indexOf('"', end + 1);
-				    end = xmlString.indexOf('"', start + 1);
-				    if (isAddiWpt() || isCustomWpt()) {
-				    	setTerrain(CacheTerrDiff.CW_DT_UNSET);
-				    } else {
-					    try {
-					    	setTerrain(CacheTerrDiff.v1Converter(xmlString.substring(start + 1, end)));
-					    } catch (IllegalArgumentException ex) {
-					    	setTerrain(CacheTerrDiff.CW_DT_ERROR);
-					    	setIncomplete(true);
-					    	Global.getPref().log(wayPoint, ex, true);
-				        }
-				    }
-			        // The next item was 'dirty' but this is no longer used.
-		            start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setFiltered(xmlString.substring(start + 1, end).equals("true"));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        if (isAddiWpt() || isCustomWpt()) {
-			        	setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
-			        } else {
-				        try {
-				        	setCacheSize(CacheSize.v1Converter(xmlString.substring(start + 1, end)));
-				        } catch (IllegalArgumentException ex) {
-				        	setCacheSize(CacheSize.CW_SIZE_ERROR);
-				        	setIncomplete(true);
-				        	Global.getPref().log(wayPoint, ex, true);
-				        }
-			        }
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setAvailable(xmlString.substring(start + 1, end).equals("true"));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setArchived(xmlString.substring(start + 1, end).equals("true"));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setHas_bugs(xmlString.substring(start + 1, end).equals("true"));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setBlack(xmlString.substring(start + 1, end).equals("true"));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setOwned(xmlString.substring(start + 1, end).equals("true"));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setFound(xmlString.substring(start + 1, end).equals("true"));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setNew(xmlString.substring(start + 1, end).equals("true"));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setLog_updated(xmlString.substring(start + 1, end).equals("true"));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setUpdated(xmlString.substring(start + 1, end).equals("true"));
-			        // for backwards compatibility set value to true, if it is not in the file
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setHTML(!xmlString.substring(start + 1, end).equals("false"));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-		            setNoFindLogs((byte)Convert.toInt(xmlString.substring(start + 1, end)));
-	
-		            start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setOcCacheID(xmlString.substring(start + 1, end));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setIncomplete(xmlString.substring(start + 1, end).equals("true") || incomplete);
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setLastSync(xmlString.substring(start + 1, end));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
-	
-			        start = xmlString.indexOf('"', end + 1);
-			        end = xmlString.indexOf('"', start + 1);
-			        setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
-			        recommendationScore = LogList.getScore(getNumRecommended(),
-			                getNumFoundsSinceRecommendation());
-	
-			        start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            long[] attribsBits={0l,0l,0l,0l};
-		            if (start > -1 && end > -1) {
-		            	attribsBits[0]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-		        		
-				        start = xmlString.indexOf('"', end + 1);
-				        end = xmlString.indexOf('"', start + 1);
-				        if (start > -1 && end > -1)
-			            	attribsBits[2]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-		            }
-		            setAttribsAsBits(attribsBits);
-	            } else if (version == 3 || version == 2) {
-		            start = xmlString.indexOf('"');
-		            end = xmlString.indexOf('"', start + 1);
-		            setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-		            
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-		            
-		            // Assume coordinates are in decimal format
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
-		                    notDecSep, decSep));
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
-		                    notDecSep, decSep));
-		            pos = new CWPoint(lat, lon);
-		            LatLon = pos.toString();
-		            
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            setDateHidden(xmlString.substring(start + 1, end));
-		            // Convert the US format to YYYY-MM-DD if necessary
-		            if (getDateHidden().indexOf('/') > -1)
-			            setDateHidden(DateFormat.MDY2YMD(getDateHidden()));
-		            
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-		            
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            setCacheStatus(xmlString.substring(start + 1, end));
-		            
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            setOcCacheID(xmlString.substring(start + 1, end));
-		            
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            setLastSync(xmlString.substring(start + 1, end));
-		            
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
-		            
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
-		            recommendationScore = LogList.getScore(getNumRecommended(),
-		                    getNumFoundsSinceRecommendation());
-		            
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            long[] attribsBits={0l,0l,0l,0l};
-			        if (start > -1 && end > -1) {
-			        	attribsBits[0]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-	
-				        start = xmlString.indexOf('"', end + 1);
-				        end = xmlString.indexOf('"', start + 1);
-				        if (start > -1 && end > -1)
-				        	attribsBits[2]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-			        }
-			        
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            this.long2boolFields(Convert.parseLong(xmlString.substring(start + 1, end)));
-		            
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-		            if (version == 2) {
-		            	long2byteFieldsv2(Convert.parseLong(xmlString.substring(start + 1, end)));
-		            } else {
-		            	long2byteFields(Convert.parseLong(xmlString.substring(start + 1, end)));
-		            }
-		            start = xmlString.indexOf('"', end + 1);
-		            end = xmlString.indexOf('"', start + 1);
-			        if (start > -1 && end > -1) {
-			        	attribsBits[1]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-	
-				        start = xmlString.indexOf('"', end + 1);
-				        end = xmlString.indexOf('"', start + 1);
-				        if (start > -1 && end > -1)
-				        	attribsBits[3]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-			        }
-			        setAttribsAsBits(attribsBits);
-	            }
-				if (version < Profile.CURRENTFILEFORMAT) {
-		            // forceload of details, creates waypoint.xml if missing
-		            details = getCacheDetails(false);
-		            // make sure details get (re)written in new format
-		            details.hasUnsavedChanges = true;
-		            // update information on notes and solver info
-		            setHasNote(!details.getCacheNotes().equals(""));
-			    setHasSolver(!details.getSolver().equals(""));
+		int start, end;
+		try {
+			if (version == 1) {
+				start = xmlString.indexOf('"');
+				end = xmlString.indexOf('"', start + 1);
+				setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				// Assume coordinates are in decimal format
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(notDecSep, decSep));
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(notDecSep, decSep));
+				pos = new CWPoint(lat, lon);
+				LatLon = pos.toString();
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setDateHidden(xmlString.substring(start + 1, end));
+				// Convert the US format to YYYY-MM-DD if necessary
+				if (getDateHidden().indexOf('/') > -1)
+					setDateHidden(DateFormat.toYYMMDD(getDateHidden()));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setCacheStatus(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setType(CacheType.v1Converter((xmlString.substring(start + 1, end))));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				if (isAddiWpt() || isCustomWpt()) {
+					setHard(CacheTerrDiff.CW_DT_UNSET);
+				} else {
+					try {
+						setHard(CacheTerrDiff.v1Converter(xmlString.substring(start + 1, end)));
+					} catch (IllegalArgumentException ex) {
+						setHard(CacheTerrDiff.CW_DT_ERROR);
+						setIncomplete(true);
+						Global.getPref().log(wayPoint, ex, true);
+					}
 				}
-	        } catch (Exception ex) {
-	        	// Global.getPref().log("Ignored Exception in CacheHolder()", ex, true);
-	        }
-        }
-	
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				if (isAddiWpt() || isCustomWpt()) {
+					setTerrain(CacheTerrDiff.CW_DT_UNSET);
+				} else {
+					try {
+						setTerrain(CacheTerrDiff.v1Converter(xmlString.substring(start + 1, end)));
+					} catch (IllegalArgumentException ex) {
+						setTerrain(CacheTerrDiff.CW_DT_ERROR);
+						setIncomplete(true);
+						Global.getPref().log(wayPoint, ex, true);
+					}
+				}
+				// The next item was 'dirty' but this is no longer used.
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setFiltered(xmlString.substring(start + 1, end).equals("true"));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				if (isAddiWpt() || isCustomWpt()) {
+					setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
+				} else {
+					try {
+						setCacheSize(CacheSize.v1Converter(xmlString.substring(start + 1, end)));
+					} catch (IllegalArgumentException ex) {
+						setCacheSize(CacheSize.CW_SIZE_ERROR);
+						setIncomplete(true);
+						Global.getPref().log(wayPoint, ex, true);
+					}
+				}
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setAvailable(xmlString.substring(start + 1, end).equals("true"));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setArchived(xmlString.substring(start + 1, end).equals("true"));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setHas_bugs(xmlString.substring(start + 1, end).equals("true"));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setBlack(xmlString.substring(start + 1, end).equals("true"));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setOwned(xmlString.substring(start + 1, end).equals("true"));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setFound(xmlString.substring(start + 1, end).equals("true"));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setNew(xmlString.substring(start + 1, end).equals("true"));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setLog_updated(xmlString.substring(start + 1, end).equals("true"));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setUpdated(xmlString.substring(start + 1, end).equals("true"));
+				// for backwards compatibility set value to true, if it is not in the file
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setHTML(!xmlString.substring(start + 1, end).equals("false"));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setNoFindLogs((byte) Convert.toInt(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setOcCacheID(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setIncomplete(xmlString.substring(start + 1, end).equals("true") || incomplete);
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setLastSync(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
+				recommendationScore = LogList.getScore(getNumRecommended(), getNumFoundsSinceRecommendation());
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				long[] attribsBits = { 0l, 0l, 0l, 0l };
+				if (start > -1 && end > -1) {
+					attribsBits[0] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+
+					start = xmlString.indexOf('"', end + 1);
+					end = xmlString.indexOf('"', start + 1);
+					if (start > -1 && end > -1)
+						attribsBits[2] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+				}
+				setAttribsAsBits(attribsBits);
+			} else if (version == 3 || version == 2) {
+				start = xmlString.indexOf('"');
+				end = xmlString.indexOf('"', start + 1);
+				setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				// Assume coordinates are in decimal format
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(notDecSep, decSep));
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(notDecSep, decSep));
+				pos = new CWPoint(lat, lon);
+				LatLon = pos.toString();
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setDateHidden(xmlString.substring(start + 1, end));
+				// Convert the US format to YYYY-MM-DD if necessary
+				if (getDateHidden().indexOf('/') > -1)
+					setDateHidden(DateFormat.toYYMMDD(getDateHidden()));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setCacheStatus(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setOcCacheID(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setLastSync(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
+				recommendationScore = LogList.getScore(getNumRecommended(), getNumFoundsSinceRecommendation());
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				long[] attribsBits = { 0l, 0l, 0l, 0l };
+				if (start > -1 && end > -1) {
+					attribsBits[0] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+
+					start = xmlString.indexOf('"', end + 1);
+					end = xmlString.indexOf('"', start + 1);
+					if (start > -1 && end > -1)
+						attribsBits[2] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+				}
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				this.long2boolFields(Convert.parseLong(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				if (version == 2) {
+					long2byteFieldsv2(Convert.parseLong(xmlString.substring(start + 1, end)));
+				} else {
+					long2byteFields(Convert.parseLong(xmlString.substring(start + 1, end)));
+				}
+				start = xmlString.indexOf('"', end + 1);
+				end = xmlString.indexOf('"', start + 1);
+				if (start > -1 && end > -1) {
+					attribsBits[1] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+
+					start = xmlString.indexOf('"', end + 1);
+					end = xmlString.indexOf('"', start + 1);
+					if (start > -1 && end > -1)
+						attribsBits[3] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+				}
+				setAttribsAsBits(attribsBits);
+			}
+			if (version < Profile.CURRENTFILEFORMAT) {
+				// forceload of details, creates waypoint.xml if missing
+				details = getCacheDetails(false);
+				// make sure details get (re)written in new format
+				details.hasUnsavedChanges = true;
+				// update information on notes and solver info
+				setHasNote(!details.getCacheNotes().equals(""));
+				setHasSolver(!details.getSolver().equals(""));
+			}
+		} catch (Exception ex) {
+			// Global.getPref().log("Ignored Exception in CacheHolder()", ex, true);
+		}
+	}
+
 	/**
-	 * Returns the distance in formatted output. Using kilometers when metric system is active,
-	 * using miles when imperial system is active.
+	 * Returns the distance in formatted output. Using kilometers when metric system is active, using miles when imperial system is active.
 	 * 
 	 * @return The current distance.
 	 */
@@ -461,8 +453,7 @@
 				}
 				result = MyLocale.formatDouble(newValue, "0.00") + " " + newUnit;
 			} else {
-				result = "? "
-				        + (Global.getPref().metricSystem == Metrics.IMPERIAL ? Metrics.getUnit(Metrics.MILES) : Metrics.getUnit(Metrics.KILOMETER));
+				result = "? " + (Global.getPref().metricSystem == Metrics.IMPERIAL ? Metrics.getUnit(Metrics.MILES) : Metrics.getUnit(Metrics.KILOMETER));
 			}
 			// Caching values, so reevaluation is only done when really needed
 			this.lastKilom = this.kilom;
@@ -471,31 +462,26 @@
 		}
 		return result;
 	}
-	/** 
-	 * Updates Cache information with information provided by cache given as argument. This is used
-	 * to update the cache with the information retrieved from files or web: The argument cache
-	 * is the one that is filled with the read information, <code>this</code> is the cache that
-	 * is already in the database and subject to update. 
-	 * @param ch The cache who's information is updating the current one
-	 * @param overwrite If <code>true</code>, then <i>status</i>, <i>is_found</i> and <i>position</i>
-	 * is updated, otherwise not.
+
+	/**
+	 * Updates Cache information with information provided by cache given as argument. This is used to update the cache with the information retrieved from files or web: The argument cache is the one that is filled with the read information,
+	 * <code>this</code> is the cache that is already in the database and subject to update.
+	 * 
+	 * @param ch
+	 *            The cache who's information is updating the current one
+	 * @param overwrite
+	 *            If <code>true</code>, then <i>status</i>, <i>is_found</i> and <i>position</i> is updated, otherwise not.
 	 */
 	public void update(CacheHolder ch) {
 		this.recommendationScore = ch.recommendationScore;
 		this.setNumFoundsSinceRecommendation(ch.getNumFoundsSinceRecommendation());
 		this.setNumRecommended(ch.getNumRecommended());
-		boolean mayChangeCoordinates = !this.cacheStatus.startsWith(MyLocale.getMsg(362,"solved"));
-		/* Here we have to distinguish several cases:
-		 * this.is_found       this                ch               Update 'this'
-		 *                                         (values are
-		 *                                     empty or yyyy-mm-dd)
-		 * ----------------------------------------------------------------------
-		 * false               any                 yyyy-mm-dd       yes
-		 * true                "Found"             yyyy-mm-dd       yes
-		 * true                yyyy-mm-dd          yyyy-mm-dd       yes (or no)
-		 * true                yyyy-mm-dd hh:mm    yyyy-mm-dd       no
-		*/
-		if (!this.found || this.cacheStatus.indexOf(":")<0) {
+		boolean mayChangeCoordinates = !this.cacheStatus.startsWith(MyLocale.getMsg(362, "solved"));
+		/*
+		 * Here we have to distinguish several cases: this.is_found this ch Update 'this' (values are empty or yyyy-mm-dd) ---------------------------------------------------------------------- false any yyyy-mm-dd yes true "Found" yyyy-mm-dd yes true
+		 * yyyy-mm-dd yyyy-mm-dd yes (or no) true yyyy-mm-dd hh:mm yyyy-mm-dd no
+		 */
+		if (!this.found || this.cacheStatus.indexOf(":") < 0) {
 			// don't overwrite with empty data
 			if (!ch.getCacheStatus().trim().equals("")) {
 				this.setCacheStatus(ch.getCacheStatus());
@@ -527,19 +513,20 @@
 		this.setFiltered(ch.is_filtered());
 		this.setIncomplete(ch.is_incomplete());
 		this.addiWpts = ch.addiWpts;
-		this.mainCache=ch.mainCache;
+		this.mainCache = ch.mainCache;
 		this.setOcCacheID(ch.getOcCacheID());
 		this.setNoFindLogs(ch.getNoFindLogs());
 		this.setHas_bugs(ch.has_bugs());
 		this.setHTML(ch.is_HTML());
-		this.sort=ch.sort;
+		this.sort = ch.sort;
 		this.setLastSync(ch.getLastSync());
 
 		this.setAttribsAsBits(ch.getAttributesBits());
 		if (ch.detailsLoaded()) {
 			this.getCacheDetails(false).update(ch.getCacheDetails(false));
-		}	
+		}
 	}
+
 	/**
 	 * Call it only when necessary, it takes time, because all logs must be parsed
 	 */
@@ -565,84 +552,93 @@
 		} else {
 			recommendationScore = -1;
 			setNumFoundsSinceRecommendation(-1);
-//			setNumRecommended(-1);
+			// setNumRecommended(-1);
 		}
 	}
-	
+
 	/** Return a XML string containing all the cache data for storing in index.xml */
 	public String toXML() {
-		calcRecommendationScore(); 
-		sb.delete(0,sb.length());
+		calcRecommendationScore();
+		sb.delete(0, sb.length());
 		sb.append("    <CACHE ");
-		sb.append(" name = \"");        sb.append(SafeXML.clean(getCacheName()));
-		sb.append("\" owner = \"");		sb.append(SafeXML.clean(getCacheOwner()));
-		sb.append("\" lat = \""); 		sb.append(pos.latDec ); 
-		sb.append("\" lon = \"");		sb.append(pos.lonDec);
-		sb.append("\" hidden = \"");	sb.append(getDateHidden());
-		sb.append("\" wayp = \"");		sb.append(SafeXML.clean(getWayPoint()));
-		sb.append("\" status = \"");	sb.append(getCacheStatus());
-		sb.append("\" ocCacheID = \"" );sb.append(getOcCacheID()); 
-		sb.append("\" lastSyncOC = \"" );sb.append(getLastSync()); 
-		sb.append("\" num_recommended = \"");sb.append(Convert.formatInt(getNumRecommended())); 
-		sb.append("\" num_found = \"" );sb.append(Convert.formatInt(getNumFoundsSinceRecommendation()));
+		sb.append(" name = \"");
+		sb.append(SafeXML.clean(getCacheName()));
+		sb.append("\" owner = \"");
+		sb.append(SafeXML.clean(getCacheOwner()));
+		sb.append("\" lat = \"");
+		sb.append(pos.latDec);
+		sb.append("\" lon = \"");
+		sb.append(pos.lonDec);
+		sb.append("\" hidden = \"");
+		sb.append(getDateHidden());
+		sb.append("\" wayp = \"");
+		sb.append(SafeXML.clean(getWayPoint()));
+		sb.append("\" status = \"");
+		sb.append(getCacheStatus());
+		sb.append("\" ocCacheID = \"");
+		sb.append(getOcCacheID());
+		sb.append("\" lastSyncOC = \"");
+		sb.append(getLastSync());
+		sb.append("\" num_recommended = \"");
+		sb.append(Convert.formatInt(getNumRecommended()));
+		sb.append("\" num_found = \"");
+		sb.append(Convert.formatInt(getNumFoundsSinceRecommendation()));
 		long[] attribsBits = getAttributesBits();
-		sb.append("\" attributesYes = \"" ); sb.append(Convert.formatLong(attribsBits[0]));
-		sb.append("\" attributesNo = \"" ); sb.append(Convert.formatLong(attribsBits[2]));
-		sb.append("\" boolFields=\"" ); sb.append(Convert.formatLong(this.boolFields2long()));
-		sb.append("\" byteFields=\"" ); sb.append(Convert.formatLong(this.byteFields2long()));
-		sb.append("\" attributesYes1 = \"" ); sb.append(Convert.formatLong(attribsBits[1]));
-		sb.append("\" attributesNo1 = \"" ); sb.append(Convert.formatLong(attribsBits[3]));
+		sb.append("\" attributesYes = \"");
+		sb.append(Convert.formatLong(attribsBits[0]));
+		sb.append("\" attributesNo = \"");
+		sb.append(Convert.formatLong(attribsBits[2]));
+		sb.append("\" boolFields=\"");
+		sb.append(Convert.formatLong(this.boolFields2long()));
+		sb.append("\" byteFields=\"");
+		sb.append(Convert.formatLong(this.byteFields2long()));
+		sb.append("\" attributesYes1 = \"");
+		sb.append(Convert.formatLong(attribsBits[1]));
+		sb.append("\" attributesNo1 = \"");
+		sb.append(Convert.formatLong(attribsBits[3]));
 		sb.append("\" />\n");
 		return sb.toString();
 	}
-	
+
 	/** Return a Hashtable containing all the cache data for Templates */
-	public Hashtable toHashtable(
-			Regex decSep, Regex badChars, 
-			int shortWaypointLength, int shortNameLength, int nrOfLogs,
-			TextCodec codec, GarminMap gm,
-			boolean withFoundText,
-			int ModTyp,
-			String expName
-			) {
+	public Hashtable toHashtable(Regex decSep, Regex badChars, int shortWaypointLength, int shortNameLength, int nrOfLogs, TextCodec codec, GarminMap gm, boolean withFoundText, int ModTyp, String expName) {
 		Hashtable varParams = new Hashtable();
 		CacheHolderDetail det = this.getCacheDetails(false);
 		varParams.put("PROGDIR", FileBase.getProgramDirectory());
 		varParams.put("PROFILDIR", Global.getProfile().dataDir);
 		varParams.put("ALIAS", Global.getPref().myAlias);
-		varParams.put("TYPE", CacheType.type2TypeTag(type)); //<type>
-		varParams.put("TYPENO",""+type);
-		varParams.put("SYM", CacheType.type2SymTag(type)); //<sym>
-		varParams.put("GSTYPE", CacheType.type2GSTypeTag(type)); //<groundspeak:type>
+		varParams.put("TYPE", CacheType.type2TypeTag(type)); // <type>
+		varParams.put("TYPENO", "" + type);
+		varParams.put("SYM", CacheType.type2SymTag(type)); // <sym>
+		varParams.put("GSTYPE", CacheType.type2GSTypeTag(type)); // <groundspeak:type>
 		varParams.put("SHORTTYPE", CacheType.getExportShortId(type));
 		if (isAddiWpt()) {
-			CacheHolder ch=this.mainCache;
-			varParams.put("MAINWP",ch.getWayPoint());
+			CacheHolder ch = this.mainCache;
+			varParams.put("MAINWP", ch.getWayPoint());
 			varParams.put("MAINWPNAME", ch.getCacheName());
-			varParams.put("DIFFICULTY", (ch.hard < 0)?"!<!":decSep.replaceAll(CacheTerrDiff.longDT(ch.hard)));
+			varParams.put("DIFFICULTY", (ch.hard < 0) ? "!<!" : decSep.replaceAll(CacheTerrDiff.longDT(ch.hard)));
 			String sHard = Integer.toString(ch.hard);
-			varParams.put("SHORTDIFFICULTY", (ch.hard < 0)?"":sHard);
-			varParams.put("SHDIFFICULTY", (ch.hard < 0)?"":sHard.substring(0,1));
-			varParams.put("TERRAIN", (ch.terrain < 0)?"":decSep.replaceAll(CacheTerrDiff.longDT(ch.terrain)));
+			varParams.put("SHORTDIFFICULTY", (ch.hard < 0) ? "" : sHard);
+			varParams.put("SHDIFFICULTY", (ch.hard < 0) ? "" : sHard.substring(0, 1));
+			varParams.put("TERRAIN", (ch.terrain < 0) ? "" : decSep.replaceAll(CacheTerrDiff.longDT(ch.terrain)));
 			String sTerrain = Integer.toString(ch.terrain);
-			varParams.put("SHORTTERRAIN", (ch.terrain < 0)?"":sTerrain);
-			varParams.put("SHTERRAIN", (ch.terrain < 0)?"":sTerrain.substring(0,1));
+			varParams.put("SHORTTERRAIN", (ch.terrain < 0) ? "" : sTerrain);
+			varParams.put("SHTERRAIN", (ch.terrain < 0) ? "" : sTerrain.substring(0, 1));
 			varParams.put("SIZE", CacheSize.cw2ExportString(ch.cacheSize));
 			varParams.put("SHORTSIZE", CacheSize.getExportShortId(ch.cacheSize));
 			varParams.put("OWNER", (ModTyp == 0) ? SafeXML.cleanGPX(ch.cacheOwner) : ch.cacheOwner);
 			varParams.put("DATE", ch.dateHidden);
-		}
-		else {
+		} else {
 			varParams.put("MAINWP", "");
 			varParams.put("MAINWPNAME", "");
-			varParams.put("DIFFICULTY", (isCustomWpt() || hard < 0)?"":decSep.replaceAll(CacheTerrDiff.longDT(hard)));
+			varParams.put("DIFFICULTY", (isCustomWpt() || hard < 0) ? "" : decSep.replaceAll(CacheTerrDiff.longDT(hard)));
 			String sHard = Integer.toString(hard);
-			varParams.put("SHORTDIFFICULTY", (isCustomWpt() || hard < 0)?"":sHard);
-			varParams.put("SHDIFFICULTY", (isCustomWpt() || hard < 0)?"":sHard.substring(0,1));
-			varParams.put("TERRAIN", (isCustomWpt() || terrain < 0)?"":decSep.replaceAll(CacheTerrDiff.longDT(terrain)));
+			varParams.put("SHORTDIFFICULTY", (isCustomWpt() || hard < 0) ? "" : sHard);
+			varParams.put("SHDIFFICULTY", (isCustomWpt() || hard < 0) ? "" : sHard.substring(0, 1));
+			varParams.put("TERRAIN", (isCustomWpt() || terrain < 0) ? "" : decSep.replaceAll(CacheTerrDiff.longDT(terrain)));
 			String sTerrain = Integer.toString(terrain);
-			varParams.put("SHORTTERRAIN", (isCustomWpt() || terrain < 0)?"":sTerrain);
-			varParams.put("SHTERRAIN", (isCustomWpt() || terrain < 0)?"":sTerrain.substring(0,1));
+			varParams.put("SHORTTERRAIN", (isCustomWpt() || terrain < 0) ? "" : sTerrain);
+			varParams.put("SHTERRAIN", (isCustomWpt() || terrain < 0) ? "" : sTerrain.substring(0, 1));
 			varParams.put("SIZE", CacheSize.cw2ExportString(cacheSize));
 			varParams.put("SHORTSIZE", CacheSize.getExportShortId(cacheSize));
 			varParams.put("OWNER", (ModTyp == 0) ? SafeXML.cleanGPX(cacheOwner) : cacheOwner);
@@ -650,48 +646,51 @@
 		}
 		if (isCustomWpt()) {
 
-		}		
-		varParams.put("WAYPOINT", wayPoint); //<name>
+		}
+		varParams.put("WAYPOINT", wayPoint); // <name>
 		int wpl = wayPoint.length();
 		int wps = (wpl < shortWaypointLength) ? 0 : wpl - shortWaypointLength;
 		varParams.put("SHORTWAYPOINT", wayPoint.substring(wps, wpl));
 		varParams.put("DISTANCE", decSep.replaceAll(getDistance()));
 		varParams.put("BEARING", bearing);
-		if ((pos!=null && pos.isValid())) {
+		if ((pos != null && pos.isValid())) {
 			varParams.put("LATLON", decSep.replaceAll(LatLon));
 			varParams.put("LAT", decSep.replaceAll(pos.getLatDeg(CWPoint.DD)));
-			varParams.put("LON", decSep.replaceAll(pos.getLonDeg(CWPoint.DD)));		
-		}
-		else {
+			varParams.put("LON", decSep.replaceAll(pos.getLonDeg(CWPoint.DD)));
+		} else {
 			varParams.put("LATLON", "unknown");
 			varParams.put("LAT", "");
-			varParams.put("LON", "");		
+			varParams.put("LON", "");
 		}
 		if (withFoundText) {
-			varParams.put("STATUS",getStatusText());
-		}
-		else
+			varParams.put("STATUS", getStatusText());
+		} else
 			varParams.put("STATUS", cacheStatus);
 		varParams.put("GC_LOGTYPE", getGCLogType());
 		varParams.put("STATUS_DATE", getStatusDate());
 		varParams.put("STATUS_TIME", getStatusTime());
 		varParams.put("CACHE_NAME", cacheName);
-		if (codec instanceof AsciiCodec) { cacheName=Exporter.simplifyString(cacheName);} // use for "NAME"
-		if (badChars != null) { cacheName=badChars.replaceAll(cacheName); } // use for "NAME"
+		if (codec instanceof AsciiCodec) {
+			cacheName = Exporter.simplifyString(cacheName);
+		} // use for "NAME"
+		if (badChars != null) {
+			cacheName = badChars.replaceAll(cacheName);
+		} // use for "NAME"
 		varParams.put("NAME", cacheName); // !!! cacheName used twice
-		String shortName=shortenName(cacheName, shortNameLength);
+		String shortName = shortenName(cacheName, shortNameLength);
 		varParams.put("SHORTNAME", shortName);
-		varParams.put("TRAVELBUG", (bugs?"Y":"N"));
-		if (gm!=null) varParams.put("GMTYPE", gm.getIcon(this));
-		varParams.put("NOW_DATE",nowdate().setToCurrentTime().toString());
-		varParams.put("NOW_TIME",nowtime().setToCurrentTime().toString());
+		varParams.put("TRAVELBUG", (bugs ? "Y" : "N"));
+		if (gm != null)
+			varParams.put("GMTYPE", gm.getIcon(this));
+		varParams.put("NOW_DATE", nowdate().setToCurrentTime().toString());
+		varParams.put("NOW_TIME", nowtime().setToCurrentTime().toString());
 		varParams.put("CACHEID", GetCacheID());
 		varParams.put("AVAILABLE", available ? "TRUE" : "FALSE");
 		varParams.put("ARCHIVED", archived ? "TRUE" : "FALSE");
 		varParams.put("HTML", html ? "TRUE" : "FALSE");
 		varParams.put("VOTE", getRecommended());
-		//() ? TRUE : FALSE
-		if (det == null){
+		// () ? TRUE : FALSE
+		if (det == null) {
 			varParams.put("URL", "");
 			varParams.put("DESCRIPTION", "");
 			varParams.put("NOTES", "");
@@ -699,145 +698,143 @@
 			varParams.put("DECRYPTEDHINTS", "");
 			varParams.put("COUNTRY", "");
 			varParams.put("STATE", "");
-		}
-		else {
+		} else {
 			varParams.put("URL", det.URL);
 			if (html) {
 				if (ModTyp == 0) {
-					varParams.put("DESCRIPTION",SafeXML.cleanGPX(det.LongDescription));
-				}
-				else {
+					varParams.put("DESCRIPTION", SafeXML.cleanGPX(det.LongDescription));
+				} else {
 					varParams.put("DESCRIPTION", modifyLongDesc(det, ModTyp));
 				}
 			} else {
-				 // what was the reason? replace or no replace? I dont remember
-				varParams.put("DESCRIPTION",STRreplace.replace(det.LongDescription, "\n", "<br>"));
+				// what was the reason? replace or no replace? I dont remember
+				varParams.put("DESCRIPTION", STRreplace.replace(det.LongDescription, "\n", "<br>"));
 			}
-			
+
 			if (badChars != null) {
-				if (ModTyp == 0){
-					varParams.put("NOTES",badChars.replaceAll(det.getCacheNotes()));
+				if (ModTyp == 0) {
+					varParams.put("NOTES", badChars.replaceAll(det.getCacheNotes()));
+				} else {
+					varParams.put("NOTES", STRreplace.replace(badChars.replaceAll(det.getCacheNotes()), "\n", "<br>"));
 				}
-				else {
-					varParams.put("NOTES",STRreplace.replace(badChars.replaceAll(det.getCacheNotes()), "\n", "<br>"));
-				}
-				varParams.put("HINTS",(ModTyp == 0) ? SafeXML.cleanGPX(badChars.replaceAll(det.Hints)) : badChars.replaceAll(det.Hints));
-				varParams.put("DECRYPTEDHINTS",(ModTyp == 0) ? SafeXML.cleanGPX(badChars.replaceAll(Common.rot13(det.Hints))) : badChars.replaceAll(Common.rot13(det.Hints)));
+				varParams.put("HINTS", (ModTyp == 0) ? SafeXML.cleanGPX(badChars.replaceAll(det.Hints)) : badChars.replaceAll(det.Hints));
+				varParams.put("DECRYPTEDHINTS", (ModTyp == 0) ? SafeXML.cleanGPX(badChars.replaceAll(Common.rot13(det.Hints))) : badChars.replaceAll(Common.rot13(det.Hints)));
 			} else {
-				if (ModTyp == 0){
+				if (ModTyp == 0) {
 					varParams.put("NOTES", SafeXML.cleanGPX(det.getCacheNotes()));
-				}
-				else {
+				} else {
 					varParams.put("NOTES", STRreplace.replace(det.getCacheNotes(), "\n", "<br>"));
 				}
-				varParams.put("HINTS",(ModTyp == 0) ? SafeXML.cleanGPX(det.Hints) : det.Hints);
-				varParams.put("DECRYPTEDHINTS",(ModTyp == 0) ? SafeXML.cleanGPX(Common.rot13(det.Hints)) : Common.rot13(det.Hints));
+				varParams.put("HINTS", (ModTyp == 0) ? SafeXML.cleanGPX(det.Hints) : det.Hints);
+				varParams.put("DECRYPTEDHINTS", (ModTyp == 0) ? SafeXML.cleanGPX(Common.rot13(det.Hints)) : Common.rot13(det.Hints));
 			}
-			if (det.Travelbugs.size()>0) varParams.put("BUGS",(ModTyp == 0) ? SafeXML.cleanGPX(det.Travelbugs.toHtml()) : det.Travelbugs.toHtml());
-			if (det.getSolver()!=null && det.getSolver().trim().length()>0) 
-				varParams.put("SOLVER", STRreplace.replace(det.getSolver(),"\n","<br/>\n"));
+			if (det.Travelbugs.size() > 0)
+				varParams.put("BUGS", (ModTyp == 0) ? SafeXML.cleanGPX(det.Travelbugs.toHtml()) : det.Travelbugs.toHtml());
+			if (det.getSolver() != null && det.getSolver().trim().length() > 0)
+				varParams.put("SOLVER", STRreplace.replace(det.getSolver(), "\n", "<br/>\n"));
 			varParams.put("COUNTRY", det.Country);
 			varParams.put("STATE", det.State);
-			
+
 			// attributes
-			Vector attVect=new Vector(det.attributes.count()+1);
-			for (int i=0; i<det.attributes.count(); i++) {
-				Hashtable atts=new Hashtable();
+			Vector attVect = new Vector(det.attributes.count() + 1);
+			for (int i = 0; i < det.attributes.count(); i++) {
+				Hashtable atts = new Hashtable();
 				atts.put("PATHANDIMAGE", det.attributes.getAttribute(i).getPathAndImageName());
 				atts.put("IMAGE", det.attributes.getAttribute(i).getImageName());
 				atts.put("GCID", det.attributes.getAttribute(i).getGCId());
 				atts.put("INC", "" + det.attributes.getAttribute(i).getInc());
-				atts.put("INC2TXT", det.attributes.getAttribute(i).getInc()==1 ? "YES:" : "NO:");
-				if (i % 5 ==4)
-					atts.put("BR","<br/>");
+				atts.put("INC2TXT", det.attributes.getAttribute(i).getInc() == 1 ? "YES:" : "NO:");
+				if (i % 5 == 4)
+					atts.put("BR", "<br/>");
 				else
-					atts.put("BR","");
-				atts.put("INFO",det.attributes.getAttribute(i).getMsg());
-				atts.put("GCINFO",det.attributes.getAttribute(i).getGCText());
+					atts.put("BR", "");
+				atts.put("INFO", det.attributes.getAttribute(i).getMsg());
+				atts.put("GCINFO", det.attributes.getAttribute(i).getGCText());
 				attVect.add(atts);
 			}
-			varParams.put("ATTRIBUTES",attVect);
-			
+			varParams.put("ATTRIBUTES", attVect);
+
 			// logs
-			Vector logVect=new Vector(det.CacheLogs.size());
+			Vector logVect = new Vector(det.CacheLogs.size());
 			int maxlogs = det.CacheLogs.size();
-			if (nrOfLogs > -1 && nrOfLogs < maxlogs ) maxlogs=nrOfLogs;
-			for (int i=0; i<maxlogs; i++) {
-				Hashtable logs=new Hashtable();
+			if (nrOfLogs > -1 && nrOfLogs < maxlogs)
+				maxlogs = nrOfLogs;
+			for (int i = 0; i < maxlogs; i++) {
+				Hashtable logs = new Hashtable();
 				String stmp;
 				if (det.CacheLogs.getLog(i).getIcon().equals("MAXLOG")) {
 					logs.put("WAYPOINT", wayPoint);
-					logs.put("ICON","");
-					logs.put("LOGTYPE","");
+					logs.put("ICON", "");
+					logs.put("LOGTYPE", "");
 					logs.put("DATE", "");
 					logs.put("LOGGER", "");
-					stmp = "<hr>"+MyLocale.getMsg(736,"Too many logs")+"<hr>";
-				}
-				else {
+					stmp = "<hr>" + MyLocale.getMsg(736, "Too many logs") + "<hr>";
+				} else {
 					logs.put("WAYPOINT", wayPoint);
-					logs.put("ICON",det.CacheLogs.getLog(i).getIcon());
-					logs.put("LOGTYPE",image2TypeText(det.CacheLogs.getLog(i).getIcon()));
+					logs.put("ICON", det.CacheLogs.getLog(i).getIcon());
+					logs.put("LOGTYPE", image2TypeText(det.CacheLogs.getLog(i).getIcon()));
 					logs.put("DATE", det.CacheLogs.getLog(i).getDate());
 					logs.put("LOGGER", (ModTyp == 0) ? SafeXML.cleanGPX(det.CacheLogs.getLog(i).getLogger()) : det.CacheLogs.getLog(i).getLogger());
-					stmp = STRreplace.replace(det.CacheLogs.getLog(i).getMessage().trim(),"http://www.geocaching.com/images/icons/",null);
+					stmp = STRreplace.replace(det.CacheLogs.getLog(i).getMessage().trim(), "http://www.geocaching.com/images/icons/", null);
 				}
 				logs.put("MESSAGE", (ModTyp == 0) ? SafeXML.cleanGPX(stmp) : stmp);
 				logVect.add(logs);
 			}
-			varParams.put("LOGS",logVect);
+			varParams.put("LOGS", logVect);
 
-			Vector addiVect=new Vector(addiWpts.size());
-			for (int i=0; i<addiWpts.size(); i++) {
-				Hashtable addis=new Hashtable();
-				CacheHolder ch=(CacheHolder) addiWpts.get(i);
-				addis.put("WAYPOINT",ch.getWayPoint());
-				addis.put("NAME",(ModTyp == 0) ? SafeXML.cleanGPX(ch.getCacheName()) : ch.getCacheName());
-				if ((ch.pos!=null && ch.pos.isValid())) {
-					addis.put("LATLON",decSep.replaceAll(ch.pos.toString()));
-					addis.put("LAT",decSep.replaceAll(ch.pos.getLatDeg(CWPoint.DD)));
-					addis.put("LON",decSep.replaceAll(ch.pos.getLonDeg(CWPoint.DD)));
-				}
-				else {
+			Vector addiVect = new Vector(addiWpts.size());
+			for (int i = 0; i < addiWpts.size(); i++) {
+				Hashtable addis = new Hashtable();
+				CacheHolder ch = (CacheHolder) addiWpts.get(i);
+				addis.put("WAYPOINT", ch.getWayPoint());
+				addis.put("NAME", (ModTyp == 0) ? SafeXML.cleanGPX(ch.getCacheName()) : ch.getCacheName());
+				if ((ch.pos != null && ch.pos.isValid())) {
+					addis.put("LATLON", decSep.replaceAll(ch.pos.toString()));
+					addis.put("LAT", decSep.replaceAll(ch.pos.getLatDeg(CWPoint.DD)));
+					addis.put("LON", decSep.replaceAll(ch.pos.getLonDeg(CWPoint.DD)));
+				} else {
 					addis.put("LATLON", "unknown");
 					addis.put("LAT", "");
-					addis.put("LON", "");		
+					addis.put("LON", "");
 				}
-				addis.put("IMG",CacheType.typeImageForId(ch.getType()));
-				addis.put("ICON",""+ch.getType());
+				addis.put("IMG", CacheType.typeImageForId(ch.getType()));
+				addis.put("ICON", "" + ch.getType());
 				addis.put("TYPENAME", CacheType.type2Gui(ch.getType()));
-				addis.put("TYPE", CacheType.type2TypeTag(ch.getType())); //<type>
-				addis.put("SYM", CacheType.type2SymTag(ch.getType())); //<sym>
-				addis.put("GSTYPE", CacheType.type2GSTypeTag(ch.getType())); //<groundspeak:type>
-				addis.put("LONGDESC",(ModTyp == 0) ? SafeXML.cleanGPX(ch.getCacheDetails(false).LongDescription) : ch.getCacheDetails(false).LongDescription);
+				addis.put("TYPE", CacheType.type2TypeTag(ch.getType())); // <type>
+				addis.put("SYM", CacheType.type2SymTag(ch.getType())); // <sym>
+				addis.put("GSTYPE", CacheType.type2GSTypeTag(ch.getType())); // <groundspeak:type>
+				addis.put("LONGDESC", (ModTyp == 0) ? SafeXML.cleanGPX(ch.getCacheDetails(false).LongDescription) : ch.getCacheDetails(false).LongDescription);
 				addiVect.add(addis);
 			}
-			varParams.put("ADDIS",addiVect);
-			
-			Vector imgVect=new Vector(det.images.size());
-			for (int i=0; i<det.images.size(); i++) {
-				Hashtable imgs=new Hashtable();
+			varParams.put("ADDIS", addiVect);
+
+			Vector imgVect = new Vector(det.images.size());
+			for (int i = 0; i < det.images.size(); i++) {
+				Hashtable imgs = new Hashtable();
 				String imgFile = det.images.get(i).getFilename();
-				imgs.put("FILENAME",imgFile);
-				imgs.put("TEXT",det.images.get(i).getTitle());
-				imgs.put("COMMENT",det.images.get(i).getComment());
-				imgs.put("URL",det.images.get(i).getURL());
+				imgs.put("FILENAME", imgFile);
+				imgs.put("TEXT", det.images.get(i).getTitle());
+				imgs.put("COMMENT", det.images.get(i).getComment());
+				imgs.put("URL", det.images.get(i).getURL());
 				if (!expName.equals("")) {
 					String src = Global.getProfile().dataDir + imgFile;
 					String dest = Global.getPref().getExportPath(expName) + imgFile;
-					if (!DataMover.copy(src,dest)) {
-						Global.getPref().log("[CacheHolder:toHashtable]error copying "+imgFile+" to "+Global.getPref().getExportPath(expName));
+					if (!DataMover.copy(src, dest)) {
+						Global.getPref().log("[CacheHolder:toHashtable]error copying " + imgFile + " to " + Global.getPref().getExportPath(expName));
 					}
 				}
 				imgVect.add(imgs);
 			}
-			varParams.put("cacheImg",imgVect);
+			varParams.put("cacheImg", imgVect);
 		}
 		return varParams;
-	}	
+	}
 
 	/**
 	 * generate a gc.com compatible string representation of log derived from the internally stored image
-	 * @param image name of the image to display
+	 * 
+	 * @param image
+	 *            name of the image to display
 	 * @return log type. will default to "Write note" for unknown logtypes
 	 */
 	public static final String image2TypeText(String image) {
@@ -877,36 +874,40 @@
 	}
 
 	/**
-	 * Modify the image links in the long description so that they point to image files in the local directory
-	 * Also copy the image file to the target directory so that it can be displayed.
-	 * @param chD CacheHolderDetail
+	 * Modify the image links in the long description so that they point to image files in the local directory Also copy the image file to the target directory so that it can be displayed.
+	 * 
+	 * @param chD
+	 *            CacheHolderDetail
 	 * @param int ModTypLongDesc == 1 get image from profile path, == 2 get image from html-path
 	 * @return The modified long description
 	 */
 	private String modifyLongDesc(CacheHolderDetail chD, int ModTypLongDesc) {
-		StringBuffer s=new StringBuffer(chD.LongDescription.length());
-		int start=0;
+		StringBuffer s = new StringBuffer(chD.LongDescription.length());
+		int start = 0;
 		int pos;
-		int imageNo=0;
-		String imgsrc="";
-		if (ModTypLongDesc==1) imgsrc="file://"+Global.getProfile().dataDir;
-		while (start>=0 && (pos=chD.LongDescription.indexOf("<img",start))>0) {
-			if (imageNo >= chD.images.size()) break;
-			s.append(chD.LongDescription.substring(start,pos));
-			start=chD.LongDescription.indexOf(">",pos)+1;
-			String oldurl=chD.images.get(imageNo).getURL();
-			String imgString=chD.LongDescription.substring(pos, start);
-			if (imgString.indexOf(oldurl)==-1) {
+		int imageNo = 0;
+		String imgsrc = "";
+		if (ModTypLongDesc == 1)
+			imgsrc = "file://" + Global.getProfile().dataDir;
+		while (start >= 0 && (pos = chD.LongDescription.indexOf("<img", start)) > 0) {
+			if (imageNo >= chD.images.size())
+				break;
+			s.append(chD.LongDescription.substring(start, pos));
+			start = chD.LongDescription.indexOf(">", pos) + 1;
+			String oldurl = chD.images.get(imageNo).getURL();
+			String imgString = chD.LongDescription.substring(pos, start);
+			if (imgString.indexOf(oldurl) == -1) {
 				if (oldurl.startsWith("http://")) {
-					int i = oldurl.indexOf("/", 7)+1;
-					oldurl=oldurl.substring(i);
+					int i = oldurl.indexOf("/", 7) + 1;
+					oldurl = oldurl.substring(i);
 				}
 			}
-			String newurl=imgsrc+chD.images.get(imageNo).getFilename();
-			s.append(STRreplace.replace(imgString,oldurl,newurl));
+			String newurl = imgsrc + chD.images.get(imageNo).getFilename();
+			s.append(STRreplace.replace(imgString, oldurl, newurl));
 			imageNo++;
 		}
-		if (start>=0) s.append(chD.LongDescription.substring(start));
+		if (start >= 0)
+			s.append(chD.LongDescription.substring(start));
 		return s.toString();
 	}
 
@@ -914,56 +915,61 @@
 		Time nd = new Time();
 		return nd.setFormat("yyyy-MM-dd");
 	}
+
 	private final static Time nowtime() {
 		Time nt = new Time();
 		return nt.setFormat("HH:mm");
 	}
 
-	private final static String selbstLaute="aeiouAEIOU";
+	private final static String selbstLaute = "aeiouAEIOU";
+
 	private final static String mitLauteKlein() {
-		final StringBuffer lower=new StringBuffer(26);// region/language dependent ?
-		for (int i=97; i<=122; i++ ) {
+		final StringBuffer lower = new StringBuffer(26);// region/language dependent ?
+		for (int i = 97; i <= 122; i++) {
 			lower.append((char) i);
 		}
 		return lower.toString();
 	}
+
 	public String shortenName(String Name, int maxLength) {
-		String shortName=removeCharsfromString(Name, maxLength, selbstLaute);
-		return  removeCharsfromString(shortName, maxLength, mitLauteKlein());
+		String shortName = removeCharsfromString(Name, maxLength, selbstLaute);
+		return removeCharsfromString(shortName, maxLength, mitLauteKlein());
 	}
-    private static String removeCharsfromString( String text, int MaxLength, String chars ) {
-        if ( text == null ) return null;
-        int originalTextLength = text.length();
-        int anzToRemove=originalTextLength-MaxLength;
-        if (anzToRemove<=0) return text;
-        int anzRemoved=0;
-        StringBuffer sb = new StringBuffer( 50 );
-        for ( int i = originalTextLength-1; i >= 0; i-- ) {
-            char c = text.charAt( i );
-            if (chars.indexOf(c) == -1) {
-            	sb.insert(0,c);
-            }
-            else {
-            	anzRemoved++;
-            	if (anzRemoved==anzToRemove) {
-            		sb.insert(0, text.substring(0,i));
-            		i=0; // exit for
-            	}
-            }
-        }
-        return sb.toString();
-    }
 
+	private static String removeCharsfromString(String text, int MaxLength, String chars) {
+		if (text == null)
+			return null;
+		int originalTextLength = text.length();
+		int anzToRemove = originalTextLength - MaxLength;
+		if (anzToRemove <= 0)
+			return text;
+		int anzRemoved = 0;
+		StringBuffer sb = new StringBuffer(50);
+		for (int i = originalTextLength - 1; i >= 0; i--) {
+			char c = text.charAt(i);
+			if (chars.indexOf(c) == -1) {
+				sb.insert(0, c);
+			} else {
+				anzRemoved++;
+				if (anzRemoved == anzToRemove) {
+					sb.insert(0, text.substring(0, i));
+					i = 0; // exit for
+				}
+			}
+		}
+		return sb.toString();
+	}
+
 	/** return true if waypoint is an additional waypoint of a cache */
 	public boolean isAddiWpt() {
 		return CacheType.isAddiWpt(type);
 	}
-	
+
 	/** return true if waypoint is a custom waypoint */
 	public boolean isCustomWpt() {
 		return CacheType.isCustomWpt(type);
 	}
-	
+
 	/** return true if waypoint is a cache main waypoint */
 	public boolean isCacheWpt() {
 		return CacheType.isCacheWpt(type);
@@ -971,15 +977,15 @@
 
 	/** return true waypoint has one or more additional waypoints */
 	public boolean hasAddiWpt() {
-		return addiWpts.getCount()>0;
+		return addiWpts.getCount() > 0;
 	}
 
 	public boolean isOC() {
 		return OC.isOC(wayPoint);
 	}
 
-	public void calcDistance(CWPoint toPoint) {	
-		if(pos.isValid()){
+	public void calcDistance(CWPoint toPoint) {
+		if (pos.isValid()) {
 			kilom = pos.getDistance(toPoint);
 			degrees = toPoint.getBearing(pos);
 			bearing = CWPoint.getDirection(degrees);
@@ -989,7 +995,7 @@
 		}
 	}
 
-	public void setAttributesFromMainCache(){
+	public void setAttributesFromMainCache() {
 		CacheHolder mainCh = this.mainCache;
 		this.setCacheOwner(mainCh.getCacheOwner());
 		if (mainCh.is_found()) {
@@ -997,9 +1003,8 @@
 				this.setCacheStatus(mainCh.getCacheStatus());
 				this.setFound(true);
 			}
-			// else addi is already found (perhaps at other time) 
-		}
-		else {
+			// else addi is already found (perhaps at other time)
+		} else {
 			// there may be a found addi , so don't overwrite
 			if ((this.getType() == CacheType.CW_TYPE_FINAL)) {
 				this.setCacheStatus(mainCh.getCacheStatus());
@@ -1013,10 +1018,10 @@
 		this.setNew(mainCh.is_new());
 	}
 
-	public void setAttributesToAddiWpts(){
-		if (this.hasAddiWpt()){
+	public void setAttributesToAddiWpts() {
+		if (this.hasAddiWpt()) {
 			CacheHolder addiWpt;
-			for (int i= this.addiWpts.getCount() - 1;  i>=0; i--){
+			for (int i = this.addiWpts.getCount() - 1; i >= 0; i--) {
 				addiWpt = (CacheHolder) this.addiWpts.get(i);
 				addiWpt.setAttributesFromMainCache();
 			}
@@ -1024,39 +1029,46 @@
 	}
 
 	/**
-	 * True if ch and this belong to the same main cache. 
+	 * True if ch and this belong to the same main cache.
+	 * 
 	 * @param ch
 	 * @return
 	 */
 	public boolean hasSameMainCache(CacheHolder ch) {
-		if (this == ch) return true;
-		if (ch == null) return false;
-		if ((!this.isAddiWpt()) && (!ch.isAddiWpt())) return false;
+		if (this == ch)
+			return true;
+		if (ch == null)
+			return false;
+		if ((!this.isAddiWpt()) && (!ch.isAddiWpt()))
+			return false;
 		CacheHolder main1, main2;
-		if (this.isAddiWpt()) main1 = this.mainCache;  else main1 = this;
-		if (ch.isAddiWpt()) main2 = ch.mainCache; else main2 = ch; 
+		if (this.isAddiWpt())
+			main1 = this.mainCache;
+		else
+			main1 = this;
+		if (ch.isAddiWpt())
+			main2 = ch.mainCache;
+		else
+			main2 = ch;
 		return main1 == main2;
 	}
 
-	/** Find out of detail object of Cache is loaded. Returns <code>true</code> if this is the case.
+	/**
+	 * Find out of detail object of Cache is loaded. Returns <code>true</code> if this is the case.
+	 * 
 	 * @return True when details object is present
 	 */
 	public boolean detailsLoaded() {
-		return details!=null;
+		return details != null;
 	}
 
 	/**
-	 * Gets the detail object of a cache. The detail object stores information which is not needed
-	 * for every cache instantaneously, but can be loaded if the user decides to look at this cache.
-	 * If the cache object is already existing, the method will return this object, otherwise it 
-	 * will create it and try to read it from the corresponding <waypoint>.xml file.
-	 * Depending on the parameters it is allowed that the <waypoint>.xml file does not yet exist,
-	 * or the user is warned that the file doesn't exist.
-	 * If more than <code>maxdetails</code> details are loaded, then the 5 last recently loaded 
-	 * caches are unloaded (to save ram). 
+	 * Gets the detail object of a cache. The detail object stores information which is not needed for every cache instantaneously, but can be loaded if the user decides to look at this cache. If the cache object is already existing, the method will
+	 * return this object, otherwise it will create it and try to read it from the corresponding <waypoint>.xml file. Depending on the parameters it is allowed that the <waypoint>.xml file does not yet exist, or the user is warned that the file doesn't
+	 * exist. If more than <code>maxdetails</code> details are loaded, then the 5 last recently loaded caches are unloaded (to save ram).
+	 * 
 	 * @param alarmuser
-	 *            If true an error message will be displayed to the user, if the details could not
-	 *            be read, and the method returns null 
+	 *            If true an error message will be displayed to the user, if the details could not be read, and the method returns null
 	 * @return The respective CacheHolderDetail, or null
 	 */
 	public CacheHolderDetail getCacheDetails(boolean alarmuser) {
@@ -1066,9 +1078,8 @@
 				details.readCache(Global.getProfile().dataDir);
 			} catch (IOException e) {
 				if (alarmuser) {
-					//FIXME: put a message to languages file
-					(new MessageBox(MyLocale.getMsg(31415,"Error"), MyLocale.getMsg(31415, "Could not read cache details for cache: ")
-					        + this.getWayPoint(), FormBase.OKB)).execute();
+					// FIXME: put a message to languages file
+					(new MessageBox(MyLocale.getMsg(31415, "Error"), MyLocale.getMsg(31415, "Could not read cache details for cache: ") + this.getWayPoint(), FormBase.OKB)).execute();
 					// details = null;
 				}
 				this.setIncomplete(true);
@@ -1076,111 +1087,115 @@
 			// for importing/spidering reasons helper objects with same waypoint are created
 			if (details != null && !cachesWithLoadedDetails.contains(this)) {
 				cachesWithLoadedDetails.add(this);
-				if (cachesWithLoadedDetails.size() >= Global.getPref().maxDetails) removeOldestDetails();
+				if (cachesWithLoadedDetails.size() >= Global.getPref().maxDetails)
+					removeOldestDetails();
 			}
 		}
 		return details;
 	}
 
 	/**
-	 * Saves the cache to the corresponding <waypoint>.xml file, located in the profiles
-	 * directory. The waypoint of the 
-	 * cache should be set to do so.
+	 * Saves the cache to the corresponding <waypoint>.xml file, located in the profiles directory. The waypoint of the cache should be set to do so.
 	 */
 	public void save() {
 		checkIncomplete();
 		this.getCacheDetails(false).saveCacheDetails(Global.getProfile().dataDir);
 	}
-	
+
 	void releaseCacheDetails() {
-		if (details != null && details.hasUnsavedChanges){
+		if (details != null && details.hasUnsavedChanges) {
 			details.saveCacheDetails(Global.getProfile().dataDir);
 		}
 		details = null;
 		cachesWithLoadedDetails.remove(this);
 	}
 
-	//final static int maxDetails = 50; 
+	// final static int maxDetails = 50;
 	static Vector cachesWithLoadedDetails = new Vector(Global.getPref().maxDetails);
 
 	public static void removeOldestDetails() {
 		CacheHolder ch;
-		for (int i=0; i<Global.getPref().deleteDetails; i++) {
-//			String wp = (String) cachesWithLoadedDetails.get(i);
-	//		CacheHolder ch = Global.getProfile().cacheDB.get(wp);
+		for (int i = 0; i < Global.getPref().deleteDetails; i++) {
+			// String wp = (String) cachesWithLoadedDetails.get(i);
+			// CacheHolder ch = Global.getProfile().cacheDB.get(wp);
 			ch = (CacheHolder) cachesWithLoadedDetails.get(i);
-			if (ch!=null) ch.releaseCacheDetails();
-		}	
+			if (ch != null)
+				ch.releaseCacheDetails();
+		}
 	}
 
 	public static void removeAllDetails() {
 		CacheHolder ch;
-		for (int i=cachesWithLoadedDetails.size()-1; i>=0; i--) {
+		for (int i = cachesWithLoadedDetails.size() - 1; i >= 0; i--) {
 			// String wp = (String) cachesWithLoadedDetails.get(i);
 			// CacheHolder ch = Global.getProfile().cacheDB.get(wp);
 			ch = (CacheHolder) cachesWithLoadedDetails.get(i);
-			if (ch!=null && ch.detailsLoaded()) ch.releaseCacheDetails();
+			if (ch != null && ch.detailsLoaded())
+				ch.releaseCacheDetails();
 		}
 	}
 
 	/**
-	 * when importing caches you can set details.saveChanges = true
-	 * when the import is finished call this method to save the pending changes
+	 * when importing caches you can set details.saveChanges = true when the import is finished call this method to save the pending changes
 	 */
 	public static void saveAllModifiedDetails() {
 		CacheHolder ch;
 		CacheHolderDetail chD;
-		for (int i=cachesWithLoadedDetails.size()-1; i>=0; i--) {
-//			String wp = (String) cachesWithLoadedDetails.get(i);
-//			ch = Global.getProfile().cacheDB.get(wp);
+		for (int i = cachesWithLoadedDetails.size() - 1; i >= 0; i--) {
+			// String wp = (String) cachesWithLoadedDetails.get(i);
+			// ch = Global.getProfile().cacheDB.get(wp);
 			ch = (CacheHolder) cachesWithLoadedDetails.get(i);
 			if (ch != null) {
-	            chD = ch.getCacheDetails(true);
-	            if (chD!=null && chD.hasUnsavedChanges) {
-		            //ch.calcRecommendationScore();
-		            chD.saveCacheDetails(Global.getProfile().dataDir);
-	            }
-            }
+				chD = ch.getCacheDetails(true);
+				if (chD != null && chD.hasUnsavedChanges) {
+					// ch.calcRecommendationScore();
+					chD.saveCacheDetails(Global.getProfile().dataDir);
+				}
+			}
 		}
 	}
-	
+
 	public String getFoundText() {
-		int msgNr=318; // normal found			 
-		if (type == CacheType.CW_TYPE_WEBCAM) { msgNr=361;}
-		else if (type == CacheType.CW_TYPE_EVENT 
-				|| type == CacheType.CW_TYPE_MEGA_EVENT) { msgNr=355;}
+		int msgNr = 318; // normal found
+		if (type == CacheType.CW_TYPE_WEBCAM) {
+			msgNr = 361;
+		} else if (type == CacheType.CW_TYPE_EVENT || type == CacheType.CW_TYPE_MEGA_EVENT) {
+			msgNr = 355;
+		}
 		return MyLocale.getMsg(msgNr, "Found");
 	}
+
 	public String getGCFoundText() {
-		int msgNr=318; // normal found			 
-		if (type == CacheType.CW_TYPE_WEBCAM) { msgNr=361;}
-		else if (type == CacheType.CW_TYPE_EVENT 
-				|| type == CacheType.CW_TYPE_MEGA_EVENT) { msgNr=355;}
+		int msgNr = 318; // normal found
+		if (type == CacheType.CW_TYPE_WEBCAM) {
+			msgNr = 361;
+		} else if (type == CacheType.CW_TYPE_EVENT || type == CacheType.CW_TYPE_MEGA_EVENT) {
+			msgNr = 355;
+		}
 		for (int i = 0; i < _logType.length; i++) {
-			if ((""+msgNr).equals(_logType[i][MSG_NR])) {
+			if (("" + msgNr).equals(_logType[i][MSG_NR])) {
 				return _logType[i][GC_MSG];
-			}			
+			}
 		}
 		return "";
 	}
+
 	public String getCWLogText(String s) {
 		for (int i = 0; i < _logType.length; i++) {
 			if ((s).equals(_logType[i][GC_MSG])) {
-				return MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]),"");
-			}			
+				return MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]), "");
+			}
 		}
 		return "";
 	}
-	
+
 	public String getStatusText() {
-		if ((cacheStatus.length() == 10 || cacheStatus.length() == 16) &&
-				cacheStatus.charAt(4) == '-') {
-			return getFoundText() + " " + cacheStatus;			
+		if ((cacheStatus.length() == 10 || cacheStatus.length() == 16) && cacheStatus.charAt(4) == '-') {
+			return getFoundText() + " " + cacheStatus;
 		} else {
 			if (found) {
 				return getFoundText();
-			}
-			else {
+			} else {
 				return cacheStatus;
 			}
 		}
@@ -1188,137 +1203,119 @@
 
 	public String getStatusDate() {
 		String statusDate = "";
-		
-		if (is_found() || getCacheStatus().indexOf(MyLocale.getMsg(319,"not found"))>10) {
-			Regex rexDate=new Regex("([0-9]{4}-[0-9]{2}-[0-9]{2})");
+
+		if (is_found() || getCacheStatus().indexOf(MyLocale.getMsg(319, "not found")) > 10) {
+			Regex rexDate = new Regex("([0-9]{4}-[0-9]{2}-[0-9]{2})");
 			rexDate.search(getCacheStatus());
-			if (rexDate.stringMatched(1)!= null) {
+			if (rexDate.stringMatched(1) != null) {
 				statusDate = rexDate.stringMatched(1);
 			}
 		}
 
-		return statusDate;		
+		return statusDate;
 	}
-	
+
 	public String getStatusTime() {
 		String statusTime = "";
 
-		if (is_found() || getCacheStatus().indexOf(MyLocale.getMsg(319,"not found"))>10) {
-			Regex rexTime=new Regex("([0-9]{1,2}:[0-9]{2})");
+		if (is_found() || getCacheStatus().indexOf(MyLocale.getMsg(319, "not found")) > 10) {
+			Regex rexTime = new Regex("([0-9]{1,2}:[0-9]{2})");
 			rexTime.search(getCacheStatus());
-			if (rexTime.stringMatched(1)!= null) {
+			if (rexTime.stringMatched(1) != null) {
 				statusTime = rexTime.stringMatched(1);
-			}
-			else {
-				Regex rexDate=new Regex("([0-9]{4}-[0-9]{2}-[0-9]{2})");
+			} else {
+				Regex rexDate = new Regex("([0-9]{4}-[0-9]{2}-[0-9]{2})");
 				rexDate.search(getCacheStatus());
-				if (rexDate.stringMatched(1)!= null) {
+				if (rexDate.stringMatched(1) != null) {
 					statusTime = "00:00";
 				}
 			}
 		}
 
-		return statusTime;		
+		return statusTime;
 	}
-		
+
 	public String GetCacheID() {
 		String result = "";
 		String pattern = getWayPoint().toUpperCase();
 
-		if ( pattern.startsWith( "GC" ) ) {
+		if (pattern.startsWith("GC")) {
 			int gcId = 0;
 
 			String sequence = "0123456789ABCDEFGHJKMNPQRTVWXYZ";
-			
-			String rightPart = getWayPoint().substring( 2 ).toUpperCase();
-			
+
+			String rightPart = getWayPoint().substring(2).toUpperCase();
+
 			int base = 31;
 			if ((rightPart.length() < 4) || (rightPart.length() == 4 && sequence.indexOf(rightPart.charAt(0)) < 16)) {
 				base = 16;
 			}
-			
-			for ( int p = 0; p < rightPart.length(); p++ ) {
+
+			for (int p = 0; p < rightPart.length(); p++) {
 				gcId *= base;
 				gcId += sequence.indexOf(rightPart.charAt(p));
 			}
-			
-	        if ( base == 31 ) {
-	        	gcId += java.lang.Math.pow(16, 4) - 16 * java.lang.Math.pow(31, 3);
-	        }
-	        
-	        result = Integer.toString(gcId);	        
+
+			if (base == 31) {
+				gcId += java.lang.Math.pow(16, 4) - 16 * java.lang.Math.pow(31, 3);
+			}
+
+			result = Integer.toString(gcId);
 		} else if (isOC()) {
-        	result = getOcCacheID();
-        }
+			result = getOcCacheID();
+		}
 
 		return result;
 	}
 
-	private final static int MSG_NR = 0; 
-	private final static int GC_MSG = 1; 
-	private final static int IDX_WRITENOTE = 5; 	
-	private final static String[][] _logType = {	
-			{"353", ""},
-			{"318", "Found it"},
-			{"355", "Attended"},
-			{"361", "Webcam Photo Taken"},
-			{"319", "Didn't find it"},
-			{"314", "Write note"}, // at change do change IDX_WRITENOTE = 5;
-			{"315", "Needs Archived"},
-			{"316", "Needs Maintenance"},
-			{"317", "Search"}, 
-			{"354", "Will Attend"},
-			{"320", "Owner"},
-			{"359", "Owner Maintenance"},
-			{"356", "Temporarily Disable Listing"},
-			{"357", "Enable Listing"},
-			{"358", "Post Reviewer Note"},
-			{"362", "Solved"},
-			{"313", "Flag 1"},
-			{"360", "Flag 2"},
-	};
+	private final static int MSG_NR = 0;
+	private final static int GC_MSG = 1;
+	private final static int IDX_WRITENOTE = 5;
+	private final static String[][] _logType = { { "353", "" }, { "318", "Found it" }, { "355", "Attended" }, { "361", "Webcam Photo Taken" }, { "319", "Didn't find it" },
+			{ "314", "Write note" }, // at change do change IDX_WRITENOTE = 5;
+			{ "315", "Needs Archived" }, { "316", "Needs Maintenance" }, { "317", "Search" }, { "354", "Will Attend" }, { "320", "Owner" }, { "359", "Owner Maintenance" }, { "356", "Temporarily Disable Listing" }, { "357", "Enable Listing" },
+			{ "358", "Post Reviewer Note" }, { "362", "Solved" }, { "313", "Flag 1" }, { "360", "Flag 2" }, };
 
 	public final static String[] GetGuiLogTypes() {
 		String[] ret = new String[_logType.length];
 		for (int i = 0; i < _logType.length; i++) {
-			ret[i]=MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]),"");
+			ret[i] = MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]), "");
 		}
 		return ret;
 	}
-	
-	public String getGCLogType() {                                                                                
-		String gcLogType=_logType[IDX_WRITENOTE][GC_MSG];
+
+	public String getGCLogType() {
+		String gcLogType = _logType[IDX_WRITENOTE][GC_MSG];
 		if (is_found()) {
-			String msgNr="318"; // normal found			
-			if (type == CacheType.CW_TYPE_WEBCAM) { msgNr="361";}
-			else if (type == CacheType.CW_TYPE_EVENT 
-					|| type == CacheType.CW_TYPE_MEGA_EVENT) { msgNr="355";}
+			String msgNr = "318"; // normal found
+			if (type == CacheType.CW_TYPE_WEBCAM) {
+				msgNr = "361";
+			} else if (type == CacheType.CW_TYPE_EVENT || type == CacheType.CW_TYPE_MEGA_EVENT) {
+				msgNr = "355";
+			}
 			for (int i = 1; i < _logType.length; i++) {
 				if (_logType[i][MSG_NR].equals(msgNr)) {
-					gcLogType = _logType[i][GC_MSG]; 
+					gcLogType = _logType[i][GC_MSG];
 					break;
 				}
 			}
-		}
-		else {
-			String CacheStatus=getCacheStatus();  
+		} else {
+			String CacheStatus = getCacheStatus();
 			for (int i = 1; i < _logType.length; i++) {
-				if (CacheStatus.endsWith(MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]),""))) {
-					gcLogType=_logType[i][GC_MSG];
+				if (CacheStatus.endsWith(MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]), ""))) {
+					gcLogType = _logType[i][GC_MSG];
 					break;
 				}
 			}
 		}
-		return gcLogType;    
-	}                                                                                                             
-	
-	
-	
+		return gcLogType;
+	}
+
 	/**
-	 * Initializes the caches states (and its addis) before updating, so that the "new", "updated",
-	 * "log_updated" and "incomplete" properties are properly set. 
-	 * @param pNewCache <code>true</code> if it is a new cache (i.e. a cache not existing in CacheDB),
-	 * <code>false</code> otherwise.
+	 * Initializes the caches states (and its addis) before updating, so that the "new", "updated", "log_updated" and "incomplete" properties are properly set.
+	 * 
+	 * @param pNewCache
+	 *            <code>true</code> if it is a new cache (i.e. a cache not existing in CacheDB), <code>false</code> otherwise.
 	 */
 	public void initStates(boolean pNewCache) {
 		this.setNew(pNewCache);
@@ -1326,59 +1323,43 @@
 		this.setLog_updated(false);
 		this.setIncomplete(false);
 		if (!pNewCache && this.hasAddiWpt()) {
-			for (int i=0; i<this.addiWpts.size(); i++) {
-				((CacheHolder)this.addiWpts.get(i)).initStates(pNewCache);
+			for (int i = 0; i < this.addiWpts.size(); i++) {
+				((CacheHolder) this.addiWpts.get(i)).initStates(pNewCache);
 			}
 		}
 	}
 
 	/**
-	 * Creates a bit field of boolean values of the cache, represented as a long value.
-	 * Boolean value of <code>true</code> results in <code>1</code> in the long values bits,
-	 * and, vice versa, 0 for false.
+	 * Creates a bit field of boolean values of the cache, represented as a long value. Boolean value of <code>true</code> results in <code>1</code> in the long values bits, and, vice versa, 0 for false.
+	 * 
 	 * @return long value representing the boolean bit field
 	 */
 	private long boolFields2long() {
 		// To get the same list of visible caches after loading a profile,
-		// the property isVisible() is saved instead of is_filtered(), but at 
+		// the property isVisible() is saved instead of is_filtered(), but at
 		// the place where is_filtered() is read.
-		long value = bool2BitMask(!this.isVisible(), 1)     | 
-		             bool2BitMask(this.is_available(), 2)   |
-		             bool2BitMask(this.is_archived(), 3)    |
-		             bool2BitMask(this.has_bugs(), 4)       |
-		             bool2BitMask(this.is_black(), 5)       |
-		             bool2BitMask(this.is_owned(), 6)       |
-		             bool2BitMask(this.is_found(), 7)       |
-		             bool2BitMask(this.is_new(), 8)         |
-		             bool2BitMask(this.is_log_updated(), 9) |
-		             bool2BitMask(this.is_updated(), 10)    |
-		             bool2BitMask(this.is_HTML(), 11)       |
-		             bool2BitMask(this.is_incomplete(), 12) |
-		             bool2BitMask(this.hasNote(), 13)       |
-		             bool2BitMask(this.hasSolver(), 14);		             
+		long value = bool2BitMask(!this.isVisible(), 1) | bool2BitMask(this.is_available(), 2) | bool2BitMask(this.is_archived(), 3) | bool2BitMask(this.has_bugs(), 4) | bool2BitMask(this.is_black(), 5) | bool2BitMask(this.is_owned(), 6)
+				| bool2BitMask(this.is_found(), 7) | bool2BitMask(this.is_new(), 8) | bool2BitMask(this.is_log_updated(), 9) | bool2BitMask(this.is_updated(), 10) | bool2BitMask(this.is_HTML(), 11) | bool2BitMask(this.is_incomplete(), 12)
+				| bool2BitMask(this.hasNote(), 13) | bool2BitMask(this.hasSolver(), 14);
 		return value;
 	}
 
 	/**
-	 * Creates a field of byte values of certain properties of the cache, represented
-	 * as a long value.
-	 * As a long is 8 bytes wide, one might pack 8 bytes into a long, one every 8
-	 * bits. The position indicates the group of bits where the byte is packed,
+	 * Creates a field of byte values of certain properties of the cache, represented as a long value. As a long is 8 bytes wide, one might pack 8 bytes into a long, one every 8 bits. The position indicates the group of bits where the byte is packed,
 	 * counting starting from one by the right side of the long.
+	 * 
 	 * @return long value representing the byte field
 	 */
 	private long byteFields2long() {
-		long value = byteBitMask(hard, 1)    | 
-		byteBitMask(terrain, 2)   |
-		byteBitMask(type, 3)    |
-		byteBitMask(cacheSize, 4)|
-		byteBitMask(this.noFindLogs, 5);		             
+		long value = byteBitMask(hard, 1) | byteBitMask(terrain, 2) | byteBitMask(type, 3) | byteBitMask(cacheSize, 4) | byteBitMask(this.noFindLogs, 5);
 		return value;
 	}
-	
+
 	/**
 	 * Evaluates byte values from a long value for certain properties of the cache.
-	 * @param value The long value which contains up to 8 bytes.
+	 * 
+	 * @param value
+	 *            The long value which contains up to 8 bytes.
 	 */
 	private void long2byteFields(long value) {
 		setHard(byteFromLong(value, 1));
@@ -1386,17 +1367,15 @@
 		setType(byteFromLong(value, 3));
 		setCacheSize(byteFromLong(value, 4));
 		setNoFindLogs((byteFromLong(value, 5)));
-		
-		if ( getHard() == CacheTerrDiff.CW_DT_ERROR 
-				|| getTerrain() == CacheTerrDiff.CW_DT_ERROR 
-				|| getCacheSize() == CacheSize.CW_SIZE_ERROR 
-				|| getType() == CacheType.CW_TYPE_ERROR ) {
+
+		if (getHard() == CacheTerrDiff.CW_DT_ERROR || getTerrain() == CacheTerrDiff.CW_DT_ERROR || getCacheSize() == CacheSize.CW_SIZE_ERROR || getType() == CacheType.CW_TYPE_ERROR) {
 			setIncomplete(true);
 		}
 	}
-	
+
 	/**
 	 * convert a v2 byte filed to the current structures
+	 * 
 	 * @param value
 	 */
 	private void long2byteFieldsv2(long value) {
@@ -1408,11 +1387,14 @@
 		if (getHard() == -1 || getTerrain() == -1 || getCacheSize() == -1) {
 			if (isAddiWpt() || isCustomWpt()) {
 				// Addis don't have their own values for difficulty, terrain and size
-				// Custom waypoints can't be updated to remove incomplete flag, so we 
+				// Custom waypoints can't be updated to remove incomplete flag, so we
 				// have to set reasonable values.
-				if (getHard() == CacheTerrDiff.CW_DT_ERROR) setHard(CacheTerrDiff.CW_DT_UNSET);
-				if (getTerrain() == CacheTerrDiff.CW_DT_ERROR) setTerrain(CacheTerrDiff.CW_DT_UNSET);
-				if (getCacheSize() == CacheSize.CW_SIZE_ERROR) setCacheSize(CacheSize.CW_SIZE_NONE);
+				if (getHard() == CacheTerrDiff.CW_DT_ERROR)
+					setHard(CacheTerrDiff.CW_DT_UNSET);
+				if (getTerrain() == CacheTerrDiff.CW_DT_ERROR)
+					setTerrain(CacheTerrDiff.CW_DT_UNSET);
+				if (getCacheSize() == CacheSize.CW_SIZE_ERROR)
+					setCacheSize(CacheSize.CW_SIZE_NONE);
 			} else {
 				setIncomplete(true);
 			}
@@ -1420,21 +1402,24 @@
 	}
 
 	/**
-	 * Extracts a byte from a long value. The position is the number of the 8-bit block
-	 * of the long (which contains 8 8-bit blocks), counted from 1 to 8, starting from the
-	 * right side of the long.
-     * @param value The long value which contains the bytes
-     * @param position The position of the byte, from 1 to 8
-     * @return The decoded byte value
-     */
-    private byte byteFromLong(long value, int position) {
+	 * Extracts a byte from a long value. The position is the number of the 8-bit block of the long (which contains 8 8-bit blocks), counted from 1 to 8, starting from the right side of the long.
+	 * 
+	 * @param value
+	 *            The long value which contains the bytes
+	 * @param position
+	 *            The position of the byte, from 1 to 8
+	 * @return The decoded byte value
+	 */
+	private byte byteFromLong(long value, int position) {
 		byte b = -1; // = 11111111
-	    return (byte)((value & this.byteBitMask(b, position))>>>(position-1)*8);
-    }
+		return (byte) ((value & this.byteBitMask(b, position)) >>> (position - 1) * 8);
+	}
 
 	/**
 	 * Evaluates boolean values from a long value, which is seen as bit field.
-	 * @param value The bit field as long value
+	 * 
+	 * @param value
+	 *            The bit field as long value
 	 */
 	private void long2boolFields(long value) {
 		this.setFiltered((value & this.bool2BitMask(true, 1)) != 0);
@@ -1452,57 +1437,49 @@
 		this.setHasNote((value & this.bool2BitMask(true, 13)) != 0);
 		this.setHasSolver((value & this.bool2BitMask(true, 14)) != 0);
 	}
-	
+
 	/**
-	 * Represents a bit mask as long value for a boolean value which is saved at
-	 * a specified position in the long field.
-	 * @param value The boolean value we want to code
-	 * @param position Position of the value in the bit mask
-	 * @return The corresponding bit mask: A long value where all bits are set to 0 except for
-	 * the one we like to represent: This is 1 if the value is true, 0 if not. 
+	 * Represents a bit mask as long value for a boolean value which is saved at a specified position in the long field.
+	 * 
+	 * @param value
+	 *            The boolean value we want to code
+	 * @param position
+	 *            Position of the value in the bit mask
+	 * @return The corresponding bit mask: A long value where all bits are set to 0 except for the one we like to represent: This is 1 if the value is true, 0 if not.
 	 */
 	private long bool2BitMask(boolean value, int position) {
 		if (value) {
-			return (1L << (position-1));
+			return (1L << (position - 1));
 		} else {
 			return 0L;
 		}
 	}
-	
+
 	/**
-	 * Coding a long field which has only the bits of the byte value set. The position is the 
-	 * number (from 1 to 8) of the byte block which is used from the long.
-	 * @param value Byte to encode
-	 * @param position Position of the byte value in the long
+	 * Coding a long field which has only the bits of the byte value set. The position is the number (from 1 to 8) of the byte block which is used from the long.
+	 * 
+	 * @param value
+	 *            Byte to encode
+	 * @param position
+	 *            Position of the byte value in the long
 	 * @return Encoded byte value as long
 	 */
 	private long byteBitMask(byte value, int position) {
-		long result = (0xFF & (long) value) << ((position-1) *8);
+		long result = (0xFF & (long) value) << ((position - 1) * 8);
 		return result;
 	}
 
-
 	/**
-	 * Returns <code>true</code> if the waypoint should appear in the cache list, 
-	 * <code>false</code> if it should not appear.<br>
-	 * The method takes into account blacklist, filters, search results - everything
-	 * that determines if a cache is visible in the list or not. 
+	 * Returns <code>true</code> if the waypoint should appear in the cache list, <code>false</code> if it should not appear.<br>
+	 * The method takes into account blacklist, filters, search results - everything that determines if a cache is visible in the list or not.
+	 * 
 	 * @return
 	 */
 	public boolean isVisible() {
 		Profile profile = Global.getProfile();
 		int filter = profile.getFilterActive();
-		boolean noShow=
-			(  (profile.showBlacklisted() != this.is_black())   
-				||
-			   (profile.showSearchResult() && !this.is_flaged)   
-			    ||
-			   ( (filter == Filter.FILTER_ACTIVE||filter == Filter.FILTER_MARKED_ONLY) &&	
-			  	 (this.is_filtered())^profile.isFilterInverted())                            
-			  	||
-			   (filter == Filter.FILTER_CACHELIST) && 
-			     !Global.mainForm.cacheList.contains(this.getWayPoint())
-			);
+		boolean noShow = ((profile.showBlacklisted() != this.is_black()) || (profile.showSearchResult() && !this.is_flaged) || ((filter == Filter.FILTER_ACTIVE || filter == Filter.FILTER_MARKED_ONLY) && (this.is_filtered()) ^ profile.isFilterInverted()) || (filter == Filter.FILTER_CACHELIST)
+				&& !Global.mainForm.cacheList.contains(this.getWayPoint()));
 		boolean showAddi = this.showAddis() && this.mainCache != null && this.mainCache.isVisible();
 		noShow = noShow && !showAddi;
 		return !noShow;
@@ -1510,198 +1487,218 @@
 
 	// Getter and Setter for private properties
 
-	public String getLatLon() { return LatLon; }
+	public String getLatLon() {
+		return LatLon;
+	}
+
 	public void setLatLon(String _LatLon) {
-		_LatLon=_LatLon.trim();
-		if (!_LatLon.equals(LatLon.trim())) setUpdated(true);
+		_LatLon = _LatLon.trim();
+		if (!_LatLon.equals(LatLon.trim()))
+			setUpdated(true);
 		LatLon = _LatLon;
 		pos.set(_LatLon);
 	}
 
-	public String getBearing() {return bearing;}
-	
+	public String getBearing() {
+		return bearing;
+	}
+
 	/**
-	 * Gets an IconAndText object for the cache. If the level of the Icon is equal to the 
-	 * last call of the method, the same (cached) object is returned. If the object is
-	 * null or the level is different, a new object is created.<br> 
-	 * @param level 4=is_incomplete(), 3=is_new(), 2=is_updated(), 1=is_log_updated
-	 * @param fm Font metrics
+	 * Gets an IconAndText object for the cache. If the level of the Icon is equal to the last call of the method, the same (cached) object is returned. If the object is null or the level is different, a new object is created.<br>
+	 * 
+	 * @param level
+	 *            4=is_incomplete(), 3=is_new(), 2=is_updated(), 1=is_log_updated
+	 * @param fm
+	 *            Font metrics
 	 * @return New or old IconAndText object
 	 */
 	public IconAndText getIconAndTextWP(int level, FontMetrics fm) {
 		if (level != iconAndTextWPLevel || iconAndTextWP == null || !iconAndTextWP.text.equals(wayPoint)) {
 			switch (level) {
-				case 4: iconAndTextWP = new IconAndText(GuiImageBroker.imageError, wayPoint, fm); break;
-				case 3: iconAndTextWP = new IconAndText(myTableModel.yellow, wayPoint, fm); break;
-				case 2: iconAndTextWP = new IconAndText(myTableModel.red, wayPoint, fm); break;
-				case 1: iconAndTextWP = new IconAndText(myTableModel.blue, wayPoint, fm); break;
+			case 4:
+				iconAndTextWP = new IconAndText(GuiImageBroker.imageError, wayPoint, fm);
+				break;
+			case 3:
+				iconAndTextWP = new IconAndText(myTableModel.yellow, wayPoint, fm);
+				break;
+			case 2:
+				iconAndTextWP = new IconAndText(myTableModel.red, wayPoint, fm);
+				break;
+			case 1:
+				iconAndTextWP = new IconAndText(myTableModel.blue, wayPoint, fm);
+				break;
 			}
 			iconAndTextWPLevel = level;
 		}
 		return iconAndTextWP;
 	}
-	
-	public String getCacheStatus() { return cacheStatus; }
 
+	public String getCacheStatus() {
+		return cacheStatus;
+	}
+
 	public void setCacheStatus(String cacheStatus) {
-        if (!cacheStatus.equals(this.cacheStatus)) {
-        	this.cacheStatus = cacheStatus;
-            Global.getProfile().notifyUnsavedChanges(true);		
-            this.cacheStatus = cacheStatus;
-            if ((this.getType() == CacheType.CW_TYPE_FINAL) && (this.mainCache != null) ) {
-              this.mainCache.setCacheStatus(this.getCacheStatus());
-              // change the addi's in setFound
-            }
-        }
+		if (!cacheStatus.equals(this.cacheStatus)) {
+			this.cacheStatus = cacheStatus;
+			Global.getProfile().notifyUnsavedChanges(true);
+			this.cacheStatus = cacheStatus;
+			if ((this.getType() == CacheType.CW_TYPE_FINAL) && (this.mainCache != null)) {
+				this.mainCache.setCacheStatus(this.getCacheStatus());
+				// change the addi's in setFound
+			}
+		}
 	}
 
 	public String getWayPoint() {
-    	return wayPoint;
-    }
+		return wayPoint;
+	}
 
 	public void setWayPoint(String wayPoint) {
-		Global.getProfile().notifyUnsavedChanges(!wayPoint.equals(this.wayPoint));		
-    	this.wayPoint = wayPoint;
-    }
+		Global.getProfile().notifyUnsavedChanges(!wayPoint.equals(this.wayPoint));
+		this.wayPoint = wayPoint;
+	}
 
 	public String getCacheName() {
-    	return cacheName;
-    }
+		return cacheName;
+	}
 
 	public void setCacheName(String cacheName) {
-		Global.getProfile().notifyUnsavedChanges(!cacheName.equals(this.cacheName));		
-    	this.cacheName = cacheName;
-    }
+		Global.getProfile().notifyUnsavedChanges(!cacheName.equals(this.cacheName));
+		this.cacheName = cacheName;
+	}
 
 	public String getCacheOwner() {
-    	return cacheOwner;
-    }
+		return cacheOwner;
+	}
 
 	public void setCacheOwner(String cacheOwner) {
-		Global.getProfile().notifyUnsavedChanges(!cacheOwner.equals(this.cacheOwner));		
-    	this.cacheOwner = cacheOwner;
-    }
+		Global.getProfile().notifyUnsavedChanges(!cacheOwner.equals(this.cacheOwner));
+		this.cacheOwner = cacheOwner;
+	}
 
 	public String getDateHidden() {
-    	return dateHidden;
-    }
+		return dateHidden;
+	}
 
 	public void setDateHidden(String dateHidden) {
-		Global.getProfile().notifyUnsavedChanges(!dateHidden.equals(this.dateHidden));		
-    	this.dateHidden = dateHidden;
-    }
+		Global.getProfile().notifyUnsavedChanges(!dateHidden.equals(this.dateHidden));
+		this.dateHidden = dateHidden;
+	}
 
 	public byte getCacheSize() {
-    	return cacheSize;
-    }
+		return cacheSize;
+	}
 
 	public void setCacheSize(byte cacheSize) {
-		Global.getProfile().notifyUnsavedChanges(cacheSize != this.cacheSize);		
-    	this.cacheSize = cacheSize;
-    }
+		Global.getProfile().notifyUnsavedChanges(cacheSize != this.cacheSize);
+		this.cacheSize = cacheSize;
+	}
 
 	public byte getHard() {
-    	return hard;
-    }
+		return hard;
+	}
 
 	public void setHard(byte hard) {
-		Global.getProfile().notifyUnsavedChanges(hard != this.hard);		
-    	this.hard = hard;
-    }
+		Global.getProfile().notifyUnsavedChanges(hard != this.hard);
+		this.hard = hard;
+	}
 
 	public byte getTerrain() {
-    	return terrain;
-    }
+		return terrain;
+	}
 
 	public void setTerrain(byte terrain) {
-		Global.getProfile().notifyUnsavedChanges(terrain != this.terrain);		
-    	this.terrain = terrain;
-    }
+		Global.getProfile().notifyUnsavedChanges(terrain != this.terrain);
+		this.terrain = terrain;
+	}
 
 	/**
 	 * Gets the type of cache as integer.
+	 * 
 	 * @return Cache type
 	 */
 	public byte getType() {
 		return type;
-    }
+	}
 
 	/**
-	 * Sets the type of the cache. As the cache type values are int for the rest of CacheWolf
-	 * and byte internally of CacheHolder, some conversion has to be done.
-	 * @param typeId Cache Type
+	 * Sets the type of the cache. As the cache type values are int for the rest of CacheWolf and byte internally of CacheHolder, some conversion has to be done.
+	 * 
+	 * @param typeId
+	 *            Cache Type
 	 */
 	public void setType(byte typeId) {
-		Global.getProfile().notifyUnsavedChanges(typeId != type);		
-    	type = typeId;
-    }
+		Global.getProfile().notifyUnsavedChanges(typeId != type);
+		type = typeId;
+	}
 
 	public boolean is_archived() {
-    	return archived;
-    }
+		return archived;
+	}
 
 	public void setArchived(boolean is_archived) {
-		Global.getProfile().notifyUnsavedChanges(is_archived != this.archived);		
-    	this.archived = is_archived;
-    	if (this.archived) {this.available=false;}
-    }
+		Global.getProfile().notifyUnsavedChanges(is_archived != this.archived);
+		this.archived = is_archived;
+		if (this.archived) {
+			this.available = false;
+		}
+	}
 
 	public boolean is_available() {
-    	return available;
-    }
+		return available;
+	}
 
 	public void setAvailable(boolean is_available) {
 		Global.getProfile().notifyUnsavedChanges(is_available != this.available);
-    	this.available = is_available;
-		if (this.available) {this.archived=false;}
-    }
+		this.available = is_available;
+		if (this.available) {
+			this.archived = false;
+		}
+	}
 
 	public boolean is_owned() {
-    	return owned;
-    }
+		return owned;
+	}
 
 	public void setOwned(boolean is_owned) {
-		Global.getProfile().notifyUnsavedChanges(is_owned != this.owned);		
-    	this.owned = is_owned;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_owned != this.owned);
+		this.owned = is_owned;
+	}
 
 	public boolean is_found() {
-    	return found;
-    }
+		return found;
+	}
 
 	public void setFound(boolean is_found) {
-    if (is_found != this.found) {
-      Global.getProfile().notifyUnsavedChanges(true);		
-      this.found = is_found;
-      if ((this.getType() == CacheType.CW_TYPE_FINAL) && (this.mainCache != null) ) {
-        this.mainCache.setFound(is_found);
-		// done in setCacheStatus this.mainCache.setCacheStatus(this.getCacheStatus());
-        // so setFound should be called after setCacheStatus 
-        if (is_found) this.mainCache.setAttributesToAddiWpts();
-      }
-    }
-  }
+		if (is_found != this.found) {
+			Global.getProfile().notifyUnsavedChanges(true);
+			this.found = is_found;
+			if ((this.getType() == CacheType.CW_TYPE_FINAL) && (this.mainCache != null)) {
+				this.mainCache.setFound(is_found);
+				// done in setCacheStatus this.mainCache.setCacheStatus(this.getCacheStatus());
+				// so setFound should be called after setCacheStatus
+				if (is_found)
+					this.mainCache.setAttributesToAddiWpts();
+			}
+		}
+	}
 
 	/**
-	 * If this returns <code>true</code>, then the additional waypoints for this cache should be 
-	 * displayed regardless how the filter is set. If it is <code>false</code>, then the normal 
-	 * filter settings apply.<br>
-	 * This property is not saved in index.xml, so if you reload the data, then this information
-	 * is gone.
+	 * If this returns <code>true</code>, then the additional waypoints for this cache should be displayed regardless how the filter is set. If it is <code>false</code>, then the normal filter settings apply.<br>
+	 * This property is not saved in index.xml, so if you reload the data, then this information is gone.
+	 * 
 	 * @return <code>True</code>: Always display additional waypoints for cache.
 	 */
 	public boolean showAddis() {
 		return this.showAddis;
 	}
-	
+
 	/**
-	 * Setter for <code>showAddis()</code>. 
-	 * If this returns <code>true</code>, then the additional waypoints for this cache should be 
-	 * displayed regardless how the filter is set. If it is <code>false</code>, then the normal 
-	 * filter settings apply.<br>
-	 * This property is not saved in index.xml, so if you reload the data, then this information
-	 * is gone.
-	 * @param value <code>True</code>: Always display additional waypoints for cache.
+	 * Setter for <code>showAddis()</code>. If this returns <code>true</code>, then the additional waypoints for this cache should be displayed regardless how the filter is set. If it is <code>false</code>, then the normal filter settings apply.<br>
+	 * This property is not saved in index.xml, so if you reload the data, then this information is gone.
+	 * 
+	 * @param value
+	 *            <code>True</code>: Always display additional waypoints for cache.
 	 */
 	public void setShowAddis(boolean value) {
 		// This value is always stored in the main cache and all addis.
@@ -1713,17 +1710,15 @@
 		}
 		if (mc.showAddis != value) {
 			mc.showAddis = value;
-			for (int i=0; i<mc.addiWpts.size(); i++) {
+			for (int i = 0; i < mc.addiWpts.size(); i++) {
 				CacheHolder ac = (CacheHolder) mc.addiWpts.get(i);
 				ac.showAddis = value;
 			}
 		}
 	}
-	
+
 	/**
-	 * <b><u>Important</u></b>: This flag no longer indicates if a cache is visible
-	 * in the list. Instead, it now <u>only</u> flags if the cache is filtered out
-	 * by filter criteria. Use <code>isVisible()</code> instead.<br>
+	 * <b><u>Important</u></b>: This flag no longer indicates if a cache is visible in the list. Instead, it now <u>only</u> flags if the cache is filtered out by filter criteria. Use <code>isVisible()</code> instead.<br>
 	 * This property is affected by the following features:
 	 * <ul>
 	 * <li>"Defining and applying" a filter</li>
@@ -1737,239 +1732,232 @@
 	 * <li>Applying a cache tour filter</li>
 	 * <li>Switching between normal view and blacklist view</li>
 	 * <li>Performing searches</li>
-	 * <li>Anything else that isn't directly connected to filters in 
-	 * it's proper sense.</li>
+	 * <li>Anything else that isn't directly connected to filters in it's proper sense.</li>
 	 * </ul>
 	 * The new method for deciding if a cache is visible or not is <code>isVisible()
-	 * </code>.  
+	 * </code>.
+	 * 
 	 * @return <code>True</code> if filter criteria are matched
 	 */
 	public boolean is_filtered() {
-    	return filtered;
-    }
+		return filtered;
+	}
 
 	public void setFiltered(boolean is_filtered) {
-		Global.getProfile().notifyUnsavedChanges(is_filtered != this.filtered);		
-    	this.filtered = is_filtered;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_filtered != this.filtered);
+		this.filtered = is_filtered;
+	}
 
 	public boolean is_log_updated() {
-    	return log_updated;
-    }
+		return log_updated;
+	}
 
 	public void setLog_updated(boolean is_log_updated) {
-		Global.getProfile().notifyUnsavedChanges(is_log_updated != this.log_updated);		
-		if (is_log_updated && iconAndTextWPLevel == 1) iconAndTextWP = null;
-    	this.log_updated = is_log_updated;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_log_updated != this.log_updated);
+		if (is_log_updated && iconAndTextWPLevel == 1)
+			iconAndTextWP = null;
+		this.log_updated = is_log_updated;
+	}
 
 	public boolean is_updated() {
-    	return cache_updated;
-    }
+		return cache_updated;
+	}
 
 	public void setUpdated(boolean is_updated) {
-		Global.getProfile().notifyUnsavedChanges(is_updated != this.cache_updated);		
-		if (is_updated && iconAndTextWPLevel == 2) iconAndTextWP = null;
-    	this.cache_updated = is_updated;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_updated != this.cache_updated);
+		if (is_updated && iconAndTextWPLevel == 2)
+			iconAndTextWP = null;
+		this.cache_updated = is_updated;
+	}
 
 	public boolean is_incomplete() {
-    	return incomplete;
-    }
+		return incomplete;
+	}
 
 	public void setIncomplete(boolean is_incomplete) {
-		Global.getProfile().notifyUnsavedChanges(is_incomplete != this.incomplete);	
-		if (is_incomplete && iconAndTextWPLevel == 4) iconAndTextWP = null;
-    	this.incomplete = is_incomplete;
-    }
-	
+		Global.getProfile().notifyUnsavedChanges(is_incomplete != this.incomplete);
+		if (is_incomplete && iconAndTextWPLevel == 4)
+			iconAndTextWP = null;
+		this.incomplete = is_incomplete;
+	}
+
 	/** checks the waypoint data integrity to set a warning flag if something is missing */
 	public boolean checkIncomplete() {
 		// TODO: discuss if we should only check cache waypoints and silently "fix" everything else
 		boolean ret;
 		if (isCacheWpt()) {
-			if (getWayPoint().length() < 3
-					|| getHard() < CacheTerrDiff.CW_DT_UNSET
-					|| getTerrain() < CacheTerrDiff.CW_DT_UNSET
-					|| getCacheSize() == CacheSize.CW_SIZE_ERROR
-					|| getCacheOwner().length() == 0
-					|| getDateHidden().length() == 0 
-					|| getCacheName().length() == 0) 
+			if (getWayPoint().length() < 3 || getHard() < CacheTerrDiff.CW_DT_UNSET || getTerrain() < CacheTerrDiff.CW_DT_UNSET || getCacheSize() == CacheSize.CW_SIZE_ERROR || getCacheOwner().length() == 0 || getDateHidden().length() == 0
+					|| getCacheName().length() == 0)
 				ret = true;
 			else
 				ret = false;
 		} else if (isAddiWpt()) {
-			//FIXME: do not check for mainCache == null, since it will be null during initial import
-			//FIXME: find out why we only check waypoints with IDs of a certain length ???
-//			if (mainCache == null
-//					|| getHard() != CacheTerrDiff.CW_DT_UNSET 
-			if (getHard() != CacheTerrDiff.CW_DT_UNSET
-					|| getCacheSize() != CacheSize.CW_SIZE_NOTCHOSEN
-					|| getTerrain() != CacheTerrDiff.CW_DT_UNSET
-					|| getWayPoint().length() < 3
-//					|| getCacheOwner().length() > 0
-//					|| getDateHidden().length() > 0 
-					|| getCacheName().length() == 0
-					)
+			// FIXME: do not check for mainCache == null, since it will be null during initial import
+			// FIXME: find out why we only check waypoints with IDs of a certain length ???
+			// if (mainCache == null
+			// || getHard() != CacheTerrDiff.CW_DT_UNSET
+			if (getHard() != CacheTerrDiff.CW_DT_UNSET || getCacheSize() != CacheSize.CW_SIZE_NOTCHOSEN || getTerrain() != CacheTerrDiff.CW_DT_UNSET || getWayPoint().length() < 3
+			// || getCacheOwner().length() > 0
+			// || getDateHidden().length() > 0
+					|| getCacheName().length() == 0)
 				ret = true;
 			else
 				ret = false;
 		} else if (isCustomWpt()) {
-			if (getHard() != CacheTerrDiff.CW_DT_UNSET 
-					|| getTerrain() != CacheTerrDiff.CW_DT_UNSET
-					|| getCacheSize() != CacheSize.CW_SIZE_NOTCHOSEN
-					|| getWayPoint().length() < 3
-//					|| getCacheOwner().length() > 0
-//					|| getDateHidden().length() > 0 
-//					|| getCacheName().length() == 0
-					)
+			if (getHard() != CacheTerrDiff.CW_DT_UNSET || getTerrain() != CacheTerrDiff.CW_DT_UNSET || getCacheSize() != CacheSize.CW_SIZE_NOTCHOSEN || getWayPoint().length() < 3
+			// || getCacheOwner().length() > 0
+			// || getDateHidden().length() > 0
+			// || getCacheName().length() == 0
+			)
 				ret = true;
 			else
 				ret = false;
 		} else {
 			// we should not get here, so let's set a warning just in case
-			ret=true;
+			ret = true;
 		}
 		setIncomplete(ret);
 		return ret;
 	}
 
 	/**
-	 * Determines if the blacklist status is set for the cache. Do not use this method
-	 * to check if the cache should be displayed. Use <code>isVisible()</code> for
-	 * this, which already does this (and other) checks.<br>
-	 * Only use this method if you really want to inform yourself about the 
-	 * black status of the cache!
+	 * Determines if the blacklist status is set for the cache. Do not use this method to check if the cache should be displayed. Use <code>isVisible()</code> for this, which already does this (and other) checks.<br>
+	 * Only use this method if you really want to inform yourself about the black status of the cache!
+	 * 
 	 * @return <code>true</code> if he black status of the cache is set.
 	 */
 	public boolean is_black() {
-    	return black;
-    }
+		return black;
+	}
 
 	public void setBlack(boolean is_black) {
-		Global.getProfile().notifyUnsavedChanges(is_black != this.black);		
-    	this.black = is_black;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_black != this.black);
+		this.black = is_black;
+	}
 
 	public boolean is_new() {
-    	return newCache;
-    }
+		return newCache;
+	}
 
 	public void setNew(boolean is_new) {
-		Global.getProfile().notifyUnsavedChanges(is_new != this.newCache);		
-		if (is_new && iconAndTextWPLevel == 3) iconAndTextWP = null;
+		Global.getProfile().notifyUnsavedChanges(is_new != this.newCache);
+		if (is_new && iconAndTextWPLevel == 3)
+			iconAndTextWP = null;
 		this.newCache = is_new;
-    }
+	}
 
 	public String getOcCacheID() {
-    	return ocCacheID;
-    }
+		return ocCacheID;
+	}
 
 	public void setOcCacheID(String ocCacheID) {
-		Global.getProfile().notifyUnsavedChanges(!ocCacheID.equals(this.ocCacheID));		
-    	this.ocCacheID = ocCacheID;
-    }
+		Global.getProfile().notifyUnsavedChanges(!ocCacheID.equals(this.ocCacheID));
+		this.ocCacheID = ocCacheID;
+	}
 
 	public byte getNoFindLogs() {
-    	return noFindLogs;
-    }
+		return noFindLogs;
+	}
 
 	public void setNoFindLogs(byte noFindLogs) {
-		Global.getProfile().notifyUnsavedChanges(noFindLogs != this.noFindLogs);		
-    	this.noFindLogs = noFindLogs;
-    }
+		Global.getProfile().notifyUnsavedChanges(noFindLogs != this.noFindLogs);
+		this.noFindLogs = noFindLogs;
+	}
 
 	public int getNumRecommended() {
-    	return numRecommended;
-    }
+		return numRecommended;
+	}
+
 	public String getRecommended() {
 		if (!isCacheWpt())
 			return "";
-		if ( isOC() ) {
-		  return Convert.formatInt(numRecommended);
+		if (isOC()) {
+			return Convert.formatInt(numRecommended);
 		} else {
-		  int gcVote = numRecommended;
-		  if ( gcVote < 100 ) {
-		    return MyLocale.formatDouble((double)gcVote/10.0, "0.0"); 
-		  } else {
-		    int votes = gcVote / 100;
-		    gcVote = gcVote - 100 * votes;
-		    return MyLocale.formatDouble((double)gcVote/10.0, "0.0") + " (" + Convert.formatInt(votes) + ")";
-		  }
+			int gcVote = numRecommended;
+			if (gcVote < 100) {
+				return MyLocale.formatDouble((double) gcVote / 10.0, "0.0");
+			} else {
+				int votes = gcVote / 100;
+				gcVote = gcVote - 100 * votes;
+				return MyLocale.formatDouble((double) gcVote / 10.0, "0.0") + " (" + Convert.formatInt(votes) + ")";
+			}
 		}
 	}
 
 	public void setNumRecommended(int numRecommended) {
-		Global.getProfile().notifyUnsavedChanges(numRecommended != this.numRecommended);		
-    	this.numRecommended = numRecommended;
-    }
+		Global.getProfile().notifyUnsavedChanges(numRecommended != this.numRecommended);
+		this.numRecommended = numRecommended;
+	}
 
 	public int getNumFoundsSinceRecommendation() {
-    	return numFoundsSinceRecommendation;
-    }
+		return numFoundsSinceRecommendation;
+	}
 
 	public void setNumFoundsSinceRecommendation(int numFoundsSinceRecommendation) {
-		Global.getProfile().notifyUnsavedChanges(numFoundsSinceRecommendation != this.numFoundsSinceRecommendation);		
-    	this.numFoundsSinceRecommendation = numFoundsSinceRecommendation;
-    }
+		Global.getProfile().notifyUnsavedChanges(numFoundsSinceRecommendation != this.numFoundsSinceRecommendation);
+		this.numFoundsSinceRecommendation = numFoundsSinceRecommendation;
+	}
 
 	public boolean has_bugs() {
-    	return bugs;
-    }
+		return bugs;
+	}
 
 	public void setHas_bugs(boolean has_bug) {
-		Global.getProfile().notifyUnsavedChanges(has_bug != this.bugs);		
-    	this.bugs = has_bug;
-    }
+		Global.getProfile().notifyUnsavedChanges(has_bug != this.bugs);
+		this.bugs = has_bug;
+	}
 
 	public boolean is_HTML() {
-    	return html;
-    }
+		return html;
+	}
 
 	public void setHTML(boolean is_HTML) {
-		Global.getProfile().notifyUnsavedChanges(is_HTML != this.html);		
-    	this.html = is_HTML;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_HTML != this.html);
+		this.html = is_HTML;
+	}
 
 	public String getLastSync() {
-    	return lastSync;
-    }
+		return lastSync;
+	}
 
 	public void setLastSync(String lastSync) {
-		Global.getProfile().notifyUnsavedChanges(!lastSync.equals(this.lastSync));		
-    	this.lastSync = lastSync;
-    }
+		Global.getProfile().notifyUnsavedChanges(!lastSync.equals(this.lastSync));
+		this.lastSync = lastSync;
+	}
 
 	public long[] getAttributesBits() {
-    	return this.attributesBits;
-    }
+		return this.attributesBits;
+	}
 
 	public void setAttribsAsBits(long[] attributesBits) {
-		Global.getProfile().notifyUnsavedChanges(attributesBits != this.attributesBits);		
-    	this.attributesBits = attributesBits;
-    }
-	
+		Global.getProfile().notifyUnsavedChanges(attributesBits != this.attributesBits);
+		this.attributesBits = attributesBits;
+	}
+
 	public boolean hasSolver() {
 		return hasSolver;
 	}
-	
+
 	public void setHasSolver(boolean hasSolver) {
-		Global.getProfile().notifyUnsavedChanges(hasSolver != this.hasSolver);		
+		Global.getProfile().notifyUnsavedChanges(hasSolver != this.hasSolver);
 		this.hasSolver = hasSolver;
 	}
 
 	public boolean hasNote() {
 		return hasNote;
 	}
-	
+
 	public void setHasNote(boolean hasNote) {
-		Global.getProfile().notifyUnsavedChanges(hasNote != this.hasNote);		
+		Global.getProfile().notifyUnsavedChanges(hasNote != this.hasNote);
 		this.hasNote = hasNote;
 	}
-	
+
 	/**
 	 * rename a waypoint and all its associated files
-	 * @param newWptId new waypoint id (will be converted to upper case)
+	 * 
+	 * @param newWptId
+	 *            new waypoint id (will be converted to upper case)
 	 * @return true on success, false on error
 	 */
 	public boolean rename(String newWptId) {
@@ -1985,4 +1973,3 @@
 		}
 	}
 }
-

Modified: trunk/src/CacheWolf/DateFormat.java
===================================================================
--- trunk/src/CacheWolf/DateFormat.java	2011-05-08 11:30:44 UTC (rev 2996)
+++ trunk/src/CacheWolf/DateFormat.java	2011-05-10 21:54:53 UTC (rev 2997)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 /* Several date formats are used by GC.COM
@@ -33,75 +33,129 @@
  *    2004-02-27    - YYYY-MM-DD   
  */
 
-import ewe.sys.Convert;
 import ewe.sys.Time;
+import ewe.util.mString;
 
 public class DateFormat {
 
 	/** Convert the US Format into a sortable format */
-	public static String MDY2YMD(String date) {
-		// Dates are in format M/D/Y
-		int p1, p2 = -1, p3;
-		p1 = date.indexOf("/");
-		if (p1==-1){
-			//dayofweek, dayofmonth month year (Monday, 07 June 2010)
-			p1 = date.indexOf(",");			
-			p2 = date.indexOf(" ", p1 + 2);
-			p3 = date.indexOf(" ", p2 + 1);
-			final String monthNames[] = { "January", "February", "March", "April", "May",
-					"June", "July", "August", "September", "October", "November",
-					"December" };
-			for (int m = 0; m < 12; m++) {
-				if (monthNames[m].equals(date.substring(p2+1,p3))) {
-					String mm = Integer.toString(m+1);
-					if (mm.length()==1) {mm=0+mm;}
-					return date.substring(p3+1,p3+5) + "-" + mm + "-" + date.substring(p1+2, p1+4);
+	public static String toYYMMDD(String date) {
+		return toYYMMDD(toDate(date));
+	}
+
+	public static Time toDate(String ds) {
+		if (ds == null || ds.equals("") || ds.indexOf("1900") > -1)
+			return new Time(1, 1, 1900);
+		final long adaylong = new Time(2, 1, 2000).getTime() - new Time(1, 1, 2000).getTime();
+		Time d = new Time();
+		d.hour = 0;
+		d.minute = 0;
+		d.second = 0;
+		d.millis = 0;
+		if (ds.indexOf("day") > 0) {
+			if (ds.indexOf("Yesterday") > -1) {
+				d.setTime(d.getTime() - adaylong);
+			} else {
+				d.setTime(d.getTime() - adaylong * Common.parseInt(ds.substring(0, 1)));
+			}
+		} else {
+			String[] SDate;
+			ds = STRreplace.replace(ds, ",", " ");
+			ds = STRreplace.replace(ds, "  ", " ");
+			SDate = mString.split(ds, ' ');
+			if (SDate.length == 1) {
+				if (ds.indexOf('/') > -1)
+					SDate = mString.split(ds, '/');
+				else if (ds.indexOf('-') > -1)
+					SDate = mString.split(ds, '-');
+				// trying to determine Dateformat
+				int v0 = Common.parseInt(SDate[0]);
+				int v1 = Common.parseInt(SDate[1]);
+				int v2 = Common.parseInt(SDate[2]);
+				int dd, mm, yy;
+				if (v0 > 31) {
+					// yyyy mm dd
+					yy = v0;
+					mm = v1;
+					dd = v2;
+				} else {
+					yy = v2;
+					if ((v0 == 0) || (v1 == 0)) {
+						// month as text
+						String month;
+						if (v0 == 0) {
+							month = SDate[0];
+							dd = v1;
+						} else {
+							month = SDate[1];
+							dd = v0;
+						}
+						mm = monthName2int(month);
+					} else {
+						// mm dd yyyy
+						mm = v0;
+						dd = v1;
+					}
+
 				}
+				d.month = mm;
+				d.day = dd;
+				d.year = yy;
+			} else {
+				// starting with dayOfWeek or missing year
+				int offs = SDate.length - 3;
+				if (offs < 0)
+					offs = 0;
+				int v0 = Common.parseInt(SDate[offs]);
+				if (v0 == 0) {
+					d.day = Common.parseInt(SDate[offs + 1]);
+					d.month = monthName2int(SDate[offs]);
+				} else {
+					d.day = Common.parseInt(SDate[offs]);
+					d.month = monthName2int(SDate[offs + 1]);
+				}
+				if (SDate.length > 2) {
+					int yy = Common.parseInt(SDate[offs + 2]);
+					if (yy < 100)
+						d.year = 2000 + yy;
+					else
+						d.year = yy;
+				} else
+					// missing year
+					; // d.year = this year
 			}
-			return date;
 		}
-		else {
-			if (p1 > 0)
-				p2 = date.indexOf("/", p1 + 1);
-			if (p1 > 0 && p2 > 0) {
-				return date.substring(p2 + 1) + "-" + (p1 == 1 ? "0" : "")
-						+ date.substring(0, p1) + "-" + (p1 + 2 == p2 ? "0" : "")
-						+ date.substring(p1 + 1, p2);
-			} else
-				return date;
-		}
+		return d;
 	}
 
-	/* Convert the sortable date into a US date */
-	// static String YMD2MDY(String date) {
-	// return
-	// date.substring(4,6)+"/"+date.substring(6,8)+"/"+date.substring(0,4);
-	// }
-	/** Convert the log format into a sortable format */
-	public static String logdate2YMD(String logdate) {
-		String monthNames[] = { "January", "February", "March", "April", "May",
-				"June", "July", "August", "September", "October", "November",
-				"December" };
-		Time t = new Time();
-		String year, month, day;
-		int i, m;
-		logdate += ", " + t.year; // If logdate already has a year, this one is
-									// ignored
-		i = logdate.indexOf(',');
-		year = logdate.substring(i + 2, i + 6);
-		for (m = 0; m < 12; m++) {
-			if (logdate.startsWith(monthNames[m])) {
-				month = (m < 9 ? "0" : "") + Convert.formatInt(m + 1);
-				day = logdate.substring(monthNames[m].length() + 1, i);
-				if (day.length() == 1)
-					day = "0" + day;
-				return year + "-" + month + "-" + day;
+	private static int monthName2int(String month) {
+		final String enMonthNames[] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
+		for (int m = 0; m < 12; m++) {
+			if (enMonthNames[m].startsWith(month)) {
+				return m + 1;
 			}
 		}
-		return "";
+		final String deMonthNames[] = { "Januar", "Februar", "M?rz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember" };
+		for (int m = 0; m < 12; m++) {
+			if (deMonthNames[m].startsWith(month)) {
+				return m + 1;
+			}
+		}
+		return 1; // Januar if not detected / in other language
 	}
+
+	public static String toYYMMDD(Time d) {
+		return toYYMMDD(d, '-');
+	}
+
+	public static String toYYMMDD(Time d, char separator) {
+		// the CW Time Format is with separator
+		String f = "yyyy" + separator + "MM" + separator + "dd";
+		return d.format(f);
+	}
+
 	// from lastSyncDate (yyyyMMddHHmmss) to gpxLogdate (yyyy-MM-dd)
-	// if no lastSyncDate returns current Date 
+	// if no lastSyncDate returns current Date
 	public static String yyyyMMddHHmmss2gpxLogdate(String yyyyMMddHHmmss) {
 		Time d = new Time();
 		try {
@@ -109,7 +163,7 @@
 		} catch (IllegalArgumentException e) {
 			d = new Time();
 			d.parse(yyyyMMddHHmmss, "yyyyMMddHHmmss");
-		}		
+		}
 		return d.format("yyyy-MM-dd"); // +d.format("HH:mm:ss"); is set to 00:00:00 at gpxExport
 	}
 

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-08 11:30:44 UTC (rev 2996)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-10 21:54:53 UTC (rev 2997)
@@ -1330,6 +1330,7 @@
 			pref.log("already English");
 			return true;
 		}
+
 		// todo next doesn't work correct don't know why
 		// switch to english now goes into gc account Display Preferences (is permanent, must be reset)
 		final Regex rexViewstate = new Regex("id=\"__VIEWSTATE\" value=\"(.*?)\" />");
@@ -1605,7 +1606,7 @@
 			lonmax = (int) br.lonDec;
 			latmin = (int) tl.latDec;
 			latmax = (int) br.latDec;
-		} while ((lonmax - lonmin > 1) && (latmax - latmin > 1) && (scale > 16));
+		} while ((lonmax - lonmin > 1) && (latmax - latmin > 1) && (scale > 10));
 
 		String cachelist;
 
@@ -1706,16 +1707,22 @@
 
 		final int WpIndex = page.indexOf("\"gc\":");
 		final String[] elements = mString.split(page.substring(WpIndex), '\"');
-
+		if (elements.length != 63) {
+			(new MessageBox(MyLocale.getMsg(5500, "Error"), "GC changed format of new Map Infos", FormBase.OKB)).execute();
+			return;
+		}
 		final int posWP = 3; // gc
-		final int posDisabled = 6; // disabled
-		final int posDiff = 10; // difficulty
-		final int posTerr = 18; // terrain
-		final int posHidden = 25; // hidden date
-		final int posSize = 31; // size
-		final int posType = 44; // type
-		final int posOwner = 49; // owner
-		final int posGUID = 53; // guid
+		// final int posWPGuid = 7; // g
+		final int posDisabled = 10; // disabled
+		final int posPM = 12; // PM - Cache
+		// final int posLI = 14; // who knows
+		final int posDiff = 18; // difficulty
+		final int posTerr = 26; // terrain
+		final int posHidden = 33; // hidden date
+		final int posSize = 39; // size oder 43
+		final int posType = 52; // type 49 , 52
+		final int posOwner = 57; // owner
+		// final int posOwnerGUID = 61; // guid
 
 		// final boolean found = (elements[posFound].indexOf("true") > -1 ? true
 		// : false);
@@ -1726,13 +1733,16 @@
 			if (restrictedCacheType != cacheType)
 				return;
 		}
-
+		boolean pm = elements[posPM].indexOf("false") > -1 ? false : true;
+		// boolean li = elements[posLI].indexOf("true") > -1 ? false : true;
 		String wp = elements[posWP];
 		CacheHolder ch = cacheDB.get(wp);
 		if (ch == null) {
 
 			ch = new CacheHolder();
 			ch.setWayPoint(wp);
+			if (pm && !pref.isPremium)
+				ch.setCacheStatus("PM");
 			ch.pos = p;
 			final String owner = elements[posOwner];
 			ch.setCacheOwner(owner);
@@ -1751,7 +1761,7 @@
 			cacheName = STRreplace.replace(cacheName, "\\\"", "\"");
 			ch.setCacheName(cacheName);
 			ch.setAvailable((elements[posDisabled].indexOf("true") > -1 ? false : true));
-			ch.setDateHidden(DateFormat.MDY2YMD(elements[posHidden]));
+			ch.setDateHidden(DateFormat.toYYMMDD(elements[posHidden]));
 			ch.setHard(CacheTerrDiff.v1Converter(elements[posDiff].substring(1, elements[posDiff].length() - 1)));
 			ch.setTerrain(CacheTerrDiff.v1Converter(elements[posTerr].substring(1, elements[posTerr].length() - 1)));
 			ch.setCacheSize(CacheSize.gcGpxString2Cw(elements[posSize]));
@@ -2224,12 +2234,6 @@
 			return true; // or check cacheDescGC also no log?
 		lastLogCW.parse(slastLogCW, "yyyy-MM-dd");
 
-		final Time lastLogGC = new Time(); // is current time
-		lastLogGC.hour = 0;
-		lastLogGC.minute = 0;
-		lastLogGC.second = 0;
-		lastLogGC.millis = 0;
-		String[] SDate;
 		String stmp = "";
 		RexPropLogDate.search(cacheDescription);
 		if (RexPropLogDate.didMatch()) {
@@ -2238,67 +2242,8 @@
 			pref.log("check logDateRex in spider.def" + Preferences.NEWLINE + cacheDescription);
 			return false;
 		}
-		if (stmp.indexOf("day") > 0) {
-			// simplyfied (update if not newer than last week)
-			lastLogGC.setTime(lastLogGC.getTime() - 691200000L);
-		} else if (stmp.equals("")) {
-			return false; // no log yet
-		} else {
-			final String monthNames[] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
-			SDate = mString.split(stmp, ' ');
-			if (SDate.length == 1) {
-				SDate = mString.split(stmp, '/');
-				// trying to determine Dateformat
-				int v0 = Common.parseInt(SDate[0]);
-				int v1 = Common.parseInt(SDate[1]);
-				int v2 = Common.parseInt(SDate[2]);
-				int dd, mm, yy;
-				if (v0 > 31) {
-					// yyyy mm dd
-					yy = v0;
-					mm = v1;
-					dd = v2;
-				} else {
-					yy = v2;
-					if ((v0 == 0) || (v1 == 0)) {
-						// month as text
-						String month;
-						if (v0 == 0) {
-							month = SDate[0];
-							dd = v1;
-						} else {
-							month = SDate[1];
-							dd = v0;
-						}
-						mm = 12;
-						for (int m = 0; m < 12; m++) {
-							if (monthNames[m].startsWith(month)) {
-								mm = m + 1;
-								m = 12;
-							}
-						}
-					} else {
-						// mm dd yyyy
-						mm = v0;
-						dd = v1;
-					}
-
-				}
-				lastLogGC.month = mm;
-				lastLogGC.day = dd;
-				lastLogGC.year = yy;
-			} else {
-				// Format till may 2011
-				lastLogGC.day = Common.parseInt(SDate[0]);
-				for (int m = 0; m < 12; m++) {
-					if (monthNames[m].startsWith(SDate[1])) {
-						lastLogGC.month = m + 1;
-						m = 12;
-					}
-				}
-				lastLogGC.year = 2000 + Common.parseInt(SDate[2].substring(0, 2));
-			}
-		}
+		final Time lastLogGC = DateFormat.toDate(stmp);
+		// String timecheck = DateFormat.toYYMMDD(lastLogGC);
 		final boolean ret = lastLogCW.compareTo(lastLogGC) < 0;
 		return ret;
 	}
@@ -2442,7 +2387,7 @@
 							ch.setOwned(true);
 						pref.log("Owner: " + ch.getCacheOwner() + "; is_owned = " + ch.is_owned() + ";  alias1,2 = [" + pref.myAlias + "|" + pref.myAlias2 + "]");
 
-						ch.setDateHidden(DateFormat.MDY2YMD(getDateHidden(completeWebPage)));
+						ch.setDateHidden(DateFormat.toYYMMDD(getDateHidden(completeWebPage)));
 						pref.log("Hidden: " + ch.getDateHidden());
 
 						ch.getCacheDetails(false).setHints(getHints(completeWebPage));
@@ -2749,8 +2694,10 @@
 			pref.log("check blockRex in spider.def" + Preferences.NEWLINE + completeWebPage);
 		}
 		final String LogBlock = RexLogBlock.stringMatched(1);
+
 		exSingleLog.setSource(LogBlock);
 		singleLog = exSingleLog.findNext();
+
 		exIcon.setSource(singleLog);
 		exNameTemp.setSource(singleLog);
 		exName.setSource(exNameTemp.findNext());
@@ -2763,17 +2710,14 @@
 			// pref.log(singleLog);
 			nLogs++;
 			icon = exIcon.findNext();
-			icon = icon.substring(0, icon.length() - 1); // ' changes to " in
-															// UMTS-connection!
-															// first char in
-															// iconExEnd.
+			// ' changes to " in UMTS-connection! first char in iconExEnd.
+			icon = icon.substring(0, icon.length() - 1);
 			name = exName.findNext();
 			logText = exLog.findNext();
 			logText = correctSmilies(logText);
 			logId = exLogId.findNext();
 			final String ed = exDate.findNext();
-			final String d = DateFormat.logdate2YMD(ed);
-			// pref.log("Lognr:"+nLogs+"|"+icon+"|"+name+"-|-"+SafeXML.clean(pref.myAlias)+"|"+logId,null);
+			final String d = DateFormat.toYYMMDD(ed);
 			// if this log says this Cache is found by me
 			if ((icon.equals(icon_smile) || icon.equals(icon_camera) || icon.equals(icon_attended)) && (name.equalsIgnoreCase(SafeXML.clean(pref.myAlias)) || (pref.myAlias2.length() > 0 && name.equalsIgnoreCase(SafeXML.clean(pref.myAlias2))))) {
 				chD.getParent().setFound(true);



From araber95 at mail.berlios.de  Wed May 11 02:37:28 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Wed, 11 May 2011 02:37:28 PM +0200
Subject: [Cachewolf-svn] r2998 - in trunk/src/CacheWolf: . imp
Message-ID: <20110511123729.3B00E481374@sheep.berlios.de>

Author: araber95
Date: 2011-05-11 14:37:28 +0200 (Wed, 11 May 2011)
New Revision: 2998

Modified:
   trunk/src/CacheWolf/LogList.java
   trunk/src/CacheWolf/imp/SpiderGC.java
Log:
1.  no quick import of finds and own for PM
2.  no Code Change for LogList.java

Modified: trunk/src/CacheWolf/LogList.java
===================================================================
--- trunk/src/CacheWolf/LogList.java	2011-05-10 21:54:53 UTC (rev 2997)
+++ trunk/src/CacheWolf/LogList.java	2011-05-11 12:37:28 UTC (rev 2998)
@@ -1,55 +1,56 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import ewe.util.Vector;
 
 public class LogList {
-	/** The Vector containing the Log objects 
-	 * The list is always sorted in descending order */
-	private Vector logList=new Vector(10);
+	/**
+	 * The Vector containing the Log objects The list is always sorted in descending order
+	 */
+	private Vector logList = new Vector(10);
 	private static final StringBuffer buffer = new StringBuffer();
 
 	/** Construct an empty Log list */
 	public LogList() { // Public constructor
 	}
-	
+
 	/** Get the Log at a certain position in the list */
 	public Log getLog(int i) {
-		if (logList.size()>i) {
-			return (Log) logList.elementAt(i);			
-		}
-		else return null;
+		if (logList.size() > i) {
+			return (Log) logList.elementAt(i);
+		} else
+			return null;
 	}
-	
+
 	/** Return the size of the list */
 	public int size() {
 		return logList.size();
 	}
-	
+
 	/** Clear the Log list */
 	public void clear() {
 		logList.clear();
@@ -57,9 +58,10 @@
 
 	/** Add a Log to the list */
 	public void add(Log log) {
-		if (log.getIcon()!=null) logList.add(log); // Don't add invalid logs
+		if (log.getIcon() != null)
+			logList.add(log); // Don't add invalid logs
 	}
-	
+
 	/** Remove a Log from the list */
 	public void remove(int i) {
 		logList.removeElementAt(i);
@@ -69,47 +71,49 @@
 	public void replace(int i, Log log) {
 		logList.set(i, log);
 	}
-	
-	/** Merge a log into the list at the appropriate position
+
+	/**
+	 * Merge a log into the list at the appropriate position
+	 * 
 	 * @param newLog
 	 * @return the position where the log was placed or -1 if it is already in the list
-	 */ 
-	 
+	 */
+
 	public int merge(Log newLog) {
-		String newDate=newLog.getDate();
-		int size=size();
+		String newDate = newLog.getDate();
+		int size = size();
 		int i;
-		for (i=0; i<size; i++) {
-			 int comp=newDate.compareTo(((Log) logList.elementAt(i)).getDate());
-			 if (comp>0) {
-				 logList.insertElementAt(newLog, i);
-				 return i;
-			 }
-			 if (comp==0) break;
+		for (i = 0; i < size; i++) {
+			int comp = newDate.compareTo(((Log) logList.elementAt(i)).getDate());
+			if (comp > 0) {
+				logList.insertElementAt(newLog, i);
+				return i;
+			}
+			if (comp == 0)
+				break;
 		}
 		// Now i points to the first log with same date as the new log or i==size()
-		if (i==size) {
+		if (i == size) {
 			add(newLog);
 			return size;
 		}
-		int firstLog=i;
+		int firstLog = i;
 		// Check whether we have any logs with same date by same user
-		String newLogger=newLog.getLogger();
-		String newIcon=newLog.getIcon();
-		while (i<size &&  newDate.equals(((Log) logList.elementAt(i)).getDate())) {
-			Log log=(Log) logList.elementAt(i);
-			if (log.getLogger().equals(newLogger) &&
-				log.getIcon().equals(newIcon)) {
+		String newLogger = newLog.getLogger();
+		String newIcon = newLog.getIcon();
+		while (i < size && newDate.equals(((Log) logList.elementAt(i)).getDate())) {
+			Log log = (Log) logList.elementAt(i);
+			if (log.getLogger().equals(newLogger) && log.getIcon().equals(newIcon)) {
 				// Has the log message changed vs. the one we have in cache.xml?
 				if (!log.getMessage().equals(newLog.getMessage())) {
-					replace(i,newLog);
+					replace(i, newLog);
 					return i;
 				} else
 					return -1; // Log already in list
 			}
 			i++;
 		}
-		if (i==size) {
+		if (i == size) {
 			add(newLog);
 			return i;
 		} else {
@@ -118,20 +122,18 @@
 		}
 	}
 
-	 /**
-	  *  Count the number of not-found logs
-	  */
+	/**
+	 * Count the number of not-found logs
+	 */
 	public byte countNotFoundLogs() {
 		byte countNoFoundLogs = 0;
 		int currentLog = 0;
 		String currentIcon;
-		while(currentLog < size() && countNoFoundLogs < 5){
+		while (currentLog < size() && countNoFoundLogs < 5) {
 			currentIcon = getLog(currentLog).getIcon();
-			if(currentIcon.startsWith("icon_sad")) {
+			if (currentIcon.startsWith("icon_sad")) {
 				countNoFoundLogs++;
-			}else if (currentIcon.startsWith("icon_smile") || currentIcon.startsWith("icon_camera")
-             || currentIcon.startsWith("icon_attended") || currentIcon.startsWith("icon_rsvp")
-             || currentIcon.startsWith("icon_maint")) {
+			} else if (currentIcon.startsWith("icon_smile") || currentIcon.startsWith("icon_camera") || currentIcon.startsWith("icon_attended") || currentIcon.startsWith("icon_rsvp") || currentIcon.startsWith("icon_maint")) {
 				break;
 			}
 			currentLog++;
@@ -139,51 +141,57 @@
 		return countNoFoundLogs;
 	}
 
-	 /** only valid after calling calcRecommendations() */
-	 int numRecommended = 0;
-	 /** only valid after calling calcRecommendations() */
-	 int foundsSinceRecommendation = 0;
-	 /** only valid after calling calcRecommendations() */
-	 int recommendationRating = 0;
-	 
-	 /**
-	  * call this to 
-	  *
-	  */
-	 public void calcRecommendations() {
-		 numRecommended = 0;
-		 foundsSinceRecommendation = 0;
-		 Log l;
-		 int s = size();
-		 int i;
-		 for (i= 0 ; i < s; i++){
-			 l = getLog(i);
-			 if (l.getDate().compareTo("2007-01-14") < 0) break; // this is the date when the recommendation system was introdueced in opencaching.de see: http://www.geoclub.de/viewtopic.php?t=14901&highlight=formel
-			 if (l.isRecomended()) numRecommended++;
-			 if (l.isFoundLog()) foundsSinceRecommendation++; 
-		 }
-		 recommendationRating = getScore(numRecommended, foundsSinceRecommendation);
-	 }
-	 
-	 public static int getScore(int numrecommends, int numfoundlogs) {
-		 return Math.round((((float)numrecommends * (float)numrecommends +1f ) / (numfoundlogs / 10f +1f))*100f);
-	 }
-	 
-	 /**
-	  * Returns a simple concatenation of all Log texts of the list. Intended for text search in 
-	  * Logs.
+	/** only valid after calling calcRecommendations() */
+	int numRecommended = 0;
+	/** only valid after calling calcRecommendations() */
+	int foundsSinceRecommendation = 0;
+	/** only valid after calling calcRecommendations() */
+	int recommendationRating = 0;
+
+	/**
+	 * call this to
+	 * 
+	 */
+	public void calcRecommendations() {
+		numRecommended = 0;
+		foundsSinceRecommendation = 0;
+		Log l;
+		int s = size();
+		int i;
+		for (i = 0; i < s; i++) {
+			l = getLog(i);
+			// 2007-01-14 is the date when the recommendation system was introdueced in opencaching.de see:
+			// http://www.geoclub.de/viewtopic.php?t=14901&highlight=formel
+			if (l.getDate().compareTo("2007-01-14") < 0)
+				break;
+			if (l.isRecomended())
+				numRecommended++;
+			if (l.isFoundLog())
+				foundsSinceRecommendation++;
+		}
+		recommendationRating = getScore(numRecommended, foundsSinceRecommendation);
+	}
+
+	public static int getScore(int numrecommends, int numfoundlogs) {
+		return Math.round((((float) numrecommends * (float) numrecommends + 1f) / (numfoundlogs / 10f + 1f)) * 100f);
+	}
+
+	/**
+	 * Returns a simple concatenation of all Log texts of the list. Intended for text search in Logs.
+	 * 
 	 * @return All log messages
 	 */
 	public String allMessages() {
-		 buffer.setLength(0);
-		 for (int i=0; i<logList.size(); i++) {
-			 buffer.append(((Log)logList.get(i)).getMessage());
-		 }
-		 return buffer.toString();
-	 }
+		buffer.setLength(0);
+		for (int i = 0; i < logList.size(); i++) {
+			buffer.append(((Log) logList.get(i)).getMessage());
+		}
+		return buffer.toString();
+	}
 
 	/**
 	 * trim down number of log to maximum number user wants to keep in database
+	 * 
 	 * @return number of removed logs
 	 */
 	public int purgeLogs() {
@@ -191,12 +199,12 @@
 		boolean keepOwn = Global.getPref().alwaysKeepOwnLogs;
 		int purgedLogs = 0;
 		for (int i = logList.size(); i > maxKeep; i--) {
-			if (!(keepOwn && getLog(i-1).isOwnLog())) {
-				this.remove(i-1);
+			if (!(keepOwn && getLog(i - 1).isOwnLog())) {
+				this.remove(i - 1);
 				purgedLogs++;
 			}
 		}
 		return purgedLogs;
 	}
-	
+
 }

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-10 21:54:53 UTC (rev 2997)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-11 12:37:28 UTC (rev 2998)
@@ -1676,6 +1676,10 @@
 		try {
 			page_number++;
 			url = "http://www.geocaching.com/map/beta/map.info?" + "x=" + strLon + "&y=" + strLat + "&z=" + scale + "&k=" + userToken + "&st=" + sessionToken + "&ep=1";
+			if (doNotgetFound) {
+				url = url + "&hf=1"; // do not get finds
+			}
+			url = url + "&hh=1"; // do not get own
 			UrlFetcher.setRequestorProperty("Content-Type", "application/json; charset=UTF-8");
 			ret = UrlFetcher.fetch(url);
 



From araber95 at mail.berlios.de  Wed May 11 05:56:46 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Wed, 11 May 2011 05:56:46 PM +0200
Subject: [Cachewolf-svn] r2999 - trunk/res_noewe
Message-ID: <20110511155646.CE40C48122A@sheep.berlios.de>

Author: araber95
Date: 2011-05-11 17:56:46 +0200 (Wed, 11 May 2011)
New Revision: 2999

Modified:
   trunk/res_noewe/spider.def
Log:
spider.def adaption to last gc - change :
1. logs <5  (update of last change)
2. attributes

Modified: trunk/res_noewe/spider.def
===================================================================
--- trunk/res_noewe/spider.def	2011-05-11 12:37:28 UTC (rev 2998)
+++ trunk/res_noewe/spider.def	2011-05-11 15:56:46 UTC (rev 2999)
@@ -126,7 +126,7 @@
 #Section2a: Logs
 #--------------------------------------
 # blockRex extrahiert zun?chst aus der gesamten Seite den Logbereich
-blockRex           = <table class="LogsTable">((?s).*?)</table>\\s+<p>\\s+</p>
+blockRex           = <table class="LogsTable">((?s).*?)</table>\\s+<p>
 # singleLogEx extrahiert in einer Schleife alle Logs aus dem Logbereich
 singleLogExStart   = ><strong><img src=
 singleLogExEnd     = <small><a\ href="
@@ -208,7 +208,7 @@
 #--------------------------------------
 #Section2e: Attributes
 #--------------------------------------
-attBlockExStart = <div\ class="CacheDetailNavigationWidget\ Spacing">
+attBlockExStart = <div\ class="CacheDetailNavigationWidget
 attBlockExEnd  = What\ are\ Attributes?</a></small></p>
 attExStart = /images/attributes/
 attExEnd = "\ alt="



From araber95 at mail.berlios.de  Thu May 12 01:04:45 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Thu, 12 May 2011 01:04:45 AM +0200
Subject: [Cachewolf-svn] r3000 - in trunk: res_noewe/languages src/CacheWolf
	src/CacheWolf/imp
Message-ID: <20110511230445.BDEBF481396@sheep.berlios.de>

Author: araber95
Date: 2011-05-12 01:04:45 +0200 (Thu, 12 May 2011)
New Revision: 3000

Added:
   trunk/src/CacheWolf/imp/OCLinkImporter.java
Modified:
   trunk/res_noewe/languages/DE.cfg
   trunk/res_noewe/languages/EN.cfg
   trunk/res_noewe/languages/FR.cfg
   trunk/res_noewe/languages/NL.cfg
   trunk/res_noewe/languages/PL.cfg
   trunk/res_noewe/languages/SV.cfg
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/MyComparer.java
   trunk/src/CacheWolf/UrlFetcher.java
   trunk/src/CacheWolf/imp/OCGPXfetch.java
   trunk/src/CacheWolf/imp/SpiderGC.java
   trunk/src/CacheWolf/myTableModel.java
Log:
new function : getting GCs corresponding OC CacheID (if exists) and OCs find status

Modified: trunk/res_noewe/languages/DE.cfg
===================================================================
--- trunk/res_noewe/languages/DE.cfg	2011-05-11 15:56:46 UTC (rev 2999)
+++ trunk/res_noewe/languages/DE.cfg	2011-05-11 23:04:45 UTC (rev 3000)
@@ -455,6 +455,7 @@
 1206=Rechner
 1207=?nderungen im Profil Speichern?
 1208=Bewertungen von gcvote
+1209=Link zu OC - Cache
 1300=Letzte Einstellung
 1301=Profil ausw?hlen:
 1400=Zone

Modified: trunk/res_noewe/languages/EN.cfg
===================================================================
--- trunk/res_noewe/languages/EN.cfg	2011-05-11 15:56:46 UTC (rev 2999)
+++ trunk/res_noewe/languages/EN.cfg	2011-05-11 23:04:45 UTC (rev 3000)
@@ -455,6 +455,7 @@
 1206=Calc
 1207=Your profile has unsaved changes. Do you want to save?
 1208=ratings from GCVote
+1209=link to OC - Cache
 1300=Last Setting
 1301=Select Profile:
 1400=Zone

Modified: trunk/res_noewe/languages/FR.cfg
===================================================================
--- trunk/res_noewe/languages/FR.cfg	2011-05-11 15:56:46 UTC (rev 2999)
+++ trunk/res_noewe/languages/FR.cfg	2011-05-11 23:04:45 UTC (rev 3000)
@@ -455,6 +455,7 @@
 1206=Ordinateur
 1207=Sauvegarder les changements dans le profil?
 1208=ratings from GCVote
+1209 = lien vers OC - Cache
 1300=Dernier param?tage
 1301=Choisir profil:
 1400=Zone

Modified: trunk/res_noewe/languages/NL.cfg
===================================================================
--- trunk/res_noewe/languages/NL.cfg	2011-05-11 15:56:46 UTC (rev 2999)
+++ trunk/res_noewe/languages/NL.cfg	2011-05-11 23:04:45 UTC (rev 3000)
@@ -455,6 +455,7 @@
 1206=Calculator
 1207=Jouw profiel is veranderd, wil je het profiel opslaan?
 1208=ratings from GCVote
+1209 = link naar OC - Cache
 1300=Laatste instellingen
 1301=Selecteer profiel
 1400=Zone

Modified: trunk/res_noewe/languages/PL.cfg
===================================================================
--- trunk/res_noewe/languages/PL.cfg	2011-05-11 15:56:46 UTC (rev 2999)
+++ trunk/res_noewe/languages/PL.cfg	2011-05-11 23:04:45 UTC (rev 3000)
@@ -455,6 +455,7 @@
 1206=Calc
 1207=Twoj Profil ma niezapisane zmiany. Chcesz zapisac?
 1208=ratings from GCVote
+1209 = link do OC - Cache
 1300=Ostatnie ustawienia
 1301=Wybierz Profil:
 1400=Strefa

Modified: trunk/res_noewe/languages/SV.cfg
===================================================================
--- trunk/res_noewe/languages/SV.cfg	2011-05-11 15:56:46 UTC (rev 2999)
+++ trunk/res_noewe/languages/SV.cfg	2011-05-11 23:04:45 UTC (rev 3000)
@@ -455,6 +455,7 @@
 1206=Calc
 1207=Din profil har sparats. Vill du spara?
 1208=ratings from GCVote
+1209 = l?nk till OC - Cache
 1300=senaste inst?llningen
 1301=V?lj profil:
 1400=Zone

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2011-05-11 15:56:46 UTC (rev 2999)
+++ trunk/src/CacheWolf/CacheHolder.java	2011-05-11 23:04:45 UTC (rev 3000)
@@ -514,7 +514,8 @@
 		this.setIncomplete(ch.is_incomplete());
 		this.addiWpts = ch.addiWpts;
 		this.mainCache = ch.mainCache;
-		this.setOcCacheID(ch.getOcCacheID());
+		if (ch.getOcCacheID().length() > 0)
+			this.setOcCacheID(ch.getOcCacheID());
 		this.setNoFindLogs(ch.getNoFindLogs());
 		this.setHas_bugs(ch.has_bugs());
 		this.setHTML(ch.is_HTML());
@@ -1872,7 +1873,7 @@
 		if (!isCacheWpt())
 			return "";
 		if (isOC()) {
-			return Convert.formatInt(numRecommended);
+			return Convert.formatInt(recommendationScore) + " (" + Convert.formatInt(numRecommended) + ")";
 		} else {
 			int gcVote = numRecommended;
 			if (gcVote < 100) {

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2011-05-11 15:56:46 UTC (rev 2999)
+++ trunk/src/CacheWolf/MainMenu.java	2011-05-11 23:04:45 UTC (rev 3000)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.exp.ASCExporter;
@@ -42,6 +42,7 @@
 import CacheWolf.imp.GPXImporter;
 import CacheWolf.imp.LOCXMLImporter;
 import CacheWolf.imp.OCGPXfetch;
+import CacheWolf.imp.OCLinkImporter;
 import CacheWolf.imp.OCXMLImporter;
 import CacheWolf.imp.OCXMLImporterScreen;
 import CacheWolf.imp.SpiderGC;
@@ -71,215 +72,141 @@
 import ewe.util.Vector;
 
 /**
- *	This class creates the menu for cachewolf. It is also responsible
- *	for reacting to user inputs in the menu.<br>
- *	This class id=100
- *	@see MainForm
- *	@see MainTab
- *   Last change:
- *     20061123 salzkammergut Tidied up, added MyLocale, added additional internationalisation, combine save/filter for small screens, garminConn
+ * This class creates the menu for cachewolf. It is also responsible for reacting to user inputs in the menu.<br>
+ * This class id=100
+ * 
+ * @see MainForm
+ * @see MainTab Last change: 20061123 salzkammergut Tidied up, added MyLocale, added additional internationalisation, combine save/filter for small screens, garminConn
  */
 public class MainMenu extends MenuBar {
-	private MenuItem preferences, mnuContext,loadcaches,loadOC, loadOCFinds, /* savenexit, */ savenoxit,exit,search,searchAll,searchClr;
+	private MenuItem preferences, mnuContext, loadcaches, loadOC, loadOCFinds, /* savenexit, */savenoxit, exit, search, searchAll, searchClr;
 	private MenuItem downloadmap, kalibmap, importmap, selectMapPath;
-	private MenuItem spider, spiderRoute, spiderQuick, spiderAllFinds, loadGCVotes, update, chkVersion;
+	private MenuItem spider, spiderRoute, spiderQuick, spiderAllFinds, loadGCVotes, fetchOCLink, update, chkVersion;
 	private MenuItem about, wolflang, sysinfo, legend;
 	private MenuItem exportGpxNg, exporthtml, exporttop50, exportASC, exportTomTom, exportMSARCSV, exportSpoilerPOI;
 	private MenuItem exportOZI, exportKML, exportTPL, exportExplorist;
 	private MenuItem filtCreate, filtClear, filtInvert, filtSelected, filtNonSelected, filtBlack, filtApply;
-	private MenuItem exportLOC, exportGPS, mnuSeparator=new MenuItem("-");
-	private MenuItem orgNewWP, orgCopy, orgMove, orgDelete,orgRebuild,orgCheckNotesAndSolver;
+	private MenuItem exportLOC, exportGPS, mnuSeparator = new MenuItem("-");
+	private MenuItem orgNewWP, orgCopy, orgMove, orgDelete, orgRebuild, orgCheckNotesAndSolver;
 	public MenuItem cacheTour, orgTravelbugs, mnuForceLogin;
 	private MenuItem mnuNewProfile, mnuOpenProfile, mnuDeleteProfile, mnuRenameProfile, mnuEditCenter;
 	private Form father;
 	private TablePanel tbp;
-	private FilterScreen scnFilter=new FilterScreen();
+	private FilterScreen scnFilter = new FilterScreen();
 	private static boolean searchInDescriptionAndNotes = false;
 	private static boolean searchInLogs = false;
+	GCVoteImporter sGCV = null;
+	OCLinkImporter sOCL = null;
 
-	public MainMenu(Form f){
+	public MainMenu(Form f) {
 
 		Global.getPref().setgpsbabel();
 
 		father = f;
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// subMenu for profiles, part of "Application" menu below
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] mnuProfile = {
-			mnuNewProfile = new MenuItem(MyLocale.getMsg(1107,"New")),
-			mnuOpenProfile = new MenuItem(MyLocale.getMsg(1109,"Open")),
-			mnuDeleteProfile = new MenuItem(MyLocale.getMsg(1125,"Delete")),
-			mnuRenameProfile = new MenuItem(MyLocale.getMsg(1126,"Rename")),
-		};
-		Menu profileMenu = new Menu(mnuProfile,MyLocale.getMsg(121,"Profiles"));
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] mnuProfile = { mnuNewProfile = new MenuItem(MyLocale.getMsg(1107, "New")), mnuOpenProfile = new MenuItem(MyLocale.getMsg(1109, "Open")), mnuDeleteProfile = new MenuItem(MyLocale.getMsg(1125, "Delete")),
+				mnuRenameProfile = new MenuItem(MyLocale.getMsg(1126, "Rename")), };
+		Menu profileMenu = new Menu(mnuProfile, MyLocale.getMsg(121, "Profiles"));
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// subMenu for import, part of "Application" menu below
-		///////////////////////////////////////////////////////////////////////
-		if (Global.getPref().spiderRoute) 
-			spiderRoute = new MenuItem(MyLocale.getMsg(137,"Download along a Route from geocaching.com"));
-		else spiderRoute = mnuSeparator;
-		MenuItem[] mnuImport = {				
-				loadcaches     = new MenuItem(MyLocale.getMsg(129,"Import GPX")),
-				mnuSeparator,
-				loadOC         = new MenuItem(MyLocale.getMsg(130,"Download from opencaching")),
-				loadOCFinds    = new MenuItem(MyLocale.getMsg(163,"Finds from opencaching")),
-				mnuSeparator,
-				spider         = new MenuItem(MyLocale.getMsg(131,"Download from geocaching.com")),
-				spiderRoute,
-				spiderAllFinds = new MenuItem(MyLocale.getMsg(217,"Spider all finds from geocaching.com")),
-				spiderQuick    = new MenuItem(MyLocale.getMsg(138,"from GC quick")),
-				update         = new MenuItem(MyLocale.getMsg(1014,"Update cache data")),
-				mnuSeparator,
-				loadGCVotes    = new MenuItem(MyLocale.getMsg(1208,"Import ratings from GCVote")),
-				mnuSeparator,
-				mnuForceLogin  = new MenuItem(MyLocale.getMsg(216,"Always login to GC")),
-		};
-		Menu importMenu = new Menu(mnuImport, MyLocale.getMsg(175,"Import"));
-		if (Global.getPref().forceLogin) mnuForceLogin.modifiers^=MenuItem.Checked;
+		// /////////////////////////////////////////////////////////////////////
+		if (Global.getPref().spiderRoute)
+			spiderRoute = new MenuItem(MyLocale.getMsg(137, "Download along a Route from geocaching.com"));
+		else
+			spiderRoute = mnuSeparator;
+		MenuItem[] mnuImport = { loadcaches = new MenuItem(MyLocale.getMsg(129, "Import GPX")), mnuSeparator, loadOC = new MenuItem(MyLocale.getMsg(130, "Download from opencaching")),
+				loadOCFinds = new MenuItem(MyLocale.getMsg(163, "Finds from opencaching")), mnuSeparator, spider = new MenuItem(MyLocale.getMsg(131, "Download from geocaching.com")), spiderRoute,
+				spiderAllFinds = new MenuItem(MyLocale.getMsg(217, "Spider all finds from geocaching.com")), spiderQuick = new MenuItem(MyLocale.getMsg(138, "from GC quick")), update = new MenuItem(MyLocale.getMsg(1014, "Update cache data")),
+				mnuSeparator, loadGCVotes = new MenuItem(MyLocale.getMsg(1208, "Import ratings from GCVote")), fetchOCLink = new MenuItem(MyLocale.getMsg(1209, "Fetch link to OC - Cache")), mnuSeparator,
+				mnuForceLogin = new MenuItem(MyLocale.getMsg(216, "Always login to GC")), };
+		Menu importMenu = new Menu(mnuImport, MyLocale.getMsg(175, "Import"));
+		if (Global.getPref().forceLogin)
+			mnuForceLogin.modifiers ^= MenuItem.Checked;
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// subMenu for export, part of "Application" menu below
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] exitems = {
-				exporthtml = new MenuItem(MyLocale.getMsg(100,"to HTML")),
-				exportGpxNg = new MenuItem(MyLocale.getMsg(101,"to GPX Test")),
-				exporttop50 = new MenuItem(MyLocale.getMsg(102,"to TOP50 ASCII")),
-				exportASC = new MenuItem(MyLocale.getMsg(104,"to CSV")),
-				exportTomTom = new MenuItem(MyLocale.getMsg(105,"to TomTom")),
-				exportMSARCSV = new MenuItem(MyLocale.getMsg(106,"to MS AutoRoute CSV")),
-				exportLOC = new MenuItem(MyLocale.getMsg(215,"to LOC")),
-				exportGPS = new MenuItem(MyLocale.getMsg(122,"to GPS")),
-				exportOZI = new MenuItem(MyLocale.getMsg(124,"to OZI")),
-				exportKML = new MenuItem(MyLocale.getMsg(125,"to Google Earth")),
-				exportExplorist = new MenuItem(MyLocale.getMsg(132,"to Explorist")),
-				exportTPL = new MenuItem(MyLocale.getMsg(128,"via Template")),
-				exportSpoilerPOI = new MenuItem(MyLocale.getMsg(135,"to SpoilerPOI")),
-		};
-		if ( Global.getPref().gpsbabel == null ) {
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] exitems = { exporthtml = new MenuItem(MyLocale.getMsg(100, "to HTML")), exportGpxNg = new MenuItem(MyLocale.getMsg(101, "to GPX Test")), exporttop50 = new MenuItem(MyLocale.getMsg(102, "to TOP50 ASCII")),
+				exportASC = new MenuItem(MyLocale.getMsg(104, "to CSV")), exportTomTom = new MenuItem(MyLocale.getMsg(105, "to TomTom")), exportMSARCSV = new MenuItem(MyLocale.getMsg(106, "to MS AutoRoute CSV")),
+				exportLOC = new MenuItem(MyLocale.getMsg(215, "to LOC")), exportGPS = new MenuItem(MyLocale.getMsg(122, "to GPS")), exportOZI = new MenuItem(MyLocale.getMsg(124, "to OZI")),
+				exportKML = new MenuItem(MyLocale.getMsg(125, "to Google Earth")), exportExplorist = new MenuItem(MyLocale.getMsg(132, "to Explorist")), exportTPL = new MenuItem(MyLocale.getMsg(128, "via Template")),
+				exportSpoilerPOI = new MenuItem(MyLocale.getMsg(135, "to SpoilerPOI")), };
+		if (Global.getPref().gpsbabel == null) {
 			exportGPS.modifiers = MenuItem.Disabled;
-			exportGPS.setText(MyLocale.getMsg(136,"to GPS : gpsbabel missing."));
+			exportGPS.setText(MyLocale.getMsg(136, "to GPS : gpsbabel missing."));
 		}
 
-		Menu exportMenu = new Menu(exitems, MyLocale.getMsg(107,"Export"));
+		Menu exportMenu = new Menu(exitems, MyLocale.getMsg(107, "Export"));
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// subMenu for maps, part of "Application" menu below
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] mapMenuItems = {
-				downloadmap = new MenuItem(MyLocale.getMsg(162,"Download calibrated")),
-				importmap = new MenuItem(MyLocale.getMsg(150,"Import")),
-				kalibmap = new MenuItem(MyLocale.getMsg(151,"Calibrate")),
-				selectMapPath = new MenuItem(MyLocale.getMsg(4236, "Change map directory$c")),
-		};
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] mapMenuItems = { downloadmap = new MenuItem(MyLocale.getMsg(162, "Download calibrated")), importmap = new MenuItem(MyLocale.getMsg(150, "Import")), kalibmap = new MenuItem(MyLocale.getMsg(151, "Calibrate")),
+				selectMapPath = new MenuItem(MyLocale.getMsg(4236, "Change map directory$c")), };
 		Menu mapsMenu = new Menu(mapMenuItems, null);
 
 		// Now we start with the horizontal menu bar "Application", "Search", "Filter", "Organise", "About"
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// Create the "Application" pulldown menu
-		///////////////////////////////////////////////////////////////////////
-		MenuItem [] appMenuItems={
-				new MenuItem(MyLocale.getMsg(121,"Profile"), 0, profileMenu),
-				preferences = new MenuItem(MyLocale.getMsg(108,"Preferences")),
-				mnuEditCenter = new MenuItem(MyLocale.getMsg(1110,"Centre")),
-				mnuContext = new MenuItem(MyLocale.getMsg(134,"Current Cache")),
-				mnuSeparator,
-				new MenuItem(MyLocale.getMsg(175,"Import"),0,importMenu),
-				new MenuItem(MyLocale.getMsg(107,"Export"),0,exportMenu),
-				new MenuItem(MyLocale.getMsg(149,"Maps"),0,mapsMenu),
-				mnuSeparator,
-				savenoxit = new MenuItem(MyLocale.getMsg(127,"Save")),
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] appMenuItems = { new MenuItem(MyLocale.getMsg(121, "Profile"), 0, profileMenu), preferences = new MenuItem(MyLocale.getMsg(108, "Preferences")), mnuEditCenter = new MenuItem(MyLocale.getMsg(1110, "Centre")),
+				mnuContext = new MenuItem(MyLocale.getMsg(134, "Current Cache")), mnuSeparator, new MenuItem(MyLocale.getMsg(175, "Import"), 0, importMenu), new MenuItem(MyLocale.getMsg(107, "Export"), 0, exportMenu),
+				new MenuItem(MyLocale.getMsg(149, "Maps"), 0, mapsMenu), mnuSeparator, savenoxit = new MenuItem(MyLocale.getMsg(127, "Save")),
 				// savenexit = new MenuItem(MyLocale.getMsg(110,"Save & Exit")),
-				exit = new MenuItem(MyLocale.getMsg(111,"Exit")),
-		};
-		this.addMenu(new PullDownMenu(MyLocale.getMsg(120,"Application"),new Menu(appMenuItems,null)));
+				exit = new MenuItem(MyLocale.getMsg(111, "Exit")), };
+		this.addMenu(new PullDownMenu(MyLocale.getMsg(120, "Application"), new Menu(appMenuItems, null)));
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// Create the "Search" pulldown menu
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] searchMenuItems={
-				search = new MenuItem(MyLocale.getMsg(112,"Search$"+(char)6)),// char 6 = ctrl +f
-				searchAll = new MenuItem(MyLocale.getMsg(133,"Search All")),
-				searchClr = new MenuItem(MyLocale.getMsg(113,"Clear search")),
-		};
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] searchMenuItems = { search = new MenuItem(MyLocale.getMsg(112, "Search$" + (char) 6)),// char 6 = ctrl +f
+				searchAll = new MenuItem(MyLocale.getMsg(133, "Search All")), searchClr = new MenuItem(MyLocale.getMsg(113, "Clear search")), };
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// Create the "Filter" pulldown menu
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] filterMenuItems={
-				filtApply  = new MenuItem(MyLocale.getMsg(709,"Apply")),
-				filtCreate  = new MenuItem(MyLocale.getMsg(114,"Create")),
-				filtInvert  = new MenuItem(MyLocale.getMsg(115,"Invert")),
-				filtClear   = new MenuItem(MyLocale.getMsg(116,"Clear")),
-				mnuSeparator,
-				filtSelected = new MenuItem(MyLocale.getMsg(160,"Filter selected")),
-				filtNonSelected = new MenuItem(MyLocale.getMsg(1011,"Filter out non selected")),
-				mnuSeparator,
-				filtBlack   = new MenuItem(MyLocale.getMsg(161,"Show Blacklist")),
-		};
-        filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] filterMenuItems = { filtApply = new MenuItem(MyLocale.getMsg(709, "Apply")), filtCreate = new MenuItem(MyLocale.getMsg(114, "Create")), filtInvert = new MenuItem(MyLocale.getMsg(115, "Invert")),
+				filtClear = new MenuItem(MyLocale.getMsg(116, "Clear")), mnuSeparator, filtSelected = new MenuItem(MyLocale.getMsg(160, "Filter selected")), filtNonSelected = new MenuItem(MyLocale.getMsg(1011, "Filter out non selected")), mnuSeparator,
+				filtBlack = new MenuItem(MyLocale.getMsg(161, "Show Blacklist")), };
+		filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers & ~MenuItem.Checked;
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// Create a combined "Filter and Search" pulldown menu for devices with small screens
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] filterAndSearchMenuItems={
-				filtApply,
-				filtCreate,
-				filtInvert,
-				filtClear,
-				mnuSeparator,
-				filtSelected,
-				filtNonSelected,
-				mnuSeparator,
-				filtBlack,
-				mnuSeparator,
-				search,
-				searchClr,
-		};
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] filterAndSearchMenuItems = { filtApply, filtCreate, filtInvert, filtClear, mnuSeparator, filtSelected, filtNonSelected, mnuSeparator, filtBlack, mnuSeparator, search, searchClr, };
 
 		// Depending on screen width display either filter and search menus or the combined menu
-		if (MyLocale.getScreenWidth()>300) {
-			this.addMenu(new PullDownMenu(MyLocale.getMsg(112,"Search"),new Menu(searchMenuItems,null)));
-			this.addMenu(new PullDownMenu(MyLocale.getMsg(159,"Filter"),new Menu(filterMenuItems,null)));
+		if (MyLocale.getScreenWidth() > 300) {
+			this.addMenu(new PullDownMenu(MyLocale.getMsg(112, "Search"), new Menu(searchMenuItems, null)));
+			this.addMenu(new PullDownMenu(MyLocale.getMsg(159, "Filter"), new Menu(filterMenuItems, null)));
 		} else {
-			this.addMenu(new PullDownMenu(MyLocale.getMsg(159,"Filter"),new Menu(filterAndSearchMenuItems,null)));
+			this.addMenu(new PullDownMenu(MyLocale.getMsg(159, "Filter"), new Menu(filterAndSearchMenuItems, null)));
 		}
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// Create the "Organise" pulldown menu
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] organiseMenuItems={				
-				orgNewWP = new MenuItem(MyLocale.getMsg(214,"New Waypoint")),
-				mnuSeparator,
-				orgCopy  = new MenuItem(MyLocale.getMsg(141,"Copy")),
-				orgMove  = new MenuItem(MyLocale.getMsg(142,"Move")),
-				orgDelete   = new MenuItem(MyLocale.getMsg(143,"Delete")),
-				orgRebuild   = new MenuItem(MyLocale.getMsg(208,"Rebuild Index")),
-				orgCheckNotesAndSolver = new MenuItem(MyLocale.getMsg(220,"Check Notes/Solver")),
-				mnuSeparator,
-				orgTravelbugs = new MenuItem(MyLocale.getMsg(139,"Manage travelbugs")),
-				cacheTour = new MenuItem(MyLocale.getMsg(198,"Cachetour")),
-		};
-		this.addMenu(new PullDownMenu(MyLocale.getMsg(140,"Organise"),new Menu(organiseMenuItems,null)));
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] organiseMenuItems = { orgNewWP = new MenuItem(MyLocale.getMsg(214, "New Waypoint")), mnuSeparator, orgCopy = new MenuItem(MyLocale.getMsg(141, "Copy")), orgMove = new MenuItem(MyLocale.getMsg(142, "Move")),
+				orgDelete = new MenuItem(MyLocale.getMsg(143, "Delete")), orgRebuild = new MenuItem(MyLocale.getMsg(208, "Rebuild Index")), orgCheckNotesAndSolver = new MenuItem(MyLocale.getMsg(220, "Check Notes/Solver")), mnuSeparator,
+				orgTravelbugs = new MenuItem(MyLocale.getMsg(139, "Manage travelbugs")), cacheTour = new MenuItem(MyLocale.getMsg(198, "Cachetour")), };
+		this.addMenu(new PullDownMenu(MyLocale.getMsg(140, "Organise"), new Menu(organiseMenuItems, null)));
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// Create the "About" pulldown menu
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] aboutMenuItems={
-				about = new MenuItem(MyLocale.getMsg(117,"About")),
-				legend = new MenuItem(MyLocale.getMsg(155,"Legend")),
-				wolflang = new MenuItem(MyLocale.getMsg(118,"WolfLanguage")),
-				sysinfo = new MenuItem(MyLocale.getMsg(157,"System")),
-				chkVersion = new MenuItem(MyLocale.getMsg(158,"Version Check")),
-		};
-		this.addMenu(new PullDownMenu(MyLocale.getMsg(117,"About"),new Menu(aboutMenuItems,null)));
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] aboutMenuItems = { about = new MenuItem(MyLocale.getMsg(117, "About")), legend = new MenuItem(MyLocale.getMsg(155, "Legend")), wolflang = new MenuItem(MyLocale.getMsg(118, "WolfLanguage")),
+				sysinfo = new MenuItem(MyLocale.getMsg(157, "System")), chkVersion = new MenuItem(MyLocale.getMsg(158, "Version Check")), };
+		this.addMenu(new PullDownMenu(MyLocale.getMsg(117, "About"), new Menu(aboutMenuItems, null)));
 	}
 
-	public void setTablePanel(TablePanel t){
+	public void setTablePanel(TablePanel t) {
 		tbp = t;
 		if (mnuContext.subMenu == null) {
-			if ((","+Global.getPref().listColMap+",").indexOf(",0,")>=0)
+			if (("," + Global.getPref().listColMap + ",").indexOf(",0,") >= 0)
 				mnuContext.subMenu = tbp.tc.getMenuFull();
 			else
 				mnuContext.subMenu = tbp.tc.getMenuSmall();
@@ -288,21 +215,21 @@
 
 	public void allowProfileChange(boolean profileChangeAllowed) {
 		if (profileChangeAllowed) {
-			mnuNewProfile.modifiers&=~MenuItem.Disabled;
-			mnuOpenProfile.modifiers&=~MenuItem.Disabled;
+			mnuNewProfile.modifiers &= ~MenuItem.Disabled;
+			mnuOpenProfile.modifiers &= ~MenuItem.Disabled;
 		} else {
-			mnuNewProfile.modifiers|=MenuItem.Disabled;
-			mnuOpenProfile.modifiers|=MenuItem.Disabled;
+			mnuNewProfile.modifiers |= MenuItem.Disabled;
+			mnuOpenProfile.modifiers |= MenuItem.Disabled;
 		}
 	}
 
 	public void setForceLogin() {
-		mnuForceLogin.modifiers=Global.getPref().forceLogin ? Global.mainTab.mnuMain.modifiers|MenuItem.Checked : Global.mainTab.mnuMain.modifiers&~MenuItem.Checked;
+		mnuForceLogin.modifiers = Global.getPref().forceLogin ? Global.mainTab.mnuMain.modifiers | MenuItem.Checked : Global.mainTab.mnuMain.modifiers & ~MenuItem.Checked;
 	}
 
 	public static void search() {
-		SearchBox inp = new SearchBox(MyLocale.getMsg(119,"Search for:"));
-		String srch = inp.input(null,"",searchInDescriptionAndNotes,searchInLogs,10);
+		SearchBox inp = new SearchBox(MyLocale.getMsg(119, "Search for:"));
+		String srch = inp.input(null, "", searchInDescriptionAndNotes, searchInLogs, 10);
 		MyLocale.setSIPOff();
 		if (srch != null) {
 			searchInDescriptionAndNotes = inp.useNoteDesc();
@@ -312,60 +239,61 @@
 			Global.mainTab.tbP.refreshTable();
 		}
 	}
-	public void onEvent(Event ev){
-		Preferences pref=Global.getPref();
-		Profile profile=Global.getProfile();
-		CacheDB cacheDB=profile.cacheDB;
+
+	public void onEvent(Event ev) {
+		Preferences pref = Global.getPref();
+		Profile profile = Global.getProfile();
+		CacheDB cacheDB = profile.cacheDB;
 		Global.mainTab.updatePendingChanges();
-		if (ev instanceof MenuEvent){ //&& ev.type == MenuEvent.PRESSED
-			MenuEvent mev = (MenuEvent)ev;
-			///////////////////////////////////////////////////////////////////////
+		if (ev instanceof MenuEvent) { // && ev.type == MenuEvent.PRESSED
+			MenuEvent mev = (MenuEvent) ev;
+			// /////////////////////////////////////////////////////////////////////
 			// subMenu for profiles, part of "Application" menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == mnuNewProfile){
-				if (NewProfileWizard.startNewProfileWizard(getFrame()) ) {
-					tbp.myMod.numRows=0;
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == mnuNewProfile) {
+				if (NewProfileWizard.startNewProfileWizard(getFrame())) {
+					tbp.myMod.numRows = 0;
 					pref.setCurCentrePt(profile.centre);
-		            filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
+					filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers & ~MenuItem.Checked;
 					tbp.refreshTable();
 				}
 			}
-			if(mev.selectedItem == mnuOpenProfile){
+			if (mev.selectedItem == mnuOpenProfile) {
 				Global.mainTab.saveUnsavedChanges(true);
-				if (pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_FORCED_ON,false)) {
-					tbp.myMod.sortedBy=-1;
-					tbp.myMod.numRows=0;
+				if (pref.selectProfile(profile, Preferences.PROFILE_SELECTOR_FORCED_ON, false)) {
+					tbp.myMod.sortedBy = -1;
+					tbp.myMod.numRows = 0;
 					CacheHolder.removeAllDetails();
 					profile.cacheDB.clear();
-					InfoBox infB = new InfoBox("CacheWolf",MyLocale.getMsg(5000,"Loading Cache-List"));
+					InfoBox infB = new InfoBox("CacheWolf", MyLocale.getMsg(5000, "Loading Cache-List"));
 					infB.exec();
 					infB.waitUntilPainted(1000);
 					Vm.showWait(infB, true);
 					profile.readIndex(infB);
 					Vm.showWait(infB, false);
 					pref.setCurCentrePt(profile.centre);
-                    filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
-        			Global.mainForm.setTitle(profile.name + " - CW "+Version.getRelease());
+					filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers & ~MenuItem.Checked;
+					Global.mainForm.setTitle(profile.name + " - CW " + Version.getRelease());
 					infB.close(0);
 					tbp.resetModel();
 				}
 			}
-			if(mev.selectedItem == mnuDeleteProfile) {
-				pref.editProfile(2,227,226);
+			if (mev.selectedItem == mnuDeleteProfile) {
+				pref.editProfile(2, 227, 226);
 			}
-			if(mev.selectedItem == mnuRenameProfile) {
-				pref.editProfile(3,228,229);
+			if (mev.selectedItem == mnuRenameProfile) {
+				pref.editProfile(3, 228, 229);
 			}
-			if(mev.selectedItem == mnuEditCenter){
-				ProfileDataForm f=new ProfileDataForm(pref,profile);
+			if (mev.selectedItem == mnuEditCenter) {
+				ProfileDataForm f = new ProfileDataForm(pref, profile);
 				f.execute(getFrame(), Gui.CENTER_FRAME);
 				tbp.refreshTable();
 				f.close(0);
 			}
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// subMenu for import, part of "Application" menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == spider){
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == spider) {
 				SpiderGC spGC = new SpiderGC(pref, profile);
 				Global.mainTab.saveUnsavedChanges(false);
 				spGC.doIt();
@@ -373,7 +301,7 @@
 				profile.readIndex();
 				tbp.resetModel();
 			}
-			if(mev.selectedItem == spiderRoute){
+			if (mev.selectedItem == spiderRoute) {
 				SpiderGC spGC = new SpiderGC(pref, profile);
 				Global.mainTab.saveUnsavedChanges(false);
 				spGC.doItAlongARoute();
@@ -381,7 +309,7 @@
 				profile.readIndex();
 				tbp.resetModel();
 			}
-			if(mev.selectedItem == spiderQuick){
+			if (mev.selectedItem == spiderQuick) {
 				SpiderGC spGC = new SpiderGC(pref, profile);
 				Global.mainTab.saveUnsavedChanges(false);
 				spGC.doItQuickFillFromMapList();
@@ -389,7 +317,7 @@
 				profile.readIndex();
 				tbp.resetModel();
 			}
-			if(mev.selectedItem == spiderAllFinds){
+			if (mev.selectedItem == spiderAllFinds) {
 				SpiderGC spGC = new SpiderGC(pref, profile);
 				Global.mainTab.saveUnsavedChanges(false);
 				spGC.doIt(true);
@@ -397,253 +325,256 @@
 				profile.readIndex();
 				tbp.resetModel();
 			}
-			if(mev.selectedItem == loadGCVotes){
-                GCVoteImporter sGCV = new GCVoteImporter(pref, profile);
-                sGCV.doIt();
-                tbp.resetModel();
+			if (mev.selectedItem == loadGCVotes) {
+				if (sGCV == null)
+					sGCV = new GCVoteImporter(pref, profile);
+				sGCV.doIt();
+				tbp.resetModel();
 			}
-			if(mev.selectedItem == loadcaches){
+			if (mev.selectedItem == fetchOCLink) {
+				if (sOCL == null)
+					sOCL = new OCLinkImporter();
+				sOCL.doIt();
+				tbp.resetModel();
+			}
+			if (mev.selectedItem == loadcaches) {
 				String dir = pref.getImporterPath("LocGpxImporter");
-				FileChooser fc = new FileChooser(FileChooserBase.OPEN|FileChooserBase.MULTI_SELECT, dir);
+				FileChooser fc = new FileChooser(FileChooserBase.OPEN | FileChooserBase.MULTI_SELECT, dir);
 				fc.addMask("*.gpx,*.zip,*.loc,fieldnotes.txt,geocache_visits.txt,FieldNotes.log,newlogs.txt");
-				fc.setTitle(MyLocale.getMsg(909,"Select file(s)"));
-				if(fc.execute() != FormBase.IDCANCEL){
+				fc.setTitle(MyLocale.getMsg(909, "Select file(s)"));
+				if (fc.execute() != FormBase.IDCANCEL) {
 					dir = fc.getChosenDirectory().toString();
 					pref.setImporterPath("LocGpxImporter", dir);
 					String files[] = fc.getAllChosen();
 					int how = GPXImporter.DOIT_ASK;
-					for (int i = 0; i < files.length; i++){
+					for (int i = 0; i < files.length; i++) {
 						String file = dir + "/" + files[i];
-						if (file.endsWith("txt")||file.endsWith("log")){
-							FieldnotesImporter fn=new FieldnotesImporter(pref, profile, file);
+						if (file.endsWith("txt") || file.endsWith("log")) {
+							FieldnotesImporter fn = new FieldnotesImporter(pref, profile, file);
 							fn.doIt();
-						}
-						else if (file.endsWith("loc")){
+						} else if (file.endsWith("loc")) {
 							LOCXMLImporter loc = new LOCXMLImporter(pref, profile, file);
 							loc.doIt();
-						}
-						else { //gpx + zip
+						} else { // gpx + zip
 							GPXImporter gpx = new GPXImporter(pref, profile, file);
 							gpx.doIt(how);
 							how = gpx.getHow();
 						}
 					}
 				}
-                Global.getProfile().setShowBlacklisted(false);
-                filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
+				Global.getProfile().setShowBlacklisted(false);
+				filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers & ~MenuItem.Checked;
 				tbp.resetModel();
 			}
-			if(mev.selectedItem == loadOC){
-				OCXMLImporter oc = new OCXMLImporter(pref,profile);
+			if (mev.selectedItem == loadOC) {
+				OCXMLImporter oc = new OCXMLImporter(pref, profile);
 				oc.doIt();
-                Global.getProfile().setShowBlacklisted(false);
-                filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
+				Global.getProfile().setShowBlacklisted(false);
+				filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers & ~MenuItem.Checked;
 				tbp.resetModel();
 			}
-			if(mev.selectedItem == loadOCFinds){
+			if (mev.selectedItem == loadOCFinds) {
 				OCGPXfetch.doIt();
-                Global.getProfile().setShowBlacklisted(false);
-                filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
+				Global.getProfile().setShowBlacklisted(false);
+				filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers & ~MenuItem.Checked;
 				tbp.resetModel();
 			}
 			if (mev.selectedItem == update)
 				updateSelectedCaches(tbp);
-			if(mev.selectedItem == mnuForceLogin) {
-				mnuForceLogin.modifiers^=MenuItem.Checked;
-				Global.getPref().forceLogin=(mnuForceLogin.modifiers&MenuItem.Checked)!=0;
+			if (mev.selectedItem == mnuForceLogin) {
+				mnuForceLogin.modifiers ^= MenuItem.Checked;
+				Global.getPref().forceLogin = (mnuForceLogin.modifiers & MenuItem.Checked) != 0;
 				Global.getPref().savePreferences();
 			}
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// subMenu for export, part of "Application" menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == exporthtml){
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == exporthtml) {
 				HTMLExporter htm = new HTMLExporter(pref, profile);
 				htm.doIt();
 			}
-			if(mev.selectedItem == exportGpxNg){
+			if (mev.selectedItem == exportGpxNg) {
 				GpxExportNg gpx = new GpxExportNg();
 				gpx.doit();
 			}
-			if(mev.selectedItem == exporttop50){
+			if (mev.selectedItem == exporttop50) {
 				OVLExporter ovl = new OVLExporter(pref, profile);
 				ovl.doIt();
 			}
-			if(mev.selectedItem == exportASC){
-				ASCExporter asc = new ASCExporter(pref,profile);
+			if (mev.selectedItem == exportASC) {
+				ASCExporter asc = new ASCExporter(pref, profile);
 				asc.doIt();
 			}
-			if(mev.selectedItem == exportTomTom){
+			if (mev.selectedItem == exportTomTom) {
 				TomTomExporter tt = new TomTomExporter();
 				tt.doIt();
 			}
-			if(mev.selectedItem == exportMSARCSV){
-				MSARCSVExporter msar = new MSARCSVExporter(pref,profile);
+			if (mev.selectedItem == exportMSARCSV) {
+				MSARCSVExporter msar = new MSARCSVExporter(pref, profile);
 				msar.doIt();
 			}
-			if(mev.selectedItem == exportLOC){
+			if (mev.selectedItem == exportLOC) {
 				LocExporter loc = new LocExporter();
 				loc.doIt();
 			}
-			if(mev.selectedItem == exportGPS){
+			if (mev.selectedItem == exportGPS) {
 				String gpsBabelCommand;
 				Vm.showWait(true);
 				LocExporter loc = new LocExporter();
-				//String tmpFileName = FileBase.getProgramDirectory() + "/temp.loc";
-                //Must not contain special characters, because we don't quote below, because quoting causes problems on some platforms.
-				//Find another way, when CW can be started from outside the program directory.
+				// String tmpFileName = FileBase.getProgramDirectory() + "/temp.loc";
+				// Must not contain special characters, because we don't quote below, because quoting causes problems on some platforms.
+				// Find another way, when CW can be started from outside the program directory.
 				String tmpFileName = "temp.loc";
 				loc.setTmpFileName(tmpFileName);
 				loc.doIt(LocExporter.MODE_AUTO);
-				ProgressBarForm.display(MyLocale.getMsg(950,"Transfer"),MyLocale.getMsg(951,"Sending to GPS"), null);
-				gpsBabelCommand = pref.gpsbabel+" "+pref.garminGPSBabelOptions+" -i geo -f "+ tmpFileName +" -o garmin -F " + pref.garminConn +":";
-				pref.log("[MainMenu:onEvent] "+gpsBabelCommand);
+				ProgressBarForm.display(MyLocale.getMsg(950, "Transfer"), MyLocale.getMsg(951, "Sending to GPS"), null);
+				gpsBabelCommand = pref.gpsbabel + " " + pref.garminGPSBabelOptions + " -i geo -f " + tmpFileName + " -o garmin -F " + pref.garminConn + ":";
+				pref.log("[MainMenu:onEvent] " + gpsBabelCommand);
 				try {
 					// this will *only* work with ewe.jar at the moment
-					ewe.sys.Process p = Vm.exec( gpsBabelCommand );
+					ewe.sys.Process p = Vm.exec(gpsBabelCommand);
 					p.waitFor();
-				}catch(IOException ioex){
+				} catch (IOException ioex) {
 					Vm.showWait(false);
 					(new MessageBox("Error", "Garmin export unsuccessful", FormBase.OKB)).execute();
-					pref.log("Error exporting to Garmin",ioex,true);
-				};
+					pref.log("Error exporting to Garmin", ioex, true);
+				}
+				;
 				ProgressBarForm.clear();
 				Vm.showWait(false);
 			}
-			if(mev.selectedItem == exportOZI){
-				OziExporter ozi = new OziExporter( pref, profile);
+			if (mev.selectedItem == exportOZI) {
+				OziExporter ozi = new OziExporter(pref, profile);
 				ozi.doIt();
 			}
-			if(mev.selectedItem == exportKML){
-				KMLExporter kml = new KMLExporter( pref, profile);
+			if (mev.selectedItem == exportKML) {
+				KMLExporter kml = new KMLExporter(pref, profile);
 				kml.doIt();
 			}
-			if(mev.selectedItem == exportTPL){
-				FileChooser fc = new FileChooser(FileChooserBase.OPEN, FileBase.getProgramDirectory()+FileBase.separator+"templates");
+			if (mev.selectedItem == exportTPL) {
+				FileChooser fc = new FileChooser(FileChooserBase.OPEN, FileBase.getProgramDirectory() + FileBase.separator + "templates");
 				fc.addMask("*.tpl");
-				fc.setTitle(MyLocale.getMsg(910,"Select Template file"));
-				if(fc.execute() != FormBase.IDCANCEL){
-					TPLExporter tpl = new TPLExporter( pref, profile, fc.getChosenFile().toString());
+				fc.setTitle(MyLocale.getMsg(910, "Select Template file"));
+				if (fc.execute() != FormBase.IDCANCEL) {
+					TPLExporter tpl = new TPLExporter(pref, profile, fc.getChosenFile().toString());
 					tpl.doIt();
 				}
 			}
-			if(mev.selectedItem == exportExplorist) {
-				ExploristExporter mag = new ExploristExporter( pref, profile);
+			if (mev.selectedItem == exportExplorist) {
+				ExploristExporter mag = new ExploristExporter(pref, profile);
 				mag.doIt();
 			}
-			if(mev.selectedItem == exportSpoilerPOI) {
-				SpoilerPOIExporter spoilerpoi = new SpoilerPOIExporter( pref, profile);
+			if (mev.selectedItem == exportSpoilerPOI) {
+				SpoilerPOIExporter spoilerpoi = new SpoilerPOIExporter(pref, profile);
 				spoilerpoi.doIt();
 			}
 
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// subMenu for maps, part of "Application" menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == downloadmap){
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == downloadmap) {
 				MapLoaderGui mLG = new MapLoaderGui(cacheDB);
 				mLG.exec(); // .execute doesn't work because the tcp-socket uses another thread which cannot be startet if here .execute() is used!
 			}
-			if(mev.selectedItem == importmap){
+			if (mev.selectedItem == importmap) {
 
 				MapImporter map = new MapImporter(pref);
 				map.importMap();
 			}
-			if(mev.selectedItem == kalibmap){
+			if (mev.selectedItem == kalibmap) {
 				SelectMap sM = new SelectMap();
 				sM.execute();
-				if((sM.getSelectedMap()).length()>0){
+				if ((sM.getSelectedMap()).length() > 0) {
 					try {
-						MapImporter map = new MapImporter(pref, sM.getSelectedMap(),sM.worldfileexists);
+						MapImporter map = new MapImporter(pref, sM.getSelectedMap(), sM.worldfileexists);
 						map.execute(null, Gui.CENTER_FRAME);
 					} catch (java.lang.OutOfMemoryError e) {
-						MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, "Error"), MyLocale.getMsg(156,"Out of memory error, map to big"), FormBase.OKB);
+						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(312, "Error"), MyLocale.getMsg(156, "Out of memory error, map to big"), FormBase.OKB);
 						tmpMB.exec();
 					}
 				}
 			}
-			if (mev.selectedItem==selectMapPath) {
+			if (mev.selectedItem == selectMapPath) {
 				FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, Global.getPref().getCustomMapsPath());
 				fc.addMask("*.wfl");
-				fc.setTitle(MyLocale.getMsg(4200,"Select map directory:"));
-				if(fc.execute() != FormBase.IDCANCEL){
+				fc.setTitle(MyLocale.getMsg(4200, "Select map directory:"));
+				if (fc.execute() != FormBase.IDCANCEL) {
 					Global.getPref().saveCustomMapsPath(fc.getChosen().toString());
-					//mm.loadMaps(Global.getPref().getCustomMapsPath(), mm.posCircle.where.latDec);
-					//mm.forceMapLoad();
+					// mm.loadMaps(Global.getPref().getCustomMapsPath(), mm.posCircle.where.latDec);
+					// mm.forceMapLoad();
 				}
 
 			}
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// "Application" pulldown menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == preferences){
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == preferences) {
 				tbp.saveColWidth(pref);
 				PreferencesScreen pfs = new PreferencesScreen(pref);
 				pfs.execute(father.getFrame(), Gui.CENTER_FRAME);
 				pref.readPrefFile();
 			}
-			if(mev.selectedItem == savenoxit){
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+			if (mev.selectedItem == savenoxit) {
+				profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 				tbp.saveColWidth(pref);
 			}
-/*
-			if(mev.selectedItem == savenexit){
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
-				tbp.saveColWidth(pref);
-				ewe.sys.Vm.exit(0);
-			}
-*/
-			if(mev.selectedItem == exit){
+			/*
+			 * if(mev.selectedItem == savenexit){ profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR); tbp.saveColWidth(pref); ewe.sys.Vm.exit(0); }
+			 */
+			if (mev.selectedItem == exit) {
 				Global.mainTab.saveUnsavedChanges(true);
 				ewe.sys.Vm.exit(0);
 			}
 
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// "Search" pulldown menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == search){
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == search) {
 				search();
 			}
-			if(mev.selectedItem == searchAll){
+			if (mev.selectedItem == searchAll) {
 				SearchCache ssc = new SearchCache(cacheDB);
 				ssc.clearSearch();
 				tbp.refreshTable();
-                search();
+				search();
 			}
-			if(mev.selectedItem == searchClr){
+			if (mev.selectedItem == searchClr) {
 				SearchCache ssc = new SearchCache(cacheDB);
 				ssc.clearSearch();
 				tbp.refreshTable();
 			}
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// "Filter" pulldown menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == filtApply){
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == filtApply) {
 				Filter flt = new Filter();
 				flt.setFilter();
 				flt.doFilter();
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == filtCreate){
+			if (mev.selectedItem == filtCreate) {
 				scnFilter.setData(profile.getCurrentFilter());
 				scnFilter.setPreferredSize(450, 480);
-				if(Vm.isMobile()) scnFilter.setPreferredSize(MyLocale.getScreenWidth(), MyLocale.getScreenHeight()); //Fullscreen
+				if (Vm.isMobile())
+					scnFilter.setPreferredSize(MyLocale.getScreenWidth(), MyLocale.getScreenHeight()); // Fullscreen
 				scnFilter.execute(father.getFrame(), Gui.CENTER_FRAME);
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == filtInvert){
+			if (mev.selectedItem == filtInvert) {
 				Filter flt = new Filter();
 				flt.invertFilter();
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == filtClear){
+			if (mev.selectedItem == filtClear) {
 				Filter flt = new Filter();
 				flt.clearFilter();
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == filtSelected){ // incremental filter
+			if (mev.selectedItem == filtSelected) { // incremental filter
 				Global.getProfile().selectionChanged = true;
 				CacheHolder ch;
 				boolean filterChanged = false;
-				for(int i = cacheDB.size()-1; i>=0; i--){
+				for (int i = cacheDB.size() - 1; i >= 0; i--) {
 					ch = cacheDB.get(i);
 					// This is an incremental filter, i.e. it keeps the existing filter
 					// status and only adds the marked caches to the filtered set
@@ -652,16 +583,16 @@
 						filterChanged = true;
 					}
 				}
-				if ( filterChanged && Global.getProfile().getFilterActive() == Filter.FILTER_INACTIVE) {
+				if (filterChanged && Global.getProfile().getFilterActive() == Filter.FILTER_INACTIVE) {
 					Global.getProfile().setFilterActive(Filter.FILTER_MARKED_ONLY);
 				}
 				tbp.refreshTable();
 			}
-			if (mev.selectedItem == filtNonSelected){
+			if (mev.selectedItem == filtNonSelected) {
 				Global.getProfile().selectionChanged = true;
 				CacheHolder ch;
 				boolean filterChanged = false;
-				for(int i = cacheDB.size()-1; i >=0; i--){
+				for (int i = cacheDB.size() - 1; i >= 0; i--) {
 					ch = cacheDB.get(i);
 					// incremental filter. Keeps status of all marked caches and
 					// adds unmarked caches to filtered list
@@ -670,102 +601,104 @@
 						filterChanged = true;
 					}
 				}
-				if ( filterChanged && Global.getProfile().getFilterActive() == Filter.FILTER_INACTIVE) {
+				if (filterChanged && Global.getProfile().getFilterActive() == Filter.FILTER_INACTIVE) {
 					Global.getProfile().setFilterActive(Filter.FILTER_MARKED_ONLY);
 				}
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == filtBlack){
-				//filtBlack.modifiers=filtBlack.modifiers|MenuItem.Checked;
+			if (mev.selectedItem == filtBlack) {
+				// filtBlack.modifiers=filtBlack.modifiers|MenuItem.Checked;
 				Global.getProfile().setShowBlacklisted(!Global.getProfile().showBlacklisted());
-				filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&~MenuItem.Checked;
+				filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers & ~MenuItem.Checked;
 				SearchCache ssc = new SearchCache(cacheDB);
 				ssc.clearSearch();// Clear search & restore filter status
 				tbp.refreshTable();
 			}
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// "Organise" pulldown menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == orgNewWP){
-				if (Global.mainTab.tbP.getSelectedCache() >= 0) 
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == orgNewWP) {
+				if (Global.mainTab.tbP.getSelectedCache() >= 0)
 					Global.mainTab.lastselected = cacheDB.get(Global.mainTab.tbP.getSelectedCache()).getWayPoint();
-				else Global.mainTab.lastselected = "";
+				else
+					Global.mainTab.lastselected = "";
 				Global.mainTab.newWaypoint(new CacheHolder());
 			}
 
-			if(mev.selectedItem == orgCopy){
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+			if (mev.selectedItem == orgCopy) {
+				profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 				DataMover dm = new DataMover();
 				dm.copyCaches();
 				tbp.refreshTable();
 			}
 
-			if(mev.selectedItem == orgMove){
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+			if (mev.selectedItem == orgMove) {
+				profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 				DataMover dm = new DataMover();
 				dm.moveCaches();
 				tbp.refreshTable();
 			}
 
-			if(mev.selectedItem == orgDelete){
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+			if (mev.selectedItem == orgDelete) {
+				profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 				DataMover dm = new DataMover();
 				dm.deleteCaches();
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == orgRebuild){
-				Rebuild rb=new Rebuild();
+			if (mev.selectedItem == orgRebuild) {
+				Rebuild rb = new Rebuild();
 				rb.rebuild();
 				profile.updateBearingDistance();
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == orgCheckNotesAndSolver){
+			if (mev.selectedItem == orgCheckNotesAndSolver) {
 				// Checking every cache if notes or solver data exist
-				CWProgressBar cwp = new CWProgressBar(MyLocale.getMsg(219,"Searching..."), 0, cacheDB.size(), true);
+				CWProgressBar cwp = new CWProgressBar(MyLocale.getMsg(219, "Searching..."), 0, cacheDB.size(), true);
 				cwp.exec();
 				cwp.allowExit(true);
-				for(int i = 0;i < cacheDB.size();i++){
+				for (int i = 0; i < cacheDB.size(); i++) {
 					cwp.setPosition(i);
 					CacheHolder ch = cacheDB.get(i);
-					if (ch.mainCache==null) {
+					if (ch.mainCache == null) {
 						ch.setHasNote(!ch.getCacheDetails(false).getCacheNotes().equals(""));
 						ch.setHasSolver(!ch.getCacheDetails(false).getSolver().equals(""));
 					}
-					if (cwp.isClosed()) break;
+					if (cwp.isClosed())
+						break;
 				} // for
 				cwp.exit(0);
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == orgTravelbugs){
-				Form tbs=TravelbugJourneyScreenFactory.createTravelbugJourneyScreen();
-				tbs.setPreferredSize(800,600);
+			if (mev.selectedItem == orgTravelbugs) {
+				Form tbs = TravelbugJourneyScreenFactory.createTravelbugJourneyScreen();
+				tbs.setPreferredSize(800, 600);
 				tbs.execute();
 				tbs.close(0);
 			}
-			if(mev.selectedItem == cacheTour){
-				cacheTour.modifiers^=MenuItem.Checked;
+			if (mev.selectedItem == cacheTour) {
+				cacheTour.modifiers ^= MenuItem.Checked;
 				Global.mainForm.toggleCacheListVisible();
 			}
 
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// "About" pulldown menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == about){
-				InfoScreen is = new InfoScreen(MyLocale.getLocalizedFile("info.html"), MyLocale.getMsg(117,"About"),true, pref);
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == about) {
+				InfoScreen is = new InfoScreen(MyLocale.getLocalizedFile("info.html"), MyLocale.getMsg(117, "About"), true, pref);
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
-			if(mev.selectedItem == legend){
-				InfoScreen is = new InfoScreen(MyLocale.getLocalizedFile("legende.html"), MyLocale.getMsg(155,"Legend"),true, pref);
+			if (mev.selectedItem == legend) {
+				InfoScreen is = new InfoScreen(MyLocale.getLocalizedFile("legende.html"), MyLocale.getMsg(155, "Legend"), true, pref);
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
-			if(mev.selectedItem == wolflang){
-				InfoScreen is = new InfoScreen(MyLocale.getLocalizedFile("wolflang.html"), MyLocale.getMsg(118,"WolfLanguage"), true, pref);
+			if (mev.selectedItem == wolflang) {
+				InfoScreen is = new InfoScreen(MyLocale.getLocalizedFile("wolflang.html"), MyLocale.getMsg(118, "WolfLanguage"), true, pref);
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
-			if(mev.selectedItem == sysinfo){
-				StringBuffer sb=new StringBuffer(400);
+			if (mev.selectedItem == sysinfo) {
+				StringBuffer sb = new StringBuffer(400);
 				Font f = mApp.guiFont;
-				sb.append(MyLocale.getMsg(121,"Profile"));
+				sb.append(MyLocale.getMsg(121, "Profile"));
 				sb.append(": ");
 				sb.append(profile.dataDir);
 				sb.append("<br>");
@@ -792,21 +725,22 @@
 				sb.append(MyLocale.getMsg(265, "Screen:"));
 				sb.append(' ');
 				sb.append(MyLocale.getScreenWidth());
-				sb.append(" x ");	 sb.append(MyLocale.getScreenHeight());
+				sb.append(" x ");
+				sb.append(MyLocale.getScreenHeight());
 				sb.append("<br>");
 				sb.append(MyLocale.getMsg(266, "Font size:"));
 				sb.append(' ');
 				sb.append(f.getSize());
 				sb.append("<br>");
 				sb.append(MyLocale.getMsg(267, "Entries in DB:"));
-				sb.append (' ');
+				sb.append(' ');
 				sb.append(cacheDB.size());
 				sb.append("<br>");
-				sb.append(MyLocale.getMsg (268, "File separator is:"));
-				sb.append (" \"");
-				sb.append(Vm.getProperty("file.separator","def"));
+				sb.append(MyLocale.getMsg(268, "File separator is:"));
+				sb.append(" \"");
+				sb.append(Vm.getProperty("file.separator", "def"));
 				sb.append("\"<br>");
-				sb.append(MyLocale.getMsg (269, "Programme directory is:"));
+				sb.append(MyLocale.getMsg(269, "Programme directory is:"));
 				sb.append(' ');
 				sb.append(FileBase.getProgramDirectory());
 				sb.append("<br>");
@@ -822,11 +756,11 @@
 				sb.append(' ');
 				sb.append(Version.getReleaseDetailed());
 				sb.append("<br>");
-				InfoScreen is = new InfoScreen(sb.toString(), "System", false,pref);
-				pref.log(STRreplace.replace(sb.toString(),"<br>",Preferences.NEWLINE),null);
+				InfoScreen is = new InfoScreen(sb.toString(), "System", false, pref);
+				pref.log(STRreplace.replace(sb.toString(), "<br>", Preferences.NEWLINE), null);
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
-			if(mev.selectedItem == chkVersion){
+			if (mev.selectedItem == chkVersion) {
 				(new MessageBox(MyLocale.getMsg(178, "Version Checking"), Version.getUpdateMessage(), FormBase.OKB)).execute();
 			}
 
@@ -842,13 +776,15 @@
 	}
 
 	public static void updateSelectedCaches(TablePanel tablePanel) {
-		Preferences pref=Global.getPref();
-		Profile profile=Global.getProfile();
-		CacheDB cacheDB=profile.cacheDB;
+		Preferences pref = Global.getPref();
+		Profile profile = Global.getProfile();
+		CacheDB cacheDB = profile.cacheDB;
 		CacheHolder ch;
 
-		OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(1014,"updateSelectedCaches"), OCXMLImporterScreen.IMAGES| OCXMLImporterScreen.TRAVELBUGS| OCXMLImporterScreen.MAXLOGS| OCXMLImporterScreen.ALL);
-		if (options.execute() == FormBase.IDCANCEL) {	return; }
+		OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(1014, "updateSelectedCaches"), OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.TRAVELBUGS | OCXMLImporterScreen.MAXLOGS | OCXMLImporterScreen.ALL);
+		if (options.execute() == FormBase.IDCANCEL) {
+			return;
+		}
 
 		SpiderGC spider = new SpiderGC(pref, profile);
 		OCXMLImporter ocSync = new OCXMLImporter(pref, profile);
@@ -861,27 +797,23 @@
 		boolean loadAllLogs = (pref.maxLogsToSpider > 5);
 
 		Vector cachesToUpdate = new Vector();
-		for(int i = 0; i <	cacheDB.size(); i++){
+		for (int i = 0; i < cacheDB.size(); i++) {
 			ch = cacheDB.get(i);
-			if(ch.is_Checked == true && ch.isVisible()) {
-				String wpStart = ch.getWayPoint().substring(0,2);
-				if ( ch.getWayPoint().length()>1 && (wpStart.equalsIgnoreCase("GC") || ch.isOC()))
-//					Notiz: Wenn es ein addi Wpt ist, sollte eigentlich der Maincache gespidert werden
-//					Alter code prft aber nur ob ein Maincache von GC existiert und versucht dann den addi direkt zu spidern, was nicht funktioniert
+			if (ch.is_Checked == true && ch.isVisible()) {
+				String wpStart = ch.getWayPoint().substring(0, 2);
+				if (ch.getWayPoint().length() > 1 && (wpStart.equalsIgnoreCase("GC") || ch.isOC()))
+				// Notiz: Wenn es ein addi Wpt ist, sollte eigentlich der Maincache gespidert werden
+				// Alter code prft aber nur ob ein Maincache von GC existiert und versucht dann den addi direkt zu spidern, was nicht funktioniert
 				{
 					cachesToUpdate.add(new Integer(i));
 				} else {
-					if (ch.isAddiWpt() && ch.mainCache!=null && !ch.mainCache.is_Checked && !alreadySaid2) { // Is the father ticked?
-						alreadySaid2=true;
-						(new MessageBox(MyLocale.getMsg(327,"Information"),
-								        MyLocale.getMsg(5001,"Can't spider additional waypoint directly. Please check main cache."), FormBase.OKB)).execute();
+					if (ch.isAddiWpt() && ch.mainCache != null && !ch.mainCache.is_Checked && !alreadySaid2) { // Is the father ticked?
+						alreadySaid2 = true;
+						(new MessageBox(MyLocale.getMsg(327, "Information"), MyLocale.getMsg(5001, "Can't spider additional waypoint directly. Please check main cache."), FormBase.OKB)).execute();
 					}
 					if (!ch.isAddiWpt() && !alreadySaid) {
 						alreadySaid = true;
-						(new MessageBox(MyLocale.getMsg(327,"Information"),
-					        ch.getWayPoint()+ MyLocale.getMsg(5002,
-					        	": At the moment this function is only applicable for geocaching.com and opencaching.de/.cz/.org.uk ."),
-					        FormBase.OKB)).execute();
+						(new MessageBox(MyLocale.getMsg(327, "Information"), ch.getWayPoint() + MyLocale.getMsg(5002, ": At the moment this function is only applicable for geocaching.com and opencaching.de/.cz/.org.uk ."), FormBase.OKB)).execute();
 					}
 				}
 
@@ -889,14 +821,14 @@
 		}
 
 		int spiderErrors = 0;
-		boolean forceLogin=Global.getPref().forceLogin; // To ensure that spiderSingle only logs in once if forcedLogin=true
-		for(int j = 0; j <	cachesToUpdate.size(); j++){
-			int i = ((Integer)cachesToUpdate.get(j)).intValue();
+		boolean forceLogin = Global.getPref().forceLogin; // To ensure that spiderSingle only logs in once if forcedLogin=true
+		for (int j = 0; j < cachesToUpdate.size(); j++) {
+			int i = ((Integer) cachesToUpdate.get(j)).intValue();
 			ch = cacheDB.get(i);
-//			infB.setInfo("Loading: " + ch.wayPoint);
-			infB.setInfo(MyLocale.getMsg(5513,"Loading: ") + ch.getWayPoint() +" (" + (j+1) + " / " + cachesToUpdate.size() + ")");
+			// infB.setInfo("Loading: " + ch.wayPoint);
+			infB.setInfo(MyLocale.getMsg(5513, "Loading: ") + ch.getWayPoint() + " (" + (j + 1) + " / " + cachesToUpdate.size() + ")");
 			infB.redisplay();
-			if (ch.getWayPoint().substring(0,2).equalsIgnoreCase("GC")) {
+			if (ch.getWayPoint().substring(0, 2).equalsIgnoreCase("GC")) {
 				int test = spider.spiderSingle(i, infB, forceLogin, loadAllLogs || ch.is_found());
 				if (test == SpiderGC.SPIDER_CANCEL) {
 					infB.close(0);
@@ -904,30 +836,29 @@
 				} else if (test == SpiderGC.SPIDER_ERROR) {
 					spiderErrors++;
 				} else {
-					//profile.hasUnsavedChanges=true;
+					// profile.hasUnsavedChanges=true;
 				}
-				forceLogin=false;
-			}
-			else {
+				forceLogin = false;
+			} else {
 				if (!ocSync.syncSingle(i, infB)) {
 					infB.close(0);
 					break;
 				} else {
-					//profile.hasUnsavedChanges=true;
+					// profile.hasUnsavedChanges=true;
 				}
 			}
 
-//			cacheDB.clear();
-//			profile.readIndex();
+			// cacheDB.clear();
+			// profile.readIndex();
 		}
 		infB.close(0);
-		profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+		profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 		profile.restoreFilter();
 		profile.updateBearingDistance();
 		tablePanel.refreshTable();
 		Vm.showWait(false);
-		if ( spiderErrors > 0) {
-			new MessageBox(MyLocale.getMsg(5500,"Error"),spiderErrors + MyLocale.getMsg(5516," cache descriptions%0acould not be loaded."),FormBase.DEFOKB).execute();
+		if (spiderErrors > 0) {
+			new MessageBox(MyLocale.getMsg(5500, "Error"), spiderErrors + MyLocale.getMsg(5516, " cache descriptions%0acould not be loaded."), FormBase.DEFOKB).execute();
 		}
 	}
 

Modified: trunk/src/CacheWolf/MyComparer.java
===================================================================
--- trunk/src/CacheWolf/MyComparer.java	2011-05-11 15:56:46 UTC (rev 2999)
+++ trunk/src/CacheWolf/MyComparer.java	2011-05-11 23:04:45 UTC (rev 3000)
@@ -1,183 +1,194 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 import ewe.util.Comparer;
 import ewe.util.Vector;
+import ewe.util.mString;
 
 /**
-*	This class handles the sorting for most of the sorting tasks. If a cache is 
-*	to be displayed in the table or not is handled in the table model
-*	@see MyTableModel
-*	@see DistComparer
-*/
-public class MyComparer implements Comparer{
+ * This class handles the sorting for most of the sorting tasks. If a cache is to be displayed in the table or not is handled in the table model
+ * 
+ * @see MyTableModel
+ * @see DistComparer
+ */
+public class MyComparer implements Comparer {
 	Vector cacheDB;
-	
-	public MyComparer(CacheDB cacheDB, int colToCompare, int visibleSize){
-		//visibleSize=Global.mainTab.tbP.myMod.numRows;
-		if (visibleSize<2) return;
-		for (int i=visibleSize; i<cacheDB.size(); i++) {
-			CacheHolder ch=cacheDB.get(i);
-			ch.sort="\uFFFF";
+
+	public MyComparer(CacheDB cacheDB, int colToCompare, int visibleSize) {
+		// visibleSize=Global.mainTab.tbP.myMod.numRows;
+		if (visibleSize < 2)
+			return;
+		for (int i = visibleSize; i < cacheDB.size(); i++) {
+			CacheHolder ch = cacheDB.get(i);
+			ch.sort = "\uFFFF";
 		}
-		if (colToCompare==1) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=String.valueOf(ch.getType());
+		if (colToCompare == 1) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = String.valueOf(ch.getType());
 			}
-		} else if (colToCompare==2) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=String.valueOf(ch.getHard());
+		} else if (colToCompare == 2) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = String.valueOf(ch.getHard());
 			}
-		} else if (colToCompare==3) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=String.valueOf(ch.getTerrain());
+		} else if (colToCompare == 3) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = String.valueOf(ch.getTerrain());
 			}
-		} else if (colToCompare==4) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=ch.getWayPoint().toUpperCase();
+		} else if (colToCompare == 4) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getWayPoint().toUpperCase();
 			}
-		} else if (colToCompare==5) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=ch.getCacheName().trim().toLowerCase();
+		} else if (colToCompare == 5) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getCacheName().trim().toLowerCase();
 			}
-		} else if (colToCompare==6) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=ch.getLatLon();
+		} else if (colToCompare == 6) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getLatLon();
 			}
-		} else if (colToCompare==7) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=ch.getCacheOwner().toLowerCase();
+		} else if (colToCompare == 7) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getCacheOwner().toLowerCase();
 			}
-		} else if (colToCompare==8) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=ch.getDateHidden();
+		} else if (colToCompare == 8) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getDateHidden();
 			}
-		} else if (colToCompare==9) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=ch.getCacheStatus();
+		} else if (colToCompare == 9) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getCacheStatus();
 			}
-		} else if (colToCompare==10) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
+		} else if (colToCompare == 10) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
 				// CHECK Is the formatting correctly done?
-				if (ch.kilom==-1.0) {
-					ch.sort="\uFFFF";
+				if (ch.kilom == -1.0) {
+					ch.sort = "\uFFFF";
+				} else {
+					ch.sort = MyLocale.formatDouble(ch.kilom * 1000, "000000000000");
 				}
-				else {
-					ch.sort = MyLocale.formatDouble(ch.kilom*1000, "000000000000");
-				}
 			}
-		} else if (colToCompare==11) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
+		} else if (colToCompare == 11) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
 				if (ch.getBearing().equals("?")) {
-					ch.sort="\uFFFF";
+					ch.sort = "\uFFFF";
+				} else {
+					ch.sort = ch.getBearing();
 				}
+			}
+
+		} else if (colToCompare == 12) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = Integer.toString(ch.getCacheSize());
+			}
+		} else if (colToCompare == 13) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				if (ch.isOC()) {
+					ch.sort = MyLocale.formatLong(ch.recommendationScore, "000") + MyLocale.formatLong(ch.getNumRecommended(), "00000");
+				} else {
+					int gcVote = ch.getNumRecommended();
+					if (gcVote < 100) {
+						ch.sort = MyLocale.formatLong(gcVote, "000") + "00000000";
+					} else {
+						int votes = gcVote / 100;
+						gcVote = gcVote - 100 * votes;
+						ch.sort = MyLocale.formatLong(gcVote, "000") + MyLocale.formatLong(votes, "00000000");
+					}
+				}
+			}
+		} else if (colToCompare == 14) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				if (ch.getWayPoint().startsWith("GC"))
+					ch.sort = ch.getOcCacheID();
 				else {
-					ch.sort=ch.getBearing();
-				}			
+					String[] stmp = mString.split(ch.getCacheOwner(), '/');
+					int l = stmp.length - 1;
+					if (l > 0) {
+						String s = stmp[l].trim();
+						if (s.startsWith("GC"))
+							ch.sort = s;
+						else
+							ch.sort = "\uFFFF";
+					} else
+						ch.sort = "\uFFFF"; // ans Ende
+				}
 			}
-			
-		} else if (colToCompare==12) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=Integer.toString(ch.getCacheSize());
+		} else if (colToCompare == 15) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				if (ch.hasSolver()) {
+					ch.sort = "1";
+				} else {
+					ch.sort = "2";
+				}
 			}
-		} else if (colToCompare==13) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				if ( ch.isOC() ) {
-  				ch.sort=MyLocale.formatLong(ch.getNumRecommended(),"00000");
-        } else {
-				  int gcVote = ch.getNumRecommended();
-				  if ( gcVote < 100 ) {
-				    ch.sort=MyLocale.formatLong(gcVote,"00") + "00000000";
-          } else {
-            int votes = gcVote / 100;
-            gcVote = gcVote - 100 * votes;
-            ch.sort = MyLocale.formatLong(gcVote,"00") + MyLocale.formatLong(votes,"00000000");
-          }
-        }
-			}			
-		} else if (colToCompare==14) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				if (ch.isOC())
-					ch.sort=MyLocale.formatLong(ch.recommendationScore,"00000");
-				else
-					ch.sort="\uFFFF";
-			}			
-		} else if (colToCompare==15) {
-		    for (int i=0; i<visibleSize; i++) {
-		        CacheHolder ch=cacheDB.get(i);
-		        if (ch.hasSolver()) {
-		            ch.sort="1";
-		        } else {
-		            ch.sort="2";
-		        }
-		    }
-		} else if (colToCompare==16) {
-		    for (int i=0; i<visibleSize; i++) {
-		        CacheHolder ch=cacheDB.get(i);
-		        if (ch.hasNote()) {
-		            ch.sort="1";
-		        } else {
-		            ch.sort="2";
-		        }
-		    }
-		} else if (colToCompare==17) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch =  cacheDB.get(i);
-				ch.sort=MyLocale.formatLong(ch.addiWpts.size(),"000");
+		} else if (colToCompare == 16) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				if (ch.hasNote()) {
+					ch.sort = "1";
+				} else {
+					ch.sort = "2";
+				}
 			}
-		} else if (colToCompare==18) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch =  cacheDB.get(i);
-				ch.sort=MyLocale.formatLong(ch.getNoFindLogs(),"000");
+		} else if (colToCompare == 17) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = MyLocale.formatLong(ch.addiWpts.size(), "000");
 			}
-		} else if (colToCompare==19) {
-			for (int i=0; i<visibleSize; i++) {
-				CacheHolder ch =  cacheDB.get(i);
-				ch.sort=ch.getLastSync();
+		} else if (colToCompare == 18) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = MyLocale.formatLong(ch.getNoFindLogs(), "000");
 			}
+		} else if (colToCompare == 19) {
+			for (int i = 0; i < visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getLastSync();
+			}
 		}
- 	}
-	
-	public int compare(Object o1, Object o2){
-		CacheHolder oo1 = (CacheHolder)o1;
-		CacheHolder oo2 = (CacheHolder)o2;
+	}
+
+	public int compare(Object o1, Object o2) {
+		CacheHolder oo1 = (CacheHolder) o1;
+		CacheHolder oo2 = (CacheHolder) o2;
 		return oo1.sort.compareTo(oo2.sort);
 	}
 }

Modified: trunk/src/CacheWolf/UrlFetcher.java
===================================================================
--- trunk/src/CacheWolf/UrlFetcher.java	2011-05-11 15:56:46 UTC (rev 2999)
+++ trunk/src/CacheWolf/UrlFetcher.java	2011-05-11 23:04:45 UTC (rev 3000)
@@ -28,6 +28,7 @@
 import ewe.data.PropertyList;
 import ewe.io.AsciiCodec;
 import ewe.io.File;
+import ewe.io.FileBase;
 import ewe.io.FileOutputStream;
 import ewe.io.IOException;
 import ewe.io.JavaUtf8Codec;
@@ -131,6 +132,20 @@
 				i = i - 1;
 			}
 			realUrl = urltmp;
+			if (!urltmp.startsWith("http")) {
+				url = FileBase.fixupPath(url);
+				String uu = url.toLowerCase();
+				String host;
+				uu = url.replace('\\', '/');
+				host = uu.substring(7);
+				int first = host.indexOf('/');
+				if (first != -1) {
+					host = host.substring(0, first);
+				}
+				if (!urltmp.startsWith("/"))
+					host = host + "/";
+				urltmp = "http://" + host + urltmp;
+			}
 			conn.setUrl(urltmp);
 			conn.documentIsEncoded = isUrlEncoded(urltmp);
 			if (permanentRequestorProperties == null)
@@ -153,6 +168,12 @@
 			urltmp = conn.getRedirectTo();
 			if (urltmp != null) {
 				conn.disconnect();
+				final PropertyList pl = UrlFetcher.getDocumentProperties();
+				if (pl != null) {
+					String cookie = (String) pl.getValue("Set-Cookie", "");
+					if (!cookie.equals(""))
+						setPermanentRequestorProperty("Cookie", cookie);
+				}
 				conn = conn.getRedirectedConnection(urltmp);
 				forceRedirect = false; // one time or more redirected
 			}
@@ -236,7 +257,7 @@
 			char c = what[i];
 			if (spaceToPlus && c == ' ')
 				c = '+';
-			else if (c <= '/' || c >= 127 || c == '+' || c == '&' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}') {
+			else if (c <= ' ' || c >= 127 || c == '+' || c == '&' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}' || c == '$' || c == '/') {
 				dest[d++] = '%';
 				dest[d++] = hex.charAt((c >> 4) & 0xf);
 				dest[d++] = hex.charAt(c & 0xf);

Modified: trunk/src/CacheWolf/imp/OCGPXfetch.java
===================================================================
--- trunk/src/CacheWolf/imp/OCGPXfetch.java	2011-05-11 15:56:46 UTC (rev 2999)
+++ trunk/src/CacheWolf/imp/OCGPXfetch.java	2011-05-11 23:04:45 UTC (rev 3000)
@@ -1,90 +1,78 @@
 package CacheWolf.imp;
 
-import ewe.io.File;
-import ewe.io.IOException;
-import ewe.ui.FormBase;
 import CacheWolf.Global;
 import CacheWolf.MyLocale;
 import CacheWolf.Preferences;
 import CacheWolf.Profile;
 import CacheWolf.UrlFetcher;
 import CacheWolf.utils.FileBugfix;
+import ewe.io.File;
+import ewe.io.IOException;
+import ewe.ui.FormBase;
 
 public class OCGPXfetch {
 	static Preferences pref = Global.getPref();
 	static Profile prof = Global.getProfile();;
-	
+
 	public static void doIt() {
 		String hostname = pref.lastOCSite;
-		boolean oldDownloadAllOC=pref.downloadAllOC;
+		boolean oldDownloadAllOC = pref.downloadAllOC;
 		boolean onlyListedAtOC = false;
-		OCXMLImporterScreen importOpt = new OCXMLImporterScreen(
-				MyLocale.getMsg(130,"Download from opencaching"),
-				OCXMLImporterScreen.IMAGES|
-				OCXMLImporterScreen.ALL|
-				OCXMLImporterScreen.HOST);
-		importOpt.missingCheckBox.setText(MyLocale.getMsg(164,"only listed at OC"));
+		OCXMLImporterScreen importOpt = new OCXMLImporterScreen(MyLocale.getMsg(130, "Download from opencaching"), OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.ALL | OCXMLImporterScreen.HOST);
+		importOpt.missingCheckBox.setText(MyLocale.getMsg(164, "only listed at OC"));
 		importOpt.missingCheckBox.setState(onlyListedAtOC);
-		if (importOpt.execute() == FormBase.IDCANCEL) {	return; }
-		onlyListedAtOC=pref.downloadAllOC;
-		pref.downloadAllOC=oldDownloadAllOC;
-		if (importOpt.domains.getSelectedItem()!=null) {
-			hostname = (String)importOpt.domains.getSelectedItem();
-			pref.lastOCSite=hostname;
+		if (importOpt.execute() == FormBase.IDCANCEL) {
+			return;
 		}
+		onlyListedAtOC = pref.downloadAllOC;
+		pref.downloadAllOC = oldDownloadAllOC;
+		if (importOpt.domains.getSelectedItem() != null) {
+			hostname = (String) importOpt.domains.getSelectedItem();
+			pref.lastOCSite = hostname;
+		}
 
 		try {
-			String address="http://"+hostname+"/search.php?";
-			address+="searchto=searchbyfinder"; // searchbydistance
-			address+="&showresult=1&expert=0&sort=bydistance&orderRatingFirst=0";
-			address+="&f_userowner=0&f_userfound=0&f_inactive=0&f_ignored=0";
-			address+="&f_otherPlatforms="; // 0 = all 1 = nur OC
+			String address = "http://" + hostname + "/search.php?";
+			address += "searchto=searchbyfinder"; // searchbydistance
+			address += "&showresult=1&expert=0&sort=bydistance&orderRatingFirst=0";
+			address += "&f_userowner=0&f_userfound=0&f_inactive=0&f_ignored=0";
+			address += "&f_otherPlatforms="; // 0 = all 1 = nur OC
 			if (onlyListedAtOC)
-				address+="1";
-			else 
-				address+="0"; 
-			address+="&country=&difficultymin=0&difficultymax=0&terrainmin=0&terrainmax=0&cachetype=1;2;3;4;5;6;7;8;9;10&cachesize=1;2;3;4;5;6;7&cache_attribs=&cache_attribs_not=";
-			address+="&logtype=1,7";
-			address+="&utf8=1&output=gpx&zip=1";
-			address+="&count=max";
-			address+="&finder="+pref.myAlias;
-			String tmpFile=prof.dataDir + "dummy.zip";
+				address += "1";
+			else
+				address += "0";
+			address += "&country=&difficultymin=0&difficultymax=0&terrainmin=0&terrainmax=0&cachetype=1;2;3;4;5;6;7;8;9;10&cachesize=1;2;3;4;5;6;7&cache_attribs=&cache_attribs_not=";
+			address += "&logtype=1,7";
+			address += "&utf8=1&output=gpx&zip=1";
+			address += "&count=max";
+			address += "&finder=" + pref.myAlias;
+			String tmpFile = prof.dataDir + "dummy.zip";
 			login();
 			UrlFetcher.fetchDataFile(address, tmpFile);
 			File ftmp = new FileBugfix(tmpFile);
-			if (ftmp.exists() && ftmp.length()>0) {
+			if (ftmp.exists() && ftmp.length() > 0) {
 				GPXImporter gpx = new GPXImporter(pref, prof, tmpFile);
-				if (pref.downloadPics) 
-					gpx.doIt(GPXImporter.DOIT_WITHSPOILER);				
-				else gpx.doIt(GPXImporter.DOIT_NOSPOILER);
+				if (pref.downloadPics)
+					gpx.doIt(GPXImporter.DOIT_WITHSPOILER);
+				else
+					gpx.doIt(GPXImporter.DOIT_NOSPOILER);
 			}
 			ftmp.delete();
 		} catch (IOException e) {
 		}
 	}
-	
-	private static boolean login() {
+
+	public static boolean login() {
 		// TODO this is only a preliminary Version of login
 		boolean loggedIn = false;
 		String page;
 		try {
-			String loginDaten="target=myhome.php&action=login&email="+pref.myAlias+"&password="+pref.password;
-			try {
-				UrlFetcher.setpostData(loginDaten);
-				UrlFetcher.setMaxRedirections(1);
-				UrlFetcher.fetch("http://www.opencaching.de/login.php");
-			} catch (IOException e) {
-				if (e.getMessage().startsWith("too many http redirections")) {
-					String cookie = (String) UrlFetcher.getDocumentProperties().getValue("Set-Cookie","");
-					UrlFetcher.setPermanentRequestorProperty("Cookie",cookie);
-					page=UrlFetcher.fetch("http://www.opencaching.de/login.php?action=cookieverify&target=myhome.php");
-					page=UrlFetcher.fetch("http://www.opencaching.de/myhome.php");
-					// control , that I am logged in
-					// (by ?) get finderid ?
-					// todo set language ?
-					loggedIn = page.indexOf("Eingeloggt als") > -1;
-				}
-			}			
+			String loginDaten = "target=myhome.php&action=login&email=" + pref.myAlias + "&password=" + pref.password;
+			UrlFetcher.setpostData(loginDaten);
+			page = UrlFetcher.fetch("http://www.opencaching.de/login.php");
+			// final PropertyList pl = UrlFetcher.getDocumentProperties();
+			page = UrlFetcher.fetch("http://www.opencaching.de/myhome.php");
+			loggedIn = page.indexOf("Eingeloggt als") > -1;
 		} catch (IOException e) {
 			pref.log("Fehler", e);
 		}

Added: trunk/src/CacheWolf/imp/OCLinkImporter.java
===================================================================
--- trunk/src/CacheWolf/imp/OCLinkImporter.java	                        (rev 0)
+++ trunk/src/CacheWolf/imp/OCLinkImporter.java	2011-05-11 23:04:45 UTC (rev 3000)
@@ -0,0 +1,79 @@
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
+
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+package CacheWolf.imp;
+
+import CacheWolf.CacheDB;
+import CacheWolf.CacheHolder;
+import CacheWolf.Global;
+import CacheWolf.UrlFetcher;
+import ewe.sys.Handle;
+import ewe.ui.ProgressBarForm;
+
+public class OCLinkImporter {
+	private CacheDB cacheDB;
+
+	public OCLinkImporter() {
+		this.cacheDB = Global.getProfile().cacheDB;
+	}
+
+	public void doIt() {
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+
+		pbf.showMainTask = false;
+		pbf.setTask(h, "Import OC names ...");
+		pbf.exec();
+		OCGPXfetch.login();
+		for (int o = 0; o < cacheDB.size(); o += 1) {
+			CacheHolder ch = cacheDB.get(o);
+			String wp = ch.getWayPoint();
+			if (wp.startsWith("GC")) {
+				String url = "http://www.opencaching.de/map2.php?mode=wpsearch&wp=" + wp;
+				h.progress = (float) o / (float) (cacheDB.size() - 1);
+				h.changed();
+				try {
+					String result = UrlFetcher.fetch(url);
+					boolean found = false;
+					int start = result.indexOf("found=\"") + 7;
+					if (result.substring(start).startsWith("1"))
+						found = true;
+					start = result.indexOf("wpoc=\"") + 6;
+					if (start > 5) {
+						int idend = result.indexOf("\"", start);
+						String ocwp = result.substring(start, idend);
+						if (!found)
+							ocwp = "-" + ocwp;
+						ch.setOcCacheID(ocwp);
+					}
+				} catch (Exception e) {
+					// dann halt nicht
+				}
+			}
+		}
+		pbf.exit(0);
+	}
+
+}


Property changes on: trunk/src/CacheWolf/imp/OCLinkImporter.java
___________________________________________________________________
Added: svn:mime-type
   + text/plain

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-11 15:56:46 UTC (rev 2999)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-11 23:04:45 UTC (rev 3000)
@@ -1341,14 +1341,17 @@
 		} else
 			return false;
 		final String strEnglishPage = "ctl00$uxLocaleList$uxLocaleList$ctl01$uxLocaleItem";
-		final String postStr = "__EVENTTARGET=" + UrlFetcher.encodeURL(strEnglishPage, false) + "&__EVENTARGUMENT=" + "&__VIEWSTATE=" + UrlFetcher.encodeURL(viewstate, false);
+		String postStr = "__EVENTTARGET=" + UrlFetcher.encodeURL(strEnglishPage, false) + "&__EVENTARGUMENT=" + "&__VIEWSTATE=" + UrlFetcher.encodeURL(viewstate, false);
+		// postStr += UrlFetcher.encodeURL("&ctl00$ContentBody$tbSearch=postal code, country, etc.", true);
 		try {
 			UrlFetcher.setpostData(postStr);
-			/*
-			 * UrlFetcher.setRequestorProperty("Referer", url); UrlFetcher.setRequestorProperty("Origin", "http://www.geocaching.com"); UrlFetcher.setRequestorProperty("Cache-Control", "max-age=0"); UrlFetcher.setRequestorProperty("Accept-Charset",
-			 * "ISO-8859-1,utf-8;q=0.7,*;q=0.3"); UrlFetcher.setRequestorProperty("Accept-Language", "de-DE,de;q=0.8,en-US;q=0.6,en;q=0.4"); cookie =
-			 * "company_history=%5B%5B%22http%3A//feedback.geocaching.com/geocaching%22%2C%22Geocaching%22%5D%5D; Send2GPS=garmin; __qca=P0-675333427-1299837942815; " + cookie; UrlFetcher.setPermanentRequestorProperty("Cookie", cookie);
-			 */
+			// UrlFetcher.setRequestorProperty("Referer", url);
+			// UrlFetcher.setRequestorProperty("Origin", "http://www.geocaching.com");
+			// UrlFetcher.setRequestorProperty("Cache-Control", "max-age=0");
+			// UrlFetcher.setRequestorProperty("Accept-Charset", "ISO-8859-1,utf-8;q=0.7,*;q=0.3");
+			// UrlFetcher.setRequestorProperty("Accept-Language", "de-DE,de;q=0.8,en-US;q=0.6,en;q=0.4");
+			// cookie = "company_history=%5B%5B%22http%3A//feedback.geocaching.com/geocaching%22%2C%22Geocaching%22%5D%5D; Send2GPS=garmin; __qca=P0-675333427-1299837942815; " + cookie;
+			// UrlFetcher.setPermanentRequestorProperty("Cookie", cookie);
 			page = UrlFetcher.fetch(url);
 			if (page.indexOf(loggedInEnglish) > -1) {
 				pref.log("Switched to English");

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2011-05-11 15:56:46 UTC (rev 2999)
+++ trunk/src/CacheWolf/myTableModel.java	2011-05-11 23:04:45 UTC (rev 3000)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import ewe.fx.Color;
@@ -31,7 +31,6 @@
 import ewe.fx.Image;
 import ewe.fx.Point;
 import ewe.fx.mImage;
-import ewe.sys.Convert;
 import ewe.sys.Time;
 import ewe.sys.Vm;
 import ewe.ui.CellConstants;
@@ -39,11 +38,10 @@
 import ewe.ui.TableCellAttributes;
 import ewe.ui.TableModel;
 import ewe.util.Vector;
+import ewe.util.mString;
 
 /**
- * Table model used to display the cache list. Used by the table control in the
- * first panel of CacheWolf. 20061212 salzkammergut, patch to speed up
- * scrolling, Used MyLocale
+ * Table model used to display the cache list. Used by the table control in the first panel of CacheWolf. 20061212 salzkammergut, patch to speed up scrolling, Used MyLocale
  */
 public class myTableModel extends TableModel {
 
@@ -66,30 +64,17 @@
 	/** The max number of columns in the list view */
 	public static final int N_COLUMNS = 20;
 	/**
-	 * How the columns are mapped onto the list view. If colMap[i]=j, it means
-	 * that the element j (as per the list below) is visible in column i.
-	 * [0]TickBox, [1]Type, [2]Distance, [3]Terrain, [4]waypoint, [5]name,
-	 * [6]coordinates, [7]owner, [8]datehidden, [9]status, [10]distance,
-	 * [11]bearing, [12] Size, [13] # of OC recommend. [14] OC index, [15]
-	 * Solver exists, [16] Note exists, [17] # Additionals, [18] # DNF [19] Last
-	 * Sync Date
+	 * How the columns are mapped onto the list view. If colMap[i]=j, it means that the element j (as per the list below) is visible in column i. [0]TickBox, [1]Type, [2]Distance, [3]Terrain, [4]waypoint, [5]name, [6]coordinates, [7]owner, [8]datehidden,
+	 * [9]status, [10]distance, [11]bearing, [12] Size, [13] # of OC recommend. [14] OC index, [15] Solver exists, [16] Note exists, [17] # Additionals, [18] # DNF [19] Last Sync Date
 	 * 
-	 * Attention: When adding columns here, also add a default width in
-	 * Preferences.listColWidth
+	 * Attention: When adding columns here, also add a default width in Preferences.listColWidth
 	 */
 	private int[] colMap;
 	/** The column widths corresponding to the list of columns above */
 	private int[] colWidth;
-	private String[] colName = { " ", "?", MyLocale.getMsg(1000, "D"),
-			MyLocale.getMsg(1001, "T"), MyLocale.getMsg(1002, "Waypoint"),
-			"Name", MyLocale.getMsg(1004, "Location"),
-			MyLocale.getMsg(1005, "Owner"), MyLocale.getMsg(1006, "Hidden"),
-			MyLocale.getMsg(1007, "Status"), MyLocale.getMsg(1008, "Dist"),
-			MyLocale.getMsg(1009, "Bear"), MyLocale.getMsg(1017, "S"),
-			MyLocale.getMsg(1026, "#Rec"), MyLocale.getMsg(1027, "OC-IDX"),
-			MyLocale.getMsg(1038, "S"), MyLocale.getMsg(1040, "N"),
-			MyLocale.getMsg(1047, "A"), MyLocale.getMsg(1049, "DNF"),
-			MyLocale.getMsg(1051, "Last synced") };
+	private String[] colName = { " ", "?", MyLocale.getMsg(1000, "D"), MyLocale.getMsg(1001, "T"), MyLocale.getMsg(1002, "Waypoint"), "Name", MyLocale.getMsg(1004, "Location"), MyLocale.getMsg(1005, "Owner"), MyLocale.getMsg(1006, "Hidden"),
+			MyLocale.getMsg(1007, "Status"), MyLocale.getMsg(1008, "Dist"), MyLocale.getMsg(1009, "Bear"), MyLocale.getMsg(1017, "S"), MyLocale.getMsg(1026, "#Rec"), MyLocale.getMsg(1027, "OC-IDX"), MyLocale.getMsg(1038, "S"),
+			MyLocale.getMsg(1040, "N"), MyLocale.getMsg(1047, "A"), MyLocale.getMsg(1049, "DNF"), MyLocale.getMsg(1051, "Last synced") };
 
 	private static Image noFindLogs[] = new Image[4];
 	public static mImage red, blue, yellow; // skull, green
@@ -106,8 +91,7 @@
 	private mImage picHasSolver, picHasNotes;
 	private mImage[] sizePics = new mImage[CacheSize.CW_TOTAL_SIZE_IMAGES];
 	/**
-	 * This is the modifier (Shift & Control key status) for Pen Events it is
-	 * set in myTableControl.onEvent
+	 * This is the modifier (Shift & Control key status) for Pen Events it is set in myTableControl.onEvent
 	 */
 	public int penEventModifiers;
 	public myTableControl tcControl;
@@ -174,10 +158,8 @@
 	 * 
 	 */
 	public void setColumnNamesAndWidths() {
-		colMap = TableColumnChooser.str2Array(Global.getPref().listColMap, 0,
-				N_COLUMNS - 1, 0, -1);
-		colWidth = TableColumnChooser.str2Array(Global.getPref().listColWidth,
-				10, 1024, 50, colMap.length);
+		colMap = TableColumnChooser.str2Array(Global.getPref().listColMap, 0, N_COLUMNS - 1, 0, -1);
+		colWidth = TableColumnChooser.str2Array(Global.getPref().listColWidth, 10, 1024, 50, colMap.length);
 		numCols = colMap.length;
 		clearCellAdjustments();
 		// If the displayed columns include the checkbox, we use the full menu
@@ -188,8 +170,7 @@
 	}
 
 	/**
-	 * Return the column widths as a comma delimited string for storing in the
-	 * preferences
+	 * Return the column widths as a comma delimited string for storing in the preferences
 	 * 
 	 * @return
 	 */
@@ -261,14 +242,12 @@
 	}
 
 	/**
-	 * Method to set the row color of the table displaying the cache list,
-	 * depending on different flags set to the cache.
+	 * Method to set the row color of the table displaying the cache list, depending on different flags set to the cache.
 	 */
 	/*
 	 * (non-Javadoc)
 	 * 
-	 * @see ewe.ui.TableModel#getCellAttributes(int, int, boolean,
-	 * ewe.ui.TableCellAttributes)
+	 * @see ewe.ui.TableModel#getCellAttributes(int, int, boolean, ewe.ui.TableCellAttributes)
 	 */
 	public TableCellAttributes getCellAttributes(int row, int col, boolean isSelected, TableCellAttributes ta) {
 		ta = super.getCellAttributes(row, col, isSelected, ta);
@@ -320,7 +299,7 @@
 					lastColorFG.set(ta.foreground);
 					lastRow = row;
 				} catch (Exception e) {
-					Global.getPref().log("[myTableModel:getCellAttributes]Ignored row="+row+" lastRow="+lastRow,e, true);
+					Global.getPref().log("[myTableModel:getCellAttributes]Ignored row=" + row + " lastRow=" + lastRow, e, true);
 				}
 				;
 			} else {
@@ -329,8 +308,7 @@
 				ta.fillColor = lastColorBG;
 				ta.foreground = lastColorFG;
 			}
-		} else if (row == -1 && colMap[col] == 0
-				&& Global.getProfile().showBlacklisted()) {
+		} else if (row == -1 && colMap[col] == 0 && Global.getProfile().showBlacklisted()) {
 			ta.fillColor = Color.Black;
 			lastColorBG.set(ta.fillColor);
 		}
@@ -338,22 +316,17 @@
 	}
 
 	/**
-	 * Determines the arithmetic mean value of two colors and stores the result
-	 * in the third color.
+	 * Determines the arithmetic mean value of two colors and stores the result in the third color.
 	 * 
 	 * @param colorMerged
 	 *            Resulting color
 	 * @param colorA
-	 *            First color to merge. May be same object as
-	 *            <code>colorMerged</code>.
+	 *            First color to merge. May be same object as <code>colorMerged</code>.
 	 * @param colorB
-	 *            Second color to merge. May be same object as
-	 *            <code>colorMerged</code>.
+	 *            Second color to merge. May be same object as <code>colorMerged</code>.
 	 */
 	private void mergeColor(Color colorMerged, Color colorA, Color colorB) {
-		colorMerged.set((colorA.getRed() + colorB.getRed()) / 2, (colorA
-				.getGreen() + colorB.getGreen()) / 2,
-				(colorA.getBlue() + colorB.getBlue()) / 2);
+		colorMerged.set((colorA.getRed() + colorB.getRed()) / 2, (colorA.getGreen() + colorB.getGreen()) / 2, (colorA.getBlue() + colorB.getBlue()) / 2);
 	}
 
 	public int calculateRowHeight(int row) {
@@ -370,9 +343,7 @@
 	}
 
 	/**
-	 * Need to override this method with a null return to avoid getCellData
-	 * being called twice on each access to a cell. For further reference see
-	 * the Ewe source code.
+	 * Need to override this method with a null return to avoid getCellData being called twice on each access to a cell. For further reference see the Ewe source code.
 	 * 
 	 * @author skg
 	 */
@@ -432,8 +403,7 @@
 					return ch.getWayPoint();
 				case 5: // Cachename
 					// Fast return for majority of case
-					if (!showExtraWptInfo
-							|| (ch.has_bugs() == false && ch.getNoFindLogs() == 0))
+					if (!showExtraWptInfo || (ch.has_bugs() == false && ch.getNoFindLogs() == 0))
 						return ch.getCacheName();
 					// Now need more checks
 					IconAndText wpVal = new IconAndText();
@@ -465,13 +435,23 @@
 					} else {
 						return sizePics[CacheSize.guiSizeImageId(ch.getCacheSize())];
 					}
-				case 13: // OC number of recommendations
-					 return ch.getRecommended();
-          
-				case 14: // OC rating
-					if (ch.isOC())
-						return Convert.formatInt(ch.recommendationScore);
-					return null;
+				case 13: // OC / gcvote Bewertung
+					return ch.getRecommended();
+				case 14: //
+					if (ch.getWayPoint().startsWith("GC"))
+						return ch.getOcCacheID();
+					else {
+						String[] stmp = mString.split(ch.getCacheOwner(), '/');
+						int l = stmp.length - 1;
+						if (l > 0) {
+							String s = stmp[l].trim();
+							if (s.startsWith("GC"))
+								return s;
+							else
+								return "";
+						} else
+							return "";
+					}
 				case 15: // Is solver filled?
 					if (ch.hasSolver())
 						return picHasSolver;
@@ -497,10 +477,9 @@
 				case 19: // Last sync date
 					if (!ch.getLastSync().equals("")) {
 						try {
-							lastSyncWorker.parse(ch.getLastSync(),
-									"yyyyMMddHHmmss");
+							lastSyncWorker.parse(ch.getLastSync(), "yyyyMMddHHmmss");
 						} catch (IllegalArgumentException e) {
-							Global.getPref().log("Could not parse 'lastSyncDate': "	+ ch.getLastSync() + ". Reset to empty.", e);
+							Global.getPref().log("Could not parse 'lastSyncDate': " + ch.getLastSync() + ". Reset to empty.", e);
 							ch.setLastSync("");
 						}
 						return lastSyncWorker.format("yyyy-MM-dd HH:mm");
@@ -551,7 +530,7 @@
 				retval = true;
 			}
 		} catch (NullPointerException npex) {
-			Global.getPref().log("[myTableModel:Penpressed]",npex,true);
+			Global.getPref().log("[myTableModel:Penpressed]", npex, true);
 			Vm.showWait(false);
 		}
 		return retval;
@@ -574,7 +553,7 @@
 			CacheHolder ch = null;
 			if ((a != null) && (a.y >= 0) && (a.y < cacheDB.size()))
 				ch = cacheDB.get(a.y);
-			cacheDB.sort(new MyComparer(cacheDB, sortedBy, numRows),!sortAscending);
+			cacheDB.sort(new MyComparer(cacheDB, sortedBy, numRows), !sortAscending);
 			updateRows();
 			// = cacheDB.rebuild(sortedVector of ch,
 			// invisibleVector of ch)
@@ -591,9 +570,7 @@
 	}
 
 	/**
-	 * Toggle the select status for a group of caches If from==to, the addi
-	 * Waypoints are also toggled if the cache is a main waypoint If from!=to,
-	 * each cache is toggled irrespective of its type (main or addi)
+	 * Toggle the select status for a group of caches If from==to, the addi Waypoints are also toggled if the cache is a main waypoint If from!=to, each cache is toggled irrespective of its type (main or addi)
 	 * 
 	 * @param from
 	 *            index of first cache to toggle



From araber95 at mail.berlios.de  Thu May 12 10:42:00 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Thu, 12 May 2011 10:42:00 PM +0200
Subject: [Cachewolf-svn] r3001 - in trunk/src/CacheWolf: . imp
Message-ID: <20110512204201.0E82E4813C4@sheep.berlios.de>

Author: araber95
Date: 2011-05-12 22:42:00 +0200 (Thu, 12 May 2011)
New Revision: 3001

Modified:
   trunk/src/CacheWolf/InfoBox.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/MyComparer.java
   trunk/src/CacheWolf/UrlFetcher.java
   trunk/src/CacheWolf/imp/OCLinkImporter.java
   trunk/src/CacheWolf/myTableControl.java
   trunk/src/CacheWolf/myTableModel.java
Log:
1. Import OC Links only for visible Caches. Starting "-" means : not yet logged at OC
2. log OC - Cache from found GC-Cache in Browser. Text in Clipboard.
3. log OC - Cache from found GC-Cache without Browser if clicked in OC-IDx Column. Error Result shown with ! in front of OC - Waypoint.

(All restricted to opencaching.de at the moment)

Modified: trunk/src/CacheWolf/InfoBox.java
===================================================================
--- trunk/src/CacheWolf/InfoBox.java	2011-05-11 23:04:45 UTC (rev 3000)
+++ trunk/src/CacheWolf/InfoBox.java	2011-05-12 20:42:00 UTC (rev 3001)
@@ -1,29 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 import ewe.ui.CellConstants;
 import ewe.ui.ControlConstants;
 import ewe.ui.ControlEvent;
@@ -37,7 +38,7 @@
 import ewe.ui.mInput;
 import ewe.ui.mLabel;
 
-public class InfoBox extends Form{
+public class InfoBox extends Form {
 	TextMessage msgArea;
 	mCheckBox mCB;
 	TextMessage warnings;
@@ -50,28 +51,21 @@
 	public final static int DISPLAY_ONLY = 3;
 	public final static int PROGRESS_WITH_WARNINGS = 4;
 	private int type = 0;
-	/** This variable is set to true if the user closed the Info window by
-	 *  clicking the "close" button. It can be used to check if a lengthy task needs to be
-	 *  aborted (i.e. spidering)
+	/**
+	 * This variable is set to true if the user closed the Info window by clicking the "close" button. It can be used to check if a lengthy task needs to be aborted (i.e. spidering)
 	 */
-	public boolean isClosed=false;
+	public boolean isClosed = false;
 
-	public InfoBox(String title, String info){
+	public InfoBox(String title, String info) {
 		this(title, info, DISPLAY_ONLY);
 
-		/*this.setPreferredSize(170,50);
-		this.title = title;
-		msgArea = new MessageArea(""), CellConstants.STRETCH, CellConstants.FILL)
-		this.addLast(scP = new ScrollBarPanel(msgArea));
-		msgArea.setText(info);
-		mB.setHotKey(0, IKeys.ACTION);
-		mB.setHotKey(0, IKeys.ENTER);
-		//mB.set(Control.Invisible, true);
-		//this.addLast(mB, CellConstants.STRETCH, CellConstants.FILL);
+		/*
+		 * this.setPreferredSize(170,50); this.title = title; msgArea = new MessageArea(""), CellConstants.STRETCH, CellConstants.FILL) this.addLast(scP = new ScrollBarPanel(msgArea)); msgArea.setText(info); mB.setHotKey(0, IKeys.ACTION); mB.setHotKey(0,
+		 * IKeys.ENTER); //mB.set(Control.Invisible, true); //this.addLast(mB, CellConstants.STRETCH, CellConstants.FILL);
 		 */
 	}
 
-	public String getInput(){
+	public String getInput() {
 		return feedback.getText();
 	}
 
@@ -80,29 +74,43 @@
 		this.repaintNow();
 	}
 
-	public InfoBox(String title, String info, int ty){
-		this(title, info, ty, true);
-//		this.setPreferredSize(170, 50);
+	public InfoBox(String title, String info, int type) {
+		this(title, info, type, true);
+		// this.setPreferredSize(170, 50);
 		relayout(false);
 	}
 
 	public InfoBox(String title, String info, int ty, boolean autoWrap) {
 		type = ty;
-//		this.setPreferredSize(150,50);
+		// this.setPreferredSize(150,50);
 		// Resize InfoBox with Fontsize
-		Preferences pref=Global.getPref();
+		Preferences pref = Global.getPref();
 		int fs = pref.fontSize;
 		int sw = MyLocale.getScreenWidth();
-		int psx; int psy;
-		psx=170;psy=50;
-		if((fs > 11) && (sw >= 200)){psx=200;psy=70;}
-		if((fs > 16) && (sw >= 250)){psx=250;psy=90;}
-		if((fs > 21) && (sw >= 300)){psx=300;psy=110;}
-		if((fs > 24) && (sw >= 350)){psx=350;psy=130;}
+		int psx;
+		int psy;
+		psx = 170;
+		psy = 50;
+		if ((fs > 11) && (sw >= 200)) {
+			psx = 200;
+			psy = 70;
+		}
+		if ((fs > 16) && (sw >= 250)) {
+			psx = 250;
+			psy = 90;
+		}
+		if ((fs > 21) && (sw >= 300)) {
+			psx = 300;
+			psy = 110;
+		}
+		if ((fs > 24) && (sw >= 350)) {
+			psx = 350;
+			psy = 130;
+		}
 		this.setPreferredSize(psx, psy);
 		this.title = title;
 		switch (type) {
-		case CHECKBOX: 
+		case CHECKBOX:
 			mCB = new mCheckBox(info);
 			this.addLast(mCB, CellConstants.STRETCH, CellConstants.FILL);
 			break;
@@ -123,11 +131,11 @@
 			msgArea.autoWrap = autoWrap;
 			msgArea.alignment = CellConstants.CENTER;
 			msgArea.anchor = CellConstants.CENTER;
-			msgArea.setPreferredSize(psx-20, psy);
+			msgArea.setPreferredSize(psx - 20, psy);
 			this.addLast(msgArea.getScrollablePanel(), CellConstants.HEXPAND | CellConstants.HGROW, CellConstants.HEXPAND | CellConstants.HGROW);
 			warnings = new TextMessage("");
 			warnings.autoWrap = autoWrap;
-			this.addLast(warnings.getScrollablePanel(), CellConstants.HEXPAND | CellConstants.VEXPAND |CellConstants.VGROW, CellConstants.HEXPAND | CellConstants.VEXPAND |CellConstants.VGROW);
+			this.addLast(warnings.getScrollablePanel(), CellConstants.HEXPAND | CellConstants.VEXPAND | CellConstants.VGROW, CellConstants.HEXPAND | CellConstants.VEXPAND | CellConstants.VGROW);
 			mB.set(ControlConstants.Disabled, true);
 			mB.setPreferredSize(40, 20);
 			addLast(mB, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
@@ -142,48 +150,52 @@
 		}
 	}
 
-	public void setInfo(String info){
+	public void setInfo(String info) {
 		msgArea.setText(info);
 		this.repaintNow();
 	}
-	
+
 	public void setInfoHeight(int heighti) {
 		msgArea.setPreferredSize(getPreferredSize(null).width, heighti);
 	}
+
 	public void setInfoWidth(int widthi) {
-		msgArea.setPreferredSize(widthi,getPreferredSize(null).height);
+		msgArea.setPreferredSize(widthi, getPreferredSize(null).height);
 	}
-	public String getInfo(){
+
+	public String getInfo() {
 		return msgArea.getText();
 	}
 
-	public void addWarning (String w) {
+	public void addWarning(String w) {
 		warnings.setText(warnings.text + w);
 	}
-	public void addOkButton() { //unfortunately this doesn't work
+
+	public void addOkButton() { // unfortunately this doesn't work
 		mB.set(ControlConstants.Disabled, false);
-		//addNext(mB);
-		//relayout(true);
-		//mB.set(Control.Invisible, false);
+		// addNext(mB);
+		// relayout(true);
+		// mB.set(Control.Invisible, false);
 		this.repaintNow();
 	}
 
-	public void onEvent(Event ev){
+	public void onEvent(Event ev) {
 		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
-			if(ev.target == mB){
-				if(type == CHECKBOX) mCB_state = mCB.getState();
+			if (ev.target == mB) {
+				if (type == CHECKBOX)
+					mCB_state = mCB.getState();
 				this.close(FormBase.IDOK);
 			}
-			if(ev.target == mC){
+			if (ev.target == mC) {
 				this.close(FormBase.IDCANCEL);
 			}
 		}
 		super.onEvent(ev);
 	}
-	
+
 	protected boolean canExit(int exitCode) {
-		isClosed=true;
+		isClosed = true;
 		return true;
 	}
-	
+
 }
\ No newline at end of file

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2011-05-11 23:04:45 UTC (rev 3000)
+++ trunk/src/CacheWolf/MainMenu.java	2011-05-12 20:42:00 UTC (rev 3001)
@@ -79,7 +79,7 @@
  * @see MainTab Last change: 20061123 salzkammergut Tidied up, added MyLocale, added additional internationalisation, combine save/filter for small screens, garminConn
  */
 public class MainMenu extends MenuBar {
-	private MenuItem preferences, mnuContext, loadcaches, loadOC, loadOCFinds, /* savenexit, */savenoxit, exit, search, searchAll, searchClr;
+	private MenuItem preferences, mnuContext, loadcaches, loadOC, loadOCFinds, savenoxit, exit, search, searchAll, searchClr;
 	private MenuItem downloadmap, kalibmap, importmap, selectMapPath;
 	private MenuItem spider, spiderRoute, spiderQuick, spiderAllFinds, loadGCVotes, fetchOCLink, update, chkVersion;
 	private MenuItem about, wolflang, sysinfo, legend;
@@ -96,7 +96,6 @@
 	private static boolean searchInDescriptionAndNotes = false;
 	private static boolean searchInLogs = false;
 	GCVoteImporter sGCV = null;
-	OCLinkImporter sOCL = null;
 
 	public MainMenu(Form f) {
 
@@ -107,8 +106,11 @@
 		// /////////////////////////////////////////////////////////////////////
 		// subMenu for profiles, part of "Application" menu below
 		// /////////////////////////////////////////////////////////////////////
-		MenuItem[] mnuProfile = { mnuNewProfile = new MenuItem(MyLocale.getMsg(1107, "New")), mnuOpenProfile = new MenuItem(MyLocale.getMsg(1109, "Open")), mnuDeleteProfile = new MenuItem(MyLocale.getMsg(1125, "Delete")),
-				mnuRenameProfile = new MenuItem(MyLocale.getMsg(1126, "Rename")), };
+		MenuItem[] mnuProfile = { mnuNewProfile = new MenuItem(MyLocale.getMsg(1107, "New")), //
+				mnuOpenProfile = new MenuItem(MyLocale.getMsg(1109, "Open")), //
+				mnuDeleteProfile = new MenuItem(MyLocale.getMsg(1125, "Delete")), //
+				mnuRenameProfile = new MenuItem(MyLocale.getMsg(1126, "Rename")), //
+		};
 		Menu profileMenu = new Menu(mnuProfile, MyLocale.getMsg(121, "Profiles"));
 
 		// /////////////////////////////////////////////////////////////////////
@@ -118,11 +120,22 @@
 			spiderRoute = new MenuItem(MyLocale.getMsg(137, "Download along a Route from geocaching.com"));
 		else
 			spiderRoute = mnuSeparator;
-		MenuItem[] mnuImport = { loadcaches = new MenuItem(MyLocale.getMsg(129, "Import GPX")), mnuSeparator, loadOC = new MenuItem(MyLocale.getMsg(130, "Download from opencaching")),
-				loadOCFinds = new MenuItem(MyLocale.getMsg(163, "Finds from opencaching")), mnuSeparator, spider = new MenuItem(MyLocale.getMsg(131, "Download from geocaching.com")), spiderRoute,
-				spiderAllFinds = new MenuItem(MyLocale.getMsg(217, "Spider all finds from geocaching.com")), spiderQuick = new MenuItem(MyLocale.getMsg(138, "from GC quick")), update = new MenuItem(MyLocale.getMsg(1014, "Update cache data")),
-				mnuSeparator, loadGCVotes = new MenuItem(MyLocale.getMsg(1208, "Import ratings from GCVote")), fetchOCLink = new MenuItem(MyLocale.getMsg(1209, "Fetch link to OC - Cache")), mnuSeparator,
-				mnuForceLogin = new MenuItem(MyLocale.getMsg(216, "Always login to GC")), };
+		MenuItem[] mnuImport = { loadcaches = new MenuItem(MyLocale.getMsg(129, "Import GPX")), //
+				mnuSeparator, //
+				loadOC = new MenuItem(MyLocale.getMsg(130, "Download from opencaching")), //
+				loadOCFinds = new MenuItem(MyLocale.getMsg(163, "Finds from opencaching")), //
+				mnuSeparator, //
+				spider = new MenuItem(MyLocale.getMsg(131, "Download from geocaching.com")), //
+				spiderRoute, //
+				spiderAllFinds = new MenuItem(MyLocale.getMsg(217, "Spider all finds from geocaching.com")), //
+				spiderQuick = new MenuItem(MyLocale.getMsg(138, "from GC quick")), //
+				update = new MenuItem(MyLocale.getMsg(1014, "Update cache data")), //
+				mnuSeparator, //
+				loadGCVotes = new MenuItem(MyLocale.getMsg(1208, "Import ratings from GCVote")), //
+				fetchOCLink = new MenuItem(MyLocale.getMsg(1209, "Fetch link to OC - Cache")), //
+				mnuSeparator, //
+				mnuForceLogin = new MenuItem(MyLocale.getMsg(216, "Always login to GC")), //
+		};
 		Menu importMenu = new Menu(mnuImport, MyLocale.getMsg(175, "Import"));
 		if (Global.getPref().forceLogin)
 			mnuForceLogin.modifiers ^= MenuItem.Checked;
@@ -130,54 +143,89 @@
 		// /////////////////////////////////////////////////////////////////////
 		// subMenu for export, part of "Application" menu below
 		// /////////////////////////////////////////////////////////////////////
-		MenuItem[] exitems = { exporthtml = new MenuItem(MyLocale.getMsg(100, "to HTML")), exportGpxNg = new MenuItem(MyLocale.getMsg(101, "to GPX Test")), exporttop50 = new MenuItem(MyLocale.getMsg(102, "to TOP50 ASCII")),
-				exportASC = new MenuItem(MyLocale.getMsg(104, "to CSV")), exportTomTom = new MenuItem(MyLocale.getMsg(105, "to TomTom")), exportMSARCSV = new MenuItem(MyLocale.getMsg(106, "to MS AutoRoute CSV")),
-				exportLOC = new MenuItem(MyLocale.getMsg(215, "to LOC")), exportGPS = new MenuItem(MyLocale.getMsg(122, "to GPS")), exportOZI = new MenuItem(MyLocale.getMsg(124, "to OZI")),
-				exportKML = new MenuItem(MyLocale.getMsg(125, "to Google Earth")), exportExplorist = new MenuItem(MyLocale.getMsg(132, "to Explorist")), exportTPL = new MenuItem(MyLocale.getMsg(128, "via Template")),
-				exportSpoilerPOI = new MenuItem(MyLocale.getMsg(135, "to SpoilerPOI")), };
+		MenuItem[] exitems = { exporthtml = new MenuItem(MyLocale.getMsg(100, "to HTML")), //
+				exportGpxNg = new MenuItem(MyLocale.getMsg(101, "to GPX Test")), //
+				exporttop50 = new MenuItem(MyLocale.getMsg(102, "to TOP50 ASCII")), //
+				exportASC = new MenuItem(MyLocale.getMsg(104, "to CSV")), //
+				exportTomTom = new MenuItem(MyLocale.getMsg(105, "to TomTom")), //
+				exportMSARCSV = new MenuItem(MyLocale.getMsg(106, "to MS AutoRoute CSV")), //
+				exportLOC = new MenuItem(MyLocale.getMsg(215, "to LOC")), //
+				exportGPS = new MenuItem(MyLocale.getMsg(122, "to GPS")), //
+				exportOZI = new MenuItem(MyLocale.getMsg(124, "to OZI")), //
+				exportKML = new MenuItem(MyLocale.getMsg(125, "to Google Earth")), //
+				exportExplorist = new MenuItem(MyLocale.getMsg(132, "to Explorist")), //
+				exportTPL = new MenuItem(MyLocale.getMsg(128, "via Template")), //
+				exportSpoilerPOI = new MenuItem(MyLocale.getMsg(135, "to SpoilerPOI")), //
+		};
 		if (Global.getPref().gpsbabel == null) {
 			exportGPS.modifiers = MenuItem.Disabled;
 			exportGPS.setText(MyLocale.getMsg(136, "to GPS : gpsbabel missing."));
 		}
-
 		Menu exportMenu = new Menu(exitems, MyLocale.getMsg(107, "Export"));
 
 		// /////////////////////////////////////////////////////////////////////
 		// subMenu for maps, part of "Application" menu below
 		// /////////////////////////////////////////////////////////////////////
-		MenuItem[] mapMenuItems = { downloadmap = new MenuItem(MyLocale.getMsg(162, "Download calibrated")), importmap = new MenuItem(MyLocale.getMsg(150, "Import")), kalibmap = new MenuItem(MyLocale.getMsg(151, "Calibrate")),
-				selectMapPath = new MenuItem(MyLocale.getMsg(4236, "Change map directory$c")), };
+		MenuItem[] mapMenuItems = { downloadmap = new MenuItem(MyLocale.getMsg(162, "Download calibrated")), //
+				importmap = new MenuItem(MyLocale.getMsg(150, "Import")), //
+				kalibmap = new MenuItem(MyLocale.getMsg(151, "Calibrate")), //
+				selectMapPath = new MenuItem(MyLocale.getMsg(4236, "Change map directory$c")), //
+		};
 		Menu mapsMenu = new Menu(mapMenuItems, null);
 
 		// Now we start with the horizontal menu bar "Application", "Search", "Filter", "Organise", "About"
 		// /////////////////////////////////////////////////////////////////////
 		// Create the "Application" pulldown menu
 		// /////////////////////////////////////////////////////////////////////
-		MenuItem[] appMenuItems = { new MenuItem(MyLocale.getMsg(121, "Profile"), 0, profileMenu), preferences = new MenuItem(MyLocale.getMsg(108, "Preferences")), mnuEditCenter = new MenuItem(MyLocale.getMsg(1110, "Centre")),
-				mnuContext = new MenuItem(MyLocale.getMsg(134, "Current Cache")), mnuSeparator, new MenuItem(MyLocale.getMsg(175, "Import"), 0, importMenu), new MenuItem(MyLocale.getMsg(107, "Export"), 0, exportMenu),
-				new MenuItem(MyLocale.getMsg(149, "Maps"), 0, mapsMenu), mnuSeparator, savenoxit = new MenuItem(MyLocale.getMsg(127, "Save")),
-				// savenexit = new MenuItem(MyLocale.getMsg(110,"Save & Exit")),
-				exit = new MenuItem(MyLocale.getMsg(111, "Exit")), };
+		MenuItem[] appMenuItems = { new MenuItem(MyLocale.getMsg(121, "Profile"), 0, profileMenu), //
+				preferences = new MenuItem(MyLocale.getMsg(108, "Preferences")), //
+				mnuEditCenter = new MenuItem(MyLocale.getMsg(1110, "Centre")), //
+				mnuContext = new MenuItem(MyLocale.getMsg(134, "Current Cache")), //
+				mnuSeparator, new MenuItem(MyLocale.getMsg(175, "Import"), 0, importMenu), //
+				new MenuItem(MyLocale.getMsg(107, "Export"), 0, exportMenu), //
+				new MenuItem(MyLocale.getMsg(149, "Maps"), 0, mapsMenu), //
+				mnuSeparator, //
+				savenoxit = new MenuItem(MyLocale.getMsg(127, "Save")), //
+				exit = new MenuItem(MyLocale.getMsg(111, "Exit")), //
+		};
 		this.addMenu(new PullDownMenu(MyLocale.getMsg(120, "Application"), new Menu(appMenuItems, null)));
 
 		// /////////////////////////////////////////////////////////////////////
 		// Create the "Search" pulldown menu
 		// /////////////////////////////////////////////////////////////////////
-		MenuItem[] searchMenuItems = { search = new MenuItem(MyLocale.getMsg(112, "Search$" + (char) 6)),// char 6 = ctrl +f
-				searchAll = new MenuItem(MyLocale.getMsg(133, "Search All")), searchClr = new MenuItem(MyLocale.getMsg(113, "Clear search")), };
+		MenuItem[] searchMenuItems = { search = new MenuItem(MyLocale.getMsg(112, "Search$" + (char) 6)), // char 6 = ctrl +f
+				searchAll = new MenuItem(MyLocale.getMsg(133, "Search All")), //
+				searchClr = new MenuItem(MyLocale.getMsg(113, "Clear search")), //
+		};
 
 		// /////////////////////////////////////////////////////////////////////
 		// Create the "Filter" pulldown menu
 		// /////////////////////////////////////////////////////////////////////
 		MenuItem[] filterMenuItems = { filtApply = new MenuItem(MyLocale.getMsg(709, "Apply")), filtCreate = new MenuItem(MyLocale.getMsg(114, "Create")), filtInvert = new MenuItem(MyLocale.getMsg(115, "Invert")),
-				filtClear = new MenuItem(MyLocale.getMsg(116, "Clear")), mnuSeparator, filtSelected = new MenuItem(MyLocale.getMsg(160, "Filter selected")), filtNonSelected = new MenuItem(MyLocale.getMsg(1011, "Filter out non selected")), mnuSeparator,
-				filtBlack = new MenuItem(MyLocale.getMsg(161, "Show Blacklist")), };
+				filtClear = new MenuItem(MyLocale.getMsg(116, "Clear")), //
+				mnuSeparator, //
+				filtSelected = new MenuItem(MyLocale.getMsg(160, "Filter selected")), //
+				filtNonSelected = new MenuItem(MyLocale.getMsg(1011, "Filter out non selected")), //
+				mnuSeparator, filtBlack = new MenuItem(MyLocale.getMsg(161, "Show Blacklist")), //
+		};
 		filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers & ~MenuItem.Checked;
 
 		// /////////////////////////////////////////////////////////////////////
 		// Create a combined "Filter and Search" pulldown menu for devices with small screens
 		// /////////////////////////////////////////////////////////////////////
-		MenuItem[] filterAndSearchMenuItems = { filtApply, filtCreate, filtInvert, filtClear, mnuSeparator, filtSelected, filtNonSelected, mnuSeparator, filtBlack, mnuSeparator, search, searchClr, };
+		MenuItem[] filterAndSearchMenuItems = { filtApply, //
+				filtCreate, //
+				filtInvert, //
+				filtClear, //
+				mnuSeparator, //
+				filtSelected, //
+				filtNonSelected, //
+				mnuSeparator, //
+				filtBlack, //
+				mnuSeparator, //
+				search, //
+				searchClr, //
+		};
 
 		// Depending on screen width display either filter and search menus or the combined menu
 		if (MyLocale.getScreenWidth() > 300) {
@@ -190,9 +238,17 @@
 		// /////////////////////////////////////////////////////////////////////
 		// Create the "Organise" pulldown menu
 		// /////////////////////////////////////////////////////////////////////
-		MenuItem[] organiseMenuItems = { orgNewWP = new MenuItem(MyLocale.getMsg(214, "New Waypoint")), mnuSeparator, orgCopy = new MenuItem(MyLocale.getMsg(141, "Copy")), orgMove = new MenuItem(MyLocale.getMsg(142, "Move")),
-				orgDelete = new MenuItem(MyLocale.getMsg(143, "Delete")), orgRebuild = new MenuItem(MyLocale.getMsg(208, "Rebuild Index")), orgCheckNotesAndSolver = new MenuItem(MyLocale.getMsg(220, "Check Notes/Solver")), mnuSeparator,
-				orgTravelbugs = new MenuItem(MyLocale.getMsg(139, "Manage travelbugs")), cacheTour = new MenuItem(MyLocale.getMsg(198, "Cachetour")), };
+		MenuItem[] organiseMenuItems = { orgNewWP = new MenuItem(MyLocale.getMsg(214, "New Waypoint")), //
+				mnuSeparator, //
+				orgCopy = new MenuItem(MyLocale.getMsg(141, "Copy")), //
+				orgMove = new MenuItem(MyLocale.getMsg(142, "Move")), //
+				orgDelete = new MenuItem(MyLocale.getMsg(143, "Delete")), //
+				orgRebuild = new MenuItem(MyLocale.getMsg(208, "Rebuild Index")), //
+				orgCheckNotesAndSolver = new MenuItem(MyLocale.getMsg(220, "Check Notes/Solver")), //
+				mnuSeparator, //
+				orgTravelbugs = new MenuItem(MyLocale.getMsg(139, "Manage travelbugs")), //
+				cacheTour = new MenuItem(MyLocale.getMsg(198, "Cachetour")), //
+		};
 		this.addMenu(new PullDownMenu(MyLocale.getMsg(140, "Organise"), new Menu(organiseMenuItems, null)));
 
 		// /////////////////////////////////////////////////////////////////////
@@ -223,10 +279,6 @@
 		}
 	}
 
-	public void setForceLogin() {
-		mnuForceLogin.modifiers = Global.getPref().forceLogin ? Global.mainTab.mnuMain.modifiers | MenuItem.Checked : Global.mainTab.mnuMain.modifiers & ~MenuItem.Checked;
-	}
-
 	public static void search() {
 		SearchBox inp = new SearchBox(MyLocale.getMsg(119, "Search for:"));
 		String srch = inp.input(null, "", searchInDescriptionAndNotes, searchInLogs, 10);
@@ -332,9 +384,7 @@
 				tbp.resetModel();
 			}
 			if (mev.selectedItem == fetchOCLink) {
-				if (sOCL == null)
-					sOCL = new OCLinkImporter();
-				sOCL.doIt();
+				OCLinkImporter.doIt();
 				tbp.resetModel();
 			}
 			if (mev.selectedItem == loadcaches) {

Modified: trunk/src/CacheWolf/MyComparer.java
===================================================================
--- trunk/src/CacheWolf/MyComparer.java	2011-05-11 23:04:45 UTC (rev 3000)
+++ trunk/src/CacheWolf/MyComparer.java	2011-05-12 20:42:00 UTC (rev 3001)
@@ -136,7 +136,10 @@
 			for (int i = 0; i < visibleSize; i++) {
 				CacheHolder ch = cacheDB.get(i);
 				if (ch.getWayPoint().startsWith("GC"))
-					ch.sort = ch.getOcCacheID();
+					if (ch.getOcCacheID().length() == 0)
+						ch.sort = "\uFFFF";
+					else
+						ch.sort = ch.getOcCacheID();
 				else {
 					String[] stmp = mString.split(ch.getCacheOwner(), '/');
 					int l = stmp.length - 1;

Modified: trunk/src/CacheWolf/UrlFetcher.java
===================================================================
--- trunk/src/CacheWolf/UrlFetcher.java	2011-05-11 23:04:45 UTC (rev 3000)
+++ trunk/src/CacheWolf/UrlFetcher.java	2011-05-12 20:42:00 UTC (rev 3001)
@@ -226,7 +226,7 @@
 		AsciiCodec asciicod = new AsciiCodec();
 		CharArray utf8bytes = new CharArray();
 		asciicod.decodeText(utf8.data, 0, utf8.length, true, utf8bytes);
-		return encodeURL(utf8bytes.toString(), false);
+		return encodeURL(utf8bytes.toString(), true);
 	}
 
 	final static String hex = ewe.util.TextEncoder.hex;

Modified: trunk/src/CacheWolf/imp/OCLinkImporter.java
===================================================================
--- trunk/src/CacheWolf/imp/OCLinkImporter.java	2011-05-11 23:04:45 UTC (rev 3000)
+++ trunk/src/CacheWolf/imp/OCLinkImporter.java	2011-05-12 20:42:00 UTC (rev 3001)
@@ -33,47 +33,58 @@
 import ewe.ui.ProgressBarForm;
 
 public class OCLinkImporter {
-	private CacheDB cacheDB;
+	private static CacheDB cacheDB = null;
 
-	public OCLinkImporter() {
-		this.cacheDB = Global.getProfile().cacheDB;
-	}
+	public static void doIt() {
 
-	public void doIt() {
+		if (cacheDB == null)
+			cacheDB = Global.getProfile().cacheDB;
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
 
 		pbf.showMainTask = false;
 		pbf.setTask(h, "Import OC names ...");
 		pbf.exec();
-		OCGPXfetch.login();
-		for (int o = 0; o < cacheDB.size(); o += 1) {
-			CacheHolder ch = cacheDB.get(o);
-			String wp = ch.getWayPoint();
-			if (wp.startsWith("GC")) {
-				String url = "http://www.opencaching.de/map2.php?mode=wpsearch&wp=" + wp;
+		if (OCGPXfetch.login()) {
+			for (int o = 0; o < cacheDB.size(); o += 1) {
 				h.progress = (float) o / (float) (cacheDB.size() - 1);
-				h.changed();
-				try {
-					String result = UrlFetcher.fetch(url);
-					boolean found = false;
-					int start = result.indexOf("found=\"") + 7;
-					if (result.substring(start).startsWith("1"))
-						found = true;
-					start = result.indexOf("wpoc=\"") + 6;
-					if (start > 5) {
-						int idend = result.indexOf("\"", start);
-						String ocwp = result.substring(start, idend);
-						if (!found)
-							ocwp = "-" + ocwp;
-						ch.setOcCacheID(ocwp);
-					}
-				} catch (Exception e) {
-					// dann halt nicht
-				}
+				if (o % 100 == 0)
+					h.changed();
+				if (pbf.exitValue == -1)
+					break;
+				CacheHolder ch = cacheDB.get(o);
+				if (ch.isVisible())
+					updateOCLink(ch);
 			}
 		}
 		pbf.exit(0);
 	}
 
+	public static void updateOCLink(CacheHolder ch) {
+		String wp = ch.getWayPoint();
+		if (wp.startsWith("GC")) {
+			String url = "http://www.opencaching.de/map2.php?mode=wpsearch&wp=" + wp;
+			ch.setOcCacheID("");
+			try {
+				String result = UrlFetcher.fetch(url);
+				boolean found = false;
+				int start = result.indexOf("found=\"") + 7;
+				if (result.substring(start).startsWith("1"))
+					found = true;
+				start = result.indexOf("wpoc=\"") + 6;
+				if (start > 5) {
+					int idend = result.indexOf("\"", start);
+					String ocwp = result.substring(start, idend);
+					if (!found)
+						ocwp = "-" + ocwp;
+					ch.setOcCacheID(ocwp);
+					ch.save();
+				}
+			} catch (Exception e) {
+				// dann halt nicht
+			}
+		}
+		// return ch;
+	}
+
 }

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2011-05-11 23:04:45 UTC (rev 3000)
+++ trunk/src/CacheWolf/myTableControl.java	2011-05-12 20:42:00 UTC (rev 3001)
@@ -1,30 +1,32 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
+import CacheWolf.imp.OCGPXfetch;
+import CacheWolf.imp.OCLinkImporter;
 import CacheWolf.utils.CWWrapper;
 import CacheWolf.utils.FileBugfix;
 import ewe.fx.IconAndText;
@@ -34,6 +36,7 @@
 import ewe.io.IOException;
 import ewe.sys.Handle;
 import ewe.sys.Locale;
+import ewe.sys.Time;
 import ewe.sys.Vm;
 import ewe.ui.Control;
 import ewe.ui.DragContext;
@@ -52,15 +55,17 @@
 import ewe.ui.mList;
 
 /**
- *	Implements the user interaction of the list view. Works together with myTableModel and TablePanel
+ * Implements the user interaction of the list view. Works together with myTableModel and TablePanel
  */
-public class myTableControl extends TableControl{
+public class myTableControl extends TableControl {
 
 	public Preferences pref;
 	public Profile profile;
 	public CacheDB cacheDB;
 	public TablePanel tbp;
 
+	public int clickedColumn = 0;
+
 	private MenuItem miOpen, miGoto, miCenter, miUnhideAddis;
 	private MenuItem miOpenOnline, miOpenOffline, miLogOnline, miOpenGmaps;
 	private MenuItem miDelete, miUpdate, miChangeBlack;
@@ -71,47 +76,47 @@
 	private Menu mSmall;
 
 	myTableControl(TablePanel tablePanel) {
-		profile=Global.getProfile();
+		profile = Global.getProfile();
 		cacheDB = profile.cacheDB;
 		pref = Global.getPref();
-		tbp =tablePanel;
+		tbp = tablePanel;
 		allowDragSelection = false; // allow only one row to be selected at one time
-	MenuItem[] mnuFull = {
-			miOpen = new MenuItem(MyLocale.getMsg(1021,"Open description")),
-			miGoto = new MenuItem(MyLocale.getMsg(1010,"Goto")),
-		  	miCenter = new MenuItem(MyLocale.getMsg(1019,"Center")),
-		  	miUnhideAddis = new MenuItem(MyLocale.getMsg(1042,"Unhide Addis")),
-		  	miSeparator = new MenuItem("-"),
-		  	miOpenOnline = new MenuItem(MyLocale.getMsg(1020,"Open in $browser online")),
-		  	miOpenOffline = new MenuItem(MyLocale.getMsg(1018,"Open in browser offline")),
-		  	miLogOnline = new MenuItem(MyLocale.getMsg(1052,"Log online in Browser")),
-		  	miOpenGmaps = new MenuItem(MyLocale.getMsg(1053,"Open in Google maps online")),
-		  	miSeparator,
-		  	miDelete = new MenuItem(MyLocale.getMsg(1012,"Delete selected")),
-		  	miUpdate = new MenuItem(MyLocale.getMsg(1014,"Update")),
-		  	miChangeBlack = new MenuItem(MyLocale.getMsg(1054, "Change Blacklist")),
-		  	miSeparator,
-		  	miTickAll = new MenuItem(MyLocale.getMsg(1015,"Select all")),
-		  	miUntickAll = new MenuItem(MyLocale.getMsg(1016,"De-select all"))
-	};
-  	mFull = new Menu(mnuFull, MyLocale.getMsg(1013,"With selection"));
-  	MenuItem[] mnuSmall = new MenuItem[8];
-  	mnuSmall[0] = miOpen;
-  	mnuSmall[1] = miGoto;
-  	mnuSmall[2] = miCenter;
-  	mnuSmall[3] = miUnhideAddis;
-  	mnuSmall[4] = miSeparator;
-  	mnuSmall[5] = miOpenOnline;
-  	mnuSmall[6] = miOpenOffline;
-  	mnuSmall[7] = miLogOnline;
-  	mSmall = new Menu(mnuSmall, MyLocale.getMsg(1013,"With selection"));
+		MenuItem[] mnuFull = { miOpen = new MenuItem(MyLocale.getMsg(1021, "Open description")), //
+				miGoto = new MenuItem(MyLocale.getMsg(1010, "Goto")), //
+				miCenter = new MenuItem(MyLocale.getMsg(1019, "Center")), //
+				miUnhideAddis = new MenuItem(MyLocale.getMsg(1042, "Unhide Addis")), //
+				miSeparator = new MenuItem("-"), //
+				miOpenOnline = new MenuItem(MyLocale.getMsg(1020, "Open in $browser online")), //
+				miOpenOffline = new MenuItem(MyLocale.getMsg(1018, "Open in browser offline")), //
+				miLogOnline = new MenuItem(MyLocale.getMsg(1052, "Log online in Browser")), //
+				miOpenGmaps = new MenuItem(MyLocale.getMsg(1053, "Open in Google maps online")), //
+				miSeparator, //
+				miDelete = new MenuItem(MyLocale.getMsg(1012, "Delete selected")), //
+				miUpdate = new MenuItem(MyLocale.getMsg(1014, "Update")), //
+				miChangeBlack = new MenuItem(MyLocale.getMsg(1054, "Change Blacklist")), //
+				miSeparator, //
+				miTickAll = new MenuItem(MyLocale.getMsg(1015, "Select all")), //
+				miUntickAll = new MenuItem(MyLocale.getMsg(1016, "De-select all")) //
+		};
+		mFull = new Menu(mnuFull, MyLocale.getMsg(1013, "With selection"));
+
+		MenuItem[] mnuSmall = new MenuItem[8];
+		mnuSmall[0] = miOpen;
+		mnuSmall[1] = miGoto;
+		mnuSmall[2] = miCenter;
+		mnuSmall[3] = miUnhideAddis;
+		mnuSmall[4] = miSeparator;
+		mnuSmall[5] = miOpenOnline;
+		mnuSmall[6] = miOpenOffline;
+		mnuSmall[7] = miLogOnline;
+		mSmall = new Menu(mnuSmall, MyLocale.getMsg(1013, "With selection"));
 	}
 
 	/** Full menu when listview includes checkbox */
 	public void setMenuFull() {
 		setMenu(mFull);
-//		if (!Vm.getPlatform().equals("Win32") && !Vm.getPlatform().equals("Java"))
-//		   ((MenuItem)mFull.items.get(5)).modifiers|=MenuItem.Disabled;
+		// if (!Vm.getPlatform().equals("Win32") && !Vm.getPlatform().equals("Java"))
+		// ((MenuItem)mFull.items.get(5)).modifiers|=MenuItem.Disabled;
 	}
 
 	public Menu getMenuFull() {
@@ -121,51 +126,60 @@
 	/** Small menu when listview does not include checkbox */
 	public void setMenuSmall() {
 		setMenu(mSmall);
-		//if (!Vm.getPlatform().equals("Win32") && !Vm.getPlatform().equals("Java"))
-		//	   ((MenuItem)mSmall.items.get(5)).modifiers|=MenuItem.Disabled;
+		// if (!Vm.getPlatform().equals("Win32") && !Vm.getPlatform().equals("Java"))
+		// ((MenuItem)mSmall.items.get(5)).modifiers|=MenuItem.Disabled;
 	}
 
-	public void penRightReleased(Point p){
-		if (cacheDB.size()>0) { // No context menu when DB is empty
+	public void penRightReleased(Point p) {
+		if (cacheDB.size() > 0) { // No context menu when DB is empty
 			adjustAddiHideUnhideMenu();
-			menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
+			menuState.doShowMenu(p, true, null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
 
 		}
 	}
 
-    public void penHeld(Point p){
-		if (cacheDB.size()>0) // No context menu when DB is empty
+	public void penHeld(Point p) {
+		if (cacheDB.size() > 0) // No context menu when DB is empty
 			adjustAddiHideUnhideMenu();
-			menuState.doShowMenu(p,true,null);
+		menuState.doShowMenu(p, true, null);
 	}
 
 	public void onKeyEvent(KeyEvent ev) {
-		if (ev.type == KeyEvent.KEY_PRESS && ev.target == this){
-			if ( (ev.modifiers & IKeys.CONTROL) > 0 && ev.key == 1){ // <ctrl-a> gives 1, <ctrl-b> == 2
+		if (ev.type == KeyEvent.KEY_PRESS && ev.target == this) {
+			if ((ev.modifiers & IKeys.CONTROL) > 0 && ev.key == 1) { // <ctrl-a> gives 1, <ctrl-b> == 2
 				// select all on <ctrl-a>
 				setSelectForAll(true);
 				ev.consumed = true;
-			}
-			else  {
+			} else {
 				Global.mainTab.clearDetails();
-				if (ev.key == IKeys.HOME) Global.mainTab.tbP.selectRow(0); //  cursorTo(0,cursor.x+listMode,true);
-				else if (ev.key == IKeys.END) Global.mainTab.tbP.selectRow(model.numRows-1); //cursorTo(model.numRows-1,cursor.x+listMode,true);
-				else if (ev.key == IKeys.PAGE_DOWN) Global.mainTab.tbP.selectRow(java.lang.Math.min(cursor.y+ getOnScreen(null).height-1, model.numRows-1)); //cursorTo(java.lang.Math.min(cursor.y+ getOnScreen(null).height-1, model.numRows-1),cursor.x+listMode,true); // I don't know why this doesn't work: tbp.doScroll(IScroll.Vertical, IScroll.PageHigher, 1);
-				else if (ev.key == IKeys.PAGE_UP) Global.mainTab.tbP.selectRow(java.lang.Math.max(cursor.y-getOnScreen(null).height+1, 0)); // cursorTo(java.lang.Math.max(cursor.y-getOnScreen(null).height+1, 0),cursor.x+listMode,true);
-				else if (ev.key == IKeys.ACTION || ev.key == IKeys.ENTER) Global.mainTab.select(Global.mainTab.descP);
-				else if (ev.key == IKeys.DOWN) Global.mainTab.tbP.selectRow(java.lang.Math.min(cursor.y+ 1, model.numRows-1));
-				else if (ev.key == IKeys.UP) Global.mainTab.tbP.selectRow(java.lang.Math.max(cursor.y-1, 0));
-				else if (ev.key == IKeys.LEFT && Global.mainForm.cacheListVisible && cursor.y>=0 && cursor.y<tbp.myMod.numRows) Global.mainForm.cacheList.addCache(cacheDB.get(cursor.y).getWayPoint());
+				if (ev.key == IKeys.HOME)
+					Global.mainTab.tbP.selectRow(0); // cursorTo(0,cursor.x+listMode,true);
+				else if (ev.key == IKeys.END)
+					Global.mainTab.tbP.selectRow(model.numRows - 1); // cursorTo(model.numRows-1,cursor.x+listMode,true);
+				else if (ev.key == IKeys.PAGE_DOWN)
+					Global.mainTab.tbP.selectRow(java.lang.Math.min(cursor.y + getOnScreen(null).height - 1, model.numRows - 1)); // cursorTo(java.lang.Math.min(cursor.y+ getOnScreen(null).height-1, model.numRows-1),cursor.x+listMode,true); // I don't
+																																	// know why this doesn't work: tbp.doScroll(IScroll.Vertical, IScroll.PageHigher, 1);
+				else if (ev.key == IKeys.PAGE_UP)
+					Global.mainTab.tbP.selectRow(java.lang.Math.max(cursor.y - getOnScreen(null).height + 1, 0)); // cursorTo(java.lang.Math.max(cursor.y-getOnScreen(null).height+1, 0),cursor.x+listMode,true);
+				else if (ev.key == IKeys.ACTION || ev.key == IKeys.ENTER)
+					Global.mainTab.select(Global.mainTab.descP);
+				else if (ev.key == IKeys.DOWN)
+					Global.mainTab.tbP.selectRow(java.lang.Math.min(cursor.y + 1, model.numRows - 1));
+				else if (ev.key == IKeys.UP)
+					Global.mainTab.tbP.selectRow(java.lang.Math.max(cursor.y - 1, 0));
+				else if (ev.key == IKeys.LEFT && Global.mainForm.cacheListVisible && cursor.y >= 0 && cursor.y < tbp.myMod.numRows)
+					Global.mainForm.cacheList.addCache(cacheDB.get(cursor.y).getWayPoint());
 				else if (ev.key == IKeys.RIGHT) {
 					CacheHolder ch;
 					ch = cacheDB.get(tbp.getSelectedCache());
 					Global.mainTab.gotoP.setDestinationAndSwitch(ch);
-				}
-				else if (ev.key == 6 ) MainMenu.search(); // (char)6 == ctrl + f
-				else super.onKeyEvent(ev);
+				} else if (ev.key == 6)
+					MainMenu.search(); // (char)6 == ctrl + f
+				else
+					super.onKeyEvent(ev);
 			}
-		}
-		else super.onKeyEvent(ev);
+		} else
+			super.onKeyEvent(ev);
 	}
 
 	/** Set all caches either as selected or as deselected, depending on argument */
@@ -174,48 +188,46 @@
 		tbp.refreshTable();
 	}
 
-
 	/** always select a whole row */
-	public boolean isSelected(int pRow,int pCol) {
-		return pRow==selection.y;
+	public boolean isSelected(int pRow, int pCol) {
+		return pRow == selection.y;
 	}
+
 	private void callExternalProgram(String program, String parameter) {
 		// invalid path will be handled by try
 		try {
 			CWWrapper.exec(program, parameter); // maybe this works on some PDAs?
 		} catch (IOException ex) {
-			(new MessageBox(MyLocale.getMsg(321,"Error"),
-					MyLocale.getMsg(1034,"Cannot start "+program+"!") + "\n" + ex.toString() + "\n" +
-					MyLocale.getMsg(1035,"Possible reason:") + "\n" +
-					MyLocale.getMsg(1036,"A bug in ewe VM, please be") + "\n" +
-					MyLocale.getMsg(1037,"patient for an update"),FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1034, "Cannot start " + program + "!") + "\n" + ex.toString() + "\n" + MyLocale.getMsg(1035, "Possible reason:") + "\n" + MyLocale.getMsg(1036, "A bug in ewe VM, please be")
+					+ "\n" + MyLocale.getMsg(1037, "patient for an update"), FormBase.OKB)).execute();
 		}
 	}
 
-	public void popupMenuEvent(Object selectedItem){
-		if (selectedItem == null) return;
+	public void popupMenuEvent(Object selectedItem) {
+		if (selectedItem == null)
+			return;
 		CacheHolder ch;
-		if (selectedItem == miTickAll){
+		if (selectedItem == miTickAll) {
 			setSelectForAll(true);
 		} else
 
-		if (selectedItem == miUntickAll){
+		if (selectedItem == miUntickAll) {
 			setSelectForAll(false);
 		} else
 
-		if (selectedItem == miDelete){
+		if (selectedItem == miDelete) {
 			Vm.showWait(true);
 			// Count # of caches to delete
-			int allCount=0;
-			int mainNonVisibleCount=0;
-			int addiNonVisibleCount=0;
-			int shouldDeleteCount=0;
-			boolean deleteFiltered=true;  // Bisheriges Verhalten
-			for(int i = cacheDB.size()-1; i >=0; i--){
+			int allCount = 0;
+			int mainNonVisibleCount = 0;
+			int addiNonVisibleCount = 0;
+			int shouldDeleteCount = 0;
+			boolean deleteFiltered = true; // Bisheriges Verhalten
+			for (int i = cacheDB.size() - 1; i >= 0; i--) {
 				CacheHolder currCache = cacheDB.get(i);
-				if ( currCache.is_Checked) {
+				if (currCache.is_Checked) {
 					allCount++;
-					if (! currCache.isVisible()) {
+					if (!currCache.isVisible()) {
 						if (currCache.isAddiWpt()) {
 							addiNonVisibleCount++;
 						} else {
@@ -226,62 +238,60 @@
 			}
 			// Warn if there are ticked but invisible caches - and ask if they should be deleted too.
 			shouldDeleteCount = allCount;
-			if (addiNonVisibleCount + mainNonVisibleCount > 0){
-				if ((new MessageBox(MyLocale.getMsg(144,"Warning"),
-						            MyLocale.getMsg(1029, "There are caches that are ticked but invisible.\n(Main caches: ") +
-						            	mainNonVisibleCount + MyLocale.getMsg(1030, ", additional Waypoints: ") +
-						            	addiNonVisibleCount+")\n" + MyLocale.getMsg(1031, "Delete them, too?"),
-						            	FormBase.YESB | FormBase.NOB)).execute() == FormBase.IDYES) {
+			if (addiNonVisibleCount + mainNonVisibleCount > 0) {
+				if ((new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(1029, "There are caches that are ticked but invisible.\n(Main caches: ") + mainNonVisibleCount + MyLocale.getMsg(1030, ", additional Waypoints: ") + addiNonVisibleCount
+						+ ")\n" + MyLocale.getMsg(1031, "Delete them, too?"), FormBase.YESB | FormBase.NOB)).execute() == FormBase.IDYES) {
 					deleteFiltered = true;
 				} else {
 					deleteFiltered = false;
 					shouldDeleteCount = allCount - mainNonVisibleCount - addiNonVisibleCount;
 				}
 			}
-			if (shouldDeleteCount>0) {
-				if ((new MessageBox(MyLocale.getMsg(144,"Warning"),MyLocale.getMsg(1022, "Delete selected caches (") + shouldDeleteCount + MyLocale.getMsg(1028, ") ?"), FormBase.YESB | FormBase.NOB)).execute() == FormBase.IDYES) {
-					DataMover dm=new DataMover();
+			if (shouldDeleteCount > 0) {
+				if ((new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(1022, "Delete selected caches (") + shouldDeleteCount + MyLocale.getMsg(1028, ") ?"), FormBase.YESB | FormBase.NOB)).execute() == FormBase.IDYES) {
+					DataMover dm = new DataMover();
 					myProgressBarForm pbf = new myProgressBarForm();
 					Handle h = new Handle();
-					int nDeleted=0;
-					int size=cacheDB.size();
-					pbf.setTask(h,"Be patient. Reading directory");
+					int nDeleted = 0;
+					int size = cacheDB.size();
+					pbf.setTask(h, "Be patient. Reading directory");
 					pbf.exec();
-					h.progress = (float)0.5;
+					h.progress = (float) 0.5;
 					h.changed();
-					String[] CacheFiles = new FileBugfix(profile.dataDir).list(null, FileBase.LIST_FILES_ONLY|FileBase.LIST_DONT_SORT);
-					pbf.setTask(h,MyLocale.getMsg(1012, "Delete selected"));
-					for(int i = size-1; i >=0; i--){// Start Counting down, as the size decreases with each deleted cache
+					String[] CacheFiles = new FileBugfix(profile.dataDir).list(null, FileBase.LIST_FILES_ONLY | FileBase.LIST_DONT_SORT);
+					pbf.setTask(h, MyLocale.getMsg(1012, "Delete selected"));
+					for (int i = size - 1; i >= 0; i--) {// Start Counting down, as the size decreases with each deleted cache
 						ch = cacheDB.get(i);
-						if(ch.is_Checked && (ch.isVisible() || deleteFiltered)) {
+						if (ch.is_Checked && (ch.isVisible() || deleteFiltered)) {
 							nDeleted++;
-							h.progress = ((float)nDeleted)/(float)allCount;
+							h.progress = ((float) nDeleted) / (float) allCount;
 							h.changed();
 							cacheDB.removeElementAt(i);
-							dm.deleteCacheFiles(ch.getWayPoint(),profile.dataDir,CacheFiles);
-							ch=null;
-							if (pbf.isClosed) break;
+							dm.deleteCacheFiles(ch.getWayPoint(), profile.dataDir, CacheFiles);
+							ch = null;
+							if (pbf.isClosed)
+								break;
 						}
 					}
 					pbf.exit(0);
-					tbp.myMod.numRows-=nDeleted;
-					profile.saveIndex(pref,true);
+					tbp.myMod.numRows -= nDeleted;
+					profile.saveIndex(pref, true);
 					tbp.refreshTable();
 				}
 			}
 			Vm.showWait(false);
 		} else
 
-		if (selectedItem == miUpdate){
+		if (selectedItem == miUpdate) {
 			MainMenu.updateSelectedCaches(tbp);
 		} else
-		
-		if (selectedItem == miChangeBlack){
+
+		if (selectedItem == miChangeBlack) {
 			Vm.showWait(true);
 			try {
-				for(int i = cacheDB.size()-1; i >=0; i--){
+				for (int i = cacheDB.size() - 1; i >= 0; i--) {
 					CacheHolder currCache = cacheDB.get(i);
-					if ( currCache.isVisible() && currCache.is_Checked) {
+					if (currCache.isVisible() && currCache.is_Checked) {
 						if (currCache.isAddiWpt()) {
 							// currCache.setBlack(!currCache.is_black());
 						} else {
@@ -295,18 +305,19 @@
 				tbp.refreshTable();
 			} finally {
 				Vm.showWait(false);
-			};
+			}
+			;
 		} else
 
-		if (selectedItem == miCenter){
+		if (selectedItem == miCenter) {
 			if (tbp.getSelectedCache() < 0) {
 				Global.getPref().log("[myTableControl:popupMenuEvent] getSelectedCache() < 0");
 				return;
 			}
 			CacheHolder thisCache = cacheDB.get(tbp.getSelectedCache());
-			CWPoint cp=new CWPoint(thisCache.getLatLon());
-			if (!cp.isValid()){
-				MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(4111,"Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"), FormBase.OKB);
+			CWPoint cp = new CWPoint(thisCache.getLatLon());
+			if (!cp.isValid()) {
+				MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(4111, "Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"), FormBase.OKB);
 				tmpMB.execute();
 			} else {
 				pref.setCurCentrePt(cp);
@@ -317,79 +328,128 @@
 			// This toggles the "showAddis" Flag
 			ch = cacheDB.get(tbp.getSelectedCache());
 			ch.setShowAddis(!ch.showAddis());
-			if (ch.addiWpts.size()>0) {
+			if (ch.addiWpts.size() > 0) {
 				tbp.refreshTable();
 			} else {
 				// This should never occur, as we check prior to activating the menu if the
 				// cache has addis. But just in case...
-				new MessageBox(MyLocale.getMsg(4201, "Info"), MyLocale.getMsg(1043, "This cache has no additional waypoints."),FormBase.OKB).execute();
+				new MessageBox(MyLocale.getMsg(4201, "Info"), MyLocale.getMsg(1043, "This cache has no additional waypoints."), FormBase.OKB).execute();
 			}
 		} else
 
-		if (selectedItem == miGoto){
+		if (selectedItem == miGoto) {
 			ch = cacheDB.get(tbp.getSelectedCache());
 			Global.mainTab.gotoP.setDestinationAndSwitch(ch);
 		} else
 
-		if (selectedItem == miOpenOnline){
-				ch = cacheDB.get(tbp.getSelectedCache());
-				CacheHolderDetail chD=ch.getCacheDetails(true);
-				if (chD != null) { callExternalProgram(pref.browser, chD.URL); }
+		if (selectedItem == miOpenOnline) {
+			ch = cacheDB.get(tbp.getSelectedCache());
+			CacheHolder mainCache = ch;
+			if (ch.isAddiWpt() && (ch.mainCache != null)) {
+				mainCache = ch.mainCache;
+			}
+			CacheHolderDetail chD = mainCache.getCacheDetails(true);
+			String url = chD.URL;
+			if (clickedColumn == 14 && mainCache.getOcCacheID().length() > 0) {
+				if (!mainCache.getOcCacheID().startsWith("OC")) {
+					url = "http://www.opencaching.de/viewcache.php?wp=" + mainCache.getOcCacheID().substring(1);
+				} else {
+					url = "http://www.opencaching.de/viewcache.php?wp=" + mainCache.getOcCacheID();
+				}
+			}
+			if (url != null) {
+				callExternalProgram(pref.browser, url);
+			}
 		} else
 
 		if (selectedItem == miOpenGmaps) {
 			ch = cacheDB.get(tbp.getSelectedCache());
 			if (ch.pos.isValid()) {
-				String lat=""+ch.pos.getLatDeg(CWPoint.DD);
-				String lon=""+ch.pos.getLonDeg(CWPoint.DD);
-				String nameOfCache=ewe.net.URL.encodeURL(ch.cacheName,false).replace('#','N').replace('@','_');
-				String language=Vm.getLocale().getString(Locale.LANGUAGE_SHORT, 0, 0);
-				if (!pref.language.equalsIgnoreCase("auto")) {language=pref.language;}
-				String url="http://maps.google."+language+"/maps?q="+nameOfCache+"@"+lat+","+lon;
+				String lat = "" + ch.pos.getLatDeg(CWPoint.DD);
+				String lon = "" + ch.pos.getLonDeg(CWPoint.DD);
+				String nameOfCache = ewe.net.URL.encodeURL(ch.cacheName, false).replace('#', 'N').replace('@', '_');
+				String language = Vm.getLocale().getString(Locale.LANGUAGE_SHORT, 0, 0);
+				if (!pref.language.equalsIgnoreCase("auto")) {
+					language = pref.language;
+				}
+				String url = "http://maps.google." + language + "/maps?q=" + nameOfCache + "@" + lat + "," + lon;
 				callExternalProgram(pref.browser, url);
-				url="http://www.geocaching.com/map/default.aspx?lat="+lat+"&lng="+lon;
+				url = "http://www.geocaching.com/map/default.aspx?lat=" + lat + "&lng=" + lon;
 				callExternalProgram(pref.browser, url);
 			}
 		} else
 
 		if (selectedItem == miOpenOffline) {
-			ShowCacheInBrowser sc=new ShowCacheInBrowser();
+			ShowCacheInBrowser sc = new ShowCacheInBrowser();
 			sc.showCache(cacheDB.get(tbp.getSelectedCache()));
 		} else
 
-		if (selectedItem == miLogOnline){
-				ch = cacheDB.get(tbp.getSelectedCache());
-				CacheHolder mainCache = ch;
-				if (ch.isAddiWpt() && (ch.mainCache != null)) {
-					mainCache = ch.mainCache;
-				}
-				if (mainCache.isCacheWpt()) {
-					CacheHolderDetail chD=mainCache.getCacheDetails(true);
-						if (chD != null) {
-							String URL = "";
-							if (ch.isOC()) {
-								URL = chD.URL;
-								if (URL.indexOf("viewcache") >= 0) {
-									URL = STRreplace.replace(URL, "viewcache", "log");
-								} else {
-									URL = "";
+		if (selectedItem == miLogOnline) {
+			ch = cacheDB.get(tbp.getSelectedCache());
+			CacheHolder mainCache = ch;
+			if (ch.isAddiWpt() && (ch.mainCache != null)) {
+				mainCache = ch.mainCache;
+			}
+			if (mainCache.isCacheWpt()) {
+				CacheHolderDetail chD = mainCache.getCacheDetails(true);
+				if (chD != null) {
+					String URL = "";
+					String notes = chD.getCacheNotes();
+					if (notes.length() > 0) {
+						Vm.setClipboardText(notes);
+					}
+					if (ch.isOC()) {
+						URL = chD.URL;
+						if (URL.indexOf("viewcache") >= 0) {
+							URL = STRreplace.replace(URL, "viewcache", "log");
+						} else {
+							URL = "";
+						}
+					} else {
+						if (chD.OwnLogId.length() > 0 && mainCache.getOcCacheID().startsWith("-")) {
+							URL = "http://www.opencaching.de/log.php?wp=" + mainCache.getOcCacheID().substring(1);
+							if (clickedColumn == 14) {
+								// take GC log direct to OC
+								if (OCGPXfetch.login()) {
+									String page = "";
+									try {
+										page = UrlFetcher.fetch(URL);
+										String ocCacheId = new Extractor(page, "viewcache.php?cacheid=", "\">", 0, true).findNext();
+										String postData = "cacheid=" + ocCacheId + "&version3=1&descMode=3&logtype=1";
+										Time logDate = DateFormat.toDate(chD.OwnLog.getDate());
+										postData += "&logday=" + logDate.day;
+										postData += "&logmonth=" + logDate.month;
+										postData += "&logyear=" + logDate.year;
+										postData += "&logtext=" + UrlFetcher.toUtf8Url(chD.OwnLog.getMessage());
+										postData += "&submitform=Log+eintragen";
+										UrlFetcher.setpostData(postData);
+										page = UrlFetcher.fetch(URL);
+										OCLinkImporter.updateOCLink(ch);
+										if (ch.getOcCacheID().startsWith("-")) {
+											ch.setOcCacheID("!" + ch.getOcCacheID().substring(1));
+											ch.save();
+										}
+									} catch (IOException e) {
+										// dann nicht
+									}
 								}
+								URL = "";
 							} else {
-								URL = "http://www.geocaching.com/seek/log.aspx?ID=" + mainCache.GetCacheID();
+								// open OC logpage with GC Logtext in Clipboard
+								Vm.setClipboardText(chD.OwnLog.getDate() + '\n' + "<br>" + chD.OwnLog.getMessage());
 							}
+						} else
+							URL = "http://www.geocaching.com/seek/log.aspx?ID=" + mainCache.GetCacheID();
+					}
 
-							if (URL.length() > 0) {
-								String notes = chD.getCacheNotes();
-								if (notes.length() > 0) {
-									Vm.setClipboardText(notes);
-								}
-								callExternalProgram(pref.browser, URL);
-							}
-						}
+					if (URL.length() > 0) {
+						callExternalProgram(pref.browser, URL);
+					}
 				}
+			}
 		} else
 
-		if (selectedItem == miOpen){
+		if (selectedItem == miOpen) {
 			penDoubleClicked(null);
 		}
 
@@ -400,18 +460,16 @@
 	}
 
 	public void onEvent(Event ev) {
-		if (ev instanceof PenEvent && (ev.type == PenEvent.PEN_DOWN) ){
-			Global.mainTab.tbP.myMod.penEventModifiers=((PenEvent)ev).modifiers;
-	    }
+		if (ev instanceof PenEvent && (ev.type == PenEvent.PEN_DOWN)) {
+			Global.mainTab.tbP.myMod.penEventModifiers = ((PenEvent) ev).modifiers;
+		}
 
 		super.onEvent(ev);
 	}
 
 	/**
-	 * Adjusting the menu item for hiding or unhiding additional waypoints. If the cache has no
-	 * addis, then the menu is deactivated. If it has addis, then the menu text is adapted according
-	 * to the current value of the property <code>showAddis()</code>.
-	 *
+	 * Adjusting the menu item for hiding or unhiding additional waypoints. If the cache has no addis, then the menu is deactivated. If it has addis, then the menu text is adapted according to the current value of the property <code>showAddis()</code>.
+	 * 
 	 */
 	public void adjustAddiHideUnhideMenu() {
 		if (tbp.getSelectedCache() < 0) {
@@ -437,97 +495,103 @@
 
 	// /////////////////////////////////////////////////
 	// Allow the caches to be dragged into a cachelist
-    ///////////////////////////////////////////////////
+	// /////////////////////////////////////////////////
 
 	IconAndText imgDrag;
 	String wayPoint;
 	int row;
 
 	public void startDragging(DragContext dc) {
-		 Point p=cellAtPoint(dc.start.x,dc.start.y,null);
-		 if (p==null) {super.startDragging(dc); return;}
-		 wayPoint=null;
-		 if (p.y>=0) {
+		Point p = cellAtPoint(dc.start.x, dc.start.y, null);
+		if (p == null) {
+			super.startDragging(dc);
+			return;
+		}
+		wayPoint = null;
+		if (p.y >= 0) {
 			if (!Global.mainForm.cacheListVisible) {
-				dc.cancelled=true;
+				dc.cancelled = true;
 				return;
 			}
-			 row=p.y;
-			 CacheHolder ch=cacheDB.get(p.y);
-			 wayPoint=ch.getWayPoint();
-			 imgDrag=new IconAndText();
-			 imgDrag.addColumn(CacheType.getTypeImage(ch.getType()));
-			 imgDrag.addColumn(ch.getWayPoint());
-			 dc.dragData=dc.startImageDrag(imgDrag,new Point(8,8),this);
-		 } else super.startDragging(dc);
-	 }
+			row = p.y;
+			CacheHolder ch = cacheDB.get(p.y);
+			wayPoint = ch.getWayPoint();
+			imgDrag = new IconAndText();
+			imgDrag.addColumn(CacheType.getTypeImage(ch.getType()));
+			imgDrag.addColumn(ch.getWayPoint());
+			dc.dragData = dc.startImageDrag(imgDrag, new Point(8, 8), this);
+		} else
+			super.startDragging(dc);
+	}
 
-	 public void stopDragging(DragContext dc) {
-		 if (wayPoint!=null && !dc.cancelled) {
-			 dc.stopImageDrag(true);
-			 Point p = Gui.getPosInParent(this,getWindow());
-			 p.x += dc.curPoint.x;
-			 p.y += dc.curPoint.y;
-			 Control c = getWindow().findChild(p.x,p.y);
-		     if (c instanceof mList && c.text.equals("CacheList")) {
-		    	 if (Global.mainForm.cacheList.addCache(wayPoint)) {
-		    		 c.repaintNow();
-		    		 ((mList) c).makeItemVisible(((mList)c).itemsSize()-1);
-		    	 }
-		     }
-		     Global.mainTab.tbP.selectRow(row);
-		 }else super.stopDragging(dc);
-	 }
+	public void stopDragging(DragContext dc) {
+		if (wayPoint != null && !dc.cancelled) {
+			dc.stopImageDrag(true);
+			Point p = Gui.getPosInParent(this, getWindow());
+			p.x += dc.curPoint.x;
+			p.y += dc.curPoint.y;
+			Control c = getWindow().findChild(p.x, p.y);
+			if (c instanceof mList && c.text.equals("CacheList")) {
+				if (Global.mainForm.cacheList.addCache(wayPoint)) {
+					c.repaintNow();
+					((mList) c).makeItemVisible(((mList) c).itemsSize() - 1);
+				}
+			}
+			Global.mainTab.tbP.selectRow(row);
+		} else
+			super.stopDragging(dc);
+	}
 
-	 public void dragged(DragContext dc) {
-	 	if (wayPoint!=null)
-		   dc.imageDrag();
-	 	else
-	 		super.dragged(dc);
-	 }
+	public void dragged(DragContext dc) {
+		if (wayPoint != null)
+			dc.imageDrag();
+		else
+			super.dragged(dc);
+	}
 
-	 public void cursorTo(int pRow,int pCol,boolean selectNew) {
-		if (pRow != -2 && pCol != -2 && !canSelect(pRow,pCol)) return;
-		cursor.set(pCol,pRow);
-		if (selectNew){
+	public void cursorTo(int pRow, int pCol, boolean selectNew) {
+		if (pRow != -2 && pCol != -2 && !canSelect(pRow, pCol))
+			return;
+		cursor.set(pCol, pRow);
+		if (selectNew) {
 			clearSelectedCells(oldExtendedSelection);
-			paintCells(null,oldExtendedSelection);
-			if (pRow != -2 && pCol != -2){
-				if (scrollToVisible(pRow,pCol)) repaintNow();
-				addToSelection(Rect.buff.set(0,pRow,model.numCols,1),true);
-				//fireSelectionEvent(TableEvent.FLAG_SELECTED_BY_ARROWKEY);
+			paintCells(null, oldExtendedSelection);
+			if (pRow != -2 && pCol != -2) {
+				if (scrollToVisible(pRow, pCol))
+					repaintNow();
+				addToSelection(Rect.buff.set(0, pRow, model.numCols, 1), true);
+				// fireSelectionEvent(TableEvent.FLAG_SELECTED_BY_ARROWKEY);
 				clickedFlags = TableEvent.FLAG_SELECTED_BY_ARROWKEY;
-				if (clickMode) clicked(pRow,pCol);
+				if (clickMode)
+					clicked(pRow, pCol);
 				clickedFlags = 0;
 			}
 		}
-	 }
+	}
 
-	 /**
-	  * this is only necessary to hinder the user to unselect
-	  */
-	 public void penReleased(Point p,boolean isDouble)
-	 {
-		 Point p2 = cellAtPoint(p.x,p.y,null);
-		 super.penReleased(p, isDouble);
-		 Rect sel = getSelection(null);
-		 if ((sel.height == 0 || sel.height == 0) && p2 != null) cursorTo(p2.y,p2.x, true); // if the selection is gone -> reselect it
+	/**
+	 * this is only necessary to hinder the user to unselect
+	 */
+	public void penReleased(Point p, boolean isDouble) {
+		Point p2 = cellAtPoint(p.x, p.y, null);
+		super.penReleased(p, isDouble);
+		Rect sel = getSelection(null);
+		if ((sel.height == 0 || sel.height == 0) && p2 != null)
+			cursorTo(p2.y, p2.x, true); // if the selection is gone -> reselect it
 
-	 }
+	}
 
-	 class myProgressBarForm extends ProgressBarForm {
+	class myProgressBarForm extends ProgressBarForm {
 
-		 boolean isClosed=false;
+		boolean isClosed = false;
 
-		 protected boolean canExit(int exitCode) {
-			isClosed=true;
+		protected boolean canExit(int exitCode) {
+			isClosed = true;
 			return true;
-		 }
+		}
 
-	 }
+	}
 
-
-
 	public Menu getMenuSmall() {
 		return mSmall;
 	}

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2011-05-11 23:04:45 UTC (rev 3000)
+++ trunk/src/CacheWolf/myTableModel.java	2011-05-12 20:42:00 UTC (rev 3001)
@@ -501,17 +501,18 @@
 			return false;
 		try {
 			// Check whether the click is on the checkbox image
+			tcControl.clickedColumn = colMap[cell.x];
 			if (cell.y >= 0 && colMap[cell.x] == 0) {
 				Global.getProfile().selectionChanged = true;
 				if ((penEventModifiers & IKeys.SHIFT) > 0) {
-					if (tcControl.cursor.y >= 0) { // Second row being marked
-													// with shift key pressed
+					if (tcControl.cursor.y >= 0) {
+						// Second row being marked with shift key pressed
 						if (tcControl.cursor.y < cell.y)
 							toggleSelect(tcControl.cursor.y + 1, cell.y, cell.x);
 						else
 							toggleSelect(cell.y, tcControl.cursor.y - 1, cell.x);
-					} else { // Remember this row as start of range, but don't
-								// toggle yet
+					} else {
+						// Remember this row as start of range, but don't toggle yet
 					}
 				} else { // Single row marked
 					toggleSelect(cell.y, cell.y, cell.x);



From araber95 at mail.berlios.de  Sat May 14 12:22:41 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Sat, 14 May 2011 12:22:41 AM +0200
Subject: [Cachewolf-svn] r3002 - in trunk: res_noewe/languages src/CacheWolf
	src/CacheWolf/exp src/CacheWolf/imp
Message-ID: <20110513222241.977754813CD@sheep.berlios.de>

Author: araber95
Date: 2011-05-14 00:22:41 +0200 (Sat, 14 May 2011)
New Revision: 3002

Added:
   trunk/src/CacheWolf/exp/OCLogExport.java
Modified:
   trunk/res_noewe/languages/DE.cfg
   trunk/res_noewe/languages/EN.cfg
   trunk/res_noewe/languages/FR.cfg
   trunk/res_noewe/languages/NL.cfg
   trunk/res_noewe/languages/PL.cfg
   trunk/res_noewe/languages/SV.cfg
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/imp/OCGPXfetch.java
   trunk/src/CacheWolf/imp/OCLinkImporter.java
   trunk/src/CacheWolf/myTableControl.java
Log:
1. add Exporter for automated writing of gc-logs to the OC database
2. improvements on the OC-Link Importer
3. improvements in gc-cache context menu for handling oc-caches

Modified: trunk/res_noewe/languages/DE.cfg
===================================================================
--- trunk/res_noewe/languages/DE.cfg	2011-05-12 20:42:00 UTC (rev 3001)
+++ trunk/res_noewe/languages/DE.cfg	2011-05-13 22:22:41 UTC (rev 3002)
@@ -456,6 +456,7 @@
 1207=?nderungen im Profil Speichern?
 1208=Bewertungen von gcvote
 1209=Link zu OC - Cache
+1210=Logs nach OC
 1300=Letzte Einstellung
 1301=Profil ausw?hlen:
 1400=Zone

Modified: trunk/res_noewe/languages/EN.cfg
===================================================================
--- trunk/res_noewe/languages/EN.cfg	2011-05-12 20:42:00 UTC (rev 3001)
+++ trunk/res_noewe/languages/EN.cfg	2011-05-13 22:22:41 UTC (rev 3002)
@@ -456,6 +456,7 @@
 1207=Your profile has unsaved changes. Do you want to save?
 1208=ratings from GCVote
 1209=link to OC - Cache
+1210=logs to OC
 1300=Last Setting
 1301=Select Profile:
 1400=Zone

Modified: trunk/res_noewe/languages/FR.cfg
===================================================================
--- trunk/res_noewe/languages/FR.cfg	2011-05-12 20:42:00 UTC (rev 3001)
+++ trunk/res_noewe/languages/FR.cfg	2011-05-13 22:22:41 UTC (rev 3002)
@@ -456,6 +456,7 @@
 1207=Sauvegarder les changements dans le profil?
 1208=ratings from GCVote
 1209 = lien vers OC - Cache
+1210 = journaux pour OC
 1300=Dernier param?tage
 1301=Choisir profil:
 1400=Zone

Modified: trunk/res_noewe/languages/NL.cfg
===================================================================
--- trunk/res_noewe/languages/NL.cfg	2011-05-12 20:42:00 UTC (rev 3001)
+++ trunk/res_noewe/languages/NL.cfg	2011-05-13 22:22:41 UTC (rev 3002)
@@ -456,6 +456,7 @@
 1207=Jouw profiel is veranderd, wil je het profiel opslaan?
 1208=ratings from GCVote
 1209 = link naar OC - Cache
+1210 = logboeken naar OC
 1300=Laatste instellingen
 1301=Selecteer profiel
 1400=Zone

Modified: trunk/res_noewe/languages/PL.cfg
===================================================================
--- trunk/res_noewe/languages/PL.cfg	2011-05-12 20:42:00 UTC (rev 3001)
+++ trunk/res_noewe/languages/PL.cfg	2011-05-13 22:22:41 UTC (rev 3002)
@@ -456,6 +456,7 @@
 1207=Twoj Profil ma niezapisane zmiany. Chcesz zapisac?
 1208=ratings from GCVote
 1209 = link do OC - Cache
+1210 = dziennik?w OC
 1300=Ostatnie ustawienia
 1301=Wybierz Profil:
 1400=Strefa

Modified: trunk/res_noewe/languages/SV.cfg
===================================================================
--- trunk/res_noewe/languages/SV.cfg	2011-05-12 20:42:00 UTC (rev 3001)
+++ trunk/res_noewe/languages/SV.cfg	2011-05-13 22:22:41 UTC (rev 3002)
@@ -456,6 +456,7 @@
 1207=Din profil har sparats. Vill du spara?
 1208=ratings from GCVote
 1209 = l?nk till OC - Cache
+1210 = loggar till OC
 1300=senaste inst?llningen
 1301=V?lj profil:
 1400=Zone

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2011-05-12 20:42:00 UTC (rev 3001)
+++ trunk/src/CacheWolf/MainMenu.java	2011-05-13 22:22:41 UTC (rev 3002)
@@ -32,6 +32,7 @@
 import CacheWolf.exp.KMLExporter;
 import CacheWolf.exp.LocExporter;
 import CacheWolf.exp.MSARCSVExporter;
+import CacheWolf.exp.OCLogExport;
 import CacheWolf.exp.OVLExporter;
 import CacheWolf.exp.OziExporter;
 import CacheWolf.exp.SpoilerPOIExporter;
@@ -84,7 +85,7 @@
 	private MenuItem spider, spiderRoute, spiderQuick, spiderAllFinds, loadGCVotes, fetchOCLink, update, chkVersion;
 	private MenuItem about, wolflang, sysinfo, legend;
 	private MenuItem exportGpxNg, exporthtml, exporttop50, exportASC, exportTomTom, exportMSARCSV, exportSpoilerPOI;
-	private MenuItem exportOZI, exportKML, exportTPL, exportExplorist;
+	private MenuItem exportOZI, exportKML, exportTPL, exportExplorist, exportOCLog;
 	private MenuItem filtCreate, filtClear, filtInvert, filtSelected, filtNonSelected, filtBlack, filtApply;
 	private MenuItem exportLOC, exportGPS, mnuSeparator = new MenuItem("-");
 	private MenuItem orgNewWP, orgCopy, orgMove, orgDelete, orgRebuild, orgCheckNotesAndSolver;
@@ -154,8 +155,9 @@
 				exportOZI = new MenuItem(MyLocale.getMsg(124, "to OZI")), //
 				exportKML = new MenuItem(MyLocale.getMsg(125, "to Google Earth")), //
 				exportExplorist = new MenuItem(MyLocale.getMsg(132, "to Explorist")), //
+				exportSpoilerPOI = new MenuItem(MyLocale.getMsg(135, "to SpoilerPOI")), //
 				exportTPL = new MenuItem(MyLocale.getMsg(128, "via Template")), //
-				exportSpoilerPOI = new MenuItem(MyLocale.getMsg(135, "to SpoilerPOI")), //
+				exportOCLog = new MenuItem(MyLocale.getMsg(1210, "logs to OC")), //
 		};
 		if (Global.getPref().gpsbabel == null) {
 			exportGPS.modifiers = MenuItem.Disabled;
@@ -510,6 +512,11 @@
 					tpl.doIt();
 				}
 			}
+			//
+			if (mev.selectedItem == exportOCLog) {
+				OCLogExport.doit();
+				tbp.resetModel();
+			}
 			if (mev.selectedItem == exportExplorist) {
 				ExploristExporter mag = new ExploristExporter(pref, profile);
 				mag.doIt();

Added: trunk/src/CacheWolf/exp/OCLogExport.java
===================================================================
--- trunk/src/CacheWolf/exp/OCLogExport.java	                        (rev 0)
+++ trunk/src/CacheWolf/exp/OCLogExport.java	2011-05-13 22:22:41 UTC (rev 3002)
@@ -0,0 +1,91 @@
+package CacheWolf.exp;
+
+import CacheWolf.CacheDB;
+import CacheWolf.CacheHolder;
+import CacheWolf.CacheHolderDetail;
+import CacheWolf.DateFormat;
+import CacheWolf.Extractor;
+import CacheWolf.Global;
+import CacheWolf.OC;
+import CacheWolf.UrlFetcher;
+import CacheWolf.imp.OCGPXfetch;
+import CacheWolf.imp.OCLinkImporter;
+import ewe.io.IOException;
+import ewe.sys.Handle;
+import ewe.sys.Time;
+import ewe.sys.Vm;
+import ewe.ui.ProgressBarForm;
+
+public class OCLogExport {
+	private static boolean loggedIn = false;
+	private static CacheDB cacheDB = null;
+
+	public static void doit() {
+
+		if (cacheDB == null)
+			cacheDB = Global.getProfile().cacheDB;
+		int totalWaypoints = cacheDB.countVisible();
+		int updated = 0;
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+
+		pbf.showMainTask = false;
+		pbf.setTask(h, "logging opencaching ...");
+		pbf.exec();
+		if (OCGPXfetch.login()) {
+			for (int o = 0; o < cacheDB.size(); o += 1) {
+				h.progress = (float) o / (float) totalWaypoints;
+				h.changed();
+				if (pbf.exitValue == -1)
+					break;
+				CacheHolder ch = cacheDB.get(o);
+				if (ch.isVisible()) {
+					doOneLog(ch);
+					updated++;
+				}
+			}
+		}
+		pbf.exit(0);
+	}
+
+	public static void doOneLog(CacheHolder ch) {
+		// take GC log direct to OC, needs valid ch
+		Vm.showWait(true);
+		String wpName = ch.getOcCacheID();
+		if (wpName.length() > 1) {
+			if (!loggedIn)
+				loggedIn = OCGPXfetch.login();
+			if (loggedIn) {
+				if (wpName.charAt(0) < 65) {
+					// noch nicht bei OC gelogged
+					wpName = ch.getOcCacheID().substring(1);
+					String url = "http://" + OC.getOCHostName(wpName) + "/log.php?wp=" + wpName;
+					String page = "";
+					try {
+						CacheHolderDetail chD = ch.getCacheDetails(false);
+						page = UrlFetcher.fetch(url);
+						loggedIn = page.indexOf("Eingeloggt als") > -1; // next time perhaps
+						String ocCacheId = new Extractor(page, "viewcache.php?cacheid=", "\">", 0, true).findNext();
+						String postData = "cacheid=" + ocCacheId + "&version3=1&descMode=3&logtype=1";
+						Time logDate = DateFormat.toDate(chD.OwnLog.getDate());
+						postData += "&logday=" + logDate.day;
+						postData += "&logmonth=" + logDate.month;
+						postData += "&logyear=" + logDate.year;
+						postData += "&logtext=" + UrlFetcher.toUtf8Url(chD.OwnLog.getMessage());
+						postData += "&submitform=Log+eintragen"; // todo for other opencaching sites
+						UrlFetcher.setpostData(postData);
+						page = UrlFetcher.fetch(url);
+						OCLinkImporter.updateOCLink(ch);
+						if (ch.getOcCacheID().startsWith("-")) {
+							ch.setOcCacheID("!" + ch.getOcCacheID().substring(1));
+							ch.save();
+						}
+					} catch (IOException e) {
+						// dann nicht
+					}
+				}
+			}
+		}
+		Vm.showWait(false);
+	}
+}


Property changes on: trunk/src/CacheWolf/exp/OCLogExport.java
___________________________________________________________________
Added: svn:mime-type
   + text/plain

Modified: trunk/src/CacheWolf/imp/OCGPXfetch.java
===================================================================
--- trunk/src/CacheWolf/imp/OCGPXfetch.java	2011-05-12 20:42:00 UTC (rev 3001)
+++ trunk/src/CacheWolf/imp/OCGPXfetch.java	2011-05-13 22:22:41 UTC (rev 3002)
@@ -64,6 +64,7 @@
 
 	public static boolean login() {
 		// TODO this is only a preliminary Version of login
+		// todo for other opencaching sites
 		boolean loggedIn = false;
 		String page;
 		try {

Modified: trunk/src/CacheWolf/imp/OCLinkImporter.java
===================================================================
--- trunk/src/CacheWolf/imp/OCLinkImporter.java	2011-05-12 20:42:00 UTC (rev 3001)
+++ trunk/src/CacheWolf/imp/OCLinkImporter.java	2011-05-13 22:22:41 UTC (rev 3002)
@@ -28,8 +28,10 @@
 import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
 import CacheWolf.Global;
+import CacheWolf.OC;
 import CacheWolf.UrlFetcher;
 import ewe.sys.Handle;
+import ewe.sys.Vm;
 import ewe.ui.ProgressBarForm;
 
 public class OCLinkImporter {
@@ -39,6 +41,8 @@
 
 		if (cacheDB == null)
 			cacheDB = Global.getProfile().cacheDB;
+		int totalWaypoints = cacheDB.countVisible();
+		int updated = 0;
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
 
@@ -47,44 +51,70 @@
 		pbf.exec();
 		if (OCGPXfetch.login()) {
 			for (int o = 0; o < cacheDB.size(); o += 1) {
-				h.progress = (float) o / (float) (cacheDB.size() - 1);
-				if (o % 100 == 0)
-					h.changed();
+				h.progress = (float) updated / (float) totalWaypoints;
+				h.changed();
 				if (pbf.exitValue == -1)
 					break;
 				CacheHolder ch = cacheDB.get(o);
-				if (ch.isVisible())
+				if (ch.isVisible()) {
 					updateOCLink(ch);
+					updated++;
+				}
 			}
 		}
 		pbf.exit(0);
 	}
 
 	public static void updateOCLink(CacheHolder ch) {
+		// todo other OC sites
+		Vm.showWait(true);
+		boolean save = false;
 		String wp = ch.getWayPoint();
 		if (wp.startsWith("GC")) {
-			String url = "http://www.opencaching.de/map2.php?mode=wpsearch&wp=" + wp;
-			ch.setOcCacheID("");
+			String wpName = ch.getOcCacheID();
+			if (wpName.length() > 0) {
+				if (wpName.charAt(0) < 65)
+					wp = wpName.substring(1);
+				else {
+					if (wpName.startsWith("OC")) // other OC sites
+						wp = wpName;
+				}
+				if (!wp.startsWith("OC")) {
+					// other OC sites
+					ch.setOcCacheID(""); // there may be a value from gpx - import
+					save = true;
+				}
+			}
+			// other OC sites
+			String url = "http://" + OC.getOCHostName("OC") + "/map2.php?mode=wpsearch&wp=" + wp;
 			try {
 				String result = UrlFetcher.fetch(url);
 				boolean found = false;
-				int start = result.indexOf("found=\"") + 7;
-				if (result.substring(start).startsWith("1"))
+				if (result.substring(result.indexOf("found=\"") + 7).startsWith("1"))
 					found = true;
-				start = result.indexOf("wpoc=\"") + 6;
+				int start = result.indexOf("wpoc=\"") + 6;
 				if (start > 5) {
 					int idend = result.indexOf("\"", start);
 					String ocwp = result.substring(start, idend);
 					if (!found)
 						ocwp = "-" + ocwp;
-					ch.setOcCacheID(ocwp);
+					if (!ocwp.equals(ch.getOcCacheID())) {
+						ch.setOcCacheID(ocwp);
+						save = true;
+					}
+				} else {
+					// check over coordinates
+					// still looking for the best method
+				}
+				if (save)
 					ch.save();
-				}
+
 			} catch (Exception e) {
 				// dann halt nicht
 			}
 		}
 		// return ch;
+		Vm.showWait(false);
 	}
 
 }

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2011-05-12 20:42:00 UTC (rev 3001)
+++ trunk/src/CacheWolf/myTableControl.java	2011-05-13 22:22:41 UTC (rev 3002)
@@ -25,8 +25,7 @@
  */
 package CacheWolf;
 
-import CacheWolf.imp.OCGPXfetch;
-import CacheWolf.imp.OCLinkImporter;
+import CacheWolf.exp.OCLogExport;
 import CacheWolf.utils.CWWrapper;
 import CacheWolf.utils.FileBugfix;
 import ewe.fx.IconAndText;
@@ -36,7 +35,6 @@
 import ewe.io.IOException;
 import ewe.sys.Handle;
 import ewe.sys.Locale;
-import ewe.sys.Time;
 import ewe.sys.Vm;
 import ewe.ui.Control;
 import ewe.ui.DragContext;
@@ -204,6 +202,9 @@
 	}
 
 	public void popupMenuEvent(Object selectedItem) {
+		String url;
+		CacheHolder mainCache;
+		CacheHolderDetail chD;
 		if (selectedItem == null)
 			return;
 		CacheHolder ch;
@@ -344,18 +345,17 @@
 
 		if (selectedItem == miOpenOnline) {
 			ch = cacheDB.get(tbp.getSelectedCache());
-			CacheHolder mainCache = ch;
+			mainCache = ch;
 			if (ch.isAddiWpt() && (ch.mainCache != null)) {
 				mainCache = ch.mainCache;
 			}
-			CacheHolderDetail chD = mainCache.getCacheDetails(true);
-			String url = chD.URL;
-			if (clickedColumn == 14 && mainCache.getOcCacheID().length() > 0) {
-				if (!mainCache.getOcCacheID().startsWith("OC")) {
-					url = "http://www.opencaching.de/viewcache.php?wp=" + mainCache.getOcCacheID().substring(1);
-				} else {
-					url = "http://www.opencaching.de/viewcache.php?wp=" + mainCache.getOcCacheID();
-				}
+			chD = mainCache.getCacheDetails(true);
+			url = chD.URL;
+			String wpName = mainCache.getOcCacheID();
+			if (clickedColumn == 14 && wpName.length() > 0) {
+				if (wpName.charAt(0) < 65)
+					wpName = mainCache.getOcCacheID().substring(1);
+				url = "http://" + OC.getOCHostName(wpName) + "/viewcache.php?wp=" + wpName;
 			}
 			if (url != null) {
 				callExternalProgram(pref.browser, url);
@@ -372,7 +372,7 @@
 				if (!pref.language.equalsIgnoreCase("auto")) {
 					language = pref.language;
 				}
-				String url = "http://maps.google." + language + "/maps?q=" + nameOfCache + "@" + lat + "," + lon;
+				url = "http://maps.google." + language + "/maps?q=" + nameOfCache + "@" + lat + "," + lon;
 				callExternalProgram(pref.browser, url);
 				url = "http://www.geocaching.com/map/default.aspx?lat=" + lat + "&lng=" + lon;
 				callExternalProgram(pref.browser, url);
@@ -386,64 +386,49 @@
 
 		if (selectedItem == miLogOnline) {
 			ch = cacheDB.get(tbp.getSelectedCache());
-			CacheHolder mainCache = ch;
+			mainCache = ch;
+			url = "";
 			if (ch.isAddiWpt() && (ch.mainCache != null)) {
 				mainCache = ch.mainCache;
 			}
 			if (mainCache.isCacheWpt()) {
-				CacheHolderDetail chD = mainCache.getCacheDetails(true);
+				chD = mainCache.getCacheDetails(false);
 				if (chD != null) {
-					String URL = "";
 					String notes = chD.getCacheNotes();
 					if (notes.length() > 0) {
-						Vm.setClipboardText(notes);
+						Vm.setClipboardText(mainCache.getCacheStatus() + '\n' + "<br>" + notes);
 					}
-					if (ch.isOC()) {
-						URL = chD.URL;
-						if (URL.indexOf("viewcache") >= 0) {
-							URL = STRreplace.replace(URL, "viewcache", "log");
-						} else {
-							URL = "";
+					if (mainCache.isOC()) {
+						url = chD.URL;
+						if (url.indexOf("viewcache") >= 0) {
+							url = STRreplace.replace(url, "viewcache", "log");
 						}
 					} else {
-						if (chD.OwnLogId.length() > 0 && mainCache.getOcCacheID().startsWith("-")) {
-							URL = "http://www.opencaching.de/log.php?wp=" + mainCache.getOcCacheID().substring(1);
-							if (clickedColumn == 14) {
-								// take GC log direct to OC
-								if (OCGPXfetch.login()) {
-									String page = "";
-									try {
-										page = UrlFetcher.fetch(URL);
-										String ocCacheId = new Extractor(page, "viewcache.php?cacheid=", "\">", 0, true).findNext();
-										String postData = "cacheid=" + ocCacheId + "&version3=1&descMode=3&logtype=1";
-										Time logDate = DateFormat.toDate(chD.OwnLog.getDate());
-										postData += "&logday=" + logDate.day;
-										postData += "&logmonth=" + logDate.month;
-										postData += "&logyear=" + logDate.year;
-										postData += "&logtext=" + UrlFetcher.toUtf8Url(chD.OwnLog.getMessage());
-										postData += "&submitform=Log+eintragen";
-										UrlFetcher.setpostData(postData);
-										page = UrlFetcher.fetch(URL);
-										OCLinkImporter.updateOCLink(ch);
-										if (ch.getOcCacheID().startsWith("-")) {
-											ch.setOcCacheID("!" + ch.getOcCacheID().substring(1));
-											ch.save();
+						if (chD.OwnLogId.length() > 0) {
+							String wpName = mainCache.getOcCacheID();
+							if (wpName.length() > 0 && wpName.charAt(0) < 65) {
+								// OC log (already logged at GC but not at OC)
+								if (clickedColumn == 14) {
+									OCLogExport.doOneLog(mainCache);
+									tbp.refreshTable();
+								} else {
+									// open OC logpage with GC Logtext in Clipboard
+									Vm.setClipboardText(chD.OwnLog.getDate() + '\n' + "<br>" + chD.OwnLog.getMessage());
+									if (wpName.length() > 1) {
+										if (wpName.charAt(0) < 65) {
+											wpName = mainCache.getOcCacheID().substring(1);
 										}
-									} catch (IOException e) {
-										// dann nicht
+										url = "http://" + OC.getOCHostName(wpName) + "/log.php?wp=" + wpName;
 									}
 								}
-								URL = "";
-							} else {
-								// open OC logpage with GC Logtext in Clipboard
-								Vm.setClipboardText(chD.OwnLog.getDate() + '\n' + "<br>" + chD.OwnLog.getMessage());
 							}
 						} else
-							URL = "http://www.geocaching.com/seek/log.aspx?ID=" + mainCache.GetCacheID();
+							// GC log
+							url = "http://www.geocaching.com/seek/log.aspx?ID=" + mainCache.GetCacheID();
 					}
 
-					if (URL.length() > 0) {
-						callExternalProgram(pref.browser, URL);
+					if (url.length() > 0) {
+						callExternalProgram(pref.browser, url);
 					}
 				}
 			}



From araber95 at mail.berlios.de  Sat May 14 06:21:34 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Sat, 14 May 2011 06:21:34 PM +0200
Subject: [Cachewolf-svn] r3003 - in trunk/src/CacheWolf: . exp imp
Message-ID: <20110514162134.88E324813F7@sheep.berlios.de>

Author: araber95
Date: 2011-05-14 18:21:34 +0200 (Sat, 14 May 2011)
New Revision: 3003

Modified:
   trunk/src/CacheWolf/exp/OCLogExport.java
   trunk/src/CacheWolf/imp/OCLinkImporter.java
   trunk/src/CacheWolf/myTableControl.java
Log:
1. logging visited events from gc to oc works now. (oc must correct its output for find (visited) on map2 page)
2. open gc page for oc-cache if there is one shown at ColumnID 14 = OC-Idx
3. finding oc - cache (link) with help of gc coordinate (for oc-caches that have no link to gc)


Modified: trunk/src/CacheWolf/exp/OCLogExport.java
===================================================================
--- trunk/src/CacheWolf/exp/OCLogExport.java	2011-05-13 22:22:41 UTC (rev 3002)
+++ trunk/src/CacheWolf/exp/OCLogExport.java	2011-05-14 16:21:34 UTC (rev 3003)
@@ -3,6 +3,7 @@
 import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
 import CacheWolf.CacheHolderDetail;
+import CacheWolf.CacheType;
 import CacheWolf.DateFormat;
 import CacheWolf.Extractor;
 import CacheWolf.Global;
@@ -16,7 +17,7 @@
 import ewe.sys.Vm;
 import ewe.ui.ProgressBarForm;
 
-public class OCLogExport {
+public final class OCLogExport {
 	private static boolean loggedIn = false;
 	private static CacheDB cacheDB = null;
 
@@ -34,14 +35,14 @@
 		pbf.exec();
 		if (OCGPXfetch.login()) {
 			for (int o = 0; o < cacheDB.size(); o += 1) {
-				h.progress = (float) o / (float) totalWaypoints;
-				h.changed();
 				if (pbf.exitValue == -1)
 					break;
 				CacheHolder ch = cacheDB.get(o);
 				if (ch.isVisible()) {
 					doOneLog(ch);
 					updated++;
+					h.progress = (float) updated / (float) totalWaypoints;
+					h.changed();
 				}
 			}
 		}
@@ -66,7 +67,11 @@
 						page = UrlFetcher.fetch(url);
 						loggedIn = page.indexOf("Eingeloggt als") > -1; // next time perhaps
 						String ocCacheId = new Extractor(page, "viewcache.php?cacheid=", "\">", 0, true).findNext();
-						String postData = "cacheid=" + ocCacheId + "&version3=1&descMode=3&logtype=1";
+						String postData = "cacheid=" + ocCacheId + "&version3=1&descMode=3";
+						if (ch.getType() == CacheType.CW_TYPE_EVENT || ch.getType() == CacheType.CW_TYPE_EVENT)
+							postData = postData + "&logtype=7";
+						else
+							postData = postData + "&logtype=1";
 						Time logDate = DateFormat.toDate(chD.OwnLog.getDate());
 						postData += "&logday=" + logDate.day;
 						postData += "&logmonth=" + logDate.month;

Modified: trunk/src/CacheWolf/imp/OCLinkImporter.java
===================================================================
--- trunk/src/CacheWolf/imp/OCLinkImporter.java	2011-05-13 22:22:41 UTC (rev 3002)
+++ trunk/src/CacheWolf/imp/OCLinkImporter.java	2011-05-14 16:21:34 UTC (rev 3003)
@@ -25,16 +25,19 @@
  */
 package CacheWolf.imp;
 
+import CacheWolf.CWPoint;
 import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
+import CacheWolf.Common;
 import CacheWolf.Global;
 import CacheWolf.OC;
+import CacheWolf.SafeXML;
 import CacheWolf.UrlFetcher;
 import ewe.sys.Handle;
 import ewe.sys.Vm;
 import ewe.ui.ProgressBarForm;
 
-public class OCLinkImporter {
+public final class OCLinkImporter {
 	private static CacheDB cacheDB = null;
 
 	public static void doIt() {
@@ -51,14 +54,14 @@
 		pbf.exec();
 		if (OCGPXfetch.login()) {
 			for (int o = 0; o < cacheDB.size(); o += 1) {
-				h.progress = (float) updated / (float) totalWaypoints;
-				h.changed();
 				if (pbf.exitValue == -1)
 					break;
 				CacheHolder ch = cacheDB.get(o);
 				if (ch.isVisible()) {
 					updateOCLink(ch);
 					updated++;
+					h.progress = (float) updated / (float) totalWaypoints;
+					h.changed();
 				}
 			}
 		}
@@ -86,26 +89,53 @@
 				}
 			}
 			// other OC sites
-			String url = "http://" + OC.getOCHostName("OC") + "/map2.php?mode=wpsearch&wp=" + wp;
+			String baseurl = "http://" + OC.getOCHostName("OC") + "/map2.php?";
+			boolean hasOC = false;
 			try {
+				String url = baseurl + "mode=wpsearch&wp=" + wp;
 				String result = UrlFetcher.fetch(url);
-				boolean found = false;
-				if (result.substring(result.indexOf("found=\"") + 7).startsWith("1"))
-					found = true;
-				int start = result.indexOf("wpoc=\"") + 6;
-				if (start > 5) {
-					int idend = result.indexOf("\"", start);
-					String ocwp = result.substring(start, idend);
-					if (!found)
-						ocwp = "-" + ocwp;
-					if (!ocwp.equals(ch.getOcCacheID())) {
-						ch.setOcCacheID(ocwp);
-						save = true;
+				if (result.indexOf("wpoc=\"") > -1)
+					hasOC = true;
+				else {
+					// check over coordinates
+					// getting a cache next to the coordinates
+					String nLat = ch.pos.getLatDeg(CWPoint.DD);
+					String nLon = ch.pos.getLonDeg(CWPoint.DD);
+					url = baseurl + "mode=locate&lat=" + nLat + "&lon=" + nLon;
+					result = SafeXML.cleanback(UrlFetcher.fetch(url));
+					if (result.indexOf(ch.cacheName) > -1) {
+						hasOC = true;
+					} else {
+						int start = result.indexOf("coords=\"") + 8;
+						int lonend = result.indexOf(",", start);
+						int latend = result.indexOf("\"", lonend);
+						double lon = Common.parseDouble(result.substring(start, lonend));
+						double lat = Common.parseDouble(result.substring(lonend + 1, latend));
+						boolean sameCoord = lon == ch.pos.lonDec && lat == ch.pos.latDec;
+						if (sameCoord) {
+							start = result.indexOf("username=\"") + 10;
+							int end = result.indexOf("\"", start);
+							if (ch.getCacheOwner().toLowerCase().equals(result.substring(start, end).toLowerCase()))
+								hasOC = true;
+						}
 					}
-				} else {
-					// check over coordinates
-					// still looking for the best method
 				}
+				if (hasOC) {
+					boolean found = false;
+					if (result.substring(result.indexOf("found=\"") + 7).startsWith("1"))
+						found = true;
+					int start = result.indexOf("wpoc=\"") + 6;
+					if (start > 5) {
+						int idend = result.indexOf("\"", start);
+						String ocwp = result.substring(start, idend);
+						if (!found)
+							ocwp = "-" + ocwp;
+						if (!ocwp.equals(ch.getOcCacheID())) {
+							ch.setOcCacheID(ocwp);
+							save = true;
+						}
+					}
+				}
 				if (save)
 					ch.save();
 

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2011-05-13 22:22:41 UTC (rev 3002)
+++ trunk/src/CacheWolf/myTableControl.java	2011-05-14 16:21:34 UTC (rev 3003)
@@ -51,6 +51,7 @@
 import ewe.ui.TableControl;
 import ewe.ui.TableEvent;
 import ewe.ui.mList;
+import ewe.util.mString;
 
 /**
  * Implements the user interaction of the list view. Works together with myTableModel and TablePanel
@@ -352,10 +353,23 @@
 			chD = mainCache.getCacheDetails(true);
 			url = chD.URL;
 			String wpName = mainCache.getOcCacheID();
-			if (clickedColumn == 14 && wpName.length() > 0) {
-				if (wpName.charAt(0) < 65)
-					wpName = mainCache.getOcCacheID().substring(1);
-				url = "http://" + OC.getOCHostName(wpName) + "/viewcache.php?wp=" + wpName;
+			if (clickedColumn == 14) {
+				if (mainCache.isOC()) {
+					String[] stmp = mString.split(ch.getCacheOwner(), '/');
+					int l = stmp.length - 1;
+					if (l > 0) {
+						String s = stmp[l].trim();
+						if (s.startsWith("GC")) {
+							url = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + s;
+						}
+					}
+				} else {
+					if (wpName.length() > 0) {
+						if (wpName.charAt(0) < 65)
+							wpName = mainCache.getOcCacheID().substring(1);
+						url = "http://" + OC.getOCHostName(wpName) + "/viewcache.php?wp=" + wpName;
+					}
+				}
 			}
 			if (url != null) {
 				callExternalProgram(pref.browser, url);
@@ -367,7 +381,7 @@
 			if (ch.pos.isValid()) {
 				String lat = "" + ch.pos.getLatDeg(CWPoint.DD);
 				String lon = "" + ch.pos.getLonDeg(CWPoint.DD);
-				String nameOfCache = ewe.net.URL.encodeURL(ch.cacheName, false).replace('#', 'N').replace('@', '_');
+				String nameOfCache = UrlFetcher.encodeURL(ch.cacheName, false).replace('#', 'N').replace('@', '_');
 				String language = Vm.getLocale().getString(Locale.LANGUAGE_SHORT, 0, 0);
 				if (!pref.language.equalsIgnoreCase("auto")) {
 					language = pref.language;



From araber95 at mail.berlios.de  Sat May 14 10:57:49 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Sat, 14 May 2011 10:57:49 PM +0200
Subject: [Cachewolf-svn] r3004 - in trunk/src/CacheWolf: exp imp
Message-ID: <20110514205749.483994813F7@sheep.berlios.de>

Author: araber95
Date: 2011-05-14 22:57:48 +0200 (Sat, 14 May 2011)
New Revision: 3004

Modified:
   trunk/src/CacheWolf/exp/OCLogExport.java
   trunk/src/CacheWolf/imp/OCLinkImporter.java
Log:
1. NPE in OCLogExport fixed
2. subcheck in OCLinkImport for cachename fixed

Modified: trunk/src/CacheWolf/exp/OCLogExport.java
===================================================================
--- trunk/src/CacheWolf/exp/OCLogExport.java	2011-05-14 16:21:34 UTC (rev 3003)
+++ trunk/src/CacheWolf/exp/OCLogExport.java	2011-05-14 20:57:48 UTC (rev 3004)
@@ -50,6 +50,8 @@
 	}
 
 	public static void doOneLog(CacheHolder ch) {
+		if (!ch.is_found())
+			return;
 		// take GC log direct to OC, needs valid ch
 		Vm.showWait(true);
 		String wpName = ch.getOcCacheID();
@@ -64,26 +66,28 @@
 					String page = "";
 					try {
 						CacheHolderDetail chD = ch.getCacheDetails(false);
-						page = UrlFetcher.fetch(url);
-						loggedIn = page.indexOf("Eingeloggt als") > -1; // next time perhaps
-						String ocCacheId = new Extractor(page, "viewcache.php?cacheid=", "\">", 0, true).findNext();
-						String postData = "cacheid=" + ocCacheId + "&version3=1&descMode=3";
-						if (ch.getType() == CacheType.CW_TYPE_EVENT || ch.getType() == CacheType.CW_TYPE_EVENT)
-							postData = postData + "&logtype=7";
-						else
-							postData = postData + "&logtype=1";
-						Time logDate = DateFormat.toDate(chD.OwnLog.getDate());
-						postData += "&logday=" + logDate.day;
-						postData += "&logmonth=" + logDate.month;
-						postData += "&logyear=" + logDate.year;
-						postData += "&logtext=" + UrlFetcher.toUtf8Url(chD.OwnLog.getMessage());
-						postData += "&submitform=Log+eintragen"; // todo for other opencaching sites
-						UrlFetcher.setpostData(postData);
-						page = UrlFetcher.fetch(url);
-						OCLinkImporter.updateOCLink(ch);
-						if (ch.getOcCacheID().startsWith("-")) {
-							ch.setOcCacheID("!" + ch.getOcCacheID().substring(1));
-							ch.save();
+						if (chD.OwnLog != null) {
+							page = UrlFetcher.fetch(url);
+							loggedIn = page.indexOf("Eingeloggt als") > -1; // next time perhaps
+							String ocCacheId = new Extractor(page, "viewcache.php?cacheid=", "\">", 0, true).findNext();
+							String postData = "cacheid=" + ocCacheId + "&version3=1&descMode=3";
+							if (ch.getType() == CacheType.CW_TYPE_EVENT || ch.getType() == CacheType.CW_TYPE_EVENT)
+								postData = postData + "&logtype=7";
+							else
+								postData = postData + "&logtype=1";
+							Time logDate = DateFormat.toDate(chD.OwnLog.getDate());
+							postData += "&logday=" + logDate.day;
+							postData += "&logmonth=" + logDate.month;
+							postData += "&logyear=" + logDate.year;
+							postData += "&logtext=" + UrlFetcher.toUtf8Url(chD.OwnLog.getMessage());
+							postData += "&submitform=Log+eintragen"; // todo for other opencaching sites
+							UrlFetcher.setpostData(postData);
+							page = UrlFetcher.fetch(url);
+							OCLinkImporter.updateOCLink(ch);
+							if (ch.getOcCacheID().startsWith("-")) {
+								ch.setOcCacheID("!" + ch.getOcCacheID().substring(1));
+								ch.save();
+							}
 						}
 					} catch (IOException e) {
 						// dann nicht

Modified: trunk/src/CacheWolf/imp/OCLinkImporter.java
===================================================================
--- trunk/src/CacheWolf/imp/OCLinkImporter.java	2011-05-14 16:21:34 UTC (rev 3003)
+++ trunk/src/CacheWolf/imp/OCLinkImporter.java	2011-05-14 20:57:48 UTC (rev 3004)
@@ -29,6 +29,7 @@
 import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
 import CacheWolf.Common;
+import CacheWolf.Extractor;
 import CacheWolf.Global;
 import CacheWolf.OC;
 import CacheWolf.SafeXML;
@@ -103,7 +104,8 @@
 					String nLon = ch.pos.getLonDeg(CWPoint.DD);
 					url = baseurl + "mode=locate&lat=" + nLat + "&lon=" + nLon;
 					result = SafeXML.cleanback(UrlFetcher.fetch(url));
-					if (result.indexOf(ch.cacheName) > -1) {
+					String ocCacheName = new Extractor(result, "name=\"", "\"", 0, true).findNext();
+					if (ch.cacheName.equals(ocCacheName)) {
 						hasOC = true;
 					} else {
 						int start = result.indexOf("coords=\"") + 8;



From araber95 at mail.berlios.de  Sun May 15 08:20:09 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Sun, 15 May 2011 08:20:09 PM +0200
Subject: [Cachewolf-svn] r3005 - in trunk/src/CacheWolf: . imp view/ewe
	view/pda
Message-ID: <20110515182009.DD752480A0E@sheep.berlios.de>

Author: araber95
Date: 2011-05-15 20:20:09 +0200 (Sun, 15 May 2011)
New Revision: 3005

Modified:
   trunk/src/CacheWolf/CoordsScreen.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/TravelbugJourneyScreen.java
   trunk/src/CacheWolf/UrlFetcher.java
   trunk/src/CacheWolf/imp/SpiderGC.java
   trunk/src/CacheWolf/myTableControl.java
   trunk/src/CacheWolf/view/ewe/TravelbugJourneyScreen.java
   trunk/src/CacheWolf/view/ewe/TravelbugMenu.java
   trunk/src/CacheWolf/view/pda/PDATravelbugDetailMenu.java
Log:


Modified: trunk/src/CacheWolf/CoordsScreen.java
===================================================================
--- trunk/src/CacheWolf/CoordsScreen.java	2011-05-14 20:57:48 UTC (rev 3004)
+++ trunk/src/CacheWolf/CoordsScreen.java	2011-05-15 18:20:09 UTC (rev 3005)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.imp.SpiderGC;
@@ -50,11 +50,10 @@
 import ewe.ui.mLabel;
 
 /**
- *	Class for entering coordinates<br>
- *	Class IDs 1400 and 600 (same as calc panel and preferences screen)<br>
+ * Class for entering coordinates<br>
+ * Class IDs 1400 and 600 (same as calc panel and preferences screen)<br>
  */
 
-
 public class CoordsScreen extends Form {
 
 	mCheckBox chkDMM, chkDMS, chkDD, chkCustom;
@@ -70,138 +69,171 @@
 	CWPoint coordInp = new CWPoint();
 	CellPanel topLinePanel = new CellPanel();
 	CellPanel mainPanel = new CellPanel();
-	int exitKeys[]={75009};
+	int exitKeys[] = { 75009 };
 	int currFormat;
 
 	boolean bNSDeg = false;
 	boolean bNSm = false;
-	boolean	bNSs = false;
+	boolean bNSs = false;
 	boolean bEWDeg = false;
 	boolean bEWm = false;
 	boolean bEWs = false;
 	boolean bUTMNorthing = false;
 	boolean bUTMEasting = false;
-	
 
 	private boolean allowInvalid = false;
 
-	public CoordsScreen(boolean allowInvalidCoords)
-	{
+	public CoordsScreen(boolean allowInvalidCoords) {
 		allowInvalid = allowInvalidCoords;
 
-		InitCoordsScreen();		
+		InitCoordsScreen();
 	}
 
-	public CoordsScreen()
-	{
-		InitCoordsScreen();		
+	public CoordsScreen() {
+		InitCoordsScreen();
 	}
 
-	private void InitCoordsScreen()
-	{
+	private void InitCoordsScreen() {
 		this.setTitle("");
-		//Radiobuttons for format
-		topLinePanel.addNext(chkDD =new mCheckBox("d.d?"),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		topLinePanel.addNext(chkDMM =new mCheckBox("d?m.m\'"),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		topLinePanel.addNext(chkDMS =new mCheckBox("d?m\'s\""),CellConstants.DONTSTRETCH,CellConstants.WEST);
-		//topLinePanel.addNext(chkUTM =new mCheckBox("UTM"),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		topLinePanel.addNext(chkCustom =new mCheckBox(""),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		// Radiobuttons for format
+		topLinePanel.addNext(chkDD = new mCheckBox("d.d?"), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		topLinePanel.addNext(chkDMM = new mCheckBox("d?m.m\'"), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		topLinePanel.addNext(chkDMS = new mCheckBox("d?m\'s\""), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		// topLinePanel.addNext(chkUTM =new mCheckBox("UTM"),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		topLinePanel.addNext(chkCustom = new mCheckBox(""), CellConstants.DONTSTRETCH, CellConstants.WEST);
 
 		String[] ls = TransformCoordinates.getProjectedSystemNames();
-		topLinePanel.addLast(localCooSystem = new mChoice(ls, 0),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		topLinePanel.addLast(localCooSystem = new mChoice(ls, 0), CellConstants.DONTSTRETCH, CellConstants.WEST);
 
-		chkDD.setGroup(chkFormat); chkDD.exitKeys=exitKeys;
-		chkDMM.setGroup(chkFormat);chkDMM.exitKeys=exitKeys;
-		chkDMS.setGroup(chkFormat);chkDMS.exitKeys=exitKeys;
-		chkCustom.setGroup(chkFormat);chkCustom.exitKeys=exitKeys;
-		this.addLast(topLinePanel,CellConstants.DONTSTRETCH, CellConstants.WEST);
+		chkDD.setGroup(chkFormat);
+		chkDD.exitKeys = exitKeys;
+		chkDMM.setGroup(chkFormat);
+		chkDMM.exitKeys = exitKeys;
+		chkDMS.setGroup(chkFormat);
+		chkDMS.exitKeys = exitKeys;
+		chkCustom.setGroup(chkFormat);
+		chkCustom.exitKeys = exitKeys;
+		this.addLast(topLinePanel, CellConstants.DONTSTRETCH, CellConstants.WEST);
 
 		// Input for degrees
-		mainPanel.addNext(chcNS = new mChoice(new String[]{"N", "S"},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(chcNS = new mChoice(new String[] { "N", "S" }, 0), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		chcNS.setInt(0);
-		mainPanel.addNext(inpNSDeg = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addNext(inpNSm = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addLast(inpNSs = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(inpNSDeg = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addNext(inpNSm = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addLast(inpNSs = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 
-		mainPanel.addNext(chcEW = new mChoice(new String[]{"E", "W"},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(chcEW = new mChoice(new String[] { "E", "W" }, 0), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		chcEW.setInt(0);
-		mainPanel.addNext(inpEWDeg = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addNext(inpEWm = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addLast(inpEWs = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(inpEWDeg = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addNext(inpEWm = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addLast(inpEWs = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 
 		// Input for UTM
-		if (allowInvalid){
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1400,"Zone")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1402,"Easting")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1401,"Northing")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addLast(btnClear = new mButton(MyLocale.getMsg(1413,"Clear")),CellConstants.HSTRETCH, (CellConstants.HFILL));
+		if (allowInvalid) {
+			mainPanel.addNext(new mLabel(MyLocale.getMsg(1400, "Zone")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.SOUTHWEST));
+			mainPanel.addNext(new mLabel(MyLocale.getMsg(1402, "Easting")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.SOUTHWEST));
+			mainPanel.addNext(new mLabel(MyLocale.getMsg(1401, "Northing")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.SOUTHWEST));
+			mainPanel.addLast(btnClear = new mButton(MyLocale.getMsg(1413, "Clear")), CellConstants.HSTRETCH, (CellConstants.HFILL));
 		} else {
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1400,"Zone")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1402,"Easting")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1401,"Northing")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addLast(btnSearch = new mButton(MyLocale.getMsg(1414,"Search")),CellConstants.HSTRETCH, (CellConstants.HFILL));
+			mainPanel.addNext(new mLabel(MyLocale.getMsg(1400, "Zone")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.SOUTHWEST));
+			mainPanel.addNext(new mLabel(MyLocale.getMsg(1402, "Easting")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.SOUTHWEST));
+			mainPanel.addNext(new mLabel(MyLocale.getMsg(1401, "Northing")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.SOUTHWEST));
+			mainPanel.addLast(btnSearch = new mButton(MyLocale.getMsg(1414, "Search")), CellConstants.HSTRETCH, (CellConstants.HFILL));
 		}
 
-		mainPanel.addNext(inpUTMZone = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addNext(inpUTMEasting = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addNext(inpUTMNorthing = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addLast(btnGps = new mButton("GPS"),CellConstants.HSTRETCH, (CellConstants.HFILL));
+		mainPanel.addNext(inpUTMZone = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addNext(inpUTMEasting = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addNext(inpUTMNorthing = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addLast(btnGps = new mButton("GPS"), CellConstants.HSTRETCH, (CellConstants.HFILL));
 
-		//	mainPanel.addLast(new mLabel(MyLocale.getMsg(1405,"To load coordinates from GC, enter GCxxxxx below")),CellConstants.HSTRETCH, (CellConstants.HFILL)).setTag(SPAN,new Dimension(4,1));
+		// mainPanel.addLast(new mLabel(MyLocale.getMsg(1405,"To load coordinates from GC, enter GCxxxxx below")),CellConstants.HSTRETCH, (CellConstants.HFILL)).setTag(SPAN,new Dimension(4,1));
 		// Input for free Text
-		mainPanel.addNext(inpText = new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		inpText.toolTip=MyLocale.getMsg(1406,"Enter coordinates in any format or GCxxxxx");
-		inpText.setTag(SPAN,new Dimension(3,1));
-		mainPanel.addLast(btnParse = new mButton(MyLocale.getMsg(619,"Parse")),CellConstants.HSTRETCH, (CellConstants.HFILL));
+		mainPanel.addNext(inpText = new mInput(), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		inpText.toolTip = MyLocale.getMsg(1406, "Enter coordinates in any format or GCxxxxx");
+		inpText.setTag(SPAN, new Dimension(3, 1));
+		mainPanel.addLast(btnParse = new mButton(MyLocale.getMsg(619, "Parse")), CellConstants.HSTRETCH, (CellConstants.HFILL));
 
 		// Buttons for cancel and apply, copy and paste
-		btnCancel = new mButton(MyLocale.getMsg(614,"Cancel"));
+		btnCancel = new mButton(MyLocale.getMsg(614, "Cancel"));
 		btnCancel.setHotKey(0, IKeys.ESCAPE);
-		mainPanel.addNext(btnCancel,CellConstants.HSTRETCH, (CellConstants.HFILL));
-		//btnCancel.setTag(SPAN,new Dimension(4,1));
-		mainPanel.addNext(btnApply = new mButton(MyLocale.getMsg(615,"Apply")),CellConstants.HSTRETCH, (CellConstants.HFILL));
-		//btnApply.setTag(SPAN,new Dimension(4,1));
-		mainPanel.addNext(btnPaste = new mButton(MyLocale.getMsg(617,"Paste")),CellConstants.HSTRETCH, (CellConstants.HFILL));
-		//btnParse.setTag(SPAN,new Dimension(4,1));
-		mainPanel.addLast(btnCopy = new mButton(MyLocale.getMsg(618,"Copy")),CellConstants.HSTRETCH, (CellConstants.HFILL));
-		//btnCopy.setTag(SPAN,new Dimension(4,1));
-		chcNS.exitKeys=exitKeys; chcEW.exitKeys=exitKeys;
-		//add Panels
-		this.addLast(mainPanel,CellConstants.DONTSTRETCH, CellConstants.WEST);
+		mainPanel.addNext(btnCancel, CellConstants.HSTRETCH, (CellConstants.HFILL));
+		// btnCancel.setTag(SPAN,new Dimension(4,1));
+		mainPanel.addNext(btnApply = new mButton(MyLocale.getMsg(615, "Apply")), CellConstants.HSTRETCH, (CellConstants.HFILL));
+		// btnApply.setTag(SPAN,new Dimension(4,1));
+		mainPanel.addNext(btnPaste = new mButton(MyLocale.getMsg(617, "Paste")), CellConstants.HSTRETCH, (CellConstants.HFILL));
+		// btnParse.setTag(SPAN,new Dimension(4,1));
+		mainPanel.addLast(btnCopy = new mButton(MyLocale.getMsg(618, "Copy")), CellConstants.HSTRETCH, (CellConstants.HFILL));
+		// btnCopy.setTag(SPAN,new Dimension(4,1));
+		chcNS.exitKeys = exitKeys;
+		chcEW.exitKeys = exitKeys;
+		// add Panels
+		this.addLast(mainPanel, CellConstants.DONTSTRETCH, CellConstants.WEST);
 		chcNS.takeFocus(ControlConstants.ByKeyboard);
-		
-		
+
 	}
 
-	public void activateFields(int format){
-		//inpEWDeg.wantReturn=false; inpEWm.wantReturn=false; inpEWs.wantReturn=false; inpUTMNorthing.wantReturn=false;
+	public void activateFields(int format) {
+		// inpEWDeg.wantReturn=false; inpEWm.wantReturn=false; inpEWs.wantReturn=false; inpUTMNorthing.wantReturn=false;
 
-		switch (format){
+		switch (format) {
 		case TransformCoordinates.DD:
-			enable(chcNS); enable(inpNSDeg); disable(inpNSm); disable(inpNSs);
-			enable(chcEW); enable(inpEWDeg); disable(inpEWm); disable(inpEWs);
-			//inpEWDeg.wantReturn=true;
-			disable(inpUTMZone); disable(inpUTMNorthing); disable(inpUTMEasting);
+			enable(chcNS);
+			enable(inpNSDeg);
+			disable(inpNSm);
+			disable(inpNSs);
+			enable(chcEW);
+			enable(inpEWDeg);
+			disable(inpEWm);
+			disable(inpEWs);
+			// inpEWDeg.wantReturn=true;
+			disable(inpUTMZone);
+			disable(inpUTMNorthing);
+			disable(inpUTMEasting);
 			break;
-		case TransformCoordinates.DMM: 	
-			enable(chcNS); enable(inpNSDeg); enable(inpNSm); disable(inpNSs);
-			enable(chcEW); enable(inpEWDeg); enable(inpEWm); disable(inpEWs);
-			//inpEWm.wantReturn=true;
-			disable(inpUTMZone); disable(inpUTMNorthing); disable(inpUTMEasting);
+		case TransformCoordinates.DMM:
+			enable(chcNS);
+			enable(inpNSDeg);
+			enable(inpNSm);
+			disable(inpNSs);
+			enable(chcEW);
+			enable(inpEWDeg);
+			enable(inpEWm);
+			disable(inpEWs);
+			// inpEWm.wantReturn=true;
+			disable(inpUTMZone);
+			disable(inpUTMNorthing);
+			disable(inpUTMEasting);
 			break;
-		case TransformCoordinates.DMS: 	
-			enable(chcNS); enable(inpNSDeg); enable(inpNSm); enable(inpNSs);
-			enable(chcEW); enable(inpEWDeg); enable(inpEWm); enable(inpEWs);
-			//inpEWs.wantReturn=true;
-			disable(inpUTMZone); disable(inpUTMNorthing); disable(inpUTMEasting);
+		case TransformCoordinates.DMS:
+			enable(chcNS);
+			enable(inpNSDeg);
+			enable(inpNSm);
+			enable(inpNSs);
+			enable(chcEW);
+			enable(inpEWDeg);
+			enable(inpEWm);
+			enable(inpEWs);
+			// inpEWs.wantReturn=true;
+			disable(inpUTMZone);
+			disable(inpUTMNorthing);
+			disable(inpUTMEasting);
 			break;
-		default: 	
-			disable(chcNS); disable(inpNSDeg); disable(inpNSm); disable(inpNSs);
-			disable(chcEW); disable(inpEWDeg); disable(inpEWm); disable(inpEWs);
-			if (TransformCoordinates.localSystems[localCooSystem.getInt()].zoneSeperatly) enable(inpUTMZone);
-			else disable(inpUTMZone); 
-			enable(inpUTMNorthing); enable(inpUTMEasting);
-			//inpUTMNorthing.wantReturn=true;
+		default:
+			disable(chcNS);
+			disable(inpNSDeg);
+			disable(inpNSm);
+			disable(inpNSs);
+			disable(chcEW);
+			disable(inpEWDeg);
+			disable(inpEWm);
+			disable(inpEWs);
+			if (TransformCoordinates.localSystems[localCooSystem.getInt()].zoneSeperatly)
+				enable(inpUTMZone);
+			else
+				disable(inpUTMZone);
+			enable(inpUTMNorthing);
+			enable(inpUTMEasting);
+			// inpUTMNorthing.wantReturn=true;
 			break;
 		}
 
@@ -210,54 +242,57 @@
 		this.repaintNow();
 	}
 
-	private void enable(Control c) {c.modify(ControlConstants.TakesKeyFocus,ControlConstants.Disabled); }
-	private void disable(Control c) {c.modify(ControlConstants.Disabled,ControlConstants.TakesKeyFocus); }
+	private void enable(Control c) {
+		c.modify(ControlConstants.TakesKeyFocus, ControlConstants.Disabled);
+	}
 
-	public void readFields(CWPoint coords){
+	private void disable(Control c) {
+		c.modify(ControlConstants.Disabled, ControlConstants.TakesKeyFocus);
+	}
+
+	public void readFields(CWPoint coords) {
 		String NS, EW;
 		if (localSystemToformatSel(currFormat) >= formatSelToLocalSystem.length) {
 			if (TransformCoordinates.getLocalSystem(currFormat).zoneSeperatly)
-				coords.set(inpUTMNorthing.getText(), inpUTMEasting.getText(), inpUTMZone.getText(), currFormat); 
+				coords.set(inpUTMNorthing.getText(), inpUTMEasting.getText(), inpUTMZone.getText(), currFormat);
 			else
-				coords.set(inpUTMNorthing.getText(), inpUTMEasting.getText(), currFormat);			
+				coords.set(inpUTMNorthing.getText(), inpUTMEasting.getText(), currFormat);
+		} else {
+			NS = chcNS.getInt() == 0 ? "N" : "S";
+			EW = chcEW.getInt() == 0 ? "E" : "W";
+			coords.set(NS, inpNSDeg.getText(), inpNSm.getText(), inpNSs.getText(), EW, inpEWDeg.getText(), inpEWm.getText(), inpEWs.getText(), currFormat);
 		}
-		else {
-			NS = chcNS.getInt()== 0?"N":"S";
-			EW = chcEW.getInt()== 0?"E":"W";
-			coords.set(NS, inpNSDeg.getText(), inpNSm.getText(), inpNSs.getText(),
-					EW, inpEWDeg.getText(), inpEWm.getText(), inpEWs.getText(),
-					currFormat);
-		}
 		int formatsel = combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt());
 		currFormat = getLocalSystem(formatsel);
 		return;
 	}
+
 	public void setFields(CWPoint coords, int format) {
-		int formatsel = localSystemToformatSel(format); 
-		if ( formatsel >= formatSelToLocalSystem.length){ // projected point = neither dd, dd? mm.mm nor dd? mm' ss.s"
-			if (coords.isValid()){
+		int formatsel = localSystemToformatSel(format);
+		if (formatsel >= formatSelToLocalSystem.length) { // projected point = neither dd, dd? mm.mm nor dd? mm' ss.s"
+			if (coords.isValid()) {
 				localCooSystem.setInt(formatsel - formatSelToLocalSystem.length);
 				ProjectedPoint pp = TransformCoordinates.wgs84ToLocalsystem(coords, format);
 				inpText.setText(pp.toHumanReadableString());
-				inpUTMNorthing.setText(Common.DoubleToString(pp.getNorthing(),0,0));
-				inpUTMEasting.setText(Common.DoubleToString(pp.getEasting(),0,0));
-				if (TransformCoordinates.getLocalSystem(format).zoneSeperatly) inpUTMZone.setText(pp.getZoneString()); 
-				else inpUTMZone.setText("");
-			}
-			else {
+				inpUTMNorthing.setText(Common.DoubleToString(pp.getNorthing(), 0, 0));
+				inpUTMEasting.setText(Common.DoubleToString(pp.getEasting(), 0, 0));
+				if (TransformCoordinates.getLocalSystem(format).zoneSeperatly)
+					inpUTMZone.setText(pp.getZoneString());
+				else
+					inpUTMZone.setText("");
+			} else {
 				inpUTMNorthing.setText("0");
 				inpUTMEasting.setText("0");
 			}
-		}
-		else {
-			chcNS.setInt(coords.getNSLetter().equals("N")?0:1);
-			chcEW.setInt(coords.getEWLetter().equals("E")?0:1);
+		} else {
+			chcNS.setInt(coords.getNSLetter().equals("N") ? 0 : 1);
+			chcEW.setInt(coords.getEWLetter().equals("E") ? 0 : 1);
 
-			inpNSDeg.setText(STRreplace.replace(coords.getLatDeg(format),"-",""));
+			inpNSDeg.setText(STRreplace.replace(coords.getLatDeg(format), "-", ""));
 			inpNSm.setText(coords.getLatMin(format));
 			inpNSs.setText(coords.getLatSec(format));
 
-			inpEWDeg.setText(STRreplace.replace(coords.getLonDeg(format),"-",""));
+			inpEWDeg.setText(STRreplace.replace(coords.getLonDeg(format), "-", ""));
 			inpEWm.setText(coords.getLonMin(format));
 			inpEWs.setText(coords.getLonSec(format));
 		}
@@ -267,140 +302,139 @@
 		activateFields(format);
 	}
 
-	public CWPoint getCoords(){
+	public CWPoint getCoords() {
 		return coordInp;
 	}
 
+	public void onEvent(Event ev) {
 
-	
-	public void onEvent(Event ev){
-
 		// Ensure that the Enter key moves to the appropriate field
 		// for Checkboxes and Choice controls this is done via the exitKeys
 		// For input fields we use the wantReturn field
 
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.EXITED){
-			if (((ControlEvent)ev).target==chkDD || ((ControlEvent)ev).target==chkDMM ||
-					((ControlEvent)ev).target==chkDMS) Gui.takeFocus(chcNS,ControlConstants.ByKeyboard);	
-			if (((ControlEvent)ev).target==chkCustom) Gui.takeFocus(inpUTMEasting,ControlConstants.ByKeyboard);
-			if (((ControlEvent)ev).target==chcNS) Gui.takeFocus(inpNSDeg,ControlConstants.ByKeyboard);
-			if (((ControlEvent)ev).target==chcEW) Gui.takeFocus(inpEWDeg,ControlConstants.ByKeyboard);
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.EXITED) {
+			if (((ControlEvent) ev).target == chkDD || ((ControlEvent) ev).target == chkDMM || ((ControlEvent) ev).target == chkDMS)
+				Gui.takeFocus(chcNS, ControlConstants.ByKeyboard);
+			if (((ControlEvent) ev).target == chkCustom)
+				Gui.takeFocus(inpUTMEasting, ControlConstants.ByKeyboard);
+			if (((ControlEvent) ev).target == chcNS)
+				Gui.takeFocus(inpNSDeg, ControlConstants.ByKeyboard);
+			if (((ControlEvent) ev).target == chcEW)
+				Gui.takeFocus(inpEWDeg, ControlConstants.ByKeyboard);
 		}
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if (((ControlEvent)ev).target==inpEWDeg || ((ControlEvent)ev).target==inpEWm ||
-					((ControlEvent)ev).target==inpEWs || ((ControlEvent)ev).target==inpUTMNorthing) Gui.takeFocus(btnApply,ControlConstants.ByKeyboard);	
-			
-			
-			if (ev.target == chkFormat || ev.target == localCooSystem){
-				if (ev.target == localCooSystem) chkFormat.selectIndex(3);
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
+			if (((ControlEvent) ev).target == inpEWDeg || ((ControlEvent) ev).target == inpEWm || ((ControlEvent) ev).target == inpEWs || ((ControlEvent) ev).target == inpUTMNorthing)
+				Gui.takeFocus(btnApply, ControlConstants.ByKeyboard);
+
+			if (ev.target == chkFormat || ev.target == localCooSystem) {
+				if (ev.target == localCooSystem)
+					chkFormat.selectIndex(3);
 				readFields(coordInp);
 				setFields(coordInp, currFormat);
 				this.repaintNow();
 			}
 
-			if (ev.target == btnCancel){
+			if (ev.target == btnCancel) {
 				this.close(IDCANCEL);
 			}
 
-			if (ev.target == btnApply){
+			if (ev.target == btnApply) {
 				currFormat = getLocalSystem(combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt()));
 				readFields(coordInp);
-				if (coordInp.isValid()) this.close(IDOK);
+				if (coordInp.isValid())
+					this.close(IDOK);
 				else {
-					if	( allowInvalid ) {
-						if ((new MessageBox(MyLocale.getMsg(144,"Warnung"),MyLocale.getMsg(1412,"Coordinates invalid. Apply anyway?"),FormBase.DEFOKB|FormBase.NOB)).execute() == FormBase.IDOK ) {
-							this.close(IDOK);						
+					if (allowInvalid) {
+						if ((new MessageBox(MyLocale.getMsg(144, "Warnung"), MyLocale.getMsg(1412, "Coordinates invalid. Apply anyway?"), FormBase.DEFOKB | FormBase.NOB)).execute() == FormBase.IDOK) {
+							this.close(IDOK);
 						}
 					} else {
-						(new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(1411,"Please enter valid coordinates"), FormBase.OKB)).execute();						
+						(new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(1411, "Please enter valid coordinates"), FormBase.OKB)).execute();
 					}
 				}
 			}
 
-			if (ev.target == btnPaste){
+			if (ev.target == btnPaste) {
 				inpText.setText(Vm.getClipboardText(""));
 			}
 
-			if (ev.target == btnCopy){
+			if (ev.target == btnCopy) {
 				readFields(coordInp); // TODO was anderes als Gau?-Kr?ger unterst?tzen
 				Vm.setClipboardText(coordInp.toString(currFormat));
 			}
 
-			if (ev.target == btnParse){
+			if (ev.target == btnParse) {
 				// try to parse coords
 				CWPoint coord;
-				String inp=inpText.getText().trim().toUpperCase();
+				String inp = inpText.getText().trim().toUpperCase();
 				if (inp.startsWith("GC")) {
 					SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
 					coord = new CWPoint(spider.getCacheCoordinates(inp));
-				} else {	
+					Global.getPref().setOldGCLanguage();
+				} else {
 					coord = new CWPoint(inp);
 				}
-				if (!coord.isValid()){
-					MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321,"Error"), MyLocale.getMsg(4111,"Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"), FormBase.OKB);
+				if (!coord.isValid()) {
+					MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321, "Error"), MyLocale.getMsg(4111, "Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM"), FormBase.OKB);
 					tmpMB.exec();
-				}else {
-					currFormat =  getLocalSystem(combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt()));
-					setFields(coord,currFormat);
+				} else {
+					currFormat = getLocalSystem(combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt()));
+					setFields(coord, currFormat);
 					this.repaintNow();
 				}
 			}
 
-			if (ev.target == btnGps){
-				Navigate nav=Global.mainTab.nav;
-				if (nav.gpsPos.isValid()){
+			if (ev.target == btnGps) {
+				Navigate nav = Global.mainTab.nav;
+				if (nav.gpsPos.isValid()) {
 					CWPoint coord = nav.gpsPos;
 					currFormat = getLocalSystem(combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt()));
-					setFields(coord,currFormat);
+					setFields(coord, currFormat);
 				}
 			}
 
-			if (ev.target == btnClear){
-				CWPoint coord = new CWPoint(91,361);
+			if (ev.target == btnClear) {
+				CWPoint coord = new CWPoint(91, 361);
 				currFormat = getLocalSystem(combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt()));
-				setFields(coord,currFormat);
+				setFields(coord, currFormat);
 			}
-			
+
 			if (ev.target == btnSearch) {
-				GeoCodeGui s = new GeoCodeGui(); 
+				GeoCodeGui s = new GeoCodeGui();
 				int ok = s.execute();
 				if (ok == FormBase.IDOK) {
 					currFormat = getLocalSystem(combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt()));
-					setFields(s.coordInp,currFormat);
+					setFields(s.coordInp, currFormat);
 				}
 			}
 		}
 		super.onEvent(ev);
 	}
-	
 
-	private static final int[] formatSelToLocalSystem = {
-		TransformCoordinates.DD,
-		TransformCoordinates.DMM,
-		TransformCoordinates.DMS,
-	};
+	private static final int[] formatSelToLocalSystem = { TransformCoordinates.DD, TransformCoordinates.DMM, TransformCoordinates.DMS, };
 
 	public int localSystemToformatSel(int cwpointformat) {
-		for (int i=0; i < formatSelToLocalSystem.length; i++) 
-			if (formatSelToLocalSystem[i] == cwpointformat) return i;
-		for (int i=0; i < TransformCoordinates.localSystems.length; i++) 
-			if (TransformCoordinates.localSystems[i].code == cwpointformat) return i + formatSelToLocalSystem.length;
-		
+		for (int i = 0; i < formatSelToLocalSystem.length; i++)
+			if (formatSelToLocalSystem[i] == cwpointformat)
+				return i;
+		for (int i = 0; i < TransformCoordinates.localSystems.length; i++)
+			if (TransformCoordinates.localSystems[i].code == cwpointformat)
+				return i + formatSelToLocalSystem.length;
+
 		throw new IllegalArgumentException("CoordScreen.CWPointformatToformatSel: cwpointformat " + cwpointformat + "not supported");
 	}
 
 	public static final int getLocalSystem(int formatsel) { // be carefull: this method is also used by CalcPanel
-		if (formatsel < formatSelToLocalSystem.length) return formatSelToLocalSystem[formatsel];
+		if (formatsel < formatSelToLocalSystem.length)
+			return formatSelToLocalSystem[formatsel];
 		return TransformCoordinates.localSystems[formatsel - formatSelToLocalSystem.length].code;
 	}
-	
+
 	public static final int combineToFormatSel(int radiobuttonindex, int choiceindex) {
 		int ret = radiobuttonindex;
-		if (ret == formatSelToLocalSystem.length) ret += choiceindex;
+		if (ret == formatSelToLocalSystem.length)
+			ret += choiceindex;
 		return ret;
 	}
 
 }
-
-
-

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2011-05-14 20:57:48 UTC (rev 3004)
+++ trunk/src/CacheWolf/MainMenu.java	2011-05-15 18:20:09 UTC (rev 3005)
@@ -354,6 +354,7 @@
 				cacheDB.clear();
 				profile.readIndex();
 				tbp.resetModel();
+				pref.setOldGCLanguage();
 			}
 			if (mev.selectedItem == spiderRoute) {
 				SpiderGC spGC = new SpiderGC(pref, profile);
@@ -362,6 +363,7 @@
 				cacheDB.clear();
 				profile.readIndex();
 				tbp.resetModel();
+				pref.setOldGCLanguage();
 			}
 			if (mev.selectedItem == spiderQuick) {
 				SpiderGC spGC = new SpiderGC(pref, profile);
@@ -370,6 +372,7 @@
 				cacheDB.clear();
 				profile.readIndex();
 				tbp.resetModel();
+				pref.setOldGCLanguage();
 			}
 			if (mev.selectedItem == spiderAllFinds) {
 				SpiderGC spGC = new SpiderGC(pref, profile);
@@ -378,6 +381,7 @@
 				cacheDB.clear();
 				profile.readIndex();
 				tbp.resetModel();
+				pref.setOldGCLanguage();
 			}
 			if (mev.selectedItem == loadGCVotes) {
 				if (sGCV == null)
@@ -417,6 +421,7 @@
 				Global.getProfile().setShowBlacklisted(false);
 				filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers & ~MenuItem.Checked;
 				tbp.resetModel();
+				pref.setOldGCLanguage();
 			}
 			if (mev.selectedItem == loadOC) {
 				OCXMLImporter oc = new OCXMLImporter(pref, profile);
@@ -431,8 +436,10 @@
 				filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers & ~MenuItem.Checked;
 				tbp.resetModel();
 			}
-			if (mev.selectedItem == update)
+			if (mev.selectedItem == update) {
 				updateSelectedCaches(tbp);
+				pref.setOldGCLanguage();
+			}
 			if (mev.selectedItem == mnuForceLogin) {
 				mnuForceLogin.modifiers ^= MenuItem.Checked;
 				Global.getPref().forceLogin = (mnuForceLogin.modifiers & MenuItem.Checked) != 0;

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2011-05-14 20:57:48 UTC (rev 3004)
+++ trunk/src/CacheWolf/Preferences.java	2011-05-15 18:20:09 UTC (rev 3005)
@@ -314,18 +314,16 @@
 	/** Width and height of free defined tile size */
 	public int tilewidth;
 	public int tileheight;
-
 	/** ShowCachesOnMap */
 	public boolean showCachesOnMap = true;
-
 	/** SortingGroupedByCache */
 	public boolean SortingGroupedByCache = true;
-
 	/** useOwnSymbols */
 	public boolean useOwnSymbols = true;
-
 	/** TRUE if we want automatic sorting **/
 	public boolean sortAutomatic = true;
+	//
+	public String oldLanguageCtl = "";
 
 	// ////////////////////////////////////////////
 	/**
@@ -1342,4 +1340,12 @@
 			absoluteBaseDir += "/";
 	}
 
+	public void setOldGCLanguage() {
+		if (oldLanguageCtl.length() != 0)
+			try {
+				UrlFetcher.fetch(oldLanguageCtl);
+			} catch (IOException e) {
+				// dann halt nicht
+			}
+	}
 }

Modified: trunk/src/CacheWolf/TravelbugJourneyScreen.java
===================================================================
--- trunk/src/CacheWolf/TravelbugJourneyScreen.java	2011-05-14 20:57:48 UTC (rev 3004)
+++ trunk/src/CacheWolf/TravelbugJourneyScreen.java	2011-05-15 18:20:09 UTC (rev 3005)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 /**
@@ -78,8 +78,8 @@
 import ewe.ui.mLabel;
 import ewe.ui.mTabbedPanel;
 
-public class TravelbugJourneyScreen extends Form  {
-	
+public class TravelbugJourneyScreen extends Form {
+
 	/** The list control */
 	private tbListControl tcTbJourneyList;
 	/** The list model */
@@ -88,588 +88,612 @@
 	private TravelbugJourneyList tblMyTravelbugJourneys;
 	/** The panel for the lower half of the screen */
 	private CellPanel lowerpane;
-	private mInput inpName,inpTrackingNo, 
-		   inpFromDate, inpFromProfile, inpFromWaypoint, 
-	       inpToDate, inpToProfile, inpToWaypoint;
+	private mInput inpName, inpTrackingNo, inpFromDate, inpFromProfile, inpFromWaypoint, inpToDate, inpToProfile, inpToWaypoint;
 	private mLabel lblId;
-	private mButton btnFromDate,btnToDate;
+	private mButton btnFromDate, btnToDate;
 	private mCheckBox chkFromLogged, chkToLogged;
 	private HtmlDisplay txtMission;
 	private mTabbedPanel pnlTab;
-    /**	 List of TBs in the current cache */
-	private TravelbugList tblSrcCache; 
+	/** List of TBs in the current cache */
+	private TravelbugList tblSrcCache;
 	/** The currently selected row */
-	private int selectedRow=-1;
-	/** A label which holds the number of currently displayed travelbug journeys*/
+	private int selectedRow = -1;
+	/** A label which holds the number of currently displayed travelbug journeys */
 	private mLabel lblNumVisibleJourneys;
-	private final Color RED=new Color(255,0,0);
-	private int exitKeys[]={75009};
-	/** A flag to track whether the current cache has to be saved because a travelbug
+	private final Color RED = new Color(255, 0, 0);
+	private int exitKeys[] = { 75009 };
+	/**
+	 * A flag to track whether the current cache has to be saved because a travelbug
 	 * was added to or taken from it.
 	 */
-	private boolean chDmodified=false;
-	
+	private boolean chDmodified = false;
+
 	/** The current cache */
 	private CacheHolderDetail chD;
 	/** The base data of the current cache */
 	private CacheHolder ch;
 	/** The name of the current waypoint */
-	private String waypoint="";
-	
+	private String waypoint = "";
+
 	public TravelbugJourneyScreen() {
-		CacheDB cacheDB=Global.getProfile().cacheDB;
+		CacheDB cacheDB = Global.getProfile().cacheDB;
 		SplittablePanel split = new SplittablePanel(PanelSplitter.VERTICAL);
 		CellPanel tablepane = split.getNextPanel();
-		int curCacheNo=Global.mainTab.tbP.getSelectedCache();
-		String cache="";
-		if (curCacheNo>=0 && curCacheNo<cacheDB.size()) {
-			ch=cacheDB.get(curCacheNo);
-			cache=MyLocale.getMsg(6022,": Current cache: ")+ch.getWayPoint()+" - "+ch.getCacheName();
-			waypoint=ch.getWayPoint();
-			chD=ch.getCacheDetails(true);
-			tblSrcCache=ch.getCacheDetails(true).Travelbugs;
+		int curCacheNo = Global.mainTab.tbP.getSelectedCache();
+		String cache = "";
+		if (curCacheNo >= 0 && curCacheNo < cacheDB.size()) {
+			ch = cacheDB.get(curCacheNo);
+			cache = MyLocale.getMsg(6022, ": Current cache: ") + ch.getWayPoint() + " - " + ch.getCacheName();
+			waypoint = ch.getWayPoint();
+			chD = ch.getCacheDetails(true);
+			tblSrcCache = ch.getCacheDetails(true).Travelbugs;
 		}
-		title="Travelbugs"+cache;
-		tcTbJourneyList=new tbListControl();
-		tcTbJourneyList.setTableModel(modTbJourneyList=new tbListTableModel());
-		tablepane.addLast(new MyScrollBarPanel(tcTbJourneyList,ScrollablePanel.AlwaysShowVerticalScrollers),STRETCH,FILL);
-	
+		title = "Travelbugs" + cache;
+		tcTbJourneyList = new tbListControl();
+		tcTbJourneyList.setTableModel(modTbJourneyList = new tbListTableModel());
+		tablepane.addLast(new MyScrollBarPanel(tcTbJourneyList, ScrollablePanel.AlwaysShowVerticalScrollers), STRETCH, FILL);
+
 		lowerpane = split.getNextPanel();
-		
-		pnlTab=new mTabbedPanel();
-		pnlTab.extraControlsRight=lblNumVisibleJourneys=new mLabel("  0");
-		//------------------------------------------------
+
+		pnlTab = new mTabbedPanel();
+		pnlTab.extraControlsRight = lblNumVisibleJourneys = new mLabel("  0");
+		// ------------------------------------------------
 		// First Tab - Name & Tracking #
-		//------------------------------------------------
-		CellPanel pnlName=new CellPanel();
-		pnlName.addNext(new mLabel(MyLocale.getMsg(6025,"Name:")),DONTSTRETCH,DONTFILL);
-		pnlName.addLast(inpName=new mInput(),HSTRETCH,HFILL);
-		pnlName.addNext(new mLabel(MyLocale.getMsg(6026,"Tracking #:")),DONTSTRETCH,DONTFILL);
-		pnlName.addLast(inpTrackingNo=new mInput(),HSTRETCH,HFILL);
-		pnlName.addNext(new mLabel(MyLocale.getMsg(6027,"ID/GUID:")),DONTSTRETCH,DONTFILL);
-		pnlName.addLast(lblId=new mLabel(""),HSTRETCH,HFILL);
-		pnlTab.addCard(pnlName,MyLocale.getMsg(6028,"Name"),"Name");
-		
-		//------------------------------------------------
+		// ------------------------------------------------
+		CellPanel pnlName = new CellPanel();
+		pnlName.addNext(new mLabel(MyLocale.getMsg(6025, "Name:")), DONTSTRETCH, DONTFILL);
+		pnlName.addLast(inpName = new mInput(), HSTRETCH, HFILL);
+		pnlName.addNext(new mLabel(MyLocale.getMsg(6026, "Tracking #:")), DONTSTRETCH, DONTFILL);
+		pnlName.addLast(inpTrackingNo = new mInput(), HSTRETCH, HFILL);
+		pnlName.addNext(new mLabel(MyLocale.getMsg(6027, "ID/GUID:")), DONTSTRETCH, DONTFILL);
+		pnlName.addLast(lblId = new mLabel(""), HSTRETCH, HFILL);
+		pnlTab.addCard(pnlName, MyLocale.getMsg(6028, "Name"), "Name");
+
+		// ------------------------------------------------
 		// Second Tab - Where was the TB picked up from
-		//------------------------------------------------
-		CellPanel pnlFrom=new CellPanel();
-		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6029,"Profile/Cache:")),DONTSTRETCH,DONTFILL|WEST);
-		pnlFrom.addNext(inpFromProfile=new mInput(),HSTRETCH,HFILL);
-		pnlFrom.addLast(inpFromWaypoint=new mInput(),HSTRETCH,HFILL);
-		
-		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6030,"Date found:")),DONTSTRETCH,DONTFILL|WEST);
-		pnlFrom.addNext(inpFromDate=new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		pnlFrom.addLast(btnFromDate=new mButton(new mImage("calendar.png")),DONTSTRETCH,DONTFILL|WEST);
-		btnFromDate.modify(0,ControlConstants.TakesKeyFocus);
-		
-		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6031,"Logged:")),DONTSTRETCH,DONTFILL|WEST);
-		pnlFrom.addLast(chkFromLogged=new mCheckBox(""),DONTSTRETCH,DONTFILL|WEST);
-		chkFromLogged.exitKeys=exitKeys;
+		// ------------------------------------------------
+		CellPanel pnlFrom = new CellPanel();
+		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6029, "Profile/Cache:")), DONTSTRETCH, DONTFILL | WEST);
+		pnlFrom.addNext(inpFromProfile = new mInput(), HSTRETCH, HFILL);
+		pnlFrom.addLast(inpFromWaypoint = new mInput(), HSTRETCH, HFILL);
+
+		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6030, "Date found:")), DONTSTRETCH, DONTFILL | WEST);
+		pnlFrom.addNext(inpFromDate = new mInput(), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		pnlFrom.addLast(btnFromDate = new mButton(new mImage("calendar.png")), DONTSTRETCH, DONTFILL | WEST);
+		btnFromDate.modify(0, ControlConstants.TakesKeyFocus);
+
+		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6031, "Logged:")), DONTSTRETCH, DONTFILL | WEST);
+		pnlFrom.addLast(chkFromLogged = new mCheckBox(""), DONTSTRETCH, DONTFILL | WEST);
+		chkFromLogged.exitKeys = exitKeys;
 		pnlFrom.addLast(new mLabel(""));
-		
-		pnlTab.addCard(pnlFrom,MyLocale.getMsg(6032,"From"),"From");
 
-		//------------------------------------------------
+		pnlTab.addCard(pnlFrom, MyLocale.getMsg(6032, "From"), "From");
+
+		// ------------------------------------------------
 		// Third Tab - Where was the TB dropped
-		//------------------------------------------------
-		CellPanel pnlTo=new CellPanel();
-		pnlTo.addNext(new mLabel(MyLocale.getMsg(6029,"Profile/Cache:")),DONTSTRETCH,DONTFILL|WEST);
-		pnlTo.addNext(inpToProfile=new mInput(),HSTRETCH,HFILL);
-		pnlTo.addLast(inpToWaypoint=new mInput(),HSTRETCH,HFILL);
-		
-		pnlTo.addNext(new mLabel(MyLocale.getMsg(6033,"Date dropped:")),DONTSTRETCH,DONTFILL|WEST);
-		pnlTo.addNext(inpToDate=new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		//inpToDate.modifyAll(DisplayOnly,0);
-		pnlTo.addLast(btnToDate=new mButton(new mImage("calendar.png")),DONTSTRETCH,DONTFILL|WEST);
-		btnToDate.modify(0,ControlConstants.TakesKeyFocus);
-		//pnlTo.addLast(new mLabel(""));
-		
-		pnlTo.addNext(new mLabel(MyLocale.getMsg(6031,"Logged:")),DONTSTRETCH,DONTFILL|WEST);
-		pnlTo.addLast(chkToLogged=new mCheckBox(""),DONTSTRETCH,DONTFILL|WEST);
-		chkToLogged.exitKeys=exitKeys;
+		// ------------------------------------------------
+		CellPanel pnlTo = new CellPanel();
+		pnlTo.addNext(new mLabel(MyLocale.getMsg(6029, "Profile/Cache:")), DONTSTRETCH, DONTFILL | WEST);
+		pnlTo.addNext(inpToProfile = new mInput(), HSTRETCH, HFILL);
+		pnlTo.addLast(inpToWaypoint = new mInput(), HSTRETCH, HFILL);
+
+		pnlTo.addNext(new mLabel(MyLocale.getMsg(6033, "Date dropped:")), DONTSTRETCH, DONTFILL | WEST);
+		pnlTo.addNext(inpToDate = new mInput(), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		// inpToDate.modifyAll(DisplayOnly,0);
+		pnlTo.addLast(btnToDate = new mButton(new mImage("calendar.png")), DONTSTRETCH, DONTFILL | WEST);
+		btnToDate.modify(0, ControlConstants.TakesKeyFocus);
+		// pnlTo.addLast(new mLabel(""));
+
+		pnlTo.addNext(new mLabel(MyLocale.getMsg(6031, "Logged:")), DONTSTRETCH, DONTFILL | WEST);
+		pnlTo.addLast(chkToLogged = new mCheckBox(""), DONTSTRETCH, DONTFILL | WEST);
+		chkToLogged.exitKeys = exitKeys;
 		pnlTo.addLast(new mLabel(""));
-		
-		pnlTab.addCard(pnlTo,MyLocale.getMsg(6034,"To"),"To");
-		
-		//------------------------------------------------
+
+		pnlTab.addCard(pnlTo, MyLocale.getMsg(6034, "To"), "To");
+
+		// ------------------------------------------------
 		// Last Panel - TB Mission
-		//------------------------------------------------
-		CellPanel pnlDest=new CellPanel();
-		pnlDest.addLast(new mLabel(MyLocale.getMsg(6035,"Mission:")));
-		pnlDest.addLast(txtMission=new HtmlDisplay(),STRETCH,FILL);
-		txtMission.rows=3;
-		pnlTab.addCard(pnlDest,MyLocale.getMsg(6036,"Mission"),"Mission");
+		// ------------------------------------------------
+		CellPanel pnlDest = new CellPanel();
+		pnlDest.addLast(new mLabel(MyLocale.getMsg(6035, "Mission:")));
+		pnlDest.addLast(txtMission = new HtmlDisplay(), STRETCH, FILL);
+		txtMission.rows = 3;
+		pnlTab.addCard(pnlDest, MyLocale.getMsg(6036, "Mission"), "Mission");
 
-		
-		lowerpane.addLast(pnlTab,STRETCH,FILL);
-		
-		
-		split.setSplitter(PanelSplitter.AFTER|PanelSplitter.HIDDEN,PanelSplitter.BEFORE|PanelSplitter.HIDDEN,0);
-		addLast(split,STRETCH,FILL);
-		//setPreferredSize(MyLocale.getScreenWidth()<=240?240:MyLocale.getScreenWidth()*2/3,240);
-		
-		tblMyTravelbugJourneys=new TravelbugJourneyList();
+		lowerpane.addLast(pnlTab, STRETCH, FILL);
+
+		split.setSplitter(PanelSplitter.AFTER | PanelSplitter.HIDDEN, PanelSplitter.BEFORE | PanelSplitter.HIDDEN, 0);
+		addLast(split, STRETCH, FILL);
+		// setPreferredSize(MyLocale.getScreenWidth()<=240?240:MyLocale.getScreenWidth()*2/3,240);
+
+		tblMyTravelbugJourneys = new TravelbugJourneyList();
 		tblMyTravelbugJourneys.readTravelbugsFile();
-		modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+		modTbJourneyList.numRows = tblMyTravelbugJourneys.size();
 		// Get the columns to display and their widths from preferences
-		modTbJourneyList.columnMap=
-			TableColumnChooser.str2Array(Global.getPref().travelbugColMap,0,11,0, -1);
-		modTbJourneyList.colWidth=
-			TableColumnChooser.str2Array(Global.getPref().travelbugColWidth,10,1024,50, -1);
-		modTbJourneyList.numCols=modTbJourneyList.columnMap.length;
-		
-		modTbJourneyList.select(0,12,true);
+		modTbJourneyList.columnMap = TableColumnChooser.str2Array(Global.getPref().travelbugColMap, 0, 11, 0, -1);
+		modTbJourneyList.colWidth = TableColumnChooser.str2Array(Global.getPref().travelbugColWidth, 10, 1024, 50, -1);
+		modTbJourneyList.numCols = modTbJourneyList.columnMap.length;
+
+		modTbJourneyList.select(0, 12, true);
 		/* Restore the saved setting about showing only non-logged bugs */
 		if (Global.getPref().travelbugShowOnlyNonLogged) {
 			tcTbJourneyList.toggleNonLogged();
 		}
 		updateNumBugs();
 	}
-	
+
 	/** Indicate the number of journeys currently displayed */
 	private void updateNumBugs() {
-		lblNumVisibleJourneys.setText(""+modTbJourneyList.numRows);
+		lblNumVisibleJourneys.setText("" + modTbJourneyList.numRows);
 		lblNumVisibleJourneys.repaint();
 	}
-	
+
 	/** The control which had the last focus */
 	private Control currentControl;
-	
-	public void onEvent(Event ev){
-		// Update the table from the input form  
-		if ((ev instanceof MultiPanelEvent || ev instanceof ControlEvent || ev instanceof DataChangeEvent) && selectedRow!=-1 &&
-				selectedRow<tblMyTravelbugJourneys.size()){
-			TravelbugJourney tbj=tblMyTravelbugJourneys.getTBJourney(selectedRow);
-			if (currentControl==inpName) 			tbj.getTb().setName(inpName.getText());
-			else if (currentControl==inpTrackingNo)  tbj.getTb().setTrackingNo(inpTrackingNo.getText());
-			else if (currentControl==inpFromProfile) tbj.setFromProfile(inpFromProfile.getText());
-			else if (currentControl==inpFromWaypoint)tbj.setFromWaypoint(inpFromWaypoint.getText());
-			else if (currentControl==inpFromDate)    tbj.setFromDate(inpFromDate.getText());
-			else if (currentControl==chkFromLogged)  tbj.setFromLogged(chkFromLogged.state);
-			else if (currentControl==inpToProfile)   tbj.setToProfile(inpToProfile.getText());
-			else if (currentControl==inpToWaypoint)  tbj.setToWaypoint(inpToWaypoint.getText());
-			else if (currentControl==inpToDate)      tbj.setToDate(inpToDate.getText());
-			else if (currentControl==chkToLogged)    tbj.setToLogged(chkToLogged.state);
-			//else if (ev.target==txtMission)     tb.setMission(txtMission.getText());
+
+	public void onEvent(Event ev) {
+		// Update the table from the input form
+		if ((ev instanceof MultiPanelEvent || ev instanceof ControlEvent || ev instanceof DataChangeEvent) && selectedRow != -1 && selectedRow < tblMyTravelbugJourneys.size()) {
+			TravelbugJourney tbj = tblMyTravelbugJourneys.getTBJourney(selectedRow);
+			if (currentControl == inpName)
+				tbj.getTb().setName(inpName.getText());
+			else if (currentControl == inpTrackingNo)
+				tbj.getTb().setTrackingNo(inpTrackingNo.getText());
+			else if (currentControl == inpFromProfile)
+				tbj.setFromProfile(inpFromProfile.getText());
+			else if (currentControl == inpFromWaypoint)
+				tbj.setFromWaypoint(inpFromWaypoint.getText());
+			else if (currentControl == inpFromDate)
+				tbj.setFromDate(inpFromDate.getText());
+			else if (currentControl == chkFromLogged)
+				tbj.setFromLogged(chkFromLogged.state);
+			else if (currentControl == inpToProfile)
+				tbj.setToProfile(inpToProfile.getText());
+			else if (currentControl == inpToWaypoint)
+				tbj.setToWaypoint(inpToWaypoint.getText());
+			else if (currentControl == inpToDate)
+				tbj.setToDate(inpToDate.getText());
+			else if (currentControl == chkToLogged)
+				tbj.setToLogged(chkToLogged.state);
+			// else if (ev.target==txtMission) tb.setMission(txtMission.getText());
 			tcTbJourneyList.repaint();
 		}
-		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED && selectedRow!=-1){
-			if (ev.target==inpTrackingNo) {pnlTab.selectNextTab(true,true); Gui.takeFocus(inpFromProfile,ControlConstants.ByKeyboard);pnlTab.repaint(); }
-			if (ev.target==inpFromDate) Gui.takeFocus(chkFromLogged,ControlConstants.ByKeyboard);
-			if (ev.target==inpToDate) Gui.takeFocus(chkToLogged,ControlConstants.ByKeyboard);
-			if (ev.target==btnFromDate || ev.target==btnToDate) {
-				mInput inpDate=ev.target==btnFromDate ? inpFromDate : inpToDate;
-				DateTimeChooser dc=new DateTimeChooser(Vm.getLocale());
-				dc.title=MyLocale.getMsg(328,"Date found"); 
-				dc.setPreferredSize(240,240);
-				String foundDate=inpDate.getText();
-				Time t=new Time();
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED && selectedRow != -1) {
+			if (ev.target == inpTrackingNo) {
+				pnlTab.selectNextTab(true, true);
+				Gui.takeFocus(inpFromProfile, ControlConstants.ByKeyboard);
+				pnlTab.repaint();
+			}
+			if (ev.target == inpFromDate)
+				Gui.takeFocus(chkFromLogged, ControlConstants.ByKeyboard);
+			if (ev.target == inpToDate)
+				Gui.takeFocus(chkToLogged, ControlConstants.ByKeyboard);
+			if (ev.target == btnFromDate || ev.target == btnToDate) {
+				mInput inpDate = ev.target == btnFromDate ? inpFromDate : inpToDate;
+				DateTimeChooser dc = new DateTimeChooser(Vm.getLocale());
+				dc.title = MyLocale.getMsg(328, "Date found");
+				dc.setPreferredSize(240, 240);
+				String foundDate = inpDate.getText();
+				Time t = new Time();
 				try {
-					t.parse(foundDate,"y-M-d H:m");
-				} catch(IllegalArgumentException e) {
+					t.parse(foundDate, "y-M-d H:m");
+				} catch (IllegalArgumentException e) {
 					try {
-						t.parse(foundDate,"y-M-d");
-					} catch(IllegalArgumentException e1) {
+						t.parse(foundDate, "y-M-d");
+					} catch (IllegalArgumentException e1) {
 						// Can't parse date - should not happen
 					}
-				};
+				}
+				;
 				dc.reset(t);
-				if (dc.execute()==ewe.ui.FormBase.IDOK) {
-				  inpDate.setText(Convert.toString(dc.year)+"-"+MyLocale.formatLong(dc.month,"00")+"-"+MyLocale.formatLong(dc.day,"00")+" "+dc.time);
-				  if (ev.target==btnFromDate){ 
-					  tblMyTravelbugJourneys.getTBJourney(selectedRow).setFromDate(inpDate.getText());
-					  Gui.takeFocus(chkFromLogged,ControlConstants.ByKeyboard);
-				  } else {
-					  tblMyTravelbugJourneys.getTBJourney(selectedRow).setToDate(inpDate.getText());
-					  Gui.takeFocus(chkToLogged,ControlConstants.ByKeyboard);
-				  } tcTbJourneyList.repaint();
-				}				
+				if (dc.execute() == ewe.ui.FormBase.IDOK) {
+					inpDate.setText(Convert.toString(dc.year) + "-" + MyLocale.formatLong(dc.month, "00") + "-" + MyLocale.formatLong(dc.day, "00") + " " + dc.time);
+					if (ev.target == btnFromDate) {
+						tblMyTravelbugJourneys.getTBJourney(selectedRow).setFromDate(inpDate.getText());
+						Gui.takeFocus(chkFromLogged, ControlConstants.ByKeyboard);
+					} else {
+						tblMyTravelbugJourneys.getTBJourney(selectedRow).setToDate(inpDate.getText());
+						Gui.takeFocus(chkToLogged, ControlConstants.ByKeyboard);
+					}
+					tcTbJourneyList.repaint();
+				}
 			}
 		}
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.EXITED){
-			pnlTab.selectNextTab(true,true); 
-			if (ev.target==chkFromLogged) Gui.takeFocus(inpToProfile,ControlConstants.ByKeyboard);
-			if (ev.target==chkToLogged) Gui.takeFocus(txtMission,ControlConstants.ByKeyboard);
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.EXITED) {
+			pnlTab.selectNextTab(true, true);
+			if (ev.target == chkFromLogged)
+				Gui.takeFocus(inpToProfile, ControlConstants.ByKeyboard);
+			if (ev.target == chkToLogged)
+				Gui.takeFocus(txtMission, ControlConstants.ByKeyboard);
 		}
 		// The user closed the travelbugs screen
-		if (ev instanceof FormEvent && ev.type==FormEvent.CLOSED  && chD!=null) {
+		if (ev instanceof FormEvent && ev.type == FormEvent.CLOSED && chD != null) {
 			tblMyTravelbugJourneys.saveTravelbugsFile();
 			tblMyTravelbugJourneys.clear();
 			// Save the flag about showing non-logged journeys only
-			boolean old=Global.getPref().travelbugShowOnlyNonLogged;
-			Global.getPref().travelbugShowOnlyNonLogged=(tcTbJourneyList.mnuToggleList.modifiers & MenuItem.Checked) == MenuItem.Checked;
-			String travelbugColWidth=modTbJourneyList.getColWidths();
+			boolean old = Global.getPref().travelbugShowOnlyNonLogged;
+			Global.getPref().travelbugShowOnlyNonLogged = (tcTbJourneyList.mnuToggleList.modifiers & MenuItem.Checked) == MenuItem.Checked;
+			String travelbugColWidth = modTbJourneyList.getColWidths();
 			// If the preferences changed, save the pref.xml file
 			Vm.showWait(true);
-			if (!Global.getPref().travelbugColWidth.equals(travelbugColWidth) ||
-				old!=Global.getPref().travelbugShowOnlyNonLogged) {
-				Global.getPref().travelbugColWidth=travelbugColWidth;
+			if (!Global.getPref().travelbugColWidth.equals(travelbugColWidth) || old != Global.getPref().travelbugShowOnlyNonLogged) {
+				Global.getPref().travelbugColWidth = travelbugColWidth;
 				Global.getPref().savePreferences();
 			}
 			// If the list of travelbugs in the cache was modified, we need to save the cache too
 			if (chDmodified) {
-				ch.setHas_bugs(chD.Travelbugs.size()>0);
+				ch.setHas_bugs(chD.Travelbugs.size() > 0);
 				ch.save();
 			}
 			Vm.showWait(false);
-			chD=null;
+			chD = null;
 		}
 		updateNumBugs();
-		currentControl=Gui.focusedControl();
+		currentControl = Gui.focusedControl();
 	}
-	
-	
-//==============================================================
-// tbListTableModel
-//==============================================================
-class tbListTableModel extends TableModel {
-	private FontMetrics fm;
-	private Image imgRed;
-	tbListTableModel() {
-		
-		fillToEqualHeights=true;
-		allRowsSameSize=true;
-		hasRowHeaders=false;
-		//shadeAlternateRows=true;
-		cursorSize=new Dimension(12,1);
-		clipData=true;
-		fm=getFontMetrics();
-		// A red dot indicates that the journey has not been completely logged
-		imgRed = new Image("red.png");
-	}
-    private int colWidth[];
-	private int columnMap[];
-	
-	public Object getCellText(int row, int col) {
-		return null;
-	}
 
-	public Object getCellData(int row, int col){
-		if(row == -1){
-			return TravelbugJourney.getElementNameByNumber(columnMap[col]);
-		} else {
-			int map=columnMap[col];
-			// If we have not yet logged the from or the to, a red dot is placed in front of the first item
-			if (col==0 && (!tblMyTravelbugJourneys.getTBJourney(row).getFromLogged() ||
-				!tblMyTravelbugJourneys.getTBJourney(row).getToLogged())) { 
-				// Is it a column with a checkbox?
-				if (map!=7 && map!=11) 
-					return new IconAndText((IImage)imgRed,(String) tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map),fm);
-				else { // Checkbox - special treatment
-					IconAndText iat=new IconAndText(imgRed,"",fm);
-					iat.addColumn(tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map));
-					return iat;
-				}
-			} else 
-				return tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map);
-		}	
-	}
-	public int calculateRowHeight(int row) {
-		return charHeight+2;
-	}
-	
-	public int calculateColWidth(int col){
-		if(col == -1) 
-        	return 0;
-        else if (col<numCols)
-        	return colWidth[columnMap[col]];
-        else return 0;
-	}
-	
-	public TableCellAttributes getCellAttributes(int row,int col,boolean isSelected,TableCellAttributes ta) {
-		ta=super.getCellAttributes(row,col,isSelected,ta);
-		ta.alignment = CellConstants.LEFT;
-		ta.anchor = CellConstants.LEFT;
-		// Color the elements red, if we have not yet logged
-		if (row>=0)
-		switch (columnMap[col]) {
-		case 6: // fromDate
-				if (!tblMyTravelbugJourneys.getTBJourney(row).getFromLogged()) ta.foreground=RED;
-				break;
-		case 10: // toDate
-				if (!tblMyTravelbugJourneys.getTBJourney(row).getToLogged()) ta.foreground=RED;
-				break;
+	// ==============================================================
+	// tbListTableModel
+	// ==============================================================
+	class tbListTableModel extends TableModel {
+		private FontMetrics fm;
+		private Image imgRed;
+
+		tbListTableModel() {
+
+			fillToEqualHeights = true;
+			allRowsSameSize = true;
+			hasRowHeaders = false;
+			// shadeAlternateRows=true;
+			cursorSize = new Dimension(12, 1);
+			clipData = true;
+			fm = getFontMetrics();
+			// A red dot indicates that the journey has not been completely logged
+			imgRed = new Image("red.png");
 		}
-		return ta;
-	}
 
-	private void showFields(TravelbugJourney tbj) {
-	   	inpName.setText(tbj.getTb().getName());
-		inpTrackingNo.setText(tbj.getTb().getTrackingNo());
-		lblId.setText(tbj.getTb().getGuid());
-		inpFromProfile.setText(tbj.getFromProfile());
-		inpFromWaypoint.setText(tbj.getFromWaypoint());
-		inpFromDate.setText(tbj.getFromDate());
-		chkFromLogged.setState(tbj.getFromLogged());
-		inpToProfile.setText(tbj.getToProfile());
-		inpToWaypoint.setText(tbj.getToWaypoint());
-		inpToDate.setText(tbj.getToDate());
-		chkToLogged.setState(tbj.getToLogged());
-		txtMission.setHtml(tbj.getTb().getMission());
-	}
-	
-	private boolean sortAsc=false;
-	private int sortedBy = -1;
-	private int lastRow=-1;
-	public int penEventModifiers; 
+		private int colWidth[];
+		private int columnMap[];
 
-	public boolean penPressed(Point onTable,Point cell){
-		boolean retval=false;
-		if(cell!=null && cell.y == -1){ // Hit a header => sort the table accordingly
-			Vm.showWait(true);
-			if (cell.x == sortedBy) sortAsc=!sortAsc;
-			else sortAsc = false;
-			sortedBy = cell.x;
-			// Check whether the list only shows non-logged journeys. If so, a subset
-			// of the table must be sorted
-			if ((tcTbJourneyList.mnuToggleList.modifiers & MenuItem.Checked) == MenuItem.Checked) {
-				tblMyTravelbugJourneys.sortFirstHalf(columnMap[cell.x], sortAsc,modTbJourneyList.numRows);
-			} else { // Showing all journeys - sort the full table
-				tblMyTravelbugJourneys.sort(columnMap[cell.x], sortAsc);
+		public Object getCellText(int row, int col) {
+			return null;
+		}
+
+		public Object getCellData(int row, int col) {
+			if (row == -1) {
+				return TravelbugJourney.getElementNameByNumber(columnMap[col]);
+			} else {
+				int map = columnMap[col];
+				// If we have not yet logged the from or the to, a red dot is placed in front of the first item
+				if (col == 0 && (!tblMyTravelbugJourneys.getTBJourney(row).getFromLogged() || !tblMyTravelbugJourneys.getTBJourney(row).getToLogged())) {
+					// Is it a column with a checkbox?
+					if (map != 7 && map != 11)
+						return new IconAndText((IImage) imgRed, (String) tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map), fm);
+					else { // Checkbox - special treatment
+						IconAndText iat = new IconAndText(imgRed, "", fm);
+						iat.addColumn(tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map));
+						return iat;
+					}
+				} else
+					return tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map);
 			}
-			tcTbJourneyList.repaint();
-			Vm.showWait(false);
-			retval = true;
-		} else if (cell!=null && cell.y>=0 && (penEventModifiers & IKeys.SHIFT)>0) {
-			// A range of rows can be marked by shift-click on the first and last row
-			if (lastRow!=-1) { // Second row being marked with shift key pressed
-				if (lastRow<cell.y)
-					toggleSelect(lastRow,cell.y);
-				else
-					toggleSelect(cell.y,lastRow);
-				lastRow=-1;
-				retval=true;
-			} else { // Remember this row as start of range, but don't toggle yet
-				lastRow=cell.y;
-			}
-		} else { // Single row marked
-			lastRow=-1;
 		}
-		return retval;
-	}
 
-	/** Select a range of rows */
-	private void toggleSelect(int fromRow, int toRow) {
-		tcTbJourneyList.clearSelection(null);
-		tcTbJourneyList.addToSelection(new Rect(0,fromRow,numCols,toRow-fromRow+1),false,true);
-	}
-	
-	/**
-	 * Return the column widths as a comma delimited string for storing in the preferences
-	 * @return
-	 */
-	private String getColWidths() {
-		// Update the list with the current widths
-		for (int col=0; col<numCols; col++) {
-			colWidth[columnMap[col]]=getColWidth(col);
+		public int calculateRowHeight(int row) {
+			return charHeight + 2;
 		}
-		// Convert to string
-		StringBuffer sb=new StringBuffer(40);
-		for (int i=0; i<colWidth.length; i++) {
-			if (sb.length()!=0) sb.append(',');
-			sb.append(colWidth[i]);
-		}
-		return sb.toString();
-	}
-}
 
-//==============================================================
-//tbListControl
-//==============================================================
-class tbListControl extends TableControl {
-	private MenuItem mnuNewTB, mnuDeleteTB,mnuGetMission,mnuOpenOnline,mnuDropTB,mnuPickupTB,mnuDeleteTBs;
-	public MenuItem mnuToggleList;
-	private Menu mnuFullMenu,mnuDeleteMenu;
-	
-	tbListControl() {
-		MenuItem[] TBMenuItems=new MenuItem[10];
-		TBMenuItems[0]= mnuPickupTB = new MenuItem(MyLocale.getMsg(6040,"Pick up TB from current cache"));
-		TBMenuItems[1]= mnuDropTB = new MenuItem(MyLocale.getMsg(6041,"Drop TB in cache"));
-		TBMenuItems[2]= new MenuItem("-");
-		TBMenuItems[3]= mnuNewTB = new MenuItem(MyLocale.getMsg(6042,"New Travelbug"));
-		TBMenuItems[4]= mnuDeleteTB = new MenuItem(MyLocale.getMsg(6043,"Delete Travelbug"));
-		TBMenuItems[5]= new MenuItem("-");
-		TBMenuItems[6]= mnuGetMission = new MenuItem(MyLocale.getMsg(6044,"Get Mission"));
-		TBMenuItems[7]= mnuOpenOnline = new MenuItem(MyLocale.getMsg(6045,"Open on-line"));
-		TBMenuItems[8]= new MenuItem("-");
-		TBMenuItems[9]= mnuToggleList = new MenuItem(MyLocale.getMsg(6046,"Show only not logged"));
-		mnuFullMenu=new Menu(TBMenuItems,"");
-		// A second pop-up menu with only one entry, if a range of rows is selected
-		MenuItem[] TBMenuItemsDel=new MenuItem[1];
-		TBMenuItemsDel[0]=mnuDeleteTBs=new MenuItem(MyLocale.getMsg(6047,"Delete selected Travelbugs"));
-		mnuDeleteMenu=new Menu(TBMenuItemsDel,"");
-		mnuDropTB.modifiers|=MenuItem.Disabled;
-		mnuDeleteTB.modifiers|=MenuItem.Disabled;
-		mnuGetMission.modifiers|=MenuItem.Disabled;
-		mnuOpenOnline.modifiers|=MenuItem.Disabled;
-	}
-	
-	public void onEvent(Event ev) {
-		Rect sel=getSelection(null);
-		if (sel.y<tblMyTravelbugJourneys.size()) {
-			mnuDeleteTB.modifiers&=~MenuItem.Disabled;
-			mnuGetMission.modifiers&=~MenuItem.Disabled;
-			mnuOpenOnline.modifiers&=~MenuItem.Disabled;
-			if (tblMyTravelbugJourneys.getTBJourney(sel.y).inMyPosession()) 
-				mnuDropTB.modifiers&=~MenuItem.Disabled;
+		public int calculateColWidth(int col) {
+			if (col == -1)
+				return 0;
+			else if (col < numCols)
+				return colWidth[columnMap[col]];
 			else
-				mnuDropTB.modifiers|=MenuItem.Disabled;
-		} else {
-			mnuDeleteTB.modifiers|=MenuItem.Disabled;
-			mnuGetMission.modifiers|=MenuItem.Disabled;
-			mnuOpenOnline.modifiers|=MenuItem.Disabled;
+				return 0;
 		}
-		// If more than one row is selected, show the limited pop-up menu
-		if (sel.height>1)
-			setMenu(mnuDeleteMenu);
-		else
-			setMenu(mnuFullMenu);
-	    if (ev instanceof PenEvent) modTbJourneyList.penEventModifiers=((PenEvent)ev).modifiers;
-		super.onEvent(ev);
-	}
 
-	public void penRightReleased(Point p){
-		menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
-	}
+		public TableCellAttributes getCellAttributes(int row, int col, boolean isSelected, TableCellAttributes ta) {
+			ta = super.getCellAttributes(row, col, isSelected, ta);
+			ta.alignment = CellConstants.LEFT;
+			ta.anchor = CellConstants.LEFT;
+			// Color the elements red, if we have not yet logged
+			if (row >= 0)
+				switch (columnMap[col]) {
+				case 6: // fromDate
+					if (!tblMyTravelbugJourneys.getTBJourney(row).getFromLogged())
+						ta.foreground = RED;
+					break;
+				case 10: // toDate
+					if (!tblMyTravelbugJourneys.getTBJourney(row).getToLogged())
+						ta.foreground = RED;
+					break;
+				}
+			return ta;
+		}
 
-	public void penHeld(Point p){
-		menuState.doShowMenu(p,true,null); 
-	}
+		private void showFields(TravelbugJourney tbj) {
+			inpName.setText(tbj.getTb().getName());
+			inpTrackingNo.setText(tbj.getTb().getTrackingNo());
+			lblId.setText(tbj.getTb().getGuid());
+			inpFromProfile.setText(tbj.getFromProfile());
+			inpFromWaypoint.setText(tbj.getFromWaypoint());
+			inpFromDate.setText(tbj.getFromDate());
+			chkFromLogged.setState(tbj.getFromLogged());
+			inpToProfile.setText(tbj.getToProfile());
+			inpToWaypoint.setText(tbj.getToWaypoint());
+			inpToDate.setText(tbj.getToDate());
+			chkToLogged.setState(tbj.getToLogged());
+			txtMission.setHtml(tbj.getTb().getMission());
+		}
 
-	public void popupMenuEvent(Object selectedItem){
-		if (selectedItem==mnuPickupTB) {
-			Travelbug tb=TravelbugPickup.pickupTravelbug(tblSrcCache);	
-			if (tb!=null) {
-				chDmodified=true;
-				tblMyTravelbugJourneys.addTbPickup(tb,Global.getProfile().name,waypoint);
-				modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+		private boolean sortAsc = false;
+		private int sortedBy = -1;
+		private int lastRow = -1;
+		public int penEventModifiers;
+
+		public boolean penPressed(Point onTable, Point cell) {
+			boolean retval = false;
+			if (cell != null && cell.y == -1) { // Hit a header => sort the table accordingly
+				Vm.showWait(true);
+				if (cell.x == sortedBy)
+					sortAsc = !sortAsc;
+				else
+					sortAsc = false;
+				sortedBy = cell.x;
+				// Check whether the list only shows non-logged journeys. If so, a subset
+				// of the table must be sorted
+				if ((tcTbJourneyList.mnuToggleList.modifiers & MenuItem.Checked) == MenuItem.Checked) {
+					tblMyTravelbugJourneys.sortFirstHalf(columnMap[cell.x], sortAsc, modTbJourneyList.numRows);
+				} else { // Showing all journeys - sort the full table
+					tblMyTravelbugJourneys.sort(columnMap[cell.x], sortAsc);
+				}
 				tcTbJourneyList.repaint();
+				Vm.showWait(false);
+				retval = true;
+			} else if (cell != null && cell.y >= 0 && (penEventModifiers & IKeys.SHIFT) > 0) {
+				// A range of rows can be marked by shift-click on the first and last row
+				if (lastRow != -1) { // Second row being marked with shift key pressed
+					if (lastRow < cell.y)
+						toggleSelect(lastRow, cell.y);
+					else
+						toggleSelect(cell.y, lastRow);
+					lastRow = -1;
+					retval = true;
+				} else { // Remember this row as start of range, but don't toggle yet
+					lastRow = cell.y;
+				}
+			} else { // Single row marked
+				lastRow = -1;
 			}
+			return retval;
 		}
-		if (selectedItem==mnuDropTB) {
-			if (selectedRow>=0 && selectedRow<modTbJourneyList.numRows) {
-				Travelbug tb=tblMyTravelbugJourneys.getTBJourney(selectedRow).getTb();
-				chD.Travelbugs.add(tb);
-				tblMyTravelbugJourneys.addTbDrop(tb,Global.getProfile().name,waypoint);
-				chDmodified=true;
-				ch.setHas_bugs(true);
+
+		/** Select a range of rows */
+		private void toggleSelect(int fromRow, int toRow) {
+			tcTbJourneyList.clearSelection(null);
+			tcTbJourneyList.addToSelection(new Rect(0, fromRow, numCols, toRow - fromRow + 1), false, true);
+		}
+
+		/**
+		 * Return the column widths as a comma delimited string for storing in the preferences
+		 * 
+		 * @return
+		 */
+		private String getColWidths() {
+			// Update the list with the current widths
+			for (int col = 0; col < numCols; col++) {
+				colWidth[columnMap[col]] = getColWidth(col);
 			}
-			repaint();
+			// Convert to string
+			StringBuffer sb = new StringBuffer(40);
+			for (int i = 0; i < colWidth.length; i++) {
+				if (sb.length() != 0)
+					sb.append(',');
+				sb.append(colWidth[i]);
+			}
+			return sb.toString();
 		}
-		if (selectedItem==mnuNewTB) {
-			TravelbugJourney tbj=new TravelbugJourney("New");
-			tbj.setFromProfile(Global.getProfile().name);
-			tbj.setFromWaypoint(waypoint);
-			tblMyTravelbugJourneys.add(tbj);
-			modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
-			cursorTo(tblMyTravelbugJourneys.size()-1,1,true);
-			tcTbJourneyList.repaint();
+	}
+
+	// ==============================================================
+	// tbListControl
+	// ==============================================================
+	class tbListControl extends TableControl {
+		private MenuItem mnuNewTB, mnuDeleteTB, mnuGetMission, mnuOpenOnline, mnuDropTB, mnuPickupTB, mnuDeleteTBs;
+		public MenuItem mnuToggleList;
+		private Menu mnuFullMenu, mnuDeleteMenu;
+
+		tbListControl() {
+			MenuItem[] TBMenuItems = new MenuItem[10];
+			TBMenuItems[0] = mnuPickupTB = new MenuItem(MyLocale.getMsg(6040, "Pick up TB from current cache"));
+			TBMenuItems[1] = mnuDropTB = new MenuItem(MyLocale.getMsg(6041, "Drop TB in cache"));
+			TBMenuItems[2] = new MenuItem("-");
+			TBMenuItems[3] = mnuNewTB = new MenuItem(MyLocale.getMsg(6042, "New Travelbug"));
+			TBMenuItems[4] = mnuDeleteTB = new MenuItem(MyLocale.getMsg(6043, "Delete Travelbug"));
+			TBMenuItems[5] = new MenuItem("-");
+			TBMenuItems[6] = mnuGetMission = new MenuItem(MyLocale.getMsg(6044, "Get Mission"));
+			TBMenuItems[7] = mnuOpenOnline = new MenuItem(MyLocale.getMsg(6045, "Open on-line"));
+			TBMenuItems[8] = new MenuItem("-");
+			TBMenuItems[9] = mnuToggleList = new MenuItem(MyLocale.getMsg(6046, "Show only not logged"));
+			mnuFullMenu = new Menu(TBMenuItems, "");
+			// A second pop-up menu with only one entry, if a range of rows is selected
+			MenuItem[] TBMenuItemsDel = new MenuItem[1];
+			TBMenuItemsDel[0] = mnuDeleteTBs = new MenuItem(MyLocale.getMsg(6047, "Delete selected Travelbugs"));
+			mnuDeleteMenu = new Menu(TBMenuItemsDel, "");
+			mnuDropTB.modifiers |= MenuItem.Disabled;
+			mnuDeleteTB.modifiers |= MenuItem.Disabled;
+			mnuGetMission.modifiers |= MenuItem.Disabled;
+			mnuOpenOnline.modifiers |= MenuItem.Disabled;
 		}
-		if (selectedItem==mnuDeleteTB && selectedRow>=0) {
-			tblMyTravelbugJourneys.remove(selectedRow);
-			modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
-			if (selectedRow>0) 
-				cursorTo(selectedRow-1,0,true);
+
+		public void onEvent(Event ev) {
+			Rect sel = getSelection(null);
+			if (sel.y < tblMyTravelbugJourneys.size()) {
+				mnuDeleteTB.modifiers &= ~MenuItem.Disabled;
+				mnuGetMission.modifiers &= ~MenuItem.Disabled;
+				mnuOpenOnline.modifiers &= ~MenuItem.Disabled;
+				if (tblMyTravelbugJourneys.getTBJourney(sel.y).inMyPosession())
+					mnuDropTB.modifiers &= ~MenuItem.Disabled;
+				else
+					mnuDropTB.modifiers |= MenuItem.Disabled;
+			} else {
+				mnuDeleteTB.modifiers |= MenuItem.Disabled;
+				mnuGetMission.modifiers |= MenuItem.Disabled;
+				mnuOpenOnline.modifiers |= MenuItem.Disabled;
+			}
+			// If more than one row is selected, show the limited pop-up menu
+			if (sel.height > 1)
+				setMenu(mnuDeleteMenu);
 			else
-				modTbJourneyList.showFields(new TravelbugJourney(""));
-			tcTbJourneyList.repaint();
+				setMenu(mnuFullMenu);
+			if (ev instanceof PenEvent)
+				modTbJourneyList.penEventModifiers = ((PenEvent) ev).modifiers;
+			super.onEvent(ev);
 		}
-		/* Delete a group of travelbugs which have been marked with Shift-Click */
-		if (selectedItem==mnuDeleteTBs) {  
-			Rect sel=getSelection(null);
-			for (int i=0; i<sel.height; i++)
-				tblMyTravelbugJourneys.remove(sel.y);
-			modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
-			if (sel.y<modTbJourneyList.numRows) 
-				cursorTo(sel.y,0,true);
-			else
-				modTbJourneyList.showFields(new TravelbugJourney(""));
-			tcTbJourneyList.repaint();
+
+		public void penRightReleased(Point p) {
+			menuState.doShowMenu(p, true, null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
 		}
-		if (selectedItem==mnuGetMission && selectedRow>-1) {
-			TravelbugJourney tbj=tblMyTravelbugJourneys.getTBJourney(selectedRow);
-			SpiderGC spider=new SpiderGC(Global.getPref(),Global.getProfile());
-			Vm.showWait(true);
-			
-			//if we have an ID, get mission by ID
-			if (tbj.getTb().getGuid().length()!=0) {
-				tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
-			} else {
-				//try to get mission and name by tracking number
-				boolean suceeded = false;
-				if (tbj.getTb().getTrackingNo().length() != 0) {
-					suceeded = spider.getBugMissionAndNameByTrackNr(tbj.getTb());
+
+		public void penHeld(Point p) {
+			menuState.doShowMenu(p, true, null);
+		}
+
+		public void popupMenuEvent(Object selectedItem) {
+			if (selectedItem == mnuPickupTB) {
+				Travelbug tb = TravelbugPickup.pickupTravelbug(tblSrcCache);
+				if (tb != null) {
+					chDmodified = true;
+					tblMyTravelbugJourneys.addTbPickup(tb, Global.getProfile().name, waypoint);
+					modTbJourneyList.numRows = tblMyTravelbugJourneys.size();
+					tcTbJourneyList.repaint();
 				}
-				//if this has't worked, try to get ID by name
-				if (!suceeded) {
-					tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName().trim()));
-					//if we have an ID now, get mission by ID
-					if (tbj.getTb().getGuid().length()!=0) {
-						tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+			}
+			if (selectedItem == mnuDropTB) {
+				if (selectedRow >= 0 && selectedRow < modTbJourneyList.numRows) {
+					Travelbug tb = tblMyTravelbugJourneys.getTBJourney(selectedRow).getTb();
+					chD.Travelbugs.add(tb);
+					tblMyTravelbugJourneys.addTbDrop(tb, Global.getProfile().name, waypoint);
+					chDmodified = true;
+					ch.setHas_bugs(true);
+				}
+				repaint();
+			}
+			if (selectedItem == mnuNewTB) {
+				TravelbugJourney tbj = new TravelbugJourney("New");
+				tbj.setFromProfile(Global.getProfile().name);
+				tbj.setFromWaypoint(waypoint);
+				tblMyTravelbugJourneys.add(tbj);
+				modTbJourneyList.numRows = tblMyTravelbugJourneys.size();
+				cursorTo(tblMyTravelbugJourneys.size() - 1, 1, true);
+				tcTbJourneyList.repaint();
+			}
+			if (selectedItem == mnuDeleteTB && selectedRow >= 0) {
+				tblMyTravelbugJourneys.remove(selectedRow);
+				modTbJourneyList.numRows = tblMyTravelbugJourneys.size();
+				if (selectedRow > 0)
+					cursorTo(selectedRow - 1, 0, true);
+				else
+					modTbJourneyList.showFields(new TravelbugJourney(""));
+				tcTbJourneyList.repaint();
+			}
+			/* Delete a group of travelbugs which have been marked with Shift-Click */
+			if (selectedItem == mnuDeleteTBs) {
+				Rect sel = getSelection(null);
+				for (int i = 0; i < sel.height; i++)
+					tblMyTravelbugJourneys.remove(sel.y);
+				modTbJourneyList.numRows = tblMyTravelbugJourneys.size();
+				if (sel.y < modTbJourneyList.numRows)
+					cursorTo(sel.y, 0, true);
+				else
+					modTbJourneyList.showFields(new TravelbugJourney(""));
+				tcTbJourneyList.repaint();
+			}
+			if (selectedItem == mnuGetMission && selectedRow > -1) {
+				TravelbugJourney tbj = tblMyTravelbugJourneys.getTBJourney(selectedRow);
+				SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
+				Vm.showWait(true);
+
+				// if we have an ID, get mission by ID
+				if (tbj.getTb().getGuid().length() != 0) {
+					tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+				} else {
+					// try to get mission and name by tracking number
+					boolean suceeded = false;
+					if (tbj.getTb().getTrackingNo().length() != 0) {
+						suceeded = spider.getBugMissionAndNameByTrackNr(tbj.getTb());
 					}
+					// if this has't worked, try to get ID by name
+					if (!suceeded) {
+						tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName().trim()));
+						// if we have an ID now, get mission by ID
+						if (tbj.getTb().getGuid().length() != 0) {
+							tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+						}
+					}
 				}
+
+				Vm.showWait(false);
+				tcTbJourneyList.repaint();
+				txtMission.setHtml(tbj.getTb().getMission());
+				inpName.setText(tbj.getTb().getName());
+				lblId.setText(tbj.getTb().getGuid());
+				lowerpane.repaint();
+				Global.getPref().setOldGCLanguage();
 			}
-			
-			Vm.showWait(false);
-			tcTbJourneyList.repaint();
-			txtMission.setHtml(tbj.getTb().getMission());
-			inpName.setText(tbj.getTb().getName());
-			lblId.setText(tbj.getTb().getGuid());
-			lowerpane.repaint();
-		}
-		if (selectedItem==mnuOpenOnline && selectedRow>=0) {
-			TravelbugJourney tbj=tblMyTravelbugJourneys.getTBJourney(selectedRow);
-			SpiderGC spider=new SpiderGC(Global.getPref(),Global.getProfile());
-			Vm.showWait(true);
-			// First check whether ID is set, if not get it
-			if (tbj.getTb().getGuid().length()==0) tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName()));
-			if (tbj.getTb().getGuid().length()!=0) {
-				Vm.showWait(false);
-				try {
-					String s;
-					if (tbj.getTb().getGuid().length()>10)
-						s = "http://www.geocaching.com/track/details.aspx?guid="+tbj.getTb().getGuid();
-					else
-						s = "http://www.geocaching.com/track/details.aspx?id="+tbj.getTb().getGuid();
+			if (selectedItem == mnuOpenOnline && selectedRow >= 0) {
+				TravelbugJourney tbj = tblMyTravelbugJourneys.getTBJourney(selectedRow);
+				SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
+				Vm.showWait(true);
+				// First check whether ID is set, if not get it
+				if (tbj.getTb().getGuid().length() == 0)
+					tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName()));
+				if (tbj.getTb().getGuid().length() != 0) {
+					Vm.showWait(false);
+					try {
+						String s;
+						if (tbj.getTb().getGuid().length() > 10)
+							s = "http://www.geocaching.com/track/details.aspx?guid=" + tbj.getTb().getGuid();
+						else
+							s = "http://www.geocaching.com/track/details.aspx?id=" + tbj.getTb().getGuid();
 
-					CWWrapper.exec(Global.getPref().browser, s);
-					Global.getPref().log("Executed: \""+Global.getPref().browser+"\" \""+s+"\"");
-				} catch (Exception ioex) {
-					// Global.getPref().log("Ignored Exception", ioex, true);
+						CWWrapper.exec(Global.getPref().browser, s);
+						Global.getPref().log("Executed: \"" + Global.getPref().browser + "\" \"" + s + "\"");
+					} catch (Exception ioex) {
+						// Global.getPref().log("Ignored Exception", ioex, true);
+					}
 				}
+				Global.getPref().setOldGCLanguage();
 			}
+			if (selectedItem == mnuToggleList) {
+				toggleNonLogged();
+			}
+			updateNumBugs();
 		}
-		if (selectedItem==mnuToggleList) {
-			toggleNonLogged();
+
+		/** Toggle between displaying all journeys or just those which still need to be logged */
+		public void toggleNonLogged() {
+			mnuToggleList.modifiers ^= MenuItem.Checked;
+			if ((mnuToggleList.modifiers & MenuItem.Checked) == MenuItem.Checked) {
+				// First sort the non-logged items to the top
+				tblMyTravelbugJourneys.sort(TravelbugJourney.BOTHLOGGED, false);
+				// modListTable.numRows=tblMyTravelbugJourneys.size();
+				modTbJourneyList.numRows = tblMyTravelbugJourneys.countNonLogged();
+			} else {
+				modTbJourneyList.numRows = tblMyTravelbugJourneys.size();
+			}
+			tcTbJourneyList.repaint();
 		}
-		updateNumBugs();
-	}
-	
-	/** Toggle between displaying all journeys or just those which still need to be logged */
-	public void toggleNonLogged() {
-		mnuToggleList.modifiers^=MenuItem.Checked;
-		if ((mnuToggleList.modifiers & MenuItem.Checked) == MenuItem.Checked) {
-			// First sort the non-logged items to the top
-			tblMyTravelbugJourneys.sort(TravelbugJourney.BOTHLOGGED, false);
-			// 		modListTable.numRows=tblMyTravelbugJourneys.size();
-			modTbJourneyList.numRows=tblMyTravelbugJourneys.countNonLogged();
-		} else {
-			modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+
+		public void cursorTo(int row, int col, boolean selectNew) {
+			super.cursorTo(row, col, selectNew);
+			selectedRow = row;
+			if (row >= 0) {
+				modTbJourneyList.showFields(tblMyTravelbugJourneys.getTBJourney(row));
+			} else {
+				modTbJourneyList.showFields(new TravelbugJourney(""));
+			}
 		}
-		tcTbJourneyList.repaint();
 	}
-	
-	
-	public void cursorTo(int row,int col,boolean selectNew) {
-		super.cursorTo(row,col,selectNew);
-		selectedRow=row;
-		if (row>=0) { 
-			modTbJourneyList.showFields(tblMyTravelbugJourneys.getTBJourney(row));
-		} else {
-			modTbJourneyList.showFields(new TravelbugJourney(""));
-		}
-	}
-}
 
 }

Modified: trunk/src/CacheWolf/UrlFetcher.java
===================================================================
--- trunk/src/CacheWolf/UrlFetcher.java	2011-05-14 20:57:48 UTC (rev 3004)
+++ trunk/src/CacheWolf/UrlFetcher.java	2011-05-15 18:20:09 UTC (rev 3005)
@@ -255,9 +255,11 @@
 				dest = n;
 			}
 			char c = what[i];
+			// removed || c == '&'
+			// added || c == '$' || c == '/' || c == ','
 			if (spaceToPlus && c == ' ')
 				c = '+';
-			else if (c <= ' ' || c >= 127 || c == '+' || c == '&' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}' || c == '$' || c == '/') {
+			else if (c <= ' ' || c >= 127 || c == '+' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}' || c == '$' || c == '/' || c == ',') {
 				dest[d++] = '%';
 				dest[d++] = hex.charAt((c >> 4) & 0xf);
 				dest[d++] = hex.charAt(c & 0xf);

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-14 20:57:48 UTC (rev 3004)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-15 18:20:09 UTC (rev 3005)
@@ -142,17 +142,10 @@
 	private static String propFirstPage2;
 	private static String propFirstPageFinds;
 	private static String gotoNextPage = "ctl00$ContentBody$pgrTop$ctl08";
-	private static String gotoNextBlock = "ctl00$ContentBody$pgrTop$ctl06"; // change
-																			// to
-																			// the
-																			// block
-																			// (10pages)
-																			// of
-																			// the
-																			// wanted
-																			// page
-	private static String gotoPage = "ctl00$ContentBody$pgrTop$lbGoToPage_"; // add
-																				// pagenumber
+	// change to the block (10pages) of the wanted page
+	private static String gotoNextBlock = "ctl00$ContentBody$pgrTop$ctl06";
+	// add pagenumber
+	private static String gotoPage = "ctl00$ContentBody$pgrTop$lbGoToPage_";
 	private static String propMaxDistance;
 	private static String propShowOnlyFound;
 	private static Regex RexPropListBlock;
@@ -545,7 +538,7 @@
 				ch.initStates(false);
 		}
 
-		double halfSideLength = maxDistance; // halbe Seitenl?nge eines Quadrats
+		double halfSideLength = maxDistance; // halbe Seitenl??nge eines Quadrats
 												// ums Zentrum in km
 		if (pref.metricSystem == Metrics.IMPERIAL) {
 			halfSideLength = Metrics.convertUnit(maxDistance, Metrics.MILES, Metrics.KILOMETER);
@@ -1130,7 +1123,7 @@
 			if (loggedIn)
 				return FormBase.IDOK;
 			else {
-				(new MessageBox("Login", "Check UserID in preferences | Einstellungen, or check GC-Language. Must be English.", FormBase.OKB)).execute();
+				(new MessageBox("Login", "Check UserID in preferences | Einstellungen.", FormBase.OKB)).execute();
 				return ERR_LOGIN;
 			}
 		} else {
@@ -1290,7 +1283,7 @@
 
 	private boolean switchToEnglish() {
 		// change language to EN , further operations relay on English
-		String url = "http://www.geocaching.com/";
+		String url = "http://www.geocaching.com/default.aspx";
 		String page = "";
 		String loggedInEnglish = ">Sign Out<";
 		String userID = "userid=" + pref.userID;
@@ -1328,31 +1321,23 @@
 		}
 		if (page.indexOf(loggedInEnglish) > -1) {
 			pref.log("already English");
+			pref.oldLanguageCtl = ""; // nothing to reset
 			return true;
 		}
-
-		// todo next doesn't work correct don't know why
 		// switch to english now goes into gc account Display Preferences (is permanent, must be reset)
-		final Regex rexViewstate = new Regex("id=\"__VIEWSTATE\" value=\"(.*?)\" />");
-		String viewstate = "";
-		rexViewstate.search(page);
-		if (rexViewstate.didMatch()) {
-			viewstate = rexViewstate.stringMatched(1);
-		} else
-			return false;
-		final String strEnglishPage = "ctl00$uxLocaleList$uxLocaleList$ctl01$uxLocaleItem";
-		String postStr = "__EVENTTARGET=" + UrlFetcher.encodeURL(strEnglishPage, false) + "&__EVENTARGUMENT=" + "&__VIEWSTATE=" + UrlFetcher.encodeURL(viewstate, false);
-		// postStr += UrlFetcher.encodeURL("&ctl00$ContentBody$tbSearch=postal code, country, etc.", true);
+		String languages[] = { "English", "Deutsch", "Fran??ais", "Portugu??s", "??e??tina", "Svenska", "Nederlands", "Catal??", "Polski", "Eesti", "Norsk, Bokm??l", "?????????", "Espa??ol" };
+		String oldLanguage = new Extractor(page, "<a href=\"#\">", "&#9660;</a>", 0, true).findNext();
+		for (int i = 0; i < languages.length; i++) {
+			if (oldLanguage.equals(languages[i])) {
+				pref.oldLanguageCtl = url + "?__EVENTTARGET=" + UrlFetcher.encodeURL("ctl00$uxLocaleList$uxLocaleList$ctl" + MyLocale.formatLong(i, "00") + "$uxLocaleItem", false);
+				break;
+			}
+		}
+		final String strEnglishPage = "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem";
+		url += "?__EVENTTARGET=" + UrlFetcher.encodeURL(strEnglishPage, false);
 		try {
-			UrlFetcher.setpostData(postStr);
-			// UrlFetcher.setRequestorProperty("Referer", url);
-			// UrlFetcher.setRequestorProperty("Origin", "http://www.geocaching.com");
-			// UrlFetcher.setRequestorProperty("Cache-Control", "max-age=0");
-			// UrlFetcher.setRequestorProperty("Accept-Charset", "ISO-8859-1,utf-8;q=0.7,*;q=0.3");
-			// UrlFetcher.setRequestorProperty("Accept-Language", "de-DE,de;q=0.8,en-US;q=0.6,en;q=0.4");
-			// cookie = "company_history=%5B%5B%22http%3A//feedback.geocaching.com/geocaching%22%2C%22Geocaching%22%5D%5D; Send2GPS=garmin; __qca=P0-675333427-1299837942815; " + cookie;
-			// UrlFetcher.setPermanentRequestorProperty("Cookie", cookie);
 			page = UrlFetcher.fetch(url);
+			// String s = new Extractor(page, "<a href=\"#\">", "&#9660;</a>", 0, true).findNext();
 			if (page.indexOf(loggedInEnglish) > -1) {
 				pref.log("Switched to English");
 				return true;
@@ -1361,7 +1346,7 @@
 				return false;
 			}
 		} catch (final Exception ex) {
-			pref.log("Error switching to English: check " + url + " : " + postStr, ex);
+			pref.log("Error switching to English: check " + url, ex);
 			return false;
 		}
 
@@ -1547,7 +1532,7 @@
 				ch.initStates(false);
 		}
 
-		double halfSideLength = maxDistance; // halbe Seitenl?nge eines Quadrats ums Zentrum in km
+		double halfSideLength = maxDistance; // halbe Seitenl??nge eines Quadrats ums Zentrum in km
 		if (pref.metricSystem == Metrics.IMPERIAL) {
 			halfSideLength = Metrics.convertUnit(maxDistance, Metrics.MILES, Metrics.KILOMETER);
 		}
@@ -1930,8 +1915,8 @@
 			if (ret.indexOf("ere") > -1)
 				return distanceAndDirection; // zur Zeit " Here -1"
 			// Versuch den DistanceCodeKey automatisch zu bestimmen
-			// da dieser von gc mal wieder ge?ndert wurde.
-			// todo Ben?tigt ev noch weitere Anpassungen: | am Anfang, and calc
+			// da dieser von gc mal wieder ge??ndert wurde.
+			// todo Ben??tigt ev noch weitere Anpassungen: | am Anfang, and calc
 			// of keylength
 
 			// String thereitis="|0.34 km|102.698";
@@ -1965,7 +1950,7 @@
 			final String coded = ewe.net.URL.decodeURL(RexPropDistanceCode.stringMatched(1));
 			final String newkey = decodeXor(coded, thereitis);
 			final int keylength = 13; // wenn nicht 13 dann newkey auf
-										// wiederholung pr?fen
+										// wiederholung pr??fen
 			DistanceCodeKey = newkey.substring(0, keylength);
 			ret = decodeXor(stmp, DistanceCodeKey).replace('|', ' ');
 			pref.log("Automatic key: " + DistanceCodeKey + " result: " + ret + Preferences.NEWLINE);

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2011-05-14 20:57:48 UTC (rev 3004)
+++ trunk/src/CacheWolf/myTableControl.java	2011-05-15 18:20:09 UTC (rev 3005)
@@ -286,6 +286,7 @@
 
 		if (selectedItem == miUpdate) {
 			MainMenu.updateSelectedCaches(tbp);
+			pref.setOldGCLanguage();
 		} else
 
 		if (selectedItem == miChangeBlack) {

Modified: trunk/src/CacheWolf/view/ewe/TravelbugJourneyScreen.java
===================================================================
--- trunk/src/CacheWolf/view/ewe/TravelbugJourneyScreen.java	2011-05-14 20:57:48 UTC (rev 3004)
+++ trunk/src/CacheWolf/view/ewe/TravelbugJourneyScreen.java	2011-05-15 18:20:09 UTC (rev 3005)
@@ -104,9 +104,7 @@
 
 	/** The panel for the lower half of the screen */
 	private CellPanel lowerpane;
-	private mInput inpName, inpTrackingNo,
-			inpFromDate, inpFromProfile, inpFromWaypoint,
-			inpToDate, inpToProfile, inpToWaypoint;
+	private mInput inpName, inpTrackingNo, inpFromDate, inpFromProfile, inpFromWaypoint, inpToDate, inpToProfile, inpToWaypoint;
 	private mLabel lblId;
 	private mButton btnFromDate, btnToDate;
 	private mCheckBox chkFromLogged, chkToLogged;
@@ -136,7 +134,7 @@
 
 	// =========== MODEL
 	// Set to Public to implement MVC-Pattern [AP]
-//	public TravelbugJourneyList tblMyTravelbugJourneys;
+	// public TravelbugJourneyList tblMyTravelbugJourneys;
 	/** List of TBs in the current cache */
 	// Set to Public to implement MVC-Pattern [AP]
 	public TravelbugList tblSrcCache;
@@ -170,8 +168,7 @@
 		title = "Travelbugs" + cache;
 		tcTbJourneyList = new tbListControl(model);
 		tcTbJourneyList.setTableModel(modTbJourneyList = new tbListTableModel());
-		tablepane.addLast(new MyScrollBarPanel(tcTbJourneyList, ScrollablePanel.AlwaysShowVerticalScrollers), STRETCH,
-				FILL);
+		tablepane.addLast(new MyScrollBarPanel(tcTbJourneyList, ScrollablePanel.AlwaysShowVerticalScrollers), STRETCH, FILL);
 
 		lowerpane = split.getNextPanel();
 
@@ -255,10 +252,8 @@
 
 		modTbJourneyList.numRows = model.allTravelbugJourneys.size();
 		// Get the columns to display and their widths from preferences
-		modTbJourneyList.columnMap =
-				TableColumnChooser.str2Array(Global.getPref().travelbugColMap, 0, 11, 0, -1);
-		modTbJourneyList.colWidth =
-				TableColumnChooser.str2Array(Global.getPref().travelbugColWidth, 10, 1024, 50, -1);
+		modTbJourneyList.columnMap = TableColumnChooser.str2Array(Global.getPref().travelbugColMap, 0, 11, 0, -1);
+		modTbJourneyList.colWidth = TableColumnChooser.str2Array(Global.getPref().travelbugColWidth, 10, 1024, 50, -1);
 		modTbJourneyList.numCols = modTbJourneyList.columnMap.length;
 
 		modTbJourneyList.select(0, 12, true);
@@ -281,9 +276,7 @@
 
 	public void onEvent(Event ev) {
 		// Update the table from the input form
-		if ((ev instanceof MultiPanelEvent || ev instanceof ControlEvent || ev instanceof DataChangeEvent)
-				&& selectedRow != -1 &&
-				selectedRow < model.allTravelbugJourneys.size()) {
+		if ((ev instanceof MultiPanelEvent || ev instanceof ControlEvent || ev instanceof DataChangeEvent) && selectedRow != -1 && selectedRow < model.allTravelbugJourneys.size()) {
 			TravelbugJourney tbj = model.allTravelbugJourneys.getTBJourney(selectedRow);
 			if (currentControl == inpName)
 				tbj.getTb().setName(inpName.getText());
@@ -338,8 +331,7 @@
 				;
 				dc.reset(t);
 				if (dc.execute() == ewe.ui.FormBase.IDOK) {
-					inpDate.setText(Convert.toString(dc.year) + "-" + MyLocale.formatLong(dc.month, "00") + "-"
-							+ MyLocale.formatLong(dc.day, "00") + " " + dc.time);
+					inpDate.setText(Convert.toString(dc.year) + "-" + MyLocale.formatLong(dc.month, "00") + "-" + MyLocale.formatLong(dc.day, "00") + " " + dc.time);
 					if (ev.target == btnFromDate) {
 						model.allTravelbugJourneys.getTBJourney(selectedRow).setFromDate(inpDate.getText());
 						Gui.takeFocus(chkFromLogged, ControlConstants.ByKeyboard);
@@ -368,8 +360,7 @@
 			String travelbugColWidth = modTbJourneyList.getColWidths();
 			// If the preferences changed, save the pref.xml file
 			Vm.showWait(true);
-			if (!Global.getPref().travelbugColWidth.equals(travelbugColWidth) ||
-					old != Global.getPref().travelbugShowOnlyNonLogged) {
+			if (!Global.getPref().travelbugColWidth.equals(travelbugColWidth) || old != Global.getPref().travelbugShowOnlyNonLogged) {
 				Global.getPref().travelbugColWidth = travelbugColWidth;
 				Global.getPref().savePreferences();
 			}
@@ -421,12 +412,10 @@
 				int map = columnMap[col];
 				// If we have not yet logged the from or the to, a red dot is
 				// placed in front of the first item
-				if (col == 0 && (!model.allTravelbugJourneys.getTBJourney(row).getFromLogged() ||
-						!model.allTravelbugJourneys.getTBJourney(row).getToLogged())) {
+				if (col == 0 && (!model.allTravelbugJourneys.getTBJourney(row).getFromLogged() || !model.allTravelbugJourneys.getTBJourney(row).getToLogged())) {
 					// Is it a column with a checkbox?
 					if (map != 7 && map != 11)
-						return new IconAndText((IImage) imgRed, (String) model.allTravelbugJourneys.getTBJourney(row)
-								.getElementByNumber(map), fm);
+						return new IconAndText((IImage) imgRed, (String) model.allTravelbugJourneys.getTBJourney(row).getElementByNumber(map), fm);
 					else { // Checkbox - special treatment
 						IconAndText iat = new IconAndText(imgRed, "", fm);
 						iat.addColumn(model.allTravelbugJourneys.getTBJourney(row).getElementByNumber(map));
@@ -721,6 +710,7 @@
 				inpName.setText(tbj.getTb().getName());
 				lblId.setText(tbj.getTb().getGuid());
 				lowerpane.repaint();
+				Global.getPref().setOldGCLanguage();
 			}
 			if (selectedItem == mnuOpenOnline && selectedRow >= 0) {
 				TravelbugJourney tbj = tbModel.allTravelbugJourneys.getTBJourney(selectedRow);
@@ -749,6 +739,7 @@
 				toggleNonLogged();
 			}
 			updateNumBugs();
+			Global.getPref().setOldGCLanguage();
 		}
 
 		/**

Modified: trunk/src/CacheWolf/view/ewe/TravelbugMenu.java
===================================================================
--- trunk/src/CacheWolf/view/ewe/TravelbugMenu.java	2011-05-14 20:57:48 UTC (rev 3004)
+++ trunk/src/CacheWolf/view/ewe/TravelbugMenu.java	2011-05-15 18:20:09 UTC (rev 3005)
@@ -19,8 +19,7 @@
 import ewe.ui.PullDownMenu;
 
 /**
- * Controller for the {@link TravelbugList}. Preferrably used by
- * {@link TravelbugJourneyScreen}
+ * Controller for the {@link TravelbugList}. Preferrably used by {@link TravelbugJourneyScreen}
  * 
  * @author andi
  * 
@@ -43,7 +42,6 @@
 	public TravelbugJourneyScreen view;
 	private TravelBugScreenModel model;
 
-	
 	public TravelbugMenu(TravelBugScreenModel model) {
 		this.model = model;
 		MenuItem[] TBMenuItems = new MenuItem[9];
@@ -147,6 +145,7 @@
 						}
 					}
 				}
+				Global.getPref().setOldGCLanguage();
 			} else if (mev.selectedItem == mnuOpenOnline && view.selectedRow >= 0) {
 				TravelbugJourney tbj = model.allTravelbugJourneys.getTBJourney(view.selectedRow);
 				SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
@@ -169,6 +168,7 @@
 						Global.getPref().log("Ignored Exception", ioex, true);
 					}
 				}
+				Global.getPref().setOldGCLanguage();
 			}
 
 		}

Modified: trunk/src/CacheWolf/view/pda/PDATravelbugDetailMenu.java
===================================================================
--- trunk/src/CacheWolf/view/pda/PDATravelbugDetailMenu.java	2011-05-14 20:57:48 UTC (rev 3004)
+++ trunk/src/CacheWolf/view/pda/PDATravelbugDetailMenu.java	2011-05-15 18:20:09 UTC (rev 3005)
@@ -55,12 +55,12 @@
 				journeyScreen.model.allTravelbugJourneys.addTbDrop(tb, Global.getProfile().name, ch.getWayPoint());
 				ch.setHas_bugs(true);
 				ch.save();
-				//Set Input fields to the new Values:
+				// Set Input fields to the new Values:
 				view.getInpToWaypoint().setText(view.getTravelbug().getToWaypoint());
 				view.getInpToProfile().setText(view.getTravelbug().getToProfile());
 				view.getInpToDate().setText(view.getTravelbug().getToDate());
-				//Save now. The action won't recognize the changes:
-				journeyScreen.model.allTravelbugJourneys.saveTravelbugsFile();	
+				// Save now. The action won't recognize the changes:
+				journeyScreen.model.allTravelbugJourneys.saveTravelbugsFile();
 			}
 			journeyScreen.setupTBButtons();
 			exit(0);
@@ -87,6 +87,7 @@
 					Global.getPref().log("Ignored Exception", ioex, true);
 				}
 			}
+			Global.getPref().setOldGCLanguage();
 			exit(0);
 		} else if (action.equals(SPIDER)) {
 			Travelbug tb = view.getTravelbug().getTb();
@@ -113,16 +114,15 @@
 			}
 			journeyScreen.model.allTravelbugJourneys.saveTravelbugsFile();
 			Vm.showWait(false);
+			Global.getPref().setOldGCLanguage();
 			exit(0);
 		} else if (action.equals(DELETE)) {
 			// LOESCHEN DES TB's aus der Datenbank ist Boese!!!
 			// Erst mal eine Sicherheitesabfrage bauen:
-			int r = PDAOptionPane.showConfirmDialog(this.getFrame(), "Sind Sie Sicher???",
-					"Wollen Sie wirklich den TB l?schen??");
+			int r = PDAOptionPane.showConfirmDialog(this.getFrame(), "Sind Sie Sicher???", "Wollen Sie wirklich den TB l?schen??");
 			if (r == PDAOptionPane.OK) {
 				for (int i = 0; i < journeyScreen.model.allTravelbugJourneys.size(); i++) {
-					TravelbugJourney tbJourney =
-							journeyScreen.model.allTravelbugJourneys.getTBJourney(i);
+					TravelbugJourney tbJourney = journeyScreen.model.allTravelbugJourneys.getTBJourney(i);
 					if (tbJourney.getTb().getTrackingNo().equals(view.getTravelbug().getTb().getTrackingNo())) {
 						journeyScreen.model.allTravelbugJourneys.remove(i);
 						journeyScreen.model.allTravelbugJourneys.saveTravelbugsFile();



From mik77 at mail.berlios.de  Wed May 18 09:45:09 2011
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Wed, 18 May 2011 09:45:09 AM +0200
Subject: [Cachewolf-svn] r3006 - trunk/res_noewe
Message-ID: <20110518074510.1D73A4813CD@sheep.berlios.de>

Author: mik77
Date: 2011-05-18 09:45:09 +0200 (Wed, 18 May 2011)
New Revision: 3006

Modified:
   trunk/res_noewe/spider.def
Log:
better description recognition

Modified: trunk/res_noewe/spider.def
===================================================================
--- trunk/res_noewe/spider.def	2011-05-15 18:20:09 UTC (rev 3005)
+++ trunk/res_noewe/spider.def	2011-05-18 07:45:09 UTC (rev 3006)
@@ -111,7 +111,7 @@
 premiumCachepage   = class="Warning">listing\ visible\ to\ Premium
 latLonRex          = tBody_LatLon"\ style="font-weight:bold;">((?s).*?)</span>
 shortDescRex       = tBody_ShortDescription">((?s).*?)</span>
-longDescRex        = tBody_LongDescription">((?s).*?)</span>\\s+</div>
+longDescRex        = tBody_LongDescription">((?s).*?)<strong>\\s+Additional\ Hints</strong>
 cacheNameRex       = tBody_CacheName">((?s).*?)</span>
 cacheOwnerRex      = &wid(?:(?s).*?)>((?s).*?)<
 dateHiddenRex      = (?:Hidden|Event\ Date)\\s*:\\s*((?s).*?)<



From araber95 at mail.berlios.de  Wed May 18 04:06:48 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Wed, 18 May 2011 04:06:48 PM +0200
Subject: [Cachewolf-svn] r3007 - in trunk/src/CacheWolf: . imp navi
Message-ID: <20110518140648.BF9A0481274@sheep.berlios.de>

Author: araber95
Date: 2011-05-18 16:06:48 +0200 (Wed, 18 May 2011)
New Revision: 3007

Modified:
   trunk/src/CacheWolf/Attributes.java
   trunk/src/CacheWolf/CacheHolderDetail.java
   trunk/src/CacheWolf/Extractor.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/SafeXML.java
   trunk/src/CacheWolf/UrlFetcher.java
   trunk/src/CacheWolf/imp/GPXImporter.java
   trunk/src/CacheWolf/imp/SpiderGC.java
   trunk/src/CacheWolf/navi/CWGPSPoint.java
Log:
1. extended error message on gpx import.
2. switch to english on login at gc and  back to original
3. corrected entity checking
4. corrected Url Text encoding
5. changed Extractor to easy work with quick import
6. make quick import work a bit more robust (gc changed output again) using Extractor

Modified: trunk/src/CacheWolf/Attributes.java
===================================================================
--- trunk/src/CacheWolf/Attributes.java	2011-05-18 07:45:09 UTC (rev 3006)
+++ trunk/src/CacheWolf/Attributes.java	2011-05-18 14:06:48 UTC (rev 3007)
@@ -1,133 +1,150 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 public class Attributes {
-	public Attributes(){} // Just a public constructor
-	public final static int MAXATTRIBS=12;
+	public Attributes() {
+	} // Just a public constructor
+
+	public final static int MAXATTRIBS = 12;
 	/**
 	 * The number of attributes for this cache (=number of array elements in use in attribs)
 	 */
-	private int _count=0;
+	private int _count = 0;
 	/**
 	 * The attributes as array of MAXATTRIBS Attribute
 	 */
-	private Attribute attribs[]=new Attribute[MAXATTRIBS];
+	private Attribute attribs[] = new Attribute[MAXATTRIBS];
 	/**
-	 * The attributes presence in Bit Representation 
+	 * The attributes presence in Bit Representation
 	 */
-	private long[] attrYes = {0l,0l};
-	private long[] attrNo = {0l,0l};	
+	private long[] attrYes = { 0l, 0l };
+	private long[] attrNo = { 0l, 0l };
+
 	/**
 	 * Get the number of attributes in the list
+	 * 
 	 * @return number of attributes
 	 */
-	public int count(){return _count;}	
+	public int count() {
+		return _count;
+	}
+
 	/**
-	 * getting an empty attributes list for this Cache 
+	 * getting an empty attributes list for this Cache
 	 */
 	public void clear() {
-		_count=0;
-		attrYes[0]=0l;
-		attrYes[1]=0l;
-		attrNo[0]=0l;
-		attrNo[1]=0l;
+		_count = 0;
+		attrYes[0] = 0l;
+		attrYes[1] = 0l;
+		attrNo[0] = 0l;
+		attrNo[1] = 0l;
 	}
+
 	/**
-	 *  Filling the Attributes from Cache.xml (CacheHolderDetail)
-	 *  todo : remove this "historic" reprensentation , saving as Bits should be enough (araber95)
+	 * Filling the Attributes from Cache.xml (CacheHolderDetail)
+	 * todo : remove this "historic" reprensentation , saving as Bits should be enough (araber95)
 	 */
-	public void XmlAttributesEnd(String elem){
+	public void XmlAttributesEnd(String elem) {
 		clear();
-		Extractor ex=new Extractor(elem,"<ATT>","</ATT>",0,true);
-		String dummy = ex.findNext();
-		while(ex.endOfSearch()==false){
+		Extractor ex = new Extractor(elem, "<ATT>", "</ATT>", 0, true);
+		String dummy;
+		while ((dummy = ex.findNext()).length() > 0) {
 			add(dummy);
-			dummy = ex.findNext();
 		}
 	}
+
 	/**
-	 * Prepare for attributes to be written to cache.xml file 
-	 *  todo : remove this "historic" reprensentation , saving as Bits should be enough (araber95)
+	 * Prepare for attributes to be written to cache.xml file
+	 * todo : remove this "historic" reprensentation , saving as Bits should be enough (araber95)
 	 */
-	public String XmlAttributesWrite(){
-		StringBuffer sb=new StringBuffer(1000);
+	public String XmlAttributesWrite() {
+		StringBuffer sb = new StringBuffer(1000);
 		sb.append("<ATTRIBUTES>\n");
-		for (int i=0; i<_count; i++) {
+		for (int i = 0; i < _count; i++) {
 			sb.append("   <ATT>");
 			sb.append(attribs[i].getImageName());
 			sb.append("</ATT>\n");
 		}
 		sb.append("</ATTRIBUTES>\n");
 		return sb.toString();
-	}	
+	}
+
 	/**
 	 * Add a new attribute to the array by Name, meaning its icon picture name
+	 * 
 	 * @param attributeName
 	 */
-	public void add(String attributeName){
-		if (_count<attribs.length) {
-			if ( !attributeName.equalsIgnoreCase( "attribute-blank.gif" ) ) {
+	public void add(String attributeName) {
+		if (_count < attribs.length) {
+			if (!attributeName.equalsIgnoreCase("attribute-blank.gif")) {
 				Attribute attr = new Attribute(attributeName);
 				attribs[_count++] = attr;
-				attrYes=attr.getYesBit(attrYes);
-				attrNo=attr.getNoBit(attrNo);
+				attrYes = attr.getYesBit(attrYes);
+				attrNo = attr.getNoBit(attrNo);
 			}
 		}
 	}
+
 	/**
 	 * Add a new attribute to the array by ID and Inc as you get it from GC gpx-File
-	 * @param GC attribute ID
-	 * @param GC attribute Inc (attribute set = 0 ,attribute  not set = 1)
+	 * 
+	 * @param GC
+	 *            attribute ID
+	 * @param GC
+	 *            attribute Inc (attribute set = 0 ,attribute not set = 1)
 	 */
 	public void add(int attIdGC, String Yes1No0) {
-		if (_count<attribs.length) {
+		if (_count < attribs.length) {
 			Attribute attr = new Attribute(attIdGC, Yes1No0);
 			boolean doAdd = true;
-			int replace=0;
+			int replace = 0;
 			for (int i = 0; i < _count; i++) {
-				if (attribs[i].getGCId().equals(attr.getGCId())){
-					doAdd=false;
-					replace=i;
+				if (attribs[i].getGCId().equals(attr.getGCId())) {
+					doAdd = false;
+					replace = i;
 					break;
 				}
 			}
 			if (doAdd) {
 				attribs[_count++] = attr;
-			}
-			else {
+			} else {
 				// free old attr ?
-				attribs[replace]=attr;
+				attribs[replace] = attr;
 			}
-			attrYes=attr.getYesBit(attrYes);
-			attrNo=attr.getNoBit(attrNo);			
+			attrYes = attr.getYesBit(attrYes);
+			attrNo = attr.getNoBit(attrNo);
 		}
 	}
+
 	/**
-	 * Add a new attribute to the array by OC-IDas you get it from OC xml/zip-download 
-	 * @param OC attribute ID
+	 * Add a new attribute to the array by OC-IDas you get it from OC xml/zip-download
+	 * 
+	 * @param OC
+	 *            attribute ID
 	 */
 	public void add(int attIdOC) {
 		Attribute attr = new Attribute(attIdOC);
@@ -136,30 +153,34 @@
 				return;
 			}
 		}
-		if (_count<attribs.length) {
+		if (_count < attribs.length) {
 			attribs[_count++] = attr;
-			attrYes=attr.getYesBit(attrYes);
+			attrYes = attr.getYesBit(attrYes);
 		}
 	}
+
 	/**
 	 * to get the Bit Representation of the Attributs of this Cache
+	 * 
 	 * @return the Long array representing the Attributes of this Cache
 	 */
 	public long[] getAttribsAsBits() {
 		long ret[] = new long[4];
-		ret[0]=attrYes[0];
-		ret[1]=attrYes[1];
-		ret[2]=attrNo[0];
-		ret[3]=attrNo[1];
+		ret[0] = attrYes[0];
+		ret[1] = attrYes[1];
+		ret[2] = attrNo[0];
+		ret[3] = attrNo[1];
 		return ret;
 	}
+
 	/**
 	 * Get the i-th attribute
-	 * @param i The number for which the attribute is to be retrieved
+	 * 
+	 * @param i
+	 *            The number for which the attribute is to be retrieved
 	 * @return The attribute
 	 */
 	public Attribute getAttribute(int i) {
 		return attribs[i];
 	}
 }
-

Modified: trunk/src/CacheWolf/CacheHolderDetail.java
===================================================================
--- trunk/src/CacheWolf/CacheHolderDetail.java	2011-05-18 07:45:09 UTC (rev 3006)
+++ trunk/src/CacheWolf/CacheHolderDetail.java	2011-05-18 14:06:48 UTC (rev 3007)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.utils.FileBugfix;
@@ -40,532 +40,555 @@
 import ewe.util.Vector;
 
 public class CacheHolderDetail {
-	  
-	  
-	 /** CacheHolder which holds the detail. <b>Only</b> set by CacheHolder when creating detail! **/
-	  private CacheHolder parent = null;
-	  public String LongDescription = CacheHolder.EMPTY;
-	  public String LastUpdate = CacheHolder.EMPTY;
-	  public String Hints = CacheHolder.EMPTY;
-	  public LogList CacheLogs=new LogList();
-	  private String CacheNotes = CacheHolder.EMPTY;
-	  public CacheImages images = new CacheImages();
-	  public CacheImages logImages = new CacheImages();
-	  public CacheImages userImages = new CacheImages();
-	  public Attributes attributes=new Attributes();
-	  public Vector CacheIcons = new Vector();
-	  public TravelbugList Travelbugs=new TravelbugList();
-	  //public String Bugs = EMPTY; Superceded by Travelbugs
-	  public String URL = CacheHolder.EMPTY;
-	  private String Solver = CacheHolder.EMPTY;
-	  public String OwnLogId = CacheHolder.EMPTY;
-	  public Log OwnLog = null;
-	  public String Country = CacheHolder.EMPTY;
-	  public String State = CacheHolder.EMPTY;
-	  /** For faster cache import (from opencaching) changes are only written when the details are freed from memory 
-	   * If you want to save the changes automatically when the details are unloaded, set this to true */ 
-	  public boolean hasUnsavedChanges = false;
-	  
-	 public CacheHolderDetail(CacheHolder ch) {
-		 parent = ch;
-	 }
 
-	 public CacheHolder getParent() {
-		 return parent;
-	 }
-	 public void setLongDescription(String longDescription) {
-	 	if (LongDescription.equals("")) getParent().setNew(true);
-	 	else if (!stripControlChars(LongDescription).equals(stripControlChars(longDescription))) getParent().setUpdated(true);
-	 	LongDescription = longDescription;
-	 }
-	 
-	 private String stripControlChars(String desc) {
-		 StringBuffer sb=new StringBuffer(desc.length());
-		 for (int i=0; i<desc.length(); i++) {
-			char c=desc.charAt(i);
-			if (c>' ') sb.append(c);
-		 }
-		 return sb.toString();
-	 }
-	 
-	 public void setHints(String hints) {
-	 	if (!Hints.equals(hints)) getParent().setUpdated(true);
-	 	Hints = hints;
-	 }
-	 
-	 public void setSolver(String solver) {
-		 if (!Solver.equals(solver)) getParent().setUpdated(true);
-		 getParent().setHasSolver(!solver.trim().equals(""));
-		 Solver = solver;
-	 }
-	 
-	 public String getSolver() {
-		 return this.Solver;
-	 }
+	/** CacheHolder which holds the detail. <b>Only</b> set by CacheHolder when creating detail! **/
+	private CacheHolder parent = null;
+	public String LongDescription = CacheHolder.EMPTY;
+	public String LastUpdate = CacheHolder.EMPTY;
+	public String Hints = CacheHolder.EMPTY;
+	public LogList CacheLogs = new LogList();
+	private String CacheNotes = CacheHolder.EMPTY;
+	public CacheImages images = new CacheImages();
+	public CacheImages logImages = new CacheImages();
+	public CacheImages userImages = new CacheImages();
+	public Attributes attributes = new Attributes();
+	public Vector CacheIcons = new Vector();
+	public TravelbugList Travelbugs = new TravelbugList();
+	// public String Bugs = EMPTY; Superceded by Travelbugs
+	public String URL = CacheHolder.EMPTY;
+	private String Solver = CacheHolder.EMPTY;
+	public String OwnLogId = CacheHolder.EMPTY;
+	public Log OwnLog = null;
+	public String Country = CacheHolder.EMPTY;
+	public String State = CacheHolder.EMPTY;
+	/**
+	 * For faster cache import (from opencaching) changes are only written when the details are freed from memory
+	 * If you want to save the changes automatically when the details are unloaded, set this to true
+	 */
+	public boolean hasUnsavedChanges = false;
 
-	 public void setCacheNotes(String notes) {
-		 if (!CacheNotes.equals(notes)) getParent().setUpdated(true);
-		 getParent().setHasNote(!notes.trim().equals(""));
-		 CacheNotes = notes;
-	 }
-	 
-	 public String getCacheNotes() {
-		 return this.CacheNotes;
-	 }
-	 
-	 public void setCacheLogs(LogList newLogs) {
-		 int size=newLogs.size();
-		 for (int i=size-1; i>=0; i--) { // Loop over all new logs, must start with oldest log
-			 if (CacheLogs.merge(newLogs.getLog(i))>=0) getParent().setLog_updated(true);
-		 }
-		 if (CacheLogs.purgeLogs() > 0) hasUnsavedChanges=true;
-		 getParent().setNoFindLogs(CacheLogs.countNotFoundLogs());
-	 }
+	public CacheHolderDetail(CacheHolder ch) {
+		parent = ch;
+	}
 
-	 
-	  /**
+	public CacheHolder getParent() {
+		return parent;
+	}
+
+	public void setLongDescription(String longDescription) {
+		if (LongDescription.equals(""))
+			getParent().setNew(true);
+		else if (!stripControlChars(LongDescription).equals(stripControlChars(longDescription)))
+			getParent().setUpdated(true);
+		LongDescription = longDescription;
+	}
+
+	private String stripControlChars(String desc) {
+		StringBuffer sb = new StringBuffer(desc.length());
+		for (int i = 0; i < desc.length(); i++) {
+			char c = desc.charAt(i);
+			if (c > ' ')
+				sb.append(c);
+		}
+		return sb.toString();
+	}
+
+	public void setHints(String hints) {
+		if (!Hints.equals(hints))
+			getParent().setUpdated(true);
+		Hints = hints;
+	}
+
+	public void setSolver(String solver) {
+		if (!Solver.equals(solver))
+			getParent().setUpdated(true);
+		getParent().setHasSolver(!solver.trim().equals(""));
+		Solver = solver;
+	}
+
+	public String getSolver() {
+		return this.Solver;
+	}
+
+	public void setCacheNotes(String notes) {
+		if (!CacheNotes.equals(notes))
+			getParent().setUpdated(true);
+		getParent().setHasNote(!notes.trim().equals(""));
+		CacheNotes = notes;
+	}
+
+	public String getCacheNotes() {
+		return this.CacheNotes;
+	}
+
+	public void setCacheLogs(LogList newLogs) {
+		int size = newLogs.size();
+		for (int i = size - 1; i >= 0; i--) { // Loop over all new logs, must start with oldest log
+			if (CacheLogs.merge(newLogs.getLog(i)) >= 0)
+				getParent().setLog_updated(true);
+		}
+		if (CacheLogs.purgeLogs() > 0)
+			hasUnsavedChanges = true;
+		getParent().setNoFindLogs(CacheLogs.countNotFoundLogs());
+	}
+
+	/**
 	 * Method to update an existing cache with new data. This is
 	 * necessary to avoid missing old logs. Called from GPX Importer
-	 * @param newCh new cache data
+	 * 
+	 * @param newCh
+	 *            new cache data
 	 * @return CacheHolder with updated data
 	 */
-	 public CacheHolderDetail update(CacheHolderDetail newCh) {
-			// flags
-			CacheHolder ch = getParent();
-			if (ch.is_found() && ch.getCacheStatus().equals("")) {
-				ch.setCacheStatus(ch.getFoundText());
+	public CacheHolderDetail update(CacheHolderDetail newCh) {
+		// flags
+		CacheHolder ch = getParent();
+		if (ch.is_found() && ch.getCacheStatus().equals("")) {
+			ch.setCacheStatus(ch.getFoundText());
+		}
+		// travelbugs:GPX-File contains all actual travelbugs but not the missions
+		// we need to check whether the travelbug is already in the existing list
+		getParent().setHas_bugs(newCh.Travelbugs.size() > 0);
+		for (int i = newCh.Travelbugs.size() - 1; i >= 0; i--) {
+			Travelbug tb = newCh.Travelbugs.getTB(i);
+			Travelbug oldTB = this.Travelbugs.find(tb.getName());
+			// If the bug is already in the cache, we keep it
+			if (oldTB != null) {
+				if (tb.getMission().length() > 0)
+					oldTB.setMission(tb.getMission());
+				if (tb.getGuid().length() > 0)
+					oldTB.setGuid(tb.getGuid());
+				newCh.Travelbugs.replace(i, oldTB);
 			}
-			//travelbugs:GPX-File contains all actual travelbugs but not the missions
-			// we need to check whether the travelbug is already in the existing list
-			getParent().setHas_bugs(newCh.Travelbugs.size()>0);
-			for (int i=newCh.Travelbugs.size()-1; i>=0; i--) {
-				Travelbug tb=newCh.Travelbugs.getTB(i);
-				Travelbug oldTB=this.Travelbugs.find(tb.getName());
-				// If the bug is already in the cache, we keep it
-				if (oldTB != null) {
-					if (tb.getMission().length() > 0)
-						oldTB.setMission(tb.getMission());
-					if (tb.getGuid().length() > 0)
-						oldTB.setGuid(tb.getGuid());
-					newCh.Travelbugs.replace(i,oldTB);
-				}
+		}
+		this.Travelbugs = newCh.Travelbugs;
+		if (newCh.attributes.count() > 0)
+			this.attributes = newCh.attributes;
+		// URL
+		this.URL = newCh.URL;
+		// Images
+		this.images = newCh.images;
+		setLongDescription(newCh.LongDescription);
+		setHints(newCh.Hints);
+		setCacheLogs(newCh.CacheLogs);
+		if (newCh.OwnLogId.length() > 0)
+			this.OwnLogId = newCh.OwnLogId;
+		if (newCh.OwnLog != null)
+			this.OwnLog = newCh.OwnLog;
+		if (newCh.Country.length() > 0)
+			this.Country = newCh.Country;
+		if (newCh.State.length() > 0)
+			this.State = newCh.State;
+		if (newCh.getSolver().length() > 0)
+			this.setSolver(newCh.getSolver());
+		return this;
+	}
+
+	/**
+	 * Adds a user image to the cache data
+	 * 
+	 * @param profile
+	 */
+	public void addUserImage(Profile profile) {
+		File imgFile;
+		String imgDesc, imgDestName;
+
+		// Get Image and description
+		FileChooser fc = new FileChooser(FileChooserBase.OPEN, profile.dataDir);
+		fc.setTitle("Select image file:");
+		if (fc.execute() != FormBase.IDCANCEL) {
+			imgFile = fc.getChosenFile();
+			imgDesc = new InputBox("Description").input("", 10);
+			// Create Destination Filename
+			String ext = imgFile.getFileExt().substring(imgFile.getFileExt().lastIndexOf('.'));
+			imgDestName = getParent().getWayPoint() + "_U_" + (this.userImages.size() + 1) + ext;
+
+			ImageInfo userImageInfo = new ImageInfo();
+			userImageInfo.setFilename(imgDestName);
+			userImageInfo.setTitle(imgDesc);
+			this.userImages.add(userImageInfo);
+			// Copy File
+			DataMover.copy(imgFile.getFullPath(), profile.dataDir + imgDestName);
+			// Save Data
+			saveCacheDetails(profile.dataDir);
+		}
+	}
+
+	/**
+	 * Method to parse a specific cache.xml file.
+	 * It fills information on cache details, hints, logs, notes and
+	 * images.
+	 */
+	void readCache(String dir) throws IOException {
+		String dummy;
+		FileReader in = null;
+		ImageInfo imageInfo;
+		// If parent cache has empty waypoint then don't do anything. This might happen
+		// when a cache object is freshly created to serve as container for imported data
+		if (this.getParent().getWayPoint().equals(CacheHolder.EMPTY))
+			return;
+		FileBugfix cacheFile = new FileBugfix(dir + getParent().getWayPoint().toLowerCase() + ".xml");
+		if (cacheFile.exists()) {
+			try {
+				in = new FileReader(cacheFile.getAbsolutePath());
+			} catch (FileNotFoundException e) {
+				in = null; // exception is thrown again below, if file could not be found in upper case, too
 			}
-			this.Travelbugs = newCh.Travelbugs;
-			if (newCh.attributes.count() > 0) this.attributes = newCh.attributes;
-			// URL
-			this.URL = newCh.URL;
-			// Images
-			this.images = newCh.images;
-			setLongDescription(newCh.LongDescription);
-			setHints(newCh.Hints);
-			setCacheLogs(newCh.CacheLogs);
-			if (newCh.OwnLogId.length()>0) this.OwnLogId=newCh.OwnLogId;
-			if (newCh.OwnLog != null) this.OwnLog = newCh.OwnLog;
-			if (newCh.Country.length()>0) this.Country=newCh.Country;
-			if (newCh.State.length()>0) this.State=newCh.State;
-			if (newCh.getSolver().length()>0) this.setSolver(newCh.getSolver());
-			return this;		
-	 }
-	  
-	  /**
-	   * Adds a user image to the cache data
-	   * @param profile
-	   */
-		public void addUserImage(Profile profile){
-		  File imgFile;
-		  String imgDesc, imgDestName;
-		  
-		  //Get Image and description
-			FileChooser fc = new FileChooser(FileChooserBase.OPEN, profile.dataDir);
-			fc.setTitle("Select image file:");
-			if(fc.execute() != FormBase.IDCANCEL){
-				imgFile = fc.getChosenFile();
-				imgDesc = new InputBox("Description").input("",10);
-				//Create Destination Filename
-				String ext = imgFile.getFileExt().substring(imgFile.getFileExt().lastIndexOf('.'));
-				imgDestName = getParent().getWayPoint() + "_U_" + (this.userImages.size()+1) + ext;
-				
-				ImageInfo userImageInfo = new ImageInfo();
-				userImageInfo.setFilename(imgDestName);
-				userImageInfo.setTitle(imgDesc);
-				this.userImages.add(userImageInfo);
-				// Copy File
-				DataMover.copy(imgFile.getFullPath(),profile.dataDir + imgDestName);
-				// Save Data
-				saveCacheDetails(profile.dataDir);
+		}
+		if (in == null) {
+			cacheFile = new FileBugfix(dir + getParent().getWayPoint() + ".xml");
+			if (cacheFile.exists()) {
+				in = new FileReader(cacheFile.getAbsolutePath());
 			}
-	  }
+		}
 
-	  
-		/**
-		*	Method to parse a specific cache.xml file.
-		*	It fills information on cache details, hints, logs, notes and
-		*	images.
-		*/
-		void readCache(String dir) throws IOException{
-			String dummy;
-			FileReader in = null;
-			ImageInfo imageInfo;
-			// If parent cache has empty waypoint then don't do anything. This might happen
-			// when a cache object is freshly created to serve as container for imported data
-			if (this.getParent().getWayPoint().equals(CacheHolder.EMPTY)) return;
-			FileBugfix cacheFile = new FileBugfix(dir + getParent().getWayPoint().toLowerCase() + ".xml");			
-			if (cacheFile.exists()) {
-				try {
-					in = new FileReader(cacheFile.getAbsolutePath());
-				} catch (FileNotFoundException e) {
-					in = null; //exception is thrown again below, if file could not be found in upper case, too
-				}
+		if (in == null)
+			throw new FileNotFoundException(dir + getParent().getWayPoint().toLowerCase() + ".xml");
+		Global.getPref().log("Reading file " + getParent().getWayPoint() + ".xml");
+		String text = in.readAll();
+		in.close();
+
+		Extractor ex = new Extractor(text, "<DETAILS><![CDATA[", "]]></DETAILS>", 0, true);
+		LongDescription = ex.findNext();
+
+		ex.set(text, "<COUNTRY><![CDATA[", "]]></COUNTRY>", 0, true);
+		Country = ex.findNext();
+
+		ex.set(text, "<STATE><![CDATA[", "]]></STATE>", 0, true);
+		State = ex.findNext();
+
+		// Attributes
+		ex.set(text, "<ATTRIBUTES>", "</ATTRIBUTES>", 0, true);
+		attributes.XmlAttributesEnd(ex.findNext());
+
+		ex.set(text, "<HINTS><![CDATA[", "]]></HINTS>", 0, true);
+		Hints = ex.findNext();
+
+		ex.set(text, "<LOGS>", "</LOGS>", 0, true);
+		dummy = ex.findNext();
+
+		ex.set(dummy, "<OWNLOGID>", "</OWNLOGID>", 0, true);
+		OwnLogId = ex.findNext();
+
+		ex.set(dummy, "<OWNLOG><![CDATA[", "]]></OWNLOG>", 0, true);
+		String ownLogText = ex.findNext();
+		if (ownLogText.length() > 0) {
+			if (ownLogText.indexOf("<img src='") >= 0) {
+				OwnLog = new Log(ownLogText + "]]>");
+			} else {
+				OwnLog = new Log("icon_smile.gif", "1900-01-01", Global.getPref().myAlias, ownLogText);
 			}
-			if (in == null) {
-				cacheFile = new FileBugfix(dir + getParent().getWayPoint() + ".xml");			
-				if (cacheFile.exists()) {
-					in = new FileReader(cacheFile.getAbsolutePath());
-				}
-			}
+		} else {
+			OwnLog = null;
+		}
 
-			if (in == null) throw new FileNotFoundException(dir+getParent().getWayPoint().toLowerCase()+".xml");
-			Global.getPref().log("Reading file "+getParent().getWayPoint() + ".xml");
-			String text= in.readAll();
-			in.close();
-			Extractor ex = new Extractor(text, "<DETAILS><![CDATA[", "]]></DETAILS>", 0, true);		
-			LongDescription = ex.findNext();
-			ex = new Extractor(text, "<COUNTRY><![CDATA[", "]]></COUNTRY>", 0, true);
-			Country = ex.findNext();
-			ex = new Extractor(text, "<STATE><![CDATA[", "]]></STATE>", 0, true);
-			State = ex.findNext();
-			// Attributes
-			ex = new Extractor(text,"<ATTRIBUTES>","</ATTRIBUTES>",0,true);
-			attributes.XmlAttributesEnd(ex.findNext());
-			
-			ex = new Extractor(text, "<HINTS><![CDATA[", "]]></HINTS>", 0, true);
-			Hints = ex.findNext();
-			ex = new Extractor(text, "<LOGS>","</LOGS>", 0, true);
-			dummy = ex.findNext();
-			ex = new Extractor(dummy, "<OWNLOGID>","</OWNLOGID>", 0, true);
-			OwnLogId = ex.findNext();
-			ex = new Extractor(dummy, "<OWNLOG><![CDATA[", "]]></OWNLOG>", 0, true);
-			String ownLogText = ex.findNext();
-			if ( ownLogText.length() > 0 ) {
-				if (ownLogText.indexOf("<img src='") >= 0) {
-					OwnLog = new Log( ownLogText + "]]>" );
-				} else {
-					OwnLog = new Log( "icon_smile.gif", "1900-01-01", Global.getPref().myAlias, ownLogText );
-				}
+		CacheLogs.clear();
+		ex.set(dummy, "<LOG>", "</LOG>", 0, true);
+		while ((dummy = ex.findNext()).length() > 0) {
+			CacheLogs.add(new Log(dummy));
+		}
+
+		ex.set(text, "<NOTES><![CDATA[", "]]></NOTES>", 0, true);
+		CacheNotes = ex.findNext();
+		images.clear();
+
+		ex.set(text, "<IMG>", "</IMG>", 0, true);
+		while ((dummy = ex.findNext()).length() > 0) {
+			imageInfo = new ImageInfo();
+			int pos = dummy.indexOf("<URL>");
+			if (pos > 0) {
+				imageInfo.setFilename(SafeXML.cleanback(dummy.substring(0, pos)));
+				imageInfo.setURL(SafeXML.cleanback((dummy.substring(pos + 5, dummy.indexOf("</URL>")))));
 			} else {
-				OwnLog = null;
+				imageInfo.setFilename(SafeXML.cleanback(dummy));
 			}
-			CacheLogs.clear();
-			ex = new Extractor(dummy, "<LOG>","</LOG>", 0, true);
-			
-			dummy = ex.findNext();
-			while(!ex.endOfSearch()){
-				CacheLogs.add(new Log(dummy));
-				dummy = ex.findNext();
-			}
-			ex = new Extractor(text, "<NOTES><![CDATA[", "]]></NOTES>", 0, true);
-			CacheNotes = ex.findNext();
-			images.clear();
-			ex = new Extractor(text, "<IMG>", "</IMG>", 0, true);
-			dummy = ex.findNext();
-			while(!ex.endOfSearch()){
-				imageInfo = new ImageInfo();
-				int pos=dummy.indexOf("<URL>");
-				if (pos>0) {
-					imageInfo.setFilename(SafeXML.cleanback(dummy.substring(0,pos)));
-					imageInfo.setURL(SafeXML.cleanback((dummy.substring(pos+5,dummy.indexOf("</URL>")))));
-				} else {
-					imageInfo.setFilename(SafeXML.cleanback(dummy));
-				}
-				this.images.add(imageInfo);
-				dummy = ex.findNext();
-			}
-			ex = new Extractor(text, "<IMGTEXT>", "</IMGTEXT>", 0, true);
-			dummy = ex.findNext();
-			int imgNr = 0;
-			while(!ex.endOfSearch()){
-				if (imgNr >= this.images.size()) {
-					images.add(new ImageInfo()); // this (more IMGTEXT than IMG in the <cache>.xml, but it happens. So avoid an ArrayIndexOutOfBoundException and add an ImageInfo gracefully
-					Global.getPref().log("Error reading " + this.getParent().getWayPoint() + "More IMGTEXT tags than IMG tags");
-				}
-				imageInfo = this.images.get(imgNr);
-				int pos=dummy.indexOf("<DESC>");
-				if (pos>0) {
-					imageInfo.setTitle(dummy.substring(0,pos));
-					imageInfo.setComment(dummy.substring(pos+6,dummy.indexOf("</DESC>")));
-				} else {
-					imageInfo.setTitle(dummy);
-				}
-				dummy = ex.findNext();
-				imgNr = imgNr + 1;
-			}
-			// Logimages
-			logImages.clear();
-			ex = new Extractor(text, "<LOGIMG>", "</LOGIMG>", 0, true);
-			dummy = ex.findNext();
-			while(!ex.endOfSearch()){
-				imageInfo = new ImageInfo();
-				imageInfo.setFilename(dummy);
-				logImages.add(imageInfo);
-				dummy = ex.findNext();
-			}
-			ex = new Extractor(text, "<LOGIMGTEXT>", "</LOGIMGTEXT>", 0, true);
-			dummy = ex.findNext();
-			imgNr = 0;
-			while(!ex.endOfSearch()){
-				imageInfo = logImages.get(imgNr++);
-				imageInfo.setTitle(dummy);
-				dummy = ex.findNext();
-			}
+			this.images.add(imageInfo);
+		}
 
-			userImages.clear();
-			ex = new Extractor(text, "<USERIMG>", "</USERIMG>", 0, true);
-			dummy = ex.findNext();
-			while(!ex.endOfSearch()){
-				imageInfo = new ImageInfo();
-				imageInfo.setFilename(dummy);
-				userImages.add(imageInfo);
-				dummy = ex.findNext();
+		ex.set(text, "<IMGTEXT>", "</IMGTEXT>", 0, true);
+		int imgNr = 0;
+		while ((dummy = ex.findNext()).length() > 0) {
+			if (imgNr >= this.images.size()) {
+				images.add(new ImageInfo()); // this (more IMGTEXT than IMG in the <cache>.xml, but it happens. So avoid an ArrayIndexOutOfBoundException and add an ImageInfo gracefully
+				Global.getPref().log("Error reading " + this.getParent().getWayPoint() + "More IMGTEXT tags than IMG tags");
 			}
-			ex = new Extractor(text, "<USERIMGTEXT>", "</USERIMGTEXT>", 0, true);
-			dummy = ex.findNext();
-			imgNr = 0;
-			while(!ex.endOfSearch()){
-				imageInfo = userImages.get(imgNr++);
+			imageInfo = this.images.get(imgNr);
+			int pos = dummy.indexOf("<DESC>");
+			if (pos > 0) {
+				imageInfo.setTitle(dummy.substring(0, pos));
+				imageInfo.setComment(dummy.substring(pos + 6, dummy.indexOf("</DESC>")));
+			} else {
 				imageInfo.setTitle(dummy);
-				dummy = ex.findNext();
 			}
+			imgNr = imgNr + 1;
+		}
 
-			ex = new Extractor(text, "<TRAVELBUGS>", "</TRAVELBUGS>", 0, false);
-			dummy=ex.findNext();
-			if (ex.endOfSearch()) {
-				ex = new Extractor(text, "<BUGS><![CDATA[", "]]></BUGS>", 0, true);
-				String Bugs = ex.findNext();
-				Travelbugs.addFromHTML(Bugs);
-			} else
-				Travelbugs.addFromXML(dummy);
-			
-			ex = new Extractor(text, "<URL><![CDATA[", "]]></URL>", 0, true);
-			// if no URL is stored, set default URL (at this time only possible for gc.com)
-			dummy = ex.findNext();
-			if (dummy.length() > 10){
-				URL = dummy;
-				int logpos = URL.indexOf("&"); //&Submit &log=y
-				if (logpos > 0) URL=URL.substring(0,logpos);
-			}
-			else {
-				if (getParent().getWayPoint().startsWith("GC")) {
-					URL = "http://www.geocaching.com/seek/cache_details.aspx?wp="+ getParent().getWayPoint();
-				}
-			}
-			ex = new Extractor(text, "<SOLVER><![CDATA[", "]]></SOLVER>", 0, true);
-			this.setSolver(ex.findNext());
+		logImages.clear();
+		ex.set(text, "<LOGIMG>", "</LOGIMG>", 0, true);
+		while ((dummy = ex.findNext()).length() > 0) {
+			imageInfo = new ImageInfo();
+			imageInfo.setFilename(dummy);
+			logImages.add(imageInfo);
 		}
-		public void deleteFile(String FileName) {	
-			//File exists?
-			boolean exists = (new File(FileName)).exists();
-			//yes: then delete
-			if (exists) {
-				boolean ok = (new File(FileName)).delete();
-				if(ok) ok = true;
-			}
-			boolean exists2 = (new File(FileName.toLowerCase())).exists();
-			//yes: delete
-			if (exists2) {
-				boolean ok2 = (new File(FileName.toLowerCase())).delete();
-				if(ok2) ok2=true;
-			}
+
+		ex.set(text, "<LOGIMGTEXT>", "</LOGIMGTEXT>", 0, true);
+		imgNr = 0;
+		while ((dummy = ex.findNext()).length() > 0) {
+			imageInfo = logImages.get(imgNr++);
+			imageInfo.setTitle(dummy);
 		}
-		/**
-		*	Method to save a cache.xml file.
-		*/
-		public void saveCacheDetails(String dir){
-			PrintWriter detfile;
-			deleteFile(dir + getParent().getWayPoint() + ".xml");
-			try{
-			  detfile = new PrintWriter(new BufferedWriter(new FileWriter(new FileBugfix(dir + getParent().getWayPoint().toLowerCase() + ".xml").getAbsolutePath())));
-			} catch (Exception e) {
-				Global.getPref().log("Problem creating details file",e,true);
-				return;
-			}
-			try{
-				if(getParent().getWayPoint().length()>0){
-				  detfile.print("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n");
-				  detfile.print("<CACHEDETAILS>\r\n");
-				  detfile.print("<VERSION value = \"3\"/>\n");
-				  detfile.print("<DETAILS><![CDATA["+LongDescription+"]]></DETAILS>\r\n");
-				  detfile.print("<COUNTRY><![CDATA["+Country+"]]></COUNTRY>\n");
-				  detfile.print("<STATE><![CDATA["+State+"]]></STATE>\n");
-				  detfile.print(attributes.XmlAttributesWrite());
-				  detfile.print("<HINTS><![CDATA["+Hints+"]]></HINTS>\r\n");
-				  detfile.print("<LOGS>\r\n");
-				  detfile.print("<OWNLOGID>"+OwnLogId+"</OWNLOGID>\r\n");
-				  if ( OwnLog != null ) {
-					  detfile.print("<OWNLOG><![CDATA["+OwnLog.toHtml()+"]]></OWNLOG>\r\n");
-				  } else {
-					  detfile.print("<OWNLOG><![CDATA[]]></OWNLOG>\r\n");
-				  }
-				  for(int i = 0; i < CacheLogs.size(); i++){
-					  detfile.print(CacheLogs.getLog(i).toXML());
-				  }
-				  detfile.print("</LOGS>\r\n");
-			
-				  detfile.print("<NOTES><![CDATA["+CacheNotes+"]]></NOTES>\n");
-				  detfile.print("<IMAGES>\n");
-				  String stbuf;
-				  for(int i = 0;i<images.size();i++){
-						stbuf = images.get(i).getFilename();
-						String urlBuf = images.get(i).getURL();
-						if (urlBuf != null && !urlBuf.equals("")) {
-							detfile.print("    <IMG>"+SafeXML.clean(stbuf)+"<URL>"+SafeXML.clean(urlBuf)+"</URL></IMG>\n");
-						} else {
-							detfile.print("    <IMG>"+SafeXML.clean(stbuf)+"</IMG>\n");
-						}
-				  }
-				  int iis = images.size();
-				  for(int i = 0;i<iis;i++){
-						stbuf = images.get(i).getTitle();
-						if (i< iis && !images.get(i).getComment().equals(""))
-							detfile.print("    <IMGTEXT>"+stbuf+"<DESC>"+images.get(i).getComment()+"</DESC></IMGTEXT>\n");
-						else 
-							detfile.print("    <IMGTEXT>"+stbuf+"</IMGTEXT>\n");
-				  }
 
-				  for(int i = 0;i<logImages.size();i++){
-						stbuf = logImages.get(i).getFilename();
-						detfile.print("    <LOGIMG>"+stbuf+"</LOGIMG>\n");
-				  }
-				  for(int i = 0;i<logImages.size();i++){
-						stbuf = logImages.get(i).getTitle();
-						detfile.print("    <LOGIMGTEXT>"+stbuf+"</LOGIMGTEXT>\n");
-				  }
-				  for(int i = 0;i<userImages.size();i++){
-						stbuf = userImages.get(i).getFilename();
-						detfile.print("    <USERIMG>"+stbuf+"</USERIMG>\n");
-				  }
-				  for(int i = 0;i<userImages.size();i++){
-						stbuf = userImages.get(i).getTitle();
-						detfile.print("    <USERIMGTEXT>"+stbuf+"</USERIMGTEXT>\n");
-				  }
+		userImages.clear();
+		ex.set(text, "<USERIMG>", "</USERIMG>", 0, true);
+		while ((dummy = ex.findNext()).length() > 0) {
+			imageInfo = new ImageInfo();
+			imageInfo.setFilename(dummy);
+			userImages.add(imageInfo);
+		}
 
+		ex.set(text, "<USERIMGTEXT>", "</USERIMGTEXT>", 0, true);
+		imgNr = 0;
+		while ((dummy = ex.findNext()).length() > 0) {
+			imageInfo = userImages.get(imgNr++);
+			imageInfo.setTitle(dummy);
+		}
 
-				  detfile.print("</IMAGES>\n");
-				  //detfile.print("<BUGS><![CDATA[\n");
-				  //detfile.print(Bugs+"\n");
-				  //detfile.print("]]></BUGS>\n");
-				  detfile.print(Travelbugs.toXML());
-				  detfile.print("<URL><![CDATA["+URL+"]]></URL>\r\n");
-				  detfile.print("<SOLVER><![CDATA["+getSolver()+"]]></SOLVER>\r\n");
-				  detfile.print(getParent().toXML()); // This will allow restoration of index.xml
-				  detfile.print("</CACHEDETAILS>\n");
-				  Global.getPref().log("Writing file: "+getParent().getWayPoint().toLowerCase() + ".xml");
-				} // if length
-			} catch (Exception e){
-				Global.getPref().log("Problem waypoint " + getParent().getWayPoint() + " writing to a details file: ",e);
+		ex.set(text, "<TRAVELBUGS>", "</TRAVELBUGS>", 0, false);
+		dummy = ex.findNext();
+		if (dummy.length() == 0) {
+			ex = new Extractor(text, "<BUGS><![CDATA[", "]]></BUGS>", 0, true);
+			String Bugs = ex.findNext();
+			Travelbugs.addFromHTML(Bugs);
+		} else
+			Travelbugs.addFromXML(dummy);
+
+		ex.set(text, "<URL><![CDATA[", "]]></URL>", 0, true);
+		// if no URL is stored, set default URL (at this time only possible for gc.com)
+		dummy = ex.findNext();
+		if (dummy.length() > 10) {
+			URL = dummy;
+			int logpos = URL.indexOf("&"); // &Submit &log=y
+			if (logpos > 0)
+				URL = URL.substring(0, logpos);
+		} else {
+			if (getParent().getWayPoint().startsWith("GC")) {
+				URL = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + getParent().getWayPoint();
 			}
-			try{
-			  detfile.close();
-			} catch (Exception e){
-				Global.getPref().log("Problem waypoint " + getParent().getWayPoint() + " writing to a details file: ",e);
-			}
-			hasUnsavedChanges = false;
 		}
-				
-		/**
-		 * Return true if this cache has additional info for some pictures
-		 * @return true if cache has additional info, false otherwise
-		 */
-		public boolean hasImageInfo() {
-			for (int i=this.images.size()-1; i>=0; i--)
-				if (!this.images.get(i).getComment().equals("")) return true;
-			return false;
+
+		ex.set(text, "<SOLVER><![CDATA[", "]]></SOLVER>", 0, true);
+		this.setSolver(ex.findNext());
+	}
+
+	public void deleteFile(String FileName) {
+		// File exists?
+		boolean exists = (new File(FileName)).exists();
+		// yes: then delete
+		if (exists) {
+			boolean ok = (new File(FileName)).delete();
+			if (ok)
+				ok = true;
 		}
+		boolean exists2 = (new File(FileName.toLowerCase())).exists();
+		// yes: delete
+		if (exists2) {
+			boolean ok2 = (new File(FileName.toLowerCase())).delete();
+			if (ok2)
+				ok2 = true;
+		}
+	}
 
-		/**
-		 * change id in waypoint details and rename associated files. Function should only be called by CacheHolder
-		 * @param newWptId new id of the waypoint
-		 * @return true on success, false for failure
-		 */
-		protected boolean rename(String newWptId) {
-			boolean success = false;
-			String profiledir = Global.getProfile().dataDir;
-			int oldWptLength = getParent().getWayPoint().length();
-			
-			// just in case ... (got the pun? ;) )
-			newWptId = newWptId.toUpperCase();
-			
-			// update image information
-			for(int i = 0;i<images.size();i++){
-				String filename = images.get(i).getFilename();
-				String comment = images.get(i).getComment();
-				String title = images.get(i).getTitle();
-				if (filename.indexOf(getParent().getWayPoint()) == 0) {
-					filename=newWptId.concat(filename.substring(oldWptLength));
-					images.get(i).setFilename(filename);
+	/**
+	 * Method to save a cache.xml file.
+	 */
+	public void saveCacheDetails(String dir) {
+		PrintWriter detfile;
+		deleteFile(dir + getParent().getWayPoint() + ".xml");
+		try {
+			detfile = new PrintWriter(new BufferedWriter(new FileWriter(new FileBugfix(dir + getParent().getWayPoint().toLowerCase() + ".xml").getAbsolutePath())));
+		} catch (Exception e) {
+			Global.getPref().log("Problem creating details file", e, true);
+			return;
+		}
+		try {
+			if (getParent().getWayPoint().length() > 0) {
+				detfile.print("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n");
+				detfile.print("<CACHEDETAILS>\r\n");
+				detfile.print("<VERSION value = \"3\"/>\n");
+				detfile.print("<DETAILS><![CDATA[" + LongDescription + "]]></DETAILS>\r\n");
+				detfile.print("<COUNTRY><![CDATA[" + Country + "]]></COUNTRY>\n");
+				detfile.print("<STATE><![CDATA[" + State + "]]></STATE>\n");
+				detfile.print(attributes.XmlAttributesWrite());
+				detfile.print("<HINTS><![CDATA[" + Hints + "]]></HINTS>\r\n");
+				detfile.print("<LOGS>\r\n");
+				detfile.print("<OWNLOGID>" + OwnLogId + "</OWNLOGID>\r\n");
+				if (OwnLog != null) {
+					detfile.print("<OWNLOG><![CDATA[" + OwnLog.toHtml() + "]]></OWNLOG>\r\n");
+				} else {
+					detfile.print("<OWNLOG><![CDATA[]]></OWNLOG>\r\n");
 				}
-				if (comment.indexOf(getParent().getWayPoint()) == 0) {
-					comment=newWptId.concat(comment.substring(oldWptLength));
-					images.get(i).setComment(comment);
+				for (int i = 0; i < CacheLogs.size(); i++) {
+					detfile.print(CacheLogs.getLog(i).toXML());
 				}
-				if (title.indexOf(getParent().getWayPoint()) == 0) {
-					title=newWptId.concat(title.substring(oldWptLength));
-					images.get(i).setTitle(title);
+				detfile.print("</LOGS>\r\n");
+
+				detfile.print("<NOTES><![CDATA[" + CacheNotes + "]]></NOTES>\n");
+				detfile.print("<IMAGES>\n");
+				String stbuf;
+				for (int i = 0; i < images.size(); i++) {
+					stbuf = images.get(i).getFilename();
+					String urlBuf = images.get(i).getURL();
+					if (urlBuf != null && !urlBuf.equals("")) {
+						detfile.print("    <IMG>" + SafeXML.clean(stbuf) + "<URL>" + SafeXML.clean(urlBuf) + "</URL></IMG>\n");
+					} else {
+						detfile.print("    <IMG>" + SafeXML.clean(stbuf) + "</IMG>\n");
+					}
 				}
-			}
-			for(int i = 0;i<logImages.size();i++){
-				String filename = logImages.get(i).getFilename();
-				String comment = logImages.get(i).getComment();
-				String title = logImages.get(i).getTitle();
-				if (filename.indexOf(getParent().getWayPoint()) == 0) {
-					filename=newWptId.concat(filename.substring(oldWptLength));
-					logImages.get(i).setFilename(filename);
+				int iis = images.size();
+				for (int i = 0; i < iis; i++) {
+					stbuf = images.get(i).getTitle();
+					if (i < iis && !images.get(i).getComment().equals(""))
+						detfile.print("    <IMGTEXT>" + stbuf + "<DESC>" + images.get(i).getComment() + "</DESC></IMGTEXT>\n");
+					else
+						detfile.print("    <IMGTEXT>" + stbuf + "</IMGTEXT>\n");
 				}
-				if (comment.indexOf(getParent().getWayPoint()) == 0) {
-					comment=newWptId.concat(comment.substring(oldWptLength));
-					logImages.get(i).setComment(comment);
+
+				for (int i = 0; i < logImages.size(); i++) {
+					stbuf = logImages.get(i).getFilename();
+					detfile.print("    <LOGIMG>" + stbuf + "</LOGIMG>\n");
 				}
-				if (title.indexOf(getParent().getWayPoint()) == 0) {
-					title=newWptId.concat(title.substring(oldWptLength));
-					logImages.get(i).setTitle(title);
+				for (int i = 0; i < logImages.size(); i++) {
+					stbuf = logImages.get(i).getTitle();
+					detfile.print("    <LOGIMGTEXT>" + stbuf + "</LOGIMGTEXT>\n");
 				}
-			}
-			for(int i = 0;i<userImages.size();i++){
-				String filename = userImages.get(i).getFilename();
-				String comment = userImages.get(i).getComment();
-				String title = userImages.get(i).getTitle();
-				if (filename.indexOf(getParent().getWayPoint()) == 0) {
-					filename=newWptId.concat(filename.substring(oldWptLength));
-					userImages.get(i).setFilename(filename);
+				for (int i = 0; i < userImages.size(); i++) {
+					stbuf = userImages.get(i).getFilename();
+					detfile.print("    <USERIMG>" + stbuf + "</USERIMG>\n");
 				}
-				if (comment.indexOf(getParent().getWayPoint()) == 0) {
-					comment=newWptId.concat(comment.substring(oldWptLength));
-					userImages.get(i).setComment(comment);
+				for (int i = 0; i < userImages.size(); i++) {
+					stbuf = userImages.get(i).getTitle();
+					detfile.print("    <USERIMGTEXT>" + stbuf + "</USERIMGTEXT>\n");
 				}
-				if (title.indexOf(getParent().getWayPoint()) == 0) {
-					title=newWptId.concat(title.substring(oldWptLength));
-					userImages.get(i).setTitle(title);
-				}
+
+				detfile.print("</IMAGES>\n");
+				// detfile.print("<BUGS><![CDATA[\n");
+				// detfile.print(Bugs+"\n");
+				// detfile.print("]]></BUGS>\n");
+				detfile.print(Travelbugs.toXML());
+				detfile.print("<URL><![CDATA[" + URL + "]]></URL>\r\n");
+				detfile.print("<SOLVER><![CDATA[" + getSolver() + "]]></SOLVER>\r\n");
+				detfile.print(getParent().toXML()); // This will allow restoration of index.xml
+				detfile.print("</CACHEDETAILS>\n");
+				Global.getPref().log("Writing file: " + getParent().getWayPoint().toLowerCase() + ".xml");
+			} // if length
+		} catch (Exception e) {
+			Global.getPref().log("Problem waypoint " + getParent().getWayPoint() + " writing to a details file: ", e);
+		}
+		try {
+			detfile.close();
+		} catch (Exception e) {
+			Global.getPref().log("Problem waypoint " + getParent().getWayPoint() + " writing to a details file: ", e);
+		}
+		hasUnsavedChanges = false;
+	}
+
+	/**
+	 * Return true if this cache has additional info for some pictures
+	 * 
+	 * @return true if cache has additional info, false otherwise
+	 */
+	public boolean hasImageInfo() {
+		for (int i = this.images.size() - 1; i >= 0; i--)
+			if (!this.images.get(i).getComment().equals(""))
+				return true;
+		return false;
+	}
+
+	/**
+	 * change id in waypoint details and rename associated files. Function should only be called by CacheHolder
+	 * 
+	 * @param newWptId
+	 *            new id of the waypoint
+	 * @return true on success, false for failure
+	 */
+	protected boolean rename(String newWptId) {
+		boolean success = false;
+		String profiledir = Global.getProfile().dataDir;
+		int oldWptLength = getParent().getWayPoint().length();
+
+		// just in case ... (got the pun? ;) )
+		newWptId = newWptId.toUpperCase();
+
+		// update image information
+		for (int i = 0; i < images.size(); i++) {
+			String filename = images.get(i).getFilename();
+			String comment = images.get(i).getComment();
+			String title = images.get(i).getTitle();
+			if (filename.indexOf(getParent().getWayPoint()) == 0) {
+				filename = newWptId.concat(filename.substring(oldWptLength));
+				images.get(i).setFilename(filename);
 			}
+			if (comment.indexOf(getParent().getWayPoint()) == 0) {
+				comment = newWptId.concat(comment.substring(oldWptLength));
+				images.get(i).setComment(comment);
+			}
+			if (title.indexOf(getParent().getWayPoint()) == 0) {
+				title = newWptId.concat(title.substring(oldWptLength));
+				images.get(i).setTitle(title);
+			}
+		}
+		for (int i = 0; i < logImages.size(); i++) {
+			String filename = logImages.get(i).getFilename();
+			String comment = logImages.get(i).getComment();
+			String title = logImages.get(i).getTitle();
+			if (filename.indexOf(getParent().getWayPoint()) == 0) {
+				filename = newWptId.concat(filename.substring(oldWptLength));
+				logImages.get(i).setFilename(filename);
+			}
+			if (comment.indexOf(getParent().getWayPoint()) == 0) {
+				comment = newWptId.concat(comment.substring(oldWptLength));
+				logImages.get(i).setComment(comment);
+			}
+			if (title.indexOf(getParent().getWayPoint()) == 0) {
+				title = newWptId.concat(title.substring(oldWptLength));
+				logImages.get(i).setTitle(title);
+			}
+		}
+		for (int i = 0; i < userImages.size(); i++) {
+			String filename = userImages.get(i).getFilename();
+			String comment = userImages.get(i).getComment();
+			String title = userImages.get(i).getTitle();
+			if (filename.indexOf(getParent().getWayPoint()) == 0) {
+				filename = newWptId.concat(filename.substring(oldWptLength));
+				userImages.get(i).setFilename(filename);
+			}
+			if (comment.indexOf(getParent().getWayPoint()) == 0) {
+				comment = newWptId.concat(comment.substring(oldWptLength));
+				userImages.get(i).setComment(comment);
+			}
+			if (title.indexOf(getParent().getWayPoint()) == 0) {
+				title = newWptId.concat(title.substring(oldWptLength));
+				userImages.get(i).setTitle(title);
+			}
+		}
 
-			// rename the files
-			try {
-				// since we use *.* we do not need FileBugFix
-				String srcFiles[] = new File(profiledir).list(getParent().getWayPoint().concat("*.*"), ewe.io.FileBase.LIST_FILES_ONLY);
-				for (int i=0; i < srcFiles.length;i++){
-					String newfile = newWptId.concat(srcFiles[i].substring(oldWptLength));
-					File srcFile = new File(profiledir.concat(srcFiles[i]));
-					File dstFile = new File(profiledir.concat(newfile));
-					srcFile.move(dstFile);
-				}
-				success = true;
-			} catch (Exception e) {
-				Global.getPref().log("Error renaming waypoint details", e, true);
-				//TODO: any chance of a roll back?
-				//TODO: should we ignore a file not found?
+		// rename the files
+		try {
+			// since we use *.* we do not need FileBugFix
+			String srcFiles[] = new File(profiledir).list(getParent().getWayPoint().concat("*.*"), ewe.io.FileBase.LIST_FILES_ONLY);
+			for (int i = 0; i < srcFiles.length; i++) {
+				String newfile = newWptId.concat(srcFiles[i].substring(oldWptLength));
+				File srcFile = new File(profiledir.concat(srcFiles[i]));
+				File dstFile = new File(profiledir.concat(newfile));
+				srcFile.move(dstFile);
 			}
-			hasUnsavedChanges = true;
-			return success;
+			success = true;
+		} catch (Exception e) {
+			Global.getPref().log("Error renaming waypoint details", e, true);
+			// TODO: any chance of a roll back?
+			// TODO: should we ignore a file not found?
 		}
+		hasUnsavedChanges = true;
+		return success;
+	}
 }
-
-

Modified: trunk/src/CacheWolf/Extractor.java
===================================================================
--- trunk/src/CacheWolf/Extractor.java	2011-05-18 07:45:09 UTC (rev 3006)
+++ trunk/src/CacheWolf/Extractor.java	2011-05-18 14:06:48 UTC (rev 3007)
@@ -1,104 +1,119 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
+/**
+ * This is a powerfull class that is used very often. It is quicker than
+ * XML parsing and should be used whenever possible to find and extract
+ * parts of a string in a string.
+ */
+public class Extractor {
+	int _startOffset;
+	String _searchText;
+	String start;
+	String end;
+	boolean _betweenonly;
+	public static boolean INCLUDESTARTEND = false;
+	public static boolean EXCLUDESTARTEND = true;
 
-/**
-*	This is a powerfull class that is used very often. It is quicker than
-*	XML parsing and should be used whenever possible to find and extract
-*	parts of a string in a string.
-*/
-public class Extractor  {
-		int startOffset; // No initialisation needed, done in constructor
-		String searchText;
-		String start;
-		String end;
-		String tst;
-		boolean betweenonly;
-		public static boolean INCLUDESTARTEND = false;
-		public static boolean EXCLUDESTARTEND = true;
-		/**
-		*	Create an extractor.
-		*	sTxt = The string to search through.<br>
-		*	st = The string that denotes the start of the string to extract<br>
-		*	e = The string that denotes the end of the string to extract<br>
-		*	sOff = The beginning offset from which to start the search in sTxt<br>
-		*	only = if false the string returned will inlcude st and e; if true
-		*	it will not include st and e.
-		*
-		*/
-		public Extractor(String sTxt, String st, String e, int sOff, boolean only){
-			startOffset = sOff;
-			searchText = sTxt;
-			end = e;
-			start = st;
-			betweenonly = only;
-		}
-		
-		/**
-		 * Mehtod to set the source text to be searched through
-		 * 
-		 */
-		public void setSource(String sTxt){
-			searchText = sTxt;
-			startOffset = 0;
-		}
-		
-		/**
-		* Method that informs if the search has encountered the end of the string
-		* that is being searched through.
-		*/
-		public boolean endOfSearch(){
-			if(searchText == null || startOffset >= searchText.length()) return true;
-			else return false;
-		}
-		
-		/**
-		*	Method to find the next occurance of a string that is enclosed by
-		*	that start (st) and end string (e). if end is not found the string
-		*	is returned til it's end.
-		*/
-		public String findNext(){
-			if (searchText == null) return new String(); //maby null should 
-			int idxStart = searchText.indexOf(start,startOffset);
-			int idxEnd = searchText.indexOf(end, idxStart+start.length());
-			if(idxEnd == -1) idxEnd = searchText.length(); //index counts from zero length from 1 but the last char is not included in substr and substr accepts length +1 (but not length+2)
-			startOffset = idxEnd;
-			tst = new String();
-			if(idxStart > -1){
-				if(betweenonly == false){
-					if (idxEnd+end.length() >= searchText.length()) 
-						 tst = searchText.substring(idxStart);
-					else tst = searchText.substring(idxStart,idxEnd+end.length());
-				}else{ 
-					tst = searchText.substring(idxStart+start.length(),idxEnd);
+	/**
+	 * Create an extractor.
+	 * searchText = The string to search through.<br>
+	 * st = The string that denotes the start of the string to extract<br>
+	 * e = The string that denotes the end of the string to extract<br>
+	 * startOffset = The beginning offset from which to start the search in sTxt<br>
+	 * betweenonly = if false the string returned will inlcude st and e;
+	 * if true it will not include st and e.
+	 * 
+	 */
+	public Extractor(String searchText, String st, String e, int startOffset, boolean betweenonly) {
+		_startOffset = startOffset;
+		_searchText = searchText;
+		end = e;
+		start = st;
+		_betweenonly = betweenonly;
+	}
+
+	/**
+	 * Mehtod to set the source text to be searched through
+	 * 
+	 */
+	public void set(String searchText, String st, String e, int startOffset, boolean betweenonly) {
+		_startOffset = startOffset;
+		_searchText = searchText;
+		end = e;
+		start = st;
+		_betweenonly = betweenonly;
+	}
+
+	public void set(String searchText) {
+		_searchText = searchText;
+		_startOffset = 0;
+	}
+
+	public String findFirst(String searchText) {
+		_searchText = searchText;
+		_startOffset = 0;
+		return findNext();
+	}
+
+	public String findNext(String startText) {
+		start = startText;
+		return findNext();
+	}
+
+	public String findNext(String startText, String endText) {
+		start = startText;
+		end = endText;
+		return findNext();
+	}
+
+	/**
+	 * Method to find the next occurance of a string that is enclosed by
+	 * that start (st) and end string (e).
+	 * if end is not found empty string is returned.
+	 */
+	public String findNext() {
+		String ret = "";
+		if (_searchText != null && _searchText.length() > _startOffset + start.length() + end.length()) {
+			int idxStart = _searchText.indexOf(start, _startOffset);
+			int idxEnd = -1;
+			if (idxStart > -1) {
+				idxEnd = _searchText.indexOf(end, idxStart + start.length());
+				if (idxEnd > -1) {
+					_startOffset = idxEnd;
+					ret = _searchText.substring(idxStart + start.length(), idxEnd);
+					if (!this._betweenonly)
+						ret = start + ret + end;
 				}
-			} else {
-				startOffset = searchText.length();
 			}
-			return tst;
+			if (idxEnd == -1) {
+				_startOffset = _searchText.length(); // Schluss
+			}
 		}
+		return ret;
+	}
 }

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2011-05-18 07:45:09 UTC (rev 3006)
+++ trunk/src/CacheWolf/Profile.java	2011-05-18 14:06:48 UTC (rev 3007)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.Area;
@@ -44,22 +44,25 @@
 
 /**
  * This class holds a profile, i.e. a group of caches with a centre location
- *
+ * 
  * @author salzkammergut
- *
+ * 
  */
 public class Profile {
 
-	/** The list of caches (CacheHolder objects). A pointer to this object exists in many classes in parallel to
-	 *  this object, i.e. the respective class contains both a {@link Profile} object and a cacheDB Vector.
+	/**
+	 * The list of caches (CacheHolder objects). A pointer to this object exists in many classes in parallel to
+	 * this object, i.e. the respective class contains both a {@link Profile} object and a cacheDB Vector.
 	 */
-	public CacheDB cacheDB=new CacheDB();
+	public CacheDB cacheDB = new CacheDB();
 	/** The centre point of this group of caches. Read from ans stored to index.xml file */
-	public CWPoint centre=new CWPoint();
-	/** The name of the profile. The baseDir in preferences is appended this name to give the dataDir where
-	 *  the index.xml and cache files live. (Excuse the English spelling of centre)     */
-	public String name="";
-	/** This is the directory for the profile. It contains a closing /.   	 */
+	public CWPoint centre = new CWPoint();
+	/**
+	 * The name of the profile. The baseDir in preferences is appended this name to give the dataDir where
+	 * the index.xml and cache files live. (Excuse the English spelling of centre)
+	 */
+	public String name = "";
+	/** This is the directory for the profile. It contains a closing /. */
 	public String dataDir = "";
 
 	/** Last sync date for opencaching caches */
@@ -73,11 +76,11 @@
 	private String minDistGC = "";
 	/** Direction for geocaching caches */
 	private String directionGC = "";
-	
-	private String gpxStyle =new String(); 
-	private String gpxTarget =new String(); 
-	private String gpxId =new String(); 
 
+	private String gpxStyle = new String();
+	private String gpxTarget = new String();
+	private String gpxId = new String();
+
 	/** path to the maps of the profile relative to the maps root */
 	private String relativeCustomMapsPath = "";
 
@@ -91,7 +94,8 @@
 	private boolean showSearchResult = false;
 
 	public boolean selectionChanged = true; // ("H?ckchen") used by movingMap to get to knao if it should update the caches in the map
-	/** True if the profile has been modified and not saved
+	/**
+	 * True if the profile has been modified and not saved
 	 * The following modifications set this flag: New profile centre, Change of waypoint data
 	 */
 	private boolean hasUnsavedChanges = false;
@@ -100,21 +104,19 @@
 	/** version number of current format for index.xml and waypoint.xml */
 	protected static int CURRENTFILEFORMAT = 3;
 
-	//TODO Add other settings, such as max. number of logs to spider
-	//TODO Add settings for the preferred mapper to allow for maps other than expedia and other resolutions
+	// TODO Add other settings, such as max. number of logs to spider
+	// TODO Add settings for the preferred mapper to allow for maps other than expedia and other resolutions
 
 	/**
 	 * Constructor for a profile
-	 *
+	 * 
 	 */
-	public Profile(){ // public constructor
+	public Profile() { // public constructor
 	}
 
-
 	/**
-	 * Returns <code>true</code> if profile needs to be changed when profile is left. Returns
-	 * <code>false</code> if no relevant changes have been made.
-	 *
+	 * Returns <code>true</code> if profile needs to be changed when profile is left. Returns <code>false</code> if no relevant changes have been made.
+	 * 
 	 * @return hasUnsavedChanges
 	 */
 	public boolean hasUnsavedChanges() {
@@ -125,7 +127,7 @@
 	 * Remember that profile needs to be saved. Flag is set <code>true</code> when parameter is
 	 * true, but it's not set to <code>false</code> when parameter is <code>false</code>.<br>
 	 * This is only done internally on saving the cache.
-	 *
+	 * 
 	 * @param hasUnsavedChanges
 	 *            the hasUnsavedChanges to set
 	 */
@@ -161,58 +163,58 @@
 	}
 
 	/**
-	 *	Method to save the index.xml file that holds the total information
-	 *	on available caches in the database. The database is nothing else
-	 *	than the collection of caches in a directory.
-	 *
-	 *   Not sure whether we need to keep 'pref' in method signature. May eventually remove it.
-	 *
-	 *   Saves the index with the filter settings from Filter
+	 * Method to save the index.xml file that holds the total information
+	 * on available caches in the database. The database is nothing else
+	 * than the collection of caches in a directory.
+	 * 
+	 * Not sure whether we need to keep 'pref' in method signature. May eventually remove it.
+	 * 
+	 * Saves the index with the filter settings from Filter
 	 */
-//	public void saveIndex(Preferences pref, boolean showprogress){
-//		saveIndex(pref,showprogress, Filter.filterActive,Filter.filterInverted);
-//	}
+	// public void saveIndex(Preferences pref, boolean showprogress){
+	// saveIndex(pref,showprogress, Filter.filterActive,Filter.filterInverted);
+	// }
 
-
 	/** Save index with filter settings given */
 	public void saveIndex(Preferences pref, boolean showprogress) {
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
-		int updFrequ=Vm.isMobile()?10:40; // Number of caches between screen updates
-		if(showprogress){
-			pbf.showMainTask = true;//false;
-			pbf.setTask(h,"Saving Index");
+		int updFrequ = Vm.isMobile() ? 10 : 40; // Number of caches between screen updates
+		if (showprogress) {
+			pbf.showMainTask = true;// false;
+			pbf.setTask(h, "Saving Index");
 			pbf.exec();
 		}
 		CacheHolder.saveAllModifiedDetails(); // this must be called first as it makes some calculations
 		PrintWriter detfile;
 		CacheHolder ch;
 		try {
-			File backup=new File(dataDir+"index.bak");
+			File backup = new File(dataDir + "index.bak");
 			if (backup.exists()) {
 				backup.delete();
 			}
-			File index=new File(dataDir+"index.xml");
+			File index = new File(dataDir + "index.xml");
 			index.rename("index.bak");
 		} catch (Exception ex) {
 			pref.log("[Profile:saveIndex]Error deleting backup or renaming index.xml");
 		}
-		try{
+		try {
 			detfile = new PrintWriter(new BufferedWriter(new FileWriter(new FileBugfix(dataDir + "index.xml").getAbsolutePath())));
 		} catch (Exception e) {
-			pref.log("Problem creating index.xml " + dataDir,e);
+			pref.log("Problem creating index.xml " + dataDir, e);
 			return;
 		}
-		CWPoint savedCentre=centre;
-		if (centre==null || !centre.isValid() || (savedCentre.latDec==0.0 && savedCentre.lonDec==0.0)) savedCentre=pref.getCurCentrePt();
+		CWPoint savedCentre = centre;
+		if (centre == null || !centre.isValid() || (savedCentre.latDec == 0.0 && savedCentre.lonDec == 0.0))
+			savedCentre = pref.getCurCentrePt();
 
-		try{
+		try {
 			detfile.print("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
 			detfile.print("<CACHELIST format=\"decimal\">\n");
 			detfile.print("    <VERSION value = \"3\"/>\n");
 			if (savedCentre.isValid())
-				detfile.print("    <CENTRE lat=\""+savedCentre.latDec+"\" lon=\""+savedCentre.lonDec+"\"/>\n");
-			if(getLast_sync_opencaching() == null || getLast_sync_opencaching().endsWith("null") || getLast_sync_opencaching().equals("")){
+				detfile.print("    <CENTRE lat=\"" + savedCentre.latDec + "\" lon=\"" + savedCentre.lonDec + "\"/>\n");
+			if (getLast_sync_opencaching() == null || getLast_sync_opencaching().endsWith("null") || getLast_sync_opencaching().equals("")) {
 				setLast_sync_opencaching("20050801000000");
 			}
 			if (getDistOC() == null || getDistOC().endsWith("null") || getDistOC().equals("")) {
@@ -232,15 +234,14 @@
 			// normal filter, because after loading there is no cache tour defined
 			// which could be used as filter criterium.
 			int activeFilterForSave;
-			if (getFilterActive()==Filter.FILTER_CACHELIST) {
+			if (getFilterActive() == Filter.FILTER_CACHELIST) {
 				activeFilterForSave = Filter.FILTER_ACTIVE;
 			} else {
 				activeFilterForSave = getFilterActive();
 			}
-			detfile.print("    <FILTERCONFIG status = \""+activeFilterForSave+
-					(isFilterInverted()?"T":"F")+"\" showBlacklist = \""+showBlacklisted()+"\" />\n");
+			detfile.print("    <FILTERCONFIG status = \"" + activeFilterForSave + (isFilterInverted() ? "T" : "F") + "\" showBlacklist = \"" + showBlacklisted() + "\" />\n");
 			detfile.print(this.getCurrentFilter().toXML(""));
-			detfile.print("    <SYNCOC date = \""+getLast_sync_opencaching()+"\" dist = \""+getDistOC()+"\"/>\n");
+			detfile.print("    <SYNCOC date = \"" + getLast_sync_opencaching() + "\" dist = \"" + getDistOC() + "\"/>\n");
 			detfile.print("    <SPIDERGC dist = \"" + getDistGC() + "\" mindist = \"" + getMinDistGC() + "\" direction = \"" + getDirectionGC() + "\"/>\n");
 			detfile.print("    <EXPORT style = \"" + getGpxStyle() + "\" target = \"" + getGpxTarget() + "\" id = \"" + getGpxId() + "\"/>\n");
 			detfile.print("    <mapspath relativeDir = \"" + SafeXML.clean(relativeCustomMapsPath) + "\"/>\n");
@@ -248,7 +249,8 @@
 			for (int i = 0; i < size; i++) {
 				if (showprogress) {
 					h.progress = (float) i / (float) size;
-					if ((i%updFrequ)==0) h.changed();
+					if ((i % updFrequ) == 0)
+						h.changed();
 				}
 				ch = cacheDB.get(i);
 				if (ch.getWayPoint().length() > 0) {
@@ -257,12 +259,14 @@
 			}
 			detfile.print("</CACHELIST>\n");
 			detfile.close();
-			buildReferences(); //TODO Why is this needed here?
-			if(showprogress) pbf.exit(0);
-		}catch(Exception e){
-			pref.log("Problem writing to index file ",e);
+			buildReferences(); // TODO Why is this needed here?
+			if (showprogress)
+				pbf.exit(0);
+		} catch (Exception e) {
+			pref.log("Problem writing to index file ", e);
 			detfile.close();
-			if(showprogress) pbf.exit(0);
+			if (showprogress)
+				pbf.exit(0);
 		}
 		resetUnsavedChanges();
 	}
@@ -270,19 +274,20 @@
 	public void readIndex() {
 		readIndex(null);
 	}
+
 	/**
-	 *	Method to read the index.xml file that holds the total information
-	 *	on available caches in the database. The database in nothing else
-	 *	than the collection of caches in a directory.
+	 * Method to read the index.xml file that holds the total information
+	 * on available caches in the database. The database in nothing else
+	 * than the collection of caches in a directory.
 	 */
 	public void readIndex(InfoBox infoBox) {
-		int updFrequ=Vm.isMobile()?10:40; // Number of caches between screen updates
+		int updFrequ = Vm.isMobile() ? 10 : 40; // Number of caches between screen updates
 		try {
 			selectionChanged = true;
 			boolean fmtDec = false;
-			String mainInfoText = MyLocale.getMsg(5000,"Loading Cache-List");
-			int wptNo=1;
-			int lastShownWpt=0;
+			String mainInfoText = MyLocale.getMsg(5000, "Loading Cache-List");
+			int wptNo = 1;
+			int lastShownWpt = 0;
 			char decSep = MyLocale.getDigSeparator().charAt(0);
 			char notDecSep = decSep == '.' ? ',' : '.';
 			FileBugfix indexFile = new FileBugfix(dataDir + "index.xml");
@@ -290,92 +295,106 @@
 			indexXmlVersion = 1; // Initial guess
 			in.readLine(); // <?xml version= ...
 			String text = in.readLine(); // <CACHELIST>
-			if (text!=null && text.indexOf("decimal")>0) fmtDec=true;
+			if (text != null && text.indexOf("decimal") > 0)
+				fmtDec = true;
 			Extractor ex = new Extractor(null, " = \"", "\" ", 0, true);
 
-			//ewe.sys.Time startT=new ewe.sys.Time();
+			// ewe.sys.Time startT=new ewe.sys.Time();
 			boolean convertWarningDisplayed = false;
-			while ((text = in.readLine()) != null){
+			while ((text = in.readLine()) != null) {
 				// Check for Line with cache data
-				if (text.indexOf("<CACHE ")>=0){
+				if (text.indexOf("<CACHE ") >= 0) {
 					if (indexXmlVersion < CURRENTFILEFORMAT && !convertWarningDisplayed) {
 						if (indexXmlVersion < CURRENTFILEFORMAT) {
 							convertWarningDisplayed = true;
-							int res=new MessageBox(MyLocale.getMsg(144, "Warning"), MyLocale.getMsg(4407, "The profile files are not in the current format.%0aTherefore they are now converted to the current format. Depending of the size of the profile and the computer involved this may take some minutes. Please bear with us until the conversion is done."), FormBase.YESB|FormBase.NOB).execute();
+							int res = new MessageBox(
+									MyLocale.getMsg(144, "Warning"),
+									MyLocale.getMsg(4407,
+											"The profile files are not in the current format.%0aTherefore they are now converted to the current format. Depending of the size of the profile and the computer involved this may take some minutes. Please bear with us until the conversion is done."),
+									FormBase.YESB | FormBase.NOB).execute();
 							if (res == MessageBox.NOB) {
 								ewe.sys.Vm.exit(0);
 							}
 						}
 					}
-					if (infoBox!=null) {
+					if (infoBox != null) {
 						if (wptNo - updFrequ >= lastShownWpt) {
-							infoBox.setInfo(mainInfoText+"\n"+String.valueOf(wptNo));
+							infoBox.setInfo(mainInfoText + "\n" + String.valueOf(wptNo));
 							lastShownWpt = wptNo;
 						}
 						wptNo++;
 					}
-					CacheHolder ch=new CacheHolder(text,indexXmlVersion);
+					CacheHolder ch = new CacheHolder(text, indexXmlVersion);
 					cacheDB.add(ch);
-				} else if (text.indexOf("<CENTRE")>=0) { // lat=  lon=
+				} else if (text.indexOf("<CENTRE") >= 0) { // lat= lon=
 					if (fmtDec) {
-						int start=text.indexOf("lat=\"")+5;
-						String lat=text.substring(start,text.indexOf("\"",start)).replace(notDecSep,decSep);
-						start=text.indexOf("lon=\"")+5;
-						String lon=text.substring(start,text.indexOf("\"",start)).replace(notDecSep,decSep);
-						centre.set(Convert.parseDouble(lat),Convert.parseDouble(lon));
+						int start = text.indexOf("lat=\"") + 5;
+						String lat = text.substring(start, text.indexOf("\"", start)).replace(notDecSep, decSep);
+						start = text.indexOf("lon=\"") + 5;
+						String lon = text.substring(start, text.indexOf("\"", start)).replace(notDecSep, decSep);
+						centre.set(Convert.parseDouble(lat), Convert.parseDouble(lon));
 					} else {
-						int start=text.indexOf("lat=\"")+5;
-						String lat=SafeXML.cleanback(text.substring(start,text.indexOf("\"",start)));
-						start=text.indexOf("long=\"")+6;
-						String lon=SafeXML.cleanback(text.substring(start,text.indexOf("\"",start)));
-						centre.set(lat+" "+lon,TransformCoordinates.CW); // Fast parse
+						int start = text.indexOf("lat=\"") + 5;
+						String lat = SafeXML.cleanback(text.substring(start, text.indexOf("\"", start)));
+						start = text.indexOf("long=\"") + 6;
+						String lon = SafeXML.cleanback(text.substring(start, text.indexOf("\"", start)));
+						centre.set(lat + " " + lon, TransformCoordinates.CW); // Fast parse
 					}
-				} else if (text.indexOf("<VERSION")>=0) {
-					int start=text.indexOf("value = \"")+9;
-					indexXmlVersion  = Integer.valueOf(text.substring(start,text.indexOf("\"",start))).intValue();
+				} else if (text.indexOf("<VERSION") >= 0) {
+					int start = text.indexOf("value = \"") + 9;
+					indexXmlVersion = Integer.valueOf(text.substring(start, text.indexOf("\"", start))).intValue();
 					if (indexXmlVersion > CURRENTFILEFORMAT) {
 						Global.getPref().log("[Profile:readIndex]unsupported file format");
 						clearProfile();
 						return;
 					}
-				} else if (text.indexOf("<SYNCOC")>=0) {
-					int start=text.indexOf("date = \"")+8;
-					setLast_sync_opencaching(text.substring(start,text.indexOf("\"",start)));
-					start=text.indexOf("dist = \"")+8;
-					setDistOC(text.substring(start,text.indexOf("\"",start)));
-				} else if (text.indexOf("mapspath")>=0) {
-					int start=text.indexOf("relativeDir = \"")+15;
-					setRelativeCustomMapsPath(SafeXML.cleanback(text.substring(start,text.indexOf("\"",start))).replace('\\','/'));
-				} else if (text.indexOf("<SPIDERGC")>=0) {
-					int start=text.indexOf("dist = \"")+8;
-					setDistGC(text.substring(start,text.indexOf("\"",start)));
-					start=text.indexOf("mindist = \"")+11;
-					if (start==10) {setMinDistGC("0");}
-					else setMinDistGC(text.substring(start,text.indexOf("\"",start)));
-					start=text.indexOf("direction = \"")+13;
-					if (start==12) {setDirectionGC("");}
-					else setDirectionGC(text.substring(start,text.indexOf("\"",start)));
-				} else if (text.indexOf("<EXPORT")>=0) {
-					int start=text.indexOf("style = \"")+9;
-					if (start==8) {setGpxStyle("0");}
-					else setGpxStyle(text.substring(start,text.indexOf("\"",start)));
-					start=text.indexOf("target = \"")+10;
-					if (start==9) {setGpxTarget("0");}
-					else setGpxTarget(text.substring(start,text.indexOf("\"",start)));
-					start=text.indexOf("id = \"")+6;
-					if (start==5) {setGpxId("0");}
-					else setGpxId(text.substring(start,text.indexOf("\"",start)));
-				} else if (indexXmlVersion <=2 && text.indexOf("<FILTER")>=0){
+				} else if (text.indexOf("<SYNCOC") >= 0) {
+					int start = text.indexOf("date = \"") + 8;
+					setLast_sync_opencaching(text.substring(start, text.indexOf("\"", start)));
+					start = text.indexOf("dist = \"") + 8;
+					setDistOC(text.substring(start, text.indexOf("\"", start)));
+				} else if (text.indexOf("mapspath") >= 0) {
+					int start = text.indexOf("relativeDir = \"") + 15;
+					setRelativeCustomMapsPath(SafeXML.cleanback(text.substring(start, text.indexOf("\"", start))).replace('\\', '/'));
+				} else if (text.indexOf("<SPIDERGC") >= 0) {
+					int start = text.indexOf("dist = \"") + 8;
+					setDistGC(text.substring(start, text.indexOf("\"", start)));
+					start = text.indexOf("mindist = \"") + 11;
+					if (start == 10) {
+						setMinDistGC("0");
+					} else
+						setMinDistGC(text.substring(start, text.indexOf("\"", start)));
+					start = text.indexOf("direction = \"") + 13;
+					if (start == 12) {
+						setDirectionGC("");
+					} else
+						setDirectionGC(text.substring(start, text.indexOf("\"", start)));
+				} else if (text.indexOf("<EXPORT") >= 0) {
+					int start = text.indexOf("style = \"") + 9;
+					if (start == 8) {
+						setGpxStyle("0");
+					} else
+						setGpxStyle(text.substring(start, text.indexOf("\"", start)));
+					start = text.indexOf("target = \"") + 10;
+					if (start == 9) {
+						setGpxTarget("0");
+					} else
+						setGpxTarget(text.substring(start, text.indexOf("\"", start)));
+					start = text.indexOf("id = \"") + 6;
+					if (start == 5) {
+						setGpxId("0");
+					} else
+						setGpxId(text.substring(start, text.indexOf("\"", start)));
+				} else if (indexXmlVersion <= 2 && text.indexOf("<FILTER") >= 0) {
 					// Read filter data of file versions 1 and 2. (Legacy code)
-					ex.setSource(text.substring(text.indexOf("<FILTER")));
-					String temp=ex.findNext(); // Filter status is now first, need to deal with old versions which don't have filter status
-					if (temp.length()==2) {
+					String temp = ex.findFirst(text.substring(text.indexOf("<FILTER"))); // Filter status is now first, need to deal with old versions which don't have filter status
+					if (temp.length() == 2) {
 						// Compatibility with previous versions
-						if (temp.charAt(0)=='T')
+						if (temp.charAt(0) == 'T')
 							setFilterActive(Filter.FILTER_ACTIVE);
 						else
-							setFilterActive(Common.parseInt(temp.substring(0,1)));
-						setFilterInverted(temp.charAt(1)=='T');
+							setFilterActive(Common.parseInt(temp.substring(0, 1)));
+						setFilterInverted(temp.charAt(1) == 'T');
 						setFilterRose(ex.findNext());
 					} else
 						setFilterRose(temp);
@@ -386,20 +405,19 @@
 					setFilterTerr(ex.findNext());
 					setFilterSize(ex.findNext());
 					String attr = ex.findNext();
-					long[] filterAttr = { 0l,0l,0l,0l };					
+					long[] filterAttr = { 0l, 0l, 0l, 0l };
 					if (attr != null && !attr.equals(""))
 						filterAttr[0] = Convert.parseLong(attr);
 					attr = ex.findNext();
 					if (attr != null && !attr.equals(""))
 						filterAttr[2] = Convert.parseLong(attr);
 					attr = ex.findNext();
-					setFilterAttr(filterAttr);					
+					setFilterAttr(filterAttr);
 					if (attr != null && !attr.equals(""))
 						setFilterAttrChoice(Convert.parseInt(attr));
 					setShowBlacklisted(Boolean.valueOf(ex.findNext()).booleanValue());
-				} else if (text.indexOf("<FILTERDATA")>=0){
-					ex.setSource(text.substring(text.indexOf("<FILTERDATA")));
-					setFilterRose(ex.findNext());
+				} else if (text.indexOf("<FILTERDATA") >= 0) {
+					setFilterRose(ex.findFirst(text.substring(text.indexOf("<FILTERDATA"))));
 					setFilterType(ex.findNext());
 					setFilterVar(ex.findNext());
 					setFilterDist(ex.findNext());
@@ -407,7 +425,7 @@
 					setFilterTerr(ex.findNext());
 					setFilterSize(ex.findNext());
 					String attr = ex.findNext();
-					long[] filterAttr = { 0l,0l,0l,0l };					
+					long[] filterAttr = { 0l, 0l, 0l, 0l };
 					if (attr != null && !attr.equals(""))
 						filterAttr[0] = Convert.parseLong(attr);
 					attr = ex.findNext();
@@ -418,69 +436,68 @@
 					setFilterAttrChoice(Convert.parseInt(attr));
 					setFilterStatus(SafeXML.cleanback(ex.findNext()));
 					setFilterUseRegexp(Boolean.valueOf(ex.findNext()).booleanValue());
-					attr = ex.findNext();					
-	  				if (attr != null && !attr.equals("")) {
-	  					setFilterNoCoord(Boolean.valueOf(attr).booleanValue());
+					attr = ex.findNext();
+					if (attr != null && !attr.equals("")) {
+						setFilterNoCoord(Boolean.valueOf(attr).booleanValue());
 
-	  				}
-	  				else {
-	  					setFilterNoCoord(true);
-	  				}
-	  				attr = ex.findNext();					
-	  				if (attr != null && !attr.equals(""))
-	  					filterAttr[1] = Convert.parseLong(attr);
-	  				attr = ex.findNext();
-	  				if (attr != null && !attr.equals(""))
-	  					filterAttr[3] = Convert.parseLong(attr);
-	  				setFilterAttr(filterAttr);
-				} else if (text.indexOf("<FILTERCONFIG")>=0){
-					ex.setSource(text.substring(text.indexOf("<FILTERCONFIG")));
-					String temp=ex.findNext();
-					setFilterActive(Common.parseInt(temp.substring(0,1)));
-					setFilterInverted(temp.charAt(1)=='T');
+					} else {
+						setFilterNoCoord(true);
+					}
+					attr = ex.findNext();
+					if (attr != null && !attr.equals(""))
+						filterAttr[1] = Convert.parseLong(attr);
+					attr = ex.findNext();
+					if (attr != null && !attr.equals(""))
+						filterAttr[3] = Convert.parseLong(attr);
+					setFilterAttr(filterAttr);
+				} else if (text.indexOf("<FILTERCONFIG") >= 0) {
+					String temp = ex.findFirst(text.substring(text.indexOf("<FILTERCONFIG")));
+					setFilterActive(Common.parseInt(temp.substring(0, 1)));
+					setFilterInverted(temp.charAt(1) == 'T');
 					setShowBlacklisted(Boolean.valueOf(ex.findNext()).booleanValue());
 				}
 			}
 			in.close();
 			// Build references between caches and addi wpts
-			if (infoBox!=null) {
-				infoBox.setInfo(MyLocale.getMsg(5004,"Building references..."));
+			if (infoBox != null) {
+				infoBox.setInfo(MyLocale.getMsg(5004, "Building references..."));
 			}
 			buildReferences();
 			if (indexXmlVersion < CURRENTFILEFORMAT) {
 				saveIndex(Global.getPref(), true);
 			}
 		} catch (FileNotFoundException e) {
-			Global.getPref().log("index.xml not found in directory "+dataDir,e);
-		} catch (IOException e){
-			Global.getPref().log("Problem reading index.xml in dir: "+dataDir,e,true);
+			Global.getPref().log("index.xml not found in directory " + dataDir, e);
+		} catch (IOException e) {
+			Global.getPref().log("Problem reading index.xml in dir: " + dataDir, e, true);
 		}
 		this.getCurrentFilter().normaliseFilters();
 		resetUnsavedChanges();
 	}
 
-	/** Restore the filter to the values stored in this profile
-	 *  Called from Main Form and MainMenu
-	 *  The values of Filter.isActive and Filter.isInactive are set by the filter
+	/**
+	 * Restore the filter to the values stored in this profile
+	 * Called from Main Form and MainMenu
+	 * The values of Filter.isActive and Filter.isInactive are set by the filter
 	 **/
 	public void restoreFilter() {
-		restoreFilter( true );
+		restoreFilter(true);
 	}
 
 	void restoreFilter(boolean clearIfInactive) {
-		boolean inverted=isFilterInverted(); // Save it as doFilter will clear filterInverted
-		Filter flt=new Filter();
-		if (getFilterActive()==Filter.FILTER_ACTIVE) {
+		boolean inverted = isFilterInverted(); // Save it as doFilter will clear filterInverted
+		Filter flt = new Filter();
+		if (getFilterActive() == Filter.FILTER_ACTIVE) {
 			flt.setFilter();
 			flt.doFilter();
 			if (inverted) {
 				flt.invertFilter();
 				setFilterInverted(true); // Needed because previous line inverts filterInverted
 			}
-		} else if (getFilterActive()==Filter.FILTER_CACHELIST) {
+		} else if (getFilterActive() == Filter.FILTER_CACHELIST) {
 			Global.mainForm.cacheList.applyCacheList();
-			//flt.filterActive=filterActive;
-		} else if (getFilterActive()==Filter.FILTER_INACTIVE) {
+			// flt.filterActive=filterActive;
+		} else if (getFilterActive() == Filter.FILTER_INACTIVE) {
 			if (clearIfInactive) {
 				flt.clearFilter();
 			}
@@ -507,8 +524,9 @@
 	}
 
 	/**
-	 *
-	 * @param forcache maincache
+	 * 
+	 * @param forcache
+	 *            maincache
 	 * @return
 	 */
 	public String getNewAddiWayPointName(String forcache) {
@@ -522,7 +540,7 @@
 
 	/**
 	 * Call this after getNewAddiWayPointName to set the references between main and addi correctly
-	 *
+	 * 
 	 * @param ch
 	 */
 	public void setAddiRef(CacheHolder ch) {
@@ -530,15 +548,15 @@
 		int mainindex = getCacheIndex("GC" + mainwpt);
 		if (mainindex < 0 || !cacheDB.get(mainindex).isCacheWpt()) {
 			for (int i = 0; i < OC.OCSites.length; i++) {
-				mainindex=getCacheIndex(OC.OCSites[i][OC.OC_PREFIX] + mainwpt);
-				if (mainindex >= 0 && cacheDB.get(mainindex).isCacheWpt()){
+				mainindex = getCacheIndex(OC.OCSites[i][OC.OC_PREFIX] + mainwpt);
+				if (mainindex >= 0 && cacheDB.get(mainindex).isCacheWpt()) {
 					break;
 				}
 			}
 		}
 		if (mainindex < 0 || !cacheDB.get(mainindex).isCacheWpt())
 			mainindex = getCacheIndex("CW" + mainwpt);
-		if (mainindex < 0 /* || !cacheDB.get(mainindex)..isCacheWpt() */ )  {
+		if (mainindex < 0 /* || !cacheDB.get(mainindex)..isCacheWpt() */) {
 			ch.setIncomplete(true);
 		} else {
 			CacheHolder mainch = cacheDB.get(mainindex);
@@ -553,8 +571,7 @@
 	}
 
 	public String toString() {
-		return "Profile: Name="+name+"\nCentre="+centre.toString()+"\ndataDir="+dataDir+"\nlastSyncOC="+
-		getLast_sync_opencaching()+"\ndistOC="+getDistOC()+"\ndistGC="+getDistGC();
+		return "Profile: Name=" + name + "\nCentre=" + centre.toString() + "\ndataDir=" + dataDir + "\nlastSyncOC=" + getLast_sync_opencaching() + "\ndistOC=" + getDistOC() + "\ndistGC=" + getDistGC();
 	}
 
 	public void setSelectForAll(boolean selectStatus) {
@@ -570,7 +587,8 @@
 	public int numCachesInArea; // only valid after calling getSourroundingArea
 
 	public Area getSourroundingArea(boolean onlyOfSelected) {
-		if (cacheDB == null || cacheDB.size() == 0) return null;
+		if (cacheDB == null || cacheDB.size() == 0)
+			return null;
 		CacheHolder ch;
 		CWPoint topleft = null;
 		CWPoint bottomright = null;
@@ -584,15 +602,22 @@
 					tmpca.set(ch.getLatLon());
 					ch.pos = new CWPoint(tmpca);
 				}
-				if (ch.pos.isValid() ){ // done: && ch.pos.latDec != 0 && ch.pos.lonDec != 0 TO-DO != 0 sollte rausgenommen werden sobald in der Liste vern?nftig mit nicht gesetzten pos umgegangen wird
+				if (ch.pos.isValid()) { // done: && ch.pos.latDec != 0 && ch.pos.lonDec != 0 TO-DO != 0 sollte rausgenommen werden sobald in der Liste vern?nftig mit nicht gesetzten pos umgegangen wird
 					isAddi = ch.isAddiWpt();
-				if (!isAddi || (isAddi && ch.mainCache != null && ch.pos.getDistance(ch.mainCache.pos) < 1000)) { // test for plausiblity of coordinates of Additional Waypoints: more then 1000 km away from main Waypoint is unplausible -> ignore it // && ch.mainCache != null is only necessary because the data base may be corrupted
-						if (topleft == null) topleft = new CWPoint(ch.pos);
-						if (bottomright == null) bottomright = new CWPoint(ch.pos);
-						if (topleft.latDec < ch.pos.latDec) topleft.latDec = ch.pos.latDec;
-						if (topleft.lonDec > ch.pos.lonDec) topleft.lonDec = ch.pos.lonDec;
-						if (bottomright.latDec > ch.pos.latDec) bottomright.latDec = ch.pos.latDec;
-						if (bottomright.lonDec < ch.pos.lonDec) bottomright.lonDec = ch.pos.lonDec;
+					if (!isAddi || (isAddi && ch.mainCache != null && ch.pos.getDistance(ch.mainCache.pos) < 1000)) { // test for plausiblity of coordinates of Additional Waypoints: more then 1000 km away from main Waypoint is unplausible -> ignore it //
+																														// && ch.mainCache != null is only necessary because the data base may be corrupted
+						if (topleft == null)
+							topleft = new CWPoint(ch.pos);
+						if (bottomright == null)
+							bottomright = new CWPoint(ch.pos);
+						if (topleft.latDec < ch.pos.latDec)
+							topleft.latDec = ch.pos.latDec;
+						if (topleft.lonDec > ch.pos.lonDec)
+							topleft.lonDec = ch.pos.lonDec;
+						if (bottomright.latDec > ch.pos.latDec)
+							bottomright.latDec = ch.pos.latDec;
+						if (bottomright.lonDec < ch.pos.lonDec)
+							bottomright.lonDec = ch.pos.lonDec;
 						numCachesInArea++;
 					}
 				}
@@ -600,35 +625,38 @@
 		}
 		if (topleft != null && bottomright != null)
 			return new Area(topleft, bottomright);
-		else return null;
+		else
+			return null;
 	}
 
 	/**
-	 *	Method to calculate bearing and distance of a cache in the index
-	 *	list.
-	 *	@see	CacheHolder
-	 *	@see	Extractor
+	 * Method to calculate bearing and distance of a cache in the index
+	 * list.
+	 * 
+	 * @see CacheHolder
+	 * @see Extractor
 	 */
-	public void updateBearingDistance(){
+	public void updateBearingDistance() {
 		CWPoint centerPoint = new CWPoint(Global.getPref().getCurCentrePt()); // Clone current centre to be sure
 		int anz = cacheDB.size();
 		CacheHolder ch;
 		// Jetzt durch die CacheDaten schleifen
-		while(--anz >= 0){
+		while (--anz >= 0) {
 			ch = cacheDB.get(anz); // This returns a pointer to the CacheHolder object
 			ch.calcDistance(centerPoint);
 		}
 		// The following call is not very clean as it mixes UI with base classes
 		// However, calling it from here allows us to recenter the
 		// radar panel with only one call
-		if (Global.mainTab!=null) Global.mainTab.radarP.recenterRadar();
-	} //updateBearingDistance
+		if (Global.mainTab != null)
+			Global.mainTab.radarP.recenterRadar();
+	} // updateBearingDistance
 
 	/**
 	 * Method to build the reference between addi wpt
 	 * and main cache.
 	 */
-	public void buildReferences(){
+	public void buildReferences() {
 		CacheHolder ch;
 		MyComparer myComparer = new MyComparer();
 
@@ -752,6 +780,7 @@
 	/**
 	 * If <code>true</code> then the cache list will only display the
 	 * caches that are result of a search.
+	 * 
 	 * @return <code>True</code> if list should only display search results
 	 */
 	public boolean showSearchResult() {
@@ -761,10 +790,12 @@
 	/**
 	 * Sets parameter if cache list should only display the caches that are
 	 * results of a search.
-	 * @param showSearchResult <code>True</code>: List should only display search
-	 * results.
+	 * 
+	 * @param showSearchResult
+	 *            <code>True</code>: List should only display search
+	 *            results.
 	 */
-	public void setShowSearchResult(boolean showSearchResult){
+	public void setShowSearchResult(boolean showSearchResult) {
 		this.showSearchResult = showSearchResult;
 	}
 
@@ -787,31 +818,31 @@
 	}
 
 	public String getFilterStatus() {
-    	return currentFilter.getFilterStatus();
-    }
+		return currentFilter.getFilterStatus();
+	}
 
 	public void setFilterStatus(String filterStatus) {
 		this.notifyUnsavedChanges(filterStatus != this.getFilterStatus());
-    	this.currentFilter.setFilterStatus(filterStatus);
-    }
+		this.currentFilter.setFilterStatus(filterStatus);
+	}
 
 	public boolean getFilterUseRegexp() {
-    	return currentFilter.useRegexp();
-    }
+		return currentFilter.useRegexp();
+	}
 
 	public void setFilterUseRegexp(boolean useRegexp) {
 		this.notifyUnsavedChanges(useRegexp != this.getFilterUseRegexp());
-    	this.currentFilter.setUseRegexp(useRegexp);
-    }
+		this.currentFilter.setUseRegexp(useRegexp);
+	}
 
 	public boolean getFilterNoCoord() {
-    	return currentFilter.getFilterNoCoord();
-    }
+		return currentFilter.getFilterNoCoord();
+	}
 
 	public void setFilterNoCoord(boolean filterNoCoord) {
 		this.notifyUnsavedChanges(filterNoCoord != this.getFilterNoCoord());
-    	this.currentFilter.setFilterNoCoord(filterNoCoord);
-    }
+		this.currentFilter.setFilterNoCoord(filterNoCoord);
+	}
 
 	public String getLast_sync_opencaching() {
 		return last_sync_opencaching;
@@ -854,7 +885,8 @@
 	public int getGpxId() {
 		return Convert.toInt(gpxId);
 	}
-//
+
+	//
 	public void setMinDistGC(String minDistGC) {
 		this.notifyUnsavedChanges(!minDistGC.equals(this.minDistGC));
 		this.minDistGC = minDistGC;
@@ -893,23 +925,24 @@
 		this.notifyUnsavedChanges(!rCMPath.equals(this.relativeCustomMapsPath));
 		this.relativeCustomMapsPath = rCMPath;
 	}
+
 	/**
 	 * Returns the currently active FilterData object for the profile.
+	 * 
 	 * @return Object representing the setting of the filter
 	 */
 	public FilterData getCurrentFilter() {
-    	return currentFilter;
-    }
+		return currentFilter;
+	}
 
 	public void setCurrentFilter(FilterData currentFilter) {
-    	this.currentFilter = currentFilter;
-    }
+		this.currentFilter = currentFilter;
+	}
 
 	private class MyComparer implements ewe.util.Comparer {
 
 		public int compare(Object o1, Object o2) {
-			return ((CacheHolder) o1).getWayPoint().compareTo(
-			        ((CacheHolder) o2).getWayPoint());
+			return ((CacheHolder) o1).getWayPoint().compareTo(((CacheHolder) o2).getWayPoint());
 		}
 
 	}

Modified: trunk/src/CacheWolf/SafeXML.java
===================================================================
--- trunk/src/CacheWolf/SafeXML.java	2011-05-18 07:45:09 UTC (rev 3006)
+++ trunk/src/CacheWolf/SafeXML.java	2011-05-18 14:06:48 UTC (rev 3007)
@@ -1,155 +1,59 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 /**
-*	A class to replace unsafe XML characters with characters that a user
-*	"can read", and vice versa
-* 20061222: skg Modified cleanback to speed up the new index.xml reader
-*/
+ *	A class to replace unsafe XML characters with characters that a user
+ *	"can read", and vice versa
+ * 20061222: skg Modified cleanback to speed up the new index.xml reader
+ */
 
 import ewe.util.Hashtable;
 
-public final class SafeXML{
+public final class SafeXML {
 	private static final char ENTITY_START = '&';
 	private static final char ENTITY_END = ';';
-	
+
 	private final static Hashtable iso2htmlMappings = new Hashtable(300);
 	static {
 		final String[] mappingArray = new String[] {
-				"&apos;",   "'",		// Added 20061227 - not a valid HTML entity but used in XML
-				"&quot;",   "\"",
-				"&amp;",    "&",
-				"&lt;",     "<",
-				"&gt;",     ">",
-				"&nbsp;",   " ",
-				"&iexcl;",  "?",
-				"&cent;",   "?",
-				"&pound;",  "?",
-				"&curren;", "?",
-				"&yen;",    "?",
-				"&brvbar;", "?",
-				"&sect;",   "?",
-				"&uml;",    "?",
-				"&copy;",   "?",
-				"&ordf;",   "?",
-				"&laquo;",  "?",
-				"&not;",    "?",
-				"&shy;",    "?",
-				"&reg;",    "?",
-				"&macr;",   "?",
-				"&deg;",    "?",
-				"&plusmn;", "?",
-				"&sup2;",   "?",
-				"&sup3;",   "?",
-				"&acute;",  "?",
-				"&micro;",  "?",
-				"&para;",   "?",
-				"&middot;", "?",
-				"&cedil;",  "?",
-				"&sup1;",   "?",
-				"&ordm;",   "?",
-				"&raquo;",  "?",
-				"&frac14;", "?",
-				"&frac12;", "?",
-				"&frac34;", "?",
-				"&iquest;", "?",
-				"&Agrave;", "?",
-				"&Aacute;", "?",
-				"&Acirc;",  "?",
-				"&Atilde;", "?",
-				"&Auml;",   "?",
-				"&Aring;",  "?",
-				"&AElig;",  "?",
-				"&Ccedil;", "?",
-				"&Egrave;", "?",
-				"&Eacute;", "?",
-				"&Ecirc;",  "?",
-				"&Euml;",   "?",
-				"&Igrave;", "?",
-				"&Iacute;", "?",
-				"&Icirc;",  "?",
-				"&Iuml;",   "?",
-				"&ETH;",    "?",
-				"&Ntilde;", "?",
-				"&Ograve;", "?",
-				"&Oacute;", "?",
-				"&Ocirc;",  "?",
-				"&Otilde;", "?",
-				"&Ouml;",   "?",
-				"&times;",  "?",
-				"&Oslash;", "?",
-				"&Ugrave;", "?",
-				"&Uacute;", "?",
-				"&Ucirc;",  "?",
-				"&Uuml;",   "?",
-				"&Yacute;", "?",
-				"&THORN;",  "?",
-				"&szlig;",  "?",
-				"&agrave;", "?",
-				"&aacute;", "?",
-				"&acirc;",  "?",
-				"&atilde;", "?",
-				"&auml;",   "?",
-				"&aring;",  "?",
-				"&aelig;",  "?",
-				"&ccedil;", "?",
-				"&egrave;", "?",
-				"&eacute;", "?",
-				"&ecirc;",  "?",
-				"&euml;",   "?",
-				"&igrave;", "?",
-				"&iacute;", "?",
-				"&icirc;",  "?",
-				"&iuml;",   "?",
-				"&eth;",    "?",
-				"&ntilde;", "?",
-				"&ograve;", "?",
-				"&oacute;", "?",
-				"&ocirc;",  "?",
-				"&otilde;", "?",
-				"&ouml;",   "?",
-				"&divide;", "?",
-				"&oslash;", "?",
-				"&ugrave;", "?",
-				"&uacute;", "?",
-				"&ucirc;",  "?",
-				"&uuml;",   "?",
-				"&yacute;", "?",
-				"&thorn;",  "?",
-				"&yuml;",   "?",
-				"&ndash;",  "?"
-				};
+				"&apos;",
+				"'", // Added 20061227 - not a valid HTML entity but used in XML
+				"&quot;", "\"", "&amp;", "&", "&lt;", "<", "&gt;", ">", "&nbsp;", " ", "&iexcl;", "?", "&cent;", "?", "&pound;", "?", "&curren;", "?", "&yen;", "?", "&brvbar;", "?", "&sect;", "?", "&uml;", "?", "&copy;", "?", "&ordf;", "?", "&laquo;",
+				"?", "&not;", "?", "&shy;", "?", "&reg;", "?", "&macr;", "?", "&deg;", "?", "&plusmn;", "?", "&sup2;", "?", "&sup3;", "?", "&acute;", "?", "&micro;", "?", "&para;", "?", "&middot;", "?", "&cedil;", "?", "&sup1;", "?", "&ordm;", "?",
+				"&raquo;", "?", "&frac14;", "?", "&frac12;", "?", "&frac34;", "?", "&iquest;", "?", "&Agrave;", "?", "&Aacute;", "?", "&Acirc;", "?", "&Atilde;", "?", "&Auml;", "?", "&Aring;", "?", "&AElig;", "?", "&Ccedil;", "?", "&Egrave;", "?",
+				"&Eacute;", "?", "&Ecirc;", "?", "&Euml;", "?", "&Igrave;", "?", "&Iacute;", "?", "&Icirc;", "?", "&Iuml;", "?", "&ETH;", "?", "&Ntilde;", "?", "&Ograve;", "?", "&Oacute;", "?", "&Ocirc;", "?", "&Otilde;", "?", "&Ouml;", "?", "&times;",
+				"?", "&Oslash;", "?", "&Ugrave;", "?", "&Uacute;", "?", "&Ucirc;", "?", "&Uuml;", "?", "&Yacute;", "?", "&THORN;", "?", "&szlig;", "?", "&agrave;", "?", "&aacute;", "?", "&acirc;", "?", "&atilde;", "?", "&auml;", "?", "&aring;", "?",
+				"&aelig;", "?", "&ccedil;", "?", "&egrave;", "?", "&eacute;", "?", "&ecirc;", "?", "&euml;", "?", "&igrave;", "?", "&iacute;", "?", "&icirc;", "?", "&iuml;", "?", "&eth;", "?", "&ntilde;", "?", "&ograve;", "?", "&oacute;", "?",
+				"&ocirc;", "?", "&otilde;", "?", "&ouml;", "?", "&divide;", "?", "&oslash;", "?", "&ugrave;", "?", "&uacute;", "?", "&ucirc;", "?", "&uuml;", "?", "&yacute;", "?", "&thorn;", "?", "&yuml;", "?", "&ndash;", "?" };
 		for (int i = 0; i < mappingArray.length; i = i + 2) {
-			iso2htmlMappings.put( mappingArray[i], mappingArray[i+1]);
+			iso2htmlMappings.put(mappingArray[i], mappingArray[i + 1]);
 		}
 	}
-		
-	
-	
+
 	/**
 	 * Converts a <code>String</code> containing HTML entities to
 	 * a <code>String</code> containing only ISO8859-1 characters.
@@ -158,47 +62,48 @@
 	 * 8859-1 table by Martin Ramsch</a>.
 	 * 
 	 * @author <a href="mailto:ey at inweb.de">Christian Ey</a>
-	 *
+	 * 
 	 * @version 1.0
-	 * @param htmlString The <code>String</code> containing HTML
-	 * 	entities
+	 * @param htmlString
+	 *            The <code>String</code> containing HTML
+	 *            entities
 	 * @return A <code>String</code> containing only ISO8859-1
-	 * 	characters
+	 *         characters
 	 */
-	public final static String cleanback( String htmlString) {
+	public final static String cleanback(String htmlString) {
 		int indexStart;
 		// return immediately if string is null or does not contain &
-		if (htmlString != null && (indexStart = htmlString.indexOf( ENTITY_START))>=0) {
+		if (htmlString != null && (indexStart = htmlString.indexOf(ENTITY_START)) >= 0) {
 			// copy everything from the beginning to entity start into buffer
-			StringBuffer isoBuffer = new StringBuffer( htmlString.substring( 0, indexStart));
+			StringBuffer isoBuffer = new StringBuffer(htmlString.substring(0, indexStart));
 			while (indexStart >= 0) {
-				int indexEnd = htmlString.indexOf( ENTITY_END, indexStart + 1);
+				int indexEnd = htmlString.indexOf(ENTITY_END, indexStart + 1);
 				if (indexEnd >= 0) {
-					int alternativeStart = htmlString.indexOf( ENTITY_START, indexStart + 1);
+					int alternativeStart = htmlString.indexOf(ENTITY_START, indexStart + 1);
 					if ((alternativeStart > indexStart) && (alternativeStart < indexEnd)) {
 						// a second index start is found inbetween current index start
 						// and index end
-						
+
 						// flush the html string inbetween
-						isoBuffer.append( htmlString.substring( indexStart, alternativeStart));
-						
+						isoBuffer.append(htmlString.substring(indexStart, alternativeStart));
+
 						// use the second index start and loop again
 						indexStart = alternativeStart;
 					} else {
-						String entity = htmlString.substring( indexStart, indexEnd + 1);
-						appendEntityAsIsoChar(entity, isoBuffer); 
-						indexStart = htmlString.indexOf( ENTITY_START, indexEnd + 1);
+						String entity = htmlString.substring(indexStart, indexEnd + 1);
+						appendEntityAsIsoChar(entity, isoBuffer);
+						indexStart = htmlString.indexOf(ENTITY_START, indexEnd + 1);
 						if (indexStart >= 0) {
 							// another entity start detected, flush the html string inbetween
-							isoBuffer.append( htmlString.substring( indexEnd + 1, indexStart));
+							isoBuffer.append(htmlString.substring(indexEnd + 1, indexStart));
 						} else {
 							// no further entity start detected, flush rest of html string
-							isoBuffer.append( htmlString.substring( indexEnd + 1));
+							isoBuffer.append(htmlString.substring(indexEnd + 1));
 						}
 					}
 				} else {
 					// entity start without matching entity end detected, ignore gracefully
-					isoBuffer.append( htmlString.substring( indexStart));
+					isoBuffer.append(htmlString.substring(indexStart));
 					break;
 				}
 			}
@@ -211,17 +116,18 @@
 
 	private final static void appendEntityAsIsoChar(String entity, StringBuffer addto) {
 		if (entity.startsWith("&#")) {
-			try{
-				if (entity.charAt(2)== 'x' || entity.charAt(2) == 'X') // number in hexadecimal // not tested because I don't have an XML containing hexadecimal encodings
-					addto.append((char)Integer.parseInt(entity.substring(3, entity.length()-1), 16)); 
-				else // number is decimal
-					addto.append((char)Integer.parseInt(entity.substring(2, entity.length()-1)));
+			try {
+				if (entity.charAt(2) == 'x' || entity.charAt(2) == 'X') // number in hexadecimal // not tested because I don't have an XML containing hexadecimal encodings
+					addto.append((char) Integer.parseInt(entity.substring(3, entity.length() - 1), 16));
+				else
+					// number is decimal
+					addto.append((char) Integer.parseInt(entity.substring(2, entity.length() - 1)));
 			} catch (NumberFormatException e) {
 				addto.append(entity); // not a valid number, insert original text
 			}
 
 		} // number format exception
-		else { // entity with a name like "&quot"						
+		else { // entity with a name like "&quot"
 			String isoCharacter = (String) iso2htmlMappings.get(entity);
 			if (isoCharacter != null) {
 				// insert iso character instead of html entity
@@ -232,127 +138,136 @@
 			}
 		}
 	}
-	
+
 	/**
-     * convert a single char to its equivalent HTML entity. Ordinary chars are
-     * not changed. 160 -> &nbsp;
-     *
-     * @param c Char to convert
-     *
-     * @return equivalent string eg. &amp;, null means leave char as is.
-     */
-    private final static String charToEntity( char c )
-        {
-        switch ( c ) {
-	        case '"' : return "&quot;";
-	        case '&' : return "&amp;";
-	        case '<' : return "&lt;";
-	        case '>' : return "&gt;";
-	        case '\'': return "&apos;";
-            default :
-                if ( c < 127 ) {
-                    // leave alone as equivalent string.
-                    return null;
-                    // faster than String.valueOf( c ).intern();
-                } else {
-                    // use the &#nnn; form
-                    return "&#" + Integer.toString( c ) + ";";
-                }
-            } // end switch
-        } // end charToEntity
+	 * convert a single char to its equivalent HTML entity. Ordinary chars are
+	 * not changed. 160 -> &nbsp;
+	 * 
+	 * @param c
+	 *            Char to convert
+	 * 
+	 * @return equivalent string eg. &amp;, null means leave char as is.
+	 */
+	private final static String charToEntity(char c) {
+		switch (c) {
+		case '"':
+			return "&quot;";
+		case '&':
+			return "&amp;";
+		case '<':
+			return "&lt;";
+		case '>':
+			return "&gt;";
+		case '\'':
+			return "&apos;";
+		default:
+			if (c < 127) {
+				// leave alone as equivalent string.
+				return null;
+				// faster than String.valueOf( c ).intern();
+			} else {
+				// use the &#nnn; form
+				return "&#" + Integer.toString(c) + ";";
+			}
+		} // end switch
+	} // end charToEntity
 
-    /**
-     * Converts text to HTML by quoting dangerous characters. Text must not
-     * already contain entities. e.g. " ==> &quot; < ==> &lt; ordinary text
-     * passes unchanged. Does not convert space to &nbsp;
-     *
-     * @param text raw text to be processed. Must not be null.
-     *
-     * @return translated text, or null if input is null.
-     */
-    public final static String clean( String text ) {
-        if ( text == null ) return null;
-        int originalTextLength = text.length();
-        StringBuffer sb = new StringBuffer( originalTextLength * 110 / 100 );
-        int charsToAppend = 0;
-        for ( int i = 0; i < originalTextLength; i++ ) {
-            char c = text.charAt( i );
-            String entity = charToEntity( c );
-            if ( entity == null ) {
-                // we could sb.append( c ), but that would be slower
-                // than saving them up for a big append.
-                charsToAppend++;
-            } else {
-                if ( charsToAppend != 0 ) {
-                    sb.append( text.substring( i - charsToAppend, i ) );
-                    charsToAppend = 0;
-                }
-                sb.append( entity );
-            }
-        } // end for
-        // append chars to the right of the last entity.
-        if ( charsToAppend != 0 ) {
-            sb.append( text.substring( originalTextLength - charsToAppend,
-                                       originalTextLength ) );
-        }
+	/**
+	 * Converts text to HTML by quoting dangerous characters. Text must not
+	 * already contain entities. e.g. " ==> &quot; < ==> &lt; ordinary text
+	 * passes unchanged. Does not convert space to &nbsp;
+	 * 
+	 * @param text
+	 *            raw text to be processed. Must not be null.
+	 * 
+	 * @return translated text, or null if input is null.
+	 */
+	public final static String clean(String text) {
+		if (text == null)
+			return null;
+		int originalTextLength = text.length();
+		StringBuffer sb = new StringBuffer(originalTextLength * 110 / 100);
+		int charsToAppend = 0;
+		for (int i = 0; i < originalTextLength; i++) {
+			char c = text.charAt(i);
+			String entity = charToEntity(c);
+			if (entity == null) {
+				// we could sb.append( c ), but that would be slower
+				// than saving them up for a big append.
+				charsToAppend++;
+			} else {
+				if (charsToAppend != 0) {
+					sb.append(text.substring(i - charsToAppend, i));
+					charsToAppend = 0;
+				}
+				sb.append(entity);
+			}
+		} // end for
+			// append chars to the right of the last entity.
+		if (charsToAppend != 0) {
+			sb.append(text.substring(originalTextLength - charsToAppend, originalTextLength));
+		}
 
-        // if result is not longer, we did not do anything. Save RAM.
-        return ( sb.length() == originalTextLength ) ? text : sb.toString();
-    } // end insertEntities
-	
-	
+		// if result is not longer, we did not do anything. Save RAM.
+		return (sb.length() == originalTextLength) ? text : sb.toString();
+	} // end insertEntities
 
 	/**
 	 * Converts a data string to something that is safe to use inside
 	 * an XML file (like prefs.xml) - entities like &amp; are *NOT*
 	 * valid XML unless declared specially, so we must use the numerical
 	 * values here.
-	 *
-	 * @param src (String) raw text to be processed
-	 *
+	 * 
+	 * @param src
+	 *            (String) raw text to be processed
+	 * 
 	 * @return (String) translated text, or null if input is null
 	 */
-	public final static String cleanGPX(String str){
-		String dummy = STRreplace.replace(str, "&","&amp;");
-		//"&amp;#" --> "&#"); //Darstellung Umlaute etc : siehe  http://www.geoclub.de/viewtopic.php?f=40&t=50635&p=798796#p798796
+	public final static String cleanGPX(String str) {
+		String dummy = STRreplace.replace(str, "&", "&amp;");
+		// "&amp;#" --> "&#"); //Darstellung Umlaute etc : siehe http://www.geoclub.de/viewtopic.php?f=40&t=50635&p=798796#p798796
 		// aber so etwas nicht "&amp;#entry15063" --> !!not!! "&#entry15063" (Cache GCPB5P export -> gpx, import -> mapsource)
-		int pos=0;
-		while (pos>-1) {
-			pos=dummy.indexOf("&amp;#",pos);
-			int pos1=dummy.indexOf(";",pos+6);
-			int k = pos1-pos; // wann kommt das ; als Ende eines numerischen entities?
-			if (pos>-1) {
-				if ( k < 12) {
-					String s = dummy.substring(pos+6,pos+8).toLowerCase();
-					char c=s.charAt(0);
-					char c1=s.charAt(1);
-					if ((c=='x' && ((c1>='0' && c1<='9') || (c1>='a' && c1<='f'))) || (c>='0' && c<='9')) {
-						dummy=dummy.substring(0, pos+1) + dummy.substring(pos+5, dummy.length());
+		int pos = 0;
+		while (pos > -1) {
+			pos = dummy.indexOf("&amp;#", pos);
+			int pos1 = dummy.indexOf(";", pos + 6);
+			int k = pos1 - pos; // wann kommt das ; als Ende eines numerischen entities?
+			if (pos > -1) {
+				if (pos1 > -1) {
+					if (k < 12) {
+						String s = dummy.substring(pos + 6, pos + 8).toLowerCase();
+						char c = s.charAt(0);
+						char c1 = s.charAt(1);
+						if ((c == 'x' && ((c1 >= '0' && c1 <= '9') || (c1 >= 'a' && c1 <= 'f'))) || (c >= '0' && c <= '9')) {
+							dummy = dummy.substring(0, pos + 1) + dummy.substring(pos + 5, dummy.length());
+						}
 					}
 				}
 				pos++;
 			}
 		}
-		dummy = STRreplace.replace(dummy, "&amp;amp;","&amp;"); //falls schon &amp; im str war 
-			
+		dummy = STRreplace.replace(dummy, "&amp;amp;", "&amp;"); // falls schon &amp; im str war
+
 		dummy = STRreplace.replace(dummy, "<", "&lt;");
 		dummy = STRreplace.replace(dummy, ">", "&gt;");
 		dummy = STRreplace.replace(dummy, "\"", "&quot;");
-		dummy = STRreplace.replace(dummy, "'","&apos;");
+		dummy = STRreplace.replace(dummy, "'", "&apos;");
 		// why
-		dummy = STRreplace.replace(dummy, "\u0004","");
-		// this means changing content, 
+		dummy = STRreplace.replace(dummy, "\u0004", "");
+		// this means changing content,
 		// but it is the easiest way of avoiding ]]> to be interpreted as endmark of CDATA-section
-		dummy = STRreplace.replace(dummy, "]]>","]] >");
+		dummy = STRreplace.replace(dummy, "]]>", "]] >");
 		// \ in gpx is not imported by mapsource, basecamp, garmin?...(there is no replacement)
-		dummy = STRreplace.replace(dummy, "\\","BkSlsh;");
+		dummy = STRreplace.replace(dummy, "\\", "BkSlsh;");
 
 		return dummy;
 	}
+
 	public final static String strxmlencode(boolean src) {
 		/* bools are always safe */
 		return (src ? "true" : "false");
 	}
+
 	public final static String strxmlencode(int src) {
 		/* numbers are always safe */
 		return (Integer.toString(src));

Modified: trunk/src/CacheWolf/UrlFetcher.java
===================================================================
--- trunk/src/CacheWolf/UrlFetcher.java	2011-05-18 07:45:09 UTC (rev 3006)
+++ trunk/src/CacheWolf/UrlFetcher.java	2011-05-18 14:06:48 UTC (rev 3007)
@@ -255,11 +255,10 @@
 				dest = n;
 			}
 			char c = what[i];
-			// removed || c == '&'
 			// added || c == '$' || c == '/' || c == ','
 			if (spaceToPlus && c == ' ')
 				c = '+';
-			else if (c <= ' ' || c >= 127 || c == '+' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}' || c == '$' || c == '/' || c == ',') {
+			else if (c <= ' ' || c >= 127 || c == '+' || c == '&' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}' || c == '$' || c == '/' || c == ',') {
 				dest[d++] = '%';
 				dest[d++] = hex.charAt((c >> 4) & 0xf);
 				dest[d++] = hex.charAt(c & 0xf);

Modified: trunk/src/CacheWolf/imp/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/imp/GPXImporter.java	2011-05-18 07:45:09 UTC (rev 3006)
+++ trunk/src/CacheWolf/imp/GPXImporter.java	2011-05-18 14:06:48 UTC (rev 3007)
@@ -1,32 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.imp;
 
-import com.stevesoft.ewe_pat.Regex;
-
 import CacheWolf.Attribute;
 import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
@@ -49,6 +47,9 @@
 import CacheWolf.UrlFetcher;
 import CacheWolf.imp.SpiderGC.SpiderProperties;
 import CacheWolf.utils.FileBugfix;
+
+import com.stevesoft.ewe_pat.Regex;
+
 import ewe.io.File;
 import ewe.io.FileInputStream;
 import ewe.io.IOException;
@@ -66,12 +67,12 @@
 import ewesoft.xml.sax.AttributeList;
 
 /**
-*	Class to import Data from an GPX File. If cache data exists, the data from 
-*	the GPX-File is ignored.
-*	Class ID = 4000
-*/
+ * Class to import Data from an GPX File. If cache data exists, the data from
+ * the GPX-File is ignored.
+ * Class ID = 4000
+ */
 public class GPXImporter extends MinML {
-	
+
 	static Preferences pref;
 	Profile profile;
 	CacheDB cacheDB;
@@ -80,7 +81,7 @@
 	boolean inWpt, inCache, inLogs, inBug;
 	public XMLElement document;
 	private Vector files = new Vector();
-	private boolean debugGPX = false; 
+	private boolean debugGPX = false;
 	InfoBox infB;
 	boolean spiderOK = true;
 	boolean doSpider = false;
@@ -99,15 +100,14 @@
 	private String attID;
 	private String attInc;
 
-	public GPXImporter(Preferences p, Profile prof, String f )
-	{
-		profile=prof;
+	public GPXImporter(Preferences p, Profile prof, String f) {
+		profile = prof;
 		pref = p;
 		cacheDB = profile.cacheDB;
-		//file = f;
+		// file = f;
 		files.add(f);
 		saveDir = profile.dataDir;
-		//msgA = msgArea;
+		// msgA = msgArea;
 		inWpt = false;
 		inCache = false;
 		inLogs = false;
@@ -115,17 +115,19 @@
 		doitHow = DOIT_ASK;
 	}
 
-	public void doIt(int how){
+	public void doIt(int how) {
 		doitHow = how;
 		Filter flt = new Filter();
-		boolean wasFiltered = (profile.getFilterActive()==Filter.FILTER_ACTIVE);
+		boolean wasFiltered = (profile.getFilterActive() == Filter.FILTER_ACTIVE);
 		flt.clearFilter();
-		try{
+		try {
 			ewe.io.Reader r;
 			String file;
 			if (how == DOIT_ASK) {
-				OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(5510,"Spider Options"), OCXMLImporterScreen.IMAGES| OCXMLImporterScreen.ISGC);
-				if (options.execute() == FormBase.IDCANCEL) { return; }
+				OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(5510, "Spider Options"), OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.ISGC);
+				if (options.execute() == FormBase.IDCANCEL) {
+					return;
+				}
 				doSpider = options.imagesCheckBox.getState();
 				options.close(0);
 			} else if (how == DOIT_NOSPOILER) {
@@ -139,23 +141,22 @@
 			} else {
 				doitHow = DOIT_NOSPOILER;
 			}
-			
+
 			Vm.showWait(true);
-			for (int i=0; i<files.size();i++){
-				//Test for zip.file
-				file = (String)files.get(i);
-				if (file.indexOf(".zip") > 0){
-					ZipFile zif = new ZipFile (file);
+			for (int i = 0; i < files.size(); i++) {
+				// Test for zip.file
+				file = (String) files.get(i);
+				if (file.indexOf(".zip") > 0) {
+					ZipFile zif = new ZipFile(file);
 					ZipEntry zipEnt;
 					Enumeration zipEnum = zif.entries();
 					// there could be more than one file in the archive
-					while (zipEnum.hasMoreElements())
-					{
+					while (zipEnum.hasMoreElements()) {
 						zipEnt = (ZipEntry) zipEnum.nextElement();
 						// skip over PRC-files
-						if (zipEnt.getName().endsWith("gpx")){
+						if (zipEnt.getName().endsWith("gpx")) {
 							r = new ewe.io.InputStreamReader(zif.getInputStream(zipEnt));
-							infB = new InfoBox(zipEnt.toString(),(MyLocale.getMsg(4000,"Loaded caches: ") + zaehlerGel));
+							infB = new InfoBox(zipEnt.toString(), (MyLocale.getMsg(4000, "Loaded caches: ") + zaehlerGel));
 							infB.exec();
 							if (r.read() != 65279)
 								r = new ewe.io.InputStreamReader(zif.getInputStream(zipEnt));
@@ -165,11 +166,10 @@
 						}
 					}
 					zif.close();
-				}
-				else {
+				} else {
 					FileInputStream rFIS = new ewe.io.FileInputStream(file);
 					r = new ewe.io.InputStreamReader(rFIS);
-					infB = new InfoBox("Info",(MyLocale.getMsg(4000,"Loaded caches: ") + zaehlerGel));
+					infB = new InfoBox("Info", (MyLocale.getMsg(4000, "Loaded caches: ") + zaehlerGel));
 					infB.show();
 					if (r.read() != 65279) {
 						r.close();
@@ -182,47 +182,60 @@
 					rFIS.close();
 					infB.close(0);
 				}
-				// save Index 
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+				// save Index
+				profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 				infB.close(0);
 			}
-				Vm.showWait(false);
-			}catch(Exception e){
-				pref.log("[GPXImporter:DoIt]",e,true);
-				Vm.showWait(false);
+			Vm.showWait(false);
+		} catch (Exception e) {
+			if (holder.getWayPoint().length() > 0) {
+				pref.log("[GPXImporter:DoIt] " + holder.getWayPoint() + " LogID=" + logId, e, true);
+			} else {
+				pref.log("[GPXImporter:DoIt] " + holder.getLatLon() + " LogID=" + logId, e, true);
 			}
-		if(wasFiltered){
+			infB.close(0);
+			Vm.showWait(false);
+		}
+		if (wasFiltered) {
 			flt.setFilter();
 			flt.doFilter();
 		}
 	}
-	public void startElement(String name, AttributeList atts){
-		strBuf=new StringBuffer(300);
-		if(infB.isClosed)  return;
-		if (name.equals("gpx")){
+
+	public void startElement(String name, AttributeList atts) {
+		strBuf = new StringBuffer(300);
+		if (infB.isClosed)
+			return;
+		if (name.equals("gpx")) {
 			// check for opencaching
-			if (atts.getValue("creator").indexOf("opencaching")> 0) fromOC = true;
-			else fromOC = false;
-			if (atts.getValue("creator").startsWith("TerraCaching")) fromTC = true;
-			else fromTC = false;
+			if (atts.getValue("creator").indexOf("opencaching") > 0)
+				fromOC = true;
+			else
+				fromOC = false;
+			if (atts.getValue("creator").startsWith("TerraCaching"))
+				fromTC = true;
+			else
+				fromTC = false;
 
-			// if (fromOC && doSpider) (new MessageBox("Warnung", MyLocale.getMsg(4001, "GPX files from opencaching don't contain information of images, they cannot be laoded. Best you get caches from opencaching by menu /Application/Import/Download from Opencaching"), FormBase.OKB)).execute();
+			// if (fromOC && doSpider) (new MessageBox("Warnung", MyLocale.getMsg(4001,
+			// "GPX files from opencaching don't contain information of images, they cannot be laoded. Best you get caches from opencaching by menu /Application/Import/Download from Opencaching"), FormBase.OKB)).execute();
 			zaehlerGel = 0;
 		}
 		if (name.equals("wpt")) {
 			holder = new CacheHolder();
-			holder.pos.set(Common.parseDouble(atts.getValue("lat")),Common.parseDouble(atts.getValue("lon")));
+			holder.pos.set(Common.parseDouble(atts.getValue("lat")), Common.parseDouble(atts.getValue("lon")));
 			holder.setLatLon(holder.pos.toString());
 			inWpt = true;
 			inLogs = false;
 			inBug = false;
 			nameFound = false;
 			zaehlerGel++;
-			infB.setInfo(MyLocale.getMsg(4000,"Loaded caches: ") + zaehlerGel);
+			infB.setInfo(MyLocale.getMsg(4000, "Loaded caches: ") + zaehlerGel);
+			logId = "";
 			return;
 		}
-		
-		if (name.equals("link")&& inWpt){
+
+		if (name.equals("link") && inWpt) {
 			holder.getCacheDetails(false).URL = atts.getValue("href");
 			return;
 		}
@@ -231,7 +244,7 @@
 			inCache = true;
 			holder.setAvailable(atts.getValue("available").equals("True"));
 			holder.setArchived(atts.getValue("archived").equals("True"));
-			// OC now has GC - Format,  get CacheID -- missing p.ex. on GcTour gpx
+			// OC now has GC - Format, get CacheID -- missing p.ex. on GcTour gpx
 			for (int i = 0; i < atts.getLength(); i++) {
 				if (atts.getName(i).equals("id")) {
 					holder.setOcCacheID(atts.getValue("id"));
@@ -241,10 +254,10 @@
 			return;
 		}
 		// OC
-		if (name.equals("geocache")|| name.equals("cache")) {
+		if (name.equals("geocache") || name.equals("cache")) {
 			boolean available = false;
-			boolean archived  = false;
-			inCache=true;
+			boolean archived = false;
+			inCache = true;
 			// get CacheID -- missing p.ex. on GcTour gpx
 			for (int i = 0; i < atts.getLength(); i++) {
 				if (atts.getName(i).equals("id")) {
@@ -254,25 +267,28 @@
 			}
 			// get status
 			String status = atts.getValue("status");
-			if (status.equals("Available")) available = true;
-			else if (status.equals("Unavailable")) available = false;
-			else if (status.equals("Draft")) available = false;
-			else if (status.equals("Archived")) archived = true;
+			if (status.equals("Available"))
+				available = true;
+			else if (status.equals("Unavailable"))
+				available = false;
+			else if (status.equals("Draft"))
+				available = false;
+			else if (status.equals("Archived"))
+				archived = true;
 			holder.setArchived(archived);
 			holder.setAvailable(available);
 			return;
 		}
-		
+
 		if (name.equals("terra:terracache")) {
-			inCache=true;
+			inCache = true;
 		}
 
-		
 		if (name.indexOf("long_description") > -1) {
 			holder.setHTML(atts.getValue("html").toLowerCase().equals("true"));
 		}
-		if (name.equals("description") || name.equals("terra:description") ) {
-			//set HTML always to true if from oc.de or TC
+		if (name.equals("description") || name.equals("terra:description")) {
+			// set HTML always to true if from oc.de or TC
 			holder.setHTML(true);
 		}
 
@@ -294,102 +310,103 @@
 			attID = atts.getValue("id");
 			attInc = atts.getValue("inc");
 			return;
-		}		
-		if (debugGPX){
+		}
+		if (debugGPX) {
 			for (int i = 0; i < atts.getLength(); i++) {
-				pref.log("[GPXExporter:startElement]Type: " + atts.getType(i) + " Name: " + atts.getName(i)+ " Value: "+atts.getValue(i),null);
+				pref.log("[GPXExporter:startElement]Type: " + atts.getType(i) + " Name: " + atts.getName(i) + " Value: " + atts.getValue(i), null);
 			}
 		}
 	}
-	
-	public void endElement(String name){
-		strData=strBuf.toString();
-		if(infB.isClosed) return;
+
+	public void endElement(String name) {
+		strData = strBuf.toString();
+		if (infB.isClosed)
+			return;
 		// logs
-		if (inLogs){
-			if (name.equals("groundspeak:date")|| name.equals("time")|| name.equals("date")|| name.equals("terra:date"))  {
-				logDate = new String(strData.substring(0,10));
+		if (inLogs) {
+			if (name.equals("groundspeak:date") || name.equals("time") || name.equals("date") || name.equals("terra:date")) {
+				logDate = new String(strData.substring(0, 10));
 				return;
 			}
-			if (name.equals("groundspeak:type") || name.equals("type") || name.equals("terra:type")){
+			if (name.equals("groundspeak:type") || name.equals("type") || name.equals("terra:type")) {
 				logIcon = new String(Log.typeText2Image(strData));
 				return;
 			}
-			if (name.equals("groundspeak:finder")|| name.equals("geocacher")|| name.equals("finder")|| name.equals("terra:user")){
+			if (name.equals("groundspeak:finder") || name.equals("geocacher") || name.equals("finder") || name.equals("terra:user")) {
 				logFinder = new String(strData);
 				return;
 			}
-			if (name.equals("groundspeak:text") || name.equals("text") || name.equals("terra:entry")){ 
+			if (name.equals("groundspeak:text") || name.equals("text") || name.equals("terra:entry")) {
 				logData = new String(strData);
 				return;
 			}
-			if (name.equals("groundspeak:log") || name.equals("log") || name.equals("terra:log") ) {
-				holder.getCacheDetails(false).CacheLogs.add(new Log(logIcon,logDate,logFinder,logData));
-				if((logIcon.equals("icon_smile.gif") || logIcon.equals("icon_camera.gif") || logIcon.equals("icon_attended.gif")) && 
-						  (SafeXML.cleanback(logFinder).equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()>0 && SafeXML.cleanback(logFinder).equalsIgnoreCase(pref.myAlias2)))) {
-							holder.setCacheStatus(logDate);
-							holder.setFound(true);
-							holder.getCacheDetails(false).OwnLogId = logId;
-							holder.getCacheDetails(false).OwnLog = new Log(logIcon,logDate,logFinder,logData);
+			if (name.equals("groundspeak:log") || name.equals("log") || name.equals("terra:log")) {
+				holder.getCacheDetails(false).CacheLogs.add(new Log(logIcon, logDate, logFinder, logData));
+				if ((logIcon.equals("icon_smile.gif") || logIcon.equals("icon_camera.gif") || logIcon.equals("icon_attended.gif"))
+						&& (SafeXML.cleanback(logFinder).equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length() > 0 && SafeXML.cleanback(logFinder).equalsIgnoreCase(pref.myAlias2)))) {
+					holder.setCacheStatus(logDate);
+					holder.setFound(true);
+					holder.getCacheDetails(false).OwnLogId = logId;
+					holder.getCacheDetails(false).OwnLog = new Log(logIcon, logDate, logFinder, logData);
 				}
 				return;
 			}
 		}
-		
-		if (name.equals("wpt")){
-			
-			int index=cacheDB.getIndex(holder.getWayPoint());
-			if (index == -1){// Add cache Data only, if waypoint not already in database
+
+		if (name.equals("wpt")) {
+
+			int index = cacheDB.getIndex(holder.getWayPoint());
+			if (index == -1) {// Add cache Data only, if waypoint not already in database
 				holder.setNoFindLogs(holder.getCacheDetails(false).CacheLogs.countNotFoundLogs());
 				holder.setNew(true);
 				cacheDB.add(holder);
 				// don't spider additional waypoints, so check
 				// if waypoint starts with "GC"
-				if(doSpider) {
-					if(spiderOK && holder.is_archived() == false){
-						if(holder.getLatLon().length() > 1){ }
-						//spiderImages();
+				if (doSpider) {
+					if (spiderOK && holder.is_archived() == false) {
+						if (holder.getLatLon().length() > 1) {
+						}
+						// spiderImages();
 						spiderImagesUsingSpider();
-						//Rename image sources
+						// Rename image sources
 						String text;
 						String orig;
 						String imgName;
 						orig = holder.getCacheDetails(false).LongDescription;
+
 						Extractor ex = new Extractor(orig, "<img src=\"", ">", 0, false);
-						text = ex.findNext();
 						int num = 0;
-						while(ex.endOfSearch() == false && spiderOK){
-							if (num >= holder.getCacheDetails(false).images.size())break;
+						while ((text = ex.findNext()).length() > 0 && spiderOK) {
+							if (num >= holder.getCacheDetails(false).images.size())
+								break;
 							imgName = holder.getCacheDetails(false).images.get(num).getTitle();
 							holder.getCacheDetails(false).LongDescription = STRreplace.replace(holder.getCacheDetails(false).LongDescription, text, "[[Image: " + imgName + "]]");
 							num++;
-							text = ex.findNext();
 						}
 					}
 				}
 				holder.save();
-				//crw.saveIndex(cacheDB,saveDir);
+				// crw.saveIndex(cacheDB,saveDir);
 			}
-			//Update cache data
+			// Update cache data
 			else {
-				CacheHolder oldCh= cacheDB.get(index);
+				CacheHolder oldCh = cacheDB.get(index);
 				// Preserve images: Copy images from old cache version because here we didn't add
 				// any image information to the holder object.
 				if (pref.downloadPics && holder.isOC()) {
-					spiderImagesUsingSpider(); 
-				}
-				else {
+					spiderImagesUsingSpider();
+				} else {
 					holder.getCacheDetails(false).images = oldCh.getCacheDetails(true).images;
 				}
 				oldCh.initStates(false);
 				oldCh.update(holder);
 				oldCh.save();
 			}
-			
+
 			inWpt = false;
 			return;
 		}
-		if (name.equals("sym")&& strData.endsWith("Found")) {
+		if (name.equals("sym") && strData.endsWith("Found")) {
 			holder.setFound(true);
 			holder.setCacheStatus(holder.getFoundText());
 			return;
@@ -399,88 +416,86 @@
 			return;
 		}
 
-		if (name.equals("groundspeak:name")&& inBug) {
-			Travelbug tb=new Travelbug(strData);
+		if (name.equals("groundspeak:name") && inBug) {
+			Travelbug tb = new Travelbug(strData);
 			holder.getCacheDetails(false).Travelbugs.add(tb);
 			holder.setHas_bugs(true);
 			return;
 		}
-		
-		if (name.equals("time") && !inWpt) {		    
+
+		if (name.equals("time") && !inWpt) {
 			try {
-			    gpxDate.parse(strData.substring(0,19),"yyyy-MM-dd'T'HH:mm:ss");
+				gpxDate.parse(strData.substring(0, 19), "yyyy-MM-dd'T'HH:mm:ss");
 			} catch (IllegalArgumentException e) {
-			    gpxDate.setTime(0);
-			    pref.log("[GPXImporter:endElement]Error parsing Element time: '"+strData+"'. Ignoring.");
+				gpxDate.setTime(0);
+				pref.log("[GPXImporter:endElement]Error parsing Element time: '" + strData + "'. Ignoring.");
 			}
 			return;
 		}
 
 		if (name.equals("time") && inWpt) {
-			holder.setDateHidden(strData.substring(0,10)); //Date;
+			holder.setDateHidden(strData.substring(0, 10)); // Date;
 			return;
 		}
 		// cache information
-		if (name.equals("groundspeak:cache") || name.equals("geocache")|| name.equals("cache")|| name.equals("terra:terracache")) {
+		if (name.equals("groundspeak:cache") || name.equals("geocache") || name.equals("cache") || name.equals("terra:terracache")) {
 			inCache = false;
 		}
-		
+
 		if (name.equals("name") && inWpt && !inCache) {
 			holder.setWayPoint(strData);
-			if (gpxDate.getTime()!=0) {
-			    holder.setLastSync(gpxDate.format("yyyyMMddHHmmss"));
+			if (gpxDate.getTime() != 0) {
+				holder.setLastSync(gpxDate.format("yyyyMMddHHmmss"));
 			} else {
-			    holder.setLastSync("");
-			}    
-			//msgA.setText("import " + strData);
+				holder.setLastSync("");
+			}
+			// msgA.setText("import " + strData);
 			return;
 		}
 
 		// fill name with contents of <desc>, in case of gc.com the name is
 		// later replaced by the contents of <groundspeak:name> which is shorter
-		if (name.equals("desc")&& inWpt ) {
+		if (name.equals("desc") && inWpt) {
 			holder.setCacheName(strData);
-			//msgA.setText("import " + strData);
+			// msgA.setText("import " + strData);
 			return;
 		}
-		if (name.equals("url")&& inWpt){
+		if (name.equals("url") && inWpt) {
 			holder.getCacheDetails(false).URL = strData;
 			return;
 		}
-		
+
 		// Text for additional waypoints, no HTML
-		if (name.equals("cmt")&& inWpt){
+		if (name.equals("cmt") && inWpt) {
 			holder.getCacheDetails(false).LongDescription = strData;
 			holder.setHTML(false);
 			return;
 		}
-		
+
 		// aditional wapypoint
-		if (name.equals("type")&& inWpt && !inCache && strData.startsWith("Waypoint")){
+		if (name.equals("type") && inWpt && !inCache && strData.startsWith("Waypoint")) {
 			holder.setType(CacheType.gpxType2CwType(strData));
 			holder.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
 			holder.setHard(CacheTerrDiff.CW_DT_UNSET);
 			holder.setTerrain(CacheTerrDiff.CW_DT_UNSET);
 			holder.setLastSync("");
 		}
-		
-		if (name.indexOf("name")>-1 && inCache) {
+
+		if (name.indexOf("name") > -1 && inCache) {
 			holder.setCacheName(strData);
 			return;
 		}
-		if (name.equals("groundspeak:owner") || name.equals("owner")||name.equals("terra:owner")) {
+		if (name.equals("groundspeak:owner") || name.equals("owner") || name.equals("terra:owner")) {
 			holder.setCacheOwner(strData);
-			if (pref.myAlias.equals(SafeXML.cleanback(strData)) || 
-				(pref.myAlias2.length()>0 && SafeXML.cleanback(strData).equalsIgnoreCase(pref.myAlias2)))
+			if (pref.myAlias.equals(SafeXML.cleanback(strData)) || (pref.myAlias2.length() > 0 && SafeXML.cleanback(strData).equalsIgnoreCase(pref.myAlias2)))
 				holder.setOwned(true);
 			return;
 		}
 		if (name.equals("groundspeak:placed_by")) {
-			if(holder.getCacheOwner().equals("")) {
+			if (holder.getCacheOwner().equals("")) {
 				holder.setCacheOwner(strData);
-				if (pref.myAlias.equals(SafeXML.cleanback(strData)) || 
-						(pref.myAlias2.length()>0 && SafeXML.cleanback(strData).equalsIgnoreCase(pref.myAlias2)))
-						holder.setOwned(true);
+				if (pref.myAlias.equals(SafeXML.cleanback(strData)) || (pref.myAlias2.length() > 0 && SafeXML.cleanback(strData).equalsIgnoreCase(pref.myAlias2)))
+					holder.setOwned(true);
 			}
 			return;
 		}
@@ -488,11 +503,11 @@
 			holder.setHard(CacheTerrDiff.v1Converter(strData));
 			return;
 		}
-		if (name.equals("groundspeak:terrain")|| name.equals("terrain")|| name.equals("terra:physical_challenge")) {
+		if (name.equals("groundspeak:terrain") || name.equals("terrain") || name.equals("terra:physical_challenge")) {
 			holder.setTerrain(CacheTerrDiff.v1Converter(strData));
 			return;
 		}
-		if ((name.equals("groundspeak:type") || name.equals("type")|| name.equals("terra:style"))&& inCache){
+		if ((name.equals("groundspeak:type") || name.equals("type") || name.equals("terra:style")) && inCache) {
 			holder.setType(CacheType.gpxType2CwType(strData));
 			if (holder.isCustomWpt()) {
 				holder.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
@@ -501,158 +516,177 @@
 			}
 			return;
 		}
-		if (name.equals("groundspeak:container")|| name.equals("container")){
+		if (name.equals("groundspeak:container") || name.equals("container")) {
 			holder.setCacheSize(CacheSize.gcGpxString2Cw(strData));
 			return;
 		}
-		if (name.equals("groundspeak:country")|| name.equals("country")){
+		if (name.equals("groundspeak:country") || name.equals("country")) {
 			holder.getCacheDetails(false).Country = strData;
 			return;
 		}
-		if (name.equals("groundspeak:state")|| name.equals("state")){
+		if (name.equals("groundspeak:state") || name.equals("state")) {
 			holder.getCacheDetails(false).State = strData;
 			return;
 		}
-		if (name.equals("terra:size")){
+		if (name.equals("terra:size")) {
 			holder.setCacheSize(CacheSize.tcGpxString2Cw(strData));
 		}
 
-		if (name.indexOf("short_description") > -1|| name.equals("summary")) {
-			if (holder.is_HTML())	holder.getCacheDetails(false).LongDescription =SafeXML.cleanback(strData)+"<br>"; // <br> needed because we also use a <br> in SpiderGC. Without it the comparison in ch.update fails
-			else holder.getCacheDetails(false).LongDescription =strData+"\n";
+		if (name.indexOf("short_description") > -1 || name.equals("summary")) {
+			if (holder.is_HTML())
+				holder.getCacheDetails(false).LongDescription = SafeXML.cleanback(strData) + "<br>"; // <br> needed because we also use a <br> in SpiderGC. Without it the comparison in ch.update fails
+			else
+				holder.getCacheDetails(false).LongDescription = strData + "\n";
 			return;
 		}
 
-		if (name.indexOf("long_description") > -1 || name.equals("description")|| name.equals("terra:description")) {
-			if (holder.is_HTML())	holder.getCacheDetails(false).LongDescription +=SafeXML.cleanback(strData);
-			else holder.getCacheDetails(false).LongDescription +=strData;
+		if (name.indexOf("long_description") > -1 || name.equals("description") || name.equals("terra:description")) {
+			if (holder.is_HTML())
+				holder.getCacheDetails(false).LongDescription += SafeXML.cleanback(strData);
+			else
+				holder.getCacheDetails(false).LongDescription += strData;
 			return;
 		}
 		if (name.indexOf("encoded_hints") > -1 || name.equals("hints")) {
-			holder.getCacheDetails(false).Hints = STRreplace.replace(STRreplace.replace(Common.rot13(strData),"\n","<br>"),"\t","");
+			holder.getCacheDetails(false).Hints = STRreplace.replace(STRreplace.replace(Common.rot13(strData), "\n", "<br>"), "\t", "");
 			return;
 		}
-		
+
 		if (name.equals("terra:hint")) {
 			// remove "&lt;br&gt;<br>" from the end
 			int indexTrash = strData.indexOf("&lt;br&gt;<br>");
-			if (indexTrash > 0)	holder.getCacheDetails(false).Hints = STRreplace.replace(STRreplace.replace(Common.rot13(strData.substring(0,indexTrash)),"\n","<br>"),"\t","");
+			if (indexTrash > 0)
+				holder.getCacheDetails(false).Hints = STRreplace.replace(STRreplace.replace(Common.rot13(strData.substring(0, indexTrash)), "\n", "<br>"), "\t", "");
 			return;
 		}
 
 		if (name.equals("groundspeak:attribute")) {
 			if (attID.equals("")) {
-				attID=Attribute.getIdFromGCText(strData);
+				attID = Attribute.getIdFromGCText(strData);
 			}
 			int id = Integer.parseInt(attID);
-			holder.getCacheDetails(false).attributes.add(id,attInc);
+			holder.getCacheDetails(false).attributes.add(id, attInc);
 			holder.setAttribsAsBits(holder.getCacheDetails(false).attributes.getAttribsAsBits());
 			return;
-		}		
+		}
 
 	}
-	public void characters(char[] ch,int start,int length){
-		strBuf.append(ch,start,length);
-		if (debugGPX) pref.log("Char: " + strBuf.toString(),null);
+
+	public void characters(char[] ch, int start, int length) {
+		strBuf.append(ch, start, length);
+		if (debugGPX)
+			pref.log("Char: " + strBuf.toString(), null);
 	}
-	
-	public static String TCSizetoText(String size){
-		if (size.equals("1")) return "Micro";
-		if (size.equals("2")) return "Medium";
-		if (size.equals("3")) return "Regular";
-		if (size.equals("4")) return "Large";
-		if (size.equals("5")) return "Very Large";
 
+	public static String TCSizetoText(String size) {
+		if (size.equals("1"))
+			return "Micro";
+		if (size.equals("2"))
+			return "Medium";
+		if (size.equals("3"))
+			return "Regular";
+		if (size.equals("4"))
+			return "Large";
+		if (size.equals("5"))
+			return "Very Large";
+
 		return "None";
 	}
-	
-	private void spiderImagesUsingSpider(){
+
+	private void spiderImagesUsingSpider() {
 		String addresse;
 		String cacheText;
-		
+
 		// just to be sure to have a spider object
-		if (imgSpider == null) imgSpider = new SpiderGC(pref, profile);
-		if (propsSpider == null) {propsSpider = imgSpider.new SpiderProperties();	}
-		
+		if (imgSpider == null)
+			imgSpider = new SpiderGC(pref, profile);
+		if (propsSpider == null) {
+			propsSpider = imgSpider.new SpiderProperties();
+		}
+
 		try {
-				if (fromTC) {
-						imgSpider.getImages(holder.getCacheDetails(false).LongDescription, holder.getCacheDetails(false),false);
-				}
-				else {
-					if (fromOC) {
-						holder.getCacheDetails(false).images.clear();
-						addresse=holder.getCacheDetails(false).URL;
-						cacheText = UrlFetcher.fetch(addresse);
-						Extractor exBeschreibung = new Extractor(cacheText, "<!-- Beschreibung -->", "<!-- End Beschreibung -->", 0, false);
-						String beschreibung = exBeschreibung.findNext();
-						getOCPictures(beschreibung);
-						Extractor exBilder = new Extractor(cacheText, "<!-- Bilder -->", "<!-- End Bilder -->", 0, false);
-						String bilder = exBilder.findNext();
-						getOCPictures(bilder);
+			if (fromTC) {
+				imgSpider.getImages(holder.getCacheDetails(false).LongDescription, holder.getCacheDetails(false), false);
+			} else {
+				if (fromOC) {
+					holder.getCacheDetails(false).images.clear();
+					addresse = holder.getCacheDetails(false).URL;
+					cacheText = UrlFetcher.fetch(addresse);
+					Extractor exBeschreibung = new Extractor(cacheText, "<!-- Beschreibung -->", "<!-- End Beschreibung -->", 0, false);
+					String beschreibung = exBeschreibung.findNext();
+					getOCPictures(beschreibung);
+					Extractor exBilder = new Extractor(cacheText, "<!-- Bilder -->", "<!-- End Bilder -->", 0, false);
+					String bilder = exBilder.findNext();
+					getOCPictures(bilder);
+				} else {
+					addresse = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + holder.getWayPoint();
+					cacheText = UrlFetcher.fetch(addresse);
+					if (cacheText.indexOf(propsSpider.getProp("premiumCachepage")) > 0) {
+						// Premium cache spidered by non premium member
+						imgSpider.getImages(holder.getCacheDetails(false).LongDescription, holder.getCacheDetails(false), false);
+					} else {
+						imgSpider.getImages(cacheText, holder.getCacheDetails(false), true);
 					}
-					else {
-						addresse = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + holder.getWayPoint() ;
-						cacheText = UrlFetcher.fetch(addresse);
-						if (cacheText.indexOf(propsSpider.getProp("premiumCachepage")) > 0) {
-							// Premium cache spidered by non premium member
-							imgSpider.getImages(holder.getCacheDetails(false).LongDescription, holder.getCacheDetails(false),false);
-						}
-						else {
-							imgSpider.getImages(cacheText, holder.getCacheDetails(false),true);
-						}
-						try {
-							imgSpider.getAttributes(cacheText, holder.getCacheDetails(false));
-						} catch (Exception e) {
-							pref.log("unable to fetch attributes for"+holder.getWayPoint(), e);
-						}
+					try {
+						imgSpider.getAttributes(cacheText, holder.getCacheDetails(false));
+					} catch (Exception e) {
+						pref.log("unable to fetch attributes for" + holder.getWayPoint(), e);
 					}
 				}
+			}
 		} catch (Exception e1) {
 			// e1.printStackTrace();
 		}
 	}
+
 	private void getOCPictures(String html) {
 		Regex imgRegexUrl = new Regex("(<img[^>]*src=[\"\']([^>^\"^\']*)[^>]*>|<img[^>]*src=([^>^\"^\'^ ]*)[^>]*>)");
 		imgRegexUrl.setIgnoreCase(true);
-		int descIndex=0;
-		while (imgRegexUrl.searchFrom(html, descIndex)) {			
+		int descIndex = 0;
+		while (imgRegexUrl.searchFrom(html, descIndex)) {
 			descIndex = imgRegexUrl.matchedTo();
-			String fetchUrl=imgRegexUrl.stringMatched(2); // URL in Anf?hrungszeichen in (2)		
-			if (fetchUrl==null) { fetchUrl=imgRegexUrl.stringMatched(3); } // falls ohne in (3)			
-			if (fetchUrl==null) {continue;} // schlechtes html
-			//  fetchUrl ist auf jeden Fall ohne Anf?hrungszeichen
-			if (fetchUrl.startsWith("resource")) continue; // 
+			String fetchUrl = imgRegexUrl.stringMatched(2); // URL in Anf?hrungszeichen in (2)
+			if (fetchUrl == null) {
+				fetchUrl = imgRegexUrl.stringMatched(3);
+			} // falls ohne in (3)
+			if (fetchUrl == null) {
+				continue;
+			} // schlechtes html
+				// fetchUrl ist auf jeden Fall ohne Anf?hrungszeichen
+			if (fetchUrl.startsWith("resource"))
+				continue; //
 			if (fetchUrl.startsWith("images")) // z.B. Flaggen
-				if (!fetchUrl.startsWith("images/uploads")) continue;
-			if (fetchUrl.startsWith("thumbs")) continue; // z.B. Flaggen
+				if (!fetchUrl.startsWith("images/uploads"))
+					continue;
+			if (fetchUrl.startsWith("thumbs"))
+				continue; // z.B. Flaggen
 			try {
-				//TODO this is not quite correct: actually the "base" URL must be known...
-				// but anyway a different baseURL should not happen very often  - it doesn't in my area
+				// TODO this is not quite correct: actually the "base" URL must be known...
+				// but anyway a different baseURL should not happen very often - it doesn't in my area
 				String hostname = OC.getOCHostName(holder.getWayPoint());
 				if (!fetchUrl.startsWith("http://")) {
-					fetchUrl = new URL(new URL("http://" + hostname+"/"), fetchUrl).toString();
+					fetchUrl = new URL(new URL("http://" + hostname + "/"), fetchUrl).toString();
 				}
-			} catch (MalformedURLException e) {	continue; } // auch egal
+			} catch (MalformedURLException e) {
+				continue;
+			} // auch egal
 			ImageInfo imageInfo = new ImageInfo();
 			imageInfo.setURL(fetchUrl);
 			imageInfo.setTitle(makeTitle(imgRegexUrl.stringMatched(1), fetchUrl));
 			getPic(imageInfo);
 		}
-		
-		
+
 		Extractor exHref = new Extractor(html, "<a href=", "</a>", 0, true);
-		while (!exHref.endOfSearch()) {
-			String href = exHref.findNext();
-			if (href.length() > 0) {
-				Extractor exHttp = new Extractor(href, "http://", "\"", 0, true);
-				String fetchUrl = exHttp.findNext();
+		String href = "";
+		Extractor exHttp = new Extractor(href, "http://", "\"", 0, true);
+		while ((href = exHref.findNext()).length() > 0) {
+			exHttp.set(href, "http://", "\"", 0, true);
+			String fetchUrl = exHttp.findNext();
+			if (fetchUrl.length() > 0) {
 				try {
 					String imgType = (fetchUrl.substring(fetchUrl.lastIndexOf('.')).toLowerCase() + "    ").substring(0, 4).trim();
 					fetchUrl = "http://" + fetchUrl.substring(0, fetchUrl.lastIndexOf('.') + imgType.length());
-					if (imgType.startsWith(".jpg") ||
-						imgType.startsWith(".bmp") ||
-						imgType.startsWith(".png") ||
-						imgType.startsWith(".gif")) {
+					if (imgType.startsWith(".jpg") || imgType.startsWith(".bmp") || imgType.startsWith(".png") || imgType.startsWith(".gif")) {
 						ImageInfo imageInfo = new ImageInfo();
 						imageInfo.setURL(fetchUrl);
 						imageInfo.setTitle(makeTitle(href, fetchUrl));
@@ -669,37 +703,40 @@
 		imgRegexAlt.setIgnoreCase(true);
 		String imgAltText;
 		if (imgRegexAlt.search(imgTag)) {
-			imgAltText=imgRegexAlt.stringMatched(1);
-			if (imgAltText==null)	imgAltText=imgRegexAlt.stringMatched(2);			
+			imgAltText = imgRegexAlt.stringMatched(1);
+			if (imgAltText == null)
+				imgAltText = imgRegexAlt.stringMatched(2);
 		} else { // no alternative text as image title -> use --- or filename
-			//wenn von Opencaching oder geocaching ist Dateiname doch nicht so toll, weil nur aus Nummer bestehend
-			if (fetchUrl.toLowerCase().indexOf("opencaching.") > 0 || fetchUrl.toLowerCase().indexOf("geocaching.com") > 0) 
+			// wenn von Opencaching oder geocaching ist Dateiname doch nicht so toll, weil nur aus Nummer bestehend
+			if (fetchUrl.toLowerCase().indexOf("opencaching.") > 0 || fetchUrl.toLowerCase().indexOf("geocaching.com") > 0)
 				imgAltText = "---"; // no image title
-			else imgAltText = fetchUrl.substring(fetchUrl.lastIndexOf('/')+1);
+			else
+				imgAltText = fetchUrl.substring(fetchUrl.lastIndexOf('/') + 1);
 		}
 		return imgAltText;
 	}
-	
+
 	private void getPic(ImageInfo imageInfo) {
-		String fileName = holder.getWayPoint() + "_" + imageInfo.getURL().substring(imageInfo.getURL().lastIndexOf('/')+1);
+		String fileName = holder.getWayPoint() + "_" + imageInfo.getURL().substring(imageInfo.getURL().lastIndexOf('/') + 1);
 		fileName = Common.ClearForFileName(fileName).toLowerCase();
 		String target = profile.dataDir + fileName;
 		imageInfo.setFilename(fileName);
 		try {
 			File ftest = new FileBugfix(target);
-			if (ftest.exists()){
-				if (ftest.length() == 0) { ftest.delete(); }
-				else { holder.getCacheDetails(false).images.add(imageInfo);	}
-			}
-			else {
+			if (ftest.exists()) {
+				if (ftest.length() == 0) {
+					ftest.delete();
+				} else {
+					holder.getCacheDetails(false).images.add(imageInfo);
+				}
+			} else {
 				if (pref.downloadPics) {
 					UrlFetcher.fetchDataFile(imageInfo.getURL(), target);
 					ftest = new FileBugfix(target);
-					if (ftest.exists()){
-						if ( ftest.length() > 0 ) {
+					if (ftest.exists()) {
+						if (ftest.length() > 0) {
 							holder.getCacheDetails(false).images.add(imageInfo);
-						}
-						else {
+						} else {
 							ftest.delete();
 						}
 					}
@@ -708,21 +745,25 @@
 		} catch (IOException e) {
 			String ErrMessage;
 			String wp, n;
-			if (holder != null && holder.getWayPoint() != null) wp = holder.getWayPoint();
-			else 												wp = "WP???";
-			if (holder != null && holder.getCacheName() != null) n = holder.getCacheName();
-			else 												 n = "name???";
+			if (holder != null && holder.getWayPoint() != null)
+				wp = holder.getWayPoint();
+			else
+				wp = "WP???";
+			if (holder != null && holder.getCacheName() != null)
+				n = holder.getCacheName();
+			else
+				n = "name???";
 
-			if (e == null) ErrMessage = "Ignoring error: OCXMLImporter.getPic: IOExeption == null, while downloading picture: "+fileName+" from URL:"+imageInfo.getURL();
+			if (e == null)
+				ErrMessage = "Ignoring error: OCXMLImporter.getPic: IOExeption == null, while downloading picture: " + fileName + " from URL:" + imageInfo.getURL();
 			else {
-				if (e.getMessage().equalsIgnoreCase("could not connect") ||
-						e.getMessage().equalsIgnoreCase("unkown host")) {
+				if (e.getMessage().equalsIgnoreCase("could not connect") || e.getMessage().equalsIgnoreCase("unkown host")) {
 					// is there a better way to find out what happened?
-					ErrMessage = MyLocale.getMsg(1618,"Ignoring error in cache: ")+ n + " ("+wp+")"+MyLocale.getMsg(1619,": could not download image from URL: ")+imageInfo.getURL();
+					ErrMessage = MyLocale.getMsg(1618, "Ignoring error in cache: ") + n + " (" + wp + ")" + MyLocale.getMsg(1619, ": could not download image from URL: ") + imageInfo.getURL();
 				} else
-					ErrMessage = MyLocale.getMsg(1618,"Ignoring error in cache: ")+ n + " ("+wp+"): ignoring IOException: "+e.getMessage()+ " while downloading picture:"+fileName+" from URL:"+imageInfo.getURL();
+					ErrMessage = MyLocale.getMsg(1618, "Ignoring error in cache: ") + n + " (" + wp + "): ignoring IOException: " + e.getMessage() + " while downloading picture:" + fileName + " from URL:" + imageInfo.getURL();
 			}
-			pref.log(ErrMessage,e,true);
+			pref.log(ErrMessage, e, true);
 		}
 
 	}

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-18 07:45:09 UTC (rev 3006)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-18 14:06:48 UTC (rev 3007)
@@ -357,10 +357,8 @@
 		infB = new InfoBox("Status", MyLocale.getMsg(5502, "Fetching pages..."));
 		infB.exec();
 
-		if (!loggedIn || pref.forceLogin) {
-			if (login() != FormBase.IDOK)
-				return;
-		}
+		if (!login())
+			return;
 
 		// Reset states for all caches when spidering
 		// (http://tinyurl.com/dzjh7p)
@@ -538,16 +536,14 @@
 				ch.initStates(false);
 		}
 
-		double halfSideLength = maxDistance; // halbe Seitenl??nge eines Quadrats
+		double halfSideLength = maxDistance; // halbe Seitenl????nge eines Quadrats
 												// ums Zentrum in km
 		if (pref.metricSystem == Metrics.IMPERIAL) {
 			halfSideLength = Metrics.convertUnit(maxDistance, Metrics.MILES, Metrics.KILOMETER);
 		}
 
-		if (!loggedIn || pref.forceLogin) {
-			if (login() != FormBase.IDOK)
-				return;
-		}
+		if (!login())
+			return;
 
 		page_number = 0;
 		num_added = 0;
@@ -777,10 +773,8 @@
 	}
 
 	private Hashtable fillDownloadLists(int maxNew, int maxUpdate, double toDistance, double fromDistance, String[] directions, Hashtable cExpectedForUpdate) {
-		if (!loggedIn || pref.forceLogin) {
-			if (login() != FormBase.IDOK)
-				return null;
-		}
+		if (!login())
+			return null;
 
 		int numFinds;
 		int startPage = 1;
@@ -1038,12 +1032,8 @@
 			return -1; // No point re-spidering an addi waypoint, comes with
 						// parent
 
-		// check if we need to login
-		if (!loggedIn || forceLogin) {
-			if (this.login() != FormBase.IDOK)
-				return -1;
-			// loggedIn is already set by this.login()
-		}
+		if (!login())
+			return -1;
 		try {
 			// Read the cache data from GC.COM and compare to old data
 			ret = getCacheByWaypointName(ch, true, pref.downloadPics, pref.downloadTBs, false, loadAllLogs);
@@ -1089,11 +1079,8 @@
 		// Check whether spider definitions could be loaded, if not issue
 		// appropriate message and terminate
 		// Try to login. If login fails, issue appropriate message and terminate
-		if (!loggedIn || pref.forceLogin) {
-			if (login() != FormBase.IDOK) {
-				return "";
-			}
-		}
+		if (!login())
+			return "";
 		final InfoBox localInfB = new InfoBox("Info", "Loading", InfoBox.PROGRESS_WITH_WARNINGS);
 		localInfB.exec();
 		try {
@@ -1116,21 +1103,24 @@
 	/**
 	 * Method to login the user to gc.com It will request a password and use the alias defined in preferences If the login page cannot be fetched, the password is cleared. If the login fails, an appropriate message is displayed.
 	 */
-	private int login() {
+	private boolean login() {
+		if (loggedIn && !pref.forceLogin) {
+			return true;
+		}
 		if (pref.userID.length() > 0) {
 			UrlFetcher.setPermanentRequestorProperty("Cookie", null);
 			loggedIn = switchToEnglish();
 			if (loggedIn)
-				return FormBase.IDOK;
+				return true;
 			else {
 				(new MessageBox("Login", "Check UserID in preferences | Einstellungen.", FormBase.OKB)).execute();
-				return ERR_LOGIN;
+				return false;
 			}
 		} else {
 			UrlFetcher.setPermanentRequestorProperty("Cookie", null);
 			if (true) {
 				(new MessageBox("Login", "Check UserID in preferences| Einstellungen.", FormBase.OKB)).execute();
-				return ERR_LOGIN; // until SSL/https works
+				return false; // until SSL/https works
 			}
 		}
 		loggedIn = false;
@@ -1139,7 +1129,7 @@
 			loginPageUrl = p.getProp("loginPage");
 			loginSuccess = p.getProp("loginSuccess");
 		} catch (final Exception ex) { // Tag not found in spider.def
-			return ERR_LOGIN;
+			return false;
 		}
 
 		// **0 Get password
@@ -1154,7 +1144,7 @@
 		}
 		localInfB.close(0);
 		if (code != FormBase.IDOK)
-			return code;
+			return false;
 
 		// **1 now we have user and password for login
 		localInfB = new InfoBox(MyLocale.getMsg(5507, "Status"), MyLocale.getMsg(5508, "Logging in..."));
@@ -1165,13 +1155,13 @@
 				localInfB.close(0);
 				(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5499, "Error loading login page.%0aPlease check your internet connection."), FormBase.OKB)).execute();
 				pref.log("[login]:Could not fetch: gc.com login page " + loginPageUrl, null);
-				return ERR_LOGIN;
+				return false;
 			}
 		} catch (final Exception ex) {
 			localInfB.close(0);
 			(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5499, "Error loading login page.%0aPlease check your internet connection."), FormBase.OKB)).execute();
 			pref.log("[login]:Could not fetch: gc.com login page", ex);
-			return ERR_LOGIN;
+			return false;
 		}
 
 		// **2 now we can check the loginpage if logged in else log in
@@ -1189,7 +1179,7 @@
 						localInfB.close(0);
 						(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5499, "Error loading login page.%0aPlease check your internet connection."), FormBase.OKB)).execute();
 						pref.log("[login]:Could not fetch: gc.com login page", ex);
-						return ERR_LOGIN;
+						return false;
 					}
 
 				}
@@ -1206,7 +1196,7 @@
 						pref.log("[login]:__VIEWSTATE not found (before login): no login possible.", null);
 						// we need the __VIEWSTATE for sending loginData, so we
 						// should abort here
-						return ERR_LOGIN;
+						return false;
 					}
 					final StringBuffer sb = new StringBuffer(1000);
 					sb.append("__VIEWSTATE=" + URL.encodeURL(viewstate, false));
@@ -1239,7 +1229,7 @@
 						} else {
 							localInfB.close(0);
 							pref.log("[login]:SessionID not found.", null);
-							return ERR_LOGIN;
+							return false;
 						}
 						final Regex rexCookieID = new Regex("(?i)userid=(.*?);.*");
 						rexCookieID.search(docprops);
@@ -1248,7 +1238,7 @@
 						} else {
 							localInfB.close(0);
 							pref.log("[login]:userID not found.", null);
-							return ERR_LOGIN;
+							return false;
 						}
 						UrlFetcher.setPermanentRequestorProperty("Cookie", cookie);
 					} else {
@@ -1258,15 +1248,15 @@
 						pref.log("[login.Answer]:" + loginPage, null);
 						localInfB.close(0);
 						(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5501, "Login failed! Wrong account or password?"), FormBase.OKB)).execute();
-						return ERR_LOGIN;
+						return false;
 					}
 					if (!this.switchToEnglish())
-						return ERR_LOGIN;
+						return false;
 				} catch (final Exception ex) {
 					pref.log("[login]:Login failed with exception.", ex);
 					localInfB.close(0);
 					(new MessageBox(MyLocale.getMsg(5500, "Error"), MyLocale.getMsg(5501, "Login failed. Error loading page after login."), FormBase.OKB)).execute();
-					return ERR_LOGIN;
+					return false;
 				}
 			}
 		}
@@ -1274,10 +1264,10 @@
 		final boolean loginAborted = localInfB.isClosed;
 		localInfB.close(0);
 		if (loginAborted)
-			return FormBase.IDCANCEL;
+			return false;
 		else {
 			loggedIn = true;
-			return FormBase.IDOK;
+			return true;
 		}
 	}
 
@@ -1285,7 +1275,6 @@
 		// change language to EN , further operations relay on English
 		String url = "http://www.geocaching.com/default.aspx";
 		String page = "";
-		String loggedInEnglish = ">Sign Out<";
 		String userID = "userid=" + pref.userID;
 		try {
 			UrlFetcher.setPermanentRequestorProperty("Cookie", userID);
@@ -1319,26 +1308,31 @@
 		} catch (IOException e) {
 			return false;
 		}
-		if (page.indexOf(loggedInEnglish) > -1) {
+		Extractor ext = new Extractor(page, "<a href=\"#\">", "&#9660;</a>", 0, true);
+		String oldLanguage = ext.findNext();
+		if (oldLanguage.equals("English")) {
 			pref.log("already English");
 			pref.oldLanguageCtl = ""; // nothing to reset
 			return true;
 		}
 		// switch to english now goes into gc account Display Preferences (is permanent, must be reset)
-		String languages[] = { "English", "Deutsch", "Fran??ais", "Portugu??s", "??e??tina", "Svenska", "Nederlands", "Catal??", "Polski", "Eesti", "Norsk, Bokm??l", "?????????", "Espa??ol" };
-		String oldLanguage = new Extractor(page, "<a href=\"#\">", "&#9660;</a>", 0, true).findNext();
+		// todo as long as Textfile Encoding is CP1252 we compare with substring(1) and think koreanisch if no merge at all
+		String languages[] = { "English", "Deutsch", "Fran?ais", "Portugu?s", "Ce?tina", "Svenska", "Nederlands", "Catal?", "Polski", "Eesti", "Norsk, Bokm?l", "???", "Espa?ol" };
 		for (int i = 0; i < languages.length; i++) {
-			if (oldLanguage.equals(languages[i])) {
+			if (oldLanguage.substring(1).equals(languages[i].substring(1))) {
 				pref.oldLanguageCtl = url + "?__EVENTTARGET=" + UrlFetcher.encodeURL("ctl00$uxLocaleList$uxLocaleList$ctl" + MyLocale.formatLong(i, "00") + "$uxLocaleItem", false);
 				break;
 			}
 		}
+		if (pref.oldLanguageCtl.length() == 0) {
+			// koreanisch
+			pref.oldLanguageCtl = url + "?__EVENTTARGET=" + UrlFetcher.encodeURL("ctl00$uxLocaleList$uxLocaleList$ctl" + "11" + "$uxLocaleItem", false);
+		}
 		final String strEnglishPage = "ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem";
 		url += "?__EVENTTARGET=" + UrlFetcher.encodeURL(strEnglishPage, false);
 		try {
 			page = UrlFetcher.fetch(url);
-			// String s = new Extractor(page, "<a href=\"#\">", "&#9660;</a>", 0, true).findNext();
-			if (page.indexOf(loggedInEnglish) > -1) {
+			if (ext.findFirst(page).equals("English")) {
 				pref.log("Switched to English");
 				return true;
 			} else {
@@ -1532,16 +1526,13 @@
 				ch.initStates(false);
 		}
 
-		double halfSideLength = maxDistance; // halbe Seitenl??nge eines Quadrats ums Zentrum in km
+		double halfSideLength = maxDistance; // halbe Seitenl????nge eines Quadrats ums Zentrum in km
 		if (pref.metricSystem == Metrics.IMPERIAL) {
 			halfSideLength = Metrics.convertUnit(maxDistance, Metrics.MILES, Metrics.KILOMETER);
 		}
+		if (!login())
+			return;
 
-		if (!loggedIn || pref.forceLogin) {
-			if (login() != FormBase.IDOK)
-				return;
-		}
-
 		page_number = 0;
 		num_added = 0;
 
@@ -1697,46 +1688,34 @@
 
 	private void addCacheNewMap(String page, CWPoint p, boolean setCachesToLoad) {
 
-		final int WpIndex = page.indexOf("\"gc\":");
-		final String[] elements = mString.split(page.substring(WpIndex), '\"');
-		if (elements.length != 63) {
-			(new MessageBox(MyLocale.getMsg(5500, "Error"), "GC changed format of new Map Infos", FormBase.OKB)).execute();
-			return;
-		}
-		final int posWP = 3; // gc
-		// final int posWPGuid = 7; // g
-		final int posDisabled = 10; // disabled
-		final int posPM = 12; // PM - Cache
-		// final int posLI = 14; // who knows
-		final int posDiff = 18; // difficulty
-		final int posTerr = 26; // terrain
-		final int posHidden = 33; // hidden date
-		final int posSize = 39; // size oder 43
-		final int posType = 52; // type 49 , 52
-		final int posOwner = 57; // owner
-		// final int posOwnerGUID = 61; // guid
+		Extractor ext = new Extractor(page, "{\"name\":\"", "\",", 0, true);
+		String cacheName = ext.findNext(); // Text
+		String wp = ext.findNext("\"gc\":\""); // Text
+		String disabled = ext.findNext("\"disabled\":", ","); // true/false
+		String subrOnly = ext.findNext("\"subrOnly\":"); // true/false
+		ext.findNext("\"li\":"); // true/false (not used, what is that)
+		ext.findNext("\"fp\":"); // int (favorite points)
+		String difficulty = ext.findNext("\"text\":"); // double
+		String terrain = ext.findNext(); // double;
+		String hidden = ext.findNext("\"hidden\":\"", "\","); // string Datum
+		String container = ext.findNext("\"text\":\""); // Text (Micro,...)
+		ext.findNext("\"value\":", "}"); // int dont remove
+		String type = ext.findNext("\"value\":", "}"); // int
+		String owner = ext.findNext("text\":\"", "\","); // Text
 
-		// final boolean found = (elements[posFound].indexOf("true") > -1 ? true
-		// : false);
-		// if (found && doNotgetFound) return;
-
-		final byte cacheType = CacheType.gcSpider2CwType(elements[posType].substring(1, elements[posType].length() - 2));
+		final byte cacheType = CacheType.gcSpider2CwType(type);
 		if (restrictedCacheType != CacheType.CW_TYPE_ERROR) {
 			if (restrictedCacheType != cacheType)
 				return;
 		}
-		boolean pm = elements[posPM].indexOf("false") > -1 ? false : true;
-		// boolean li = elements[posLI].indexOf("true") > -1 ? false : true;
-		String wp = elements[posWP];
 		CacheHolder ch = cacheDB.get(wp);
 		if (ch == null) {
-
 			ch = new CacheHolder();
 			ch.setWayPoint(wp);
+			boolean pm = subrOnly.equals("false") ? false : true;
 			if (pm && !pref.isPremium)
 				ch.setCacheStatus("PM");
 			ch.pos = p;
-			final String owner = elements[posOwner];
 			ch.setCacheOwner(owner);
 			// wird nicht mehr geliefert , todo aus Grafik extrahieren.
 			if (owner.equals(pref.myAlias) || owner.equals(pref.myAlias2)) {
@@ -1748,15 +1727,13 @@
 				}
 			}
 
-			final int NameIndex = page.indexOf("\"name\":\"");
-			String cacheName = page.substring(NameIndex + 8, WpIndex - 2);
 			cacheName = STRreplace.replace(cacheName, "\\\"", "\"");
 			ch.setCacheName(cacheName);
-			ch.setAvailable((elements[posDisabled].indexOf("true") > -1 ? false : true));
-			ch.setDateHidden(DateFormat.toYYMMDD(elements[posHidden]));
-			ch.setHard(CacheTerrDiff.v1Converter(elements[posDiff].substring(1, elements[posDiff].length() - 1)));
-			ch.setTerrain(CacheTerrDiff.v1Converter(elements[posTerr].substring(1, elements[posTerr].length() - 1)));
-			ch.setCacheSize(CacheSize.gcGpxString2Cw(elements[posSize]));
+			ch.setAvailable(disabled.equals("true") ? false : true);
+			ch.setDateHidden(DateFormat.toYYMMDD(hidden));
+			ch.setHard(CacheTerrDiff.v1Converter(difficulty));
+			ch.setTerrain(CacheTerrDiff.v1Converter(terrain));
+			ch.setCacheSize(CacheSize.gcGpxString2Cw(container));
 			ch.setType(cacheType);
 			num_added++;
 			cacheDB.add(ch);
@@ -1915,8 +1892,8 @@
 			if (ret.indexOf("ere") > -1)
 				return distanceAndDirection; // zur Zeit " Here -1"
 			// Versuch den DistanceCodeKey automatisch zu bestimmen
-			// da dieser von gc mal wieder ge??ndert wurde.
-			// todo Ben??tigt ev noch weitere Anpassungen: | am Anfang, and calc
+			// da dieser von gc mal wieder ge????ndert wurde.
+			// todo Ben????tigt ev noch weitere Anpassungen: | am Anfang, and calc
 			// of keylength
 
 			// String thereitis="|0.34 km|102.698";
@@ -1949,8 +1926,8 @@
 			}
 			final String coded = ewe.net.URL.decodeURL(RexPropDistanceCode.stringMatched(1));
 			final String newkey = decodeXor(coded, thereitis);
-			final int keylength = 13; // wenn nicht 13 dann newkey auf
-										// wiederholung pr??fen
+			final int keylength = 13;
+			// wenn nicht 13 dann newkey auf wiederholung pr????fen
 			DistanceCodeKey = newkey.substring(0, keylength);
 			ret = decodeXor(stmp, DistanceCodeKey).replace('|', ' ');
 			pref.log("Automatic key: " + DistanceCodeKey + " result: " + ret + Preferences.NEWLINE);
@@ -1960,17 +1937,8 @@
 		if (RexPropDistance.didMatch()) {
 			if (MyLocale.getDigSeparator().equals(",")) {
 				distanceAndDirection[0] = Convert.toDouble(RexPropDistance.stringMatched(1).replace('.', ','));
-				final String r = RexPropDistance.right(1).substring(3); // 3
-																		// expexts
-																		// 2
-																		// char
-																		// which
-																		// are
-																		// at
-																		// moment
-																		// "km"
-																		// or
-																		// "mi"
+				final String r = RexPropDistance.right(1).substring(3);
+				// 3 expexts 2 char which are at moment "km" or "mi"
 				distanceAndDirection[1] = Convert.toDouble(r.replace('.', ','));
 			} else {
 				distanceAndDirection[0] = Convert.toDouble(RexPropDistance.stringMatched(1));
@@ -2687,29 +2655,26 @@
 		}
 		final String LogBlock = RexLogBlock.stringMatched(1);
 
-		exSingleLog.setSource(LogBlock);
-		singleLog = exSingleLog.findNext();
-
-		exIcon.setSource(singleLog);
-		exNameTemp.setSource(singleLog);
-		exName.setSource(exNameTemp.findNext());
-		exDate.setSource(singleLog);
-		exLog.setSource(singleLog);
-		exLogId.setSource(singleLog);
+		exSingleLog.set(LogBlock);
 		int nLogs = 0;
 		boolean foundown = false;
-		while (!exSingleLog.endOfSearch()) {
-			// pref.log(singleLog);
+		while ((singleLog = exSingleLog.findNext()).length() > 0) {
 			nLogs++;
-			icon = exIcon.findNext();
+
+			icon = exIcon.findFirst(singleLog);
 			// ' changes to " in UMTS-connection! first char in iconExEnd.
 			icon = icon.substring(0, icon.length() - 1);
-			name = exName.findNext();
-			logText = exLog.findNext();
+
+			name = exName.findFirst(exNameTemp.findFirst(singleLog));
+
+			logText = exLog.findFirst(singleLog);
 			logText = correctSmilies(logText);
-			logId = exLogId.findNext();
-			final String ed = exDate.findNext();
+
+			logId = exLogId.findFirst(singleLog);
+
+			final String ed = exDate.findFirst(singleLog);
 			final String d = DateFormat.toYYMMDD(ed);
+
 			// if this log says this Cache is found by me
 			if ((icon.equals(icon_smile) || icon.equals(icon_camera) || icon.equals(icon_attended)) && (name.equalsIgnoreCase(SafeXML.clean(pref.myAlias)) || (pref.myAlias2.length() > 0 && name.equalsIgnoreCase(SafeXML.clean(pref.myAlias2))))) {
 				chD.getParent().setFound(true);
@@ -2726,13 +2691,6 @@
 					break;
 				}
 			}
-			singleLog = exSingleLog.findNext();
-			exIcon.setSource(singleLog);
-			exNameTemp.setSource(singleLog);
-			exName.setSource(exNameTemp.findNext());
-			exDate.setSource(singleLog);
-			exLog.setSource(singleLog);
-			exLogId.setSource(singleLog);
 		}
 		if (nLogs > pref.maxLogsToSpider) {
 			reslts.add(Log.maxLog());
@@ -2768,38 +2726,39 @@
 	 */
 	public void getBugs(CacheHolderDetail chD, String doc) throws Exception {
 		final Extractor exBlock = new Extractor(doc, p.getProp("blockExStart"), p.getProp("blockExEnd"), 0, Extractor.EXCLUDESTARTEND);
-		final String bugBlock = exBlock.findNext();
-		final Extractor exBug = new Extractor(bugBlock, p.getProp("bugExStart"), p.getProp("bugExEnd"), 0, Extractor.EXCLUDESTARTEND);
-		String link, bug, linkPlusBug, bugDetails;
-		final String oldInfoBox = infB.getInfo();
-		chD.Travelbugs.clear();
-		while (!exBug.endOfSearch()) {
-			if (infB.isClosed)
-				break; // Allow user to cancel by closing progress form
-			linkPlusBug = exBug.findNext();
-			final int idx = linkPlusBug.indexOf(p.getProp("bugLinkEnd"));
-			if (idx < 0)
-				break; // No link/bug pair found
-			link = linkPlusBug.substring(0, idx);
-			final Extractor exBugName = new Extractor(linkPlusBug, p.getProp("bugNameExStart"), p.getProp("bugNameExEnd"), 0, Extractor.EXCLUDESTARTEND);
-			bug = exBugName.findNext();
-			if (bug.length() > 0) { // Found a bug, get its details
-				final Travelbug tb = new Travelbug(bug);
-				try {
-					infB.setInfo(oldInfoBox + MyLocale.getMsg(5514, "\nGetting bug: ") + SafeXML.cleanback(bug));
-					bugDetails = UrlFetcher.fetch(link);
-					pref.log("[getBugs] Fetched TB details: " + bug);
-					final Extractor exDetails = new Extractor(bugDetails, p.getProp("bugDetailsStart"), p.getProp("bugDetailsEnd"), 0, Extractor.EXCLUDESTARTEND);
-					tb.setMission(exDetails.findNext());
-					final Extractor exGuid = new Extractor(bugDetails, "action=\"details.aspx?guid=", "\" id=\"aspnetForm", 0, Extractor.EXCLUDESTARTEND);
-					tb.setGuid(exGuid.findNext());
-					chD.Travelbugs.add(tb);
-				} catch (final Exception ex) {
-					pref.log("[getBugs] Could not fetch bug details", ex);
+		final String bugBlock;
+		if ((bugBlock = exBlock.findNext()).length() > 0) {
+			String link, bug, linkPlusBug, bugDetails;
+			final String oldInfoBox = infB.getInfo();
+			chD.Travelbugs.clear();
+			final Extractor exBug = new Extractor(bugBlock, p.getProp("bugExStart"), p.getProp("bugExEnd"), 0, Extractor.EXCLUDESTARTEND);
+			while ((linkPlusBug = exBug.findNext()).length() > 0) {
+				if (infB.isClosed)
+					break;
+				final int idx = linkPlusBug.indexOf(p.getProp("bugLinkEnd"));
+				if (idx < 0)
+					break; // No link/bug pair found
+				link = linkPlusBug.substring(0, idx);
+				final Extractor exBugName = new Extractor(linkPlusBug, p.getProp("bugNameExStart"), p.getProp("bugNameExEnd"), 0, Extractor.EXCLUDESTARTEND);
+				if ((bug = exBugName.findNext()).length() > 0) {
+					// Found a bug, get its details
+					final Travelbug tb = new Travelbug(bug);
+					try {
+						infB.setInfo(oldInfoBox + MyLocale.getMsg(5514, "\nGetting bug: ") + SafeXML.cleanback(bug));
+						bugDetails = UrlFetcher.fetch(link);
+						pref.log("[getBugs] Fetched TB details: " + bug);
+						final Extractor exDetails = new Extractor(bugDetails, p.getProp("bugDetailsStart"), p.getProp("bugDetailsEnd"), 0, Extractor.EXCLUDESTARTEND);
+						tb.setMission(exDetails.findNext());
+						final Extractor exGuid = new Extractor(bugDetails, "action=\"details.aspx?guid=", "\" id=\"aspnetForm", 0, Extractor.EXCLUDESTARTEND);
+						tb.setGuid(exGuid.findNext());
+						chD.Travelbugs.add(tb);
+					} catch (final Exception ex) {
+						pref.log("[getBugs] Could not fetch bug details", ex);
+					}
 				}
 			}
+			infB.setInfo(oldInfoBox);
 		}
-		infB.setInfo(oldInfoBox);
 	}
 
 	/**
@@ -2840,56 +2799,52 @@
 			return;
 		}
 		String tst;
-		tst = exImgBlock.findNext();
-		Extractor exImgSrc = new Extractor(tst, "http://", "\"", 0, true);
-		while (exImgBlock.endOfSearch() == false) {
-			imgUrl = exImgSrc.findNext();
-			if (imgUrl.length() > 0) {
-				// Optimize: img.groundspeak.com -> img.geocaching.com (for
-				// better caching purposes)
-				imgUrl = CacheImages.optimizeLink("http://" + imgUrl);
-				try {
-					imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + "    ").substring(0, 4).trim();
-					// imgType is now max 4 chars, starting with .
-					if (imgType.startsWith(".png") || imgType.startsWith(".jpg") || imgType.startsWith(".gif")) {
-						// Check whether image was already spidered for this
-						// cache
-						idxUrl = spideredUrls.find(imgUrl);
-						imgName = chD.getParent().getWayPoint() + "_" + Convert.toString(imgCounter);
-						imageInfo = null;
-						if (idxUrl < 0) { // New image
-							fileName = chD.getParent().getWayPoint().toLowerCase() + "_" + Convert.toString(spiderCounter);
-							if (lastImages != null) {
-								imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
-							}
-							if (imageInfo == null) {
-								imageInfo = new ImageInfo();
-								pref.log("[getImages] Loading image: " + imgUrl + " as " + fileName + imgType);
-								spiderImage(imgUrl, fileName + imgType);
-								imageInfo.setFilename(fileName + imgType);
-								imageInfo.setURL(imgUrl);
-							} else {
-								pref.log("[getImages] Already exising image: " + imgUrl + " as " + imageInfo.getFilename());
-							}
-							spideredUrls.add(imgUrl);
-							spiderCounter++;
-						} else { // Image already spidered as wayPoint_'idxUrl'
-							fileName = chD.getParent().getWayPoint().toLowerCase() + "_" + Convert.toString(idxUrl);
-							pref.log("[getImages] Already loaded image: " + imgUrl + " as " + fileName + imgType);
+		Extractor exImgSrc = new Extractor("", "http://", "\"", 0, true);
+		while ((tst = exImgBlock.findNext()).length() > 0) {
+			// Optimize: img.groundspeak.com -> img.geocaching.com (for
+			// better caching purposes)
+			imgUrl = exImgSrc.findFirst(tst);
+			imgUrl = CacheImages.optimizeLink("http://" + imgUrl);
+			try {
+				imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + "    ").substring(0, 4).trim();
+				// imgType is now max 4 chars, starting with .
+				if (imgType.startsWith(".png") || imgType.startsWith(".jpg") || imgType.startsWith(".gif")) {
+					// Check whether image was already spidered for this
+					// cache
+					idxUrl = spideredUrls.find(imgUrl);
+					imgName = chD.getParent().getWayPoint() + "_" + Convert.toString(imgCounter);
+					imageInfo = null;
+					if (idxUrl < 0) { // New image
+						fileName = chD.getParent().getWayPoint().toLowerCase() + "_" + Convert.toString(spiderCounter);
+						if (lastImages != null) {
+							imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
+						}
+						if (imageInfo == null) {
 							imageInfo = new ImageInfo();
+							pref.log("[getImages] Loading image: " + imgUrl + " as " + fileName + imgType);
+							spiderImage(imgUrl, fileName + imgType);
 							imageInfo.setFilename(fileName + imgType);
 							imageInfo.setURL(imgUrl);
+						} else {
+							pref.log("[getImages] Already exising image: " + imgUrl + " as " + imageInfo.getFilename());
 						}
-						imageInfo.setTitle(imgName);
-						imageInfo.setComment(null);
-						imgCounter++;
-						chD.images.add(imageInfo);
+						spideredUrls.add(imgUrl);
+						spiderCounter++;
+					} else { // Image already spidered as wayPoint_'idxUrl'
+						fileName = chD.getParent().getWayPoint().toLowerCase() + "_" + Convert.toString(idxUrl);
+						pref.log("[getImages] Already loaded image: " + imgUrl + " as " + fileName + imgType);
+						imageInfo = new ImageInfo();
+						imageInfo.setFilename(fileName + imgType);
+						imageInfo.setURL(imgUrl);
 					}
-				} catch (final IndexOutOfBoundsException e) {
-					pref.log("[getImages] Problem loading image. imgURL:" + imgUrl, e);
+					imageInfo.setTitle(imgName);
+					imageInfo.setComment(null);
+					imgCounter++;
+					chD.images.add(imageInfo);
 				}
+			} catch (final IndexOutOfBoundsException e) {
+				pref.log("[getImages] Problem loading image. imgURL:" + imgUrl, e);
 			}
-			exImgSrc.setSource(exImgBlock.findNext());
 		}
 		// ========
 		// In the image span
@@ -2904,101 +2859,97 @@
 		} catch (final Exception ex) {
 			return;
 		}
-		while (!exImgSrc.endOfSearch()) {
-			imgUrl = exImgSrc.findNext();
+		while ((imgUrl = exImgSrc.findNext()).length() > 0) {
 			imgComment = exImgComment.findNext();
-			if (imgUrl.length() > 0) {
-				imgUrl = "http://" + imgUrl;
-				try {
-					imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + "    ").substring(0, 4).trim();
-					// imgType is now max 4 chars, starting with .
-					if (imgType.startsWith(".png") || imgType.startsWith(".jpg") || imgType.startsWith(".gif")) {
-						// Check whether image was already spidered for this
-						// cache
-						idxUrl = spideredUrls.find(imgUrl);
-						imgName = chD.getParent().getWayPoint() + "_" + Convert.toString(imgCounter);
-						imageInfo = null;
-						if (idxUrl < 0) { // New image
-							fileName = chD.getParent().getWayPoint().toLowerCase() + "_" + Convert.toString(spiderCounter);
-							if (lastImages != null) {
-								imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
-							}
-							if (imageInfo == null) {
-								imageInfo = new ImageInfo();
-								pref.log("[getImages] Loading image: " + imgUrl + " as " + fileName + imgType);
-								spiderImage(imgUrl, fileName + imgType);
-								imageInfo.setFilename(fileName + imgType);
-								imageInfo.setURL(imgUrl);
-							} else {
-								pref.log("[getImages] Already exising image: " + imgUrl + " as " + imageInfo.getFilename());
-							}
-							spideredUrls.add(imgUrl);
-							spiderCounter++;
-						} else { // Image already spidered as wayPoint_'idxUrl'
-							fileName = chD.getParent().getWayPoint().toLowerCase() + "_" + Convert.toString(idxUrl);
-							pref.log("[getImages] Already loaded image: " + imgUrl + " as " + fileName + imgType);
+			imgUrl = "http://" + imgUrl;
+			try {
+				imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + "    ").substring(0, 4).trim();
+				// imgType is now max 4 chars, starting with .
+				if (imgType.startsWith(".png") || imgType.startsWith(".jpg") || imgType.startsWith(".gif")) {
+					// Check whether image was already spidered for this
+					// cache
+					idxUrl = spideredUrls.find(imgUrl);
+					imgName = chD.getParent().getWayPoint() + "_" + Convert.toString(imgCounter);
+					imageInfo = null;
+					if (idxUrl < 0) { // New image
+						fileName = chD.getParent().getWayPoint().toLowerCase() + "_" + Convert.toString(spiderCounter);
+						if (lastImages != null) {
+							imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
+						}
+						if (imageInfo == null) {
 							imageInfo = new ImageInfo();
+							pref.log("[getImages] Loading image: " + imgUrl + " as " + fileName + imgType);
+							spiderImage(imgUrl, fileName + imgType);
 							imageInfo.setFilename(fileName + imgType);
 							imageInfo.setURL(imgUrl);
+						} else {
+							pref.log("[getImages] Already exising image: " + imgUrl + " as " + imageInfo.getFilename());
 						}
-						imageInfo.setTitle(exImgName.findNext());
-						while (imgComment.startsWith("<br />"))
-							imgComment = imgComment.substring(6);
-						while (imgComment.endsWith("<br />"))
-							imgComment = imgComment.substring(0, imgComment.length() - 6);
-						imageInfo.setComment(imgComment);
-						chD.images.add(imageInfo);
+						spideredUrls.add(imgUrl);
+						spiderCounter++;
+					} else { // Image already spidered as wayPoint_'idxUrl'
+						fileName = chD.getParent().getWayPoint().toLowerCase() + "_" + Convert.toString(idxUrl);
+						pref.log("[getImages] Already loaded image: " + imgUrl + " as " + fileName + imgType);
+						imageInfo = new ImageInfo();
+						imageInfo.setFilename(fileName + imgType);
+						imageInfo.setURL(imgUrl);
 					}
-				} catch (final IndexOutOfBoundsException e) {
-					pref.log("[getImages] IndexOutOfBoundsException in image span. imgURL:" + imgUrl, e);
+					imageInfo.setTitle(exImgName.findNext());
+					while (imgComment.startsWith("<br />"))
+						imgComment = imgComment.substring(6);
+					while (imgComment.endsWith("<br />"))
+						imgComment = imgComment.substring(0, imgComment.length() - 6);
+					imageInfo.setComment(imgComment);
+					chD.images.add(imageInfo);
 				}
+			} catch (final IndexOutOfBoundsException e) {
+				pref.log("[getImages] IndexOutOfBoundsException in image span. imgURL:" + imgUrl, e);
 			}
+
 		}
 		// ========
 		// Final sweep to check for images in hrefs
 		// ========
 		final Extractor exFinal = new Extractor(longDesc, "http://", "\"", 0, true);
-		while (!exFinal.endOfSearch()) {
-			imgUrl = exFinal.findNext();
-			if (imgUrl.length() > 0) {
-				// Optimize: img.groundspeak.com -> img.geocaching.com (for
-				// better caching purposes)
-				imgUrl = CacheImages.optimizeLink("http://" + imgUrl);
-				try {
-					imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + "    ").substring(0, 4).trim();
-					// imgType is now max 4 chars, starting with . Delete
-					// characters in URL after the image extension
-					imgUrl = imgUrl.substring(0, imgUrl.lastIndexOf('.') + imgType.length());
-					if (imgType.startsWith(".jpg") || imgType.startsWith(".bmp") || imgType.startsWith(".png") || imgType.startsWith(".gif")) {
-						// Check whether image was already spidered for this
-						// cache
-						idxUrl = spideredUrls.find(imgUrl);
-						if (idxUrl < 0) { // New image
-							imgName = chD.getParent().getWayPoint() + "_" + Convert.toString(imgCounter);
-							fileName = chD.getParent().getWayPoint().toLowerCase() + "_" + Convert.toString(spiderCounter);
-							if (lastImages != null) {
-								imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
-							}
-							if (imageInfo == null) {
-								imageInfo = new ImageInfo();
-								pref.log("[getImages] Loading image: " + imgUrl + " as " + fileName + imgType);
-								spiderImage(imgUrl, fileName + imgType);
-								imageInfo.setFilename(fileName + imgType);
-								imageInfo.setURL(imgUrl);
-							} else {
-								pref.log("[getImages] Already exising image: " + imgUrl + " as " + imageInfo.getFilename());
-							}
-							spideredUrls.add(imgUrl);
-							spiderCounter++;
-							imageInfo.setTitle(imgName);
-							imgCounter++;
-							chD.images.add(imageInfo);
+		while ((imgUrl = exFinal.findNext()).length() > 0) {
+			// Optimize: img.groundspeak.com -> img.geocaching.com (for
+			// better caching purposes)
+			imgUrl = CacheImages.optimizeLink("http://" + imgUrl);
+			try {
+				imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + "    ").substring(0, 4).trim();
+				// imgType is now max 4 chars, starting with . Delete
+				// characters in URL after the image extension
+				imgUrl = imgUrl.substring(0, imgUrl.lastIndexOf('.') + imgType.length());
+				if (imgType.startsWith(".jpg") || imgType.startsWith(".bmp") || imgType.startsWith(".png") || imgType.startsWith(".gif")) {
+					// Check whether image was already spidered for this
+					// cache
+					idxUrl = spideredUrls.find(imgUrl);
+					if (idxUrl < 0) { // New image
+						imgName = chD.getParent().getWayPoint() + "_" + Convert.toString(imgCounter);
+						fileName = chD.getParent().getWayPoint().toLowerCase() + "_" + Convert.toString(spiderCounter);
+						if (lastImages != null) {
+							imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
 						}
+						if (imageInfo == null) {
+							imageInfo = new ImageInfo();
+							pref.log("[getImages] Loading image: " + imgUrl + " as " + fileName + imgType);
+							spiderImage(imgUrl, fileName + imgType);
+							imageInfo.setFilename(fileName + imgType);
+							imageInfo.setURL(imgUrl);
+						} else {
+							pref.log("[getImages] Already exising image: " + imgUrl + " as " + imageInfo.getFilename());
+						}
+						spideredUrls.add(imgUrl);
+						spiderCounter++;
+						imageInfo.setTitle(imgName);
+						imgCounter++;
+						chD.images.add(imageInfo);
 					}
-				} catch (final IndexOutOfBoundsException e) {
-					pref.log("[getImages] Problem loading image. imgURL:" + imgUrl, e);
 				}
+			} catch (final IndexOutOfBoundsException e) {
+				pref.log("[getImages] Problem loading image. imgURL:" + imgUrl, e);
 			}
+
 		}
 	}
 
@@ -3038,96 +2989,90 @@
 
 	private void getAddWaypoints(String doc, String wayPoint, boolean is_found) throws Exception {
 		final Extractor exWayBlock = new Extractor(doc, p.getProp("wayBlockExStart"), p.getProp("wayBlockExEnd"), 0, false);
-		String wayBlock = "";
-		String rowBlock = "";
-		wayBlock = exWayBlock.findNext();
-		final Regex nameRex = new Regex(p.getProp("nameRex"));
-		final Regex koordRex = new Regex(p.getProp("koordRex"));
-		final Regex descRex = new Regex(p.getProp("descRex"));
-		final Regex typeRex = new Regex(p.getProp("typeRex"));
-		int counter = 0;
-		if (!exWayBlock.endOfSearch() && wayBlock.indexOf("No additional waypoints to display.") < 0) {
-			final Extractor exRowBlock = new Extractor(wayBlock, p.getProp("rowBlockExStart"), p.getProp("rowBlockExEnd"), 0, false);
-			rowBlock = exRowBlock.findNext();
-			rowBlock = exRowBlock.findNext();
-			while (!exRowBlock.endOfSearch()) {
-				CacheHolder hd = null;
+		String wayBlock;
+		if ((wayBlock = exWayBlock.findNext()).length() > 0) {
+			if (wayBlock.indexOf("No additional waypoints to display.") < 0) {
+				final Regex nameRex = new Regex(p.getProp("nameRex"));
+				final Regex koordRex = new Regex(p.getProp("koordRex"));
+				final Regex descRex = new Regex(p.getProp("descRex"));
+				final Regex typeRex = new Regex(p.getProp("typeRex"));
+				int counter = 0;
+				final Extractor exRowBlock = new Extractor(wayBlock, p.getProp("rowBlockExStart"), p.getProp("rowBlockExEnd"), 0, false);
+				String rowBlock;
+				rowBlock = exRowBlock.findNext();
+				while ((rowBlock = exRowBlock.findNext()).length() > 0) {
+					CacheHolder hd = null;
 
-				/*
-				 * String[] AddiBlock=mString.split(rowBlock,'\n'); int linePrefix=8; if(AddiBlock.length < linePrefix + 1) { (new MessageBox(MyLocale.getMsg(5500,"Error"), "GC changed table output \nCW must be changed too!", FormBase.OKB)).execute();
-				 * break; } String prefix=AddiBlock[linePrefix].trim();
-				 */
+					final Extractor exPrefix = new Extractor(rowBlock, p.getProp("prefixExStart"), p.getProp("prefixExEnd"), 0, true);
+					final String prefix = exPrefix.findNext();
+					String adWayPoint;
+					if (prefix.length() == 2)
+						adWayPoint = prefix + wayPoint.substring(2);
+					else
+						adWayPoint = MyLocale.formatLong(counter, "00") + wayPoint.substring(2);
+					counter++;
+					final int idx = profile.getCacheIndex(adWayPoint);
+					if (idx >= 0) {
+						// Creating new CacheHolder, but accessing old cache.xml file
+						hd = new CacheHolder();
+						hd.setWayPoint(adWayPoint);
+						// Accessing Details reads file if not yet done
+						hd.getCacheDetails(true);
+					} else {
+						hd = new CacheHolder();
+						hd.setWayPoint(adWayPoint);
+					}
+					hd.initStates(idx < 0);
 
-				// Extractor exPrefix=new
-				// Extractor(AddiBlock[linePrefix].trim(),p.getProp("prefixExStart"),p.getProp("prefixExEnd"),0,true);
-				final Extractor exPrefix = new Extractor(rowBlock, p.getProp("prefixExStart"), p.getProp("prefixExEnd"), 0, true);
-				final String prefix = exPrefix.findNext();
+					nameRex.search(rowBlock);
+					if (nameRex.didMatch()) {
+						hd.setCacheName(nameRex.stringMatched(1));
+					} else {
+						pref.log("check nameRex in spider.def" + Preferences.NEWLINE + rowBlock);
+					}
 
-				String adWayPoint;
-				if (prefix.length() == 2)
-					adWayPoint = prefix + wayPoint.substring(2);
-				else
-					adWayPoint = MyLocale.formatLong(counter, "00") + wayPoint.substring(2);
-				counter++;
-				final int idx = profile.getCacheIndex(adWayPoint);
-				if (idx >= 0) {
-					// Creating new CacheHolder, but accessing old cache.xml
-					// file
-					hd = new CacheHolder();
-					hd.setWayPoint(adWayPoint);
-					hd.getCacheDetails(true); // Accessing Details reads file if
-												// not yet done
-				} else {
-					hd = new CacheHolder();
-					hd.setWayPoint(adWayPoint);
-				}
-				hd.initStates(idx < 0);
-				nameRex.search(rowBlock);
-				if (nameRex.didMatch()) {
-					hd.setCacheName(nameRex.stringMatched(1));
-				} else {
-					pref.log("check nameRex in spider.def" + Preferences.NEWLINE + rowBlock);
-				}
-				koordRex.search(rowBlock);
-				typeRex.search(rowBlock);
-				if (koordRex.didMatch()) {
-					hd.setLatLon(koordRex.stringMatched(1));
-					koords_not_yet_found = false;
-				} else {
-					if (koords_not_yet_found) {
+					koordRex.search(rowBlock);
+					if (koordRex.didMatch()) {
+						hd.setLatLon(koordRex.stringMatched(1));
 						koords_not_yet_found = false;
-						pref.log("check koordRex in spider.def" + Preferences.NEWLINE + rowBlock);
+					} else {
+						if (koords_not_yet_found) {
+							koords_not_yet_found = false;
+							pref.log("check koordRex in spider.def" + Preferences.NEWLINE + rowBlock);
+						}
 					}
-				}
-				if (typeRex.didMatch()) {
-					hd.setType(CacheType.gpxType2CwType("Waypoint|" + typeRex.stringMatched(1)));
-				} else {
-					pref.log("check typeRex in spider.def" + Preferences.NEWLINE + rowBlock);
-				}
-				rowBlock = exRowBlock.findNext();
-				descRex.search(rowBlock);
-				if (descRex.didMatch()) {
-					hd.getCacheDetails(false).setLongDescription(descRex.stringMatched(1).trim());
-				} else {
-					pref.log("check descRex in spider.def" + Preferences.NEWLINE + rowBlock);
-				}
-				hd.setFound(is_found);
-				hd.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
-				hd.setHard(CacheTerrDiff.CW_DT_UNSET);
-				hd.setTerrain(CacheTerrDiff.CW_DT_UNSET);
-				if (idx < 0) {
-					cacheDB.add(hd);
-					hd.save();
-				} else {
-					final CacheHolder cx = cacheDB.get(idx);
-					final boolean checked = cx.is_Checked;
-					cx.initStates(false);
-					cx.update(hd);
-					cx.is_Checked = checked;
-					cx.save();
-				}
-				rowBlock = exRowBlock.findNext();
 
+					typeRex.search(rowBlock);
+					if (typeRex.didMatch()) {
+						hd.setType(CacheType.gpxType2CwType("Waypoint|" + typeRex.stringMatched(1)));
+					} else {
+						pref.log("check typeRex in spider.def" + Preferences.NEWLINE + rowBlock);
+					}
+
+					rowBlock = exRowBlock.findNext();
+					descRex.search(rowBlock);
+					if (descRex.didMatch()) {
+						hd.getCacheDetails(false).setLongDescription(descRex.stringMatched(1).trim());
+					} else {
+						pref.log("check descRex in spider.def" + Preferences.NEWLINE + rowBlock);
+					}
+					hd.setFound(is_found);
+					hd.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
+					hd.setHard(CacheTerrDiff.CW_DT_UNSET);
+					hd.setTerrain(CacheTerrDiff.CW_DT_UNSET);
+
+					if (idx < 0) {
+						cacheDB.add(hd);
+						hd.save();
+					} else {
+						final CacheHolder cx = cacheDB.get(idx);
+						final boolean checked = cx.is_Checked;
+						cx.initStates(false);
+						cx.update(hd);
+						cx.is_Checked = checked;
+						cx.save();
+					}
+				}
 			}
 		}
 	}
@@ -3136,11 +3081,10 @@
 		final Extractor attBlock = new Extractor(doc, p.getProp("attBlockExStart"), p.getProp("attBlockExEnd"), 0, true);
 		final String atts = attBlock.findNext();
 		final Extractor attEx = new Extractor(atts, p.getProp("attExStart"), p.getProp("attExEnd"), 0, true);
-		String attribute = attEx.findNext();
+		String attribute;
 		chD.attributes.clear();
-		while (!attEx.endOfSearch()) {
+		while ((attribute = attEx.findNext()).length() > 0) {
 			chD.attributes.add(attribute);
-			attribute = attEx.findNext();
 		}
 		chD.getParent().setAttribsAsBits(chD.attributes.getAttribsAsBits());
 	}

Modified: trunk/src/CacheWolf/navi/CWGPSPoint.java
===================================================================
--- trunk/src/CacheWolf/navi/CWGPSPoint.java	2011-05-18 07:45:09 UTC (rev 3006)
+++ trunk/src/CacheWolf/navi/CWGPSPoint.java	2011-05-18 14:06:48 UTC (rev 3007)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import org.json.JSONArray;
@@ -40,19 +40,18 @@
 import ewe.sys.TimerProc;
 import ewe.sys.Vm;
 
-
 /**
  * @author Kalle
- * Class for decoding NMEA sentences
+ *         Class for decoding NMEA sentences
  */
 
-public class CWGPSPoint extends CWPoint implements TimerProc{
+public class CWGPSPoint extends CWPoint implements TimerProc {
 	public static final int LOGNMEA = 0x01;
-	public static final int LOGRAW  = 0x02;
-	public static final int LOGALL  = LOGNMEA|LOGRAW;
+	public static final int LOGRAW = 0x02;
+	public static final int LOGALL = LOGNMEA | LOGRAW;
 
 	public double Speed; // Speed: km/h
-	public double Bear;	// Bearing
+	public double Bear; // Bearing
 	public String Time; // Time: HHmmss.SS
 	public String Date; // Date: ddMMyy
 	public int Fix; // Fix (0: none, 1: GPS, 2: differential GPS). See getFix() for more possible values.
@@ -61,7 +60,7 @@
 	public double HDOP; // Horizontal dilution of precision
 	public double Alt; // Altitude in meters
 
-	//Logging
+	// Logging
 	int logTimer = 0;
 	int logFlag = 0;
 	boolean writeLog = false;
@@ -69,15 +68,14 @@
 	FileWriter logFile;
 	String lastStrExamined = "";
 
-	//Regex numberMatcher = new Regex("\\-?\\d+");
+	// Regex numberMatcher = new Regex("\\-?\\d+");
 
-	public CWGPSPoint()
-	{
+	public CWGPSPoint() {
 		super();
 		this.Speed = 0;
 		this.Bear = 0;
 		this.Time = "";
-		this.Date="";
+		this.Date = "";
 		this.Fix = 0;
 		this.numSat = 0;
 		this.numSatsInView = 0;
@@ -85,29 +83,32 @@
 		this.HDOP = 0;
 	}
 
-
-	public double getSpeed(){
+	public double getSpeed() {
 		return this.Speed;
 	}
 
-	public double getBear (){
+	public double getBear() {
 		return this.Bear;
 	}
-	public String getTime(){
+
+	public String getTime() {
 		return this.Time;
 	}
 
 	/**
-	 * @return > 0: fixed <br> 0: not fixed <br> -1: no data from serial port <br> -2 data from serial port could not be interpreted
+	 * @return > 0: fixed <br>
+	 *         0: not fixed <br>
+	 *         -1: no data from serial port <br>
+	 *         -2 data from serial port could not be interpreted
 	 */
-	public int getFix(){
+	public int getFix() {
 		return this.Fix;
 	}
 
 	/**
 	 * this method should be called, if COM-Port is closed
 	 */
-	public void noData(){
+	public void noData() {
 		this.Fix = 0;
 		this.numSat = 0;
 		this.HDOP = 0;
@@ -116,7 +117,7 @@
 	/**
 	 * this method should be called, if not data is coming from COM-Port but is expected to come
 	 */
-	public void noDataError(){
+	public void noDataError() {
 		this.Fix = -1;
 		this.numSat = -1;
 		this.HDOP = -1;
@@ -125,13 +126,13 @@
 	/**
 	 * this method should be called, if examine returns for several calls that it couldn't interprete the data
 	 */
-	public void noInterpretableData(){
+	public void noInterpretableData() {
 		this.Fix = -2;
 		this.numSat = -2;
 		this.HDOP = -2;
 	}
 
-	public void ticked(int timerId, int elapsed){
+	public void ticked(int timerId, int elapsed) {
 		if (timerId == logTimer) {
 			writeLog = true;
 		}
@@ -139,23 +140,26 @@
 	}
 
 	/**
-	 *
-	 * @param logFileDir directory for logfile
-	 * @param seconds	 intervall for writing to logfile
-	 * @param flag		 level of logging
+	 * 
+	 * @param logFileDir
+	 *            directory for logfile
+	 * @param seconds
+	 *            intervall for writing to logfile
+	 * @param flag
+	 *            level of logging
 	 * @return 0 success, -1 failure
 	 */
-	public int startLog(String logFileDir, int seconds, int flag){
+	public int startLog(String logFileDir, int seconds, int flag) {
 
 		Time currTime = new Time();
 		currTime.getTime();
 		currTime.setFormat("yyyyMMdd'_'HHmm");
-		String logFileName = new String(logFileDir + currTime.toString()+ ".log");
+		String logFileName = new String(logFileDir + currTime.toString() + ".log");
 		// create Logfile
 		try {
 			logFile = new FileWriter(logFileName);
 		} catch (IOException e) {
-			Global.getPref().log("Error creating LogFile " + logFileName,e,true);
+			Global.getPref().log("Error creating LogFile " + logFileName, e, true);
 			return -1;
 		}
 		// start timer
@@ -168,10 +172,11 @@
 	public void stopLog() {
 		writeLog = false;
 
-		if (doLogging){
+		if (doLogging) {
 			try {
 				logFile.close();
-			} catch (IOException e) {/*Too lazy to do something */}
+			} catch (IOException e) {/* Too lazy to do something */
+			}
 			if (logTimer > 0) {
 				Vm.cancelTimer(logTimer);
 				logTimer = 0;
@@ -180,82 +185,107 @@
 		doLogging = false;
 	}
 
-
-	public int getSats(){
+	public int getSats() {
 		return this.numSat;
 	}
 
-	public int getSatsInView(){
+	public int getSatsInView() {
 		return this.numSatsInView;
 	}
 
-	public double getAlt(){
+	public double getAlt() {
 		return this.Alt;
 	}
 
-	public double getHDOP(){
+	public double getHDOP() {
 		return this.HDOP;
 	}
 
 	/**
 	 * Sets the attributes from a NMEA String
-	 * @param NMEA	string with data to examine
+	 * 
+	 * @param NMEA
+	 *            string with data to examine
 	 * @return true if some data could be interpreted false otherwise
 	 */
-	public boolean examine(String NMEA){
+	public boolean examine(String NMEA) {
 		boolean interpreted = false;
 		boolean logWritten = false;
 		try {
 			int i, start, end;
-			String latDeg="0", latMin="0", latNS="N";
-			String lonDeg="0", lonMin="0", lonEW="E";
+			String latDeg = "0", latMin = "0", latNS = "N";
+			String lonDeg = "0", lonMin = "0", lonEW = "E";
 			String currToken;
 			end = 0;
 			lastStrExamined = NMEA;
-			while(true){
+			while (true) {
 				start = NMEA.indexOf("$GP", end);
-				if (start == -1) break;
+				if (start == -1)
+					break;
 				end = NMEA.indexOf("*", start);
-				if ((end == -1)||(end+3 > NMEA.length())) break;
+				if ((end == -1) || (end + 3 > NMEA.length()))
+					break;
 
-				if ((end - start) < 15 || !checkSumOK(NMEA.substring(start,end+3))){
+				if ((end - start) < 15 || !checkSumOK(NMEA.substring(start, end + 3))) {
 					continue;
 				}
 				// Write log after finding valid NMEA sequence
-				if (writeLog && (logFlag & LOGRAW) > 0){
+				if (writeLog && (logFlag & LOGRAW) > 0) {
 					try {
-						logFile.write(NMEA.substring(start,end+3)+"\n");
+						logFile.write(NMEA.substring(start, end + 3) + "\n");
 						logWritten = true;
 					} catch (IOException e) {
 						// Global.getPref().log("Ignored Exception", e, true);
 					}
 				}
 
-				Extractor ex = new Extractor ("," + NMEA.substring(start,end), ",",",",0,true);
+				Extractor ex = new Extractor("," + NMEA.substring(start, end), ",", ",", 0, true);
 				currToken = ex.findNext();
-				if (currToken.equals("$GPGGA")){
+				if (currToken.equals("$GPGGA")) {
 					i = 0;
-					while(ex.endOfSearch() != true){
-						boolean latlonerror = false; // indicate that some error occured in the data -> in this case frace fix to non-fixed in order to avoid invalid coordinates when a fix is indicated to the higher level API
-						currToken = ex.findNext();
+					while ((currToken = ex.findNext()).length() > 0) {
+						// indicate that some error occured in the data -> in this case frace fix to non-fixed in order to avoid invalid coordinates when a fix is indicated to the higher level API
+						boolean latlonerror = false;
 						i++;
-						if (currToken.length()==0) {
-							if (i >= 2 && i <= 5) latlonerror = true; // force non-fix if lat-lon not contained
-							continue; // sometimes there are 2 colons directly one after the other like ",," (e.g. loox)
-						}
-						switch (i){
-						case 1: this.Time = currToken; break;
-						case 2: try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
-						try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
-						break;
-						case 3: latNS = currToken;
-						break;
+						switch (i) {
+						case 1:
+							this.Time = currToken;
+							break;
+						case 2:
+							try {
+								latDeg = currToken.substring(0, 2);
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
+							try {
+								latMin = currToken.substring(2, currToken.length());
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
+							break;
+						case 3:
+							latNS = currToken;
+							break;
 
-						case 4: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
-						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true; } catch (IndexOutOfBoundsException e) {latlonerror = true;}
-						break;
-						case 5: lonEW = currToken;
-						break;
+						case 4:
+							try {
+								lonDeg = currToken.substring(0, 3);
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
+							try {
+								lonMin = currToken.substring(3, currToken.length());
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
+							break;
+						case 5:
+							lonEW = currToken;
+							break;
 						case 6:
 							if (!latlonerror) {
 								this.Fix = Convert.toInt(currToken);
@@ -265,142 +295,194 @@
 								this.Fix = 0;
 								break;
 							}
-						case 7: this.numSat = Convert.toInt(currToken); interpreted = true; break;
-						case 8: try {this.HDOP = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {
-							// Global.getPref().log("Ignored Exception", e, true);
-						} break;
-						case 9: try {this.Alt = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {
-							// Global.getPref().log("Ignored Exception", e, true);
-						} break;
+						case 7:
+							this.numSat = Convert.toInt(currToken);
+							interpreted = true;
+							break;
+						case 8:
+							try {
+								this.HDOP = Common.parseDouble(currToken);
+								interpreted = true;
+							} catch (NumberFormatException e) {
+								// Global.getPref().log("Ignored Exception", e, true);
+							}
+							break;
+						case 9:
+							try {
+								this.Alt = Common.parseDouble(currToken);
+								interpreted = true;
+							} catch (NumberFormatException e) {
+								// Global.getPref().log("Ignored Exception", e, true);
+							}
+							break;
 						} // switch
 					} // while
-					if (Fix > 0) this.set(latNS, latDeg, latMin, "0", lonEW, lonDeg, lonMin, "0", TransformCoordinates.DMM);
+					if (Fix > 0)
+						this.set(latNS, latDeg, latMin, "0", lonEW, lonDeg, lonMin, "0", TransformCoordinates.DMM);
 
 				} // if
 
-				if (currToken.equals("$GPVTG")){
+				if (currToken.equals("$GPVTG")) {
 					i = 0;
-					while(ex.endOfSearch() != true){
-						currToken = ex.findNext();
+					while ((currToken = ex.findNext()).length() > 0) {
 						i++;
-						if (currToken.length()==0) continue;
-						switch (i){
-						case 1: try { this.Bear =Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {
-							// Global.getPref().log("Ignored Exception", e, true);
-						}
-						if (this.Bear > 360) Global.getPref().log("Error bear VTG",null);
-						break;
-						case 7: try { this.Speed = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {
-							// Global.getPref().log("Ignored Exception", e, true);
-						}
-						break;
+						switch (i) {
+						case 1:
+							try {
+								this.Bear = Common.parseDouble(currToken);
+								interpreted = true;
+							} catch (NumberFormatException e) {
+								// Global.getPref().log("Ignored Exception", e, true);
+							}
+							if (this.Bear > 360)
+								Global.getPref().log("Error bear VTG", null);
+							break;
+						case 7:
+							try {
+								this.Speed = Common.parseDouble(currToken);
+								interpreted = true;
+							} catch (NumberFormatException e) {
+								// Global.getPref().log("Ignored Exception", e, true);
+							}
+							break;
 						} // switch
 					} // while
 				} // if
 
-				if (currToken.equals("$GPRMC")){
+				if (currToken.equals("$GPRMC")) {
 					i = 0;
 					String status = "V";
 					boolean latlonerror = false;
-					while(ex.endOfSearch() != true){
-						currToken = ex.findNext();
+					while ((currToken = ex.findNext()).length() > 0) {
 						i++;
-						if (currToken.length() == 0) {
-							if (i >= 2 && i <= 6) latlonerror = true; // force non-fix if lat-lon not contained
-							continue; // sometimes there are 2 colons directly one after the other like ",," (e.g. loox)
-						}
-						if (currToken.length() == 0) continue;
-						switch (i){
-						case 1: this.Time = currToken; interpreted = true; break;
-						case 2: status = currToken;
-						if (status.equals("A")) this.Fix = 1;
-						else this.Fix = 0;
-						interpreted = true;
-						break;
+						switch (i) {
+						case 1:
+							this.Time = currToken;
+							interpreted = true;
+							break;
+						case 2:
+							status = currToken;
+							if (status.equals("A"))
+								this.Fix = 1;
+							else
+								this.Fix = 0;
+							interpreted = true;
+							break;
 						case 3:
-							try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
-							try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
+							try {
+								latDeg = currToken.substring(0, 2);
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
+							try {
+								latMin = currToken.substring(2, currToken.length());
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
 							break;
-						case 4: latNS = currToken; interpreted = true;
-						break;
-						case 5: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {
-							// Global.getPref().log("Ignored Exception", e, true);
-						}
-						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {
-							// Global.getPref().log("Ignored Exception", e, true);
-						}
-						break;
-						case 6: lonEW = currToken;
-						interpreted = true;
-						break;
-						case 7: if (status.equals("A")){
-							try {this.Speed = Common.parseDouble(currToken)*1.854;
-							interpreted = true; } catch (NumberFormatException e) {
-								//Global.getPref().log("Ignored Exception", e, true);
-							}
-						}
-						break;
-						case 8: if (status.equals("A") && currToken.length()> 0){
-							try {this.Bear = Common.parseDouble(currToken);
-							interpreted = true; } catch (NumberFormatException e) {
+						case 4:
+							latNS = currToken;
+							interpreted = true;
+							break;
+						case 5:
+							try {
+								lonDeg = currToken.substring(0, 3);
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
 								// Global.getPref().log("Ignored Exception", e, true);
 							}
-						}
-						break;
-						case 9: if (status.equals("A") && currToken.length()> 0){
-							try {this.Date = currToken;
-							interpreted = true; } catch (NumberFormatException e) {
+							try {
+								lonMin = currToken.substring(3, currToken.length());
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
 								// Global.getPref().log("Ignored Exception", e, true);
 							}
-						}
-						break;
+							break;
+						case 6:
+							lonEW = currToken;
+							interpreted = true;
+							break;
+						case 7:
+							if (status.equals("A")) {
+								try {
+									this.Speed = Common.parseDouble(currToken) * 1.854;
+									interpreted = true;
+								} catch (NumberFormatException e) {
+									// Global.getPref().log("Ignored Exception", e, true);
+								}
+							}
+							break;
+						case 8:
+							if (status.equals("A") && currToken.length() > 0) {
+								try {
+									this.Bear = Common.parseDouble(currToken);
+									interpreted = true;
+								} catch (NumberFormatException e) {
+									// Global.getPref().log("Ignored Exception", e, true);
+								}
+							}
+							break;
+						case 9:
+							if (status.equals("A") && currToken.length() > 0) {
+								try {
+									this.Date = currToken;
+									interpreted = true;
+								} catch (NumberFormatException e) {
+									// Global.getPref().log("Ignored Exception", e, true);
+								}
+							}
+							break;
 						} // switch
 					} // while
-					if (latlonerror) this.Fix = 0;
+					if (latlonerror)
+						this.Fix = 0;
 					else {
-						if (status.equals("A")){
-							this.set(latNS, latDeg, latMin, "0",
-									lonEW, lonDeg, lonMin, "0", TransformCoordinates.DMM);
+						if (status.equals("A")) {
+							this.set(latNS, latDeg, latMin, "0", lonEW, lonDeg, lonMin, "0", TransformCoordinates.DMM);
 						}
 					}
 				} // if
 
-				if (currToken.equals("$GPGSV")){
+				if (currToken.equals("$GPGSV")) {
 					i = 0;
-					while(ex.endOfSearch() != true){
-						currToken = ex.findNext();
+					while ((currToken = ex.findNext()).length() > 0) {
 						i++;
-						if (currToken.length() == 0) continue; // sometimes there are 2 colons directly one after the other like ",," (e.g. loox)
-						switch (i){
-						case 3: this.numSatsInView = Convert.toInt(currToken); interpreted = true; break;
+						switch (i) {
+						case 3:
+							this.numSatsInView = Convert.toInt(currToken);
+							interpreted = true;
+							break;
 						} // switch
 					} // while
 				} // if
 
-			} //while
+			} // while
 		} catch (Exception e) {
 			Global.getPref().log("Exception in examine in CWGPSPoint", e, true);
 		}
 
-		if	(logWritten)
+		if (logWritten)
 			writeLog = false;
 
 		return interpreted;
 	}
 
-
 	/**
 	 * Sets the attributes from a GPSD <code>POLL</code> object
-	 *
-	 * @param gps	{@link JSONObject} containing GPS <code>POLL</code> data.
+	 * 
+	 * @param gps
+	 *            {@link JSONObject} containing GPS <code>POLL</code> data.
 	 * @return true if some data could be interpreted false otherwise
 	 *         Tblue> For now, this always returns true. Any ideas what
-	 *                should be treated as not interpretable?
-	 * @throws JSONException When trying to access a not existing key (should not happen!).
+	 *         should be treated as not interpretable?
+	 * @throws JSONException
+	 *             When trying to access a not existing key (should not happen!).
 	 */
 	public boolean examineGpsd(JSONObject gps) throws JSONException {
-		JSONArray fixes    = gps.getJSONArray( "fixes" );
-		JSONArray skyviews = gps.getJSONArray( "skyviews" );
+		JSONArray fixes = gps.getJSONArray("fixes");
+		JSONArray skyviews = gps.getJSONArray("skyviews");
 		JSONArray sats;
 		JSONObject a_fix, a_skyview;
 		int fix_mode, i;
@@ -409,59 +491,55 @@
 
 		lastStrExamined = gps.toString();
 
-		TimeObj.setTime( (long)( gps.getDouble( "timestamp" ) * 1000 ) );
-		this.Time = TimeObj.format( "HHmmss.SS" );
-		this.Date = TimeObj.format( "ddMMyy" );
+		TimeObj.setTime((long) (gps.getDouble("timestamp") * 1000));
+		this.Time = TimeObj.format("HHmmss.SS");
+		this.Date = TimeObj.format("ddMMyy");
 
-		if( fixes.length() > 0 ) {
+		if (fixes.length() > 0) {
 			// We will only use the first fix.
 			// TODO: Randomize?
-			a_fix = fixes.getJSONObject( 0 );
-			
+			a_fix = fixes.getJSONObject(0);
+
 			// 0: no mode seen yet, 1: none, 2: 2D, 3: 3D.
 			// Tblue> Does 3D mean differential here?
-			this.Fix = ( fix_mode = a_fix.getInt( "mode" ) ) > 0 ? fix_mode - 1 : 0;
+			this.Fix = (fix_mode = a_fix.getInt("mode")) > 0 ? fix_mode - 1 : 0;
 
 			// Speed is in m/s.
-			if( a_fix.has( "speed" ) ) {
-				this.Speed = ( a_fix.getDouble( "speed" ) / 1000 ) * 60 * 60;
+			if (a_fix.has("speed")) {
+				this.Speed = (a_fix.getDouble("speed") / 1000) * 60 * 60;
 			}
 
-			if( a_fix.has( "track" ) ) {
-				this.Bear = a_fix.getDouble( "track" );
+			if (a_fix.has("track")) {
+				this.Bear = a_fix.getDouble("track");
 			}
 
-			if( a_fix.has( "alt" ) ) {
-				this.Alt = a_fix.getDouble( "alt" );
+			if (a_fix.has("alt")) {
+				this.Alt = a_fix.getDouble("alt");
 			}
 
-			if( a_fix.has( "lat" ) && a_fix.has( "lon" ) ) {
-				my_lat = a_fix.getDouble( "lat" );
-				my_lon = a_fix.getDouble( "lon" );
+			if (a_fix.has("lat") && a_fix.has("lon")) {
+				my_lat = a_fix.getDouble("lat");
+				my_lon = a_fix.getDouble("lon");
 
-				set( my_lat > 0 ? "N" : "S", String.valueOf( my_lat ), "0", "0",
-					 my_lon > 0 ? "E" : "W", String.valueOf( my_lon ), "0", "0",
-					 TransformCoordinates.DD );
+				set(my_lat > 0 ? "N" : "S", String.valueOf(my_lat), "0", "0", my_lon > 0 ? "E" : "W", String.valueOf(my_lon), "0", "0", TransformCoordinates.DD);
 			}
 		}
 
-		if( skyviews.length() > 0 )
-		{
+		if (skyviews.length() > 0) {
 			// We will only use the first skyview.
 			// TODO: Randomize?
-			a_skyview = skyviews.getJSONObject( 0 );
+			a_skyview = skyviews.getJSONObject(0);
 
-			if( a_skyview.has( "hdop" ) ) {
-				this.HDOP = a_skyview.getDouble( "hdop" );
+			if (a_skyview.has("hdop")) {
+				this.HDOP = a_skyview.getDouble("hdop");
 			}
 
-			sats = a_skyview.getJSONArray( "satellites" );
+			sats = a_skyview.getJSONArray("satellites");
 			this.numSatsInView = sats.length();
 
-			if( this.numSatsInView > 0 )
-			{
-				for( this.numSat = 0, i = 0; i < this.numSatsInView; i++ ) {
-					if( sats.getJSONObject( i ).getBoolean( "used" ) ) {
+			if (this.numSatsInView > 0) {
+				for (this.numSat = 0, i = 0; i < this.numSatsInView; i++) {
+					if (sats.getJSONObject(i).getBoolean("used")) {
 						this.numSat++;
 					}
 				}
@@ -471,71 +549,72 @@
 		return true;
 	}
 
-
 	/**
 	 * Sets the attributes from an old-style GPSD string.
-	 * @param gps	GPSD string with data to examine
-	 *              Format: GPSD,key=value,...
+	 * 
+	 * @param gps
+	 *            GPSD string with data to examine
+	 *            Format: GPSD,key=value,...
 	 * @return true if some data could be interpreted false otherwise
 	 */
-	public boolean examineOldGpsd(String gps){
+	public boolean examineOldGpsd(String gps) {
 		boolean valid = false;
-		if(!gps.startsWith("GPSD,"))
+		if (!gps.startsWith("GPSD,"))
 			return false;
-		Extractor ex = new Extractor (gps, ",",",",4,true);
-		while(!ex.endOfSearch()){
-			String part = ex.findNext();
-			if(part.startsWith("A=") && part.indexOf('?')<0){
+		Extractor ex = new Extractor(gps, ",", ",", 4, true);
+		String part;
+		while ((part = ex.findNext()).length() > 0) {
+			if (part.startsWith("A=") && part.indexOf('?') < 0) {
 				// The current altitude as "A=%f", meters above mean sea level.
-				this.Alt=Common.parseDouble(part.substring(2));
+				this.Alt = Common.parseDouble(part.substring(2));
 				valid = true;
-			}else if(part.startsWith("D=") && part.indexOf('?')<0){
+			} else if (part.startsWith("D=") && part.indexOf('?') < 0) {
 				// Returns the UTC time in the ISO 8601 format, "D=yyyy-mm-ddThh:mm:ss.ssZ"
-				//                                               0000000000111111111122
-				//                                               0123456789012345678901
-				String year = part.substring(2,6);
-				String month = part.substring(7,9);
-				String day = part.substring(10,12);
-				String hour = part.substring(13,15);
-				String min = part.substring(16,18);
-				String sec = part.substring(19,21);
-				this.Date=year+month+day;
-				this.Time=hour+min+sec;
+				// 0000000000111111111122
+				// 0123456789012345678901
+				String year = part.substring(2, 6);
+				String month = part.substring(7, 9);
+				String day = part.substring(10, 12);
+				String hour = part.substring(13, 15);
+				String min = part.substring(16, 18);
+				String sec = part.substring(19, 21);
+				this.Date = year + month + day;
+				this.Time = hour + min + sec;
 				valid = true;
-			}else if(part.startsWith("P=")){
+			} else if (part.startsWith("P=")) {
 				// Returns the current position in the form "P=%f %f"; numbers are in degrees, latitude first.
-				if(part.indexOf('?')<0){
+				if (part.indexOf('?') < 0) {
 					this.Fix = 1;
-					int spacepos=part.indexOf(' ');
-					if(spacepos>=3){
-						String lat=part.substring(2,spacepos);
-						String lon=part.substring(spacepos+1);
-						this.latDec=Common.parseDouble(lat);
-						this.lonDec=Common.parseDouble(lon);
-					}else
+					int spacepos = part.indexOf(' ');
+					if (spacepos >= 3) {
+						String lat = part.substring(2, spacepos);
+						String lon = part.substring(spacepos + 1);
+						this.latDec = Common.parseDouble(lat);
+						this.lonDec = Common.parseDouble(lon);
+					} else
 						this.set(part.substring(2));
-				}else{
+				} else {
 					this.Fix = 0;
 				}
 				valid = true;
-			}else if(part.startsWith("Q=")){
+			} else if (part.startsWith("Q=")) {
 				// Returns "Q=%d %f %f %f %f %f": a count of satellites used in the last fix,
 				// and five dimensionless dilution-of-precision (DOP) numbers --
 				// spherical, horizontal, vertical, time, and total geometric.
-				int spacepos=part.indexOf(' ');
-				if(part.indexOf('?')<0 && spacepos>=3){
+				int spacepos = part.indexOf(' ');
+				if (part.indexOf('?') < 0 && spacepos >= 3) {
 					this.numSat = Common.parseInt(part.substring(2, spacepos));
 					valid = true;
-				}else{
+				} else {
 					this.numSat = 0;
 				}
-				this.numSatsInView = 0;			// Not supported by GPSD
-				//TODO parse DOP values
-			}else if(part.startsWith("T=") && part.indexOf('?')<0){
+				this.numSatsInView = 0; // Not supported by GPSD
+				// TODO parse DOP values
+			} else if (part.startsWith("T=") && part.indexOf('?') < 0) {
 				// Track made good; course "T=%f" in degrees from true north.
 				this.Bear = Common.parseDouble(part.substring(2));
 				valid = true;
-			}else if(part.startsWith("V=") && part.indexOf('?')<0){
+			} else if (part.startsWith("V=") && part.indexOf('?') < 0) {
 				// The current speed over ground as "V=%f" in knots.
 				this.Speed = Common.parseDouble(part.substring(2));
 				valid = true;
@@ -544,16 +623,16 @@
 		return valid;
 	}
 
-
-	private boolean checkSumOK(String nmea){
+	private boolean checkSumOK(String nmea) {
 		int startPos = 1; // begin after $
 		int endPos = nmea.length() - 3;// without * an two checksum chars
 		byte checkSum = 0;
 
-		for (int i= startPos; i<endPos;i++){
+		for (int i = startPos; i < endPos; i++) {
 			checkSum ^= nmea.charAt(i);
 		}
-		try { return (checkSum == Byte.parseByte(nmea.substring(endPos+1),16));
+		try {
+			return (checkSum == Byte.parseByte(nmea.substring(endPos + 1), 16));
 		} catch (IndexOutOfBoundsException e) {
 			return false;
 		} catch (NumberFormatException e) {
@@ -561,9 +640,7 @@
 		}
 	}
 
-
-
-	public void printAll(){
+	public void printAll() {
 		Global.getPref().log("Latitude:     " + this.getLatDeg(TransformCoordinates.DD));
 		Global.getPref().log("Longitude:    " + this.getLonDeg(TransformCoordinates.DD));
 		Global.getPref().log("Speed:        " + this.Speed);
@@ -577,5 +654,3 @@
 		Global.getPref().log("----------------");
 	}
 }
-
-



From araber95 at mail.berlios.de  Fri May 20 06:46:24 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Fri, 20 May 2011 06:46:24 PM +0200
Subject: [Cachewolf-svn] r3008 - in trunk: res_noewe/symbols resources
	src/CacheWolf src/CacheWolf/navi src/CacheWolf/navi/touchControls
Message-ID: <20110520164625.3392A4813EA@sheep.berlios.de>

Author: araber95
Date: 2011-05-20 18:46:24 +0200 (Fri, 20 May 2011)
New Revision: 3008

Added:
   trunk/resources/archived.png
   trunk/resources/bonus.png
   trunk/resources/disabled.png
   trunk/resources/dnf.png
   trunk/resources/owned.png
   trunk/resources/solved.png
Removed:
   trunk/res_noewe/symbols/2foundsize.png
Modified:
   trunk/res_noewe/symbols/readme.htm
   trunk/resources/found.png
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/CacheType.java
   trunk/src/CacheWolf/GuiImageBroker.java
   trunk/src/CacheWolf/RadarPanel.java
   trunk/src/CacheWolf/navi/MapImage.java
   trunk/src/CacheWolf/navi/MapSymbol.java
   trunk/src/CacheWolf/navi/MovingMap.java
   trunk/src/CacheWolf/navi/touchControls/MovingMapControlItem.java
   trunk/src/CacheWolf/navi/touchControls/MovingMapControlItemButton.java
Log:
Cachesymbol -Overlays introduced: found, dnf, archived, disabled, own, solved, bonus

Deleted: trunk/res_noewe/symbols/2foundsize.png
===================================================================
(Binary files differ)

Modified: trunk/res_noewe/symbols/readme.htm
===================================================================
--- trunk/res_noewe/symbols/readme.htm	2011-05-18 14:06:48 UTC (rev 3007)
+++ trunk/res_noewe/symbols/readme.htm	2011-05-20 16:46:24 UTC (rev 3008)
@@ -14,16 +14,16 @@
  <o:DocumentProperties>
   <o:Author>.</o:Author>
   <o:LastAuthor>Franz</o:LastAuthor>
-  <o:Revision>7</o:Revision>
+  <o:Revision>8</o:Revision>
   <o:Created>2009-10-23T21:05:00Z</o:Created>
-  <o:LastSaved>2011-04-16T14:48:00Z</o:LastSaved>
+  <o:LastSaved>2011-05-20T16:42:00Z</o:LastSaved>
   <o:Pages>1</o:Pages>
-  <o:Words>256</o:Words>
-  <o:Characters>1615</o:Characters>
+  <o:Words>390</o:Words>
+  <o:Characters>2458</o:Characters>
   <o:Company>CF Computer</o:Company>
-  <o:Lines>13</o:Lines>
-  <o:Paragraphs>3</o:Paragraphs>
-  <o:CharactersWithSpaces>1868</o:CharactersWithSpaces>
+  <o:Lines>20</o:Lines>
+  <o:Paragraphs>5</o:Paragraphs>
+  <o:CharactersWithSpaces>2843</o:CharactersWithSpaces>
   <o:Version>10.6870</o:Version>
  </o:DocumentProperties>
 </xml><![endif]--><!--[if gte mso 9]><xml>
@@ -84,7 +84,7 @@
 	font-family:"Times New Roman";}
 </style>
 <![endif]--><!--[if gte mso 9]><xml>
- <o:shapedefaults v:ext="edit" spidmax="6146"/>
+ <o:shapedefaults v:ext="edit" spidmax="7170"/>
 </xml><![endif]--><!--[if gte mso 9]><xml>
  <o:shapelayout v:ext="edit">
   <o:idmap v:ext="edit" data="1"/>
@@ -97,7 +97,7 @@
 
 <p class=MsoNormal>In diesem Verzeichnis vorhandene .<span class=SpellE>png-Dateien</span>
 werden als alternative Symbole in den Cachewolf geladen, falls in den
-Einstellungen/Tab mehr eingeschaltet.</p>
+Einstellungen/Tab Mehr/nutze eigene Symbole eingeschaltet.</p>
 
 <p class=MsoNormal>Dabei sollte es sich um <span class=SpellE>PNGs</span> der
 Gr??e 16x16 handeln oder kleiner.</p>
@@ -106,13 +106,38 @@
 Symbole angezeigt, falls sie existieren und der Dateiname auf <span
 class=SpellE>size</span> endet.</p>
 
-<p class=MsoNormal>F?r <span class=GramE>gefundene</span> Cache k?nnen auf der
-Karte entsprechende Symbole angezeigt werden. Der Dateiname muss daf?r auf <span
-class=SpellE>foundsize</span> enden.</p>
+<p class=MsoNormal>F?r folgende <span class=SpellE>Stati</span> kann ein extra
+Symbol auf der Kartenansicht ?berlagert werden: </p>
 
-<p class=MsoNormal>Es m?ssen nur die Dateien erstellt werden, die ersetzt
-werden sollen.</p>
+<p class=MsoNormal><span class=SpellE><span class=GramE>found.png</span></span><span
+class=GramE> :</span> habe den Cache schon gefunden.</p>
 
+<p class=MsoNormal><span class=SpellE>dnf.png</span>: habe den Cache nicht
+gefunden:<o:p></o:p></p>
+
+<p class=MsoNormal><span class=SpellE><span class=GramE>archived.png</span></span><span
+class=GramE> :</span> der Cache ist archiviert.</p>
+
+<p class=MsoNormal><span class=SpellE>disabled.png</span>: Der Cache ist
+vor?bergehend nicht <span class=SpellE>suchbar</span>.</p>
+
+<p class=MsoNormal><span class=SpellE>owned.png</span>: Den Cache habe ich
+selber platziert.</p>
+
+<p class=MsoNormal><span class=SpellE>solved.png</span>: Du hast dem Cache den
+Status ?gel?st? gegeben, d.h. an den Koordinaten ist der Cache zu finden.</p>
+
+<p class=MsoNormal><span class=SpellE>bonus.png</span>: Das ist ein Bonuscache.
+Die Koordinaten ergeben sich durch Suchen eines anderen Cache.</p>
+
+<p class=MsoNormal>Das ?berlagernde Symbol <span class=SpellE>mu?</span>
+kleiner oder gleich gro? sein wie das Cachesymbol.<o:p></o:p></p>
+
+<p class=MsoNormal><o:p>&nbsp;</o:p></p>
+
+<p class=MsoNormal>Es m?ssen nur die Dateien erstellt werden, die ersetzt werden
+sollen.</p>
+
 <p class=MsoNormal>Ist keine entsprechende Datei vorhanden, wird das
 Cachewolf-interne Symbol beibehalten.</p>
 
@@ -122,9 +147,8 @@
 <p class=MsoNormal><o:p>&nbsp;</o:p></p>
 
 <p class=MsoNormal><span lang=EN-GB style='mso-ansi-language:EN-GB'>.<span
-class=SpellE>png</span>-files in this directory will be loaded as customized
-symbols into <span class=SpellE>Cachewolf</span> if checked in preferences tab
-more.<o:p></o:p></span></p>
+class=SpellE>png</span>-files in this directory will be loaded as customized symbols
+into <span class=SpellE>Cachewolf</span> if checked in preferences tab more.<o:p></o:p></span></p>
 
 <p class=MsoNormal><span lang=EN-GB style='mso-ansi-language:EN-GB'>They're
 supposed to be 16x16 <span class=SpellE>PNGs</span> or less.<o:p></o:p></span></p>
@@ -132,9 +156,26 @@
 <p class=MsoNormal><span lang=EN-GB style='mso-ansi-language:EN-GB'>On the map
 larger symbols are shown, if they exist and the filename ends on size.<o:p></o:p></span></p>
 
-<p class=MsoNormal><span lang=EN-GB style='mso-ansi-language:EN-GB'>Incorrectly
-named files will be ignored.<o:p></o:p></span></p>
+<p class=MsoNormal><span lang=EN-GB style='mso-ansi-language:EN-GB'>For&nbsp;the
+following&nbsp;states, an&nbsp;extra&nbsp;symbol is&nbsp;superimposed&nbsp;on&nbsp;the&nbsp;map<span
+class=GramE>:</span><br>
+<span class=SpellE>found.png</span>:&nbsp;the&nbsp;cache&nbsp;had&nbsp;been&nbsp;found.<br>
+<span class=SpellE>dnf.png</span>:&nbsp;the&nbsp;cache&nbsp;was&nbsp;not found<span
+class=GramE>:</span><br>
+<span class=SpellE>archived.png</span>:&nbsp;the cache&nbsp;is&nbsp;archived.<br>
+<span class=SpellE>disabled.png</span>: The&nbsp;cache&nbsp;is&nbsp;temporarily
+not searchable.<br>
+<span class=SpellE>owned.png</span>:&nbsp;the&nbsp;cache&nbsp;I&nbsp;have myself
+placed.<br>
+<span class=SpellE>solved.png</span>: You&nbsp;have&nbsp;the&nbsp;cache&nbsp;status
+&quot;solved&quot;&nbsp;if&nbsp;i.e.&nbsp;at coordinates cache can be&nbsp;found.<br>
+<span class=SpellE>bonus.png</span>: This is&nbsp;a&nbsp;bonus.&nbsp;The Coordinates&nbsp;result&nbsp;from&nbsp;searching
+another&nbsp;cache.<br>
+The&nbsp;superimposed&nbsp;image&nbsp;must be smaller&nbsp;or be&nbsp;the same
+size&nbsp;as&nbsp;the&nbsp;icon&nbsp;cache.<o:p></o:p></span></p>
 
+<p class=MsoNormal><span lang=EN-GB style='mso-ansi-language:EN-GB'><o:p>&nbsp;</o:p></span></p>
+
 <p class=MsoNormal><span lang=EN-GB style='mso-ansi-language:EN-GB'>You only
 have to create images for those symbols you want customized.<o:p></o:p></span></p>
 

Added: trunk/resources/archived.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/archived.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/resources/bonus.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/bonus.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/resources/disabled.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/disabled.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/resources/dnf.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/dnf.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Modified: trunk/resources/found.png
===================================================================
(Binary files differ)

Added: trunk/resources/owned.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/owned.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/resources/solved.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/solved.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2011-05-18 14:06:48 UTC (rev 3007)
+++ trunk/src/CacheWolf/CacheHolder.java	2011-05-20 16:46:24 UTC (rev 3008)
@@ -1517,7 +1517,7 @@
 		if (level != iconAndTextWPLevel || iconAndTextWP == null || !iconAndTextWP.text.equals(wayPoint)) {
 			switch (level) {
 			case 4:
-				iconAndTextWP = new IconAndText(GuiImageBroker.imageError, wayPoint, fm);
+				iconAndTextWP = new IconAndText(CacheType.getTypeImage(CacheType.CW_TYPE_ERROR), wayPoint, fm);
 				break;
 			case 3:
 				iconAndTextWP = new IconAndText(myTableModel.yellow, wayPoint, fm);
@@ -1542,7 +1542,6 @@
 		if (!cacheStatus.equals(this.cacheStatus)) {
 			this.cacheStatus = cacheStatus;
 			Global.getProfile().notifyUnsavedChanges(true);
-			this.cacheStatus = cacheStatus;
 			if ((this.getType() == CacheType.CW_TYPE_FINAL) && (this.mainCache != null)) {
 				this.mainCache.setCacheStatus(this.getCacheStatus());
 				// change the addi's in setFound

Modified: trunk/src/CacheWolf/CacheType.java
===================================================================
--- trunk/src/CacheWolf/CacheType.java	2011-05-18 14:06:48 UTC (rev 3007)
+++ trunk/src/CacheWolf/CacheType.java	2011-05-20 16:46:24 UTC (rev 3008)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import ewe.fx.Image;
@@ -47,11 +47,11 @@
 	public int _FilterPattern; // 2**BitNr in Filter int (does not correspond with BitNr in String)
 	public Image _iconImage;
 	public Image _mapImage;
-	public Image _foundImage;
-	public CTyp(byte cwMappedCType, byte cwCType, char cwCGroup, String cwCTypeV1, String gcCTypeSpider,
-			String ocCTypeXmlImport, byte cwCTypeV2, char gpxShortCType, String imageName,
-			String[] gpx, int msgNrCTypeName, int gUIOrder, int filterStringPos, int filterPattern) {
+	public Image[] _modImage = { null, null, null, null, null, null, null };
 
+	public CTyp(byte cwMappedCType, byte cwCType, char cwCGroup, String cwCTypeV1, String gcCTypeSpider, String ocCTypeXmlImport, byte cwCTypeV2, char gpxShortCType, String imageName, String[] gpx, int msgNrCTypeName, int gUIOrder, int filterStringPos,
+			int filterPattern) {
+
 		_cwMappedCType = cwMappedCType;
 		_cwCType = cwCType;
 		_cwCGroup = cwCGroup;
@@ -70,19 +70,17 @@
 		_FilterStringPos = filterStringPos;
 		_FilterPattern = filterPattern;
 		if (!_imageName.equals("")) {
-			_iconImage=new Image(_imageName);
-			_mapImage=_iconImage;
-			_foundImage=new Image("found.png");
+			_iconImage = new Image(_imageName);
+			_mapImage = _iconImage;
 		}
 	}
 }
 
-
 /**
  * Handles all aspects of converting cache type information
  * from and to the various im- and exporters ...
  * converting legacy profiles to current standard
- *
+ * 
  * Do not instantiate this class, only use it in a static way
  */
 public final class CacheType {
@@ -112,7 +110,7 @@
 	public static final byte CW_TYPE_WEBCAM = 11;
 	/** locationless cache (GC) */
 	public static final byte CW_TYPE_LOCATIONLESS = 12;
-	/** CITO cache (GC)*/
+	/** CITO cache (GC) */
 	public static final byte CW_TYPE_CITO = 13;
 	/** Mega Event Cache (GC) */
 	public static final byte CW_TYPE_MEGA_EVENT = 100;
@@ -134,88 +132,103 @@
 	public static final byte CW_TYPE_REFERENCE = 55;
 	/** unrecognized cache type or missing information */
 	public static final byte CW_TYPE_ERROR = -1;
-	String[] ggpx={"Geocache|Custom","Custom","Custom",""};
+	String[] ggpx = { "Geocache|Custom", "Custom", "Custom", "" };
+	private static final byte found = 0;
+	private static final byte archived = 1;
+	private static final byte disabled = 2;
+	private static final byte solved = 3;
+	private static final byte bonus = 4;
+	private static final byte owned = 5;
+	private static final byte dnf = 6;
+	//
 	private static final CTyp[] cTypRef = {
-		// custom waypoints
-		new CTyp(CW_TYPE_CUSTOM,CW_TYPE_CUSTOM,'P',"0","","",(byte) -128,'C',"typeCustom.png",new String[] {"Geocache|Custom","Custom","Custom",""},1,0,10,0x000100),
-		// Cache waypoints
-		new CTyp(CW_TYPE_TRADITIONAL,CW_TYPE_TRADITIONAL,'C',"2","2","2",(byte) -126,'T',"typeTradi.png",new String[] {"Geocache|Traditional Cache","Geocache","Traditional Cache","Traditional|Classic"},2,1,0,0x000001),
-		new CTyp(CW_TYPE_MULTI,CW_TYPE_MULTI,'C',"3","3","3",(byte) -125,'M',"typeMulti.png",new String[] {"Geocache|Multi-cache","Geocache","Multi-cache","Multi|Offset"},3,2,1,0x000002),
-		new CTyp(CW_TYPE_VIRTUAL,CW_TYPE_VIRTUAL,'C',"4","4","4",(byte) -124,'V',"typeVirtual.png",new String[] {"Geocache|Virtual Cache","Geocache","Virtual Cache","Virtual"},4,3,2,0x000004),
-		new CTyp(CW_TYPE_LETTERBOX,CW_TYPE_LETTERBOX,'C',"5","5","",(byte) -123,'L',"typeLetterbox.png",new String[] {"Geocache|Letterbox Hybrid","Geocache","Letterbox Hybrid","Letterbox"},5,4,3,0x000008),
-		new CTyp(CW_TYPE_EVENT,CW_TYPE_EVENT,'C',"6","6","6",(byte) -122,'X',"typeEvent.png",new String[] {"Geocache|Event Cache","Geocache","Event Cache","Event"},6,5,4,0x000010),
-		new CTyp(CW_TYPE_MEGA_EVENT,CW_TYPE_MEGA_EVENT,'C',"453","453","",(byte) 101,'X',"typeMegaevent.png",new String[] {"Geocache|Mega-Event Cache","Geocache","Mega-Event Cache","Mega"},14,6,9,0x000200),
-		new CTyp(CW_TYPE_WEBCAM,CW_TYPE_WEBCAM,'C',"11","11","5",(byte) -117,'W',"typeWebcam.png",new String[] {"Geocache|Webcam Cache","Geocache","Webcam Cache","Webcam"},11,7,5,0x000020),
-		new CTyp(CW_TYPE_UNKNOWN,CW_TYPE_UNKNOWN,'C',"8","8","",(byte) -120,'U',"typeUnknown.png",new String[] {"Geocache|Unknown Cache","Geocache","Unknown Cache","Mystery"},8,8,6,0x000040),
-		new CTyp(CW_TYPE_LOCATIONLESS,CW_TYPE_LOCATIONLESS,'C',"12","12","",(byte) -116,'O',"typeLocless.png",new String[] {"Geocache|Locationless (Reverse) Cache","Geocache","Locationless (Reverse) Cache","Locationless"},12,9,8,0x000080),
-		new CTyp(CW_TYPE_CITO,CW_TYPE_CITO,'C',"13","13","",(byte) -115,'X',"typeCito.png",new String[] {"Geocache|Cache In Trash Out Event","Geocache","Cache In Trash Out Event","CITO"},13,10,17,0x020000),
-		new CTyp(CW_TYPE_EARTH,CW_TYPE_EARTH,'C',"137","137","",(byte) 9,'E',"typeEarth.png",new String[] {"Geocache|Earthcache","Geocache","Earthcache","Earth"},18,11,7,0x000400),
-		new CTyp(CW_TYPE_WHEREIGO,CW_TYPE_WHEREIGO,'C',"1858","1858","",(byte) 100,'G',"typeWhereigo.png",new String[] {"Geocache|Wherigo Cache","Geocache","Wherigo Cache","Wherigo"},15,12,18,0x040000),
-		// additional waypoints
-		new CTyp(CW_TYPE_PARKING,CW_TYPE_PARKING,'A',"50","","",(byte) -78,'P',"typeParking.png",new String[] {"Waypoint|Parking Area","Parking Area","Parking Area",""},50,13,11,0x000800),
-		new CTyp(CW_TYPE_STAGE,CW_TYPE_STAGE,'A',"51","","",(byte) -77,'S',"typeStage.png",new String[] {"Waypoint|Stages of a Multicache","Stages of a Multicache","Stages of a Multicache",""},51,14,12,0x001000),
-		new CTyp(CW_TYPE_QUESTION,CW_TYPE_QUESTION,'A',"52","","",(byte) -76,'Q',"typeQuestion.png",new String[] {"Waypoint|Question to Answer","Question to Answer","Question to Answer",""},52,15,13,0x002000),
-		new CTyp(CW_TYPE_FINAL,CW_TYPE_FINAL,'A',"53","","",(byte) -75,'F',"typeFinal.png",new String[] {"Waypoint|Final Location","Final Location","Final Location",""},53,16,14,0x004000),
-		new CTyp(CW_TYPE_TRAILHEAD,CW_TYPE_TRAILHEAD,'A',"54","","",(byte) -74,'H',"typeTrailhead.png",new String[] {"Waypoint|Trailhead","Trailhead","Trailhead",""},54,17,15,0x008000),
-		new CTyp(CW_TYPE_REFERENCE,CW_TYPE_REFERENCE,'A',"55","","",(byte) -73,'R',"typeReference.png",new String[] {"Waypoint|Reference Point","Reference Point","Reference Point",""},55,18,16,0x010000),
-		// error on waypoint
-		new CTyp(CW_TYPE_ERROR,CW_TYPE_ERROR,'E',"","","",(byte) -1,'-',"guiError.png",new String[] {"","","",""},49,-1,-1,0),
-        // mapped types (recognized on input from gpx or download-spider / or cw - version)
-		new CTyp(CW_TYPE_UNKNOWN,(byte) 1,'C',"","","1",(byte) -1,'U',"",new String[] {"Geocache|Other","Geocache","Other","Other"},21,-1,-1,0),
-		new CTyp(CW_TYPE_UNKNOWN,(byte) 7,'C',"7","","7",(byte) -121,'U',"",new String[] {"Geocache|Quiz","Geocache","Quiz","Quiz"},7,-1,-1,0),
-		new CTyp(CW_TYPE_UNKNOWN,(byte) 9,'C',"9","","9",(byte) -119,'U',"",new String[] {"Geocache|Moving","Geocache","Moving","Moving"},9,-1,-1,0),
-		new CTyp(CW_TYPE_TRADITIONAL,(byte) 10,'C',"10","","10",(byte) -118,'U',"",new String[] {"Geocache|DriveIn","Geocache","DriveIn","DriveIn"},10,-1,-1,0),
-		new CTyp(CW_TYPE_EVENT,(byte) 14,'C',"","3653","",(byte) -1,'X',"",new String[] {"Geocache|Lost and Found Event Cache","Geocache","Lost and Found Event Cache",""},6,-1,-1,0),
-		new CTyp(CW_TYPE_TRADITIONAL,(byte) 102,'C',"","9","",(byte) -1,'T',"",new String[] {"Geocache|Project APE Cache","Geocache","Project APE Cache","APE"},16,-1,-1,0),
-		new CTyp(CW_TYPE_EVENT,(byte) 103,'C',"","1304","",(byte) -1,'X',"",new String[] {"Geocache|GPS Adventures Exhibit","Geocache","GPS Adventures Exhibit","MAZE"},17,-1,-1,0),
-		new CTyp(CW_TYPE_UNKNOWN,(byte) 108,'C',"","","8",(byte) -1,'U',"",new String[] {"only on OC download","","",""},19,-1,-1,0),
-		new CTyp(CW_TYPE_WHEREIGO,(byte) 15,'C',"","","",(byte) -62,'G',"",new String[] {"Hack for V2 Typ","","",""},-1,-1,-1,0),
-	};
+			// custom waypoints
+			new CTyp(CW_TYPE_CUSTOM, CW_TYPE_CUSTOM, 'P', "0", "", "", (byte) -128, 'C', "typeCustom.png", new String[] { "Geocache|Custom", "Custom", "Custom", "" }, 1, 0, 10, 0x000100),
+			// Cache waypoints
+			new CTyp(CW_TYPE_TRADITIONAL, CW_TYPE_TRADITIONAL, 'C', "2", "2", "2", (byte) -126, 'T', "typeTradi.png", new String[] { "Geocache|Traditional Cache", "Geocache", "Traditional Cache", "Traditional|Classic" }, 2, 1, 0, 0x000001),
+			new CTyp(CW_TYPE_MULTI, CW_TYPE_MULTI, 'C', "3", "3", "3", (byte) -125, 'M', "typeMulti.png", new String[] { "Geocache|Multi-cache", "Geocache", "Multi-cache", "Multi|Offset" }, 3, 2, 1, 0x000002),
+			new CTyp(CW_TYPE_VIRTUAL, CW_TYPE_VIRTUAL, 'C', "4", "4", "4", (byte) -124, 'V', "typeVirtual.png", new String[] { "Geocache|Virtual Cache", "Geocache", "Virtual Cache", "Virtual" }, 4, 3, 2, 0x000004),
+			new CTyp(CW_TYPE_LETTERBOX, CW_TYPE_LETTERBOX, 'C', "5", "5", "", (byte) -123, 'L', "typeLetterbox.png", new String[] { "Geocache|Letterbox Hybrid", "Geocache", "Letterbox Hybrid", "Letterbox" }, 5, 4, 3, 0x000008),
+			new CTyp(CW_TYPE_EVENT, CW_TYPE_EVENT, 'C', "6", "6", "6", (byte) -122, 'X', "typeEvent.png", new String[] { "Geocache|Event Cache", "Geocache", "Event Cache", "Event" }, 6, 5, 4, 0x000010),
+			new CTyp(CW_TYPE_MEGA_EVENT, CW_TYPE_MEGA_EVENT, 'C', "453", "453", "", (byte) 101, 'X', "typeMegaevent.png", new String[] { "Geocache|Mega-Event Cache", "Geocache", "Mega-Event Cache", "Mega" }, 14, 6, 9, 0x000200),
+			new CTyp(CW_TYPE_WEBCAM, CW_TYPE_WEBCAM, 'C', "11", "11", "5", (byte) -117, 'W', "typeWebcam.png", new String[] { "Geocache|Webcam Cache", "Geocache", "Webcam Cache", "Webcam" }, 11, 7, 5, 0x000020),
+			new CTyp(CW_TYPE_UNKNOWN, CW_TYPE_UNKNOWN, 'C', "8", "8", "", (byte) -120, 'U', "typeUnknown.png", new String[] { "Geocache|Unknown Cache", "Geocache", "Unknown Cache", "Mystery" }, 8, 8, 6, 0x000040),
+			new CTyp(CW_TYPE_LOCATIONLESS, CW_TYPE_LOCATIONLESS, 'C', "12", "12", "", (byte) -116, 'O', "typeLocless.png", new String[] { "Geocache|Locationless (Reverse) Cache", "Geocache", "Locationless (Reverse) Cache", "Locationless" }, 12, 9, 8,
+					0x000080),
+			new CTyp(CW_TYPE_CITO, CW_TYPE_CITO, 'C', "13", "13", "", (byte) -115, 'X', "typeCito.png", new String[] { "Geocache|Cache In Trash Out Event", "Geocache", "Cache In Trash Out Event", "CITO" }, 13, 10, 17, 0x020000),
+			new CTyp(CW_TYPE_EARTH, CW_TYPE_EARTH, 'C', "137", "137", "", (byte) 9, 'E', "typeEarth.png", new String[] { "Geocache|Earthcache", "Geocache", "Earthcache", "Earth" }, 18, 11, 7, 0x000400),
+			new CTyp(CW_TYPE_WHEREIGO, CW_TYPE_WHEREIGO, 'C', "1858", "1858", "", (byte) 100, 'G', "typeWhereigo.png", new String[] { "Geocache|Wherigo Cache", "Geocache", "Wherigo Cache", "Wherigo" }, 15, 12, 18, 0x040000),
+			// additional waypoints
+			new CTyp(CW_TYPE_PARKING, CW_TYPE_PARKING, 'A', "50", "", "", (byte) -78, 'P', "typeParking.png", new String[] { "Waypoint|Parking Area", "Parking Area", "Parking Area", "" }, 50, 13, 11, 0x000800),
+			new CTyp(CW_TYPE_STAGE, CW_TYPE_STAGE, 'A', "51", "", "", (byte) -77, 'S', "typeStage.png", new String[] { "Waypoint|Stages of a Multicache", "Stages of a Multicache", "Stages of a Multicache", "" }, 51, 14, 12, 0x001000),
+			new CTyp(CW_TYPE_QUESTION, CW_TYPE_QUESTION, 'A', "52", "", "", (byte) -76, 'Q', "typeQuestion.png", new String[] { "Waypoint|Question to Answer", "Question to Answer", "Question to Answer", "" }, 52, 15, 13, 0x002000),
+			new CTyp(CW_TYPE_FINAL, CW_TYPE_FINAL, 'A', "53", "", "", (byte) -75, 'F', "typeFinal.png", new String[] { "Waypoint|Final Location", "Final Location", "Final Location", "" }, 53, 16, 14, 0x004000),
+			new CTyp(CW_TYPE_TRAILHEAD, CW_TYPE_TRAILHEAD, 'A', "54", "", "", (byte) -74, 'H', "typeTrailhead.png", new String[] { "Waypoint|Trailhead", "Trailhead", "Trailhead", "" }, 54, 17, 15, 0x008000),
+			new CTyp(CW_TYPE_REFERENCE, CW_TYPE_REFERENCE, 'A', "55", "", "", (byte) -73, 'R', "typeReference.png", new String[] { "Waypoint|Reference Point", "Reference Point", "Reference Point", "" }, 55, 18, 16, 0x010000),
+			// error on waypoint
+			new CTyp(CW_TYPE_ERROR, CW_TYPE_ERROR, 'E', "", "", "", (byte) -1, '-', "guiError.png", new String[] { "", "", "", "" }, 49, -1, -1, 0),
+			// mapped types (recognized on input from gpx or download-spider / or cw - version)
+			new CTyp(CW_TYPE_UNKNOWN, (byte) 1, 'C', "", "", "1", (byte) -1, 'U', "", new String[] { "Geocache|Other", "Geocache", "Other", "Other" }, 21, -1, -1, 0),
+			new CTyp(CW_TYPE_UNKNOWN, (byte) 7, 'C', "7", "", "7", (byte) -121, 'U', "", new String[] { "Geocache|Quiz", "Geocache", "Quiz", "Quiz" }, 7, -1, -1, 0),
+			new CTyp(CW_TYPE_UNKNOWN, (byte) 9, 'C', "9", "", "9", (byte) -119, 'U', "", new String[] { "Geocache|Moving", "Geocache", "Moving", "Moving" }, 9, -1, -1, 0),
+			new CTyp(CW_TYPE_TRADITIONAL, (byte) 10, 'C', "10", "", "10", (byte) -118, 'U', "", new String[] { "Geocache|DriveIn", "Geocache", "DriveIn", "DriveIn" }, 10, -1, -1, 0),
+			new CTyp(CW_TYPE_EVENT, (byte) 14, 'C', "", "3653", "", (byte) -1, 'X', "", new String[] { "Geocache|Lost and Found Event Cache", "Geocache", "Lost and Found Event Cache", "" }, 6, -1, -1, 0),
+			new CTyp(CW_TYPE_TRADITIONAL, (byte) 102, 'C', "", "9", "", (byte) -1, 'T', "", new String[] { "Geocache|Project APE Cache", "Geocache", "Project APE Cache", "APE" }, 16, -1, -1, 0),
+			new CTyp(CW_TYPE_EVENT, (byte) 103, 'C', "", "1304", "", (byte) -1, 'X', "", new String[] { "Geocache|GPS Adventures Exhibit", "Geocache", "GPS Adventures Exhibit", "MAZE" }, 17, -1, -1, 0),
+			new CTyp(CW_TYPE_UNKNOWN, (byte) 108, 'C', "", "", "8", (byte) -1, 'U', "", new String[] { "only on OC download", "", "", "" }, 19, -1, -1, 0),
+			new CTyp(CW_TYPE_WHEREIGO, (byte) 15, 'C', "", "", "", (byte) -62, 'G', "", new String[] { "Hack for V2 Typ", "", "", "" }, -1, -1, -1, 0), };
 	// public static final int anzCacheTyps=cTypRef.length;
-	public static final byte maxCWCType=110;
-    static final byte[] Ref_Index = new byte[maxCWCType];
+	public static final byte maxCWCType = 110;
+	static final byte[] Ref_Index = new byte[maxCWCType];
 	static {
 		// +1 cause error is -1 and array starts at 0
-	  for (byte i = (byte) (cTypRef.length - 1); i>=0; i--) {
-		  Ref_Index[1 + cTypRef[i]._cwCType]= i;
-	   }
+		for (byte i = (byte) (cTypRef.length - 1); i >= 0; i--) {
+			Ref_Index[1 + cTypRef[i]._cwCType] = i;
+		}
 	}
+
 	public static byte Ref_Index(final byte type) {
-		final byte ret=Ref_Index[cTypRef[Ref_Index[type+1]]._cwMappedCType + 1];
+		final byte ret = Ref_Index[cTypRef[Ref_Index[type + 1]]._cwMappedCType + 1];
 		return ret;
 	}
 
-
-
 	/**
 	 * check if a given waypoint type is an additional waypoint
-	 * @param type waypoint type to check
+	 * 
+	 * @param type
+	 *            waypoint type to check
 	 * @return true if it is an additional waypoint, false otherwise
 	 */
 	public static boolean isAddiWpt(final byte type) {
 		return cTypRef[Ref_Index(type)]._cwCGroup == 'A';
 	}
+
 	/**
 	 * check if a given waypoint type is an cache waypoint
-	 * @param type waypoint type to check
+	 * 
+	 * @param type
+	 *            waypoint type to check
 	 * @return true if it is an Cache waypoint, false otherwise
 	 */
 	public static boolean isCacheWpt(final byte type) {
 		return cTypRef[Ref_Index(type)]._cwCGroup == 'C';
 	}
+
 	/**
 	 * check if a given waypoint type is an Custom waypoint
-	 * @param type waypoint type to check
+	 * 
+	 * @param type
+	 *            waypoint type to check
 	 * @return true if it is an Custom waypint, false otherwise
 	 */
 	public static boolean isCustomWpt(final byte type) {
 		return cTypRef[Ref_Index(type)]._cwCGroup == 'P';
 	}
 
-
 	// done for DetailsPanel.java and KML- and TomTom-Exporter
 	/**
 	 * create list of cache types to be shown in GUI drop down lists
+	 * 
 	 * @return list of cache types to be shown in GUI drop down list
 	 * @see guiSelect2Cw
 	 * @see cw2GuiSelect
@@ -224,36 +237,47 @@
 		int j = 0;
 		for (int i = 0; i < cTypRef.length; i++) {
 			if (cTypRef[i]._GUIOrder > j) {
-				j=cTypRef[i]._GUIOrder;
+				j = cTypRef[i]._GUIOrder;
 			}
 		}
-		final String[] ret = new String[j+1];
+		final String[] ret = new String[j + 1];
 		for (int i = 0; i < cTypRef.length; i++) {
 			if (cTypRef[i]._GUIOrder > -1) {
-				ret[cTypRef[i]._GUIOrder]=MyLocale.getMsg(cTypRef[i]._msgNrCTypeName,"");
+				ret[cTypRef[i]._GUIOrder] = MyLocale.getMsg(cTypRef[i]._msgNrCTypeName, "");
 			}
 		}
 		return ret;
 	}
+
 	/**
 	 * translate GUI drop down index selection back to internally stored type
-	 * @param selection index value from drop down list
+	 * 
+	 * @param selection
+	 *            index value from drop down list
 	 * @return internal type
-	 * @throws IllegalArgumentException if <code>selection</code> can not be matched
+	 * @throws IllegalArgumentException
+	 *             if <code>selection</code> can not be matched
 	 * @see guiTypeStrings
 	 * @see cw2GuiSelect
 	 */
 	public static byte guiSelect2Cw(final int selection) {
-		for (byte i=0; i<cTypRef.length; i++) {
-			if (cTypRef[i]._GUIOrder == selection) {return cTypRef[i]._cwCType;};
+		for (byte i = 0; i < cTypRef.length; i++) {
+			if (cTypRef[i]._GUIOrder == selection) {
+				return cTypRef[i]._cwCType;
+			}
+			;
 		}
 		return -1;
 	}
+
 	/**
 	 * translate cache type to position of index to highlight in GUI cache type drop down list
-	 * @param typeId internal id of cache type
+	 * 
+	 * @param typeId
+	 *            internal id of cache type
 	 * @return index of the cache type in GUI list
-	 * @throws IllegalArgumentException if <code>id</code> can not be matched
+	 * @throws IllegalArgumentException
+	 *             if <code>id</code> can not be matched
 	 * @see guiTypeStrings
 	 * @see guiSelect2Cw
 	 */
@@ -261,25 +285,32 @@
 		return cTypRef[Ref_Index(typeId)]._GUIOrder;
 	}
 
-
-
 	/**
 	 * convert the strings found in import of GPX from GC, OC or TC to internal cache type
-	 * @param gpxType type information found in GPX
+	 * 
+	 * @param gpxType
+	 *            type information found in GPX
 	 * @return internal cache type
 	 */
 	public static byte gpxType2CwType(final String gpxType) throws IllegalArgumentException {
-		for (byte i=0; i<cTypRef.length; i++) {
-			if (cTypRef[i]._gpxWptTypeTag.equalsIgnoreCase(gpxType)) {return cTypRef[i]._cwMappedCType;};
+		for (byte i = 0; i < cTypRef.length; i++) {
+			if (cTypRef[i]._gpxWptTypeTag.equalsIgnoreCase(gpxType)) {
+				return cTypRef[i]._cwMappedCType;
+			}
+			;
 		}
-		for (byte i=0; i<cTypRef.length; i++) {
-			if (cTypRef[i]._gpxWptGCextensionTypTag.equalsIgnoreCase(gpxType)) {return cTypRef[i]._cwMappedCType;};
+		for (byte i = 0; i < cTypRef.length; i++) {
+			if (cTypRef[i]._gpxWptGCextensionTypTag.equalsIgnoreCase(gpxType)) {
+				return cTypRef[i]._cwMappedCType;
+			}
+			;
 		}
 		final String lowerCaseGPXType = gpxType.toLowerCase();
-		for (byte i=0; i<cTypRef.length; i++) {
+		for (byte i = 0; i < cTypRef.length; i++) {
 			if (cTypRef[i]._gpxAlternativeWptTypTags.toLowerCase().indexOf(lowerCaseGPXType) != -1) {
 				return cTypRef[i]._cwMappedCType;
-			};
+			}
+			;
 		}
 		// TODO extend definition of _gpxAlternativeWptTypTags for all cases of Mystery
 		// old code was : if (!(gpxType.indexOf("Mystery")==-1)) return CW_TYPE_UNKNOWN;
@@ -288,9 +319,12 @@
 
 	/**
 	 * convert the cache type information from an OC XML import to internal cache type
-	 * @param ocType cache type found in OC XML
+	 * 
+	 * @param ocType
+	 *            cache type found in OC XML
 	 * @return internal cache type
-	 * @throws IllegalArgumentException if <code>ocType</code> can not be matched
+	 * @throws IllegalArgumentException
+	 *             if <code>ocType</code> can not be matched
 	 */
 	public static byte ocType2CwType(final String ocType) {
 		for (int i = 0; i < cTypRef.length; i++) {
@@ -300,11 +334,15 @@
 		}
 		return -1;
 	}
+
 	/**
 	 * convert type information discovered by GC spider to internal type information
-	 * @param gcType type information from GC spider
+	 * 
+	 * @param gcType
+	 *            type information from GC spider
 	 * @return internal representation of cache type
-	 * @throws IllegalArgumentException if <code>gcType</code> can not be matched
+	 * @throws IllegalArgumentException
+	 *             if <code>gcType</code> can not be matched
 	 */
 	public static byte gcSpider2CwType(final String gcType) {
 		for (int i = 0; i < cTypRef.length; i++) {
@@ -314,9 +352,12 @@
 		}
 		return -1;
 	}
+
 	/**
 	 * convert version1 type information to current values
-	 * @param type version1 cache type information
+	 * 
+	 * @param type
+	 *            version1 cache type information
 	 * @return current version cache type information or -1
 	 * @deprecated remove once v1 file version compatibility is abandoned
 	 */
@@ -328,9 +369,12 @@
 		}
 		return -1;
 	}
+
 	/**
 	 * convert version2 type information to current values
-	 * @param type version2 cache type information
+	 * 
+	 * @param type
+	 *            version2 cache type information
 	 * @return current version cache type information or -1
 	 * @deprecated remove once v2 file version compatibility is abandoned
 	 */
@@ -343,128 +387,218 @@
 		return -1;
 	}
 
-
-
 	/**
 	 * translate cache type to a short version for compact exporters or "smart" cache names.
-	 * @param typeId CacheWolf internal type information
+	 * 
+	 * @param typeId
+	 *            CacheWolf internal type information
 	 * @return abbreviation of cache type
 	 */
 	public static String getExportShortId(final byte typeId) {
-		return ""+cTypRef[Ref_Index(typeId)]._gpxShortCType;
+		return "" + cTypRef[Ref_Index(typeId)]._gpxShortCType;
 	}
+
 	/**
 	 * map cache types to images
-	 * @param typeId internal cache type id
+	 * 
+	 * @param typeId
+	 *            internal cache type id
 	 * @return non qualified name of image
 	 */
 	public static String typeImageForId(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._imageName;
 	}
+
 	/**
 	 * generate type description matching those of GC for GPX export
-	 * @param typeId internal type id
+	 * 
+	 * @param typeId
+	 *            internal type id
 	 * @return type information in GC.com <type> GPX format
 	 */
 	public static String type2TypeTag(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._gpxWptTypeTag;
 	}
+
 	/**
 	 * generate type description matching those of GC for GPX export
-	 * @param typeId internal type id
+	 * 
+	 * @param typeId
+	 *            internal type id
 	 * @return symb information in GC.com <sym> GPX format
 	 */
 	public static String type2SymTag(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._gpxWptSymTag;
 	}
+
 	/**
 	 * generate type description matching those of GC for GPX export
-	 * @param typeId internal type id
+	 * 
+	 * @param typeId
+	 *            internal type id
 	 * @return type information in GC.com <groundspeak:type> GPX format
 	 */
 	public static String type2GSTypeTag(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._gpxWptGCextensionTypTag;
 	}
+
 	/**
 	 * generate type description matching those of GC for GPX export
-	 * @param typeId internal type id
+	 * 
+	 * @param typeId
+	 *            internal type id
 	 * @return Gui - string for type
 	 */
 	public static String type2Gui(final byte typeId) {
-		return MyLocale.getMsg(cTypRef[Ref_Index(typeId)]._msgNrCTypeName,"");
+		return MyLocale.getMsg(cTypRef[Ref_Index(typeId)]._msgNrCTypeName, "");
 	}
+
 	/**
 	 * select image to be displayed for a given cache type
-	 * @param typeId internal cache type id
+	 * 
+	 * @param typeId
+	 *            internal cache type id
 	 * @return <code>Image</code> object to be displayed
 	 */
 	public static Image getTypeImage(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._iconImage;
 	}
+
 	/**
 	 * select image to be displayed for a given cache type
-	 * @param typeId internal cache type id
+	 * 
+	 * @param typeId
+	 *            internal cache type id
 	 * @return <code>Image</code> object to be displayed
 	 */
-	public static Image getMapImage(final byte typeId) {
-		return cTypRef[Ref_Index(typeId)]._mapImage;
+	public static Image getMapImage(CacheHolder ch) {
+		byte typeId = ch.getType();
+		Image im = cTypRef[Ref_Index(typeId)]._mapImage;
+		if (ch.is_found()) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[found] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[found] = newOverlayedImage(im, GuiImageBroker.found);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[found];
+		} else if (ch.is_archived()) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[archived] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[archived] = newOverlayedImage(im, GuiImageBroker.archived);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[archived];
+		} else if (!ch.is_available()) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[disabled] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[disabled] = newOverlayedImage(im, GuiImageBroker.disabled);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[disabled];
+		} else if (ch.is_owned()) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[owned] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[owned] = newOverlayedImage(im, GuiImageBroker.owned);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[owned];
+		} else if (ch.getCacheStatus().startsWith(MyLocale.getMsg(362, "solved"))) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[solved] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[solved] = newOverlayedImage(im, GuiImageBroker.solved);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[solved];
+		} else if (ch.getCacheStatus().startsWith(MyLocale.getMsg(319, "Not Found"))) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[dnf] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[dnf] = newOverlayedImage(im, GuiImageBroker.dnf);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[dnf];
+		} else if (ch.getCacheName().toLowerCase().indexOf("bonus") > -1) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[bonus] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[bonus] = newOverlayedImage(im, GuiImageBroker.bonus);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[bonus];
+		}
+		return im;
 	}
 
-	public static Image getFoundImage(final byte typeId) {
-		return cTypRef[Ref_Index(typeId)]._foundImage;
-	}
 	/**
 	 * select image to be displayed for a given cache type
-	 * @param typeId internal cache type id
-	 * @param Image object to be displayed
+	 * 
+	 * @param typeId
+	 *            internal cache type id
+	 * @param Image
+	 *            object to be displayed
 	 */
 	public static void setTypeImage(final byte id, final Image iconImage) {
 		if (cTypRef[Ref_Index(id)]._iconImage != cTypRef[Ref_Index(id)]._mapImage)
 			cTypRef[Ref_Index(id)]._iconImage.free();
-		cTypRef[Ref_Index(id)]._iconImage=iconImage;
+		cTypRef[Ref_Index(id)]._iconImage = iconImage;
 	}
+
 	/**
 	 * select image to be displayed for a given cache type
-	 * @param typeId internal cache type id
-	 * @param Image object to be displayed
+	 * 
+	 * @param typeId
+	 *            internal cache type id
+	 * @param Image
+	 *            object to be displayed
 	 */
 	public static void setMapImage(final byte id, final Image mapImage) {
 		if (cTypRef[Ref_Index(id)]._iconImage != cTypRef[Ref_Index(id)]._mapImage)
 			cTypRef[Ref_Index(id)]._mapImage.free();
-		cTypRef[Ref_Index(id)]._mapImage=mapImage;
+		cTypRef[Ref_Index(id)]._mapImage = mapImage;
 	}
-	public static void setFoundImage(final byte id, final Image foundImage) {
-		cTypRef[Ref_Index(id)]._foundImage=foundImage;
-	}
 
-
 	// TODO do it better in Version 4
 	public static int getCacheTypePattern(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._FilterPattern;
 	}
+
 	public static int Type_FilterString2Type_FilterPattern(final String Type_FilterString) {
 		int typeMatchPattern = 0;
 		for (int i = 0; i < cTypRef.length; i++) {
 			if (cTypRef[i]._FilterStringPos > -1) {
 				if (Type_FilterString.charAt(cTypRef[i]._FilterStringPos) == '1') {
-					typeMatchPattern|=cTypRef[i]._FilterPattern;
+					typeMatchPattern |= cTypRef[i]._FilterPattern;
 				}
 			}
 		}
 		return typeMatchPattern;
 	}
+
 	public static boolean hasTypeMatchPattern(final int typeMatchPattern) {
 		return typeMatchPattern != 0;
 	}
+
 	public static boolean hasMainTypeMatchPattern(final int typeMatchPattern) {
 		int TYPE_MAIN = 0;
 		for (int i = 0; i < cTypRef.length; i++) {
-			if (cTypRef[i]._cwCGroup == 'C' || cTypRef[i]._cwCGroup == 'P' ) {
-				TYPE_MAIN|=cTypRef[i]._FilterPattern;
+			if (cTypRef[i]._cwCGroup == 'C' || cTypRef[i]._cwCGroup == 'P') {
+				TYPE_MAIN |= cTypRef[i]._FilterPattern;
 			}
 		}
 		return (typeMatchPattern & TYPE_MAIN) != 0;
 	}
 
+	private static Image newOverlayedImage(Image imsrc, Image imovl) {
+		// Overlay added at topleft
+		int srcWidth = imsrc.getWidth();
+		int srcHeight = imsrc.getHeight();
+		int ovlWidth = imovl.getWidth();
+		int ovlHeight = imovl.getHeight();
+		if (srcWidth < ovlWidth || srcHeight < ovlHeight)
+			return imsrc;
+		int[] srcPixels = imsrc.getPixels(null, 0, 0, 0, srcWidth, srcHeight, 0);
+		int[] ovlPixels = imovl.getPixels(null, 0, 0, 0, ovlWidth, ovlHeight, 0);
+		int offsrc;
+		int offovl = 0;
+		for (int y = 0; y < ovlHeight; y++) { // top down
+			offsrc = y * srcWidth;
+			for (int x = 0; x < ovlWidth; x++) {
+				int alphaval = (ovlPixels[offovl] >> 24) & 0xff;
+				if (alphaval > 0) {
+					srcPixels[offsrc] = ovlPixels[offovl];
+				}
+				offovl++;
+				offsrc++;
+			}
+		}
+		Image modImage = new Image(imsrc, 0);
+		modImage.setPixels(srcPixels, 0, 0, 0, srcWidth, srcHeight, 0);
+		return modImage;
+	}
+
 	// TODO it for OCXMLImporterScreen and FilterScreen ?
 }

Modified: trunk/src/CacheWolf/GuiImageBroker.java
===================================================================
--- trunk/src/CacheWolf/GuiImageBroker.java	2011-05-18 14:06:48 UTC (rev 3007)
+++ trunk/src/CacheWolf/GuiImageBroker.java	2011-05-20 16:46:24 UTC (rev 3008)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.utils.FileBugfix;
@@ -31,43 +31,23 @@
 
 /**
  * hold preloaded versions of GUI images in a single place
- *
+ * 
  * Do not instantiate this class, only use it in a static way.
  */
 
 public final class GuiImageBroker {
+	public static Image found = new Image("found.png");
+	public static Image disabled = new Image("disabled.png"); // available
+	public static Image archived = new Image("archived.png");
+	public static Image solved = new Image("solved.png");
+	public static Image bonus = new Image("bonus.png");
+	public static Image owned = new Image("selected.png");
+	public static Image dnf = new Image("dnf.png");
 
-	// TODO: check with Image and mImage
-
-	/** image to be displayed in case of error */
-	public static Image imageError = new Image("guiError.png");
-
-	/**
-	 * images to be displayed for cache types in GUI
-	 * @see getTypeImage
-	 * @see CacheTypes
-	 */
-
-	/** thou shallst not instantiate this object */
 	private GuiImageBroker() {
 		// Noting to do
 	}
 
-	public static Image getTypeImage(byte typeId,boolean map, boolean found) {
-		if (!map) {
-			return CacheType.getTypeImage(typeId);
-		}
-		else {
-			if (found) {
-				return CacheType.getFoundImage(typeId);
-			}
-			else {
-				return CacheType.getMapImage(typeId);
-			}
-		}
-	}
-
-
 	/**
 	 * Replaces the build-in symbols by images stored in /symbols:
 	 * If the sub directory symbols exists in CW-directory *.png-files
@@ -78,47 +58,56 @@
 	 * Images are NOT checked for size etc.
 	 */
 	public static void customizedSymbols() {
-		final String sdir="/symbols/";
-		final FileBugfix dir=new FileBugfix(FileBase.getProgramDirectory()+sdir);
-		if (dir.isDirectory()){
+		final String sdir = "/symbols/";
+		final FileBugfix dir = new FileBugfix(FileBase.getProgramDirectory() + sdir);
+		if (dir.isDirectory()) {
 			int id;
-			boolean size=false;
-			boolean found=false;
+			boolean size = false;
 			String name = "";
-			String [] pngFiles;
-			pngFiles=dir.list("*.png",0);
-			Global.getPref().log("Nr. of own symbols (png-files) : "+pngFiles.length);
-			for (int i=0; i<pngFiles.length; i++) {
-				name = pngFiles[i].substring(0,pngFiles[i].length()-4);
-				if (name.toLowerCase().endsWith("size")){
-					size=true;
-					name=name.substring(0,name.length()-4);
+			String[] pngFiles;
+			pngFiles = dir.list("*.png", FileBase.LIST_FILES_ONLY);
+			Global.getPref().log("Nr. of own symbols (png-files) : " + pngFiles.length);
+			for (int i = 0; i < pngFiles.length; i++) {
+				name = pngFiles[i].substring(0, pngFiles[i].length() - 4).toLowerCase();
+				if (name.endsWith("size")) {
+					size = true;
+					name = name.substring(0, name.length() - 4);
+				} else {
+					if (name.equals("disabled")) {
+						disabled = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals("archived")) {
+						archived = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals("solved")) {
+						solved = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals("bonus")) {
+						bonus = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals("owned")) {
+						owned = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals("dnf")) {
+						dnf = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals("found")) {
+						found = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
 				}
-				if (name.toLowerCase().endsWith("found")){
-					found=true;
-					name=name.substring(0,name.length()-5);
-				}
 				try {
 					id = Integer.parseInt(name);
+				} catch (final Exception E) {
+					id = -1; // filename invalid for symbols
 				}
-				catch (final Exception E){
-					id = -1; //filename invalid for symbols
-				}
-				if (0<=id && id<=CacheType.maxCWCType){
-					final String s=FileBase.getProgramDirectory()+sdir+pngFiles[i];
-					Global.getPref().log("own symbol: "+(i+1)+" = "+pngFiles[i]);
-					if (size){
-						if (found) {
-							CacheType.setFoundImage((byte) id, new Image(s));
-						}
-						else {
-							CacheType.setMapImage((byte) id, new Image(s));
-						}
-						size=false;
-						found=false;
+				if (0 <= id && id <= CacheType.maxCWCType) {
+					final String s = FileBase.getProgramDirectory() + sdir + pngFiles[i];
+					Global.getPref().log("own symbol: " + (i + 1) + " = " + pngFiles[i]);
+					if (size) {
+						CacheType.setMapImage((byte) id, new Image(s));
+						size = false;
 
-					}
-					else{
+					} else {
 						CacheType.setTypeImage((byte) id, new Image(s));
 					}
 				}

Modified: trunk/src/CacheWolf/RadarPanel.java
===================================================================
--- trunk/src/CacheWolf/RadarPanel.java	2011-05-18 14:06:48 UTC (rev 3007)
+++ trunk/src/CacheWolf/RadarPanel.java	2011-05-20 16:46:24 UTC (rev 3008)
@@ -1,29 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 import ewe.fx.Color;
 import ewe.fx.Dimension;
 import ewe.fx.Font;
@@ -40,16 +41,16 @@
 import ewe.ui.mButton;
 
 /**
-*	The radar panel. Displays the caches around a centre point.<br>
-*	Handles scaling as well as toggling the different views in the radar panel.<br>
-*	Also handles clicking on a cache.<br>
-*	Class ID=500
-*/
-public class RadarPanel extends CellPanel{
+ * The radar panel. Displays the caches around a centre point.<br>
+ * Handles scaling as well as toggling the different views in the radar panel.<br>
+ * Also handles clicking on a cache.<br>
+ * Class ID=500
+ */
+public class RadarPanel extends CellPanel {
 	mButton btMinus = new mButton("   -   ");
 	mButton btToggle = new mButton("Toggle");
 	mButton btPlus = new mButton("   +   ");
-	int toggleMod = 0; //0 = cacheicons, 1= cacheWP, 2 = cacheNames
+	int toggleMod = 0; // 0 = cacheicons, 1= cacheWP, 2 = cacheNames
 	Preferences pref;
 	CacheDB cacheDB;
 	myInteractivePanel iActP;
@@ -60,54 +61,55 @@
 	CacheHolder selectedWaypoint = null;
 	MainTab mt;
 	boolean penMoving = false;
-	int x1,y1,x2,y2 = 0;
-	boolean reCenterImage=true;
+	int x1, y1, x2, y2 = 0;
+	boolean reCenterImage = true;
+
 	/**
-	* Constructor for the radar panel.
-	* Loads images, sets up the interactive panel and
-	* "navigation" buttons.
-	*/
-	public RadarPanel(){
+	 * Constructor for the radar panel.
+	 * Loads images, sets up the interactive panel and
+	 * "navigation" buttons.
+	 */
+	public RadarPanel() {
 		this.addLast(iActP = new myInteractivePanel(), CellConstants.STRETCH, CellConstants.FILL);
 		final CellPanel cp = new CellPanel();
-		cp.addNext(btMinus,CellConstants.HSTRETCH, (CellConstants.FILL|CellConstants.WEST));
-		cp.addNext(btToggle,CellConstants.HSTRETCH, CellConstants.FILL);
-		cp.addLast(btPlus,CellConstants.HSTRETCH, (CellConstants.FILL|CellConstants.EAST));
+		cp.addNext(btMinus, CellConstants.HSTRETCH, (CellConstants.FILL | CellConstants.WEST));
+		cp.addNext(btToggle, CellConstants.HSTRETCH, CellConstants.FILL);
+		cp.addLast(btPlus, CellConstants.HSTRETCH, (CellConstants.FILL | CellConstants.EAST));
 		this.addLast(cp, CellConstants.HSTRETCH, CellConstants.FILL);
 	}
 
-	public void setMainTab(MainTab tb){
+	public void setMainTab(MainTab tb) {
 		mt = tb;
 		iActP.setMainTab(tb);
 	}
 
 	/**
-	* Informs the radar panel on preferences and currently loaded cache
-	* database. It also calculates the maximum size available for drawing
-	* the radar.
-	*/
-	public void setParam(Preferences p, CacheDB db, CacheHolder sWp){
+	 * Informs the radar panel on preferences and currently loaded cache
+	 * database. It also calculates the maximum size available for drawing
+	 * the radar.
+	 */
+	public void setParam(Preferences p, CacheDB db, CacheHolder sWp) {
 		selectedWaypoint = sWp;
 		pref = p;
 		cacheDB = db;
-		height = (pref.myAppHeight)*6/5; // add 10% each at top/bottom
-		width = (pref.myAppWidth)*6/5;
+		height = (pref.myAppHeight) * 6 / 5; // add 10% each at top/bottom
+		width = (pref.myAppWidth) * 6 / 5;
 	}
 
 	// Call this after the centre has changed to re-center the radar panel
 	public void recenterRadar() {
-		reCenterImage=true;
+		reCenterImage = true;
 	}
 
 	/**
-	* Public method to draw the different caches and the
-	* radar background
-	*/
-	public void drawThePanel(){
+	 * Public method to draw the different caches and the
+	 * radar background
+	 */
+	public void drawThePanel() {
 		// If there are any images remove them!
 		final int anz = iActP.images.size();
-		for(int i = 0; i<anz;i++){
-			iActP.removeImage((AniImage)iActP.images.get(0));
+		for (int i = 0; i < anz; i++) {
+			iActP.removeImage((AniImage) iActP.images.get(0));
 		}
 		iActP.refresh();
 		drawBackground();
@@ -116,157 +118,163 @@
 		if (reCenterImage) {
 			// Hack to scroll to left origin for a defined position for subsequent
 			// scroll which centers the image
-			iActP.scroll(-1000,-1000);
-			final Dimension dispSize=getDisplayedSize(null);
-			iActP.scroll((width-dispSize.width)/2,(height-dispSize.height+btMinus.getSize(null).height)/2);
-			reCenterImage=false;
+			iActP.scroll(-1000, -1000);
+			final Dimension dispSize = getDisplayedSize(null);
+			iActP.scroll((width - dispSize.width) / 2, (height - dispSize.height + btMinus.getSize(null).height) / 2);
+			reCenterImage = false;
 		}
 	}
 
 	/**
-	* Private method to draw the caches.
-	*/
-	private void drawCaches(){
-		final Font radarFont = new Font("Gui", Font.BOLD,Global.getPref().fontSize);
+	 * Private method to draw the caches.
+	 */
+	private void drawCaches() {
+		final Font radarFont = new Font("Gui", Font.BOLD, Global.getPref().fontSize);
 		final FontMetrics fm = getFontMetrics(radarFont);
 		AniImage aImg;
 		RadarPanelImage rpi;
-		int drX,drY = 0;
+		int drX, drY = 0;
 		CacheHolder holder;
 		double degrees;
-		final double pi180=java.lang.Math.PI / 180.0;
-		for(int i = cacheDB.size()-1; i >=0 ; i--){
+		final double pi180 = java.lang.Math.PI / 180.0;
+		for (int i = cacheDB.size() - 1; i >= 0; i--) {
 			holder = cacheDB.get(i);
-			if(holder.isVisible() && holder.pos.isValid()) {
+			if (holder.isVisible() && holder.pos.isValid()) {
 				degrees = holder.degrees * pi180;
-				drX =new Float(holder.kilom/scale *  java.lang.Math.sin(degrees)).intValue();
-				drY = -new Float(holder.kilom/scale *  java.lang.Math.cos(degrees)).intValue();
-				if(centerX+drX>=0 && centerY+drY>=0 && centerX+drX<=width && centerY+drY <= height){
-					if (toggleMod>0) {
+				drX = new Float(holder.kilom / scale * java.lang.Math.sin(degrees)).intValue();
+				drY = -new Float(holder.kilom / scale * java.lang.Math.cos(degrees)).intValue();
+				if (centerX + drX >= 0 && centerY + drY >= 0 && centerX + drX <= width && centerY + drY <= height) {
+					if (toggleMod > 0) {
 						String s;
-						if (toggleMod==1)
-							s=holder.getWayPoint();
+						if (toggleMod == 1)
+							s = holder.getWayPoint();
 						else
-							s=holder.getCacheName();
-						if (s.length()>0) {
+							s = holder.getCacheName();
+						if (s.length() > 0) {
 							int tw;
-							final Image img = new Image(tw=fm.getTextWidth(s),fm.getHeight());
+							final Image img = new Image(tw = fm.getTextWidth(s), fm.getHeight());
 							final Graphics g = new Graphics(img);
 							g.setFont(radarFont);
 							g.setColor(Color.Black);
-							g.fillRect(0,0,tw, fm.getHeight());
+							g.fillRect(0, 0, tw, fm.getHeight());
 							g.setColor(Color.White);
-							g.drawText(s, 0,0);
+							g.drawText(s, 0, 0);
 							aImg = new AniImage(img);
-							aImg.setLocation(centerX+drX+5,centerY+drY);
+							aImg.setLocation(centerX + drX + 5, centerY + drY);
 							aImg.transparentColor = Color.Black;
 							aImg.properties = mImage.IsNotHot;
 							iActP.addImage(aImg);
 						}
 					}
-					Image imgCache=GuiImageBroker.getTypeImage(holder.getType(),true, holder.is_found());
-					// If we have no image for the cache type use a question mark
-					if (imgCache==null) imgCache=GuiImageBroker.getTypeImage(CacheType.CW_TYPE_UNKNOWN,true,false);
+					Image imgCache = CacheType.getMapImage(holder);
 					rpi = new RadarPanelImage(imgCache);
 					rpi.wayPoint = holder.getWayPoint();
 					rpi.rownum = i;
 					final int dx = imgCache.getWidth();
 					final int dy = imgCache.getHeight();
-					rpi.setLocation(centerX+drX-dx/2,centerY+drY-dy/2);
+					rpi.setLocation(centerX + drX - dx / 2, centerY + drY - dy / 2);
 					iActP.addImage(rpi);
-					if(holder == selectedWaypoint){ // Draw red circle around selected wpt
-						final int diag = (int) (java.lang.Math.sqrt(dx*dx+dy*dy)+0.5);
+					if (holder == selectedWaypoint) { // Draw red circle around selected wpt
+						final int diag = (int) (java.lang.Math.sqrt(dx * dx + dy * dy) + 0.5);
 						final Image imgCircle = new Image(diag, diag);
 						final Graphics gCircle = new Graphics(imgCircle);
 						gCircle.setColor(Color.Black);
-						gCircle.fillRect(0,0,diag,diag);
-						gCircle.setColor(new Color(255,0,0));
-						gCircle.drawEllipse(0,0, diag,diag);
+						gCircle.fillRect(0, 0, diag, diag);
+						gCircle.setColor(new Color(255, 0, 0));
+						gCircle.drawEllipse(0, 0, diag, diag);
 						aImg = new AniImage(imgCircle);
-						aImg.setLocation(centerX+drX-diag/2,centerY+drY-diag/2);
-						aImg.transparentColor = new Color(0,0,0);
+						aImg.setLocation(centerX + drX - diag / 2, centerY + drY - diag / 2);
+						aImg.transparentColor = new Color(0, 0, 0);
 						aImg.properties = mImage.IsNotHot;
 						iActP.addImage(aImg);
 					}
-				}//if center...
+				}// if center...
 			}// if is_black...
 		}
 	}
 
 	/**
-	* Private method to draw the black background and green radar.
-	* Also calculates some other parameters.
-	* Always call this before calling drawCaches().
-	*/
-	private void drawBackground(){
+	 * Private method to draw the black background and green radar.
+	 * Also calculates some other parameters.
+	 * Always call this before calling drawCaches().
+	 */
+	private void drawBackground() {
 		final Rect r = new Rect(new Dimension(width, height));
 		iActP.virtualSize = r;
 		iActP.refresh();
 		final Image img = new Image(width, height);
 		final Graphics g = new Graphics(img);
 		g.setColor(Color.Black);
-		g.fillRect(0,0,width, height);
+		g.fillRect(0, 0, width, height);
 
-
-		if(width < height) {
-			scale = (double)scaleKm / (double)height;
+		if (width < height) {
+			scale = (double) scaleKm / (double) height;
 		} else {
-			scale = (double)scaleKm / (double)width;
+			scale = (double) scaleKm / (double) width;
 		}
 		centerX = (width / 2);
 		centerY = (height / 2);
-		//centerY = (int)(centerY-centerY*0.15);
-		g.setColor(new Color(0,255,0));
-		int radstep= 0, steps=0, radius = 0;
+		// centerY = (int)(centerY-centerY*0.15);
+		g.setColor(new Color(0, 255, 0));
+		int radstep = 0, steps = 0, radius = 0;
 
-		if(width > height){
-			radstep = (int)(10 / scale);
+		if (width > height) {
+			radstep = (int) (10 / scale);
 			steps = (width / radstep);
-		}else{
-			radstep = (int)(10 / scale);
+		} else {
+			radstep = (int) (10 / scale);
 			steps = (height / radstep);
 		}
-		for(int i = 1; i <= steps; i++){
-			radius = (radstep * i)*2;
-			g.drawEllipse(centerX-radius/2,centerY-radius/2, radius,radius);
+		for (int i = 1; i <= steps; i++) {
+			radius = (radstep * i) * 2;
+			g.drawEllipse(centerX - radius / 2, centerY - radius / 2, radius, radius);
 		}
-		g.drawLine(centerX,0,centerX,height);
-		g.drawLine(0,centerY,width,centerY);
+		g.drawLine(centerX, 0, centerX, height);
+		g.drawLine(0, centerY, width, centerY);
 
 		// Show 1 KM radius only if we have zoomed in (useful for cities with high density of caches)
-		if (scaleKm<=20) {
-			g.setColor(new Color(255,255,0)); // Yellow for 1km circle
-			radius = radstep/5;
-			g.drawEllipse(centerX-radius/2,centerY-radius/2, radius,radius);
+		if (scaleKm <= 20) {
+			g.setColor(new Color(255, 255, 0)); // Yellow for 1km circle
+			radius = radstep / 5;
+			g.drawEllipse(centerX - radius / 2, centerY - radius / 2, radius, radius);
 			g.free();
 		}
 		final AniImage aImg = new AniImage(img);
-		//iActP.addImage(aImg);
+		// iActP.addImage(aImg);
 		iActP.backgroundImage = img;
-		final int xPos = (pref.myAppWidth/2 - width/2);
-		aImg.setLocation(xPos,0);
+		final int xPos = (pref.myAppWidth / 2 - width / 2);
+		aImg.setLocation(xPos, 0);
 		aImg.refresh();
 	}
 
-	public void onEvent(Event ev){
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if (ev.target == btPlus){
-				if (scaleKm>10) scaleKm = scaleKm - 10;
-				else if (scaleKm==10) scaleKm=5;
-				else if (scaleKm==5) scaleKm=2;
-				else scaleKm=1;
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
+			if (ev.target == btPlus) {
+				if (scaleKm > 10)
+					scaleKm = scaleKm - 10;
+				else if (scaleKm == 10)
+					scaleKm = 5;
+				else if (scaleKm == 5)
+					scaleKm = 2;
+				else
+					scaleKm = 1;
 				drawThePanel();
 			}
-			if (ev.target == btMinus){
-				if (scaleKm==1) scaleKm=2;
-				else if(scaleKm==2) scaleKm=5;
-				else if(scaleKm==5) scaleKm=10;
-				else scaleKm = scaleKm + 10;
+			if (ev.target == btMinus) {
+				if (scaleKm == 1)
+					scaleKm = 2;
+				else if (scaleKm == 2)
+					scaleKm = 5;
+				else if (scaleKm == 5)
+					scaleKm = 10;
+				else
+					scaleKm = scaleKm + 10;
 				drawThePanel();
 			}
-			if (ev.target == btToggle){
+			if (ev.target == btToggle) {
 				toggleMod++;
-				if(toggleMod > 2) toggleMod = 0;
+				if (toggleMod > 2)
+					toggleMod = 0;
 				drawThePanel();
 			}
 		}

Modified: trunk/src/CacheWolf/navi/MapImage.java
===================================================================
--- trunk/src/CacheWolf/navi/MapImage.java	2011-05-18 14:06:48 UTC (rev 3007)
+++ trunk/src/CacheWolf/navi/MapImage.java	2011-05-20 16:46:24 UTC (rev 3008)
@@ -1,29 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
+
 import ewe.fx.Color;
 import ewe.fx.Dimension;
 import ewe.fx.Image;
@@ -35,45 +36,52 @@
 import ewe.graphics.AniImage;
 import ewe.io.FileInputStream;
 import ewe.io.IOException;
-/** 
+
+/**
  * class that can be used with any x and any y
- * it will save taht location and make itself automatically
- * invisible if it is not on the screen. Call setscreensize to
- * set the screensize
+ * it will save that location and
+ * make itself automatically invisible if it is not on the screen.
+ * Call setscreensize to set the screensize
+ * 
  * @author pfeffer
- *
+ * 
  */
 public class MapImage extends AniImage {
 	public Point locAlways = new Point(); // contains the theoretical location even if it the location is out of the screen. If the image is on the screen, it contains the same as location
 	public static Dimension screenDim;
 	boolean hidden = false;
+
 	public MapImage() {
 		super();
-		if (screenDim == null) screenDim = new Dimension(0,0);
+		if (screenDim == null)
+			screenDim = new Dimension(0, 0);
 	}
 
 	public MapImage(String f) throws ImageDecodingException, UnsupportedImageFormatException, ImageNotFoundException, ewe.sys.SystemResourceException {
-		if (screenDim == null) screenDim = new Dimension(0,0);
-		//super(f); the following code is only necessary because of an Bug in ewe 1.49, which doesn't read from a fakefilesystem. If there were no bug, calling super(f) would be sufficient
+		if (screenDim == null)
+			screenDim = new Dimension(0, 0);
+		// super(f); the following code is only necessary because of an Bug in ewe 1.49, which doesn't read from a fakefilesystem. If there were no bug, calling super(f) would be sufficient
 		ewe.io.File file = ewe.sys.Vm.newFileObject();
 		file.set(null, f);
 		try {
-		//ByteArray imbytes = ewe.io.IO.readAllBytes(input, knownSize, stopAfterKnownSize);(file, null, true); // this would be possible if ewe 1.49 wouldn't have another bug: fakefilesystem doesn't implement (oderride) length(), it only overrides getLenght(), that's why readallBytes will call the original File implementation and cause and NullpointerException
-		setImage(new Image(new FileInputStream(f).toReadableStream(), 0), 0); // copied from super() 
-		freeSource(); // copied from super()
-		} catch (IOException e) { 
-			throw new ImageNotFoundException(f); // in order to behave the same way as super would have 
+			// ByteArray imbytes = ewe.io.IO.readAllBytes(input, knownSize, stopAfterKnownSize);(file, null, true); // this would be possible if ewe 1.49 wouldn't have another bug: fakefilesystem doesn't implement (oderride) length(), it only overrides
+			// getLenght(), that's why readallBytes will call the original File implementation and cause and NullpointerException
+			setImage(new Image(new FileInputStream(f).toReadableStream(), 0), 0); // copied from super()
+			freeSource(); // copied from super()
+		} catch (IOException e) {
+			throw new ImageNotFoundException(f); // in order to behave the same way as super would have
 		}
 	}
 
 	public MapImage(mImage im) {
 		super(im);
-		if (screenDim == null) screenDim = new Dimension(0,0);
+		if (screenDim == null)
+			screenDim = new Dimension(0, 0);
 	}
 
 	/**
 	 * Best you call this routine before you make any instance of MapImage
-	 * If the windows size changes after instantiation call  screenDimChanged()
+	 * If the windows size changes after instantiation call screenDimChanged()
 	 * for every symbol.
 	 * 
 	 */
@@ -83,13 +91,14 @@
 
 	public void setImage(Image im, Color c) {
 		super.setImage(im, c);
-		if (screenDim == null) screenDim = new Dimension(0,0);
+		if (screenDim == null)
+			screenDim = new Dimension(0, 0);
 	}
 
-	public void setLocation (int x, int y) {
+	public void setLocation(int x, int y) {
 		locAlways.x = x;
 		locAlways.y = y;
-		if (!hidden && isOnScreen()) { 
+		if (!hidden && isOnScreen()) {
 			super.setLocation(x, y);
 			properties &= ~mImage.IsInvisible;
 		} else {
@@ -98,10 +107,10 @@
 		}
 	}
 
-	public void move (int x, int y) {
+	public void move(int x, int y) {
 		locAlways.x = x;
 		locAlways.y = y;
-		if (!hidden && isOnScreen()) { 
+		if (!hidden && isOnScreen()) {
 			super.move(x, y);
 			properties &= ~mImage.IsInvisible;
 		} else {
@@ -110,23 +119,24 @@
 		}
 	}
 
-	public boolean isOnScreen() { 
-		if ( (locAlways.x + location.width > 0 && locAlways.x < screenDim.width) && 
-				(locAlways.y + location.height > 0 && locAlways.y < screenDim.height) ) return true;
-		else return false;
+	public boolean isOnScreen() {
+		if ((locAlways.x + location.width > 0 && locAlways.x < screenDim.width) && (locAlways.y + location.height > 0 && locAlways.y < screenDim.height))
+			return true;
+		else
+			return false;
 	}
 
 	public void screenDimChanged() {
 		move(locAlways.x, locAlways.y);
-		//if (!hidden && isOnScreen()) properties &= ~AniImage.IsInvisible;
-		//else properties |= AniImage.IsInvisible;
+		// if (!hidden && isOnScreen()) properties &= ~AniImage.IsInvisible;
+		// else properties |= AniImage.IsInvisible;
 	}
 
-
 	public void hide() {
 		hidden = true;
 		properties |= mImage.IsInvisible;
 	}
+
 	public void unhide() {
 		hidden = false;
 		move(locAlways.x, locAlways.y);

Modified: trunk/src/CacheWolf/navi/MapSymbol.java
===================================================================
--- trunk/src/CacheWolf/navi/MapSymbol.java	2011-05-18 14:06:48 UTC (rev 3007)
+++ trunk/src/CacheWolf/navi/MapSymbol.java	2011-05-20 16:46:24 UTC (rev 3008)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -33,26 +33,30 @@
 	String name;
 	String filename;
 	CWPoint where;
-	
+
 	public MapSymbol(String namei, String filenamei, CWPoint where_) {
 		name = namei;
 		filename = filenamei;
 		where = where_;
 	}
+
 	public MapSymbol(String namei, Object mapObjecti, String filenamei, CWPoint where_) {
 		name = namei;
 		filename = filenamei;
 		where = where_;
 		mapObject = mapObjecti;
 	}
+
 	public MapSymbol(String namei, Object mapObjecti, Image fromIm, CWPoint where_) {
 		name = namei;
 		where = where_;
 		mapObject = mapObjecti;
 		setImage(fromIm);
 	}
-	public void loadImage(){
-		setImage(new Image(filename),0); freeSource();;
-		//properties = AniImage.AlwaysOnTop;
+
+	public void loadImage() {
+		setImage(new Image(filename), 0);
+		freeSource();
+		// properties = AniImage.AlwaysOnTop;
 	}
 }

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2011-05-18 14:06:48 UTC (rev 3007)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2011-05-20 16:46:24 UTC (rev 3008)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -33,7 +33,6 @@
 import CacheWolf.CacheType;
 import CacheWolf.Common;
 import CacheWolf.Global;
-import CacheWolf.GuiImageBroker;
 import CacheWolf.InfoBox;
 import CacheWolf.MainTab;
 import CacheWolf.MyLocale;
@@ -86,17 +85,16 @@
 import ewe.util.Vector;
 
 /**
- *	Class to handle a moving map.
+ * Class to handle a moving map.
  */
 public final class MovingMap extends Form implements ICommandListener {
-	public final static int gotFix = 4; //green
-	public final static int lostFix = 3; //yellow
+	public final static int gotFix = 4; // green
+	public final static int lostFix = 3; // yellow
 	public final static int noGPSData = 2; // red
 	public final static int noGPS = 1; // no GPS-Position marker, manually disconnected
 	public final static int ignoreGPS = -1; // ignore even changes in GPS-signal (eg. from lost fix to gotFix) this is wanted when the map is moved manually
 
 	public MapSymbol gotoPos = null;
-	CacheHolder markedCache = null;
 	public int GpsStatus;
 	Preferences pref;
 	MovingMapPanel mmp;
@@ -107,7 +105,7 @@
 	CWPoint TrackOverlaySetCenterTopLeft;
 	Vector tracks;
 	MapInfoObject currentMap = null;
-	//String mapPath;
+	// String mapPath;
 	Navigate myNavigation;
 	boolean running = false;
 
@@ -117,9 +115,10 @@
 	AniImage statusImageNoSignal;
 	AniImage statusImageNoGps;
 	MapSymbol posCircle;
-	String MARK_CACHE_IMAGE;
+	final static Image imgSelectedCache = new Image("mark_cache.png");
+	final static Image imgGoto = new Image("goto_map.png");
 	int posCircleX = 0, posCircleY = 0, lastCompareX = Integer.MAX_VALUE, lastCompareY = Integer.MAX_VALUE;
-	//double posCircleLat, posCircleLon;
+	// double posCircleLat, posCircleLon;
 	FontMetrics fm;
 
 	boolean dontUpdatePos = false; // this is only internaly used to avoid multi-threading problems
@@ -130,8 +129,8 @@
 	boolean noMapsAvailable;
 	boolean zoomingMode = false;
 	public boolean mapsloaded = false;
-	boolean additionalOverlaysDeleted=true;
-	protected boolean paintPosDestLine=true;
+	boolean additionalOverlaysDeleted = true;
+	protected boolean paintPosDestLine = true;
 	Point lastRepaintMapPos = null;
 	double lastDistance = -1;
 
@@ -143,7 +142,7 @@
 	public static final int tileWidth = 100;
 	public static final int tileHeight = 100;
 
-	//Needed by updatePosition to decide if a recalculation of map-tiles is needed:
+	// Needed by updatePosition to decide if a recalculation of map-tiles is needed:
 	private int lastXPos;
 	private int lastYPos;
 	private int lastWidth;
@@ -157,11 +156,9 @@
 	public void setFillWhiteArea(boolean fillWhiteArea) {
 		pref.fillWhiteArea = fillWhiteArea;
 		if (!fillWhiteArea) { // remove tiles from panel
-			for (int i = mmp.images.size() -1; i >= 0; i--) {
+			for (int i = mmp.images.size() - 1; i >= 0; i--) {
 				final AniImage im = (AniImage) mmp.images.get(i);
-				if ((im instanceof MapImage)
-						&& (!((im instanceof MapSymbol)
-								|| (im instanceof TrackOverlay) || mmp.mapImage == im))) {
+				if ((im instanceof MapImage) && (!((im instanceof MapSymbol) || (im instanceof TrackOverlay) || mmp.mapImage == im))) {
 					mmp.images.remove(im);
 				}
 			}
@@ -170,7 +167,7 @@
 
 	public void setShowCachesOnMap(boolean value) {
 		if (value != pref.showCachesOnMap) {
-			pref.showCachesOnMap=value;
+			pref.showCachesOnMap = value;
 		}
 		if (!value) {
 			removeAllMapSymbols();
@@ -178,7 +175,6 @@
 
 	}
 
-
 	public boolean isMobileVga() {
 		return mobileVGA;
 	}
@@ -191,41 +187,41 @@
 		return controlsLayer;
 	}
 
-	public MovingMap(Navigate nav, CacheDB cacheDB){
+	public MovingMap(Navigate nav, CacheDB cacheDB) {
 		this.cacheDB = cacheDB;
 		this.myNavigation = nav;
 		this.pref = Global.getPref();
-		if (pref.myAppHeight <= 640 && pref.myAppWidth <= 640)	this.windowFlagsToSet = WindowConstants.FLAG_FULL_SCREEN;
-//      The following line is commented out, because this caused trouble under ewe-vm v1.49 on win-xp
-//      when MovingMap was started with maximized CacheWolf-Window
-//		this.windowFlagsToClear = WindowConstants.FLAG_HAS_TITLE | UIConstants.BDR_NOBORDER;
+		if (pref.myAppHeight <= 640 && pref.myAppWidth <= 640)
+			this.windowFlagsToSet = WindowConstants.FLAG_FULL_SCREEN;
+		// The following line is commented out, because this caused trouble under ewe-vm v1.49 on win-xp
+		// when MovingMap was started with maximized CacheWolf-Window
+		// this.windowFlagsToClear = WindowConstants.FLAG_HAS_TITLE | UIConstants.BDR_NOBORDER;
 		this.hasTopBar = false;
 		this.noBorder = true;
 		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
-//		this.setPreferredSize(240,320);
+		// this.setPreferredSize(240,320);
 		this.title = "Moving Map";
-		this.backGround = new Color(254,254,254); // background must not be black because black is interpreted as transparent and transparent images above (eg trackoverlay) want be drawn in windows-VM, so be care, don|t use white either
+		this.backGround = new Color(254, 254, 254); // background must not be black because black is interpreted as transparent and transparent images above (eg trackoverlay) want be drawn in windows-VM, so be care, don|t use white either
 
 		mmp = new MovingMapPanel(this);
 		this.addLast(mmp);
 
 		if (Vm.isMobile() && MyLocale.getScreenWidth() >= 400)
 			mobileVGA = true;
-		String imagesize="";
-		if(mobileVGA) imagesize="_vga";
+		String imagesize = "";
+		if (mobileVGA)
+			imagesize = "_vga";
 
-
-		statusImageHaveSignal = new AniImage("position_green"+imagesize+".png");
-		statusImageNoSignal = new AniImage("position_yellow"+imagesize+".png");
-		statusImageNoGps = new AniImage("position_red"+imagesize+".png");
-		posCircle = new MapSymbol("position_green"+imagesize+".png", "gps-position", new CWPoint());
-		MARK_CACHE_IMAGE = "mark_cache.png";
-		//directionArrows
+		statusImageHaveSignal = new AniImage("position_green" + imagesize + ".png");
+		statusImageNoSignal = new AniImage("position_yellow" + imagesize + ".png");
+		statusImageNoGps = new AniImage("position_red" + imagesize + ".png");
+		posCircle = new MapSymbol("position_green" + imagesize + ".png", "gps-position", new CWPoint());
+		// directionArrows
 		directionArrows.properties = mImage.AlwaysOnTop;
 		mmp.addImage(directionArrows);
-		//target distance
-		final int fontSize = ( 3 * pref.fontSize ) / 2;
-		final Font imageFont = new Font("Helvetica", Font.PLAIN, fontSize );
+		// target distance
+		final int fontSize = (3 * pref.fontSize) / 2;
+		final Font imageFont = new Font("Helvetica", Font.PLAIN, fontSize);
 		fm = getFontMetrics(imageFont);
 		setGpsStatus(noGPS);
 		posCircle.properties = mImage.AlwaysOnTop;
@@ -237,42 +233,49 @@
 		mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
 		lastHighestResolutionGPSDestScale = -1;
 
-		lastRepaintMapPos = new Point(pref.myAppWidth +1, pref.myAppHeight +1);
+		lastRepaintMapPos = new Point(pref.myAppWidth + 1, pref.myAppHeight + 1);
 
 		controlsLayer = new MovingMapControls(this);
 
-
 	}
 
-	public void resizeTo(int w,int h) {
+	public void resizeTo(int w, int h) {
 		super.resizeTo(w, h);
 		updateFormSize(w, h);
 	}
 
 	public void updateFormSize(int w, int h) {
 		MapImage.setScreenSize(w, h);
-		directionArrows.setLocation(w/2-directionArrows.getWidth()/2, 10);
-		if (mmp.mapImage != null) mmp.mapImage.screenDimChanged();
-		if (posCircle != null) posCircle.screenDimChanged();
-		if (tracks != null) rebuildOverlaySet();
+		directionArrows.setLocation(w / 2 - directionArrows.getWidth() / 2, 10);
+		if (mmp.mapImage != null)
+			mmp.mapImage.screenDimChanged();
+		if (posCircle != null)
+			posCircle.screenDimChanged();
+		if (tracks != null)
+			rebuildOverlaySet();
 		if (symbols != null) { // TODO: see if the rest of the code works with symbols = null
-			for (int i = symbols.size() -1; i >= 0; i-- ) {
-				((MapSymbol)symbols.get(i)).screenDimChanged();
+			for (int i = symbols.size() - 1; i >= 0; i--) {
+				((MapSymbol) symbols.get(i)).screenDimChanged();
 			}
 		}
-		if (controlsLayer!=null) {
+		if (controlsLayer != null) {
 			controlsLayer.updateFormSize(w, h);
 		}
 	}
 
 	boolean loadingMapList = false;
+
 	/**
 	 * loads the list of maps
-	 * @param mapsPath must not have a trailing end "/"
-	 * @param lat used to create empty maps with correct conversion from lon to meters the latitude must be known
+	 * 
+	 * @param mapsPath
+	 *            must not have a trailing end "/"
+	 * @param lat
+	 *            used to create empty maps with correct conversion from lon to meters the latitude must be known
 	 */
-	public void loadMaps(String mapsPath, double lat){
-		if (loadingMapList) return;
+	public void loadMaps(String mapsPath, double lat) {
+		if (loadingMapList)
+			return;
 		loadingMapList = true;
 		final InfoBox inf = new InfoBox(MyLocale.getMsg(4201, "Info"), MyLocale.getMsg(4203, "Loading list of maps..."));
 		Vm.showWait(this, true);
@@ -283,9 +286,11 @@
 		dontUpdatePos = true;
 		maps = new MapsList(mapsPath); // this actually loads the maps
 		if (maps.isEmpty()) {
-			(new MessageBox(MyLocale.getMsg(4201, "Information"), MyLocale.getMsg(4204, "No georeferenced map available \n Please choose a scale \n to show the track and the caches. \n You can get one by the menu: Application/Maps/download calibrated"), FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(4201, "Information"), MyLocale.getMsg(4204, "No georeferenced map available \n Please choose a scale \n to show the track and the caches. \n You can get one by the menu: Application/Maps/download calibrated"),
+					FormBase.OKB)).execute();
 			noMapsAvailable = true;
-		} else noMapsAvailable = false;
+		} else
+			noMapsAvailable = false;
 		maps.addEmptyMaps(lat); // the empty maps must be added last, otherwise in method setBestMap, when no map is available, a malfunction will happen, see there
 		maps.onCompletedRead();
 		dontUpdatePos = saveGpsIgnoreStatus;
@@ -297,8 +302,7 @@
 
 	public void updateScale() {
 
-		if (currentMap != null)
-		{
+		if (currentMap != null) {
 			double lineLengthMeters = 40 * currentMap.scale;
 
 			final int metricSystem = pref.metricSystem;
@@ -312,7 +316,7 @@
 				smallUnit = Metrics.FEET;
 				threshold = 501;
 
-				localizedLineLength = Metrics.convertUnit( lineLengthMeters, Metrics.METER, smallUnit);
+				localizedLineLength = Metrics.convertUnit(lineLengthMeters, Metrics.METER, smallUnit);
 			} else {
 				bigUnit = Metrics.KILOMETER;
 				smallUnit = Metrics.METER;
@@ -323,48 +327,44 @@
 
 			int currentUnit = smallUnit;
 
-			float digits = (float)java.lang.Math.floor( java.lang.Math.log(localizedLineLength) / java.lang.Math.log(10.0) );
-			localizedLineLength = (float)java.lang.Math.ceil( localizedLineLength / (float)java.lang.Math.pow(10, digits) ) * (float)java.lang.Math.pow(10, digits);
+			float digits = (float) java.lang.Math.floor(java.lang.Math.log(localizedLineLength) / java.lang.Math.log(10.0));
+			localizedLineLength = (float) java.lang.Math.ceil(localizedLineLength / (float) java.lang.Math.pow(10, digits)) * (float) java.lang.Math.pow(10, digits);
 
-			if (localizedLineLength >= threshold)
-			{
+			if (localizedLineLength >= threshold) {
 				currentUnit = bigUnit;
-				localizedLineLength = Metrics.convertUnit( lineLengthMeters, Metrics.METER, currentUnit);
+				localizedLineLength = Metrics.convertUnit(lineLengthMeters, Metrics.METER, currentUnit);
 
-				digits = (float)java.lang.Math.floor( java.lang.Math.log(localizedLineLength) / java.lang.Math.log(10.0) );
-				localizedLineLength = (float)java.lang.Math.ceil( localizedLineLength / (float)java.lang.Math.pow(10, digits) ) * (float)java.lang.Math.pow(10, digits);
+				digits = (float) java.lang.Math.floor(java.lang.Math.log(localizedLineLength) / java.lang.Math.log(10.0));
+				localizedLineLength = (float) java.lang.Math.ceil(localizedLineLength / (float) java.lang.Math.pow(10, digits)) * (float) java.lang.Math.pow(10, digits);
 			}
 
 			String lineLengthString = Convert.toString((int) localizedLineLength) + Metrics.getUnit(currentUnit);
 
-			if	(digits < 0){
+			if (digits < 0) {
 				final Double tmp = new Double();
 				tmp.set(localizedLineLength);
 
-				final int decimals = (int)(-1 * digits);
+				final int decimals = (int) (-1 * digits);
 
-				lineLengthString = tmp.toString(decimals+2,decimals,0) + Metrics.getUnit(currentUnit);
-//				lineLengthString = MyLocale.formatDouble(tmp,"0.000") + Metrics.getUnit(currentUnit);
+				lineLengthString = tmp.toString(decimals + 2, decimals, 0) + Metrics.getUnit(currentUnit);
+				// lineLengthString = MyLocale.formatDouble(tmp,"0.000") + Metrics.getUnit(currentUnit);
 			}
 
-			lineLengthMeters = Metrics.convertUnit( localizedLineLength, currentUnit, Metrics.METER);
+			lineLengthMeters = Metrics.convertUnit(localizedLineLength, currentUnit, Metrics.METER);
 
-			final int lineLengthPixels = (int)java.lang.Math.round( lineLengthMeters / currentMap.scale );
+			final int lineLengthPixels = (int) java.lang.Math.round(lineLengthMeters / currentMap.scale);
 
 			controlsLayer.updateContent("scale", lineLengthString, lineLengthPixels);
-		}
-		else{
+		} else {
 
-		controlsLayer.updateContent("scale", "no map", 20);
+			controlsLayer.updateContent("scale", "no map", 20);
 		}
 	}
 
 	public void updateDistance(boolean repaint) {
-		if (gotoPos != null && posCircle.where.isValid())
-		{
+		if (gotoPos != null && posCircle.where.isValid()) {
 			final double currentDistance = gotoPos.where.getDistance(posCircle.where);
-			if (currentDistance != lastDistance)
-			{
+			if (currentDistance != lastDistance) {
 				lastDistance = currentDistance;
 				final ewe.sys.Double dd = new ewe.sys.Double();
 				String d;
@@ -388,19 +388,17 @@
 					localizedDistance = currentDistance;
 				}
 				dd.set(localizedDistance);
-				if (dd.value >= threshold){
-					d = MyLocale.formatDouble(dd,"0.000") + Metrics.getUnit(bigUnit);
+				if (dd.value >= threshold) {
+					d = MyLocale.formatDouble(dd, "0.000") + Metrics.getUnit(bigUnit);
 				} else {
 					dd.set(Metrics.convertUnit(dd.value, bigUnit, smallUnit));
-					d = dd.toString(3,0,0) + Metrics.getUnit(smallUnit);
+					d = dd.toString(3, 0, 0) + Metrics.getUnit(smallUnit);
 				}
 
 				controlsLayer.updateContent("distance", d);
 
 			}
-		}
-		else
-		{
+		} else {
 			controlsLayer.updateContent("distance", "");
 		}
 	}
@@ -414,16 +412,17 @@
 		final FormFrame ret = exec();
 		running = true;
 		// disconnect movingMap from GPS TODO only if GPS-pos is not on the screen
-		if (forceCenter) setGpsStatus(noGPS);
+		if (forceCenter)
+			setGpsStatus(noGPS);
 		// to load maplist + place a map on screen otherwise no symbol can be placed
-		ignoreGps=true; // else overlay symbols are removed on started gps
+		ignoreGps = true; // else overlay symbols are removed on started gps
 
 		rebuildOverlaySet(); // show tracks , even if reentering map
 
 		updatePosition(centerTo);
 		setCenterOfScreen(centerTo, false);
 
-		if (getControlsLayer()!=null) {
+		if (getControlsLayer() != null) {
 			getControlsLayer().changeRoleState(MovingMapControls.ROLE_MENU, false);
 		}
 
@@ -431,50 +430,38 @@
 		if (Global.getProfile().selectionChanged) {
 			// this means marking has changed
 			Global.getProfile().selectionChanged = false;
-			if (pref.showCachesOnMap) removeAllMapSymbols(); // not really needed: hopefully removed by showCachesOnMap
+			if (pref.showCachesOnMap)
+				removeAllMapSymbols(); // not really needed: hopefully removed by showCachesOnMap
 		}
-		setMarkedCache(Global.mainTab.ch); // this is the selected one (not necessary marked)
 		showCachesOnMap();
 
 		if (myNavigation.destinationIsCache) {
 			destChanged(myNavigation.destinationCache);
-		}
-		else {
+		} else {
 			destChanged(myNavigation.destination);
 		}
 
 		repaint();
-		ignoreGps=false;
+		ignoreGps = false;
 
 		return ret;
 	}
 
-	public void setMarkedCache(CacheHolder ch) {
-		if (ch == markedCache) return;
-		if (markedCache != null) {
-			removeMapSymbol("selectedCache");
-			if (!markedCache.is_Checked) removeMapSymbol(markedCache);
-		}
-		if (ch != null) {
-			if ( ch.pos.isValid()) {
-				addSymbol("selectedCache", MARK_CACHE_IMAGE, ch.pos);
-				addSymbolIfNecessary(ch.getCacheName(), ch, GuiImageBroker.getTypeImage(ch.getType(),true,ch.is_found()), ch.pos);
-				markedCache = ch;
-			}
-		}
-	}
-
 	public void addTrack(Track tr) {
-		if (tr == null) return;
-		if (tracks == null) tracks = new Vector();
-		if (tracks.find(tr) >= 0 ) return; // track already in list
+		if (tr == null)
+			return;
+		if (tracks == null)
+			tracks = new Vector();
+		if (tracks.find(tr) >= 0)
+			return; // track already in list
 		tracks.add(tr);
 		rebuildOverlaySet();
 	}
 
 	public void addTracks(Track[] trs) {
-		if (trs==null || trs.length == 0) return;
-		for (int i=0; i<trs.length; i++) {
+		if (trs == null || trs.length == 0)
+			return;
+		for (int i = 0; i < trs.length; i++) {
 			addTrack(trs[i]);
 		}
 		rebuildOverlaySet();
@@ -482,26 +469,28 @@
 
 	/**
 	 * adds an 3x3 set of overlays to the map-window which contain the track
-	 *
+	 * 
 	 * add tracks with addtrack(track) before
 	 */
 
 	public void addOverlaySet() {
-		if (tracks == null) return; // no tracks
+		if (tracks == null)
+			return; // no tracks
 		try {
 			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
 			addMissingOverlays();
 		} catch (final NullPointerException e) {
 			// hapens if currentmap == null or PosCircle not valid
+		} catch (final IllegalArgumentException e) {
+			// happens if screensize is still not known ---> in both cases creation of Overlayset will be done in updateOverlayPos if tracks != null
 		}
-		catch (final IllegalArgumentException e) {
-			// happens if screensize is still not known    ---> in both cases creation of Overlayset will be done in updateOverlayPos if tracks != null
-		}
 	}
 
 	public void destroyOverlaySet() {
 		if (TrackOverlays != null) {
-			for (int i=0; i< TrackOverlays.length; i++) {	destroyOverlay(i);	}
+			for (int i = 0; i < TrackOverlays.length; i++) {
+				destroyOverlay(i);
+			}
 		}
 		Vm.getUsedMemory(true); // call garbage collection
 		Vm.gc();
@@ -513,7 +502,8 @@
 	}
 
 	public void addMissingOverlays() {
-		if (currentMap == null || (!posCircle.where.isValid()) || width == 0 || height == 0) return; // height == 0 happens if this is called before the form ist displayed on the screen
+		if (currentMap == null || (!posCircle.where.isValid()) || width == 0 || height == 0)
+			return; // height == 0 happens if this is called before the form ist displayed on the screen
 		if (TrackOverlays == null) {
 			TrackOverlays = new TrackOverlay[9];
 			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
@@ -521,16 +511,16 @@
 		final boolean saveGPSIgnoreStatus = dontUpdatePos; // avoid multi-threading problems
 		dontUpdatePos = true;
 		final Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft); // TrackOverlay[4] == center of Trackoverlays
-		//upperleftOf4.x = (upperleftOf4.x + 1* width) % (width * 2) - 1 * width;
-		//upperleftOf4.y = (upperleftOf4.y + 1* height) % (height * 2) - 1 * height;
+		// upperleftOf4.x = (upperleftOf4.x + 1* width) % (width * 2) - 1 * width;
+		// upperleftOf4.y = (upperleftOf4.y + 1* height) % (height * 2) - 1 * height;
 		int i;
-		for (int yi=0; yi<3; yi++) {
-			for (int xi=0; xi<3; xi++) {
-				i = yi*3+xi;
-				if (TrackOverlays[i]==null) {
+		for (int yi = 0; yi < 3; yi++) {
+			for (int xi = 0; xi < 3; xi++) {
+				i = yi * 3 + xi;
+				if (TrackOverlays[i] == null) {
 					pref.log("addMissingOverlays: widht: " + width + ", height: " + height);
-					TrackOverlays[i]= new TrackOverlay(ScreenXY2LatLon(upperleftOf4.x+(xi-1)*width, upperleftOf4.y+(yi-1)*height), width, height, currentMap);
-					TrackOverlays[i].setLocation(width+1, height+1); // outside of the screen will hide it automatically it will get the correct position in upadteOverlayposition
+					TrackOverlays[i] = new TrackOverlay(ScreenXY2LatLon(upperleftOf4.x + (xi - 1) * width, upperleftOf4.y + (yi - 1) * height), width, height, currentMap);
+					TrackOverlays[i].setLocation(width + 1, height + 1); // outside of the screen will hide it automatically it will get the correct position in upadteOverlayposition
 					TrackOverlays[i].tracks = this.tracks;
 					TrackOverlays[i].paintTracks();
 					mmp.addImage(TrackOverlays[i]);
@@ -538,29 +528,32 @@
 			}
 		}
 		updateOverlayOnlyPos();
-		if (mmp.mapImage != null) mmp.images.moveToBack(mmp.mapImage);
+		if (mmp.mapImage != null)
+			mmp.images.moveToBack(mmp.mapImage);
 		dontUpdatePos = saveGPSIgnoreStatus;
 	}
 
 	private void destroyOverlay(int ov) {
-		if (TrackOverlays[ov] == null) return;
+		if (TrackOverlays[ov] == null)
+			return;
 		mmp.removeImage(TrackOverlays[ov]);
 		TrackOverlays[ov].free();
-		TrackOverlays[ov]=null;
+		TrackOverlays[ov] = null;
 	}
+
 	public void rearangeOverlays() {
 		final Point oldp = getXYonScreen(TrackOverlaySetCenterTopLeft);
 		if (TrackOverlays[1].isOnScreen()) { // oben raus
-			TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y - 2* height));
+			TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y - 2 * height));
 			destroyOverlay(6);
 			destroyOverlay(7);
 			destroyOverlay(8);
 			mmp.removeImage(TrackOverlays[0]);
 			mmp.removeImage(TrackOverlays[1]);
 			mmp.removeImage(TrackOverlays[2]);
-			TrackOverlays[6]=TrackOverlays[0];
-			TrackOverlays[7]=TrackOverlays[1];
-			TrackOverlays[8]=TrackOverlays[2];
+			TrackOverlays[6] = TrackOverlays[0];
+			TrackOverlays[7] = TrackOverlays[1];
+			TrackOverlays[8] = TrackOverlays[2];
 			mmp.addImage(TrackOverlays[6]);
 			mmp.addImage(TrackOverlays[7]);
 			mmp.addImage(TrackOverlays[8]);
@@ -572,16 +565,16 @@
 			destroyOverlay(5);
 		} else {
 			if (TrackOverlays[3].isOnScreen()) { // links raus
-				TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y ));
+				TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2 * width, oldp.y));
 				destroyOverlay(2);
 				destroyOverlay(5);
 				destroyOverlay(8);
 				mmp.removeImage(TrackOverlays[0]);
 				mmp.removeImage(TrackOverlays[3]);
 				mmp.removeImage(TrackOverlays[6]);
-				TrackOverlays[2]=TrackOverlays[0];
-				TrackOverlays[5]=TrackOverlays[3];
-				TrackOverlays[8]=TrackOverlays[6];
+				TrackOverlays[2] = TrackOverlays[0];
+				TrackOverlays[5] = TrackOverlays[3];
+				TrackOverlays[8] = TrackOverlays[6];
 				mmp.addImage(TrackOverlays[2]);
 				mmp.addImage(TrackOverlays[5]);
 				mmp.addImage(TrackOverlays[8]);
@@ -593,16 +586,16 @@
 				destroyOverlay(7);
 			} else {
 				if (TrackOverlays[5].isOnScreen()) { // rechts raus
-					TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y ));
+					TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2 * width, oldp.y));
 					destroyOverlay(0);
 					destroyOverlay(3);
 					destroyOverlay(6);
 					mmp.removeImage(TrackOverlays[2]);
 					mmp.removeImage(TrackOverlays[5]);
 					mmp.removeImage(TrackOverlays[8]);
-					TrackOverlays[0]=TrackOverlays[2];
-					TrackOverlays[3]=TrackOverlays[5];
-					TrackOverlays[6]=TrackOverlays[8];
+					TrackOverlays[0] = TrackOverlays[2];
+					TrackOverlays[3] = TrackOverlays[5];
+					TrackOverlays[6] = TrackOverlays[8];
 					mmp.addImage(TrackOverlays[0]);
 					mmp.addImage(TrackOverlays[3]);
 					mmp.addImage(TrackOverlays[6]);
@@ -614,16 +607,16 @@
 					destroyOverlay(7);
 				} else {
 					if (TrackOverlays[7].isOnScreen()) { // unten raus
-						TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y + 2* height));
+						TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y + 2 * height));
 						destroyOverlay(0);
 						destroyOverlay(1);
 						destroyOverlay(2);
 						mmp.removeImage(TrackOverlays[6]);
 						mmp.removeImage(TrackOverlays[7]);
 						mmp.removeImage(TrackOverlays[8]);
-						TrackOverlays[0]=TrackOverlays[6];
-						TrackOverlays[1]=TrackOverlays[7];
-						TrackOverlays[2]=TrackOverlays[8];
+						TrackOverlays[0] = TrackOverlays[6];
+						TrackOverlays[1] = TrackOverlays[7];
+						TrackOverlays[2] = TrackOverlays[8];
 						mmp.addImage(TrackOverlays[0]);
 						mmp.addImage(TrackOverlays[1]);
 						mmp.addImage(TrackOverlays[2]);
@@ -634,11 +627,11 @@
 						destroyOverlay(4);
 						destroyOverlay(5);
 					} else { // it is important to test for diagonal only if the other didn't match
-						if (TrackOverlays[0].isOnScreen()) {  // links oben raus
-							TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y - 2* height));
+						if (TrackOverlays[0].isOnScreen()) { // links oben raus
+							TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2 * width, oldp.y - 2 * height));
 							destroyOverlay(8);
 							mmp.removeImage(TrackOverlays[0]);
-							TrackOverlays[8]=TrackOverlays[0];
+							TrackOverlays[8] = TrackOverlays[0];
 							mmp.addImage(TrackOverlays[8]);
 							TrackOverlays[0] = null;
 							destroyOverlay(1);
@@ -650,10 +643,10 @@
 							destroyOverlay(7);
 						} else {
 							if (TrackOverlays[2].isOnScreen()) { // rechts oben raus
-								TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y - 2* height));
+								TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2 * width, oldp.y - 2 * height));
 								destroyOverlay(6);
 								mmp.removeImage(TrackOverlays[2]);
-								TrackOverlays[6]=TrackOverlays[2];
+								TrackOverlays[6] = TrackOverlays[2];
 								mmp.addImage(TrackOverlays[6]);
 								TrackOverlays[2] = null;
 								destroyOverlay(0);
@@ -665,10 +658,10 @@
 								destroyOverlay(8);
 							} else {
 								if (TrackOverlays[6].isOnScreen()) { // links unten raus
-									TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y + 2* height));
+									TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2 * width, oldp.y + 2 * height));
 									destroyOverlay(2);
 									mmp.removeImage(TrackOverlays[6]);
-									TrackOverlays[2]=TrackOverlays[6];
+									TrackOverlays[2] = TrackOverlays[6];
 									mmp.addImage(TrackOverlays[2]);
 									TrackOverlays[6] = null;
 									destroyOverlay(0);
@@ -680,10 +673,10 @@
 									destroyOverlay(8);
 								} else {
 									if (TrackOverlays[8].isOnScreen()) { // rechts unten raus
-										TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y + 2* height));
+										TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2 * width, oldp.y + 2 * height));
 										destroyOverlay(0);
 										mmp.removeImage(TrackOverlays[8]);
-										TrackOverlays[0]=TrackOverlays[8];
+										TrackOverlays[0] = TrackOverlays[8];
 										mmp.addImage(TrackOverlays[0]);
 										TrackOverlays[8] = null;
 										destroyOverlay(1);
@@ -693,49 +686,58 @@
 										destroyOverlay(5);
 										destroyOverlay(6);
 										destroyOverlay(7);
-									}else
-										for (int i=0; i<TrackOverlays.length; i++) {
+									} else
+										for (int i = 0; i < TrackOverlays.length; i++) {
 											destroyOverlay(i);
 											TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
 										} // this happens if a position jump occured
-								}}}}}}} // close all IFs
+								}
+							}
+						}
+					}
+				}
+			}
+		} // close all IFs
 		Vm.gc(); // call garbage collection
 	}
 
 	public void ShowLastAddedPoint(Track tr) {
-		if (TrackOverlays == null || tr == null) return;
-		for (int i=0; i<TrackOverlays.length; i++){
+		if (TrackOverlays == null || tr == null)
+			return;
+		for (int i = 0; i < TrackOverlays.length; i++) {
 			TrackOverlays[i].paintLastAddedPoint(tr);
 		}
 	}
 
 	public void updateOverlayOnlyPos() {
-		if (TrackOverlays == null || TrackOverlays[4] == null) return;
-		//	Point upperleft = getMapXYPosition();
+		if (TrackOverlays == null || TrackOverlays[4] == null)
+			return;
+		// Point upperleft = getMapXYPosition();
 		Point posOnScreen;
 		posOnScreen = getXYonScreen(TrackOverlays[4].topLeft);
 		final Dimension ws = mmp.getSize(null);
 		final int ww = ws.width;
 		final int wh = ws.height;
-		//Vm.sleep(100); // this is necessary because the ewe vm ist not multi-threaded and the serial thread also needs time
+		// Vm.sleep(100); // this is necessary because the ewe vm ist not multi-threaded and the serial thread also needs time
 		int num, pX, pY;
-		for (int yi=0; yi<3; yi++) {
-			for (int xi=0; xi<3; xi++) {
-				num = yi*3+xi;
-				pX = posOnScreen.x+(xi-1)*ww;
-				pY = posOnScreen.y+(yi-1)*wh;
+		for (int yi = 0; yi < 3; yi++) {
+			for (int xi = 0; xi < 3; xi++) {
+				num = yi * 3 + xi;
+				pX = posOnScreen.x + (xi - 1) * ww;
+				pY = posOnScreen.y + (yi - 1) * wh;
 				TrackOverlays[num].setLocation(pX, pY);
 			}
 		}
 	}
 
 	public void updateOverlayPos() {
-		if (tracks == null || tracks.size() == 0) return;
-		if (TrackOverlays == null || TrackOverlays[4] == null) addMissingOverlays();
+		if (tracks == null || tracks.size() == 0)
+			return;
+		if (TrackOverlays == null || TrackOverlays[4] == null)
+			addMissingOverlays();
 		else {
 			updateOverlayOnlyPos();
-			if (TrackOverlays[0].locAlways.x > 0 || TrackOverlays[2].locAlways.x < 0
-					|| TrackOverlays[0].locAlways.y > 0 || TrackOverlays[8].locAlways.y < 0) { // testForNeedToRearange
+			if (TrackOverlays[0].locAlways.x > 0 || TrackOverlays[2].locAlways.x < 0 || TrackOverlays[0].locAlways.y > 0 || TrackOverlays[8].locAlways.y < 0) { // testForNeedToRearange
 				rearangeOverlays();
 				addMissingOverlays();
 				// updateOverlayOnlyPos(); is called from addMissingOverlays
@@ -745,54 +747,58 @@
 
 	/**
 	 * move posCircle to the Centre of the Screen
-	 *
+	 * 
 	 */
 	public void resetCenterOfMap() {
 		if (width != 0) {
-			posCircleX = width /2;
-			posCircleY = height /2;
+			posCircleX = width / 2;
+			posCircleY = height / 2;
 		} else {
-			posCircleX = pref.myAppWidth/2; // maybe this could /should be repleced to windows size
-			posCircleY = pref.myAppHeight/2;
+			posCircleX = pref.myAppWidth / 2; // maybe this could /should be repleced to windows size
+			posCircleY = pref.myAppHeight / 2;
 		}
 		posCircle.hidden = false;
-		posCircle.move(posCircleX-posCircle.getWidth()/2, posCircleY-posCircle.getHeight()/2); // posCircle.setLocation caused a problem -> hiding the posCircle in some situation
+		posCircle.move(posCircleX - posCircle.getWidth() / 2, posCircleY - posCircle.getHeight() / 2); // posCircle.setLocation caused a problem -> hiding the posCircle in some situation
 	}
 
 	public void movePosCircleToLatLon(CWPoint p, boolean repaint) {
 		moveScreenXYtoLatLon(new Point(posCircleX, posCircleY), p, repaint);
 	}
 
-	public void setCenterOfScreen (CWPoint c, boolean repaint) {
-		moveScreenXYtoLatLon(new Point (this.width/2, this.height/2), c, repaint);
+	public void setCenterOfScreen(CWPoint c, boolean repaint) {
+		moveScreenXYtoLatLon(new Point(this.width / 2, this.height / 2), c, repaint);
 	}
 
 	public void moveScreenXYtoLatLon(Point s, CWPoint c, boolean repaint) {
 		final Point mappos = getMapPositionOnScreen();
 		final Point onscreenpos = getXYonScreen(c);
-		if (mmp != null && mmp.mapImage != null) mmp.mapImage.move(mappos.x - onscreenpos.x + s.x, mappos.y - onscreenpos.y + s.y);
+		if (mmp != null && mmp.mapImage != null)
+			mmp.mapImage.move(mappos.x - onscreenpos.x + s.x, mappos.y - onscreenpos.y + s.y);
 		mapMoved(s.x - onscreenpos.x, s.y - onscreenpos.y);
-		if (repaint) mmp.repaintNow();
+		if (repaint)
+			mmp.repaintNow();
 	}
 
-	/** call this if the map moved on the screen (by dragging)
+	/**
+	 * call this if the map moved on the screen (by dragging)
 	 * this routine will adjust (move accordingly) all other symbols on the screen
+	 * 
 	 * @param diffX
 	 * @param diffY
 	 */
 	public void mapMoved(int diffX, int diffY) {
 		final int w = posCircle.getWidth();
 		final int h = posCircle.getHeight();
-		final int npx = posCircleX-w/2+diffX;
-		final int npy = posCircleY-h/2+diffY;
+		final int npx = posCircleX - w / 2 + diffX;
+		final int npy = posCircleY - h / 2 + diffY;
 		posCircle.move(npx, npy);
-		posCircleX = posCircleX+diffX;
-		posCircleY = posCircleY+diffY;
-		if (posCircle.where.isValid()){
+		posCircleX = posCircleX + diffX;
+		posCircleY = posCircleY + diffY;
+		if (posCircle.where.isValid()) {
 			dontUpdatePos = false;
 			updatePosition(posCircle.where);
-		}
-		else updateSymbolPositions(); // will also be done in updatePosition
+		} else
+			updateSymbolPositions(); // will also be done in updatePosition
 		updateOverlayPos();
 	}
 
@@ -802,194 +808,222 @@
 	 * the map-position is calculated relativ to posCircle (x,y and lat/lon)
 	 * returns the same as mmp.mapImage.getLocation(mapPos);
 	 * but also works if mmp == null and is used to move the map to the correct point
+	 * 
 	 * @return
 	 */
 	public Point getMapPositionOnScreen() {
 		if (currentMap == null || !posCircle.where.isValid())
-			return new Point(pref.myAppWidth +1, pref.myAppHeight +1);
+			return new Point(pref.myAppWidth + 1, pref.myAppHeight + 1);
 		// in case no calculation is possible return somthing outside of the screen
 		final Point mapPos = new Point();
-		//if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
-		//else {
+		// if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
+		// else {
 		final Point mapposint = currentMap.calcMapXY(posCircle.where);
 		mapPos.x = posCircleX - mapposint.x;
 		mapPos.y = posCircleY - mapposint.y;
-		//}
+		// }
 		return mapPos;
 	}
 
 	/**
-	 *
+	 * 
 	 * @param lat
 	 * @param lon
 	 * @return
 	 */
-	public Point getXYonScreen(TrackPoint ll){
-		if (currentMap == null) return null;
+	public Point getXYonScreen(TrackPoint ll) {
+		if (currentMap == null)
+			return null;
 		final Point coords = currentMap.calcMapXY(ll);
 		final Point mapPos = getMapPositionOnScreen();
 		return new Point(coords.x + mapPos.x, coords.y + mapPos.y);
 	}
 
-	public CWPoint ScreenXY2LatLon (int px, int py){
+	public CWPoint ScreenXY2LatLon(int px, int py) {
 		final Point mapPos = getMapPositionOnScreen();
 		return currentMap.calcLatLon(px - mapPos.x, py - mapPos.y);
 	}
 
-
 	public void updateSymbolPositions() {
-		if (symbols == null) return;
+		if (symbols == null)
+			return;
 		Point pOnScreen;
 		MapSymbol symb;
 		int w, h;
 		showCachesOnMap();
-		for (int i=symbols.size()-1; i>=0; i--) {
-			symb = (MapSymbol)symbols.get(i);
+		for (int i = symbols.size() - 1; i >= 0; i--) {
+			symb = (MapSymbol) symbols.get(i);
 			pOnScreen = getXYonScreen(symb.where);
-			w=symb.getWidth();
-			h=symb.getHeight();
-			symb.move(pOnScreen.x-w/2, pOnScreen.y-h/2);
+			w = symb.getWidth();
+			h = symb.getHeight();
+			symb.move(pOnScreen.x - w / 2, pOnScreen.y - h / 2);
 		}
 	}
 
 	public MapSymbol addSymbol(String pName, String filename, CWPoint where) {
-		if (symbols==null) symbols=new Vector();
+		if (symbols == null)
+			symbols = new Vector();
 		final MapSymbol ms = new MapSymbol(pName, filename, where);
 		ms.loadImage();
 		ms.properties |= mImage.AlwaysOnTop;
 		final Point pOnScreen = getXYonScreen(where);
-		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		ms.setLocation(pOnScreen.x - ms.getWidth() / 2, pOnScreen.y - ms.getHeight() / 2);
 		symbols.add(ms);
 		mmp.addImage(ms);
 		return ms;
 	}
 
 	public MapSymbol addSymbol(String pName, Object mapObject, String filename, CWPoint where) {
-		if (symbols==null) symbols=new Vector();
+		if (symbols == null)
+			symbols = new Vector();
 		final MapSymbol ms = new MapSymbol(pName, mapObject, filename, where);
 		ms.loadImage();
 		ms.properties |= mImage.AlwaysOnTop;
 		final Point pOnScreen = getXYonScreen(where);
-		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		ms.setLocation(pOnScreen.x - ms.getWidth() / 2, pOnScreen.y - ms.getHeight() / 2);
 		symbols.add(ms);
 		mmp.addImage(ms);
 		return ms;
 	}
 
-	public void addSymbolIfNecessary(String pName, Object mapObject, Image imSymb, CWPoint where) {
-		if (findMapSymbol(pName) >= 0) return;
-		else addSymbol(pName, mapObject, imSymb, where);
+	private boolean addSymbolIsNecessary(String pName) {
+		if (findMapSymbol(pName) >= 0)
+			return false;
+		else
+			return true;
 	}
 
+	private void addSymbolIfNecessary(String pName, Object mapObject, Image imSymb, CWPoint where) {
+		if (findMapSymbol(pName) >= 0)
+			return;
+		else
+			addSymbol(pName, mapObject, imSymb, where);
+	}
+
 	public void addSymbolOnTop(String pName, Object mapObject, String filename, CWPoint where) {
-		removeMapSymbol(pName); // Object possibly removes another picture from screen
-		addSymbol(pName,mapObject,filename, where);
+		removeMapSymbol(mapObject);
+		addSymbol(pName, mapObject, filename, where);
 	}
 
 	public void addSymbol(String pName, Object mapObject, Image imSymb, CWPoint ll) {
-		if (symbols==null) symbols=new Vector();
+		if (symbols == null)
+			symbols = new Vector();
 		final MapSymbol ms = new MapSymbol(pName, mapObject, imSymb, ll);
 		ms.properties = mImage.AlwaysOnTop;
 		final Point pOnScreen = getXYonScreen(ll);
-		if (pOnScreen != null) ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		if (pOnScreen != null)
+			ms.setLocation(pOnScreen.x - ms.getWidth() / 2, pOnScreen.y - ms.getHeight() / 2);
 		symbols.add(ms);
 		mmp.addImage(ms);
 	}
 
 	public void destChanged(CWPoint d) {
-		if(!running || (d == null && gotoPos == null) ||
-				(d != null && gotoPos != null && gotoPos.where.equals(d))) return;
+		if (!running || (d == null && gotoPos == null) || (d != null && gotoPos != null && gotoPos.where.equals(d)))
+			return;
 		removeMapSymbol("goto");
-		if (d == null || !d.isValid() ) return;
+		if (d == null || !d.isValid())
+			return;
 		gotoPos = addSymbol("goto", "goto_map.png", d);
 		forceMapLoad = true;
 		// dirty hack: if this.width == 0, then the symbols are not on the screen
 		// and get hidden by updateSymbolPositions
-		if (this.width != 0) updatePosition(posCircle.where);
+		if (this.width != 0)
+			updatePosition(posCircle.where);
 	}
 
 	public void destChanged(CacheHolder ch) {
-		final CWPoint d = new CWPoint (ch.pos);
-		if(!running || (gotoPos != null && gotoPos.where.equals(d))) return;
+		final CWPoint d = new CWPoint(ch.pos);
+		if (!running || (gotoPos != null && gotoPos.where.equals(d)))
+			return;
 		removeMapSymbol("goto");
-		if (!d.isValid() ) return;
+		if (!d.isValid())
+			return;
 		gotoPos = addSymbol("goto", ch, "goto_map.png", d);
 		forceMapLoad = true;
 		// dirty hack: if this.width == 0, then the symbols are not on the screen
 		// and get hidden by updateSymbolPositions
-		if (this.width != 0) updatePosition(posCircle.where);
+		if (this.width != 0)
+			updatePosition(posCircle.where);
 	}
 
-	public CWPoint getGotoPos(){
-		if (gotoPos == null) return null;
+	public CWPoint getGotoPos() {
+		if (gotoPos == null)
+			return null;
 		return new CWPoint(gotoPos.where);
 	}
 
-	public void removeAllMapSymbols(){
-		if (symbols == null) return;
-		for (int i = symbols.size()-1; i >= 0; i--) {
-			mmp.removeImage((MapSymbol)symbols.get(i));
+	public void removeAllMapSymbols() {
+		if (symbols == null)
+			return;
+		for (int i = symbols.size() - 1; i >= 0; i--) {
+			mmp.removeImage((MapSymbol) symbols.get(i));
 		}
 		symbols.removeAllElements();
 	}
 
 	public void removeMapSymbol(String pName) {
 		final int symbNr = findMapSymbol(pName);
-		if (symbNr != -1) removeMapSymbol(symbNr);
+		if (symbNr != -1)
+			removeMapSymbol(symbNr);
 	}
 
 	public void removeMapSymbol(Object obj) {
 		final int symbNr = findMapSymbol(obj);
-		if (symbNr != -1) removeMapSymbol(symbNr);
+		if (symbNr != -1)
+			removeMapSymbol(symbNr);
 	}
 
 	public void removeMapSymbol(int SymNr) {
-		mmp.removeImage(((MapSymbol)symbols.get(SymNr)));
+		mmp.removeImage(((MapSymbol) symbols.get(SymNr)));
 		symbols.removeElementAt(SymNr);
 	}
 
 	public int findMapSymbol(String pName) {
-		if (symbols == null) return -1;
+		if (symbols == null)
+			return -1;
 		MapSymbol ms;
-		for (int i = symbols.size() -1; i >= 0 ; i--) {
-			ms= (MapSymbol)symbols.get(i);
-			if (ms.name == pName) return i;
+		for (int i = symbols.size() - 1; i >= 0; i--) {
+			ms = (MapSymbol) symbols.get(i);
+			if (ms.name == pName)
+				return i;
 		}
 		return -1;
 	}
 
 	public int findMapSymbol(Object obj) {
-		if (symbols == null) return -1;
+		if (symbols == null)
+			return -1;
 		MapSymbol ms;
-		for (int i = symbols.size() -1; i >= 0 ; i--) {
-			ms= (MapSymbol)symbols.get(i);
-			if (ms.mapObject == obj) return i;
+		for (int i = symbols.size() - 1; i >= 0; i--) {
+			ms = (MapSymbol) symbols.get(i);
+			if (ms.mapObject == obj)
+				return i;
 		}
 		return -1;
 	}
 
 	/**
 	 * Move the map so that the posCircle is at lat/lon
-	 *
+	 * 
 	 * @param
 	 */
-	public void updateOnlyPosition(CWPoint where, boolean updateOverlay){
+	public void updateOnlyPosition(CWPoint where, boolean updateOverlay) {
 		posCircle.where.set(where);
 		final Point mapPos = getMapPositionOnScreen();
-		if (forceMapLoad || (java.lang.Math.abs(lastRepaintMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(lastRepaintMapPos.y - mapPos.y) > 1))
-		{
+		if (forceMapLoad || (java.lang.Math.abs(lastRepaintMapPos.x - mapPos.x) > 1 || java.lang.Math.abs(lastRepaintMapPos.y - mapPos.y) > 1)) {
 			lastRepaintMapPos = mapPos;
-			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x, mapPos.y);
+			if (mmp.mapImage != null)
+				mmp.mapImage.move(mapPos.x, mapPos.y);
 			updateSymbolPositions();
 			updateDistance(false);
-			if (updateOverlay ) updateOverlayPos(); // && TrackOverlays != null
+			if (updateOverlay)
+				updateOverlayPos(); // && TrackOverlays != null
 			repaint(); // don't wait
-		}
-		else
-		{
+		} else {
 			updateDistance(true);
 		}
 	}
+
 	private void loadBestMap(CWPoint where) {
 		if (!mapsloaded || !this.maps.getMapsPath().equals(pref.getCustomMapsPath())) {
 			loadMaps(pref.getCustomMapsPath(), where.latDec);
@@ -1000,46 +1034,44 @@
 			forceMapLoad = false;
 		}
 	}
+
 	/**
 	 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
 	 */
-	public void updatePosition(CWPoint where){
-		if (dontUpdatePos || loadingMapList) return; // avoid multi-threading problems
+	public void updatePosition(CWPoint where) {
+		if (dontUpdatePos || loadingMapList)
+			return; // avoid multi-threading problems
 		loadBestMap(where);
-		if (width==0 || height==0) { pref.log("[MovingMap:updatePosition]no window shown"); return; } // why is this called with these values
+		if (width == 0 || height == 0) {
+			pref.log("[MovingMap:updatePosition]no window shown");
+			return;
+		} // why is this called with these values
 		updateOnlyPosition(where, true);
 		final Point mapPos = getMapPositionOnScreen();
-		final boolean screenNotCompletlyCovered = (mmp.mapImage == null)
-				|| (mmp.mapImage != null && (
-				   mapPos.y > 0                                      || mapPos.x                           > 0
-				|| mapPos.y + mmp.mapImage.getHeight() < this.height || mapPos.x + mmp.mapImage.getWidth() < this.width));
-		//if screendimensions changed also force reload of map
+		final boolean screenNotCompletlyCovered = (mmp.mapImage == null) || (mmp.mapImage != null && (mapPos.y > 0 || mapPos.x > 0 || mapPos.y + mmp.mapImage.getHeight() < this.height || mapPos.x + mmp.mapImage.getWidth() < this.width));
+		// if screendimensions changed also force reload of map
 		forceMapLoad |= lastWidth != width || lastHeight != height;
 		if (forceMapLoad || wantMapTest || screenNotCompletlyCovered) { // if force || want || map doesn't cover the screen completly
-			if (forceMapLoad ||
-				(java.lang.Math.abs(lastCompareX - mapPos.x) > this.width / 10 ||
-				 java.lang.Math.abs(lastCompareY - mapPos.y) > this.height / 10)) {
+			if (forceMapLoad || (java.lang.Math.abs(lastCompareX - mapPos.x) > this.width / 10 || java.lang.Math.abs(lastCompareY - mapPos.y) > this.height / 10)) {
 				// more then 1/10 of screen moved since last time we tried to find a better map
 				if (autoSelectMap) {
 					setBestMap(where, screenNotCompletlyCovered);
 					forceMapLoad = false;
 				}
-				if (isFillWhiteArea()) { fillWhiteArea(screenNotCompletlyCovered); }
+				if (isFillWhiteArea()) {
+					fillWhiteArea(screenNotCompletlyCovered);
+				}
 				lastCompareX = mapPos.x;
 				lastCompareY = mapPos.y;
-			}
-			else{
+			} else {
 				final int deltaX = mapPos.x - lastXPos;
 				final int deltaY = mapPos.y - lastYPos;
-				for(int i = mmp.images.size() -1; i >= 0; i--){
+				for (int i = mmp.images.size() - 1; i >= 0; i--) {
 					final AniImage im = (AniImage) mmp.images.get(i);
-					if ((im instanceof MapImage)
-						&& (!((im instanceof MapSymbol)
-							|| (im instanceof TrackOverlay)
-							|| mmp.mapImage == im))) {
-						//locAlways contains the real coordinates while
-						//location is only correct if the image is on the screen.
-						final Point p = ((MapImage)im).locAlways;
+					if ((im instanceof MapImage) && (!((im instanceof MapSymbol) || (im instanceof TrackOverlay) || mmp.mapImage == im))) {
+						// locAlways contains the real coordinates while
+						// location is only correct if the image is on the screen.
+						final Point p = ((MapImage) im).locAlways;
 						p.x += deltaX;
 						p.y += deltaY;
 						im.setLocation(p.x, p.y);
@@ -1057,33 +1089,28 @@
 	private void showCachesOnMap() {
 		// if (width == 0 || height == 0) return;
 		CacheHolder ch;
-		final Area screenArea = new Area(ScreenXY2LatLon(0,0), ScreenXY2LatLon(width,height));
+		final Area screenArea = new Area(ScreenXY2LatLon(0, 0), ScreenXY2LatLon(width, height));
 		for (int i = cacheDB.size() - 1; i >= 0; i--) {
 			ch = cacheDB.get(i);
 			if (screenArea.isInBound(ch.pos)) {
 				// because visible and valid don't change while showing map -->need no remove
 				if (ch.isVisible() && ch.pos.isValid()) {
 					if (pref.showCachesOnMap) {
-						addSymbolIfNecessary(ch.cacheName, ch, GuiImageBroker.getTypeImage(ch.getType(),true,ch.is_found()), ch.pos);
-					}
-					else {
-						if (ch.is_Checked) {
-							addSymbolIfNecessary(ch.cacheName, ch, GuiImageBroker.getTypeImage(ch.getType(),true,ch.is_found()), ch.pos);
+						if (addSymbolIsNecessary(ch.getWayPoint())) {
+							addSymbol(ch.getWayPoint(), ch, CacheType.getMapImage(ch), ch.pos);
 						}
-						else {
+					} else {
+						if (ch.is_Checked || ch == Global.mainTab.ch) {
+							if (addSymbolIsNecessary(ch.getWayPoint())) {
+								addSymbol(ch.getWayPoint(), ch, CacheType.getMapImage(ch), ch.pos);
+							}
+						} else {
 							removeMapSymbol(ch);
 						}
 					}
 				}
-			}else{
-				if (ch.cacheName.equals("")) {
-					removeMapSymbol(ch);
-				}
-				else {
-					// remove the right one , as
-					// possibly more than one picture associated with ch (target,selected ..)
-					removeMapSymbol(ch.cacheName);
-				}
+			} else {
+				removeMapSymbol(ch);
 			}
 		}
 		// adding target and selected
@@ -1098,182 +1125,175 @@
 			if (gotoPosCH != null) {
 				if (screenArea.isInBound(gotoPosCH.pos)) {
 					if (!pref.showCachesOnMap) {
-						addSymbolIfNecessary(gotoPosCH.cacheName, gotoPosCH, GuiImageBroker.getTypeImage(gotoPosCH.getType(),true,gotoPosCH.is_found()), gotoPosCH.pos);
+						addSymbolIfNecessary(gotoPosCH.getWayPoint(), gotoPosCH, CacheType.getMapImage(gotoPosCH), gotoPosCH.pos);
 					}
-					addSymbolOnTop("goto", gotoPosCH, "goto_map.png", gotoPos.where);
+					addSymbolIfNecessary("goto", gotoPosCH, imgGoto, gotoPos.where);
 				}
 			}
 		}
-		// show Selected
-		if (markedCache != null) {
-			if (screenArea.isInBound(markedCache.pos)) {
-				addSymbolIfNecessary(markedCache.cacheName, markedCache, GuiImageBroker.getTypeImage(markedCache.getType(),true, false), markedCache.pos);
-				addSymbolOnTop("selectedCache", markedCache, MARK_CACHE_IMAGE, markedCache.pos);
+		// mark Selected
+		ch = cacheDB.get(Global.mainTab.tbP.getSelectedCache());
+		if (ch != null) {
+			if (screenArea.isInBound(ch.pos)) {
+				addSymbolIfNecessary("selectedCache", ch, imgSelectedCache, ch.pos);
 			}
 		}
 	}
-	boolean reflectResourceException=true;
+
+	boolean reflectResourceException = true;
+
 	private void fillWhiteArea(boolean screenNotCompletlyCovered) {
-		if (mmp.mapImage == null) return; // if error at map load
+		if (mmp.mapImage == null)
+			return; // if error at map load
 		// Clean up any additional images, tiles will removed and any
 		// other item be added again later
 		final Vector icons = new Vector(mmp.images.size());
 		try {
-		Vm.showWait(true);
-		dontUpdatePos=true; // no new Position while filling
+			Vm.showWait(true);
+			dontUpdatePos = true; // no new Position while filling
 
-		final int s = mmp.images.size(); // avoid calling size() in each iteration
-		for (int i = 0; i < s ;  i++) {
-			final AniImage im = (AniImage) mmp.images.get(i);
-			if (!(im instanceof MapImage) ||
-				(im instanceof MapSymbol) ||
-				(im instanceof TrackOverlay) ||
-				mmp.mapImage == im) {
-				icons.add(im);
+			final int s = mmp.images.size(); // avoid calling size() in each iteration
+			for (int i = 0; i < s; i++) {
+				final AniImage im = (AniImage) mmp.images.get(i);
+				if (!(im instanceof MapImage) || (im instanceof MapSymbol) || (im instanceof TrackOverlay) || mmp.mapImage == im) {
+					icons.add(im);
+				}
 			}
-		}
-		mmp.images.clear();
-		// Mark all tiles as dirty
-		MovingMapCache.getCache().clearUsedFlags();
+			mmp.images.clear();
+			// Mark all tiles as dirty
+			MovingMapCache.getCache().clearUsedFlags();
 
-		// Holds areas not filled by currentmap and/or used tiles
-		final Vector rectangles = new Vector();
-		// calculate areas which will not drawn
-		final Point mapPosx = getMapPositionOnScreen();
-		if ( screenNotCompletlyCovered && ( // screen not completely covered is only used, because it is already calculated
-				mapPosx.x > this.width || mapPosx.y > this.height // map doesn't overlap with the screen
-				|| mapPosx.x + mmp.mapImage.getWidth() < 0 || mapPosx.y + mmp.mapImage.getHeight() < 0) ) {
-			rectangles.add(new Rect(0,0, this.width, this.height)); // if the map is completely outside the screen, just fill the screen, nit all the space beteween the map and the screen
-		} else {
-			final Rect whiteArea = new Rect((-width/10), (-height/10), (int)(width*1.1), (int)(height*1.1));
-			final Rect blackArea = new Rect(mapPosx.x, mapPosx.y, mmp.mapImage.getWidth(), mmp.mapImage.getHeight());
-			calculateRectangles(blackArea, whiteArea, rectangles);
-		}
-		// I've sometimes experienced an endless loop which might be
-		// caused by a bug in getBestMap. Therefore i will stop the loop
-		// after 30 runs
-		int count = 0;
-		while (isFillWhiteArea() && currentMap.zoomFactor == 1.0
-				&& !mapHidden && !rectangles.isEmpty() && count < 30) {
-			count++;
-			try {
-				updateTileForWhiteArea(rectangles);
+			// Holds areas not filled by currentmap and/or used tiles
+			final Vector rectangles = new Vector();
+			// calculate areas which will not drawn
+			final Point mapPosx = getMapPositionOnScreen();
+			if (screenNotCompletlyCovered && ( // screen not completely covered is only used, because it is already calculated
+					mapPosx.x > this.width || mapPosx.y > this.height // map doesn't overlap with the screen
+							|| mapPosx.x + mmp.mapImage.getWidth() < 0 || mapPosx.y + mmp.mapImage.getHeight() < 0)) {
+				rectangles.add(new Rect(0, 0, this.width, this.height)); // if the map is completely outside the screen, just fill the screen, nit all the space beteween the map and the screen
+			} else {
+				final Rect whiteArea = new Rect((-width / 10), (-height / 10), (int) (width * 1.1), (int) (height * 1.1));
+				final Rect blackArea = new Rect(mapPosx.x, mapPosx.y, mmp.mapImage.getWidth(), mmp.mapImage.getHeight());
+				calculateRectangles(blackArea, whiteArea, rectangles);
 			}
-			catch (final ewe.sys.SystemResourceException sre) {
-				// next time there may be no problem, and ask only once
-				if (reflectResourceException) {
-					if (new MessageBox(
-							"Error",
-							"Not enough ressources to fill white ares, disabling this",
-							MessageBox.YESB | MessageBox.NOB).execute() == MessageBox.IDYES) {
-						setFillWhiteArea(false);
-						reflectResourceException=true;
+			// I've sometimes experienced an endless loop which might be
+			// caused by a bug in getBestMap. Therefore i will stop the loop
+			// after 30 runs
+			int count = 0;
+			while (isFillWhiteArea() && currentMap.zoomFactor == 1.0 && !mapHidden && !rectangles.isEmpty() && count < 30) {
+				count++;
+				try {
+					updateTileForWhiteArea(rectangles);
+				} catch (final ewe.sys.SystemResourceException sre) {
+					// next time there may be no problem, and ask only once
+					if (reflectResourceException) {
+						if (new MessageBox("Error", "Not enough ressources to fill white ares, disabling this", MessageBox.YESB | MessageBox.NOB).execute() == MessageBox.IDYES) {
+							setFillWhiteArea(false);
+							reflectResourceException = true;
+						} else {
+							reflectResourceException = false;
+						}
 					}
-					else {
-						reflectResourceException=false;
-					}
 				}
 			}
-		}
-		}
-		finally {
+		} finally {
 			// Remove all tiles not needed from the cache to reduce memory
 			MovingMapCache.getCache().cleanCache();
 			// At Last redraw all icons on the map
 			mmp.images.addAll(icons);
 			Vm.showWait(false);
-			dontUpdatePos=false; // do next Position
+			dontUpdatePos = false; // do next Position
 			repaint();
 		}
 	}
+
 	private void updateTileForWhiteArea(Vector rectangles) {
 		Rect blackArea;
 		final Rect r = (Rect) rectangles.get(0);
 		rectangles.removeElementAt(0);
-		//calculate the center of the rectangle and try to get an map for it
-		final int middlewidth = r.x + (r.width)/2;
-		final int middleheight = r.y + (r.height)/2;
+		// calculate the center of the rectangle and try to get an map for it
+		final int middlewidth = r.x + (r.width) / 2;
+		final int middleheight = r.y + (r.height) / 2;
 		final CWPoint centerPoint = ScreenXY2LatLon(middlewidth, middleheight);
-		final Rect screen = new Rect ();
-		screen.height = r.height ;//- r.y;
-		screen.width = r.width ;//- r.x;
-		final MapInfoObject bestMap = maps.getBestMap(centerPoint, screen, currentMap.scale, true,false);
-		if (bestMap == null){
-			//No map found, area must be left white
+		final Rect screen = new Rect();
+		screen.height = r.height;// - r.y;
+		screen.width = r.width;// - r.x;
+		final MapInfoObject bestMap = maps.getBestMap(centerPoint, screen, currentMap.scale, true, false);
+		if (bestMap == null) {
+			// No map found, area must be left white
 			return;
 		}
-		//A map was found, but it does not contain the previously calculated center
-		if (!(bestMap.bottomright.latDec <= centerPoint.latDec && centerPoint.latDec <= bestMap.topleft.latDec)){
+		// A map was found, but it does not contain the previously calculated center
+		if (!(bestMap.bottomright.latDec <= centerPoint.latDec && centerPoint.latDec <= bestMap.topleft.latDec)) {
 			return;
 		}
-		if (!(bestMap.topleft.lonDec <= centerPoint.lonDec && centerPoint.lonDec <= bestMap.bottomright.lonDec)){
+		if (!(bestMap.topleft.lonDec <= centerPoint.lonDec && centerPoint.lonDec <= bestMap.bottomright.lonDec)) {
 			return;
 		}
-		//Pfeffer got an NPE in the following if-statement. I think the image-filename has got not the correct extension.
-		//For me, showing a message seems better than throwing the NPE
+		// Pfeffer got an NPE in the following if-statement. I think the image-filename has got not the correct extension.
+		// For me, showing a message seems better than throwing the NPE
 		final String imagefilename = bestMap.getImageFilename();
-		if (imagefilename == null){
-			(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4217, "Could not find image associated with: \n")+currentMap.fileNameWFL, FormBase.OKB)).execute();
+		if (imagefilename == null) {
+			(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4217, "Could not find image associated with: \n") + currentMap.fileNameWFL, FormBase.OKB)).execute();
 			return;
 		}
 
 		if (!imagefilename.equals(currentMap.getImageFilename())) {
 			final String filename = bestMap.getImageFilename();
 			if (filename.length() > 0) {
-				//calculate position of the new map on the screen
+				// calculate position of the new map on the screen
 				final Point mapPos = new Point();
 				final Point mapposint = bestMap.calcMapXY(posCircle.where);
 				mapPos.x = posCircleX - mapposint.x;
 				mapPos.y = posCircleY - mapposint.y;
 				final Point mapDimension = bestMap.calcMapXY(bestMap.bottomright);
-				blackArea = new Rect (mapPos.x, mapPos.y, mapDimension.x, mapDimension.y);
-				//Are there any white areas left?
+				blackArea = new Rect(mapPos.x, mapPos.y, mapDimension.x, mapDimension.y);
+				// Are there any white areas left?
 				calculateRectangles(blackArea, r, rectangles);
-				//Not all maps have the dimension 1000x1000 Pixels, we cache this information:
-				Dimension rect2 = MovingMapCache.getCache().getDimension (filename);
+				// Not all maps have the dimension 1000x1000 Pixels, we cache this information:
+				Dimension rect2 = MovingMapCache.getCache().getDimension(filename);
 				MapImage fullImage = null;
-				if (rect2 == null){
+				if (rect2 == null) {
 					fullImage = new MapImage(filename);
-					rect2 = new Dimension (fullImage.getHeight(), fullImage.getWidth());
-					MovingMapCache.getCache ().putDimension (filename, rect2);
+					rect2 = new Dimension(fullImage.getHeight(), fullImage.getWidth());
+					MovingMapCache.getCache().putDimension(filename, rect2);
 				}
 				generateTiles(blackArea, filename, mapPos, rect2, fullImage);
 			}
 		}
 	}
 
-	private void generateTiles(Rect blackArea, String filename, Point mapPos,
-			Dimension rect2, MapImage fullImage) {
-		//Generate tiles from the map
-		final int numRows = ((rect2.height-1)/tileHeight)+1;
-		final int numCols = ((rect2.width-1)/tileWidth)+1;
+	private void generateTiles(Rect blackArea, String filename, Point mapPos, Dimension rect2, MapImage fullImage) {
+		// Generate tiles from the map
+		final int numRows = ((rect2.height - 1) / tileHeight) + 1;
+		final int numCols = ((rect2.width - 1) / tileWidth) + 1;
 		for (int row = 0; row < numRows; row++) {
 			for (int column = 0; column < numCols; column++) {
-				//Tile is not needed, don't process
+				// Tile is not needed, don't process
 				if (!isCoveredByBlackArea(mapPos, row, column, blackArea, rect2)) {
 					continue;
 				}
-				//Get tile from cache or if not found, put all tiles for this image into the cache.
+				// Get tile from cache or if not found, put all tiles for this image into the cache.
 				MapImage im = MovingMapCache.getCache().get(filename, row, column);
 				if (im == null) {
-					if (fullImage == null){
+					if (fullImage == null) {
 						fullImage = new MapImage(filename);
 					}
 					putImageIntoCache(filename, fullImage, mapPos, blackArea);
 					im = MovingMapCache.getCache().get(filename, row, column);
 				}
-				//If a tile has been found, draw it on the screen
+				// If a tile has been found, draw it on the screen
 				if (im != null) {
-					//Check if not already added. this might happen if the map for horizontal and vertical stripe is the same
-					boolean added=false;
-					for(int i=mmp.images.size()-1; i >= 0; i--) {
-						final MapImage m=(MapImage) mmp.images.get(i);
-						if (m == im){
-							added=true;
+					// Check if not already added. this might happen if the map for horizontal and vertical stripe is the same
+					boolean added = false;
+					for (int i = mmp.images.size() - 1; i >= 0; i--) {
+						final MapImage m = (MapImage) mmp.images.get(i);
+						if (m == im) {
+							added = true;
 							break;
 						}
 					}
-					if(!added){
+					if (!added) {
 						im.setLocation(mapPos.x + (column * tileWidth), mapPos.y + (row * tileHeight));
 						mmp.addImage(im);
 					}
@@ -1284,13 +1304,13 @@
 
 	private void putImageIntoCache(String filename, MapImage fullImage, Point mapPos, Rect blackArea) {
 		MapImage im;
-		final int numRows = (fullImage.getHeight()-1)/tileHeight + 1;
-		final int numCols = (fullImage.getWidth()-1)/tileWidth + 1;
+		final int numRows = (fullImage.getHeight() - 1) / tileHeight + 1;
+		final int numCols = (fullImage.getWidth() - 1) / tileWidth + 1;
 		for (int row2 = 0; row2 < numRows; row2++) {
 			for (int column2 = 0; column2 < numCols; column2++) {
-				final int realWidth = java.lang.Math.min(tileWidth, (fullImage.getWidth() - tileWidth*column2));
-				final int realHeight = java.lang.Math.min(tileHeight, (fullImage.getHeight() - tileHeight*row2));
-				if (!isCoveredByBlackArea(mapPos, row2, column2, blackArea, new Dimension(fullImage.getWidth(), fullImage.getHeight()))){
+				final int realWidth = java.lang.Math.min(tileWidth, (fullImage.getWidth() - tileWidth * column2));
+				final int realHeight = java.lang.Math.min(tileHeight, (fullImage.getHeight() - tileHeight * row2));
+				if (!isCoveredByBlackArea(mapPos, row2, column2, blackArea, new Dimension(fullImage.getWidth(), fullImage.getHeight()))) {
 					continue;
 				}
 				final Image image2 = new Image(realWidth, realHeight);
@@ -1305,54 +1325,57 @@
 		}
 	}
 
-	private boolean isCoveredByBlackArea (Point mapPos, int row,int column,Rect blackArea, Dimension mapDimension){
-		final int realWidth = java.lang.Math.min(tileWidth, (mapDimension.width - tileWidth*column));
-		final int realHeight = java.lang.Math.min(tileHeight, (mapDimension.height - tileHeight*row));
+	private boolean isCoveredByBlackArea(Point mapPos, int row, int column, Rect blackArea, Dimension mapDimension) {
+		final int realWidth = java.lang.Math.min(tileWidth, (mapDimension.width - tileWidth * column));
+		final int realHeight = java.lang.Math.min(tileHeight, (mapDimension.height - tileHeight * row));
 		final int left = mapPos.x + column * tileWidth;
 		final int right = left + realWidth;
 		final int top = mapPos.y + row * tileHeight;
-		final int bottom = top +realHeight;
-		if (right < blackArea.x || bottom < blackArea.y){
+		final int bottom = top + realHeight;
+		if (right < blackArea.x || bottom < blackArea.y) {
 			return false;
 		}
-		if (left > blackArea.x + blackArea.width || top > blackArea.y + blackArea.height){
+		if (left > blackArea.x + blackArea.width || top > blackArea.y + blackArea.height) {
 			return false;
 		}
 		return true;
 	}
+
 	/*
-	private String SRect(Rect r){
-		String OL, UR ;
-		OL= " ("+String.valueOf(r.x)+","+String.valueOf(r.y)+")";
-		UR= " ("+String.valueOf(r.x+r.width)+","+String.valueOf(r.y+r.height)+") ";
-		return OL+" :"+UR;
-	}
-	*/
+	 * private String SRect(Rect r){
+	 * String OL, UR ;
+	 * OL= " ("+String.valueOf(r.x)+","+String.valueOf(r.y)+")";
+	 * UR= " ("+String.valueOf(r.x+r.width)+","+String.valueOf(r.y+r.height)+") ";
+	 * return OL+" :"+UR;
+	 * }
+	 */
 	private void calculateRectangles(Rect blackArea, Rect whiteArea, Vector rectangles) {
-		if (width == 0 || height == 0) return;
-		final int offsetX = width/10;
-		final int offsetY = height/10;
-		final int width=this.width+offsetX;
-		final int height=this.height+offsetY;
-		if (whiteArea.x >= width || whiteArea.y >= height) return;
+		if (width == 0 || height == 0)
+			return;
+		final int offsetX = width / 10;
+		final int offsetY = height / 10;
+		final int width = this.width + offsetX;
+		final int height = this.height + offsetY;
+		if (whiteArea.x >= width || whiteArea.y >= height)
+			return;
 
-		if (blackArea.x < -offsetX){
+		if (blackArea.x < -offsetX) {
 			blackArea.width += blackArea.x + offsetX;
 			blackArea.x = -offsetX;
 		}
-		if (blackArea.y < -offsetY){
+		if (blackArea.y < -offsetY) {
 			blackArea.height += blackArea.y + offsetY;
 			blackArea.y = -offsetY;
 		}
-		if (blackArea.x + blackArea.width > width){
+		if (blackArea.x + blackArea.width > width) {
 			blackArea.width = width - blackArea.x;
 		}
-		if (blackArea.y + blackArea.height > height){
+		if (blackArea.y + blackArea.height > height) {
 			blackArea.height = height - blackArea.y;
 		}
 
 		if (blackArea.x > whiteArea.x) {
-			final Rect r= new Rect ();
+			final Rect r = new Rect();
 			r.x = -offsetX;
 			r.y = whiteArea.y;
 			r.width = blackArea.x + offsetX;
@@ -1360,23 +1383,23 @@
 			rectangles.add(r);
 		}
 		if (blackArea.y > whiteArea.y) {
-			final Rect r= new Rect ();
+			final Rect r = new Rect();
 			r.x = whiteArea.x;
 			r.y = -offsetY;
 			r.width = whiteArea.width;
 			r.height = blackArea.y + offsetY;
 			rectangles.add(r);
 		}
-		if ((blackArea.y + blackArea.height) <  whiteArea.y + whiteArea.height) {
-			final Rect r= new Rect ();
+		if ((blackArea.y + blackArea.height) < whiteArea.y + whiteArea.height) {
+			final Rect r = new Rect();
 			r.x = whiteArea.x;
 			r.y = blackArea.y + blackArea.height;
 			r.width = whiteArea.width;
 			r.height = (whiteArea.y + whiteArea.height) - r.y;
 			rectangles.add(r);
 		}
-		if ((blackArea.x + blackArea.width)<  whiteArea.x + whiteArea.width) {
-			final Rect r= new Rect ();
+		if ((blackArea.x + blackArea.width) < whiteArea.x + whiteArea.width) {
+			final Rect r = new Rect();
 			r.x = blackArea.x + blackArea.width;
 			r.y = whiteArea.y;
 			r.width = (whiteArea.x + whiteArea.width) - r.x;
@@ -1386,18 +1409,20 @@
 	}
 
 	public void updateGps(int fix) {
-		if (!running || ignoreGps) return;
+		if (!running || ignoreGps)
+			return;
 		// runMovingMap neccessary in case of multi-threaded Java-VM:
 		// ticked could be called during load of mmp
-		if ((fix > 0) && (myNavigation.gpsPos.getSats()>= 0)) { // TODO is getSats really necessary?
-			directionArrows.setDirections((float)myNavigation.gpsPos.getBearing(myNavigation.destination),
-					(float)myNavigation.skyOrientationDir.lonDec, (float)myNavigation.gpsPos.getBear());
+		if ((fix > 0) && (myNavigation.gpsPos.getSats() >= 0)) { // TODO is getSats really necessary?
+			directionArrows.setDirections((float) myNavigation.gpsPos.getBearing(myNavigation.destination), (float) myNavigation.skyOrientationDir.lonDec, (float) myNavigation.gpsPos.getBear());
 			setGpsStatus(MovingMap.gotFix);
 			updatePosition(myNavigation.gpsPos);
 			ShowLastAddedPoint(myNavigation.curTrack);
 		}
-		if (fix == 0 && myNavigation.gpsPos.getSats()== 0) 	setGpsStatus(MovingMap.lostFix);
-		if (fix < 0 )	setGpsStatus(MovingMap.noGPSData);
+		if (fix == 0 && myNavigation.gpsPos.getSats() == 0)
+			setGpsStatus(MovingMap.lostFix);
+		if (fix < 0)
+			setGpsStatus(MovingMap.noGPSData);
 		controlsLayer.updateContent("hdop", Convert.toString(myNavigation.gpsPos.getHDOP()));
 		controlsLayer.updateContent("sats", Convert.toString(myNavigation.gpsPos.getSats()) + "/" + Convert.toString(myNavigation.gpsPos.getSatsInView()));
 	}
@@ -1406,6 +1431,7 @@
 		addTrack(myNavigation.curTrack);
 		ignoreGps = false;
 	}
+
 	public void gpsStoped() {
 		setGpsStatus(MovingMap.noGPS);
 	}
@@ -1413,7 +1439,8 @@
 	int mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
 	float scaleWanted;
 	boolean wantMapTest = true; // if true updateposition calls setBestMap regulary even if the currentmap covers the whole screen
-	public final static int NORMAL_KEEP_RESOLUTION = 1; // keeps the choosen resolution as long as a map is available that overlaps with the screen and with the PosCircle - it changes the resolution if no such map is available. It wil cahnge back to the wanted scale as soon as a map becomes available (through movement of the GPS-receiver)
+	public final static int NORMAL_KEEP_RESOLUTION = 1; // keeps the choosen resolution as long as a map is available that overlaps with the screen and with the PosCircle - it changes the resolution if no such map is available. It wil cahnge back to the
+														// wanted scale as soon as a map becomes available (through movement of the GPS-receiver)
 	public final static int HIGHEST_RESOLUTION = 2;
 	public final static int HIGHEST_RESOLUTION_GPS_DEST = 3;
 	boolean inBestMap = false; // to avoid multi-threading problems
@@ -1426,18 +1453,19 @@
 	 * but anyway the map will be adjusted (moved) relativ to posCircle
 	 * when a better map was found the called method updateposition will set
 	 * posCirleLat/-Lon to lat/lon.
-	 *
+	 * 
 	 * @param lat
 	 * @param lon
 	 * @param loadIfSameScale
-	 * 			false: will not change the map if the better map has the same scale as the current
-	 * 			  - this is used not to change the map if it covers already the screen completely
-	 * 			true: willchange the map, regardless of change in scale
+	 *            false: will not change the map if the better map has the same scale as the current
+	 *            - this is used not to change the map if it covers already the screen completely
+	 *            true: willchange the map, regardless of change in scale
 	 */
 	public void setBestMap(CWPoint where, boolean loadIfSameScale) {
-		if (inBestMap) return;
+		if (inBestMap)
+			return;
 		inBestMap = true;
-		final Object [] s = getRectForMapChange(where);
+		final Object[] s = getRectForMapChange(where);
 		final CWPoint cll = (CWPoint) s[0];
 		final Rect screen = (Rect) s[1];
 		final boolean posCircleOnScreen = ((Boolean) s[2]).booleanValue();
@@ -1446,41 +1474,46 @@
 		switch (mapChangeModus) {
 		case NORMAL_KEEP_RESOLUTION:
 			lastHighestResolutionGPSDestScale = -1;
-			newmap = maps.getBestMap(cll, screen, scaleWanted, false,true);
-			if (newmap == null) newmap = currentMap;
-			if (MapsList.scaleEquals(scaleWanted, newmap)) wantMapTest = false;
+			newmap = maps.getBestMap(cll, screen, scaleWanted, false, true);
+			if (newmap == null)
+				newmap = currentMap;
+			if (MapsList.scaleEquals(scaleWanted, newmap))
+				wantMapTest = false;
 			break;
 		case HIGHEST_RESOLUTION:
 			lastHighestResolutionGPSDestScale = -1;
-			newmap = maps.getBestMap(cll, screen, 0.000001f, false,true);
+			newmap = maps.getBestMap(cll, screen, 0.000001f, false, true);
 			break;
 		case HIGHEST_RESOLUTION_GPS_DEST:
-			if (gotoPos!= null && GpsStatus != noGPS && posCircle.where.isValid()) {
-				if ( ( !posCircleOnScreen ) && ( lastHighestResolutionGPSDestScale > 0 ) ) {
-					newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale , false,true);
+			if (gotoPos != null && GpsStatus != noGPS && posCircle.where.isValid()) {
+				if ((!posCircleOnScreen) && (lastHighestResolutionGPSDestScale > 0)) {
+					newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale, false, true);
 				} else {
 					newmap = maps.getMapForArea(posCircle.where, gotoPos.where); // TODO use home-coos if no gps? - consider start from details panel and from gotopanel
-					if (newmap == null)	newmap = maps.getBestMap(cll, screen, 10000000000000000000000000000000000f, false,true); // use map with most available overview if no map containing PosCircle and GotoPos is available
+					if (newmap == null)
+						newmap = maps.getBestMap(cll, screen, 10000000000000000000000000000000000f, false, true); // use map with most available overview if no map containing PosCircle and GotoPos is available
 
 					if (newmap != null) {
 						lastHighestResolutionGPSDestScale = newmap.scale;
 
 						if (!posCircleOnScreen) {
-							newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale , false,true);
+							newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale, false, true);
 						}
 					}
 				}
 			}
-			//	either Goto-Pos or GPS-Pos not set
+			// either Goto-Pos or GPS-Pos not set
 			else {
 				lastHighestResolutionGPSDestScale = -1;
-				newmap = maps.getBestMap(cll, screen, 0.000001f, false,true);
+				newmap = maps.getBestMap(cll, screen, 0.000001f, false, true);
 			}
 			break;
-		default: (new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4208, "Bug: \nillegal mapChangeModus: ") + mapChangeModus, FormBase.OKB)).execute(); break;
+		default:
+			(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4208, "Bug: \nillegal mapChangeModus: ") + mapChangeModus, FormBase.OKB)).execute();
+			break;
 		}
-		if ( newmap != null && (currentMap == null || !currentMap.mapName.equals(newmap.mapName)) ) {
-			if (loadIfSameScale || !MapsList.scaleEquals(currentMap.scale / currentMap.zoomFactor, newmap) ) {
+		if (newmap != null && (currentMap == null || !currentMap.mapName.equals(newmap.mapName))) {
+			if (loadIfSameScale || !MapsList.scaleEquals(currentMap.scale / currentMap.zoomFactor, newmap)) {
 				// better map found
 				setMap(newmap, where);
 				moveScreenXYtoLatLon(new Point(screen.x, screen.y), cll, true);
@@ -1492,31 +1525,37 @@
 			// F?r die aktuelle Position steht keine Karte zur Verf?ng
 			posCircle.where.set(cll); // choosemap calls setmap with posCircle-coos
 			try {
-				setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), where); // beware: "-4" only works if the empty maps were added last see MapsList.addEmptyMaps
-			} catch (final IOException e) { (new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4209, "setBestMap: problem in: setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), lat, lon) lat/lon:") + where.toString(), FormBase.OKB)).exec(); }
+				setMap(((MapListEntry) maps.elementAt(maps.getCount() - 4)).getMap(), where); // beware: "-4" only works if the empty maps were added last see MapsList.addEmptyMaps
+			} catch (final IOException e) {
+				(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4209, "setBestMap: problem in: setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), lat, lon) lat/lon:") + where.toString(), FormBase.OKB)).exec();
+			}
 			while (currentMap == null) { // this actually cannot happen, but maybe in case of an inconstistent code change (esp. regarding empty maps)
 				mmp.chooseMap(); // force the user to select a scale
-				 if (currentMap == null) (new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4210, "Moving map cannot run without a map - please select one. \n You can select an empty map"), FormBase.OKB)).execute();
+				if (currentMap == null)
+					(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4210, "Moving map cannot run without a map - please select one. \n You can select an empty map"), FormBase.OKB)).execute();
 			}
 		}
 		inBestMap = false;
 	}
 
-	public void setResModus (int modus) {
+	public void setResModus(int modus) {
 		scaleWanted = currentMap.scale;
-		if (mapChangeModus == modus) return;
+		if (mapChangeModus == modus)
+			return;
 		mapChangeModus = modus;
 		lastHighestResolutionGPSDestScale = -1;
 		if (modus != NORMAL_KEEP_RESOLUTION) {
 			setBestMap(posCircle.where, true);
 		}
 	}
+
 	/**
 	 * method to get a point on the screen which must be included in the map
 	 * the map methods are looking for. If the poscircle is on the screen this will be
 	 * that point. If it is outside then the centre of the screen will be used.
-	 *
+	 * 
 	 * returns [0] = CWPoint of that point, [1] Rect describing the screen around it
+	 * 
 	 * @param lat
 	 * @param lon
 	 * @return
@@ -1530,12 +1569,13 @@
 		if (posCircleX >= 0 && posCircleX <= w && posCircleY >= 0 && posCircleY <= h && ll.isValid()) {
 			posCircleOnScreen = java.lang.Boolean.TRUE;
 			pX = posCircleX; // posCircle is inside the screen
-			pY = posCircleY; // TODO eigentlich interessiert, ob nach dem evtl. Kartenwechsel PosCircle on Screen ist. So wie es jetzt ist, kann 2mal der gleiche Aufruf zum laden unterschiedlicher Karten f???hren, wenn vorher PosCircle nicht auf dem SChirm war, nach dem ersten Laden aber schon.
+			pY = posCircleY; // TODO eigentlich interessiert, ob nach dem evtl. Kartenwechsel PosCircle on Screen ist. So wie es jetzt ist, kann 2mal der gleiche Aufruf zum laden unterschiedlicher Karten f???hren, wenn vorher PosCircle nicht auf dem
+								// SChirm war, nach dem ersten Laden aber schon.
 			cll = new CWPoint(ll);
 		} else { // when posCircle out of screen - use centre of screen as point which as to be included in the map
-			cll = ScreenXY2LatLon(w/2, h/2);
-			pX = w/2;
-			pY = h/2;
+			cll = ScreenXY2LatLon(w / 2, h / 2);
+			pX = w / 2;
+			pY = h / 2;
 		}
 		final Object[] ret = new Object[3];
 		ret[0] = cll;
@@ -1545,18 +1585,19 @@
 	}
 
 	/**
-	 *
-	 * @param betterOverview true: getmap with better overview
+	 * 
+	 * @param betterOverview
+	 *            true: getmap with better overview
 	 * @return
 	 */
-	public void loadMoreDetailedMap(boolean betterOverview){
+	public void loadMoreDetailedMap(boolean betterOverview) {
 		final int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
 		final int h = (height != 0 ? height : pref.myAppHeight);
-		final Rect screen = new Rect(w/2, h/2, w, h);
+		final Rect screen = new Rect(w / 2, h / 2, w, h);
 
 		CWPoint cll;
 		if (currentMap != null) {
-			cll = ScreenXY2LatLon(w/2, h/2);
+			cll = ScreenXY2LatLon(w / 2, h / 2);
 		} else {
 			cll = new CWPoint(posCircle.where);
 		}
@@ -1571,37 +1612,36 @@
 				fillWhiteArea(true);
 			}
 			dontUpdatePos = saveGpsIgnStatus;
-		}
-		else (new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4211, "No ") +
-				(betterOverview ? MyLocale.getMsg(4212, "less") : MyLocale.getMsg(4213, "more") ) +
-				MyLocale.getMsg(4214, " detailed map available"),
-				FormBase.OKB)).execute();
+		} else
+			(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4211, "No ") + (betterOverview ? MyLocale.getMsg(4212, "less") : MyLocale.getMsg(4213, "more")) + MyLocale.getMsg(4214, " detailed map available"), FormBase.OKB)).execute();
 	}
 
-	public void loadMapForAllCaches(){
+	public void loadMapForAllCaches() {
 		final Area sur = Global.getProfile().getSourroundingArea(true);
 		if (sur == null) {
 			(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4215, "Keine  Caches mit H???ckchen ausgew???hlt"), FormBase.OKB)).execute();
 			return;
 		}
 		MapInfoObject newmap = maps.getMapForArea(sur.topleft, sur.bottomright);
-		if (newmap == null ) { // no map that includs all caches is available -> load map with lowest resolution
-			final Object [] s = getRectForMapChange(posCircle.where);
+		if (newmap == null) { // no map that includs all caches is available -> load map with lowest resolution
+			final Object[] s = getRectForMapChange(posCircle.where);
 			final CWPoint cll = (CWPoint) s[0];
 			final Rect screen = (Rect) s[1];
-			newmap = maps.getBestMap(cll, screen, Float.MAX_VALUE -1, false,true);
+			newmap = maps.getBestMap(cll, screen, Float.MAX_VALUE - 1, false, true);
 		}
 		if (newmap == null) { // no map is covering any area of the caches -> zoom an empty map to cover all caches on screen
 			try {
-				final Object [] s = getRectForMapChange(posCircle.where);
-			//	CWPoint cll = (CWPoint) s[0];
+				final Object[] s = getRectForMapChange(posCircle.where);
+				// CWPoint cll = (CWPoint) s[0];
 				final Rect screen = (Rect) s[1];
-				final float neededscalex = (float) (sur.topleft.getDistance(sur.topleft.latDec, sur.bottomright.lonDec) * 1000 / (screen.width-15)); // 15 for the size of the cache image
-				final float neededscaley = (float) (sur.topleft.getDistance(sur.bottomright.latDec, sur.topleft.lonDec) * 1000 / (screen.height-15)); // 15 for the size of the cache image
-				newmap = ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(); // beware: "-4" only works if the empty maps were added last see MapsList.addEmptyMaps
+				final float neededscalex = (float) (sur.topleft.getDistance(sur.topleft.latDec, sur.bottomright.lonDec) * 1000 / (screen.width - 15)); // 15 for the size of the cache image
+				final float neededscaley = (float) (sur.topleft.getDistance(sur.bottomright.latDec, sur.topleft.lonDec) * 1000 / (screen.height - 15)); // 15 for the size of the cache image
+				newmap = ((MapListEntry) maps.elementAt(maps.getCount() - 4)).getMap(); // beware: "-4" only works if the empty maps were added last see MapsList.addEmptyMaps
 				newmap.zoom(newmap.scale * newmap.zoomFactor / (neededscalex > neededscaley ? neededscalex : neededscaley), 0, 0);
 				forceMapLoad = true;
-			} catch (final IOException e) { (new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4279, "loadMapForAllCaches: IO-Exception in: newmap = ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap();"), FormBase.OKB)).exec(); }
+			} catch (final IOException e) {
+				(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4279, "loadMapForAllCaches: IO-Exception in: newmap = ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap();"), FormBase.OKB)).exec();
+			}
 		}
 		final boolean saveGpsIgnStatus = dontUpdatePos;
 		dontUpdatePos = true;
@@ -1610,17 +1650,31 @@
 		dontUpdatePos = saveGpsIgnStatus;
 	}
 
-	public void setGpsStatus (int status) {
-		if (status == GpsStatus) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
+	public void setGpsStatus(int status) {
+		if (status == GpsStatus)
+			return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
 		GpsStatus = status;
 		dontUpdatePos = false;
 		ignoreGps = false;
 		switch (status) {
-		case noGPS: 	{ posCircle.change(null); ignoreGps = true; break; }
-		case gotFix:    { posCircle.change(statusImageHaveSignal); break; }
-		case lostFix:   { posCircle.change(statusImageNoSignal); break; }
-		case noGPSData: { posCircle.change(statusImageNoGps); break; }
+		case noGPS: {
+			posCircle.change(null);
+			ignoreGps = true;
+			break;
 		}
+		case gotFix: {
+			posCircle.change(statusImageHaveSignal);
+			break;
+		}
+		case lostFix: {
+			posCircle.change(statusImageNoSignal);
+			break;
+		}
+		case noGPSData: {
+			posCircle.change(statusImageNoGps);
+			break;
+		}
+		}
 		mapMoved(0, 0); // positions the posCircle correctly accourding to its size (which can change when the image changes, e.g. from null to something else
 		posCircle.refreshNow();
 	}
@@ -1634,15 +1688,20 @@
 		autoSelectMap = true;
 		forceMapLoad = true;
 		// showMap(); why this?
-		if (myNavigation.gpsPos.Fix <=0) updatePosition(posCircle.where);
-		else updateGps(myNavigation.gpsPos.getFix());
+		if (myNavigation.gpsPos.Fix <= 0)
+			updatePosition(posCircle.where);
+		else
+			updateGps(myNavigation.gpsPos.getFix());
 	}
 
-	/** sets and displays the map
-	 *
+	/**
+	 * sets and displays the map
+	 * 
 	 * @param newmap
-	 * @param lat move map so that lat/lon is in the centre / -361: don't adust to lat/lon
-	 * @param lon -361: don't adust to lat/lon
+	 * @param lat
+	 *            move map so that lat/lon is in the centre / -361: don't adust to lat/lon
+	 * @param lon
+	 *            -361: don't adust to lat/lon
 	 */
 	public void setMap(MapInfoObject newmap, CWPoint where) {
 		if (currentMap != null && newmap.mapName.equals(currentMap.mapName) && !forceMapLoad) {
@@ -1653,15 +1712,15 @@
 			Vm.showWait(true);
 			boolean saveIgnoreStatus;
 			saveIgnoreStatus = dontUpdatePos;
-			dontUpdatePos = true;  // make updatePosition ignore calls during loading new map
-			pref.log(MyLocale.getMsg(4216, "Loading map...")+newmap.mapName);
+			dontUpdatePos = true; // make updatePosition ignore calls during loading new map
+			pref.log(MyLocale.getMsg(4216, "Loading map...") + newmap.mapName);
 			try {
 				this.currentMap = newmap;
 				this.title = currentMap.mapName;
 				// neccessary to make updateposition to test if the current map is the best one for the GPS-Position
 				lastCompareX = Integer.MAX_VALUE;
 				lastCompareY = Integer.MAX_VALUE;
-				if (mmp.mapImage != null ) {
+				if (mmp.mapImage != null) {
 					mmp.removeImage(mmp.mapImage);
 					mmp.mapImage.free();
 					mmp.mapImage = null;
@@ -1671,23 +1730,23 @@
 				}
 				// give memory free before loading the new map to avoid out of memory error
 				final String ImageFilename = currentMap.getImageFilename();
-				if (ImageFilename == null ) {
+				if (ImageFilename == null) {
 					mmp.mapImage = new MapImage();
 					maps.remove(currentMap);
-					(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4217, "Could not find image associated with: \n")+currentMap.fileNameWFL, FormBase.OKB)).execute();
-				}
-				else {
+					(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4217, "Could not find image associated with: \n") + currentMap.fileNameWFL, FormBase.OKB)).execute();
+				} else {
 					if (ImageFilename.length() > 0) {
 						// attention: when running in native java-vm,
 						// no exception will be thrown, not even OutOfMemeoryError
 						mmp.mapImage = new MapImage(ImageFilename);
-					}
-					else mmp.mapImage = new MapImage(); // no image associated with the calibration info ("empty map")
+					} else
+						mmp.mapImage = new MapImage(); // no image associated with the calibration info ("empty map")
 				}
 				mapImage1to1 = mmp.mapImage;
 				mmp.mapImage.properties = mmp.mapImage.properties | mImage.IsMoveable;
-				if (mapHidden) mmp.mapImage.hide();
-				mmp.mapImage.move(0,0);
+				if (mapHidden)
+					mmp.mapImage.hide();
+				mmp.mapImage.move(0, 0);
 				mmp.addImage(mmp.mapImage);
 				mmp.images.moveToBack(mmp.mapImage);
 				rebuildOverlaySet();
@@ -1701,7 +1760,7 @@
 				dontUpdatePos = saveIgnoreStatus;
 			} catch (final IllegalArgumentException e) {
 				// thrown by new AniImage() in ewe-vm if file not found;
-				pref.log("[MovingMap:setMap]IllegalArgumentException",e,true);
+				pref.log("[MovingMap:setMap]IllegalArgumentException", e, true);
 				if (mmp.mapImage != null) {
 					mmp.removeImage(mmp.mapImage);
 					mmp.mapImage.free();
@@ -1710,10 +1769,10 @@
 				}
 				rebuildOverlaySet();
 				updateOnlyPosition(where, false);
-				(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4218, "Could not load map: \n")+ newmap.getImageFilename(), FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4218, "Could not load map: \n") + newmap.getImageFilename(), FormBase.OKB)).execute();
 				dontUpdatePos = saveIgnoreStatus;
 			} catch (final OutOfMemoryError e) {
-				pref.log("[MovingMap:setMap]OutOfMemoryError",e,true);
+				pref.log("[MovingMap:setMap]OutOfMemoryError", e, true);
 				if (mmp.mapImage != null) {
 					mmp.removeImage(mmp.mapImage);
 					mmp.mapImage.free();
@@ -1722,13 +1781,11 @@
 				}
 				rebuildOverlaySet();
 				updateOnlyPosition(where, false);
-				(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4219, "Not enough memory to load map: \n")
-						+ newmap.getImageFilename()
-						+ MyLocale.getMsg(4220, "\nYou can try to close\n all prgrams and \nrestart CacheWolf"),
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4219, "Not enough memory to load map: \n") + newmap.getImageFilename() + MyLocale.getMsg(4220, "\nYou can try to close\n all prgrams and \nrestart CacheWolf"), FormBase.OKB))
+						.execute();
 				dontUpdatePos = saveIgnoreStatus;
-			}catch (final SystemResourceException e) {
-				pref.log("[MovingMap:setMap]SystemResourceException",e,true);
+			} catch (final SystemResourceException e) {
+				pref.log("[MovingMap:setMap]SystemResourceException", e, true);
 				if (mmp.mapImage != null) {
 					mmp.removeImage(mmp.mapImage);
 					mmp.mapImage.free();
@@ -1736,15 +1793,13 @@
 					mapImage1to1 = mmp.mapImage;
 				}
 				rebuildOverlaySet();
-				updateOnlyPosition(where, false); // TODO this doesn't work correctly if the resolution changed, I guess because the pixels of PosCircle will be interpreted from the new resolution, but should be interpreted using the old resolution to test: select a map with a much greater value of m per pixel manually
-				(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4221, "Not enough ressources to load map: ")
-						+ newmap.getImageFilename()
-						+ MyLocale.getMsg(4220, "\nYou can try to close\n all prgrams and \nrestart CacheWolf"),
+				updateOnlyPosition(where, false); // TODO this doesn't work correctly if the resolution changed, I guess because the pixels of PosCircle will be interpreted from the new resolution, but should be interpreted using the old resolution to
+													// test: select a map with a much greater value of m per pixel manually
+				(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4221, "Not enough ressources to load map: ") + newmap.getImageFilename() + MyLocale.getMsg(4220, "\nYou can try to close\n all prgrams and \nrestart CacheWolf"),
 						FormBase.OKB)).execute();
 				dontUpdatePos = saveIgnoreStatus;
 			}
-		}
-		finally{
+		} finally {
 			Vm.showWait(false);
 		}
 	}
@@ -1757,17 +1812,18 @@
 		final Point centerOnMap = currentMap.calcMapXY(newCenter);
 		final int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
 		final int h = (height != 0 ? height : pref.myAppHeight);
-		final int mapPosX = w/2 - centerOnMap.x;
-		final int mapPosY = h/2 - centerOnMap.y;
+		final int mapPosX = w / 2 - centerOnMap.x;
+		final int mapPosY = h / 2 - centerOnMap.y;
 		final int newPosCircleX = mapPosX + circlePosOnMap.x;
 		final int newPosCircleY = mapPosY + circlePosOnMap.y;
 
-		if (mmp != null && mmp.mapImage != null) mmp.mapImage.move(mapPosX, mapPosY);
+		if (mmp != null && mmp.mapImage != null)
+			mmp.mapImage.move(mapPosX, mapPosY);
 
 		final int wCircle = posCircle.getWidth();
 		final int hCircle = posCircle.getHeight();
-		final int npx = newPosCircleX-wCircle/2;
-		final int npy = newPosCircleY-hCircle/2;
+		final int npx = newPosCircleX - wCircle / 2;
+		final int npy = newPosCircleY - hCircle / 2;
 		posCircle.move(npx, npy);
 		posCircleX = newPosCircleX;
 		posCircleY = newPosCircleY;
@@ -1778,9 +1834,9 @@
 	public void hideMap() {
 		if (mmp != null && mmp.mapImage != null)
 			mmp.mapImage.hide();
-		for(final Iterator i=mmp.images.iterator(); i.hasNext ();){
+		for (final Iterator i = mmp.images.iterator(); i.hasNext();) {
 			final AniImage image = (AniImage) i.next();
-			if (image instanceof MapImage && !(image instanceof MapSymbol) && !(image instanceof TrackOverlay)){
+			if (image instanceof MapImage && !(image instanceof MapSymbol) && !(image instanceof TrackOverlay)) {
 				((MapImage) image).hide();
 			}
 		}
@@ -1789,63 +1845,64 @@
 	}
 
 	public void showMap() {
-		if (mmp != null && mmp.mapImage != null) mmp.mapImage.unhide();
+		if (mmp != null && mmp.mapImage != null)
+			mmp.mapImage.unhide();
 		mapHidden = false;
-		for(final Iterator i=mmp.images.iterator(); i.hasNext ();){
+		for (final Iterator i = mmp.images.iterator(); i.hasNext();) {
 			final AniImage image = (AniImage) i.next();
-			if (image instanceof MapImage && !(image instanceof MapSymbol) && !(image instanceof TrackOverlay)){
+			if (image instanceof MapImage && !(image instanceof MapSymbol) && !(image instanceof TrackOverlay)) {
 				((MapImage) image).unhide();
 			}
 		}
 		repaintNow();
 	}
-/*
-	public void setZoomingMode() {
-		repaintNow();
-		zoomingMode = true;
-	}
-*/
+
+	/*
+	 * public void setZoomingMode() {
+	 * repaintNow();
+	 * zoomingMode = true;
+	 * }
+	 */
 	/**
 	 * zommes in if w>0 and out if w<0
+	 * 
 	 * @param firstclickpoint
 	 * @param w
 	 * @param h
 	 */
 	public void zoomScreenRect(Point firstclickpoint, int w, int h) {
-		int newImageWidth = (int) (this.width *  (this.width  < 481 ? 2 : 1.6)); // (maximal) size of the zoomed image
-		int newImageHeight= (int) (this.height * (this.width < 481 ?  2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors
-		final CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y + h/2);
+		int newImageWidth = (int) (this.width * (this.width < 481 ? 2 : 1.6)); // (maximal) size of the zoomed image
+		int newImageHeight = (int) (this.height * (this.width < 481 ? 2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors
+		final CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w / 2, firstclickpoint.y + h / 2);
 		float zoomFactor;
 		if (h < 0) {
 			h = java.lang.Math.abs(h);
 			firstclickpoint.y = firstclickpoint.y - h;
 		}
 		if (w > 0) { // zoom in
-			zoomFactor = java.lang.Math.min((float)this.width / (float)w, (float)this.height / (float)h);
-		}
-		else { // zoom out
+			zoomFactor = java.lang.Math.min((float) this.width / (float) w, (float) this.height / (float) h);
+		} else { // zoom out
 			w = java.lang.Math.abs(w);
 			firstclickpoint.x = firstclickpoint.x - w; // make firstclickedpoint the upper left corner
-			zoomFactor = java.lang.Math.max((float)w / (float)this.width, (float)h / (float)this.height);
+			zoomFactor = java.lang.Math.max((float) w / (float) this.width, (float) h / (float) this.height);
 		}
 		// calculate rect in unzoomed image in a way that the centre of the new image is the centre of selected area but give priority to the prefered image size of the scaled image
 		newImageHeight = (int) (newImageHeight / zoomFactor / currentMap.zoomFactor);
 		newImageWidth = (int) (newImageWidth / zoomFactor / currentMap.zoomFactor);
 		final Point mappos = getMapPositionOnScreen();
-		final int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w/2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth /2);
-		final int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h/2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight /2);
-		final Rect newImageRect = new Rect(xinunscaledimage , yinunscaledimage, newImageWidth, newImageHeight);
-		if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
-		{
+		final int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w / 2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth / 2);
+		final int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h / 2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight / 2);
+		final Rect newImageRect = new Rect(xinunscaledimage, yinunscaledimage, newImageWidth, newImageHeight);
+		if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null) {
 			// try to avoid overlapping by shifting
 			if (newImageRect.x < 0)
 				newImageRect.x = 0; // align left if left overlapping
 			if (newImageRect.y < 0)
 				newImageRect.y = 0;
 			if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth())
-				newImageRect.x = mapImage1to1.getWidth()- newImageWidth; // align right if right overlaping
+				newImageRect.x = mapImage1to1.getWidth() - newImageWidth; // align right if right overlaping
 			if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight())
-				newImageRect.y = mapImage1to1.getHeight()- newImageHeight;
+				newImageRect.y = mapImage1to1.getHeight() - newImageHeight;
 			// crop if after shifting still overlapping
 			if (newImageRect.x < 0)
 				newImageRect.x = 0;
@@ -1854,14 +1911,13 @@
 			if (newImageRect.x + newImageRect.width >= mapImage1to1.getWidth())
 				newImageRect.width = mapImage1to1.getWidth() - newImageRect.x;
 			if (newImageRect.y + newImageRect.height >= mapImage1to1.getHeight())
-				newImageRect.height= mapImage1to1.getHeight()- newImageRect.y;
+				newImageRect.height = mapImage1to1.getHeight() - newImageRect.y;
 		}
 		zoomFromUnscaled(zoomFactor * currentMap.zoomFactor, newImageRect, center);
 	}
 
 	public void zoomin() {
-		zoomScreenRect(new Point(this.width / 4, this.height / 4),
-				this.width / 2, this.height / 2);
+		zoomScreenRect(new Point(this.width / 4, this.height / 4), this.width / 2, this.height / 2);
 	}
 
 	public void zoomout() {
@@ -1871,8 +1927,7 @@
 			zoomfactor = 1;
 		}
 		if (mapImage1to1 != null)
-			zoomFromUnscaled(zoomfactor, new Rect(0, 0,
-					mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
+			zoomFromUnscaled(zoomfactor, new Rect(0, 0, mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
 		else
 			zoomFromUnscaled(zoomfactor, new Rect(0, 0, 1, 1), center);
 	}
@@ -1882,18 +1937,23 @@
 	}
 
 	public void zoom1to1() {
-		final CWPoint center = ScreenXY2LatLon(this.width /2 , this.height/2);
-		if (mapImage1to1 != null) zoomFromUnscaled(1, new Rect(0,0,mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
-		else zoomFromUnscaled(1, new Rect(0,0, 1,1), center);
+		final CWPoint center = ScreenXY2LatLon(this.width / 2, this.height / 2);
+		if (mapImage1to1 != null)
+			zoomFromUnscaled(1, new Rect(0, 0, mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
+		else
+			zoomFromUnscaled(1, new Rect(0, 0, 1, 1), center);
 	}
 
 	/**
 	 * do the actual scaling
-	 * @param zoomFactor relative to original image
-	 * @param newImageRect Rect in the 1:1 image that contains the area to be zoomed into
+	 * 
+	 * @param zoomFactor
+	 *            relative to original image
+	 * @param newImageRect
+	 *            Rect in the 1:1 image that contains the area to be zoomed into
 	 * @param center
 	 */
-	public void zoomFromUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
+	public void zoomFromUnscaled(float zoomFactor, Rect newImageRect, CWPoint center) {
 		Vm.showWait(this, true);
 		final boolean savegpsstatus = dontUpdatePos;
 		if (mapImage1to1 != null) {
@@ -1907,31 +1967,35 @@
 				if (mmp.mapImage != mapImage1to1) {
 					mmp.mapImage.free();
 					mmp.mapImage = null;
-				} else tmp = mapImage1to1;
+				} else
+					tmp = mapImage1to1;
 			}
 			Vm.getUsedMemory(true);
 			try {
-				if (zoomFactor == 1) tmp = mapImage1to1;
-				else tmp = new MapImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor), (int)(newImageRect.height*zoomFactor), newImageRect, 0));
+				if (zoomFactor == 1)
+					tmp = mapImage1to1;
+				else
+					tmp = new MapImage(mapImage1to1.scale((int) (newImageRect.width * zoomFactor), (int) (newImageRect.height * zoomFactor), newImageRect, 0));
 				currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
 			} catch (final OutOfMemoryError e) {
-				(new MessageBox(MyLocale.getMsg(4207, "Error"),
-						MyLocale.getMsg(4222, "Out of memory error"), FormBase.OKB)).execute();
-				//tmp = mapImage1to1;
-			} //if (tmp != null) currentMap.zoom();}
+				(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4222, "Out of memory error"), FormBase.OKB)).execute();
+				// tmp = mapImage1to1;
+			} // if (tmp != null) currentMap.zoom();}
 			Vm.getUsedMemory(true);
 			mmp.mapImage = tmp; // use unscaled or no image in case of OutOfMemoryError
 			mmp.mapImage.properties = saveprop;
-			if (mapHidden) mmp.mapImage.hide();
+			if (mapHidden)
+				mmp.mapImage.hide();
 			mmp.addImage(mmp.mapImage);
 			mmp.images.moveToBack(mmp.mapImage);
-			if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null)
-			{
+			if (mapImage1to1 != null && mmp.mapImage != null && mapImage1to1.image != null) {
 				final Point mappos = getMapPositionOnScreen();
-				mmp.mapImage.move(mappos.x,mappos.y);
+				mmp.mapImage.move(mappos.x, mappos.y);
 			}
 		} else // no map image loaded
-		{ currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y); }
+		{
+			currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
+		}
 		// scaleWanted = currentMap.scale; use this if you want to change automatically to a map scale that best fits the zooming
 		destroyOverlaySet();
 		Vm.getUsedMemory(true); // call garbage collection
@@ -1943,15 +2007,11 @@
 		dontUpdatePos = savegpsstatus;
 	}
 
-	public void onEvent(Event ev){
-		if(ev instanceof FormEvent && (ev.type == FormEvent.CLOSED )){
+	public void onEvent(Event ev) {
+		if (ev instanceof FormEvent && (ev.type == FormEvent.CLOSED)) {
 			running = false;
 		}
-		if( ev instanceof KeyEvent &&
-			ev.target == this &&
-			( (((KeyEvent)ev).key == IKeys.ESCAPE) ||
-			  (((KeyEvent)ev).key == IKeys.ENTER) ||
-			  (((KeyEvent)ev).key == IKeys.ACTION) ) ) {
+		if (ev instanceof KeyEvent && ev.target == this && ((((KeyEvent) ev).key == IKeys.ESCAPE) || (((KeyEvent) ev).key == IKeys.ENTER) || (((KeyEvent) ev).key == IKeys.ACTION))) {
 			this.close(0);
 			ev.consumed = true;
 		}
@@ -1972,8 +2032,8 @@
 		if (CHANGE_MAP_DIR == actionCommand) {
 			final FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, Global.getPref().getCustomMapsPath());
 			fc.addMask("*.wfl");
-			fc.setTitle(MyLocale.getMsg(4200,"Select map directory:"));
-			if(fc.execute() != FormBase.IDCANCEL){
+			fc.setTitle(MyLocale.getMsg(4200, "Select map directory:"));
+			if (fc.execute() != FormBase.IDCANCEL) {
 				Global.getPref().saveCustomMapsPath(fc.getChosen().toString());
 				loadMaps(Global.getPref().getCustomMapsPath(), posCircle.where.latDec);
 				forceMapLoad();
@@ -1982,27 +2042,27 @@
 		}
 		if (FILL_MAP == actionCommand) {
 			setFillWhiteArea(true);
-			updatePosition (posCircle.where);
+			updatePosition(posCircle.where);
 			mmp.repaint();
 			return true;
 		}
 		if (NO_FILL_MAP == actionCommand) {
 			setFillWhiteArea(false);
-			updatePosition (posCircle.where);
+			updatePosition(posCircle.where);
 			mmp.repaint();
 			return true;
 		}
 		if (SHOW_CACHES == actionCommand) {
 			setShowCachesOnMap(true);
-			forceMapLoad=true;
-			updatePosition (posCircle.where);
+			forceMapLoad = true;
+			updatePosition(posCircle.where);
 			mmp.repaint();
 			return true;
 		}
 		if (HIDE_CACHES == actionCommand) {
 			setShowCachesOnMap(false);
-			forceMapLoad=true;
-			updatePosition (posCircle.where);
+			forceMapLoad = true;
+			updatePosition(posCircle.where);
 			mmp.repaint();
 			return true;
 		}
@@ -2043,7 +2103,7 @@
 			return true;
 		}
 		if (MOVE_TO_DEST == actionCommand) {
-			if (gotoPos!=null) {
+			if (gotoPos != null) {
 				setCenterOfScreen(gotoPos.where, true);
 			}
 			return true;
@@ -2076,22 +2136,20 @@
 		return mapHidden;
 	}
 
-
 	public void setPaintPosDestLine(boolean paintPosDestLine) {
 		this.paintPosDestLine = paintPosDestLine;
 	}
 
-
 }
 
 /**
- *	Class to display the map bitmap and to select another bitmap to display.
+ * Class to display the map bitmap and to select another bitmap to display.
  */
 class MovingMapPanel extends InteractivePanel implements EventListener {
 	Menu kontextMenu;
 	MenuItem gotoMenuItem = new MenuItem(MyLocale.getMsg(4230, "Goto here$g"), 0, null);
 	MenuItem newWayPointMenuItem = new MenuItem(MyLocale.getMsg(4232, "Create new Waypoint here$n"), 0, null);;
-	MenuItem openCacheDescMenuItem,openCacheDetailMenuItem,addCachetoListMenuItem,gotoCacheMenuItem,hintMenuItem,missionMenuItem;
+	MenuItem openCacheDescMenuItem, openCacheDetailMenuItem, addCachetoListMenuItem, gotoCacheMenuItem, hintMenuItem, missionMenuItem;
 
 	MenuItem miLuminary[];
 
@@ -2103,45 +2161,49 @@
 	boolean paintingZoomArea;
 
 	ImageList saveImageList = null;
-	int lastZoomWidth , lastZoomHeight;
+	int lastZoomWidth, lastZoomHeight;
 
-	boolean ignoreNextDrag=false;
-	boolean onlyIfCache=false;
+	boolean ignoreNextDrag = false;
+	boolean onlyIfCache = false;
 
-	public MovingMapPanel(MovingMap f){
+	public MovingMapPanel(MovingMap f) {
 		this.mm = f;
 		miLuminary = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
-		for (int i=0; i<SkyOrientation.LUMINARY_NAMES.length; i++) {
+		for (int i = 0; i < SkyOrientation.LUMINARY_NAMES.length; i++) {
 			miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i));
 		}
 		set(ControlConstants.WantHoldDown, true); // want to get simulated right-clicks
 	}
 
-	public boolean imageBeginDragged(AniImage which,Point pos) {
+	public boolean imageBeginDragged(AniImage which, Point pos) {
 		if (mm.zoomingMode == true) { // zoom
-//			saveMapLoc = pos;
-			//		saveGpsIgnoreStatus = mm.ignoreGps;
-			//	mm.ignoreGps = true;
+			// saveMapLoc = pos;
+			// saveGpsIgnoreStatus = mm.ignoreGps;
+			// mm.ignoreGps = true;
 			return false;
 		}
 		if (mm.getControlsLayer().imageBeginDragged(which, pos)) {
 			return false;
 		}
 		// move (drag) map
-		//if (!(which == null || which == mapImage || which instanceof TrackOverlay || which == mm.directionArrows) ) return false;
+		// if (!(which == null || which == mapImage || which instanceof TrackOverlay || which == mm.directionArrows) ) return false;
 		saveGpsIgnoreStatus = mm.dontUpdatePos;
 		mm.dontUpdatePos = true;
 		saveMapLoc = pos;
 		bringMapToTop();
-		if (mapImage.isOnScreen() && !mapImage.hidden ) return super.imageBeginDragged(mapImage, pos);
-		else return super.imageBeginDragged(null, pos);
+		if (mapImage.isOnScreen() && !mapImage.hidden)
+			return super.imageBeginDragged(mapImage, pos);
+		else
+			return super.imageBeginDragged(null, pos);
 	}
 
-	public boolean imageNotDragged(ImageDragContext dc,Point pos){
+	public boolean imageNotDragged(ImageDragContext dc, Point pos) {
 		final boolean ret = super.imageNotDragged(dc, pos);
 		bringMaptoBack();
-		if (dc.image == null) moveMap(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
-		else mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
+		if (dc.image == null)
+			moveMap(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
+		else
+			mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
 		mm.dontUpdatePos = saveGpsIgnoreStatus;
 		this.repaintNow();
 		return ret;
@@ -2150,64 +2212,71 @@
 	public void onPenEvent(PenEvent ev) {
 		if (ignoreNextDrag) {
 			// On PDA next event after a Kontext ist a drag, that will move the map unwanted
-			ignoreNextDrag=false;
-			if (ev.type == PenEvent.PEN_DRAG) return; // ignoring now
+			ignoreNextDrag = false;
+			if (ev.type == PenEvent.PEN_DRAG)
+				return; // ignoring now
 		}
 		if (ev.type == PenEvent.PEN_DOWN) {
 			if (mm.zoomingMode) {
 				saveGpsIgnoreStatus = mm.dontUpdatePos;
 				mm.dontUpdatePos = true;
-				saveMapLoc = new Point (ev.x, ev.y);
+				saveMapLoc = new Point(ev.x, ev.y);
 				paintingZoomArea = true;
 				mm.zoomingMode = true;
-			}
-			else {
-				saveMapLoc = new Point (ev.x, ev.y);
+			} else {
+				saveMapLoc = new Point(ev.x, ev.y);
 				if (ev.modifiers == PenEvent.RIGHT_BUTTON) {
 					// context penHeld is fired directly on PDA (cause WantHoldDown Control Modifier)
 					// but not on PC (Java) , therefor it is here
-					penHeld(new Point (ev.x, ev.y));
-				}
-				else {
+					penHeld(new Point(ev.x, ev.y));
+				} else {
 					// do it even on left klick
-					onlyIfCache=true;
-					penHeld(new Point (ev.x, ev.y));
+					onlyIfCache = true;
+					penHeld(new Point(ev.x, ev.y));
 				}
 			}
-		}
-		else {
+		} else {
 			if (mm.zoomingMode) {
-				if ( ev.type == PenEvent.PEN_UP ) {
+				if (ev.type == PenEvent.PEN_UP) {
 					paintingZoomArea = false;
 					mm.zoomingMode = false;
 					mm.getControlsLayer().changeRoleState("zoom_manually", false);
 					mm.dontUpdatePos = saveGpsIgnoreStatus;
-					if (java.lang.Math.abs(lastZoomWidth) < 15 || java.lang.Math.abs(lastZoomHeight) < 15)  {
+					if (java.lang.Math.abs(lastZoomWidth) < 15 || java.lang.Math.abs(lastZoomHeight) < 15) {
 						repaintNow();
 						return; // dont make to big zoom jumps - it is most probable not an intentional zoom
 					}
 					mm.zoomScreenRect(saveMapLoc, lastZoomWidth, lastZoomHeight);
 				}
-				if (paintingZoomArea &&
-					(ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {
+				if (paintingZoomArea && (ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {
 					int left, top;
 					final Graphics dr = this.getGraphics();
-					if (lastZoomWidth < 0)left = saveMapLoc.x + lastZoomWidth;
-					else left = saveMapLoc.x;
-					if (lastZoomHeight < 0)top = saveMapLoc.y + lastZoomHeight;
-					else top = saveMapLoc.y;
+					if (lastZoomWidth < 0)
+						left = saveMapLoc.x + lastZoomWidth;
+					else
+						left = saveMapLoc.x;
+					if (lastZoomHeight < 0)
+						top = saveMapLoc.y + lastZoomHeight;
+					else
+						top = saveMapLoc.y;
 					left -= 2;
 					top -= 2;
-					if (top < 0) top = 0;
-					if (left < 0) left = 0;
-					this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth)+4, java.lang.Math.abs(lastZoomHeight)+4));
+					if (top < 0)
+						top = 0;
+					if (left < 0)
+						left = 0;
+					this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth) + 4, java.lang.Math.abs(lastZoomHeight) + 4));
 					lastZoomWidth = ev.x - saveMapLoc.x;
-					lastZoomHeight =  ev.y - saveMapLoc.y;
-					if (lastZoomWidth < 0) left = saveMapLoc.x + lastZoomWidth;
-					else left = saveMapLoc.x;
-					if (lastZoomHeight < 0)top = saveMapLoc.y + lastZoomHeight;
-					else top = saveMapLoc.y;
-					dr.setPen(new Pen(new Color(255,0,0),Pen.SOLID,3));
+					lastZoomHeight = ev.y - saveMapLoc.y;
+					if (lastZoomWidth < 0)
+						left = saveMapLoc.x + lastZoomWidth;
+					else
+						left = saveMapLoc.x;
+					if (lastZoomHeight < 0)
+						top = saveMapLoc.y + lastZoomHeight;
+					else
+						top = saveMapLoc.y;
+					dr.setPen(new Pen(new Color(255, 0, 0), Pen.SOLID, 3));
 					dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight), 0); // bug in ewe: thickness parameter is ignored
 				}
 			}
@@ -2225,28 +2294,30 @@
 		images.removeAllElements();
 		images.add(mapImage);
 	}
+
 	private void bringMaptoBack() {
-		if (saveImageList == null) return;
+		if (saveImageList == null)
+			return;
 		images = saveImageList;
 		saveImageList = null;
 	}
 
 	public void moveMap(int diffX, int diffY) {
 		Point p = new Point();
-		if (mapImage!= null) {
+		if (mapImage != null) {
 			p = mapImage.locAlways;
-			mapImage.move(p.x+diffX,p.y+diffY);
-			//		if (mm.mapHidden) mapImage.properties |= AniImage.IsInvisible; // this is neccesarry because move will unhide the map if the coos show that the map is on the screen
+			mapImage.move(p.x + diffX, p.y + diffY);
+			// if (mm.mapHidden) mapImage.properties |= AniImage.IsInvisible; // this is neccesarry because move will unhide the map if the coos show that the map is on the screen
 		}
 		mapMoved(diffX, diffY);
 	}
 
-	public void mapMoved(int diffX, int diffY){
+	public void mapMoved(int diffX, int diffY) {
 		mm.mapMoved(diffX, diffY);
 		this.repaintNow();
 	}
 
-	public void doPaint(Graphics g,Rect area) {
+	public void doPaint(Graphics g, Rect area) {
 		super.doPaint(g, area);
 		if (mm.gotoPos != null && mm.paintPosDestLine) {
 			final Point dest = mm.getXYonScreen(mm.gotoPos.where);
@@ -2257,12 +2328,14 @@
 
 	public void chooseMap() {
 		CWPoint gpspos;
-		if (mm.myNavigation.gpsPos.Fix > 0) gpspos = new CWPoint(mm.myNavigation.gpsPos.latDec, mm.myNavigation.gpsPos.lonDec);
-		else gpspos = null;
+		if (mm.myNavigation.gpsPos.Fix > 0)
+			gpspos = new CWPoint(mm.myNavigation.gpsPos.latDec, mm.myNavigation.gpsPos.lonDec);
+		else
+			gpspos = null;
 		final ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos(), mm.currentMap);
-		if(l.execute() == FormBase.IDOK){
+		if (l.execute() == FormBase.IDOK) {
 			mm.autoSelectMap = false;
-			if (l.selectedMap.isInBound(mm.posCircle.where) || l.selectedMap.getImageFilename().length()==0) {
+			if (l.selectedMap.isInBound(mm.posCircle.where) || l.selectedMap.getImageFilename().length() == 0) {
 				mm.setMap(l.selectedMap, mm.posCircle.where);
 				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
 				mm.ignoreGps = false;
@@ -2273,24 +2346,24 @@
 				if (mm.currentMap.fileNameWFL.length() > 0)
 					mm.setCenterOfScreen(l.selectedMap.center, true); // if map has an image
 				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
-				//Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
-				//double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4];
-				//mm.posCircleX = 0; // place map to the upper left corner of windows
-				//mm.posCircleY = 0;
-				//mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
+				// Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
+				// double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4];
+				// mm.posCircleX = 0; // place map to the upper left corner of windows
+				// mm.posCircleY = 0;
+				// mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
 			}
 		}
 	}
 
 	/**
-	 *	Method to react to user.
+	 * Method to react to user.
 	 */
-	public void imageClicked(AniImage which, Point pos){
+	public void imageClicked(AniImage which, Point pos) {
 		mm.getControlsLayer().imageClicked(which);
 	}
 
-	public void penHeld(Point p){
-		ignoreNextDrag=true;
+	public void penHeld(Point p) {
+		ignoreNextDrag = true;
 		if (!mm.zoomingMode) {
 			kontextMenu = new Menu();
 			if (!onlyIfCache) {
@@ -2300,69 +2373,66 @@
 			}
 			final AniImage clickedOnImage = images.findHotImage(p);
 			if (clickedOnImage != null && clickedOnImage instanceof MapSymbol) {
-				if ( ((MapSymbol)clickedOnImage).mapObject instanceof CacheHolder) {
-					clickedCache = (CacheHolder)( ((MapSymbol)clickedOnImage).mapObject);
+				if (((MapSymbol) clickedOnImage).mapObject instanceof CacheHolder) {
+					clickedCache = (CacheHolder) (((MapSymbol) clickedOnImage).mapObject);
 					// clickedCache == null can happen if clicked on the goto-symbol
 					if (clickedCache != null) {
-						openCacheDescMenuItem = new MenuItem(MyLocale.getMsg(201, "Open Desctiption")+" '"+(clickedCache.getCacheName().length()>0 ? clickedCache.getCacheName() : clickedCache.getWayPoint())+"'$o");
+						openCacheDescMenuItem = new MenuItem(MyLocale.getMsg(201, "Open Desctiption") + " '" + (clickedCache.getCacheName().length() > 0 ? clickedCache.getCacheName() : clickedCache.getWayPoint()) + "'$o");
 						kontextMenu.addItem(openCacheDescMenuItem);
-						openCacheDetailMenuItem = new MenuItem(MyLocale.getMsg(200, "Open Details")+" '"+(clickedCache.getCacheName().length()>0 ? clickedCache.getCacheName() : clickedCache.getWayPoint())+"'$e");
+						openCacheDetailMenuItem = new MenuItem(MyLocale.getMsg(200, "Open Details") + " '" + (clickedCache.getCacheName().length() > 0 ? clickedCache.getCacheName() : clickedCache.getWayPoint()) + "'$e");
 						kontextMenu.addItem(openCacheDetailMenuItem);
-						gotoCacheMenuItem = new MenuItem(MyLocale.getMsg(4279, "Goto")+ " '"+(clickedCache.getCacheName().length()>0 ? clickedCache.getCacheName() : clickedCache.getWayPoint())+"'$g");
+						gotoCacheMenuItem = new MenuItem(MyLocale.getMsg(4279, "Goto") + " '" + (clickedCache.getCacheName().length() > 0 ? clickedCache.getCacheName() : clickedCache.getWayPoint()) + "'$g");
 						kontextMenu.addItem(gotoCacheMenuItem);
 						if (Global.mainForm.cacheListVisible) {
-							addCachetoListMenuItem = new MenuItem(MyLocale.getMsg(199,"Add to cachetour"));
+							addCachetoListMenuItem = new MenuItem(MyLocale.getMsg(199, "Add to cachetour"));
 							kontextMenu.addItem(addCachetoListMenuItem);
 						}
-						String stmp=clickedCache.getCacheDetails(false).Hints;
-						stmp=stmp.substring(0,Math.min(10,stmp.length())).trim();
-						if (!stmp.equals("")){
-							kontextMenu.addItem(hintMenuItem=new MenuItem("Hint: "+stmp));
+						String stmp = clickedCache.getCacheDetails(false).Hints;
+						stmp = stmp.substring(0, Math.min(10, stmp.length())).trim();
+						if (!stmp.equals("")) {
+							kontextMenu.addItem(hintMenuItem = new MenuItem("Hint: " + stmp));
 						}
 						if (clickedCache.getType() == CacheType.CW_TYPE_QUESTION) {
-							stmp=clickedCache.getCacheDetails(false).LongDescription;
+							stmp = clickedCache.getCacheDetails(false).LongDescription;
 							if (!stmp.equals("")) {
-								kontextMenu.addItem(missionMenuItem=new MenuItem("?: "));
+								kontextMenu.addItem(missionMenuItem = new MenuItem("?: "));
 							}
 						}
 						kontextMenu.addItem(new MenuItem("-"));
-						kontextMenu.addItem(new MenuItem(clickedCache.getWayPoint()+" Info:"));
-						kontextMenu.addItem(new MenuItem("Difficulty: "+CacheTerrDiff.longDT(clickedCache.getHard())));
-						kontextMenu.addItem(new MenuItem("Terrain: "+CacheTerrDiff.longDT(clickedCache.getTerrain())));
-						kontextMenu.addItem(new MenuItem("Size: "+CacheSize.cw2ExportString(clickedCache.getCacheSize())));
+						kontextMenu.addItem(new MenuItem(clickedCache.getWayPoint() + " Info:"));
+						kontextMenu.addItem(new MenuItem("Difficulty: " + CacheTerrDiff.longDT(clickedCache.getHard())));
+						kontextMenu.addItem(new MenuItem("Terrain: " + CacheTerrDiff.longDT(clickedCache.getTerrain())));
+						kontextMenu.addItem(new MenuItem("Size: " + CacheSize.cw2ExportString(clickedCache.getCacheSize())));
 					}
 				}
 			}
 			/*
-			 *  this kontext will be replaced by the settings of the rose in the goto panel
-			 *
-			if ( !(mm.directionArrows.onHotArea(p.x, p.y)) ) {
-			}
-			else {
-				for (int i=0; i<SkyOrientation.LUMINARY_NAMES.length; i++) {
-					kontextMenu.addItem(miLuminary[i]);
-					if (i == mm.myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
-					else miLuminary[i].modifiers &= MenuItem.Checked;
-				}
-			}
-			*/
-			onlyIfCache=false;
-			if (kontextMenu.items.size()>0) {
+			 * this kontext will be replaced by the settings of the rose in the goto panel
+			 * 
+			 * if ( !(mm.directionArrows.onHotArea(p.x, p.y)) ) {
+			 * }
+			 * else {
+			 * for (int i=0; i<SkyOrientation.LUMINARY_NAMES.length; i++) {
+			 * kontextMenu.addItem(miLuminary[i]);
+			 * if (i == mm.myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
+			 * else miLuminary[i].modifiers &= MenuItem.Checked;
+			 * }
+			 * }
+			 */
+			onlyIfCache = false;
+			if (kontextMenu.items.size() > 0) {
 				kontextMenu.exec(this, new Point(p.x, p.y), this);
-			}
-			else kontextMenu=null;
+			} else
+				kontextMenu = null;
 		}
 	}
 
 	public boolean imageMovedOn(AniImage which) {
 		if (which instanceof MapSymbol) {
-			if ( ((MapSymbol)which).mapObject instanceof CacheHolder) {
+			if (((MapSymbol) which).mapObject instanceof CacheHolder) {
 				final CacheHolder ch = (CacheHolder) ((MapSymbol) which).mapObject;
-				this.toolTip=ch.getWayPoint()+"\n"
-							+ ch.cacheName+"\n"
-							+ "Difficulty: "+CacheTerrDiff.longDT(ch.getHard())+"\n"
-							+ "Terrain: "+CacheTerrDiff.longDT(ch.getTerrain())+"\n"
-							+ "Size: "+CacheSize.cw2ExportString(ch.getCacheSize())+"\n";
+				this.toolTip = ch.getWayPoint() + "\n" + ch.getCacheName() + "\n" + "Difficulty: " + CacheTerrDiff.longDT(ch.getHard()) + "\n" + "Terrain: " + CacheTerrDiff.longDT(ch.getTerrain()) + "\n" + "Size: "
+						+ CacheSize.cw2ExportString(ch.getCacheSize()) + "\n";
 				if (ch.getType() == CacheType.CW_TYPE_QUESTION) {
 					this.toolTip = this.toolTip + ch.getCacheDetails(false).LongDescription;
 				}
@@ -2370,21 +2440,19 @@
 		}
 		return true;
 	}
+
 	public boolean imageMovedOff(AniImage which) {
 		if (which instanceof MapSymbol) {
-			if ( ((MapSymbol)which).mapObject instanceof CacheHolder) {
-				this.toolTip=null;
+			if (((MapSymbol) which).mapObject instanceof CacheHolder) {
+				this.toolTip = null;
 			}
 		}
 		return true;
 	}
 
-	public void onEvent(Event ev){
+	public void onEvent(Event ev) {
 		// nothing selected in kontext
-		if (kontextMenu != null
-				&& ev instanceof PenEvent
-				&& ev.type == PenEvent.PEN_DOWN
-				&& ev.target == this) {
+		if (kontextMenu != null && ev instanceof PenEvent && ev.type == PenEvent.PEN_DOWN && ev.target == this) {
 			kontextMenu.close();
 			kontextMenu = null;
 			return;
@@ -2392,7 +2460,7 @@
 		// something selected
 		if (ev instanceof MenuEvent) {
 			if (ev.target == kontextMenu) {
-				if ((((MenuEvent)ev).type==MenuEvent.SELECTED)) {
+				if ((((MenuEvent) ev).type == MenuEvent.SELECTED)) {
 					final MenuItem action = (MenuItem) kontextMenu.getSelectedItem();
 					if (action == gotoMenuItem) {
 						closeKontextMenu();
@@ -2402,9 +2470,9 @@
 						leaveMovingMap();
 						final MainTab mainT = Global.mainTab;
 						if (action == openCacheDescMenuItem)
-							mainT.openPanel(clickedCache,2);
+							mainT.openPanel(clickedCache, 2);
 						else
-							mainT.openPanel(clickedCache,1);
+							mainT.openPanel(clickedCache, 1);
 					}
 					if (action == gotoCacheMenuItem) {
 						closeKontextMenu();
@@ -2422,21 +2490,21 @@
 						Global.mainForm.cacheList.addCache(clickedCache.getWayPoint());
 					}
 					if (action == hintMenuItem) {
-						(new MessageBox("Hint", STRreplace.replace(Common.rot13(clickedCache.getCacheDetails(false).Hints),"<br>","\n"), FormBase.OKB)).execute();
+						(new MessageBox("Hint", STRreplace.replace(Common.rot13(clickedCache.getCacheDetails(false).Hints), "<br>", "\n"), FormBase.OKB)).execute();
 					}
 					if (action == missionMenuItem) {
-						(new MessageBox("Mission", STRreplace.replace(clickedCache.getCacheDetails(false).LongDescription,"<br>","\n"), FormBase.OKB)).execute();
+						(new MessageBox("Mission", STRreplace.replace(clickedCache.getCacheDetails(false).LongDescription, "<br>", "\n"), FormBase.OKB)).execute();
 					}
 					/*
-					for (int i=0; i<miLuminary.length; i++) {
-						if (action == miLuminary[i]) {
-							kontextMenu.close();
-							mm.myNavigation.setLuminary(i);
-							mm.updateGps(mm.myNavigation.gpsPos.getFix());
-							miLuminary[i].modifiers |= MenuItem.Checked;
-						} else miLuminary[i].modifiers &= ~MenuItem.Checked;
-					}
-					*/
+					 * for (int i=0; i<miLuminary.length; i++) {
+					 * if (action == miLuminary[i]) {
+					 * kontextMenu.close();
+					 * mm.myNavigation.setLuminary(i);
+					 * mm.updateGps(mm.myNavigation.gpsPos.getFix());
+					 * miLuminary[i].modifiers |= MenuItem.Checked;
+					 * } else miLuminary[i].modifiers &= ~MenuItem.Checked;
+					 * }
+					 */
 				}
 			} // if (ev.target == kontextMenu)
 		}
@@ -2447,12 +2515,13 @@
 		kontextMenu.close();
 		// for not to do an additional klick (before reacting on klicks)
 		final PenEvent pev = new PenEvent();
-		pev.target=this;
-		pev.type=PenEvent.PEN_DOWN;
+		pev.target = this;
+		pev.type = PenEvent.PEN_DOWN;
 		this.postEvent(pev);
-		pev.type=PenEvent.PEN_UP;
+		pev.type = PenEvent.PEN_UP;
 		this.postEvent(pev);
 	}
+
 	private void leaveMovingMap() {
 		closeKontextMenu();
 		final WindowEvent close = new WindowEvent();
@@ -2463,20 +2532,20 @@
 }
 
 /**
- *	Class to display maps to choose from
+ * Class to display maps to choose from
  */
-class ListBox extends Form{
+class ListBox extends Form {
 	public MapInfoObject selectedMap; // = new MapInfoObject();
 	mButton cancelButton, okButton;
-	mList list = new mList(4,1,false);
+	mList list = new mList(4, 1, false);
 	public boolean selected = false;
 	Vector maps;
 
-	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos, MapInfoObject curMap){
+	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos, MapInfoObject curMap) {
 		this.title = MyLocale.getMsg(4271, "Maps");
 		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else
 		// set width to screenwidth *3/4 but to at least 240 if the screen is big engough for 240px width
-		this.setPreferredSize(java.lang.Math.max(MyLocale.getScreenWidth()*3/4, java.lang.Math.min(240, MyLocale.getScreenWidth()) ), MyLocale.getScreenHeight()*3/4);
+		this.setPreferredSize(java.lang.Math.max(MyLocale.getScreenWidth() * 3 / 4, java.lang.Math.min(240, MyLocale.getScreenWidth())), MyLocale.getScreenHeight() * 3 / 4);
 		this.maps = maps;
 		MapInfoObject map;
 		MapListEntry ml;
@@ -2485,45 +2554,55 @@
 		boolean curMapFound = false;
 		final boolean[] inList = new boolean[maps.size()];
 		int row = -1;
-		if (curMap == null) curMapFound = true;
+		if (curMap == null)
+			curMapFound = true;
 		if (gotopos != null && Gps != null) {
 			list.addItem(MyLocale.getMsg(4272, "--- Maps containing GPS and goto pos. ---"));
 			row++;
-			cmp = "FF1"+(new Area(new CWPoint(Gps.latDec, Gps.lonDec), gotopos)).getEasyFindString();
-			for(int i = 0; i<maps.size();i++){
-				ml = (MapListEntry)maps.get(i);
+			cmp = "FF1" + (new Area(new CWPoint(Gps.latDec, Gps.lonDec), gotopos)).getEasyFindString();
+			for (int i = 0; i < maps.size(); i++) {
+				ml = (MapListEntry) maps.get(i);
 				try {
-					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
-					else { map = ml.getMap();}
-				} catch (final IOException ex) {continue; } // could not read .wfl-file
-				if( map.isInBound(Gps.latDec, Gps.lonDec) && map.isInBound(gotopos) )
-				{
+					if (!Area.containsRoughly(ml.sortEntryBBox, cmp))
+						continue; // TODO if no map available
+					else {
+						map = ml.getMap();
+					}
+				} catch (final IOException ex) {
+					continue;
+				} // could not read .wfl-file
+				if (map.isInBound(Gps.latDec, Gps.lonDec) && map.isInBound(gotopos)) {
 					list.addItem(i + ": " + map.mapName);
 					row++;
 					inList[i] = true;
-					if (!curMapFound && curMap!=null && map.mapName.equals(curMap.mapName)) {
+					if (!curMapFound && curMap != null && map.mapName.equals(curMap.mapName)) {
 						oldmap = row;
 						curMapFound = true;
 					}
-				} else inList[i] = false;
+				} else
+					inList[i] = false;
 			}
 		}
 		if (Gps != null) {
 			list.addItem(MyLocale.getMsg(4273, "--- Maps containing curr. position ---"));
 			row++;
-			cmp = "FF1"+Area.getEasyFindString(new CWPoint(Gps.latDec, Gps.lonDec), 30);
-			for(int i = 0; i<maps.size();i++){
-				ml = (MapListEntry)maps.get(i);
+			cmp = "FF1" + Area.getEasyFindString(new CWPoint(Gps.latDec, Gps.lonDec), 30);
+			for (int i = 0; i < maps.size(); i++) {
+				ml = (MapListEntry) maps.get(i);
 				try {
-					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
-					else { map = ml.getMap();}
-				} catch (final IOException ex) {continue; } // could not read .wfl-file
-				if( map.isInBound(Gps.latDec, Gps.lonDec) )
-				{
+					if (!Area.containsRoughly(ml.sortEntryBBox, cmp))
+						continue; // TODO if no map available
+					else {
+						map = ml.getMap();
+					}
+				} catch (final IOException ex) {
+					continue;
+				} // could not read .wfl-file
+				if (map.isInBound(Gps.latDec, Gps.lonDec)) {
 					list.addItem(i + ": " + map.mapName);
 					row++;
 					inList[i] = true;
-					if (!curMapFound  && curMap!=null && map.mapName.equals(curMap.mapName)) {
+					if (!curMapFound && curMap != null && map.mapName.equals(curMap.mapName)) {
 						oldmap = row;
 						curMapFound = true;
 					}
@@ -2533,18 +2612,23 @@
 		if (gotopos != null) {
 			list.addItem(MyLocale.getMsg(4274, "--- Karten des Ziels ---"));
 			row++;
-			cmp = "FF1"+Area.getEasyFindString(gotopos, 30);
-			for(int i = 0; i<maps.size();i++){
-				ml = (MapListEntry)maps.get(i);
+			cmp = "FF1" + Area.getEasyFindString(gotopos, 30);
+			for (int i = 0; i < maps.size(); i++) {
+				ml = (MapListEntry) maps.get(i);
 				try {
-					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
-					else { map = ml.getMap();}
-				} catch (final IOException ex) {continue; } // could not read .wfl-file
-				if(map.isInBound(gotopos)) {
+					if (!Area.containsRoughly(ml.sortEntryBBox, cmp))
+						continue; // TODO if no map available
+					else {
+						map = ml.getMap();
+					}
+				} catch (final IOException ex) {
+					continue;
+				} // could not read .wfl-file
+				if (map.isInBound(gotopos)) {
 					list.addItem(i + ": " + map.mapName);
 					row++;
 					inList[i] = true;
-					if (!curMapFound  && curMap!=null && map.mapName.equals(curMap.mapName)) {
+					if (!curMapFound && curMap != null && map.mapName.equals(curMap.mapName)) {
 						oldmap = row;
 						curMapFound = true;
 					}
@@ -2553,69 +2637,68 @@
 		}
 		list.addItem(MyLocale.getMsg(4275, "--- andere Karten ---"));
 		row++;
-		for(int i = 0; i<maps.size();i++){
-			ml = (MapListEntry)maps.get(i);
-			if(!inList[i]) {
+		for (int i = 0; i < maps.size(); i++) {
+			ml = (MapListEntry) maps.get(i);
+			if (!inList[i]) {
 				list.addItem(i + ": " + ml.filename);
 				row++;
-				if (!curMapFound && curMap!=null && ml.filename.equals(curMap.mapName)) {
+				if (!curMapFound && curMap != null && ml.filename.equals(curMap.mapName)) {
 					oldmap = row;
 					curMapFound = true;
 				}
 			}
 		}
 		list.selectItem(oldmap, true);
-		this.addLast(new CacheWolf.MyScrollBarPanel(list),CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(new CacheWolf.MyScrollBarPanel(list), CellConstants.STRETCH, CellConstants.FILL);
 		cancelButton = new mButton(MyLocale.getMsg(4276, "Cancel"));
 		cancelButton.setHotKey(0, KeyEvent.getCancelKey(true));
-		this.addNext(cancelButton,CellConstants.STRETCH, CellConstants.FILL);
+		this.addNext(cancelButton, CellConstants.STRETCH, CellConstants.FILL);
 		okButton = new mButton(MyLocale.getMsg(4277, "Select"));
 		okButton.setHotKey(0, KeyEvent.getActionKey(true));
-		this.addLast(okButton,CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(okButton, CellConstants.STRETCH, CellConstants.FILL);
 		okButton.takeFocus(0);
 	}
+
 	public void mapSelected() {
 		try {
 			selectedMap = null;
 			int mapNum = 0;
 			String it = new String();
 			it = list.getText();
-			if (it != ""){
-				it = it.substring(0,it.indexOf(':'));
+			if (it != "") {
+				it = it.substring(0, it.indexOf(':'));
 				mapNum = Convert.toInt(it);
 				try {
-				selectedMap = ((MapListEntry)maps.get(mapNum)).getMap();
-				selected = true;
-				this.close(FormBase.IDOK);
+					selectedMap = ((MapListEntry) maps.get(mapNum)).getMap();
+					selected = true;
+					this.close(FormBase.IDOK);
 				} catch (final IOException e) {
-					(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4278, "Cannot load wfl-file: \n")
-							+ ((MapListEntry)maps.get(mapNum)).filename, FormBase.OKB)).execute();
+					(new MessageBox(MyLocale.getMsg(4207, "Error"), MyLocale.getMsg(4278, "Cannot load wfl-file: \n") + ((MapListEntry) maps.get(mapNum)).filename, FormBase.OKB)).execute();
 				}
-			}
-			else {
+			} else {
 				selected = false;
 				this.close(FormBase.IDCANCEL);
 			}
-		}catch (final NegativeArraySizeException e) {
+		} catch (final NegativeArraySizeException e) {
 			// happens in substring when a dividing line selected
 		}
 	}
 
-	public void onEvent(Event ev){
-		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelButton){
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
+			if (ev.target == cancelButton) {
 				selectedMap = null;
 				selected = false;
 				this.close(FormBase.IDCANCEL);
 			}
-			if (ev.target == okButton || ev.target == list){ // ev.target == list is posted by mList if a selection was double clicked
+			if (ev.target == okButton || ev.target == list) { // ev.target == list is posted by mList if a selection was double clicked
 				mapSelected();
 			}
 		}
 		super.onEvent(ev);
 	}
 
-	public void  penDoubleClicked(Point where) {
+	public void penDoubleClicked(Point where) {
 		mapSelected();
 	}
 }
@@ -2627,13 +2710,13 @@
 
 	int minY;
 	Graphics draw;
-	private MapInfoObject map=null;
+	private MapInfoObject map = null;
 
-	Color moveDirColor = new Color(255,0,0); // RED
-	final static Color sunDirColor = new Color(255,255,0); // Yellow
-	//final static Color GREEN = new Color(0,255,0);
-	final static Color gotoDirColor = new Color(0,0,128); // dark blue
-	final static Color northDirColor = new Color(0,0,255); // Blue
+	Color moveDirColor = new Color(255, 0, 0); // RED
+	final static Color sunDirColor = new Color(255, 255, 0); // Yellow
+	// final static Color GREEN = new Color(0,255,0);
+	final static Color gotoDirColor = new Color(0, 0, 128); // dark blue
+	final static Color northDirColor = new Color(0, 0, 255); // Blue
 	Point[] sunDirArrow = null;
 	Point[] gotoDirArrow = null;
 	Point[] moveDirArrow = null;
@@ -2643,31 +2726,33 @@
 	int arrowThickness = imageSize / 28;
 
 	/**
-	 * @param gd goto direction
-	 * @param sd sun direction
-	 * @param md moving direction
+	 * @param gd
+	 *            goto direction
+	 * @param sd
+	 *            sun direction
+	 * @param md
+	 *            moving direction
 	 */
-	public ArrowsOnMap(){
+	public ArrowsOnMap() {
 		super();
 		newImage();
-		//	setDirections(90, 180, -90);
+		// setDirections(90, 180, -90);
 	}
 
 	public void newImage() {
-		setImage(new Image(imageSize,imageSize), Color.White);
+		setImage(new Image(imageSize, imageSize), Color.White);
 		draw = new Graphics(image);
 	}
+
 	public void setMap(MapInfoObject m) {
 		map = m;
 		makeArrows();
 	}
 
-	public void setDirections(float gd, float sd, float md ) {
+	public void setDirections(float gd, float sd, float md) {
 		if (java.lang.Math.abs(gotoDir - gd) > 1 // to save cpu-usage only update if the is a change of directions of more than 1 degree
-				|| java.lang.Math.abs(sunDir - sd) > 1
-				|| java.lang.Math.abs(moveDir - md) > 1)
-		{
-			//dirsChanged = false;
+				|| java.lang.Math.abs(sunDir - sd) > 1 || java.lang.Math.abs(moveDir - md) > 1) {
+			// dirsChanged = false;
 			gotoDir = gd;
 			sunDir = sd;
 			moveDir = md;
@@ -2677,98 +2762,111 @@
 
 	/**
 	 * draw arrows for the directions of movement and destination waypoint
-	 * @param ctrl the control to paint on
-	 * @param moveDir degrees of movement
-	 * @param destDir degrees of destination waypoint
+	 * 
+	 * @param ctrl
+	 *            the control to paint on
+	 * @param moveDir
+	 *            degrees of movement
+	 * @param destDir
+	 *            degrees of destination waypoint
 	 */
 
-	public void doDraw(Graphics g,int options) {
-		if (map == null || g == null) return;
+	public void doDraw(Graphics g, int options) {
+		if (map == null || g == null)
+			return;
 		drawArrows(g);
 		return;
-/*		if (!dirsChanged) {
-			g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height); // the transparency with a transparent color doesn't work in ewe-vm for pocketpc, it works in java-vm, ewe-vm on pocketpc2003
-			return;
-		}
-		dirsChanged = false;
-		//super.doDraw(g, options);
-		draw.setColor(Color.White);
-		draw.fillRect(0, 0, location.width, location.height);
-		minY = Integer.MAX_VALUE;
-		drawArrows(draw);
-		draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw
-		g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
-*/	}
+		/*
+		 * if (!dirsChanged) {
+		 * g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height); // the transparency with a transparent color doesn't work in ewe-vm for pocketpc, it works in java-vm, ewe-vm on pocketpc2003
+		 * return;
+		 * }
+		 * dirsChanged = false;
+		 * //super.doDraw(g, options);
+		 * draw.setColor(Color.White);
+		 * draw.fillRect(0, 0, location.width, location.height);
+		 * minY = Integer.MAX_VALUE;
+		 * drawArrows(draw);
+		 * draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw
+		 * g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
+		 */}
 
-	private void makeArrows(){
-			// draw only valid arrows
-			if (moveDir < 360 && moveDir > -360) {
-				if (moveDirArrow == null) moveDirArrow = new Point[2];
-				makeArrow(moveDirArrow, moveDir, 1.0f);
-			} else moveDirArrow = null;
-			if (gotoDir < 360 && gotoDir > -360) {
-				if (gotoDirArrow == null) gotoDirArrow = new Point[2];
-				makeArrow(gotoDirArrow, gotoDir, 1.0f);
-			} else gotoDirArrow = null;
-			if (sunDir < 360 && sunDir> -360) {
-				if (sunDirArrow == null ) sunDirArrow = new Point[2];
-				makeArrow(sunDirArrow, sunDir, 0.75f);
-			} else sunDirArrow = null;
-			if (map != null && java.lang.Math.abs(map.rotationRad) > 1.5 / 180 * java.lang.Math.PI)	{ // show northth arrow only if it has more than 1.5 degree deviation from vertical direction
-				if (northDirArrow == null) northDirArrow = new Point[2];
-				makeArrow(northDirArrow, 0, 1.0f); // north direction
-			} else northDirArrow = null;
+	private void makeArrows() {
+		// draw only valid arrows
+		if (moveDir < 360 && moveDir > -360) {
+			if (moveDirArrow == null)
+				moveDirArrow = new Point[2];
+			makeArrow(moveDirArrow, moveDir, 1.0f);
+		} else
+			moveDirArrow = null;
+		if (gotoDir < 360 && gotoDir > -360) {
+			if (gotoDirArrow == null)
+				gotoDirArrow = new Point[2];
+			makeArrow(gotoDirArrow, gotoDir, 1.0f);
+		} else
+			gotoDirArrow = null;
+		if (sunDir < 360 && sunDir > -360) {
+			if (sunDirArrow == null)
+				sunDirArrow = new Point[2];
+			makeArrow(sunDirArrow, sunDir, 0.75f);
+		} else
+			sunDirArrow = null;
+		if (map != null && java.lang.Math.abs(map.rotationRad) > 1.5 / 180 * java.lang.Math.PI) { // show northth arrow only if it has more than 1.5 degree deviation from vertical direction
+			if (northDirArrow == null)
+				northDirArrow = new Point[2];
+			makeArrow(northDirArrow, 0, 1.0f); // north direction
+		} else
+			northDirArrow = null;
 
-			//select moveDirColor according to difference to gotoDir
-			moveDirColor = new Color(255,0,0); // red
+		// select moveDirColor according to difference to gotoDir
+		moveDirColor = new Color(255, 0, 0); // red
 
-			if (moveDirArrow != null && gotoDirArrow != null)
-			{
-				float diff = java.lang.Math.abs(moveDir - gotoDir);
-				while (diff > 360)
-				{
-					diff -= 360.0f;
-				}
-				if (diff > 180)
-				{
-					diff = 360.0f - diff;
-				}
+		if (moveDirArrow != null && gotoDirArrow != null) {
+			float diff = java.lang.Math.abs(moveDir - gotoDir);
+			while (diff > 360) {
+				diff -= 360.0f;
+			}
+			if (diff > 180) {
+				diff = 360.0f - diff;
+			}
 
-				if (diff <= 5.0)
-				{
-					moveDirColor = new Color(0,192,0);// darkgreen
-				}
-				else if (diff <= 22.5)
-				{
-					moveDirColor = new Color(0,255,0);// green
-				}
-				else if (diff <= 45.0)
-				{
-					moveDirColor = new Color(255,128,0);// orange
-				}
+			if (diff <= 5.0) {
+				moveDirColor = new Color(0, 192, 0);// darkgreen
+			} else if (diff <= 22.5) {
+				moveDirColor = new Color(0, 255, 0);// green
+			} else if (diff <= 45.0) {
+				moveDirColor = new Color(255, 128, 0);// orange
 			}
 		}
+	}
 
 	/**
 	 * make (calculate) Pixel array for a single arrow
-	 * @param g handle for drawing
-	 * @param angle angle of arrow
-	 * @param col color of arrow
+	 * 
+	 * @param g
+	 *            handle for drawing
+	 * @param angle
+	 *            angle of arrow
+	 * @param col
+	 *            color of arrow
 	 */
 	private void makeArrow(Point[] arrow, float angle, float scale) {
-		if (map == null) return;
+		if (map == null)
+			return;
 
 		float angleRad;
-		final int centerX = location.width/2, centerY = location.height/2;
-		if (arrow[0] == null) arrow[0] = new Point();
-		if (arrow[1] == null) arrow[1] = new Point();
+		final int centerX = location.width / 2, centerY = location.height / 2;
+		if (arrow[0] == null)
+			arrow[0] = new Point();
+		if (arrow[1] == null)
+			arrow[1] = new Point();
 		arrow[0].x = centerX;
 		arrow[0].y = centerY;
-		angleRad = angle * (float)java.lang.Math.PI / 180 + map.rotationRad;
+		angleRad = angle * (float) java.lang.Math.PI / 180 + map.rotationRad;
 		arrow[1].x = centerX + new Float(centerX * java.lang.Math.sin(angleRad) * scale).intValue();
 		arrow[1].y = centerY - new Float(centerY * java.lang.Math.cos(angleRad) * scale).intValue();
-		//	g.setPen(new Pen(Color.Black,Pen.SOLID,7));
-		//	g.drawLine(centerX,centerY,x,y);
+		// g.setPen(new Pen(Color.Black,Pen.SOLID,7));
+		// g.drawLine(centerX,centerY,x,y);
 	}
 
 	public void drawArrows(Graphics g) {
@@ -2779,12 +2877,9 @@
 	}
 
 	public void drawArrow(Graphics g, Point[] arrow, Color col) {
-		if (arrow == null) return;
-		g.setPen(new Pen(col,Pen.SOLID,arrowThickness));
-		g.drawLine(arrow[0].x, arrow[0].y, arrow[1].x,arrow[1].y);
+		if (arrow == null)
+			return;
+		g.setPen(new Pen(col, Pen.SOLID, arrowThickness));
+		g.drawLine(arrow[0].x, arrow[0].y, arrow[1].x, arrow[1].y);
 	}
 }
-
-
-
-

Modified: trunk/src/CacheWolf/navi/touchControls/MovingMapControlItem.java
===================================================================
--- trunk/src/CacheWolf/navi/touchControls/MovingMapControlItem.java	2011-05-18 14:06:48 UTC (rev 3007)
+++ trunk/src/CacheWolf/navi/touchControls/MovingMapControlItem.java	2011-05-20 16:46:24 UTC (rev 3008)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi.touchControls;
 
 import CacheWolf.Global;
@@ -87,25 +87,21 @@
 					offsetx = offsety;
 				}
 
-				int[] iconPixels = icon.getPixels(null, 0, 0, 0, iconW, iconH,
-						0);
-				int[] imagePixels = image.getPixels(null, 0, 0, 0, imageW,
-						imageH, 0);
+				int[] iconPixels = icon.getPixels(null, 0, 0, 0, iconW, iconH, 0);
+				int[] imagePixels = image.getPixels(null, 0, 0, 0, imageW, imageH, 0);
 
-				for (int line = 0; line < imageH; line++) {
-					for (int pos = 0; pos < imageW; pos++) {
+				for (int y = 0; y < imageH; y++) {
+					for (int x = 0; x < imageW; x++) {
 
-						if (line >= offsety && pos >= offsetx
-								&& line < offsety + iconH
-								&& pos < offsetx + iconW) {
+						if (y >= offsety && x >= offsetx && y < offsety + iconH && x < offsetx + iconW) {
 
-							int iconx = pos - offsetx;
-							int icony = line - offsety;
+							int iconx = x - offsetx;
+							int icony = y - offsety;
 
-							int index = line * imageW + pos;
+							int index = y * imageW + x;
 							int iconIndex = icony * iconW + iconx;
 							int alphaval = (iconPixels[iconIndex] >> 24) & 0xff;
-							
+
 							if (alphaval > 127) {
 								imagePixels[index] = iconPixels[iconIndex];
 							}
@@ -117,15 +113,14 @@
 				image.setPixels(imagePixels, 0, 0, 0, imageW, imageH, 0);
 
 			} else
-				Global.getPref().log("icon " + iconSrc + " is bigger than " + source+ "! Icon not loaded",null);
+				Global.getPref().log("icon " + iconSrc + " is bigger than " + source + "! Icon not loaded", null);
 
 		}
 
 		if (alpha >= 0 && alpha < 256) {
 			alpha = alpha << 24;
 
-			int[] imageBits = image.getPixels(null, 0, 0, 0, image.getWidth(),
-					image.getHeight(), 0);
+			int[] imageBits = image.getPixels(null, 0, 0, 0, image.getWidth(), image.getHeight(), 0);
 			for (int i = 0; i < imageBits.length; i++) {
 				if (imageBits[i] != 0) {
 					imageBits[i] &= 0xffffff;
@@ -133,8 +128,7 @@
 				}
 
 			}
-			image.setPixels(imageBits, 0, 0, 0, image.getWidth(), image
-					.getHeight(), 0);
+			image.setPixels(imageBits, 0, 0, 0, image.getWidth(), image.getHeight(), 0);
 			image.enableAlpha();
 		}
 
@@ -156,6 +150,7 @@
 	public String getContent() {
 		return null;
 	}
+
 	public String getText() {
 		return null;
 	}
@@ -209,7 +204,7 @@
 
 			Boolean thisElement = (Boolean) roles.get(nextKey);
 			if (!overallRoles.containsKey(nextKey)) {
-				Global.getPref().log("Lookup role " + nextKey + " not possible",null);
+				Global.getPref().log("Lookup role " + nextKey + " not possible", null);
 				return false;
 			}
 

Modified: trunk/src/CacheWolf/navi/touchControls/MovingMapControlItemButton.java
===================================================================
--- trunk/src/CacheWolf/navi/touchControls/MovingMapControlItemButton.java	2011-05-18 14:06:48 UTC (rev 3007)
+++ trunk/src/CacheWolf/navi/touchControls/MovingMapControlItemButton.java	2011-05-20 16:46:24 UTC (rev 3008)
@@ -1,31 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi.touchControls;
 
-
 import ewe.fx.Image;
 import ewe.fx.mImage;
 import ewe.graphics.AniImage;
@@ -34,22 +33,20 @@
 
 	private int command;
 	private AniImageGrayScaled aniImage;
-	
-	public MovingMapControlItemButton(String source,String iconSrc, int actionCommand,
-			int alpha) {
+
+	public MovingMapControlItemButton(String source, String iconSrc, int actionCommand, int alpha) {
 		Image image = MovingMapControlItem.createImage(source, iconSrc, alpha);
 		aniImage = new AniImageGrayScaled(image);
 		aniImage.freeSource();
 		command = actionCommand;
-		aniImage.properties|= mImage.AlwaysOnTop;
-		xProperties|=IS_ICON_WITH_COMMAND;
+		aniImage.properties |= mImage.AlwaysOnTop;
+		xProperties |= IS_ICON_WITH_COMMAND;
 	}
 
 	public int getActionCommand() {
 		return command;
 	}
 
-	
 	public int getWidth() {
 		return aniImage.getWidth();
 	}



From apreisser at mail.berlios.de  Sat May 21 01:26:47 2011
From: apreisser at mail.berlios.de (apreisser at mail.berlios.de)
Date: Sat, 21 May 2011 01:26:47 PM +0200
Subject: [Cachewolf-svn] r3009 - trunk/src/CacheWolf/view/pda
Message-ID: <20110521112647.6760E4813F8@sheep.berlios.de>

Author: apreisser
Date: 2011-05-21 13:26:46 +0200 (Sat, 21 May 2011)
New Revision: 3009

Modified:
   trunk/src/CacheWolf/view/pda/PDATravelbugJourneyScreen.java
Log:
Buttons not displaying a member of the listmodel will be disabled

Modified: trunk/src/CacheWolf/view/pda/PDATravelbugJourneyScreen.java
===================================================================
--- trunk/src/CacheWolf/view/pda/PDATravelbugJourneyScreen.java	2011-05-20 16:46:24 UTC (rev 3008)
+++ trunk/src/CacheWolf/view/pda/PDATravelbugJourneyScreen.java	2011-05-21 11:26:46 UTC (rev 3009)
@@ -2,10 +2,11 @@
 
 import CacheWolf.MyLocale;
 import CacheWolf.TravelbugJourney;
-import CacheWolf.model.TravelBugScreenModel;
+import CacheWolf.model.TravelBugJourneyScreenModel;
 import ewe.graphics.AniImage;
 import ewe.sys.Vm;
 import ewe.ui.CellConstants;
+import ewe.ui.ControlConstants;
 import ewe.ui.ControlEvent;
 import ewe.ui.Form;
 
@@ -20,14 +21,8 @@
 
 	PDAListButton[] listButtons;
 
-	TravelBugScreenModel model;
-	// public boolean onlyLogged = false;
-	// /**
-	// * List of all travelbugs in inventory
-	// */
-	// public TravelbugJourneyList myTravelbugJourneys;
-	//
-	// private Vector tbJourneysShowSet;
+	TravelBugJourneyScreenModel model;
+
 	/**
 	 * The index of the first item in the list shown
 	 */
@@ -39,7 +34,7 @@
 	 * The six visible entries in the List
 	 */
 
-	public PDATravelbugJourneyScreen(TravelBugScreenModel travelbugModel) {
+	public PDATravelbugJourneyScreen(TravelBugJourneyScreenModel travelbugModel) {
 		listButtons = new PDAListButton[linesOnScreen];
 		addListener(this);
 		setTitle("TravelBugs");
@@ -115,13 +110,12 @@
 				listButtons[i].toText = tbJourney.getToWaypoint() + '/' + tbJourney.getToProfile();
 				listButtons[i].toLogged = tbJourney.getToLogged();
 				listButtons[i].image = new AniImage("bug_vga.gif");
+				listButtons[i].modify(ControlConstants.Disabled, 1);
 			} else {
-				listButtons[i].text =
-						listButtons[i].fromText =
-								listButtons[i].toText = "";
-				listButtons[i].toLogged =
-						listButtons[i].fromLogged = true;
+				listButtons[i].text = listButtons[i].fromText =	listButtons[i].toText = "";
+				listButtons[i].toLogged = listButtons[i].fromLogged = true;
 				listButtons[i].image = null;
+				listButtons[i].modify(ControlConstants.Disabled, 0);
 			}
 			listButtons[i].repaint();
 		}



From apreisser at mail.berlios.de  Sat May 21 04:12:33 2011
From: apreisser at mail.berlios.de (apreisser at mail.berlios.de)
Date: Sat, 21 May 2011 04:12:33 PM +0200
Subject: [Cachewolf-svn] r3010 - trunk/src/CacheWolf
Message-ID: <20110521141233.BF6EC4813F8@sheep.berlios.de>

Author: apreisser
Date: 2011-05-21 16:12:33 +0200 (Sat, 21 May 2011)
New Revision: 3010

Modified:
   trunk/src/CacheWolf/MainMenu.java
Log:
Sets PreferredSize of TravelBugJourneyScreen to screensize store in MyLocale

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2011-05-21 11:26:46 UTC (rev 3009)
+++ trunk/src/CacheWolf/MainMenu.java	2011-05-21 14:12:33 UTC (rev 3010)
@@ -735,7 +735,7 @@
 			}
 			if (mev.selectedItem == orgTravelbugs) {
 				Form tbs = TravelbugJourneyScreenFactory.createTravelbugJourneyScreen();
-				tbs.setPreferredSize(800, 600);
+				tbs.setPreferredSize(MyLocale.getScreenWidth(), MyLocale.getScreenHeight());
 				tbs.execute();
 				tbs.close(0);
 			}



From apreisser at mail.berlios.de  Sat May 21 04:37:59 2011
From: apreisser at mail.berlios.de (apreisser at mail.berlios.de)
Date: Sat, 21 May 2011 04:37:59 PM +0200
Subject: [Cachewolf-svn] r3011 - trunk/src/CacheWolf
Message-ID: <20110521143759.75F944813F8@sheep.berlios.de>

Author: apreisser
Date: 2011-05-21 16:37:59 +0200 (Sat, 21 May 2011)
New Revision: 3011

Modified:
   trunk/src/CacheWolf/HintLogPanel.java
Log:
Dead code eliminated

Modified: trunk/src/CacheWolf/HintLogPanel.java
===================================================================
--- trunk/src/CacheWolf/HintLogPanel.java	2011-05-21 14:12:33 UTC (rev 3010)
+++ trunk/src/CacheWolf/HintLogPanel.java	2011-05-21 14:37:59 UTC (rev 3011)
@@ -289,7 +289,7 @@
 			if (dx != 0 || dy != 0) scroll(dx,dy);
 			refresh();
 			return true;
-		}else if (true || where.x < origin.x || where.x >= origin.x+r.width || where.y < origin.y || where.y >= origin.y+r.height){
+		}else if (true/* || where.x < origin.x || where.x >= origin.x+r.width || where.y < origin.y || where.y >= origin.y+r.height*/){
 	 			if (autoScrolling) {
 					didAutoScroll = true;
 					scroll(-to.x,-to.y);



From apreisser at mail.berlios.de  Sat May 21 04:43:05 2011
From: apreisser at mail.berlios.de (apreisser at mail.berlios.de)
Date: Sat, 21 May 2011 04:43:05 PM +0200
Subject: [Cachewolf-svn] r3012 - in trunk/src/CacheWolf: . model view
	view/ewe view/pda
Message-ID: <20110521144305.E15484813F8@sheep.berlios.de>

Author: apreisser
Date: 2011-05-21 16:43:05 +0200 (Sat, 21 May 2011)
New Revision: 3012

Added:
   trunk/src/CacheWolf/model/AbstractListModel.java
   trunk/src/CacheWolf/model/TravelBugJourneyScreenModel.java
   trunk/src/CacheWolf/model/TravelbugScreenModel.java
   trunk/src/CacheWolf/view/ITravelbugScreen.java
   trunk/src/CacheWolf/view/TravelBugScreenFactory.java
   trunk/src/CacheWolf/view/pda/PDAList.java
   trunk/src/CacheWolf/view/pda/PDATravelbugScreen.java
Removed:
   trunk/src/CacheWolf/model/TravelBugScreenModel.java
Modified:
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/TravelbugPickup.java
   trunk/src/CacheWolf/TravelbugScreen.java
   trunk/src/CacheWolf/view/TravelbugJourneyScreenFactory.java
   trunk/src/CacheWolf/view/ewe/TravelbugJourneyScreen.java
   trunk/src/CacheWolf/view/ewe/TravelbugMenu.java
   trunk/src/CacheWolf/view/pda/PDAListButton.java
   trunk/src/CacheWolf/view/pda/PDATravelbugDetailPanel.java
Log:
Picking up TBs becomes more finger-friendly when called from the TravelBugJourneyScreen.

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2011-05-21 14:37:59 UTC (rev 3011)
+++ trunk/src/CacheWolf/DetailsPanel.java	2011-05-21 14:43:05 UTC (rev 3012)
@@ -958,14 +958,12 @@
 					tbjList = new TravelbugJourneyList();
 					tbjList.readTravelbugsFile();
 					TravelbugList tbl = tbjList.getMyTravelbugs();
-					TravelbugScreen tbs = new TravelbugScreen(tbl, MyLocale
-							.getMsg(6017, "Drop a travelbug"), false);
+					TravelbugScreen tbs = new TravelbugScreen(tbl, MyLocale.getMsg(6017, "Drop a travelbug"), false);
 					tbs.execute();
 					if (tbs.selectedItem >= 0) {
 						Travelbug tb = tbl.getTB(tbs.selectedItem);
 						cache.getCacheDetails(true).Travelbugs.add(tb);
-						tbjList.addTbDrop(tb, Global.getProfile().name,
-								cache.getWayPoint());
+						tbjList.addTbDrop(tb, Global.getProfile().name, cache.getWayPoint());
 					}
 					tbjList.saveTravelbugsFile();
 					cache.setHas_bugs(cache.getCacheDetails(true).Travelbugs.size() > 0);

Modified: trunk/src/CacheWolf/TravelbugPickup.java
===================================================================
--- trunk/src/CacheWolf/TravelbugPickup.java	2011-05-21 14:37:59 UTC (rev 3011)
+++ trunk/src/CacheWolf/TravelbugPickup.java	2011-05-21 14:43:05 UTC (rev 3012)
@@ -1,59 +1,66 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
+import CacheWolf.view.ITravelbugScreen;
+import CacheWolf.view.TravelBugScreenFactory;
 import ewe.ui.InputBox;
 
 public class TravelbugPickup {
 
 	/**
-	 * Choose a travelbug from those listed in the travelbug list and delete it, if
-	 * the operation was not cancelled.
-	 * @param tbl List of travelbugs from where a bug is picked up
+	 * Choose a travelbug from those listed in the travelbug list and delete it,
+	 * if the operation was not cancelled.
+	 * 
+	 * @param tbl
+	 *            List of travelbugs from where a bug is picked up
 	 */
 	public static Travelbug pickupTravelbug(TravelbugList tbl) {
-		Travelbug tb=null;
-		TravelbugScreen tbs=new TravelbugScreen(tbl,MyLocale.getMsg(6016,"Pick up travelbug"),true);
+		Travelbug tb = null;
+		// TravelbugScreen tbs=new TravelbugScreen(tbl,MyLocale.getMsg(6016,"Pick up travelbug"),true);
+		ITravelbugScreen tbs = TravelBugScreenFactory.createTravelbugScreen(tbl, MyLocale.getMsg(6016, "Pick up travelbug"), true);
 		tbs.execute(); // Select TB to pick up
-		if (tbs.selectedItem>=0) { // Was a TB selected ?
+		if (tbs.getSelectedItem() >= 0) { // Was a TB selected ?
 			// If the returned item is bigger than number of bugs in cache
-			// we have found a new unlisted bug. 
-			if (tbs.selectedItem==tbl.size()) {
-				InputBox ibox=new InputBox(MyLocale.getMsg(6018,"Travelbug name"));
-				String name=ibox.input("",240);
-				if (name==null) return null; // No name given
-				tb=new Travelbug(name);
+			// we have found a new unlisted bug.
+			if (tbs.getSelectedItem() == tbl.size()) {
+				InputBox ibox = new InputBox(MyLocale.getMsg(6018, "Travelbug name"));
+				String name = ibox.input("", 240);
+				if (name == null)
+					return null; // No name given
+				tb = new Travelbug(name);
 			} else { // A bug in the list was chosen
-				tb=tbl.getTB(tbs.selectedItem);
+				tb = tbl.getTB(tbs.getSelectedItem());
 				// Remove the tb from the list
-				tbl.remove(tbs.selectedItem);
+				tbl.remove(tbs.getSelectedItem());
 			}
-			InputBox ibox=new InputBox(MyLocale.getMsg(6019,"Tracking number"));
-			String trackingNo=ibox.input("",240);
-			if (trackingNo==null) trackingNo="";
+			InputBox ibox = new InputBox(MyLocale.getMsg(6019, "Tracking number"));
+			String trackingNo = ibox.input("", 240);
+			if (trackingNo == null)
+				trackingNo = "";
 			tb.setTrackingNo(trackingNo);
 		}
 		return tb;

Modified: trunk/src/CacheWolf/TravelbugScreen.java
===================================================================
--- trunk/src/CacheWolf/TravelbugScreen.java	2011-05-21 14:37:59 UTC (rev 3011)
+++ trunk/src/CacheWolf/TravelbugScreen.java	2011-05-21 14:43:05 UTC (rev 3012)
@@ -25,6 +25,7 @@
     */
 package CacheWolf;
 
+import CacheWolf.view.ITravelbugScreen;
 import ewe.ui.CellConstants;
 import ewe.ui.ControlEvent;
 import ewe.ui.Event;
@@ -40,19 +41,23 @@
  * Choose a travelbug to pick up or drop
  * @author salzkammergut
  */ 
-public class TravelbugScreen extends Form {
+public class TravelbugScreen extends Form implements ITravelbugScreen {
 	private myList disp;
 	private mButton btCancel,btAccept;
 	/** The index into the list of travelbugs indicating the selected bug */
 	public int selectedItem=-1;
 	
+	public int getSelectedItem() {
+		return selectedItem;
+	}
+
 	/**
 	 * A screen to choose a travelbug from a list of bugs
 	 * @param tbl The list of travelbugs from which to choose
 	 * @param title The title of the screen
 	 * @param allowNew True if a travelbug not on the list can be selected
 	 */
-	TravelbugScreen(TravelbugList tbl, String title,boolean allowNew) {
+	public TravelbugScreen(TravelbugList tbl, String title,boolean allowNew) {
 		this.setTitle(title);
 		this.setPreferredSize(240, -1);
 		disp=new myList(tbl,allowNew);
@@ -104,7 +109,4 @@
 				return SafeXML.cleanback(tbl.getTB(idx).getName());
 		}
 	}
-
-
-
 }

Added: trunk/src/CacheWolf/model/AbstractListModel.java
===================================================================
--- trunk/src/CacheWolf/model/AbstractListModel.java	                        (rev 0)
+++ trunk/src/CacheWolf/model/AbstractListModel.java	2011-05-21 14:43:05 UTC (rev 3012)
@@ -0,0 +1,47 @@
+package CacheWolf.model;
+
+import ewe.util.Vector;
+
+public abstract class AbstractListModel {
+
+	public Vector allItems;
+
+	public Vector shownItems = new Vector ();
+	public int sortCriteria;
+
+	public AbstractListModel() {
+		super();
+	}
+
+	/**
+	 * Creates the list of objects to be shown in the List. With this methode You can hide some objects.
+	 * Standardimplementation is to show all objects anytime. 
+	 *  
+	 */
+	public void createShowSet(){
+		shownItems.clear();
+		shownItems.addAll(allItems);
+	}
+	
+	/**
+	 * Adds an Object to this model to last position.
+	 * @param o
+	 */
+	public void add (Object o){
+		allItems.add(o);
+	}
+	
+	/**
+	 * Returns the number of elements in the showset of this model
+	 */
+	public int size(){
+		return shownItems.size();
+	}
+	
+	/**
+	 * Returns the Nth item in the showset of this model
+	 */
+	public Object get(int n){
+		return shownItems.get(n);
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/CacheWolf/model/AbstractListModel.java
___________________________________________________________________
Added: svn:mime-type
   + text/plain

Copied: trunk/src/CacheWolf/model/TravelBugJourneyScreenModel.java (from rev 2988, trunk/src/CacheWolf/model/TravelBugScreenModel.java)
===================================================================
--- trunk/src/CacheWolf/model/TravelBugJourneyScreenModel.java	                        (rev 0)
+++ trunk/src/CacheWolf/model/TravelBugJourneyScreenModel.java	2011-05-21 14:43:05 UTC (rev 3012)
@@ -0,0 +1,33 @@
+package CacheWolf.model;
+
+import CacheWolf.CacheHolder;
+import CacheWolf.Global;
+import CacheWolf.TravelbugJourney;
+import CacheWolf.TravelbugJourneyList;
+import ewe.util.Vector;
+
+public class TravelBugJourneyScreenModel {
+
+	public CacheHolder actualCache;
+	public TravelbugJourneyList allTravelbugJourneys;
+	public Vector shownTravelbugJourneys = new Vector ();
+	public boolean onlyLogged;
+	public int sortCriteria;
+
+	public void toggleOnlyLogged() {
+		onlyLogged = !onlyLogged;
+		createShowSet();
+		Global.getPref().travelbugShowOnlyNonLogged = onlyLogged;
+		Global.getPref().savePreferences();
+	}
+
+	public void createShowSet() {
+		shownTravelbugJourneys.clear();
+		for (int i = 0; i < allTravelbugJourneys.size(); i++) {
+			TravelbugJourney tbJourney = allTravelbugJourneys.getTBJourney(i);
+			if (!onlyLogged || (onlyLogged && (!tbJourney.getFromLogged() || !tbJourney.getToLogged()))) {
+				shownTravelbugJourneys.add(tbJourney);
+			}
+		}
+	}
+}


Property changes on: trunk/src/CacheWolf/model/TravelBugJourneyScreenModel.java
___________________________________________________________________
Added: svn:mime-type
   + text/plain

Deleted: trunk/src/CacheWolf/model/TravelBugScreenModel.java
===================================================================
--- trunk/src/CacheWolf/model/TravelBugScreenModel.java	2011-05-21 14:37:59 UTC (rev 3011)
+++ trunk/src/CacheWolf/model/TravelBugScreenModel.java	2011-05-21 14:43:05 UTC (rev 3012)
@@ -1,33 +0,0 @@
-package CacheWolf.model;
-
-import CacheWolf.CacheHolder;
-import CacheWolf.Global;
-import CacheWolf.TravelbugJourney;
-import CacheWolf.TravelbugJourneyList;
-import ewe.util.Vector;
-
-public class TravelBugScreenModel {
-
-	public CacheHolder actualCache;
-	public TravelbugJourneyList allTravelbugJourneys;
-	public Vector shownTravelbugJourneys = new Vector ();
-	public boolean onlyLogged;
-	public int sortCriteria;
-
-	public void toggleOnlyLogged() {
-		onlyLogged = !onlyLogged;
-		createShowSet();
-		Global.getPref().travelbugShowOnlyNonLogged = onlyLogged;
-		Global.getPref().savePreferences();
-	}
-
-	public void createShowSet() {
-		shownTravelbugJourneys.clear();
-		for (int i = 0; i < allTravelbugJourneys.size(); i++) {
-			TravelbugJourney tbJourney = allTravelbugJourneys.getTBJourney(i);
-			if (!onlyLogged || (onlyLogged && (!tbJourney.getFromLogged() || !tbJourney.getToLogged()))) {
-				shownTravelbugJourneys.add(tbJourney);
-			}
-		}
-	}
-}

Added: trunk/src/CacheWolf/model/TravelbugScreenModel.java
===================================================================
--- trunk/src/CacheWolf/model/TravelbugScreenModel.java	                        (rev 0)
+++ trunk/src/CacheWolf/model/TravelbugScreenModel.java	2011-05-21 14:43:05 UTC (rev 3012)
@@ -0,0 +1,8 @@
+package CacheWolf.model;
+
+public class TravelbugScreenModel extends AbstractListModel {
+
+	public void createShowSet() {
+	}
+
+}


Property changes on: trunk/src/CacheWolf/model/TravelbugScreenModel.java
___________________________________________________________________
Added: svn:mime-type
   + text/plain

Added: trunk/src/CacheWolf/view/ITravelbugScreen.java
===================================================================
--- trunk/src/CacheWolf/view/ITravelbugScreen.java	                        (rev 0)
+++ trunk/src/CacheWolf/view/ITravelbugScreen.java	2011-05-21 14:43:05 UTC (rev 3012)
@@ -0,0 +1,17 @@
+package CacheWolf.view;
+
+public interface ITravelbugScreen {
+
+	/**
+	 * Shows the form
+	 * @return
+	 */
+	int execute();
+
+	/**
+	 * Returns the selected entry if any else <code>null</code>
+	 * @return
+	 */
+	int getSelectedItem();
+
+}
\ No newline at end of file


Property changes on: trunk/src/CacheWolf/view/ITravelbugScreen.java
___________________________________________________________________
Added: svn:mime-type
   + text/plain

Added: trunk/src/CacheWolf/view/TravelBugScreenFactory.java
===================================================================
--- trunk/src/CacheWolf/view/TravelBugScreenFactory.java	                        (rev 0)
+++ trunk/src/CacheWolf/view/TravelBugScreenFactory.java	2011-05-21 14:43:05 UTC (rev 3012)
@@ -0,0 +1,65 @@
+package CacheWolf.view;
+
+import java.lang.reflect.Constructor;
+
+import CacheWolf.Global;
+import CacheWolf.TravelbugList;
+import CacheWolf.TravelbugScreen;
+import CacheWolf.view.ewe.TravelbugJourneyScreen;
+import CacheWolf.view.pda.PDATravelbugScreen;
+import ewe.reflect.Reflect;
+import ewe.sys.Vm;
+
+public class TravelBugScreenFactory {
+
+	/**
+	 * Variante fuer Desktop unter Java???
+	 */
+	private static boolean isSwing;
+	static {
+		Global.getPref().log("Static initializer start ");
+		Class swingClass = null;
+		try {
+			swingClass = TravelbugJourneyScreen.class.getClassLoader().loadClass("javax.swing.JTable");
+		} catch (Exception e) {
+			Global.getPref().log("Swing not found");
+			Global.getPref().log(e.toString());
+			// ignore!
+		}
+		isSwing = swingClass != null && false;
+	}
+
+	/**
+	 * Variante fuer Android-PDA
+	 */
+	private static final boolean isAndroid = false;
+
+	public static ITravelbugScreen createTravelbugScreen(TravelbugList tbl, String title, boolean allowNew) {
+		Global.getPref().log("Mobile-Device: " + Vm.isMobile());
+		Global.getPref().log("Preference for Mobile-Device: " + Global.getPref().mobileGUI);
+		if (Vm.isMobile() && Global.getPref().mobileGUI) {
+			try {
+				Class loadClass = Reflect.getForName("CacheWolf.view.pda.PDATravelbugScreen").getReflectedClass();
+				Constructor constructor = loadClass.getConstructor(new Class[] { TravelbugList.class, String.class, boolean.class });
+				ITravelbugScreen result = (ITravelbugScreen) constructor.newInstance(new Object[] { tbl, title, allowNew });
+				Global.getPref().log("TBScreen successfully instantiated");
+				return result;
+			} catch (Throwable e) {
+				Global.getPref().log("CacheWolf.view.pda.PDATravelbugScreen not found");
+				Global.getPref().log("Error in instantiating TravelBugScreen", e, true);
+				e.printStackTrace();
+				// ignore?? VM on WinPC seems to have no classloader
+				return new PDATravelbugScreen(tbl, title, allowNew);
+			}
+		} else if (isSwing) {
+			throw new InstantiationError("No Swing GUI available");
+			// return new TravelbugJourneyScreen(model);
+		} else if (isAndroid) {
+			throw new InstantiationError("No Android GUI available");
+			// return new TravelbugJourneyScreen(model);
+		} else {
+			return new TravelbugScreen(tbl, title, allowNew);
+		}
+	}
+
+}


Property changes on: trunk/src/CacheWolf/view/TravelBugScreenFactory.java
___________________________________________________________________
Added: svn:mime-type
   + text/plain

Modified: trunk/src/CacheWolf/view/TravelbugJourneyScreenFactory.java
===================================================================
--- trunk/src/CacheWolf/view/TravelbugJourneyScreenFactory.java	2011-05-21 14:37:59 UTC (rev 3011)
+++ trunk/src/CacheWolf/view/TravelbugJourneyScreenFactory.java	2011-05-21 14:43:05 UTC (rev 3012)
@@ -6,7 +6,7 @@
 import CacheWolf.CacheHolder;
 import CacheWolf.Global;
 import CacheWolf.TravelbugJourneyList;
-import CacheWolf.model.TravelBugScreenModel;
+import CacheWolf.model.TravelBugJourneyScreenModel;
 import CacheWolf.view.ewe.TravelbugJourneyScreen;
 import CacheWolf.view.pda.PDATravelbugJourneyScreen;
 import ewe.reflect.Reflect;
@@ -30,6 +30,7 @@
 			//ignore!
 		}
 		isSwing = swingClass!=null;
+		isSwing = false;
 	}
 
 	/**
@@ -38,7 +39,7 @@
 	private static final boolean isAndroid = false;
 
 	public static Form createTravelbugJourneyScreen() {
-		TravelBugScreenModel model = new TravelBugScreenModel();
+		TravelBugJourneyScreenModel model = new TravelBugJourneyScreenModel();
 		model.onlyLogged = Global.getPref().travelbugShowOnlyNonLogged;
 		int curCacheNo = Global.mainTab.tbP.getSelectedCache();
 		CacheDB cacheDB = Global.getProfile().cacheDB;
@@ -65,7 +66,7 @@
 				//ignore?? VM on WinPC seems to have no classloader
 				return new PDATravelbugJourneyScreen(model);
 			}
-		} else if (isSwing) {
+		} else if ( isSwing) {
 			throw new InstantiationError ("No Swing GUI available");
 		} else if (isAndroid) {
 			throw new InstantiationError ("No Android GUI available");

Modified: trunk/src/CacheWolf/view/ewe/TravelbugJourneyScreen.java
===================================================================
--- trunk/src/CacheWolf/view/ewe/TravelbugJourneyScreen.java	2011-05-21 14:37:59 UTC (rev 3011)
+++ trunk/src/CacheWolf/view/ewe/TravelbugJourneyScreen.java	2011-05-21 14:43:05 UTC (rev 3012)
@@ -49,7 +49,7 @@
 import CacheWolf.TravelbugList;
 import CacheWolf.TravelbugPickup;
 import CacheWolf.imp.SpiderGC;
-import CacheWolf.model.TravelBugScreenModel;
+import CacheWolf.model.TravelBugJourneyScreenModel;
 import CacheWolf.utils.CWWrapper;
 import ewe.fx.Color;
 import ewe.fx.Dimension;
@@ -123,7 +123,7 @@
 	// =========== CONTROLLER
 	public TravelbugMenu mnuTBMenu;
 	// ========== MODEL
-	public TravelBugScreenModel model;
+	public TravelBugJourneyScreenModel model;
 
 	/**
 	 * A flag to track whether the current cache has to be saved because a
@@ -148,7 +148,7 @@
 	// Set to Public to implement MVC-Pattern [AP]
 	public String waypoint = "";
 
-	public TravelbugJourneyScreen(TravelBugScreenModel newModel) {
+	public TravelbugJourneyScreen(TravelBugJourneyScreenModel newModel) {
 		model = newModel;
 		CacheDB cacheDB = Global.getProfile().cacheDB;
 		SplittablePanel split = new SplittablePanel(PanelSplitter.VERTICAL);
@@ -555,9 +555,9 @@
 		private MenuItem mnuNewTB, mnuDeleteTB, mnuGetMission, mnuOpenOnline, mnuDropTB, mnuPickupTB, mnuDeleteTBs;
 		public MenuItem mnuToggleList;
 		private Menu mnuFullMenu, mnuDeleteMenu;
-		private TravelBugScreenModel tbModel;
+		private TravelBugJourneyScreenModel tbModel;
 
-		tbListControl(TravelBugScreenModel tbModel) {
+		tbListControl(TravelBugJourneyScreenModel tbModel) {
 			this.tbModel = tbModel;
 			MenuItem[] TBMenuItems = new MenuItem[10];
 			TBMenuItems[0] = mnuPickupTB = new MenuItem(MyLocale.getMsg(6040, "Pick up TB from current cache"));

Modified: trunk/src/CacheWolf/view/ewe/TravelbugMenu.java
===================================================================
--- trunk/src/CacheWolf/view/ewe/TravelbugMenu.java	2011-05-21 14:37:59 UTC (rev 3011)
+++ trunk/src/CacheWolf/view/ewe/TravelbugMenu.java	2011-05-21 14:43:05 UTC (rev 3012)
@@ -7,7 +7,8 @@
 import CacheWolf.TravelbugList;
 import CacheWolf.TravelbugPickup;
 import CacheWolf.imp.SpiderGC;
-import CacheWolf.model.TravelBugScreenModel;
+import CacheWolf.model.AbstractListModel;
+import CacheWolf.model.TravelBugJourneyScreenModel;
 import CacheWolf.utils.CWWrapper;
 import ewe.fx.Rect;
 import ewe.sys.Vm;
@@ -40,9 +41,9 @@
 	 * The View displaying the model for this
 	 */
 	public TravelbugJourneyScreen view;
-	private TravelBugScreenModel model;
+	private TravelBugJourneyScreenModel model;
 
-	public TravelbugMenu(TravelBugScreenModel model) {
+	public TravelbugMenu(TravelBugJourneyScreenModel model) {
 		this.model = model;
 		MenuItem[] TBMenuItems = new MenuItem[9];
 		TBMenuItems[0] = mnuPickupTB = new MenuItem(MyLocale.getMsg(6040, "Pick up TB from current cache"));

Added: trunk/src/CacheWolf/view/pda/PDAList.java
===================================================================
--- trunk/src/CacheWolf/view/pda/PDAList.java	                        (rev 0)
+++ trunk/src/CacheWolf/view/pda/PDAList.java	2011-05-21 14:43:05 UTC (rev 3012)
@@ -0,0 +1,87 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.MyLocale;
+import ewe.sys.Vm;
+import ewe.ui.CellConstants;
+import ewe.ui.ControlEvent;
+import ewe.ui.Form;
+import ewe.util.Vector;
+
+public abstract class PDAList extends Form {
+	protected static final String LINE = "Line";
+
+	protected static final String NEXT_PAGE = "NextPage";
+
+	protected static final String PREV_PAGE = "PrevPage";
+
+	protected static final String MENUE = "Menue";
+
+	public Vector model;
+	private int linesOnScreen=7;
+	PDAListButton[] listButtons;
+	protected int firstLine;
+
+	public PDAList() {
+		listButtons = new PDAListButton[linesOnScreen];
+		//Show Full Screen
+		setPreferredSize(MyLocale.getScreenWidth(), MyLocale.getScreenHeight());
+		addListener(this);
+		setTitle("Liste");
+
+		firstLine = 0;
+		for (int i = 0; i < linesOnScreen; i++) {
+			listButtons[i] = new PDAListButton("", LINE + i);
+			addLast(listButtons[i], CellConstants.STRETCH, CellConstants.FILL);
+		}
+		model = new Vector();
+		setupTBButtons();
+		PDAMenuButton b1 = new PDAMenuButton("<<<", PREV_PAGE);
+		addNext(b1, CellConstants.HSTRETCH, CellConstants.HFILL);
+		b1 = new PDAMenuButton(MyLocale.getMsg(6052, "MENU"), MENUE);
+		b1.anchor = 0;
+		addNext(b1, CellConstants.HSTRETCH, CellConstants.HFILL);
+		b1 = new PDAMenuButton(">>>", NEXT_PAGE);
+		b1.anchor = CellConstants.EAST;
+		addLast(b1, CellConstants.HSTRETCH, CellConstants.HFILL);
+	}
+
+	public void onControlEvent(ControlEvent ev) {
+		if (ev instanceof ControlEvent) {
+			switch (ev.type) {
+			case ControlEvent.PRESSED:
+				if (ev.action.equals(NEXT_PAGE) && model.size() > firstLine + linesOnScreen) {
+					firstLine += linesOnScreen;
+					setupTBButtons();
+				} else if (ev.action.equals(PREV_PAGE) && firstLine > 0) {
+					firstLine -= linesOnScreen;
+					if (firstLine < 0) {
+						firstLine = 0;
+					}
+					setupTBButtons();
+				} else if (ev.action.startsWith(LINE)) {
+					int line = ev.action.charAt(LINE.length()) - '0';
+					Object clickedItem =  model.get(line + firstLine);
+					Vm.debug("List clicked: " + clickedItem);
+				} else if (ev.action.equals(MENUE)) {
+					setupTBButtons();
+				}
+				break;
+			default:
+				super.onControlEvent(ev);
+			}
+		}
+	}
+
+	public void setupTBButtons() {
+		for (int i = 0; i < linesOnScreen; i++) {
+			if (i + firstLine < model.size()) {
+				Object modelElement = model.get(i + firstLine);
+				listButtons[i].text = modelElement.toString();
+			} else {
+				listButtons[i].text = listButtons[i].fromText = listButtons[i].toText = "";
+			}
+			listButtons[i].repaint();
+		}
+	}
+
+}


Property changes on: trunk/src/CacheWolf/view/pda/PDAList.java
___________________________________________________________________
Added: svn:mime-type
   + text/plain

Modified: trunk/src/CacheWolf/view/pda/PDAListButton.java
===================================================================
--- trunk/src/CacheWolf/view/pda/PDAListButton.java	2011-05-21 14:37:59 UTC (rev 3011)
+++ trunk/src/CacheWolf/view/pda/PDAListButton.java	2011-05-21 14:43:05 UTC (rev 3012)
@@ -31,12 +31,4 @@
 		this.buttonObject = new PDAListButtonObject(this);
 	}
 	
-//	public Dimension getPreferredSize(Dimension paramDimension) {
-//		Dimension size = super.getPreferredSize(paramDimension);
-//		FontMetrics fm = new FontMetrics(font, getWindow());
-//		size.height = (int)(fm.getHeight()*2.5);
-//		size.width=fm.getTextWidth(text);
-//		return size;
-//	}
-
 }

Modified: trunk/src/CacheWolf/view/pda/PDATravelbugDetailPanel.java
===================================================================
--- trunk/src/CacheWolf/view/pda/PDATravelbugDetailPanel.java	2011-05-21 14:37:59 UTC (rev 3011)
+++ trunk/src/CacheWolf/view/pda/PDATravelbugDetailPanel.java	2011-05-21 14:43:05 UTC (rev 3012)
@@ -27,6 +27,8 @@
 
 public class PDATravelbugDetailPanel extends Form {
 
+	private static final int BOXWIDTH = 40;
+
 	private static final String MENUE = "MENUE";
 
 	private static final String BACK = "back";
@@ -169,6 +171,8 @@
 
 		panel.addNext(new mLabel(MyLocale.getMsg(6031, "Logged:")), DONTSTRETCH, DONTFILL | WEST);
 		chkFromLogged = new mCheckBox("");
+		chkFromLogged.boxWidth = BOXWIDTH;
+		chkFromLogged.font = tmpFont;
 		chkFromLogged.setState(tbJourney.getFromLogged());
 		panel.addLast(chkFromLogged, DONTSTRETCH, DONTFILL | WEST);
 		chkFromLogged.exitKeys = exitKeys;
@@ -192,6 +196,7 @@
 
 		panel.addNext(new mLabel(MyLocale.getMsg(6031, "Logged:")), DONTSTRETCH, DONTFILL | WEST);
 		chkToLogged = new mCheckBox("");
+		chkToLogged.boxWidth = BOXWIDTH;
 		chkToLogged.setState(tbJourney.getToLogged());
 		panel.addLast(chkToLogged, DONTSTRETCH, DONTFILL | WEST);
 		chkToLogged.exitKeys = exitKeys;

Added: trunk/src/CacheWolf/view/pda/PDATravelbugScreen.java
===================================================================
--- trunk/src/CacheWolf/view/pda/PDATravelbugScreen.java	                        (rev 0)
+++ trunk/src/CacheWolf/view/pda/PDATravelbugScreen.java	2011-05-21 14:43:05 UTC (rev 3012)
@@ -0,0 +1,67 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.MyLocale;
+import CacheWolf.Travelbug;
+import CacheWolf.TravelbugList;
+import CacheWolf.view.ITravelbugScreen;
+import ewe.ui.ControlEvent;
+import ewe.util.Vector;
+
+public class PDATravelbugScreen extends PDAList implements ITravelbugScreen{
+
+	/** The index into the list of travelbugs indicating the selected bug */
+	public int selectedItem=-1;
+	
+	/**
+	 * A screen to choose a travelbug from a list of bugs
+	 * @param tbl The list of travelbugs from which to choose
+	 * @param title The title of the screen
+	 * @param allowNew True if a travelbug not on the list can be selected
+	 */
+	public PDATravelbugScreen(TravelbugList tbl, String title, boolean allowNew) {
+		super();
+		model = new Vector();
+		for (int i=0;i < tbl.size();i++){
+			Travelbug tb = tbl.getTB(i);
+			model.add(tb.getName());
+		}
+		if (allowNew){
+			model.add(MyLocale.getMsg(6015,"*** OTHER ***"));
+		}
+		setupTBButtons();
+}
+
+	public void onControlEvent(ControlEvent ev) {
+		if (ev instanceof ControlEvent) {
+			switch (ev.type) {
+			case ControlEvent.PRESSED:
+				if (ev.action.equals(NEXT_PAGE) ||(ev.action.equals(PREV_PAGE))) {
+					super.onControlEvent(ev);	
+				} else if (ev.action.startsWith(LINE)) {
+					selectedItem = ev.action.charAt(LINE.length()) - '0';
+//					Object clickedItem =  model.get(line + firstLine);
+//					Form form = new PDATravelbugDetailPanel(tbJourney, this);
+//					form.setPreferredSize(800, 600);
+//					form.execute();
+//					setupTBButtons();
+					exit(0);
+				} else if (ev.action.equals(MENUE)) {
+//					Form form = new PDATravelbugMenuPanel(this);
+//					form.setPreferredSize(800, 600);
+//					int execute = form.execute();
+//					if (execute == 1){
+//						exit(0);
+//					}
+					setupTBButtons();
+				}
+				break;
+			default:
+				super.onControlEvent(ev);
+			}
+		}
+	}
+
+	public int getSelectedItem() {
+		return selectedItem;
+	}
+}


Property changes on: trunk/src/CacheWolf/view/pda/PDATravelbugScreen.java
___________________________________________________________________
Added: svn:mime-type
   + text/plain



From apreisser at mail.berlios.de  Sat May 21 04:52:38 2011
From: apreisser at mail.berlios.de (apreisser at mail.berlios.de)
Date: Sat, 21 May 2011 04:52:38 PM +0200
Subject: [Cachewolf-svn] r3013 - in trunk/src/CacheWolf: model view/ewe
	view/pda
Message-ID: <20110521145239.223FA4813F8@sheep.berlios.de>

Author: apreisser
Date: 2011-05-21 16:52:38 +0200 (Sat, 21 May 2011)
New Revision: 3013

Added:
   trunk/src/CacheWolf/model/DefaultListModel.java
Removed:
   trunk/src/CacheWolf/model/AbstractListModel.java
Modified:
   trunk/src/CacheWolf/model/TravelbugScreenModel.java
   trunk/src/CacheWolf/view/ewe/TravelbugMenu.java
   trunk/src/CacheWolf/view/pda/PDAList.java
   trunk/src/CacheWolf/view/pda/PDATravelbugScreen.java
Log:
Slighty modified the model for the TBPickUpScreen

Deleted: trunk/src/CacheWolf/model/AbstractListModel.java
===================================================================
--- trunk/src/CacheWolf/model/AbstractListModel.java	2011-05-21 14:43:05 UTC (rev 3012)
+++ trunk/src/CacheWolf/model/AbstractListModel.java	2011-05-21 14:52:38 UTC (rev 3013)
@@ -1,47 +0,0 @@
-package CacheWolf.model;
-
-import ewe.util.Vector;
-
-public abstract class AbstractListModel {
-
-	public Vector allItems;
-
-	public Vector shownItems = new Vector ();
-	public int sortCriteria;
-
-	public AbstractListModel() {
-		super();
-	}
-
-	/**
-	 * Creates the list of objects to be shown in the List. With this methode You can hide some objects.
-	 * Standardimplementation is to show all objects anytime. 
-	 *  
-	 */
-	public void createShowSet(){
-		shownItems.clear();
-		shownItems.addAll(allItems);
-	}
-	
-	/**
-	 * Adds an Object to this model to last position.
-	 * @param o
-	 */
-	public void add (Object o){
-		allItems.add(o);
-	}
-	
-	/**
-	 * Returns the number of elements in the showset of this model
-	 */
-	public int size(){
-		return shownItems.size();
-	}
-	
-	/**
-	 * Returns the Nth item in the showset of this model
-	 */
-	public Object get(int n){
-		return shownItems.get(n);
-	}
-}
\ No newline at end of file

Copied: trunk/src/CacheWolf/model/DefaultListModel.java (from rev 3012, trunk/src/CacheWolf/model/AbstractListModel.java)
===================================================================
--- trunk/src/CacheWolf/model/DefaultListModel.java	                        (rev 0)
+++ trunk/src/CacheWolf/model/DefaultListModel.java	2011-05-21 14:52:38 UTC (rev 3013)
@@ -0,0 +1,49 @@
+package CacheWolf.model;
+
+import ewe.util.Vector;
+
+public  class DefaultListModel {
+
+	public Vector allItems;
+
+	public Vector shownItems = new Vector ();
+	public int sortCriteria;
+
+	public DefaultListModel() {
+		super();
+		allItems = new Vector ();
+		shownItems = new Vector();
+	}
+
+	/**
+	 * Creates the list of objects to be shown in the List. With this methode You can hide some objects.
+	 * Standardimplementation is to show all objects anytime. 
+	 *  
+	 */
+	public void createShowSet(){
+		shownItems.clear();
+		shownItems.addAll(allItems);
+	}
+	
+	/**
+	 * Adds an Object to this model to last position.
+	 * @param o
+	 */
+	public void add (Object o){
+		allItems.add(o);
+	}
+	
+	/**
+	 * Returns the number of elements in the showset of this model
+	 */
+	public int size(){
+		return shownItems.size();
+	}
+	
+	/**
+	 * Returns the Nth item in the showset of this model
+	 */
+	public Object get(int n){
+		return shownItems.get(n);
+	}
+}
\ No newline at end of file


Property changes on: trunk/src/CacheWolf/model/DefaultListModel.java
___________________________________________________________________
Added: svn:mime-type
   + text/plain

Modified: trunk/src/CacheWolf/model/TravelbugScreenModel.java
===================================================================
--- trunk/src/CacheWolf/model/TravelbugScreenModel.java	2011-05-21 14:43:05 UTC (rev 3012)
+++ trunk/src/CacheWolf/model/TravelbugScreenModel.java	2011-05-21 14:52:38 UTC (rev 3013)
@@ -1,6 +1,6 @@
 package CacheWolf.model;
 
-public class TravelbugScreenModel extends AbstractListModel {
+public class TravelbugScreenModel extends DefaultListModel {
 
 	public void createShowSet() {
 	}

Modified: trunk/src/CacheWolf/view/ewe/TravelbugMenu.java
===================================================================
--- trunk/src/CacheWolf/view/ewe/TravelbugMenu.java	2011-05-21 14:43:05 UTC (rev 3012)
+++ trunk/src/CacheWolf/view/ewe/TravelbugMenu.java	2011-05-21 14:52:38 UTC (rev 3013)
@@ -7,7 +7,7 @@
 import CacheWolf.TravelbugList;
 import CacheWolf.TravelbugPickup;
 import CacheWolf.imp.SpiderGC;
-import CacheWolf.model.AbstractListModel;
+import CacheWolf.model.DefaultListModel;
 import CacheWolf.model.TravelBugJourneyScreenModel;
 import CacheWolf.utils.CWWrapper;
 import ewe.fx.Rect;

Modified: trunk/src/CacheWolf/view/pda/PDAList.java
===================================================================
--- trunk/src/CacheWolf/view/pda/PDAList.java	2011-05-21 14:43:05 UTC (rev 3012)
+++ trunk/src/CacheWolf/view/pda/PDAList.java	2011-05-21 14:52:38 UTC (rev 3013)
@@ -1,6 +1,7 @@
 package CacheWolf.view.pda;
 
 import CacheWolf.MyLocale;
+import CacheWolf.model.DefaultListModel;
 import ewe.sys.Vm;
 import ewe.ui.CellConstants;
 import ewe.ui.ControlEvent;
@@ -16,7 +17,7 @@
 
 	protected static final String MENUE = "Menue";
 
-	public Vector model;
+	public DefaultListModel model;
 	private int linesOnScreen=7;
 	PDAListButton[] listButtons;
 	protected int firstLine;
@@ -33,7 +34,6 @@
 			listButtons[i] = new PDAListButton("", LINE + i);
 			addLast(listButtons[i], CellConstants.STRETCH, CellConstants.FILL);
 		}
-		model = new Vector();
 		setupTBButtons();
 		PDAMenuButton b1 = new PDAMenuButton("<<<", PREV_PAGE);
 		addNext(b1, CellConstants.HSTRETCH, CellConstants.HFILL);
@@ -74,7 +74,7 @@
 
 	public void setupTBButtons() {
 		for (int i = 0; i < linesOnScreen; i++) {
-			if (i + firstLine < model.size()) {
+			if (model != null && i + firstLine < model.size()) {
 				Object modelElement = model.get(i + firstLine);
 				listButtons[i].text = modelElement.toString();
 			} else {

Modified: trunk/src/CacheWolf/view/pda/PDATravelbugScreen.java
===================================================================
--- trunk/src/CacheWolf/view/pda/PDATravelbugScreen.java	2011-05-21 14:43:05 UTC (rev 3012)
+++ trunk/src/CacheWolf/view/pda/PDATravelbugScreen.java	2011-05-21 14:52:38 UTC (rev 3013)
@@ -3,9 +3,9 @@
 import CacheWolf.MyLocale;
 import CacheWolf.Travelbug;
 import CacheWolf.TravelbugList;
+import CacheWolf.model.DefaultListModel;
 import CacheWolf.view.ITravelbugScreen;
 import ewe.ui.ControlEvent;
-import ewe.util.Vector;
 
 public class PDATravelbugScreen extends PDAList implements ITravelbugScreen{
 
@@ -20,7 +20,7 @@
 	 */
 	public PDATravelbugScreen(TravelbugList tbl, String title, boolean allowNew) {
 		super();
-		model = new Vector();
+		model = new DefaultListModel();
 		for (int i=0;i < tbl.size();i++){
 			Travelbug tb = tbl.getTB(i);
 			model.add(tb.getName());
@@ -28,6 +28,7 @@
 		if (allowNew){
 			model.add(MyLocale.getMsg(6015,"*** OTHER ***"));
 		}
+		model.createShowSet();
 		setupTBButtons();
 }
 



From apreisser at mail.berlios.de  Sat May 21 04:52:52 2011
From: apreisser at mail.berlios.de (apreisser at mail.berlios.de)
Date: Sat, 21 May 2011 04:52:52 PM +0200
Subject: [Cachewolf-svn] r3014 - trunk/src/CacheWolf/imp
Message-ID: <20110521145252.BABE54813F8@sheep.berlios.de>

Author: apreisser
Date: 2011-05-21 16:52:52 +0200 (Sat, 21 May 2011)
New Revision: 3014

Modified:
   trunk/src/CacheWolf/imp/SpiderGC.java
Log:
Dead code eliminated

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-21 14:52:38 UTC (rev 3013)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-21 14:52:52 UTC (rev 3014)
@@ -1720,12 +1720,12 @@
 			// wird nicht mehr geliefert , todo aus Grafik extrahieren.
 			if (owner.equals(pref.myAlias) || owner.equals(pref.myAlias2)) {
 				ch.setOwned(true);
-			} else {
-				if (false) {
-					ch.setFound(true);
-					ch.setCacheStatus(ch.getFoundText());
-				}
 			}
+			//DEAD CODE commented out
+//			else if (false) {
+//				ch.setFound(true);
+//				ch.setCacheStatus(ch.getFoundText());
+//			}
 
 			cacheName = STRreplace.replace(cacheName, "\\\"", "\"");
 			ch.setCacheName(cacheName);



From araber95 at mail.berlios.de  Sat May 21 09:13:46 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Sat, 21 May 2011 09:13:46 PM +0200
Subject: [Cachewolf-svn] r3015 - in trunk/src/CacheWolf: . exp imp navi
Message-ID: <20110521191346.B650B481401@sheep.berlios.de>

Author: araber95
Date: 2011-05-21 21:13:46 +0200 (Sat, 21 May 2011)
New Revision: 3015

Modified:
   trunk/src/CacheWolf/DateFormat.java
   trunk/src/CacheWolf/Preferences.java
   trunk/src/CacheWolf/exp/KMLExporter.java
   trunk/src/CacheWolf/imp/OCXMLImporterScreen.java
   trunk/src/CacheWolf/imp/SpiderGC.java
   trunk/src/CacheWolf/navi/MovingMap.java
Log:
1. recognition of Dataformat
2. option get finds in prefs
3. selecting selected cache on map

Modified: trunk/src/CacheWolf/DateFormat.java
===================================================================
--- trunk/src/CacheWolf/DateFormat.java	2011-05-21 14:52:52 UTC (rev 3014)
+++ trunk/src/CacheWolf/DateFormat.java	2011-05-21 19:13:46 UTC (rev 3015)
@@ -38,6 +38,8 @@
 
 public class DateFormat {
 
+	public static String GCDateFormat = "";
+
 	/** Convert the US Format into a sortable format */
 	public static String toYYMMDD(String date) {
 		return toYYMMDD(toDate(date));
@@ -92,9 +94,14 @@
 						}
 						mm = monthName2int(month);
 					} else {
-						// mm dd yyyy
-						mm = v0;
-						dd = v1;
+						// mm dd yyyy (doesn't work for dd mm yyyy)
+						if (GCDateFormat.equals("dd/MM/yyyy")) {
+							dd = v0;
+							mm = v1;
+						} else {
+							mm = v0;
+							dd = v1;
+						}
 					}
 
 				}

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2011-05-21 14:52:52 UTC (rev 3014)
+++ trunk/src/CacheWolf/Preferences.java	2011-05-21 19:13:46 UTC (rev 3015)
@@ -324,6 +324,7 @@
 	public boolean sortAutomatic = true;
 	//
 	public String oldLanguageCtl = "";
+	public boolean doNotGetFound = true;
 
 	// ////////////////////////////////////////////
 	/**
@@ -560,6 +561,7 @@
 		} else if (name.equals("gotopanel")) {
 			northCenteredGoto = Boolean.valueOf(atts.getValue("northcentered")).booleanValue();
 		} else if (name.equals("spider")) {
+			doNotGetFound = !Boolean.valueOf(atts.getValue("getFinds")).booleanValue();
 			forceLogin = Boolean.valueOf(atts.getValue("forcelogin")).booleanValue();
 			checkLog = Boolean.valueOf(atts.getValue("checkLog")).booleanValue();
 			tmp = atts.getValue("checkTBs");
@@ -708,37 +710,119 @@
 			setPathToConfigFile(null); // this sets the default value
 		try {
 			PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(pathToConfigFile)));
-			outp.print("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
-			outp.print("<preferences>\n");
-			outp.print("    <locale language=\"" + SafeXML.clean(language) + "\"/>\n");
-			outp.print("    <basedir dir = \"" + SafeXML.clean(getBaseDir()) + "\"/>\n");
-			outp.print("    <lastprofile autoreload=\"" + SafeXML.strxmlencode(autoReloadLastProfile) + "\">" + SafeXML.clean(lastProfile) + "</lastprofile>\n"); // RB
-			outp.print("    <CurrentCentre FromGPSPosition=\"" + SafeXML.clean(Convert.toString(setCurrentCentreFromGPSPosition)) + "\"/>\n");
-			outp.print("    <alias name =\"" + SafeXML.clean(myAlias) + "\" password=\"" + SafeXML.clean(password) + "\" />\n");
-			outp.print("    <alias2 name =\"" + SafeXML.clean(myAlias2) + "\"/>\n");
-			outp.print("    <gcmemberid name =\"" + SafeXML.clean(gcMemberId) + "\"" + " Premium =\"" + SafeXML.strxmlencode(isPremium) + "\"/>\n");
-			outp.print("    <browser name = \"" + SafeXML.clean(browser) + "\"/>\n");
-			outp.print("    <proxy prx = \"" + SafeXML.clean(myproxy) + "\" prt = \"" + SafeXML.clean(myproxyport) + "\" active = \"" + SafeXML.strxmlencode(proxyActive) + "\" />\n");
-			outp.print("    <port portname = \"" + SafeXML.clean(mySPO.portName) + "\" baud = \"" + SafeXML.strxmlencode(mySPO.baudRate) + "\"/>\n");
-			outp.print("    <portforward active= \"" + SafeXML.clean(Convert.toString(forwardGPS)) + "\" destinationHost = \"" + SafeXML.clean(forwardGpsHost) + "\"/>\n");
-			outp.print("    <gpsd active= \"" + SafeXML.strxmlencode(useGPSD) + "\" host = \"" + SafeXML.clean(gpsdHost) + "\" port = \"" + SafeXML.strxmlencode(gpsdPort) + "\"/>\n");
-			outp.print("    <portlog active= \"" + SafeXML.clean(Convert.toString(logGPS)) + "\" logTimer = \"" + SafeXML.clean(logGPSTimer) + "\"/>\n");
-			outp.print("    <font name=\"" + fontName + "\" size=\"" + SafeXML.strxmlencode(fontSize) + "\"/>\n");
-			outp.print("    <screen menuattop=\"" + menuAtTop + "\" tabsattop=\"" + tabsAtTop + "\" showstatus=\"" + showStatus + "\" hasclosebutton=\"" + hasCloseButton + "\" h=\"" + myAppHeight + "\" w=\"" + myAppWidth + "\" />\n");
-			outp.print("    <fixedsip state = \"" + SafeXML.strxmlencode(fixSIP) + "\"/>\n");
-			outp.print("    <listview colmap=\"" + SafeXML.clean(listColMap) + "\" colwidths=\"" + SafeXML.clean(listColWidth) + "\" />\n");
-			outp.print("    <travelbugs colmap=\"" + SafeXML.clean(travelbugColMap) + "\" colwidths=\"" + SafeXML.clean(travelbugColWidth) + "\" shownonlogged=\"" + SafeXML.strxmlencode(travelbugShowOnlyNonLogged) + "\" />\n");
+			outp.print("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" //
+					+ "<preferences>\n" //
+					+ "    <locale language=\"" + SafeXML.clean(language) + "\"/>\n" //
+
+					+ "    <basedir dir=\"" + SafeXML.clean(getBaseDir()) + "\"/>\n"//
+
+					+ "    <lastprofile" //
+					+ " autoreload=\"" + SafeXML.strxmlencode(autoReloadLastProfile) + "\"" //
+					+ ">" //
+					+ SafeXML.clean(lastProfile) + "</lastprofile>\n" //
+
+					+ "    <CurrentCentre" //
+					+ " FromGPSPosition=\"" + SafeXML.strxmlencode(setCurrentCentreFromGPSPosition) + "\"" //
+					+ "/>\n" //
+
+					+ "    <alias" //
+					+ " name=\"" + SafeXML.clean(myAlias) + "\"" //
+					+ " password=\"" + SafeXML.clean(password) + "\"" //
+					+ "/>\n" //
+
+					+ "    <alias2 name=\"" + SafeXML.clean(myAlias2) + "\"/>\n" //
+
+					+ "    <gcmemberid" //
+					+ " name=\"" + SafeXML.clean(gcMemberId) + "\"" //
+					+ " Premium=\"" + SafeXML.strxmlencode(isPremium) + "\"" //
+					+ "/>\n" //
+
+					+ "    <browser name=\"" + SafeXML.clean(browser) + "\"/>\n" //
+
+					+ "    <proxy" //
+					+ " prx=\"" + SafeXML.clean(myproxy) + "\"" //
+					+ " prt=\"" + SafeXML.clean(myproxyport) + "\"" //
+					+ " active=\"" + SafeXML.strxmlencode(proxyActive) + "\"" //
+					+ "/>\n" //
+
+					+ "    <port" //
+					+ " portname=\"" + SafeXML.clean(mySPO.portName) + "\"" //
+					+ " baud=\"" + SafeXML.strxmlencode(mySPO.baudRate) + "\"" //
+					+ "/>\n" //
+
+					+ "    <portforward" //
+					+ " active=\"" + SafeXML.strxmlencode(forwardGPS) + "\"" //
+					+ " destinationHost=\"" + SafeXML.clean(forwardGpsHost) + "\"" //
+					+ "/>\n" //
+
+					+ "    <gpsd" //
+					+ " active=\"" + SafeXML.strxmlencode(useGPSD) + "\"" //
+					+ " host=\"" + SafeXML.clean(gpsdHost) + "\"" //
+					+ " port=\"" + SafeXML.strxmlencode(gpsdPort) + "\"" //
+					+ "/>\n" //
+
+					+ "    <portlog" //
+					+ " active=\"" + SafeXML.strxmlencode(logGPS) + "\"" //
+					+ " logTimer=\"" + SafeXML.clean(logGPSTimer) + "\"" //
+					+ "/>\n" //
+
+					+ "    <font" //
+					+ " name=\"" + fontName + "\"" //
+					+ " size=\"" + SafeXML.strxmlencode(fontSize) + "\"" //
+					+ "/>\n" //
+
+					+ "    <screen" //
+					+ " menuattop=\"" + menuAtTop + "\"" //
+					+ " tabsattop=\"" + tabsAtTop + "\"" //
+					+ " showstatus=\"" + showStatus + "\"" //
+					+ " hasclosebutton=\"" + hasCloseButton + "\"" //
+					+ " h=\"" + myAppHeight + "\"" //
+					+ " w=\"" + myAppWidth + "\"" //
+					+ "/>\n" //
+
+					+ "    <fixedsip state=\"" + SafeXML.strxmlencode(fixSIP) + "\"/>\n" //
+
+					+ "    <listview" //
+					+ " colmap=\"" + SafeXML.clean(listColMap) + "\"" //
+					+ " colwidths=\"" + SafeXML.clean(listColWidth) + "\"" //
+					+ "/>\n" //
+
+					+ "    <travelbugs" //
+					+ " colmap=\"" + SafeXML.clean(travelbugColMap) + "\"" //
+					+ " colwidths=\"" + SafeXML.clean(travelbugColWidth) + "\"" //
+					+ " shownonlogged=\"" + SafeXML.strxmlencode(travelbugShowOnlyNonLogged) + "\"" //
+					+ "/>\n");
+
 			outp.print("    <descpanel showimages=\"" + SafeXML.strxmlencode(descShowImg) + "\" />\n");
 			outp.print("    <imagepanel showdeletedimages=\"" + SafeXML.strxmlencode(showDeletedImages) + "\"/>\n");
-			outp.print("    <hintlogpanel logsperpage=\"" + SafeXML.strxmlencode(logsPerPage) + "\" initialhintheight=\"" + SafeXML.strxmlencode(initialHintHeight) + "\"  maxspiderlogs=\"" + SafeXML.strxmlencode(maxLogsToSpider) + "\" />\n");
+			outp.print("    <hintlogpanel"//
+					+ " logsperpage=\"" + SafeXML.strxmlencode(logsPerPage) + "\"" //
+					+ " initialhintheight=\"" + SafeXML.strxmlencode(initialHintHeight) + "\"" //
+					+ " maxspiderlogs=\"" + SafeXML.strxmlencode(maxLogsToSpider) + "\"" //
+					+ "/>\n");
 			outp.print("    <solver ignorevariablecase=\"" + SafeXML.strxmlencode(solverIgnoreCase) + "\" degMode=\"" + SafeXML.strxmlencode(solverDegMode) + "\" />\n");
-			outp.print("    <garmin connection = \"" + SafeXML.clean(garminConn) + "\" GPSBabelOptions = \"" + SafeXML.clean(garminGPSBabelOptions) + "\" MaxWaypointLength = \"" + SafeXML.strxmlencode(garminMaxLen) + "\" addDetailsToWaypoint = \""
-					+ SafeXML.strxmlencode(addDetailsToWaypoint) + "\" addDetailsToName = \"" + SafeXML.strxmlencode(addDetailsToName) + "\" />\n");
+			outp.print("    <garmin" //
+					+ " connection=\"" + SafeXML.clean(garminConn) + "\"" //
+					+ " GPSBabelOptions=\"" + SafeXML.clean(garminGPSBabelOptions) + "\"" //
+					+ " MaxWaypointLength=\"" + SafeXML.strxmlencode(garminMaxLen) + "\"" //
+					+ " addDetailsToWaypoint=\"" + SafeXML.strxmlencode(addDetailsToWaypoint) + "\"" //
+					+ " addDetailsToName=\"" + SafeXML.strxmlencode(addDetailsToName) + "\"" //
+					+ "/>\n");
 			outp.print("    <opencaching lastSite=\"" + lastOCSite + "\" downloadMissing=\"" + SafeXML.strxmlencode(downloadAllOC) + "\"/>\n");
-			outp.print("    <location lat = \"" + SafeXML.clean(curCentrePt.getLatDeg(TransformCoordinates.DD)) + "\" long = \"" + SafeXML.clean(curCentrePt.getLonDeg(TransformCoordinates.DD)) + "\"/>\n");
-			outp.print("    <spider" + " forcelogin=\"" + SafeXML.strxmlencode(forceLogin) + "\"" + " spiderUpdates=\"" + SafeXML.strxmlencode(spiderUpdates) + "\"" + " checkLog=\"" + SafeXML.strxmlencode(checkLog) + "\"" + " checkTBs=\""
-					+ SafeXML.strxmlencode(checkTBs) + "\"" + " checkDTS=\"" + SafeXML.strxmlencode(checkDTS) + "\"" + " spiderRoute=\"" + SafeXML.strxmlencode(spiderRoute) + "\"" + " maxSpiderNumber=\"" + SafeXML.strxmlencode(maxSpiderNumber) + "\""
-					+ " downloadPics=\"" + SafeXML.strxmlencode(downloadPics) + "\"" + " downloadTBs=\"" + SafeXML.strxmlencode(downloadTBs) + "\"" + " UserID=\"" + SafeXML.clean(userID) + "\"" + "/>\n");
+			outp.print("    <location lat=\"" + SafeXML.clean(curCentrePt.getLatDeg(TransformCoordinates.DD)) + "\" long=\"" + SafeXML.clean(curCentrePt.getLonDeg(TransformCoordinates.DD)) + "\"/>\n");
+			outp.print("    <spider" //
+					+ " forcelogin=\"" + SafeXML.strxmlencode(forceLogin) + "\"" //
+					+ " spiderUpdates=\"" + SafeXML.strxmlencode(spiderUpdates) + "\"" //
+					+ " checkLog=\"" + SafeXML.strxmlencode(checkLog) + "\"" //
+					+ " checkTBs=\"" + SafeXML.strxmlencode(checkTBs) + "\"" //
+					+ " checkDTS=\"" + SafeXML.strxmlencode(checkDTS) + "\"" //
+					+ " spiderRoute=\"" + SafeXML.strxmlencode(spiderRoute) + "\"" //
+					+ " maxSpiderNumber=\"" + SafeXML.strxmlencode(maxSpiderNumber) + "\"" //
+					+ " downloadPics=\"" + SafeXML.strxmlencode(downloadPics) + "\"" //
+					+ " downloadTBs=\"" + SafeXML.strxmlencode(downloadTBs) + "\"" //
+					+ " UserID=\"" + SafeXML.clean(userID) + "\"" //
+					+ " getFinds=\"" + SafeXML.strxmlencode(!doNotGetFound) + "\"" //
+					+ "/>\n");
 			outp.print("    <gotopanel northcentered=\"" + SafeXML.strxmlencode(northCenteredGoto) + "\" />\n");
 			outp.print("    <details cacheSize=\"" + SafeXML.strxmlencode(maxDetails) + "\" delete=\"" + SafeXML.strxmlencode(deleteDetails) + "\"/>\n");
 			outp.print("    <metric type=\"" + SafeXML.strxmlencode(metricSystem) + "\"/>\n");
@@ -746,7 +830,7 @@
 					+ "\"/>\n");
 			outp.print("    <datamover processorMode=\"" + SafeXML.strxmlencode(processorMode) + "\" />\n");
 			if (customMapsPath != null)
-				outp.print("    <mapspath dir = \"" + SafeXML.clean(customMapsPath.replace('\\', '/')) + "\"/>\n");
+				outp.print("    <mapspath dir=\"" + SafeXML.clean(customMapsPath.replace('\\', '/')) + "\"/>\n");
 			// Saving filters
 			String[] filterIDs = this.getFilterIDs();
 			for (int i = 0; i < filterIDs.length; i++) {

Modified: trunk/src/CacheWolf/exp/KMLExporter.java
===================================================================
--- trunk/src/CacheWolf/exp/KMLExporter.java	2011-05-21 14:52:52 UTC (rev 3014)
+++ trunk/src/CacheWolf/exp/KMLExporter.java	2011-05-21 19:13:46 UTC (rev 3015)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CWPoint;
@@ -45,49 +45,40 @@
 import ewe.ui.ProgressBarForm;
 import ewe.util.Hashtable;
 import ewe.util.Iterator;
+import ewe.util.Map.MapEntry;
 import ewe.util.Vector;
-import ewe.util.Map.MapEntry;
 import ewe.util.zip.ZipEntry;
 import ewe.util.zip.ZipException;
 import ewe.util.zip.ZipFile;
 
 /**
-*	Class to export the cache database (index) to an KML-File
-*	which can be read by Google Earth
-*
-*/
+ * Class to export the cache database (index) to an KML-File
+ * which can be read by Google Earth
+ * 
+ */
 public class KMLExporter extends Exporter {
 	private static final String COLOR_FOUND = "ff98fb98";
 	private static final String COLOR_OWNED = "ffffaa55";
 	private static final String COLOR_AVAILABLE = "ffffffff";
 	private static final String COLOR_NOT_AVAILABLE = "ff0000ff";
 
-
 	static final int AVAILABLE = 0;
 	static final int FOUND = 1;
 	static final int OWNED = 2;
 	static final int NOT_AVAILABLE = 3;
 	static final int UNKNOWN = 4;
 
-
-	String []categoryNames = {"Available","Found", "Owned", "Not Available", "UNKNOWN"};
-	Hashtable [] outCacheDB = new Hashtable[categoryNames.length];
+	String[] categoryNames = { "Available", "Found", "Owned", "Not Available", "UNKNOWN" };
+	Hashtable[] outCacheDB = new Hashtable[categoryNames.length];
 	private Profile prof;
 
-	public KMLExporter(){
+	public KMLExporter(Preferences p, Profile _prof) {
 		super();
 		this.setMask("*.kml");
-		this.setHowManyParams(LAT_LON);
+		prof = _prof;
 	}
 
-
-	public KMLExporter(Preferences p, Profile _prof){
-			super();
-			this.setMask("*.kml");
-			prof=_prof;
-	}
-
-	public void doIt(int variant){
+	public void doIt(int variant) {
 		File outFile;
 		String str;
 		CacheHolder ch;
@@ -97,13 +88,14 @@
 
 		if (variant == ASK_FILE) {
 			outFile = getOutputFile();
-			if (outFile == null) return;
+			if (outFile == null)
+				return;
 		} else {
 			outFile = new File(tmpFileName);
 		}
 
 		pbf.showMainTask = false;
-		pbf.setTask(h,"Exporting ...");
+		pbf.setTask(h, "Exporting ...");
 		pbf.exec();
 
 		int counter = cacheDB.countVisible();
@@ -111,51 +103,55 @@
 		copyIcons(outFile.getParent());
 		buildOutDB();
 
-		try{
-			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(outFile)));
-			str = STRreplace.replace(this.header(),"CacheWolf",prof.name);
-			if (str != null) outp.print(str);
+		try {
+			PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(outFile)));
+			str = STRreplace.replace(this.header(), "CacheWolf", prof.name);
+			if (str != null)
+				outp.print(str);
 			for (int cat = 0; cat < categoryNames.length; cat++) {
 				// skip over empty categories
-				if (outCacheDB[cat]==null) continue;
+				if (outCacheDB[cat] == null)
+					continue;
 
 				Iterator outLoop = outCacheDB[cat].entries();
 				outp.print(startFolder(categoryNames[cat]));
 
 				Vector tmp;
 				MapEntry entry;
-				while (outLoop.hasNext()){
+				while (outLoop.hasNext()) {
 					entry = (MapEntry) outLoop.next();
-					tmp = (Vector)entry.getValue();
+					tmp = (Vector) entry.getValue();
 					// skip over empty cachetypes
-					if (tmp.size() == 0) continue;
+					if (tmp.size() == 0)
+						continue;
 					outp.print(startFolder(CacheType.type2Gui(Integer.valueOf(entry.getKey().toString()).byteValue())));
 
-					for(int i = 0; i<tmp.size(); i++){
+					for (int i = 0; i < tmp.size(); i++) {
 						ch = (CacheHolder) tmp.get(i);
-						if (ch.isAddiWpt()) continue;
+						if (ch.isAddiWpt())
+							continue;
 						expCount++;
-						h.progress = (float)expCount/(float)counter;
+						h.progress = (float) expCount / (float) counter;
 						h.changed();
 
-						if (ch.pos.isValid()){
-							str = record(ch, ch.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-								     ch.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
-							if (str != null) outp.print(str);
+						if (ch.pos.isValid()) {
+							str = record(ch, ch.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), ch.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+							if (str != null)
+								outp.print(str);
 						}
-						if (ch.hasAddiWpt()){
+						if (ch.hasAddiWpt()) {
 							boolean createdAdditionalWaypointsFolder = false;
-							for(int j = 0; j<ch.addiWpts.size(); j++){
+							for (int j = 0; j < ch.addiWpts.size(); j++) {
 								addiWpt = (CacheHolder) ch.addiWpts.get(j);
 								expCount++;
-								if (ch.pos.isValid() &&  addiWpt.isVisible()){
-									if (! createdAdditionalWaypointsFolder) {
+								if (ch.pos.isValid() && addiWpt.isVisible()) {
+									if (!createdAdditionalWaypointsFolder) {
 										outp.print(startFolder("Additional Waypoints", false));
 										createdAdditionalWaypointsFolder = true;
 									}
-									str = record(addiWpt, addiWpt.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-											addiWpt.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
-									if (str != null) outp.print(str);
+									str = record(addiWpt, addiWpt.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), addiWpt.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+									if (str != null)
+										outp.print(str);
 								}
 
 							}
@@ -170,17 +166,18 @@
 			}
 
 			str = trailer();
-			if (str != null) outp.print(str);
+			if (str != null)
+				outp.print(str);
 			outp.close();
 			pbf.exit(0);
-		} catch (IOException ioE){
-			pref.log("Error opening " + outFile.getName(),ioE);
+		} catch (IOException ioE) {
+			pref.log("Error opening " + outFile.getName(), ioE);
 		}
-		//try
+		// try
 
 	}
 
-	private void buildOutDB(){
+	private void buildOutDB() {
 		CacheHolder ch;
 		Vector tmp;
 		Iterator categoryLoop;
@@ -197,49 +194,54 @@
 		}
 
 		// fill structure with data from cacheDB
-		for(int i = 0; i<cacheDB.size(); i++){
-			ch=cacheDB.get(i);
+		for (int i = 0; i < cacheDB.size(); i++) {
+			ch = cacheDB.get(i);
 			// TODO Das Argument nach STring zu casten gef???llt mir nicht ganz...
-			if(ch.isVisible() && !ch.isAddiWpt()){
-				if (ch.is_found()) { tmp = (Vector) outCacheDB[FOUND].get(String.valueOf(ch.getType()));}
-				else if (ch.is_owned()) { tmp = (Vector) outCacheDB[OWNED].get(String.valueOf(ch.getType()));}
-				else if (ch.is_archived() || !ch.is_available()){ tmp = (Vector) outCacheDB[NOT_AVAILABLE].get(String.valueOf(ch.getType()));}
-				else if (ch.is_available()){ tmp = (Vector) outCacheDB[AVAILABLE].get(String.valueOf(ch.getType()));}
-				else { tmp = (Vector) outCacheDB[UNKNOWN].get(String.valueOf(ch.getType()));}
-
+			if (ch.isVisible() && !ch.isAddiWpt()) {
+				if (ch.is_found()) {
+					tmp = (Vector) outCacheDB[FOUND].get(String.valueOf(ch.getType()));
+				} else if (ch.is_owned()) {
+					tmp = (Vector) outCacheDB[OWNED].get(String.valueOf(ch.getType()));
+				} else if (ch.is_archived() || !ch.is_available()) {
+					tmp = (Vector) outCacheDB[NOT_AVAILABLE].get(String.valueOf(ch.getType()));
+				} else if (ch.is_available()) {
+					tmp = (Vector) outCacheDB[AVAILABLE].get(String.valueOf(ch.getType()));
+				} else {
+					tmp = (Vector) outCacheDB[UNKNOWN].get(String.valueOf(ch.getType()));
+				}
 				tmp.add(ch);
 			}
 		}
 
-		//eleminate empty categories
+		// eleminate empty categories
 		for (int i = 0; i < categoryNames.length; i++) {
 			categoryLoop = outCacheDB[i].entries();
 			foundOne = false;
-			//look if all vectors for cachetypes are filled
-			while (categoryLoop.hasNext()){
+			// look if all vectors for cachetypes are filled
+			while (categoryLoop.hasNext()) {
 				entry = (MapEntry) categoryLoop.next();
-				tmp = (Vector)entry.getValue();
-				if (tmp.size()> 0){
+				tmp = (Vector) entry.getValue();
+				if (tmp.size() > 0) {
 					foundOne = true;
 					break;
 				}
 			}
 			// set hashtable for that category to null
-			if (!foundOne)outCacheDB[i] = null;
+			if (!foundOne)
+				outCacheDB[i] = null;
 		}
 
-
 	}
 
-	private String startFolder(String name){
+	private String startFolder(String name) {
 		return startFolder(name, true);
 	}
 
-	private String startFolder(String name, boolean open){
+	private String startFolder(String name, boolean open) {
 		StringBuffer strBuf = new StringBuffer(200);
 		strBuf.append("<Folder>\r\n");
 		strBuf.append("<name>" + name + "</name>\r\n");
-		strBuf.append("<open>" + (open?"1":"0") + "</open>\r\n");
+		strBuf.append("<open>" + (open ? "1" : "0") + "</open>\r\n");
 
 		return strBuf.toString();
 	}
@@ -249,15 +251,15 @@
 		return "</Folder>\r\n";
 	}
 
-	public void copyIcons(String dir){
-		ZipFile zif=null;
+	public void copyIcons(String dir) {
+		ZipFile zif = null;
 		try {
-			zif = new ZipFile (FileBase.getProgramDirectory() + FileBase.separator + "exporticons" + FileBase.separator + "GoogleEarth.zip");
+			zif = new ZipFile(FileBase.getProgramDirectory() + FileBase.separator + "exporticons" + FileBase.separator + "GoogleEarth.zip");
 		} catch (IOException e) {
 		}
 		try {
-      if (zif == null) {
-			  zif = new ZipFile (FileBase.getProgramDirectory() + FileBase.separator + "exporticons" + FileBase.separator + "exporticons" + FileBase.separator + "GoogleEarth.zip");
+			if (zif == null) {
+				zif = new ZipFile(FileBase.getProgramDirectory() + FileBase.separator + "exporticons" + FileBase.separator + "exporticons" + FileBase.separator + "GoogleEarth.zip");
 			}
 			ZipEntry zipEnt;
 			int len;
@@ -266,27 +268,29 @@
 			for (int i = 0; i < CacheType.guiTypeStrings().length; i++) {
 				fileName = CacheType.typeImageForId(CacheType.guiSelect2Cw(i));
 				zipEnt = zif.getEntry(fileName);
-				if (zipEnt == null) continue;
-			    byte[] buff = new byte[ zipEnt.getSize() ];
-			    InputStream  fis = zif.getInputStream(zipEnt);
-			    FileOutputStream fos = new FileOutputStream( dir + "/" + fileName);
-			    while( 0 < (len = fis.read( buff )) )
-			      fos.write( buff, 0, len );
-			    fos.flush();
-			    fos.close();
-			    fis.close();
+				if (zipEnt == null)
+					continue;
+				byte[] buff = new byte[zipEnt.getSize()];
+				InputStream fis = zif.getInputStream(zipEnt);
+				FileOutputStream fos = new FileOutputStream(dir + "/" + fileName);
+				while (0 < (len = fis.read(buff)))
+					fos.write(buff, 0, len);
+				fos.flush();
+				fos.close();
+				fis.close();
 			}
 
-			} catch (ZipException e) {
-				pref.log("Problem copying Icon",e,true);
-			} catch (IOException e) {
-				pref.log("Problem copying Icon",e,true);
-			}
+		} catch (ZipException e) {
+			pref.log("Problem copying Icon", e, true);
+		} catch (IOException e) {
+			pref.log("Problem copying Icon", e, true);
+		}
 	}
 
+	StringBuffer strBuf = new StringBuffer(200);
 
-	public String header () {
-		StringBuffer strBuf = new StringBuffer(200);
+	public String header() {
+		strBuf.setLength(0);
 
 		strBuf.append("<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n");
 		strBuf.append("<kml xmlns=\"http://earth.google.com/kml/2.0\">\r\n");
@@ -297,29 +301,28 @@
 		return strBuf.toString();
 	}
 
-
-	public String record(CacheHolder ch, String lat, String lon){
-		StringBuffer strBuf = new StringBuffer(200);
+	public String record(CacheHolder ch, String lat, String lon) {
+		strBuf.setLength(0);
 		CacheHolderDetail det = ch.getCacheDetails(true);
 
 		strBuf.append("   <Placemark>\r\n");
-		if (det.URL != null){
-			strBuf.append("      <description>"+SafeXML.clean(det.URL)+"</description>\r\n");
+		if (det.URL != null) {
+			strBuf.append("      <description>" + SafeXML.clean(det.URL) + "</description>\r\n");
 		}
-		strBuf.append("      <name>"+ ch.getWayPoint() + " - " + SafeXML.clean(ch.getCacheName()) +"</name>\r\n");
+		strBuf.append("      <name>" + ch.getWayPoint() + " - " + SafeXML.clean(ch.getCacheName()) + "</name>\r\n");
 		strBuf.append("      <LookAt>\r\n");
 		strBuf.append("         <latitude>" + lat + "</latitude>\r\n");
 		strBuf.append("         <longitude>" + lon + "</longitude>\r\n");
 		strBuf.append("         <range>10000</range><tilt>0</tilt><heading>0</heading>\r\n");
 		strBuf.append("      </LookAt>\r\n");
 		strBuf.append("      <Point>\r\n");
-		strBuf.append("         <coordinates>"  + lon + "," + lat + "</coordinates>\r\n");
+		strBuf.append("         <coordinates>" + lon + "," + lat + "</coordinates>\r\n");
 		strBuf.append("      </Point>\r\n");
 		strBuf.append("      <Style>\r\n");
 		strBuf.append("      <IconStyle>\r\n");
 		strBuf.append("         <Icon>\r\n");
-//		strBuf.append("            <href>"+ File.getProgramDirectory()+ "/" + CacheType.type2pic(Convert.parseInt(ch.type))+ "</href>\r\n");
-		strBuf.append("            <href>"+ CacheType.typeImageForId(ch.getType())+ "</href>\r\n");
+		// strBuf.append("            <href>"+ File.getProgramDirectory()+ "/" + CacheType.type2pic(Convert.parseInt(ch.type))+ "</href>\r\n");
+		strBuf.append("            <href>" + CacheType.typeImageForId(ch.getType()) + "</href>\r\n");
 		strBuf.append("         </Icon>\r\n");
 		strBuf.append("      </IconStyle>\r\n");
 		strBuf.append("      <LabelStyle>\r\n");
@@ -331,8 +334,8 @@
 		return strBuf.toString();
 	}
 
-	public String trailer(){
-		StringBuffer strBuf = new StringBuffer(50);
+	public String trailer() {
+		strBuf.setLength(0);
 
 		strBuf.append("</Folder>\r\n");
 		strBuf.append("</kml>\r\n");
@@ -340,10 +343,13 @@
 		return strBuf.toString();
 	}
 
-	private String getColor(CacheHolder ch){
-		if (ch.is_found()) return COLOR_FOUND;
-		if (ch.is_owned()) return COLOR_OWNED;
-		if (ch.is_archived() || !ch.is_available()) return COLOR_NOT_AVAILABLE;
+	private String getColor(CacheHolder ch) {
+		if (ch.is_found())
+			return COLOR_FOUND;
+		if (ch.is_owned())
+			return COLOR_OWNED;
+		if (ch.is_archived() || !ch.is_available())
+			return COLOR_NOT_AVAILABLE;
 
 		return COLOR_AVAILABLE;
 	}

Modified: trunk/src/CacheWolf/imp/OCXMLImporterScreen.java
===================================================================
--- trunk/src/CacheWolf/imp/OCXMLImporterScreen.java	2011-05-21 14:52:52 UTC (rev 3014)
+++ trunk/src/CacheWolf/imp/OCXMLImporterScreen.java	2011-05-21 19:13:46 UTC (rev 3015)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.imp;
 
 import CacheWolf.CacheType;
@@ -49,9 +49,9 @@
 
 /**
  * @author pfeffer
- * This Class is the Dialog for Download from Opencaching.de
- * is called from OCXMLImporter
- * 20061209 Bugfix: Checking for uninitialised missingCheckBox
+ *         This Class is the Dialog for Download from Opencaching.de
+ *         is called from OCXMLImporter
+ *         20061209 Bugfix: Checking for uninitialised missingCheckBox
  */
 public class OCXMLImporterScreen extends Form {
 	mButton cancelB, okB;
@@ -63,7 +63,7 @@
 	mInput maxNumberInput;
 	mInput maxNumberUpdates;
 	mInput maxLogsInput;
-	mCheckBox imagesCheckBox, /*mapsCheckBox, */ missingCheckBox, foundCheckBox, travelbugsCheckBox;
+	mCheckBox imagesCheckBox, /* mapsCheckBox, */missingCheckBox, foundCheckBox, travelbugsCheckBox;
 	ewe.ui.mChoice domains;
 	String fileName;
 
@@ -86,7 +86,6 @@
 	public static final int MAXUPDATE = 4096;
 	public static final int FILENAME = 8192; // track or route gpx
 
-
 	public OCXMLImporterScreen(String title, int options) {
 		super();
 		pref = Global.getPref(); // myPreferences sollte sp?ter auch diese Einstellungen speichern
@@ -95,39 +94,28 @@
 
 		this.title = title;
 
-		if((options & HOST) > 0){
-			domains = new mChoice(OC.OCHostNames(),OC.getSiteIndex(pref.lastOCSite));
+		if ((options & HOST) > 0) {
+			domains = new mChoice(OC.OCHostNames(), OC.getSiteIndex(pref.lastOCSite));
 			domains.setTextSize(25, 1);
-			this.addLast(domains, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+			this.addLast(domains, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
 		}
 
 		if ((options & TYPE) > 0) {
-			this.addLast( chcType = new mChoice(new String[] {
-					MyLocale.getMsg(1627,"All caches"),
-					MyLocale.getMsg(2,"Tradi"),
-					MyLocale.getMsg(3,"Multi"),
-					MyLocale.getMsg(4,"Virtual"),
-					MyLocale.getMsg(5,"Letterbox"),
-					MyLocale.getMsg(6,"Event"),
-					MyLocale.getMsg(14,"Mega Event"),
-					MyLocale.getMsg(11,"Webcam"),
-					MyLocale.getMsg(8,"Mysterie"),
-					MyLocale.getMsg(13,"CITO"),
-					MyLocale.getMsg(18,"Earth"),
-					MyLocale.getMsg(15,"WhereIGo"),
-				},0), CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
+			this.addLast(chcType = new mChoice(new String[] { MyLocale.getMsg(1627, "All caches"), MyLocale.getMsg(2, "Tradi"), MyLocale.getMsg(3, "Multi"), MyLocale.getMsg(4, "Virtual"), MyLocale.getMsg(5, "Letterbox"), MyLocale.getMsg(6, "Event"),
+					MyLocale.getMsg(14, "Mega Event"), MyLocale.getMsg(11, "Webcam"), MyLocale.getMsg(8, "Mysterie"), MyLocale.getMsg(13, "CITO"), MyLocale.getMsg(18, "Earth"), MyLocale.getMsg(15, "WhereIGo"), }, 0), CellConstants.STRETCH,
+					(CellConstants.FILL | CellConstants.WEST));
 		}
 
 		if ((options & MINDIST) > 0) {
-			this.addNext(distLbl = new mLabel(MyLocale.getMsg(1628,"min. Distance:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(distLbl = new mLabel(MyLocale.getMsg(1628, "min. Distance:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			minDistanceInput = new mInput();
 			minDistanceInput.setText(Global.getProfile().getMinDistGC());
-			this.addNext(minDistanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			this.addLast(new mLabel(" km/mi."),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(minDistanceInput, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+			this.addLast(new mLabel(" km/mi."), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		}
 
 		if ((options & DIST) > 0) {
-			this.addNext(distLbl = new mLabel(MyLocale.getMsg(1601,"Distance:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(distLbl = new mLabel(MyLocale.getMsg(1601, "Distance:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			maxDistanceInput = new mInput();
 			String dist1;
 			String dist2;
@@ -138,150 +126,154 @@
 				dist1 = Global.getProfile().getDistOC();
 				dist2 = Global.getProfile().getDistGC();
 			}
-			if ( dist1.equals("") || dist1.equals("0") || dist1.equals("0.0") ) {
+			if (dist1.equals("") || dist1.equals("0") || dist1.equals("0.0")) {
 				dist1 = dist2;
 			}
 			maxDistanceInput.setText(dist1);
-			this.addNext(maxDistanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			this.addLast(distUnit = new mLabel(" km/mi."),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(maxDistanceInput, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+			this.addLast(distUnit = new mLabel(" km/mi."), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		}
 
 		if ((options & DIRECTION) > 0) {
-			this.addNext(new mLabel(MyLocale.getMsg(1629,"Richtung:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(new mLabel(MyLocale.getMsg(1629, "Richtung:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			directionInput = new mInput();
 			directionInput.setText(Global.getProfile().getDirectionGC());
-			directionInput.toolTip=MyLocale.getMsg(1630,"z.B. leer oder von-bis (Grad)");
-			this.addLast(directionInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			directionInput.toolTip = MyLocale.getMsg(1630, "z.B. leer oder von-bis (Grad)");
+			this.addLast(directionInput, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		}
 
 		if ((options & MAXNUMBER) > 0) {
-			this.addNext(maxNumberLbl = new mLabel(MyLocale.getMsg(1623,"Max. number:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(maxNumberLbl = new mLabel(MyLocale.getMsg(1623, "Max. number:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			maxNumberInput = new mInput();
-			if ( pref.maxSpiderNumber < 0 || pref.maxSpiderNumber == Integer.MAX_VALUE) {
+			if (pref.maxSpiderNumber < 0 || pref.maxSpiderNumber == Integer.MAX_VALUE) {
 				maxNumberInput.setText("");
 			} else {
 				maxNumberInput.setText(Integer.toString(pref.maxSpiderNumber));
 			}
-			this.addNext(maxNumberInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			this.addLast( new mLabel(MyLocale.getMsg(1624," caches")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(maxNumberInput, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+			this.addLast(new mLabel(MyLocale.getMsg(1624, " caches")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		}
 
 		if ((options & MAXUPDATE) > 0) {
-			this.addNext(new mLabel(MyLocale.getMsg(1631,"Max. Updates:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(new mLabel(MyLocale.getMsg(1631, "Max. Updates:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			maxNumberUpdates = new mInput();
 			maxNumberUpdates.setText("");
-			this.addNext(maxNumberUpdates,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			this.addLast( new mLabel(MyLocale.getMsg(1624," caches")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(maxNumberUpdates, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+			this.addLast(new mLabel(MyLocale.getMsg(1624, " caches")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		}
 
 		if ((options & MAXLOGS) > 0) {
-			this.addNext(new mLabel(MyLocale.getMsg(1626,"Max. logs:")),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(new mLabel(MyLocale.getMsg(1626, "Max. logs:")), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			maxLogsInput = new mInput();
 			maxLogsInput.setText(Convert.toString(pref.maxLogsToSpider));
-			this.addLast(maxLogsInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addLast(maxLogsInput, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		}
 
 		if ((options & IMAGES) > 0) {
 			imagesCheckBox = new mCheckBox();
-			imagesCheckBox.setText(MyLocale.getMsg(1602,"Download Images"));
+			imagesCheckBox.setText(MyLocale.getMsg(1602, "Download Images"));
 			imagesCheckBox.setState(pref.downloadPics);
-			this.addLast(imagesCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+			this.addLast(imagesCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
 		}
 
 		if ((options & TRAVELBUGS) > 0) {
 			travelbugsCheckBox = new mCheckBox();
-			travelbugsCheckBox.setText(MyLocale.getMsg(1625,"Download TBs"));
+			travelbugsCheckBox.setText(MyLocale.getMsg(1625, "Download TBs"));
 			travelbugsCheckBox.setState(pref.downloadTBs);
-			this.addLast(travelbugsCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+			this.addLast(travelbugsCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
 		}
 
-		if((options & INCLUDEFOUND) > 0){
+		if ((options & INCLUDEFOUND) > 0) {
 			foundCheckBox = new mCheckBox();
-			foundCheckBox.setText(MyLocale.getMsg(1622,"Exclude found caches"));
-			foundCheckBox.setState(true);
-			this.addLast(foundCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+			foundCheckBox.setText(MyLocale.getMsg(1622, "Exclude found caches"));
+			foundCheckBox.setState(pref.doNotGetFound);
+			this.addLast(foundCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
 		}
 
-		if((options & ALL) > 0){
+		if ((options & ALL) > 0) {
 			missingCheckBox = new mCheckBox();
-			missingCheckBox.setText(MyLocale.getMsg(1606,"Alle erneut downloaden"));
+			missingCheckBox.setText(MyLocale.getMsg(1606, "Alle erneut downloaden"));
 			missingCheckBox.setState(pref.downloadAllOC);
-			this.addLast(missingCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+			this.addLast(missingCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
 		}
 
 		if ((options & FILENAME) > 0) {
 			String dir = pref.getImporterPath("LocGpxImporter");
 			FileChooser fc = new FileChooser(FileChooserBase.OPEN, dir);
 			fc.addMask("*.gpx");
-			fc.setTitle(MyLocale.getMsg(909,"Select file(s)"));
-			if(fc.execute() != FormBase.IDCANCEL){
+			fc.setTitle(MyLocale.getMsg(909, "Select file(s)"));
+			if (fc.execute() != FormBase.IDCANCEL) {
 				dir = fc.getChosenDirectory().toString();
 				pref.setImporterPath("LocGpxImporter", dir);
-				//String files[] = fc.getAllChosen();
-				fileName=fc.file;
+				// String files[] = fc.getAllChosen();
+				fileName = fc.file;
+			} else {
+				fileName = "";
 			}
-			else {
-				fileName="";
-			}
 		}
 
-		cancelB = new mButton(MyLocale.getMsg(1604,"Cancel"));
+		cancelB = new mButton(MyLocale.getMsg(1604, "Cancel"));
 		cancelB.setHotKey(0, IKeys.ESCAPE);
-		this.addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		okB = new mButton(MyLocale.getMsg(1605,"OK"));
+		this.addNext(cancelB, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		okB = new mButton(MyLocale.getMsg(1605, "OK"));
 		okB.setHotKey(0, IKeys.ACTION);
 		okB.setHotKey(0, IKeys.ENTER);
-		this.addLast(okB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		this.addLast(okB, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 	}
-	public void onEvent(Event ev){
-		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelB){
+
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED) {
+			if (ev.target == cancelB) {
 				this.close(FormBase.IDCANCEL);
 			}
-			if (ev.target == okB){
-				    // distOC wird hier noch nicht in Pref eingetragen, damit noch gepr?ft werden kann, ob es gr??er oder kleiner ist als vorher
-					if (missingCheckBox!=null) pref.downloadAllOC = missingCheckBox.state;
-					if (imagesCheckBox!=null) pref.downloadPics = imagesCheckBox.state;
-					if (travelbugsCheckBox!=null) pref.downloadTBs = travelbugsCheckBox.state;
-					if (maxLogsInput!=null) pref.maxLogsToSpider=Common.parseInt(maxLogsInput.getText());
-					pref.savePreferences();
+			if (ev.target == okB) {
+				// distOC wird hier noch nicht in Pref eingetragen, damit noch gepr?ft werden kann, ob es gr??er oder kleiner ist als vorher
+				if (missingCheckBox != null)
+					pref.downloadAllOC = missingCheckBox.state;
+				if (imagesCheckBox != null)
+					pref.downloadPics = imagesCheckBox.state;
+				if (travelbugsCheckBox != null)
+					pref.downloadTBs = travelbugsCheckBox.state;
+				if (maxLogsInput != null)
+					pref.maxLogsToSpider = Common.parseInt(maxLogsInput.getText());
+				pref.savePreferences();
 				this.close(FormBase.IDOK);
-				}
+			}
 		}
 		super.onEvent(ev);
 	}
 
-	public String getCacheTypeRestriction(SpiderProperties p){
+	public String getCacheTypeRestriction(SpiderProperties p) {
 		String cacheTypeRestriction = "";
 
-		if (chcType!=null){
+		if (chcType != null) {
 			try {
 				switch (chcType.getInt()) {
-				case  0:
+				case 0:
 					cacheTypeRestriction = "";
 					break;
-				case  1:
+				case 1:
 					cacheTypeRestriction = p.getProp("onlyTraditional");
 					break;
-				case  2:
+				case 2:
 					cacheTypeRestriction = p.getProp("onlyMulti");
 					break;
-				case  3:
-					cacheTypeRestriction = p.getProp("onlyVirtual") ;
+				case 3:
+					cacheTypeRestriction = p.getProp("onlyVirtual");
 					break;
-				case  4:
+				case 4:
 					cacheTypeRestriction = p.getProp("onlyLetterboxHybrid");
 					break;
-				case  5:
+				case 5:
 					cacheTypeRestriction = p.getProp("onlyEvent");
 					break;
-				case  6:
+				case 6:
 					cacheTypeRestriction = p.getProp("onlyMegaEvent");
 					break;
-				case  7:
+				case 7:
 					cacheTypeRestriction = p.getProp("onlyWebcam");
 					break;
-				case  8:
+				case 8:
 					cacheTypeRestriction = p.getProp("onlyUnknown");
 					break;
 				case 9:
@@ -296,43 +288,43 @@
 				default:
 					cacheTypeRestriction = "";
 				}
-			}catch (Exception ex) { // Some tag missing from spider.def
+			} catch (Exception ex) { // Some tag missing from spider.def
 			}
 		}
 		return cacheTypeRestriction;
 	}
 
-	public byte getRestrictedCacheType(SpiderProperties p){
+	public byte getRestrictedCacheType(SpiderProperties p) {
 		byte RestrictedType = CacheType.CW_TYPE_ERROR;
 
-		if (chcType!=null){
+		if (chcType != null) {
 			try {
 				switch (chcType.getInt()) {
-				case  0:
+				case 0:
 					RestrictedType = CacheType.CW_TYPE_ERROR;
 					break;
-				case  1:
+				case 1:
 					RestrictedType = CacheType.CW_TYPE_TRADITIONAL;
 					break;
-				case  2:
+				case 2:
 					RestrictedType = CacheType.CW_TYPE_MULTI;
 					break;
-				case  3:
+				case 3:
 					RestrictedType = CacheType.CW_TYPE_VIRTUAL;
 					break;
-				case  4:
+				case 4:
 					RestrictedType = CacheType.CW_TYPE_LETTERBOX;
 					break;
-				case  5:
+				case 5:
 					RestrictedType = CacheType.CW_TYPE_EVENT;
 					break;
-				case  6:
+				case 6:
 					RestrictedType = CacheType.CW_TYPE_MEGA_EVENT;
 					break;
-				case  7:
+				case 7:
 					RestrictedType = CacheType.CW_TYPE_WEBCAM;
 					break;
-				case  8:
+				case 8:
 					RestrictedType = CacheType.CW_TYPE_UNKNOWN;
 					break;
 				case 9:
@@ -347,7 +339,7 @@
 				default:
 					RestrictedType = CacheType.CW_TYPE_ERROR;
 				}
-			}catch (Exception ex) { // Some tag missing from spider.def
+			} catch (Exception ex) { // Some tag missing from spider.def
 			}
 		}
 		return RestrictedType;

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-21 14:52:52 UTC (rev 3014)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-21 19:13:46 UTC (rev 3015)
@@ -724,7 +724,7 @@
 			}
 			doNotgetFound = options.foundCheckBox.getState();
 		}
-
+		pref.doNotGetFound = doNotgetFound;
 		if (menu == 0) {
 
 			int maxNew = -1;
@@ -1273,7 +1273,7 @@
 
 	private boolean switchToEnglish() {
 		// change language to EN , further operations relay on English
-		String url = "http://www.geocaching.com/default.aspx";
+		String url = "http://www.geocaching.com/account/ManagePreferences.aspx";
 		String page = "";
 		String userID = "userid=" + pref.userID;
 		try {
@@ -1308,7 +1308,13 @@
 		} catch (IOException e) {
 			return false;
 		}
-		Extractor ext = new Extractor(page, "<a href=\"#\">", "&#9660;</a>", 0, true);
+		Extractor ext = new Extractor(page, "ctl00$ContentBody$uxLanguagePreference", "</select>", 0, true);
+		String languageBlock = ext.findNext();
+		ext.set(ext.findNext("ctl00$ContentBody$uxDateTimeFormat"), "selected\" value=\"", "\">", 0, true);
+		DateFormat.GCDateFormat = ext.findNext();
+		// <option selected="selected" value="de-DE">Deutsch</option>
+		ext.set(languageBlock, "<option selected=", "/option>", 0, true);
+		ext.set(ext.findNext(), ">", "<", 0, true);
 		String oldLanguage = ext.findNext();
 		if (oldLanguage.equals("English")) {
 			pref.log("already English");
@@ -1332,6 +1338,7 @@
 		url += "?__EVENTTARGET=" + UrlFetcher.encodeURL(strEnglishPage, false);
 		try {
 			page = UrlFetcher.fetch(url);
+			ext.set(page, "<a href=\"#\">", "&#9660;", 0, true);
 			if (ext.findFirst(page).equals("English")) {
 				pref.log("Switched to English");
 				return true;

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2011-05-21 14:52:52 UTC (rev 3014)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2011-05-21 19:13:46 UTC (rev 3015)
@@ -1100,7 +1100,7 @@
 							addSymbol(ch.getWayPoint(), ch, CacheType.getMapImage(ch), ch.pos);
 						}
 					} else {
-						if (ch.is_Checked || ch == Global.mainTab.ch) {
+						if (ch.is_Checked || ch == cacheDB.get(Global.mainTab.tbP.getSelectedCache())) {
 							if (addSymbolIsNecessary(ch.getWayPoint())) {
 								addSymbol(ch.getWayPoint(), ch, CacheType.getMapImage(ch), ch.pos);
 							}



From araber95 at mail.berlios.de  Sat May 21 09:19:23 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Sat, 21 May 2011 09:19:23 PM +0200
Subject: [Cachewolf-svn] r3016 - trunk/src/CacheWolf
Message-ID: <20110521191923.BE179481401@sheep.berlios.de>

Author: araber95
Date: 2011-05-21 21:19:23 +0200 (Sat, 21 May 2011)
New Revision: 3016

Modified:
   trunk/src/CacheWolf/GuiImageBroker.java
Log:
removed selected.png

Modified: trunk/src/CacheWolf/GuiImageBroker.java
===================================================================
--- trunk/src/CacheWolf/GuiImageBroker.java	2011-05-21 19:13:46 UTC (rev 3015)
+++ trunk/src/CacheWolf/GuiImageBroker.java	2011-05-21 19:19:23 UTC (rev 3016)
@@ -41,7 +41,7 @@
 	public static Image archived = new Image("archived.png");
 	public static Image solved = new Image("solved.png");
 	public static Image bonus = new Image("bonus.png");
-	public static Image owned = new Image("selected.png");
+	public static Image owned = new Image("owned.png");
 	public static Image dnf = new Image("dnf.png");
 
 	private GuiImageBroker() {



From araber95 at mail.berlios.de  Sat May 21 10:34:11 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Sat, 21 May 2011 10:34:11 PM +0200
Subject: [Cachewolf-svn] r3017 - in trunk/src/CacheWolf: . view
Message-ID: <20110521203411.56D3A481401@sheep.berlios.de>

Author: araber95
Date: 2011-05-21 22:34:10 +0200 (Sat, 21 May 2011)
New Revision: 3017

Modified:
   trunk/src/CacheWolf/TravelbugPickup.java
   trunk/src/CacheWolf/view/TravelBugScreenFactory.java
Log:
quick solution for compile to work

Modified: trunk/src/CacheWolf/TravelbugPickup.java
===================================================================
--- trunk/src/CacheWolf/TravelbugPickup.java	2011-05-21 19:19:23 UTC (rev 3016)
+++ trunk/src/CacheWolf/TravelbugPickup.java	2011-05-21 20:34:10 UTC (rev 3017)
@@ -41,7 +41,7 @@
 	public static Travelbug pickupTravelbug(TravelbugList tbl) {
 		Travelbug tb = null;
 		// TravelbugScreen tbs=new TravelbugScreen(tbl,MyLocale.getMsg(6016,"Pick up travelbug"),true);
-		ITravelbugScreen tbs = TravelBugScreenFactory.createTravelbugScreen(tbl, MyLocale.getMsg(6016, "Pick up travelbug"), true);
+		ITravelbugScreen tbs = TravelBugScreenFactory.createTravelbugScreen(tbl, MyLocale.getMsg(6016, "Pick up travelbug"), new Boolean(true));
 		tbs.execute(); // Select TB to pick up
 		if (tbs.getSelectedItem() >= 0) { // Was a TB selected ?
 			// If the returned item is bigger than number of bugs in cache

Modified: trunk/src/CacheWolf/view/TravelBugScreenFactory.java
===================================================================
--- trunk/src/CacheWolf/view/TravelBugScreenFactory.java	2011-05-21 19:19:23 UTC (rev 3016)
+++ trunk/src/CacheWolf/view/TravelBugScreenFactory.java	2011-05-21 20:34:10 UTC (rev 3017)
@@ -34,7 +34,7 @@
 	 */
 	private static final boolean isAndroid = false;
 
-	public static ITravelbugScreen createTravelbugScreen(TravelbugList tbl, String title, boolean allowNew) {
+	public static ITravelbugScreen createTravelbugScreen(TravelbugList tbl, String title, Boolean allowNew) {
 		Global.getPref().log("Mobile-Device: " + Vm.isMobile());
 		Global.getPref().log("Preference for Mobile-Device: " + Global.getPref().mobileGUI);
 		if (Vm.isMobile() && Global.getPref().mobileGUI) {
@@ -49,7 +49,7 @@
 				Global.getPref().log("Error in instantiating TravelBugScreen", e, true);
 				e.printStackTrace();
 				// ignore?? VM on WinPC seems to have no classloader
-				return new PDATravelbugScreen(tbl, title, allowNew);
+				return new PDATravelbugScreen(tbl, title, allowNew.booleanValue());
 			}
 		} else if (isSwing) {
 			throw new InstantiationError("No Swing GUI available");
@@ -58,7 +58,7 @@
 			throw new InstantiationError("No Android GUI available");
 			// return new TravelbugJourneyScreen(model);
 		} else {
-			return new TravelbugScreen(tbl, title, allowNew);
+			return new TravelbugScreen(tbl, title, allowNew.booleanValue());
 		}
 	}
 



From mik77 at mail.berlios.de  Sat May 21 11:09:51 2011
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sat, 21 May 2011 11:09:51 PM +0200
Subject: [Cachewolf-svn] r3018 - trunk/src/CacheWolf
Message-ID: <20110521210951.4E5DD481401@sheep.berlios.de>

Author: mik77
Date: 2011-05-21 23:09:50 +0200 (Sat, 21 May 2011)
New Revision: 3018

Modified:
   trunk/src/CacheWolf/CacheType.java
Log:
mark DNF with date in map

Modified: trunk/src/CacheWolf/CacheType.java
===================================================================
--- trunk/src/CacheWolf/CacheType.java	2011-05-21 20:34:10 UTC (rev 3017)
+++ trunk/src/CacheWolf/CacheType.java	2011-05-21 21:09:50 UTC (rev 3018)
@@ -80,7 +80,7 @@
  * Handles all aspects of converting cache type information
  * from and to the various im- and exporters ...
  * converting legacy profiles to current standard
- * 
+ *
  * Do not instantiate this class, only use it in a static way
  */
 public final class CacheType {
@@ -194,7 +194,7 @@
 
 	/**
 	 * check if a given waypoint type is an additional waypoint
-	 * 
+	 *
 	 * @param type
 	 *            waypoint type to check
 	 * @return true if it is an additional waypoint, false otherwise
@@ -205,7 +205,7 @@
 
 	/**
 	 * check if a given waypoint type is an cache waypoint
-	 * 
+	 *
 	 * @param type
 	 *            waypoint type to check
 	 * @return true if it is an Cache waypoint, false otherwise
@@ -216,7 +216,7 @@
 
 	/**
 	 * check if a given waypoint type is an Custom waypoint
-	 * 
+	 *
 	 * @param type
 	 *            waypoint type to check
 	 * @return true if it is an Custom waypint, false otherwise
@@ -228,7 +228,7 @@
 	// done for DetailsPanel.java and KML- and TomTom-Exporter
 	/**
 	 * create list of cache types to be shown in GUI drop down lists
-	 * 
+	 *
 	 * @return list of cache types to be shown in GUI drop down list
 	 * @see guiSelect2Cw
 	 * @see cw2GuiSelect
@@ -251,7 +251,7 @@
 
 	/**
 	 * translate GUI drop down index selection back to internally stored type
-	 * 
+	 *
 	 * @param selection
 	 *            index value from drop down list
 	 * @return internal type
@@ -272,7 +272,7 @@
 
 	/**
 	 * translate cache type to position of index to highlight in GUI cache type drop down list
-	 * 
+	 *
 	 * @param typeId
 	 *            internal id of cache type
 	 * @return index of the cache type in GUI list
@@ -287,7 +287,7 @@
 
 	/**
 	 * convert the strings found in import of GPX from GC, OC or TC to internal cache type
-	 * 
+	 *
 	 * @param gpxType
 	 *            type information found in GPX
 	 * @return internal cache type
@@ -319,7 +319,7 @@
 
 	/**
 	 * convert the cache type information from an OC XML import to internal cache type
-	 * 
+	 *
 	 * @param ocType
 	 *            cache type found in OC XML
 	 * @return internal cache type
@@ -337,7 +337,7 @@
 
 	/**
 	 * convert type information discovered by GC spider to internal type information
-	 * 
+	 *
 	 * @param gcType
 	 *            type information from GC spider
 	 * @return internal representation of cache type
@@ -355,7 +355,7 @@
 
 	/**
 	 * convert version1 type information to current values
-	 * 
+	 *
 	 * @param type
 	 *            version1 cache type information
 	 * @return current version cache type information or -1
@@ -372,7 +372,7 @@
 
 	/**
 	 * convert version2 type information to current values
-	 * 
+	 *
 	 * @param type
 	 *            version2 cache type information
 	 * @return current version cache type information or -1
@@ -389,7 +389,7 @@
 
 	/**
 	 * translate cache type to a short version for compact exporters or "smart" cache names.
-	 * 
+	 *
 	 * @param typeId
 	 *            CacheWolf internal type information
 	 * @return abbreviation of cache type
@@ -400,7 +400,7 @@
 
 	/**
 	 * map cache types to images
-	 * 
+	 *
 	 * @param typeId
 	 *            internal cache type id
 	 * @return non qualified name of image
@@ -411,7 +411,7 @@
 
 	/**
 	 * generate type description matching those of GC for GPX export
-	 * 
+	 *
 	 * @param typeId
 	 *            internal type id
 	 * @return type information in GC.com <type> GPX format
@@ -422,7 +422,7 @@
 
 	/**
 	 * generate type description matching those of GC for GPX export
-	 * 
+	 *
 	 * @param typeId
 	 *            internal type id
 	 * @return symb information in GC.com <sym> GPX format
@@ -433,7 +433,7 @@
 
 	/**
 	 * generate type description matching those of GC for GPX export
-	 * 
+	 *
 	 * @param typeId
 	 *            internal type id
 	 * @return type information in GC.com <groundspeak:type> GPX format
@@ -444,7 +444,7 @@
 
 	/**
 	 * generate type description matching those of GC for GPX export
-	 * 
+	 *
 	 * @param typeId
 	 *            internal type id
 	 * @return Gui - string for type
@@ -455,7 +455,7 @@
 
 	/**
 	 * select image to be displayed for a given cache type
-	 * 
+	 *
 	 * @param typeId
 	 *            internal cache type id
 	 * @return <code>Image</code> object to be displayed
@@ -466,7 +466,7 @@
 
 	/**
 	 * select image to be displayed for a given cache type
-	 * 
+	 *
 	 * @param typeId
 	 *            internal cache type id
 	 * @return <code>Image</code> object to be displayed
@@ -499,7 +499,7 @@
 				cTypRef[Ref_Index(typeId)]._modImage[solved] = newOverlayedImage(im, GuiImageBroker.solved);
 			}
 			im = cTypRef[Ref_Index(typeId)]._modImage[solved];
-		} else if (ch.getCacheStatus().startsWith(MyLocale.getMsg(319, "Not Found"))) {
+		} else if (ch.getCacheStatus().indexOf(MyLocale.getMsg(319, "Not Found")) > -1) {
 			if (cTypRef[Ref_Index(typeId)]._modImage[dnf] == null) {
 				cTypRef[Ref_Index(typeId)]._modImage[dnf] = newOverlayedImage(im, GuiImageBroker.dnf);
 			}
@@ -515,7 +515,7 @@
 
 	/**
 	 * select image to be displayed for a given cache type
-	 * 
+	 *
 	 * @param typeId
 	 *            internal cache type id
 	 * @param Image
@@ -529,7 +529,7 @@
 
 	/**
 	 * select image to be displayed for a given cache type
-	 * 
+	 *
 	 * @param typeId
 	 *            internal cache type id
 	 * @param Image



From mik77 at mail.berlios.de  Wed May 25 10:58:24 2011
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Wed, 25 May 2011 10:58:24 AM +0200
Subject: [Cachewolf-svn] r3019 - trunk/res_noewe
Message-ID: <20110525085825.25B13480A15@sheep.berlios.de>

Author: mik77
Date: 2011-05-25 10:58:24 +0200 (Wed, 25 May 2011)
New Revision: 3019

Modified:
   trunk/res_noewe/spider.def
Log:
Hint RegEx corrected

Modified: trunk/res_noewe/spider.def
===================================================================
--- trunk/res_noewe/spider.def	2011-05-21 21:09:50 UTC (rev 3018)
+++ trunk/res_noewe/spider.def	2011-05-25 08:58:24 UTC (rev 3019)
@@ -115,7 +115,7 @@
 cacheNameRex       = tBody_CacheName">((?s).*?)</span>
 cacheOwnerRex      = &wid(?:(?s).*?)>((?s).*?)<
 dateHiddenRex      = (?:Hidden|Event\ Date)\\s*:\\s*((?s).*?)<
-hintsRex           = <div id="div_hint" class="HalfLeft">\\s*((?s).*?)\\s*</div>
+hintsRex           = <div\ id="div_hint"\ class="span-8\ WrapFix">\\s*((?s).*?)\\s*</div>
 sizeRex            = alt="Size:\ ((?s).*?)"
 difficultyRex      = difficulty\ of\ (.*?),
 terrainRex         = terrain\ of\ (.*?)\\.\\ 



From araber95 at mail.berlios.de  Sat May 28 06:47:43 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Sat, 28 May 2011 06:47:43 PM +0200
Subject: [Cachewolf-svn] r3020 - in trunk: res_noewe src/CacheWolf
	src/CacheWolf/imp
Message-ID: <20110528164744.5110C4813D2@sheep.berlios.de>

Author: araber95
Date: 2011-05-28 18:47:43 +0200 (Sat, 28 May 2011)
New Revision: 3020

Modified:
   trunk/res_noewe/spider.def
   trunk/src/CacheWolf/Extractor.java
   trunk/src/CacheWolf/Travelbug.java
   trunk/src/CacheWolf/imp/SpiderGC.java
Log:
make TB work again (spider.def) and some optimizing for for getting them.

Modified: trunk/res_noewe/spider.def
===================================================================
--- trunk/res_noewe/spider.def	2011-05-25 08:58:24 UTC (rev 3019)
+++ trunk/res_noewe/spider.def	2011-05-28 16:47:43 UTC (rev 3020)
@@ -153,8 +153,8 @@
 #Section2b: Bugs
 #--------------------------------------
 # blockEx extrahiert zun?chst den Bugbereich aus der gesamten Seite
-blockExStart       = <span\ id="ctl00_ContentBody_uxTravelBugList_uxInventoryLabel">Inventory</span>
-blockExEnd         = <p\ class="NoSpacing">
+blockExStart       = ctl00_ContentBody_uxTravelBugList_uxInventoryLabel
+blockExEnd         = ctl00_ContentBody_uxTravelBugList_uxTrackableItemsLinks
 # bugEx extrahiert die Namen der einzelnen Bugs aus dem Bugbereich
 bugExStart         = <a\ href="
 bugExEnd           = </a>

Modified: trunk/src/CacheWolf/Extractor.java
===================================================================
--- trunk/src/CacheWolf/Extractor.java	2011-05-25 08:58:24 UTC (rev 3019)
+++ trunk/src/CacheWolf/Extractor.java	2011-05-28 16:47:43 UTC (rev 3020)
@@ -74,6 +74,11 @@
 		_startOffset = 0;
 	}
 
+	public void set(String searchText, int startOffset) {
+		_searchText = searchText;
+		_startOffset = startOffset;
+	}
+
 	public String findFirst(String searchText) {
 		_searchText = searchText;
 		_startOffset = 0;

Modified: trunk/src/CacheWolf/Travelbug.java
===================================================================
--- trunk/src/CacheWolf/Travelbug.java	2011-05-25 08:58:24 UTC (rev 3019)
+++ trunk/src/CacheWolf/Travelbug.java	2011-05-28 16:47:43 UTC (rev 3020)
@@ -1,59 +1,63 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 /**
  * This contains the basic information of a GC travelbug.
+ * 
  * @author salzkammergut
- *
+ * 
  */
 public class Travelbug {
-	/** GC unique id or guid (both are used depending on how the TB is picked up).
+	/**
+	 * GC unique id or guid (both are used depending on how the TB is picked up).
 	 * Travelbugs retrieved from a cache use the guid, travelbugs entered manually
-	 * use the id */
-	private String guid;       //0
+	 * use the id
+	 */
+	private String guid; // 0
 	/** GC Name i.e. "First Roman Geocoin" */
-	private String name;       //1
+	private String name; // 1
 	/** GC tracking no i.e. 652345, needed for logging */
-	private String trackingNo; //2 
+	private String trackingNo; // 2
 	/** GC Mission */
-	private String mission;    //3
+	private String mission; // 3
 
 	/** Construct a travelbug with a given name */
 	public Travelbug(String name) {
-		this("",name,"");
+		this("", name, "");
 	}
 
 	/** Construct a travelbug with id, name and mission */
 	public Travelbug(String guid, String name, String mission) {
-		setGuid(guid);
-		setName(name);
-		setMission(mission);
+		this.guid = guid;
+		this.name = SafeXML.cleanback(name);
+		this.mission = mission;
 		setTrackingNo("");
 	}
-	
+
 	public String getGuid() {
 		return guid;
 	}
@@ -85,10 +89,10 @@
 	public String getMission() {
 		return this.mission;
 	}
-	
+
 	/** Return XML representation of travelbug for storing in cache.xml */
-	public String toXML(){
-		StringBuffer s=new StringBuffer(300);
+	public String toXML() {
+		StringBuffer s = new StringBuffer(300);
 		s.append("  <tb guid=\"");
 		s.append(guid);
 		s.append("\"><name><![CDATA[");
@@ -98,10 +102,10 @@
 		s.append("]]></tb>\n");
 		return s.toString();
 	}
-	
+
 	/** Return HTML representation of travelbug for display on screen */
-	public String toHtml(){
-		StringBuffer s=new StringBuffer(300);
+	public String toHtml() {
+		StringBuffer s = new StringBuffer(300);
 		s.append("<b>Name:</b> ");
 		s.append(name);
 		s.append("<br>");

Modified: trunk/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-25 08:58:24 UTC (rev 3019)
+++ trunk/src/CacheWolf/imp/SpiderGC.java	2011-05-28 16:47:43 UTC (rev 3020)
@@ -862,14 +862,14 @@
 				if (RexPropListBlock.didMatch()) {
 					tableOfHtmlListPage = RexPropListBlock.stringMatched(1);
 				} else {
-					pref.log("check listBlockRex in spider.def" + Preferences.NEWLINE + htmlListPage);
+					pref.log("[SpiderGC.java:fillDownloadLists]check listBlockRex!");
 					tableOfHtmlListPage = "";
 				}
 				RexPropLine.search(tableOfHtmlListPage);
 				while (toDistance > 0) {
 					if (!RexPropLine.didMatch()) {
 						if (page_number == 1 && found_on_page == 0)
-							pref.log("check lineRex in spider.def");
+							pref.log("[SpiderGC.java:fillDownloadLists]check lineRex!");
 						break;
 					}
 					found_on_page++;
@@ -1347,7 +1347,7 @@
 				return false;
 			}
 		} catch (final Exception ex) {
-			pref.log("Error switching to English: check " + url, ex);
+			pref.log("[SpiderGC.java:switchToEnglish]Error switching to English: check " + url, ex);
 			return false;
 		}
 
@@ -1445,7 +1445,7 @@
 			viewstate = rexViewstate.stringMatched(1);
 		} else {
 			viewstate = "";
-			pref.log("[getAListPage] check rexViewstate in SpiderGC.java" + Preferences.NEWLINE + htmlListPage);
+			pref.log("[SpiderGC.java:getAListPage] check rexViewstate!", null);
 		}
 
 		final Regex rexViewstate1 = new Regex("id=\"__VIEWSTATE1\" value=\"(.*?)\" />");
@@ -1455,7 +1455,7 @@
 			viewstate1 = rexViewstate1.stringMatched(1);
 		} else {
 			viewstate1 = "";
-			pref.log("[getAListPage] check rexViewstate1 in SpiderGC.java" + Preferences.NEWLINE + htmlListPage);
+			pref.log("[SpiderGC.java:getAListPage] check rexViewstate1!", null);
 		}
 
 		final String postData = "__EVENTTARGET=" + URL.encodeURL(whatPage, false) + "&" + "__EVENTARGUMENT=" + "&" + "__VIEWSTATEFIELDCOUNT=2" + "&" + "__VIEWSTATE=" + URL.encodeURL(viewstate, false) + "&" + "__VIEWSTATE1="
@@ -1728,11 +1728,11 @@
 			if (owner.equals(pref.myAlias) || owner.equals(pref.myAlias2)) {
 				ch.setOwned(true);
 			}
-			//DEAD CODE commented out
-//			else if (false) {
-//				ch.setFound(true);
-//				ch.setCacheStatus(ch.getFoundText());
-//			}
+			// DEAD CODE commented out
+			// else if (false) {
+			// ch.setFound(true);
+			// ch.setCacheStatus(ch.getFoundText());
+			// }
 
 			cacheName = STRreplace.replace(cacheName, "\\\"", "\"");
 			ch.setCacheName(cacheName);
@@ -1826,7 +1826,7 @@
 					pref.log("sizeChanged");
 				}
 			} else {
-				pref.log("check DTS calculation", null);
+				pref.log("[SpiderGC.java:updateExists]check DTS calculation!", null);
 			}
 		}
 		if (newFoundExists(ch, CacheDescription)) {
@@ -1853,7 +1853,7 @@
 		if (RexNumFinds.didMatch()) {
 			return Common.parseInt(RexNumFinds.stringMatched(1));
 		} else {
-			pref.log("check RexNumFinds in SpiderGC.java / initialiseProperties" + Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getNumFound]check RexNumFinds!", null);
 			return 0;
 		}
 	}
@@ -1888,7 +1888,7 @@
 			return distanceAndDirection;
 		RexPropDistanceCode.search(doc);
 		if (!RexPropDistanceCode.didMatch()) {
-			pref.log("check distRex" + Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getDistanceAndDirection]check distRex!", null);
 			distanceAndDirection[0] = -1.0; // Abbruch
 			return distanceAndDirection;
 		}
@@ -1957,7 +1957,7 @@
 				distanceAndDirection[0] = distanceAndDirection[0] / 5280.0;
 			}
 		} else {
-			pref.log("(gc Code change ?) check distCodeKey in spider.def" + Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getDistanceAndDirection](gc Code change ?) check distCodeKey!", null);
 		}
 
 		return distanceAndDirection;
@@ -1973,7 +1973,7 @@
 	private String getWP(String doc) throws Exception {
 		RexPropWaypoint.search(doc);
 		if (!RexPropWaypoint.didMatch()) {
-			pref.log("check waypointRex in spider.def" + Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getWP]check waypointRex!", null);
 			return "???";
 		}
 		return "GC" + RexPropWaypoint.stringMatched(1);
@@ -2014,7 +2014,7 @@
 				return true;
 			}
 		}
-		pref.log("check TypeRex in spider.def" + Preferences.NEWLINE + toCheck);
+		pref.log("[SpiderGC.java:typeChanged]check TypeRex!", null);
 		return false;
 	}
 
@@ -2047,7 +2047,7 @@
 			 * 4)) / 2.0); if (difficulty.equals("0.5")) { difficulty = "5"; } return difficulty+"/"+terrain+"/"+size;
 			 */
 		}
-		pref.log("check DTSRex in spider.def" + Preferences.NEWLINE + toCheck);
+		pref.log("[SpiderGC.java:getDTS]check DTSRex!", null);
 		return "";
 	}
 
@@ -2206,7 +2206,7 @@
 		if (RexPropLogDate.didMatch()) {
 			stmp = RexPropLogDate.stringMatched(1);
 		} else {
-			pref.log("check logDateRex in spider.def" + Preferences.NEWLINE + cacheDescription);
+			pref.log("[SpiderGC.java:newFoundExists]check logDateRex!", null);
 			return false;
 		}
 		final Time lastLogGC = DateFormat.toDate(stmp);
@@ -2440,7 +2440,7 @@
 		final Regex inRex = new Regex(p.getProp("latLonRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log("check latLonRex in spider.def" + Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getLatLon]check latLonRex!", null);
 			return "???";
 		}
 		return inRex.stringMatched(1);
@@ -2462,7 +2462,7 @@
 		shortDescRex.search(doc);
 		if (!shortDescRex.didMatch()) {
 			if (shortDescRex_not_yet_found)
-				pref.log("no shortDesc or check shortDescRex in spider.def");
+				pref.log("[SpiderGC.java:getLongDesc]no shortDesc or check shortDescRex!", null);
 			// + Preferences.NEWLINE + doc);
 		} else {
 			res = shortDescRex.stringMatched(1);
@@ -2471,7 +2471,7 @@
 		res += "<br>";
 		longDescRex.search(doc);
 		if (!longDescRex.didMatch()) {
-			pref.log("check longDescRex in spider.def" + Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getLongDesc]check longDescRex!", null);
 		} else {
 			res += longDescRex.stringMatched(1);
 		}
@@ -2495,7 +2495,7 @@
 		final Regex inRex = new Regex(p.getProp("cacheLocationRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log("check cacheLocationRex in spider.def" + Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getLocation]check cacheLocationRex!", null);
 			return "";
 		}
 		return inRex.stringMatched(1);
@@ -2512,7 +2512,7 @@
 		final Regex inRex = new Regex(p.getProp("cacheNameRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log("check cacheNameRex in spider.def" + Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getName]check cacheNameRex!", null);
 			return "???";
 		}
 		return inRex.stringMatched(1);
@@ -2529,7 +2529,7 @@
 		final Regex inRex = new Regex(p.getProp("cacheOwnerRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log("check cacheOwnerRex in spider.def" + Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getOwner]check cacheOwnerRex!", null);
 			return "???";
 		}
 		return inRex.stringMatched(1);
@@ -2546,7 +2546,7 @@
 		final Regex inRex = new Regex(p.getProp("dateHiddenRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log("check dateHiddenRex in spider.def" + Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getDateHidden]check dateHiddenRex!", null);
 			return "???";
 		}
 		return inRex.stringMatched(1);
@@ -2563,7 +2563,7 @@
 		final Regex inRex = new Regex(p.getProp("hintsRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log("check hintsRex in spider.def" + Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getHints]check hintsRex!", null);
 			return "";
 		}
 		return inRex.stringMatched(1);
@@ -2582,7 +2582,7 @@
 		if (inRex.didMatch())
 			return inRex.stringMatched(1);
 		else {
-			pref.log("check sizeRex in spider.def" + Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getSize]check sizeRex!", null);
 			return "None";
 		}
 	}
@@ -2600,7 +2600,7 @@
 		if (inRex.didMatch())
 			return inRex.stringMatched(1);
 		else {
-			pref.log("check difficultyRex in spider.def" + Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getDiff]check difficultyRex!", null);
 			return "-1";
 		}
 	}
@@ -2618,7 +2618,7 @@
 		if (inRex.didMatch())
 			return inRex.stringMatched(1);
 		else {
-			pref.log("check terrainRex in spider.def" + Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getTerr]check terrainRex!", null);
 			return "-1";
 		}
 	}
@@ -2635,7 +2635,7 @@
 		if (RexCacheType.didMatch())
 			return CacheType.gcSpider2CwType(RexCacheType.stringMatched(1));
 		else {
-			pref.log("check cacheTypeRex in spider.def" + Preferences.NEWLINE + doc);
+			pref.log("[SpiderGC.java:getType]check cacheTypeRex!", null);
 			return 0;
 		}
 	}
@@ -2658,7 +2658,7 @@
 		final LogList reslts = chD.CacheLogs;
 		RexLogBlock.search(completeWebPage);
 		if (!RexLogBlock.didMatch()) {
-			pref.log("check blockRex in spider.def" + Preferences.NEWLINE + completeWebPage);
+			pref.log("[SpiderGC.java:getLogs]check blockRex!", null);
 		}
 		final String LogBlock = RexLogBlock.stringMatched(1);
 
@@ -2732,39 +2732,47 @@
 	 * @return A HTML formatted string with bug names and there purpose
 	 */
 	public void getBugs(CacheHolderDetail chD, String doc) throws Exception {
+		chD.Travelbugs.clear();
+		if (doc.indexOf("ctl00_ContentBody_uxTravelBugList_uxNoTrackableItemsLabel") >= 0) {
+			return; // there are no trackables
+		}
 		final Extractor exBlock = new Extractor(doc, p.getProp("blockExStart"), p.getProp("blockExEnd"), 0, Extractor.EXCLUDESTARTEND);
+		final Extractor exBug = new Extractor("", p.getProp("bugExStart"), p.getProp("bugExEnd"), 0, Extractor.EXCLUDESTARTEND);
+		final Extractor exBugName = new Extractor("", "", "", 0, Extractor.EXCLUDESTARTEND);
 		final String bugBlock;
 		if ((bugBlock = exBlock.findNext()).length() > 0) {
 			String link, bug, linkPlusBug, bugDetails;
 			final String oldInfoBox = infB.getInfo();
-			chD.Travelbugs.clear();
-			final Extractor exBug = new Extractor(bugBlock, p.getProp("bugExStart"), p.getProp("bugExEnd"), 0, Extractor.EXCLUDESTARTEND);
+			boolean exBugWrong = true;
+			exBug.set(bugBlock);
 			while ((linkPlusBug = exBug.findNext()).length() > 0) {
+				exBugWrong = false;
 				if (infB.isClosed)
 					break;
 				final int idx = linkPlusBug.indexOf(p.getProp("bugLinkEnd"));
-				if (idx < 0)
+				if (idx < 0) {
+					pref.log("[SpiderGC.java:getBugs]check TBs bugLinkEnd!", null);
 					break; // No link/bug pair found
+				}
 				link = linkPlusBug.substring(0, idx);
-				final Extractor exBugName = new Extractor(linkPlusBug, p.getProp("bugNameExStart"), p.getProp("bugNameExEnd"), 0, Extractor.EXCLUDESTARTEND);
+				exBugName.set(linkPlusBug, p.getProp("bugNameExStart"), p.getProp("bugNameExEnd"), idx, Extractor.EXCLUDESTARTEND);
 				if ((bug = exBugName.findNext()).length() > 0) {
-					// Found a bug, get its details
-					final Travelbug tb = new Travelbug(bug);
+					// Found a bug, get its mission
 					try {
 						infB.setInfo(oldInfoBox + MyLocale.getMsg(5514, "\nGetting bug: ") + SafeXML.cleanback(bug));
 						bugDetails = UrlFetcher.fetch(link);
-						pref.log("[getBugs] Fetched TB details: " + bug);
-						final Extractor exDetails = new Extractor(bugDetails, p.getProp("bugDetailsStart"), p.getProp("bugDetailsEnd"), 0, Extractor.EXCLUDESTARTEND);
-						tb.setMission(exDetails.findNext());
-						final Extractor exGuid = new Extractor(bugDetails, "action=\"details.aspx?guid=", "\" id=\"aspnetForm", 0, Extractor.EXCLUDESTARTEND);
-						tb.setGuid(exGuid.findNext());
-						chD.Travelbugs.add(tb);
+						exBugName.set(bugDetails, p.getProp("bugDetailsStart"), p.getProp("bugDetailsEnd"), 0, Extractor.EXCLUDESTARTEND); // reusing exBugName
+						chD.Travelbugs.add(new Travelbug(link.substring(1 + link.indexOf("=")), bug, exBugName.findNext()));
 					} catch (final Exception ex) {
-						pref.log("[getBugs] Could not fetch bug details", ex);
+						pref.log("[SpiderGC.java:getBugs] Could not fetch buginfo from " + link, ex);
 					}
 				}
 			}
 			infB.setInfo(oldInfoBox);
+			if (exBugWrong)
+				pref.log("[SpiderGC.java:getBugs]check TBs bugExStart / bugExEnd!", null);
+		} else {
+			pref.log("[SpiderGC.java:getBugs]check TBs blockExStart / blockExEnd!", null);
 		}
 	}
 



From araber95 at mail.berlios.de  Mon May 30 10:47:18 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Mon, 30 May 2011 10:47:18 AM +0200
Subject: [Cachewolf-svn] r3021 - trunk/src/CacheWolf
Message-ID: <20110530084718.73DCB480C3B@sheep.berlios.de>

Author: araber95
Date: 2011-05-30 10:47:18 +0200 (Mon, 30 May 2011)
New Revision: 3021

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/DBStats.java
   trunk/src/CacheWolf/MainMenu.java
Log:
count of finds / recognition of main cache waypoint corrected.

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2011-05-28 16:47:43 UTC (rev 3020)
+++ trunk/src/CacheWolf/CacheHolder.java	2011-05-30 08:47:18 UTC (rev 3021)
@@ -982,7 +982,10 @@
 	}
 
 	public boolean isOC() {
-		return OC.isOC(wayPoint);
+		if (this.isCacheWpt()) {
+			return OC.isOC(wayPoint);
+		} else
+			return false;
 	}
 
 	public void calcDistance(CWPoint toPoint) {
@@ -1238,7 +1241,7 @@
 
 	public String GetCacheID() {
 		String result = "";
-		String pattern = getWayPoint().toUpperCase();
+		String pattern = wayPoint.toUpperCase();
 
 		if (pattern.startsWith("GC")) {
 			int gcId = 0;

Modified: trunk/src/CacheWolf/DBStats.java
===================================================================
--- trunk/src/CacheWolf/DBStats.java	2011-05-28 16:47:43 UTC (rev 3020)
+++ trunk/src/CacheWolf/DBStats.java	2011-05-30 08:47:18 UTC (rev 3021)
@@ -1,38 +1,38 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 /**
  * @author Marc
- * Use this class to obtain statistics or information on a cache database.
+ *         Use this class to obtain statistics or information on a cache database.
  */
 public class DBStats {
 	CacheDB cacheDB = null;
 
-	public DBStats(CacheDB db){
+	public DBStats(CacheDB db) {
 		cacheDB = db;
 	}
 
@@ -41,81 +41,78 @@
 	 * It will count waypoints only that start with
 	 * GC,or
 	 * OC
+	 * 
 	 * @return
 	 */
-	public String visible(boolean big){
+	public String visible(boolean big) {
 		CacheHolder holder;
 		int counter = 0;
 		int whiteCaches = 0;
 		int whiteWaypoints = 0;
-		for(int i = 0; i<cacheDB.size();i++){
+		for (int i = 0; i < cacheDB.size(); i++) {
 			holder = cacheDB.get(i);
-			if(holder.isVisible()){
+			if (holder.isVisible()) {
 				counter++;
 				if (CacheType.isAddiWpt(holder.getType())) {
 					whiteWaypoints++;
-				}
-				else {
+				} else {
 					whiteCaches++;
 				}
 			}
 		}
 		if (big)
-			return counter+"("+whiteCaches+"/"+whiteWaypoints+")";
+			return counter + "(" + whiteCaches + "/" + whiteWaypoints + ")";
 		else
-			return ""+whiteCaches;
+			return "" + whiteCaches;
 
 	}
 
 	/**
 	 * Method to get the number of caches available for display
+	 * 
 	 * @return
 	 */
-	public String total(boolean big){
+	public String total(boolean big) {
 		CacheHolder holder;
 		int all = cacheDB.size();
 		int whiteCaches = 0;
 		int whiteWaypoints = 0;
 		int blackCaches = 0;
 		int blackWaypoints = 0;
-		for(int i = 0; i<all;i++){
+		for (int i = 0; i < all; i++) {
 			holder = cacheDB.get(i);
-			if(holder.is_black()){
-			  if (CacheType.isAddiWpt(holder.getType())) {
-				  blackWaypoints++;
-			  }
-			  else {
-				  blackCaches++;
-			  }
-			}
-			else {
+			if (holder.is_black()) {
 				if (CacheType.isAddiWpt(holder.getType())) {
-					whiteWaypoints++;
+					blackWaypoints++;
+				} else {
+					blackCaches++;
 				}
-				else {
+			} else {
+				if (CacheType.isAddiWpt(holder.getType())) {
+					whiteWaypoints++;
+				} else {
 					whiteCaches++;
 				}
 			}
 		}
-		if (big){
-			if ( blackCaches > 0 || blackWaypoints > 0) {
-				return all+"("+whiteCaches+"/"+whiteWaypoints+"+"+blackCaches+"/"+blackWaypoints+")";
+		if (big) {
+			if (blackCaches > 0 || blackWaypoints > 0) {
+				return all + "(" + whiteCaches + "/" + whiteWaypoints + "+" + blackCaches + "/" + blackWaypoints + ")";
+			} else {
+				return all + "(" + whiteCaches + "/" + whiteWaypoints + ")";
 			}
-			else {
-				return all+"("+whiteCaches+"/"+whiteWaypoints+")";
-			}
-		}
-		else
-			return ""+whiteCaches;
+		} else
+			return "" + whiteCaches;
 	}
 
-	public int totalFound(){
+	public int totalFound() {
 		CacheHolder holder;
 		int counter = 0;
-		for(int i = 0; i<cacheDB.size();i++){
+		for (int i = 0; i < cacheDB.size(); i++) {
 			holder = cacheDB.get(i);
-			if(holder.is_found() == true) {
-				if(holder.getWayPoint().startsWith("GC") || holder.isOC()) counter++;
+			if (holder.is_found() == true) {
+				if (holder.isCacheWpt())
+					counter++;
 			}
 		}
 		return counter;

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2011-05-28 16:47:43 UTC (rev 3020)
+++ trunk/src/CacheWolf/MainMenu.java	2011-05-30 08:47:18 UTC (rev 3021)
@@ -864,8 +864,7 @@
 		for (int i = 0; i < cacheDB.size(); i++) {
 			ch = cacheDB.get(i);
 			if (ch.is_Checked == true && ch.isVisible()) {
-				String wpStart = ch.getWayPoint().substring(0, 2);
-				if (ch.getWayPoint().length() > 1 && (wpStart.equalsIgnoreCase("GC") || ch.isOC()))
+				if (ch.getWayPoint().length() > 1 && ch.isCacheWpt())
 				// Notiz: Wenn es ein addi Wpt ist, sollte eigentlich der Maincache gespidert werden
 				// Alter code prft aber nur ob ein Maincache von GC existiert und versucht dann den addi direkt zu spidern, was nicht funktioniert
 				{



From araber95 at mail.berlios.de  Tue May 31 12:23:53 2011
From: araber95 at mail.berlios.de (araber95 at mail.berlios.de)
Date: Tue, 31 May 2011 12:23:53 PM +0200
Subject: [Cachewolf-svn] r3022 - trunk/src/CacheWolf
Message-ID: <20110531102354.103984805EB@sheep.berlios.de>

Author: araber95
Date: 2011-05-31 12:23:53 +0200 (Tue, 31 May 2011)
New Revision: 3022

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/MyComparer.java
   trunk/src/CacheWolf/OC.java
   trunk/src/CacheWolf/myTableControl.java
   trunk/src/CacheWolf/myTableModel.java
Log:
1. correct check for  main waypoint to update (that have type set to custom with meaning type not yet set, loc-import or just created)
2. correct getting GC waypoint from OC waypoint (if there is more than one reference)

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2011-05-30 08:47:18 UTC (rev 3021)
+++ trunk/src/CacheWolf/CacheHolder.java	2011-05-31 10:23:53 UTC (rev 3022)
@@ -982,10 +982,7 @@
 	}
 
 	public boolean isOC() {
-		if (this.isCacheWpt()) {
-			return OC.isOC(wayPoint);
-		} else
-			return false;
+		return OC.isOC(wayPoint);
 	}
 
 	public void calcDistance(CWPoint toPoint) {

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2011-05-30 08:47:18 UTC (rev 3021)
+++ trunk/src/CacheWolf/MainMenu.java	2011-05-31 10:23:53 UTC (rev 3022)
@@ -864,7 +864,8 @@
 		for (int i = 0; i < cacheDB.size(); i++) {
 			ch = cacheDB.get(i);
 			if (ch.is_Checked == true && ch.isVisible()) {
-				if (ch.getWayPoint().length() > 1 && ch.isCacheWpt())
+				// should work even if only the wayPoint is created
+				if ((ch.getWayPoint().toUpperCase().startsWith("GC") || ch.isOC()))
 				// Notiz: Wenn es ein addi Wpt ist, sollte eigentlich der Maincache gespidert werden
 				// Alter code prft aber nur ob ein Maincache von GC existiert und versucht dann den addi direkt zu spidern, was nicht funktioniert
 				{

Modified: trunk/src/CacheWolf/MyComparer.java
===================================================================
--- trunk/src/CacheWolf/MyComparer.java	2011-05-30 08:47:18 UTC (rev 3021)
+++ trunk/src/CacheWolf/MyComparer.java	2011-05-31 10:23:53 UTC (rev 3022)
@@ -27,7 +27,6 @@
 
 import ewe.util.Comparer;
 import ewe.util.Vector;
-import ewe.util.mString;
 
 /**
  * This class handles the sorting for most of the sorting tasks. If a cache is to be displayed in the table or not is handled in the table model
@@ -141,15 +140,8 @@
 					else
 						ch.sort = ch.getOcCacheID();
 				else {
-					String[] stmp = mString.split(ch.getCacheOwner(), '/');
-					int l = stmp.length - 1;
-					if (l > 0) {
-						String s = stmp[l].trim();
-						if (s.startsWith("GC"))
-							ch.sort = s;
-						else
-							ch.sort = "\uFFFF";
-					} else
+					ch.sort = OC.getGCWayPoint(ch.getCacheOwner());
+					if (ch.sort.length() == 0)
 						ch.sort = "\uFFFF"; // ans Ende
 				}
 			}

Modified: trunk/src/CacheWolf/OC.java
===================================================================
--- trunk/src/CacheWolf/OC.java	2011-05-30 08:47:18 UTC (rev 3021)
+++ trunk/src/CacheWolf/OC.java	2011-05-31 10:23:53 UTC (rev 3022)
@@ -1,30 +1,31 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See http://developer.berlios.de/projects/cachewolf/
-    for more information.
-    Contact: 	bilbowolf at users.berlios.de
-    			kalli at users.berlios.de
+Copyright (C) 2006  CacheWolf development team
+See http://developer.berlios.de/projects/cachewolf/
+for more information.
+Contact: 	bilbowolf at users.berlios.de
+			kalli at users.berlios.de
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
+
 public final class OC {
 
 	/** thou shallst not instantiate this object */
@@ -32,45 +33,51 @@
 		// Nothing to do
 	}
 
-	public final static int OC_HOSTNAME = 0; 
-	public final static int OC_PREFIX = 1; 
-	public final static String[][] OCSites = {
-		{"www.opencaching.de", "OC"},
-		{"www.opencaching.pl", "OP"},
-		{"www.opencaching.cz", "OZ"},
-		{"www.opencaching.org.uk", "OK"},
-		{"www.opencaching.se", "OS"},
-		{"www.opencaching.no", "ON"},
-		{"www.opencaching.us", "OU"}
-		};
+	public final static int OC_HOSTNAME = 0;
+	public final static int OC_PREFIX = 1;
+	public final static String[][] OCSites = { { "www.opencaching.de", "OC" }, { "www.opencaching.pl", "OP" }, { "www.opencaching.cz", "OZ" }, { "www.opencaching.org.uk", "OK" }, { "www.opencaching.se", "OS" }, { "www.opencaching.no", "ON" },
+			{ "www.opencaching.us", "OU" } };
 
 	public final static String[] OCHostNames() {
-		String[] ret=new String[OCSites.length];
+		String[] ret = new String[OCSites.length];
 		for (int i = 0; i < OCSites.length; i++) {
-			ret[i]=OCSites[i][OC_HOSTNAME];
+			ret[i] = OCSites[i][OC_HOSTNAME];
 		}
 		return ret;
 	}
-	
-	public final static String getOCHostName(String wpName){
+
+	public final static String getOCHostName(String wpName) {
 		for (int i = 0; i < OCSites.length; i++) {
-			if(wpName.startsWith(OCSites[i][OC_PREFIX])) {
+			if (wpName.startsWith(OCSites[i][OC_PREFIX])) {
 				return OCSites[i][OC_HOSTNAME];
 			}
 		}
 		return null;
 	}
-	
+
 	public final static boolean isOC(String wpName) {
-		return (getOCHostName(wpName.toUpperCase()) != null);		
+		return (getOCHostName(wpName.toUpperCase()) != null);
 	}
-	
+
 	public final static int getSiteIndex(String site) {
 		for (int i = 0; i < OCSites.length; i++) {
-			if(site.equalsIgnoreCase(OCSites[i][OC_HOSTNAME])) {
+			if (site.equalsIgnoreCase(OCSites[i][OC_HOSTNAME])) {
 				return i;
 			}
 		}
 		return 0; // don't get a fault
 	}
+
+	public final static String getGCWayPoint(String owner) {
+		owner = owner + " ";
+		int l = owner.lastIndexOf('/');
+		if (l > 0) {
+			int i = owner.indexOf("GC", l);
+			if (i > -1) {
+				int j = owner.indexOf(" ", i);
+				return owner.substring(i, j);
+			}
+		}
+		return "";
+	}
 }

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2011-05-30 08:47:18 UTC (rev 3021)
+++ trunk/src/CacheWolf/myTableControl.java	2011-05-31 10:23:53 UTC (rev 3022)
@@ -51,7 +51,6 @@
 import ewe.ui.TableControl;
 import ewe.ui.TableEvent;
 import ewe.ui.mList;
-import ewe.util.mString;
 
 /**
  * Implements the user interaction of the list view. Works together with myTableModel and TablePanel
@@ -356,14 +355,9 @@
 			String wpName = mainCache.getOcCacheID();
 			if (clickedColumn == 14) {
 				if (mainCache.isOC()) {
-					String[] stmp = mString.split(ch.getCacheOwner(), '/');
-					int l = stmp.length - 1;
-					if (l > 0) {
-						String s = stmp[l].trim();
-						if (s.startsWith("GC")) {
-							url = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + s;
-						}
-					}
+					String s = OC.getGCWayPoint(ch.getCacheOwner());
+					if (s.length() > 0)
+						url = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + s;
 				} else {
 					if (wpName.length() > 0) {
 						if (wpName.charAt(0) < 65)

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2011-05-30 08:47:18 UTC (rev 3021)
+++ trunk/src/CacheWolf/myTableModel.java	2011-05-31 10:23:53 UTC (rev 3022)
@@ -38,7 +38,6 @@
 import ewe.ui.TableCellAttributes;
 import ewe.ui.TableModel;
 import ewe.util.Vector;
-import ewe.util.mString;
 
 /**
  * Table model used to display the cache list. Used by the table control in the first panel of CacheWolf. 20061212 salzkammergut, patch to speed up scrolling, Used MyLocale
@@ -441,16 +440,7 @@
 					if (ch.getWayPoint().startsWith("GC"))
 						return ch.getOcCacheID();
 					else {
-						String[] stmp = mString.split(ch.getCacheOwner(), '/');
-						int l = stmp.length - 1;
-						if (l > 0) {
-							String s = stmp[l].trim();
-							if (s.startsWith("GC"))
-								return s;
-							else
-								return "";
-						} else
-							return "";
+						return OC.getGCWayPoint(ch.getCacheOwner());
 					}
 				case 15: // Is solver filled?
 					if (ch.hasSolver())



